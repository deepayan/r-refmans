<!DOCTYPE html><html lang="en"><head><title>Help for package svars</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {svars}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ba.boot'><p>Bootstrap after Bootstrap</p></a></li>
<li><a href='#cf'><p>Counterfactuals for SVAR Models</p></a></li>
<li><a href='#chow.test'><p>Chow Test for Structural Break</p></a></li>
<li><a href='#fevd'><p>Forecast error variance decomposition for SVAR Models</p></a></li>
<li><a href='#hd'><p>Historical decomposition for SVAR Models</p></a></li>
<li><a href='#id.chol'><p>Recursive identification of SVAR models via Cholesky decomposition</p></a></li>
<li><a href='#id.cv'><p>Identification of SVAR models based on Changes in volatility (CV)</p></a></li>
<li><a href='#id.cvm'><p>Independence-based identification of SVAR models via Cramer-von Mises (CVM) distance</p></a></li>
<li><a href='#id.dc'><p>Independence-based identification of SVAR models build on distance covariances (DC) statistic</p></a></li>
<li><a href='#id.garch'><p>Identification of SVAR models through patterns of GARCH</p></a></li>
<li><a href='#id.ngml'><p>Non-Gaussian maximum likelihood (NGML) identification of SVAR models</p></a></li>
<li><a href='#id.st'><p>Identification of SVAR models by means of a smooth transition (ST) in covariance</p></a></li>
<li><a href='#irf'><p>Impulse Response Functions for SVAR Models</p></a></li>
<li><a href='#js.test'><p>Chi-square test for joint hypotheses</p></a></li>
<li><a href='#LN'><p>Interaction between monetary policy and the stock market</p></a></li>
<li><a href='#mb.boot'><p>Moving block bootstrap for IRFs of identified SVARs</p></a></li>
<li><a href='#stability'><p>Structural stability of a VAR(p)</p></a></li>
<li><a href='#svars'><p>svars: Data-driven identification of structural VAR models</p></a></li>
<li><a href='#USA'><p>US macroeconomic time series</p></a></li>
<li><a href='#wild.boot'><p>Wild bootstrap for IRFs of identified SVARs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data-Driven Identification of SVAR Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Lange [aut, cre],
  Bernhard Dalheimer [aut],
  Helmut Herwartz [aut],
  Simone Maxand [aut],
  Hannes Riebl [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Lange &lt;alexander.lange@uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements data-driven identification methods for structural vector autoregressive (SVAR) models as described in Lange et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v097.i05">doi:10.18637/jss.v097.i05</a>&gt;. 
             Based on an existing VAR model object (provided by e.g. VAR() from the 'vars' package), the structural 
             impact matrix is obtained via data-driven identification techniques (i.e. changes in volatility (Rigobon, R. (2003) &lt;<a href="https://doi.org/10.1162%2F003465303772815727">doi:10.1162/003465303772815727</a>&gt;),  patterns of GARCH (Normadin, M., Phaneuf, L. (2004) &lt;<a href="https://doi.org/10.1016%2Fj.jmoneco.2003.11.002">doi:10.1016/j.jmoneco.2003.11.002</a>&gt;),
             independent component analysis (Matteson, D. S, Tsay, R. S., (2013) &lt;<a href="https://doi.org/10.1080%2F01621459.2016.1150851">doi:10.1080/01621459.2016.1150851</a>&gt;), least dependent innovations (Herwartz, H., Ploedt, M., (2016) &lt;<a href="https://doi.org/10.1016%2Fj.jimonfin.2015.11.001">doi:10.1016/j.jimonfin.2015.11.001</a>&gt;), 
             smooth transition in variances (Luetkepohl, H., Netsunajev, A. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.jedc.2017.09.001">doi:10.1016/j.jedc.2017.09.001</a>&gt;) or non-Gaussian maximum likelihood (Lanne, M., Meitz, M., Saikkonen, P. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2016.06.002">doi:10.1016/j.jeconom.2016.06.002</a>&gt;)).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), vars (&ge; 1.5.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>expm, reshape2, ggplot2, copula, clue, pbapply, steadyICA,
DEoptim, zoo, strucchange, Rcpp, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), tsDyn</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-30 19:51:32 UTC; alex</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-06 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ba.boot'>Bootstrap after Bootstrap</h2><span id='topic+ba.boot'></span>

<h3>Description</h3>

<p>Bootstrap intervals based on bias-adjusted estimators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ba.boot(x, nc = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ba.boot_+3A_x">x</code></td>
<td>
<p>SVAR object of class &quot;sboot&quot;</p>
</td></tr>
<tr><td><code id="ba.boot_+3A_nc">nc</code></td>
<td>
<p>Integer. Number of processor cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;sboot&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>true</code></td>
<td>
<p>Point estimate of impulse response functions</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>List of length &quot;nboot&quot; holding bootstrap impulse response functions</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>Bootstrapped standard errors of estimated covariance decomposition
(only if &quot;x&quot; has method &quot;Cramer von-Mises&quot;, or &quot;Distance covariances&quot;)</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code>b_length</code></td>
<td>
<p>Length of each block</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>Point estimate of covariance decomposition</p>
</td></tr>
<tr><td><code>boot_mean</code></td>
<td>
<p>Mean of bootstrapped covariance decompositions</p>
</td></tr>
<tr><td><code>signrest</code></td>
<td>
<p>Evaluated sign pattern</p>
</td></tr>
<tr><td><code>sign_complete</code></td>
<td>
<p>Frequency of appearance of the complete sign pattern in all bootstrapped covariance decompositions</p>
</td></tr>
<tr><td><code>sign_part</code></td>
<td>
<p>Frequency of bootstrapped covariance decompositions which conform the complete predetermined sign pattern. If signrest=NULL,
the frequency of bootstrapped covariance decompositions that hold the same sign pattern as the point estimate is provided.</p>
</td></tr>
<tr><td><code>sign_part</code></td>
<td>
<p>Frequency of single shocks in all bootstrapped covariance decompositions which accord to a specific predetermined sign pattern</p>
</td></tr>
<tr><td><code>cov_bs</code></td>
<td>
<p>Covariance matrix of bootstrapped parameter in impact relations matrix</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Used bootstrap method</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kilian, L. (1998). Small-sample confidence intervals for impulse response functions. Review of Economics and Statistics 80, 218-230.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mb.boot">mb.boot</a></code>, <code><a href="#topic+wild.boot">wild.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data contains quarterly observations from 1965Q1 to 2008Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.dc(v1)
summary(x1)

# Bootstrap
bb &lt;- mb.boot(x1, b.length = 15, nboot = 300, n.ahead = 30, nc = 1, signrest = NULL)
summary(bb)
plot(bb, lowerq = 0.16, upperq = 0.84)

# Bias-adjusted bootstrap
bb2 &lt;- ba.boot(bb, nc = 1)
plot(bb2, lowerq = 0.16, upperq = 0.84)


</code></pre>

<hr>
<h2 id='cf'>Counterfactuals for SVAR Models</h2><span id='topic+cf'></span>

<h3>Description</h3>

<p>Calculation of Counterfactuals for an identified SVAR object 'svars' derived by function id.st( ), id.cvm( ),id.cv( ),id.dc( ) or id.ngml( ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf(x, series = 1, transition = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cf_+3A_x">x</code></td>
<td>
<p>SVAR object of class &quot;svars&quot;</p>
</td></tr>
<tr><td><code id="cf_+3A_series">series</code></td>
<td>
<p>Integer. indicating the series for which the counterfactuals should be calculated.</p>
</td></tr>
<tr><td><code id="cf_+3A_transition">transition</code></td>
<td>
<p>Numeric. Value from [0, 1] indicating how many initial values should be discarded, i.e., 0.1 means that the first 10 per cent observations of the sample are considered as transient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class attribute &quot;hd&quot; holding the Counterfactuals as data frame.
</p>


<h3>References</h3>

<p>Kilian, L., Luetkepohl, H., 2017. Structural Vector Autoregressive Analysis, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.dc">id.dc</a></code>, <code><a href="#topic+id.ngml">id.ngml</a></code>, <code><a href="#topic+id.cv">id.cv</a></code>, <code><a href="#topic+id.garch">id.garch</a></code> or <code><a href="#topic+id.st">id.st</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.dc(v1)
x2 &lt;- cf(x1, series = 2)
plot(x2)


</code></pre>

<hr>
<h2 id='chow.test'>Chow Test for Structural Break</h2><span id='topic+chow.test'></span>

<h3>Description</h3>

<p>The Chow test for structural change is implemented as sample-split and break-point test (see Luetkepohl and Kraetzig, 2004, p. 135). An estimated VAR model and the presupposed structural break need to be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chow.test(
  x,
  SB,
  nboot = 500,
  start = NULL,
  end = NULL,
  frequency = NULL,
  format = NULL,
  dateVector = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chow.test_+3A_x">x</code></td>
<td>
<p>An object of class 'vars', 'vec2var', 'nlVar'. Estimated VAR object. Or an object of class 'chowpretest' from stability()</p>
</td></tr>
<tr><td><code id="chow.test_+3A_sb">SB</code></td>
<td>
<p>Integer, vector or date character. The structural break is specified either by an integer (number of observations in the pre-break period),
a vector of ts() frequencies if a ts object is used in the VAR or a date character. If a date character is provided, either a date vector containing the whole time line
in the corresponding format or common time parameters need to be provided</p>
</td></tr>
<tr><td><code id="chow.test_+3A_nboot">nboot</code></td>
<td>
<p>Integer. Number of bootstrap iterations to calculate quantiles and p-values</p>
</td></tr>
<tr><td><code id="chow.test_+3A_start">start</code></td>
<td>
<p>Character. Start of the time series (only if dateVector is empty)</p>
</td></tr>
<tr><td><code id="chow.test_+3A_end">end</code></td>
<td>
<p>Character. End of the time series (only if dateVector is empty)</p>
</td></tr>
<tr><td><code id="chow.test_+3A_frequency">frequency</code></td>
<td>
<p>Character. Frequency of the time series (only if dateVector is empty)</p>
</td></tr>
<tr><td><code id="chow.test_+3A_format">format</code></td>
<td>
<p>Character. Date format (only if dateVector is empty)</p>
</td></tr>
<tr><td><code id="chow.test_+3A_datevector">dateVector</code></td>
<td>
<p>Vector. Vector of time periods containing SB in corresponding format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;chow&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>lambda_bp</code></td>
<td>
<p>Test statistic of the Chow test with break point</p>
</td></tr>
<tr><td><code>testcrit_bp</code></td>
<td>
<p>Critical value of the test statistic lambda_bp</p>
</td></tr>
<tr><td><code>p.value_bp</code></td>
<td>
<p>p-value of the test statistic lambda_bp</p>
</td></tr>
<tr><td><code>lambda_sp</code></td>
<td>
<p>Test statistic of the Chow test with sample split</p>
</td></tr>
<tr><td><code>testcrit_sp</code></td>
<td>
<p>Critical value of the test statistic lambda_sp</p>
</td></tr>
<tr><td><code>p.value_sp</code></td>
<td>
<p>p-value of the test statistic lambda_sp</p>
</td></tr>
<tr><td><code>SB</code></td>
<td>
<p>Structural break tested</p>
</td></tr>
<tr><td><code>SBcharacter</code></td>
<td>
<p>Structural break tested as character</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags used</p>
</td></tr>
</table>


<h3>References</h3>

<p>Luetkepohl, H., 2005. New introduction to multiple time series analysis, Springer-Verlag, Berlin.<br />
Luetkepohl, H., Kraetzig, M., 2004. Applied time series econometrics, Cambridge University Press, Cambridge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stability">stability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Testing for structural break in USA data
#' # data contains quartlery observations from 1965Q1 to 2008Q2
# assumed structural break in 1979Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
z1 &lt;- chow.test(v1, SB = 59)
summary(z1)

#Using stability() to find potential break point and sample split
x1 &lt;- stability(v1, type = "mv-chow-test")
plot(x1)
z1.1 &lt;- chow.test(x1)
summary(z1.1)
#Or using sample split as benchmark
x1$break_point &lt;- FALSE
z1.1 &lt;- chow.test(x1)
summary(z1.1)

#Structural brake via Dates
#given that time series vector with dates is available
dateVector &lt;- seq(as.Date("1965/1/1"), as.Date("2008/7/1"), "quarter")
z2 &lt;- chow.test(v1, SB = "1979-07-01", format = "%Y-%m-%d", dateVector = dateVector)
summary(z2)

# alternatively pass sequence arguments directly
z3 &lt;- chow.test(v1, SB = "1979-07-01", format = "%Y-%m-%d",
                start = "1965-01-01", end = "2008-07-01",
                frequency = "quarter")
summary(z3)

# or provide ts date format (For quarterly, monthly, weekly and daily frequencies only)
z4 &lt;- chow.test(v1, SB = c(1979,3))
summary(z4)

</code></pre>

<hr>
<h2 id='fevd'>Forecast error variance decomposition for SVAR Models</h2><span id='topic+fevd'></span><span id='topic+fevd.svars'></span>

<h3>Description</h3>

<p>Calculation of forecast error variance decomposition for an identified SVAR object 'svars' derived by function id.st( ), id.cvm( ),id.cv( ),id.dc( ) or id.ngml( ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svars'
fevd(x, n.ahead = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fevd_+3A_x">x</code></td>
<td>
<p>SVAR object of class &quot;svars&quot;.</p>
</td></tr>
<tr><td><code id="fevd_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps.</p>
</td></tr>
<tr><td><code id="fevd_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class attribute &quot;svarfevd&quot; holding the forecast error variance decompositions as data frames.
</p>


<h3>References</h3>

<p>Kilian, L., Luetkepohl, H., 2017. Structural Vector Autoregressive Analysis, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.garch">id.garch</a></code>, <code><a href="#topic+id.dc">id.dc</a></code>, <code><a href="#topic+id.ngml">id.ngml</a></code>, <code><a href="#topic+id.cv">id.cv</a></code> or <code><a href="#topic+id.st">id.st</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.dc(v1)
x2 &lt;- fevd(x1, n.ahead = 30)
plot(x2)


</code></pre>

<hr>
<h2 id='hd'>Historical decomposition for SVAR Models</h2><span id='topic+hd'></span>

<h3>Description</h3>

<p>Calculation of historical decomposition for an identified SVAR object 'svars' derived by function id.st( ), id.cvm( ),id.cv( ),id.dc( ) or id.ngml( ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hd(x, series = 1, transition = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hd_+3A_x">x</code></td>
<td>
<p>SVAR object of class &quot;svars&quot;</p>
</td></tr>
<tr><td><code id="hd_+3A_series">series</code></td>
<td>
<p>Integer. indicating the series that should be decomposed.</p>
</td></tr>
<tr><td><code id="hd_+3A_transition">transition</code></td>
<td>
<p>Numeric. Value from [0, 1] indicating how many initial values should be discarded, i.e., 0.1 means that the first 10 per cent observations of the sample are considered as transient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class attribute &quot;hd&quot; holding the historical decomposition as data frame.
</p>


<h3>References</h3>

<p>Kilian, L., Luetkepohl, H., 2017. Structural Vector Autoregressive Analysis, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.dc">id.dc</a></code>, <code><a href="#topic+id.ngml">id.ngml</a></code>, <code><a href="#topic+id.cv">id.cv</a></code>, <code><a href="#topic+id.garch">id.garch</a></code> or <code><a href="#topic+id.st">id.st</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.dc(v1)
x2 &lt;- hd(x1, series = 2)
plot(x2)


</code></pre>

<hr>
<h2 id='id.chol'>Recursive identification of SVAR models via Cholesky decomposition</h2><span id='topic+id.chol'></span>

<h3>Description</h3>

<p>Given an estimated VAR model, this function uses the Cholesky decomposition to identify the structural impact matrix B of the corresponding SVAR model
</p>
<p style="text-align: center;"><code class="reqn">y_t=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+u_t
=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+B \epsilon_t.</code>
</p>

<p>Matrix B corresponds to the decomposition of the least squares covariance matrix <code class="reqn">\Sigma_u=B\Lambda_t B'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.chol(x, order_k = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id.chol_+3A_x">x</code></td>
<td>
<p>An object of class 'vars', 'vec2var', 'nlVar'. Estimated VAR object</p>
</td></tr>
<tr><td><code id="id.chol_+3A_order_k">order_k</code></td>
<td>
<p>Vector. Vector of characters or integers specifying the assumed structure of the recursive causality. Change the causal ordering in the instantaneous effects without permuting variables and re-estimating the VAR model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;svars&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>Estimated structural impact matrix B, i.e. unique decomposition of the covariance matrix of reduced form residuals</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method applied for identification</p>
</td></tr>
<tr><td><code>order_k</code></td>
<td>
<p>Ordering of the variables as assumed for recursive causality</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>Estimated VAR parameter</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the VAR model, e.g. 'const'</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Dimension of the VAR</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Luetkepohl, H., 2005. New introduction to multiple time series analysis, Springer-Verlag, Berlin.
</p>


<h3>See Also</h3>

<p>For alternative identification approaches see <code><a href="#topic+id.st">id.st</a></code>, <code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.cv">id.cv</a></code>, <code><a href="#topic+id.dc">id.dc</a></code> or <code><a href="#topic+id.ngml">id.ngml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# data contains quarterly observations from 1965Q1 to 2008Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.chol(v1)
x2 &lt;- id.chol(v1, order_k = c("pi", "x", "i")) ## order_k = c(2,1,3)
summary(x1)


# impulse response analysis
i1 &lt;- irf(x1, n.ahead = 30)
i2 &lt;- irf(x2, n.ahead = 30)
plot(i1, scales = 'free_y')
plot(i2, scales = 'free_y')



</code></pre>

<hr>
<h2 id='id.cv'>Identification of SVAR models based on Changes in volatility (CV)</h2><span id='topic+id.cv'></span>

<h3>Description</h3>

<p>Given an estimated VAR model, this function applies changes in volatility to identify the structural impact matrix B of the corresponding SVAR model
</p>
<p style="text-align: center;"><code class="reqn">y_t=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+u_t
=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+B \epsilon_t.</code>
</p>

<p>Matrix B corresponds to the decomposition of the pre-break covariance matrix <code class="reqn">\Sigma_1=B B'</code>.
The post-break covariance corresponds to <code class="reqn">\Sigma_2=B\Lambda B'</code> where <code class="reqn">\Lambda</code> is the estimated unconditional heteroskedasticity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.cv(
  x,
  SB,
  SB2 = NULL,
  start = NULL,
  end = NULL,
  frequency = NULL,
  format = NULL,
  dateVector = NULL,
  max.iter = 50,
  crit = 0.001,
  restriction_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id.cv_+3A_x">x</code></td>
<td>
<p>An object of class 'vars', 'vec2var', 'nlVar'. Estimated VAR object</p>
</td></tr>
<tr><td><code id="id.cv_+3A_sb">SB</code></td>
<td>
<p>Integer, vector or date character. The structural break is specified either by an integer (number of observations in the pre-break period),
a vector of ts() frequencies if a ts object is used in the VAR or a date character. If a date character is provided, either a date vector containing the whole time line
in the corresponding format (see examples) or common time parameters need to be provided</p>
</td></tr>
<tr><td><code id="id.cv_+3A_sb2">SB2</code></td>
<td>
<p>Integer, vector or date character. Optional if the model should be estimated with two volatility regimes.
The structural break is specified either by an integer (number of observations in the pre-break period),
a vector of ts() frequencies if a ts object is used in the VAR or a date character. If a date character is provided, either a date vector containing the whole time line
in the corresponding format (see examples) or common time parameters need to be provided</p>
</td></tr>
<tr><td><code id="id.cv_+3A_start">start</code></td>
<td>
<p>Character. Start of the time series (only if dateVector is empty)</p>
</td></tr>
<tr><td><code id="id.cv_+3A_end">end</code></td>
<td>
<p>Character. End of the time series (only if dateVector is empty)</p>
</td></tr>
<tr><td><code id="id.cv_+3A_frequency">frequency</code></td>
<td>
<p>Character. Frequency of the time series (only if dateVector is empty)</p>
</td></tr>
<tr><td><code id="id.cv_+3A_format">format</code></td>
<td>
<p>Character. Date format (only if dateVector is empty)</p>
</td></tr>
<tr><td><code id="id.cv_+3A_datevector">dateVector</code></td>
<td>
<p>Vector. Vector of time periods containing SB in corresponding format</p>
</td></tr>
<tr><td><code id="id.cv_+3A_max.iter">max.iter</code></td>
<td>
<p>Integer. Number of maximum GLS iterations</p>
</td></tr>
<tr><td><code id="id.cv_+3A_crit">crit</code></td>
<td>
<p>Numeric. Critical value for the precision of the GLS estimation</p>
</td></tr>
<tr><td><code id="id.cv_+3A_restriction_matrix">restriction_matrix</code></td>
<td>
<p>Matrix. A matrix containing presupposed entries for matrix B, NA if no restriction is imposed (entries to be estimated). Alternatively, a K^2*K^2 matrix can be passed, where ones on the diagonal designate unrestricted and zeros restricted coefficients. (as suggested in Luetkepohl, 2017, section 5.2.1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;svars&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>Lambda</code></td>
<td>
<p>Estimated unconditional heteroscedasticity matrix <code class="reqn">\Lambda</code></p>
</td></tr>
<tr><td><code>Lambda_SE</code></td>
<td>
<p>Matrix of standard errors of Lambda</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Estimated structural impact matrix B, i.e. unique decomposition of the covariance matrix of reduced form residuals</p>
</td></tr>
<tr><td><code>B_SE</code></td>
<td>
<p>Standard errors of matrix B</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>Fish</code></td>
<td>
<p>Observed Fisher information matrix</p>
</td></tr>
<tr><td><code>Lik</code></td>
<td>
<p>Function value of likelihood</p>
</td></tr>
<tr><td><code>wald_statistic</code></td>
<td>
<p>Results of sequential Wald-type identification test on equal eigenvalues as described in Luetkepohl et. al. (2021).
In case of more than two regimes, pairwise Wald-type tests of equal diagonal elements in the Lambda matrices are performed.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>Number of GLS estimations</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method applied for identification</p>
</td></tr>
<tr><td><code>SB</code></td>
<td>
<p>Structural break (number of observations)</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>Estimated VAR parameter via GLS</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the VAR model, e.g. 'const'</p>
</td></tr>
<tr><td><code>SBcharacter</code></td>
<td>
<p>Structural break (date; if provided in function arguments)</p>
</td></tr>
<tr><td><code>restrictions</code></td>
<td>
<p>Number of specified restrictions</p>
</td></tr>
<tr><td><code>restriction_matrix</code></td>
<td>
<p>Specified restriction matrix</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Dimension of the VAR</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rigobon, R., 2003. Identification through Heteroskedasticity. The Review of Economics and Statistics, 85, 777-792.<br />
</p>
<p>Herwartz, H. &amp; Ploedt, M., 2016. Simulation Evidence on Theory-based and Statistical Identification under Volatility Breaks. Oxford Bulletin of Economics and Statistics, 78, 94-112.<br />
</p>
<p>Luetkepohl, H. &amp; Meitz, M. &amp; Netsunajev, A. &amp; and Saikkonen, P.,  2021. Testing identification via heteroskedasticity in structural vector autoregressive models. Econometrics Journal, 24, 1-22.
</p>


<h3>See Also</h3>

<p>For alternative identification approaches see <code><a href="#topic+id.st">id.st</a></code>, <code><a href="#topic+id.garch">id.garch</a></code>, <code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.dc">id.dc</a></code> or <code><a href="#topic+id.ngml">id.ngml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # data contains quartlery observations from 1965Q1 to 2008Q2
# assumed structural break in 1979Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.cv(v1, SB = 59)
summary(x1)

# switching columns according to sign patter
x1$B &lt;- x1$B[,c(3,2,1)]
x1$B[,3] &lt;- x1$B[,3]*(-1)

# Impulse response analysis
i1 &lt;- irf(x1, n.ahead = 30)
plot(i1, scales = 'free_y')

# Restrictions
# Assuming that the interest rate doesn't influence the output gap on impact
restMat &lt;- matrix(rep(NA, 9), ncol = 3)
restMat[1,3] &lt;- 0
x2 &lt;- id.cv(v1, SB = 59, restriction_matrix = restMat)
summary(x2)

# In alternative Form
restMat &lt;- diag(rep(1,9))
restMat[7,7]= 0
x2 &lt;- id.cv(v1, SB = 59, restriction_matrix = restMat)
summary(x2)

#Structural brake via Dates
# given that time series vector with dates is available
dateVector = seq(as.Date("1965/1/1"), as.Date("2008/7/1"), "quarter")
x3 &lt;- id.cv(v1, SB = "1979-07-01", format = "%Y-%m-%d", dateVector = dateVector)
summary(x3)

# or pass sequence arguments directly
x4 &lt;- id.cv(v1, SB = "1979-07-01", format = "%Y-%m-%d", start = "1965-01-01", end = "2008-07-01",
frequency = "quarter")
summary(x4)

# or provide ts date format (For quarterly, monthly, weekly and daily frequencies only)
x5 &lt;- id.cv(v1, SB = c(1979, 3))
summary(x5)

#-----# Example with three covariance regimes

x6 &lt;- id.cv(v1, SB = 59, SB2 = 110)
summary(x6)

</code></pre>

<hr>
<h2 id='id.cvm'>Independence-based identification of SVAR models via Cramer-von Mises (CVM) distance</h2><span id='topic+id.cvm'></span>

<h3>Description</h3>

<p>Given an estimated VAR model, this function applies independence-based identification for the structural impact matrix B of the corresponding SVAR model
</p>
<p style="text-align: center;"><code class="reqn">y_t=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+u_t   =c_t+A_1 y_{t-1}+...+A_p y_{t-p}+B \epsilon_t.</code>
</p>

<p>Matrix B corresponds to the unique decomposition of the least squares covariance matrix <code class="reqn">\Sigma_u=B B'</code> if the vector of structural shocks <code class="reqn">\epsilon_t</code> contains at most one Gaussian shock (Comon, 1994).
A nonparametric dependence measure, the Cramer-von Mises distance (Genest and Remillard, 2004), determines least dependent structural shocks. The minimum is obtained by a two step optimization algorithm similar to the technique described in Herwartz and Ploedt (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.cvm(x, dd = NULL, itermax = 500, steptol = 100, iter2 = 75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id.cvm_+3A_x">x</code></td>
<td>
<p>An object of class 'vars', 'vec2var', 'nlVar'. Estimated VAR object</p>
</td></tr>
<tr><td><code id="id.cvm_+3A_dd">dd</code></td>
<td>
<p>Object of class 'indepTestDist' (generated by 'indepTest' from package 'copula'). A simulated independent sample of the same size as the data. If not supplied, it will be calculated by the function</p>
</td></tr>
<tr><td><code id="id.cvm_+3A_itermax">itermax</code></td>
<td>
<p>Integer. IMaximum number of iterations for DEoptim</p>
</td></tr>
<tr><td><code id="id.cvm_+3A_steptol">steptol</code></td>
<td>
<p>Numeric. Tolerance for steps without improvement for DEoptim</p>
</td></tr>
<tr><td><code id="id.cvm_+3A_iter2">iter2</code></td>
<td>
<p>Integer. Number of iterations for the second optimization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;svars&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>Estimated structural impact matrix B, i.e. unique decomposition of the covariance matrix of reduced form errors</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>Estimated VAR parameter</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method applied for identification</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the VAR model, e.g. 'const'</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Dimension of the VAR</p>
</td></tr>
<tr><td><code>rotation_angles</code></td>
<td>
<p>Rotation angles, which lead to maximum independence</p>
</td></tr>
<tr><td><code>inc</code></td>
<td>
<p>Indicator. 1 = second optimization increased the estimation precision. 0 = second optimization did not increase the estimation precision</p>
</td></tr>
<tr><td><code>test.stats</code></td>
<td>
<p>Computed test statistics of independence test</p>
</td></tr>
<tr><td><code>iter1</code></td>
<td>
<p>Number of iterations of first optimization</p>
</td></tr>
<tr><td><code>test1</code></td>
<td>
<p>Minimum test statistic from first optimization</p>
</td></tr>
<tr><td><code>test2</code></td>
<td>
<p>Minimum test statistic from second optimization</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Herwartz, H., 2018. Hodges Lehmann detection of structural shocks - An Analysis of macroeconomic dynamics in the Euro Area, Oxford Bulletin of Economics and Statistics<br />
Herwartz, H. &amp; Ploedt, M., 2016. The macroeconomic effects of oil price shocks: Evidence from a statistical identification approach, Journal of International Money and Finance, 61, 30-44<br />
Comon, P., 1994. Independent component analysis, A new concept?, Signal Processing, 36, 287-314<br />
Genest, C. &amp; Remillard, B., 2004. Tests of independence and randomness based on the empirical copula process, Test, 13, 335-370<br />
</p>


<h3>See Also</h3>

<p>For alternative identification approaches see <code><a href="#topic+id.st">id.st</a></code>, <code><a href="#topic+id.garch">id.garch</a></code>, <code><a href="#topic+id.cv">id.cv</a></code>, <code><a href="#topic+id.dc">id.dc</a></code> or <code><a href="#topic+id.ngml">id.ngml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data contains quarterly observations from 1965Q1 to 2008Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
cob &lt;- copula::indepTestSim(v1$obs, v1$K, verbose=FALSE)
x1 &lt;- id.cvm(v1, dd = cob)
summary(x1)

# switching columns according to sign pattern
x1$B &lt;- x1$B[,c(3,2,1)]
x1$B[,3] &lt;- x1$B[,3]*(-1)

# impulse response analysis
i1 &lt;- irf(x1, n.ahead = 30)
plot(i1, scales = 'free_y')


</code></pre>

<hr>
<h2 id='id.dc'>Independence-based identification of SVAR models build on distance covariances (DC) statistic</h2><span id='topic+id.dc'></span>

<h3>Description</h3>

<p>Given an estimated VAR model, this function applies independence-based identification for the structural impact matrix B of the corresponding SVAR model
</p>
<p style="text-align: center;"><code class="reqn">y_t=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+u_t  =c_t+A_1 y_{t-1}+...+A_p y_{t-p}+B \epsilon_t.</code>
</p>

<p>Matrix B corresponds to the unique decomposition of the least squares covariance matrix <code class="reqn">\Sigma_u=B B'</code> if the vector of structural shocks <code class="reqn">\epsilon_t</code> contains at most one Gaussian shock (Comon, 1994).
A nonparametric dependence measure, the distance covariance (Szekely et al, 2007), determines least dependent structural shocks. The algorithm described in Matteson and Tsay (2013) is applied to calculate the matrix B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.dc(x, PIT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id.dc_+3A_x">x</code></td>
<td>
<p>An object of class 'vars', 'vec2var', 'nlVar'. Estimated VAR object</p>
</td></tr>
<tr><td><code id="id.dc_+3A_pit">PIT</code></td>
<td>
<p>Logical. If PIT='TRUE', the distribution and density of the independent components are estimated using gaussian kernel density estimates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;svars&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>Estimated structural impact matrix B, i.e. unique decomposition of the covariance matrix of reduced form errors</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>Estimated VAR parameter</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method applied for identification</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the VAR model, e.g. 'const'</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Dimension of the VAR</p>
</td></tr>
<tr><td><code>PIT</code></td>
<td>
<p>Logical, if PIT is used</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Matteson, D. S. &amp; Tsay, R. S., 2013. Independent Component Analysis via Distance Covariance, pre-print<br />
Szekely, G. J.; Rizzo, M. L. &amp; Bakirov, N. K., 2007. Measuring and testing dependence by correlation of distances Ann. Statist., 35, 2769-2794<br />
Comon, P., 1994. Independent component analysis, A new concept?, Signal Processing, 36, 287-314
</p>


<h3>See Also</h3>

<p>For alternative identification approaches see <code><a href="#topic+id.st">id.st</a></code>, <code><a href="#topic+id.garch">id.garch</a></code>, <code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.cv">id.cv</a></code> or <code><a href="#topic+id.ngml">id.ngml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data contains quarterly observations from 1965Q1 to 2008Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.dc(v1)
summary(x1)

# switching columns according to sign pattern
x1$B &lt;- x1$B[,c(3,2,1)]
x1$B[,3] &lt;- x1$B[,3]*(-1)

# impulse response analysis
i1 &lt;- irf(x1, n.ahead = 30)
plot(i1, scales = 'free_y')


</code></pre>

<hr>
<h2 id='id.garch'>Identification of SVAR models through patterns of GARCH</h2><span id='topic+id.garch'></span>

<h3>Description</h3>

<p>Given an estimated VAR model, this function uses GARCH-type variances to identify the structural impact matrix B of the corresponding SVAR model
</p>
<p style="text-align: center;"><code class="reqn">y_t=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+u_t
=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+B \epsilon_t.</code>
</p>

<p>Matrix B corresponds to the decomposition of the least squares covariance matrix <code class="reqn">\Sigma_u=B\Lambda_t B'</code>, where <code class="reqn">\Lambda_t</code> is the estimated conditional heteroskedasticity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.garch(
  x,
  max.iter = 5,
  crit = 0.001,
  restriction_matrix = NULL,
  start_iter = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id.garch_+3A_x">x</code></td>
<td>
<p>An object of class 'vars', 'vec2var', 'nlVar'. Estimated VAR object</p>
</td></tr>
<tr><td><code id="id.garch_+3A_max.iter">max.iter</code></td>
<td>
<p>Integer. Number of maximum likelihood optimizations</p>
</td></tr>
<tr><td><code id="id.garch_+3A_crit">crit</code></td>
<td>
<p>Numeric. Critical value for the precision of the iterative procedure</p>
</td></tr>
<tr><td><code id="id.garch_+3A_restriction_matrix">restriction_matrix</code></td>
<td>
<p>Matrix. A matrix containing presupposed entries for matrix B, NA if no restriction is imposed (entries to be estimated). Alternatively, a K^2*K^2 matrix can be passed, where ones on the diagonal designate unrestricted and zeros restricted coefficients. (as suggested in Luetkepohl, 2017, section 5.2.1).</p>
</td></tr>
<tr><td><code id="id.garch_+3A_start_iter">start_iter</code></td>
<td>
<p>Numeric. Number of random candidate initial values for univariate GRACH(1,1) optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;svars&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>Estimated structural impact matrix B, i.e. unique decomposition of the covariance matrix of reduced form residuals</p>
</td></tr>
<tr><td><code>B_SE</code></td>
<td>
<p>Standard errors of matrix B</p>
</td></tr>
<tr><td><code>GARCH_parameter</code></td>
<td>
<p>Estimated GARCH parameters of univariate GARCH models</p>
</td></tr>
<tr><td><code>GARCH_SE</code></td>
<td>
<p>Standard errors of GARCH parameters</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>Fish</code></td>
<td>
<p>Observed Fisher information matrix</p>
</td></tr>
<tr><td><code>Lik</code></td>
<td>
<p>Function value of likelihood</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>Number of likelihood optimizations</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method applied for identification</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>Estimated VAR parameter via GLS</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the VAR model, e.g. 'const'</p>
</td></tr>
<tr><td><code>restrictions</code></td>
<td>
<p>Number of specified restrictions</p>
</td></tr>
<tr><td><code>restriction_matrix</code></td>
<td>
<p>Specified restriction matrix</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Dimension of the VAR</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
<tr><td><code>I_test</code></td>
<td>
<p>Results of a series of sequential tests on the number of heteroskedastic shocks present in the system as described in Luetkepohl and Milunovich (2016).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Normadin, M. &amp; Phaneuf, L., 2004. Monetary Policy Shocks: Testing Identification Conditions under Time-Varying Conditional Volatility. Journal of Monetary Economics, 51(6), 1217-1243.<br />
</p>
<p>Lanne, M. &amp; Saikkonen, P., 2007. A Multivariate Generalized Orthogonal Factor GARCH Model. Journal of Business &amp; Economic Statistics, 25(1), 61-75.
</p>
<p>Luetkepohl, H. &amp; Milunovich, G. 2016. Testing for identification in SVAR-GARCH models. Journal of Economic Dynamics and Control, 73(C):241-258
</p>


<h3>See Also</h3>

<p>For alternative identification approaches see <code><a href="#topic+id.st">id.st</a></code>, <code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.cv">id.cv</a></code>, <code><a href="#topic+id.dc">id.dc</a></code> or <code><a href="#topic+id.ngml">id.ngml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data contains quartlery observations from 1965Q1 to 2008Q2
# assumed structural break in 1979Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.garch(v1)
summary(x1)

# Impulse response analysis
i1 &lt;- irf(x1, n.ahead = 30)
plot(i1, scales = 'free_y')

# Restrictions
# Assuming that the interest rate doesn't influence the output gap on impact
restMat &lt;- matrix(rep(NA, 9), ncol = 3)
restMat[1,3] &lt;- 0
x2 &lt;- id.garch(v1, restriction_matrix = restMat)
summary(x2)



</code></pre>

<hr>
<h2 id='id.ngml'>Non-Gaussian maximum likelihood (NGML) identification of SVAR models</h2><span id='topic+id.ngml'></span>

<h3>Description</h3>

<p>Given an estimated VAR model, this function applies identification by means of a non-Gaussian likelihood for the structural impact matrix B of the corresponding SVAR model
</p>
<p style="text-align: center;"><code class="reqn">y_t=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+u_t   =c_t+A_1 y_{t-1}+...+A_p y_{t-p}+B \epsilon_t.</code>
</p>

<p>Matrix B corresponds to the unique decomposition of the least squares covariance matrix <code class="reqn">\Sigma_u=B B'</code> if the vector of structural shocks <code class="reqn">\epsilon_t</code> contains at most one Gaussian shock (Comon, 94).
A likelihood function of independent t-distributed structural shocks <code class="reqn">\epsilon_t=B^{-1}u_t</code> is maximized with respect to the entries of B and the degrees of freedom of the t-distribution (Lanne et al., 2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.ngml(x, stage3 = FALSE, restriction_matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id.ngml_+3A_x">x</code></td>
<td>
<p>An object of class 'vars', 'vec2var', 'nlVar'. Estimated VAR object</p>
</td></tr>
<tr><td><code id="id.ngml_+3A_stage3">stage3</code></td>
<td>
<p>Logical. If stage3=&quot;TRUE&quot;, the VAR parameters are estimated via non-gaussian maximum likelihood (computationally demanding)</p>
</td></tr>
<tr><td><code id="id.ngml_+3A_restriction_matrix">restriction_matrix</code></td>
<td>
<p>Matrix. A matrix containing presupposed entries for matrix B, NA if no restriction is imposed (entries to be estimated). Alternatively, a K^2*K^2 matrix can be passed, where ones on the diagonal designate unrestricted and zeros restricted coefficients. (as suggested in Luetkepohl, 2017, section 5.2.1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;svars&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>Estimated structural impact matrix B, i.e. unique decomposition of the covariance matrix of reduced form errors</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated scale of the standardized matrix B_stand, i.e. <code class="reqn">B=B_stand*diag(\sigma_1,...,\sigma_K)</code></p>
</td></tr>
<tr><td><code>sigma_SE</code></td>
<td>
<p>Standard errors of the scale</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Estimated degrees of freedom</p>
</td></tr>
<tr><td><code>df_SE</code></td>
<td>
<p>Standard errors of the degrees of freedom</p>
</td></tr>
<tr><td><code>Fish</code></td>
<td>
<p>Observed Fisher information matrix</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>Estimated VAR parameter via ML</p>
</td></tr>
<tr><td><code>B_stand</code></td>
<td>
<p>Estimated standardized structural impact matrix</p>
</td></tr>
<tr><td><code>B_stand_SE</code></td>
<td>
<p>Standard errors of standardized matrix B_stand</p>
</td></tr>
<tr><td><code>Lik</code></td>
<td>
<p>Function value of likelihood</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method applied for identification</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the VAR model, e.g. 'const'</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Dimension of the VAR</p>
</td></tr>
<tr><td><code>restrictions</code></td>
<td>
<p>Number of specified restrictions</p>
</td></tr>
<tr><td><code>restriction_matrix</code></td>
<td>
<p>Specified restriction matrix</p>
</td></tr>
<tr><td><code>stage3</code></td>
<td>
<p>Logical, whether Stage 3 is performed</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lanne, M., Meitz, M., Saikkonen, P., 2017. Identification and estimation of non-Gaussian structural vector autoregressions. J. Econometrics 196 (2), 288-304.<br />
Comon, P., 1994. Independent component analysis, A new concept?, Signal Processing, 36, 287-314
</p>


<h3>See Also</h3>

<p>For alternative identification approaches see <code><a href="#topic+id.st">id.st</a></code>, <code><a href="#topic+id.garch">id.garch</a></code>, <code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.dc">id.dc</a></code> or <code><a href="#topic+id.cv">id.cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data contains quarterly observations from 1965Q1 to 2008Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.ngml(v1)
summary(x1)

# switching columns according to sign pattern
x1$B &lt;- x1$B[,c(3,2,1)]
x1$B[,3] &lt;- x1$B[,3]*(-1)

# impulse response analysis
i1 &lt;- irf(x1, n.ahead = 30)
plot(i1, scales = 'free_y')

</code></pre>

<hr>
<h2 id='id.st'>Identification of SVAR models by means of a smooth transition (ST) in covariance</h2><span id='topic+id.st'></span>

<h3>Description</h3>

<p>Given an estimated VAR model, this function uses a smooth transition in the covariance to identify the structural impact matrix B of the corresponding SVAR model
</p>
<p style="text-align: center;"><code class="reqn">y_t=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+u_t
=c_t+A_1 y_{t-1}+...+A_p y_{t-p}+B \epsilon_t.</code>
</p>

<p>Matrix B corresponds to the decomposition of the pre-break covariance matrix <code class="reqn">\Sigma_1=B B'</code>.
The post-break covariance corresponds to <code class="reqn">\Sigma_2=B\Lambda B'</code> where <code class="reqn">\Lambda</code> is the estimated heteroskedasticity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.st(
  x,
  c_lower = 0.3,
  c_upper = 0.7,
  c_step = 5,
  c_fix = NULL,
  transition_variable = NULL,
  gamma_lower = -3,
  gamma_upper = 2,
  gamma_step = 0.5,
  gamma_fix = NULL,
  nc = 1,
  max.iter = 5,
  crit = 0.001,
  restriction_matrix = NULL,
  lr_test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id.st_+3A_x">x</code></td>
<td>
<p>An object of class 'vars', 'vec2var', 'nlVar'. Estimated VAR object</p>
</td></tr>
<tr><td><code id="id.st_+3A_c_lower">c_lower</code></td>
<td>
<p>Numeric. Starting point for the algorithm to start searching for the volatility shift.
Default is 0.3*(Total number of observations)</p>
</td></tr>
<tr><td><code id="id.st_+3A_c_upper">c_upper</code></td>
<td>
<p>Numeric. Ending point for the algorithm to stop searching for the volatility shift.
Default is 0.7*(Total number of observations). Note that in case of a stochastic transition variable, the input requires an absolute value</p>
</td></tr>
<tr><td><code id="id.st_+3A_c_step">c_step</code></td>
<td>
<p>Integer. Step width of c. Default is 5. Note that in case of a stochastic transition variable, the input requires an absolute value</p>
</td></tr>
<tr><td><code id="id.st_+3A_c_fix">c_fix</code></td>
<td>
<p>Numeric. If the transition point is known, it can be passed as an argument
where transition point = Number of observations - c_fix</p>
</td></tr>
<tr><td><code id="id.st_+3A_transition_variable">transition_variable</code></td>
<td>
<p>A numeric vector that represents the transition variable. By default (NULL), the time is used
as transition variable. Note that c_lower,c_upper, c_step and/or c_fix have to be adjusted
to the specified transition variable</p>
</td></tr>
<tr><td><code id="id.st_+3A_gamma_lower">gamma_lower</code></td>
<td>
<p>Numeric. Lower bound for gamma. Small values indicate a flat transition function. Default is -3</p>
</td></tr>
<tr><td><code id="id.st_+3A_gamma_upper">gamma_upper</code></td>
<td>
<p>Numeric. Upper bound for gamma. Large values indicate a steep transition function. Default is 2</p>
</td></tr>
<tr><td><code id="id.st_+3A_gamma_step">gamma_step</code></td>
<td>
<p>Numeric. Step width of gamma. Default is 0.5</p>
</td></tr>
<tr><td><code id="id.st_+3A_gamma_fix">gamma_fix</code></td>
<td>
<p>Numeric. A fixed value for gamma, alternative to gamma found by the function</p>
</td></tr>
<tr><td><code id="id.st_+3A_nc">nc</code></td>
<td>
<p>Integer. Number of processor cores
Note that the smooth transition model is computationally extremely demanding.</p>
</td></tr>
<tr><td><code id="id.st_+3A_max.iter">max.iter</code></td>
<td>
<p>Integer. Number of maximum GLS iterations</p>
</td></tr>
<tr><td><code id="id.st_+3A_crit">crit</code></td>
<td>
<p>Numeric. Critical value for the precision of the GLS estimation</p>
</td></tr>
<tr><td><code id="id.st_+3A_restriction_matrix">restriction_matrix</code></td>
<td>
<p>Matrix. A matrix containing presupposed entries for matrix B, NA if no restriction is imposed (entries to be estimated). Alternatively, a K^2*K^2 matrix can be passed, where ones on the diagonal designate unrestricted and zeros restricted coefficients. (as suggested in Luetkepohl, 2017, section 5.2.1).</p>
</td></tr>
<tr><td><code id="id.st_+3A_lr_test">lr_test</code></td>
<td>
<p>Logical. Indicates whether the restricted model should be tested against the unrestricted model via a likelihood ratio test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;svars&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>Lambda</code></td>
<td>
<p>Estimated heteroscedasticity matrix <code class="reqn">\Lambda</code></p>
</td></tr>
<tr><td><code>Lambda_SE</code></td>
<td>
<p>Matrix of standard errors of Lambda</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Estimated structural impact matrix B, i.e. unique decomposition of the covariance matrix of reduced form residuals</p>
</td></tr>
<tr><td><code>B_SE</code></td>
<td>
<p>Standard errors of matrix B</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>Fish</code></td>
<td>
<p>Observed Fisher information matrix</p>
</td></tr>
<tr><td><code>Lik</code></td>
<td>
<p>Function value of likelihood</p>
</td></tr>
<tr><td><code>wald_statistic</code></td>
<td>
<p>Results of pairwise Wald tests</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>Number of GLS estimations</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method applied for identification</p>
</td></tr>
<tr><td><code>est_c</code></td>
<td>
<p>Structural break (number of observations)</p>
</td></tr>
<tr><td><code>est_g</code></td>
<td>
<p>Transition coefficient</p>
</td></tr>
<tr><td><code>transition_variable</code></td>
<td>
<p>Vector of transition variable</p>
</td></tr>
<tr><td><code>comb</code></td>
<td>
<p>Number of all grid combinations of gamma and c</p>
</td></tr>
<tr><td><code>transition_function</code></td>
<td>
<p>Vector of transition function</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>Estimated VAR parameter via GLS</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the VAR model e.g., 'const'</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Dimension of the VAR</p>
</td></tr>
<tr><td><code>restrictions</code></td>
<td>
<p>Number of specified restrictions</p>
</td></tr>
<tr><td><code>restriction_matrix</code></td>
<td>
<p>Specified restriction matrix</p>
</td></tr>
<tr><td><code>lr_test</code></td>
<td>
<p>Logical, whether a likelihood ratio test is performed</p>
</td></tr>
<tr><td><code>lRatioTest</code></td>
<td>
<p>Results of likelihood ratio test</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Luetkepohl H., Netsunajev A., 2017. Structural vector autoregressions with smooth transition <br />
in variances. Journal of Economic Dynamics and Control, 84, 43 - 57. ISSN 0165-1889.
</p>


<h3>See Also</h3>

<p>For alternative identification approaches see <code><a href="#topic+id.cv">id.cv</a></code>, <code><a href="#topic+id.garch">id.garch</a></code>, <code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.dc">id.dc</a></code>,
or <code><a href="#topic+id.ngml">id.ngml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data contains quartlery observations from 1965Q1 to 2008Q2
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.st(v1, c_fix = 80, gamma_fix = 0)
summary(x1)
plot(x1)

# switching columns according to sign patter
x1$B &lt;- x1$B[,c(3,2,1)]
x1$B[,3] &lt;- x1$B[,3]*(-1)

# Impulse response analysis
i1 &lt;- irf(x1, n.ahead = 30)
plot(i1, scales = 'free_y')

# Example with same data set as in Luetkepohl and Nestunajev 2017
v1 &lt;- vars::VAR(LN, p = 3, type = 'const')
x1 &lt;- id.st(v1, c_fix = 167, gamma_fix = -2.77)
summary(x1)
plot(x1)

# Using a lagged endogenous transition variable
# In this example inflation with two lags
inf &lt;- LN[-c(1, 449, 450), 2]*(1/sd(LN[-c(1, 449, 450), 2]))
x1_inf &lt;- id.st(v1, c_fix = 4.41, gamma_fix = 0.49, transition_variable = inf)
summary(x1_inf)
plot(x1_inf)


</code></pre>

<hr>
<h2 id='irf'>Impulse Response Functions for SVAR Models</h2><span id='topic+irf'></span><span id='topic+irf.svars'></span>

<h3>Description</h3>

<p>Calculation of impulse response functions for an identified SVAR object 'svars' derived by function id.cvm( ),id.cv( ),id.dc( ), id.ngml( ) or id.st( ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svars'
irf(x, ..., n.ahead = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irf_+3A_x">x</code></td>
<td>
<p>SVAR object of class &quot;svars&quot;.</p>
</td></tr>
<tr><td><code id="irf_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="irf_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class attribute &quot;svarirf&quot; holding the impulse response functions as data frame.
</p>


<h3>References</h3>

<p>Luetkepohl, H., 2005. New introduction to multiple time series analysis, Springer-Verlag, Berlin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.dc">id.dc</a></code>, <code><a href="#topic+id.ngml">id.ngml</a></code>, <code><a href="#topic+id.cv">id.cv</a></code> or <code><a href="#topic+id.st">id.st</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.ngml(v1)
x2 &lt;- irf(x1, n.ahead = 20)
plot(x2)


</code></pre>

<hr>
<h2 id='js.test'>Chi-square test for joint hypotheses</h2><span id='topic+js.test'></span>

<h3>Description</h3>

<p>Based on an existing bootstrap object, the test statistic allows to test joint hypotheses for selected entries of the structural matrix B. The test statistic reads as
</p>
<p style="text-align: center;"><code class="reqn">(Rvec(\widehat{B}) - r)'R(\widehat{\mbox{Cov}}[vec(B^*)])^{-1}R'(Rvec(\widehat{b} - r)) \sim \chi^2_J,</code>
</p>

<p>where <code class="reqn">\widehat{\mbox{Cov}}[vec(B^*)]</code> is the estimated covariance of vectorized bootstrap estimates of structural parameters. The composite null hypothesis is <code class="reqn">H_0: Rvec(B)= r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>js.test(x, R, r = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="js.test_+3A_x">x</code></td>
<td>
<p>Object of class 'sboot'</p>
</td></tr>
<tr><td><code id="js.test_+3A_r">R</code></td>
<td>
<p>A J*K^2 selection matrix, where J is the number of hypotheses and K the number of time series.</p>
</td></tr>
<tr><td><code id="js.test_+3A_r">r</code></td>
<td>
<p>A J*1 vector of restrictions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;jstest&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>test_statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>P-value</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Selection matrix</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Vector of restrictions</p>
</td></tr>
</table>


<h3>References</h3>

<p>Herwartz, H., 2018. Hodges Lehmann detection of structural shocks -
An analysis of macroeconomic dynamics in the Euro Area, Oxford Bulletin of Economics and Statistics
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mb.boot">mb.boot</a></code>, <code><a href="#topic+wild.boot">wild.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data contains quarterly observations from 1965Q1 to 2008Q3
# x = output gap
# pi = inflation
# i = interest rates
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.dc(v1)

# Bootstrapping of SVAR
bb &lt;- wild.boot(x1, nboot = 1000, n.ahead = 30)

# Testing the hypothesis of a lower triangular matrix as
# relation between structural and reduced form errors
R &lt;- rbind(c(0,0,0,1,0,0,0,0,0), c(0,0,0,0,0,0,1,0,0),
           c(0,0,0,0,0,0,0,1,0))
c.test &lt;- js.test(bb, R)
summary(c.test)


</code></pre>

<hr>
<h2 id='LN'>Interaction between monetary policy and the stock market</h2><span id='topic+LN'></span>

<h3>Description</h3>

<p>A five dimensional time series model which is commonly used to analyze the interaction between monetary policy and the stock market.
<br />
Monthly observations from 1970M1 to 2007M6:
</p>

<table>
<tr>
 <td style="text-align: left;">
    q </td><td style="text-align: left;"> Linearly detrended log of an industrial production index </td>
</tr>
<tr>
 <td style="text-align: left;">
    pi </td><td style="text-align: left;"> Annual change in the log of consumer prices (CPI index) (x100) </td>
</tr>
<tr>
 <td style="text-align: left;">
    c </td><td style="text-align: left;"> annual change in the log of the World Bank (non energy) commodity price index (x100) </td>
</tr>
<tr>
 <td style="text-align: left;">
    s </td><td style="text-align: left;"> Log of the real S&amp;P500 stock price index deflated by the consumer price index
    to measure the real stock prices; the series is first differenced to represent monthly returns </td>
</tr>
<tr>
 <td style="text-align: left;">
    r </td><td style="text-align: left;"> Interest rate on Federal funds </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>All series, with exception of the commodity price index (c), are taken from the FRED database and transformed as in Luetkepohl &amp; Netsunajev (2017). The commodity price index comes from the World Bank. A more detailed description of the data and a corresponding VAR model implementation can be found in Luetkepohl &amp; Netsunajev (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LN</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> containing 450 observations on 5 variables.</p>


<h3>Source</h3>

<p> Luetkepohl H., Netsunajev A., 2017. &quot;Structural vector autoregressions with smooth transition in variances.&quot; <br />
Journal of Economic Dynamics and Control, 84, 43 - 57. ISSN 0165-1889.</p>

<hr>
<h2 id='mb.boot'>Moving block bootstrap for IRFs of identified SVARs</h2><span id='topic+mb.boot'></span>

<h3>Description</h3>

<p>Calculating confidence bands for impulse response via moving block bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb.boot(
  x,
  design = "recursive",
  b.length = 15,
  n.ahead = 20,
  nboot = 500,
  nc = 1,
  dd = NULL,
  signrest = NULL,
  signcheck = TRUE,
  itermax = 300,
  steptol = 200,
  iter2 = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mb.boot_+3A_x">x</code></td>
<td>
<p>SVAR object of class &quot;svars&quot;</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_design">design</code></td>
<td>
<p>character. If design=&quot;fixed&quot;, a fixed design bootstrap is performed. If design=&quot;recursive&quot;, a recursive design bootstrap is performed.</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_b.length">b.length</code></td>
<td>
<p>Integer. Length of each block</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_nboot">nboot</code></td>
<td>
<p>Integer. Number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_nc">nc</code></td>
<td>
<p>Integer. Number of processor cores</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_dd">dd</code></td>
<td>
<p>Object of class 'indepTestDist'. A simulated independent sample of the same size as the data.
If not supplied, it will be calculated by the function</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_signrest">signrest</code></td>
<td>
<p>A list with vectors containing 1 and -1, e.g. c(1,-1,1), indicating a sign pattern of specific shocks to be tested
with the help of the bootstrap samples.</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_signcheck">signcheck</code></td>
<td>
<p>Boolean. Whether the sign pattern should be checked for each bootstrap iteration.
Note that this procedure is computationally extremely demanding for high dimensional VARs, since the number of possible permutations of B is K!,
where K is the number of variables in the VAR.</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_itermax">itermax</code></td>
<td>
<p>Integer. Maximum number of iterations for DEoptim</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_steptol">steptol</code></td>
<td>
<p>Numeric. Tolerance for steps without improvement for DEoptim</p>
</td></tr>
<tr><td><code id="mb.boot_+3A_iter2">iter2</code></td>
<td>
<p>Integer. Number of iterations for the second optimization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;sboot&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>true</code></td>
<td>
<p>Point estimate of impulse response functions</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>List of length &quot;nboot&quot; holding bootstrap impulse response functions</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>Bootstrapped standard errors of estimated covariance decomposition
(only if &quot;x&quot; has method &quot;Cramer von-Mises&quot;, or &quot;Distance covariances&quot;)</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>character. Whether a fixed design or recursive design bootstrap is performed</p>
</td></tr>
<tr><td><code>b_length</code></td>
<td>
<p>Length of each block</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>Point estimate of covariance decomposition</p>
</td></tr>
<tr><td><code>boot_mean</code></td>
<td>
<p>Mean of bootstrapped covariance decompositions</p>
</td></tr>
<tr><td><code>signrest</code></td>
<td>
<p>Evaluated sign pattern</p>
</td></tr>
<tr><td><code>sign_complete</code></td>
<td>
<p>Frequency of appearance of the complete sign pattern in all bootstrapped covariance decompositions</p>
</td></tr>
<tr><td><code>sign_part</code></td>
<td>
<p>Frequency of bootstrapped covariance decompositions which conform the complete predetermined sign pattern. If signrest=NULL,
the frequency of bootstrapped covariance decompositions that hold the same sign pattern as the point estimate is provided.</p>
</td></tr>
<tr><td><code>sign_part</code></td>
<td>
<p>Frequency of single shocks in all bootstrapped covariance decompositions which accord to a specific predetermined sign pattern</p>
</td></tr>
<tr><td><code>cov_bs</code></td>
<td>
<p>Covariance matrix of bootstrapped parameter in impact relations matrix</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Used bootstrap method</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Brueggemann, R., Jentsch, C., and Trenkler, C., 2016. Inference in VARs with conditional heteroskedasticity of unknown form. Journal of Econometrics 191, 69-85.<br />
Herwartz, H., 2017. Hodges Lehmann detection of structural shocks -
An analysis of macroeconomic dynamics in the Euro Area, Oxford Bulletin of Economics and Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.dc">id.dc</a></code>, <code><a href="#topic+id.ngml">id.ngml</a></code>, <code><a href="#topic+id.garch">id.garch</a></code>, <code><a href="#topic+id.cv">id.cv</a></code> or <code><a href="#topic+id.st">id.st</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data contains quarterly observations from 1965Q1 to 2008Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.dc(v1)
summary(x1)

# impulse response analysis with confidence bands
# Checking how often theory based impact relations appear
signrest &lt;- list(demand = c(1,1,1), supply = c(-1,1,1), money = c(-1,-1,1))
bb &lt;- mb.boot(x1, b.length = 15, nboot = 500, n.ahead = 30, nc = 1, signrest = signrest)
summary(bb)

# Plotting IRFs with confidance bands
plot(bb, lowerq = 0.16, upperq = 0.84)

# With different confidence levels
plot(bb, lowerq = c(0.05, 0.1, 0.16), upperq = c(0.95, 0.9, 0.84))

# Halls percentile
plot(bb, lowerq = 0.16, upperq = 0.84, percentile = 'hall')

# Bonferroni bands
plot(bb, lowerq = 0.16, upperq = 0.84, percentile = 'bonferroni')


</code></pre>

<hr>
<h2 id='stability'>Structural stability of a VAR(p)</h2><span id='topic+stability'></span><span id='topic+stability.varest'></span>

<h3>Description</h3>

<p>Computes an empirical fluctuation process according to a specified
method from the generalized fluctuation test framework. The test
utilises the function <code>efp()</code> and its methods from
package &lsquo;<code>strucchange</code>&rsquo;. Additionally, the function provides the option to
compute a multivariate chow test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
stability(
  x,
  type = c("OLS-CUSUM", "Rec-CUSUM", "Rec-MOSUM", "OLS-MOSUM", "RE", "ME", "Score-CUSUM",
    "Score-MOSUM", "fluctuation", "mv-chow-test"),
  h = 0.15,
  dynamic = FALSE,
  rescale = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stability_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by <code>VAR()</code>.</p>
</td></tr>
<tr><td><code id="stability_+3A_type">type</code></td>
<td>
<p>Specifies which type of fluctuation process will be computed, the default is &lsquo;<code>OLS-CUSUM</code>&rsquo;.
For details see:<code><a href="strucchange.html#topic+efp">efp</a></code> and <code><a href="#topic+chow.test">chow.test</a></code>.</p>
</td></tr>
<tr><td><code id="stability_+3A_h">h</code></td>
<td>
<p>A numeric from interval (0,1) specifying the bandwidth. Determines the size of the data window
relative to sample size (for &lsquo;<code>MOSUM</code>&rsquo;, &lsquo;<code>ME</code>&rsquo; and &lsquo;<code>mv-chow-test</code>&rsquo; only).</p>
</td></tr>
<tr><td><code id="stability_+3A_dynamic">dynamic</code></td>
<td>
<p>Logical. If &lsquo;<code>TRUE</code>&rsquo; the lagged observations are included as a regressor
(not if  &lsquo;<code>type</code>&rsquo; is &lsquo;<code>mv-chow-test</code>&rsquo;).</p>
</td></tr>
<tr><td><code id="stability_+3A_rescale">rescale</code></td>
<td>
<p>Logical. If &lsquo;<code>TRUE</code>&rsquo; the estimates will be standardized by the regressor matrix of the corresponding subsample;
if &lsquo;<code>FALSE</code>&rsquo; the whole regressor matrix will be used. (only if &lsquo;<code>type</code>&rsquo; is either &lsquo;<code>RE</code>&rsquo; or
&lsquo;<code>E</code>&rsquo;).</p>
</td></tr>
<tr><td><code id="stability_+3A_...">...</code></td>
<td>
<p>Ellipsis, is passed to <code>strucchange::sctest()</code>, as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details, please refer to documentation <code><a href="strucchange.html#topic+efp">efp</a></code> and <code><a href="#topic+chow.test">chow.test</a></code>.
</p>


<h3>Value</h3>

<p>A list with either class attribute &lsquo;<code>varstabil</code>&rsquo; or &lsquo;<code>chowpretest</code>&rsquo; holding the following elements
in case of class &lsquo;<code>varstabil</code>&rsquo;:
</p>
<table role = "presentation">
<tr><td><code>stability</code></td>
<td>
<p>A list with objects of class &lsquo;<code>efp</code>&rsquo;; length is equal to the dimension of the VAR.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>Character vector containing the names of the endogenous variables.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>An integer of the VAR dimension.</p>
</td></tr>
</table>
<p>In case of class &lsquo;<code>chowpretest</code>&rsquo; the list consists of the following elements:
</p>
<table role = "presentation">
<tr><td><code>teststat_bp</code></td>
<td>
<p>A vector containing the calculated break point test statistics for all considered break points.</p>
</td></tr>
<tr><td><code>teststat_sp</code></td>
<td>
<p>A vector containing the calculated sample split test statistics for all considered sample splits.</p>
</td></tr>
<tr><td><code>from</code></td>
<td>
<p>An integer sepcifying the first observation as possible break date.</p>
</td></tr>
<tr><td><code>to</code></td>
<td>
<p>An integer sepcifying the last observation as possible break date.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>A list with objects of class &lsquo;<code>varest</code>&rsquo;</p>
</td></tr>
<tr><td><code>break_point</code></td>
<td>
<p>Logical, if the break point test should be the benchmark for later analysis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff, Alexander Lange, Bernhard Dalheimer, Simone Maxand, Helmut Herwartz
</p>


<h3>References</h3>

<p>Zeileis, A., F. Leisch, K. Hornik and C. Kleiber (2002), strucchange: An R Package for Testing for Structural Change in Linear Regression
Models, <em>Journal of Statistical Software</em>, <b>7(2)</b>: 1-38, <a href="https://doi.org/10.18637/jss.v007.i02">doi:10.18637/jss.v007.i02</a><br />
</p>
<p>and see the references provided in the reference section of <code><a href="strucchange.html#topic+efp">efp</a></code> and <code><a href="#topic+chow.test">chow.test</a></code>, too.
</p>


<h3>See Also</h3>

<p><code><a href="vars.html#topic+VAR">VAR</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="strucchange.html#topic+efp">efp</a></code>, <code><a href="#topic+chow.test">chow.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
var.2c.stabil &lt;- stability(var.2c, type = "OLS-CUSUM")
var.2c.stabil
plot(var.2c.stabil)

data(USA)
v1 &lt;- VAR(USA, p = 6)
x1 &lt;- stability(v1, type = "mv-chow-test")
plot(x1)


</code></pre>

<hr>
<h2 id='svars'>svars: Data-driven identification of structural VAR models</h2><span id='topic+svars'></span>

<h3>Description</h3>

<p>This package implements data-driven identification methods for structural vector autoregressive (SVAR) models as described in Lange et al. (2021) <a href="https://doi.org/10.18637/jss.v097.i05">doi:10.18637/jss.v097.i05</a>.
Based on an existing VAR model object, the structural impact matrix B may be obtained
via different forms of heteroskedasticity or independent components.<br />
</p>


<h3>Details</h3>

<p>The main functions to retrieve structural impact matrices are:
</p>

<ul>
<li> 
<table>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+id.cv">id.cv</a></code> </td><td style="text-align: left;"> Identification via changes in volatility,</td>
</tr>

</table>

</li>
<li> 
<table>
<tr>
 <td style="text-align: left;"><code><a href="#topic+id.cvm">id.cvm</a></code> </td><td style="text-align: left;"> Independence-based identification of SVAR models
based on Cramer-von Mises distance,</td>
</tr>

</table>

</li>
<li> 
<table>
<tr>
 <td style="text-align: left;"><code><a href="#topic+id.dc">id.dc</a></code> </td><td style="text-align: left;"> Independence-based identification of SVAR models
based on distance covariances,</td>
</tr>

</table>

</li>
<li> 
<table>
<tr>
 <td style="text-align: left;"><code><a href="#topic+id.garch">id.garch</a></code> </td><td style="text-align: left;"> Identification through patterns of conditional heteroskedasticity,</td>
</tr>

</table>

</li>
<li> 
<table>
<tr>
 <td style="text-align: left;"><code><a href="#topic+id.ngml">id.ngml</a></code> </td><td style="text-align: left;"> Identification via Non-Gaussian maximum likelihood,</td>
</tr>

</table>

</li>
<li> 
<table>
<tr>
 <td style="text-align: left;"><code><a href="#topic+id.st">id.st</a></code> </td><td style="text-align: left;"> Identification by means of smooth transition in covariance.</td>
</tr>

</table>

</li></ul>

<p>All of these functions require an estimated var object. Currently the classes 'vars' and 'vec2var' from the <code>vars</code> package,
'nlVar', which includes both VAR and VECM, from the <code>tsDyn</code> package as well as the list from <code>MTS</code> package are supported.
Besides these core functions, additional tools to calculate confidence bands for impulse response functions using
bootstrap techniques as well as the Chow-Test for structural changes are implemented. The <code>USA</code> dataset is used to showcase the
functionalities in examples throughout the package.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Alexander Lange <a href="mailto:alexander.lange@uni-goettingen.de">alexander.lange@uni-goettingen.de</a>
</p>
</li>
<li><p> Bernhard Dalheimer <a href="mailto:bernhard.dalheimer@uni-goettingen.de">bernhard.dalheimer@uni-goettingen.de</a>
</p>
</li>
<li><p> Helmut Herwartz <a href="mailto:hherwartz@uni-goettingen.de">hherwartz@uni-goettingen.de</a>
</p>
</li>
<li><p> Simone Maxand   <a href="mailto:simone.maxand@helsinki.fi">simone.maxand@helsinki.fi</a>
</p>
</li></ul>


<hr>
<h2 id='USA'>US macroeconomic time series</h2><span id='topic+USA'></span>

<h3>Description</h3>

<p>The time series of output gap (x), inflation (pi) and interest rate (r) are taken from the FRED database and transformed as in Herwartz &amp; Ploedt (2016). The trivariate time series model is commonly used to analyze monetary policy shocks.
<br />
Quarterly observations from 1965Q1 to 2008Q3:
</p>

<table>
<tr>
 <td style="text-align: left;">
    x </td><td style="text-align: left;"> Percentage log-deviation of real GDP wrt the estimate of potential output by the Congressional Budget Office </td>
</tr>
<tr>
 <td style="text-align: left;">
    pi </td><td style="text-align: left;"> Annualized quarter-on-quarter growth of the GDP deflator </td>
</tr>
<tr>
 <td style="text-align: left;">
    i </td><td style="text-align: left;"> Interest rate on Federal funds </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>A more detailed description of the data and a corresponding VAR model implementation can be found in Herwartz &amp; Ploedt (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USA</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> containing 174 observations on 3 variables.</p>


<h3>Source</h3>

<p>Herwartz, H. &amp; Ploedt, M., 2016. Simulation Evidence on Theory-based and Statistical Identification under Volatility Breaks, Oxford Bulletin of Economics and Statistics, 78, 94-112. <br />
Data originally from FRED database of the Federal Reserve Bank of St. Louis.</p>

<hr>
<h2 id='wild.boot'>Wild bootstrap for IRFs of identified SVARs</h2><span id='topic+wild.boot'></span>

<h3>Description</h3>

<p>Calculating confidence bands for impulse response functions via wild bootstrap techniques (Goncalves and Kilian, 2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wild.boot(
  x,
  design = "fixed",
  distr = "rademacher",
  n.ahead = 20,
  nboot = 500,
  nc = 1,
  dd = NULL,
  signrest = NULL,
  signcheck = TRUE,
  itermax = 300,
  steptol = 200,
  iter2 = 50,
  rademacher = "deprecated"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wild.boot_+3A_x">x</code></td>
<td>
<p>SVAR object of class &quot;svars&quot;</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_design">design</code></td>
<td>
<p>character. If design=&quot;fixed&quot;, a fixed design bootstrap is performed. If design=&quot;recursive&quot;, a recursive design bootstrap is performed.</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_distr">distr</code></td>
<td>
<p>character. If distr=&quot;rademacher&quot;, the Rademacher distribution is used to generate the bootstrap samples. If
distr=&quot;mammen&quot;, the Mammen distribution is used. If distr = &quot;gaussian&quot;, the gaussian distribution is used.</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_nboot">nboot</code></td>
<td>
<p>Integer. Number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_nc">nc</code></td>
<td>
<p>Integer. Number of processor cores</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_dd">dd</code></td>
<td>
<p>Object of class 'indepTestDist'. A simulated independent sample of the same size as the data.
roxIf not supplied, it will be calculated by the function</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_signrest">signrest</code></td>
<td>
<p>A list with vectors containing 1 and -1, e.g. c(1,-1,1), indicating a sign pattern of specific shocks to be tested
with the help of the bootstrap samples.</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_signcheck">signcheck</code></td>
<td>
<p>Boolean. Whether the sign pattern should be checked for each bootstrap iteration.
Note that this procedure is computationally extremely demanding for high dimensional VARs, since the number of possible permutations of B is K!,
where K is the number of variables in the VAR.</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_itermax">itermax</code></td>
<td>
<p>Integer. Maximum number of iterations for DEoptim</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_steptol">steptol</code></td>
<td>
<p>Integer. Tolerance for steps without improvement for DEoptim</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_iter2">iter2</code></td>
<td>
<p>Integer. Number of iterations for the second optimization</p>
</td></tr>
<tr><td><code id="wild.boot_+3A_rademacher">rademacher</code></td>
<td>
<p>deprecated, use &quot;design&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;sboot&quot; with elements
</p>
<table role = "presentation">
<tr><td><code>true</code></td>
<td>
<p>Point estimate of impulse response functions</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>List of length &quot;nboot&quot; holding bootstrap impulse response functions</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>Bootstrapped standard errors of estimated covariance decomposition
(only if &quot;x&quot; has method &quot;Cramer von-Mises&quot;, or &quot;Distance covariances&quot;)</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code>distr</code></td>
<td>
<p>Character, whether the Gaussian, Rademacher or Mammen distribution is used in the bootstrap</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>character. Whether a fixed design or recursive design bootstrap is performed</p>
</td></tr>
<tr><td><code>point_estimate</code></td>
<td>
<p>Point estimate of covariance decomposition</p>
</td></tr>
<tr><td><code>boot_mean</code></td>
<td>
<p>Mean of bootstrapped covariance decompositions</p>
</td></tr>
<tr><td><code>signrest</code></td>
<td>
<p>Evaluated sign pattern</p>
</td></tr>
<tr><td><code>sign_complete</code></td>
<td>
<p>Frequency of appearance of the complete sign pattern in all bootstrapped covariance decompositions</p>
</td></tr>
<tr><td><code>sign_part</code></td>
<td>
<p>Frequency of bootstrapped covariance decompositions which conform the complete predetermined sign pattern. If signrest=NULL,
the frequency of bootstrapped covariance decompositions that hold the same sign pattern as the point estimate is provided.</p>
</td></tr>
<tr><td><code>sign_part</code></td>
<td>
<p>Frequency of single shocks in all bootstrapped covariance decompositions which accord to a specific predetermined sign pattern</p>
</td></tr>
<tr><td><code>cov_bs</code></td>
<td>
<p>Covariance matrix of bootstrapped parameter in impact relations matrix</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Used bootstrap method</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>Estimated input VAR object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Goncalves, S., Kilian, L., 2004. Bootstrapping autoregressions with conditional heteroskedasticity of unknown form. Journal of Econometrics 123, 89-120.<br />
Herwartz, H., 2017. Hodges Lehmann detection of structural shocks -
An analysis of macroeconomic dynamics in the Euro Area, Oxford Bulletin of Economics and Statistics
</p>


<h3>See Also</h3>

<p><code><a href="#topic+id.cvm">id.cvm</a></code>, <code><a href="#topic+id.dc">id.dc</a></code>, <code><a href="#topic+id.garch">id.garch</a></code>, <code><a href="#topic+id.ngml">id.ngml</a></code>, <code><a href="#topic+id.cv">id.cv</a></code> or <code><a href="#topic+id.st">id.st</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data contains quarterly observations from 1965Q1 to 2008Q3
# x = output gap
# pi = inflation
# i = interest rates
set.seed(23211)
v1 &lt;- vars::VAR(USA, lag.max = 10, ic = "AIC" )
x1 &lt;- id.dc(v1)
summary(x1)

# impulse response analysis with confidence bands
# Checking how often theory based impact relations appear
signrest &lt;- list(demand = c(1,1,1), supply = c(-1,1,1), money = c(-1,-1,1))
bb &lt;- wild.boot(x1, nboot = 500, n.ahead = 30, nc = 1, signrest = signrest)
summary(bb)

# Plotting IRFs with confidance bands
plot(bb, lowerq = 0.16, upperq = 0.84)

# With different confidence levels
plot(bb, lowerq = c(0.05, 0.1, 0.16), upperq = c(0.95, 0.9, 0.84))

# Halls percentile
plot(bb, lowerq = 0.16, upperq = 0.84, percentile = 'hall')

# Bonferroni bands
plot(bb, lowerq = 0.16, upperq = 0.84, percentile = 'bonferroni')



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
