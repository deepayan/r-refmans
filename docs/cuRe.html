<!DOCTYPE html><html><head><title>Help for package cuRe</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cuRe}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC.cm'><p>Akaike information criterion</p></a></li>
<li><a href='#AIC.gfcm'><p>Akaike information criterion</p></a></li>
<li><a href='#BIC.cm'><p>Bayesian information criterion</p></a></li>
<li><a href='#BIC.gfcm'><p>Bayesian information criterion</p></a></li>
<li><a href='#bsx'><p>Polynomial B-splines with eXtensions</p></a></li>
<li><a href='#calc.Crude'><p>Crude event probabilities</p></a></li>
<li><a href='#calc.Crude.quantile'><p>Compute the time to statistical cure using the conditional probability of disease-related death</p></a></li>
<li><a href='#calc.cure.quantile'><p>Compute the time to statistical cure using the conditional probability of cure</p></a></li>
<li><a href='#calc.LL'><p>Loss of lifetime estimation</p></a></li>
<li><a href='#calc.LL.quantile'><p>Compute the time to statistical cure using the loss of lifetime function</p></a></li>
<li><a href='#cb'><p>Restricted cubic splines</p></a></li>
<li><a href='#cbc'><p>Restricted cubic splines with cure</p></a></li>
<li><a href='#colonDC'><p>Colon cancer data</p></a></li>
<li><a href='#fit.cure.model'><p>Parametric cure model</p></a></li>
<li><a href='#general.haz'><p>Extract general population hazard</p></a></li>
<li><a href='#GenFlexCureModel'><p>Fit generalized mixture cure model</p></a></li>
<li><a href='#lrtest'><p>Likelihood ratio tests for comparing nested cure models</p></a></li>
<li><a href='#lts'><p>Long term survival predictions</p></a></li>
<li><a href='#plot.crude'><p>Plot crude event probabilities</p></a></li>
<li><a href='#plot.cuRe'><p>Plot function for Flexible mixture cure model</p></a></li>
<li><a href='#plot.le'><p>Plot the loss of lifetime function</p></a></li>
<li><a href='#plot.lts'><p>Plot the long term survival</p></a></li>
<li><a href='#predict.cm'><p>Predict function for flexible mixture cure model</p></a></li>
<li><a href='#predict.gfcm'><p>Predict function for flexible mixture cure model</p></a></li>
<li><a href='#survexp.dk'><p>Ratetable of the Danish general population</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parametric Cure Model Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lasse Hjort Jakobsen &lt;hjort9230@hotmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions for estimating generalized parametric mixture and non-mixture cure models &lt;<a href="https://doi.org/10.1016%2Fj.cmpb.2022.107125">doi:10.1016/j.cmpb.2022.107125</a>&gt;, loss of lifetime, mean residual lifetime, and crude event probabilities.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LasseHjort/cuRe">https://github.com/LasseHjort/cuRe</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LasseHjort/cuRe/issues">https://github.com/LasseHjort/cuRe/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), survival, rstpm2, date</td>
</tr>
<tr>
<td>Imports:</td>
<td>numDeriv, statmod, relsurv, reshape2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>Yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-03 05:29:52 UTC; hjort</td>
</tr>
<tr>
<td>Author:</td>
<td>Lasse Hjort Jakobsen [aut, cre],
  Mark Clements [cph],
  Rasmus Kuhr Jensen [ctb],
  Lars Klingen Gjærde [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-03 06:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC.cm'>Akaike information criterion</h2><span id='topic+AIC.cm'></span>

<h3>Description</h3>

<p>This function computes the AIC for a fitted parametric cure model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cm'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.cm_+3A_object">object</code></td>
<td>
<p>Object of class cm or gfcm.</p>
</td></tr>
<tr><td><code id="AIC.cm_+3A_...">...</code></td>
<td>
<p>Additionally arguments. Not currently used</p>
</td></tr>
<tr><td><code id="AIC.cm_+3A_k">k</code></td>
<td>
<p>Number to control if either AIC or BIC is to be computed (default is 2 equal to AIC).</p>
</td></tr>
</table>

<hr>
<h2 id='AIC.gfcm'>Akaike information criterion</h2><span id='topic+AIC.gfcm'></span>

<h3>Description</h3>

<p>This function computes the AIC for a fitted parametric cure model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gfcm'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.gfcm_+3A_object">object</code></td>
<td>
<p>Object of class cm or gfcm.</p>
</td></tr>
<tr><td><code id="AIC.gfcm_+3A_...">...</code></td>
<td>
<p>Additionally arguments. Not currently used</p>
</td></tr>
<tr><td><code id="AIC.gfcm_+3A_k">k</code></td>
<td>
<p>Number to control if either AIC or BIC is to be computed (default is 2 equal to AIC).</p>
</td></tr>
</table>

<hr>
<h2 id='BIC.cm'>Bayesian information criterion</h2><span id='topic+BIC.cm'></span>

<h3>Description</h3>

<p>This function computes the BIC for a fitted parametric cure model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cm'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.cm_+3A_object">object</code></td>
<td>
<p>Object of class cm or gfcm.</p>
</td></tr>
<tr><td><code id="BIC.cm_+3A_...">...</code></td>
<td>
<p>Some methods for this generic function may take additional, optional arguments. At present none do.</p>
</td></tr>
</table>

<hr>
<h2 id='BIC.gfcm'>Bayesian information criterion</h2><span id='topic+BIC.gfcm'></span>

<h3>Description</h3>

<p>This function computes the BIC for a fitted parametric cure model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gfcm'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.gfcm_+3A_object">object</code></td>
<td>
<p>Object of class cm or gfcm.</p>
</td></tr>
<tr><td><code id="BIC.gfcm_+3A_...">...</code></td>
<td>
<p>Some methods for this generic function may take additional, optional arguments. At present none do.</p>
</td></tr>
</table>

<hr>
<h2 id='bsx'>Polynomial B-splines with eXtensions</h2><span id='topic+bsx'></span>

<h3>Description</h3>

<p>Generate the B-spline basis matrix for a polynomial spline with derivative restrictions at the boundary knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsx(
  x,
  df = NULL,
  knots = NULL,
  degree = 3,
  intercept = FALSE,
  Boundary.knots = range(x),
  deriv = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsx_+3A_x">x</code></td>
<td>
<p>the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="bsx_+3A_df">df</code></td>
<td>
<p>degrees of freedom; one can specify <code>df</code> rather than knots; <code>bs()</code> then chooses
<code>df</code>-<code>degree</code> (minus one if there is an intercept) knots at suitable quantiles of <code>x</code>
(which will ignore missing values). The default, <code>NULL</code>, corresponds to no inner knots,
i.e., <code>degree</code>-<code>intercept</code>.</p>
</td></tr>
<tr><td><code id="bsx_+3A_knots">knots</code></td>
<td>
<p>the internal breakpoints that define the spline. The default is <code>NULL</code>, which results
in a basis for ordinary polynomial regression. Typical values are the mean or median for one knot,
quantiles for more knots. See also <code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="bsx_+3A_degree">degree</code></td>
<td>
<p>degree of the piecewise polynomial—default is <code>3</code> for cubic splines.</p>
</td></tr>
<tr><td><code id="bsx_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, an intercept is included in the basis; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bsx_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to anchor the B-spline basis (default the range of the non-NA data).
If both <code>knots</code> and <code>Boundary.knots</code> are supplied, the basis parameters do not depend on <code>x</code>.
Data can extend beyond <code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="bsx_+3A_deriv">deriv</code></td>
<td>
<p>an integer vector of length 2 with values between 0 and <code>degree + 1</code> giving the
derivative constraint order at the left and right boundary knots;
an order of 2 constrains the second derivative to zero (f”(x)=0);
an order of 1 constrains the first and second derivatives to zero (f'(x)=f”(x)=0);
an order of 0 constrains the zero, first and second derivatives to zero (f(x)=f'(x)=f”(x)=0)
An order of <code>degree + 1</code> computes the basis matrix similarly to <code>bs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with containing the basis functions evaluated in <code>x</code>.
</p>

<hr>
<h2 id='calc.Crude'>Crude event probabilities</h2><span id='topic+calc.Crude'></span>

<h3>Description</h3>

<p>Function for computing crude event probabilties based on relative survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.Crude(
  object,
  newdata = NULL,
  type = c("disease", "other", "condother"),
  time = NULL,
  tau = 100,
  reverse = FALSE,
  var.type = c("ci", "se", "n"),
  exp.fun = NULL,
  ratetable = cuRe::survexp.dk,
  rmap,
  scale = ayear,
  smooth.exp = FALSE,
  pars = NULL,
  link = "loglog",
  n = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.Crude_+3A_object">object</code></td>
<td>
<p>Fitted model to do predictions from. Possible classes are
<code>gfcm</code>, <code>cm</code>, <code>stpm2</code>, and <code>pstpm2</code>.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_newdata">newdata</code></td>
<td>
<p>Data frame from which to compute predictions. If empty, predictions are made on the the data which
the model was fitted on.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_type">type</code></td>
<td>
<p>Probability to compute. Possible values are <code>disease</code> (default),
<code>other</code>, and <code>condother</code> (see details).</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_time">time</code></td>
<td>
<p>Time points at which to compute predictions. If empty, a grid of 100 time points between 0
and <code>tau</code> is selected.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_tau">tau</code></td>
<td>
<p>Upper bound of the integral used to compute the probability of disease-related death (see details).
The argument is only used for <code>type = condother</code>. Default is 100.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_reverse">reverse</code></td>
<td>
<p>Logical. If <code>TRUE</code>, 1 - probability is provided (default is <code>FALSE</code>).
Only applicable for <code>type = condother</code>.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_var.type">var.type</code></td>
<td>
<p>Character. Possible values are &quot;<code>ci</code>&quot; (default) for confidence intervals,
&quot;<code>se</code>&quot; for standard errors, and &quot;<code>n</code>&quot; for neither.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_exp.fun">exp.fun</code></td>
<td>
<p>Object of class <code>list</code> containing functions for the expected survival
of each row in <code>newdata</code>. If not specified, the function computes the expected
survival based on <code>newdata</code> using the <code>survival::survexp</code> function. If <code>newdata</code> is not provided,
the expected survival is based on the data which the model was fitted on.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_ratetable">ratetable</code></td>
<td>
<p>Object of class <code>ratetable</code> used to compute the general population survival.
Default is <code>survexp.dk</code>.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_rmap">rmap</code></td>
<td>
<p>List to be passed to <code>survexp</code> from the <code>survival</code> package if <code>exp.fun = NULL</code>.
Detailed documentation on this argument can be found by <code>?survexp</code>.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_scale">scale</code></td>
<td>
<p>Numeric. Passed to the <code>survival::survexp</code> function and defaults to 365.24.
That is, the time scale is assumed to be in years.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_smooth.exp">smooth.exp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the general population survival function is smoothed by the function
<code>smooth.spline</code> using the the argument <code>all.knots = TRUE</code>.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_pars">pars</code></td>
<td>
<p>A vector of parameter values for the model given in <code>object</code>. Currently not used.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_link">link</code></td>
<td>
<p>Link function for computing variance in order to restrict confidence intervals to [0, 1].
Default is <code>loglog</code>.</p>
</td></tr>
<tr><td><code id="calc.Crude_+3A_n">n</code></td>
<td>
<p>Number of knots used for the Gauss-Legendre quadrature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates crude probabilities by using the relative survival, expected survival,
and the cause-specific hazard function.
The crude cumulative incidence of disease-related death (<code>type = "disease"</code>) is
</p>
<p style="text-align: center;"><code class="reqn">P(T \leq t, D = disease) = \int_0^t S^*(u) R(u) \lambda(u)du.</code>
</p>

<p>The crude cumulative incidence of death from other causes (<code>type = "other"</code>) is
</p>
<p style="text-align: center;"><code class="reqn">P(T \leq t, D = other) = \int_0^t S^*(u) R(u) h^*(u)du.</code>
</p>

<p>The conditional probability of eventually dying from other causes than disease (<code>type = "condother"</code>) is
</p>
<p style="text-align: center;"><code class="reqn">P(D = other| T &gt; t) = \frac{P(D = disease) - P(T \leq t, D = disease)}{P(T &gt; t)}.</code>
</p>

<p>The probability of disease-related death, P(D = disease),
can be computed by using <code>type = "disease"</code> and choosing a sufficiently large time point.
For P(D = other| T&gt;t), the argument <code>tau</code> controls this time point (default is 100).
</p>


<h3>Value</h3>

<p>A list containing the crude probability estimates
of each individual in <code>newdata</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Use data cleaned version of the colon disease data from the rstpm2 package
data("colonDC")
set.seed(2)
colonDC &lt;- colonDC[sample(1:nrow(colonDC), 1000), ]

##Extract general population hazards
colonDC$bhaz &lt;- general.haz(time = "FU", rmap = list(age = "agedays", sex = "sex", year= "dx"),
                            data = colonDC, ratetable = survexp.dk)

##Spline-base cure model
#Fit cure model
fit &lt;- rstpm2::stpm2(Surv(FUyear, status) ~ 1, data = colonDC, df = 6,
                     bhazard = colonDC$bhaz, cure = TRUE)

#Compute the probability of disease-related death
res &lt;- calc.Crude(fit, time = seq(0, 20, length.out = 50),
                  rmap = list(age = agedays, sex = sex, year = dx),
                  var.type = "n")
plot(res)

#Compute the conditional probability of dying from other causes than disease
res &lt;- calc.Crude(fit, time = seq(0, 20, length.out = 50), type = "condother",
                  rmap = list(age = agedays, sex = sex, year = dx), var.type = "n")
plot(res)


#Simple parametric cure model
#Fit cure model
fit &lt;- fit.cure.model(Surv(FUyear, status) ~ 1, data = colonDC, bhazard = "bhaz",
                      type = "mixture", dist = "weibull", link = "logit")

#Compute the probability of disease-related death
res &lt;- calc.Crude(fit, time = seq(0, 20, length.out = 50),
                  rmap = list(age = agedays, sex = sex, year = dx),
                  var.type = "n")
plot(res)

#Compute the conditional probability of disease-related death
res2 &lt;- calc.Crude(fit, time = seq(0, 20, length.out = 50), type = "condother",
                  rmap = list(age = agedays, sex = sex, year = dx), reverse = TRUE,
                  var.type = "n")
plot(res2)
</code></pre>

<hr>
<h2 id='calc.Crude.quantile'>Compute the time to statistical cure using the conditional probability of disease-related death</h2><span id='topic+calc.Crude.quantile'></span>

<h3>Description</h3>

<p>The following function estimates the time to statistical cure using the conditional
probability of disease-related death.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.Crude.quantile(
  fit,
  q = 0.05,
  newdata = NULL,
  max.time = 20,
  exp.fun = NULL,
  var.type = c("ci", "se", "n"),
  rmap,
  ratetable = cuRe::survexp.dk,
  tau = 100,
  reverse = TRUE,
  scale = ayear
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.Crude.quantile_+3A_fit">fit</code></td>
<td>
<p>Fitted model to do predictions from. Possible classes are
<code>gfmc</code>, <code>cm</code>, <code>stpm2</code>, and <code>pstpm2</code>.</p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_q">q</code></td>
<td>
<p>Threshold to estimate statistical cure according to.</p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_newdata">newdata</code></td>
<td>
<p>Data frame from which to compute predictions. If empty, predictions are made on the the data which
the model was fitted on.</p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_max.time">max.time</code></td>
<td>
<p>Upper boundary of the interval [0, <code>max.time</code>] in which to search for solution (see details).
Default is 20.</p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_exp.fun">exp.fun</code></td>
<td>
<p>Object of class <code>list</code> containing functions for the expected survival
of each row in <code>newdata</code>. If not specified, the function computes the expected
survival based on <code>newdata</code> using the <code>survival::survexp</code> function. If <code>newdata</code> is not provided,
the expected survival is based on the data which the model was fitted on.</p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_var.type">var.type</code></td>
<td>
<p>Character. Possible values are &quot;<code>ci</code>&quot; (default) for confidence intervals,
&quot;<code>se</code>&quot; for standard errors, and &quot;<code>n</code>&quot; for neither.</p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_rmap">rmap</code></td>
<td>
<p>List to be passed to <code>survexp</code> from the <code>survival</code> package if <code>exp.fun = NULL</code>.
Detailed documentation on this argument can be found by <code>?survexp</code>.</p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_ratetable">ratetable</code></td>
<td>
<p>Object of class <code>ratetable</code> used to compute the general population survival.
Default is <code>survexp.dk</code></p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_tau">tau</code></td>
<td>
<p>Upper bound of integral (see ?calc.Crude). Default is 100.</p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_reverse">reverse</code></td>
<td>
<p>Logical passed on to <code>calc.Crude</code>. If <code>TRUE</code> (default), 1 - probability is provided.
Only applicable for <code>type = condother</code>.</p>
</td></tr>
<tr><td><code id="calc.Crude.quantile_+3A_scale">scale</code></td>
<td>
<p>Numeric. Passed to the <code>survival::survexp</code> function and defaults to 365.24.
That is, the time scale is assumed to be in years.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cure point is calculated as the time point at which the conditional probability of disease-related
death reaches the threshold, <code>q</code>. If <code>q</code> is not reached within <code>max.time</code>, no solution is reported.
</p>


<h3>Value</h3>

<p>The estimated cure point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Use data cleaned version of the colon cancer data from the rstpm2 package
data("colonDC")
set.seed(2)
colonDC &lt;- colonDC[sample(1:nrow(colonDC), 500), ]

##Extract general population hazards
colonDC$bhaz &lt;- general.haz(time = "FU", rmap = list(age = "agedays", sex = "sex", year= "dx"),
                            data = colonDC, ratetable = survexp.dk)

#Fit cure model and estimate cure point
fit &lt;- rstpm2::stpm2(Surv(FUyear, status) ~ 1, data = colonDC, df = 6,
                     bhazard = colonDC$bhaz, cure = TRUE)
cp &lt;- calc.Crude.quantile(fit, q = 0.05,
                          rmap = list(age = agedays, sex = sex, year = dx))

#Compare the result with the trajectory of the conditional probability of disease-related death
res &lt;- calc.Crude(fit, type = "condother", time = seq(0, 20, length.out = 100),
                  var.type = "n",
                  rmap = list(age = agedays, sex = sex, year = dx), reverse = TRUE)
plot(res)
abline(h = 0.05, v = cp$Estimate)

</code></pre>

<hr>
<h2 id='calc.cure.quantile'>Compute the time to statistical cure using the conditional probability of cure</h2><span id='topic+calc.cure.quantile'></span>

<h3>Description</h3>

<p>The following function estimates the time to statistical cure using the
conditional probability of cure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.cure.quantile(
  fit,
  q = 0.05,
  newdata = NULL,
  max.time = 20,
  var.type = c("ci", "n"),
  reverse = TRUE,
  bdr.knot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.cure.quantile_+3A_fit">fit</code></td>
<td>
<p>Fitted model to do predictions from. Possible classes are
<code>gfcm</code>, <code>cm</code>, and <code>stpm2</code>.</p>
</td></tr>
<tr><td><code id="calc.cure.quantile_+3A_q">q</code></td>
<td>
<p>Threshold to estimate statistical cure according to.</p>
</td></tr>
<tr><td><code id="calc.cure.quantile_+3A_newdata">newdata</code></td>
<td>
<p>Data frame from which to compute predictions. If empty, predictions are made on the the data which
the model was fitted on.</p>
</td></tr>
<tr><td><code id="calc.cure.quantile_+3A_max.time">max.time</code></td>
<td>
<p>Upper boundary of the interval [0, <code>max.time</code>] in which to search for solution (see details).
Default is 20.</p>
</td></tr>
<tr><td><code id="calc.cure.quantile_+3A_var.type">var.type</code></td>
<td>
<p>Character. Possible values are &quot;<code>ci</code>&quot; (default) for confidence intervals,
&quot;<code>se</code>&quot; for standard errors, and &quot;<code>n</code>&quot; for neither.</p>
</td></tr>
<tr><td><code id="calc.cure.quantile_+3A_reverse">reverse</code></td>
<td>
<p>Logical. Whether to use the conditional probability of not being cured (default) or
the conditional probability of cure.</p>
</td></tr>
<tr><td><code id="calc.cure.quantile_+3A_bdr.knot">bdr.knot</code></td>
<td>
<p>Time point from which cure is assumed. Only relevant for class <code>stpm2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cure point is calculated as the time point at which the conditional probability of disease-related
death reaches the threshold, <code>q</code>. If <code>q</code> is not reached within <code>max.time</code>, no solution is reported.
</p>


<h3>Value</h3>

<p>The estimated cure point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Use data cleaned version of the colon cancer data from the rstpm2 package
data("colonDC")
set.seed(2)
colonDC &lt;- colonDC[sample(1:nrow(colonDC), 1000), ]

##Extract general population hazards
colonDC$bhaz &lt;- general.haz(time = "FU", rmap = list(age = "agedays", sex = "sex", year= "dx"),
                            data = colonDC, ratetable = survexp.dk)

#Fit cure model and estimate cure point
fit &lt;- GenFlexCureModel(Surv(FUyear, status) ~ 1, data = colonDC,
                        df = 5, bhazard = "bhaz")
calc.cure.quantile(fit, q = 0.05)
</code></pre>

<hr>
<h2 id='calc.LL'>Loss of lifetime estimation</h2><span id='topic+calc.LL'></span>

<h3>Description</h3>

<p>Function for computing mean residual lifetime and loss of lifetime estimates based on relative survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.LL(
  object,
  newdata = NULL,
  type = c("ll", "mrl"),
  time = NULL,
  tau = 100,
  var.type = c("ci", "se", "n"),
  exp.fun = NULL,
  ratetable = cuRe::survexp.dk,
  rmap,
  smooth.exp = FALSE,
  scale = ayear,
  pars = NULL,
  n = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.LL_+3A_object">object</code></td>
<td>
<p>Fitted model to do predictions from. Possible classes are
<code>gfcm</code>, <code>cm</code>, <code>stpm2</code>, and <code>pstpm2</code>.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_newdata">newdata</code></td>
<td>
<p>Data frame from which to compute predictions. If empty, predictions are made on the the data which
the model was fitted on.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_type">type</code></td>
<td>
<p>Type of life expectation estimate.
Possible values are <code>ll</code> (default) which gives the loss of lifetime, and <code>mrl</code>
which gives the mean residual lifetime.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_time">time</code></td>
<td>
<p>Time points at which to compute predictions. If empty, a grid of 100 time points between 0
and <code>tau</code> is selected.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_tau">tau</code></td>
<td>
<p>The upper limit of the integral (see details). Default is 100.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_var.type">var.type</code></td>
<td>
<p>Character. Possible values are &quot;<code>ci</code>&quot; (default) for confidence intervals,
&quot;<code>se</code>&quot; for standard errors, and &quot;<code>n</code>&quot; for neither.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_exp.fun">exp.fun</code></td>
<td>
<p>Object of class <code>list</code> containing functions for the expected survival
of each row in <code>newdata</code>. If not specified, the function computes the expected
survival based on <code>newdata</code> using the <code>survival::survexp</code> function. If <code>newdata</code> is not provided,
the expected survival is based on the data which the model was fitted on.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_ratetable">ratetable</code></td>
<td>
<p>Object of class <code>ratetable</code> used to compute the general population survival.
Default is <code>survexp.dk</code>.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_rmap">rmap</code></td>
<td>
<p>List to be passed to <code>survexp</code> from the <code>survival</code> package if <code>exp.fun = NULL</code>.
Detailed documentation on this argument can be found by <code>?survexp</code>.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_smooth.exp">smooth.exp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the general population survival function is smoothed by the function
<code>smooth.spline</code> using the the argument <code>all.knots = TRUE</code>.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_scale">scale</code></td>
<td>
<p>Numeric. Passed to the <code>survival::survexp</code> function and defaults to 365.24.
That is, the time scale is assumed to be in years.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_pars">pars</code></td>
<td>
<p>A vector of parameter values for the model given in <code>object</code>. Currently not used.</p>
</td></tr>
<tr><td><code id="calc.LL_+3A_n">n</code></td>
<td>
<p>Number of knots used for the Gauss-Legendre quadrature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean residual lifetime function and loss of lifetime function are based on numerical
integration of the area under the observed and expected conditional survival functions.
If <code>type = "ll"</code>, the function computes
</p>
<p style="text-align: center;"><code class="reqn">\frac{\int_t^\infty S^*(u)}{S^*(t)} - \frac{\int_t^\infty S(u)}{S(t)}.</code>
</p>

<p>If <code>type = "mrl"</code>, the function computes
</p>
<p style="text-align: center;"><code class="reqn">\frac{\int_t^\infty S(u)}{S(t)},</code>
</p>

<p>for a given t. The function <code class="reqn">S^*(t)</code> is the general population survival function and <code class="reqn">S(t)</code>
is the observed survival function. Integration to infinity is not required in studies of human mortality,
so an upper limit, <code>tau</code>, is chosen instead. As most humans die before they 100 years, this is
the default setting of the function. The integral is computed by Gauss-Legendre quadrature
and the point wise variance is estimated using the delta method and numerical differentiation.
</p>


<h3>Value</h3>

<p>An object of class <code>le</code> containing the life expectancy estimates
of each individual in <code>newdata</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Use data cleaned version of the colon cancer data from the rstpm2 package
data("colonDC")
set.seed(2)
colonDC &lt;- colonDC[sample(1:nrow(colonDC), 1000), ]

##Extract general population hazards
colonDC$bhaz &lt;- general.haz(time = "FU", rmap = list(age = "agedays", sex = "sex", year= "dx"),
                            data = colonDC, ratetable = survexp.dk)

##Spline-base cure model
#Fit cure model
fit &lt;- rstpm2::stpm2(Surv(FUyear, status) ~ 1, data = colonDC,
                     df = 6, bhazard = colonDC$bhaz, cure = TRUE)

#Compute and plot the loss of lifetime function
res &lt;- calc.LL(fit, time = seq(0, 20, length.out = 50),
               rmap = list(age = agedays, sex = sex, year = dx),
               var.type = "n")
plot(res)

#Compute and plot the mean residual lifetime
res &lt;- calc.LL(fit, time = seq(0, 20, length.out = 50), type = "mrl",
               rmap = list(age = agedays, sex = sex, year = dx),
               var.type = "n")
plot(res)


#Simple parametric cure model
#Fit cure model
fit &lt;- fit.cure.model(Surv(FUyear, status) ~ 1, data = colonDC, bhazard = "bhaz",
                      type = "mixture", dist = "weibull", link = "logit")

#Compute and plot the loss of lifetime function
res &lt;- calc.LL(fit, time = seq(0, 20, length.out = 50),
               rmap = list(age = agedays, sex = sex, year = dx),
               var.type = "n")
plot(res)

#Compute and plot the mean residual lifetime
res &lt;- calc.LL(fit, time = seq(0, 20, length.out = 50), type = "mrl",
               rmap = list(age = agedays, sex = sex, year = dx),
               var.type = "n")
plot(res)

</code></pre>

<hr>
<h2 id='calc.LL.quantile'>Compute the time to statistical cure using the loss of lifetime function</h2><span id='topic+calc.LL.quantile'></span>

<h3>Description</h3>

<p>The following function estimates the time to statistical cure using the
loss of lifetime function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.LL.quantile(
  fit,
  q = 1,
  newdata = NULL,
  max.time = 20,
  var.type = c("ci", "n"),
  exp.fun = NULL,
  rmap = NULL,
  ratetable = cuRe::survexp.dk,
  tau = 100,
  type = "ll",
  scale = ayear
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.LL.quantile_+3A_fit">fit</code></td>
<td>
<p>Fitted model to do predictions from. Possible classes are
<code>gfcm</code>, <code>cm</code>, <code>stpm2</code>, and <code>pstpm2</code>.</p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_q">q</code></td>
<td>
<p>Threshold to estimate statistical cure according to.</p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_newdata">newdata</code></td>
<td>
<p>Data frame from which to compute predictions. If empty, predictions are made on the the data which
the model was fitted on.</p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_max.time">max.time</code></td>
<td>
<p>Upper boundary of the interval [0, <code>max.time</code>] in which to search for solution (see details).
Default is 20.</p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_var.type">var.type</code></td>
<td>
<p>Character. Possible values are &quot;<code>ci</code>&quot; (default) for confidence intervals,
&quot;<code>se</code>&quot; for standard errors, and &quot;<code>n</code>&quot; for neither.</p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_exp.fun">exp.fun</code></td>
<td>
<p>Object of class <code>list</code> containing functions for the expected survival
of each row in <code>newdata</code>. If not specified, the function computes the expected
survival based on <code>newdata</code> using the <code>survival::survexp</code> function. If <code>newdata</code> is not provided,
the expected survival is based on the data which the model was fitted on.</p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_rmap">rmap</code></td>
<td>
<p>List to be passed to <code>survexp</code> from the <code>survival</code> package if <code>exp.fun = NULL</code>.
Detailed documentation on this argument can be found by <code>?survexp</code>.</p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_ratetable">ratetable</code></td>
<td>
<p>Object of class <code>ratetable</code> used to compute the general population survival.
Default is <code>survexp.dk</code></p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_tau">tau</code></td>
<td>
<p>Upper bound of integral (see ?calc.LL). Default is 100.</p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_type">type</code></td>
<td>
<p>Type of life expectancy measure. Possible values are <code>type = "ll"</code> for the loss of lifetime
and <code>type = "mrl"</code> for the mean residual lifetime.</p>
</td></tr>
<tr><td><code id="calc.LL.quantile_+3A_scale">scale</code></td>
<td>
<p>Numeric. Passed to the <code>survival::survexp</code> function and defaults to 365.24.
That is, the time scale is assumed to be in years.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated cure point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Use data cleaned version of the colon cancer data from the rstpm2 package
data("colonDC")
set.seed(2)
colonDC &lt;- colonDC[sample(1:nrow(colonDC), 1000), ]

##Extract general population hazards
colonDC$bhaz &lt;- general.haz(time = "FU", rmap = list(age = "agedays", sex = "sex", year= "dx"),
                            data = colonDC, ratetable = survexp.dk)

#Fit cure model and estimate cure point
fit &lt;- rstpm2::stpm2(Surv(FUyear, status) ~ 1, data = colonDC, df = 6,
                     bhazard = colonDC$bhaz, cure = TRUE)
calc.LL.quantile(fit, q = 1,
                 rmap = list(age = agedays, sex = sex, year = dx))
</code></pre>

<hr>
<h2 id='cb'>Restricted cubic splines</h2><span id='topic+cb'></span>

<h3>Description</h3>

<p>Function for computing the basis matrix for restricted cubic splines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cb(x, df = NULL, knots = NULL, ortho = FALSE, R.inv = NULL, intercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cb_+3A_x">x</code></td>
<td>
<p>Values to evaluate the basis functions in.</p>
</td></tr>
<tr><td><code id="cb_+3A_df">df</code></td>
<td>
<p>Degrees of freedom. One can supply <code>df</code> rather than knots; <code>cb</code> then chooses <code>df + 1</code> knots
at suitably chosen quantiles of <code>x</code> (which will ignore missing values).</p>
</td></tr>
<tr><td><code id="cb_+3A_knots">knots</code></td>
<td>
<p>Chosen knots for the spline.</p>
</td></tr>
<tr><td><code id="cb_+3A_ortho">ortho</code></td>
<td>
<p>Logical. If <code>TRUE</code> orthogonalization of the basis matrix is carried out.</p>
</td></tr>
<tr><td><code id="cb_+3A_r.inv">R.inv</code></td>
<td>
<p>Matrix or vector containing the values of the R matrix from the QR decomposition of the basis matrix.
This is used for making new predictions based on the initial orthogonalization.
Therefore the default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cb_+3A_intercept">intercept</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the intercept of the restricted cubic spline is removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with containing the basis functions evaluated in <code>x</code>.
</p>


<h3>References</h3>

<p>Royston P. and Parmar M.K. (2002) Flexible parametric proportional-hazards and proportional-odds
models for censored survival data, with application to prognostic modelling and
estimation of treatment effects. <em>Statistics in Medicine</em>, 21:15.
</p>

<hr>
<h2 id='cbc'>Restricted cubic splines with cure</h2><span id='topic+cbc'></span>

<h3>Description</h3>

<p>Function for computing the basis matrix for restricted cubic splines which are constant beyond the last knot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbc(x, df = NULL, knots = NULL, ortho = FALSE, R.inv = NULL, intercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbc_+3A_x">x</code></td>
<td>
<p>Values to evaluate the basis functions in.</p>
</td></tr>
<tr><td><code id="cbc_+3A_df">df</code></td>
<td>
<p>Degrees of freedom. One can supply <code>df</code> rather than knots; <code>cbc</code> then chooses <code>df + 1</code> knots
at suitably chosen quantiles of <code>x</code> (which will ignore missing values) and adds an additional knot at the 95th
quantile of <code>x</code>.</p>
</td></tr>
<tr><td><code id="cbc_+3A_knots">knots</code></td>
<td>
<p>Chosen knots for the spline.</p>
</td></tr>
<tr><td><code id="cbc_+3A_ortho">ortho</code></td>
<td>
<p>Logical. If <code>TRUE</code> orthogonalization of the basis matrix is carried out.</p>
</td></tr>
<tr><td><code id="cbc_+3A_r.inv">R.inv</code></td>
<td>
<p>Matrix or vector containing the values of the R matrix from the QR decomposition of the basis matrix.
This is used for making new predictions based on the initial orthogonalization.
Therefore the default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cbc_+3A_intercept">intercept</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the intercept of the restricted cubic spline is removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with containing the basis functions evaluated in <code>x</code>.
</p>


<h3>References</h3>

<p>Andersson T.M.-L., et al. (2011) Estimating and modelling cure in population-based cancer
studies within the framework of flexible parametric survival models.
<em>BMC Medical Research Methodology</em>, 11:96.
</p>

<hr>
<h2 id='colonDC'>Colon cancer data</h2><span id='topic+colonDC'></span>

<h3>Description</h3>

<p>A dataset containing the individual baseline and follow-up data on more than 15,000
colon cancer patient. The data is a cleaned version of the <code>rstpm2::colon</code> data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(colonDC)
</code></pre>


<h3>Format</h3>

<p>A data frame with 15564 rows and 11 variables
</p>


<h3>Details</h3>


<ul>
<li><p> sex. Either female or male
</p>
</li>
<li><p> age. Diagnostic age
</p>
</li>
<li><p> stage. Clinical stage at diagnosis (either unknown, localised, regional, or distant)
</p>
</li>
<li><p> statusDC. Alive indicator with cause of death
</p>
</li>
<li><p> subsite. Anatomical subsite of tumour (either coecum and ascending, transverse,
descending and sigmoid, or other and NOS)
</p>
</li>
<li><p> dx. Date of diagnosis
</p>
</li>
<li><p> exit. Date of study exit
</p>
</li>
<li><p> status. Alive indicator (0 = alive, 1 = dead)
</p>
</li>
<li><p> FU. Follow-up time measured in days
</p>
</li>
<li><p> FUyear. Follow-up time measured in years
</p>
</li>
<li><p> agedays. Diagnostic age in days.
</p>
</li></ul>


<hr>
<h2 id='fit.cure.model'>Parametric cure model</h2><span id='topic+fit.cure.model'></span>

<h3>Description</h3>

<p>This function fits parametric cure models using simple parametric distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.cure.model(
  formula,
  data,
  formula.surv = NULL,
  type = c("mixture", "nmixture"),
  dist = c("weibull", "exponential", "lognormal", "weiwei", "weiexp", "gmw"),
  link = c("logit", "loglog", "identity", "probit"),
  bhazard = NULL,
  covariance = TRUE,
  link.mix = c("logit", "loglog", "identity", "probit"),
  control = list(maxit = 10000),
  method = "Nelder-Mead",
  init = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.cure.model_+3A_formula">formula</code></td>
<td>
<p>Formula for modelling the cure proportion. The left hand side
has to be of the form <code>Surv(time, status)</code>.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_data">data</code></td>
<td>
<p>Data frame in which to interpret the variable names in <code>formula</code> and <code>formula.surv</code>.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_formula.surv">formula.surv</code></td>
<td>
<p>List of formulas for each parameter in the parametric distribution (see details).</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_type">type</code></td>
<td>
<p>A character indicating the type of cure model.
Possible values are <code>mixture</code> (default) and <code>nmixture</code>.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_dist">dist</code></td>
<td>
<p>The parametric distribution of the survival of the uncured.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_link">link</code></td>
<td>
<p>Character. Specifies the link function of the cure proportion.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_bhazard">bhazard</code></td>
<td>
<p>Background hazard.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_covariance">covariance</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the covariance matrix is computed.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_link.mix">link.mix</code></td>
<td>
<p>Character. Specifies the link function for the mixture parameter in a
weibull-weibull mixture model and weibull-exponential model.<br /> Only used when <code>dist = "weiwei"</code> and <code>dist = "weiexp"</code>.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_control">control</code></td>
<td>
<p>List of control parameters passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_method">method</code></td>
<td>
<p>Optimization method passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fit.cure.model_+3A_init">init</code></td>
<td>
<p>Initial values for the maximum likelihood optimization.
If not provided, the optimization will start in 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type = "mixture"</code>, the function fits the model,
</p>
<p style="text-align: center;"><code class="reqn">S(t|z) = \pi(z) + [1 - \pi(z)] S_u(t|z),</code>
</p>

<p>and if <code>type = "nmixture"</code>, the function fits the model,
</p>
<p style="text-align: center;"><code class="reqn">S(t|z) = \pi(z)^{\widetilde F(t)},</code>
</p>

<p>where z is a vector of covariates. The <code>formula.surv</code> argument is used to model
<code class="reqn">S_u(t)</code> (1 - <code class="reqn">\widetilde F(t)</code>). It is a <code>list</code> of formulas with as many entries as there are
parameters in the chosen parametric distribution. If not specified, all formulas are assumed to be <code>~1</code>.
The ith formula, i.e., <code>formula.surv[[i]]</code> refers to <code class="reqn">\theta_i</code> in the below survival functions.<br /><br />
Exponential model:
</p>
<p style="text-align: center;"><code class="reqn">S_u(t) = \exp\left(-t \theta_1\right).</code>
</p>

<p>Weibull model:
</p>
<p style="text-align: center;"><code class="reqn">S_u(t) = \exp\left(-\theta_1 t^{\theta_2}\right).</code>
</p>

<p>Log-normal model:
</p>
<p style="text-align: center;"><code class="reqn">S_u(t) = 1 - \Phi\left(\frac{\log(t) - \theta_1}{\theta_2}\right).</code>
</p>

<p>Weibull-exponential mixture model:
</p>
<p style="text-align: center;"><code class="reqn">S_u(t) = \theta_1\exp\left(-\theta_2 t^{\theta_3}\right) + (1 - \theta_1)\exp\left(-\theta_4 t\right).</code>
</p>

<p>Weibull-Weibull mixture model:
</p>
<p style="text-align: center;"><code class="reqn">S_u(t) = \theta_1\exp\left(-\theta_2 t^{\theta_3}\right) + (1 - \theta_1)\exp\left(-\theta_4 t^{\theta_5}\right).</code>
</p>

<p>Generalized modified Weibull distribution:
</p>
<p style="text-align: center;"><code class="reqn">S_u(t) = 1-\left(1 - \exp\left(-\theta_1 t ^ \theta_2 \exp(\theta_3 t)\right)\right) ^ \theta_4.</code>
</p>

<p>In the Weibull-exponential and Weibull-Weibull mixture models, the link function for the mixture component is controlled by <code>link.mix</code>.
The remaining parameters are modelled using an exponential link function except <code class="reqn">\theta_1</code> in the log-normal model,
which is modelled using the identity. Parameters are not transformed back to the original scale in
the outputted object and related <code>print.cm</code> and <code>summary.cm</code> functions
</p>


<h3>Value</h3>

<p>An object of class <code>cm</code> containing the estimated parameters of the cure model.
The appropriate link functions taken on <code class="reqn">\pi</code> and the <code class="reqn">\theta_i</code>'s are linear in the covariates corresponding to their respective parameter estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Use data cleaned version of the colon cancer data from the rstpm2 package
data("colonDC")
set.seed(2)
colonDC &lt;- colonDC[sample(1:nrow(colonDC), 500), ]

##Extract general population hazards
colonDC$bhaz &lt;- general.haz(time = "FU", rmap = list(age = "agedays", sex = "sex", year= "dx"),
                            data = colonDC, ratetable = survexp.dk)


###Without covariates
##Fit weibull mixture cure model
fit.wei &lt;- fit.cure.model(Surv(FUyear, status) ~ 1, data = colonDC, bhazard = "bhaz",
                          type = "mixture", dist = "weibull", link = "logit")

##Plot various summaries of the model (see ?predict.cm)
plot(fit.wei)
plot(fit.wei, time = seq(0, 40, length.out = 100))
plot(fit.wei, type = "hazard")
plot(fit.wei, type = "survuncured")
plot(fit.wei, type = "probcure")

#Fit a weibull-weibull mixture cure model
fit.weiwei &lt;- fit.cure.model(Surv(FUyear, status) ~ 1, data = colonDC, bhazard = "bhaz",
                          type = "mixture", dist = "weiwei", link = "logit")

#Compare to the weibull model
plot(fit.wei, ci = FALSE)
plot(fit.weiwei, add = TRUE, col = 2, ci = FALSE)

###With covariates
##Fit weibull mixture cure model with age effect for both components of the Weibull model
fit &lt;- fit.cure.model(Surv(FUyear, status) ~ age, data = colonDC, bhazard = "bhaz",
                      formula.surv = list(~ age, ~ age),
                      type = "mixture", dist = "weibull", link = "logit")

##Plot model for age 50 and 60
plot(fit, newdata = data.frame(age = 60),
     time = seq(0, 15, length.out = 100), ci = FALSE)
plot(fit, newdata = data.frame(age = 50),
     time = seq(0, 15, length.out = 100), ci = FALSE, add = TRUE, col = 2)

plot(fit, newdata = data.frame(age = 60),
     time = seq(0, 15, length.out = 100), ci = FALSE, type = "hazard")
plot(fit, newdata = data.frame(age = 50),
     time = seq(0, 15, length.out = 100), ci = FALSE, type = "hazard", add = TRUE, col = 2)
</code></pre>

<hr>
<h2 id='general.haz'>Extract general population hazard</h2><span id='topic+general.haz'></span>

<h3>Description</h3>

<p>Yearly general population hazards matched on age, gender, and calendar year is extracted from a ratetable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general.haz(
  time,
  rmap,
  data = NULL,
  ratetable = cuRe::survexp.dk,
  scale = 365.24
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="general.haz_+3A_time">time</code></td>
<td>
<p>Either a numeric vector of follow-up times (in days) or a character indicating the variable
containing the follow-up times in the data.</p>
</td></tr>
<tr><td><code id="general.haz_+3A_rmap">rmap</code></td>
<td>
<p>A named list. The names must match the dimension names of the ratetable input.
The elements should be given as vectors containing the relevant variables in the data
or a character indicating the name of the variable in the data.
Elements in the list named 'age' and 'year' are transformed such that the age and year of
the event/censoring time is used.
'age' must be a numeric vector given as age in days
or a character indicating the variable containing the patient ages in the data.
'year' must be of class <code>Date</code> with the calendar time points
or a character indicating the variable containing the calendar times in the data.
Other variables should be coded as characters in the data.</p>
</td></tr>
<tr><td><code id="general.haz_+3A_data">data</code></td>
<td>
<p>The data from which to extract variables from.
If <code>time</code>, <code>age</code>, <code>sex</code>, or <code>year</code> are not characters, this will not be used.</p>
</td></tr>
<tr><td><code id="general.haz_+3A_ratetable">ratetable</code></td>
<td>
<p>Object of class <code>ratetable</code> to extract background hazards from. Defaults to <code>survexp.dk</code>.</p>
</td></tr>
<tr><td><code id="general.haz_+3A_scale">scale</code></td>
<td>
<p>Numeric to adjust the scale of the outputted hazard values.
If the ratetable provides daily hazards and <code>scale = 365.24</code> (default), the outputted hazard values are yearly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>numeric</code> containing the yearly expected hazards.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Use data cleaned version of the colon cancer data from the rstpm2 package
data("colonDC")
set.seed(2)
colonDC &lt;- colonDC[sample(1:nrow(colonDC), 1000), ]

##Extract general population hazards
bhaz1 &lt;- general.haz(time = "FU",
                     rmap = list(age = "agedays", sex = "sex", year= "dx"),
                     data = colonDC,
                     ratetable = survexp.dk)

bhaz2 &lt;- general.haz(time = colonDC$FU,
                     rmap = list(age = colonDC$agedays, sex = colonDC$sex, year = colonDC$dx),
                     data = colonDC,
                     ratetable = survexp.dk)

all(bhaz2 == bhaz1)
</code></pre>

<hr>
<h2 id='GenFlexCureModel'>Fit generalized mixture cure model</h2><span id='topic+GenFlexCureModel'></span>

<h3>Description</h3>

<p>The following function fits a generalized mixture or non-mixture cure model
using a link function for the cure rate and for the survival of the uncured.
For a mixture cure model, the model is specified by
</p>
<p style="text-align: center;"><code class="reqn">S(t|z) = \pi(z) + [1 - \pi(z)] S_u(t|z),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">g_1[S_u(t|z)] = \eta_1(t, z)\qquad and \qquad g_2[\pi(z)] = \eta_2(z).</code>
</p>

<p>The function implements multiple link functions for both <code class="reqn">g_1</code> and <code class="reqn">g_2</code>. The default time-effect
is natural cubic splines, but the function allows for the use of other smoothers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenFlexCureModel(
  formula,
  data,
  smooth.formula = NULL,
  smooth.args = NULL,
  df = 3,
  tvc = NULL,
  tvc.formula = NULL,
  bhazard = NULL,
  cr.formula = ~1,
  type = "mixture",
  link.type.cr = c("logit", "loglog", "identity", "probit"),
  link.type = c("PH", "PO", "probit"),
  init = NULL,
  baseoff = FALSE,
  timeVar = "",
  time0Var = "",
  covariance = T,
  verbose = T,
  control = list(maxit = 10000),
  method = "Nelder-Mead",
  constraint = TRUE,
  ini.types = c("cure", "flexpara")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenFlexCureModel_+3A_formula">formula</code></td>
<td>
<p>Formula for modelling the survival of the uncured. Reponse has to be of the form <code>Surv(time, status)</code>.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_data">data</code></td>
<td>
<p>Data frame in which to interpret the variables names in <code>formula</code>,
<code>smooth.formula</code>, <code>tvc.formula</code>, and <code>cr.formula</code>.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_smooth.formula">smooth.formula</code></td>
<td>
<p>Formula for describing the time-effect of the survival of the uncured.
If <code>NULL</code> (default), the function uses the natural cubic splines modelled on the log-time scale.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_smooth.args">smooth.args</code></td>
<td>
<p>List. Optional arguments to the time-effect of the survival
of the uncured (default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_df">df</code></td>
<td>
<p>Integer. Degrees of freedom (default is 3) for the time-effect of the survival of the uncured.
Is not used if <code>smooth.formula</code> is provided.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_tvc">tvc</code></td>
<td>
<p>Named list of integers. Specifies the degrees of freedom for time-varying covariate effects.
For instance, <code>tvc = list(x = 3)</code> creates a time-varying spline-effect of the covariate &quot;x&quot; with
3 degrees of freedom using the <code>rstpm2::nsx</code> function.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_tvc.formula">tvc.formula</code></td>
<td>
<p>Formula for the time-varying covariate effects.
For time-varying effects, a linear term of the covariate has to be included in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_bhazard">bhazard</code></td>
<td>
<p>Background hazard.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_cr.formula">cr.formula</code></td>
<td>
<p>Formula for the cure proportion.
The left hand side of the formula is not used and should therefore not be specified.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_type">type</code></td>
<td>
<p>A character indicating the type of cure model.
Possible values are <code>mixture</code> for mixture cure models (default) and <code>nmixture</code>
for non-mixture cure models.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_link.type.cr">link.type.cr</code></td>
<td>
<p>Character providing the link function for the cure proportion.
Possible values are <code>logit</code> (default), <code>loglog</code>, <code>identity</code>, and <code>probit</code>.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_link.type">link.type</code></td>
<td>
<p>Character providing the link function for the survival of the uncured.
Possible values are <code>PH</code> for a proportional hazards model (default), <code>PO</code> for a proportion odds model,
and <code>probit</code> for a probit model.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_init">init</code></td>
<td>
<p>Initial values for the optimization procedure.
If not specified, the function will create initial values internally.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_baseoff">baseoff</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the time-effect is modelled only using <code>tvc.formula</code> rather
than merging with <code>smooth.formula</code>.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_timevar">timeVar</code></td>
<td>
<p>Optional character giving the name of the variable specifying the time component of the <code>Surv</code> object.
Should currently not be used.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_time0var">time0Var</code></td>
<td>
<p>Optional character giving the name of the variable specifying the time start time component used for delayed entry.
Should currently not be used.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_covariance">covariance</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the covariance matrix is computed.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> status messages of the function is outputted.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_control">control</code></td>
<td>
<p>Named list with control arguments passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_method">method</code></td>
<td>
<p>Character passed to <code>optim</code> indicating the method for optimization.
See <code>?optim</code> for details.</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_constraint">constraint</code></td>
<td>
<p>Logical. Indicates whether non-negativity constraints should be forced upon
the hazard of the uncured patients (see details).</p>
</td></tr>
<tr><td><code id="GenFlexCureModel_+3A_ini.types">ini.types</code></td>
<td>
<p>Character vector denoting the executed schemes for computing initial values (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default smoother is natural cubic splines established by the <code>rstpm2::nsx</code> function.
Functions such as <code>ns</code>, <code>bs</code> are readily available for usage. Also the <code>cb</code> function in this package
can be used. Initial values are calculated by two procedures and the model is fitted under each set of initial values.
The model producing the highest likelihood is selected.<br />
</p>
<p>Using <code>link.type = 'PH'</code>, the link function <code class="reqn">g_1(x) = \log(-\log(x))</code> is used.
Using <code>link.type = 'PO'</code>, the link function <code class="reqn">g_1(x) = \log(\frac{x}{1 - x})</code> is used.<br />
</p>
<p>If <code>constraint = TRUE</code>, a non-negative hazard of the uncured is ensured by a general penalization scheme.
If <code>constraint = FALSE</code>, penalization is still employed, but on the all-cause hazard instead.
</p>


<h3>Value</h3>

<p>An object of class <code>gfcm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Use data cleaned version of the colon cancer data from the rstpm2 package
data("colonDC")
set.seed(2)
colonDC &lt;- colonDC[sample(1:nrow(colonDC), 400), ]

##Extract general population hazards
colonDC$bhaz &lt;- general.haz(time = "FU", rmap = list(age = "agedays", sex = "sex", year= "dx"),
                            data = colonDC, ratetable = survexp.dk)

###Without covariates
##Fit mixture cure model
fit &lt;- GenFlexCureModel(Surv(FUyear, status) ~ 1, data = colonDC, df = 4, bhazard = "bhaz")

##Plot model
plot(fit)
plot(fit, time = seq(0.001, 40, length.out = 100))
plot(fit, type = "hazard")
plot(fit, type = "survuncured")
plot(fit, type = "probcure")

##Predict cure proportion
predict(fit, type = "curerate")


##Fit non-mixture cure model
fit &lt;- GenFlexCureModel(Surv(FUyear, status) ~ 1, data = colonDC, df = 4,
                        bhazard = "bhaz", type = "nmixture")

##Plot relative survival
plot(fit)

##Predict cure proportion
predict(fit, type = "curerate")

###With covariates
##Fit mixture cure model
fit &lt;- GenFlexCureModel(Surv(FUyear, status) ~ sex, data = colonDC, df = 4,
                        bhazard = "bhaz", cr.formula = ~ sex)

##Plot model
plot(fit, newdata = data.frame(sex = factor("female", levels = c("male", "female"))),
     time = seq(0.001, 15, length.out = 100), ci = FALSE)
plot(fit, newdata = data.frame(sex = factor("male", levels = c("male", "female"))),
     time = seq(0.001, 15, length.out = 100), col = 2, ci = FALSE, add = TRUE)


plot(fit, newdata = data.frame(sex = factor("female", levels = c("male", "female"))),
     time = seq(0.001, 15, length.out = 100), ci = FALSE, type = "survuncured")
plot(fit, newdata = data.frame(sex = factor("male", levels = c("male", "female"))),
     time = seq(0.001, 15, length.out = 100), col = 2, ci = FALSE,
     add = TRUE, type = "survuncured")

predict(fit, type = "curerate",
        data.frame(sex = factor(c("male", "female"),
                                levels = c("male", "female"))))


##Fit mixture cure model with time-varying covariates
colonDC$gender &lt;- as.numeric(colonDC$sex) - 1
fit &lt;- GenFlexCureModel(Surv(FUyear, status) ~ gender, data = colonDC, df = 6,
                        bhazard = "bhaz", cr.formula = ~ gender, tvc = list(gender = 2))

##Plot model
plot(fit, newdata = data.frame(gender = 0))
plot(fit, newdata = data.frame(gender = 1), add = TRUE, col = 2)

plot(fit, type = "hazard", newdata = data.frame(gender = 0), ci = FALSE)
plot(fit, type = "hazard", newdata = data.frame(gender = 1),
     add = TRUE, col = 2, ci = FALSE)

#Predict cure proportions for a male and female patients
predict(fit, type = "curerate", newdata = data.frame(gender = 0))
predict(fit, type = "curerate", newdata = data.frame(gender = 1))
</code></pre>

<hr>
<h2 id='lrtest'>Likelihood ratio tests for comparing nested cure models</h2><span id='topic+lrtest'></span>

<h3>Description</h3>

<p>Function for doing likelihood ratio tests for class <code>cuRe</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrtest(model1, model2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrtest_+3A_model1">model1</code></td>
<td>
<p>A model fitted by the fit.cure.model or the GenFlexCureModel function</p>
</td></tr>
<tr><td><code id="lrtest_+3A_model2">model2</code></td>
<td>
<p>Another model fitted by the fit.cure.model or the GenFlexCureModel function for comparison.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the models must be nested within the other model,
and both models must be fitted to the same data set.
</p>


<h3>Value</h3>

<p>An object of class &quot;anova&quot; containing the degrees of freedom and log-likelihoods of the two models,
the difference in degrees of freedom, the likelihood ratio Chi-squared statistic (twice the difference in log-likelihoods)
, and the p-value for the asymptotic likelihood ratio test.
</p>

<hr>
<h2 id='lts'>Long term survival predictions</h2><span id='topic+lts'></span>

<h3>Description</h3>

<p>Function for computing survival estimates using a relative survival model and the
expected general population survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lts(
  fit,
  type = c("surv", "hazard", "cumhaz", "loghaz", "fail"),
  newdata = NULL,
  time = NULL,
  var.type = c("ci", "se", "n"),
  exp.fun = NULL,
  ratetable = cuRe::survexp.dk,
  rmap,
  scale = 365.24,
  smooth.exp = FALSE,
  link = NULL,
  mean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lts_+3A_fit">fit</code></td>
<td>
<p>Fitted model to do predictions from. Possible classes are <code>gfcm</code>, <code>stpm2</code>,
<code>pstpm2</code>, and <code>cm</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_type">type</code></td>
<td>
<p>Prediction type (see details). The default is <code>surv</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_newdata">newdata</code></td>
<td>
<p>Data frame from which to compute predictions. If empty, predictions are made on the the data which
the model was fitted on.</p>
</td></tr>
<tr><td><code id="lts_+3A_time">time</code></td>
<td>
<p>Optional time points at which to compute predictions. If empty, a grid of 100 time points between 0
and the maximum follow-up time is selected.</p>
</td></tr>
<tr><td><code id="lts_+3A_var.type">var.type</code></td>
<td>
<p>Character. Possible values are &quot;<code>ci</code>&quot; (default) for confidence intervals,
&quot;<code>se</code>&quot; for standard errors, and &quot;<code>n</code>&quot; for neither.</p>
</td></tr>
<tr><td><code id="lts_+3A_exp.fun">exp.fun</code></td>
<td>
<p>Object of class <code>list</code> containing functions for the expected survival
of each row in <code>newdata</code>. If not specified, the function computes the expected
survival based on <code>newdata</code> using the <code>survival::survexp</code> function. If <code>newdata</code> is not provided,
the expected survival is based on the data which the model was fitted on.</p>
</td></tr>
<tr><td><code id="lts_+3A_ratetable">ratetable</code></td>
<td>
<p>Object of class <code>ratetable</code> used to compute the general population survival.
Default is <code>survexp.dk</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_rmap">rmap</code></td>
<td>
<p>List to be passed to <code>survexp</code> from the <code>survival</code> package if <code>exp.fun = NULL</code>.
Detailed documentation on this argument can be found by <code>?survexp</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_scale">scale</code></td>
<td>
<p>Numeric. Passed to the <code>survival::survexp</code> function and defaults to 365.24.
That is, the time scale is assumed to be in years.</p>
</td></tr>
<tr><td><code id="lts_+3A_smooth.exp">smooth.exp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the general population survival function is smoothed by the function
<code>smooth.spline</code> using the the argument <code>all.knots = TRUE</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_link">link</code></td>
<td>
<p>Character, indicating the link function for the variance calculations.
Possible values are &quot;<code>log</code>&quot;, &quot;<code>cloglog</code>&quot; for <code class="reqn">log(-log(x))</code> , &quot;<code>mlog</code>&quot; for -log(x),
and &quot;<code>I</code>&quot; for the indentity.</p>
</td></tr>
<tr><td><code id="lts_+3A_mean">mean</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function outputs the average estimate across the
rows in <code>newdata</code>. If <code>newdata = NULL</code>, the argument is not used. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values for argument <code>type</code> are:<br />
<code>surv</code>: Survival function computed by <code class="reqn">S(t) = R(t)S^*(t)</code><br />
<code>hazard</code>: Hazard function computed by <code class="reqn">h(t) = \lambda(t) + h^*(t)</code><br />
<code>cumhaz</code>: The cumulative hazard function computed by <code class="reqn">H(t) = \Lambda(t) + H^*(t)</code><br />
<code>loghazard</code>: The log-hazard function computed by <code class="reqn">\log(\lambda(t) + h^*(t))</code><br />
<code>fail</code>: The distribution function computed by <code class="reqn">1 - R(t)S^*(t)</code>
</p>


<h3>Value</h3>

<p>An object of class <code>lts</code> containing the predictions of each individual in <code>newdata</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Use data cleaned version of the colon cancer data from the rstpm2 package
data("colonDC")
set.seed(2)
colonDC &lt;- colonDC[sample(1:nrow(colonDC), 1000), ]

##Extract general population hazards
colonDC$bhaz &lt;- general.haz(time = "FU", rmap = list(age = "agedays", sex = "sex", year= "dx"),
                            data = colonDC, ratetable = survexp.dk)

##Fit flexible parametric relative survival model
fit &lt;- stpm2(Surv(FUyear, status) ~ 1, data = colonDC, df = 6, bhazard = colonDC$bhaz)

##Compute survival probabilities from 0 to 20 years
pred &lt;- lts(fit, rmap = list(age = agedays, sex = sex, year = dx))

##Plot the survival function
plot(pred)
</code></pre>

<hr>
<h2 id='plot.crude'>Plot crude event probabilities</h2><span id='topic+plot.crude'></span>

<h3>Description</h3>

<p>Plot function for the computed crude event probabilties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crude'
plot(x, ylim = c(0, 1), xlim = NULL, ci = T, col = 1,
        ylab = NULL, xlab = "Time", add = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.crude_+3A_x">x</code></td>
<td>
<p>Object of class <code>crude</code> in which crude probabilities are stored.</p>
</td></tr>
<tr><td><code id="plot.crude_+3A_ylim">ylim</code></td>
<td>
<p>Limits of y-axis.</p>
</td></tr>
<tr><td><code id="plot.crude_+3A_xlim">xlim</code></td>
<td>
<p>Limits of x-axis.</p>
</td></tr>
<tr><td><code id="plot.crude_+3A_ci">ci</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), confidence intervals are added to the plot.</p>
</td></tr>
<tr><td><code id="plot.crude_+3A_col">col</code></td>
<td>
<p>Colour of each curve.</p>
</td></tr>
<tr><td><code id="plot.crude_+3A_ylab">ylab</code></td>
<td>
<p>Label of the y-axis. If <code>NULL</code>, the function uses its default labels depending on <code>object$type</code>.</p>
</td></tr>
<tr><td><code id="plot.crude_+3A_xlab">xlab</code></td>
<td>
<p>Label of the x-axis (default is &quot;Time&quot;).</p>
</td></tr>
<tr><td><code id="plot.crude_+3A_add">add</code></td>
<td>
<p>Logical indicating wether the cruves should be added to the current plot window (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.crude_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plot</code> and <code>lines</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.cuRe'>Plot function for Flexible mixture cure model</h2><span id='topic+plot.cuRe'></span>

<h3>Description</h3>

<p>Plot function associated with the classes <code>gfcm</code> and <code>cm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cuRe'
plot(x, newdata = NULL,
        type = c("surv", "probcure", "survuncured", "hazarduncured", "cumhazuncured",
        "densityuncured", "failuncured", "oddsuncured", "loghazarduncured", "hazard",
        "density", "fail", "loghazard", "odds", "cumhaz"), time = NULL, xlim = NULL,
        ylim = c(0, 1), xlab = "Time", ylab = NULL, col = 1, ci = T, add = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cuRe_+3A_x">x</code></td>
<td>
<p>Object of class <code>cuRe</code>.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_newdata">newdata</code></td>
<td>
<p>Data frame from which to compute predictions. If empty, predictions are made on the the data which
the model was fitted on.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_type">type</code></td>
<td>
<p>Character. Defines the desired scale to plot. See ?predict.gfcm for possible values.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_time">time</code></td>
<td>
<p>Optional time points at which to compute predictions.
This argument is not used if type is <code>curerate</code>.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_xlim">xlim</code></td>
<td>
<p>Limits of the x-axis.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_ylim">ylim</code></td>
<td>
<p>Limits of the y-axis.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_xlab">xlab</code></td>
<td>
<p>Label of the x-axis. Default is &quot;Time&quot;.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_ylab">ylab</code></td>
<td>
<p>Label of the y-axis. If <code>NULL</code>, the function uses its default y-labels
depending on <code>object$type</code> and <code>object$excess</code>.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_col">col</code></td>
<td>
<p>Colour of each line.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_ci">ci</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), confidence intervals are added to the plot.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_add">add</code></td>
<td>
<p>Loglca. If <code>TRUE</code> the curve is added to the existing plot.</p>
</td></tr>
<tr><td><code id="plot.cuRe_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plot</code> and <code>lines</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot containing the predictions of each observation in <code>newdata</code>.
</p>

<hr>
<h2 id='plot.le'>Plot the loss of lifetime function</h2><span id='topic+plot.le'></span>

<h3>Description</h3>

<p>Plot function for the class <code>le</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'le'
plot(x, ylim = NULL, xlim = NULL, ci = T, col = 1,
        ylab = NULL, xlab = "Time", add = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.le_+3A_x">x</code></td>
<td>
<p>Object of class <code>le</code>.</p>
</td></tr>
<tr><td><code id="plot.le_+3A_ylim">ylim</code></td>
<td>
<p>Limit of the y-axis.</p>
</td></tr>
<tr><td><code id="plot.le_+3A_xlim">xlim</code></td>
<td>
<p>Limit of x-axis.</p>
</td></tr>
<tr><td><code id="plot.le_+3A_ci">ci</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), confidence intervals are added to the plot.</p>
</td></tr>
<tr><td><code id="plot.le_+3A_col">col</code></td>
<td>
<p>Numeric or character indicating the colours of the curves.</p>
</td></tr>
<tr><td><code id="plot.le_+3A_ylab">ylab</code></td>
<td>
<p>Label to be written on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.le_+3A_xlab">xlab</code></td>
<td>
<p>Label to be written on the x-axis.</p>
</td></tr>
<tr><td><code id="plot.le_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the curve is added to the current plot window.</p>
</td></tr>
<tr><td><code id="plot.le_+3A_...">...</code></td>
<td>
<p>Further argument passed to <code>plot</code> and <code>lines</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.lts'>Plot the long term survival</h2><span id='topic+plot.lts'></span>

<h3>Description</h3>

<p>Plot function for the class <code>lts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lts'
plot(x, ylim = NULL, xlim = NULL, ci = T, col = 1,
        ylab = NULL, xlab = "Time", add = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lts_+3A_x">x</code></td>
<td>
<p>Object of class <code>lts</code>.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_ylim">ylim</code></td>
<td>
<p>Limit of the y-axis.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_xlim">xlim</code></td>
<td>
<p>Limit of x-axis.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_ci">ci</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), confidence intervals are added to the plot.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_col">col</code></td>
<td>
<p>Numeric or character indicating the colours of the curves.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_ylab">ylab</code></td>
<td>
<p>Label to be written on the y-axis. If <code>NULL</code>, this is based on <code>type</code>.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_xlab">xlab</code></td>
<td>
<p>Label to be written on the x-axis.</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_add">add</code></td>
<td>
<p>Logical indicating whether to add to current plot window (default is FALSE).</p>
</td></tr>
<tr><td><code id="plot.lts_+3A_...">...</code></td>
<td>
<p>Further argument passed to <code>plot</code> and <code>lines</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.cm'>Predict function for flexible mixture cure model</h2><span id='topic+predict.cm'></span>

<h3>Description</h3>

<p>Function for doing predictions for class <code>cm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cm'
predict(object, newdata = NULL,
        type = c("surv", "curerate", "probcure", "survuncured", "hazarduncured",
        "cumhazuncured","densityuncured", "failuncured", "oddsuncured",
        "loghazarduncured","hazard", "density", "fail", "loghazard",
        "odds", "cumhaz"), time = NULL, var.type = c("ci", "se", "n"),
        pars = NULL, link = NULL, keep.attributes = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cm_+3A_object">object</code></td>
<td>
<p>Object of class <code>cm</code> to do predictions from.</p>
</td></tr>
<tr><td><code id="predict.cm_+3A_newdata">newdata</code></td>
<td>
<p>Data frame from which to compute predictions. If empty, predictions are made on the data which
the model was fitted on.</p>
</td></tr>
<tr><td><code id="predict.cm_+3A_type">type</code></td>
<td>
<p>Prediction type (see details). The default is <code>surv</code>.</p>
</td></tr>
<tr><td><code id="predict.cm_+3A_time">time</code></td>
<td>
<p>Optional time points at which to compute predictions.
This argument is not used if type is <code>curerate</code>.</p>
</td></tr>
<tr><td><code id="predict.cm_+3A_var.type">var.type</code></td>
<td>
<p>Character. Possible values are &quot;<code>ci</code>&quot; (default) for confidence intervals,
&quot;<code>se</code>&quot; for standard errors, and &quot;<code>n</code>&quot; for neither.</p>
</td></tr>
<tr><td><code id="predict.cm_+3A_pars">pars</code></td>
<td>
<p>Numerical vector containing the parameters values of the model.
In general, this argument can be ignored by the user.</p>
</td></tr>
<tr><td><code id="predict.cm_+3A_link">link</code></td>
<td>
<p>Character, indicating the link function for the variance calculations.
Possible values are &quot;<code>log</code>&quot;, &quot;<code>cloglog</code>&quot; for <code class="reqn">log(-log(x))</code> , &quot;<code>mlog</code>&quot; for -log(x),
and &quot;<code>I</code>&quot; for the indentity.
If <code>NULL</code> (default), the function will determine <code>link</code> from <code>type</code>.</p>
</td></tr>
<tr><td><code id="predict.cm_+3A_keep.attributes">keep.attributes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>newdata</code> will be added to the attributes of the output.</p>
</td></tr>
<tr><td><code id="predict.cm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values for argument <code>type</code> are:<br />
<code>surv</code>: Survival function<br />
<code>curerate</code>: The cure fraction<br />
<code>probcure</code>: The conditional probability of being cured<br />
<code>survuncured</code>: The survival of the uncured<br />
<code>hazarduncured</code>: The hazard function of the uncured<br />
<code>cumhazuncured</code>: The cumulative hazard of the uncured<br />
<code>densityuncured</code>: The density function of the uncured<br />
<code>failuncured</code>: The distribution function of the uncured, i.e., 1 - <code>survuncured</code><br />
<code>oddsuncured</code>: Odds of the uncured, i.e., (1 - <code>survuncured</code>) / <code>survuncured</code><br />
<code>loghazarduncured</code>: The log-hazard of the uncured<br />
<code>hazard</code>: The hazard function<br />
<code>density</code>: The density function<br />
<code>fail</code>: The distribution function<br />
<code>loghazard</code>: The log-hazard function<br />
<code>odds</code>: The odds, i.e., (1 - <code>surv</code>) / <code>surv</code><br />
<code>cumhaz</code>: The cumulative hazard function
</p>


<h3>Value</h3>

<p>A list containing the predictions of each individual in <code>newdata</code>.
</p>

<hr>
<h2 id='predict.gfcm'>Predict function for flexible mixture cure model</h2><span id='topic+predict.gfcm'></span>

<h3>Description</h3>

<p>Function for doing predictions for class <code>gfcm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gfcm'
predict(object, newdata = NULL,
        type = c("surv", "curerate", "probcure", "survuncured",
        "hazarduncured", "cumhazuncured", "densityuncured",
        "failuncured", "oddsuncured", "loghazarduncured","hazard",
        "density", "fail", "loghazard", "odds", "cumhaz"), indi = TRUE,
        time = NULL, var.type = c("ci", "se", "n"), pars = NULL,
        link = NULL, keep.attributes = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gfcm_+3A_object">object</code></td>
<td>
<p>Object of class <code>gfcm</code> to do predictions from.</p>
</td></tr>
<tr><td><code id="predict.gfcm_+3A_newdata">newdata</code></td>
<td>
<p>Data frame from which to compute predictions. If empty, predictions are made on the data which
the model was fitted on.</p>
</td></tr>
<tr><td><code id="predict.gfcm_+3A_type">type</code></td>
<td>
<p>Prediction type (see details). The default is <code>surv</code>.</p>
</td></tr>
<tr><td><code id="predict.gfcm_+3A_indi">indi</code></td>
<td>
<p>Logical. If <code>TRUE</code>, each line in <code>newdata</code> is treated as an individual observations. This
functionality allows predictions for each observation at more than one time point.</p>
</td></tr>
<tr><td><code id="predict.gfcm_+3A_time">time</code></td>
<td>
<p>Optional time points at which to compute predictions.
This argument is not used if type is <code>curerate</code>.</p>
</td></tr>
<tr><td><code id="predict.gfcm_+3A_var.type">var.type</code></td>
<td>
<p>Character. Possible values are &quot;<code>ci</code>&quot; (default) for confidence intervals,
&quot;<code>se</code>&quot; for standard errors, and &quot;<code>n</code>&quot; for neither.</p>
</td></tr>
<tr><td><code id="predict.gfcm_+3A_pars">pars</code></td>
<td>
<p>Numerical vector containing the parameters values of the model.
In general, this argument can be ignored by the user.</p>
</td></tr>
<tr><td><code id="predict.gfcm_+3A_link">link</code></td>
<td>
<p>Character, indicating the link function for the variance calculations.
Possible values are &quot;<code>log</code>&quot;, &quot;<code>cloglog</code>&quot; for <code class="reqn">log(-log(x))</code> , &quot;<code>mlog</code>&quot; for -log(x),
and &quot;<code>I</code>&quot; for the indentity.
If <code>NULL</code> (default), the function will determine <code>link</code> from <code>type</code>.</p>
</td></tr>
<tr><td><code id="predict.gfcm_+3A_keep.attributes">keep.attributes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>newdata</code> will be added to the attributes of the output.</p>
</td></tr>
<tr><td><code id="predict.gfcm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values for argument <code>type</code> are:<br />
<code>surv</code>: Survival function<br />
<code>curerate</code>: The cure fraction<br />
<code>probcure</code>: The conditional probability of being cured<br />
<code>survuncured</code>: The survival of the uncured<br />
<code>hazarduncured</code>: The hazard function of the uncured<br />
<code>cumhazuncured</code>: The cumulative hazard of the uncured<br />
<code>densityuncured</code>: The density function of the uncured<br />
<code>failuncured</code>: The distribution function of the uncured, i.e., 1 - <code>survuncured</code><br />
<code>oddsuncured</code>: Odds of the uncured, i.e., (1 - <code>survuncured</code>) / <code>survuncured</code><br />
<code>loghazarduncured</code>: The log-hazard of the uncured<br />
<code>hazard</code>: The hazard function<br />
<code>density</code>: The density function<br />
<code>fail</code>: The distribution function<br />
<code>loghazard</code>: The log-hazard function<br />
<code>odds</code>: The odds, i.e., (1 - <code>surv</code>) / <code>surv</code><br />
<code>cumhaz</code>: The cumulative hazard function
</p>


<h3>Value</h3>

<p>A list containing the predictions of each individual in <code>newdata</code>.
</p>

<hr>
<h2 id='survexp.dk'>Ratetable of the Danish general population</h2><span id='topic+survexp.dk'></span>

<h3>Description</h3>

<p>Object of class <code>ratetable</code> containing the daily hazards in the Danish general population
as reported by the Human Mortality Database (www.mortality.org).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survexp.dk
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ratetable</code> of dimension 111 x 180 x 2.
</p>


<h3>Details</h3>

<p>The ratetable was generated by using the <code>relsurv::transrate.hmd</code> function.
The data were downloaded on 15-09-2017 seperately for male and female Danish citizens.<br />
The data can be accessed through:<br />
Female: http://www.mortality.org/hmd/DNK/STATS/fltper_1x1.txt<br />
Male: http://www.mortality.org/hmd/DNK/STATS/mltper_1x1.txt<br />
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
