<!DOCTYPE html><html><head><title>Help for package MultiFit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MultiFit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MultiFIT'><p>Multiscale Fisher's Independence Test for Multivariate Dependence</p></a></li>
<li><a href='#MultiSummary'><p>Summary of significant tests</p></a></li>
<li><a href='#MultiTree'><p>Plot tree structure of tests on 2x2 contingency tables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiscale Fisher's Independence Test for Multivariate
Dependence</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>S. Gorsky, L. Ma</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>S. Gorsky &lt;sgorsky@umass.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Test for independence of two random vectors, learn and report the dependency structure. For more information, see Gorsky, Shai and Li Ma, Multiscale Fisher's Independence Test for Multivariate Dependence, Biometrika, accepted, January 2022.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8), data.table</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>png, qgraph, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-18 01:56:36 UTC; hhh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-18 03:32:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='MultiFIT'>Multiscale Fisher's Independence Test for Multivariate Dependence</h2><span id='topic+MultiFIT'></span>

<h3>Description</h3>

<p>Perform multiscale test of independence for multivariate vectors.
See vignettes for further examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiFIT(xy, x = NULL, y = NULL, p_star = NULL, R_max = NULL,
  R_star = 1, rank.transform = TRUE, ranking.approximation = FALSE,
  M = 10, apply.stopping.rule = FALSE, alpha = 0.05,
  test.method = "Fisher", correct = TRUE, min.tbl.tot = 25L,
  min.row.tot = 10L, min.col.tot = 10L, p.adjust.methods = c("H",
  "Hcorrected"), compute.all.holm = TRUE, return.all.pvs = TRUE,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiFIT_+3A_xy">xy</code></td>
<td>
<p>A list, whose first element corresponds to the matrix x as below, and
its second element corresponds to the matrix y as below. If <code>xy</code> is not
specified, <code>x</code> and <code>y</code> need to be assigned.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_x">x</code></td>
<td>
<p>A matrix, number of columns = dimension of random vector,
number of rows = number of observations.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_y">y</code></td>
<td>
<p>A matrix, number of columns = dimension of random vector,
number of rows = number of observations.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_p_star">p_star</code></td>
<td>
<p>Numeric, cuboids associated with tests whose <code>p</code>-value is below <code>p_star</code>
will be halved and further tested.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_r_max">R_max</code></td>
<td>
<p>A positive integer (or Inf), the maximal number of
resolutions to scan (algorithm will stop at a lower resolution if
all tables in it do not meet the criteria specified at <code>min.tbl.tot</code>,
<code>min.row.tot</code> and <code>min.col.tot</code>)</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_r_star">R_star</code></td>
<td>
<p>A positive integer, if set to an integer
between 0 and <code>R_max</code>, all tests up to and including resolution <code>R_star</code>
will be performed (algorithm will stop at a lower resolution than requested if
all tables in it do not meet the criteria specified at <code>min.tbl.tot</code>,
<code>min.row.tot</code> and <code>min.col.tot</code>). For higher resolutions only the children of 
tests with <code>p</code>-value lower than <code>p_star</code> will be considered.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_rank.transform">rank.transform</code></td>
<td>
<p>Logical, if <code>TRUE</code>, marginal rank transform is
performed on all margins of <code>x</code> and <code>y</code>. If <code>FALSE</code>, all
margins are scaled to 0-1 scale. When <code>FALSE</code>, the average and top
statistics of the negative logarithm of the <code>p</code>-values are only computed
for the univariate case.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_ranking.approximation">ranking.approximation</code></td>
<td>
<p>Logical, if <code>FALSE</code>, select only tests with <code>p</code>-values 
more extreme than <code>p_star</code> to halve and further test. FWER control not guaranteed.
If <code>TRUE</code>, choose at each resolution the <code>M</code> tests with the most extreme 
<code>p</code>-values to further halve and test.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_m">M</code></td>
<td>
<p>A positive integer (or Inf), the number of top ranking
tests to continue to split at each resolution. FWER control not guaranteed 
for this method.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_apply.stopping.rule">apply.stopping.rule</code></td>
<td>
<p>Logical. If TRUE, an adjusted <code>p</code>-value is computed for each resolution,</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Threshold below which resolution-specific <code>p</code>-values trigger early stopping.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_test.method">test.method</code></td>
<td>
<p>String, choose &quot;Fisher&quot; for Fisher's exact test (slowest), &quot;chi.sq&quot; for
Chi-squared test, &quot;LR&quot; for likelihood-ratio test and &quot;norm.approx&quot; for approximating
the hypergeometric distribution with a normal distribution (fastest).</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_correct">correct</code></td>
<td>
<p>Logical, if <code>TRUE</code> compute mid-p corrected <code>p</code>-values for
Fisher's exact test, or Yates corrected <code>p</code>-values for the Chi-squared test,
or Williams corrected <code>p</code>-values for the likelihood-ratio test.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_min.tbl.tot">min.tbl.tot</code></td>
<td>
<p>Non-negative integer, the minimal number of observations
per table below which a <code>p</code>-value for a given table will not be computed.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_min.row.tot">min.row.tot</code></td>
<td>
<p>Non-negative integer, the minimal number of observations
for row totals in the 2x2 contingency tables below which a contingency table will not be tested.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_min.col.tot">min.col.tot</code></td>
<td>
<p>Non-negative integer, the minimal number of observations
for column totals in the 2x2 contingency tables below which a contingency table will not be tested.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_p.adjust.methods">p.adjust.methods</code></td>
<td>
<p>String, choose between &quot;H&quot; for Holm, &quot;Hcorrected&quot; for Holm with
the correction as specified in <code>correct</code>.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_compute.all.holm">compute.all.holm</code></td>
<td>
<p>Logical, if <code>FALSE</code>, only global <code>p</code>-value is
computed (may be a little faster when any tests are performed). If <code>TRUE</code>
adjusted <code>p</code>-values are computed for all tests.</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_return.all.pvs">return.all.pvs</code></td>
<td>
<p>Logical, if TRUE, a data frame with all <code>p</code>-values
is returned (not applicable when stopping rule is applied)</p>
</td></tr>
<tr><td><code id="MultiFIT_+3A_verbose">verbose</code></td>
<td>
<p>Logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>p.values.holistic</code>, a named numerical vector containing the holistic <code>p</code>-values of
for the global null hypothesis (i.e. x independent of y).
</p>
<p><code>p.values.resolution.specific</code>, a named numerical vector containing the 
reslution specific <code>p</code>-values of for the global null hypothesis (i.e. x independent of y).
</p>
<p><code>res.by.res.pvs</code>, a dta frame that contains the raw and Bonferroni adjusted
resolution specific <code>p</code>-values.
</p>
<p><code>all.pvs</code>, a data frame that contains all <code>p</code>-values and adjusted
<code>p</code>-values that are computed. Returned if <code>return.all.pvs</code> is <code>TRUE</code>.
</p>
<p><code>all</code>, a nested list. Each entry is named and contains data about a resolution
that was tested. Each resolution is a list in itself, with <code>cuboids</code>, a summary of
all tested cuboids in a resolution, <code>tables</code>, a summary of all 2x2
contingency tables in a resolution, <code>pv</code>, a numerical vector containing the
<code>p</code>-values from the tests of independence on 2x2 contingency table in <code>tables</code>
that meet the criteria defined by <code>min.tbl.tot</code>, <code>min.row.tot</code> and <code>min.col.tot</code>.
The length of <code>pv</code> is equal to the number of rows of <code>tables</code>. <code>pv.correct</code>,
similar to the above <code>pv</code>, corrected <code>p</code>-values are computed and returned when
<code>correct</code> is <code>TRUE</code>. <code>rank.tests</code>, logical vector that indicates
whether or not a test was ranked among the top <code>M</code> tests in a resolution. The
length of <code>rank.tests</code> is equal to the number of rows of <code>tables</code>. <code>parent.cuboids</code>,
an integer vector, indicating which cuboids in a resolution are associated with
the ranked tests, and will be further halved in the next higher resolution.
<code>parent.tests</code>, a logical vector of the same length as the
number of rows of <code>tables</code>, indicating whether or not a test was chosen as a parent
test (same tests may have multiple children).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n = 300
Dx = Dy = 2
x = matrix(0, nrow = n, ncol = Dx)
y = matrix(0, nrow = n, ncol = Dy)
x[,1] = rnorm(n)
x[,2] = runif(n)
y[,1] = rnorm(n)
y[,2] = sin(5 * pi * x[ , 2]) + 1 / 5 * rnorm(n)
fit = MultiFIT(x = x, y = y, verbose = TRUE)
w = MultiSummary(x = x, y = y, fit = fit, alpha = 0.0001)
</code></pre>

<hr>
<h2 id='MultiSummary'>Summary of significant tests</h2><span id='topic+MultiSummary'></span>

<h3>Description</h3>

<p>Provide a post-hoc summary of significant tests. See vignettes for further examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiSummary(xy, x = NULL, y = NULL, fit, alpha = 0.05,
  only.rk = NULL, use.pval = NULL, plot.tests = TRUE, pch = NULL,
  rd = 2, plot.margin = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiSummary_+3A_xy">xy</code></td>
<td>
<p>A list, whose first element corresponds to the matrix x as below, and
its second element corresponds to the matrix y as below.
if <code>xy</code> is not specified, <code>x</code> and <code>y</code> need to be assigned.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_x">x</code></td>
<td>
<p>A matrix, number of columns = dimension of random vector,
number of rows = number of observations.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_y">y</code></td>
<td>
<p>A matrix, number of columns = dimension of random vector,
number of rows = number of observations.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_fit">fit</code></td>
<td>
<p>An object generated by <code>MultiFIT</code>.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_alpha">alpha</code></td>
<td>
<p>Numeric, only tests with adjusted <code>p</code>-values less than <code>alpha</code>
are presented in the output.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_only.rk">only.rk</code></td>
<td>
<p>Positive integer vector. Show only tests that are ranked according to
<code>only.rk</code> and have adjusted <code>p</code>-value below <code>alpha</code>. If left as <code>NULL</code>,
all tests with adjusted <code>p</code>-values less than <code>alpha</code>
are presented in the output.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_use.pval">use.pval</code></td>
<td>
<p>String, choose between <code>"H"</code> (for Holm), <code>"Hcorrected"</code>
(for Holm on corrected <code>p</code>-values) or <code>"MH"</code> for modified Holm.
If left <code>NULL</code>, the order of preference is <code>"MH"</code>, <code>"Hcorrected"</code> and
then <code>"H"</code>, according to which is present in the object <code>fit</code>.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_plot.tests">plot.tests</code></td>
<td>
<p>Logical, plot the marginal scatter plots that are associated with
the presented significant tests.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_pch">pch</code></td>
<td>
<p>Point style for plots. If left as <code>NULL</code>, a default combination of
crosses and bullets is applied.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_rd">rd</code></td>
<td>
<p>Numeric, number of figures to round to when presenting ranges of variables.</p>
</td></tr>
<tr><td><code id="MultiSummary_+3A_plot.margin">plot.margin</code></td>
<td>
<p>Logical, plot the marginal scatter plot of the margins that
are associated with each significant test, without highlighting which points
are conditioned on and are in the discretized 2x2 contingency table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List whose elements are <code>significant.tests</code>, a data frame that summarizes
the main features of the tests and their overall ranking by <code>p</code>-value and
<code>original.scale.cuboids</code>, a list whose number of elements is equal to the number of
significant tests (the same number of rows of the data frame <code>significant.tests</code>). Each
element corresponds to a test and is a list whose elements are the marginal ranges of
the associated cuboid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n = 300
Dx = Dy = 2
x = matrix(0, nrow = n, ncol = Dx)
y = matrix(0, nrow = n, ncol = Dy)
x[,1] = rnorm(n)
x[,2] = runif(n)
y[,1] = rnorm(n)
y[,2] = sin(5 * pi * x[ , 2]) + 1 / 5 * rnorm(n)
fit = MultiFIT(x = x, y = y, verbose = TRUE)
w = MultiSummary(x = x, y = y, fit = fit, alpha = 0.0001)
</code></pre>

<hr>
<h2 id='MultiTree'>Plot tree structure of tests on 2x2 contingency tables</h2><span id='topic+MultiTree'></span>

<h3>Description</h3>

<p>Plot a post-hoc tree of all tests or all significant tests on 2x2 discretized
contingency tables. See vignettes for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiTree(xy, x = NULL, y = NULL, fit, show.all = FALSE,
  max.node.size = 5, min.node.size = 2.5, use.pval = NULL,
  images.path = NULL, node.name = "node", filename = NULL,
  filetype = "pdf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiTree_+3A_xy">xy</code></td>
<td>
<p>A list (optional), whose first element corresponds to the matrix x as below, and
its second element corresponds to the matrix y as below.
if <code>xy</code> is not specified, <code>x</code> and <code>y</code> need to be assigned. If <code>xy</code>,
<code>x</code> and <code>y</code> are missing or <code>NULL</code>, the tree nodes are blank. If
<code>xy</code> or <code>x</code> and <code>y</code> are provided, nodes are <code>png</code> images of the marginal
scatter plots that are associated with each test.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_x">x</code></td>
<td>
<p>A matrix (optional), number of columns = dimension of random vector,
number of rows = number of observations. If <code>xy</code>,
<code>x</code> and <code>y</code> are missing or <code>NULL</code>, the tree nodes are blank. If
<code>xy</code> or <code>x</code> and <code>y</code> are provided, nodes are <code>png</code> images of the marginal
scatter plots that are associated with each test.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_y">y</code></td>
<td>
<p>A matrix (optional), number of columns = dimension of random vector,
number of rows = number of observations. If <code>xy</code>,
<code>x</code> and <code>y</code> are missing or <code>NULL</code>, the tree nodes are blank. If
<code>xy</code> or <code>x</code> and <code>y</code> are provided, nodes are <code>png</code> images of the marginal
scatter plots that are associated with each test.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_fit">fit</code></td>
<td>
<p>An object generated by <code>multiFit</code>.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_show.all">show.all</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all tests are shown. If <code>FALSE</code>
only tests who were ranked in each resolution amongst the top <code>M</code> ranking tests
are shown. See <code>?multiFit</code> for an explanation about the parameter <code>M</code> and see
documentation for further information.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_max.node.size">max.node.size</code></td>
<td>
<p>Numeric. Maximal node size. All nodes are scaled between <code>min.node.size</code> and
<code>max.node.size</code>, where larger nodes are associated smaller <code>p</code>-values of the corresponding tests
on 2x2 contingency tables.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_min.node.size">min.node.size</code></td>
<td>
<p>Numeric. Minimal node size. All nodes are scaled between <code>min.node.size</code> and
<code>max.node.size</code>, where larger nodes are associated smaller <code>p</code>-values of the corresponding tests
on 2x2 contingency tables.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_use.pval">use.pval</code></td>
<td>
<p>String, choose between <code>"H"</code> (for Holm), <code>"Hcorrected"</code>
(for Holm on corrected <code>p</code>-values) or <code>"MH"</code> for modified Holm.
If left <code>NULL</code>, the order of preference is <code>"MH"</code>, <code>"Hcorrected"</code> and
then <code>"H"</code>, according to which is present in the object <code>fit</code>.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_images.path">images.path</code></td>
<td>
<p>String, path to save <code>png</code> images of nodes to. If not
specified, images are saved to <code>tempdir()</code>.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_node.name">node.name</code></td>
<td>
<p>String, prefix for file names for nodes <code>png</code>s.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_filename">filename</code></td>
<td>
<p>String, file name for tree output. If left <code>NULL</code>, file name
is prefixed by <code>multiTree</code> and ends with system time. See documentation of
<code>qgraph::qgraph</code> for further information.</p>
</td></tr>
<tr><td><code id="MultiTree_+3A_filetype">filetype</code></td>
<td>
<p>String, default is <code>pdf</code>, See documentation of
<code>qgraph::qgraph</code> for further information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The main output of multiTree is a <code>pdf</code> file with the directed acyclic graph
showing tests as nodes.
</p>
<p>In addition, the function returns a list. Its elements are:
<code>qgraph.object</code>, the graphical object generated by the <code>qgraph</code> function. See
the <code>qgraph</code> package documentation for further details.
<code>qgraph.call</code>, the call for the tree generating function. Arguments for
the call: <code>adj</code>, the adjacency matrix, <code>nodes.size</code>, a numeric vector with the
scaled sizes of the nodes, <code>images</code>, the file names of the nodes images (may be
<code>NULL</code>), <code>filename</code> as passed to <code>multiTree</code> and passed over to <code>qgraph</code>,
and <code>filetype</code> as passed to <code>multiTree</code> and passed over to <code>qgraph</code>.
</p>
<p>Other elements of the returned list are <code>pvs.attributes</code>, the attributes summarizing the
data and the tests performed as stored in <code>fit</code>, and <code>n.nodes</code>, the number of nodes.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
