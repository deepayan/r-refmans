<!DOCTYPE html><html lang="en"><head><title>Help for package ifs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ifs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ifs'>
<p>IFS estimator</p></a></li>
<li><a href='#ifs.FT'>
<p>IFS estimator</p></a></li>
<li><a href='#IFSM'>
<p>IFSM operator</p></a></li>
<li><a href='#ifsm.cf'><p>Calculates the main parameters of the IFSM operator</p></a></li>
<li><a href='#ifsm.setQF'><p>Sets up the quadratic form for the IFSM</p></a></li>
<li><a href='#ifsm.w.maps'><p>Set up the parameters for the maps of the IFSM operator</p></a></li>
<li><a href='#ifsp.cf'><p>Calculates the main parameters of the IFS estimators</p></a></li>
<li><a href='#ifsp.setQF'><p>Sets up the quadratic form for the IFSP</p></a></li>
<li><a href='#ifsp.w.maps'><p>Set up the parameters for the maps of the IFSP operator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1.10</td>
</tr>
<tr>
<td>Title:</td>
<td>Iterated Function Systems</td>
</tr>
<tr>
<td>Author:</td>
<td>S. M. Iacus</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefano M. Iacus &lt;siacus@iq.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Iterated Function Systems Estimator as in Iacus and La Torre (2005) &lt;<a href="https://doi.org/10.1155%2FJAMDS.2005.33">doi:10.1155/JAMDS.2005.33</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-05 05:59:54 UTC; jago</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-05 08:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ifs'>
IFS estimator
</h2><span id='topic+ifs'></span><span id='topic+ifs.flex'></span><span id='topic+IFS'></span>

<h3>Description</h3>

<p>Distribution function estimator based on sample quantiles.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifs(x, p, s, a, k = 5)
ifs.flex(x, p, s, a, k = 5, f = NULL)
IFS(y, k = 5, q = 0.5, f = NULL, n = 512, maps = c("quantile", 
    "wl1", "wl2"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifs_+3A_x">x</code></td>
<td>
<p>where to estimate the distribution function</p>
</td></tr>
<tr><td><code id="ifs_+3A_p">p</code></td>
<td>
<p>the vector of coefficients <code class="reqn">p_i</code></p>
</td></tr>
<tr><td><code id="ifs_+3A_s">s</code></td>
<td>
<p>the vector of coefficients <code class="reqn">s_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="ifs_+3A_a">a</code></td>
<td>
<p>the vector of coefficients <code class="reqn">a_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="ifs_+3A_k">k</code></td>
<td>
<p>number of iterations, default = 5</p>
</td></tr>
<tr><td><code id="ifs_+3A_y">y</code></td>
<td>
<p>a vector of sample observations</p>
</td></tr>
<tr><td><code id="ifs_+3A_q">q</code></td>
<td>
<p>the proportion of quantiles to use in the construction of the 
estimator, default = 0.5. The number of quantiles is the 
<code>q * length(y)</code>.</p>
</td></tr> 
<tr><td><code id="ifs_+3A_f">f</code></td>
<td>
<p>the starting point in the space of distribution functions</p>
</td></tr>
<tr><td><code id="ifs_+3A_n">n</code></td>
<td>
<p>the number of points in which to calculate the IFS</p>
</td></tr>
<tr><td><code id="ifs_+3A_maps">maps</code></td>
<td>
<p>type of affine maps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This estimator is intended to estimate the continuous distribution
function of a random variable on [0,1]. The estimator is a continuous
function not everywhere differentiable.
</p>


<h3>Value</h3>

<p>The estimated value of the distribution function for <code>ifs</code> and <code>ifs.flex</code> or
a list of &lsquo;x&rsquo; and &lsquo;y&rsquo; coordinates of the IFS(x) graph for <code>IFS</code>.
</p>


<h3>Note</h3>

<p>It is asymptotically as good as the empirical distribution function
(see Iacus and La Torre, 2001).  
This function is called by <a href="#topic+IFS">IFS</a>. If you need to call the function
several times, you should better use <code>ifs</code> providing the
points and coefficients once instead of <code>IFS</code>.
Empirical evidence shows that the IFS-estimator is better than the edf (even 
for very small samples) in the sup-norm metric. It is also better in the MSE
sense outside of the distribution's tails if the sample quantiles are used
as points.
</p>


<h3>Author(s)</h3>

<p>S. M. Iacus</p>


<h3>References</h3>

<p>Iacus, S.M, La Torre, D. (2005)
Approximating distribution functions by iterated function systems, 
<em>Journal of Applied Mathematics and Decision Sciences</em>,
1, 33-46.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ecdf">ecdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ifs)


y&lt;-rbeta(50,.5,.1)

# uncomment if you want to test the normal distribution
# y&lt;-sort(rnorm(50,3,1))/6


IFS.est &lt;- IFS(y)
xx &lt;- IFS.est$x
tt &lt;- IFS.est$y

ss &lt;- pbeta(xx,.5,.1)

# uncomment if you want to test the normal distribution   
# ss &lt;- pnorm(6*xx-3)
     
par(mfrow=c(2,1))   
  
plot(ecdf(y),xlim=c(0,1),main="IFS estimator versus EDF")
lines(xx,ss,col="blue")
lines(xx,tt,col="red")


# calculates MSE


ww &lt;- ecdf(y)(xx)
mean((ww-ss)^2)
mean((tt-ss)^2)

plot(xx,(ww-ss)^2,main="MSE",type="l",xlab="x",ylab="MSE(x)")
lines(xx,(tt-ss)^2,col="red")
</code></pre>

<hr>
<h2 id='ifs.FT'>
IFS estimator
</h2><span id='topic+ifs.FT'></span><span id='topic+ifs.setup.FT'></span><span id='topic+ifs.pf.FT'></span><span id='topic+ifs.df.FT'></span><span id='topic+IFS.pf.FT'></span><span id='topic+IFS.df.FT'></span>

<h3>Description</h3>

<p>Distribution function estimator based on inverse Fourier transform of ans IFSs.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifs.FT(x, p, s, a, k = 2)
ifs.setup.FT(m, p, s, a, k = 2, cutoff)
ifs.pf.FT(x,b,nterms)
ifs.df.FT(x,b,nterms)
IFS.pf.FT(y, k = 2, n = 512, maps=c("quantile","wl1","wl2")) 
IFS.df.FT(y, k = 2, n = 512, maps=c("quantile","wl1","wl2")) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifs.FT_+3A_x">x</code></td>
<td>
<p>where to estimate the function</p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_p">p</code></td>
<td>
<p>the vector of coefficients <code class="reqn">p_i</code></p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_s">s</code></td>
<td>
<p>the vector of coefficients <code class="reqn">s_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_a">a</code></td>
<td>
<p>the vector of coefficients <code class="reqn">a_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_m">m</code></td>
<td>
<p>the vector of sample moments</p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_k">k</code></td>
<td>
<p>number of iterations, default = 2</p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_y">y</code></td>
<td>
<p>a vector of sample observations</p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_n">n</code></td>
<td>
<p>the number of points in which to calculate the estimator</p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_maps">maps</code></td>
<td>
<p>type of affine maps</p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_b">b</code></td>
<td>
<p>the Fourier coefficients</p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_nterms">nterms</code></td>
<td>
<p>the number of significant Fourier coefficients after the cutoff</p>
</td></tr>
<tr><td><code id="ifs.FT_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff used to determine how many Fourier coefficients are needed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This estimator is intended to estimate the continuous distribution
function, the charateristic function (Fourier transform) and the density function
of a random variable on [0,1]. 
</p>


<h3>Value</h3>

<p>The estimated value of the Fourier transform  for <code>ifs.FT</code>, the estimated value
of the distribution function for <code>ifs.pf.FT</code> and the estimated value
of the density function for <code>ifs.df.FT</code>. 
A list of &lsquo;x&rsquo; and &lsquo;y&rsquo; coordinates plus the Fourier coefficients and the number of
significant coefficients of the distribution function estimator for <code>IFS.pf.FT</code> 
and the density function for <code>IFS.df.FT</code>.
The function <code>ifs.setup.FT</code> return a list of Fourier coefficients and the number
of significant coefficients.
</p>


<h3>Note</h3>

<p>Details of this tecnique can be found in Iacus and La Torre, 2002.
</p>


<h3>Author(s)</h3>

<p>S. M. Iacus</p>


<h3>References</h3>

<p>Iacus, S.M, La Torre, D. (2005)
Approximating distribution functions by iterated function systems, 
<em>Journal of Applied Mathematics and Decision Sciences</em>,
1, 33-46.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ecdf">ecdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ifs)


nobs &lt;- 100
y&lt;-rbeta(nobs,2,4)

# uncomment if you want to test the normal distribution
# y&lt;-sort(rnorm(nobs,3,1))/6


IFS.est &lt;- IFS(y)
xx &lt;- IFS.est$x
tt &lt;- IFS.est$y

ss &lt;- pbeta(xx,2,4)

# uncomment if you want to test the normal distribution   
# ss &lt;- pnorm(6*xx-3)
     
par(mfrow=c(3,1))   
  
plot(ecdf(y),xlim=c(0,1),main="IFS estimator versus EDF")
lines(xx,ss,col="blue")
lines(IFS.est,col="red")
IFS.FT.est &lt;- IFS.pf.FT(y)
xxx &lt;- IFS.FT.est$x
uuu &lt;- IFS.FT.est$y
sss &lt;- pbeta(xxx,2,4)
# uncomment if you want to test the normal distribution   
# sss &lt;- pnorm(6*xxx-3)

lines(IFS.FT.est,col="green")


# calculates MSE


ww &lt;- ecdf(y)(xx)
mean((ww-ss)^2)
mean((tt-ss)^2)
mean((uuu-sss)^2)

plot(xx,(ww-ss)^2,main="MSE",type="l",xlab="x",ylab="MSE(x)")
lines(xx,(tt-ss)^2,col="red")
lines(xxx,(uuu-sss)^2,col="green")

plot(IFS.df.FT(y),type="l",col="green",ylim=c(0,3),main="IFS vs Kernel")
lines(density(y),col="blue")
curve(dbeta(x,2,4),0,1,add=TRUE)
# uncomment if you want to test the normal distribution   
# curve(6*dnorm(x*6-3,0,1),0,1,add=TRUE)
</code></pre>

<hr>
<h2 id='IFSM'>
IFSM operator
</h2><span id='topic+IFSM'></span>

<h3>Description</h3>

<p>IFSM operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IFSM(x, cf, a, s, k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IFSM_+3A_x">x</code></td>
<td>
<p>where to approximate the function</p>
</td></tr>
<tr><td><code id="IFSM_+3A_cf">cf</code></td>
<td>
<p>the vector of coefficients <code class="reqn">phi_i</code></p>
</td></tr>
<tr><td><code id="IFSM_+3A_s">s</code></td>
<td>
<p>the vector of coefficients <code class="reqn">s_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="IFSM_+3A_a">a</code></td>
<td>
<p>the vector of coefficients <code class="reqn">a_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="IFSM_+3A_k">k</code></td>
<td>
<p>number of iterations, default = 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operator is intended to approximate a function on L2[0,1].
If &lsquo;u&rsquo; is simulated, then the IFSM can be used to simulate a IFSM
version of &lsquo;u&rsquo;.
</p>


<h3>Value</h3>

<p>The value of the approximate target function.
</p>


<h3>Author(s)</h3>

<p>S. M. Iacus</p>


<h3>References</h3>

<p>Iacus, S.M, La Torre, D. (2005)
IFSM representation of Brownian motion with applications to simulation, 
<em>forthcoming</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ifs)

set.seed(123)
n &lt;- 50
dt &lt;- 1/n
t &lt;- (1:n)*dt
Z &lt;- rnorm(n)
B &lt;- sqrt(dt)*cumsum(Z)

ifsm.w.maps() -&gt; maps
a &lt;- maps$a
s &lt;- maps$s

ifsm.setQF(B, s, a) -&gt; QF
ifsm.cf(QF$Q,QF$b,QF$L1,QF$L2,s)-&gt; SOL
psi &lt;- SOL$psi

t1 &lt;- seq(0,1,length=250)
as.numeric(sapply(t1, function(x) IFSM(x,psi,a,s,k=5))) -&gt; B.ifsm
old.mar &lt;- par()$mar
old.mfrow &lt;- par()$mfrow
par(mfrow=c(2,1))
par(mar=c(4,4,1,1))
plot(t1,B.ifsm,type="l",xlab="time",ylab="IFSM")
plot(t,B,col="red",type="l",xlab="time",ylab="Euler scheme")
par(mar=old.mar)
par(mfrow=old.mfrow)
</code></pre>

<hr>
<h2 id='ifsm.cf'>Calculates the main parameters of the IFSM operator</h2><span id='topic+ifsm.cf'></span>

<h3>Description</h3>

<p>Tool function to construct and find the solution of the minimization
problem involving the quadratic form <code class="reqn">x'Qx + b'x</code>. Not an optimal one.
You can provide one better then this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifsm.cf(Q, b, d, l2, s, mu=1e-4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifsm.cf_+3A_q">Q</code></td>
<td>
<p>the matrix <code class="reqn">Q</code> of <code class="reqn">x'Qx + b'x</code></p>
</td></tr>
<tr><td><code id="ifsm.cf_+3A_b">b</code></td>
<td>
<p>the vector <code class="reqn">b</code> of <code class="reqn">x'Qx + b'x</code></p>
</td></tr>
<tr><td><code id="ifsm.cf_+3A_d">d</code></td>
<td>
<p>the L1 norm of the target function</p>
</td></tr>
<tr><td><code id="ifsm.cf_+3A_l2">l2</code></td>
<td>
<p>the L2 norm of the target function</p>
</td></tr>
<tr><td><code id="ifsm.cf_+3A_s">s</code></td>
<td>
<p>the vector <code class="reqn">s</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="ifsm.cf_+3A_mu">mu</code></td>
<td>
<p>tolerance</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list
</p>
<table role = "presentation">
<tr><td><code>cf</code></td>
<td>
<p>the vector of the coefficients to be plugged into the IFSM</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>the collage distance at the solution</p>
</td></tr>
</table>


<h3>References</h3>

<p>Iacus, S.M, La Torre, D. (2005)
IFSM representation of Brownian motion with applications to simulation, 
<em>forthcoming</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IFSM">IFSM</a></code>
</p>

<hr>
<h2 id='ifsm.setQF'>Sets up the quadratic form for the IFSM</h2><span id='topic+ifsm.setQF'></span>

<h3>Description</h3>

<p>Tool function to construct the quadratic form <code class="reqn">x'Qx + b'x + l2</code> to be 
minimized under some constraint depending on l1. This is used to construct
the IFSM operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifsm.setQF(u, s, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifsm.setQF_+3A_u">u</code></td>
<td>
<p>the vector of values of the target function u</p>
</td></tr>
<tr><td><code id="ifsm.setQF_+3A_s">s</code></td>
<td>
<p>the vector of coefficients <code class="reqn">s_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="ifsm.setQF_+3A_a">a</code></td>
<td>
<p>the vector of coefficients <code class="reqn">a_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operator is intended to approximate a function on L2[0,1].
If &lsquo;u&rsquo; is simulated, then the IFSM can be used to simulate a IFSM
version of &lsquo;u&rsquo;.
</p>


<h3>Value</h3>

<p>List of elements
</p>
<table role = "presentation">
<tr><td><code>Q</code></td>
<td>
<p>the matrix of the quadratic form</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the matrix of the quadratic form</p>
</td></tr>
<tr><td><code>L1</code></td>
<td>
<p>the L1 norm of the target function</p>
</td></tr>
<tr><td><code>L2</code></td>
<td>
<p>the L2 norm of the target function</p>
</td></tr>
<tr><td><code>M1</code></td>
<td>
<p>the integral of the target function</p>
</td></tr>		
</table>


<h3>Author(s)</h3>

<p>S. M. Iacus</p>


<h3>References</h3>

<p>Iacus, S.M, La Torre, D. (2005)
IFSM representation of Brownian motion with applications to simulation, 
<em>forthcoming</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IFSM">IFSM</a></code>
</p>

<hr>
<h2 id='ifsm.w.maps'>Set up the parameters for the maps of the IFSM operator</h2><span id='topic+ifsm.w.maps'></span>

<h3>Description</h3>

<p>This is called before calling <code>ifsm.setQF</code> to prepare the
parameters to be passed in <code>ifsm.setQF</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifsm.w.maps(M=8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifsm.w.maps_+3A_m">M</code></td>
<td>
<p>M is such that <code>sum(2^(1:M))</code> maps are created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 
</p>
<table role = "presentation">
<tr><td><code>a</code></td>
<td>
<p>the vector of the coefficents &lsquo;a&rsquo; in the maps</p>
</td></tr>	
<tr><td><code>s</code></td>
<td>
<p>the vector of the coefficents &lsquo;s&rsquo; in the maps</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>S. M. Iacus</p>


<h3>See Also</h3>

<p><code><a href="#topic+IFSM">IFSM</a></code>
</p>

<hr>
<h2 id='ifsp.cf'>Calculates the main parameters of the IFS estimators</h2><span id='topic+ifsp.cf'></span>

<h3>Description</h3>

<p>Tool function to construct and find the solution of the minimization
problem involving the quadratic form <code class="reqn">x'Qx + b'x</code>. Not an optimal one.
You can provide one better then this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifsp.cf(Q,b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifsp.cf_+3A_q">Q</code></td>
<td>
<p>the matrix <code class="reqn">Q</code> of <code class="reqn">x'Qx + b'x</code></p>
</td></tr>
<tr><td><code id="ifsp.cf_+3A_b">b</code></td>
<td>
<p>the vector <code class="reqn">b</code> of <code class="reqn">x'Qx + b'x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>the vector of the coefficients to be plugged into the IFS</p>
</td></tr>
</table>


<h3>References</h3>

<p>Iacus, S.M, La Torre, D. (2005)
Approximating distribution functions by iterated function systems, 
<em>Journal of Applied Mathematics and Decision Sciences</em>,
1, 33-46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifs">ifs</a></code>
</p>

<hr>
<h2 id='ifsp.setQF'>Sets up the quadratic form for the IFSP</h2><span id='topic+ifsp.setQF'></span>

<h3>Description</h3>

<p>Tool function to construct the quadratic form <code class="reqn">x'Qx + b'x</code> to be minimized
to construct the IFSP operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifsp.setQF(m, s, a, n = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifsp.setQF_+3A_m">m</code></td>
<td>
<p>the vector of the sample or true moments of the target function</p>
</td></tr>
<tr><td><code id="ifsp.setQF_+3A_s">s</code></td>
<td>
<p>the vector of coefficients <code class="reqn">s_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="ifsp.setQF_+3A_a">a</code></td>
<td>
<p>the vector of coefficients <code class="reqn">a_i</code> in: <code class="reqn">w_i = s_i *x + a_i</code></p>
</td></tr>
<tr><td><code id="ifsp.setQF_+3A_n">n</code></td>
<td>
<p>number of parameter to use in the IFSP operator, default = 10</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operator is intended to approximate a continuous distribution
function of a random variable on [0,1]. If moments are estimated on
a random sample, then the IFSP operator is an estimator of the
distribution function of the data.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Q</code></td>
<td>
<p>the matrix of the quadratic form</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the matrix of the quadratic form</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>S. M. Iacus</p>


<h3>References</h3>

<p>Iacus, S.M, La Torre, D. (2005)
Approximating distribution functions by iterated function systems, 
<em>Journal of Applied Mathematics and Decision Sciences</em>,
1, 33-46.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifs">ifs</a></code>
</p>

<hr>
<h2 id='ifsp.w.maps'>Set up the parameters for the maps of the IFSP operator</h2><span id='topic+ifsp.w.maps'></span>

<h3>Description</h3>

<p>This is called before calling <code>ifsp.setQF</code> to prepare the
parameters to be passed in <code>ifsp.setQF</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifsp.w.maps(y, maps = c("quantile","wl1","wl2"), qtl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifsp.w.maps_+3A_y">y</code></td>
<td>
<p>the vector of the sample observations</p>
</td></tr>
<tr><td><code id="ifsp.w.maps_+3A_maps">maps</code></td>
<td>
<p>type of maps: quantile, wl1 or wl2</p>
</td></tr>
<tr><td><code id="ifsp.w.maps_+3A_qtl">qtl</code></td>
<td>
<p>instead of passing the data y you can pass a vector
of quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>the vector of the empirical moments</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>the vector of the coefficents &lsquo;a&rsquo; in the maps</p>
</td></tr>	
<tr><td><code>s</code></td>
<td>
<p>the vector of the coefficents &lsquo;s&rsquo; in the maps</p>
</td></tr>	
<tr><td><code>n</code></td>
<td>
<p>the number of maps</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>S. M. Iacus</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifs">ifs</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
