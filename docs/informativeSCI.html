<!DOCTYPE html><html lang="en"><head><title>Help for package informativeSCI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {informativeSCI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#informativeSCI-package'><p>informativeSCI: Informative Simultaneous Confidence Intervals</p></a></li>
<li><a href='#explore_q'><p>Exploration of the Information Weights</p></a></li>
<li><a href='#funcBisec'><p>Bisection function</p></a></li>
<li><a href='#inExactSCI'><p>Checking Precision of Approximations</p></a></li>
<li><a href='#informSCI'><p>Calculation of Lower Informative SCI-bounds</p></a></li>
<li><a href='#notInExactSCI'><p>Checking Precision of Approximations</p></a></li>
<li><a href='#sigmaManyToOne'><p>Calculation of the Covariance Matrix for a Many-to-one-Comparison</p></a></li>
<li><a href='#weightsGTP'><p>Function for determining the (monotone part of the) local significance levels</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Informative Simultaneous Confidence Intervals</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Liane Kluge &lt;liane@uni-bremen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculation of informative simultaneous confidence intervals
    for graphical described multiple test procedures and given information
    weights. Bretz et al. (2009) &lt;<a href="https://doi.org/10.1002%2Fsim.3495">doi:10.1002/sim.3495</a>&gt; and Brannath et
    al. (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2402.13719">doi:10.48550/arXiv.2402.13719</a>&gt;. Furthermore, exploration of the
    behavior of the informative bounds in dependence of the information
    weights.  Comparisons with compatible bounds are possible.
    Strassburger and Bretz (2008) &lt;<a href="https://doi.org/10.1002%2Fsim.3338">doi:10.1002/sim.3338</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LianeKluge/informativeSCI">https://github.com/LianeKluge/informativeSCI</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LianeKluge/informativeSCI/issues">https://github.com/LianeKluge/informativeSCI/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>gMCP (&ge; 0.8-17)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm (&ge; 1.2-4)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-21 10:50:34 UTC; liane</td>
</tr>
<tr>
<td>Author:</td>
<td>Liane Kluge [aut, cre],
  Werner Brannath [ctb],
  Martin Scharpenberg [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-21 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='informativeSCI-package'>informativeSCI: Informative Simultaneous Confidence Intervals</h2><span id='topic+informativeSCI'></span><span id='topic+informativeSCI-package'></span>

<h3>Description</h3>

<p>Calculation of informative simultaneous confidence intervals for graphical described multiple test procedures and given information weights. Bretz et al. (2009) <a href="https://doi.org/10.1002/sim.3495">doi:10.1002/sim.3495</a> and Brannath et al. (2024) <a href="https://doi.org/10.48550/arXiv.2402.13719">doi:10.48550/arXiv.2402.13719</a>. Furthermore, exploration of the behavior of the informative bounds in dependence of the information weights. Comparisons with compatible bounds are possible. Strassburger and Bretz (2008) <a href="https://doi.org/10.1002/sim.3338">doi:10.1002/sim.3338</a>.
</p>


<h3>Details</h3>

<p>The main function of the package is the <a href="#topic+informSCI">informSCI</a>-function for
calculating informative lower simultaneous confidence bounds for a given
graphical test procedure and given information weights. The
<a href="#topic+explore_q">explore_q</a>-function can help to find the right information weights
for the <a href="#topic+informSCI">informSCI</a>-algorithm. The <a href="#topic+inExactSCI">inExactSCI</a>- and
<a href="#topic+notInExactSCI">notInExactSCI</a>-functions can help to determine how accurate a
(numerical) approximation of the true informative lower SCI-bounds is.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Liane Kluge <a href="mailto:liane@uni-bremen.de">liane@uni-bremen.de</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Werner Brannath [contributor]
</p>
</li>
<li><p> Martin Scharpenberg [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>F. Bretz, W. Maurer, W. Brannath, M. Posch: A graphical approach
to sequentially rejective multiple test procedures. Statistics in Medicine
28.4 (2009), pp. 586-604.
</p>
<p>K. Strassburger, F. Bretz: Compatible simultaneous lower confidence bounds
for the Holm procedure and other Bonferroni based closed tests. Statistics
in Medicine 27.4 (2008), pp. 4914-4927.
S. Schmidt, W. Brannath: Informative Simultaneous Confidence Intervals
in Hierarchical Testing. Methods of Information in Medicine 53.4 (2014),
pp. 278–283.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/LianeKluge/informativeSCI">https://github.com/LianeKluge/informativeSCI</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/LianeKluge/informativeSCI/issues">https://github.com/LianeKluge/informativeSCI/issues</a>
</p>
</li></ul>


<hr>
<h2 id='explore_q'>Exploration of the Information Weights</h2><span id='topic+explore_q'></span>

<h3>Description</h3>

<p>The function calculates various statistical quantities giving some
information about the behavior of informative lower SCI-bounds
(<a href="#topic+informSCI">informSCI</a>) and its induced test for a given graphical test procedure
with m hypotheses. The simulation is done for different information weights
of the hypotheses. These statistical quantities are intended to be used for
determining information weights that represent the best possible trade-off
between the number of rejections and the expected size of the informative
lower informative SCI-bounds. The statistical quantities can also be
calculated for the graphical test and the related compatible lower
SCI-bounds, which allows a comparison between the two strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explore_q(
  gMCP = NULL,
  g = NULL,
  weights = NULL,
  trueParam,
  sigma = NULL,
  qFixed = matrix(0, 0, 2),
  mu_0 = 0,
  alpha = 0.05,
  addHyp = matrix(0, 0, 3),
  allRej = NULL,
  atLeastOneRej = NULL,
  qGrid = NULL,
  qInterval = c(0, 1),
  qStepSize = 1/10,
  numSim = 1000,
  sampleSizes = NULL,
  sampleSizeControl = NULL,
  varObs = NULL,
  exploreGraph = TRUE,
  eps = 1/10^5,
  timesSmallerEps = 3,
  maxIterSCI = 1000,
  maxIterBisec = 1000,
  tolBisec = 1/10^3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explore_q_+3A_gmcp">gMCP</code></td>
<td>
<p>An object of class <code><a href="gMCP.html#topic+graphMCP">graphMCP</a></code> indicating the
underlying graphical test.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_g">g</code></td>
<td>
<p>Numeric square matrix of transition weights for the graphical test
with m rows and m columns. The i-th row of the entered matrix defines the
arrows starting from the i-th hypothesis. Each entry has to be between
0 and 1 and each row must sum to a number less than or equal to 1. The
diagonal elements must be zero. Entering <code>g</code> and <code>weights</code> can be
used as the input as an alternative to specifying <code>gMCP</code>.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of weights of dimension m. It defines the
initial proportion of significance level which is assigned to each null
hypothesis. Entering <code>g</code> and <code>weights</code> can be used as the input as
an alternative to specifying <code>gMCP</code>.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_trueparam">trueParam</code></td>
<td>
<p>A numeric vector of dimension m defining the assumed true
parameters <code class="reqn">\vartheta_i, 1\leq i\leq m</code>.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_sigma">sigma</code></td>
<td>
<p>A covariance matrix of dimension <code class="reqn">m\times m</code>. <code>sigma</code>
indicates the covariance matrix of the point estimators for the parameter
of interest. Can be missing in the case of a many-to-one comparison.
Then, <code>sampleSizes</code>, <code>sampleSizeControl</code> and <code>varObs</code>
must be specified.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_qfixed">qFixed</code></td>
<td>
<p>A numeric matrix with l rows and 2 columns, where l is an
integer between 0 and m. The matrix describes the fixed information weights
of the simulation. The first column indicates the indices of the hypothesis
for which the information weight should be fixed during the simulation
(i.e. the entries of the first column must be natural numbers between
1 and m). The second column contains the fixed values of their respective
fixed information weights (i.e. the entries of the second column must be
between 0 and 1 (inclusive)). It is permissible for all information weights
to be fixed  (i.e. <code>qFixed</code> has m rows) or none to be fixed
(i.e. <code>qFixed</code> has 0 rows).</p>
</td></tr>
<tr><td><code id="explore_q_+3A_mu_0">mu_0</code></td>
<td>
<p>A numeric vector of dimension 1 or m defining the bounds of the
null hypotheses of the underlying graphical test. If <code>mu_0</code> has
dimension 1, the same value is used for each null hypothesis.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_alpha">alpha</code></td>
<td>
<p>A numeric defining the overall significance level for the
graphical test (i.e. SCIs will have coverage probability of at least
<code class="reqn">1-</code><code>alpha</code>. The parameter must be strictly between 0 and 1.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_addhyp">addHyp</code></td>
<td>
<p>A numeric matrix with k rows and 3 columns (k can be 0)
The matrix indicates for which (further) shifted hypotheses the rejection
probability is to be calculated. Every row describes one hypothesis.
The first entry is a natural number greater than m identifying the
hypothesis. The second entry of each row is the index of the corresponding
parameter of interest. The third entry is the right border of the hypothesis.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_allrej">allRej</code></td>
<td>
<p>A list of vectors. Each vector in the list contains the indices
of subfamilies of the family of all hypotheses, including the <code>addHyp</code>.
The indices of the null hypotheses of the underlying graph range from 1 to m.
The indices for <code>addHyp</code> are given by the first column of <code>addHyp</code>.
For each such family, the probability of rejecting all hypotheses at the same
time is calculated.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_atleastonerej">atLeastOneRej</code></td>
<td>
<p>A list of vectors. Each vector in the list contains the
indices of subfamilies of the family of all hypotheses, including
the <code>addHyp</code>. The indices of the null hypotheses of the underlying graph
range from 1 to m. The indices for <code>addHyp</code> are given by the first
column of <code>addHyp</code>. For each such family, the probability of rejecting
at least one hypothesis is calculated.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_qgrid">qGrid</code></td>
<td>
<p>A numeric vector indicating the values of the non-fixed
information weights for the simulation. The entries must be between 0 and 1
(inclusive).</p>
</td></tr>
<tr><td><code id="explore_q_+3A_qinterval">qInterval</code></td>
<td>
<p>A numeric vector of dimension 2 specifying the minimum
and maximum values allowed for the varying information weights.
<code>qInterval</code> and <code>qStepsize</code> can be used as the input as an
alternative to specifying <code>qGrid</code>. If all are entered, <code>qGrid</code>
is used and <code>qInterval</code> and <code>qStepSize</code> are ignored.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_qstepsize">qStepSize</code></td>
<td>
<p>A positive numeric defining the step size for the varying
information weights. <code>qInterval</code> and <code>qStepsize</code> can be used as
the input as an alternative to specifying <code>qGrid</code>.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_numsim">numSim</code></td>
<td>
<p>A natural number indicating how many simulations are to be
performed.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_samplesizes">sampleSizes</code></td>
<td>
<p>A numeric vector indicating the sample size of each
non-control group, in the many-to-one case. Not required if <code>sigma</code>
is entered.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_samplesizecontrol">sampleSizeControl</code></td>
<td>
<p>A numeric indicating the sample size of the control
group, in the many-to-one case. Not required if <code>sigma</code> is entered.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_varobs">varObs</code></td>
<td>
<p>A positive numeric indicating the variance of the individual
observations, in the many-to-one case. Not required if <code>sigma</code> is
entered.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_exploregraph">exploreGraph</code></td>
<td>
<p>A boolean indicating whether the simulation should be
also done for the underlying graphical test and the corresponding compatible
lower SCI-bounds.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_eps">eps</code></td>
<td>
<p>A numeric for the <code>informSCI</code>-algorithm indicating the
desired strict upper bound on the Chebyshev distance between two successive
calculated approximations (the Chebyshev distance is induced by
the maximum norm).</p>
</td></tr>
<tr><td><code id="explore_q_+3A_timessmallereps">timesSmallerEps</code></td>
<td>
<p>A positive integer for the <code>informSCI</code>-algorithm
indicating how many times the Chebyshev distance of two successive
calculated approximations should be less than <code>eps</code> in succession. Here
we use the convention <code class="reqn">-\infty- (-\infty):=0</code>.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_maxitersci">maxIterSCI</code></td>
<td>
<p>Maximum number of iterations for determining the lower
informative SCI-bounds.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_maxiterbisec">maxIterBisec</code></td>
<td>
<p>Maximum number of iterations of the bisection method
which is used during the <code>informSCI</code>-algorithm for finding roots.</p>
</td></tr>
<tr><td><code id="explore_q_+3A_tolbisec">tolBisec</code></td>
<td>
<p>A non-negative numeric indicating the error tolerance of
the bisection method which is used for finding roots in the
<code>informSCI</code>-algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that there are m parameters of interest
<code class="reqn">\vartheta_1,\dots,\vartheta_m</code>. For each parameter there is a null
hypothesis defined as <code class="reqn">H_i^{{\mu_0}_i}:\vartheta_i\leq{\mu_0}_i</code>.
The bounds <code class="reqn">{\mu_0}</code> correspond to <code>mu_0</code>. The underlying graphical
test (specified by <code>gMCP</code> or <code>g</code> and <code>weights</code>) is based on
these hypotheses.
</p>
<p>The function simulates estimations of point estimators for the parameter of
interest <code class="reqn">\vartheta_1,\dots, \vartheta_m</code>. The estimators follow a
multivariate normal distribution with mean <code>trueParam</code> and covariance
matrix <code>sigma</code>. The function repeatedly calls the
<code><a href="#topic+informSCI">informSCI</a></code>-function.
</p>
<p>The algorithm only optimizes for a single parameter, which is used for all
non-fixed information weights.
The parameter is chosen from a grid specified by <code>qInterval</code> and
<code>qStepsize</code>. The constructed grid contains all values which are between
<code>qInterval[1]</code> and <code>qInterval[2]</code> and can be written as
<code>qInterval[1]</code><code class="reqn">+k\cdot</code><code>qStepsize</code> where k is a natural number.
Alternatively, the parameter is chosen directly from <code>qGrid</code>.
</p>


<h3>Value</h3>

<p>The function returns a list containing several statistical quantities
to use for the informative lower SCI-bounds to find the best possible
trade-off between the number of rejections and the expected size of the
informative lower SCI-bounds. In the case that  <code>exploreGraph=TRUE</code>,
the returned list also contains the same quantities for the (original)
graphical test and related compatible bounds. This allows a comparison.
</p>

<ul>
<li> <p><code>rejecHyp</code>: A matrix containing for several hypotheses the
empirical rejection probability by the informative confidence bounds.
The first m rows correspond to the hypotheses of the graph. The other rows
correspond to the hypotheses specified by <code>addHyp</code>. Each row indicates
the rejection probability for different values of the information weights.
</p>
</li>
<li> <p><code>meanISCI</code>: A matrix containing in its columns the empirical mean
of the lower informative confidence bounds for different information weights.
Only the lower bounds which are greater than <code>-Inf</code> are used for the
empirical mean.
</p>
</li>
<li> <p><code>impISCI</code>: A matrix containing in its columns the empirical
average distance between the lower informative confidence bounds and
<code>mu_0</code> for different information weights. Only the lower bounds which
are greater than <code>-Inf</code> are used for the empirical average distance.
</p>
</li>
<li> <p><code>biasISCI</code>: A matrix containing in its columns the empirical
average distance between the lower informative confidence bounds and the
true parameters <code>trueParam</code> for different information weights. Only the
lower bounds which are greater than <code>-Inf</code> are used for the empirical
average distance.
</p>
</li>
<li> <p><code>numISCIfinite</code>: A matrix containing in its columns how many times
the lower informative confidence bounds were each greater than <code>-Inf</code>
for different information weights.
</p>
</li>
<li> <p><code>rejecAllHyp</code>: A matrix containing in its columns for each family
from <code>allRej</code> the empirical probability of rejecting all of the
hypotheses from the family with the induced test at the same time for
different information weights.
</p>
</li>
<li> <p><code>rejecAtLeastHyp</code>: A matrix containing in its columns for each
family from <code>atLeastOneRej</code> the empirical probability of rejecting
at least one of the hypotheses from the family with the induced test for
different information weights.
</p>
</li></ul>

<p>If <code>exploreGraph=TRUE</code>:
</p>

<ul>
<li> <p><code>rejecHypGraph</code>: A vector containing for each of the null
hypotheses of the graph and of the additional hypotheses (specified by
<code>addHyp</code>) its empirical rejection probability by the original graph.
</p>
</li>
<li> <p><code>meanCSCI</code>: A vector containing, for each parameter
<code class="reqn">\vartheta_i, 1\leq i\leq m</code> the empirical mean of the lower compatible
confidence bounds. Only the lower bounds which are greater than <code>-Inf</code>
are used for the empirical mean.
</p>
</li>
<li> <p><code>impCSCI</code>: A vector containing, for each parameter, the empirical
average distance between the lower compatible confidence bounds and
<code>mu_0</code>. Only the lower bounds which are greater than <code>-Inf</code> are
used.
</p>
</li>
<li> <p><code>biasCSCI</code>: A vector containing, for each parameter,
the empirical average distance between the lower compatible confidence bounds
and the true parameters <code>trueParam</code>. Only the lower bounds which are
greater than <code>-Inf</code> are used.
</p>
</li>
<li> <p><code>numCSCIfinite</code>: A vector containing, for each parameter, how
many times the compatible lower confidence bounds were each greater
than <code>-Inf</code>.
</p>
</li>
<li> <p><code>rejecAllHypCSCI</code>: A vector containing, for each family from
<code>allRej</code>, the empirical probability of rejecting all of the hypotheses
from the family with the (original) graphical test.
</p>
</li>
<li> <p><code>rejecAtLeastHypCSCI</code>: A vector containing, for each family from
<code>atLeastOneRej</code>, the empirical probability of rejecting at least one
of the hypotheses from the family with the (original) graphical test.
</p>
</li></ul>



<h3>References</h3>

<p>S. Schmidt, W. Brannath: Informative simultaneous confidence intervals
for the fallback procedure. Biometrical Journal 57.4 (2015), pp. 712–719.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+informSCI">informSCI</a></code> <code><a href="gMCP.html#topic+gMCP">gMCP</a></code>
<code><a href="gMCP.html#topic+simConfint">simConfint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explore_q(gMCP=BonferroniHolm(3), trueParam=c(1.5,1,0.2),
sigma=diag(3)*0.2, qFixed=matrix(c(2,3,0.3,0.3),2,2), mu_0=c(-0.5,0,0),
addHyp=matrix(c(4,1,0),1,3),allRej =list(c(1,2), c(4,2)), 
atLeastOneRej=list(c(2,3)),numSim=100)
explore_q(g=matrix(c(0,0,1,0),2,2), weights=c(1,0), trueParam=c(0.5,2), 
mu_0=c(-1,0), alpha=0.025, qGrid=c(1/10*c(1:10),c(0.97,0.98,0.99)), 
numSim=100, sampleSizes=c(89,95), sampleSizeControl=77, varObs=10)

</code></pre>

<hr>
<h2 id='funcBisec'>Bisection function</h2><span id='topic+funcBisec'></span>

<h3>Description</h3>

<p>Bisection function to find solutions of the key equation of the
<code>informSCI</code>-algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcBisec(f_1, f_2, a, b, maxIter = 1000, tol = 1/10^3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="funcBisec_+3A_f_1">f_1</code></td>
<td>
<p>Left side of the key equation as a function in one variable.</p>
</td></tr>
<tr><td><code id="funcBisec_+3A_f_2">f_2</code></td>
<td>
<p>Right side of the key equation as a function in one variable.</p>
</td></tr>
<tr><td><code id="funcBisec_+3A_a">a</code></td>
<td>
<p>A real value indicating the left bound of the search region.
<code class="reqn">f_1(a)\leq f_2(a)</code> must hold true.</p>
</td></tr>
<tr><td><code id="funcBisec_+3A_b">b</code></td>
<td>
<p>A real value indicating the right bound of the search region.
<code class="reqn">f_1(b)\geq f_2(b)</code> must hold true.</p>
</td></tr>
<tr><td><code id="funcBisec_+3A_maxiter">maxIter</code></td>
<td>
<p>A positive integer defining the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="funcBisec_+3A_tol">tol</code></td>
<td>
<p>A non-negative numeric indicating the error tolerance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function tries to find a solution of the key equation of the
<code>informSCI</code>-algorithm which is equivalent to  determining the
intersection point of <code>f_1</code> and <code>f_2</code>.
The function uses the bisection method and tries to determine the root
of the function <code>f_1-f_2</code>. Note that by definition of the key equation
and the assumptions of the <code>informSCI</code>-algorithm <code>f_1-f_2</code> is
a continuous strictly increasing function. Because of the assumptions on
<code>a</code> and <code>b</code> <code>f_1-f_2</code> has a non-positive function value in
point <code>a</code> and non-negative function value in point <code>b</code>. Thus,
<code>f_1-f_2</code> has exactly one root in the closed interval <code class="reqn">[a,b]</code>.
</p>
<p>The bisection method repeatedly halves the interval between <code>a</code> and
<code>b</code>. The function stops when the root is found or when the maximum
number of iterations is reached or when the interval is less than <code>tol</code>.
</p>


<h3>Value</h3>

<p>Returns intersection point. In the case that no intersection point
is found, the left side of the final interval is returned, rather than the
midpoint. The returned point is a lower approximation of the solution of the
key equation.
</p>

<hr>
<h2 id='inExactSCI'>Checking Precision of Approximations</h2><span id='topic+inExactSCI'></span>

<h3>Description</h3>

<p>The functions checks whether information about the precision of an
approximation for the informative lower SCI-bounds can be collected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inExactSCI(
  L,
  randomShifts = 0,
  shifts = NULL,
  tolTrueSCI,
  gMCP = NULL,
  g = NULL,
  weights = NULL,
  q,
  estimates = NULL,
  Z = NULL,
  pValues = NULL,
  SE = NULL,
  I = NULL,
  mu_0,
  alpha,
  checkInput = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inExactSCI_+3A_l">L</code></td>
<td>
<p>An m-dimensional non-negative vector whose entries are the lower
bounds of an approximation of the informative SCI.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_randomshifts">randomShifts</code></td>
<td>
<p>A positive integer indicating how many random directions
of length <code>tolTrueSCI</code> should be generated.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_shifts">shifts</code></td>
<td>
<p>A matrix with m columns and any number of rows. Each entry must
be non-negative. Each row is a direction in the m-dimensional real space.
Each row must have at least one positive entry. <code>randomShifts</code> should
be a positive integer or <code>shifts</code> should contain at least one row.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_toltruesci">tolTrueSCI</code></td>
<td>
<p>The randomly generated shift-vectors and the row vectors
in <code>shifts</code> are rescaled to have length <code>tolTrueSCI</code>.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_gmcp">gMCP</code></td>
<td>
<p>An object of class <code><a href="gMCP.html#topic+graphMCP">graphMCP</a></code> indicating the
underlying graphical test.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_g">g</code></td>
<td>
<p>Numeric square matrix of transition weights for the graphical test
with m rows and m columns. The i-th row of the entered matrix defines the
arrows starting from the i-th hypothesis. Each entry has to be between
0 and 1 and each row must sum to a number less than or equal to 1. The
diagonal elements must be zero. Entering <code>g</code> and <code>weights</code> can be
used as the input as an alternative to specifying <code>gMCP</code>.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of weights of dimension m. It defines the
initial proportion of significance level which is assigned to each null
hypothesis. Entering <code>g</code> and <code>weights</code> can be used as the input as
an alternative to specifying <code>gMCP</code>.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_q">q</code></td>
<td>
<p>A numeric vector of dimension 1 or m defining the information
weights for each hypothesis. The entries have to be between 0 and 1
(inclusive). If <code>q</code> has dimension 1, the same information weight is
used for each hypothesis.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_estimates">estimates</code></td>
<td>
<p>An m-dimensional numeric vector of unbiased point estimates
for the parameters of interest. Each estimator is assumed to be
(asymptotically) normal.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_z">Z</code></td>
<td>
<p>An m-dimensional numeric vector of z-scores for testing the null
hypotheses. <code>Z</code> can be entered as an alternative to <code>estimates</code>.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_pvalues">pValues</code></td>
<td>
<p>An m-dimensional numeric vector of p-values from (asymptotic)
z-tests for testing the null hypotheses. <code>pValues</code> can be entered as an
alternative to <code>estimates</code> and <code>Z</code>.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_se">SE</code></td>
<td>
<p>A positive numeric vector of dimension 1 or m indicating the
standard errors of the point estimators. If <code>SE</code> has dimension 1, the
same value is used for each estimator.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_i">I</code></td>
<td>
<p>A positive numeric vector indicating the information of the
estimators. It can be entered as an alternative to the vector <code>SE</code>.
The relationship <code>SE</code><code class="reqn">=1/</code><code>I</code><code class="reqn">^{1/2}</code> is assumed.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_mu_0">mu_0</code></td>
<td>
<p>A numeric vector of dimension 1 or m defining the bounds of the
null hypotheses of the underlying graphical test. If <code>mu_0</code> has
dimension 1, the same value is used for each null hypothesis.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_alpha">alpha</code></td>
<td>
<p>A numeric defining the overall significance level for the
graphical test (i.e. SCIs will have coverage probability of at least
<code class="reqn">1-</code><code>alpha</code>. The parameter must be strictly between 0 and 1.</p>
</td></tr>
<tr><td><code id="inExactSCI_+3A_checkinput">checkInput</code></td>
<td>
<p>A boolean specifying whether the entered values should be
checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks if it can be determined whether <code>L</code> can be shifted
by a randomly generated rescaled direction or by a rescaled direction in the
shift matrix such that it lies in the true SCI. If this is possible,
the approximation is precise.
(The random directions are generated in such a way that all entries are
positive.)
</p>
<p>Let m be the dimension of <code>L</code>. m also describes the number of
hypotheses of interest.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if we can determine that the approximation is
indeed precise. Returns <code>FALSE</code> if we cannot determine that the
approximation is precise. (The approximation may still be precise.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+informSCI">informSCI</a></code> <code><a href="#topic+explore_q">explore_q</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- matrix(c(0,0,1,0),2,2)
weights &lt;- c(1,0)
q &lt;- c(0.0068,1)
mu_0 &lt;- c(-1,0)
pValues &lt;- c(0.0002,0.01)
SE &lt;- c(0.31,1.11)
alpha &lt;- 0.025
L &lt;- informSCI(g=g, weights=weights, q=q, mu_0=mu_0, pValues=pValues, SE=SE,
alpha=alpha, eps=1/10^5, tolBisec=1/10^5)$L
# When the randomShifts- or shift-parameter in the informSCI-function is
# specified, the inExactSCI-function is called by the informSCI-function.
# It is also possible to analyse the accuracy of a calculated L (or an 
# approximation of the lower informative SCI-bounds) by directly using 
# the inExactSCI-function:
inExactSCI(L=L, randomShifts=100, tolTrueSCI=1/10^5, g=g, weights=weights,
q=q, pValues=pValues, SE=SE, mu_0=mu_0, alpha=alpha)
</code></pre>

<hr>
<h2 id='informSCI'>Calculation of Lower Informative SCI-bounds</h2><span id='topic+informSCI'></span>

<h3>Description</h3>

<p>The function calculates informative lower SCI-bounds for a given graph of m
hypotheses and given information weights. m is a natural number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>informSCI(
  gMCP = NULL,
  g = NULL,
  weights = NULL,
  q,
  mu_0 = 0,
  estimates = NULL,
  Z = NULL,
  pValues = NULL,
  SE = NULL,
  I = NULL,
  alpha = 0.05,
  eps = 1/10^5,
  timesSmallerEps = 3,
  randomShifts = 0,
  shifts = NULL,
  tolTrueSCI = sqrt(ifelse(!is.null(gMCP), length(getWeights(gMCP)), length(weights))) *
    eps,
  maxIter = 1000,
  maxIterBisec = 1000,
  tolBisec = 1/10^5,
  calculateCSCI = TRUE,
  checkInput = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="informSCI_+3A_gmcp">gMCP</code></td>
<td>
<p>An object of class <code><a href="gMCP.html#topic+graphMCP">graphMCP</a></code> indicating the
underlying graphical test.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_g">g</code></td>
<td>
<p>Numeric square matrix of transition weights for the graphical test
with m rows and m columns. The i-th row of the entered matrix defines the
arrows starting from the i-th hypothesis. Each entry has to be between
0 and 1 and each row must sum to a number less than or equal to 1. The
diagonal elements must be zero. Entering <code>g</code> and <code>weights</code> can be
used as the input as an alternative to specifying <code>gMCP</code>.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of weights of dimension m. It defines the
initial proportion of significance level which is assigned to each null
hypothesis. Entering <code>g</code> and <code>weights</code> can be used as the input as
an alternative to specifying <code>gMCP</code>.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_q">q</code></td>
<td>
<p>A numeric vector of dimension 1 or m defining the information
weights for each hypothesis. The entries have to be between 0 and 1
(inclusive). If <code>q</code> has dimension 1, the same information weight is
used for each hypothesis.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_mu_0">mu_0</code></td>
<td>
<p>A numeric vector of dimension 1 or m defining the bounds of the
null hypotheses of the underlying graphical test. If <code>mu_0</code> has
dimension 1, the same value is used for each null hypothesis.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_estimates">estimates</code></td>
<td>
<p>An m-dimensional numeric vector of unbiased point estimates
for the parameters of interest. Each estimator is assumed to be
(asymptotically) normal.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_z">Z</code></td>
<td>
<p>An m-dimensional numeric vector of z-scores for testing the null
hypotheses. <code>Z</code> can be entered as an alternative to <code>estimates</code>.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_pvalues">pValues</code></td>
<td>
<p>An m-dimensional numeric vector of p-values from (asymptotic)
z-tests for testing the null hypotheses. <code>pValues</code> can be entered as an
alternative to <code>estimates</code> and <code>Z</code>.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_se">SE</code></td>
<td>
<p>A positive numeric vector of dimension 1 or m indicating the
standard errors of the point estimators. If <code>SE</code> has dimension 1, the
same value is used for each estimator.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_i">I</code></td>
<td>
<p>A positive numeric vector indicating the information of the
estimators. It can be entered as an alternative to the vector <code>SE</code>.
The relationship <code>SE</code><code class="reqn">=1/</code><code>I</code><code class="reqn">^{1/2}</code> is assumed.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_alpha">alpha</code></td>
<td>
<p>A numeric defining the overall significance level for the
graphical test (i.e. SCIs will have coverage probability of at least
<code class="reqn">1-</code><code>alpha</code>. The parameter must be strictly between 0 and 1.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_eps">eps</code></td>
<td>
<p>A numeric indicating the desired strict upper bound on the
Chebyshev distance between two successive calculated approximations (the
Chebyshev distance is induced by the maximum norm).</p>
</td></tr>
<tr><td><code id="informSCI_+3A_timessmallereps">timesSmallerEps</code></td>
<td>
<p>A positive integer indicating how many times the
Chebyshev distance of two successive calculated approximations should be
less than <code>eps</code> in succession. Here we use the convention
<code class="reqn">|-\infty-(-\infty)|:=0</code>.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_randomshifts">randomShifts</code></td>
<td>
<p>A positive integer indicating how many random directions
of length <code>tolTrueSCI</code> should be generated. At the end of the algorithm
the parameter is passed to the <code><a href="#topic+inExactSCI">inExactSCI</a></code>- and the
<code><a href="#topic+notInExactSCI">notInExactSCI</a></code>-functions to determine whether the approximation
<code>L</code> of the true lower SCI-bounds is precise or imprecise.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_shifts">shifts</code></td>
<td>
<p>A matrix with m columns and any number of rows. Each entry must
be non-negative. Each row is a direction in the m-dimensional real space.
Each row must have at least one positive entry. At the end of the algorithm
the parameter is passed to the <code><a href="#topic+inExactSCI">inExactSCI</a></code>- and the
<code><a href="#topic+notInExactSCI">notInExactSCI</a></code>-functions to determine whether the approximation
<code>L</code> of the true lower SCI-bounds is precise or imprecise.
<code>randomShifts</code> must be a positive integer or <code>shifts</code> must contain
at least one row. It is recommended to choose <code>randomShifts</code><code class="reqn">&gt;0</code>
or enter a <code>shifts</code>-matrix with at least one row. Entering both
parameters is also permissible.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_toltruesci">tolTrueSCI</code></td>
<td>
<p>The randomly generated shift-vectors and the row vectors
in <code>shifts</code> are rescaled to have length <code>tolTrueSCI</code>. It is
recommended to choose <code>tolTrueSCI</code> greater than
<code class="reqn">\sqrt{m}\cdot</code><code>eps</code> and greater than <code>tolBisec</code>.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_maxiter">maxIter</code></td>
<td>
<p>Maximum number of iterations for determining the lower
informative SCI bounds.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_maxiterbisec">maxIterBisec</code></td>
<td>
<p>Maximum number of iterations of the bisection method
which is used during the algorithm for finding roots.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_tolbisec">tolBisec</code></td>
<td>
<p>A non-negative numeric indicating the error tolerance of the
bisection method which is used for finding roots.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_calculatecsci">calculateCSCI</code></td>
<td>
<p>A boolean indicating whether compatible bounds should
also be calculated.</p>
</td></tr>
<tr><td><code id="informSCI_+3A_checkinput">checkInput</code></td>
<td>
<p>A boolean specifying whether the entered values should be
checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that there are m parameters of interest
<code class="reqn">\vartheta_1,\dots,\vartheta_m</code>. For each parameter there is a null
hypothesis defined as <code class="reqn">H_i^{{\mu_0}_i}:\vartheta_i\leq{\mu_0}_i</code>.
The bounds <code class="reqn">{\mu_0}</code> correspond to <code>mu_0</code>. The parameter <code>gMCP</code>
or the parameters <code>g</code> and <code>weights</code> define a graphical multiple
test procedure for the hypotheses.
</p>
<p>The algorithm further assumes that for each hypothesis there is an unbiased
point estimator which is (asymptotically) normal.
The <code>informSCI</code>-algorithm is based on the p-values from the
corresponding (asymptotic) z-tests.
</p>
<p>The algorithm terminates when the Chebyshev distance of two successive
calculated approximations is less than <code>eps</code>
<code>timesSmallerEps</code>-times in succession or if the maximum number of
iterations is reached.
</p>
<p>The function also tries to find information about the precision of the final
calculated approximation of the true lower informative SCI-bounds by
calling the <code><a href="#topic+inExactSCI">inExactSCI</a></code>- and the
<code><a href="#topic+notInExactSCI">notInExactSCI</a></code>-functions.
</p>
<p>For further details see the given references.
</p>


<h3>Value</h3>

<p>The function returns a list containing the calculated lower
informative SCI-bounds as well as compatible lower SCI-bounds
(if <code>calculateCSCI==TRUE</code>) to allow a comparison. Additionally, the
returned list contains elements which can give some information about the
precision of the calculated lower informative SCI-bounds compared to the
true informative SCI-bounds.
</p>

<ul>
<li> <p><code>L</code>: A numeric vector of dimension m of the lower informative
SCI-bounds
</p>
</li>
<li> <p><code>rejecHyp</code>: A boolean vector of dimension m indicating the rejected
hypotheses of the multiple test induced by the informative SCI-bounds
</p>
</li>
<li> <p><code>diffApprox</code>: A non-negative numeric indicating the Chebyshev distance
between the calculated last two approximations of the lower informative
SCI-bounds.
</p>
</li>
<li> <p><code>timesApprSmallerEps</code>: A natural number between 0 and
<code>timesSmallerEps</code> indicating how many times the Chebyshev distance of
two successive calculated approximations in succession  was less than
<code>eps</code> when the algorithm terminated.
</p>
</li>
<li> <p><code>numIter</code>: A natural number indicating the number of iterations
required by the algorithm.
</p>
</li>
<li> <p><code>accuracyL</code>: A string containing information about the collected
information about the precision of the calculated lower informative
SCI-bounds compared with the true lower SCI-bounds.
</p>
</li></ul>

<p>If <code>calculateCSCI=TRUE</code>:
</p>

<ul>
<li> <p><code>informSCIcompatible</code>: A boolean vector of dimension m indicating
whether each informative bound is compatible to the test decision
about its corresponding null hypothesis by the underlying graphical test.
</p>
</li>
<li> <p><code>cSCI</code>: A numeric vector of dimension m of compatible lower
SCI-bounds from <code><a href="gMCP.html#topic+simConfint">simConfint</a></code>.
</p>
</li>
<li> <p><code>rejecHypGraph</code>: A boolean vector of dimension m indicating the
rejected hypotheses of the underlying graphical test.
</p>
</li></ul>



<h3>References</h3>

<p>F. Bretz, W. Maurer, W. Brannath, M. Posch: A graphical approach
to sequentially rejective multiple test procedures. Statistics in Medicine
28.4 (2009), pp. 586-604.
</p>
<p>K. Strassburger, F. Bretz: Compatible simultaneous lower confidence bounds
for the Holm procedure and other Bonferroni based closed tests. Statistics
in Medicine 27.4 (2008), pp. 4914-4927.
</p>
<p>S. Schmidt, W. Brannath: Informative Simultaneous Confidence Intervals
in Hierarchical Testing. Methods of Information in Medicine 53.4 (2014),
pp. 278–283.
</p>


<h3>See Also</h3>

<p><code><a href="gMCP.html#topic+gMCP">gMCP</a></code> <code><a href="gMCP.html#topic+simConfint">simConfint</a></code>
<code><a href="#topic+explore_q">explore_q</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>informSCI(gMCP=BonferroniHolm(3), q=0.3, mu_0=-0.5 ,estimates=c(0,2,-1),
SE=0.1467)
Z &lt;- (c(0,2,-1)-(-0.5))/0.1467
informSCI(gMCP=BonferroniHolm(3), q=0.3, mu_0=-0.5, Z=Z, I=1/(0.1467^2),
randomShifts=100)
informSCI(g=matrix(c(0,0,1,0),2,2), weights=c(1,0), q=c(0.0068,1),
mu_0=c(-1,0), pValues=c(0.0002,0.01), SE=c(0.31,1.11), alpha=0.025, 
shifts=rbind(c(1,0),c(0,1),c(1,1)))
informSCI(g=matrix(c(0,0,1,0),2,2), weights=c(1,0), q=c(0.0068,1),
mu_0=c(-1,0), pValues=c(0.0002,0.01), I=1/c(0.31,1.11)^2, alpha=0.025, 
shifts=rbind(c(1,0),c(0,1),c(1,1)), calculateCSCI = FALSE)

</code></pre>

<hr>
<h2 id='notInExactSCI'>Checking Precision of Approximations</h2><span id='topic+notInExactSCI'></span>

<h3>Description</h3>

<p>The function checks whether information about the precision of
an approximation for the informative lower SCI-bounds can be collected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notInExactSCI(
  L,
  randomShifts = 0,
  shifts = NULL,
  tolTrueSCI,
  gMCP = NULL,
  g = NULL,
  weights = NULL,
  q,
  estimates = NULL,
  Z = NULL,
  pValues = NULL,
  SE = NULL,
  I = NULL,
  mu_0,
  alpha,
  checkInput = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="notInExactSCI_+3A_l">L</code></td>
<td>
<p>An m-dimensional non-negative vector whose entries are the lower
bounds of an approximation of the informative SCI.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_randomshifts">randomShifts</code></td>
<td>
<p>A positive integer indicating how many random directions
of length <code>tolTrueSCI</code> should be generated.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_shifts">shifts</code></td>
<td>
<p>A matrix with m columns and any number of rows. Each entry must
be non-negative. Each row is a direction in the m-dimensional real space.
Each row must have at least one positive entry.  <code>randomShifts</code> should
be a positive integer or <code>shifts</code> should contain at least one row.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_toltruesci">tolTrueSCI</code></td>
<td>
<p>The randomly generated shift-vectors and the row vectors
in <code>shifts</code> are rescaled to have length <code>tolTrueSCI</code>.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_gmcp">gMCP</code></td>
<td>
<p>An object of class <code><a href="gMCP.html#topic+graphMCP">graphMCP</a></code> indicating the
underlying graphical test.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_g">g</code></td>
<td>
<p>Numeric square matrix of transition weights for the graphical test
with m rows and m columns. The i-th row of the entered matrix defines the
arrows starting from the i-th hypothesis. Each entry has to be between
0 and 1 and each row must sum to a number less than or equal to 1. The
diagonal elements must be zero. Entering <code>g</code> and <code>weights</code> can be
used as the input as an alternative to specifying <code>gMCP</code>.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of weights of dimension m. It defines the
initial proportion of significance level which is assigned to each null
hypothesis. Entering <code>g</code> and <code>weights</code> can be used as the input as
an alternative to specifying <code>gMCP</code>.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_q">q</code></td>
<td>
<p>A numeric vector of dimension 1 or m defining the information
weights for each hypothesis. The entries have to be between 0 and 1
(inclusive). If <code>q</code> has dimension 1, the same information weight is
used for each hypothesis.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_estimates">estimates</code></td>
<td>
<p>An m-dimensional numeric vector of unbiased point estimates
for the parameters of interest. Each estimator is assumed to be
(asymptotically) normal.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_z">Z</code></td>
<td>
<p>An m-dimensional numeric vector of z-scores for testing the null
hypotheses. <code>Z</code> can be entered as an alternative to <code>estimates</code>.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_pvalues">pValues</code></td>
<td>
<p>An m-dimensional numeric vector of p-values from (asymptotic)
z-tests for testing the null hypotheses. <code>pValues</code> can be entered as an
alternative to <code>estimates</code> and <code>Z</code>.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_se">SE</code></td>
<td>
<p>A positive numeric vector of dimension 1 or m indicating the
standard errors of the point estimators. If <code>SE</code> has dimension 1, the
same value is used for each estimator.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_i">I</code></td>
<td>
<p>A positive numeric vector indicating the information of the
estimators. It can be entered as an alternative to the vector <code>SE</code>.
The relationship <code>SE</code><code class="reqn">=1/</code><code>I</code><code class="reqn">^{1/2}</code> is assumed.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_mu_0">mu_0</code></td>
<td>
<p>A numeric vector of dimension 1 or m defining the bounds of the
null hypotheses of the underlying graphical test. If <code>mu_0</code> has
dimension 1, the same value is used for each null hypothesis.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_alpha">alpha</code></td>
<td>
<p>A numeric defining the overall significance level for the
graphical test (i.e. SCIs will have coverage probability of at least
<code class="reqn">1-</code><code>alpha</code>. The parameter must be strictly between 0 and 1.</p>
</td></tr>
<tr><td><code id="notInExactSCI_+3A_checkinput">checkInput</code></td>
<td>
<p>A boolean specifying whether the entered values should be
checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks if it can be determined whether <code>L</code> can be shifted
by a rescaled randomly generated direction or by a rescaled direction in the
shift matrix such that it describes valid lower informative SCI bounds.
If this is possible, the approximation <code>L</code> is imprecise.
(The random directions are generated in such a way that all entries are
positive.)
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if we can determine that the approximation is
imprecise. Returns <code>FALSE</code> if we cannot determine that the
approximation is imprecise. (The approximation may still be imprecise.) Note
that <code>inExactSCI</code> and <code>notInExactSCI</code> could both return
<code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+informSCI">informSCI</a></code> <code><a href="#topic+explore_q">explore_q</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- matrix(c(0,0,1,0),2,2)
weights &lt;- c(1,0)
q &lt;- c(0.0068,1)
mu_0 &lt;- c(-1,0)
pValues &lt;- c(0.0002,0.01)
SE &lt;- c(0.31,1.11)
alpha &lt;- 0.025
L &lt;- informSCI(g=g, weights=weights, q=q, mu_0=mu_0, pValues=pValues, SE=SE,
alpha=alpha, eps=1/10, tolBisec=1/10)$L
# When the randomShifts- or shift-parameter in the informSCI-function is
# specified, the notInExactSCI-function is called by the informSCI-function.
# It is also possible to analyse the accuracy of a calculated L (or an 
# approximation of the lower informative SCI-bounds) by directly using 
# the notInExactSCI-function:
notInExactSCI(L=L, randomShifts=100, tolTrueSCI=1/10^5, g=g, weights=weights, 
q=q, pValues=pValues, SE=SE, mu_0=mu_0, alpha=alpha)
</code></pre>

<hr>
<h2 id='sigmaManyToOne'>Calculation of the Covariance Matrix for a Many-to-one-Comparison</h2><span id='topic+sigmaManyToOne'></span>

<h3>Description</h3>

<p>The function calculates the covariance matrix for many-to-one-comparisons.
The covariance matrix is calculated for the point estimators,
each defined by the difference between the empirical mean of one of
the experimental groups and the empirical mean of the control group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmaManyToOne(sampleSizes, sampleSizeControl, varObs, checkInput = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigmaManyToOne_+3A_samplesizes">sampleSizes</code></td>
<td>
<p>A numeric vector indicating the sample size of each
non-control group.</p>
</td></tr>
<tr><td><code id="sigmaManyToOne_+3A_samplesizecontrol">sampleSizeControl</code></td>
<td>
<p>A numeric indicating the sample size of the control
group.</p>
</td></tr>
<tr><td><code id="sigmaManyToOne_+3A_varobs">varObs</code></td>
<td>
<p>A positive numeric indicating the variance of the individual
observations.</p>
</td></tr>
<tr><td><code id="sigmaManyToOne_+3A_checkinput">checkInput</code></td>
<td>
<p>A boolean specifying whether the entered values should be
checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sigmaManyToOne(sampleSizes=c(89,95), sampleSizeControl=77,
 varObs=10)
</code></pre>

<hr>
<h2 id='weightsGTP'>Function for determining the (monotone part of the) local significance levels</h2><span id='topic+weightsGTP'></span>

<h3>Description</h3>

<p>Function for determining the monotone part (<code>eta.mu</code>) of the local
significance levels for the key equation of the informative SCI algorithm.
The function creates dual graphs and rejects some of its hypotheses to
obtain the local significance levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightsGTP(mu, g, weights, alpha, q, mu_0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightsGTP_+3A_mu">mu</code></td>
<td>
<p>A real-valued vector (-<code>Inf</code> is also allowed) of dimension m
indicating which dual graph should be created and which null hypotheses
should be rejected. <code>mu[i]&gt;mu_0[i]</code> iff the corresponding hypothesis is
rejected, <code class="reqn">1\leq i\leq m</code>.</p>
</td></tr>
<tr><td><code id="weightsGTP_+3A_g">g</code></td>
<td>
<p>A numeric square matrix of transition weights for the graphical
test procedure.</p>
</td></tr>
<tr><td><code id="weightsGTP_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of dimension m of initial weights for the
graphical test procedure.</p>
</td></tr>
<tr><td><code id="weightsGTP_+3A_alpha">alpha</code></td>
<td>
<p>Overall level of the graphical test procedure.</p>
</td></tr>
<tr><td><code id="weightsGTP_+3A_q">q</code></td>
<td>
<p>A numeric vector of dimension m of information weights.</p>
</td></tr>
<tr><td><code id="weightsGTP_+3A_mu_0">mu_0</code></td>
<td>
<p>A numeric vector of dimension m of bounds of the null hypotheses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>m = number of hypotheses.
</p>
<p>The function is not suitable if for all <code class="reqn">1\leq i\leq m</code> it holds
<code>q[i]==0</code> and <code>mu[i]&gt;mu_0[i]</code>.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of dimension m (<code>eta.mu</code>) used for
solving the key equation of the <code>informSCI</code> algorithm. It contains the
local levels in <code>mu</code> divided by <code>q^{max(mu-mu_0,0)}</code> or divided by
adapted information weights (only if <code>q[i]&gt;0</code>).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
