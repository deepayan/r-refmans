<!DOCTYPE html><html><head><title>Help for package SDEFSR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SDEFSR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.SDEFSR_Rules'><p>Filter rules in a <code>SDEFSR_Rules</code> object returning a new <code>SDEFSR_Rules</code> object</p></a></li>
<li><a href='#as.data.frame.SDEFSR_Dataset'><p>S3 function to convert into a data.frame the SDEFSR dataset</p>
</p>
<p>This function converts a SDEFSR_Dataset object into a data.frame</p></a></li>
<li><a href='#carTra'><p>Car evaluation dataset</p></a></li>
<li><a href='#carTst'><p>Car evaluation dataset</p></a></li>
<li><a href='#FUGEPSD'><p>Fuzzy Genetic Programming-based learning for Subgroup Discovery (FuGePSD) Algorithm.</p></a></li>
<li><a href='#germanTra'><p>German Credit data set</p></a></li>
<li><a href='#germanTst'><p>German Credit data set</p></a></li>
<li><a href='#habermanRules'><p>Haberman survival rule set</p></a></li>
<li><a href='#habermanTra'><p>Haberman survival data set</p></a></li>
<li><a href='#habermanTst'><p>Haberman survival data set</p></a></li>
<li><a href='#MESDIF'><p>Multiobjective Evolutionary Subgroup DIscovery Fuzzy rules (MESDIF) Algorithm</p></a></li>
<li><a href='#NMEEF_SD'><p>Non-dominated Multi-objective Evolutionary algorithm for Extracting Fuzzy rules in Subgroup Discovery (NMEEF-SD)</p></a></li>
<li><a href='#plot.SDEFSR_Rules'><p>Plot a rule set generated by a SDEFSR algorithm</p></a></li>
<li><a href='#print.SDEFSR_Dataset'><p>S3 function to print in console the contents of the dataset</p>
</p>
<p>This function shows the matrix of data uncoded.</p></a></li>
<li><a href='#read.dataset'><p>Reads a KEEL, ARFF or CSV data format file.</p></a></li>
<li><a href='#SDEFSR'><p>SDEFSR: A package for Subgroup Discovery with Evolutionary Fuzzy Systems in R</p></a></li>
<li><a href='#SDEFSR_DatasetFromDataFrame'><p>Creates a <code>SDEFSR_Dataset</code> object from a <code>data.frame</code></p></a></li>
<li><a href='#SDEFSR_GUI'><p>Launch a web interface for use the algorithms easily.</p></a></li>
<li><a href='#SDIGA'><p>Subgroup Discovery Iterative Genetic Algorithm (SDIGA)</p></a></li>
<li><a href='#sort.SDEFSR_Rules'><p>@title Return an ordered rule set by a given quality measure</p>
</p>
<p>@description This function sorts a rule set in descendant order by a given quality measure that are available on the object</p></a></li>
<li><a href='#summary.SDEFSR_Dataset'><p>S3 function to summary a SDEFSR_Dataset object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Subgroup Discovery with Evolutionary Fuzzy Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.22</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-24</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Angel M. Garcia &lt;agvico@ujaen.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of evolutionary fuzzy systems for the data mining task called
    "subgroup discovery". In particular, the algorithms presented in this package are:
    M. J. del Jesus, P. Gonzalez, F. Herrera, M. Mesonero (2007) &lt;<a href="https://doi.org/10.1109%2FTFUZZ.2006.890662">doi:10.1109/TFUZZ.2006.890662</a>&gt;
    M. J. del Jesus, P. Gonzalez, F. Herrera (2007) &lt;<a href="https://doi.org/10.1109%2FMCDM.2007.369416">doi:10.1109/MCDM.2007.369416</a>&gt;
    C. J. Carmona, P. Gonzalez, M. J. del Jesus, F. Herrera (2010) &lt;<a href="https://doi.org/10.1109%2FTFUZZ.2010.2060200">doi:10.1109/TFUZZ.2010.2060200</a>&gt;
    C. J. Carmona, V. Ruiz-Rodado, M. J. del Jesus, A. Weber, M. Grootveld, P. Gonz√°lez, D. Elizondo (2015) &lt;<a href="https://doi.org/10.1016%2Fj.ins.2014.11.030">doi:10.1016/j.ins.2014.11.030</a>&gt;
    It also provide a Shiny App to ease the analysis. The algorithms work with data sets provided in
    KEEL, ARFF and CSV format and also with data.frame objects. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SIMIDAT/SDEFSR">https://github.com/SIMIDAT/SDEFSR</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreign, methods, parallel, stats, utils, ggplot2, shiny (&ge;
0.11)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Angel M. Garcia [aut, cre],
  Pedro Gonzalez [aut, cph],
  Cristobal J. Carmona [aut, cph],
  Francisco Charte [ctb],
  Maria J. del Jesus [aut, cph]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-30 06:28:41 UTC; agvico</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-30 06:50:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.SDEFSR_Rules'>Filter rules in a <code>SDEFSR_Rules</code> object returning a new <code>SDEFSR_Rules</code> object</h2><span id='topic++5B.SDEFSR_Rules'></span>

<h3>Description</h3>

<p>Generates a new <code>SDEFSR_Rules</code> object containing the rules that passed the filter
specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SDEFSR_Rules'
SDEFSR_RulesObject[condition = T]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.SDEFSR_Rules_+3A_sdefsr_rulesobject">SDEFSR_RulesObject</code></td>
<td>
<p>The <code>SDEFSR_RulesObject</code> object to filter</p>
</td></tr>
<tr><td><code id="+2B5B.SDEFSR_Rules_+3A_condition">condition</code></td>
<td>
<p>Expression to filter the <code>SDEFSR_Rules</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions allows to filter the rule set by a given quality measure. The quality measures 
that are available are: <code>nVars, Coverage, Unusualness, Significance, FuzzySupport, 
    Support, FuzzyConfidence, Confidence, TPr and FPr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SDEFSR)
#Apply filter by unusualness
habermanRules[Unusualness &gt; 0.05]

#Also, you can make the filter as complex as you can
#Filter by Unusualness and TPr
habermanRules[Unusualness &gt; 0.05 &amp; TPr &gt; 0.9]


</code></pre>

<hr>
<h2 id='as.data.frame.SDEFSR_Dataset'>S3 function to convert into a data.frame the SDEFSR dataset
This function converts a SDEFSR_Dataset object into a data.frame</h2><span id='topic+as.data.frame.SDEFSR_Dataset'></span>

<h3>Description</h3>

<p>S3 function to convert into a data.frame the SDEFSR dataset
</p>
<p>This function converts a SDEFSR_Dataset object into a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SDEFSR_Dataset'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.SDEFSR_Dataset_+3A_x">x</code></td>
<td>
<p>The <code>SDEFSR_Dataset</code> object to view</p>
</td></tr>
<tr><td><code id="as.data.frame.SDEFSR_Dataset_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the as.data.frame function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, a <code>SDEFSR_Dataset</code> object has a list of of examples
and this examples are coded numerically. This function decode these examples and convert the list into a data.frame
</p>


<h3>Value</h3>

<p>a data.frame with the dataset uncoded. Numeric attributes are &quot;numeric&quot; class, while categorical attributes are &quot;factor&quot;
</p>
<p>@examples
</p>
<p>as.data.frame(habermanTra)
</p>

<hr>
<h2 id='carTra'>Car evaluation dataset</h2><span id='topic+carTra'></span>

<h3>Description</h3>

<p>Training data for the car dataset
</p>


<h3>Format</h3>

<p>A SDEFSR_Dataset class with 1382 instances, 6 variables (without the target variable) and 4 values for the target Variable.
Three labels for each variable are defined.
</p>


<h3>Details</h3>

<p>Car Evaluation Database was derived from a simple hierarchical decision model. 
The model evaluates cars according to six input attributes: buying, maint, doors, 
persons, lug_boot, safety.
</p>


<h3>Source</h3>

<p>M. Bohanec and V. Rajkovic: Knowledge acquisition and explanation for multi-attribute 
decision making. In 8th Intl Workshop on Expert Systems and their Applications, Avignon, 
France. pages 59-78, 1988.
</p>
<p>B. Zupan, M. Bohanec, I. Bratko, J. Demsar: Machine learning by function decomposition. 
ICML-97, Nashville, TN. 1997 (to appear).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   carTra$data
   carTra$attributeNames
   
</code></pre>

<hr>
<h2 id='carTst'>Car evaluation dataset</h2><span id='topic+carTst'></span>

<h3>Description</h3>

<p>Test data for the car dataset
</p>


<h3>Format</h3>

<p>A SDEFSR_Dataset class with 346 instances, 6 variables (without the target variable) and 4 values for the target Variable.
Three labels for each variable are defined.
</p>


<h3>Details</h3>

<p>Car Evaluation Database was derived from a simple hierarchical decision model. 
The model evaluates cars according to six input attributes: buying, maint, doors, 
persons, lug_boot, safety.
</p>


<h3>Source</h3>

<p>M. Bohanec and V. Rajkovic: Knowledge acquisition and explanation for multi-attribute 
decision making. In 8th Intl Workshop on Expert Systems and their Applications, Avignon, 
France. pages 59-78, 1988.
</p>
<p>B. Zupan, M. Bohanec, I. Bratko, J. Demsar: Machine learning by function decomposition. 
ICML-97, Nashville, TN. 1997 (to appear).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   carTst$data
   carTst$attributeNames
   
</code></pre>

<hr>
<h2 id='FUGEPSD'>Fuzzy Genetic Programming-based learning for Subgroup Discovery (FuGePSD) Algorithm.</h2><span id='topic+FUGEPSD'></span>

<h3>Description</h3>

<p>Make a subgroup discovery task using the FuGePSD algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FUGEPSD(
  paramFile = NULL,
  training = NULL,
  test = NULL,
  output = c("optionsFile.txt", "rulesFile.txt", "testQM.txt"),
  seed = 0,
  nLabels = 3,
  t_norm = "product_t-norm",
  ruleWeight = "Certainty_Factor",
  frm = "Normalized_Sum",
  numGenerations = 300,
  numberOfInitialRules = 100,
  crossProb = 0.5,
  mutProb = 0.2,
  insProb = 0.15,
  dropProb = 0.15,
  tournamentSize = 2,
  globalFitnessWeights = c(0.7, 0.1, 0.05, 0.2),
  minCnf = 0.6,
  ALL_CLASS = TRUE,
  targetVariable = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FUGEPSD_+3A_paramfile">paramFile</code></td>
<td>
<p>The path of the parameters file. <code>NULL</code> If you want to use training and test <code>SDEFSR_Dataset</code> variables</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_training">training</code></td>
<td>
<p>A <code>SDEFSR_Dataset</code> class variable with training data.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_test">test</code></td>
<td>
<p>A <code>SDEFSR_Dataset</code> class variable with test data.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_output">output</code></td>
<td>
<p>Character vector with the paths where store information file, rules file and test quality measures file, respectively. For rules and quality measures files, the algorithm generate 4 files, each one with the results of a given filter of fuzzy confidence.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_seed">seed</code></td>
<td>
<p>An integer to set the seed used for generate random numbers.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_nlabels">nLabels</code></td>
<td>
<p>Number of linguistic labels for numerical variables. By default 3. We recommend an odd number between 3 and 9.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_t_norm">t_norm</code></td>
<td>
<p>A string with the t-norm to use when computing the compatibilty degree of the rules. Use <code>'Minimum/Maximum'</code> to specify the minimum t-norm, if not, we use product t-norm that is the default method.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_ruleweight">ruleWeight</code></td>
<td>
<p>String with the method to calculate the rule weight. Possible values are: 
</p>

<ul>
<li> <p><code>Certainty_Factor</code>: It uses the Classic Certainty Factor Weight method.
</p>
</li>
<li> <p><code>Average_Penalized_Certainty_Factor</code>: It uses Penalized Certainty Factor weight II by Ishibuchi.
</p>
</li>
<li> <p><code>No_Weights</code>: There are no weight calculation.
</p>
</li>
<li><p> Default: If none of this are specificied, the default method is Penalized Certainty Factor Weight IV by Ishibuchi.
</p>
</li></ul>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_frm">frm</code></td>
<td>
<p>A string specifying the Fuzzy Reasoning Method to use. Possible Values are:
</p>

<ul>
<li> <p><code>Normalized_Sum</code>: It uses the Normalized Sum or Additive Combination Fuzzy Reasoning Method.
</p>
</li>
<li> <p><code>Arithmetic_Mean</code>: It uses the Arithmetic Mean Fuzzy Reasoning Method.
</p>
</li>
<li><p> Default: By default, Winning Rule Fuzzy Reasoning Method are selected.
</p>
</li></ul>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_numgenerations">numGenerations</code></td>
<td>
<p>An integer to set the number of generations to perfom before stop the evolutionary process.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_numberofinitialrules">numberOfInitialRules</code></td>
<td>
<p>An integer to set the number individuals or rules in the initial population.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_crossprob">crossProb</code></td>
<td>
<p>Sets the crossover probability. We recommend a number in [0,1].</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_mutprob">mutProb</code></td>
<td>
<p>Sets the mutation probability. We recommend a number in [0,1].</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_insprob">insProb</code></td>
<td>
<p>Sets the insertion probability. We recommend a number in [0,1].</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_dropprob">dropProb</code></td>
<td>
<p>Sets the dropping probability. We recommend a number in [0,1].</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_tournamentsize">tournamentSize</code></td>
<td>
<p>Sets the number of individuals that will be chosen in the tournament selection procedure. This number must be greater than or equal to 2.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_globalfitnessweights">globalFitnessWeights</code></td>
<td>
<p>A numeric vector of length 4 specifying the weights used in the computation of the Global Fitness Parameter.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_mincnf">minCnf</code></td>
<td>
<p>A value in [0,1] to filter rules with a minimum confidence</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_all_class">ALL_CLASS</code></td>
<td>
<p>if TRUE, the algorithm returns, at least, the best rule for each target class, even if it does not pass the filters. If FALSE, it only returns, at least, the best rule if there are not rules that passes the filters.</p>
</td></tr>
<tr><td><code id="FUGEPSD_+3A_targetvariable">targetVariable</code></td>
<td>
<p>The name or index position of the target variable (or class). It must be a categorical one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets as target variable the last one that appear in <code>SDEFSR_Dataset</code> object. If you want 
to change the target variable, you can set the <code>targetVariable</code> to change this target variable.
The target variable MUST be categorical, if it is not, throws an error. Also, the default behaviour is to find
rules for all possible values of the target varaible. <code>targetClass</code> sets a value of the target variable where the
algorithm only finds rules about this value.
</p>
<p>If you specify in <code>paramFile</code> something distinct to <code>NULL</code> the rest of the parameters are
ignored and the algorithm tries to read the file specified. See &quot;Parameters file structure&quot; below 
if you want to use a parameters file.
</p>
<p>@return The algorithm shows in console the following results:
</p>

<ol>
<li><p> Information about the parameters used in the algorithm.
</p>
</li>
<li><p> Results for each filter:
</p>

<ol>
<li><p> Rules generated that passes the filter.
</p>
</li>
<li><p> The test quality measures for each rule in that filter.
</p>
</li></ol>

</li></ol>

<p>Also, this results are saved in a file with rules and other with the quality measures, one file per filter.
</p>
<p>@section How does this algorithm work?:
This algorithm performs a EFS based on a genetic programming algorithm. This algorithm starts with an initial 
population generated in a random manner where individuals are represented through the &quot;chromosome = individual&quot;
approach includind both antecedent and consequent of the rule. The representation of the consequent has the advantage
of getting rules for all target class with only one execution of the algorithm.  
</p>
<p>The algorithm employs a cooperative-competition approach were rules of the population cooperate and compete between them in order to 
obtain the optimal solution. So this algorithm performs to evaluation, one for individual rules to competition and other for the total population 
for cooperation.  
</p>
<p>The algorithm evolves generating an offspring population of the same size than initial generated by the application of the
genetic operators over the main population. Once applied, both populations are joined a token competition is performed in order to 
maintain the diversity of the rules generated. Also, this token competition reduce the population sice deleting those rules that are not competitive.  
</p>
<p>After the evolutionary process a screening function is applied over the best population. This screening function filter the rules that have a minimum
level of confidence and sensitivity. Those levels are 0.6 for sensitivy and four filters of 0.6, 0.7, 0.8 and 0.9 for fuzzy confidence are performed.  
</p>
<p>Also, the user can force the algorithm return at least one rule for all target class values, even if not pass the screening function. This 
behaviour is specified by the ALL_CLASS parameter.
</p>
<p>@section Parameters file structure:
The <code>paramFile</code> argument points to a file which has the neccesary parameters to execute FuGePSD.
This file <strong>must</strong> be, at least, this parameters (separated by a carriage return):
</p>

<ul>
<li> <p><code>algorithm</code>  Specify the algorithm to execute. In this case. &quot;MESDIF&quot;
</p>
</li>
<li> <p><code>inputData</code>  Specify two paths of KEEL files for training and test. In case of specify only the name of the file, the path will be the working directory.
</p>
</li>
<li> <p><code>seed</code>  Sets the seed for the random number generator
</p>
</li>
<li> <p><code>nLabels</code>  Sets the number of fuzzy labels to create when reading the files
</p>
</li>
<li> <p><code>nEval</code>  Set the maximum number of <strong>evaluations of rules</strong> for stop the genetic process
</p>
</li>
<li> <p><code>popLength</code>  Sets number of individuals of the main population
</p>
</li>
<li> <p><code>eliteLength</code>  Sets number of individuals of the elite population. Must be less than <code>popLength</code>  
</p>
</li>
<li> <p><code>crossProb</code>  Crossover probability of the genetic algorithm. Value in [0,1]
</p>
</li>
<li> <p><code>mutProb</code>  Mutation probability of the genetic algorithm. Value in [0,1]
</p>
</li>
<li> <p><code>Obj1</code> Sets the objetive number 1. 
</p>
</li>
<li> <p><code>Obj2</code> Sets the objetive number 2. 
</p>
</li>
<li> <p><code>Obj3</code> Sets the objetive number 3. 
</p>
</li>
<li> <p><code>Obj4</code> Sets the objetive number 4.
</p>
</li>
<li> <p><code>RulesRep</code>  Representation of each chromosome of the population. &quot;can&quot; for canonical representation. &quot;dnf&quot; for DNF representation.
</p>
</li>
<li> <p><code>targetClass</code>  Value of the target variable to search for subgroups. The target variable <strong>is always the last variable.</strong> Use <code>null</code> to search for every value of the target variable
</p>
</li></ul>

<p>An example of parameter file could be:
</p>
<pre>
 algorithm = FUGEPSD
 inputData = "banana-5-1tra.dat" "banana-5-1tst.dat"
 outputData = "Parameters_INFO.txt" "Rules.txt" "TestMeasures.txt"
 seed = 23783
 Number of Labels = 3
 T-norm/T-conorm for the Computation of the Compatibility Degree = Normalized_Sum
 Rule Weight = Certainty_Factor
 Fuzzy Reasoning Method = Normalized_Sum
 Number of Generations = 300
 Initial Number of Fuzzy Rules = 100
 Crossover probability = 0.5
 Mutation probability = 0.2
 Insertion probability = 0.15
 Dropping Condition probability = 0.15
 Tournament Selection Size = 2 
 Global Fitness Weight 1 = 0.7
 Global Fitness Weight 2 = 0.1 
 Global Fitness Weight 3 = 0.05
 Global Fitness Weight 4 = 0.2
 All Class = true</pre>


<h3>Author(s)</h3>

<p>Written on R by Angel M. Garcia &lt;amgv0009@red.ujaen.es&gt;
</p>


<h3>References</h3>

<p>A fuzzy genetic programming-based algorithm for subgroup discovery and the application to one problem of pathogenesis of acute sore throat conditions in humans, Carmona, C.J., Ruiz-Rodado V., del Jesus M.J., Weber A., Grootveld M., Gonzalez P., and Elizondo D. , Information Sciences, Volume 298, p.180-197, (2015)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FUGEPSD(training = habermanTra,
         test = habermanTst,
         output = c(NA, NA, NA),
         seed = 23783,
         nLabels = 3,
         t_norm = "Minimum/Maximum",
         ruleWeight = "Certainty_Factor",
         frm = "Normalized_Sum",
         numGenerations = 20,
         numberOfInitialRules = 15,
         crossProb = 0.5,
         mutProb = 0.2,
         insProb = 0.15,
         dropProb = 0.15,
         tournamentSize = 2,
         globalFitnessWeights = c(0.7, 0.1, 0.3, 0.2),
         ALL_CLASS = TRUE)
         
## Not run: 
# Execution with a parameters file called 'ParamFile.txt' in the working directory:

FUGEPSD("ParamFile.txt")


## End(Not run)

</code></pre>

<hr>
<h2 id='germanTra'>German Credit data set</h2><span id='topic+germanTra'></span>

<h3>Description</h3>

<p>Training data for the german dataset
</p>


<h3>Format</h3>

<p>A SDEFSR_Dataset class with 800 instances, 20 variables (without the target variable)
and 2 values for the target class.
</p>


<h3>Details</h3>

<p>A numerical version of the Statlog German Credit Data data set. 
Here, the task is to classify customers as good (1) or bad (2), 
depending on 20 features about them and their bancary accounts.
</p>


<h3>Source</h3>

<p><a href="https://sci2s.ugr.es/keel/dataset.php?cod=88">https://sci2s.ugr.es/keel/dataset.php?cod=88</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     germanTra$data
     
</code></pre>

<hr>
<h2 id='germanTst'>German Credit data set</h2><span id='topic+germanTst'></span>

<h3>Description</h3>

<p>Test data for the german dataset
</p>


<h3>Format</h3>

<p>A SDEFSR_Dataset class with 200 instances, 20 variables (without the target variable)
and 2 values for the target class.
</p>


<h3>Details</h3>

<p>A numerical version of the Statlog German Credit Data data set. 
Here, the task is to classify customers as good (1) or bad (2), 
depending on 20 features about them and their bancary accounts.
</p>


<h3>Source</h3>

<p><a href="https://sci2s.ugr.es/keel/dataset.php?cod=88">https://sci2s.ugr.es/keel/dataset.php?cod=88</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     germanTra$data
     
</code></pre>

<hr>
<h2 id='habermanRules'>Haberman survival rule set</h2><span id='topic+habermanRules'></span>

<h3>Description</h3>

<p>Rules generated by the SDIGA algorithm with the default parameters for the <code>haberman</code> dataset.
</p>


<h3>Details</h3>

<p>The rule set contains only two rules. One for each target variable
</p>


<h3>Source</h3>

<p>Haberman, S. J. (1976). Generalized Residuals for Log-Linear Models, 
Proceedings of the 9th International Biometrics Conference, Boston, pp. 104-122.
</p>
<p>Landwehr, J. M., Pregibon, D., and Shoemaker, A. C. (1984), Graphical Models for 
Assessing Logistic Regression Models (with discussion), Journal of the American Statistical 
Association 79: 61-83.
</p>
<p>Lo, W.-D. (1993). Logistic Regression Trees, PhD thesis, Department of Statistics,
University of Wisconsin, Madison, WI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    habermanRules
</code></pre>

<hr>
<h2 id='habermanTra'>Haberman survival data set</h2><span id='topic+habermanTra'></span>

<h3>Description</h3>

<p>Training data for the Haberman dataset.
</p>


<h3>Format</h3>

<p>A SDEFSR_Dataset class with 306 instances, 3 variables (without the target variable) and 2 values for the target variable.
Three fuzzy labels for each numerical variable are defined.
</p>


<h3>Details</h3>

<p>This data set contains cases from a study that was conducted between 1958 and 1970 
at the University of Chicago's Billings Hospital on the survival of patients who had undergone 
surgery for breast cancer. The task is to determine if the patient survived 5 years or longer 
(positive) or if the patient died within 5 year (negative)
</p>


<h3>Source</h3>

<p>Haberman, S. J. (1976). Generalized Residuals for Log-Linear Models, 
Proceedings of the 9th International Biometrics Conference, Boston, pp. 104-122.
</p>
<p>Landwehr, J. M., Pregibon, D., and Shoemaker, A. C. (1984), Graphical Models for 
Assessing Logistic Regression Models (with discussion), Journal of the American Statistical 
Association 79: 61-83.
</p>
<p>Lo, W.-D. (1993). Logistic Regression Trees, PhD thesis, Department of Statistics,
University of Wisconsin, Madison, WI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    habermanTra$data 
    habermanTra$fuzzySets
    
</code></pre>

<hr>
<h2 id='habermanTst'>Haberman survival data set</h2><span id='topic+habermanTst'></span>

<h3>Description</h3>

<p>Test data for the Haberman dataset.
</p>


<h3>Format</h3>

<p>A SDEFSR_Dataset class with 62 instances, 3 variables (without the target variable) and 2 values for the target variable.
Three fuzzy labels for each numerical variable are defined.
</p>


<h3>Details</h3>

<p>This data set contains cases from a study that was conducted between 1958 and 1970 
at the University of Chicago's Billings Hospital on the survival of patients who had undergone 
surgery for breast cancer. The task is to determine if the patient survived 5 years or longer 
(positive) or if the patient died within 5 year (negative)
</p>


<h3>Source</h3>

<p>Haberman, S. J. (1976). Generalized Residuals for Log-Linear Models, 
Proceedings of the 9th International Biometrics Conference, Boston, pp. 104-122.
</p>
<p>Landwehr, J. M., Pregibon, D., and Shoemaker, A. C. (1984), Graphical Models for 
Assessing Logistic Regression Models (with discussion), Journal of the American Statistical 
Association 79: 61-83.
</p>
<p>Lo, W.-D. (1993). Logistic Regression Trees, PhD thesis, Department of Statistics,
University of Wisconsin, Madison, WI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    habermanTra$data 
    habermanTra$fuzzySets
</code></pre>

<hr>
<h2 id='MESDIF'>Multiobjective Evolutionary Subgroup DIscovery Fuzzy rules (MESDIF) Algorithm</h2><span id='topic+MESDIF'></span>

<h3>Description</h3>

<p>Performs a subgroup discovery task executing the MESDIF algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MESDIF(
  paramFile = NULL,
  training = NULL,
  test = NULL,
  output = c("optionsFile.txt", "rulesFile.txt", "testQM.txt"),
  seed = 0,
  nLabels = 3,
  nEval = 10000,
  popLength = 100,
  eliteLength = 3,
  crossProb = 0.6,
  mutProb = 0.01,
  RulesRep = "can",
  Obj1 = "CSUP",
  Obj2 = "CCNF",
  Obj3 = "null",
  Obj4 = "null",
  targetVariable = NA,
  targetClass = "null"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MESDIF_+3A_paramfile">paramFile</code></td>
<td>
<p>The path of the parameters file. <code>NULL</code> If you want to use training and test <code>SDEFSR_Dataset</code> variables</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_training">training</code></td>
<td>
<p>A <code>SDEFSR_Dataset</code> class variable with training data.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_test">test</code></td>
<td>
<p>A <code>SDEFSR_Dataset</code> class variable with test data. <code>NULL</code> if you only want to use training data.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_output">output</code></td>
<td>
<p>character vector with the paths where store information file, rules file and quality measures file, respectively.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_seed">seed</code></td>
<td>
<p>An integer to set the seed used for generate random numbers.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_nlabels">nLabels</code></td>
<td>
<p>Number of linguistic labels that represents numerical variables.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_neval">nEval</code></td>
<td>
<p>An integer for set the maximum number of evaluations in the evolutive process. Large values of this parameter increments the computing time.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_poplength">popLength</code></td>
<td>
<p>An integer to set the number of individuals in the population.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_elitelength">eliteLength</code></td>
<td>
<p>An integer to set the number of individuals in the elite population.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_crossprob">crossProb</code></td>
<td>
<p>Sets the crossover probability. A number in [0,1].</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_mutprob">mutProb</code></td>
<td>
<p>Sets the mutation probability. A number in [0,1].</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_rulesrep">RulesRep</code></td>
<td>
<p>Representation used in the rules. &quot;can&quot; for canonical rules, &quot;dnf&quot; for DNF rules.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_obj1">Obj1</code></td>
<td>
<p>Sets the Objective number 1. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_obj2">Obj2</code></td>
<td>
<p>Sets the Objective number 2. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_obj3">Obj3</code></td>
<td>
<p>Sets the Objective number 3. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_obj4">Obj4</code></td>
<td>
<p>Sets the Objective number 4. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_targetvariable">targetVariable</code></td>
<td>
<p>The name or index position of the target variable (or class). It must be a categorical one.</p>
</td></tr>
<tr><td><code id="MESDIF_+3A_targetclass">targetClass</code></td>
<td>
<p>A string specifing the value of the target variable. <code>null</code> for search for all possible values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets as target variable the last one that appear in <code>SDEFSR_Dataset</code> object. If you want 
to change the target variable, you can set the <code>targetVariable</code> to change this target variable.
The target variable MUST be categorical, if it is not, throws an error. Also, the default behaviour is to find
rules for all possible values of the target varaible. <code>targetClass</code> sets a value of the target variable where the
algorithm only finds rules about this value.
</p>
<p>If you specify in <code>paramFile</code> something distinct to <code>NULL</code> the rest of the parameters are
ignored and the algorithm tries to read the file specified. See &quot;Parameters file structure&quot; below 
if you want to use a parameters file.
</p>


<h3>Value</h3>

<p>The algorithm shows in the console the following results:
</p>

<ol>
<li><p> The parameters used in the algorithm
</p>
</li>
<li><p> The rules generated.
</p>
</li>
<li><p> The quality measures for test of every rule and the global results. This globals results shows the number of 
rules generated and means results for each quality measure.
</p>
</li></ol>

<p>Also, the algorithms save those results in the files specified in the <code>output</code> parameter of the algorithm or 
in the <code>outputData</code> parameter in the parameters file.
</p>
<p>Additionally a <code>SDEFSR_Rules</code> object is returned with this information.
</p>


<h3>How does this algorithm work?</h3>

<p>This algorithm performs a multi-objective genetic algorithm based on elitism (following the SPEA2 approach). The elite population has 
a fixed size and it is filled by non-dominated individuals.
</p>
<p>An individual is non-dominated when <code>(! all(ObjI1 &lt;= ObjI2) &amp; any(ObjI1 &lt; ObjI2))</code> where ObjI1
is the objective value for our individual and ObjI2 is the objetive value for another individual.
The number of dominated individuals by each one determine, in addition with a niches technique that considers
the proximity among values of the objectives a fitness value for the selection.
</p>
<p>The number of non-dominated individuals might be greater or less than elite population size and in those cases
MESDIF implements a truncation operator and a fill operator respectively. Then, genetic operators are
applied.
</p>
<p>At the final of the evolutive process it returns the rules stored in elite population. Therefore, the number of rules is fixed with the <code>eliteLength</code> parameter.
</p>


<h3>Parameters file structure</h3>

<p>The <code>paramFile</code> argument points to a file which has the necesary parameters for MESDIF works.
This file <strong>must</strong> have, at least, those parameters (separated by a carriage return):
</p>

<ul>
<li> <p><code>algorithm</code>  Specify the algorithm to execute. In this case. &quot;MESDIF&quot;
</p>
</li>
<li> <p><code>inputData</code>  Specify two paths of KEEL files for training and test. In case of specify only the name of the file, the path will be the working directory.
</p>
</li>
<li> <p><code>seed</code>  Sets the seed for the random number generator
</p>
</li>
<li> <p><code>nLabels</code>  Sets the number of fuzzy labels to create when reading the files
</p>
</li>
<li> <p><code>nEval</code>  Set the maximun number of <strong>evaluations of rules</strong> for stop the genetic process
</p>
</li>
<li> <p><code>popLength</code>  Sets number of individuals of the main population
</p>
</li>
<li> <p><code>eliteLength</code>  Sets number of individuals of the elite population. Must be less than <code>popLength</code>  
</p>
</li>
<li> <p><code>crossProb</code>  Crossover probability of the genetic algorithm. Value in [0,1]
</p>
</li>
<li> <p><code>mutProb</code>  Mutation probability of the genetic algorithm. Value in [0,1]
</p>
</li>
<li> <p><code>Obj1</code> Sets the objective number 1. 
</p>
</li>
<li> <p><code>Obj2</code> Sets the objective number 2. 
</p>
</li>
<li> <p><code>Obj3</code> Sets the objective number 3. 
</p>
</li>
<li> <p><code>Obj4</code> Sets the objective number 4.
</p>
</li>
<li> <p><code>RulesRep</code>  Representation of each chromosome of the population. &quot;can&quot; for canonical representation. &quot;dnf&quot; for DNF representation.
</p>
</li>
<li> <p><code>targetVariable</code> The name or index position of the target variable (or class). It must be a categorical one.
</p>
</li>
<li> <p><code>targetClass</code>  Value of the target variable to search for subgroups. The target variable <strong>is always the last variable.</strong> Use <code>null</code> to search for every value of the target variable
</p>
</li></ul>

<p>An example of parameter file could be:
</p>
<pre>
 algorithm = MESDIF
 inputData = "irisd-10-1tra.dat" "irisd-10-1tst.dat"
 outputData = "irisD-10-1-INFO.txt" "irisD-10-1-Rules.txt" "irisD-10-1-TestMeasures.txt"
 seed = 0
 nLabels = 3
 nEval = 500
 popLength = 100
 eliteLength = 3
 crossProb = 0.6
 mutProb = 0.01
 RulesRep = can
 Obj1 = comp
 Obj2 = unus
 Obj3 = null
 Obj4 = null
 targetClass = Iris-setosa </pre>
<p>@section Objective values:
You can use the following quality measures in the ObjX value of the parameter file using this values:
</p>

<ul>
<li><p> Unusualness -&gt; <code>unus</code>
</p>
</li>
<li><p> Crisp Support -&gt; <code>csup</code>
</p>
</li>
<li><p> Crisp Confidence -&gt; <code>ccnf</code>
</p>
</li>
<li><p> Fuzzy Support -&gt; <code>fsup</code>
</p>
</li>
<li><p> Fuzzy Confidence -&gt; <code>fcnf</code>
</p>
</li>
<li><p> Coverage -&gt; <code>cove</code>
</p>
</li>
<li><p> Significance -&gt; <code>sign</code>
</p>
</li></ul>

<p>If you dont want to use a objective value you must specify <code>null</code>
</p>


<h3>References</h3>


<ul>
<li><p> Berlanga, F., Del Jesus, M., Gonzalez, P., Herrera, F., &amp; Mesonero, M. (2006). Multiobjective Evolutionary Induction of Subgroup Discovery Fuzzy Rules: A Case Study in Marketing.
</p>
</li>
<li><p> Zitzler, E., Laumanns, M., &amp; Thiele, L. (2001). SPEA2: Improving the Strength Pareto Evolutionary Algorithm. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> MESDIF( paramFile = NULL,
        training = habermanTra, 
        test = habermanTst, 
        output = c(NA, NA, NA),
        seed = 0, 
        nLabels = 3,
        nEval = 300, 
        popLength = 100, 
        eliteLength = 3,
        crossProb = 0.6,
        mutProb = 0.01, 
        RulesRep = "can",
        Obj1 = "CSUP", 
        Obj2 = "CCNF",
        Obj3 = "null",
        Obj4 = "null",
        targetClass = "positive"
        )

## Not run: 
Execution for all classes, see 'targetClass' parameter
MESDIF( paramFile = NULL,
        training = habermanTra, 
        test = habermanTst, 
        output = c("optionsFile.txt", "rulesFile.txt", "testQM.txt"),
        seed = 0, 
        nLabels = 3,
        nEval = 300, 
        popLength = 100, 
        eliteLength = 3,
        crossProb = 0.6,
        mutProb = 0.01, 
        RulesRep = "can",
        Obj1 = "CSUP", 
        Obj2 = "CCNF",
        Obj3 = "null",
        Obj4 = "null",
        targetClass = "null"
        )
 
## End(Not run)

</code></pre>

<hr>
<h2 id='NMEEF_SD'>Non-dominated Multi-objective Evolutionary algorithm for Extracting Fuzzy rules in Subgroup Discovery (NMEEF-SD)</h2><span id='topic+NMEEF_SD'></span>

<h3>Description</h3>

<p>Perfoms a subgroup discovery task executing the algorithm NMEEF-SD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMEEF_SD(
  paramFile = NULL,
  training = NULL,
  test = NULL,
  output = c("optionsFile.txt", "rulesFile.txt", "testQM.txt"),
  seed = 0,
  nLabels = 3,
  nEval = 10000,
  popLength = 100,
  mutProb = 0.1,
  crossProb = 0.6,
  Obj1 = "CSUP",
  Obj2 = "CCNF",
  Obj3 = "null",
  minCnf = 0.6,
  reInitCoverage = "yes",
  porcCob = 0.5,
  StrictDominance = "yes",
  targetVariable = NA,
  targetClass = "null"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMEEF_SD_+3A_paramfile">paramFile</code></td>
<td>
<p>The path of the parameters file. <code>NULL</code> If you want to use training and test <code>SDEFSR_Dataset</code> variables</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_training">training</code></td>
<td>
<p>A <code>SDEFSR_Dataset</code> class variable with training data.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_test">test</code></td>
<td>
<p>A <code>SDEFSR_Dataset</code> class variable with training data.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_output">output</code></td>
<td>
<p>character vector with the paths of where store information file, rules file and test quality measures file, respectively.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_seed">seed</code></td>
<td>
<p>An integer to set the seed used for generate random numbers.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_nlabels">nLabels</code></td>
<td>
<p>Number of linguistic labels for numerical variables.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_neval">nEval</code></td>
<td>
<p>An integer for set the maximum number of evaluations in the evolutionary process.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_poplength">popLength</code></td>
<td>
<p>An integer to set the number of individuals in the population.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_mutprob">mutProb</code></td>
<td>
<p>Sets the mutation probability. A number in [0,1].</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_crossprob">crossProb</code></td>
<td>
<p>Sets the crossover probability. A number in [0,1].</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_obj1">Obj1</code></td>
<td>
<p>Sets the Objective number 1. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_obj2">Obj2</code></td>
<td>
<p>Sets the Objective number 2. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_obj3">Obj3</code></td>
<td>
<p>Sets the Objective number 3. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_mincnf">minCnf</code></td>
<td>
<p>Sets the minimum confidence that must have a rule in the Pareto front for being returned. A number in [0,1].</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_reinitcoverage">reInitCoverage</code></td>
<td>
<p>Sets if the algorithm must perform the reinitialitation based on coverage when it is needed. A string with &quot;yes&quot; or &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_porccob">porcCob</code></td>
<td>
<p>Sets the maximum percentage of variables that participate in the rules generated in the reinitialitation based on coverage. A number in [0,1]</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_strictdominance">StrictDominance</code></td>
<td>
<p>Sets if the comparison between individuals must be done by strict dominance or not. A string with &quot;yes&quot; or &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_targetvariable">targetVariable</code></td>
<td>
<p>The name or index position of the target variable (or class). It must be a categorical one.</p>
</td></tr>
<tr><td><code id="NMEEF_SD_+3A_targetclass">targetClass</code></td>
<td>
<p>A string specifing the value the target variable. <code>null</code> for search for all possible values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets as target variable the last one that appear in <code>SDEFSR_Dataset</code> object. If you want 
to change the target variable, you can set the <code>targetVariable</code> to change this target variable.
The target variable MUST be categorical, if it is not, throws an error. Also, the default behaviour is to find
rules for all possible values of the target varaible. <code>targetClass</code> sets a value of the target variable where the
algorithm only finds rules about this value.
</p>
<p>If you specify in <code>paramFile</code> something distinct to <code>NULL</code> the rest of the parameters are
ignored and the algorithm tries to read the file specified. See &quot;Parameters file structure&quot; below 
if you want to use a parameters file.
</p>


<h3>Value</h3>

<p>The algorithm shows in the console the following results:
</p>

<ol>
<li><p> The parameters used in the algorithm
</p>
</li>
<li><p> The rules generated.
</p>
</li>
<li><p> The quality measures for test of every rule and the global results.
</p>
<p>Also, the algorithms save those results in the files specified in the <code>output</code> parameter of the algorithm or 
in the <code>outputData</code> parameter in the parameters file.
</p>
</li></ol>



<h3>How does this algorithm work?</h3>

<p>NMEEF-SD is a multiobjetctive genetic algorithm based on a NSGA-II approach. The algorithm
first makes a selection based on binary tournament and save the individuals in a offspring population.
Then, NMEEF-SD apply the genetic operators over individuals in offspring population
</p>
<p>For generate the population which participate in the next iteration of the evolutionary process
NMEEF-SD calculate the dominance among all individuals (join main population and offspring) and then, apply the NSGA-II fast sort algorithm to order
the population by fronts of dominance, the first front is the non-dominated front (or Pareto), the second is 
where the individuals dominated by one individual are, the thirt front dominated by two and so on.
</p>
<p>To promove diversity NMEEF-SD has a mechanism of reinitialization of the population based on coverage
if the Pareto doesnt evolve during a 5
</p>
<p>At the final of the evolutionary process, the algorithm returns only the individuals in the Pareto front
which has a confidence greater than a minimum confidence level.
</p>


<h3>Parameters file structure</h3>

<p>The <code>paramFile</code> argument points to a file which has the necesary parameters for NMEEF-SD works.
This file <strong>must</strong> be, at least, those parameters (separated by a carriage return):
</p>

<ul>
<li> <p><code>algorithm</code>  Specify the algorithm to execute. In this case. &quot;NMEEFSD&quot;
</p>
</li>
<li> <p><code>inputData</code>  Specify two paths of KEEL files for training and test. In case of specify only the name of the file, the path will be the working directory.
</p>
</li>
<li> <p><code>seed</code>  Sets the seed for the random number generator
</p>
</li>
<li> <p><code>nLabels</code>  Sets the number of fuzzy labels to create when reading the files
</p>
</li>
<li> <p><code>nEval</code>  Set the maximun number of <strong>evaluations of rules</strong> for stop the genetic process
</p>
</li>
<li> <p><code>popLength</code>  Sets number of individuals of the main population
</p>
</li>
<li> <p><code>ReInitCob</code>  Sets if NMEEF-SD do the reinitialization based on coverage. Values: &quot;yes&quot; or &quot;no&quot;  
</p>
</li>
<li> <p><code>crossProb</code>  Crossover probability of the genetic algorithm. Value in [0,1]
</p>
</li>
<li> <p><code>mutProb</code>  Mutation probability of the genetic algorithm. Value in [0,1]
</p>
</li>
<li> <p><code>RulesRep</code>  Representation of each chromosome of the population. &quot;can&quot; for canonical representation. &quot;dnf&quot; for DNF representation.
</p>
</li>
<li> <p><code>porcCob</code>  Sets the maximum percentage of variables participe in a rule when doing the reinitialization based on coverage. Value in [0,1]
</p>
</li>
<li> <p><code>Obj1</code> Sets the objective number 1. 
</p>
</li>
<li> <p><code>Obj2</code> Sets the objective number 2. 
</p>
</li>
<li> <p><code>Obj3</code> Sets the objective number 3. 
</p>
</li>
<li> <p><code>minCnf</code> Minimum confidence for returning a rule of the Pareto. Value in [0,1] 
</p>
</li>
<li> <p><code>StrictDominance</code> Sets if the comparison of individuals when calculating dominance must be using strict dominance or not. Values: &quot;yes&quot; or &quot;no&quot;
</p>
</li>
<li> <p><code>targetClass</code>  Value of the target variable to search for subgroups. The target variable <strong>is always the last variable.</strong>. Use <code>null</code> to search for every value of the target variable
</p>
</li></ul>

<p>An example of parameter file could be:
</p>
<pre>
algorithm = NMEEFSD
inputData = "irisd-10-1tra.dat" "irisd-10-1tra.dat" "irisD-10-1tst.dat"
outputData = "irisD-10-1-INFO.txt" "irisD-10-1-Rules.txt" "irisD-10-1-TestMeasures.txt"
seed = 1
RulesRep = can
nLabels = 3
nEval = 500
popLength = 51
crossProb = 0.6
mutProb = 0.1
ReInitCob = yes
porcCob = 0.5
Obj1 = comp
Obj2 = unus
Obj3 = null
minCnf = 0.6
StrictDominance = yes
targetClass = Iris-setosa
</pre>


<h3>Objective values</h3>

<p>You can use the following quality measures in the ObjX value of the parameter file using this values:
</p>

<ul>
<li><p> Unusualness -&gt; <code>unus</code>
</p>
</li>
<li><p> Crisp Support -&gt; <code>csup</code>
</p>
</li>
<li><p> Crisp Confidence -&gt; <code>ccnf</code>
</p>
</li>
<li><p> Fuzzy Support -&gt; <code>fsup</code>
</p>
</li>
<li><p> Fuzzy Confidence -&gt; <code>fcnf</code>
</p>
</li>
<li><p> Coverage -&gt; <code>cove</code>
</p>
</li>
<li><p> Significance -&gt; <code>sign</code>
</p>
</li></ul>

<p>If you dont want to use a objetive value you must specify <code>null</code>
</p>


<h3>References</h3>

<p>Carmona, C., Gonzalez, P., del Jesus, M., &amp; Herrera, F. (2010). NMEEF-SD: Non-dominated Multi-objective Evolutionary algorithm for Extracting Fuzzy rules in Subgroup Discovery.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
   NMEEF_SD(paramFile = NULL, 
               training = habermanTra, 
               test = habermanTst, 
               output = c(NA, NA, NA),
               seed = 0, 
               nLabels = 3,
               nEval = 300, 
               popLength = 100, 
               mutProb = 0.1,
               crossProb = 0.6,
               Obj1 = "CSUP",
               Obj2 = "CCNF",
               Obj3 = "null",
               minCnf = 0.6,
               reInitCoverage = "yes",
               porcCob = 0.5,
               StrictDominance = "yes",
               targetClass = "positive"
               )  
## Not run: 
      NMEEF_SD(paramFile = NULL, 
               training = habermanTra, 
               test = habermanTst, 
               output = c("optionsFile.txt", "rulesFile.txt", "testQM.txt"),
               seed = 0, 
               nLabels = 3,
               nEval = 300, 
               popLength = 100, 
               mutProb = 0.1,
               crossProb = 0.6,
               Obj1 = "CSUP",
               Obj2 = "CCNF",
               Obj3 = "null",
               minCnf = 0.6,
               reInitCoverage = "yes",
               porcCob = 0.5,
               StrictDominance = "yes",
               targetClass = "null"
               )
     
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.SDEFSR_Rules'>Plot a rule set generated by a SDEFSR algorithm</h2><span id='topic+plot.SDEFSR_Rules'></span>

<h3>Description</h3>

<p>This function plots the rule set by means of a bar graph that shows TPR vs FPR quality measure of each rule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SDEFSR_Rules'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SDEFSR_Rules_+3A_x">x</code></td>
<td>
<p>an <code>SDEFSR_Rules</code> object generated by a subgroup discovery algorithm of the SDEFSR package</p>
</td></tr>
<tr><td><code id="plot.SDEFSR_Rules_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works depending on the package ggplot2 that allow to generate such graph. If the package ggplot2 is not 
installed, the this function ask the user to install it. After install, load the package and show the graph.
</p>
<p>A TPR vs FPR graph show the precision of a rule. Quality rules has big TPR values and small FPR values.
Big values of both quality measures indicates that the rule is too much general and it is too obvious. 
Small values of both indicates that the rule is too much specific and it would be an invalid rule.
</p>


<h3>Value</h3>

<p>A TPR vs FPR graph generated by ggplot2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(habermanRules)

</code></pre>

<hr>
<h2 id='print.SDEFSR_Dataset'>S3 function to print in console the contents of the dataset
This function shows the matrix of data uncoded.</h2><span id='topic+print.SDEFSR_Dataset'></span>

<h3>Description</h3>

<p>S3 function to print in console the contents of the dataset
</p>
<p>This function shows the matrix of data uncoded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SDEFSR_Dataset'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SDEFSR_Dataset_+3A_x">x</code></td>
<td>
<p>The <code>SDEFSR_Dataset</code> object to view</p>
</td></tr>
<tr><td><code id="print.SDEFSR_Dataset_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function show the matix of data. Internally, a <code>SDEFSR_Dataset</code> object has a list of of examples
and this examples are coded numerically. This function decode these examples and convert the list into a matrix.
</p>


<h3>Value</h3>

<p>a matrix with the dataset uncoded.
</p>
<p>@examples
</p>
<p>print(habermanTra)
</p>

<hr>
<h2 id='read.dataset'>Reads a KEEL, ARFF or CSV data format file.</h2><span id='topic+read.dataset'></span>

<h3>Description</h3>

<p>This function reads a KEEL (.dat), ARFF (.arff) or CSV dataset file and store the information
in a <code>SDEFSR_Dataset</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dataset(file, sep = ",", quote = "\"", dec = ".", na.strings = "?")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.dataset_+3A_file">file</code></td>
<td>
<p>The path of the file to read</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_sep">sep</code></td>
<td>
<p>The separator character to use</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_quote">quote</code></td>
<td>
<p>The character used to take quotes</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_dec">dec</code></td>
<td>
<p>The character used to define decimal characters</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_na.strings">na.strings</code></td>
<td>
<p>The character to detect lost data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A KEEL data file must have the following structure:
</p>

<ul>
<li><p> @relation: Name of the data set 
</p>
</li>
<li><p> @attribute: Description of an attribute (one for each attribute)
</p>
</li>
<li><p> @inputs: List with the names of the input attributes 
</p>
</li>
<li><p> @output: Name of the output attribute (Not used in this algorithms implementation) 
</p>
</li>
<li><p> @data: Starting tag of the data
</p>
</li></ul>

<p>The rest of the file contains all the examples belonging to the data set, expressed in comma sepparated values format.
ARFF file format is a well-know dataset format from WEKA data mining tool.
CSV is a format which means comma-separated values. Where each examples is on a line and each value of the variables of the examples
are separated by commas.
</p>


<h3>Author(s)</h3>

<p>Angel M. Garcia &lt;agvico@ujaen.es&gt;
</p>


<h3>References</h3>

<p>J. Alcala-Fdez, A. Fernandez, J. Luengo, J. Derrac, S. Garcia, L. Sanchez, F. Herrera. KEEL Data-Mining Software Tool: Data Set Repository, Integration of Algorithms and Experimental Analysis Framework. Journal of Multiple-Valued Logic and Soft Computing 17:2-3 (2011) 255-287.
</p>


<h3>See Also</h3>

<p>KEEL Dataset Repository (Standard Classification): <a href="https://sci2s.ugr.es/keel/category.php?cat=clas">https://sci2s.ugr.es/keel/category.php?cat=clas</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run: 
       Reads a KEEL dataset from a file.
       read.dataset(file = "C:\KEELFile.dat")

       read.dataset(file = "C:\KEELFile.dat", nLabels = 7)
       
     Reads an ARFF dataset from a file.
       read.dataset(file = "C:\ARFFFile.arff")

       read.dataset(file = "C:\ARFFFile.arff", nLabels = 7)
    
## End(Not run)
    
</code></pre>

<hr>
<h2 id='SDEFSR'>SDEFSR: A package for Subgroup Discovery with Evolutionary Fuzzy Systems in R</h2><span id='topic+SDEFSR'></span>

<h3>Description</h3>

<p>The SDEFSR package provide a tool for read KEEL datasets and four evolutionary fuzzy rule-based 
algorithms for subgroup discovery.
</p>


<h3>Details</h3>

<p>The algorithms provided works with datasets in KEEL, ARFF or CSV format and also with <code>data.frame</code> objects.
</p>
<p>The package also provide a Shiny app for making the same tasks that the package can do
and can display some additional information about data for making an exploratory analysis.
</p>
<p>The algorithms provided are Evolutionary Fuzzy Systems (EFS) which take advantages of evolutionary algorithms 
for maximize more than one quality measure and fuzzy logic, which makes a representation of numerical variables that are
more understandable for humans and more robust to noise. 
</p>
<p>The algorithms in the SDEFSR package support target variable with more than two values. However, this target variables
must be categorical. Thus, if you have a numeric target variable, a discretization must be perfomed before executing the
method.
</p>


<h3>SDEFSR functions</h3>


<ul>
<li><p><code><a href="#topic+MESDIF">MESDIF</a></code>                 Multiobjective Evolutionary Subgroup DIscovery Fuzzy rules (MESDIF) Algorithm.
</p>
</li>
<li><p><code><a href="#topic+NMEEF_SD">NMEEF_SD</a></code>               Non-dominated Multi-objective Evolutionary algorithm for Extracting Fuzzy rules in Subgroup Discovery (NMEEF-SD).
</p>
</li>
<li><p><code><a href="#topic+read.dataset">read.dataset</a></code>           reads a KEEL, ARFF or CSV format file.
</p>
</li>
<li><p><code><a href="#topic+SDIGA">SDIGA</a></code>                  Subgroup Discovery Iterative Genetic Algorithm (SDIGA).
</p>
</li>
<li><p><code><a href="#topic+SDEFSR_GUI">SDEFSR_GUI</a></code>               Launch the Shiny app in your browser.
</p>
</li>
<li><p><code><a href="#topic+FUGEPSD">FUGEPSD</a></code>                Fuzzy Genetic Programming-based learning for Subgroup Discovery (FuGePSD) Algorithm.
</p>
</li>
<li><p><code><a href="#topic+plot.SDEFSR_Rules">plot.SDEFSR_Rules</a></code>            Plot the discovered rules by a SDEFSR algorithm.
</p>
</li>
<li><p><code><a href="#topic+sort.SDEFSR_Rules">sort.SDEFSR_Rules</a></code>             Sort the discovered rules by a given quality measure.
</p>
</li>
<li><p><code><a href="#topic+SDEFSR_DatasetFromDataFrame">SDEFSR_DatasetFromDataFrame</a></code>   Reads a data.frame and create a <code>SDEFSR_Dataset</code> object to be execute by an algorithm of this package.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Angel M. Garcia-Vico &lt;agvico@ujaen.es&gt;
</p>

<hr>
<h2 id='SDEFSR_DatasetFromDataFrame'>Creates a <code>SDEFSR_Dataset</code> object from a <code>data.frame</code></h2><span id='topic+SDEFSR_DatasetFromDataFrame'></span>

<h3>Description</h3>

<p>Creates a <code>SDEFSR_Dataset</code> object from a <code>data.frame</code> and create fuzzy labels for numerical variables too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SDEFSR_DatasetFromDataFrame(
  data,
  relation,
  names = NA,
  types = NA,
  classNames = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SDEFSR_DatasetFromDataFrame_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> object with all neccesary information. See details.</p>
</td></tr>
<tr><td><code id="SDEFSR_DatasetFromDataFrame_+3A_relation">relation</code></td>
<td>
<p>A string that indicate the name of the relation.</p>
</td></tr>
<tr><td><code id="SDEFSR_DatasetFromDataFrame_+3A_names">names</code></td>
<td>
<p>An optional character vector indicating the name of the attributes.</p>
</td></tr>
<tr><td><code id="SDEFSR_DatasetFromDataFrame_+3A_types">types</code></td>
<td>
<p>An optional character vector indicating 'c' if variable is categorical, 'r' if is real and 'e' if it is an integer</p>
</td></tr>
<tr><td><code id="SDEFSR_DatasetFromDataFrame_+3A_classnames">classNames</code></td>
<td>
<p>An optional character vector indicating the values of the target class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information of the data.frame must be stored with instances in rows and variables in columns
If you dont specify any of the optional parameter the function try to obtain them automatically. 
</p>
<p>For <code>'names'</code> if it is NA, the function takes the name of the columns by <code>colnames</code>.
</p>
<p>For <code>'types'</code> if it is NA, the function takes the type of an attribute asking the type of the column of the data.frame.
If it is <code>'character'</code> it is assumed that it is categorical, and if <code>'numeric'</code> it is assumed that it is a real number.
PLEASE, PAY ATTENTION TO THIS WAY OF WORK. It can cause tranformation errors taking a numeric variable as categorical or vice-versa.
</p>
<p>For <code>'classNames'</code> if it is NA, the function returns unique values of the last attribute of the data.frame that is considered the class attribute.
</p>


<h3>Value</h3>

<p>A <code>SDEFSR_Dataset</code> object with all the information of the dataset.
</p>


<h3>Author(s)</h3>

<p>Angel M Garcia &lt;amgv0009@red.ujaen.es&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.dataset">read.dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SDEFSR)
df &lt;- data.frame(matrix(runif(1000), ncol = 10))
#Add class attribute
df[,11] &lt;- c("0", "1", "2", "3")
SDEFSR_DatasetObject &lt;- SDEFSR_DatasetFromDataFrame(df, "random")
invisible()

</code></pre>

<hr>
<h2 id='SDEFSR_GUI'>Launch a web interface for use the algorithms easily.</h2><span id='topic+SDEFSR_GUI'></span>

<h3>Description</h3>

<p>Launches a Shiny-based interface for the package in your browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SDEFSR_GUI()
</code></pre>


<h3>Details</h3>

<p>The package <code>SDEFSR</code> provide simple, shiny-based web interface for performs the taks 
easily. The interface only work with new datasets loaded directly in the platform.
</p>
<p>The web application is structured as follows:
</p>

<ul>
<li><p> The first you have to do is load your training and test files. This files must be valids KEEL format files.
</p>
</li>
<li><p> After chose your datasets, you can view information about the dataset or execute the algorithm
</p>
</li>
<li><p> You can choose the target variable or the variable to visualize and choose the target value or execute the algorithm for all the values.
</p>
</li>
<li><p> Choosed the target variable, you can  choose the algorithm to execute and change his parameters with the controls provided.
</p>
</li>
<li><p> After you can execute the algorithm. The results are exposed in three tabs that are at the top of the page, just at the right of the &quot;Exploratory Analysis&quot; tab.
</p>
</li></ul>

<p>The tables can be sorted for each value and also you can search and filter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SDEFSR)
SDEFSR_GUI()

## End(Not run)
    
</code></pre>

<hr>
<h2 id='SDIGA'>Subgroup Discovery Iterative Genetic Algorithm (SDIGA)</h2><span id='topic+SDIGA'></span>

<h3>Description</h3>

<p>Perfoms a subgroup discovery task executing the algorithm SDIGA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SDIGA(
  parameters_file = NULL,
  training = NULL,
  test = NULL,
  output = c("optionsFile.txt", "rulesFile.txt", "testQM.txt"),
  seed = 0,
  nLabels = 3,
  nEval = 10000,
  popLength = 100,
  mutProb = 0.01,
  RulesRep = "can",
  Obj1 = "CSUP",
  w1 = 0.7,
  Obj2 = "CCNF",
  w2 = 0.3,
  Obj3 = "null",
  w3 = 0,
  minConf = 0.6,
  lSearch = "yes",
  targetVariable = NA,
  targetClass = "null"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SDIGA_+3A_parameters_file">parameters_file</code></td>
<td>
<p>The path of the parameters file. <code>NULL</code> If you want to use training and test <code>SDEFSR_Dataset</code> variables</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_training">training</code></td>
<td>
<p>A <code>SDEFSR_Dataset</code> class variable with training data.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_test">test</code></td>
<td>
<p>A <code>SDEFSR_Dataset</code> class variable with training data.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_output">output</code></td>
<td>
<p>character vector with the paths of where store information file, rules file and test quality measures file, respectively.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_seed">seed</code></td>
<td>
<p>An integer to set the seed used for generate random numbers.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_nlabels">nLabels</code></td>
<td>
<p>Number of linguistic labels that represents numerical variables.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_neval">nEval</code></td>
<td>
<p>An integer for set the maximum number of evaluations in the evolutive process.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_poplength">popLength</code></td>
<td>
<p>An integer to set the number of individuals in the population.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_mutprob">mutProb</code></td>
<td>
<p>Sets the mutation probability. A number in [0,1].</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_rulesrep">RulesRep</code></td>
<td>
<p>Representation used in the rules. &quot;can&quot; for canonical rules, &quot;dnf&quot; for DNF rules.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_obj1">Obj1</code></td>
<td>
<p>Sets the Objective number 1. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_w1">w1</code></td>
<td>
<p>Sets the weight of <code>Obj1</code>.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_obj2">Obj2</code></td>
<td>
<p>Sets the Objective number 2. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_w2">w2</code></td>
<td>
<p>Sets the weight of <code>Obj2</code>.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_obj3">Obj3</code></td>
<td>
<p>Sets the Objective number 3. See <code>Objective values</code> for more information about the possible values.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_w3">w3</code></td>
<td>
<p>Sets the weight of <code>Obj3</code>.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_minconf">minConf</code></td>
<td>
<p>Sets the minimum confidence that must have the rule returned by the genetic algorithm after the local optimitation phase. A number in [0,1].</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_lsearch">lSearch</code></td>
<td>
<p>Sets if the local optimitation phase must be performed. A string with &quot;yes&quot; or &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_targetvariable">targetVariable</code></td>
<td>
<p>A string with the name or an integer with the index position of the target variable (or class). It must be a categorical one.</p>
</td></tr>
<tr><td><code id="SDIGA_+3A_targetclass">targetClass</code></td>
<td>
<p>A string specifing the value the target variable. <code>null</code> for search for all possible values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets as target variable the last one that appear in <code>SDEFSR_Dataset</code> object. If you want 
to change the target variable, you can set the <code>targetVariable</code> to change this target variable.
The target variable MUST be categorical, if it is not, throws an error. Also, the default behaviour is to find
rules for all possible values of the target varaible. <code>targetClass</code> sets a value of the target variable where the
algorithm only finds rules about this value.
</p>
<p>If you specify in <code>paramFile</code> something distinct to <code>NULL</code> the rest of the parameters are
ignored and the algorithm tries to read the file specified. See &quot;Parameters file structure&quot; below 
if you want to use a parameters file.
</p>


<h3>Value</h3>

<p>The algorithm shows in the console the following results:
</p>

<ol>
<li><p> The parameters used in the algorithm
</p>
</li>
<li><p> The rules generated.
</p>
</li>
<li><p> The quality measures for test of every rule and the global results.
</p>
</li></ol>

<p>Also, the algorithms save those results in the files specified in the <code>output</code> parameter of the algorithm or 
in the <code>outputData</code> parameter in the parameters file.
</p>


<h3>How does this algorithm work?</h3>

<p>This algorithm has a genetic algorithm in his core. This genetic algorithm returns only the best
rule of the population and it is executed so many times until a stop condition is reached. The stop condition is 
that the rule returned must cover at least one new example (not covered by previous rules) and must have a confidence
greater than a minimum.
</p>
<p>After returning the rule, a local improvement could be applied for make the rule more general. This local improve is done
by means of a hill-climbing local search.
</p>
<p>The genetic algorithm cross only the two best individuals. But the mutation operator is applied over all the population,
individuals from cross too.
</p>


<h3>Parameters file structure</h3>

<p>The <code>parameters_file</code> argument points to a file which has the necesary parameters for SDIGA works.
This file <strong>must</strong> be, at least, those parameters (separated by a carriage return):
</p>

<ul>
<li> <p><code>algorithm</code>  Specify the algorithm to execute. In this case. &quot;SDIGA&quot;
</p>
</li>
<li> <p><code>inputData</code>  Specify two paths of KEEL files for training and test. In case of specify only the name of the file, the path will be the working directory.
</p>
</li>
<li> <p><code>seed</code>  Sets the seed for the random number generator
</p>
</li>
<li> <p><code>nLabels</code>  Sets the number of fuzzy labels to create when reading the files
</p>
</li>
<li> <p><code>nEval</code>  Set the maximun number of <strong>evaluations of rules</strong> for stop the genetic process
</p>
</li>
<li> <p><code>popLength</code>  Sets number of individuals of the main population
</p>
</li>
<li> <p><code>mutProb</code>  Mutation probability of the genetic algorithm. Value in [0,1]
</p>
</li>
<li> <p><code>RulesRep</code>  Representation of each chromosome of the population. &quot;can&quot; for canonical representation. &quot;dnf&quot; for DNF representation.
</p>
</li>
<li> <p><code>Obj1</code> Sets the objective number 1. 
</p>
</li>
<li> <p><code>w1</code> Sets the weigth assigned to the objective number 1. Value in [0,1]
</p>
</li>
<li> <p><code>Obj2</code> Sets the objective number 2. 
</p>
</li>
<li> <p><code>w2</code> Sets the weigth assigned to the objective number 2. Value in [0,1]
</p>
</li>
<li> <p><code>Obj3</code> Sets the objective number 3. 
</p>
</li>
<li> <p><code>w3</code> Sets the weigth assigned to the objective number 3. Value in [0,1]
</p>
</li>
<li> <p><code>minConf</code> Sets the minimum confidence of the rule for checking the stopping criteria of the iterative process
</p>
</li>
<li> <p><code>lSearch</code> Perform the local search algorithm after the execution of the genetic algorithm? Values: &quot;yes&quot; or &quot;no&quot;
</p>
</li>
<li> <p><code>targetVariable</code> The name or index position of the target variable (or class). It must be a categorical one.
</p>
</li>
<li> <p><code>targetClass</code>  Value of the target variable to search for subgroups. The target variable <strong>is always the last variable.</strong>. Use <code>null</code> to search for every value of the target variable
</p>
</li></ul>

<p>An example of parameter file could be:
</p>
<pre>
algorithm = SDIGA
inputData = "irisD-10-1tra.dat" "irisD-10-1tst.dat"
outputData = "irisD-10-1-INFO.txt" "irisD-10-1-Rules.txt" "irisD-10-1-TestMeasures.txt"
seed = 0
nLabels = 3
nEval = 500
popLength = 100
mutProb = 0.01
minConf = 0.6
RulesRep = can
Obj1 = Comp
Obj2 = Unus
Obj3 = null
w1 = 0.7
w2 = 0.3
w3 = 0.0
lSearch = yes
</pre>


<h3>Objective values</h3>

<p>You can use the following quality measures in the ObjX value of the parameter file using this values:
</p>

<ul>
<li><p> Unusualness -&gt; <code>unus</code>
</p>
</li>
<li><p> Crisp Support -&gt; <code>csup</code>
</p>
</li>
<li><p> Crisp Confidence -&gt; <code>ccnf</code>
</p>
</li>
<li><p> Fuzzy Support -&gt; <code>fsup</code>
</p>
</li>
<li><p> Fuzzy Confidence -&gt; <code>fcnf</code>
</p>
</li>
<li><p> Coverage -&gt; <code>cove</code>
</p>
</li>
<li><p> Significance -&gt; <code>sign</code>
</p>
</li></ul>

<p>If you dont want to use a objetive value you must specify <code>null</code>
</p>


<h3>References</h3>

<p>M. J. del Jesus, P. Gonzalez, F. Herrera, and M. Mesonero, &quot;Evolutionary
Fuzzy Rule Induction Process for Subgroup Discovery: A case study in
marketing,&quot; IEEE Transactions on Fuzzy Systems, vol. 15, no. 4, pp.
578-592, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SDIGA(parameters_file = NULL, 
      training = habermanTra, 
      test = habermanTst, 
      output = c(NA, NA, NA),
      seed = 0, 
      nLabels = 3,
      nEval = 300, 
      popLength = 100, 
      mutProb = 0.01, 
      RulesRep = "can",
      Obj1 = "CSUP", 
      w1 = 0.7,
      Obj2 = "CCNF",
      w2 = 0.3,
      Obj3 = "null",
      w3 = 0,
      minConf = 0.6,
      lSearch = "yes",
      targetClass = "positive")
## Not run: 
SDIGA(parameters_file = NULL, 
      training = habermanTra, 
      test = habermanTst, 
      output = c("optionsFile.txt", "rulesFile.txt", "testQM.txt"),
      seed = 0, 
      nLabels = 3,
      nEval = 300, 
      popLength = 100, 
      mutProb = 0.01, 
      RulesRep = "can",
      Obj1 = "CSUP", 
      w1 = 0.7,
      Obj2 = "CCNF",
      w2 = 0.3,
      Obj3 = "null",
      w3 = 0,
      minConf = 0.6,
      lSearch = "yes",
      targetClass = "positive")
      
## End(Not run)
</code></pre>

<hr>
<h2 id='sort.SDEFSR_Rules'>@title Return an ordered rule set by a given quality measure
@description This function sorts a rule set in descendant order by a given quality measure that are available on the object</h2><span id='topic+sort.SDEFSR_Rules'></span>

<h3>Description</h3>

<p>@title Return an ordered rule set by a given quality measure
</p>
<p>@description This function sorts a rule set in descendant order by a given quality measure that are available on the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SDEFSR_Rules'
sort(x, decreasing = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.SDEFSR_Rules_+3A_x">x</code></td>
<td>
<p>The rule set passed as a <code>SDEFSR_Rules</code> object</p>
</td></tr>
<tr><td><code id="sort.SDEFSR_Rules_+3A_decreasing">decreasing</code></td>
<td>
<p>A logical indicating if the sort should be increasing or decreasing. By default, decreasing.</p>
</td></tr>
<tr><td><code id="sort.SDEFSR_Rules_+3A_...">...</code></td>
<td>
<p>Additional parameters as &quot;by&quot;, a String with the name of the quality measure to order by. Valid values are: <code>nVars, Coverage, Unusualness, Significance, FuzzySupport, Support, FuzzyConfidence, Confidence, Tpr, Fpr</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The additional argument in &quot;...&quot; is the 'by' argument, which is a s
string with the name of the quality measure to order by. Valid values are: 
<code>nVars, Coverage, Unusualness, Significance, FuzzySupport, Support, FuzzyConfidence, Confidence, Tpr, Fpr</code>.
</p>


<h3>Value</h3>

<p>another <code>SDEFSR_Rules</code> object with the rules sorted
</p>


<h3>Examples</h3>

<pre><code class='language-R'> sort(habermanRules)
 
</code></pre>

<hr>
<h2 id='summary.SDEFSR_Dataset'>S3 function to summary a SDEFSR_Dataset object</h2><span id='topic+summary.SDEFSR_Dataset'></span>

<h3>Description</h3>

<p>Summary relevant data of a <code>SDEFSR_Dataset</code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SDEFSR_Dataset'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SDEFSR_Dataset_+3A_object">object</code></td>
<td>
<p>A <code>SDEFSR_Dataset</code> class.</p>
</td></tr>
<tr><td><code id="summary.SDEFSR_Dataset_+3A_...">...</code></td>
<td>
<p>Additional arguments to the summary function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function show important information about the <code>SDEFSR_Dataset</code> dataset for the user. Note that it does not 
show all the information available. The rest is only for the algorithms. The values that appear are accessible by the
<code>$</code> operator, e.g. dataset$relation or dataset$examplesPerClass.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
summary(carTra) 

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
