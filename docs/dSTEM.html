<!DOCTYPE html><html><head><title>Help for package dSTEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dSTEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conv'><p>Compute convolution function using FFT</p></a></li>
<li><a href='#cp.plt'><p>Plot data sequence, the first and second-order derivatives, and their local extrema</p></a></li>
<li><a href='#cpTest'><p>Multiple testing of change points for kernel smoothed data</p></a></li>
<li><a href='#dstem'><p>Detection of change points based on 'dSTEM' algorithm</p></a></li>
<li><a href='#est.pair'><p>Identify pairwise local maxima and local minima of the second-order derivative</p></a></li>
<li><a href='#est.sigma2'><p>Estimate variance of smoothed Gaussian noise</p></a></li>
<li><a href='#est.slope'><p>Estimate piecewise slope for piecewise linear model</p></a></li>
<li><a href='#Fdr'><p>Compute TPR and FPR</p></a></li>
<li><a href='#fdrBH'><p>Compute FDR threshold based on Benjamini-Hochberg (BH) algorithm</p></a></li>
<li><a href='#gen.signal'><p>Generate simulated signals</p></a></li>
<li><a href='#HST_stock'><p>Stock price of Host &amp; Hotel Resorts (HST)</p></a></li>
<li><a href='#smth.gau'><p>Smoothing data using Gaussian kernel</p></a></li>
<li><a href='#snr'><p>Compute SNR of a certain change point location</p></a></li>
<li><a href='#which.peaks'><p>Find local maxima and local minima of data sequence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Testing of Local Extrema for Detection of Change Points</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-6-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhibing He &lt;zhibingh@asu.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhibing He &lt;zhibingh@asu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simultaneously detect the number and locations of change points in piecewise linear models under stationary Gaussian noise allowing autocorrelated random noise. The core idea is to transform the problem of detecting change points into the detection of local extrema (local maxima and local minima)through kernel smoothing and differentiation of the data sequence, see Cheng et al. (2020) &lt;<a href="https://doi.org/10.1214%2F20-EJS1751">doi:10.1214/20-EJS1751</a>&gt;. A low-computational and fast algorithm call 'dSTEM' is introduced to detect change points based on the 'STEM' algorithm in D. Cheng and A. Schwartzman (2017) &lt;<a href="https://doi.org/10.1214%2F16-AOS1458">doi:10.1214/16-AOS1458</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.1214/20-EJS1751">https://doi.org/10.1214/20-EJS1751</a>,
<a href="https://doi.org/10.1214/16-AOS1458">https://doi.org/10.1214/16-AOS1458</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-20 19:01:50 UTC; hzb</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-21 09:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='conv'>Compute convolution function using FFT</h2><span id='topic+conv'></span>

<h3>Description</h3>

<p>Compute convolution function using FFT, similar to <code>'conv'</code> in matlab
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv(u, v, shape = c("same", "full"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_+3A_u">u</code></td>
<td>
<p>numerical vector</p>
</td></tr>
<tr><td><code id="conv_+3A_v">v</code></td>
<td>
<p>numerical vector, don't need to have the same length as <code>u</code></p>
</td></tr>
<tr><td><code id="conv_+3A_shape">shape</code></td>
<td>
<p>if 'same', return central part of the convolution and has the same size as <code>u</code>;
otherwise return the whole sequence of size <code class="reqn">lenth(u)+length(v)-1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of convolution, as specified by shape.
</p>


<h3>References</h3>

<p>Matlab document on <code>'conv'</code>: <a href="https://www.mathworks.com/help/matlab/ref/conv.html">https://www.mathworks.com/help/matlab/ref/conv.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u = c(-1,2,3,-2,0,1,2)
v = c(2,4,-1,1)
w = conv(u,v,'same')
</code></pre>

<hr>
<h2 id='cp.plt'>Plot data sequence, the first and second-order derivatives, and their local extrema</h2><span id='topic+cp.plt'></span>

<h3>Description</h3>

<p>Plot data sequence, the first and second-order derivatives, and their local extrema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp.plt(x, order, icd.noise, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp.plt_+3A_x">x</code></td>
<td>
<p>numerical vector of signal or signal-plus-noise data</p>
</td></tr>
<tr><td><code id="cp.plt_+3A_order">order</code></td>
<td>
<p>order of derivative of data</p>
</td></tr>
<tr><td><code id="cp.plt_+3A_icd.noise">icd.noise</code></td>
<td>
<p>logical value indicating if <code>x</code> includes noise</p>
</td></tr>
<tr><td><code id="cp.plt_+3A_h">H</code></td>
<td>
<p>optional, vector of change-point locations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l = 1200
h = seq(150,by=150,length.out=6)
jump = c(0,1.5,2,2.2,1.8,2,1.5)*3
beta1 = c(2,-1,2.5,-3,-0.2,2.5,-0.5)/50
signal = gen.signal(l,h,jump,beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
sdata = smth.gau(signal+noise,gamma)
dy = diff(sdata)
ddy = diff(sdata,differences=2)
cp.plt(signal,0,FALSE)
points(signal+noise,col="grey")
cp.plt(dy,1,H=h)
cp.plt(ddy,2,H=h)

</code></pre>

<hr>
<h2 id='cpTest'>Multiple testing of change points for kernel smoothed data</h2><span id='topic+cpTest'></span>

<h3>Description</h3>

<p>Multiple testing of change points for kernel smoothed data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpTest(
  x,
  order,
  alpha,
  gamma,
  sigma,
  breaks,
  slope,
  untest,
  nu,
  is.constant,
  margin
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpTest_+3A_x">x</code></td>
<td>
<p>vector of kernel smoothed data</p>
</td></tr>
<tr><td><code id="cpTest_+3A_order">order</code></td>
<td>
<p>order of derivative of data</p>
</td></tr>
<tr><td><code id="cpTest_+3A_alpha">alpha</code></td>
<td>
<p>global significant level</p>
</td></tr>
<tr><td><code id="cpTest_+3A_gamma">gamma</code></td>
<td>
<p>bandwidth of Gaussian kernel</p>
</td></tr>
<tr><td><code id="cpTest_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of kernel smoothed noise</p>
</td></tr>
<tr><td><code id="cpTest_+3A_breaks">breaks</code></td>
<td>
<p>vector of rough estimate of change-point locations, only required when order is 1.</p>
</td></tr>
<tr><td><code id="cpTest_+3A_slope">slope</code></td>
<td>
<p>vector of rough estimate of slopes associated with <code>breaks</code>, only required when order is 1.</p>
</td></tr>
<tr><td><code id="cpTest_+3A_untest">untest</code></td>
<td>
<p>vector of locations unnecessary to test</p>
</td></tr>
<tr><td><code id="cpTest_+3A_nu">nu</code></td>
<td>
<p>standard deviation of Gaussian kernel used to generate autocorrelated Gaussian noise,
it is 0 if the noise is Gaussian white noise.</p>
</td></tr>
<tr><td><code id="cpTest_+3A_is.constant">is.constant</code></td>
<td>
<p>logical value indicating if the signal is piecewise constant,
if TRUE, <code>breaks</code> and <code>slope</code> are not necessary.</p>
</td></tr>
<tr><td><code id="cpTest_+3A_margin">margin</code></td>
<td>
<p>length of one period of data <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of estimated change-point locations and threshold for p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## piecewise linear signal
l = 1200
h = seq(150,by=150,length.out=6)
jump = rep(0,7)
beta1 = c(2,-1,2.5,-3,-0.2,2.5)/50
beta1 = c(beta1,-sum(beta1*(c(h[1],diff(h))))/(l-tail(h,1)))
signal = gen.signal(l,h,jump,beta1)
noise = rnorm(length(signal),0,2)
gamma = 25
sdata = smth.gau(signal+noise,gamma)
ddy = diff(sdata,differences=2)
model2 = cpTest(x=ddy,order=2,gamma=gamma,alpha=0.05)
## piecewise constant
l = 1200
h = seq(150,by=150,length.out=6)
jump = c(0,1.5,2,2.2,1.8,2,1.5)
beta1 = rep(0,length(h)+1)
signal = gen.signal(l,h,jump,beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
sdata = smth.gau(signal+noise,gamma)
dy = diff(sdata)
model1 = cpTest(x=dy,order=1,alpha=0.05,gamma=gamma,is.constant=TRUE)
## piecewise linear with jump
l = 1200
h = seq(150,by=150,length.out=6)
jump = c(0,1.5,2,2.2,1.8,2,1.5)*3
beta1 = c(2,-1,2.5,-3,-0.2,2.5,-0.5)/50
signal = gen.signal(l=l,h=h,jump=jump,b1=beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
sdata = smth.gau(signal+noise,gamma)
dy = diff(sdata)
ddy = diff(sdata,differences=2)
model2 = cpTest(x=ddy,order=2,gamma=gamma,alpha=0.1)
breaks = est.pair(vall=model2$vall,peak=model2$peak,gamma=gamma)$cp
slope = est.slope(x=(signal+noise),breaks=breaks)
</code></pre>

<hr>
<h2 id='dstem'>Detection of change points based on 'dSTEM' algorithm</h2><span id='topic+dstem'></span>

<h3>Description</h3>

<p>Detection of change points based on 'dSTEM' algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dstem(
  data,
  type = c("I", "II-step", "II-linear", "mixture"),
  gamma = 20,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dstem_+3A_data">data</code></td>
<td>
<p>vector of data sequence</p>
</td></tr>
<tr><td><code id="dstem_+3A_type">type</code></td>
<td>
<p>&quot;I&quot; if the change points are piecewise linear and continuous;
&quot;II-step&quot; if the change points are piecewise constant and noncontinuous;
&quot;II-linear&quot; if the change points are piecewise linear and noncontinuous;
&quot;mixture&quot; if both type I and type II change points are include in <code>data</code></p>
</td></tr>
<tr><td><code id="dstem_+3A_gamma">gamma</code></td>
<td>
<p>bandwidth of Gaussian kernel</p>
</td></tr>
<tr><td><code id="dstem_+3A_alpha">alpha</code></td>
<td>
<p>global significant level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if type is 'mixture', the output is a list of type I and type II change points,
otherwise, it is a list of change points
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpTest">cpTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## piecewise linear signal
l = 1200
h = seq(150,by=150,length.out=6)
jump = rep(0,7)
beta1 = c(2,-1,2.5,-3,-0.2,2.5)/50
beta1 = c(beta1,-sum(beta1*(c(h[1],diff(h))))/(l-tail(h,1)))
signal = gen.signal(l,h,jump,beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
model = dstem(signal + noise,"I",gamma=gamma,alpha=0.05)
## piecewise constant
l = 1200
h = seq(150,by=150,length.out=6)
jump = c(0,1.5,2,2.2,1.8,2,1.5)
beta1 = rep(0,length(h)+1)
signal = gen.signal(l,h,jump,beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
model = dstem(signal + noise, "II-step",gamma,alpha=0.05)
## piecewise linear with jump
l = 1200
h = seq(150,by=150,length.out=6)
jump = c(0,1.5,2,2.2,1.8,2,1.5)*3
beta1 = c(2,-1,2.5,-3,-0.2,2.5,-0.5)/50
signal = gen.signal(l=l,h=h,jump=jump,b1=beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
model = dstem(signal + noise, "II-linear",gamma,alpha=0.05)
</code></pre>

<hr>
<h2 id='est.pair'>Identify pairwise local maxima and local minima of the second-order derivative</h2><span id='topic+est.pair'></span>

<h3>Description</h3>

<p>Identify pairwise local maxima and local minima of the second-order derivative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.pair(vall, peak, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est.pair_+3A_vall">vall</code></td>
<td>
<p>vector of locations of significant local minima</p>
</td></tr>
<tr><td><code id="est.pair_+3A_peak">peak</code></td>
<td>
<p>vector of locations of significant local maxima</p>
</td></tr>
<tr><td><code id="est.pair_+3A_gamma">gamma</code></td>
<td>
<p>bandwidth of Gaussian kernel smoothing function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of detected pairs and detected change-point locations through second-order derivative testing
</p>

<hr>
<h2 id='est.sigma2'>Estimate variance of smoothed Gaussian noise</h2><span id='topic+est.sigma2'></span>

<h3>Description</h3>

<p>Estimate variance of smoothed Gaussian noise through its second-order derivative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.sigma2(x, gamma, k = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est.sigma2_+3A_x">x</code></td>
<td>
<p>numerical vector of second-order derivative of kernel smoothed data</p>
</td></tr>
<tr><td><code id="est.sigma2_+3A_gamma">gamma</code></td>
<td>
<p>bandwidth of Gaussian kernel</p>
</td></tr>
<tr><td><code id="est.sigma2_+3A_k">k</code></td>
<td>
<p>numerical value, local maxima (minima) are presumed beyond <code class="reqn">Mean(x) ± k*SD(x)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of estimated variance of smoothed noise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l=15000; h = seq(150,l,150)
jump = rep(0,length(h)+1); b1 = seq(from=0,by=0.15,length = length(h)+1)
signal = gen.signal(l,h,jump,b1)
data = signal + rnorm(length(signal),0,1) # standard white noise
gamma = 10
ddy = diff(smth.gau(data,gamma),differences=2)
est.sigma2(ddy,gamma,k=0.5) # true value is \eqn{\frac{1}{2\sqrt{pi}\gamma}}
</code></pre>

<hr>
<h2 id='est.slope'>Estimate piecewise slope for piecewise linear model</h2><span id='topic+est.slope'></span>

<h3>Description</h3>

<p>Estimate piecewise slope for piecewise linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.slope(x, breaks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est.slope_+3A_x">x</code></td>
<td>
<p>numerical vector of signal-plus-noise data</p>
</td></tr>
<tr><td><code id="est.slope_+3A_breaks">breaks</code></td>
<td>
<p>numerical vector of change-point locations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of estimated piecewise slope
</p>

<hr>
<h2 id='Fdr'>Compute TPR and FPR</h2><span id='topic+Fdr'></span>

<h3>Description</h3>

<p>Compute TPR and FPR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fdr(uh, th, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fdr_+3A_uh">uh</code></td>
<td>
<p>numerical vector of estimated change point locations</p>
</td></tr>
<tr><td><code id="Fdr_+3A_th">th</code></td>
<td>
<p>numerical vector of true change point locations</p>
</td></tr>
<tr><td><code id="Fdr_+3A_b">b</code></td>
<td>
<p>location tolerance, usually specified as the bandwidth <code>gamma</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe of <code>FDR</code> (FPR) and <code>Power</code> (TPR)
</p>

<hr>
<h2 id='fdrBH'>Compute FDR threshold based on Benjamini-Hochberg (BH) algorithm</h2><span id='topic+fdrBH'></span>

<h3>Description</h3>

<p>Compute FDR threshold based on Benjamini-Hochberg (BH) algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdrBH(p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdrBH_+3A_p">p</code></td>
<td>
<p>a vector of p-values</p>
</td></tr>
<tr><td><code id="fdrBH_+3A_q">q</code></td>
<td>
<p>False Discovery Rate level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value threshold based on independence or positive dependence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdrBH(seq(0.01,0.1,0.01),q=0.1)

</code></pre>

<hr>
<h2 id='gen.signal'>Generate simulated signals</h2><span id='topic+gen.signal'></span>

<h3>Description</h3>

<p>Generate simulated signals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.signal(l, h, jump, b1, rep = 1, shift = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.signal_+3A_l">l</code></td>
<td>
<p>length of data, if data is periodic then the length in each period</p>
</td></tr>
<tr><td><code id="gen.signal_+3A_h">h</code></td>
<td>
<p>numerical vector of true change point locations</p>
</td></tr>
<tr><td><code id="gen.signal_+3A_jump">jump</code></td>
<td>
<p>numerical vector of jump size at change point locations</p>
</td></tr>
<tr><td><code id="gen.signal_+3A_b1">b1</code></td>
<td>
<p>numerical vector of piecewise slopes</p>
</td></tr>
<tr><td><code id="gen.signal_+3A_rep">rep</code></td>
<td>
<p>number of periods if data is periodic, default is 1</p>
</td></tr>
<tr><td><code id="gen.signal_+3A_shift">shift</code></td>
<td>
<p>numerical vector of vertical shifts for each period, default is 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of simulated signal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l = 1200
h = seq(150,by=150,length.out=6)
jump = rep(0,7)
beta1 = c(2,-1,2.5,-3,-0.2,2.5)/50
beta1 = c(beta1,-sum(beta1*(c(h[1],diff(h))))/(l-tail(h,1)))
signal = gen.signal(l,h,jump,beta1)
</code></pre>

<hr>
<h2 id='HST_stock'>Stock price of Host &amp; Hotel Resorts (HST)</h2><span id='topic+HST_stock'></span>

<h3>Description</h3>

<p>A subset of daily stock price data of HST from November 7, 2011 to November
5, 2021.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HST_stock
</code></pre>


<h3>Format</h3>

<p>A data frame with 2,517 rows and 6 columns:
</p>

<dl>
<dt>Date</dt><dd><p>date from November 7, 2011 to November 5, 2021</p>
</dd>
<dt>Close, Open, High, Low</dt><dd><p>stock price</p>
</dd>
<dt>Volume</dt><dd><p>stock exchange volume</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://finance.yahoo.com/quote/HST&gt;
</p>

<hr>
<h2 id='smth.gau'>Smoothing data using Gaussian kernel</h2><span id='topic+smth.gau'></span>

<h3>Description</h3>

<p>Smoothing data using Gaussian kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smth.gau(x, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smth.gau_+3A_x">x</code></td>
<td>
<p>numeric vector of values to smooth</p>
</td></tr>
<tr><td><code id="smth.gau_+3A_gamma">gamma</code></td>
<td>
<p>bandwidth of Gaussian kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of smoothed values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smth.gau(x=rnorm(1000), gamma=20)
</code></pre>

<hr>
<h2 id='snr'>Compute SNR of a certain change point location</h2><span id='topic+snr'></span>

<h3>Description</h3>

<p>Compute SNR of a certain change point location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snr(order, gamma, is.jump, jump, diffb, addb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snr_+3A_order">order</code></td>
<td>
<p>order of derivative of data</p>
</td></tr>
<tr><td><code id="snr_+3A_gamma">gamma</code></td>
<td>
<p>bandwidth of Gaussian kernel</p>
</td></tr>
<tr><td><code id="snr_+3A_is.jump">is.jump</code></td>
<td>
<p>logical value indicating if the location to be calculated is a jump point</p>
</td></tr>
<tr><td><code id="snr_+3A_jump">jump</code></td>
<td>
<p>jump height</p>
</td></tr>
<tr><td><code id="snr_+3A_diffb">diffb</code></td>
<td>
<p>difference of the slopes on left and right sides of the location</p>
</td></tr>
<tr><td><code id="snr_+3A_addb">addb</code></td>
<td>
<p>sum of the slopes, only used when order is 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of SNR
</p>

<hr>
<h2 id='which.peaks'>Find local maxima and local minima of data sequence</h2><span id='topic+which.peaks'></span>

<h3>Description</h3>

<p>Find local maxima and local minima of data sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.peaks(x, partial = FALSE, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.peaks_+3A_x">x</code></td>
<td>
<p>numerical vector contains local maxima (minima)</p>
</td></tr>
<tr><td><code id="which.peaks_+3A_partial">partial</code></td>
<td>
<p>logical value indicating if the two endpoints will be considered</p>
</td></tr>
<tr><td><code id="which.peaks_+3A_decreasing">decreasing</code></td>
<td>
<p>logical value indicating whether to find local minima</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of locations of local maxima or minima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = 100:1
which.peaks(a*sin(a/3))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
