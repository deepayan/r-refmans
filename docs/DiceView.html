<!DOCTYPE html><html><head><title>Help for package DiceView</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiceView}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Apply.function'><p>Apply Functions Over Array Margins, using custom vectorization (possibly using parallel)</p></a></li>
<li><a href='#are_in.mesh'><p>Checks if some points belong to a given mesh</p></a></li>
<li><a href='#branin'><p>This is a simple copy of the Branin-Hoo 2-dimensional test function, as provided in DiceKriging package.</p>
The Branin-Hoo function is defined here over [0,1] x [0,1], instead of [-5,0] x [10,15] as usual.
It has 3 global minima : x1 = c(0.9616520, 0.15); x2 = c(0.1238946, 0.8166644); x3 = c(0.5427730, 0.15)</a></li>
<li><a href='#combn.design'><p>Generalize expand.grid() for multi-columns data. Build all combinations of lines from X1 and X2. Each line may hold multiple columns.</p></a></li>
<li><a href='#contourview.function'><p>Plot a contour view of a prediction model or function, including design points if available.</p></a></li>
<li><a href='#is_in.mesh'><p>Checks if some point belongs to a given mesh</p></a></li>
<li><a href='#is_in.p'><p>Test if points are in a hull</p></a></li>
<li><a href='#Memoize.function'><p>Memoize a function</p></a></li>
<li><a href='#mesh_exsets'><p>Search excursion set of nD function, sampled by a mesh</p></a></li>
<li><a href='#mesh_roots'><p>Multi Dimensional Multiple Roots (Zero) Finding, sampled by a mesh</p></a></li>
<li><a href='#min_dist'><p>Minimal distance between one point to many points</p></a></li>
<li><a href='#optims'><p>Title Multi-local optimization wrapper for optim, using (possibly parallel) multistart.</p></a></li>
<li><a href='#plot_mesh'><p>Plot a one dimensional mesh</p></a></li>
<li><a href='#plot2d_mesh'><p>Plot a two dimensional mesh</p></a></li>
<li><a href='#plot3d_mesh'><p>Plot a three dimensional mesh</p></a></li>
<li><a href='#points_in.mesh'><p>Extract points of mesh which belong to the mesh triangulation (may not contain all points)</p></a></li>
<li><a href='#points_out.mesh'><p>Extract points of mesh which do not belong to the mesh triangulation (may not contain all points)</p></a></li>
<li><a href='#root'><p>One Dimensional Root (Zero) Finding</p></a></li>
<li><a href='#roots'><p>One Dimensional Multiple Roots (Zero) Finding</p></a></li>
<li><a href='#sectionview.function'><p>Plot a section view of a prediction model or function, including design points if available.</p></a></li>
<li><a href='#sectionview3d.function'><p>Plot a contour view of a prediction model or function, including design points if available.</p></a></li>
<li><a href='#Vectorize.function'><p>Vectorize a multidimensional Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Methods for Visualization of Computer Experiments Design and
Surrogate</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yann Richet &lt;yann.richet@irsn.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>View 2D/3D sections, contour plots, mesh of excursion sets for computer experiments designs, surrogates or test functions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, utils, stats, grDevices, graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>DiceDesign, R.cache, geometry, scatterplot3d, parallel,
foreach</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rlibkriging, DiceKriging, DiceEval, rgl, arrangements</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/IRSN/DiceView">https://github.com/IRSN/DiceView</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-15 09:25:01 UTC; richet</td>
</tr>
<tr>
<td>Author:</td>
<td>Yann Richet <a href="https://orcid.org/0000-0002-5677-8458"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Yves Deville [aut],
  Clement Chevalier [ctb]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-15 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Apply.function'>Apply Functions Over Array Margins, using custom vectorization (possibly using parallel)</h2><span id='topic+Apply.function'></span>

<h3>Description</h3>

<p>Emulate parallel apply on a function, from mclapply. Returns a vector or array or list of values obtained by applying a function to margins of an array or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Apply.function(
  FUN,
  X,
  MARGIN = 1,
  .combine = c,
  .lapply = parallel::mclapply,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Apply.function_+3A_fun">FUN</code></td>
<td>
<p>function to apply on X</p>
</td></tr>
<tr><td><code id="Apply.function_+3A_x">X</code></td>
<td>
<p>array of input values for FUN</p>
</td></tr>
<tr><td><code id="Apply.function_+3A_margin">MARGIN</code></td>
<td>
<p>1 indicates to apply on rows (default), 2 on columns</p>
</td></tr>
<tr><td><code id="Apply.function_+3A_.combine">.combine</code></td>
<td>
<p>how to combine results (default using c(.))</p>
</td></tr>
<tr><td><code id="Apply.function_+3A_.lapply">.lapply</code></td>
<td>
<p>how to vectorize FUN call (default is parallel::mclapply)</p>
</td></tr>
<tr><td><code id="Apply.function_+3A_...">...</code></td>
<td>
<p>optional arguments to FUN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of values taken by FUN on each row/column of X
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = matrix(runif(10),ncol=2);
  rowSums(X) == apply(X,1,sum)
  apply(X,1,sum) == Apply.function(sum,X)

X = matrix(runif(10),ncol=1)
  rowSums(X) == apply(X,1,sum)
  apply(X,1,sum) == Apply.function(sum,X)

X = matrix(runif(10),ncol=2)
f = function(X) X[1]/X[2]
apply(X,1,f) == Apply.function(f,X)
</code></pre>

<hr>
<h2 id='are_in.mesh'>Checks if some points belong to a given mesh</h2><span id='topic+are_in.mesh'></span>

<h3>Description</h3>

<p>Checks if some points belong to a given mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_in.mesh(X, mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_in.mesh_+3A_x">X</code></td>
<td>
<p>points to check</p>
</td></tr>
<tr><td><code id="are_in.mesh_+3A_mesh">mesh</code></td>
<td>
<p>mesh identifying the set which X may belong</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X = matrix(runif(100),ncol=2);
inside = are_in.mesh(X,mesh=geometry::delaunayn(matrix(c(0,0,1,1,0,0),ncol=2),output.options =TRUE))
print(inside)
plot(X,col=rgb(1-inside,0,0+inside))
</code></pre>

<hr>
<h2 id='branin'>This is a simple copy of the Branin-Hoo 2-dimensional test function, as provided in DiceKriging package.
The Branin-Hoo function is defined here over [0,1] x [0,1], instead of [-5,0] x [10,15] as usual.
It has 3 global minima : x1 = c(0.9616520, 0.15); x2 = c(0.1238946, 0.8166644); x3 = c(0.5427730, 0.15)</h2><span id='topic+branin'></span>

<h3>Description</h3>

<p>This is a simple copy of the Branin-Hoo 2-dimensional test function, as provided in DiceKriging package.
The Branin-Hoo function is defined here over [0,1] x [0,1], instead of [-5,0] x [10,15] as usual.
It has 3 global minima : x1 = c(0.9616520, 0.15); x2 = c(0.1238946, 0.8166644); x3 = c(0.5427730, 0.15)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branin_+3A_x">x</code></td>
<td>
<p>a 2-dimensional vector specifying the location where the function is to be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number equal to the Branin-Hoo function values at x
</p>

<hr>
<h2 id='combn.design'>Generalize expand.grid() for multi-columns data. Build all combinations of lines from X1 and X2. Each line may hold multiple columns.</h2><span id='topic+combn.design'></span>

<h3>Description</h3>

<p>Generalize expand.grid() for multi-columns data. Build all combinations of lines from X1 and X2. Each line may hold multiple columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combn.design(X1, X2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combn.design_+3A_x1">X1</code></td>
<td>
<p>variable values, possibly with many columns</p>
</td></tr>
<tr><td><code id="combn.design_+3A_x2">X2</code></td>
<td>
<p>variable values, possibly with many columns
combn.design(matrix(c(10,20),ncol=1),matrix(c(1,2,3,4,5,6),ncol=2))
combn.design(matrix(c(10,20,30,40),ncol=2),matrix(c(1,2,3,4,5,6),ncol=2))</p>
</td></tr>
</table>

<hr>
<h2 id='contourview.function'>Plot a contour view of a prediction model or function, including design points if available.</h2><span id='topic+contourview.function'></span><span id='topic+contourview+2Cfunction+2Cfunction-method'></span><span id='topic+contourview.matrix'></span><span id='topic+contourview+2Cmatrix+2Cmatrix-method'></span><span id='topic+contourview.km'></span><span id='topic+contourview+2Ckm+2Ckm-method'></span><span id='topic+contourview.Kriging'></span><span id='topic+contourview+2CKriging+2CKriging-method'></span><span id='topic+contourview.NuggetKriging'></span><span id='topic+contourview+2CNuggetKriging+2CNuggetKriging-method'></span><span id='topic+contourview.NoiseKriging'></span><span id='topic+contourview+2CNoiseKriging+2CNoiseKriging-method'></span><span id='topic+contourview.glm'></span><span id='topic+contourview+2Cglm+2Cglm-method'></span><span id='topic+contourview.list'></span><span id='topic+contourview+2Clist+2Clist-method'></span><span id='topic+contourview'></span>

<h3>Description</h3>

<p>Plot a contour view of a prediction model or function, including design points if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
contourview(
  fun,
  vectorized = FALSE,
  dim = NULL,
  center = NULL,
  axis = NULL,
  npoints = 20,
  nlevels = 10,
  col_surf = "blue",
  filled = FALSE,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'matrix'
contourview(
  X,
  y,
  sdy = NULL,
  center = NULL,
  axis = NULL,
  col_points = "red",
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'km'
contourview(
  km_model,
  type = "UK",
  center = NULL,
  axis = NULL,
  npoints = 20,
  nlevels = 10,
  col_points = "red",
  col_surf = "blue",
  filled = FALSE,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'Kriging'
contourview(
  Kriging_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  nlevels = 10,
  col_points = "red",
  col_surf = "blue",
  filled = FALSE,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'NuggetKriging'
contourview(
  NuggetKriging_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  nlevels = 10,
  col_points = "red",
  col_surf = "blue",
  filled = FALSE,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'NoiseKriging'
contourview(
  NoiseKriging_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  nlevels = 10,
  col_points = "red",
  col_surf = "blue",
  filled = FALSE,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'glm'
contourview(
  glm_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  nlevels = 10,
  col_points = "red",
  col_surf = "blue",
  filled = FALSE,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'list'
contourview(
  modelFit_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  nlevels = 10,
  col_points = "red",
  col_surf = "blue",
  bg_blend = 1,
  filled = FALSE,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

contourview(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contourview.function_+3A_fun">fun</code></td>
<td>
<p>a function or 'predict()'-like function that returns a simple numeric or mean and standard error: list(mean=...,se=...).</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_vectorized">vectorized</code></td>
<td>
<p>is fun vectorized?</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_dim">dim</code></td>
<td>
<p>input variables dimension of the model or function.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_center">center</code></td>
<td>
<p>optional coordinates (as a list or data frame) of the center of the section view if the model's dimension is &gt; 2.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_axis">axis</code></td>
<td>
<p>optional matrix of 2-axis combinations to plot, one by row. The value <code>NULL</code> leads to all possible combinations i.e. <code>choose(D, 2)</code>.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_npoints">npoints</code></td>
<td>
<p>an optional number of points to discretize plot of response  surface and uncertainties.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_nlevels">nlevels</code></td>
<td>
<p>number of contour levels to display.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_col_surf">col_surf</code></td>
<td>
<p>color for the surface.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_filled">filled</code></td>
<td>
<p>use filled.contour</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_mfrow">mfrow</code></td>
<td>
<p>an optional list to force <code>par(mfrow = ...)</code> call. The default value  <code>NULL</code> is automatically set for compact view.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_xlab">Xlab</code></td>
<td>
<p>an optional list of string to overload names for X.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_ylab">ylab</code></td>
<td>
<p>an optional string to overload name for y.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_xlim">Xlim</code></td>
<td>
<p>an optional list to force x range for all plots. The default value <code>NULL</code> is automatically set to include all design points.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_title">title</code></td>
<td>
<p>an optional overload of main title.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_add">add</code></td>
<td>
<p>to print graphics on an existing window.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_...">...</code></td>
<td>
<p>arguments of the <code>contourview.km</code>, <code>contourview.glm</code>, <code>contourview.Kriging</code> or <code>contourview.function</code> function</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_x">X</code></td>
<td>
<p>the matrix of input design.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_y">y</code></td>
<td>
<p>the array of output values.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_sdy">sdy</code></td>
<td>
<p>optional array of output standard error.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_col_points">col_points</code></td>
<td>
<p>color of points.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_bg_blend">bg_blend</code></td>
<td>
<p>an optional factor of alpha (color channel) blending used to plot design points outside from this section.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_km_model">km_model</code></td>
<td>
<p>an object of class <code>"km"</code>.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_type">type</code></td>
<td>
<p>the kriging type to use for model prediction.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_kriging_model">Kriging_model</code></td>
<td>
<p>an object of class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_nuggetkriging_model">NuggetKriging_model</code></td>
<td>
<p>an object of class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_noisekriging_model">NoiseKriging_model</code></td>
<td>
<p>an object of class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_glm_model">glm_model</code></td>
<td>
<p>an object of class <code>"glm"</code>.</p>
</td></tr>
<tr><td><code id="contourview.function_+3A_modelfit_model">modelFit_model</code></td>
<td>
<p>an object returned by DiceEval::modelFit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If available, experimental points are plotted with fading colors. Points that fall in the specified section (if any) have the color specified <code>col_points</code> while points far away from the center have shaded versions of the same color. The amount of fading is determined using the Euclidean distance between the plotted point and <code>center</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet, IRSN
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sectionview.function">sectionview.function</a></code> for a section plot, and <code><a href="#topic+sectionview3d.function">sectionview3d.function</a></code> for a 2D section plot.
<code><a href="#topic+Vectorize.function">Vectorize.function</a></code> to wrap as vectorized a non-vectorized function.
</p>
<p><code><a href="#topic+sectionview.matrix">sectionview.matrix</a></code> for a section plot, and <code><a href="#topic+sectionview3d.matrix">sectionview3d.matrix</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.km">sectionview.km</a></code> for a section plot, and <code><a href="#topic+sectionview3d.km">sectionview3d.km</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.Kriging">sectionview.Kriging</a></code> for a section plot, and <code><a href="#topic+sectionview3d.Kriging">sectionview3d.Kriging</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.NuggetKriging">sectionview.NuggetKriging</a></code> for a section plot, and <code><a href="#topic+sectionview3d.NuggetKriging">sectionview3d.NuggetKriging</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.NoiseKriging">sectionview.NoiseKriging</a></code> for a section plot, and <code><a href="#topic+sectionview3d.NoiseKriging">sectionview3d.NoiseKriging</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.glm">sectionview.glm</a></code> for a section plot, and <code><a href="#topic+sectionview3d.glm">sectionview3d.glm</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.glm">sectionview.glm</a></code> for a section plot, and <code><a href="#topic+sectionview3d.glm">sectionview3d.glm</a></code> for a 2D section plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rnorm(15)
x2 &lt;- rnorm(15)


y &lt;- x1 + x2 + rnorm(15)
model &lt;- lm(y ~ x1 + x2)

contourview(function(x) sum(x),
                     dim=2, Xlim=cbind(range(x1),range(x2)), col='black')
points(x1,x2)

contourview(function(x) {
                      x = as.data.frame(x)
                      colnames(x) &lt;- names(model$coefficients[-1])
                      p = predict.lm(model, newdata=x, se.fit=TRUE)
                      list(mean=p$fit, se=p$se.fit)
                    }, vectorized=TRUE, dim=2, Xlim=cbind(range(x1),range(x2)), add=TRUE)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

contourview(X, y)

if (requireNamespace("DiceKriging")) { library(DiceKriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

model &lt;- km(design = X, response = y, covtype="matern3_2")

contourview(model)

}

if (requireNamespace("rlibkriging")) { library(rlibkriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

model &lt;- Kriging(X = X, y = y, kernel="matern3_2")

contourview(model)

}

if (requireNamespace("rlibkriging")) { library(rlibkriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin) + 5*rnorm(15)

model &lt;- NuggetKriging(X = X, y = y, kernel="matern3_2")

contourview(model)

}

if (requireNamespace("rlibkriging")) { library(rlibkriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin) + 5*rnorm(15)

model &lt;- NoiseKriging(X = X, y = y, kernel="matern3_2", noise=rep(5^2,15))

contourview(model)

}

x1 &lt;- rnorm(15)
x2 &lt;- rnorm(15)

y &lt;- x1 + x2^2 + rnorm(15)
model &lt;- glm(y ~ x1 + I(x2^2))

contourview(model)

if (requireNamespace("DiceEval")) { library(DiceEval)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

model &lt;- modelFit(X, y, type = "StepLinear")

contourview(model)

}

## A 2D example - Branin-Hoo function
contourview(branin, dim=2, nlevels=30, col='black')

## Not run: 
## a 16-points factorial design, and the corresponding response
d &lt;- 2; n &lt;- 16
design.fact &lt;- expand.grid(seq(0, 1, length = 4), seq(0, 1, length = 4))
design.fact &lt;- data.frame(design.fact); names(design.fact) &lt;- c("x1", "x2")
y &lt;- branin(design.fact); names(y) &lt;- "y"

if (requireNamespace("DiceKriging")) { library(DiceKriging)
## model: km
model &lt;- DiceKriging::km(design = design.fact, response = y)
contourview(model, nlevels=30)
contourview(branin, dim=2, nlevels=30, col='red', add=TRUE)
}

## model: Kriging
if (requireNamespace("rlibkriging")) { library(rlibkriging)
model &lt;- Kriging(X = as.matrix(design.fact), y = as.matrix(y), kernel="matern3_2")
contourview(model, nlevels=30)
contourview(branin, dim=2, nlevels=30, col='red', add=TRUE)
}

## model: glm
model &lt;- glm(y ~ 1+ x1 + x2 + I(x1^2) + I(x2^2) + x1*x2, data=cbind(y,design.fact))
contourview(model, nlevels=30)
contourview(branin, dim=2, nlevels=30, col='red', add=TRUE)

if (requireNamespace("DiceEval")) { library(DiceEval)
## model: StepLinear
model &lt;- modelFit(design.fact, y, type = "StepLinear")
contourview(model, nlevels=30)
contourview(branin, dim=2, nlevels=30, col='red', add=TRUE)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='is_in.mesh'>Checks if some point belongs to a given mesh</h2><span id='topic+is_in.mesh'></span>

<h3>Description</h3>

<p>Checks if some point belongs to a given mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_in.mesh(x, mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_in.mesh_+3A_x">x</code></td>
<td>
<p>point to check</p>
</td></tr>
<tr><td><code id="is_in.mesh_+3A_mesh">mesh</code></td>
<td>
<p>mesh identifying the set which X may belong</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_in.mesh(-0.5,mesh=geometry::delaunayn(matrix(c(0,1),ncol=1),output.options =TRUE))
is_in.mesh(0.5,mesh=geometry::delaunayn(matrix(c(0,1),ncol=1),output.options =TRUE))

x =matrix(-.5,ncol=2,nrow=1)
is_in.mesh(x,mesh=geometry::delaunayn(matrix(c(0,0,1,1,0,0),ncol=2),output.options =TRUE))

x =matrix(.5,ncol=2,nrow=1)
is_in.mesh(x,mesh=geometry::delaunayn(matrix(c(0,0,1,1,0,0),ncol=2),output.options =TRUE))
</code></pre>

<hr>
<h2 id='is_in.p'>Test if points are in a hull</h2><span id='topic+is_in.p'></span>

<h3>Description</h3>

<p>Test if points are in a hull
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_in.p(x, p, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_in.p_+3A_x">x</code></td>
<td>
<p>points to test</p>
</td></tr>
<tr><td><code id="is_in.p_+3A_p">p</code></td>
<td>
<p>points defining the hull</p>
</td></tr>
<tr><td><code id="is_in.p_+3A_h">h</code></td>
<td>
<p>hull itself (built from p if given as NULL (default))</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_in.p(x=-0.5,p=matrix(c(0,1),ncol=1))
is_in.p(x=0.5,p=matrix(c(0,1),ncol=1))
is_in.p(x=matrix(-.5,ncol=2,nrow=1),p=matrix(c(0,0,1,1,0,0),ncol=2))
is_in.p(x=matrix(.25,ncol=2,nrow=1),p=matrix(c(0,0,1,1,0,0),ncol=2))
is_in.p(x=matrix(-.5,ncol=3,nrow=1),p=matrix(c(0,0,0,1,0,0,0,1,0,0,0,1),ncol=3,byrow = TRUE))
is_in.p(x=matrix(.25,ncol=3,nrow=1),p=matrix(c(0,0,0,1,0,0,0,1,0,0,0,1),ncol=3,byrow = TRUE))
</code></pre>

<hr>
<h2 id='Memoize.function'>Memoize a function</h2><span id='topic+Memoize.function'></span>

<h3>Description</h3>

<p>Before each call of a function, check that the cache holds the results and returns it if available. Otherwise, compute f and cache the result for next evluations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Memoize.function(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Memoize.function_+3A_fun">fun</code></td>
<td>
<p>function to memoize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function with same behavior than argument one, but using cache.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f=function(n) rnorm(n);
F=Memoize.function(f);
F(5); F(6); F(5)
</code></pre>

<hr>
<h2 id='mesh_exsets'>Search excursion set of nD function, sampled by a mesh</h2><span id='topic+mesh_exsets'></span>

<h3>Description</h3>

<p>Search excursion set of nD function, sampled by a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh_exsets(
  f,
  vectorized = FALSE,
  threshold,
  sign,
  intervals,
  mesh = "seq",
  mesh.sizes = 11,
  maxerror_f = 1e-09,
  tol = .Machine$double.eps^0.25,
  ex_filter.tri = all,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh_exsets_+3A_f">f</code></td>
<td>
<p>Function to inverse at 'threshold'</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_vectorized">vectorized</code></td>
<td>
<p>boolean: is f already vectorized ? (default: FALSE) or if function: vectorized version of f.</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_threshold">threshold</code></td>
<td>
<p>target value to inverse</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_sign">sign</code></td>
<td>
<p>focus at conservative for above (sign=1) or below (sign=-1) the threshold</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_intervals">intervals</code></td>
<td>
<p>bounds to inverse in, each column contains min and max of each dimension</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_mesh">mesh</code></td>
<td>
<p>function or &quot;unif&quot; or &quot;seq&quot; (default) to preform interval partition</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_mesh.sizes">mesh.sizes</code></td>
<td>
<p>number of parts for mesh (duplicate for each dimension if using &quot;seq&quot;)</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_maxerror_f">maxerror_f</code></td>
<td>
<p>maximal tolerance on f precision</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance on f arg).</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_ex_filter.tri">ex_filter.tri</code></td>
<td>
<p>boolean function to validate a geometry::tri as considered in excursion : 'any' or 'all'</p>
</td></tr>
<tr><td><code id="mesh_exsets_+3A_...">...</code></td>
<td>
<p>parameters to forward to mesh_roots(...) call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># mesh_exsets(function(x) x, threshold=.51, sign=1, intervals=rbind(0,1),
#   maxerror_f=1E-2,tol=1E-2) # for faster testing
# mesh_exsets(function(x) x, threshold=.50000001, sign=1, intervals=rbind(0,1),
#   maxerror_f=1E-2,tol=1E-2) # for faster testing
# mesh_exsets(function(x) sum(x), threshold=.51,sign=1, intervals=cbind(rbind(0,1),rbind(0,1)),
#   maxerror_f=1E-2,tol=1E-2) # for faster testing
# mesh_exsets(sin,threshold=0,sign="sup",interval=c(pi/2,5*pi/2),
#   maxerror_f=1E-2,tol=1E-2) # for faster testing

if (identical(Sys.getenv("NOT_CRAN"), "true")) { # too long for CRAN on Windows

  e = mesh_exsets(function(x) (0.25+x[1])^2+(0.5+x[2])^2 ,
                threshold =0.25,sign=-1, intervals=matrix(c(-1,1,-1,1),nrow=2),
                maxerror_f=1E-2,tol=1E-2) # for faster testing

  plot(e$p,xlim=c(-1,1),ylim=c(-1,1));
  apply(e$tri,1,function(tri) polygon(e$p[tri,],col=rgb(.4,.4,.4,.4)))

  if (requireNamespace("rgl")) {
    e = mesh_exsets(function(x) (0.5+x[1])^2+(-0.5+x[2])^2+(0.+x[3])^2,
                  threshold = .25,sign=-1, mesh="unif",
                  intervals=matrix(c(-1,1,-1,1,-1,1),nrow=2),
                  maxerror_f=1E-2,tol=1E-2) # for faster testing

    rgl::plot3d(e$p,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1));
    apply(e$tri,1,function(tri)rgl::lines3d(e$p[tri,]))
  }
}
</code></pre>

<hr>
<h2 id='mesh_roots'>Multi Dimensional Multiple Roots (Zero) Finding, sampled by a mesh</h2><span id='topic+mesh_roots'></span>

<h3>Description</h3>

<p>Multi Dimensional Multiple Roots (Zero) Finding, sampled by a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh_roots(
  f,
  vectorized = FALSE,
  intervals,
  mesh = "seq",
  mesh.sizes = 11,
  maxerror_f = 1e-07,
  tol = .Machine$double.eps^0.25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh_roots_+3A_f">f</code></td>
<td>
<p>Function (one or more dimensions) to find roots of</p>
</td></tr>
<tr><td><code id="mesh_roots_+3A_vectorized">vectorized</code></td>
<td>
<p>is f already vectorized ? (default: no)</p>
</td></tr>
<tr><td><code id="mesh_roots_+3A_intervals">intervals</code></td>
<td>
<p>bounds to inverse in, each column contains min and max of each dimension</p>
</td></tr>
<tr><td><code id="mesh_roots_+3A_mesh">mesh</code></td>
<td>
<p>function or &quot;unif&quot; or &quot;seq&quot; (default) to preform interval partition</p>
</td></tr>
<tr><td><code id="mesh_roots_+3A_mesh.sizes">mesh.sizes</code></td>
<td>
<p>number of parts for mesh (duplicate for each dimension if using &quot;seq&quot;)</p>
</td></tr>
<tr><td><code id="mesh_roots_+3A_maxerror_f">maxerror_f</code></td>
<td>
<p>the maximum error on f evaluation (iterates over uniroot to converge).</p>
</td></tr>
<tr><td><code id="mesh_roots_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance on f arg).</p>
</td></tr>
<tr><td><code id="mesh_roots_+3A_...">...</code></td>
<td>
<p>Other args for f</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of x, so f(x)=0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mesh_roots(function(x) x-.51, intervals=rbind(0,1))
mesh_roots(function(x) sum(x)-.51, intervals=cbind(rbind(0,1),rbind(0,1)))
mesh_roots(sin,intervals=c(pi/2,5*pi/2))
mesh_roots(f = function(x) sin(pi*x[1])*sin(pi*x[2]),
           intervals = matrix(c(1/2,5/2,1/2,5/2),nrow=2))

r = mesh_roots(function(x) (0.25+x[1])^2+(0.5+x[2])^2-.25,
               intervals=matrix(c(-1,1,-1,1),nrow=2))
plot(r,xlim=c(-1,1),ylim=c(-1,1))

r = mesh_roots(function(x) (0.5+x[1])^2+(-0.5+x[2])^2+(0.+x[3])^2- .25,
               mesh.sizes = 11,
               intervals=matrix(c(-1,1,-1,1,-1,1),nrow=2))
scatterplot3d::scatterplot3d(r,xlim=c(-1,1),ylim=c(-1,1),zlim=c(-1,1))

mesh_roots(function(x)exp(x)-1,intervals=c(-1,2))
mesh_roots(function(x)exp(1000*x)-1,intervals=c(-1,2))
</code></pre>

<hr>
<h2 id='min_dist'>Minimal distance between one point to many points</h2><span id='topic+min_dist'></span>

<h3>Description</h3>

<p>Minimal distance between one point to many points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_dist(x, X, norm = rep(1, ncol(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_dist_+3A_x">x</code></td>
<td>
<p>one point</p>
</td></tr>
<tr><td><code id="min_dist_+3A_x">X</code></td>
<td>
<p>matrix of points (same number of columns than x)</p>
</td></tr>
<tr><td><code id="min_dist_+3A_norm">norm</code></td>
<td>
<p>normalization vecor of distance (same number of columns than x)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>minimal distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>min_dist(runif(3),matrix(runif(30),ncol=3))
</code></pre>

<hr>
<h2 id='optims'>Title Multi-local optimization wrapper for optim, using (possibly parallel) multistart.</h2><span id='topic+optims'></span>

<h3>Description</h3>

<p>Title Multi-local optimization wrapper for optim, using (possibly parallel) multistart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optims(
  pars,
  fn,
  fn.NaN = NaN,
  .apply = "mclapply",
  pars.eps = 1e-05,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optims_+3A_pars">pars</code></td>
<td>
<p>starting points for optim</p>
</td></tr>
<tr><td><code id="optims_+3A_fn">fn</code></td>
<td>
<p>objective function, like in optim().</p>
</td></tr>
<tr><td><code id="optims_+3A_fn.nan">fn.NaN</code></td>
<td>
<p>replacement value of fn when returns NaN</p>
</td></tr>
<tr><td><code id="optims_+3A_.apply">.apply</code></td>
<td>
<p>loop/parallelization backend for multistart (&quot;mclapply&quot;, &quot;lapply&quot; or &quot;foreach&quot;)</p>
</td></tr>
<tr><td><code id="optims_+3A_pars.eps">pars.eps</code></td>
<td>
<p>minimal distance between two solutions to be considered different</p>
</td></tr>
<tr><td><code id="optims_+3A_control">control</code></td>
<td>
<p>control parameters for optim()</p>
</td></tr>
<tr><td><code id="optims_+3A_...">...</code></td>
<td>
<p>additional arguments passed to optim()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with best solution and all solutions
</p>


<h3>Author(s)</h3>

<p>Yann Richet, IRSN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn = function(x) ifelse(x==0,1,sin(x)/x)
# plot(fn, xlim=c(-20,20))
optim( par=5,                     fn,lower=-20,upper=20,method='L-BFGS-B')
optims(pars=t(t(seq(-20,20,,20))),fn,lower=-20,upper=20,method='L-BFGS-B')

# Branin function (3 local minimas)
f = function (x) {
  x1 &lt;- x[1] * 15 - 5
  x2 &lt;- x[2] * 15
  (x2 - 5/(4 * pi^2) * (x1^2) + 5/pi * x1 - 6)^2 + 10 * (1 - 1/(8 * pi)) * cos(x1) + 10
}
# expect to find 3 local minimas
optims(pars=matrix(runif(100),ncol=2),f,method="L-BFGS-B",lower=c(0,0),upper=c(1,1))
</code></pre>

<hr>
<h2 id='plot_mesh'>Plot a one dimensional mesh</h2><span id='topic+plot_mesh'></span>

<h3>Description</h3>

<p>Plot a one dimensional mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mesh(mesh, y = 0, color = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mesh_+3A_mesh">mesh</code></td>
<td>
<p>1-dimensional mesh to draw</p>
</td></tr>
<tr><td><code id="plot_mesh_+3A_y">y</code></td>
<td>
<p>ordinate value where to draw the mesh</p>
</td></tr>
<tr><td><code id="plot_mesh_+3A_color">color</code></td>
<td>
<p>color of the mesh</p>
</td></tr>
<tr><td><code id="plot_mesh_+3A_...">...</code></td>
<td>
<p>optional arguments passed to plot function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot_mesh(mesh_exsets(function(x) x, threshold=.51, sign=1, intervals=rbind(0,1)))
plot_mesh(mesh_exsets(function(x) (x-.5)^2, threshold=.1, sign=-1, intervals=rbind(0,1)))
</code></pre>

<hr>
<h2 id='plot2d_mesh'>Plot a two dimensional mesh</h2><span id='topic+plot2d_mesh'></span>

<h3>Description</h3>

<p>Plot a two dimensional mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2d_mesh(mesh, color = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot2d_mesh_+3A_mesh">mesh</code></td>
<td>
<p>2-dimensional mesh to draw</p>
</td></tr>
<tr><td><code id="plot2d_mesh_+3A_color">color</code></td>
<td>
<p>color of the mesh</p>
</td></tr>
<tr><td><code id="plot2d_mesh_+3A_...">...</code></td>
<td>
<p>optional arguments passed to plot function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot2d_mesh(mesh_exsets(f = function(x) sin(pi*x[1])*sin(pi*x[2]),
                        threshold=0,sign=1, mesh="unif",mesh.size=11,
                        intervals = matrix(c(1/2,5/2,1/2,5/2),nrow=2)))
</code></pre>

<hr>
<h2 id='plot3d_mesh'>Plot a three dimensional mesh</h2><span id='topic+plot3d_mesh'></span>

<h3>Description</h3>

<p>Plot a three dimensional mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d_mesh(mesh, engine3d = NULL, color = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d_mesh_+3A_mesh">mesh</code></td>
<td>
<p>3-dimensional mesh to draw</p>
</td></tr>
<tr><td><code id="plot3d_mesh_+3A_engine3d">engine3d</code></td>
<td>
<p>3d framework to use: 'rgl' if installed or 'scatterplot3d' (default)</p>
</td></tr>
<tr><td><code id="plot3d_mesh_+3A_color">color</code></td>
<td>
<p>color of the mesh</p>
</td></tr>
<tr><td><code id="plot3d_mesh_+3A_...">...</code></td>
<td>
<p>optional arguments passed to plot function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("NOT_CRAN"), "true")) { # too long for CRAN on Windows

  plot3d_mesh(mesh_exsets(function(x) (0.5+x[1])^2+(-0.5+x[2])^2+(0.+x[3])^2,
                          threshold = .25,sign=-1, mesh="unif",
                          maxerror_f=1E-2,tol=1E-2, # faster display
                          intervals=matrix(c(-1,1,-1,1,-1,1),nrow=2)),
                          engine3d='scatterplot3d')

  if (requireNamespace("rgl")) {
    plot3d_mesh(mesh_exsets(function(x) (0.5+x[1])^2+(-0.5+x[2])^2+(0.+x[3])^2,
                            threshold = .25,sign=-1, mesh="unif",
                            maxerror_f=1E-2,tol=1E-2, # faster display
                            intervals=matrix(c(-1,1,-1,1,-1,1),nrow=2)),engine3d='rgl')
  }
}
</code></pre>

<hr>
<h2 id='points_in.mesh'>Extract points of mesh which belong to the mesh triangulation (may not contain all points)</h2><span id='topic+points_in.mesh'></span>

<h3>Description</h3>

<p>Extract points of mesh which belong to the mesh triangulation (may not contain all points)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points_in.mesh(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points_in.mesh_+3A_mesh">mesh</code></td>
<td>
<p>mesh (list(p,tri,...) from geometry)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>points coordinates inside the mesh triangulation
</p>

<hr>
<h2 id='points_out.mesh'>Extract points of mesh which do not belong to the mesh triangulation (may not contain all points)</h2><span id='topic+points_out.mesh'></span>

<h3>Description</h3>

<p>Extract points of mesh which do not belong to the mesh triangulation (may not contain all points)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points_out.mesh(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points_out.mesh_+3A_mesh">mesh</code></td>
<td>
<p>(list(p,tri,...) from geometry)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>points coordinates outside the mesh triangulation
</p>

<hr>
<h2 id='root'>One Dimensional Root (Zero) Finding</h2><span id='topic+root'></span>

<h3>Description</h3>

<p>Search one root with given precision (on y). Iterate over uniroot as long as necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root(
  f,
  lower,
  upper,
  maxerror_f = 1e-07,
  f_lower = f(lower, ...),
  f_upper = f(upper, ...),
  tol = .Machine$double.eps^0.25,
  convexity = FALSE,
  rec = 0,
  max.rec = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root_+3A_f">f</code></td>
<td>
<p>the function for which the root is sought.</p>
</td></tr>
<tr><td><code id="root_+3A_lower">lower</code></td>
<td>
<p>the lower end point of the interval to be searched.</p>
</td></tr>
<tr><td><code id="root_+3A_upper">upper</code></td>
<td>
<p>the upper end point of the interval to be searched.</p>
</td></tr>
<tr><td><code id="root_+3A_maxerror_f">maxerror_f</code></td>
<td>
<p>the maximum error on f evaluation (iterates over uniroot to converge).</p>
</td></tr>
<tr><td><code id="root_+3A_f_lower">f_lower</code></td>
<td>
<p>the same as f(lower).</p>
</td></tr>
<tr><td><code id="root_+3A_f_upper">f_upper</code></td>
<td>
<p>the same as f(upper).</p>
</td></tr>
<tr><td><code id="root_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance on f arg).</p>
</td></tr>
<tr><td><code id="root_+3A_convexity">convexity</code></td>
<td>
<p>the learned convexity factor of the function, used to reduce the boundaries for uniroot.</p>
</td></tr>
<tr><td><code id="root_+3A_rec">rec</code></td>
<td>
<p>counter of recursive level.</p>
</td></tr>
<tr><td><code id="root_+3A_max.rec">max.rec</code></td>
<td>
<p>maximal number of recursive level before failure (stop).</p>
</td></tr>
<tr><td><code id="root_+3A_...">...</code></td>
<td>
<p>additional named or unnamed arguments to be passed to f.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yann Richet, IRSN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f=function(x) {cat("f");1-exp(x)}; f(root(f,lower=-1,upper=2))
f=function(x) {cat("f");exp(x)-1}; f(root(f,lower=-1,upper=2))

.f = function(x) 1-exp(1*x)
f=function(x) {cat("f");y=.f(x);points(x,y,pch=20,col=rgb(0,0,0,.2));y}
plot(.f,xlim=c(-1,2)); f(root(f,lower=-1,upper=2))

.f = function(x) exp(10*x)-1
f=function(x) {cat("f");y=.f(x);points(x,y,pch=20);y}
plot(.f,xlim=c(-1,2)); f(root(f,lower=-1,upper=2))

.f = function(x) exp(100*x)-1
f=function(x) {cat("f");y=.f(x);points(x,y,pch=20);y}
plot(.f,xlim=c(-1,2)); f(root(f,lower=-1,upper=2))

f=function(x) {cat("f");exp(100*x)-1}; f(root(f,lower=-1,upper=2))

## Not run: 

  # Quite hard functions to find roots

  ## Increasing function
  ## convex
  n.f=0
  .f = function(x) exp(10*x)-1
  f=function(x) {n.f&lt;&lt;-n.f+1;y=.f(x);points(x,y,pch=20);y}
  plot(.f,xlim=c(-.1,.2)); f(root(f,lower=-1,upper=2))
  print(n.f)
  ## non-convex
  n.f=0
  .f = function(x) 1-exp(-10*x)
  f=function(x) {n.f&lt;&lt;-n.f+1;y=.f(x);points(x,y,pch=20);y}
  plot(.f,xlim=c(-.1,.2)); f(root(f,lower=-1,upper=2))
  print(n.f)

  # ## Decreasing function
  # ## non-convex
  n.f=0
  .f = function(x) 1-exp(10*x)
  f=function(x) {n.f&lt;&lt;-n.f+1;y=.f(x);points(x,y,pch=20,col=rgb(0,0,0,.2));y}
  plot(.f,xlim=c(-.1,.2)); f(root(f,lower=-1,upper=2))
  print(n.f)
  # ## convex
  n.f=0
  .f = function(x) exp(-10*x)-1
  f=function(x) {n.f&lt;&lt;-n.f+1;y=.f(x);points(x,y,pch=20,col=rgb(0,0,0,.2));y}
  plot(.f,xlim=c(-.1,.2)); f(root(f,lower=-1,upper=2))
  print(n.f)

## End(Not run)
</code></pre>

<hr>
<h2 id='roots'>One Dimensional Multiple Roots (Zero) Finding</h2><span id='topic+roots'></span>

<h3>Description</h3>

<p>Search multiple roots of 1D function, sampled/splitted by a (1D) mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roots(
  f,
  vectorized = FALSE,
  interval,
  maxerror_f = 1e-07,
  split = "seq",
  split.size = 11,
  tol = .Machine$double.eps^0.25,
  .lapply = parallel::mclapply,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roots_+3A_f">f</code></td>
<td>
<p>Function to find roots</p>
</td></tr>
<tr><td><code id="roots_+3A_vectorized">vectorized</code></td>
<td>
<p>boolean: is f already vectorized ? (default: FALSE) or if function: vectorized version of f.</p>
</td></tr>
<tr><td><code id="roots_+3A_interval">interval</code></td>
<td>
<p>bounds to inverse in</p>
</td></tr>
<tr><td><code id="roots_+3A_maxerror_f">maxerror_f</code></td>
<td>
<p>the maximum error on f evaluation (iterates over uniroot to converge).</p>
</td></tr>
<tr><td><code id="roots_+3A_split">split</code></td>
<td>
<p>function or &quot;unif&quot; or &quot;seq&quot; (default) to preform interval partition</p>
</td></tr>
<tr><td><code id="roots_+3A_split.size">split.size</code></td>
<td>
<p>number of parts to perform uniroot inside</p>
</td></tr>
<tr><td><code id="roots_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance on f arg).</p>
</td></tr>
<tr><td><code id="roots_+3A_.lapply">.lapply</code></td>
<td>
<p>control the loop/vectorization over different roots (defaults to multicore apply).</p>
</td></tr>
<tr><td><code id="roots_+3A_...">...</code></td>
<td>
<p>additional named or unnamed arguments to be passed to f.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of x, so f(x)=target
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roots(sin,interval=c(pi/2,5*pi/2))
roots(sin,interval=c(pi/2,1.5*pi/2))

f=function(x)exp(x)-1;
f(roots(f,interval=c(-1,2)))

f=function(x)exp(1000*x)-1;
f(roots(f,interval=c(-1,2)))
</code></pre>

<hr>
<h2 id='sectionview.function'>Plot a section view of a prediction model or function, including design points if available.</h2><span id='topic+sectionview.function'></span><span id='topic+sectionview+2Cfunction+2Cfunction-method'></span><span id='topic+sectionview.matrix'></span><span id='topic+sectionview+2Cmatrix+2Cmatrix-method'></span><span id='topic+sectionview.km'></span><span id='topic+sectionview+2Ckm+2Ckm-method'></span><span id='topic+sectionview.Kriging'></span><span id='topic+sectionview+2CKriging+2CKriging-method'></span><span id='topic+sectionview.NuggetKriging'></span><span id='topic+sectionview+2CNuggetKriging+2CNuggetKriging-method'></span><span id='topic+sectionview.NoiseKriging'></span><span id='topic+sectionview+2CNoiseKriging+2CNoiseKriging-method'></span><span id='topic+sectionview.glm'></span><span id='topic+sectionview+2Cglm+2Cglm-method'></span><span id='topic+sectionview.list'></span><span id='topic+sectionview+2Clist+2Clist-method'></span><span id='topic+sectionview'></span>

<h3>Description</h3>

<p>Plot a section view of a prediction model or function, including design points if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
sectionview(
  fun,
  vectorized = FALSE,
  dim = NULL,
  center = NULL,
  axis = NULL,
  npoints = 100,
  col_surf = "blue",
  conf_lev = c(0.5, 0.8, 0.9, 0.95, 0.99),
  conf_blend = NULL,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'matrix'
sectionview(
  X,
  y,
  sdy = NULL,
  center = NULL,
  axis = NULL,
  npoints = 100,
  col_points = "red",
  conf_lev = c(0.5, 0.8, 0.9, 0.95, 0.99),
  conf_blend = NULL,
  bg_blend = 5,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'km'
sectionview(
  km_model,
  type = "UK",
  center = NULL,
  axis = NULL,
  npoints = 100,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.5, 0.8, 0.9, 0.95, 0.99),
  conf_blend = NULL,
  bg_blend = 5,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'Kriging'
sectionview(
  Kriging_model,
  center = NULL,
  axis = NULL,
  npoints = 100,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.5, 0.8, 0.9, 0.95, 0.99),
  conf_blend = NULL,
  bg_blend = 5,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'NuggetKriging'
sectionview(
  NuggetKriging_model,
  center = NULL,
  axis = NULL,
  npoints = 100,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.5, 0.8, 0.9, 0.95, 0.99),
  conf_blend = NULL,
  bg_blend = 5,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'NoiseKriging'
sectionview(
  NoiseKriging_model,
  center = NULL,
  axis = NULL,
  npoints = 100,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.5, 0.8, 0.9, 0.95, 0.99),
  conf_blend = NULL,
  bg_blend = 5,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'glm'
sectionview(
  glm_model,
  center = NULL,
  axis = NULL,
  npoints = 100,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.5, 0.8, 0.9, 0.95, 0.99),
  conf_blend = NULL,
  bg_blend = 5,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

## S3 method for class 'list'
sectionview(
  modelFit_model,
  center = NULL,
  axis = NULL,
  npoints = 100,
  col_points = "red",
  col_surf = "blue",
  bg_blend = 5,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  ...
)

sectionview(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sectionview.function_+3A_fun">fun</code></td>
<td>
<p>a function or 'predict()'-like function that returns a simple numeric or mean and standard error: list(mean=...,se=...).</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_vectorized">vectorized</code></td>
<td>
<p>is fun vectorized?</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_dim">dim</code></td>
<td>
<p>input variables dimension of the model or function.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_center">center</code></td>
<td>
<p>optional coordinates (as a list or data frame) of the center of the section view if the model's dimension is &gt; 2.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_axis">axis</code></td>
<td>
<p>optional matrix of 2-axis combinations to plot, one by row. The value <code>NULL</code> leads to all possible combinations i.e. <code>choose(D, 2)</code>.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_npoints">npoints</code></td>
<td>
<p>an optional number of points to discretize plot of response  surface and uncertainties.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_col_surf">col_surf</code></td>
<td>
<p>color for the surface.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_conf_lev">conf_lev</code></td>
<td>
<p>an optional list of confidence interval values to display.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_conf_blend">conf_blend</code></td>
<td>
<p>an optional factor of alpha (color channel) blending used to plot confidence intervals.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_mfrow">mfrow</code></td>
<td>
<p>an optional list to force <code>par(mfrow = ...)</code> call. The default value  <code>NULL</code> is automatically set for compact view.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_xlab">Xlab</code></td>
<td>
<p>an optional list of string to overload names for X.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_ylab">ylab</code></td>
<td>
<p>an optional string to overload name for y.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_xlim">Xlim</code></td>
<td>
<p>an optional list to force x range for all plots. The default value <code>NULL</code> is automatically set to include all design points.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_ylim">ylim</code></td>
<td>
<p>an optional list to force y range for all plots.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_title">title</code></td>
<td>
<p>an optional overload of main title.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_add">add</code></td>
<td>
<p>to print graphics on an existing window.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_...">...</code></td>
<td>
<p>arguments of the <code>sectionview.km</code>, <code>sectionview.glm</code>, <code>sectionview.Kriging</code> or <code>sectionview.function</code> function</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_x">X</code></td>
<td>
<p>the matrix of input design.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_y">y</code></td>
<td>
<p>the array of output values.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_sdy">sdy</code></td>
<td>
<p>optional array of output standard error.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_col_points">col_points</code></td>
<td>
<p>color of points.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_bg_blend">bg_blend</code></td>
<td>
<p>an optional factor of alpha (color channel) blending used to plot design points outside from this section.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_km_model">km_model</code></td>
<td>
<p>an object of class <code>"km"</code>.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_type">type</code></td>
<td>
<p>the kriging type to use for model prediction.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_kriging_model">Kriging_model</code></td>
<td>
<p>an object of class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_nuggetkriging_model">NuggetKriging_model</code></td>
<td>
<p>an object of class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_noisekriging_model">NoiseKriging_model</code></td>
<td>
<p>an object of class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_glm_model">glm_model</code></td>
<td>
<p>an object of class <code>"glm"</code>.</p>
</td></tr>
<tr><td><code id="sectionview.function_+3A_modelfit_model">modelFit_model</code></td>
<td>
<p>an object returned by DiceEval::modelFit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If available, experimental points are plotted with fading colors. Points that fall in the specified section (if any) have the color specified <code>col_points</code> while points far away from the center have shaded versions of the same color. The amount of fading is determined using the Euclidean distance between the plotted point and <code>center</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet, IRSN
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sectionview.function">sectionview.function</a></code> for a section plot, and <code><a href="#topic+sectionview3d.function">sectionview3d.function</a></code> for a 2D section plot.
<code><a href="#topic+Vectorize.function">Vectorize.function</a></code> to wrap as vectorized a non-vectorized function.
</p>
<p><code><a href="#topic+sectionview.matrix">sectionview.matrix</a></code> for a section plot, and <code><a href="#topic+sectionview3d.matrix">sectionview3d.matrix</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.km">sectionview.km</a></code> for a section plot, and <code><a href="#topic+sectionview3d.km">sectionview3d.km</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.Kriging">sectionview.Kriging</a></code> for a section plot, and <code><a href="#topic+sectionview3d.Kriging">sectionview3d.Kriging</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.NuggetKriging">sectionview.NuggetKriging</a></code> for a section plot, and <code><a href="#topic+sectionview3d.NuggetKriging">sectionview3d.NuggetKriging</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.NoiseKriging">sectionview.NoiseKriging</a></code> for a section plot, and <code><a href="#topic+sectionview3d.NoiseKriging">sectionview3d.NoiseKriging</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.glm">sectionview.glm</a></code> for a section plot, and <code><a href="#topic+sectionview3d.glm">sectionview3d.glm</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.glm">sectionview.glm</a></code> for a section plot, and <code><a href="#topic+sectionview3d.glm">sectionview3d.glm</a></code> for a 2D section plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rnorm(15)
x2 &lt;- rnorm(15)

y &lt;- x1 + x2 + rnorm(15)

model &lt;- lm(y ~ x1 + x2)

sectionview(function(x) sum(x),
                     dim=2, center=c(0,0), Xlim=cbind(range(x1),range(x2)), col='black')

sectionview(function(x) {
                      x = as.data.frame(x)
                      colnames(x) &lt;- names(model$coefficients[-1])
                      p = predict.lm(model, newdata=x, se.fit=TRUE)
                      list(mean=p$fit, se=p$se.fit)
                    }, vectorized=TRUE,
                    dim=2, center=c(0,0), Xlim=cbind(range(x1),range(x2)), add=TRUE)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

sectionview(X,y, center=c(.5,.5))

if (requireNamespace("DiceKriging")) { library(DiceKriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

model &lt;- km(design = X, response = y, covtype="matern3_2")

sectionview(model, center=c(.5,.5))

}

if (requireNamespace("rlibkriging")) { library(rlibkriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

model &lt;- Kriging(X = X, y = y, kernel="matern3_2")

sectionview(model, center=c(.5,.5))

}

if (requireNamespace("rlibkriging")) { library(rlibkriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin) + 5*rnorm(15)

model &lt;- NuggetKriging(X = X, y = y, kernel="matern3_2")

sectionview(model, center=c(.5,.5))

}

if (requireNamespace("rlibkriging")) { library(rlibkriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin) + 5*rnorm(15)

model &lt;- NoiseKriging(X = X, y = y, kernel="matern3_2", noise=rep(5^2,15))

sectionview(model, center=c(.5,.5))

}

x1 &lt;- rnorm(15)
x2 &lt;- rnorm(15)

y &lt;- x1 + x2^2 + rnorm(15)
model &lt;- glm(y ~ x1 + I(x2^2))

sectionview(model, center=c(.5,.5))

if (requireNamespace("DiceEval")) { library(DiceEval)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

model &lt;- modelFit(X, y, type = "StepLinear")

sectionview(model, center=c(.5,.5))

}

## A 2D example - Branin-Hoo function
sectionview(branin, center= c(.5,.5), col='black')

## Not run: 
## a 16-points factorial design, and the corresponding response
d &lt;- 2; n &lt;- 16
design.fact &lt;- expand.grid(seq(0, 1, length = 4), seq(0, 1, length = 4))
design.fact &lt;- data.frame(design.fact); names(design.fact) &lt;- c("x1", "x2")
y &lt;- branin(design.fact); names(y) &lt;- "y"

if (requireNamespace("DiceKriging")) { library(DiceKriging)
## model: km
model &lt;- DiceKriging::km(design = design.fact, response = y)
sectionview(model, center= c(.5,.5))
sectionview(branin, center= c(.5,.5), col='red', add=TRUE)
}

if (requireNamespace("rlibkriging")) { library(rlibkriging)
## model: Kriging
model &lt;- Kriging(X = as.matrix(design.fact), y = as.matrix(y), kernel="matern3_2")
sectionview(model, center= c(.5,.5))
sectionview(branin, center= c(.5,.5), col='red', add=TRUE)
}

## model: glm
model &lt;- glm(y ~ 1+ x1 + x2 + I(x1^2) + I(x2^2) + x1*x2, data=cbind(y,design.fact))
sectionview(model, center= c(.5,.5))
sectionview(branin, center= c(.5,.5), col='red', add=TRUE)

if (requireNamespace("DiceEval")) { library(DiceEval)
## model: StepLinear
model &lt;- modelFit(design.fact, y, type = "StepLinear")
sectionview(model, center= c(.5,.5))
sectionview(branin, center= c(.5,.5), col='red', add=TRUE)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='sectionview3d.function'>Plot a contour view of a prediction model or function, including design points if available.</h2><span id='topic+sectionview3d.function'></span><span id='topic+sectionview3d+2Cfunction+2Cfunction-method'></span><span id='topic+sectionview3d.matrix'></span><span id='topic+sectionview3d+2Cmatrix+2Cmatrix-method'></span><span id='topic+sectionview3d.km'></span><span id='topic+sectionview3d+2Ckm+2Ckm-method'></span><span id='topic+sectionview3d.Kriging'></span><span id='topic+sectionview3d+2CKriging+2CKriging-method'></span><span id='topic+sectionview3d.NuggetKriging'></span><span id='topic+sectionview3d+2CNuggetKriging+2CNuggetKriging-method'></span><span id='topic+sectionview3d.NoiseKriging'></span><span id='topic+sectionview3d+2CNoiseKriging+2CNoiseKriging-method'></span><span id='topic+sectionview3d.glm'></span><span id='topic+sectionview3d+2Cglm+2Cglm-method'></span><span id='topic+sectionview3d.list'></span><span id='topic+sectionview3d+2Clist+2Clist-method'></span><span id='topic+sectionview3d'></span>

<h3>Description</h3>

<p>Plot a contour view of a prediction model or function, including design points if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
sectionview3d(
  fun,
  vectorized = FALSE,
  dim = NULL,
  center = NULL,
  axis = NULL,
  npoints = 20,
  col_surf = "blue",
  conf_lev = c(0.95),
  conf_blend = NULL,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  engine3d = NULL,
  ...
)

## S3 method for class 'matrix'
sectionview3d(
  X,
  y,
  sdy = NULL,
  center = NULL,
  axis = NULL,
  col_points = "red",
  conf_lev = c(0.95),
  conf_blend = NULL,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  engine3d = NULL,
  ...
)

## S3 method for class 'km'
sectionview3d(
  km_model,
  type = "UK",
  center = NULL,
  axis = NULL,
  npoints = 20,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.95),
  conf_blend = NULL,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  engine3d = NULL,
  ...
)

## S3 method for class 'Kriging'
sectionview3d(
  Kriging_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.95),
  conf_blend = NULL,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  engine3d = NULL,
  ...
)

## S3 method for class 'NuggetKriging'
sectionview3d(
  NuggetKriging_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.95),
  conf_blend = NULL,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  engine3d = NULL,
  ...
)

## S3 method for class 'NoiseKriging'
sectionview3d(
  NoiseKriging_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.95),
  conf_blend = NULL,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  engine3d = NULL,
  ...
)

## S3 method for class 'glm'
sectionview3d(
  glm_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  col_points = "red",
  col_surf = "blue",
  conf_lev = c(0.95),
  conf_blend = NULL,
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  engine3d = NULL,
  ...
)

## S3 method for class 'list'
sectionview3d(
  modelFit_model,
  center = NULL,
  axis = NULL,
  npoints = 20,
  col_points = "red",
  col_surf = "blue",
  bg_blend = 1,
  mfrow = NULL,
  Xlab = NULL,
  ylab = NULL,
  Xlim = NULL,
  ylim = NULL,
  title = NULL,
  add = FALSE,
  engine3d = NULL,
  ...
)

sectionview3d(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sectionview3d.function_+3A_fun">fun</code></td>
<td>
<p>a function or 'predict()'-like function that returns a simple numeric or mean and standard error: list(mean=...,se=...).</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_vectorized">vectorized</code></td>
<td>
<p>is fun vectorized?</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_dim">dim</code></td>
<td>
<p>input variables dimension of the model or function.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_center">center</code></td>
<td>
<p>optional coordinates (as a list or data frame) of the center of the section view if the model's dimension is &gt; 2.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_axis">axis</code></td>
<td>
<p>optional matrix of 2-axis combinations to plot, one by row. The value <code>NULL</code> leads to all possible combinations i.e. <code>choose(D, 2)</code>.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_npoints">npoints</code></td>
<td>
<p>an optional number of points to discretize plot of response  surface and uncertainties.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_col_surf">col_surf</code></td>
<td>
<p>color for the surface.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_conf_lev">conf_lev</code></td>
<td>
<p>an optional list of confidence interval values to display.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_conf_blend">conf_blend</code></td>
<td>
<p>an optional factor of alpha (color channel) blending used to plot confidence intervals.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_mfrow">mfrow</code></td>
<td>
<p>an optional list to force <code>par(mfrow = ...)</code> call. The default value  <code>NULL</code> is automatically set for compact view.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_xlab">Xlab</code></td>
<td>
<p>an optional list of string to overload names for X.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_ylab">ylab</code></td>
<td>
<p>an optional string to overload name for y.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_xlim">Xlim</code></td>
<td>
<p>an optional list to force x range for all plots. The default value <code>NULL</code> is automatically set to include all design points (and their 1-99 percentiles).</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_ylim">ylim</code></td>
<td>
<p>an optional list to force y range for all plots. The default value <code>NULL</code> is automatically set to include all design points (and their 1-99 percentiles).</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_title">title</code></td>
<td>
<p>an optional overload of main title.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_add">add</code></td>
<td>
<p>to print graphics on an existing window.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_engine3d">engine3d</code></td>
<td>
<p>3D view package to use. &quot;rgl&quot; if available, otherwise &quot;scatterplot3d&quot; by default.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_...">...</code></td>
<td>
<p>arguments of the <code>sectionview3d.km</code>, <code>sectionview3d.glm</code>, <code>sectionview3d.Kriging</code> or <code>sectionview3d.function</code> function</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_x">X</code></td>
<td>
<p>the matrix of input design.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_y">y</code></td>
<td>
<p>the array of output values.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_sdy">sdy</code></td>
<td>
<p>optional array of output standard error.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_col_points">col_points</code></td>
<td>
<p>color of points.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_bg_blend">bg_blend</code></td>
<td>
<p>an optional factor of alpha (color channel) blending used to plot design points outside from this section.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_km_model">km_model</code></td>
<td>
<p>an object of class <code>"km"</code>.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_type">type</code></td>
<td>
<p>the kriging type to use for model prediction.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_kriging_model">Kriging_model</code></td>
<td>
<p>an object of class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_nuggetkriging_model">NuggetKriging_model</code></td>
<td>
<p>an object of class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_noisekriging_model">NoiseKriging_model</code></td>
<td>
<p>an object of class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_glm_model">glm_model</code></td>
<td>
<p>an object of class <code>"glm"</code>.</p>
</td></tr>
<tr><td><code id="sectionview3d.function_+3A_modelfit_model">modelFit_model</code></td>
<td>
<p>an object returned by DiceEval::modelFit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If available, experimental points are plotted with fading colors. Points that fall in the specified section (if any) have the color specified <code>col_points</code> while points far away from the center have shaded versions of the same color. The amount of fading is determined using the Euclidean distance between the plotted point and <code>center</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet, IRSN
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sectionview.function">sectionview.function</a></code> for a section plot, and <code><a href="#topic+sectionview3d.function">sectionview3d.function</a></code> for a 2D section plot.
<code><a href="#topic+Vectorize.function">Vectorize.function</a></code> to wrap as vectorized a non-vectorized function.
</p>
<p><code><a href="#topic+sectionview.matrix">sectionview.matrix</a></code> for a section plot, and <code><a href="#topic+sectionview3d.matrix">sectionview3d.matrix</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.km">sectionview.km</a></code> for a section plot, and <code><a href="#topic+sectionview3d.km">sectionview3d.km</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.Kriging">sectionview.Kriging</a></code> for a section plot, and <code><a href="#topic+sectionview3d.Kriging">sectionview3d.Kriging</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.NuggetKriging">sectionview.NuggetKriging</a></code> for a section plot, and <code><a href="#topic+sectionview3d.NuggetKriging">sectionview3d.NuggetKriging</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.NoiseKriging">sectionview.NoiseKriging</a></code> for a section plot, and <code><a href="#topic+sectionview3d.NoiseKriging">sectionview3d.NoiseKriging</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.glm">sectionview.glm</a></code> for a section plot, and <code><a href="#topic+sectionview3d.glm">sectionview3d.glm</a></code> for a 2D section plot.
</p>
<p><code><a href="#topic+sectionview.glm">sectionview.glm</a></code> for a section plot, and <code><a href="#topic+sectionview3d.glm">sectionview3d.glm</a></code> for a 2D section plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rnorm(15)
x2 &lt;- rnorm(15)

y &lt;- x1 + x2 + rnorm(15)
DiceView:::open3d(); DiceView:::plot3d(x1,x2,y)

model &lt;- lm(y ~ x1 + x2)

sectionview3d(function(x) sum(x),
                     dim=2, Xlim=cbind(range(x1),range(x2)), add=TRUE, col='black')

sectionview3d(function(x) {
                      x = as.data.frame(x)
                      colnames(x) &lt;- names(model$coefficients[-1])
                      p = predict.lm(model, newdata=x, se.fit=TRUE)
                      list(mean=p$fit, se=p$se.fit)
                    }, vectorized=TRUE, dim=2, Xlim=cbind(range(x1),range(x2)), add=TRUE)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

sectionview3d(X, y)

if (requireNamespace("DiceKriging")) { library(DiceKriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

model &lt;- km(design = X, response = y, covtype="matern3_2")

sectionview3d(model)

}

if (requireNamespace("rlibkriging")) { library(rlibkriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

model &lt;- Kriging(X = X, y = y, kernel="matern3_2")

sectionview3d(model)

}

if (requireNamespace("rlibkriging")) { library(rlibkriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin) + 5*rnorm(15)

model &lt;- NuggetKriging(X = X, y = y, kernel="matern3_2")

sectionview3d(model)

}

if (requireNamespace("rlibkriging")) { library(rlibkriging)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin) + 5*rnorm(15)

model &lt;- NoiseKriging(X = X, y = y, kernel="matern3_2", noise=rep(5^2,15))

sectionview3d(model)

}

x1 &lt;- rnorm(15)
x2 &lt;- rnorm(15)

y &lt;- x1 + x2^2 + rnorm(15)
model &lt;- glm(y ~ x1 + I(x2^2))

sectionview3d(model)

if (requireNamespace("DiceEval")) { library(DiceEval)

X = matrix(runif(15*2),ncol=2)
y = apply(X,1,branin)

model &lt;- modelFit(X, y, type = "StepLinear")

sectionview3d(model)

}

## A 2D example - Branin-Hoo function
sectionview3d(branin, dim=2, col='black')

## Not run: 
## a 16-points factorial design, and the corresponding response
d &lt;- 2; n &lt;- 16
design.fact &lt;- expand.grid(seq(0, 1, length = 4), seq(0, 1, length = 4))
design.fact &lt;- data.frame(design.fact); names(design.fact) &lt;- c("x1", "x2")
y &lt;- branin(design.fact); names(y) &lt;- "y"

if (requireNamespace("DiceKriging")) { library(DiceKriging)
## model: km
model &lt;- DiceKriging::km(design = design.fact, response = y)
sectionview3d(model)
sectionview3d(branin, dim=2, col='red', add=TRUE)
}

if (requireNamespace("rlibkriging")) { library(rlibkriging)
## model: Kriging
model &lt;- rlibkriging::Kriging(X = as.matrix(design.fact), y = as.matrix(y), kernel="matern3_2")
sectionview3d(model)
sectionview3d(branin, dim=2, col='red', add=TRUE)
}

## model: glm
model &lt;- glm(y ~ 1+ x1 + x2 + I(x1^2) + I(x2^2) + x1*x2, data=cbind(y,design.fact))
sectionview3d(model)
sectionview3d(branin, dim=2, col='red', add=TRUE)

if (requireNamespace("DiceEval")) { library(DiceEval)
## model: StepLinear
model &lt;- modelFit(design.fact, y, type = "StepLinear")
sectionview3d(model)
sectionview3d(branin, dim=2, col='red', add=TRUE)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='Vectorize.function'>Vectorize a multidimensional Function</h2><span id='topic+Vectorize.function'></span>

<h3>Description</h3>

<p>Vectorize a d-dimensional (input) function, in the same way that base::Vectorize for 1-dimensional functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vectorize.function(fun, dim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Vectorize.function_+3A_fun">fun</code></td>
<td>
<p>'dim'-dimensional function to Vectorize</p>
</td></tr>
<tr><td><code id="Vectorize.function_+3A_dim">dim</code></td>
<td>
<p>dimension of input arguments of fun</p>
</td></tr>
<tr><td><code id="Vectorize.function_+3A_...">...</code></td>
<td>
<p>optional args to pass to 'Apply.function()', including .combine, .lapply, or optional args passed to 'fun'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vectorized function (to be called on matrix argument, on each row)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = function(x)x[1]+1; f(1:10); F = Vectorize.function(f,1);
F(1:10); #F = Vectorize(f); F(1:10);

f2 = function(x)x[1]+x[2]; f2(1:10); F2 = Vectorize.function(f2,2);
F2(cbind(1:10,11:20));
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
