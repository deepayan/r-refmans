<!DOCTYPE html><html lang="en"><head><title>Help for package CIEE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CIEE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrap_se'><p>Bootstrap standard error estimates</p></a></li>
<li><a href='#ciee'><p>CIEE: Causal inference based on estimating equations</p></a></li>
<li><a href='#est_funct_expr'><p>Estimating functions.</p></a></li>
<li><a href='#generate_data'><p>Data generation function</p></a></li>
<li><a href='#get_estimates'><p>CIEE parameter point estimates</p></a></li>
<li><a href='#naive_se'><p>Naive standard error estimates</p></a></li>
<li><a href='#sandwich_se'><p>Sandwich standard error estimates</p></a></li>
<li><a href='#score_and_hessian_matrix_functions'><p>Score and hessian matrix based on the estimating functions.</p></a></li>
<li><a href='#sem_appl'><p>Structural equation modeling approach</p></a></li>
<li><a href='#summary.ciee'><p>Summary function.</p></a></li>
<li><a href='#traditional_regression_functions'><p>Traditional regression approaches.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating and Testing Direct Effects in Directed Acyclic Graphs
using Estimating Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>In many studies across different disciplines, detailed measures of the variables of interest are available. If assumptions can be made regarding the direction of effects between the assessed variables, this has to be considered in the analysis. The functions in this package implement the novel approach CIEE (causal inference using estimating equations; Konigorski et al., 2018, &lt;<a href="https://doi.org/10.1002%2Fgepi.22107">doi:10.1002/gepi.22107</a>&gt;) for estimating and testing the direct effect of an exposure variable on a primary outcome, while adjusting for indirect effects of the exposure on the primary outcome through a secondary intermediate outcome and potential factors influencing the secondary outcome. The underlying directed acyclic graph (DAG) of this considered model is described in the vignette. CIEE can be applied to studies in many different fields, and it is implemented here for the analysis of a continuous primary outcome and a time-to-event primary outcome subject to censoring. CIEE uses estimating equations to obtain estimates of the direct effect and robust sandwich standard error estimates. Then, a large-sample Wald-type test statistic is computed for testing the absence of the direct effect. Additionally, standard multiple regression, regression of residuals, and the structural equation modeling approach are implemented for comparison. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lavaan, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-03-19 15:49:15 UTC; skonigor</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Konigorski [aut, cre],
  Yildiz E. Yilmaz [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Konigorski &lt;stefan.konigorski@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-03-19 16:00:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootstrap_se'>Bootstrap standard error estimates</h2><span id='topic+bootstrap_se'></span>

<h3>Description</h3>

<p>Function to obtain bootstrap standard error estimates for the parameter
estimates of the <code><a href="#topic+get_estimates">get_estimates</a></code> function, under the generalized
linear model (GLM) or accelerated failure time (AFT) setting for the analysis
of a normally-distributed or censored time-to-event primary outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_se(setting = "GLM", BS_rep = 1000, Y = NULL, X = NULL,
  K = NULL, L = NULL, C = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_se_+3A_setting">setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating
whether standard error estimates are obtained for a
normally-distributed (<code>"GLM"</code>) or censored time-to-event
(<code>"AFT"</code>) primary outcome <code>Y</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_se_+3A_bs_rep">BS_rep</code></td>
<td>
<p>Integer indicating the number of bootstrap samples that are drawn.</p>
</td></tr>
<tr><td><code id="bootstrap_se_+3A_y">Y</code></td>
<td>
<p>Numeric input vector for the primary outcome.</p>
</td></tr>
<tr><td><code id="bootstrap_se_+3A_x">X</code></td>
<td>
<p>Numeric input vector for the exposure variable.</p>
</td></tr>
<tr><td><code id="bootstrap_se_+3A_k">K</code></td>
<td>
<p>Numeric input vector for the intermediate outcome.</p>
</td></tr>
<tr><td><code id="bootstrap_se_+3A_l">L</code></td>
<td>
<p>Numeric input vector for the observed confounding factor.</p>
</td></tr>
<tr><td><code id="bootstrap_se_+3A_c">C</code></td>
<td>
<p>Numeric input vector for the censoring indicator under the AFT setting
(must be coded 0 = censored, 1 = uncensored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the GLM setting for the analysis of a normally-distributed primary
outcome Y, bootstrap standard error estimates are obtained for the estimates
of the parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1^2, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
in the models
</p>
<p style="text-align: center;"><code class="reqn">Y = \alpha_0 + \alpha_1 \cdot K + \alpha_2 \cdot X + \alpha_3 \cdot L + \epsilon_1, \epsilon_1 \sim N(0,\sigma_1^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = Y - \overline{Y} - \alpha_1 \cdot (K-\overline{K})</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = \alpha_0 + \alpha_{XY} \cdot X + \epsilon_2, \epsilon_2 \sim N(0,\sigma_2^2),</code>
</p>

<p>accounting for the additional variability from the 2-stage approach.
</p>
<p>Under the AFT setting for the analysis of a censored time-to-event primary
outcome, bootstrap standard error estimates are similarly obtained of the
parameter estimates of
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
</p>


<h3>Value</h3>

<p>Returns a vector with the bootstrap standard error estimates
of the parameter estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- generate_data(setting = "GLM", n = 100)

# For illustration use here only 100 bootstrap samples, recommended is using 1000
bootstrap_se(setting = "GLM", BS_rep = 100, Y = dat$Y, X = dat$X,
             K = dat$K, L = dat$L)

</code></pre>

<hr>
<h2 id='ciee'>CIEE: Causal inference based on estimating equations</h2><span id='topic+ciee'></span><span id='topic+ciee_loop'></span>

<h3>Description</h3>

<p>Functions to perform CIEE under the GLM or AFT setting:
<code><a href="#topic+ciee">ciee</a></code> obtains point and standard error estimates of all parameter estimates,
and p-values for testing the absence of effects; <code><a href="#topic+ciee_loop">ciee_loop</a></code> performs
<code><a href="#topic+ciee">ciee</a></code> in separate analyses of multiple exposure variables with the same
outcome measures and factors ond only returns point estimates, standard error
estimates and p-values for the exposure variables. Both functions can also compute
estimates and p-values from the two traditional regression methods and from the
structural equation modeling method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciee(setting = "GLM", estimates = c("ee", "mult_reg", "res_reg", "sem"),
  ee_se = c("sandwich"), BS_rep = NULL, Y = NULL, X = NULL, K = NULL,
  L = NULL, C = NULL)

ciee_loop(setting = "GLM", estimates = c("ee", "mult_reg", "res_reg",
  "sem"), ee_se = c("sandwich"), BS_rep = NULL, Y = NULL, X = NULL,
  K = NULL, L = NULL, C = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ciee_+3A_setting">setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating
whether a normally-distributed (<code>"GLM"</code>) or censored
time-to-event (<code>"AFT"</code>) primary outcome <code>Y</code> is
analyzed.</p>
</td></tr>
<tr><td><code id="ciee_+3A_estimates">estimates</code></td>
<td>
<p>String vector with possible values <code>"ee"</code>, <code>"mult_reg"</code>,
<code>"res_reg"</code>, <code>"sem"</code> indicating which methods
are computed. <code>"ee"</code> computes CIEE, <code>"mult_reg"</code>
the traditional multiple regression method, <code>"res_reg"</code>
the traditional regression of residuals method, and
<code>"sem"</code> the structural equation modeling approach.
Multiple methods can be specified.</p>
</td></tr>
<tr><td><code id="ciee_+3A_ee_se">ee_se</code></td>
<td>
<p>String with possible values <code>"sandwich"</code>, <code>"bootstrap"</code>,
<code>"naive"</code> indicating how the standard error estimates
of the parameter estiamtes are computed for CIEE approach.
<code>"sandwich"</code> computes the robust sandwich estimates (default,
recommended), <code>"bootstrap"</code> the bootstrap estimates and
<code>"naive"</code> the naive unadjusted standard error estimates
(not recommended, only for comparison).
One method has to be specified.</p>
</td></tr>
<tr><td><code id="ciee_+3A_bs_rep">BS_rep</code></td>
<td>
<p>Integer indicating the number of bootstrap samples that are
drawn (recommended 1000) if bootstrap standard errors are computed.</p>
</td></tr>
<tr><td><code id="ciee_+3A_y">Y</code></td>
<td>
<p>Numeric input vector for the primary outcome.</p>
</td></tr>
<tr><td><code id="ciee_+3A_x">X</code></td>
<td>
<p>Numeric input vector for the exposure variable if the <code><a href="#topic+ciee">ciee</a></code>
function is used; or numeric input dataframe containing the exposure
variables as columns if the <code><a href="#topic+ciee_loop">ciee_loop</a></code> function is used.</p>
</td></tr>
<tr><td><code id="ciee_+3A_k">K</code></td>
<td>
<p>Numeric input vector for the intermediate outcome.</p>
</td></tr>
<tr><td><code id="ciee_+3A_l">L</code></td>
<td>
<p>Numeric input vector for the observed confounding factor.</p>
</td></tr>
<tr><td><code id="ciee_+3A_c">C</code></td>
<td>
<p>Numeric input vector for the censoring indicator under the AFT setting
(must be coded 0 = censored, 1 = uncensored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the computation of CIEE, point estimates of the parameters are obtained
using the <code><a href="#topic+get_estimates">get_estimates</a></code> function. Robust sandwich (recommended),
bootstrap, or naive standard error estimates of the parameter estimates are
obtained using the <code><a href="#topic+sandwich_se">sandwich_se</a></code>, <code><a href="#topic+bootstrap_se">bootstrap_se</a></code>
or <code><a href="#topic+naive_se">naive_se</a></code> function. Large-sample Wald-type tests are performed
for testing the absence of effects, using either the robust sandwich or
bootstrap standard errors.
</p>
<p>Regarding the traditional regression methods, the multiple regression or
regression of residual approaches can be computed using the
<code><a href="#topic+mult_reg">mult_reg</a></code> and <code><a href="#topic+res_reg">res_reg</a></code> functions. Finally, the
structural equation modeling approachcan be performed using the
<code><a href="#topic+sem_appl">sem_appl</a></code> function.
</p>


<h3>Value</h3>

<p>Object of class <code>ciee</code>, for which the summary function
<code><a href="#topic+summary.ciee">summary.ciee</a></code> is implemented.
<code><a href="#topic+ciee">ciee</a></code> returns a list containing the point and standard error
estimates of all parameters as well as p-values from hypothesis tests
of the absence of effects, for each specified approach.
<code><a href="#topic+ciee_loop">ciee_loop</a></code> returns a list containing the point and standard
error estimates only of the exposure variables as well as p-values from
hypothesis tests of the absence of effects, for each specified approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate data under the GLM setting with default values
maf &lt;- 0.2
n &lt;- 100
dat &lt;- generate_data(n = n, maf = maf)
datX &lt;- data.frame(X = dat$X)
names(datX)[1] &lt;- "X1"
# Add 9 more exposure variables names X2, ..., X10 to X
for (i in 2:10){
  X &lt;- stats::rbinom(n, size = 2, prob = maf)
  datX$X &lt;- X
  names(datX)[i] &lt;- paste("X", i, sep="")
}

# Perform analysis of one exposure variable using all four methods
ciee(Y = dat$Y, X = datX$X1, K = dat$K, L = dat$L)

# Perform analysis of all exposure variables only for CIEE
ciee_loop(estimates = "ee", Y = dat$Y, X = datX, K = dat$K, L = dat$L)

</code></pre>

<hr>
<h2 id='est_funct_expr'>Estimating functions.</h2><span id='topic+est_funct_expr'></span>

<h3>Description</h3>

<p>Function to compute <code>logL1</code> and <code>logL2</code> under the GLM and AFT setting
for the analysis of a normally-distributed and of a censored time-to-event
primary outcome. <code>logL1</code> and <code>logL2</code> are functions which underlie
the estimating functions of CIEE for the derivation of point estimates and
standard error estimates. <code><a href="#topic+est_funct_expr">est_funct_expr</a></code> computes their
expression, which is then further used in the functions <code><a href="#topic+deriv_obj">deriv_obj</a></code>,
<code><a href="#topic+ciee">ciee</a></code> and <code><a href="#topic+ciee_loop">ciee_loop</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_funct_expr(setting = "GLM")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_funct_expr_+3A_setting">setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating whether
the expression of <code>logL1</code> and <code>logL2</code> is computed
under the GLM or AFT setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the GLM setting for the analysis of a normally-distributed primary
outcome <code>Y</code>, the goal is to obtain estimates for the pararameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1^2, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
under the model
</p>
<p style="text-align: center;"><code class="reqn">Y = \alpha_0 + \alpha_1 \cdot K + \alpha_2 \cdot X + \alpha_3 \cdot L + \epsilon_1, \epsilon_1 \sim N(0,\sigma_1^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = Y - \overline{Y} - \alpha_1 \cdot (K-\overline{K})</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = \alpha_0 + \alpha_{XY} \cdot X + \epsilon_2, \epsilon_2 \sim N(0,\sigma_2^2)</code>
</p>

<p><code>logL1</code> underlies the estimating functions for the derivation of the
first 5 parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1^2</code>
and
<code>logL2</code> underlies the estimating functions for the derivation of the
last 3 parameters
<code class="reqn">\alpha_4, \alpha_{XY}, \sigma_2^2</code>.
</p>
<p>Under the AFT setting for the analysis of a censored time-to-event primary
outcome <code>Y</code>, the goal is to obtain estimates of the parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1, \alpha_4, \alpha_{XY}, \sigma_2^2</code>.
Here, <code>logL1</code> similarly underlies the estimating functions
for the derivation of the first 5 parameters and <code>logL2</code> underlies the
estimating functions for the derivation of the last 3 parameters.
</p>
<p><code>logL1</code>, <code>logL2</code> equal the log-likelihood functions (<code>logL2</code>
given that <code class="reqn">\alpha_1</code> is known). For more details and the underlying model,
see the vignette.
</p>


<h3>Value</h3>

<p>Returns a list containing the expression of the functions <code>logL1</code>
and <code>logL2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est_funct_expr(setting = "GLM")
est_funct_expr(setting = "AFT")

</code></pre>

<hr>
<h2 id='generate_data'>Data generation function</h2><span id='topic+generate_data'></span>

<h3>Description</h3>

<p>Function to generate data with <code>n</code> observations of a primary
outcome <code>Y</code>, secondary outcome <code>K</code>, exposure <code>X</code>, and
measured as well as unmeasured confounders <code>L</code> and <code>U</code>, where
the primary outcome is a quantitative normally-distributed variable
(<code>setting</code> = <code>"GLM"</code>) or censored time-to-event outcome under
an accelerated failure time (AFT) model (<code>setting</code> = <code>"AFT"</code>).
Under the AFT setting, the observed time-to-event variable <code>T=exp(Y)</code>
as well as the censoring indicator <code>C</code> are also computed. <code>X</code>
is generated as a genetic exposure variable in the form of a single
nucleotide variant (SNV) in 0-1-2 additive coding with minor allele
frequency <code>maf</code>. <code>X</code> can be generated independently of <code>U</code>
(<code>X_orth_U</code> = <code>TRUE</code>) or dependent on <code>U</code>
(<code>X_orth_U</code> = <code>FALSE</code>). For more details regarding the underlying
model, see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data(setting = "GLM", n = 1000, maf = 0.2, cens = 0.3,
  a = NULL, b = NULL, aXK = 0.2, aXY = 0.1, aXL = 0, aKY = 0.3,
  aLK = 0, aLY = 0, aUY = 0, aUL = 0, mu_X = NULL, sd_X = NULL,
  X_orth_U = TRUE, mu_U = 0, sd_U = 1, mu_K = 0, sd_K = 1, mu_L = 0,
  sd_L = 1, mu_Y = 0, sd_Y = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data_+3A_setting">setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating
whether the primary outcome is generated as a
normally-distributed quantitative outcome (<code>"GLM"</code>) or
censored time-to-event outcome (<code>"AFT"</code>).</p>
</td></tr>
<tr><td><code id="generate_data_+3A_n">n</code></td>
<td>
<p>Numeric. Sample size.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_maf">maf</code></td>
<td>
<p>Numeric. Minor allele frequency of the genetic exposure variable.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_cens">cens</code></td>
<td>
<p>Numeric. Desired percentage of censored individuals and has to be
specified under the AFT setting. Note that the actual censoring
rate is generated through specification of the parameters
<code>a</code> and <code>b</code>, and <code>cens</code> is mostly used as a check
whether the desired censoring rate is obtained through <code>a</code>
and <code>b</code> (otherwise, a warning is issued).</p>
</td></tr>
<tr><td><code id="generate_data_+3A_a">a</code></td>
<td>
<p>Integer for generating the desired censoring rate under the AFT
setting. Has to be specified under the AFT setting.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_b">b</code></td>
<td>
<p>Integer for generating the desired censoring rate under the AFT
setting. Has to be specified under the AFT setting.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_axk">aXK</code></td>
<td>
<p>Numeric. Size of the effect of <code>X</code> on <code>K</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_axy">aXY</code></td>
<td>
<p>Numeric. Size of the effect of <code>X</code> on <code>Y</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_axl">aXL</code></td>
<td>
<p>Numeric. Size of the effect of <code>X</code> on <code>L</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_aky">aKY</code></td>
<td>
<p>Numeric. Size of the effect of <code>K</code> on <code>Y</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_alk">aLK</code></td>
<td>
<p>Numeric. Size of the effect of <code>L</code> on <code>K</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_aly">aLY</code></td>
<td>
<p>Numeric. Size of the effect of <code>L</code> on <code>Y</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_auy">aUY</code></td>
<td>
<p>Numeric. Size of the effect of <code>U</code> on <code>Y</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_aul">aUL</code></td>
<td>
<p>Numeric. Size of the effect of <code>U</code> on <code>L</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_mu_x">mu_X</code></td>
<td>
<p>Numeric. Expected value of <code>X</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_sd_x">sd_X</code></td>
<td>
<p>Numeric. Standard deviation of <code>X</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_x_orth_u">X_orth_U</code></td>
<td>
<p>Logical. Indicator whether <code>X</code> should be generated
independently of <code>U</code> (<code>X_orth_U</code> = <code>TRUE</code>)
or dependent on <code>U</code> (<code>X_orth_U</code> = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="generate_data_+3A_mu_u">mu_U</code></td>
<td>
<p>Numeric. Expected value of <code>U</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_sd_u">sd_U</code></td>
<td>
<p>Numeric. Standard deviation of <code>U</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_mu_k">mu_K</code></td>
<td>
<p>Numeric. Expected value of <code>K</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_sd_k">sd_K</code></td>
<td>
<p>Numeric. Standard deviation of <code>K</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_mu_l">mu_L</code></td>
<td>
<p>Numeric. Expected value of <code>L</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_sd_l">sd_L</code></td>
<td>
<p>Numeric. Standard deviation of <code>L</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_mu_y">mu_Y</code></td>
<td>
<p>Numeric. Expected value of <code>Y</code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_sd_y">sd_Y</code></td>
<td>
<p>Numeric. Standard deviation of <code>Y</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing <code>n</code> observations of the variables <code>Y</code>,
<code>K</code>, <code>X</code>, <code>L</code>, <code>U</code>. Under the AFT setting,
<code>T=exp(Y)</code> and the censoring indicator <code>C</code> (0 = censored,
1 = uncensored) are also computed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data under the GLM setting with default values
dat_GLM &lt;- generate_data()
head(dat_GLM)

# Generate data under the AFT setting with default values
dat_AFT &lt;- generate_data(setting = "AFT", a = 0.2, b = 4.75)
head(dat_AFT)

</code></pre>

<hr>
<h2 id='get_estimates'>CIEE parameter point estimates</h2><span id='topic+get_estimates'></span>

<h3>Description</h3>

<p>Function to perform CIEE to obtain point estimates under the GLM or AFT
setting for the analysis of a normally-distributed or censored time-to-event
primary outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_estimates(setting = "GLM", Y = NULL, X = NULL, K = NULL, L = NULL,
  C = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_estimates_+3A_setting">setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating
whether CIEE point estimates are obtained for a
normally-distributed (<code>"GLM"</code>) or censored time-to-event
(<code>"AFT"</code>) primary outcome <code>Y</code>.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_y">Y</code></td>
<td>
<p>Numeric input vector for the primary outcome.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_x">X</code></td>
<td>
<p>Numeric input vector for the exposure variable.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_k">K</code></td>
<td>
<p>Numeric input vector for the intermediate outcome.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_l">L</code></td>
<td>
<p>Numeric input vector for the observed confounding factor.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_c">C</code></td>
<td>
<p>Numeric input vector for the censoring indicator under the AFT setting
(must be coded 0 = censored, 1 = uncensored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the GLM setting for the analysis of a normally-distributed primary
outcome Y, estimates of the parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1^2, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
are obtained by constructing estimating equations for the models
</p>
<p style="text-align: center;"><code class="reqn">Y = \alpha_0 + \alpha_1 \cdot K + \alpha_2 \cdot X + \alpha_3 \cdot L + \epsilon_1, \epsilon_1 \sim N(0,\sigma_1^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = Y - \overline{Y} - \alpha_1 \cdot (K-\overline{K})</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = \alpha_0 + \alpha_{XY} \cdot X + \epsilon_2, \epsilon_2 \sim N(0,\sigma_2^2).</code>
</p>

<p>Under the AFT setting for the analysis of a censored time-to-event primary
outcome, estimates of the parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
are obtained by constructing
similar estimating equations based on a censored regression model and adding
an additional computation to estimate the true underlying survival times.
In addition to the parameter estimates, the mean of the estimated true
survival times is computed and returned in the output. For more details and
the underlying model, see the vignette.
</p>
<p>For both settings, the point estimates based on estimating equations equal
least squares (and maximum likelihood) estimates, and are obtained using
the <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="survival.html#topic+survreg">survreg</a></code>
functions for computational purposes.
</p>


<h3>Value</h3>

<p>Returns a list with point estimates of the parameters. Under the
AFT setting, the mean of the estimated true survival times is also
computed and returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat_GLM &lt;- generate_data(setting = "GLM")
get_estimates(setting = "GLM", Y = dat_GLM$Y, X = dat_GLM$X, K = dat_GLM$K,
              L = dat_GLM$L)

dat_AFT &lt;- generate_data(setting = "AFT", a = 0.2, b = 4.75)
get_estimates(setting = "AFT", Y = dat_AFT$Y, X = dat_AFT$X, K = dat_AFT$K,
              L = dat_AFT$L, C = dat_AFT$C)

</code></pre>

<hr>
<h2 id='naive_se'>Naive standard error estimates</h2><span id='topic+naive_se'></span>

<h3>Description</h3>

<p>Function to obtain naive standard error estimates for the parameter
estimates of the <code><a href="#topic+get_estimates">get_estimates</a></code> function, under the GLM or AFT
setting for the analysis of a normally-distributed or censored time-to-event
primary outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naive_se(setting = "GLM", Y = NULL, X = NULL, K = NULL, L = NULL,
  C = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="naive_se_+3A_setting">setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating
whether standard error estimates are obtained for a
normally-distributed (<code>"GLM"</code>) or censored time-to-event
(<code>"AFT"</code>) primary outcome <code>Y</code>.</p>
</td></tr>
<tr><td><code id="naive_se_+3A_y">Y</code></td>
<td>
<p>Numeric input vector for the primary outcome.</p>
</td></tr>
<tr><td><code id="naive_se_+3A_x">X</code></td>
<td>
<p>Numeric input vector for the exposure variable.</p>
</td></tr>
<tr><td><code id="naive_se_+3A_k">K</code></td>
<td>
<p>Numeric input vector for the intermediate outcome.</p>
</td></tr>
<tr><td><code id="naive_se_+3A_l">L</code></td>
<td>
<p>Numeric input vector for the observed confounding factor.</p>
</td></tr>
<tr><td><code id="naive_se_+3A_c">C</code></td>
<td>
<p>Numeric input vector for the censoring indicator under the AFT setting
(must be coded 0 = censored, 1 = uncensored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the GLM setting for the analysis of a normally-distributed primary
outcome Y, naive standard error estimates are obtained for the estimates of the
parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \alpha_4, \alpha_{XY}</code>
in the models
</p>
<p style="text-align: center;"><code class="reqn">Y = \alpha_0 + \alpha_1 \cdot K + \alpha_2 \cdot X + \alpha_3 \cdot L + \epsilon_1, \epsilon_1 \sim N(0,\sigma_1^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = Y - \overline{Y} - \alpha_1 \cdot (K-\overline{K})</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = \alpha_0 + \alpha_{XY} \cdot X + \epsilon_2, \epsilon_2 \sim N(0,\sigma_2^2),</code>
</p>

<p>using the <code><a href="stats.html#topic+lm">lm</a></code> function, without accounting for the
additional variability due to the 2-stage approach.
</p>
<p>Under the AFT setting for the analysis of a censored time-to-event primary
outcome, bootstrap standard error estimates are similarly obtained of the
parameter estimates of
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \alpha_4, \alpha_{XY}</code>
from the output of the <code><a href="survival.html#topic+survreg">survreg</a></code> and
<code><a href="stats.html#topic+lm">lm</a></code> functions.
</p>


<h3>Value</h3>

<p>Returns a vector with the naive standard error estimates of the
parameter estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- generate_data(setting = "GLM")
naive_se(setting = "GLM", Y = dat$Y, X = dat$X, K = dat$K, L = dat$L)

</code></pre>

<hr>
<h2 id='sandwich_se'>Sandwich standard error estimates</h2><span id='topic+sandwich_se'></span>

<h3>Description</h3>

<p>Function to obtain consistent and robust sandwich standard error estimates
based on estimating equations, for the parameter estimates of the
<code><a href="#topic+get_estimates">get_estimates</a></code> function, under the GLM or AFT setting
for the analysis of a normally-distributed or censored time-to-event primary
outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sandwich_se(setting = "GLM", scores = NULL, hessian = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sandwich_se_+3A_setting">setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating
whether standard error estimates are obtained for a
normally-distributed (<code>"GLM"</code>) or censored time-to-event
(<code>"AFT"</code>) primary outcome <code>Y</code>.</p>
</td></tr>
<tr><td><code id="sandwich_se_+3A_scores">scores</code></td>
<td>
<p>Score matrix of the parameters, which can be obtained using the
<code><a href="#topic+scores">scores</a></code> function.</p>
</td></tr>
<tr><td><code id="sandwich_se_+3A_hessian">hessian</code></td>
<td>
<p>Hessian matrix of the parameters, which can be obtained using the
<code><a href="#topic+hessian">hessian</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the GLM setting for the analysis of a normally-distributed primary
outcome Y, robust sandwich standard error estimates are obtained for the
estimates of the parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1^2, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
in the model
</p>
<p style="text-align: center;"><code class="reqn">Y = \alpha_0 + \alpha_1 \cdot K + \alpha_2 \cdot X + \alpha_3 \cdot L + \epsilon_1, \epsilon_1 \sim N(0,\sigma_1^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = Y - \overline{Y} - \alpha_1 \cdot (K-\overline{K})</code>
</p>

<p style="text-align: center;"><code class="reqn">Y^* = \alpha_0 + \alpha_{XY} \cdot X + \epsilon_2, \epsilon_2 \sim N(0,\sigma_2^2)</code>
</p>

<p>by using the score and hessian matrices of the parameters.
</p>
<p>Under the AFT setting for the analysis of a censored time-to-event primary
outcome, robust sandwich standard error estimates are  similarly obtained of
the parameter estimates of
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1, \alpha_4, \alpha_{XY}, \sigma_2^2</code>.
For more details and the underlying model, see the vignette.
</p>


<h3>Value</h3>

<p>Returns a vector with the CIEE sandwich standard error estimates
of the parameter estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate data including Y, K, L, X under the GLM setting
dat &lt;- generate_data(setting = "GLM")

# Obtain estimating functions expressions
estfunct &lt;- est_funct_expr(setting = "GLM")

# Obtain point estimates of the parameters
estimates &lt;- get_estimates(setting = "GLM", Y = dat$Y, X = dat$X,
                           K = dat$K, L = dat$L)

# Obtain matrices with all first and second derivatives
derivobj &lt;- deriv_obj(setting = "GLM", logL1 = estfunct$logL1,
                      logL2 = estfunct$logL2, Y = dat$Y, X = dat$X,
                      K = dat$K, L = dat$L, estimates = estimates)

# Obtain score and hessian matrices
results_scores &lt;- scores(derivobj)
results_hessian &lt;- hessian(derivobj)

# Obtain sandwich standard error estimates of the parameters
sandwich_se(scores = results_scores, hessian = results_hessian)

</code></pre>

<hr>
<h2 id='score_and_hessian_matrix_functions'>Score and hessian matrix based on the estimating functions.</h2><span id='topic+score_and_hessian_matrix_functions'></span><span id='topic+deriv_obj'></span><span id='topic+scores'></span><span id='topic+hessian'></span>

<h3>Description</h3>

<p>Functions to compute the score and hessian matrices of the parameters
based on the estimating functions, under the GLM and AFT setting for
the analysis of a normally-distributed or censored time-to-event
primary outcome. The score and hessian matrices are further used in
the functions <code><a href="#topic+sandwich_se">sandwich_se</a></code>, <code><a href="#topic+ciee">ciee</a></code> and
<code><a href="#topic+ciee_loop">ciee_loop</a></code> to obtain robust sandwich error estimates of the
parameter estimates of
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1^2, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
under the GLM setting and
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
under the AFT setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriv_obj(setting = "GLM", logL1 = NULL, logL2 = NULL, Y = NULL,
  X = NULL, K = NULL, L = NULL, C = NULL, estimates = NULL)

scores(derivobj = NULL)

hessian(derivobj = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_and_hessian_matrix_functions_+3A_setting">setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating
whether the matrices are computed under the GLM or AFT setting.</p>
</td></tr>
<tr><td><code id="score_and_hessian_matrix_functions_+3A_logl1">logL1</code></td>
<td>
<p>Expression of the function <code>logL1</code> generated by
the <code><a href="#topic+est_funct_expr">est_funct_expr</a></code> function.</p>
</td></tr>
<tr><td><code id="score_and_hessian_matrix_functions_+3A_logl2">logL2</code></td>
<td>
<p>Expression of the function <code>logL2</code> generated by
the <code><a href="#topic+est_funct_expr">est_funct_expr</a></code> function.</p>
</td></tr>
<tr><td><code id="score_and_hessian_matrix_functions_+3A_y">Y</code></td>
<td>
<p>Numeric input vector for the primary outcome.</p>
</td></tr>
<tr><td><code id="score_and_hessian_matrix_functions_+3A_x">X</code></td>
<td>
<p>Numeric input vector for the exposure variable.</p>
</td></tr>
<tr><td><code id="score_and_hessian_matrix_functions_+3A_k">K</code></td>
<td>
<p>Numeric input vector for the intermediate outcome.</p>
</td></tr>
<tr><td><code id="score_and_hessian_matrix_functions_+3A_l">L</code></td>
<td>
<p>Numeric input vector for the observed confounding factor.</p>
</td></tr>
<tr><td><code id="score_and_hessian_matrix_functions_+3A_c">C</code></td>
<td>
<p>Numeric input vector for the censoring indicator under the AFT setting
(must be coded 0 = censored, 1 = uncensored).</p>
</td></tr>
<tr><td><code id="score_and_hessian_matrix_functions_+3A_estimates">estimates</code></td>
<td>
<p>Numeric input vector with point estimates of the parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1^2,</code>
<code class="reqn">\alpha_4, \alpha_{XY}, \sigma_2^2</code>
under the GLM setting and of
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \sigma_1, \alpha_4, \alpha_{XY}, \sigma_2^2</code>
under the AFT setting. Under the AFT setting,
<code>estimates</code> must also contain the mean of the estimated
true survival times <code>"y_adj_bar"</code>.</p>
</td></tr>
<tr><td><code id="score_and_hessian_matrix_functions_+3A_derivobj">derivobj</code></td>
<td>
<p>Output of the <code><a href="#topic+deriv_obj">deriv_obj</a></code> function used as input in
the <code><a href="#topic+scores">scores</a></code> and <code><a href="#topic+hessian">hessian</a></code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the computation of the score and hessian matrices, first, the help function
<code><a href="#topic+deriv_obj">deriv_obj</a></code> is used. In a first step, the expression of all first
and second derivatives of the parameters is computed using the expressions of
<code>logL1</code> and <code>logL2</code> from the <code><a href="#topic+est_funct_expr">est_funct_expr</a></code> as input.
Then, the numerical values of all first and second derivatives are obtained
for the observed data <code>Y</code>, <code>X</code>, <code>K</code>, <code>L</code> (and <code>C</code> under
the AFT setting) and point estimates (<code>estimates</code>) of the parameters,
for all observed individuals.
</p>
<p>Second, the functions <code><a href="#topic+scores">scores</a></code> and <code><a href="#topic+hessian">hessian</a></code> are used
to extract the relevant score and hessian matrices with respect to <code>logL1</code>
and <code>logL2</code> from the output of <code><a href="#topic+deriv_obj">deriv_obj</a></code> and piece them together.
For further details, see the vignette.
</p>


<h3>Value</h3>

<p>The <code><a href="#topic+deriv_obj">deriv_obj</a></code> function returns a list with
objects <code>logL1_deriv</code>, <code>logL2_deriv</code> which
contain the score and hessian matrices based on <code>logL1</code>,
<code>logL2</code>, respectively.
</p>
<p>The <code><a href="#topic+scores">scores</a></code> function returns the <code class="reqn">(n \times 8)</code>
score matrix.
</p>
<p>The <code><a href="#topic+hessian">hessian</a></code> function returns the <code class="reqn">(n \times 8 \times 8)</code>
hessian matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate data including Y, K, L, X under the GLM setting
dat &lt;- generate_data(setting = "GLM")

# Obtain estimating functions' expressions
estfunct &lt;- est_funct_expr(setting = "GLM")

# Obtain point estimates of the parameters
estimates &lt;- get_estimates(setting = "GLM", Y = dat$Y, X = dat$X,
                           K = dat$K, L = dat$L)

# Obtain matrices with all first and second derivatives
derivobj &lt;- deriv_obj(setting = "GLM", logL1 = estfunct$logL1,
                      logL2 = estfunct$logL2, Y = dat$Y, X = dat$X,
                      K = dat$K, L = dat$L, estimates = estimates)
names(derivobj)
head(derivobj$logL1_deriv$gradient)

# Obtain score and hessian matrices
scores(derivobj)
hessian(derivobj)

</code></pre>

<hr>
<h2 id='sem_appl'>Structural equation modeling approach</h2><span id='topic+sem_appl'></span>

<h3>Description</h3>

<p>Function which uses the <code><a href="lavaan.html#topic+sem">sem</a></code> function in the
<code>lavaan</code> package to fit the model
</p>
<p style="text-align: center;"><code class="reqn">L = \alpha_0 + \alpha_1 \cdot X + \epsilon_1, \epsilon_1 \sim N(0,\sigma_1^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">K = \alpha_2 + \alpha_3 \cdot X + \alpha_4 \cdot L + \epsilon_2, \epsilon_2 \sim~ N(0,\sigma_2^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">Y = \alpha_5 + \alpha_6 \cdot K + \alpha_{XY} \cdot X + \epsilon_3, \epsilon_3 \sim N(0,\sigma_3^2)</code>
</p>

<p>in order to obtain point and standard error estimates
of the parameters
<code class="reqn">\alpha_1, \alpha_3, \alpha_4, \alpha_6, \alpha_{XY}</code>
for the GLM setting.
See the vignette for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sem_appl(Y = NULL, X = NULL, K = NULL, L = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sem_appl_+3A_y">Y</code></td>
<td>
<p>Numeric input vector for the primary outcome.</p>
</td></tr>
<tr><td><code id="sem_appl_+3A_x">X</code></td>
<td>
<p>Numeric input vector for the exposure variable.</p>
</td></tr>
<tr><td><code id="sem_appl_+3A_k">K</code></td>
<td>
<p>Numeric input vector for the intermediate outcome.</p>
</td></tr>
<tr><td><code id="sem_appl_+3A_l">L</code></td>
<td>
<p>Numeric input vector for the observed confounding factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with point estimates of the parameters
(<code>point_estimates</code>), standard error estimates
(<code>SE_estimates</code>) and p-values from large-sample
Wald-type tests (<code>pvalues</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- generate_data(setting = "GLM")
sem_appl(Y = dat$Y, X = dat$X, K = dat$K, L = dat$L)

</code></pre>

<hr>
<h2 id='summary.ciee'>Summary function.</h2><span id='topic+summary.ciee'></span>

<h3>Description</h3>

<p>Summary function for the <code><a href="#topic+ciee">ciee</a></code> and <code><a href="#topic+ciee_loop">ciee_loop</a></code>
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ciee'
summary(object = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ciee_+3A_object">object</code></td>
<td>
<p><code>ciee</code> object (output of the <code><a href="#topic+ciee">ciee</a></code>
or <code><a href="#topic+ciee_loop">ciee_loop</a></code> function).</p>
</td></tr>
<tr><td><code id="summary.ciee_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted data frames of the results of all computed methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
maf &lt;- 0.2
n &lt;- 1000
dat &lt;- generate_data(n = n, maf = maf)
datX &lt;- data.frame(X = dat$X)
names(datX)[1] &lt;- "X1"
for (i in 2:10){
  X &lt;- stats::rbinom(n, size = 2, prob = maf)
  datX$X &lt;- X
  names(datX)[i] &lt;- paste("X", i, sep="")
}

results1 &lt;- ciee(Y = dat$Y, X = datX$X1, K = dat$K, L = dat$L)
summary(results1)

results2 &lt;- ciee_loop(Y = dat$Y, X = datX, K = dat$K, L = dat$L)
summary(results2)

</code></pre>

<hr>
<h2 id='traditional_regression_functions'>Traditional regression approaches.</h2><span id='topic+traditional_regression_functions'></span><span id='topic+mult_reg'></span><span id='topic+res_reg'></span>

<h3>Description</h3>

<p>Functions to fit traditional regression approaches for a quantitative
normally-distributed primary outcome (<code>setting</code> = <code>"GLM"</code>)
and a censoredtime-to-event primary outcome (<code>setting</code> = <code>"AFT"</code>).
<code><a href="#topic+mult_reg">mult_reg</a></code> fits the multiple regression approach and
<code><a href="#topic+res_reg">res_reg</a></code> computes the regression of residuals approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mult_reg(setting = "GLM", Y = NULL, X = NULL, K = NULL, L = NULL,
  C = NULL)

res_reg(Y = NULL, X = NULL, K = NULL, L = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traditional_regression_functions_+3A_setting">setting</code></td>
<td>
<p>String with value <code>"GLM"</code> or <code>"AFT"</code> indicating
whether the approaches are fitted for a normally-distributed
primary outcome <code>Y</code> (<code>"GLM"</code>) or a censored
time-to-event primary outcome <code>Y</code> (<code>"AFT"</code>). Under
the <code>"AFT"</code> setting, only <code>mult_reg</code> is
available.</p>
</td></tr>
<tr><td><code id="traditional_regression_functions_+3A_y">Y</code></td>
<td>
<p>Numeric input vector of the primary outcome.</p>
</td></tr>
<tr><td><code id="traditional_regression_functions_+3A_x">X</code></td>
<td>
<p>Numeric input vector of the exposure variable.</p>
</td></tr>
<tr><td><code id="traditional_regression_functions_+3A_k">K</code></td>
<td>
<p>Numeric input vector of the intermediate outcome.</p>
</td></tr>
<tr><td><code id="traditional_regression_functions_+3A_l">L</code></td>
<td>
<p>Numeric input vector of the observed confounding factor.</p>
</td></tr>
<tr><td><code id="traditional_regression_functions_+3A_c">C</code></td>
<td>
<p>Numeric input vector of the censoring indicator under the AFT setting
(must be coded 0 = censored, 1 = uncensored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In more detail, for a quantitative normally-distributed primary outcome
<code>Y</code>, <code><a href="#topic+mult_reg">mult_reg</a></code> fits the model
</p>
<p style="text-align: center;"><code class="reqn">Y = \alpha_0 + \alpha_1 \cdot K + \alpha_{XY} \cdot X + \alpha_2 \cdot L + \epsilon</code>
</p>

<p>and obtains point and standard error estimates for the parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_{XY}, \alpha_2</code>.
<code><a href="#topic+res_reg">res_reg</a></code> obtains point and standard
error estimates for the parameters
<code class="reqn">\alpha_0, \alpha_1, \alpha_2, \alpha_3, \alpha_{XY}</code>
by fitting the models
</p>
<p style="text-align: center;"><code class="reqn">Y = \alpha_0 + \alpha_1 \cdot K + \alpha_2 \cdot L + \epsilon_1</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat{\epsilon}_1 = \alpha_3 + \alpha_{XY} \cdot X + \epsilon_2</code>
</p>

<p>Both functions use the <code><a href="stats.html#topic+lm">lm</a></code> function and also report the
provided p-values from t-tests that each parameter equals 0.
For the analysis of a censored time-to-event primary outcome <code>Y</code>,
only the multiple regression approach is implemented. Here,
<code><a href="#topic+mult_reg">mult_reg</a></code> fits the according censored regression model to obtain
coefficient and standard error estimates as well as p-values from large-sample
Wald-type tests by using the <code><a href="survival.html#topic+survreg">survreg</a></code> function.
See the vignette for more details.
</p>


<h3>Value</h3>

<p>Returns a list with point estimates of the parameters
<code>point_estimates</code>, standard error estimates <code>SE_estimates</code>
and p-values <code>pvalues</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat_GLM &lt;- generate_data(setting = "GLM")
mult_reg(setting = "GLM", Y = dat_GLM$Y, X = dat_GLM$X, K = dat_GLM$K,
         L = dat_GLM$L)
res_reg(Y = dat_GLM$Y, X = dat_GLM$X, K = dat_GLM$K, L = dat_GLM$L)

dat_AFT &lt;- generate_data(setting = "AFT", a = 0.2, b = 4.75)
mult_reg(setting = "AFT", Y = dat_AFT$Y, X = dat_AFT$X, K = dat_AFT$K,
         L = dat_AFT$L, C = dat_AFT$C)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
