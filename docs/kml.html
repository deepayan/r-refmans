<!DOCTYPE html><html lang="en"><head><title>Help for package kml</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kml}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kml-package'><p>~ Overview: K-means for Longitudinal data ~</p></a></li>
<li><a href='#affectFuzzyIndiv'>
<p>~ Function: affectFuzzyIndiv ~</p></a></li>
<li><a href='#affectIndiv'><p>~ Functions: affectIndiv &amp; affectIndivC ~</p></a></li>
<li><a href='#calculTrajFuzzyMean'>
<p>~ Function: calculTrajFuzzyMean ~</p></a></li>
<li><a href='#calculTrajMean'>
<p>~ Functions: calculTrajMean &amp; calculTrajMeanC ~</p></a></li>
<li><a href='#choice'><p> ~ Function: choice ~</p></a></li>
<li><a href='#clusterLongData'><p> ~ Function: clusterLongData (or cld) ~</p></a></li>
<li><a href='#ClusterLongData-class'><p>~ Class: ClusterLongData ~</p></a></li>
<li><a href='#epipageShort'><p>~ Data: epipageShort ~</p></a></li>
<li><a href='#fuzzyKmlSlow'><p>~ Algorithm fuzzy kml: Fuzzy k-means for Longitidinal data ~</p></a></li>
<li><a href='#generateArtificialLongData'><p>~ Function: generateArtificialLongData (or gald) ~</p></a></li>
<li><a href='#getBestPostProba'>
<p>~ Function: getBestPostProba ~</p></a></li>
<li><a href='#getClusters'>
<p>~ Function: getClusters ~</p></a></li>
<li><a href='#kml'><p>~ Algorithm kml: K-means for Longitidinal data ~</p></a></li>
<li><a href='#kml-internal'><p>~ Internal KmL objects and methods ~</p></a></li>
<li><a href='#parKml'><p> ~ Function: parKml ~</p></a></li>
<li><a href='#ParKml-class'><p>~ Class: &quot;ParKml&quot; ~</p></a></li>
<li><a href='#plot+2CClusterLongData'><p> ~ Function: plot for ClusterLongData ~</p></a></li>
<li><a href='#plotMeans+2CClusterLongData'><p> ~ Function: plotMeans for ClusterLongData ~</p></a></li>
<li><a href='#plotTraj+2CClusterLongData'><p> ~ Function: plotTraj for ClusterLongData ~</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>K-Means for Longitudinal Data</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of k-means specifically design
        to cluster longitudinal data. It provides facilities to deal with missing
        value, compute several quality criterion (Calinski and Harabatz,
        Ray and Turie, Davies and Bouldin, BIC, ...) and propose a graphical
        interface for choosing the 'best' number of clusters.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christophe Genolini &lt;christophe.genolini@free.fr&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Christophe Genolini [cre, aut],
  Bruno Falissard [ctb],
  Patrice Kiener [ctb]</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>Collate:</td>
<td>global.R clusterLongData.R parKml.R parChoice.R kml.R</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods,clv,longitudinalData (&ge; 2.4)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-21 11:11:13 UTC; patrice</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-23 17:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='kml-package'>~ Overview: K-means for Longitudinal data ~</h2><span id='topic+kml-package'></span>

<h3>Description</h3>

<p>This package is a implementation of k-means for longitudinal data (or trajectories).
Here is an overview of the package. For the description of the
algorithm, see <code><a href="#topic+kml">kml</a></code>.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> kml</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 2.4.1</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2016-02-02</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
    Depends: </td><td style="text-align: left;"> methods,clv,longitudinalData(&gt;= 2.1.2)</td>
</tr>
<tr>
 <td style="text-align: left;">
    URL:</td><td style="text-align: left;"> http://www.r-project.org</td>
</tr>
<tr>
 <td style="text-align: left;">
    URL:</td><td style="text-align: left;"> http://christophe.genolini.free.fr/kml</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Overview</h3>

<p>To cluster data, <code>KmL</code> go through three steps, each of which
is associated to some functions:
</p>

<ol>
<li><p> Data preparation
</p>
</li>
<li><p> Building &quot;optimal&quot; partition
</p>
</li>
<li><p> Exporting results
</p>
</li></ol>



<h3>1. Data preparation</h3>

<p><code>KmL</code> works on object of class <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>.
Data preparation therefore simply consists in transforming data into an object <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>.
This can be done via function
<code><a href="#topic+clusterLongData">clusterLongData</a></code>
(<code><a href="#topic+clusterLongData">cld</a></code> in short).
It converts a <code>data.frame</code> or a <code>matrix</code> into a <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>.
</p>
<p>Instead of working on real data, one can also work on artificial
data. Such data can be created with
<code><a href="#topic+generateArtificialLongData">generateArtificialLongData</a></code>
(<code><a href="#topic+gald">gald</a></code> in
short).
</p>


<h3>2. Building &quot;optimal&quot; partition</h3>

<p>Once an object of class <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> has been created, the algorithm
<code><a href="#topic+kml">kml</a></code> can be run.
</p>
<p>Starting with a <code>ClusterLongData</code>, <code>kml</code> built a 
<code>Partition</code>, a class in package longitudinalData. 

An object of class <code>Partition</code> is a partition of trajectories
into subgroups. It also contains some information like the
percentage of trajectories contained in each group or some quality critetion.<br />
</p>
<p><code>kml</code> is a &quot;hill-climbing&quot; algorithm. The specificity of this
kind of algorithm is that it always converges towards a maximum, but
one cannot know whether it is a local or a global maximum. It offers
no guarantee of optimality.
To maximize one's chances of getting a quality <code>Partition</code>, it is better to run the hill climbing algorithm several times,
then to choose the best solution. By default, <code>kml</code> executes the hill climbing algorithm 20 times
and chooses the <code>Partition</code> maximizing the determinant of the matrix between.
</p>
<p>Likewise, it is not possible to know <em>beforehand</em> the optimum number of clusters.
On the other hand, <em>afterwards</em>, it is possible to calculate
clues that will enable us to choose.
In the end, <code>kml</code> tests by default 2, 3, 4, 5 et 6 clusters, 20 times each.
</p>


<h3>3. Exporting results</h3>

<p>When <code><a href="#topic+kml">kml</a></code> has constructed some
<code>Partition</code>, the user can examine them one by one and choose
to export some. This can be done via function
<code><a href="#topic+choice">choice</a></code>. <code>choice</code> opens a graphic windows showing
various information including the trajectories clutered by a specific
<code>Partition</code>.
</p>
<p>When some <code>Partition</code> has been selected (the user can select
more than 1), it is possible to
save them. The clusters are therefore exported towards the file
<code>name-cluster.csv</code>. Criteria are exported towards
<code>name-criteres.csv</code>. The graphs are exported according to their
extension.
</p>
<p>It is also possible to extract a partition from the object
<code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> using the function <code>getClusters</code>.
</p>


<h3>See Also</h3>

<p>Classes : <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>, 
<code>Partition</code> in package longitudinalData <br />



Methods : <code><a href="#topic+clusterLongData">clusterLongData</a></code>, <code><a href="#topic+kml">kml</a></code>, <code><a href="#topic+choice">choice</a></code><br />
Plot : <code><a href="#topic+plot+2CClusterLongData">plot(ClusterLongData)</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

### 1. Data Preparation
data(epipageShort)
names(epipageShort)
cldSDQ &lt;- cld(epipageShort,timeInData=3:6,time=c(3,4,5,8))

### 2. Building "optimal" clusteration (with only 3 redrawings)
kml(cldSDQ,nbRedrawing=3,toPlot="both")

### 3. Exporting results
### To check the best's cluster numbers
plotAllCriterion(cldSDQ)


# To see the best partition
try(choice(cldSDQ))

### 4. Further analysis
epipageShort$clust &lt;- getClusters(cldSDQ,4)
summary(glm(gender~clust,data=epipageShort,family="binomial"))

### Go back to current dir
setwd(wd)

</code></pre>

<hr>
<h2 id='affectFuzzyIndiv'>
~ Function: affectFuzzyIndiv ~
</h2><span id='topic+affectFuzzyIndiv'></span>

<h3>Description</h3>

<p>Given some longitudinal data (trajectories) and k cluster's centers, <code>affectFuzzyIndiv</code>
compute the matrix of individual membership (according to the algorithm
fuzzy k-means).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affectFuzzyIndiv(traj, clustersCenter, fuzzyfier=1.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="affectFuzzyIndiv_+3A_traj">traj</code></td>
<td>
<p><code>[matrix]</code>: longitudinal data. Each line is an individual,
each column is a time measurement.</p>
</td></tr>
<tr><td><code id="affectFuzzyIndiv_+3A_clusterscenter">clustersCenter</code></td>
<td>
<p><code>[matrix]</code>: cluster's centers. Each line is a
cluster's center, each column is a time measurement.</p>
</td></tr>
<tr><td><code id="affectFuzzyIndiv_+3A_fuzzyfier">fuzzyfier</code></td>
<td>
<p><code>[numeric]</code>: value of the fuzzyfier used to
compute individual's memberships.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a matrix of clusters center <code>clustersCenter</code> (each line is
a cluster center), the function <code>affectFuzzyIndiv</code> compute for
each individual and each cluster a &quot;membership&quot;.
</p>
<p><code>affectFuzzyIndiv</code> used with <code><a href="#topic+calculTrajFuzzyMean">calculTrajFuzzyMean</a></code>
simulates one fuzzy k-means step.
</p>


<h3>Value</h3>

<p>Matrix of the membership. Each line is an individual, column are for clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################
### affectFuzzyIndiv

### Some LongitudinalData
traj &lt;- gald()["traj"]

### 4 clusters centers
center &lt;- traj[runif(4,1,nrow(traj)),]

### Affectation of each individual
affectFuzzyIndiv(traj,center)
</code></pre>

<hr>
<h2 id='affectIndiv'>~ Functions: affectIndiv &amp; affectIndivC ~</h2><span id='topic+affectIndiv'></span><span id='topic+affectIndivC'></span>

<h3>Description</h3>

<p>Given some longitudinal data (trajectories) and k clusters' centers,
<code>affectIndiv</code> and <code>affectIndivC</code>
affect each individual to the cluster whose centre is the closest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affectIndiv(traj, clustersCenter, distance = function(x,y){dist(rbind(x, y))})
affectIndivC(traj, clustersCenter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="affectIndiv_+3A_traj">traj</code></td>
<td>
<p><code>[matrix(numeric)]</code>: longitudinal data. Each line is an individual,
each column is a time measurement.</p>
</td></tr>
<tr><td><code id="affectIndiv_+3A_clusterscenter">clustersCenter</code></td>
<td>
<p><code>[matrix(numeric)]</code>: clusters centre. Each line is a
cluster center, each column is a time measurement.</p>
</td></tr>
<tr><td><code id="affectIndiv_+3A_distance">distance</code></td>
<td>
<p><code>[numeric &lt;- function(trajectory,trajectory)]</code>: use to estimate the distance between an
individual and a clusters center.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a matrix of clusters center <code>clustersCenter</code> (each line is
a cluster center), the function <code>affectIndiv</code> affect each
individual of the matrix <code>traj</code> to the closest clusters
(according to <code>distance</code>). <code>affectIndivC</code> does the same but
assume that the distance is the Euclidean
distance. <code>affectIndivC</code> is writen in C (and is therefor much faster).
</p>
<p><code>affectIndiv</code> used with <code><a href="#topic+calculTrajMean">calculTrajMean</a></code> simulates one k-means step.
</p>


<h3>Value</h3>

<p>Object of class<code><a href="longitudinalData.html#topic+Partition-class">Partition</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################
### affectIndiv

### Some trajectories
traj &lt;- gald()["traj"]

### 4 clusters centers
center &lt;- traj[runif(4,1,nrow(traj)),]

### Affectation of each individual
system.time(part &lt;- affectIndiv(traj,center))
system.time(part &lt;- affectIndivC(traj,center))
</code></pre>

<hr>
<h2 id='calculTrajFuzzyMean'>
~ Function: calculTrajFuzzyMean ~
</h2><span id='topic+calculTrajFuzzyMean'></span>

<h3>Description</h3>

<p>Given some longitudinal data and a group's membership,
<code>calculFuzzyMean</code> computes the mean trajectories of each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculTrajFuzzyMean(traj, fuzzyClust)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculTrajFuzzyMean_+3A_traj">traj</code></td>
<td>
<p><code>[matrix]</code>: longitudinal data. Each line is an individual,
each column is a time measurement.</p>
</td></tr>
<tr><td><code id="calculTrajFuzzyMean_+3A_fuzzyclust">fuzzyClust</code></td>
<td>
<p><code>[matrix(numeric)]</code>: membership matrix of each individual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a matrix of individual membership, the function
<code>calculTrajFuzzyMean</code> compute the mean trajectory of each
clusters.
</p>
<p><code><a href="#topic+affectFuzzyIndiv">affectFuzzyIndiv</a></code> used with <code>calculTrajFuzzyMean</code>
simulates one fuzzy k-means step.
</p>


<h3>Value</h3>

<p>A matrix with k line and t column containing k clusters centers. Each
line is a center, each column is a time measurement.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################
### calculTrajFuzzyMean

### Some LongitudinalData
traj &lt;- gald()["traj"]

### 4 clusters centers
center &lt;- traj[runif(4,1,nrow(traj)),]

### Affectation of each individual
membership &lt;- affectFuzzyIndiv(traj,center)

### Computation of the mean's trajectories
calculTrajFuzzyMean(traj,membership)
</code></pre>

<hr>
<h2 id='calculTrajMean'>
~ Functions: calculTrajMean &amp; calculTrajMeanC ~
</h2><span id='topic+calculTrajMean'></span><span id='topic+calculTrajMeanC'></span>

<h3>Description</h3>

<p>Given some longitudinal data and a cluster affectation,
<code>calculTrajMean</code> and <code>calculTrajMeanC</code> compute the mean trajectories of each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculTrajMean(traj, clust, centerMethod = function(x){mean(x, na.rm =TRUE)})
calculTrajMeanC(traj, clust)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculTrajMean_+3A_traj">traj</code></td>
<td>
<p><code>[matrix(numeric)]</code>: longitudinal data. Each line is an individual,
each column is a time measurement.</p>
</td></tr>
<tr><td><code id="calculTrajMean_+3A_clust">clust</code></td>
<td>
<p><code>[vector(numeric)]</code>: affectation of each
individual.</p>
</td></tr>
<tr><td><code id="calculTrajMean_+3A_centermethod">centerMethod</code></td>
<td>
<p><code>[trajectory &lt;- function(matrix(numeric))]</code>:
function that compute the mean trajectory of a group of trajectories.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of affectation to a cluster, the function
<code>calculTrajMean</code> compute the &quot;central&quot; trajectory of each
clusters. The &quot;center&quot; can be define using the argument <code>centerMethod</code>.
<code>calculTrajMeanC</code> does the same but
assume that the center definition is the classic &quot;mean&quot;.
<code>calculTrajMeanC</code> is writen in C (and is therefor much faster).
</p>
<p><code>affectIndiv</code> used with <code><a href="#topic+calculTrajMean">calculTrajMean</a></code> simulates one k-means step.
</p>


<h3>Value</h3>

<p>A matrix with k line and t column containing k clusters centers. Each
line is a center, each column is a time measurement.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################
### calculMean

### Some trajectories
traj &lt;- gald()["traj"]

### A cluster affectation
clust &lt;- initializePartition(3,200,"randomAll")

### Computation of the cluster's centers
system.time(centers &lt;- calculTrajMean(traj,clust))
system.time(centers &lt;- calculTrajMeanC(traj,clust))
</code></pre>

<hr>
<h2 id='choice'> ~ Function: choice ~</h2><span id='topic+choice'></span><span id='topic++5B+2CParChoice-method'></span><span id='topic+choice+2CClusterLongData-method'></span>

<h3>Description</h3>

<p><code>choice</code> lets the user choose some <code>Partition</code> he wants to export.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choice(object, typeGraph = "bmp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choice_+3A_object">object</code></td>
<td>
<p><code>[ClusterLongData]</code>: Object containing the trajectories and all the

<code>Partition</code> found by <code>kml</code>.</p>
</td></tr>
<tr><td><code id="choice_+3A_typegraph">typeGraph</code></td>
<td>
<p><code>[character]</code> for every selected <code>Partition</code>, <code>choice</code> export some graphs. <code>typeGraph</code> set
the format that will be used. Possible formats are the ones available for <code><a href="grDevices.html#topic+savePlot">savePlot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>choice</code> is a function that lets the user see the 

<code>Partition</code> found by <code>kml</code>.
At first, <code>choice</code> opens a graphics window (for Linux user, the windows should be explicitly
open using <code>x11(type = "Xlib")</code>). On the left side, all
the <code>Partition</code> contain in <code>Object</code> are ploted by a
number (the number of cluster of the Partition). The level of the
number is proportionnal to a quality criteria (like Calinski &amp;
Harabatz). One <code>Partition</code> is 'active', it is the one marked by a
black dot.<br />
</p>
<p>On the right side, the trajectories of Object are drawn, according to the active <code>Partition</code>.
</p>
<p>From there, <code>choice</code> offers numerous options :
</p>

<dl>
<dt>Arrow</dt><dd><p>Change the active <code>Partition</code>.</p>
</dd>
<dt>Space</dt><dd><p>Select/unselect a <code>Partition</code> (the selected
<code>Partition</code> are surrounded by a circle).</p>
</dd>
<dt>Return</dt><dd><p>Export all the selected <code>Partition</code>, then
quit the function <code>choice</code>.</p>
</dd>
<dt>'e'</dt><dd><p>Change the display (Trajectories alone / quality
criterion alone / both)</p>
</dd>
<dt>'d'</dt><dd><p>Change actif criterion.</p>
</dd>
<dt>'c'</dt><dd><p>Sort the Partition according to the actif criterion.</p>
</dd>
<dt>'r'</dt><dd><p>Change the trajectories' style.</p>
</dd>
<dt>'f'</dt><dd><p>Change the means trajectories's style.</p>
</dd>
<dt>'g/t'</dt><dd><p>Change the symbol size.</p>
</dd>
<dt>'y/h'</dt><dd><p>Change the number of symbols.</p>
</dd>
</dl>

<p>When 'return' is pressed (or 'm' using Linux), the selected <code>Partition</code> are
exported. Exporting is done in a specific named
<code>objectName-Cx-y</code> where x is the number of cluster and y is the
order in the sublist. Four files are created
:
</p>

<dl>
<dt>objectName-Cx-y-Clusters.csv</dt><dd><p>Table with two columns. The first is the
identifier of each trajectory (idAll); the second holds the cluster's
affectation of the trajectory.</p>
</dd>
<dt>objectName-Cx-y-Detail.csv</dt><dd><p>Table containing information about the
clusteration (percentage of individual
in each cluster, various qualities criterion, algorithm used to
find the partition and convergence time.)</p>
</dd>
<dt>objectName-Cx-y-Traj.bmp</dt><dd><p>Graph representing the
trajectories. All the parameters set during the visualization (color
of the trajectories, symbols used, mean color) are used
for the export. Note that the 'typeGraph' argument can be used to
export the graph in a format different than 'bmp'.</p>
</dd>
<dt>objectName-Cx-y-TrajMean.bmp</dt><dd><p>Graph representing the
means trajectories of each clusterss. All the parameters set during the visualization (color
of the trajectories, symbols used, mean color) are used
for the export.</p>
</dd>
</dl>

<p>This four file are created for each selected Partition. In addition, two
'global' graphes are created :
</p>

<dl>
<dt>objectName-criterionActif.bmp</dt><dd><p>Graph presenting the values of
the criterionActifall for all the Partition.</p>
</dd>
<dt>objectName-criterionAll.bmp</dt><dd><p>For each cluster's number, the
first Partition is considered. This graph presents on a single
display the values of all the criterion
for each first Partition. It is helpfull to compare the various qualities
criterion.</p>
</dd>
</dl>



<h3>Value</h3>

<p>For each selected <code>Partition</code>, four files are saved, plus two global files.</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+kml-package">kml-package</a></code> <br />
Classes : <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>, 

<code>Partition</code> in package longitudinalData <br />
Methods : <code><a href="#topic+kml">kml</a></code><br />
Plot : <code><a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

### Creation of artificial data
cld1 &lt;- gald(25)

### Clusterisation
kml(cld1,3:5,nbRedrawing=2,toPlot='both')

### Selection of the clustering we want
#     (note that "try" is for compatibility with CRAN only,
#     you probably can use "choice(cld1)")
try(choice(cld1))

### Go back to current dir
setwd(wd)
</code></pre>

<hr>
<h2 id='clusterLongData'> ~ Function: clusterLongData (or cld) ~</h2><span id='topic+cld'></span><span id='topic+clusterLongData'></span><span id='topic+clusterLongData+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+clusterLongData+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>clusterLongData</code> (or <code>cld</code> in short) is the constructor
for <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterLongData(traj, idAll, time, timeInData, varNames, maxNA)
cld(traj, idAll, time, timeInData, varNames, maxNA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterLongData_+3A_traj">traj</code></td>
<td>
<p><code>[matrix(numeric)]</code> or <code>[data.frame]</code>:
structure containning the trajectories. Each line is the trajectory
of an individual. The columns refer to the time during which
measures were made.</p>
</td></tr>
<tr><td><code id="clusterLongData_+3A_idall">idAll</code></td>
<td>
<p><code>[vector(character)]</code>: single identifier for each
trajectory (ie each individual). Note that the identifiers are of type
<code>character</code> (that allow to deal identifiers like <code>XUK32-612</code>,
identifiers that our favorite epidemiologists are so good at
providing). If <code>idAll</code> are <code>numeric</code>, they are converted into <code>characters</code>.</p>
</td></tr>
<tr><td><code id="clusterLongData_+3A_time">time</code></td>
<td>
<p><code>[vector(numeric)]</code>: time at which measures were made.</p>
</td></tr>
<tr><td><code id="clusterLongData_+3A_timeindata">timeInData</code></td>
<td>
<p><code>[vector(numeric)]</code>: precise the column
containing the trajectories.</p>
</td></tr>
<tr><td><code id="clusterLongData_+3A_varnames">varNames</code></td>
<td>
<p><code>[character]</code>: name of the variable being measured.</p>
</td></tr>
<tr><td><code id="clusterLongData_+3A_maxna">maxNA</code></td>
<td>
<p><code>[numeric]</code>: maximum number of NA that are tolerates
on a trajectory. If a trajectory has more
missing than <code>maxNA</code>, then it is remove from the analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clusterLongData</code> construct a object of class <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>.
Two cases can be distinguised:
</p>

<dl>
<dt><code>traj</code> is an <code>array</code>:</dt><dd><p> lines are individual. Column
are time of measurment.
</p>
<p>If <code>idAll</code> is missing, the individuals are labelled <code>i1</code>,
<code>i2</code>, <code>i3</code>,...
</p>
<p>If <code>timeInData</code> is missing, all the column
are used (<code>timeInData=1:ncol(traj)</code>).</p>
</dd>
<dt>If <code>traj</code> is a <code>data.frame</code>:</dt><dd><p> lines are
individual. Column are time of measurement.
</p>
<p>If <code>idAll</code> is missing, then the first column of the
<code>data.frame</code> is used for <code>idAll</code>
</p>
<p>If <code>timeInData</code> is missing and <code>idAll</code> is missing, then
all the columns but the first are used for <code>timeInData</code> (the
first is omited since it is already used for <code>idAll</code>): <code>idAll=traj[,1],timeInData=2:ncol(traj)</code>.
</p>
<p>If <code>timeInData</code> is missing but <code>idAll</code> is not missing,
then all the column including the first are used for <code>timeInData</code>: <code>timeInData=1:ncol(traj)</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+kml-package">kml-package</a></code> <br />
Classes : <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> <br />
Methods : <code><a href="#topic+choice">choice</a></code>, <code><a href="#topic+kml">kml</a></code><br />
Plot : <code><a href="#topic+plot">plot(ClusterLongData)</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
### From matrix

### Small data
mat &lt;- matrix(c(1,NA,3,2,3,6,1,8,10),3,3,dimnames=list(c(101,102,104),c("T2","T4","T8")))
clusterLongData(mat)
(ld1 &lt;- clusterLongData(traj=mat,idAll=as.character(c(101,102,104)),time=c(2,4,8),varNames="V"))
plot(ld1)

### Big data
mat &lt;- matrix(runif(1051*325),1051,325)
(ld2 &lt;- clusterLongData(traj=mat,idAll=paste("I-",1:1051,sep=""),time=(1:325)+0.5,varNames="R"))

####################
### From data.frame

dn &lt;- data.frame(id=1:3,v1=c(NA,2,1),v2=c(NA,1,0),v3=c(3,2,2),v4=c(4,2,NA))

### Basic
clusterLongData(dn)

### Selecting some times
(ld3 &lt;- clusterLongData(dn,timeInData=c(1,2,4),varNames=c("Hyp")))

### Excluding trajectories with more than 1 NA
(ld3 &lt;- clusterLongData(dn,maxNA=1))
</code></pre>

<hr>
<h2 id='ClusterLongData-class'>~ Class: ClusterLongData ~</h2><span id='topic+ClusterLongData-class'></span><span id='topic++5B+3C-+2CClusterLongData+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CClusterLongData-method'></span><span id='topic+is.na+2CClusterLongData-method'></span>

<h3>Description</h3>

<p><code>ClusterLongData</code> is an object containing trajectories and associated 



<code>Partition</code> (from package LongitudinalData).
</p>


<h3>Objects from the Class</h3>

<p><code><a href="#topic+kml">kml</a></code> is an algorithm that builds a set of 

<code>Partition</code> 
from longitudinal data. <code>ClusterLongData</code>
is the object containing the original longitudinal data 
and all the <code>Partition</code> that <code>kml</code> finds.<br />
</p>
<p>When created, an <code>ClusterLongData</code> object simply contains initial
data (the trajectories). After the execution of <code>kml</code>, it
contains
the original data and the <code>Partition</code> 

which has just been calculated by <code>kml</code>.
</p>
<p>Note that if <code>kml</code> is executed several times, every new <code>Partition</code>
is added to the original ones, no pre-existing <code>Partition</code> is erased.
</p>


<h3>Slots</h3>


<dl>
<dt><code>idAll</code></dt><dd><p><code>[vector(character)]</code>: Single identifier
for each of the trajectory (each individual). Usefull for exporting clusters.</p>
</dd>
<dt><code>idFewNA</code></dt><dd><p><code>[vector(character)]</code>: Restriction of
<code>idAll</code> to the trajectories that does not have 'too many' missing
value. See <code>maxNA</code> for details.</p>
</dd>
<dt><code>time</code></dt><dd><p><code>[numeric]</code>: Time at which measures are made.</p>
</dd>
<dt><code>varNames</code></dt><dd><p><code>[character]</code>: Name of the variable measured.</p>
</dd>
<dt><code>traj</code></dt><dd><p><code>[matrix(numeric)]</code>: Contains
the longitudianl data. Each lines is the trajectories of an
individual. Each column is the time at which measures
are made.</p>
</dd>
<dt><code>dimTraj</code></dt><dd><p><code>[vector2(numeric)]</code>: size of the matrix
<code>traj</code> (ie <code>dimTraj=c(length(idFewNA),length(time))</code>).</p>
</dd>
<dt><code>maxNA</code></dt><dd><p><code>[numeric]</code> or <code>[vector(numeric)]</code>:
Individual whose trajectories contain 'too many' missing value
are exclude from <code>traj</code> and will no be use in
the analysis. Their identifier is preserved in <code>idAll</code> but
not in <code>idFewNA</code>. 'too many' is define by <code>maxNA</code>: a
trajectory with more missing than <code>maxNA</code> is exclude.</p>
</dd>
<dt><code>reverse</code></dt><dd><p><code>[matrix(numeric)]</code>: if the trajectories
are scale using the function <code><a href="base.html#topic+scale">scale</a></code>, the 'scaling
parameters' (probably mean and standard deviation) are saved in
<code>reverse</code>. This is usefull to restaure the original data after a
scaling operation.</p>
</dd>
<dt><code>criterionActif</code></dt><dd><p>[character]: Store the criterion name
that will be used by functions that need a single criterion
(like <a href="longitudinalData.html#topic+plotCriterion">plotCriterion</a> or <a href="base.html#topic+ordered">ordered</a>).</p>
</dd>
<dt><code>initializationMethod</code></dt><dd><p>[vector(chararcter)]: list all
the initialization method that has already been used to find some
<code>Partition</code>
(usefull to not run several time a deterministic method).</p>
</dd>
<dt><code>sorted</code></dt><dd><p><code>[logical]</code>: are the <code>Partition</code>
curently hold in the object sorted in decreasing order ?</p>
</dd>
<dt><code>c1</code></dt><dd><p>[list(Partition)]: list of
<code>Partition</code> with 1 clusters.</p>
</dd>
<dt><code>c2</code></dt><dd><p>[list(Partition)]: list of
<code>Partition</code> with 2 clusters.</p>
</dd>
<dt><code>c3</code></dt><dd><p>[list(Partition)]: list of
<code>Partition</code> with 3 clusters.</p>
</dd>
<dt><code>...</code></dt><dd></dd>
<dt><code>c26</code></dt><dd><p>[list(Partition)]: list of
<code>Partition</code> with 26 clusters.</p>
</dd>
</dl>



<h3>Extends</h3>



<p>Class <code>LongData</code>, directly.
Class <code>ListPartition</code>, directly.
</p>


<h3>Construction</h3>

<p>Class <code>ClusterizLongData</code> objects can be constructed via function
<code><a href="#topic+clusterLongData">clusterLongData</a></code> that turn a <code>data.frame</code> or a <code>matrix</code>
into a <code>ClusterLongData</code>. Note that some artificial data can be
generated using <code><a href="#topic+gald">gald</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>object['xxx']</code></dt><dd><p>Get the value of the field
<code>xxx</code>. Inherit from <code>LongData</code> and <code>ListPartition</code>.


</p>
</dd>
<dt><code>object['xxx']&lt;-value</code></dt><dd><p>Set the field <code>xxx</code> to <code>value</code>.
<code>xxx</code>. Inherit from class <code>ListPartition</code>.

</p>
</dd>
<dt><code><a href="#topic+plot+2CClusterLongData">plot</a></code></dt><dd><p>Display the
<code>ClusterLongData</code> according to a class <code>Partition</code>.

</p>
</dd>
</dl>



<h3>Special thanks</h3>

<p>Special thanks to Boris Hejblum for debugging the '[' and '[&lt;-' operators (the
previous version was not compatible with the matrix package, which is
used by lme4).
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+kml-package">kml-package</a></code> <br />
Classes : 



classes Partition, LongData, ListPartition  <br />
Methods : <code><a href="#topic+clusterLongData">clusterLongData</a></code>, <code><a href="#topic+kml">kml</a></code>, <code><a href="#topic+choice">choice</a></code><br />
Plot : <code><a href="#topic+plot">plot(ClusterLongData)</a></code>,
<code><a href="longitudinalData.html#topic+plotCriterion">plotCriterion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

################
### Creation of some trajectories

traj &lt;- matrix(c(1,2,3,1,4, 3,6,1,8,10, 1,2,1,3,2, 4,2,5,6,3, 4,3,4,4,4, 7,6,5,5,4),6)

myCld &lt;- clusterLongData(
    traj=traj,
    idAll=as.character(c(100,102,103,109,115,123)),
    time=c(1,2,4,8,15),
    varNames="P",
    maxNA=3
)

################
### get and set
myCld["idAll"]
myCld["varNames"]
myCld["traj"]

################
### Creation of a Partition
part2 &lt;- partition(clusters=rep(1:2,3),myCld)
part3 &lt;- partition(clusters=rep(1:3,2),myCld)


################
### Adding a clusterization to a clusterizLongData
myCld["add"] &lt;- part2
myCld["add"] &lt;- part3
myCld

### Go back to current dir
setwd(wd)
</code></pre>

<hr>
<h2 id='epipageShort'>~ Data: epipageShort ~</h2><span id='topic+epipageShort'></span>

<h3>Description</h3>

<p>A subset of the longitudinal study EPIPAGE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(epipageShort)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>id</code></dt><dd><p>unique idenfier for each patient.</p>
</dd>
<dt><code>gender</code></dt><dd><p>Male or Female.</p>
</dd>
<dt><code>sdq3</code></dt><dd><p> score of the Strengths and Difficulties Questionnaire at 3 years old.</p>
</dd>
<dt><code>sdq4</code></dt><dd><p> score of the Strengths and Difficulties Questionnaire at 4 years old.</p>
</dd>
<dt><code>sdq5</code></dt><dd><p> score of the Strengths and Difficulties Questionnaire at 5 years old.</p>
</dd>
<dt><code>sdq8</code></dt><dd><p> score of the Strengths and Difficulties Questionnaire at 8 years old.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The EPIPAGE cohort, funded by INSERM and the French general health
authority, is a multi-regional French follow-up survey of severely
premature children. It included more than 4000 children born at less
than 33 weeks gestational age, and two control samples of children,
respectively born at 33-34 weeks of gestational age and born full
term. The general objectives were to study short and long term motor,
cognitive and behavioural outcomes in these children, and to determine
the impact of medical practice, care provision and organization of
perinatal care, environment, family circle and living conditions on
child health and development. About 2600 children born severely
premature and 400 and 600 controls respectively were followed up to
the age of 5 years and then to the age of 8.
</p>
<p>The SDQ is a behavioral questionnaire for children and adolescents
ages 4 through 16 years old. It measures the severity of the
disability (higher score indicate higher disability). 
</p>
<p>The database belongs to the INSERM unit U953 (P.Y. Ancel).
which has agreed to include the variable SDQ in the library.
</p>


<h3>References</h3>


<dl>
<dt>[lar08]</dt><dd><p>Larroque B, Ancel P, Marret S, Marchand L, André M, Arnaud C, Pierrat V, Rozé J, Messer J, Thiriez
G, et al. (2008). &quot;Neurodevelopmental disabilities and special care of 5-year-old children born
before 33 weeks of gestation (the EPIPAGE study): a longitudinal cohort study.&quot; The Lancet,
371(9615), 813-820.</p>
</dd>
<dt>[lau11]</dt><dd><p>Laurent C, Kouanfack C, Laborde-Balen G, Aghokeng A, Mbougua J, Boyer S, Carrieri M, Mben J,
Dontsop M, Kazé S, et al. (2011). &quot;Monitoring of HIV viral loads, CD4 cell counts, and clinical
assessments versus clinical monitoring alone for antiretroviral therapy in rural district hospitals
in Cameroon (Stratall ANRS 12110/ESTHER): a randomised non-inferiority trial.&quot; The Lancet
Infectious Diseases, 11(11), 825-833.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(epipageShort)
str(epipageShort)
</code></pre>

<hr>
<h2 id='fuzzyKmlSlow'>~ Algorithm fuzzy kml: Fuzzy k-means for Longitidinal data ~</h2><span id='topic+fuzzyKmlSlow'></span>

<h3>Description</h3>

<p><code>fuzzyKmlSlow</code> is a new implementation of fuzzy k-means for longitudinal data (or trajectories).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzyKmlSlow(traj, clusterAffectation, toPlot = "traj",
   fuzzyfier = 1.25, parAlgo = parALGO())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzyKmlSlow_+3A_traj">traj</code></td>
<td>
<p><code>[matrix(numeric)]</code>: Matrix holding the longitudinal data</p>
</td></tr>
<tr><td><code id="fuzzyKmlSlow_+3A_clusteraffectation">clusterAffectation</code></td>
<td>
<p><code>[vector(numeric)]</code>: Initial starting condition</p>
</td></tr>
<tr><td><code id="fuzzyKmlSlow_+3A_toplot">toPlot</code></td>
<td>
<p><code>[character]</code>: if &quot;traj&quot;,
then the trajectories are plot. If &quot;none&quot;, there is no graphical
display (faster).</p>
</td></tr>
<tr><td><code id="fuzzyKmlSlow_+3A_fuzzyfier">fuzzyfier</code></td>
<td>
<p><code>[numeric]</code>: value of the fuzzy k-means algorithm fuzzyfier.</p>
</td></tr>
<tr><td><code id="fuzzyKmlSlow_+3A_paralgo">parAlgo</code></td>
<td>
<p><code>[<a href="#topic+ParKml-class">ParKml</a>]</code>: default parameters for
the algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fuzzyKmlSlow</code> is a new implementation of fuzzy k-means for
longitudinal data (or trajectories). To date, it is writen in R (and
not in C, this explain the &quot;slow&quot;)
</p>


<h3>Value</h3>

<p>The matrix of the individual membership.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kml">kml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Data generation
traj &lt;- gald(25)["traj"]
partInit &lt;- initializePartition(3,100,"kmeans--",traj)

### fuzzy Kml
partResult &lt;- fuzzyKmlSlow(traj,partInit)
</code></pre>

<hr>
<h2 id='generateArtificialLongData'>~ Function: generateArtificialLongData (or gald) ~</h2><span id='topic+gald'></span><span id='topic+generateArtificialLongData'></span>

<h3>Description</h3>

<p>This function builp up an artificial longitudinal data set (single
variable-trajectory) an turn it
into an object of class <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gald(nbEachClusters=50,time=0:10,varNames="V",
    meanTrajectories=list(function(t){0},function(t){t},
       function(t){10-t},function(t){-0.4*t^2+4*t}),
    personalVariation=function(t){rnorm(1,0,2)},
    residualVariation=function(t){rnorm(1,0,2)},
    decimal=2,percentOfMissing=0)


generateArtificialLongData(nbEachClusters=50,time=0:10,varNames="V",
    meanTrajectories=list(function(t){0},function(t){t},
       function(t){10-t},function(t){-0.4*t^2+4*t}),
    personalVariation=function(t){rnorm(1,0,2)},
    residualVariation=function(t){rnorm(1,0,2)},
    decimal=2,percentOfMissing=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateArtificialLongData_+3A_nbeachclusters">nbEachClusters</code></td>
<td>
<p>[numeric] or [vector(numeric)]: number of trajectories that each
cluster must contain. If a single
number is given, it is duplicated for all groups.</p>
</td></tr>
<tr><td><code id="generateArtificialLongData_+3A_time">time</code></td>
<td>
<p>[vector(numeric)]: time at which measures are made.</p>
</td></tr>
<tr><td><code id="generateArtificialLongData_+3A_varnames">varNames</code></td>
<td>
<p>[character]: name of the variable.</p>
</td></tr>
<tr><td><code id="generateArtificialLongData_+3A_meantrajectories">meanTrajectories</code></td>
<td>
<p>[list(function)]: lists the functions
define the average trajectories of each cluster.</p>
</td></tr>
<tr><td><code id="generateArtificialLongData_+3A_personalvariation">personalVariation</code></td>
<td>
<p>[function] or [list(function)]: lists the functions
defining the personnal variation between an individual and the mean
trajectories of its cluster. Note that these function should be
constant function (the personal variation can not evolve with time). If
a single function is given, it is duplicated for all groups (see detail).</p>
</td></tr>
<tr><td><code id="generateArtificialLongData_+3A_residualvariation">residualVariation</code></td>
<td>
<p>[function] or [list(function)]: lists the functions
generating the noise of each trajectory within its own cluster. If
a single function is given, it is duplicated for all groups (see detail).</p>
</td></tr>
<tr><td><code id="generateArtificialLongData_+3A_decimal">decimal</code></td>
<td>
<p>[numeric]: number of decimals used to round up values.</p>
</td></tr>
<tr><td><code id="generateArtificialLongData_+3A_percentofmissing">percentOfMissing</code></td>
<td>
<p>[numeric]: percentage (between 0 and 1)
of missing data generated in each cluster. If a single value is
given, it is duplicated for all groups. The missing values are
Missing Completly At Random (MCAR).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generateArtificialLongData</code> (<code>gald</code> in short) is a
function that contruct a set of artificial longitudinal data.
Each individual is considered as belonging to a group. This group
follows a theoretical trajectory, function of time. These functions (one per group) are given via the argument <code>meanTrajectories</code>.
</p>
<p>Within a group, the individual undergoes individal variations. Individual variations are given via the argument <code>residualVariation</code>.
</p>
<p>The number of individuals in each group is given by <code>nbEachClusters</code>.
</p>
<p>Finally, it is possible to add missing values randomly (MCAR) striking the
data thanks to <code>percentOfMissing</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>.
</p>


<h3>Author</h3>

<p>Christophe Genolini<br />
1. UMR U1027, INSERM, Université Paul Sabatier / Toulouse III / France<br />
2. CeRSME, EA 2931, UFR STAPS, Université de Paris Ouest-Nanterre-La Défense / Nanterre / France
</p>


<h3>References</h3>

<p>[1] C. Genolini and B. Falissard<br />
&quot;KmL: k-means for longitudinal data&quot;<br />
Computational Statistics, vol 25(2), pp 317-328, 2010<br />
</p>
<p>[2] C. Genolini and B. Falissard<br />
&quot;KmL: A package to cluster longitudinal data&quot;<br />
Computer Methods and Programs in Biomedicine, 104, pp e112-121, 2011<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>, <code><a href="#topic+clusterLongData">clusterLongData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(ask=TRUE)


#####################
### Default example

(ex1 &lt;- generateArtificialLongData())
plot(ex1)
plot(ex1,parTraj=parTRAJ(col=rep(2:5,each=50)))


#####################
### Three diverging lines

ex2 &lt;- generateArtificialLongData(meanTrajectories=list(function(t)0,function(t)-t,function(t)t))
plot(ex2,parTraj=parTRAJ(col=rep(2:4,each=50)))


#####################
### Three diverging lines with high variance, unbalance groups and missing value

ex3 &lt;- generateArtificialLongData(
   meanTrajectories=list(function(t)0,function(t)-t,function(t)t),
   nbEachClusters=c(100,30,10),
   residualVariation=function(t){rnorm(1,0,3)},
   percentOfMissing=c(0.25,0.5,0.25)
)
part3 &lt;- partition(rep(1:3,c(100,30,10)))
plot(ex3,parTraj=parTRAJ(col=rep(2:4,c(100,30,10))))


#####################
### Four strange functions

ex4 &lt;- generateArtificialLongData(
    nbEachClusters=c(300,200,100,100),
    meanTrajectories=list(function(t){-10+2*t},function(t){-0.6*t^2+6*t-7.5},
       function(t){10*sin(t)},function(t){30*dnorm(t,2,1.5)}),
    residualVariation=function(t){rnorm(1,0,3)},
    time=0:10,decimal=2,percentOfMissing=0.3)
plot(ex4,parTraj=parTRAJ(col=rep(2:5,c(300,200,100,100))))


#####################
### To get only longData (if you want some artificial longData
###    to deal with another algorithm), use the getteur ["traj"]

ex5 &lt;- gald(nbEachCluster=3,time=1:3)
ex5["traj"]

par(ask=FALSE)
</code></pre>

<hr>
<h2 id='getBestPostProba'>
~ Function: getBestPostProba ~
</h2><span id='topic+getBestPostProba'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> object that hold a
<code>Partition</code>, this function extract the best
posterior probability of each individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBestPostProba(xCld, nbCluster, clusterRank = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBestPostProba_+3A_xcld">xCld</code></td>
<td>
<p><code>[ClusterLongData]</code>: object from who a cluster should
be extracted.</p>
</td></tr>
<tr><td><code id="getBestPostProba_+3A_nbcluster">nbCluster</code></td>
<td>
<p><code>[integer]</code>: number of cluster of the desired cluster.</p>
</td></tr>
<tr><td><code id="getBestPostProba_+3A_clusterrank">clusterRank</code></td>
<td>
<p><code>[integer]</code>: rank of the partition in the
clusters list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> object that hold a
<code>Partition</code>, this function extract the best
posterior probability of each individual.
</p>


<h3>Value</h3>

<p>A vector of numeric.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

### Creation of an object ClusterLongData
myCld &lt;- gald(20)

### Computation of some partition
kml(myCld,2:4,3)

### Extraction the best posterior probabilities
### form the list of partition with 3 clusters of the second clustering
getBestPostProba(myCld,3,2)

### Go back to current dir
setwd(wd)
</code></pre>

<hr>
<h2 id='getClusters'>
~ Function: getClusters ~
</h2><span id='topic+getClusters'></span>

<h3>Description</h3>

<p>This function extract a cluster affectation from an
<code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusters(xCld, nbCluster, clusterRank = 1, asInteger = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getClusters_+3A_xcld">xCld</code></td>
<td>
<p><code>[ClusterLongData]</code>: object from who a cluster should
be extracted.</p>
</td></tr>
<tr><td><code id="getClusters_+3A_nbcluster">nbCluster</code></td>
<td>
<p><code>[integer]</code>: number of cluster of the desired cluster.</p>
</td></tr>
<tr><td><code id="getClusters_+3A_clusterrank">clusterRank</code></td>
<td>
<p><code>[integer]</code>: rank of the partition in the
clusters list.</p>
</td></tr>
<tr><td><code id="getClusters_+3A_asinteger">asInteger</code></td>
<td>
<p><code>[logical]</code>: should the cluster be given as a
vector of integer ? If FALSE, a vector of LETTERS is return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extract a clusters from an object
<code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>.
It is almost the same as
<code>xCld[paste("c",nbCluster,sep="")][[clusterRank]]</code> except that
the individual with too many missing value (and thus excludes from the
analysis) will be noted by some NA values.
</p>


<h3>Value</h3>

<p>A vector of numeric or a LETTER, according to the value of <code>asInteger</code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

### Creation of an object ClusterLongData
myCld &lt;- gald(20)

### Computation of some partition
kml(myCld,2:4,3)

### Extraction form the list of partition with 3 clusters
###   of the second clustering
getClusters(myCld,3,2)

### Go back to current dir
setwd(wd)
</code></pre>

<hr>
<h2 id='kml'>~ Algorithm kml: K-means for Longitidinal data ~</h2><span id='topic+kml'></span><span id='topic+kml+2CClusterLongData-method'></span>

<h3>Description</h3>

<p><code>kml</code> is a implementation of k-means for longitudinal data (or trajectories). This algorithm is able to deal with missing value and
provides an easy way to re roll the algorithm several times, varying the starting conditions and/or the number of clusters looked for.
</p>
<p>Here is the description of the algorithm. For an overview of the package, see <a href="#topic+kml-package">kml-package</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kml(object,nbClusters=2:6,nbRedrawing=20,toPlot="none",parAlgo=parALGO())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kml_+3A_object">object</code></td>
<td>
<p>[ClusterLongData]: contains trajectories to cluster as
well as previous <code>Partition</code>.</p>
</td></tr>
<tr><td><code id="kml_+3A_nbclusters">nbClusters</code></td>
<td>
<p>[vector(numeric)]: Vector containing the number of clusters
with which <code>kml</code> must work. By default,
<code>nbClusters</code> is <code>2:6</code> which indicates that <code>kml</code> must
search partitions with respectively 2, then 3, ... up to 6
clusters. Maximum number of cluster is 26.</p>
</td></tr>
<tr><td><code id="kml_+3A_nbredrawing">nbRedrawing</code></td>
<td>
<p>[numeric]: Sets the number of time that k-means
must be re-run (with different starting conditions) for each number of clusters.</p>
</td></tr>
<tr><td><code id="kml_+3A_toplot">toPlot</code></td>
<td>
<p><code>[character]</code>: either 'traj' for plotting
trajectories alone, 'criterion' for plotting criterion alone,
'both' for plotting both or 'none' for not display anything (faster).</p>
</td></tr>
<tr><td><code id="kml_+3A_paralgo">parAlgo</code></td>
<td>
<p><code>[<a href="#topic+ParKml-class">ParKml</a>]</code>: parameters used to run
the algorithm. They can be change using the function
<code><a href="#topic+parKml">parKml</a></code>. Option are mainly 'saveFreq', 'maxIt',
'imputationMethod', 'distance' and 'startingCondition'. See
<a href="#topic+ParKml-class">ParKml</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kml</code> works on object of class <code>ClusterLongData</code>.
For each number included in <code>nbClusters</code>, <code>kml</code> computes a
<code>Partition</code> then stores it in the field
<code>cX</code> of the object <code>ClusterLongData</code> according to the number
of clusters 'X'.   The algorithm starts over as many times as it is told in <code>nbRedrawing</code>. By default, it is executed for 2,
3, 4, 5 and 6 clusters 20 times each, namely 100 times.
</p>
<p>When a <code>Partition</code> has been found, it is added to the
corresponding slot c1,
c2, c3, ... or c26. The sublist cX stores the all <code>Partition</code> with
X clusters. Inside a sublist, the
<code>Partition</code> can be sorted from the biggest quality criterion to
the smallest (the best are stored first, using
<code>ordered,ListPartition</code>), or not.
</p>
<p>Note that <code>Partition</code> are saved throughout the algorithm. If the user
interrupts the execution of <code>kml</code>, the result is not lost. If the
user run <code>kml</code> on an object, then runnig <code>kml</code> again on the same object
will add some new <code>Partition</code> to the one already found.
</p>
<p>The possible starting conditions are defined in <code><a href="longitudinalData.html#topic+initializePartition">initializePartition</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> object, after having added
some <code>Partition</code> to it.
</p>


<h3>Optimisation</h3>

<p>Behind kml, there are two different procedures :
</p>

<ol>
<li><p> Fast: when the parameter <code>distance</code> is set to &quot;euclidean&quot;
and <code>toPlot</code> is set to 'none' or
'criterion', <code>kml</code> call a C
compiled (optimized) procedure.
</p>
</li>
<li><p> Slow: when the user defines its own distance or if he wants
to see the construction of the clusters by setting <code>toPlot</code> to
'traj' or 'both', <code>kml</code> uses a R non compiled
programmes.
</p>
</li></ol>

<p>The C prodecure is 25 times faster than the R one.
</p>
<p>So we advice to use the R procedure 1/ for trying some new method
(like using a new distance) or 2/ to &quot;see&quot; the very first clusters
construction, in order to check that every thing goes right. Then it
is better to
switch to the C procedure (like we do in <code>Example</code> section).
</p>
<p>If for a specific use, you need a different distance, feel free to
contact the author.
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+kml-package">kml-package</a></code> <br />
Classes : <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>, 

<code>Partition</code> in package longitudinalData <br />
Methods : <code><a href="#topic+clusterLongData">clusterLongData</a></code>, <code><a href="#topic+choice">choice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

### Generation of some data
cld1 &lt;- generateArtificialLongData(25)

### We suspect 3, 4 or 6 clusters, we want 3 redrawing.
###   We want to "see" what happen (so printCal and printTraj are TRUE)
kml(cld1,c(3,4,6),3,toPlot='both')

### 4 seems to be the best. We want 7 more redrawing.
###   We don't want to see again, we want to get the result as fast as possible.
kml(cld1,4,10)

### Go back to current dir
setwd(wd)

</code></pre>

<hr>
<h2 id='kml-internal'>~ Internal KmL objects and methods ~</h2><span id='topic+kmlFast'></span><span id='topic+plotLegend'></span><span id='topic+legendCol'></span><span id='topic+expandStartingCond'></span><span id='topic+cutScreen'></span><span id='topic+fastOrSlow'></span><span id='topic+exportPartition'></span><span id='topic+choiceChangeParam'></span><span id='topic+partPermut'></span><span id='topic+exportPartition+2CClusterLongData+2Cnumeric'></span><span id='topic+exportPartition+2CClusterLongData+2Cnumeric-method'></span><span id='topic+ClusterLongData_choice'></span><span id='topic++5B+2CParChoice+2CANY-method'></span><span id='topic++5B+3C-+2CParChoice+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Internal: KmL objects and methods</p>


<h3>Details</h3>

<p>These are not to be called by the user.<br />
If you have a specific need or for more details on KmL, feel free to contact
the author
(who, even if he is very lazy , will be very happy to answer and - why not? -
start a new collaboration...)
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+kml-package">kml-package</a></code> <br />
</p>

<hr>
<h2 id='parKml'> ~ Function: parKml ~</h2><span id='topic+parKml'></span><span id='topic+parALGO'></span><span id='topic++5B+3C-+2CParKml+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CParKml+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p><code>parKml</code> and <code>parALGO</code> are constructor for the object <code><a href="#topic+ParKml-class">ParKml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parKml(saveFreq,maxIt,imputationMethod,distanceName,power,distance,
   centerMethod,startingCond,nbCriterion,scale)

parALGO(saveFreq=100,maxIt=200,imputationMethod="copyMean",
   distanceName="euclidean",power=2,distance=function(){},
   centerMethod=meanNA,startingCond="nearlyAll",nbCriterion=1000,scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parKml_+3A_savefreq">saveFreq</code></td>
<td>
<p><code>[numeric]</code>: Long computations can take several
days. So it is possible to save the object <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>
on which works <code><a href="#topic+kml">kml</a></code> once in a while. <code>saveFreq</code>
defines the frequency of the saving
process. The <code>ClusterLongData</code> is saved every <code>saveFreq</code>
clustering calculations. The object is saved in the file
<code>objectName.Rdata</code> in the curent folder. If <code>saveFreq</code> is
set to <code>Inf</code>, the object is never saved.
</p>
</td></tr>
<tr><td><code id="parKml_+3A_maxit">maxIt</code></td>
<td>
<p><code>[numeric]</code>: Set a limit to the number of iteration if
convergence is not reached.
</p>
</td></tr>
<tr><td><code id="parKml_+3A_imputationmethod">imputationMethod</code></td>
<td>
<p><code>[character]</code>: the calculation of quality
criterion can not be done if some value are
missing. <code>imputationMethod</code> define the method use to impute the
missing value. See <code><a href="longitudinalData.html#topic+imputation">imputation</a></code> for detail.
</p>
</td></tr>
<tr><td><code id="parKml_+3A_distancename">distanceName</code></td>
<td>
<p><code>[character]</code>: name of the
<code>distance</code> used by k-means. If the <code>distanceName</code> is one of
&quot;manhattan&quot;, &quot;euclidean&quot;, &quot;minkowski&quot;, &quot;maximum&quot;, &quot;canberra&quot; or
&quot;binary&quot;, a compiled optimized version specificaly design for
trajectories version is used. Otherwise, the function define in
the slot <code>distance</code> is used.
</p>
</td></tr>
<tr><td><code id="parKml_+3A_power">power</code></td>
<td>
<p><code>[numeric]</code>: If <code>distanceName="minkowski"</code>, this define
the power that will be used.
</p>
</td></tr>
<tr><td><code id="parKml_+3A_distance">distance</code></td>
<td>
<p><code>[numeric &lt;- function(trajA,trajB)]</code>: function that computes the
distance between two trajectories. If no function is specified, the Euclidian
distance with Gower adjustment (to deal with missing value) is
used.
</p>
</td></tr>
<tr><td><code id="parKml_+3A_centermethod">centerMethod</code></td>
<td>
<p><code>[numeric &lt;-
      function(vector(numeric))]</code>: k-means algorithm computes the centers of
each cluster. It is possible to personalize the definition of
&quot;center&quot; by defining a function &quot;centerMethod&quot;. This function should
take a vector of numeric as argument and return a single numeric -the
center of the vector-.
</p>
</td></tr>
<tr><td><code id="parKml_+3A_startingcond">startingCond</code></td>
<td>
<p><code>[character]</code>: specifies the starting
condition. Should be one of &quot;randomAll&quot;, &quot;randomK&quot;, &quot;maxDist&quot;,
&quot;kmeans++&quot;, &quot;kmeans+&quot;, &quot;kmeans-&quot; or &quot;kmeans&ndash;&quot; (see
<code><a href="longitudinalData.html#topic+initializePartition">initializePartition</a></code> for details). It
also could take two specifics values: &quot;all&quot; stands for
c(&quot;maxDist&quot;,&quot;kmeans-&quot;) then an alternance of &quot;kmeans&ndash;&quot; and
&quot;randomK&quot; while &quot;nearlyAll&quot; stands for
&quot;kmeans-&quot; then an alternance of &quot;kmeans&ndash;&quot; and &quot;randomK&quot;.
</p>
</td></tr>





<tr><td><code id="parKml_+3A_nbcriterion">nbCriterion</code></td>
<td>
<p><code>[numeric]</code>: set the maximum number of
quality criterion that are display on the graph (since displaying
a high criterion number an slow down the overall process). The
default value is 100.
</p>
</td></tr>
<tr><td><code id="parKml_+3A_scale">scale</code></td>
<td>
<p><code>[logical]</code>: if TRUE, then the data will be
automaticaly scaled (using the function <code><a href="base.html#topic+scale">scale</a></code> with
default values) before the execution of k-means on joint
trajectories. Then the data
will be restore (using the function <code><a href="longitudinalData.html#topic+restoreRealData">restoreRealData</a></code>)
just before the end of the function <code><a href="kml3d.html#topic+kml3d">kml3d</a></code>. This option
has no effect on <code><a href="#topic+kml">kml</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parKml</code> is the constructor of object <code><a href="#topic+ParKml-class">ParKml</a></code>.
</p>


<h3>Value</h3>

<p>An object <code><a href="#topic+ParKml-class">ParKml</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

### Generation of some data
cld1 &lt;- generateArtificialLongData()

### Setting two different set of option :
(option1 &lt;- parALGO())
(option2 &lt;- parALGO(distanceName="maximum",centerMethod=function(x)median(x,na.rm=TRUE)))

### Running kml We suspect 3, 4 or 5 clusters, we want 3 redrawing.
kml(cld1,3:5,3,toPlot="both",parAlgo=option1)
kml(cld1,3:5,3,toPlot="both",parAlgo=option2)

### Go back to current dir
setwd(wd)

</code></pre>

<hr>
<h2 id='ParKml-class'>~ Class: &quot;ParKml&quot; ~ </h2><span id='topic+ParKml-class'></span><span id='topic++5B+2CParKml-method'></span><span id='topic++5B+3C-+2CParKml-method'></span>

<h3>Description</h3>

<p><code>ParKml</code> is an object containing some parameter used by <code><a href="#topic+kml">kml</a></code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>saveFreq</code></dt><dd><p><code>[numeric]</code>: Long computations can take several
days. So it is possible to save the object <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code>
on which works <code><a href="#topic+kml">kml</a></code> once in a while. <code>saveFreq</code>
defines the frequency of the saving
process. The <code>ClusterLongData</code> is saved every <code>saveFreq</code>
clustering calculations. The object is saved in the file
<code>objectName.Rdata</code> in the curent folder. If <code>saveFreq</code> is
set to <code>Inf</code>, the object is never saved.
</p>
</dd>
<dt><code>maxIt</code>:</dt><dd><p><code>[numeric]</code>: Set a limit to the number of iteration if
convergence is not reached.
</p>
</dd>
<dt><code>imputationMethod</code>:</dt><dd><p><code>[character]</code>: the calculation of quality
criterion can not be done if some value are
missing. <code>imputationMethod</code> define the method use to impute the
missing value.
See <code><a href="longitudinalData.html#topic+imputation">imputation</a></code> for detail.
</p>
</dd>
<dt><code>distanceName</code>:</dt><dd><p><code>[character]</code>: name of the
<code>distance</code> used by k-means. If the <code>distanceName</code> is one of
&quot;manhattan&quot;, &quot;euclidean&quot;, &quot;minkowski&quot;, &quot;maximum&quot;, &quot;canberra&quot; or
&quot;binary&quot;, a compiled optimized version specificaly design for
trajectories version is used. Otherwise, the function define in
the slot <code>distance</code> is used.
</p>
</dd>
<dt><code>power</code>:</dt><dd><p><code>[numeric]</code>: If <code>distanceName="minkowski"</code>, this define
the power that will be used.
</p>
</dd>
<dt><code>distance</code>:</dt><dd><p><code>[numeric &lt;- function(trajA,trajB)]</code>: function that computes the
distance between two trajectories. This field is used only if
'distanceName' is not one of the classical function.
</p>
</dd>
<dt><code>centerMethod</code>:</dt><dd><p><code>[numeric &lt;-
	function(vector(numeric))]</code>: k-means algorithm computes the centers of
each cluster. It is possible to personalize the definition of
&quot;center&quot; by defining a function &quot;centerMethod&quot;. This function should
take a vector of numeric as argument and return a single numeric -the
center of the vector-.
</p>
</dd>
<dt><code>startingCond</code>:</dt><dd><p><code>[character]</code>: specifies the starting
condition. Should be one of &quot;randomAll&quot;, &quot;randomK&quot;, &quot;maxDist&quot;,
&quot;kmeans++&quot;, &quot;kmeans+&quot;, &quot;kmeans-&quot; or &quot;kmeans&ndash;&quot; (see
<code><a href="longitudinalData.html#topic+initializePartition">initializePartition</a></code> for details). It
also could take two specifics values: &quot;all&quot; stands for
c(&quot;maxDist&quot;,&quot;kmeans-&quot;) then an alternance of &quot;kmeans&ndash;&quot; and
&quot;randomK&quot; while &quot;nearlyAll&quot; stands for
&quot;kmeans-&quot; then an alternance of &quot;kmeans&ndash;&quot; and &quot;randomK&quot;.
</p>
</dd>




<dt><code>nbCriterion</code></dt><dd><p><code>[numeric]</code>: set the maximum number of
quality criterion that are display on the graph (since displaying
a high criterion number an slow down the overall process). The
default value is 100.
</p>
</dd>
<dt>scale</dt><dd><p><code>[logical]</code>: if TRUE, then the data will be
automaticaly scaled (using the function <code><a href="base.html#topic+scale">scale</a></code> with
default values) before the execution of k-means on joint
trajectories. Then the data
will be restore (using the function <code><a href="longitudinalData.html#topic+restoreRealData">restoreRealData</a></code>)
just before the end of the function <code><a href="kml3d.html#topic+kml3d">kml3d</a></code>. This option
has no effect on <code><a href="#topic+kml">kml</a></code>.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>object['xxx']</code></dt><dd><p>Get the value of the field <code>xxx</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

### Building data
myCld &lt;- gald()

### Standard kml
kml(myCld,,3,toPlot="both")

### Using median instead of mean
parWithMedian &lt;- parALGO(centerMethod=function(x){median(x,na.rm=TRUE)})
kml(myCld,,3,toPlot="both",parAlgo=parWithMedian)

### Using distance max
parWithMax &lt;- parALGO(distanceName="maximum")
kml(myCld,,3,toPlot="both",parAlgo=parWithMax)

### Go back to current dir
setwd(wd)

</code></pre>

<hr>
<h2 id='plot+2CClusterLongData'> ~ Function: plot for ClusterLongData ~ </h2><span id='topic+plot'></span><span id='topic+plot+2CClusterLongData'></span><span id='topic+plot+2CClusterLongData+2CANY-method'></span><span id='topic+plot+2CClusterLongData+2Cmissing-method'></span><span id='topic+plot+2CClusterLongData+2Cnumeric-method'></span><span id='topic+plot+2CClusterLongData+2CPartition-method'></span>

<h3>Description</h3>

<p><code>plot</code> the trajectories of an object 

<code>ClusterLongData</code> relatively to a <code>Partition</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ClusterLongData,ANY'
plot(x,y=NA,parTraj=parTRAJ(),parMean=parMEAN(),
   addLegend=TRUE, adjustLegend=-0.12,toPlot="both",criterion=x["criterionActif"],
   nbCriterion=1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2CClusterLongData_+3A_x">x</code></td>
<td>
<p><code>[ClusterLongData]</code>: Object containing the trajectories to plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CClusterLongData_+3A_y">y</code></td>
<td>
<p><code>[numeric]</code> or <code>[vector(numeric)]</code>: Give the <code>Partition</code>
to represent. If <code>y</code> is missing, the <code>Partition</code> with
the highest quality criterion (the actif one) is selected. If <code>y</code> is a number,
the first <code>Partition</code> of the sublist <code>c-y</code> is
selected. If <code>y</code> is a couple of numeric, the <code>y[2]</code>th
<code>Partition</code> of the sublist <code>c-y[1]</code> is selected.</p>
</td></tr>
<tr><td><code id="plot+2B2CClusterLongData_+3A_partraj">parTraj</code></td>
<td>
<p><code>[ParLongData]</code>: Specification of the plotting
parameters of the individual trajectories. Fields that can be changes are
'type','col','pch','xlab' and 'ylab'. In addition to the standard
possible values, the option <code>col="clusters"</code> can be use to color the individual
trajectories according to their clusters (exemple:
<code>parTraj=parTRAJ(type="o",col="clusters")</code>). See
<code>ParLongData</code> in package <code>longitudinalData</code> for details.</p>
</td></tr>
<tr><td><code id="plot+2B2CClusterLongData_+3A_parmean">parMean</code></td>
<td>
<p><code>[ParLongData]</code>: Specification of the plotting
parameters of the mean trajectories. Fields that can be changes are
'type','col','pch','pchPeriod' and 'cex'. See
<code>ParLongData</code> in package <code>longitudinalData</code> for details.</p>
</td></tr>
<tr><td><code id="plot+2B2CClusterLongData_+3A_toplot">toPlot</code></td>
<td>
<p><code>[character]</code>: either 'traj' for plotting
trajectories alone, 'criterion' for plotting criterion alone,
'both' for plotting both or 'none' for not display anything (faster).</p>
</td></tr>
<tr><td><code id="plot+2B2CClusterLongData_+3A_criterion">criterion</code></td>
<td>
<p><code>[character]</code> or <code>[vector(character)]</code>:
criterion to display (only if 'toPlot' is 'criterion' or 'both'). If
a single criterion is given, it will be display for all the
<code>Partition</code>. If several criterion are used, they will be display for
the first <code>Partition</code> for each clusters' numbers.</p>
</td></tr>
<tr><td><code id="plot+2B2CClusterLongData_+3A_nbcriterion">nbCriterion</code></td>
<td>
<p><code>[numeric]</code>: if a single criterion is given to
<code>criterion</code> (and thus is displayed for 'all' the
<code>Partition</code>), this slot alows to fix a limit on the number of
points that will be display.</p>
</td></tr>
<tr><td><code id="plot+2B2CClusterLongData_+3A_addlegend">addLegend</code></td>
<td>
<p><code>[logical]</code>: should the legend be displayed?</p>
</td></tr>
<tr><td><code id="plot+2B2CClusterLongData_+3A_adjustlegend">adjustLegend</code></td>
<td>
<p><code>[numeric]</code>: fix the hight of the legend</p>
</td></tr>
<tr><td><code id="plot+2B2CClusterLongData_+3A_...">...</code></td>
<td>
<p>Some other parameters can be passed to the method (like
&quot;xlab&quot; or &quot;ylab&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot</code> the trajectories of an object <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> relativly
to the 'best' <code>Partition</code>, or to the
<code>Partition</code> define by <code>y</code>.
</p>
<p>Graphical option concerning the individual trajectory (col, type, pch
and xlab) can be change using <code>parTraj</code>.
Graphical option concerning the cluster mean trajectory (col, type, pch,
pchPeriod and cex) can be change using <code>parMean</code>. For more
detail on  <code>parTraj</code> and  <code>parMean</code>, see object of
class <code>ParLongData</code> in package <code>longitudinalData</code>.
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+kml-package">kml-package</a></code> <br />
Classes : <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> <br />
Plot : <code><a href="#topic+plot">plot: overview</a></code>, <code><a href="longitudinalData.html#topic+plotCriterion">plotCriterion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

##################
### Construction of the data

ld &lt;- gald()

### Basic plotting
plot(ld)


##################
### Changing graphical parameters 'par'

kml(ld,3:4,1)

### No letters on the mean trajectories
plot(ld,3,parMean=parMEAN(type="l"))

### Only one letter on the mean trajectories
plot(ld,4,parMean=parMEAN(pchPeriod=Inf))

### Color individual according to its clusters (col="clusters")
plot(ld,3,parTraj=parTRAJ(col="clusters"))

### Mean without individual
plot(ld,4,parTraj=parTRAJ(type="n"))


### No mean trajectories (type="n")
### Color individual according to its clusters (col="clusters")
plot(ld,3,parTraj=parTRAJ(col="clusters"),parMean=parMEAN(type="n"))

### Only few trajectories
plot(ld,4,nbSample=10,parTraj=parTRAJ(col='clusters'),parMean=parMEAN(type="n"))

### Go back to current dir
setwd(wd)
</code></pre>

<hr>
<h2 id='plotMeans+2CClusterLongData'> ~ Function: plotMeans for ClusterLongData ~ </h2><span id='topic+plotMeans'></span><span id='topic+plotMeans+2CClusterLongData'></span><span id='topic+plotMeans+2CClusterLongData+2CANY-method'></span><span id='topic+plotMeans+2CClusterLongData+2Cmissing-method'></span><span id='topic+plotMeans+2CClusterLongData+2Cnumeric-method'></span><span id='topic+plotMeans+2CClusterLongData+2CPartition-method'></span>

<h3>Description</h3>

<p><code>plotMeans</code> plots the means' trajectories of an object 

<code>ClusterLongData</code> relatively to a <code>Partition</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ClusterLongData,ANY'
plotMeans(x,y,parMean=parMEAN(),
   parWin=windowsCut(x['nbVar'],addLegend=TRUE),...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMeans+2B2CClusterLongData_+3A_x">x</code></td>
<td>
<p><code>[ClusterLongData]</code>: Object containing the trajectories to plotMeans.</p>
</td></tr>
<tr><td><code id="plotMeans+2B2CClusterLongData_+3A_y">y</code></td>
<td>
<p><code>[numeric]</code> or <code>[vector(numeric)]</code>: Give the <code>Partition</code>
to represent. If <code>y</code> is a number,
the first <code>Partition</code> of the sublist <code>c-y</code> is
selected. If <code>y</code> is a couple of numeric, the <code>y[2]</code>th
<code>Partition</code> of the sublist <code>c-y[1]</code> is selected (so <code>y=c(2,3)</code> select the partition
with 2 clusters, the third one).</p>
</td></tr>
<tr><td><code id="plotMeans+2B2CClusterLongData_+3A_parmean">parMean</code></td>
<td>
<p><code>[ParLongData]</code>: Specification of the plotting
parameters of the mean trajectories. Fields that can be changes are
'type','col','pch','pchPeriod' and 'cex'. See
<code>ParLongData</code> in package <code>longitudinalData</code> for details.</p>
</td></tr>
<tr><td><code id="plotMeans+2B2CClusterLongData_+3A_parwin">parWin</code></td>
<td>
<p><code>[parWindows]</code>: Set the graphical display of
the windows. See <code>ParWindows</code> in package <code>longitudinalData</code> for details.</p>
</td></tr>
<tr><td><code id="plotMeans+2B2CClusterLongData_+3A_...">...</code></td>
<td>
<p>Some other parameters can be passed to the method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotMeans</code> plots the means' trajectories of an object <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> relativly
to the 'best' <code>Partition</code>, or to the
<code>Partition</code> define by <code>y</code>.
</p>
<p>Graphical option (col, type, pch,
pchPeriod and cex) can be change using <code>parMean</code>. For more
detail on  <code>parTraj</code> and  <code>parMean</code>, see object of
class <code>ParLongData</code> in package <code>longitudinalData</code>.
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+kml-package">kml-package</a></code> <br />
Classes : <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> <br />
PlotMeans : <code><a href="#topic+plotMeans">plotMeans: overview</a></code>, <code><a href="longitudinalData.html#topic+plotCriterion">plotCriterion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

##################
### Construction of the data

ld &lt;- gald(10)
kml(ld,3:4,2)

### Basic plotMeansting
plotMeans(ld,3)

### Go back to current dir
setwd(wd)
</code></pre>

<hr>
<h2 id='plotTraj+2CClusterLongData'> ~ Function: plotTraj for ClusterLongData ~ </h2><span id='topic+plotTraj'></span><span id='topic+plotTraj+2CClusterLongData+2CANY-method'></span><span id='topic+plotTraj+2CClusterLongData+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>plotTraj</code> plot the trajectories of an object 

<code>ClusterLongData</code> relatively to a <code>Partition</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ClusterLongData,ANY'
plotTraj(x,y,parTraj=parTRAJ(col="clusters"),
   parWin=windowsCut(x['nbVar'],addLegend=TRUE),nbSample=1000,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTraj+2B2CClusterLongData_+3A_x">x</code></td>
<td>
<p><code>[ClusterLongData]</code>: Object containing the trajectories to plotTraj.</p>
</td></tr>
<tr><td><code id="plotTraj+2B2CClusterLongData_+3A_y">y</code></td>
<td>
<p><code>[numeric]</code> or <code>[couple(numeric)]</code>: Give the <code>Partition</code>
to represent. If <code>y</code> is missing, the <code>Partition</code> with
the highest quality criterion (the actif one) is selected. If <code>y</code> is a number,
the first <code>Partition</code> of the sublist <code>c-y</code> is
selected. If <code>y</code> is a couple of numeric, the <code>y[2]</code>th
<code>Partition</code> of the sublist <code>c-y[1]</code> is selected (so <code>y=c(2,3)</code> select the partition
with 2 clusters, the third one).</p>
</td></tr>
<tr><td><code id="plotTraj+2B2CClusterLongData_+3A_partraj">parTraj</code></td>
<td>
<p><code>[ParLongData]</code>: Specification of the plotting
parameters of the individual trajectories. Fields that can be changes are
'type','col','pch','xlab' and 'ylab'. In addition to the standard
possible values, the option <code>col="clusters"</code> (the default) can be use to color the individual
trajectories according to their clusters (exemple:
<code>parTraj=parTRAJ(type="o",col="clusters")</code>). See
<code>ParLongData</code> in package <code>longitudinalData</code> for details.</p>
</td></tr>
<tr><td><code id="plotTraj+2B2CClusterLongData_+3A_parwin">parWin</code></td>
<td>
<p><code>[parWindows]</code>: Set the graphical display of
the windows. See <code>ParWindows</code> in package <code>longitudinalData</code> for details.</p>
</td></tr>
<tr><td><code id="plotTraj+2B2CClusterLongData_+3A_nbsample">nbSample</code></td>
<td>
<p><code>[numeric]</code>: Graphical display of huge sample can
be time consumming. This parameters fixe the maximum number of
trajectories (randomly chosen) that will be drawn.</p>
</td></tr>
<tr><td><code id="plotTraj+2B2CClusterLongData_+3A_...">...</code></td>
<td>
<p>Some other parameters can be passed to the method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotTraj</code> the trajectories of an object <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> relativly
to the 'best' <code>Partition</code>, or to the
<code>Partition</code> define by <code>y</code>.
</p>
<p>Graphical option (col, type, pch
and xlab) can be change using <code>parTraj</code>.
For more
detail on  <code>parTraj</code>, see object of
class <code>ParLongData</code> in package <code>longitudinalData</code> .
</p>


<h3>See Also</h3>

<p>Overview: <code><a href="#topic+kml-package">kml-package</a></code> <br />
Classes : <code><a href="#topic+ClusterLongData-class">ClusterLongData</a></code> <br />
PlotTraj : <code><a href="#topic+plotTraj">plotTraj: overview</a></code>, <code><a href="longitudinalData.html#topic+plotCriterion">plotCriterion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Move to tempdir
wd &lt;- getwd()
setwd(tempdir()); getwd()

##################
### Construction of the data

ld &lt;- gald()
kml(ld,3:4,1)

### Basic plotTrajting
plotTraj(ld,3)

### Go back to current dir
setwd(wd)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
