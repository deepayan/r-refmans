<!DOCTYPE html><html lang="en"><head><title>Help for package kbal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kbal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#b_maxvarK'><p>Maximum Variance of Gaussian Kernel Matrix</p></a></li>
<li><a href='#biasbound'><p>Worst-Case Bias Bound due to Incomplete Balance</p></a></li>
<li><a href='#dimw'><p>Difference in Means and Difference in Weighted Means</p></a></li>
<li><a href='#drop_multicollin'><p>Drop Multicollinear Columns</p></a></li>
<li><a href='#ebalance_custom'><p>Modified version of ebalance (originally from Jens Hainmueller)</p></a></li>
<li><a href='#getdist'><p>L1 Distance</p></a></li>
<li><a href='#getw'><p>Find Weights using Entropy Balancing.</p></a></li>
<li><a href='#kbal'><p>Kernel Balancing</p></a></li>
<li><a href='#lalonde'><p>Data from National Supported Work program and Panel Study in Income Dynamics</p></a></li>
<li><a href='#makeK'><p>Build the Gaussian Kernel Matrix</p></a></li>
<li><a href='#one_hot'><p>One-Hot Encoding for Categorical Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kernel Balancing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a weighting approach that employs kernels to make one group have a similar distribution to another group on covariates. This method matches not only means or marginal distributions but also higher-order transformations implied by the choice of kernel. 'kbal' is applicable to both treatment effect estimation and survey reweighting problems. Based on Hazlett, C. (2020) "Kernel Balancing: A flexible non-parametric weighting procedure for estimating causal effects." Statistica Sinica. <a href="https://www.researchgate.net/publication/299013953_Kernel_Balancing_A_flexible_non-parametric_weighting_procedure_for_estimating_causal_effects/stats">https://www.researchgate.net/publication/299013953_Kernel_Balancing_A_flexible_non-parametric_weighting_procedure_for_estimating_causal_effects/stats</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/chadhazlett/kbal">https://github.com/chadhazlett/kbal</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0), RcppParallel (&ge; 4.4.4), dplyr, RSpectra</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Borna Bateni &lt;borna@ucla.edu&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-14 01:23:38 UTC; borna</td>
</tr>
<tr>
<td>Author:</td>
<td>Chad Hazlett [aut, cph],
  Ciara Sterbenz [aut],
  Erin Hartman [ctb],
  Alex Kravetz [ctb],
  Borna Bateni [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 09:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='b_maxvarK'>Maximum Variance of Gaussian Kernel Matrix</h2><span id='topic+b_maxvarK'></span>

<h3>Description</h3>

<p>Searches for the argmax of the variance of the Kernel matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_maxvarK(data, useasbases, cat_data = TRUE, maxsearch_b = 2000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_maxvarK_+3A_data">data</code></td>
<td>
<p>a matrix of data where rows are all units and columns are covariates. Where all covariates are categorical, this matrix should be one-hot encoded (refer to <code><a href="#topic+one_hot">one_hot</a></code> to produce) with <code>cat_data</code> argument true.</p>
</td></tr>
<tr><td><code id="b_maxvarK_+3A_useasbases">useasbases</code></td>
<td>
<p>binary vector specifying what observations are to be used in forming bases (columns) of the kernel matrix. Suggested default is: if the number of observations is under 4000, use all observations; when the number of observations is over 4000, use the sampled (control) units only.</p>
</td></tr>
<tr><td><code id="b_maxvarK_+3A_cat_data">cat_data</code></td>
<td>
<p>logical for whether kernel contains only categorical data or not. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="b_maxvarK_+3A_maxsearch_b">maxsearch_b</code></td>
<td>
<p>the maximum value of <code class="reqn">b</code>, the denominator of the Gaussian, searched during maximization. Default is <code>2000</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>b_maxvar</code></td>
<td>
<p>numeric <code class="reqn">b</code> value, the denominator of the Gaussian, which produces the maximum variance of <code class="reqn">K</code> kernel matrix</p>
</td></tr>
<tr><td><code>var_K</code></td>
<td>
<p>numeric maximum variance of <code class="reqn">K</code> kernel matrix found with <code class="reqn">b</code> as <code>b_maxvar</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#lalonde with only categorical data
set.seed(123)
data("lalonde")
# Select a random subset of 500 rows
lalonde_sample &lt;- sample(1:nrow(lalonde), 500, replace = FALSE)
lalonde &lt;- lalonde[lalonde_sample, ]

cat_vars &lt;- c("black","hisp","married","nodegr","u74","u75")
#Convert to one-hot encoded data matrix:
onehot_lalonde = one_hot(lalonde[, cat_vars])
colnames(onehot_lalonde)
best_b &lt;- b_maxvarK(data = onehot_lalonde, 
                    useasbases = 1-lalonde$nsw) 
 
</code></pre>

<hr>
<h2 id='biasbound'>Worst-Case Bias Bound due to Incomplete Balance</h2><span id='topic+biasbound'></span>

<h3>Description</h3>

<p>Calculate the upper bound on the bias induced by approximate balance with a given <code>hilbertnorm</code>. Approximate balance is conducted in <code>kbal()</code> and uses only the first <code>numdims</code> dimensions of the singular value decomposition of the kernel matrix to generate weights <code>w</code> which produce mean balance between control or sampled units and treated or population units. The following function calculates the worse-case bias induced by this approximate balancing with weights <code>w</code> and a given <code>hilbertnorm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biasbound(observed, target, svd.out, w, w.pop = NULL, hilbertnorm = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biasbound_+3A_observed">observed</code></td>
<td>
<p>a numeric vector of length equal to the total number of units where sampled/control units take a value of 1 and population/treated units take a value of 0.</p>
</td></tr>
<tr><td><code id="biasbound_+3A_target">target</code></td>
<td>
<p>a numeric vector of length equal to the total number of units where population/treated units take a value of 1 and sample/control units take a value of 0.</p>
</td></tr>
<tr><td><code id="biasbound_+3A_svd.out">svd.out</code></td>
<td>
<p>the list object output from <code>svd()</code> performed on the kernel matrix. Requires a list object with left singular vectors in <code>svd.out$u</code> and singular values in <code>svd.out$d</code></p>
</td></tr>
<tr><td><code id="biasbound_+3A_w">w</code></td>
<td>
<p>numeric vector containing the weight for every corresponding unit. Note that these weights should sum to the total number of units, not to one. They are divided by the number of control or sample and treated or population units internally.</p>
</td></tr>
<tr><td><code id="biasbound_+3A_w.pop">w.pop</code></td>
<td>
<p>an optional vector input to specify population weights. Must be of length equal to the total number of units (rows in <code>svd.out</code>) with all sampled units receiving a weight of 1. The sum of the weights for population units must be either 1 or the number of population units.</p>
</td></tr>
<tr><td><code id="biasbound_+3A_hilbertnorm">hilbertnorm</code></td>
<td>
<p>numeric value of the Hilbert norm. Default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>biasbound</code></td>
<td>
<p>value of worst-case bias bound due to incomplete balance with inputted weights</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#load and clean data a bit
set.seed(123)
data("lalonde")
# Select a random subset of 500 rows
lalonde_sample &lt;- sample(1:nrow(lalonde), 500, replace = FALSE)
lalonde &lt;- lalonde[lalonde_sample, ]

xvars=c("age","black","educ","hisp","married","re74","re75","nodegr","u74","u75")

#need a kernel matrix to run SVD on and pass in so get that first with makeK
#running makeK with the sampled units as the bases
K = makeK(allx = lalonde[,xvars], useasbases = 1-lalonde$nsw)

#svd on this kernel
svd_pass = svd(K)  
#let's use the original weights of 1/number of sampled units, and 1/number of target units
#this is the default if we pass in w as all 1's
biasbound(observed=(1-lalonde$nsw),
          target=lalonde$nsw,
          svd.out = svd_pass,
          w = rep(1,nrow(lalonde)), hilbertnorm=1)
 
</code></pre>

<hr>
<h2 id='dimw'>Difference in Means and Difference in Weighted Means</h2><span id='topic+dimw'></span>

<h3>Description</h3>

<p>Calculates the simple difference in means or weighted difference in means between the control or sample population and the treated or target population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimw(X, w, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimw_+3A_x">X</code></td>
<td>
<p>matrix of data where rows are observations and columns are covariates.</p>
</td></tr>
<tr><td><code id="dimw_+3A_w">w</code></td>
<td>
<p>numeric vector of weights for each observation.</p>
</td></tr>
<tr><td><code id="dimw_+3A_target">target</code></td>
<td>
<p>numeric vector of length equal to the total number of units where population/treated units take a value of 1 and sample/control units take a value of 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dim</code></td>
<td>
<p>the simple, unweighted difference in means.</p>
</td></tr>
<tr><td><code>dimw</code></td>
<td>
<p>the weighted difference in means.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#let's say we want to get the unweighted DIM and the weighted DIM using weights from the kbal
#function with the lalonde data:
#load and clean data a bit
set.seed(123)
data("lalonde")
# Select a random subset of 500 rows
lalonde_sample &lt;- sample(1:nrow(lalonde), 500, replace = FALSE)
lalonde &lt;- lalonde[lalonde_sample, ]

xvars=c("age","black","educ","hisp","married","re74","re75","nodegr","u74","u75")

#get the kbal weights
kbalout= kbal(allx=lalonde[,xvars],
               sampledinpop=FALSE,
               treatment=lalonde$nsw)
 #now use dimw to get the DIMs
 dimw(X = lalonde[,xvars], w = kbalout$w, target = lalonde$nsw)
</code></pre>

<hr>
<h2 id='drop_multicollin'>Drop Multicollinear Columns</h2><span id='topic+drop_multicollin'></span>

<h3>Description</h3>

<p>Drops multicollinear columns in order of highest correlation using the correlation matrix. 
This function uses the <code>cor</code> function from the <code>stats</code> package to calculate the correlations 
between columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_multicollin(allx, printprogress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_multicollin_+3A_allx">allx</code></td>
<td>
<p>a matrix of data to check for multicollinearity. All columns must be numeric.</p>
</td></tr>
<tr><td><code id="drop_multicollin_+3A_printprogress">printprogress</code></td>
<td>
<p>logical to indicate if progress should be printed out to the command line. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>allx_noMC</code></td>
<td>
<p>resulting data matrix of full rank after multicollinear columns have been dropped.</p>
</td></tr>
<tr><td><code>dropped_cols</code></td>
<td>
<p>column names of the dropped columns.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create data with multicollinearity 
data &lt;- data.frame(x = rnorm(100),
                   y = sample.int(100, 100), 
                   z = runif(100, 3, 6))
test = data.frame(mc_1 = data$x,
                  mc_2 = data$x * 2 + data$y - data$z)
dat = cbind(test, data)
# Run function
mc_check = drop_multicollin(dat)
mc_check$dropped_cols 


</code></pre>

<hr>
<h2 id='ebalance_custom'>Modified version of ebalance (originally from Jens Hainmueller)</h2><span id='topic+ebalance_custom'></span>

<h3>Description</h3>

<p>This is a custom version of the <code>ebal</code> (entropy balancing) package by Jens Hainmueller.  Chooses weights on controls to make
covariate means equal to those of treated. This version differs from <code>ebal</code> only in that it handles
cases where there is only a single unit, which otherwise causes a problem in the original code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebalance_custom(
  Treatment,
  X,
  base.weight = NULL,
  norm.constant = NULL,
  coefs = NULL,
  max.iterations = 200,
  constraint.tolerance = 0.001,
  print.level = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ebalance_custom_+3A_treatment">Treatment</code></td>
<td>
<p>a numeric vector of length equal to the total number of units where treated (population) units take a value of 1 and control (sampled) units take a value of 0.</p>
</td></tr>
<tr><td><code id="ebalance_custom_+3A_x">X</code></td>
<td>
<p>matrix of data where rows are observations and columns are covariates.</p>
</td></tr>
<tr><td><code id="ebalance_custom_+3A_base.weight">base.weight</code></td>
<td>
<p>an optional numeric vector argument of length equal to the total number of control units to specify the base weight of each control unit within entropy balancing. Default is even weights (1) for all controls.</p>
</td></tr>
<tr><td><code id="ebalance_custom_+3A_norm.constant">norm.constant</code></td>
<td>
<p>an optional numeric argument; users should leave unspecified in most cases.</p>
</td></tr>
<tr><td><code id="ebalance_custom_+3A_coefs">coefs</code></td>
<td>
<p>an optional vector argument of length equal to one more than the number of covariates in <code>X</code>; users should leave unspecified in most cases.</p>
</td></tr>
<tr><td><code id="ebalance_custom_+3A_max.iterations">max.iterations</code></td>
<td>
<p>numeric maximum number of iterations to use when searching for weights</p>
</td></tr>
<tr><td><code id="ebalance_custom_+3A_constraint.tolerance">constraint.tolerance</code></td>
<td>
<p>numeric tolerance level.</p>
</td></tr>
<tr><td><code id="ebalance_custom_+3A_print.level">print.level</code></td>
<td>
<p>a numeric argument to specify the amount of information printed out. 0 is silent, 1 prints convergence status, 2 prints maximum deviance per iteration, 3 prints loss and step length.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>target.margins</code></td>
<td>
<p>Column sums of <code>X</code> among the treated units.</p>
</td></tr>
<tr><td><code>co.xdata</code></td>
<td>
<p>Covariate matrix for the controls only built from <code>X</code> with an additional appended column of ones.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>weights found using ebalance. Note that treated units all receive flat weights of 1</p>
</td></tr>
<tr><td><code>maxdiff</code></td>
<td>
<p>absolute value of the largest component of the gradient in the last iteration.</p>
</td></tr>
<tr><td><code>norm.constant</code></td>
<td>
<p>norm constant used</p>
</td></tr>
<tr><td><code>constraint.tolerance</code></td>
<td>
<p>tolerance used to evaluate convergence</p>
</td></tr>
<tr><td><code>max.iterations</code></td>
<td>
<p>max iterations used</p>
</td></tr>
<tr><td><code>base.weight</code></td>
<td>
<p>base weights used</p>
</td></tr>
<tr><td><code>print.level</code></td>
<td>
<p>print level used</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Convergence status. If ebalance failed to find weights within the specified <code>constraint.tolerance</code> after <code>max.iterations</code> this is <code>FALSE</code>. Note that even if ebalance does not converge, the last iteration's weights <code>w</code> are returned.</p>
</td></tr>
</table>

<hr>
<h2 id='getdist'>L1 Distance</h2><span id='topic+getdist'></span>

<h3>Description</h3>

<p>Calculates the L1 distance between the treated or population units and the kernel balanced control or sampled units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getdist(
  target,
  observed,
  K,
  w.pop = NULL,
  w = NULL,
  numdims = NULL,
  ebal.tol = 1e-06,
  ebal.maxit = 500,
  svd.U = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getdist_+3A_target">target</code></td>
<td>
<p>a numeric vector of length equal to the total number of units where population/treated units take a value of 1 and sample/control units take a value of 0.</p>
</td></tr>
<tr><td><code id="getdist_+3A_observed">observed</code></td>
<td>
<p>a numeric vector of length equal to the total number of units where sampled/control units take a value of 1 and population/treated units take a value of 0.</p>
</td></tr>
<tr><td><code id="getdist_+3A_k">K</code></td>
<td>
<p>the kernel matrix</p>
</td></tr>
<tr><td><code id="getdist_+3A_w.pop">w.pop</code></td>
<td>
<p>an optional vector input to specify population weights. Must be of length equal to the total number of units (rows in <code>svd.U</code>) with all sampled units receiving a weight of 1. The sum of the weights for population units must be either 1 or the number of population units.</p>
</td></tr>
<tr><td><code id="getdist_+3A_w">w</code></td>
<td>
<p>a optional numeric vector of weights for every observation. Note that these weights should sum to the total number of units, where treated or population units have a weight of 1 and control or sample units have appropriate weights derived from kernel balancing with mean 1, is consistent with the output of <code>getw()</code>. If unspecified, these weights are found internally using <code>numdims</code> dimensions of the SVD of the kernel matrix <code>svd.U</code> with <code>ebalance_custom()</code>.</p>
</td></tr>
<tr><td><code id="getdist_+3A_numdims">numdims</code></td>
<td>
<p>an optional numeric input specifying the number of columns of the singular value decomposition of the kernel matrix to use when finding weights when <code>w</code> is not specified.</p>
</td></tr>
<tr><td><code id="getdist_+3A_ebal.tol">ebal.tol</code></td>
<td>
<p>an optional numeric input specifying the tolerance level used by custom entropy balancing function <code>ebalance_custom()</code> in the case that <code>w</code> is not specified. Default is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="getdist_+3A_ebal.maxit">ebal.maxit</code></td>
<td>
<p>maximum number of iterations in optimization search used by <code>ebalance_custom</code> when <code>w</code> is not specified. Default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="getdist_+3A_svd.u">svd.U</code></td>
<td>
<p>an optional matrix of left singular vectors from performing <code>svd()</code> on the kernel matrix in the case that <code>w</code> is unspecified. If unspecified when <code>w</code> also not specified, internally computes the svd of <code>K</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>L1</code></td>
<td>
<p>a numeric giving the L1 distance, the absolute difference between <code>pX_D1</code> and <code>pX_D0w</code></p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>numeric vector of weights used</p>
</td></tr>
<tr><td><code>pX_D1</code></td>
<td>
<p>a numeric vector of length equal to the total number of observations where the nth entry is the sum of the kernel distances from the nth unit to every treated or population unit. If population units are specified, this sum is weighted by <code>w.pop</code> accordingly.</p>
</td></tr>
<tr><td><code>pX_D0</code></td>
<td>
<p>a numeric vector of length equal to the total number of observations where the nth entry is the sum of the kernel distances from the nth unit to every control or sampled unit.</p>
</td></tr>
<tr><td><code>pX_D0w</code></td>
<td>
<p>a numeric vector of length equal to the total number of observations where the nth entry is the weighted sum of the kernel distances from the nth unit to every control or sampled unit. The weights are given by entropy balancing and produce mean balance on <code class="reqn">\phi(X)</code>, the expanded features of <code class="reqn">X</code> using a given kernel <code class="reqn">\phi(.)</code>, for the control or sample group and treated group or target population.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#loading and cleaning lalonde data
set.seed(123)
data("lalonde")
# Select a random subset of 500 rows
lalonde_sample &lt;- sample(1:nrow(lalonde), 500, replace = FALSE)
lalonde &lt;- lalonde[lalonde_sample, ]

xvars=c("age","black","educ","hisp","married","re74","re75","nodegr","u74","u75")

#need to first build gaussian kernel matrix
K_pass &lt;- makeK(allx = lalonde[,xvars])
#also need the SVD of this matrix
svd_pass &lt;- svd(K_pass)

#running without passing weights in directly, using numdims=33
l1_lalonde &lt;- getdist(target = lalonde$nsw,
                      observed = 1-lalonde$nsw,
                      K = K_pass,
                      svd.U = svd_pass$u,
                      numdims = 33)

 #alternatively, we can get the weights ourselves and pass them in directly
 #using the first 33 dims of svd_pass$u to match the above
w_opt &lt;- getw(target= lalonde$nsw,
              observed = 1-lalonde$nsw,
              svd.U = svd_pass$u[,1:33])$w
l1_lalonde2 &lt;- getdist(target = lalonde$nsw,
                 observed = 1-lalonde$nsw,
                 K = K_pass,
                 w = w_opt)

</code></pre>

<hr>
<h2 id='getw'>Find Weights using Entropy Balancing.</h2><span id='topic+getw'></span>

<h3>Description</h3>

<p>Uses entropy balancing to find and return the weights that produce mean balance on <code class="reqn">\phi(X_i)</code>, the expanded features of <code class="reqn">X_i</code> using a given kernel <code class="reqn">\phi(.)</code>, for the control or sample group and treated group or target population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getw(target, observed, svd.U, ebal.tol = 1e-06, ebal.maxit = 500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getw_+3A_target">target</code></td>
<td>
<p>a numeric vector of length equal to the total number of units where population/treated units take a value of 1 and sample/control units take a value of 0.</p>
</td></tr>
<tr><td><code id="getw_+3A_observed">observed</code></td>
<td>
<p>a numeric vector of length equal to the total number of units where sampled/control units take a value of 1 and population/treated units take a value of 0.</p>
</td></tr>
<tr><td><code id="getw_+3A_svd.u">svd.U</code></td>
<td>
<p>a matrix of left singular vectors from performing <code>svd()</code> on the kernel matrix.</p>
</td></tr>
<tr><td><code id="getw_+3A_ebal.tol">ebal.tol</code></td>
<td>
<p>tolerance level used by custom entropy balancing function <code>ebalance_custom</code>. Default is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="getw_+3A_ebal.maxit">ebal.maxit</code></td>
<td>
<p>maximum number of iterations in optimization search used by <code>ebalance_custom</code>. Default is <code>500</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>w</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>boolean indicating if <code>ebalance_custom</code> converged</p>
</td></tr>
<tr><td><code>ebal_error</code></td>
<td>
<p>returns error message if <code>ebalance_custom</code> encounters an error</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#load and clean data
set.seed(123)
data("lalonde")
# Select a random subset of 500 rows
lalonde_sample &lt;- sample(1:nrow(lalonde), 500, replace = FALSE)
lalonde &lt;- lalonde[lalonde_sample, ]

xvars=c("age","black","educ","hisp","married","re74","re75","nodegr","u74","u75")

#need a kernel matrix to run SVD on then find weights with; so get that first with makeK.
#running makeK with the sampled units as the bases
K = makeK(allx = lalonde[,xvars], useasbases = 1-lalonde$nsw)

#SVD on this kernel and get matrix with left singular values
U = svd(K)$u
#Use the first 10 dimensions of U.
U2=U[,1:10]
getw.out=getw(target=lalonde$nsw, 
              observed=1-lalonde$nsw, 
              svd.U=U2)
 
</code></pre>

<hr>
<h2 id='kbal'>Kernel Balancing</h2><span id='topic+kbal'></span>

<h3>Description</h3>

<p>Kernel balancing (<code>kbal</code>) is non-parametric weighting tool to make two groups have a similar distribution of covariates, not only in terms of means or marginal distributions but also on (i) general smooth functions of the covariates, including on (ii) a smoothing estimator of the joint distribution of the covariates. It was originally designed (Hazlett, 2017) to make control and treated groups look alike, as desired when estimating causal effects under conditional ignorability. This package also facilitates use of this approach for more general distribution-alignment tasks, such as making a sampled group have a similar distribution of covariates as a target population, as in survey reweighting. The examples below provide an introduction to both settings.
</p>
<p>To proceed in the causal effect setting, kbal assumes that the expectation of the non-treatment potential outcome conditional on the covariates falls in a large, flexible space of functions associated with a kernel. It then constructs linear bases for this function space and achieves approximate balance on these bases. The approximation is one that minimizes the worst-case bias that could persist due to remaining imbalances. 
</p>
<p>The <code>kbal</code> function implements kernel balancing using a gaussian kernel to expand the features of <code class="reqn">X_i</code> to infinite dimensions.  It finds approximate mean balance for the control or sample group and treated group or target population in this expanded feature space by using the first <code>numdims</code> dimensions of the singular value decomposition of the gaussian kernel matrix. It employs entropy balancing to find the weights for each unit which produce this approximate balance. When <code>numdims</code> is not user-specified, it searches through increasing dimensions of the SVD of the kernel matrix to find the number of dimensions which produce weights that minimizes the worst-case bias bound with a given <code>hilbertnorm</code>. It then returns these optimal weights, along with the minimized bias, the kernel matrix, a record of the number of dimensions used and the corresponding bias, as well as an original bias using naive group size weights for comparison. Note that while kernel balancing goes far beyond simple mean balancing, it may not result in perfect mean balance. Users who wish to require mean balancing can specify <code>meanfirst = T</code> to require mean balance on as many dimensions of the data as optimally feasible. Alternatively, users can manually specify <code>constraint</code> to append additional vector constraints to the kernel matrix in the bias bound optimization, requiring mean balance on these columns. Note further that <code>kbal</code> supports three types of input data: fully categorical, fully continuous, or mixed. When data is only categorical, as is common with demographic variables for survey reweighting, users should use argument <code>cat_data = TRUE</code> and can input their data as factors, numeric, or characters and <code>kbal</code> will internally transform the data to a more appropriate one-hot encoding and search for the value of <code>b</code>, the denominator of the exponent in the Gaussian, which maximizes the variance of the kernel matrix. When data is fully continuous, users should use default settings (<code>cat_data = FALSE</code> and <code>cont_data = FAlSE</code>, which will scale all columns and again conduct an internal search for the value of <code>b</code> which maximizes the variance of <code>K</code>. Note that with continuous data, this search may take considerably more computational time than the categorical case. When data is a mix of continuous and categorical data, users should use argument <code>mixed_data = TRUE</code>, specify by name what columns are categorical with <code>cat_columns</code>, and also set the scaling of the continuous variables with <code>cont_scale</code>. This will result in a one-hot encoding of categorical columns concatenated with the continuous columns scaled in accordance with <code>cont_scale</code> and again an internal search for the value of <code>b</code> which maximizes the variance in the kernel matrix. Again note that compared to the categorical case, this search will take more computational time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kbal(
  allx,
  useasbases = NULL,
  b = NULL,
  sampled = NULL,
  sampledinpop = NULL,
  treatment = NULL,
  population.w = NULL,
  K = NULL,
  K.svd = NULL,
  cat_data = FALSE,
  mixed_data = FALSE,
  cat_columns = NULL,
  cont_scale = NULL,
  scale_data = NULL,
  drop_MC = NULL,
  linkernel = FALSE,
  meanfirst = FALSE,
  mf_columns = NULL,
  constraint = NULL,
  scale_constraint = TRUE,
  numdims = NULL,
  minnumdims = NULL,
  maxnumdims = NULL,
  fullSVD = FALSE,
  incrementby = 1,
  ebal.maxit = 500,
  ebal.tol = 1e-06,
  ebal.convergence = NULL,
  maxsearch_b = 2000,
  early.stopping = TRUE,
  printprogress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kbal_+3A_allx">allx</code></td>
<td>
<p>a data matrix containing all observations where rows are units and columns are covariates. When using only continuous covariates (<code>cat_data = F</code> and <code>mixed_data = F</code>), all columns must be numeric. When using categorical data (either <code>cat_data = T</code> or <code>mixed_data = T</code>), categorical columns can be characters or numerics which will be treated as factors. Users should one-hot encoded categorical covariates as this transformation occurs internally.</p>
</td></tr>
<tr><td><code id="kbal_+3A_useasbases">useasbases</code></td>
<td>
<p>optional binary vector to specify what observations are to be used in forming bases (columns) of the kernel matrix to get balance on.  If the number of observations is under 4000, the default is to use all observations. When the number of observations is over 4000, the default is to use the sampled (control) units only.</p>
</td></tr>
<tr><td><code id="kbal_+3A_b">b</code></td>
<td>
<p>scaling factor in the calculation of Gaussian kernel distance equivalent to the entire denominator <code class="reqn">2\sigma^2</code> of the exponent. Default is to search for the value which maximizes the variance of the kernel matrix.</p>
</td></tr>
<tr><td><code id="kbal_+3A_sampled">sampled</code></td>
<td>
<p>a numeric vector of length equal to the total number of units where sampled units take a value of 1 and population units take a value of 0.</p>
</td></tr>
<tr><td><code id="kbal_+3A_sampledinpop">sampledinpop</code></td>
<td>
<p>a logical to be used in combination with input <code>sampled</code> that, when <code>TRUE</code>, indicates that sampled units should also be included in the target population when searching for optimal weights.</p>
</td></tr>
<tr><td><code id="kbal_+3A_treatment">treatment</code></td>
<td>
<p>an alternative input to <code>sampled</code> and <code>sampledinpop</code> that is a numeric vector of length equal to the total number of units. Current version supports the ATT estimand. Accordingly, the treated units are the target population, and the control are equivalent to the sampled. Weights play the role of making the control groups (sampled) look like the target population (treated). When specified, <code>sampledinpop</code> is forced to be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_population.w">population.w</code></td>
<td>
<p>optional vector of population weights length equal to the number of population units. Must sum to either 1 or the number of population units.</p>
</td></tr>
<tr><td><code id="kbal_+3A_k">K</code></td>
<td>
<p>optional matrix input that takes a user-specified kernel matrix and performs SVD on it internally in the search for weights which minimize the bias bound.</p>
</td></tr>
<tr><td><code id="kbal_+3A_k.svd">K.svd</code></td>
<td>
<p>optional list input that takes a user-specified singular value decomposition of the kernel matrix. This list must include three objects <code>K.svd$u</code>, a matrix of left-singular vectors, <code>K.svd$v</code>, a matrix of right-singular vectors, and their corresponding singular values <code>K.svd$d</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_cat_data">cat_data</code></td>
<td>
<p>logical argument that when true indicates <code>allx</code> contains only categorical data. When true, the internal construction of the kernel matrix uses a one-hot encoding of <code>allx</code> (multiplied by a factor of <code class="reqn">\sqrt{0.5}</code> to compensate for double counting) and the value of <code>b</code> which maximizes the variance of this kernel matrix. When true, <code>mixed_data</code>, <code>scale_data</code>, <code>linkernel</code>, and <code>drop_MC</code> should be <code>FALSE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_mixed_data">mixed_data</code></td>
<td>
<p>logical argument that when true indicates <code>allx</code> contains a combination of both continuous and categorical data. When true, the internal construction of the kernel matrix uses a one-hot encoding of the categorical variables in <code>allx</code> as specified by <code>cat_columns</code> (multiplied by a factor of <code class="reqn">\sqrt{0.5}</code> to compensate for double counting) concatenated with the remaining continuous variables scaled to have default standard deviation of 1 or that specified in <code>cont_scale</code>. When both <code>cat_data</code> and <code>cat_data</code> are <code>FALSE</code>, the kernel matrix assumes all continuous data, does not one-hot encode any part of <code>allx</code> but still uses the value of <code>b</code> which produces maximal variance in <code>K</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_cat_columns">cat_columns</code></td>
<td>
<p>optional character argument that must be specified when <code>mixed_data</code> is <code>TRUE</code> and that indicates what columns of <code>allx</code> contain categorical variables.</p>
</td></tr>
<tr><td><code id="kbal_+3A_cont_scale">cont_scale</code></td>
<td>
<p>optional numeric argument used when <code>mixed_data</code> is <code>TRUE</code> which specifies how to scale the standard deviation of continuous variables in <code>allx</code>. Can be either a a single value or a vector with length equal to the number of continuous variables in <code>allx</code> (columns not specified in <code>cat_columns</code>) and ordered accordingly.</p>
</td></tr>
<tr><td><code id="kbal_+3A_scale_data">scale_data</code></td>
<td>
<p>logical when true scales the columns of <code>allx</code> (demeans and scales variance to 1) before building the kernel matrix internally. This is appropriate when <code>allx</code> contains only continuous variables with different scales, but is not recommended when <code>allx</code> contains any categorical data. Default is <code>TRUE</code> when both <code>cat_data</code> and <code>mixed_data</code> are <code>FALSE</code> and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="kbal_+3A_drop_mc">drop_MC</code></td>
<td>
<p>logical for whether or not to drop multicollinear columns in <code>allx</code> before building <code>K</code>. When either <code>cat_data</code> or <code>mixed_data</code> is <code>TRUE</code>, forced to be <code>FALSE</code>. Otherwise, with continuous data only, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_linkernel">linkernel</code></td>
<td>
<p>logical if true, uses the linear kernel <code class="reqn">K=XX'</code> which achieves balance on the first moments of <code class="reqn">X</code> (mean balance). Note that for computational ease, the code employs <code class="reqn">K=X</code> and adjusts singular values accordingly. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_meanfirst">meanfirst</code></td>
<td>
<p>logical if true, internally searches for the optimal number of dimensions of the svd of <code>allx</code> to append to <code>K</code> as additional constraints. This will produce mean balance on as many dimensions of <code>allx</code> as optimally feasible with specified ebalance convergence and a minimal bias bound on the remaining unbalances columns of the left singular vectors of <code>K</code>. Note that any scaling specified on <code>allx</code> will be also be applied in the meanfirst routine. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_mf_columns">mf_columns</code></td>
<td>
<p>either character or numeric vector to specify what columns of <code>allx</code> to perform meanfirst with. If left unspecified, all columns will be used.</p>
</td></tr>
<tr><td><code id="kbal_+3A_constraint">constraint</code></td>
<td>
<p>optional matrix argument of additional constraints which are appended to the front of the left singular vectors of <code>K</code>. When specified, the code conducts a constrained optimization requiring mean balance on the columns of this matrix throughout the search for the minimum bias bound over the dimensions of the left singular vectors of <code>K</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_scale_constraint">scale_constraint</code></td>
<td>
<p>logical for whether constraints in <code>constraint</code> should be scaled before they are appended to the svd of <code>K</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_numdims">numdims</code></td>
<td>
<p>optional numeric argument specifying the number of dimensions of the left singular vectors of the kernel matrix to find balance bypassing the optimization search for the number of dimensions which minimize the biasbound.</p>
</td></tr>
<tr><td><code id="kbal_+3A_minnumdims">minnumdims</code></td>
<td>
<p>numeric argument to specify the minimum number of the left singular vectors of the kernel matrix to seek balance on in the search for the number of dimensions which minimize the bias. Default minimum is 1.</p>
</td></tr>
<tr><td><code id="kbal_+3A_maxnumdims">maxnumdims</code></td>
<td>
<p>numeric argument to specify the maximum number of the left singular vectors of the kernel matrix to seek balance on in the search for the number of dimensions which minimize the bias. For a Gaussian kernel, the default is the minimum between 500 and the number of bases given by <code>useasbases</code>. With a linear kernel, the default is the minimum between 500 and the number of columns in <code>allx</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_fullsvd">fullSVD</code></td>
<td>
<p>logical argument for whether the full SVD should be conducted internally. When <code>FALSE</code>, the code uses truncated svd methods from the <code>Rspectra</code> package in the interest of improving run time. When <code>FALSE</code>, the code computes only the SVD up to the either 80 percent of the columns of <code>K</code> or <code>maxnumdims</code> singular vectors, whichever is larger. When the number of columns is less than 80 percent the  number of rows, defaults to full svd. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_incrementby">incrementby</code></td>
<td>
<p>numeric argument to specify the number of dimensions to increase by from <code>minnumdims</code> to <code>maxnumdims</code> in each iteration of the search for the number of dimensions which minimizes the bias. Default is 1.</p>
</td></tr>
<tr><td><code id="kbal_+3A_ebal.maxit">ebal.maxit</code></td>
<td>
<p>maximum number of iterations used by <code>ebalance_custom()</code> in optimization in the search for weights <code>w</code>. Default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_ebal.tol">ebal.tol</code></td>
<td>
<p>tolerance level used by <code>ebalance_custom()</code>. Default is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_ebal.convergence">ebal.convergence</code></td>
<td>
<p>logical to require ebalance convergence when selecting the optimal <code>numdims</code> dimensions of <code>K</code> that minimize the biasbound. When constraints are appended to the left singular vectors of <code>K</code> via <code>meanfirst=TRUE</code> or <code>constraints</code>, forced to be <code>TRUE</code> and otherwise <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_maxsearch_b">maxsearch_b</code></td>
<td>
<p>optional argument to specify the maximum b in search for maximum variance of <code>K</code> in <code>b_maxvarK()</code>. Default is <code>2000</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_early.stopping">early.stopping</code></td>
<td>
<p>logical argument indicating whether bias balance optimization should stop twenty rounds after finding a minimum. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kbal_+3A_printprogress">printprogress</code></td>
<td>
<p>logical argument to print updates throughout. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>w</code></td>
<td>
<p>a vector of the weights found using entropy balancing on <code>numdims</code> dimensions of the SVD of the kernel matrix.</p>
</td></tr>
<tr><td><code>biasbound_opt</code></td>
<td>
<p>a numeric giving the minimal bias bound found using <code>numdims</code> as the number of dimensions of the SVD of the kernel matrix. When <code>numdims</code> is user-specified, the bias bound using this number of dimensions of the kernel matrix.</p>
</td></tr>
<tr><td><code>biasbound_orig</code></td>
<td>
<p>a numeric giving the bias bound found when all sampled (control) units have a weight equal to one over the number of sampled (control) units and all target units have a weight equal to one over the number of target units.</p>
</td></tr>
<tr><td><code>biasbound_ratio</code></td>
<td>
<p>a numeric giving the ratio of <code>biasbound_orig</code> to<code>biasbound_opt</code>. Can be informative when comparing the performance of different <code>b</code> values.</p>
</td></tr> 
<tr><td><code>dist_record</code></td>
<td>
<p>a matrix recording the bias bound corresponding to balance on increasing dimensions of the SVD of the kernel matrix starting from <code>minnumdims</code> increasing by <code>incrementby</code> to <code>maxnumdims</code> or until the bias grows to be 1.25 times the minimal bias found.</p>
</td></tr>
<tr><td><code>numdims</code></td>
<td>
<p>a numeric giving the optimal number of dimensions of the SVD of the kernel matrix which minimizes the bias bound.</p>
</td></tr>
<tr><td><code>L1_orig</code></td>
<td>
<p>a numeric giving the L1 distance found when all sampled (control) units have a weight equal to one over the number of sampled (control) units and all target units have a weight equal to one over the number of target units.</p>
</td></tr>
<tr><td><code>L1_opt</code></td>
<td>
<p>a numeric giving the L1 distance at the minimum bias bound found using <code>numdims</code> as the number of dimensions of the SVD of the kernel matrix. When <code>numdims</code> is user-specified, the L1 distance using this number of dimensions of the kernel matrix.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the kernel matrix</p>
</td></tr>
<tr><td><code>onehot_dat</code></td>
<td>
<p>when categorical data is specified, the resulting one-hot encoded categorical data used in the construction of <code>K</code>. When mixed data is specified, returns concatenated one-hot encoded categorical data and scaled continuous data used to construct <code>K</code>.</p>
</td></tr>
<tr><td><code>linkernel</code></td>
<td>
<p>logical for whether linear kernel was used</p>
</td></tr>
<tr><td><code>svdK</code></td>
<td>
<p>a list giving the SVD of the kernel matrix with left singular vectors <code>svdK$u</code>, right singular vectors <code>svdK$v</code>, and singular values <code>svdK$d</code></p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>numeric scaling factor used in the the calculation of gaussian kernel  equivalent to the denominator <code class="reqn">2\sigma^2</code> of the exponent.</p>
</td></tr>
<tr><td><code>maxvar_K</code></td>
<td>
<p>returns the resulting variance of the kernel matrix when the <code>b</code> determined internally as the argmax of the variance <code>K</code></p>
</td></tr>
<tr><td><code>bases</code></td>
<td>
<p>numeric vector indicating what bases (rows in <code>allx</code>) were used to construct kernel matrix (columns of K)</p>
</td></tr>
<tr><td><code>truncatedSVD.var</code></td>
<td>
<p>when truncated SVD methods are used on symmetric kernel matrices, a numeric which gives the proportion of the total variance of <code>K</code> captured by the first <code>maxnumdims</code> singular values found by the truncated SVD. When the kernel matrix is non-symmetric, this is a worst case approximation of the percent variance explained, assuming the remaining unknown singular values are the same magnitude as the last calculated in the truncated SVD.</p>
</td></tr>
<tr><td><code>dropped_covariates</code></td>
<td>
<p>provides a vector of character column names for covariates dropped due to multicollinearity.</p>
</td></tr>
<tr><td><code>meanfirst_dims</code></td>
<td>
<p>when <code>meanfirst=TRUE</code> the optimal number of the singular vectors of <code>allx</code> selected and appended to the front of the left singular vectors of <code>K</code></p>
</td></tr>
<tr><td><code>meanfirst_cols</code></td>
<td>
<p>when <code>meanfirst=TRUE</code> <code>meanfirst_dims</code> first left singular vectors of <code>allx</code> selected that are appended to the front of the left singular vectors of <code>K</code> and balanced on</p>
</td></tr>
<tr><td><code>ebal_error</code></td>
<td>
<p>when ebalance is unable to find convergent weights, the associated error message it reports</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hazlett, C. (2017), &quot;Kernel Balancing: A flexible non-parametric weighting procedure for estimating causal effects.&quot; Forthcoming in Statistica Sinica. https://doi.org/10.5705/ss.202017.0555
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#----------------------------------------------------------------
# Example 1: Reweight a control group to a treated to estimate ATT. 
# Benchmark using Lalonde et al.
#----------------------------------------------------------------
#1. Rerun Lalonde example with settings as in Hazlett, C (2017). Statistica Sinica paper:
set.seed(123)
data("lalonde")
# Select a random subset of 500 rows
lalonde_sample &lt;- sample(1:nrow(lalonde), 500, replace = FALSE)
lalonde &lt;- lalonde[lalonde_sample, ]

xvars=c("age","black","educ","hisp","married","re74","re75","nodegr","u74","u75")
 

kbalout.full= kbal(allx=lalonde[,xvars],
                   b=length(xvars),
                   treatment=lalonde$nsw, 
                   fullSVD = TRUE)
summary(lm(re78~nsw,w=kbalout.full$w, data = lalonde))  
 
 
 #2. Lalonde with categorical data only: u74, u75, nodegree, race, married
 cat_vars=c("race_ethnicity","married","nodegr","u74","u75")
 
 kbalout_cat_only = kbal(allx=lalonde[,cat_vars],
                         cat_data = TRUE,
                         treatment=lalonde$nsw,
                         fullSVD = TRUE)
 kbalout_cat_only$b
 summary(lm(re78~nsw,w=kbalout_cat_only$w, data = lalonde))
 

 #3. Lalonde with mixed categorical and continuous data
 cat_vars=c("race_ethnicity", "married")
 all_vars= c("age","educ","re74","re75","married", "race_ethnicity")
 
 kbalout_mixed = kbal(allx=lalonde[,all_vars],
                      mixed_data = TRUE, 
                      cat_columns = cat_vars,
                      treatment=lalonde$nsw,
                      fullSVD = TRUE)
 kbalout_mixed$b
 summary(lm(re78~nsw,w=kbalout_mixed$w, data = lalonde))
 
 
#----------------------------------------------------------------
# Example 1B: Reweight a control group to a treated to esimate ATT. 
# Benchmark using Lalonde et al. -- but just mean balancing now 
# via "linkernel".
#----------------------------------------------------------------

# Rerun Lalonde example with settings as in Hazlett, C (2017). Statistica paper:
kbalout.lin= kbal(allx=lalonde[,xvars],
                 b=length(xvars),
                 treatment=lalonde$nsw, 
                 linkernel=TRUE,
                 fullSVD=TRUE)

# Check balance with and without these weights:
dimw(X=lalonde[,xvars], w=kbalout.lin$w, target=lalonde$nsw)

summary(lm(re78~nsw,w=kbalout.lin$w, data = lalonde))
 
#----------------------------------------------------------------
# Example 2: Reweight a sample to a target population.
#----------------------------------------------------------------
# Suppose a population consists of four groups in equal shares: 
# white republican, non-white republican, white non-republicans, 
# and non-white non-republicans. A given policy happens to be supported 
# by all white republicans, and nobody else. Thus the mean level of 
# support in the population should be 25%. 
#
# Further, the sample is surveyed in such a way that was careful 
# to quota on party and race, obtaining 50% republican and 50% white.
# However, among republicans three-quarters are white and among non-republicans,
# three quarters are non-white. This biases the average level of support
# despite having a sample that matches the population on its marginal distributions. #'
# We'd like to reweight the sample so it resembles the population not 
# just on the margins, but in the joint distribution of characteristics.

pop &lt;- data.frame(
republican =  c(rep(0,400), rep(1,400)),
white = c(rep(1,200), rep(0,200), rep(1,200), rep(0,200)),
support = c(rep(1,200), rep(0,600)))
  
mean(pop$support)  # Target value
 
# Survey sample: correct margins/means, but wrong joint distribution
samp &lt;- data.frame( republican = c(rep(1, 40), rep(0,40)),
   white = c(rep(1,30), rep(0,10), rep(1,10), rep(0,30)),
   support = c(rep(1,30), rep(0,50)))
  
mean(samp$support)  # Appears that support is 37.5% instead of 25%.
 
# Mean Balancing -----------------------------------------
# Sample is already mean-balanced to the population on each 
# characteristic. However for illustrative purposes, use ebal() 
dat &lt;- rbind(pop,samp)

# Indicate which units are sampled (1) and which are population units(0)
sampled &lt;- c(rep(0,800), rep(1,80))
 
# Run ebal (treatment = population units = 1-sampled)
ebal_out &lt;- ebalance_custom(Treatment = 1-sampled, 
                            X=dat[,1:2],
                            constraint.tolerance=1e-6, 
                            print.level=-1)
 
# We can see everything gets even weights, since already mean balanced.
length(unique(ebal_out$w))

# And we end up with the same estimate we started with
weighted.mean(samp[,3], w = ebal_out$w)
 
# We see that, because the margins are correct, all weights are equal
unique(cbind(samp, e_bal_weight = ebal_out$w))

# Kernel balancing for weighting to a population (i.e. kpop) -------
kbalout = kbal(allx=dat[,1:2],
                useasbases=rep(1,nrow(dat)), 
                sampled = sampled, 
                b = 1,
                sampledinpop = FALSE)
                
# The weights now vary:
plot(kbalout$w[sampled ==1], pch=16)

# And produce correct estimate:
weighted.mean(samp$support, w = kbalout$w[sampled==1])    
 
# kbal correctly downweights white republicans and non-white non-republicans
# and upweights the non-white republicans and white non-republicans
unique(round(cbind(samp[,-3], k_bal_weight = kbalout$w[sampled==1]),6))
</code></pre>

<hr>
<h2 id='lalonde'>Data from National Supported Work program and Panel Study in Income Dynamics</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p>Dehejia and Wahba (1999) sample of data from Lalonde (1986). 
This data set includes 185 treated units from the National 
Supported Work (NSW) program, paired with 2490 control units
drawn from the Panel Study of Income Dynamics (PSID-1).
</p>
<p>The treatment variable of interest is <code>nsw</code>, which indicates that an individual 
was in the job training program. The main outcome of interest is
real earnings in 1978 (<code>re78</code>).  The remaining variables are characteristics
of the individuals, to be used as controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lalonde
</code></pre>


<h3>Format</h3>

<p>A data frame with 2675 rows and 14 columns.
</p>

<dl>
<dt>nsw</dt><dd><p>treatment indicator: participation in the National Supported Work program.</p>
</dd>
<dt>re78</dt><dd><p>real earnings in 1978 (outcome)</p>
</dd>
<dt>u78</dt><dd><p>unemployed in 1978; actually an indicator for zero income in 1978</p>
</dd>
<dt>age</dt><dd><p>age in years</p>
</dd>
<dt>black</dt><dd><p>indicator for identifying as black</p>
</dd>
<dt>hisp</dt><dd><p>indicator for identifying as Hispanic</p>
</dd>
<dt>race_ethnicity</dt><dd><p>factor for self-identified race/ethnicity; same information as <code>black</code> and <code>hisp</code> in character form.</p>
</dd>
<dt>married</dt><dd><p>indicator for being married</p>
</dd>
<dt>re74</dt><dd><p>real income in 1974</p>
</dd>
<dt>re75</dt><dd><p>real income in 1975</p>
</dd>
<dt>u74</dt><dd><p>unemployment in 1974; actually an indicator for zero income in 1974</p>
</dd>
<dt>u75</dt><dd><p>unemployment in 1975; actually an indicator for zero income in 1975</p>
</dd>
<dt>educ</dt><dd><p>Years of education of the individual</p>
</dd>
<dt>nodegr</dt><dd><p>indicator for no high school degree; actually an indicator for years of education less than 12</p>
</dd>
</dl>



<h3>References</h3>

<p>Dehejia, Rajeev H., and Sadek Wahba. &quot;Causal effects in non-experimental studies: Reevaluating the evaluation of training programs.&quot; Journal of the American statistical Association 94.448 (1999): 1053-1062.
</p>
<p>LaLonde, Robert J. &quot;Evaluating the econometric evaluations of training programs with experimental data.&quot; The American economic review (1986): 604-620.
</p>

<hr>
<h2 id='makeK'>Build the Gaussian Kernel Matrix</h2><span id='topic+makeK'></span>

<h3>Description</h3>

<p>Builds the Gaussian kernel matrix using Rcpp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeK(allx, useasbases = NULL, b = NULL, linkernel = FALSE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeK_+3A_allx">allx</code></td>
<td>
<p>a data matrix containing all observations where rows are units and columns are covariates.</p>
</td></tr>
<tr><td><code id="makeK_+3A_useasbases">useasbases</code></td>
<td>
<p>a binary vector with length equal to the number of observations (rows in <code>allx</code>) to specify which bases to use when constructing the kernel matrix (columns of <code class="reqn">K</code>). If not specified, the default is to use all observations.</p>
</td></tr>
<tr><td><code id="makeK_+3A_b">b</code></td>
<td>
<p>Scaling factor in the calculation of Gaussian kernel distance equivalent to the entire denominator <code class="reqn">2\sigma^2</code> of the exponent. Default is twice the number of covariates or columns in <code>allx</code>.</p>
</td></tr>
<tr><td><code id="makeK_+3A_linkernel">linkernel</code></td>
<td>
<p>a logical value indicating whether to use a linear kernel, <code class="reqn">K=XX'</code>, which in practice employs <code class="reqn">K=X</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="makeK_+3A_scale">scale</code></td>
<td>
<p>a logical value indicating whether to standardize <code>allx</code> (demeaned with sd=1) before constructing the kernel matrix. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>K</code></td>
<td>
<p>The kernel matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#load and clean data a bit

set.seed(123)
data("lalonde")
# Select a random subset of 500 rows
lalonde_sample &lt;- sample(1:nrow(lalonde), 500, replace = FALSE)
lalonde &lt;- lalonde[lalonde_sample, ]

xvars &lt;- c("age","black","educ","hisp","married","re74","re75","nodegr","u74","u75")

#note that lalonde$nsw is the treatment vector, so the observed is 1-lalonde$nsw
#running makeK with the sampled/control units as the bases given 
#the large size of the data
K &lt;- makeK(allx = lalonde[,xvars], useasbases = 1-lalonde$nsw) 

</code></pre>

<hr>
<h2 id='one_hot'>One-Hot Encoding for Categorical Data</h2><span id='topic+one_hot'></span>

<h3>Description</h3>

<p>Converts raw categorical string/factor data matrix into numeric one-hot encoded data matrix. Intended to help prepare data to be passed to <code>kbal</code> argument <code>allx</code> when categorical data is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_hot(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="one_hot_+3A_data">data</code></td>
<td>
<p>a dataframe or matrix where columns are string or factor type covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>onehot_data</code></td>
<td>
<p>a matrix of combined sample and population data with rows corresponding to units and columns one-hot encoded categorical covariates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Ex 1. Make up some categorical demographic data
dat = data.frame(pid = c(rep("Rep", 20),
                         rep("Dem", 20), 
                         rep("Ind", 20)), 
                 gender = c(rep("female", 35),
                            rep("male", 25)))
#Convert to one-hot encoded data matrix:
onehot_dat = one_hot(dat)

#Ex 2. lalonde data
set.seed(123)
data("lalonde")
# Select a random subset of 500 rows
lalonde_sample &lt;- sample(1:nrow(lalonde), 500, replace = FALSE)
lalonde &lt;- lalonde[lalonde_sample, ]

cat_vars=c("black","hisp","married","nodegr","u74","u75")
onehot_lalonde = one_hot(lalonde[, cat_vars])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
