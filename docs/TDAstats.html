<!DOCTYPE html><html lang="en"><head><title>Help for package TDAstats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TDAstats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TDAstats'><p>Statistical Inference for Persistent Homology in Topological Data Analysis</p></a></li>
<li><a href='#calculate_homology'><p>Calculate Persistent Homology of a Point Cloud</p></a></li>
<li><a href='#circle2d'><p>2-dimensional point cloud of a unit circle</p></a></li>
<li><a href='#id_significant'><p>Identify Significant Features in Persistent Homology</p></a></li>
<li><a href='#permutation_test'><p>Statistical Inference for Topological Data Analysis</p></a></li>
<li><a href='#phom.dist'><p>Calculate Distance between Homology Matrices</p></a></li>
<li><a href='#plot_barcode'><p>Plot Persistent Homology as Topological Barcode</p></a></li>
<li><a href='#plot_persist'><p>Plot Persistent Homology as Persistence Diagram</p></a></li>
<li><a href='#sphere3d'><p>3-dimensional point cloud of a unit sphere</p></a></li>
<li><a href='#unif2d'><p>2-dimensional point cloud of a unit square</p></a></li>
<li><a href='#unif3d'><p>3-dimensional point cloud of a unit cube</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pipeline for Topological Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive toolset for any
    useR conducting topological data analysis, specifically via the
    calculation of persistent homology in a Vietoris-Rips complex.
    The tools this package currently provides can be conveniently split
    into three main sections: (1) calculating persistent homology; (2)
    conducting statistical inference on persistent homology calculations;
    (3) visualizing persistent homology and statistical inference.
    The published form of TDAstats can be found in Wadhwa et al. (2018)
    &lt;<a href="https://doi.org/10.21105%2Fjoss.00860">doi:10.21105/joss.00860</a>&gt;.   
    For a general background on computing persistent homology for
    topological data analysis, see Otter et al. (2017)
    &lt;<a href="https://doi.org/10.1140%2Fepjds%2Fs13688-017-0109-5">doi:10.1140/epjds/s13688-017-0109-5</a>&gt;.
    To learn more about how the permutation test is used for
    nonparametric statistical inference in topological data analysis,
    read Robinson &amp; Turner (2017) &lt;<a href="https://doi.org/10.1007%2Fs41468-017-0008-7">doi:10.1007/s41468-017-0008-7</a>&gt;.
    To learn more about how TDAstats calculates persistent homology,
    you can visit the GitHub repository for Ripser, the software that
    works behind the scenes at <a href="https://github.com/Ripser/ripser">https://github.com/Ripser/ripser</a>.
    This package has been published as Wadhwa et al. (2018)
    &lt;<a href="https://doi.org/10.21105%2Fjoss.00860">doi:10.21105/joss.00860</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 2.2.1), Rcpp (&ge; 0.12.15)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rrrlw/TDAstats">https://github.com/rrrlw/TDAstats</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rrrlw/TDAstats/issues">https://github.com/rrrlw/TDAstats/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.0.0), knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-12 20:31:51 UTC; rrrlw</td>
</tr>
<tr>
<td>Author:</td>
<td>Raoul Wadhwa [aut, cre],
  Andrew Dhawan [aut],
  Drew Williamson [aut],
  Jacob Scott [aut],
  Jason Cory Brunson [ctb],
  Shota Ochi [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raoul Wadhwa &lt;raoulwadhwa@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-12 22:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='TDAstats'>Statistical Inference for Persistent Homology in Topological Data Analysis</h2><span id='topic+TDAstats'></span><span id='topic+TDAstats-package'></span>

<h3>Description</h3>

<p>This package aims to be a comprehensive toolset for any
useR conducting topological data analysis, specifically via the
calculation of persistent homology in a Vietoris-Rips complex.
The tools this package currently provides can be conveniently split
into three main sections: (1) calculating persistent homology; (2)
conducting statistical inference on persistent homology calculations;
(3) visualizing persistent homology and statistical inference.
</p>

<hr>
<h2 id='calculate_homology'>Calculate Persistent Homology of a Point Cloud</h2><span id='topic+calculate_homology'></span>

<h3>Description</h3>

<p>Calculates the persistent homology of a point cloud, as represented by
a Vietoris-Rips complex. This function is an R wrapper for Ulrich Bauer's
Ripser C++ library for calculating persistent homology. For more
information on the C++ library, see &lt;https://github.com/Ripser/ripser&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_homology(mat, dim = 1, threshold = -1, format = "cloud",
  standardize = FALSE, return_df = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_homology_+3A_mat">mat</code></td>
<td>
<p>numeric matrix containing point cloud or distance matrix</p>
</td></tr>
<tr><td><code id="calculate_homology_+3A_dim">dim</code></td>
<td>
<p>maximum dimension of features to calculate</p>
</td></tr>
<tr><td><code id="calculate_homology_+3A_threshold">threshold</code></td>
<td>
<p>maximum diameter for computation of Vietoris-Rips complexes</p>
</td></tr>
<tr><td><code id="calculate_homology_+3A_format">format</code></td>
<td>
<p>format of 'mat', either &quot;cloud&quot; for point cloud or &quot;distmat&quot; for distance matrix</p>
</td></tr>
<tr><td><code id="calculate_homology_+3A_standardize">standardize</code></td>
<td>
<p>boolean determining whether point cloud size should be standardized</p>
</td></tr>
<tr><td><code id="calculate_homology_+3A_return_df">return_df</code></td>
<td>
<p>defaults to 'FALSE', returning a matrix;
if 'TRUE', returns a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'mat' parameter should be a numeric matrix with each row corresponding
to a single point, and each column corresponding to a single dimension. Thus,
if 'mat' has 50 rows and 5 columns, it represents a point cloud with 50 points
in 5 dimensions. The 'dim' parameter should be a positive integer.
Alternatively, the 'mat' parameter could be a distance matrix (upper
triangular half is ignored); note: 'format' should be specified as &quot;ldm&quot;.
</p>


<h3>Value</h3>

<p>3-column matrix or data frame, with each row representing a TDA feature
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a 2-d point cloud of a circle (100 points)
num.pts &lt;- 100
rand.angle &lt;- runif(num.pts, 0, 2*pi)
pt.cloud &lt;- cbind(cos(rand.angle), sin(rand.angle))

# calculate persistent homology (num.pts by 3 numeric matrix)
pers.hom &lt;- calculate_homology(pt.cloud)
</code></pre>

<hr>
<h2 id='circle2d'>2-dimensional point cloud of a unit circle</h2><span id='topic+circle2d'></span>

<h3>Description</h3>

<p>A dataset containing the Cartesian coordinates of 100 points uniformly distributed
on the circumference of a unit circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle2d
</code></pre>


<h3>Format</h3>

<p>A matrix with 100 rows and 2 columns: the x- and y-coordinates</p>


<h3>Source</h3>

<p><a href="https://github.com/rrrlw/TDAstats/blob/master/data-raw/circle2d.R">https://github.com/rrrlw/TDAstats/blob/master/data-raw/circle2d.R</a>
</p>

<hr>
<h2 id='id_significant'>Identify Significant Features in Persistent Homology</h2><span id='topic+id_significant'></span>

<h3>Description</h3>

<p>An empirical method (bootstrap) to differentiate between features that
constitute signal versus noise based on the magnitude of their
persistence relative to one another. Note: you must have at
least 5 features of a given dimension to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_significant(features, dim = 1, reps = 100, cutoff = 0.975)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id_significant_+3A_features">features</code></td>
<td>
<p>3xn data frame of features; the first column must be
dimension, the second birth, and the third death</p>
</td></tr>
<tr><td><code id="id_significant_+3A_dim">dim</code></td>
<td>
<p>dimension of features of interest</p>
</td></tr>
<tr><td><code id="id_significant_+3A_reps">reps</code></td>
<td>
<p>number of replicates</p>
</td></tr>
<tr><td><code id="id_significant_+3A_cutoff">cutoff</code></td>
<td>
<p>percentile cutoff past which features are considered
significant</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># get dataset (noisy circle) and calculate persistent homology
angles &lt;- runif(100, 0, 2 * pi)
x &lt;- cos(angles) + rnorm(100, mean = 0, sd = 0.1)
y &lt;- sin(angles) + rnorm(100, mean = 0, sd = 0.1)
annulus &lt;- cbind(x, y)
phom &lt;- calculate_homology(annulus)

# find threshold of significance
# expecting 1 significant feature of dimension 1 (Betti-1 = 1 for annulus)
thresh &lt;- id_significant(features = as.data.frame(phom),
                         dim = 1,
                         reps = 500,
                         cutoff = 0.975)

# generate flat persistence diagram
# every feature higher than `thresh` is significant
plot_persist(phom, flat = TRUE)
</code></pre>

<hr>
<h2 id='permutation_test'>Statistical Inference for Topological Data Analysis</h2><span id='topic+permutation_test'></span>

<h3>Description</h3>

<p>Conducts a permutation test for nonparametric statistical inference
of persistent homology in topological data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutation_test(data1, data2, iterations, exponent = 1, update = 0,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutation_test_+3A_data1">data1</code></td>
<td>
<p>first dataset</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_data2">data2</code></td>
<td>
<p>second dataset</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_iterations">iterations</code></td>
<td>
<p>number of iterations for distribution in permutation test</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_exponent">exponent</code></td>
<td>
<p>parameter 'p' that returns Wasserstein-p metric</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_update">update</code></td>
<td>
<p>if greater than zero, will print a message every 'update' iterations</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_...">...</code></td>
<td>
<p>arguments for 'calculate_homology' used for each permutation; this includes the 'format', 'dim', and 'threshold' parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The persistent homology of two point clouds are compared with the
Wasserstein metric (where Wasserstein-1 is also known as the Earth
Mover's Distance). However, the magnitude of the metric for a single pair
of point clouds is meaningless without a reference distribution. This
function uses a permutation test (permuting the points between the two
clouds) as a nonparametric hypothesis test for statistical inference.
</p>
<p>For more details on permutation tests for statistical inference in
topological data analysis, see Robinson A, Turner K. Hypothesis
testing for topological data analysis. J Appl Comput Topology. 2017;
1(2): 241-261.&lt;doi:10.1007/s41468-017-0008-7&gt;
</p>


<h3>Value</h3>

<p>list containing results of permutation test
</p>

<hr>
<h2 id='phom.dist'>Calculate Distance between Homology Matrices</h2><span id='topic+phom.dist'></span>

<h3>Description</h3>

<p>Calculates the distance between two matrices containing persistent homology
features, usually as returned by the 'calculate_homology' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phom.dist(phom1, phom2, limit.num = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phom.dist_+3A_phom1">phom1</code></td>
<td>
<p>3-by-n numeric matrix containing persistent homology for first dataset</p>
</td></tr>
<tr><td><code id="phom.dist_+3A_phom2">phom2</code></td>
<td>
<p>3-by-n numeric matrix containing persistent homology for second dataset</p>
</td></tr>
<tr><td><code id="phom.dist_+3A_limit.num">limit.num</code></td>
<td>
<p>limit comparison to only top 'limit.num' features in each dimension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the absolute value of this measure of distance is not meaningful
without a null distribution or at least another value for relative
comparison (e.g. finding most similar pair within a triplet).
</p>


<h3>Value</h3>

<p>distance vector (1 element per dimension) between 'phom1' and 'phom2'
</p>

<hr>
<h2 id='plot_barcode'>Plot Persistent Homology as Topological Barcode</h2><span id='topic+plot_barcode'></span>

<h3>Description</h3>

<p>Plots a feature matrix as a topological barcode. See 'plot_persist' for an
alternate visualization method of persistent homology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_barcode(feature.matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_barcode_+3A_feature.matrix">feature.matrix</code></td>
<td>
<p>nx3 matrix representing persistent homology features</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'feature.matrix' parameter should be a numeric matrix with each
row corresponding to a single feature. It should have 3 columns
corresponding to feature dimension (col 1), feature birth (col 2), and
feature death (col 3). The first column should be filled with integers,
and the next two columns should be filled with numeric values.
The output from the 'calculate_homology' function in this package will be a
valid value for the 'feature.matrix' parameter.
</p>
<p>This function uses the ggplot2 framework to generate persistence diagrams.
For details, see: Wickham H (2009). ggplot2: Elegant Graphics for Data
Analysis. Springer-Verlag: New York, NY.
</p>


<h3>Value</h3>

<p>ggplot instance representing topological barcode
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a 2-d point cloud of a circle (100 points)
num.pts &lt;- 100
rand.angle &lt;- runif(num.pts, 0, 2*pi)
pt.cloud &lt;- cbind(cos(rand.angle), sin(rand.angle))

# calculate persistent homology (num.pts by 3 numeric matrix)
pers.hom &lt;- calculate_homology(pt.cloud)

# plot calculated homology features as persistence diagram
plot_barcode(pers.hom)
</code></pre>

<hr>
<h2 id='plot_persist'>Plot Persistent Homology as Persistence Diagram</h2><span id='topic+plot_persist'></span>

<h3>Description</h3>

<p>Plots a feature matrix as a persistence diagram. See 'plot_barcode' for an
alternate visualization method of persistent homology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_persist(feature.matrix, flat = FALSE, cutoff = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_persist_+3A_feature.matrix">feature.matrix</code></td>
<td>
<p>nx3 matrix representing persistent homology features</p>
</td></tr>
<tr><td><code id="plot_persist_+3A_flat">flat</code></td>
<td>
<p>default FALSE; if TRUE, plots flat persistent homology instead</p>
</td></tr>
<tr><td><code id="plot_persist_+3A_cutoff">cutoff</code></td>
<td>
<p>threshold for significant features; line added as marker on plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'feature.matrix' parameter should be a numeric matrix with each
row corresponding to a single feature. It should have 3 columns
corresponding to feature dimension (col 1), feature birth (col 2), and
feature death (col 3). The first column should be filled with integers,
and the next two columns should be filled with numeric values.
The output from the 'calculate_homology' function in this package will be a
valid value for the 'feature.matrix' parameter.
</p>
<p>This function uses the ggplot2 framework to generate persistence diagrams.
For details, see: Wickham H (2009, ISBN:9780387981413). ggplot2: Elegant Graphics for Data
Analysis. Springer-Verlag: New York, NY.
</p>


<h3>Value</h3>

<p>ggplot instance representing persistence diagram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a 2-d point cloud of a circle (100 points)
num.pts &lt;- 100
rand.angle &lt;- runif(num.pts, 0, 2*pi)
pt.cloud &lt;- cbind(cos(rand.angle), sin(rand.angle))

# calculate persistent homology (num.pts by 3 numeric matrix)
pers.hom &lt;- calculate_homology(pt.cloud)

# plot calculated homology features as persistence diagram
plot_persist(pers.hom)
</code></pre>

<hr>
<h2 id='sphere3d'>3-dimensional point cloud of a unit sphere</h2><span id='topic+sphere3d'></span>

<h3>Description</h3>

<p>A dataset containing the Cartesian coordinates of 100 points uniformly distributed
on the surface of a unit sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere3d
</code></pre>


<h3>Format</h3>

<p>A matrix with 100 rows and 3 columns: the x-, y-, and z-coordinates</p>


<h3>Source</h3>

<p><a href="https://github.com/rrrlw/TDAstats/blob/master/data-raw/sphere3d.R">https://github.com/rrrlw/TDAstats/blob/master/data-raw/sphere3d.R</a>
</p>

<hr>
<h2 id='unif2d'>2-dimensional point cloud of a unit square</h2><span id='topic+unif2d'></span>

<h3>Description</h3>

<p>A dataset containing the Cartesian coordinates of 100 points uniformly distributed
within a unit square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif2d
</code></pre>


<h3>Format</h3>

<p>A matrix with 100 rows and 2 columns: the x- and y-coordinates</p>


<h3>Source</h3>

<p><a href="https://github.com/rrrlw/TDAstats/blob/master/data-raw/unif2d.R">https://github.com/rrrlw/TDAstats/blob/master/data-raw/unif2d.R</a>
</p>

<hr>
<h2 id='unif3d'>3-dimensional point cloud of a unit cube</h2><span id='topic+unif3d'></span>

<h3>Description</h3>

<p>A dataset containing the Cartesian coordinates of 100 points uniformly distributed
within a unit cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif3d
</code></pre>


<h3>Format</h3>

<p>A matrix with 100 rows and 3 columns: the x-, y-, and z-coordinates</p>


<h3>Source</h3>

<p><a href="https://github.com/rrrlw/TDAstats/blob/master/data-raw/unif3d.R">https://github.com/rrrlw/TDAstats/blob/master/data-raw/unif3d.R</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
