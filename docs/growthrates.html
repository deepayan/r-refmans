<!DOCTYPE html><html><head><title>Help for package growthrates</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {growthrates}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[,multiple_fits,ANY,missing-method'><p>Extract or Replace Parts of a 'multiple_fits' Object</p></a></li>
<li><a href='#all_easylinear'><p>Easy Growth Rates Fit to data Frame</p></a></li>
<li><a href='#all_growthmodels'><p>Fit Nonlinear Growth Models to Data Frame</p></a></li>
<li><a href='#all_splines'><p>Fit Exponential Growth Model with Smoothing Spline</p></a></li>
<li><a href='#antibiotic'><p>Plate Reader Data of Bacterial Growth</p></a></li>
<li><a href='#bactgrowth'><p>Plate Reader Data of Bacterial Growth</p></a></li>
<li><a href='#cost'><p>Cost Function for Nonlinear Fits</p></a></li>
<li><a href='#extcoef_logistic'><p>Extended Set of Coefficients of a Logistic Growth Model</p></a></li>
<li><a href='#fit_easylinear'><p>Fit Exponential Growth Model with a Heuristic Linear Method</p></a></li>
<li><a href='#fit_growthmodel'><p>Fit Nonlinear Parametric Growth Model</p></a></li>
<li><a href='#fit_spline'><p>Fit Exponential Growth Model with Smoothing Spline</p></a></li>
<li><a href='#function_growthmodel-class'><p>Union Class of Growth Model or Function</p></a></li>
<li><a href='#grow_baranyi'><p>The Baranyi and Roberts Growth Model</p></a></li>
<li><a href='#grow_exponential'><p>Exponential Growth Model</p></a></li>
<li><a href='#grow_gompertz'><p>Growth Model According to Gompertz</p></a></li>
<li><a href='#grow_gompertz2'><p>Growth Model According to Gompertz</p></a></li>
<li><a href='#grow_huang'><p>Growth Model According to Huang</p></a></li>
<li><a href='#grow_logistic'><p>Logistic Growth Model</p></a></li>
<li><a href='#grow_richards'><p>Growth Model According to Richards</p></a></li>
<li><a href='#growthmodel'><p>Create a User-defined Parametric Growth Model</p></a></li>
<li><a href='#growthmodel-class'><p>Class of Growth Model Functions</p></a></li>
<li><a href='#growthrates_fit-class'><p>S4 Classes of Package <span class="pkg">growthrates</span></p></a></li>
<li><a href='#growthrates-package'><p>Estimate Growth Rates from Experimental Data</p></a></li>
<li><a href='#lm_or_NULL-class'><p>Union Class of Linear Model or NULL</p></a></li>
<li><a href='#lm_window'><p>Fit Exponential Growth Model with a Heuristic Linear Method</p></a></li>
<li><a href='#multisplit'><p>Split Data Frame into Multiple Groups</p></a></li>
<li><a href='#names.growthmodel'><p>Get Names Attributes of Growth Models</p></a></li>
<li><a href='#ode_genlogistic'><p>Generalized Logistic Growth Model</p></a></li>
<li><a href='#ode_twostep'><p>Twostep Growth Model</p></a></li>
<li><a href='#parse_formula'><p>Simple Formula Interface</p></a></li>
<li><a href='#parse_formula_nonlin'><p>Simple Formula Interface for Grouped Nonlinear Functions</p></a></li>
<li><a href='#plot'><p>Plot Model Fits</p></a></li>
<li><a href='#predict,growthrates_fit-method'><p>Model Predictions for <span class="pkg">growthrates</span> Fits</p></a></li>
<li><a href='#rsquared'><p>Additional Generic Functions</p></a></li>
<li><a href='#rsquared,growthrates_fit-method'><p>Accessor Methods of Package <span class="pkg">growthrates</span>.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate Growth Rates from Experimental Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-03</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Petzoldt &lt;thomas.petzoldt@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of methods to determine growth rates from
    experimental data, in particular from batch experiments and
    plate reader trials.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2), lattice, deSolve</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, methods, parallel, utils, FME</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, dplyr, ggplot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tpetzoldt/growthrates">https://github.com/tpetzoldt/growthrates</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'aaa_growthmodel-class.R' 'aab_growthmodel-constructor.R'
'aac_classes.R' 'aad_set_generics.R' 'all_easylinear.R'
'all_growthmodels.R' 'all_splines.R' 'antibiotic.R'
'bactgrowth.R' 'cost.R' 'extcoef_logistic.R' 'extract.R'
'fit_easylinear.R' 'fit_growthmodel.R' 'fit_spline.R'
'grow_baranyi.R' 'grow_exponential.R' 'grow_genlogistic.R'
'grow_gompertz.R' 'grow_gompertz2.R' 'grow_huang.R'
'grow_logistic.R' 'grow_richards.R' 'grow_twostep.R'
'growthrates-package.R' 'lm_window.R' 'methods.R'
'multisplit.R' 'names.R' 'parse_formula.R'
'parse_formula_nonlin.R' 'plot.R' 'predict.R' 'utilities.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-03 17:23:18 UTC; thpe</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Petzoldt <a href="https://orcid.org/0000-0002-4951-6468"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-03 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+2Cmultiple_fits+2CANY+2Cmissing-method'>Extract or Replace Parts of a 'multiple_fits' Object</h2><span id='topic++5B+2Cmultiple_fits+2CANY+2Cmissing-method'></span><span id='topic++5B+5B+2Cmultiple_fits+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Operators to access parts of 'multiple_fits' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiple_fits,ANY,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'multiple_fits,ANY,missing'
x[[i, j, ...]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2Cmultiple_fits+2B2CANY+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>object of class multiple_fits</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cmultiple_fits+2B2CANY+2B2Cmissing-method_+3A_i">i</code></td>
<td>
<p>numeric or character index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cmultiple_fits+2B2CANY+2B2Cmissing-method_+3A_j">j</code></td>
<td>
<p>NULL (for compatibility with other uses of  <code>[</code> or <code>[[</code>)</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cmultiple_fits+2B2CANY+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>[</code></p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cmultiple_fits+2B2CANY+2B2Cmissing-method_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> the result is coerced to the lowest possible
dimension</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bactgrowth)
L &lt;- all_splines(value ~ time | strain + conc +replicate, data=bactgrowth)

coef(L[[1]])

plot(L[["R:0:2"]])

par(mfrow=c(2, 2))
plot(L[1:4])

</code></pre>

<hr>
<h2 id='all_easylinear'>Easy Growth Rates Fit to data Frame</h2><span id='topic+all_easylinear'></span><span id='topic+all_easylinear.formula'></span><span id='topic+all_easylinear.data.frame'></span>

<h3>Description</h3>

<p>Determine maximum growth rates from log-linear part of the growth curve for
a series of experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_easylinear(...)

## S3 method for class 'formula'
all_easylinear(formula, data, h = 5, quota = 0.95, subset = NULL, ...)

## S3 method for class 'data.frame'
all_easylinear(
  data,
  grouping,
  time = "time",
  y = "value",
  h = 5,
  quota = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_easylinear_+3A_...">...</code></td>
<td>
<p>generic parameters, reserved for future extensions.</p>
</td></tr>
<tr><td><code id="all_easylinear_+3A_formula">formula</code></td>
<td>
<p>model formula specifying dependent, independent and grouping
variables in the form:
<code>dependent ~ independent | group1 + group2 + ...</code>.</p>
</td></tr>
<tr><td><code id="all_easylinear_+3A_data">data</code></td>
<td>
<p>data frame of observational data.</p>
</td></tr>
<tr><td><code id="all_easylinear_+3A_h">h</code></td>
<td>
<p>with of the window (number of data).</p>
</td></tr>
<tr><td><code id="all_easylinear_+3A_quota">quota</code></td>
<td>
<p>part of window fits considered for the overall linear fit
(relative to max. growth rate).</p>
</td></tr>
<tr><td><code id="all_easylinear_+3A_subset">subset</code></td>
<td>
<p>a specification of the rows to be used: defaults to all rows.</p>
</td></tr>
<tr><td><code id="all_easylinear_+3A_grouping">grouping</code></td>
<td>
<p>model formula or character vector of criteria defining
subsets in the data frame.</p>
</td></tr>
<tr><td><code id="all_easylinear_+3A_time">time</code></td>
<td>
<p>character vectors with name independent variabl.e.</p>
</td></tr>
<tr><td><code id="all_easylinear_+3A_y">y</code></td>
<td>
<p>character vector with name of dependent variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object with parameters of all fits.
</p>


<h3>References</h3>

<p>Hall, BG., Acar, H, Nandipati, A and Barlow, M (2014) Growth Rates Made Easy.
Mol. Biol. Evol. 31: 232-38, <a href="https://doi.org/10.1093/molbev/mst187">doi:10.1093/molbev/mst187</a>
</p>


<h3>See Also</h3>

<p>Other fitting functions: 
<code><a href="#topic+all_growthmodels">all_growthmodels</a>()</code>,
<code><a href="#topic+all_splines">all_splines</a>()</code>,
<code><a href="#topic+fit_easylinear">fit_easylinear</a>()</code>,
<code><a href="#topic+fit_growthmodel">fit_growthmodel</a>()</code>,
<code><a href="#topic+fit_spline">fit_spline</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library("growthrates")
L &lt;- all_easylinear(value ~ time | strain + conc + replicate, data=bactgrowth)
summary(L)
coef(L)
rsquared(L)

results &lt;- results(L)

library(lattice)
xyplot(mumax ~ conc|strain, data=results)


</code></pre>

<hr>
<h2 id='all_growthmodels'>Fit Nonlinear Growth Models to Data Frame</h2><span id='topic+all_growthmodels'></span><span id='topic+all_growthmodels.formula'></span><span id='topic+all_growthmodels.function'></span>

<h3>Description</h3>

<p>Determine maximum growth rates by nonlinear fits for
a series of experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_growthmodels(...)

## S3 method for class 'formula'
all_growthmodels(
  formula,
  data,
  p,
  lower = -Inf,
  upper = Inf,
  which = names(p),
  FUN = NULL,
  method = "Marq",
  transform = c("none", "log"),
  ...,
  subset = NULL,
  ncores = detectCores(logical = FALSE)
)

## S3 method for class ''function''
all_growthmodels(
  FUN,
  p,
  data,
  grouping = NULL,
  time = "time",
  y = "value",
  lower = -Inf,
  upper = Inf,
  which = names(p),
  method = "Marq",
  transform = c("none", "log"),
  ...,
  ncores = detectCores(logical = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_growthmodels_+3A_...">...</code></td>
<td>
<p>generic parameters, including parameters passed to the optimizer.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_formula">formula</code></td>
<td>
<p>model formula specifying dependent, independent and grouping
variables in the form:
<code>dependent ~ independent | group1 + group2 + ...</code>.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_data">data</code></td>
<td>
<p>data frame of observational data.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_p">p</code></td>
<td>
<p>named vector of start parameters and initial values of the growth model.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_lower">lower</code></td>
<td>
<p>lower bound of the parameter vector.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_upper">upper</code></td>
<td>
<p>upper bound of the parameter vector.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_which">which</code></td>
<td>
<p>vector of parameter names that are to be fitted.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_fun">FUN</code></td>
<td>
<p>function of growth model to be fitted.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_method">method</code></td>
<td>
<p>character vector specifying the optimization algorithm.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_transform">transform</code></td>
<td>
<p>fit model to non-transformed or log-transformed data.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_subset">subset</code></td>
<td>
<p>a specification of the rows to be used: defaults to all rows.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_ncores">ncores</code></td>
<td>
<p>number of CPU cores used for parallel computation. The number
of real cores is detected automatically by default,
but fort debugging purposes it could be wise to set <code>ncores = 1</code>.
Usage of logical (hyperthreading) cores does not speed up computation.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_grouping">grouping</code></td>
<td>
<p>vector of grouping variables defining subsets in the data frame.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_time">time</code></td>
<td>
<p>character vector with name of independent variable.</p>
</td></tr>
<tr><td><code id="all_growthmodels_+3A_y">y</code></td>
<td>
<p>character vector with name of dependent variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object containing the parameters of all fits.
</p>


<h3>See Also</h3>

<p>Other fitting functions: 
<code><a href="#topic+all_easylinear">all_easylinear</a>()</code>,
<code><a href="#topic+all_splines">all_splines</a>()</code>,
<code><a href="#topic+fit_easylinear">fit_easylinear</a>()</code>,
<code><a href="#topic+fit_growthmodel">fit_growthmodel</a>()</code>,
<code><a href="#topic+fit_spline">fit_spline</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bactgrowth)
splitted.data &lt;- multisplit(value ~ time | strain + conc + replicate,
                 data = bactgrowth)

## show which experiments are in splitted.data
names(splitted.data)

## get table from single experiment
dat &lt;- splitted.data[["D:0:1"]]

fit0 &lt;- fit_spline(dat$time, dat$value)

fit1 &lt;- all_splines(value ~ time | strain + conc + replicate,
                 data = bactgrowth, spar = 0.5)


## these examples require some CPU power and may take a bit longer

## initial parameters
p &lt;- c(coef(fit0), K = max(dat$value))

## avoid negative parameters
lower = c(y0 = 0, mumax = 0, K = 0)

## fit all models
fit2 &lt;- all_growthmodels(value ~ time | strain + conc + replicate,
          data = bactgrowth, FUN=grow_logistic,
          p = p, lower = lower, ncores = 2)

results1 &lt;- results(fit1)
results2 &lt;- results(fit2)
plot(results1$mumax, results2$mumax, xlab="smooth splines", ylab="logistic")

## experimental: nonlinear model as part of the formula

fit3 &lt;- all_growthmodels(
          value ~ grow_logistic(time, parms) | strain + conc + replicate,
          data = bactgrowth, p = p, lower = lower, ncores = 2)

## this allows also to fit to the 'global' data set or any subsets
fit4 &lt;- all_growthmodels(
          value ~ grow_logistic(time, parms),
          data = bactgrowth, p = p, lower = lower, ncores = 1)
plot(fit4)

fit5 &lt;- all_growthmodels(
          value ~ grow_logistic(time, parms) | strain + conc,
          data = bactgrowth, p = p, lower = lower, ncores = 2)
plot(fit5)


</code></pre>

<hr>
<h2 id='all_splines'>Fit Exponential Growth Model with Smoothing Spline</h2><span id='topic+all_splines'></span><span id='topic+all_splines.formula'></span><span id='topic+all_splines.data.frame'></span>

<h3>Description</h3>

<p>Determine maximum growth rates from log-linear part of the growth curve for
a series of experiments by using smoothing splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_splines(...)

## S3 method for class 'formula'
all_splines(formula, data = NULL, optgrid = 50, subset = NULL, ...)

## S3 method for class 'data.frame'
all_splines(
  data,
  grouping = NULL,
  time = "time",
  y = "value",
  optgrid = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_splines_+3A_...">...</code></td>
<td>
<p>generic parameters, including parameters passed to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, see details.</p>
</td></tr>
<tr><td><code id="all_splines_+3A_formula">formula</code></td>
<td>
<p>model formula specifying dependent, independent and grouping
variables in the form:
<code>dependent ~ independent | group1 + group2 + ...</code>.</p>
</td></tr>
<tr><td><code id="all_splines_+3A_data">data</code></td>
<td>
<p>data frame of observational data.</p>
</td></tr>
<tr><td><code id="all_splines_+3A_optgrid">optgrid</code></td>
<td>
<p>number of steps on the x-axis used for searching the maximum
of the first derivative of the spline.
The default should work in most cases, as long as the data are equally spaced.
A smaller number may lead to non-detectable speed-up, but has the risk that
the search is trapped in a local minimum.</p>
</td></tr>
<tr><td><code id="all_splines_+3A_subset">subset</code></td>
<td>
<p>a specification of the rows to be used: defaults to all rows.</p>
</td></tr>
<tr><td><code id="all_splines_+3A_grouping">grouping</code></td>
<td>
<p>vector of grouping variables defining subsets in the data frame.</p>
</td></tr>
<tr><td><code id="all_splines_+3A_time">time</code></td>
<td>
<p>character vectors with name independent variable.</p>
</td></tr>
<tr><td><code id="all_splines_+3A_y">y</code></td>
<td>
<p>character vector with name of dependent variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method was inspired by an algorithm of Kahm et al. (2010),
with different settings and assumptions. In the moment, spline fitting
is always done with log-transformed data, assuming exponential growth
at the time point of the maximum of its first derivative.
</p>
<p>All the hard work is done by function <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> from package
<span class="pkg">stats</span>, that is highly user configurable. Normally, smoothness is
automatically determined via cross-validation. This works well in many cases,
whereas manual adjustment is required otherwise, e.g. by setting <code>spar</code>
to a fixed value <code class="reqn">[0,1]</code> that also disables cross-validation.
A typical case where cross validation does not work is, if time dependent
measurements are taken as pseudoreplicates from the same experimental unit.
</p>


<h3>Value</h3>

<p>object with parameters of the fit.
</p>


<h3>References</h3>

<p>Kahm, M., Hasenbrink, G., Lichtenberg-Frate, H., Ludwig, J., Kschischo, M.
2010. grofit: Fitting Biological Growth Curves with R.
Journal of Statistical Software, 33(7), 1-21,
<a href="https://doi.org/10.18637/jss.v033.i07">doi:10.18637/jss.v033.i07</a>
</p>


<h3>See Also</h3>

<p>Other fitting functions: 
<code><a href="#topic+all_easylinear">all_easylinear</a>()</code>,
<code><a href="#topic+all_growthmodels">all_growthmodels</a>()</code>,
<code><a href="#topic+fit_easylinear">fit_easylinear</a>()</code>,
<code><a href="#topic+fit_growthmodel">fit_growthmodel</a>()</code>,
<code><a href="#topic+fit_spline">fit_spline</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bactgrowth)
L &lt;- all_splines(value ~ time | strain + conc + replicate,
                 data = bactgrowth, spar = 0.5)

par(mfrow=c(4, 3))
plot(L)
results &lt;- results(L)
xyplot(mumax ~ log(conc + 1)|strain, data=results)

## fit splines at lower grouping levels
L2 &lt;- all_splines(value ~ time | conc + strain,
                    data = bactgrowth, spar = 0.5)
plot(L2)

## total data set without any grouping
L3 &lt;- all_splines(value ~ time,
                    data = bactgrowth, spar = 0.5)
par(mfrow=c(1, 1))
plot(L3)

</code></pre>

<hr>
<h2 id='antibiotic'>Plate Reader Data of Bacterial Growth</h2><span id='topic+antibiotic'></span>

<h3>Description</h3>

<p>Example data set from growth experiments with Pseudomonas putida
on a tetracycline concentration gradient.
</p>


<h3>Format</h3>

<p>Data frame with the following columns:
</p>

<dl>
<dt>time</dt><dd><p>time in hours.</p>
</dd>
<dt>variable</dt><dd><p>sample code.</p>
</dd>
<dt>value</dt><dd><p>bacteria concentration measured as optical density.</p>
</dd>
<dt>conc</dt><dd><p>concentration of the antibiotics (Tetracycline).</p>
</dd>
<dt>repl</dt><dd><p>Replicate.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The sample data set shows four out of six replicates of the original experiment.
</p>


<h3>Source</h3>

<p>Claudia Seiler, TU Dresden, Institute of Hydrobiology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## plot data and determine growth rates
data(antibiotic)

dat &lt;- subset(antibiotic, conc==0.078 &amp; repl=="R4")
parms &lt;- c(y0=0.01, mumax=0.2, K=0.5)
fit &lt;- fit_growthmodel(grow_logistic, parms, dat$time, dat$value)
plot(fit); plot(fit, log="y")
</code></pre>

<hr>
<h2 id='bactgrowth'>Plate Reader Data of Bacterial Growth</h2><span id='topic+bactgrowth'></span>

<h3>Description</h3>

<p>Example data set from growth experiments with different
concentrations of antibiotics.
</p>


<h3>Format</h3>

<p>Data frame with the following columns:
</p>

<dl>
<dt>strain</dt><dd><p>identifier of the bacterial strain, D=donor, R=recipient, T=transconjugant.</p>
</dd>
<dt>replicate</dt><dd><p>replicate of the trial.</p>
</dd>
<dt>conc</dt><dd><p>concentration of the antibiotics (Tetracycline).</p>
</dd>
<dt>time</dt><dd><p>time in hours.</p>
</dd>
<dt>value</dt><dd><p>bacteria concentration measured as optical density.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This rather 'difficult' data set was intentionally selected to make model
fitting by the package more challenging.
</p>


<h3>Source</h3>

<p>Claudia Seiler, TU Dresden, Institute of Hydrobiology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## plot data and determine growth rates
data(bactgrowth)


library(lattice)
xyplot(value ~ time | strain + as.factor(conc),
      data = bactgrowth, groups = replicate)
</code></pre>

<hr>
<h2 id='cost'>Cost Function for Nonlinear Fits</h2><span id='topic+cost'></span>

<h3>Description</h3>

<p>Defines a cost function from the residual sum of squares between model
and observational data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost(p, obs, FUN, fixed.p = NULL, transform, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cost_+3A_p">p</code></td>
<td>
<p>vector of fitted parameters of the growth model.</p>
</td></tr>
<tr><td><code id="cost_+3A_fun">FUN</code></td>
<td>
<p>function of growth model to be fitted.</p>
</td></tr>
<tr><td><code id="cost_+3A_fixed.p">fixed.p</code></td>
<td>
<p>vector of fixed  parameters of the growth model.</p>
</td></tr>
<tr><td><code id="cost_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the optimizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function 'cost' is implemented along the lines of the
following template, see package FME for details:
</p>
<pre>
cost &lt;- function(p, obs, FUN, fixed.p = NULL, ...) {
  out &lt;- FUN(obs$time, c(p, fixed.p))
  modCost(out, obs, weight = "none", ...)
}
</pre>


<h3>Value</h3>

<p>an object of class <code>modCost</code>, see <code>modCost</code> in
package <span class="pkg">FME</span>
</p>

<hr>
<h2 id='extcoef_logistic'>Extended Set of Coefficients of a Logistic Growth Model</h2><span id='topic+extcoef_logistic'></span>

<h3>Description</h3>

<p>Estimate model-specific derived parameters of the logistic growth
model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extcoef_logistic(object, quantile = 0.95, time = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extcoef_logistic_+3A_object">object</code></td>
<td>
<p>model object fited by <code>fit_growthmodel</code></p>
</td></tr>
<tr><td><code id="extcoef_logistic_+3A_quantile">quantile</code></td>
<td>
<p>fraction of the capacity parameter (<code>K</code>) for the quantile method</p>
</td></tr>
<tr><td><code id="extcoef_logistic_+3A_time">time</code></td>
<td>
<p>2-valued vector of the search interval for the independent
variable (<code>time</code>).
Note: this needs to be set this manually if saturation is not
reached within the observation time period taken from the data.</p>
</td></tr>
<tr><td><code id="extcoef_logistic_+3A_...">...</code></td>
<td>
<p>reserved for future extensions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the estimated parameters of a logistic growth model
(<code>y0</code>, <code>mumax</code>, <code>K</code>) and a series of estimates for the time
of approximate saturation.
The estimates are defined as follows:
</p>

<ul>
<li> <p><code>turnpoint</code>: time of turnpoint (50% saturation)
</p>
</li>
<li> <p><code>sat1</code>: time of the minimum of the 2nd derivative
</p>
</li>
<li> <p><code>sat2</code>: time of the intercept between the steepest increase
(the tangent at <code>mumax</code>) and the carrying capacity <code>K</code>
</p>
</li>
<li> <p><code>sat3</code>: time when a quantile of <code>K</code> (default 0.95)
is reached
</p>
</li></ul>

<p>This function is normally not directly called by the user.
It is usually called indirectly from <code>coef</code> or <code>results</code> if
<code>extended=TRUE</code>.
</p>


<h3>Value</h3>

<p>vector that contains the fitted parameters and some
derived characteristics (extended parameters) of the logistic
function.
</p>


<h3>Note</h3>

<p>The estimates for the turnpoint and the time of approximate saturation
(<code>sat1</code>, <code>sat2</code>, <code>sat3</code>) may be unreliable, if saturation
is not reached within the observation time period. See example below.
A set of extended parameters exists currently only for the standard logistic
growth model (<code>grow_logistic</code>).
The code and naming of the parameters is preliminary and may change in
future versions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## =========================================================================
## The 'extended parameters' are usually derived
## =========================================================================

data(antibiotic)

## fit a logistic model to a single data set
dat &lt;- subset(antibiotic, conc==0.078 &amp; repl=="R4")

parms &lt;- c(y0=0.01, mumax=0.2, K=0.5)
fit &lt;- fit_growthmodel(grow_logistic, parms, dat$time, dat$value)
coef(fit, extended=TRUE)

## fit the logistic to all data sets
myData &lt;- subset(antibiotic, repl=="R3")
parms &lt;- c(y0=0.01, mumax=0.2, K=0.5)
all &lt;- all_growthmodels(value ~ time | conc,
                         data = myData, FUN=grow_logistic,
                         p = parms, ncores = 2)


par(mfrow=c(3,4))
plot(all)
results(all, extended=TRUE)
## we see that the the last 3 series (10...12) do not go into saturation
## within the observation time period.

## We can try to extend the search range:
results(all[10:12], extended=TRUE, time=c(0, 5000))


## =========================================================================
## visualisation how the 'extended parameters' are derived
## =========================================================================

# Derivatives of the logistic:
#   The 1st and 2nd derivatives are internal functions of the package.
#   They are used here for the visualisation of the algorithm.

deriv1 &lt;- function(time, y0, mumax, K) {
  ret &lt;- (K*mumax*y0*(K - y0)*exp(mumax * time))/
    ((K + y0 * (exp(mumax * time) - 1))^2)
  unname(ret)
}

deriv2 &lt;- function(time, y0, mumax, K) {
  ret &lt;- -(K * mumax^2 * y0 * (K - y0) * exp(mumax * time) *
             (-K + y0 * exp(mumax * time) + y0))/
    (K + y0 * (exp(mumax * time) - 1))^3
  unname(ret)
}
## =========================================================================

data(bactgrowth)
## extract one growth experiment by name
dat &lt;- multisplit(bactgrowth, c("strain", "conc", "replicate"))[["D:0:1"]]


## unconstraied fitting
p &lt;- c(y0 = 0.01, mumax = 0.2, K = 0.1) # start parameters
fit1 &lt;- fit_growthmodel(FUN = grow_logistic, p = p, dat$time, dat$value)
summary(fit1)
p &lt;- coef(fit1, extended=TRUE)

## copy parameters to separate variables to improve readability ------------
y0 &lt;-    p["y0"]
mumax &lt;- p["mumax"]
K  &lt;-    p["K"]
turnpoint &lt;- p["turnpoint"]
sat1 &lt;-  p["sat1"]  # 2nd derivative
sat2 &lt;-  p["sat2"]  # intercept between steepest increase and K
sat3 &lt;-  p["sat3"]  # a given quantile of K, default 95\%

## show saturation values in growth curve and 1st and 2nd derivatives ------
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(3, 1), mar=c(4,4,0.2,0))
plot(fit1)

## 95% saturation
abline(h=0.95*K, col="magenta", lty="dashed")

## Intercept between steepest increase and 100% saturation
b &lt;- deriv1(turnpoint, y0, mumax, K)
a &lt;- K/2 - b*turnpoint
abline(a=a, b=b, col="orange", lty="dashed")
abline(h=K, col="orange", lty="dashed")
points(sat2, K, pch=16, col="orange")
points(turnpoint, K/2, pch=16, col="blue")

## sat2 is the minimum of the 2nd derivative
abline(v=c(turnpoint, sat1, sat2, sat3),
       col=c("blue", "grey", "orange", "magenta"), lty="dashed")

## plot the derivatives
with(dat, plot(time, deriv1(time, y0, mumax, K), type="l", ylab="y'"))
abline(v=c(turnpoint, sat1), col=c("blue", "grey"), lty="dashed")

with(dat, plot(time, deriv2(time, y0, mumax, K), type="l",  ylab="y''"))
abline(v=sat1, col="grey", lty="dashed")
par(opar)

</code></pre>

<hr>
<h2 id='fit_easylinear'>Fit Exponential Growth Model with a Heuristic Linear Method</h2><span id='topic+fit_easylinear'></span>

<h3>Description</h3>

<p>Determine maximum growth rates from the log-linear part of a growth curve using
a heuristic approach similar to the &ldquo;growth rates made easy&rdquo;-method of
Hall et al. (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_easylinear(time, y, h = 5, quota = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_easylinear_+3A_time">time</code></td>
<td>
<p>vector of independent variable.</p>
</td></tr>
<tr><td><code id="fit_easylinear_+3A_y">y</code></td>
<td>
<p>vector of dependent variable (concentration of organisms).</p>
</td></tr>
<tr><td><code id="fit_easylinear_+3A_h">h</code></td>
<td>
<p>width of the window (number of data).</p>
</td></tr>
<tr><td><code id="fit_easylinear_+3A_quota">quota</code></td>
<td>
<p>part of window fits considered for the overall linear fit
(relative to max. growth rate)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works as follows:
</p>

<ol>
<li><p> Fit linear regressions to all subsets of <code>h</code> consecutive data
points. If for example <code class="reqn">h=5</code>, fit a linear regression to points
1 ... 5, 2 ... 6, 3... 7 and so on. The method seeks the highest
rate of exponential growth, so the dependent variable is of course
log-transformed.
</p>
</li>
<li><p> Find the subset with the highest slope <code class="reqn">b_{max}</code> and
include also the data points of adjacent subsets that have a slope of
at least <code class="reqn">quota \cdot b_{max}</code>,
e.g. all data sets that have at least 95% of the maximum slope.
</p>
</li>
<li><p> Fit a new linear model to the extended data window identified in step 2.
</p>
</li></ol>



<h3>Value</h3>

<p>object with parameters of the fit. The lag time is currently estimated
as the intersection between the fit and the horizontal line with <code class="reqn">y=y_0</code>,
where <code>y0</code> is the first value of the dependent variable. The intersection
of the fit with the abscissa is indicated as <code>y0_lm</code> (lm for linear model).
These identifieres and their assumptions may change in future versions.
</p>


<h3>References</h3>

<p>Hall, BG., Acar, H, Nandipati, A and Barlow, M (2014) Growth Rates Made Easy.
Mol. Biol. Evol. 31: 232-38, <a href="https://doi.org/10.1093/molbev/mst187">doi:10.1093/molbev/mst187</a>
</p>


<h3>See Also</h3>

<p>Other fitting functions: 
<code><a href="#topic+all_easylinear">all_easylinear</a>()</code>,
<code><a href="#topic+all_growthmodels">all_growthmodels</a>()</code>,
<code><a href="#topic+all_splines">all_splines</a>()</code>,
<code><a href="#topic+fit_growthmodel">fit_growthmodel</a>()</code>,
<code><a href="#topic+fit_spline">fit_spline</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bactgrowth)

splitted.data &lt;- multisplit(bactgrowth, c("strain", "conc", "replicate"))
dat &lt;- splitted.data[[1]]

plot(value ~ time, data=dat)
fit &lt;- fit_easylinear(dat$time, dat$value)

plot(fit)
plot(fit, log="y")
plot(fit, which="diagnostics")

fitx &lt;- fit_easylinear(dat$time, dat$value, h=8, quota=0.95)

plot(fit, log="y")
lines(fitx, pch="+", col="blue")

plot(fit)
lines(fitx, pch="+", col="blue")


</code></pre>

<hr>
<h2 id='fit_growthmodel'>Fit Nonlinear Parametric Growth Model</h2><span id='topic+fit_growthmodel'></span>

<h3>Description</h3>

<p>Determine maximum growth rates by fitting nonlinear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_growthmodel(
  FUN,
  p,
  time,
  y,
  lower = -Inf,
  upper = Inf,
  which = names(p),
  method = "Marq",
  transform = c("none", "log"),
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_growthmodel_+3A_fun">FUN</code></td>
<td>
<p>function of growth model to be fitted.</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_p">p</code></td>
<td>
<p>named vector of start parameters and initial values of the growth model.</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_time">time</code></td>
<td>
<p>vector of independent variable.</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_y">y</code></td>
<td>
<p>vector of dependent variable (concentration of organisms).</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_lower">lower</code></td>
<td>
<p>lower bound of the parameter vector (optional).</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_upper">upper</code></td>
<td>
<p>upper bound of the parameter vector (optional).</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_which">which</code></td>
<td>
<p>vector of parameter names that are to be fitted.</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_method">method</code></td>
<td>
<p>character vector specifying the optimization algorithm (see <code>modFit</code>).</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_transform">transform</code></td>
<td>
<p>fit model to non-transformed or log-transformed data.</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_control">control</code></td>
<td>
<p>A list of control parameters for the optimizers. See Details.</p>
</td></tr>
<tr><td><code id="fit_growthmodel_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the optimizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code>modFit</code> from package <span class="pkg">FME</span>.
Syntax of control parameters and available options may differ, depending
on the optimizer used, except <code>control=list(trace=...)</code> that switches
tracing on and off for all methods and is either <code>TRUE</code>, or <code>FALSE</code>,
or an integer value like 0, 1, 2, 3, depending on the optimizer.
</p>


<h3>Value</h3>

<p>object  with parameters of the fit.
</p>


<h3>See Also</h3>

<p><code>modFit</code> about constrained fitting of models to data
</p>
<p>Other fitting functions: 
<code><a href="#topic+all_easylinear">all_easylinear</a>()</code>,
<code><a href="#topic+all_growthmodels">all_growthmodels</a>()</code>,
<code><a href="#topic+all_splines">all_splines</a>()</code>,
<code><a href="#topic+fit_easylinear">fit_easylinear</a>()</code>,
<code><a href="#topic+fit_spline">fit_spline</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bactgrowth)
splitted.data &lt;- multisplit(bactgrowth, c("strain", "conc", "replicate"))

## get one element either by index or by name
dat &lt;- splitted.data[[1]]
dat &lt;- splitted.data[["D:0:1"]]

p &lt;- c(y0 = 0.01, mumax = 0.2, K = 0.1)

## unconstraied fitting
fit1 &lt;- fit_growthmodel(FUN = grow_logistic, p = p, dat$time, dat$value)
coef(fit1)
summary(fit1)

## optional box-constraints
lower &lt;- c(y0 = 1e-6, mumax = 0,   K = 0)
upper &lt;- c(y0 = 0.05, mumax = 5,   K = 0.5)
fit1 &lt;- fit_growthmodel(
  FUN = grow_logistic, p = p, dat$time, dat$value,
  lower = lower, upper = upper)

plot(fit1, log="y")

</code></pre>

<hr>
<h2 id='fit_spline'>Fit Exponential Growth Model with Smoothing Spline</h2><span id='topic+fit_spline'></span>

<h3>Description</h3>

<p>Determine maximum growth rates from the first derivative of a smoothing spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_spline(time, y, optgrid = length(time), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_spline_+3A_time">time</code></td>
<td>
<p>vector of independent variable.</p>
</td></tr>
<tr><td><code id="fit_spline_+3A_y">y</code></td>
<td>
<p>vector of dependent variable (concentration of organisms).</p>
</td></tr>
<tr><td><code id="fit_spline_+3A_optgrid">optgrid</code></td>
<td>
<p>number of steps on the x-axis used for the optimum search .
algorithm. The default should work in most cases, as long as the data are equally spaced.
A smaller number may lead to non-detectable speed-up, but has the risk that
the search gets trapped in a local minimum.</p>
</td></tr>
<tr><td><code id="fit_spline_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method was inspired by an algorithm of Kahm et al. (2010),
with different settings and assumptions. In the moment, spline fitting
is always done with log-transformed data, assuming exponential growth
at the time point of the maximum of the first derivative of the spline fit.
</p>
<p>All the hard work is done by function <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> from package
<span class="pkg">stats</span>, that is highly user configurable. Normally, smoothness is
automatically determined via cross-validation. This works well in many cases,
whereas manual adjustment is required otherwise, e.g. by setting <code>spar</code>
to a fixed value <code class="reqn">[0, 1]</code> that also disables cross-validation.
</p>


<h3>Value</h3>

<p>object with parameters of the fit
</p>


<h3>References</h3>

<p>Kahm, M., Hasenbrink, G., Lichtenberg-Frate, H., Ludwig, J., Kschischo, M.
2010. grofit: Fitting Biological Growth Curves with R.
Journal of Statistical Software, 33(7), 1-21,
<a href="https://doi.org/10.18637/jss.v033.i07">doi:10.18637/jss.v033.i07</a>
</p>


<h3>See Also</h3>

<p>Other fitting functions: 
<code><a href="#topic+all_easylinear">all_easylinear</a>()</code>,
<code><a href="#topic+all_growthmodels">all_growthmodels</a>()</code>,
<code><a href="#topic+all_splines">all_splines</a>()</code>,
<code><a href="#topic+fit_easylinear">fit_easylinear</a>()</code>,
<code><a href="#topic+fit_growthmodel">fit_growthmodel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bactgrowth)
splitted.data &lt;- multisplit(bactgrowth, c("strain", "conc", "replicate"))

dat &lt;- splitted.data[[2]]
time &lt;- dat$time
y    &lt;- dat$value

## automatic smoothing with cv
res &lt;- fit_spline(time, y)

plot(res, log="y")
plot(res)
coef(res)

## a more difficult data set
dat &lt;- splitted.data[[56]]
time &lt;- dat$time
y &lt;- dat$value

## default parameters
res &lt;- fit_spline(time, y)
plot(res, log="y")

## small optgrid, trapped in local minimum
res &lt;- fit_spline(time, y, optgrid=5)
plot(res, log="y")

## manually selected smoothing parameter
res &lt;- fit_spline(time, y, spar=.5)
plot(res, log="y")
plot(res, ylim=c(0.005, 0.03))


</code></pre>

<hr>
<h2 id='function_growthmodel-class'>Union Class of Growth Model or Function</h2><span id='topic+function_growthmodel-class'></span>

<h3>Description</h3>

<p>This class union comprises parametric model functions from class
<code>growthmodel</code> and ordinary functions to describe time-dependent
growth of organisms.
</p>


<h3>See Also</h3>

<p>the constructor function <code><a href="#topic+growthmodel">growthmodel</a></code> how to create
instances of class <code>growthmodel</code>.
</p>

<hr>
<h2 id='grow_baranyi'>The Baranyi and Roberts Growth Model</h2><span id='topic+grow_baranyi'></span>

<h3>Description</h3>

<p>The growth model of Baranyi and Roberts (1995) written as analytical solution
of the system of differential equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_baranyi(time, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_baranyi_+3A_time">time</code></td>
<td>
<p>vector of time steps (independent variable).</p>
</td></tr>
<tr><td><code id="grow_baranyi_+3A_parms">parms</code></td>
<td>
<p>named parameter vector of the Baranyi growth model with:
</p>

<ul>
<li> <p><code>y0</code> initial value of abundance,
</p>
</li>
<li> <p><code>mumax</code> maximum growth rate (1/time),
</p>
</li>
<li> <p><code>K</code> carrying capacity (max. abundance),
</p>
</li>
<li> <p><code>h0</code> parameter specifying the initial physiological state of
organisms (e.g. cells) and in consequence the lag phase
(h0 = max growth rate * lag phase).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The version of the equation used in this package has the following form:
</p>
<p style="text-align: center;"><code class="reqn">A = time + 1/mumax * log(exp(-mumax * time) + exp(-h0) - exp(-mumax * time - h0))</code>
</p>

<p style="text-align: center;"><code class="reqn">log(y) = log(y0) + mumax * A - log(1 + (exp(mumax * A) - 1) / exp(log(K) - log(y0)))</code>
</p>



<h3>Value</h3>

<p>vector of dependent variable (<code>y</code>).
</p>


<h3>References</h3>

<p>Baranyi, J. and Roberts, T. A. (1994).
A dynamic approach to predicting bacterial growth in food.
International Journal of Food Microbiology, 23, 277-294.
</p>
<p>Baranyi, J. and Roberts, T.A. (1995). Mathematics of predictive microbiology.
International Journal of Food Microbiology, 26, 199-218.
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>,
<code><a href="#topic+ode_twostep">ode_twostep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time &lt;- seq(0, 30, length=200)
y    &lt;- grow_baranyi(time, c(y0=0.01, mumax=.5, K=0.1, h0=5))[,"y"]
plot(time, y, type="l")
plot(time, y, type="l", log="y")

</code></pre>

<hr>
<h2 id='grow_exponential'>Exponential Growth Model</h2><span id='topic+grow_exponential'></span>

<h3>Description</h3>

<p>Unlimited exponential growth model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_exponential(time, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_exponential_+3A_time">time</code></td>
<td>
<p>vector of time steps (independent variable).</p>
</td></tr>
<tr><td><code id="grow_exponential_+3A_parms">parms</code></td>
<td>
<p>named parameter vector of the exponential growth model with:
</p>

<ul>
<li> <p><code>y0</code> initial abundance (e.g. concentration of bacterial cells).
</p>
</li>
<li> <p><code>mumax</code> maximum growth rate (1/time).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation used is:
</p>
<p style="text-align: center;"><code class="reqn">y = y0 * exp(mumax * time)</code>
</p>



<h3>Value</h3>

<p>vector of dependent variable (<code>y</code>).
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>,
<code><a href="#topic+ode_twostep">ode_twostep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time &lt;- seq(0, 30, length=200)
y &lt;- grow_exponential(time, c(y0=1, mumax=0.5))[,"y"]
plot(time, y, type="l")

</code></pre>

<hr>
<h2 id='grow_gompertz'>Growth Model According to Gompertz</h2><span id='topic+grow_gompertz'></span>

<h3>Description</h3>

<p>Gompertz growth model written as analytical solution of the differential
equation system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_gompertz(time, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_gompertz_+3A_time">time</code></td>
<td>
<p>vector of time steps (independent variable).</p>
</td></tr>
<tr><td><code id="grow_gompertz_+3A_parms">parms</code></td>
<td>
<p>named parameter vector of the Gompertz growth model with:
</p>

<ul>
<li> <p><code>y0</code> initial value of abundance,
</p>
</li>
<li> <p><code>mumax</code> maximum growth rate (1/time),
</p>
</li>
<li> <p><code>K</code> maximum abundance (carrying capacity).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation used here is:
</p>
<p style="text-align: center;"><code class="reqn">y = K * exp(log(y0 / K) * exp(-mumax * time))</code>
</p>



<h3>Value</h3>

<p>vector of dependent variable (<code>y</code>)
</p>


<h3>Note</h3>

<p>The naming of parameter &quot;mumax&quot; was done in analogy to the other growth
models, but it turned out that it was not consistent with the maximum
growth rate of the population. This can be considered as bug. The function
will be removed or replaced in future versions of the package. Please use
<code>grow_gompertz2</code> instead.
</p>


<h3>References</h3>

<p>Tsoularis, A. (2001) Analysis of Logistic Growth Models.
Res. Lett. Inf. Math. Sci, (2001) 2, 23-46.
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>,
<code><a href="#topic+ode_twostep">ode_twostep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time &lt;- seq(0, 30, length=200)
y    &lt;- grow_gompertz(time, c(y0=1, mumax=.2, K=10))[,"y"]
plot(time, y, type="l", ylim=c(0, 20))


</code></pre>

<hr>
<h2 id='grow_gompertz2'>Growth Model According to Gompertz</h2><span id='topic+grow_gompertz2'></span><span id='topic+grow_gompertz3'></span>

<h3>Description</h3>

<p>Gompertz growth model written as analytical solution of the differential
equation system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_gompertz2(time, parms)

grow_gompertz3(time, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_gompertz2_+3A_time">time</code></td>
<td>
<p>vector of time steps (independent variable).</p>
</td></tr>
<tr><td><code id="grow_gompertz2_+3A_parms">parms</code></td>
<td>
<p>named parameter vector of the Gompertz growth model with:
</p>

<ul>
<li> <p><code>y0</code> initial value of abundance,
</p>
</li>
<li> <p><code>mumax</code> maximum growth rate (1/time),
</p>
</li>
<li> <p><code>K</code> maximum abundance (carrying capacity),
</p>
</li>
<li> <p><code>lambda</code> time of lag phase of the 3 parameter Gompertz model .
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation used here is:
</p>
<p style="text-align: center;"><code class="reqn">y = y0*(K/y0)^(exp(-exp((exp(1)*mumax*(lambda - time))/log(K/y0)+1)))</code>
</p>

<p>Functions <code>grow_gompert2</code> and <code>grow_gompertz3</code> describe
sigmoidal growth with an exponentially decreasing intrinsic growth rate with
or without an additional lag parameter. The formula follows the
reparametrization of Zwietering et al (1990), with parameters that have
a biological meaning.
</p>


<h3>Value</h3>

<p>vector of dependent variable (<code>y</code>)
</p>


<h3>References</h3>

<p>Tsoularis, A. (2001) Analysis of Logistic Growth Models.
Res. Lett. Inf. Math. Sci, (2001) 2, 23-46.
</p>
<p>Zwietering, M. H., Jongenburger, I., Rombouts, F. M., and Van't Riet, K.
(1990). Modeling of the bacterial growth curve.
Appl. Environ. Microbiol., 56(6), 1875-1881.
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>,
<code><a href="#topic+ode_twostep">ode_twostep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time &lt;- seq(0, 30, length=200)
y    &lt;- grow_gompertz(time, c(y0=1, mumax=.2, K=10))[,"y"]
plot(time, y, type="l", ylim=c(0, 12))


</code></pre>

<hr>
<h2 id='grow_huang'>Growth Model According to Huang</h2><span id='topic+grow_huang'></span>

<h3>Description</h3>

<p>Huangs growth model written as analytical solution of the differential equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_huang(time, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_huang_+3A_time">time</code></td>
<td>
<p>vector of time steps (independent variable).</p>
</td></tr>
<tr><td><code id="grow_huang_+3A_parms">parms</code></td>
<td>
<p>named parameter vector of Huang's growth model with:
</p>

<ul>
<li> <p><code>y0</code> initial value of abundance,
</p>
</li>
<li> <p><code>mumax</code> maximum growth rate (1/time),
</p>
</li>
<li> <p><code>K</code> carrying capacity (max. total concentration of cells),
</p>
</li>
<li> <p><code>alpha</code> shape parameter determining the curvature,
</p>
</li>
<li> <p><code>lambda</code> parameter determining the lag time.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The version of the equation used in this package has the following form:
</p>
<p style="text-align: center;"><code class="reqn">B = time + 1/alpha * log((1+exp(-alpha * (time - lambda)))/(1 + exp(alpha * lambda)))</code>
</p>

<p style="text-align: center;"><code class="reqn">log(y) = log(y0) + log(K) - log(y0 + (K - y0) * exp(-mumax * B))</code>
</p>

<p>In contrast to the original publication, all parameters related to population
abundance (y, y0, K) are given as untransformed values.
They are not log-transformed.<br />
In general, using log-transformed parameters would indeed be a good idea to
avoid the need of constained optimization, but tests showed that
box-constrained optimization worked resonably well.
Therefore, handling of optionally log-transformed parameters was removed
from the package to avoid confusion. If you want to discuss this, please
let me know.
</p>


<h3>Value</h3>

<p>vector of dependent variable (<code>y</code>).
</p>


<h3>References</h3>

<p>Huang, Lihan (2008) Growth kinetics of Listeria monocytogenes in broth and
beef frankfurters - determination of lag phase duration and exponential
growth rate under isothermal conditions. Journal of Food Science 73(5),
E235 &ndash; E242. <a href="https://doi.org/10.1111/j.1750-3841.2008.00785.x">doi:10.1111/j.1750-3841.2008.00785.x</a>
</p>
<p>Huang, Lihan (2011) A new mechanistic growth model for simultaneous
determination of lag phase duration and exponential growth rate and a new
Belehdradek-type model for evaluating the effect of temperature on growth rate.
Food Microbiology 28, 770 &ndash; 776. <a href="https://doi.org/10.1016/j.fm.2010.05.019">doi:10.1016/j.fm.2010.05.019</a>
</p>
<p>Huang, Lihan (2013) Introduction to USDA Integrated Pathogen Modeling
Program (IPMP). Residue Chemistry and Predictive Microbiology Research
Unit. USDA Agricultural Research Service.
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>,
<code><a href="#topic+ode_twostep">ode_twostep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time &lt;- seq(0, 30, length=200)
y    &lt;- grow_huang(time, c(y0=0.01, mumax=.1, K=0.1, alpha=1.5, lambda=3))[,"y"]
plot(time, y, type="l")
plot(time, y, type="l", log="y")

</code></pre>

<hr>
<h2 id='grow_logistic'>Logistic Growth Model</h2><span id='topic+grow_logistic'></span>

<h3>Description</h3>

<p>Classical logistic growth model written as analytical solution of the differential equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_logistic(time, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_logistic_+3A_time">time</code></td>
<td>
<p>vector of time steps (independent variable)</p>
</td></tr>
<tr><td><code id="grow_logistic_+3A_parms">parms</code></td>
<td>
<p>named parameter vector of the logistic growth model with:
</p>

<ul>
<li> <p><code>y0</code> initial value of population measure
</p>
</li>
<li> <p><code>mumax</code> intrinsic growth rate (1/time)
</p>
</li>
<li> <p><code>K</code> carrying capacity (max. total concentration of cells)
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation used is:
</p>
<p style="text-align: center;"><code class="reqn">y = (K * y0) / (y0 + (K - y0) * exp(-mumax * time))</code>
</p>



<h3>Value</h3>

<p>vector of dependent variable (<code>y</code>).
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>,
<code><a href="#topic+ode_twostep">ode_twostep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time &lt;- seq(0, 30, length=200)
y    &lt;- grow_logistic(time, c(y0=1, mumax=0.5, K=10))[,"y"]
plot(time, y, type="l")

</code></pre>

<hr>
<h2 id='grow_richards'>Growth Model According to Richards</h2><span id='topic+grow_richards'></span>

<h3>Description</h3>

<p>Richards growth model written as analytical solution of the differential equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_richards(time, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_richards_+3A_time">time</code></td>
<td>
<p>vector of time steps (independent variable).</p>
</td></tr>
<tr><td><code id="grow_richards_+3A_parms">parms</code></td>
<td>
<p>named parameter vector of the Richards growth model with:
</p>

<ul>
<li> <p><code>y0</code> initial value of abundance,
</p>
</li>
<li> <p><code>mumax</code> maximum growth rate (note different interpretation compared
to exponential growth),
</p>
</li>
<li> <p><code>K</code> carrying capacity (max. total concentration of cells),
</p>
</li>
<li> <p><code>beta</code> shape parameter determining the curvature.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation used is:
</p>
<p style="text-align: center;"><code class="reqn">y = K*(1-exp(-beta * mumax * time)*(1-(y0/K)^-beta))^(-1/beta)</code>
</p>

<p>The naming of parameters used here follows the convention of Tsoularis (2001),
but uses <code>mumax</code> for growthrate and <code>y</code> for abundance to make them
consistent to other growth functions.
</p>


<h3>Value</h3>

<p>vector of dependent variable (<code>y</code>).
</p>


<h3>References</h3>

<p>Richards, F. J. (1959) A Flexible Growth Function for Empirical Use.
Journal of Experimental Botany 10 (2): 290&ndash;300.
</p>
<p>Tsoularis, A. (2001) Analysis of Logistic Growth Models.
Res. Lett. Inf. Math. Sci, (2001) 2, 23&ndash;46.
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>,
<code><a href="#topic+ode_twostep">ode_twostep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time &lt;- seq(0, 30, length=200)
y    &lt;- grow_richards(time, c(y0=1, mumax=.5, K=10, beta=2))[,"y"]
plot(time, y, type="l")
y    &lt;- grow_richards(time, c(y0=1, mumax=.5, K=10, beta=100))[,"y"]
lines(time, y, col="red")
y    &lt;- grow_richards(time, c(y0=1, mumax=.5, K=10, beta=.2))[,"y"]
lines(time, y, col="blue")

</code></pre>

<hr>
<h2 id='growthmodel'>Create a User-defined Parametric Growth Model</h2><span id='topic+growthmodel'></span><span id='topic+user-defined'></span><span id='topic+functions'></span>

<h3>Description</h3>

<p>This constructor method allows to create user-defined functions
that can be used as parametric models describing time-dependent
growth of organisms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growthmodel(x, pnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growthmodel_+3A_x">x</code></td>
<td>
<p>a function with arguments <code>times</code> and <code>parms</code>, and
returning a matrix with two columns <code>time</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="growthmodel_+3A_pnames">pnames</code></td>
<td>
<p>character vector with the names of the model parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">growthrates</span> has a plug-in architecture allowing
user-defined growth models of the following form:
</p>
<pre>
  identifier &lt;- function(time, parms) {
    ... content of function here ...
    return(as.matrix(data.frame(time=time, y=y)))
  }
</pre>
<p>where <code>time</code> is a numeric vector and <code>parms</code> a named, non-nested
list of model parameters. The constructor function <code>growthmodel</code>
is used to attach the names of the parameters as an optional
attribute.
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>,
<code><a href="#topic+ode_twostep">ode_twostep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test &lt;- function(time, parms) {
  with(as.list(parms), {
    y &lt;- (K * y0) / (y0 + (K - y0) * exp(-mumax * time)) + y_shift
    return(as.matrix(data.frame(time=time, y=y)))
 })
}

mygrowthmodel &lt;- growthmodel(test, c("y0", "mumax", "K", "y_shift"))


</code></pre>

<hr>
<h2 id='growthmodel-class'>Class of Growth Model Functions</h2><span id='topic+growthmodel-class'></span>

<h3>Description</h3>

<p>This class is used for the parametric <code>grow_...</code> functions of the
package and can also be used for user-defined functions to describe
time-dependent growth of organisms.
</p>


<h3>See Also</h3>

<p>the constructor function <code><a href="#topic+growthmodel">growthmodel</a></code> how to create
instances of this class.
</p>

<hr>
<h2 id='growthrates_fit-class'>S4 Classes of Package <span class="pkg">growthrates</span></h2><span id='topic+growthrates_fit-class'></span><span id='topic+nonlinear_fit-class'></span><span id='topic+easylinear_fit-class'></span><span id='topic+smooth.spline_fit-class'></span><span id='topic+multiple_fits-class'></span><span id='topic+multiple_fits'></span><span id='topic+multiple_easylinear_fits-class'></span><span id='topic+multiple_nonlinear_fits-class'></span><span id='topic+multiple_smooth.spline_fits-class'></span>

<h3>Description</h3>

<p><code>growthrates_fit</code>: top-level class representing a growthrates fit with
any method.
</p>


<h3>Slots</h3>


<dl>
<dt><code>FUN</code></dt><dd><p>model function used.</p>
</dd>
<dt><code>fit</code></dt><dd><p>results of the model fit.</p>
</dd>
<dt><code>obs</code></dt><dd><p>observation data used for model fitting.</p>
</dd>
<dt><code>rsquared</code></dt><dd><p>coefficient of determination.</p>
</dd>
<dt><code>par</code></dt><dd><p>parameters of the fit.</p>
</dd>
<dt><code>ndx</code></dt><dd><p>index values of the time points used (for <code>easylinear_fit</code>).</p>
</dd>
<dt><code>xy</code></dt><dd><p>x and y values at the maximum of the spline.</p>
</dd>
</dl>

<hr>
<h2 id='growthrates-package'>Estimate Growth Rates from Experimental Data</h2><span id='topic+growthrates-package'></span><span id='topic+growthrates'></span>

<h3>Description</h3>

<p>A collection of methods to determine growth rates from
    experimental data, in particular from batch experiments and
    plate reader trials.
</p>
<p>The package contains basically three methods:
</p>

<ul>
<li><p> fit a linear regression to a subset of data with the steepest
log-linear increase (a method, similar to Hall et al., 2013),
</p>
</li>
<li><p> fit parametric nonlinear models to the complete data set, where the
model functions can be given either in closed form or as numerically
solved (system of) differential equation(s),
</p>
</li>
<li><p> use maximum of the 1st derivative of a smoothing spline with
log-transformed y-values (similar to Kahm et al., 2010).
</p>
</li></ul>

<p>The package can fit data sets of single experiments or complete series
containing multiple data sets. Included are functions for extracting
estimates and for plotting. The package supports growth models given as
numerically solved differential equations. Multi-core computation is used to
speed up fitting of parametric models.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt
</p>


<h3>References</h3>

<p>Hall, B. G., Acar, H. and Barlow, M. 2013. Growth Rates Made Easy.
Mol. Biol. Evol. 31, 232-238, <a href="https://doi.org/10.1093/molbev/mst197">doi:10.1093/molbev/mst197</a>
</p>
<p>Kahm, M., Hasenbrink, G., Lichtenberg-Frate, H., Ludwig, J., Kschischo, M.
2010. grofit: Fitting Biological Growth Curves with R.
Journal of Statistical Software, 33(7), 1-21,
<a href="https://doi.org/10.18637/jss.v033.i07">doi:10.18637/jss.v033.i07</a>
</p>
<p>Soetaert, K. and Petzoldt, T. 2010. Inverse Modelling, Sensitivity and
Monte Carlo Analysis in R Using Package FME.
Journal of Statistical Software, 33(3), 1-28,
<a href="https://doi.org/10.18637/jss.v033.i03">doi:10.18637/jss.v033.i03</a>
</p>
<p>Soetaert, K., Petzoldt, T. Setzer, R. W. 2010. Solving Differential Equations
in R: Package deSolve. Journal of Statistical Software, 33(9), 1-25,
<a href="https://doi.org/10.18637/jss.v033.i09">doi:10.18637/jss.v033.i09</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_easylinear">fit_easylinear</a></code>, <code><a href="#topic+fit_spline">fit_spline</a></code>, <code><a href="#topic+fit_growthmodel">fit_growthmodel</a></code>,
<code><a href="#topic+all_easylinear">all_easylinear</a></code>, <code><a href="#topic+all_splines">all_splines</a></code>, <code><a href="#topic+all_growthmodels">all_growthmodels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bactgrowth)
splitted.data &lt;- multisplit(bactgrowth, c("strain", "conc", "replicate"))

## get table from single experiment
dat &lt;- splitted.data[["D:0:1"]]

fit1 &lt;- fit_spline(dat$time, dat$value)
plot(fit1, log="y")
plot(fit1)

## derive start parameters from spline fit
p &lt;- coef(fit1)

## subset of first 10 data
first10 &lt;-  dat[1:10, ]
fit2 &lt;- fit_growthmodel(grow_exponential, p=p, time=first10$time, y=first10$value)

## use parameters from spline fit and take K from the data maximum
p &lt;- c(coef(fit1), K = max(dat$value))
fit3 &lt;- fit_growthmodel(grow_logistic, p=p, time=dat$time, y=dat$value, transform="log")

plot(fit1)
lines(fit2, col="green")
lines(fit3, col="red")

</code></pre>

<hr>
<h2 id='lm_or_NULL-class'>Union Class of Linear Model or NULL</h2><span id='topic+lm_or_NULL-class'></span>

<h3>Description</h3>

<p>Class to handle no-growth cases
</p>

<hr>
<h2 id='lm_window'>Fit Exponential Growth Model with a Heuristic Linear Method</h2><span id='topic+lm_window'></span><span id='topic+lm_parms'></span>

<h3>Description</h3>

<p>Helper functions for handling linear fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_window(x, y, i0, h = 5)

lm_parms(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_window_+3A_x">x</code></td>
<td>
<p>vector of independent variable (e.g. time).</p>
</td></tr>
<tr><td><code id="lm_window_+3A_y">y</code></td>
<td>
<p>vector of dependent variable (concentration of organisms).</p>
</td></tr>
<tr><td><code id="lm_window_+3A_i0">i0</code></td>
<td>
<p>index of first value used for a window.</p>
</td></tr>
<tr><td><code id="lm_window_+3A_h">h</code></td>
<td>
<p>with of the window (number of data).</p>
</td></tr>
<tr><td><code id="lm_window_+3A_m">m</code></td>
<td>
<p>linear model (<code>lm</code>) object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are used by a heuristic linear approach, similar to the
&ldquo;growth rates made easy&rdquo;-method of Hall et al. (2013).
</p>


<h3>Value</h3>

<p>linear model object (<code>lm_window</code>
resp. vector with parameters of the fit (lm_parms).
</p>


<h3>References</h3>

<p>Hall, B. G., H. Acar and M. Barlow 2013. Growth Rates Made Easy.
Mol. Biol. Evol. 31: 232-238 <a href="https://doi.org/10.1093/molbev/mst197">doi:10.1093/molbev/mst197</a>
</p>

<hr>
<h2 id='multisplit'>Split Data Frame into Multiple Groups</h2><span id='topic+multisplit'></span><span id='topic+multisplit+2Cdata.frame+2Cformula-method'></span><span id='topic+multisplit+2Cdata.frame+2Ccharacter-method'></span><span id='topic+multisplit+2Cdata.frame+2Cfactor-method'></span><span id='topic+multisplit+2Cdata.frame+2Clist-method'></span><span id='topic+multisplit+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>A data frame is split into a list of data subsets defined by multiple groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multisplit(data, grouping, drop = TRUE, sep = ":", ...)

## S4 method for signature 'data.frame,formula'
multisplit(data, grouping, drop = TRUE, sep = ":", ...)

## S4 method for signature 'data.frame,character'
multisplit(data, grouping, drop = TRUE, sep = ":", ...)

## S4 method for signature 'data.frame,factor'
multisplit(data, grouping, drop = TRUE, sep = ":", ...)

## S4 method for signature 'data.frame,list'
multisplit(data, grouping, drop = TRUE, sep = ":", ...)

## S4 method for signature 'ANY,ANY'
multisplit(data, grouping, drop = TRUE, sep = ":", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multisplit_+3A_data">data</code></td>
<td>
<p>data frame, matrix or vector containing several subsets of data</p>
</td></tr>
<tr><td><code id="multisplit_+3A_grouping">grouping</code></td>
<td>
<p>either a character vector containing the names of the grouping variables
or a model formula specifying dependent,
independent and grouping variables in the form:
<code>dependent ~ independent | group1 + group2 + ...</code>.
It may also be a factor or list of factors as in <code><a href="base.html#topic+split">split</a></code>.</p>
</td></tr>
<tr><td><code id="multisplit_+3A_drop">drop</code></td>
<td>
<p>if drop is TRUE, unused factor levels are dropped from the result.
The default is to drop all factor levels.</p>
</td></tr>
<tr><td><code id="multisplit_+3A_sep">sep</code></td>
<td>
<p>string to construct the new level labels by joining the
constituent ones.</p>
</td></tr>
<tr><td><code id="multisplit_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="base.html#topic+split">split</a></code>, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is wrapper around <code><a href="base.html#topic+split">split</a></code> with
different defaults, slightly different behavior, and methods for additional
argument classes. <code>multisplit</code> returns always a data frame.
</p>


<h3>Value</h3>

<p>list containing data frames of the data subsets as its elements.
The components of the list are named by their grouping levels.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+split">split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(bactgrowth)

## simple method
spl &lt;- multisplit(bactgrowth, c("strain", "conc", "replicate"))

## preferred method
spl &lt;- multisplit(bactgrowth, value ~ time | strain + conc + replicate)

## show what is in one data set
spl[[1]]
summary(spl[[1]])

## use factor combination
spl[["D:0:1"]]
summary(spl[["D:0:1"]])


lapply(spl, FUN=function(x)
 plot(x$time, x$value,
      main=paste(x[1, "strain"], x[1, "conc"], x[1, "replicate"], sep=":")))


</code></pre>

<hr>
<h2 id='names.growthmodel'>Get Names Attributes of Growth Models</h2><span id='topic+names.growthmodel'></span><span id='topic+names+2Cmultiple_fits-method'></span><span id='topic+names+3C-+2Cmultiple_fits-method'></span>

<h3>Description</h3>

<p>Methods to get the parameter names of a growth model or to get or set
identifiers of <code><a href="#topic+multiple_fits">multiple_fits</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'growthmodel'
names(x)

## S4 method for signature 'multiple_fits'
names(x)

## S4 replacement method for signature 'multiple_fits'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.growthmodel_+3A_x">x</code></td>
<td>
<p>either a function being a parametric growth model of
package <span class="pkg">growthmodels</span> or an object with multiple fits.</p>
</td></tr>
<tr><td><code id="names.growthmodel_+3A_value">value</code></td>
<td>
<p>a character vector of up to the same length as x, or NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of the parameter names
</p>


<h3>Methods</h3>


<dl>
<dt>Method for class <code><a href="#topic+growthmodel">growthmodel</a></code>:</dt><dd><p> returns information about
valid parameter names if a <code>pnames</code> attribute exists, else <code>NULL</code>.
<code>NULL</code>.</p>
</dd>
<dt>Method for class <code><a href="#topic+multiple_fits">multiple_fits</a></code>:</dt><dd><p> can be applied to objects
returned by <code>all_growthmodels</code>, <code>all_splines</code> or
<code>all_easylinear</code> respectively. This can be useful for selecting
subsets, e.g. for plotting, see example below.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+multiple_fits">multiple_fits</a></code>, <code><a href="#topic+all_growthmodels">all_growthmodels</a></code>,
<code><a href="#topic+all_splines">all_splines</a></code>, <code><a href="#topic+all_easylinear">all_easylinear</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## growthmodel-method
names(grow_baranyi)

## multiple_fits-method
L &lt;- all_splines(value ~ time | strain + conc + replicate,
       data = bactgrowth)

names(L)

## plot only the 'R' strain
par(mfrow=c(4, 6))
plot(L[grep("R:", names(L))])


</code></pre>

<hr>
<h2 id='ode_genlogistic'>Generalized Logistic Growth Model</h2><span id='topic+ode_genlogistic'></span><span id='topic+grow_genlogistic'></span>

<h3>Description</h3>

<p>Generalized logistic growth model solved as differential equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode_genlogistic(time, y, parms, ...)

grow_genlogistic(time, parms, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ode_genlogistic_+3A_time">time</code></td>
<td>
<p>vector of simulation time steps</p>
</td></tr>
<tr><td><code id="ode_genlogistic_+3A_y">y</code></td>
<td>
<p>named vector with initial value of the system (e.g. cell concentration)</p>
</td></tr>
<tr><td><code id="ode_genlogistic_+3A_parms">parms</code></td>
<td>
<p>parameters of the generalized logistic growth model
</p>

<ul>
<li> <p><code>mumax</code> maximum growth rate (1/time)
</p>
</li>
<li> <p><code>K</code> carrying capacity (max. abundance)
</p>
</li>
<li> <p><code>alpha, beta, gamma</code> parameters determining the shape of growth.
Setting all values to one returns the ordinary logistic function.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ode_genlogistic_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the <code>ode</code>-function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is given as its first derivative:
</p>
<p style="text-align: center;"><code class="reqn">dy/dt = mumax * y^alpha * (1-(y/K)^beta)^gamma</code>
</p>

<p>that is then numerically integrated ('simulated') according to time (t).
</p>
<p>The generalized logistic according to Tsoularis (2001) is a flexible
model that covers exponential and logistic growth, Richards, Gompertz, von
Bertalanffy, and some more as special cases.
</p>
<p>The differential equation is solved numerically, where function
<code>ode_genlogistic</code> is the differential equation, and
<code>grow_genlogistic</code> runs a numerical simulation over time.
</p>
<p>The default version <code>grow_genlogistic</code> is run directly as compiled code,
whereas the R versions <code>ode_logistic</code> is
provided for testing by the user.
</p>


<h3>Value</h3>

<p>For <code>ode_genlogistic</code>: matrix containing the simulation outputs.
The return value of has also class <code>deSolve</code>.
</p>
<p>For <code>grow_genlogistic</code>: vector of dependent variable (<code>y</code>).
</p>

<ul>
<li> <p><code>time</code> time of the simulation
</p>
</li>
<li> <p><code>y</code> abundance of organisms
</p>
</li></ul>



<h3>References</h3>

<p>Tsoularis, A. (2001) Analysis of Logistic Growth Models.
Res. Lett. Inf. Math. Sci, (2001) 2, 23-46.
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_twostep">ode_twostep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time &lt;- seq(0, 30, length=200)
parms &lt;- c(mumax=0.5, K=10, alpha=1, beta=1, gamma=1)
y0    &lt;-  c(y=.1)
out   &lt;- ode(y0, time, ode_genlogistic, parms)
plot(out)

out2 &lt;- ode(y0, time, ode_genlogistic, parms = c(mumax=0.2, K=10, alpha=2, beta=1, gamma=1))
out3 &lt;- ode(y0, time, ode_genlogistic, parms = c(mumax=0.2, K=10, alpha=1, beta=2, gamma=1))
out4 &lt;- ode(y0, time, ode_genlogistic, parms = c(mumax=0.2, K=10, alpha=1, beta=1, gamma=2))
out5 &lt;- ode(y0, time, ode_genlogistic, parms = c(mumax=0.2, K=10, alpha=.5, beta=1, gamma=1))
out6 &lt;- ode(y0, time, ode_genlogistic, parms = c(mumax=0.2, K=10, alpha=1, beta=.5, gamma=1))
out7 &lt;- ode(y0, time, ode_genlogistic, parms = c(mumax=0.3, K=10, alpha=1, beta=1, gamma=.5))
plot(out, out2, out3, out4, out5, out6, out7)

## growth with lag (cf. log_y)
plot(ode(y0, time, ode_genlogistic, parms = c(mumax=1, K=10, alpha=2, beta=.8, gamma=5)))


</code></pre>

<hr>
<h2 id='ode_twostep'>Twostep Growth Model</h2><span id='topic+ode_twostep'></span><span id='topic+grow_twostep'></span>

<h3>Description</h3>

<p>System of two differential equations describing bacterial growth as two-step
process of activation (or adaptation) and growth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode_twostep(time, y, parms, ...)

grow_twostep(time, parms, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ode_twostep_+3A_time">time</code></td>
<td>
<p>actual time (for the ode) resp. vector of simulation time steps.</p>
</td></tr>
<tr><td><code id="ode_twostep_+3A_y">y</code></td>
<td>
<p>named vector with state of the system
(yi, ya: abundance of inactive and active organisms, e.g.
concentration of inactive resp. active cells).</p>
</td></tr>
<tr><td><code id="ode_twostep_+3A_parms">parms</code></td>
<td>
<p>parameters of the two-step growth model:
</p>

<ul>
<li> <p><code>yi, ya</code> initial abundance of active and inactive organisms,
</p>
</li>
<li> <p><code>kw</code> activation (&ldquo;wakeup&rdquo;) constant (1/time),
</p>
</li>
<li> <p><code>mumax</code> maximum growth rate (1/time),
</p>
</li>
<li> <p><code>K</code> carrying capacity (max. abundance).
</p>
</li></ul>
</td></tr>
<tr><td><code id="ode_twostep_+3A_...">...</code></td>
<td>
<p>placeholder for additional parameters (for user-extended versions of this function)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is given as a system of two differential equations:
</p>
<p style="text-align: center;"><code class="reqn">dy_i/dt = -kw * yi</code>
</p>

<p style="text-align: center;"><code class="reqn">dy_a/dt =  kw * yi + mumax * (1 - (yi + ya)/K) * ya</code>
</p>

<p>that are then numerically integrated ('simulated') according to time (t). The
model assumes that the population consists of active (<code class="reqn">y_a</code>) and inactive
(<code class="reqn">y_i</code>) cells so that the observed abundance is (<code class="reqn">y = y_i + y_a</code>).
Adapting inactive cells change to the active state with a first order 'wakeup'
rate (<code class="reqn">kw</code>).
</p>
<p>Function <code>ode_twostep</code> is the system of differential equations,
whereas <code>grow_twostep</code> runs a numerical simulation over time.
</p>
<p>A similar two-compartment model, but without the logistic term, was discussed by Baranyi (1998).
</p>


<h3>Value</h3>

<p>For <code>ode_twostep</code>: matrix containing the simulation outputs.
The return value of has also class <code>deSolve</code>.
</p>
<p>For <code>grow_twostep</code>: vector of dependent variable (<code>y</code>):
</p>

<ul>
<li> <p><code>time</code> time of the simulation
</p>
</li>
<li> <p><code>yi</code> concentration of inactive cells
</p>
</li>
<li> <p><code>ya</code> concentration of active cells
</p>
</li>
<li> <p><code>y</code> total cell concentration
</p>
</li></ul>



<h3>References</h3>

<p>Baranyi, J. (1998). Comparison of stochastic and deterministic concepts of bacterial lag.
J. heor. Biol. 192, 403&ndash;408.
</p>


<h3>See Also</h3>

<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>
</p>
<p>Other growth models: 
<code><a href="#topic+grow_baranyi">grow_baranyi</a>()</code>,
<code><a href="#topic+grow_exponential">grow_exponential</a>()</code>,
<code><a href="#topic+grow_gompertz2">grow_gompertz2</a>()</code>,
<code><a href="#topic+grow_gompertz">grow_gompertz</a>()</code>,
<code><a href="#topic+grow_huang">grow_huang</a>()</code>,
<code><a href="#topic+grow_logistic">grow_logistic</a>()</code>,
<code><a href="#topic+grow_richards">grow_richards</a>()</code>,
<code><a href="#topic+growthmodel">growthmodel</a></code>,
<code><a href="#topic+ode_genlogistic">ode_genlogistic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
time &lt;- seq(0, 30, length=200)
parms &lt;- c(kw = 0.1,	mumax=0.2, K=0.1)
y0    &lt;-  c(yi=0.01, ya=0.0)
out   &lt;- ode(y0, time, ode_twostep, parms)

plot(out)

o &lt;- grow_twostep(0:100, c(yi=0.01, ya=0.0, kw = 0.1,	mumax=0.2, K=0.1))
plot(o)

</code></pre>

<hr>
<h2 id='parse_formula'>Simple Formula Interface</h2><span id='topic+parse_formula'></span>

<h3>Description</h3>

<p>This simple formula interface handles formulae of the form
<code>dependent ~ independent | group1 + group2 + ...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_formula(grouping)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_formula_+3A_grouping">grouping</code></td>
<td>
<p>a model formula specifying dependent,
independent and grouping variables in the form:
<code>dependent ~ independent | group1 + group2 + ...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code><a href="#topic+multisplit">multisplit</a></code> and normally not called
by the user.
</p>


<h3>Value</h3>

<p>a list with the elements <code>valuevar</code>,  <code>timevar</code>, and
<code>groups</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multisplit">multisplit</a></code>,  <code><a href="base.html#topic+split">split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
parse_formula(y ~ x | a+b+c)

</code></pre>

<hr>
<h2 id='parse_formula_nonlin'>Simple Formula Interface for Grouped Nonlinear Functions</h2><span id='topic+parse_formula_nonlin'></span>

<h3>Description</h3>

<p>This simple formula interface handles formulae of the form
<code>dependent ~ FUN(independent, parms) | group1 + group2 + ...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_formula_nonlin(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_formula_nonlin_+3A_formula">formula</code></td>
<td>
<p>a model formula specifying dependent and
independent variables, nonlinear model and grouping variables in the form:
<code>dependent ~ FUN(independent, parms) | group1 + group2 + ...</code>.
FUN can be a name of an existing growth model (e.g. <code>grow_logistic</code>)
or a valid user-defined function (see <code><a href="#topic+growthmodel">growthmodel</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code><a href="#topic+all_growthmodels">all_growthmodels</a></code> and normally not
called for the user.
</p>


<h3>Value</h3>

<p>a list with the elements <code>FUN</code>, <code>valuevar</code>,  <code>timevar</code>,
and <code>groups</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multisplit">multisplit</a></code>,  <code><a href="base.html#topic+split">split</a></code>,  <code><a href="#topic+parse_formula">parse_formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ret &lt;- parse_formula_nonlin(y ~ f(x, parms) | a + b + c)

</code></pre>

<hr>
<h2 id='plot'>Plot Model Fits</h2><span id='topic+plot'></span><span id='topic+plot+2Cnonlinear_fit+2Cmissing-method'></span><span id='topic+lines+2Cnonlinear_fit-method'></span><span id='topic+plot+2Ceasylinear_fit+2Cmissing-method'></span><span id='topic+plot+2Csmooth.spline_fit+2Cmissing-method'></span><span id='topic+lines+2Ceasylinear_fit-method'></span><span id='topic+plot+2Cmultiple_fits+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods to plot growth model fits together with the data and, alternatively,
plot diagnostics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nonlinear_fit,missing'
plot(x, y, log = "", which = c("fit", "diagnostics"), ...)

## S4 method for signature 'nonlinear_fit'
lines(x, ...)

## S4 method for signature 'easylinear_fit,missing'
plot(x, y, log = "", which = c("fit", "diagnostics"), ...)

## S4 method for signature 'smooth.spline_fit,missing'
plot(x, y, ...)

## S4 method for signature 'easylinear_fit'
lines(x, ...)

## S4 method for signature 'multiple_fits,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>an object returned by a model fitting function of package
<span class="pkg">growthrates</span>, that can contain one or multiple fits.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>(ignored) for compatibility with the default plot method.</p>
</td></tr>
<tr><td><code id="plot_+3A_log">log</code></td>
<td>
<p>a character string which contains <code>"y"</code> if the y axis is to
be logarithmic.</p>
</td></tr>
<tr><td><code id="plot_+3A_which">which</code></td>
<td>
<p>either <code>"fit"</code> (default) or <code>"diagnostics"</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>other arguments pased to the plotting methods,
see <code><a href="graphics.html#topic+plot.default">plot.default</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot methods detect automatically which type of plot is
appropriate, depending on the class of <code>x</code> and can plot either one
single model fit or a complete series (multiple fits). In the latter case
it may be wise to redirect the graphics to an external file (e.g. a pdf)
and / or to use tomething like <code>par(mfrow=c(3,3))</code>.
</p>
<p>The <code>lines</code>-method is currently only available for single fits.
</p>
<p>If you need more control, you can of course also write own plotting functions.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="#topic+fit_growthmodel">fit_growthmodel</a></code>, <code><a href="#topic+fit_easylinear">fit_easylinear</a></code>,
<code><a href="#topic+all_growthmodels">all_growthmodels</a></code>, <code><a href="#topic+all_easylinear">all_easylinear</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bactgrowth)
splitted.data &lt;- multisplit(bactgrowth, c("strain", "conc", "replicate"))

## get table from single experiment
dat &lt;- splitted.data[["D:0:1"]]

fit1 &lt;- fit_spline(dat$time, dat$value)
plot(fit1, log="y")
plot(fit1)

## derive start parameters from spline fit
p &lt;- coef(fit1)

## subset of first 10 data
first10 &lt;-  dat[1:10, ]
fit2 &lt;- fit_growthmodel(grow_exponential, p=p, time=first10$time, y=first10$value)

p &lt;- c(coef(fit1), K = max(dat$value))
fit3 &lt;- fit_growthmodel(grow_logistic, p=p, time=dat$time, y=dat$value, transform="log")

plot(fit1)
lines(fit2, col="green")
lines(fit3, col="red")


all.fits &lt;- all_splines(value ~ time | strain + conc + replicate, data = bactgrowth)
par(mfrow=c(3,3))
plot(all.fits)

## it is also possible to plot a single fit or a subset of the fits
par(mfrow=c(1,1))
plot(all.fits[["D:0:1"]])
par(mfrow=c(2,2))
plot(all.fits[1:4])

## plot only the 'R' strain
par(mfrow=c(4, 6))
plot(all.fits[grep("R:", names(all.fits))])

</code></pre>

<hr>
<h2 id='predict+2Cgrowthrates_fit-method'>Model Predictions for <span class="pkg">growthrates</span> Fits</h2><span id='topic+predict+2Cgrowthrates_fit-method'></span><span id='topic+predict+2Csmooth.spline_fit-method'></span><span id='topic+predict+2Ceasylinear_fit-method'></span><span id='topic+predict+2Cnonlinear_fit-method'></span><span id='topic+predict+2Cmultiple_fits-method'></span>

<h3>Description</h3>

<p>Class-specific methods of package <span class="pkg">growthrates</span> to make predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'growthrates_fit'
predict(object, ...)

## S4 method for signature 'smooth.spline_fit'
predict(object, newdata = NULL, ..., type = c("exponential", "spline"))

## S4 method for signature 'easylinear_fit'
predict(object, newdata = NULL, ..., type = c("exponential", "no_lag"))

## S4 method for signature 'nonlinear_fit'
predict(object, newdata, ...)

## S4 method for signature 'multiple_fits'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict+2B2Cgrowthrates_fit-method_+3A_object">object</code></td>
<td>
<p>name of a 'growthrates' object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict+2B2Cgrowthrates_fit-method_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
<tr><td><code id="predict+2B2Cgrowthrates_fit-method_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame with column 'time' for new time steps with
which to predict.</p>
</td></tr>
<tr><td><code id="predict+2B2Cgrowthrates_fit-method_+3A_type">type</code></td>
<td>
<p>type of predict. Can be <code>'exponential'</code> or <code>'spline'</code> for <code>fit_spline</code>,
resp. code'exponential' or <code>'no_lag'</code> for <code>fit_easylinear</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of the predict methods is still experimental and under discussion.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+methods">methods</a></code>, <code><a href="stats.html#topic+predict.smooth.spline">predict.smooth.spline</a></code>,
<code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, <code><a href="stats.html#topic+predict.nls">predict.nls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bactgrowth)
splitted.data &lt;- multisplit(bactgrowth, c("strain", "conc", "replicate"))

## get table from single experiment
dat &lt;- splitted.data[[1]]

## --- linear fit -----------------------------------------------------------
fit &lt;- fit_easylinear(dat$time, dat$value)

plot(fit)
pr &lt;- predict(fit)
lines(pr[,1:2], col="blue", lwd=2, lty="dashed")

pr &lt;- predict(fit, newdata=list(time=seq(2, 6, .1)), type="no_lag")
lines(pr[,1:2], col="magenta")


## --- spline fit -----------------------------------------------------------
fit1 &lt;- fit_spline(dat$time, dat$value, spar=0.5)
coef(fit1)
summary(fit1)

plot(fit1)
pr &lt;- predict(fit1)
lines(pr[,1:2], lwd=2, col="blue", lty="dashed")
pr &lt;- predict(fit1, newdata=list(time=2:10), type="spline")
lines(pr[,1:2], lwd=2, col="cyan")


## --- nonlinear fit --------------------------------------------------------
dat &lt;- splitted.data[["T:0:2"]]

p   &lt;- c(y0 = 0.02, mumax = .5, K = 0.05, h0 = 1)
fit2 &lt;- fit_growthmodel(grow_baranyi, p=p, time=dat$time, y=dat$value)

## prediction for given data
predict(fit2)

## prediction for new data
pr &lt;- predict(fit2, newdata=data.frame(time=seq(0, 50, 0.1)))

plot(fit2, xlim=c(0, 50))
lines(pr[, c("time", "y")], lty="dashed", col="red")
</code></pre>

<hr>
<h2 id='rsquared'>Additional Generic Functions</h2><span id='topic+rsquared'></span><span id='topic+obs'></span><span id='topic+results'></span>

<h3>Description</h3>

<p>These functions are specifically defined for package <span class="pkg">growthrates</span>,
all other generics are imported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsquared(object, ...)

obs(object, ...)

results(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsquared_+3A_object">object</code></td>
<td>
<p>name of a 'growthrate' object</p>
</td></tr>
<tr><td><code id="rsquared_+3A_...">...</code></td>
<td>
<p>other arguments passed to the methods</p>
</td></tr>
</table>

<hr>
<h2 id='rsquared+2Cgrowthrates_fit-method'>Accessor Methods of Package <span class="pkg">growthrates</span>.</h2><span id='topic+rsquared+2Cgrowthrates_fit-method'></span><span id='topic+obs+2Cgrowthrates_fit-method'></span><span id='topic+coef+2Cgrowthrates_fit-method'></span><span id='topic+coef+2Ceasylinear_fit-method'></span><span id='topic+coef+2Csmooth.spline_fit-method'></span><span id='topic+deviance+2Cgrowthrates_fit-method'></span><span id='topic+summary+2Cgrowthrates_fit-method'></span><span id='topic+summary+2Cnonlinear_fit-method'></span><span id='topic+residuals+2Cgrowthrates_fit-method'></span><span id='topic+df.residual+2Cgrowthrates_fit-method'></span><span id='topic+summary+2Csmooth.spline_fit-method'></span><span id='topic+df.residual+2Csmooth.spline_fit-method'></span><span id='topic+deviance+2Csmooth.spline_fit-method'></span><span id='topic+coef+2Cmultiple_fits-method'></span><span id='topic+rsquared+2Cmultiple_fits-method'></span><span id='topic+deviance+2Cmultiple_fits-method'></span><span id='topic+results+2Cmultiple_fits-method'></span><span id='topic+results+2Cmultiple_easylinear_fits-method'></span><span id='topic+summary+2Cmultiple_fits-method'></span><span id='topic+residuals+2Cmultiple_fits-method'></span>

<h3>Description</h3>

<p>Functions to access the results of fitted growthrate objects:  <code>summary</code>,
<code>coef</code>, <code>rsquared</code>, <code>deviance</code>, <code>residuals</code>,
<code>df.residual</code>, <code>obs</code>, <code>results</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'growthrates_fit'
rsquared(object, ...)

## S4 method for signature 'growthrates_fit'
obs(object, ...)

## S4 method for signature 'growthrates_fit'
coef(object, extended = FALSE, ...)

## S4 method for signature 'easylinear_fit'
coef(object, ...)

## S4 method for signature 'smooth.spline_fit'
coef(object, extended = FALSE, ...)

## S4 method for signature 'growthrates_fit'
deviance(object, ...)

## S4 method for signature 'growthrates_fit'
summary(object, ...)

## S4 method for signature 'nonlinear_fit'
summary(object, cov = TRUE, ...)

## S4 method for signature 'growthrates_fit'
residuals(object, ...)

## S4 method for signature 'growthrates_fit'
df.residual(object, ...)

## S4 method for signature 'smooth.spline_fit'
summary(object, cov = TRUE, ...)

## S4 method for signature 'smooth.spline_fit'
df.residual(object, ...)

## S4 method for signature 'smooth.spline_fit'
deviance(object, ...)

## S4 method for signature 'multiple_fits'
coef(object, ...)

## S4 method for signature 'multiple_fits'
rsquared(object, ...)

## S4 method for signature 'multiple_fits'
deviance(object, ...)

## S4 method for signature 'multiple_fits'
results(object, ...)

## S4 method for signature 'multiple_easylinear_fits'
results(object, ...)

## S4 method for signature 'multiple_fits'
summary(object, ...)

## S4 method for signature 'multiple_fits'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsquared+2B2Cgrowthrates_fit-method_+3A_object">object</code></td>
<td>
<p>name of a 'growthrate' object.</p>
</td></tr>
<tr><td><code id="rsquared+2B2Cgrowthrates_fit-method_+3A_...">...</code></td>
<td>
<p>other arguments passed to the methods.</p>
</td></tr>
<tr><td><code id="rsquared+2B2Cgrowthrates_fit-method_+3A_extended">extended</code></td>
<td>
<p>boolean if extended set of parameters shoild be printed</p>
</td></tr>
<tr><td><code id="rsquared+2B2Cgrowthrates_fit-method_+3A_cov">cov</code></td>
<td>
<p>boolean if the covariance matrix should be printed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bactgrowth)
splitted.data &lt;- multisplit(bactgrowth, c("strain", "conc", "replicate"))

## get table from single experiment
dat &lt;- splitted.data[[10]]

fit1 &lt;- fit_spline(dat$time, dat$value, spar=0.5)
coef(fit1)
summary(fit1)

## derive start parameters from spline fit
p &lt;- c(coef(fit1), K = max(dat$value))
fit2 &lt;- fit_growthmodel(grow_logistic, p=p, time=dat$time, y=dat$value, transform="log")
coef(fit2)
rsquared(fit2)
deviance(fit2)

summary(fit2)

plot(residuals(fit2) ~ obs(fit2)[,2])


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
