<!DOCTYPE html><html><head><title>Help for package grt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grt-package'>
<p>General Recognition Theory</p></a></li>
<li><a href='#coef.glc'><p>Extract 'glc' or 'gcjc' coefficients</p></a></li>
<li><a href='#dprime'><p>Calculate d' (d-prime)</p></a></li>
<li><a href='#extractAIC'><p>extractAIC method for class 'glc', 'gqc', 'gcjc', and 'grg'</p></a></li>
<li><a href='#gaborPatch'>
<p>Draw a gray-scale Gabor Patch</p></a></li>
<li><a href='#gcjc'><p>General Conjunctive Classifier</p></a></li>
<li><a href='#gcjcStruct'><p>General Conjunctive Classifier structure</p></a></li>
<li><a href='#glc'><p>General Linear Classifier</p></a></li>
<li><a href='#glcStruct'><p>General Linear Classifier structure</p></a></li>
<li><a href='#gqc'><p>General Quadratic Classifier</p></a></li>
<li><a href='#gqcStruct'><p>General Quadratic Classifier structure.</p></a></li>
<li><a href='#grg'><p>General Random Guessing model</p></a></li>
<li><a href='#grtMeans'><p>Obtain means of two multivariate normal populations satisfying certain criteria</p></a></li>
<li><a href='#grtrnorm'><p>Sample from multiple multivariate normal distributions</p></a></li>
<li><a href='#ldb'><p>Linear Decision Bound</p></a></li>
<li><a href='#ldb.p.correct'><p>Probability of correct classification based on the optimal linear decision bound.</p></a></li>
<li><a href='#lines.gqcStruct'><p>lines Method for class 'gqc'</p></a></li>
<li><a href='#logLik.glc'><p>Log-Likelihood of a 'glc' or 'gcjc' Object</p></a></li>
<li><a href='#logLik.glcStruct'><p>Log-Likelihood of a 'glcStruct' or 'gcjcStruct' Object</p></a></li>
<li><a href='#logLik.gqc'><p>Log-Likelihood of a 'gqc' Object</p></a></li>
<li><a href='#logLik.gqcStruct'><p>Log-Likelihood of a 'gqcStruct' Object</p></a></li>
<li><a href='#mcovs'><p>Calculate sample means and covariance(s) of multivariate data</p></a></li>
<li><a href='#new2old_par'><p>Convert 'new' to 'old' glcStruct format</p></a></li>
<li><a href='#old2new_par'><p>Convert 'old' to 'new' glcStruct format</p></a></li>
<li><a href='#plot.gcjc'><p>Plot Method for Class 'gcjc'</p></a></li>
<li><a href='#plot.glc'><p>Plot Method for Class 'glc'</p></a></li>
<li><a href='#plot.gqc'><p>plot Method for Class 'gqc'</p></a></li>
<li><a href='#plot3d.glc'><p>plot3d Method for Class 'glc'</p></a></li>
<li><a href='#plot3d.gqc'><p>plot3d Method for Class 'gqc'</p></a></li>
<li><a href='#predict.glc'><p>predict method for General Linear Classifier</p></a></li>
<li><a href='#qdb'><p>Quadratic Decision Bound</p></a></li>
<li><a href='#qdb.p.correct'><p>the proportion correct of the quadratic decision boundary.</p></a></li>
<li><a href='#scale'><p>Scale method for the class 'glc' and 'gqc'</p></a></li>
<li><a href='#subjdemo_1d'>
<p>Sample dataset of a categorization experiment with 1D stimuli.</p></a></li>
<li><a href='#subjdemo_2d'>
<p>Sample dataset of a categorization experiment with 2D stimuli.</p></a></li>
<li><a href='#subjdemo_3d'>
<p>Sample dataset of a categorization experiment with 3D stimuli.</p></a></li>
<li><a href='#subjdemo_cj'>
<p>Sample dataset of a categorization experiment with 2D conjunctive stimuli.</p></a></li>
<li><a href='#unscale'><p>Un-scale or re-center the scaled or centered Matrix-like object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>General Recognition Theory</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-07-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Kazunaga Matsuki</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andy Wills &lt;andy@willslab.co.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to generate and analyze data for psychology experiments based on the General Recognition Theory.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), grDevices, graphics, stats, utils, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, misc3d</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-14 10:37:38 UTC; andy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-07-14 17:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='grt-package'>
General Recognition Theory
</h2><span id='topic+grt-package'></span><span id='topic+grt'></span>

<h3>Description</h3>

<p>Functions to generate and analyze data for psychology experiments based
on the General Recognition Theory.
</p>


<h3>Details</h3>

<p>This package is written based mostly on the GRT Toolbox for MATLAB by
Alfonso-Reese (2006), although many functions have been renamed and
modified from the original in order to make them more general and
&ldquo;R-like.&rdquo;
</p>
<p>The functions <code><a href="#topic+grtrnorm">grtrnorm</a></code> and <code><a href="#topic+grtMeans">grtMeans</a></code> are
used for design categorization experiments and generating stimuli. The
functions <code><a href="#topic+glc">glc</a></code>, <code><a href="#topic+gcjc">gcjc</a></code>, <code><a href="#topic+gqc">gqc</a></code>,
and <code><a href="#topic+grg">grg</a></code> are used for fitting the general linear
classifier, the general conjunctive classifier, the general quadratic
classifier, and the general random guessing model, respectively. The
<code><a href="#topic+glc">glc</a></code>, <code><a href="#topic+gcjc">gcjc</a></code>, and <code><a href="#topic+gqc">gqc</a></code> have plot
methods (<code><a href="#topic+plot.glc">plot.glc</a></code>, <code><a href="#topic+plot.gcjc">plot.gcjc</a></code>,
<code><a href="#topic+plot.gqc">plot.gqc</a></code>, <code><a href="#topic+plot3d.glc">plot3d.glc</a></code>,
<code><a href="#topic+plot3d.gqc">plot3d.gqc</a></code>).
</p>
<p>For a complete list of functions, use <code>library(help =
    "catlearn")</code>.
</p>


<h3>Author(s)</h3>

<p>Kazunaga Matsuki
</p>
<p>Maintainer: Andy Wills <a href="mailto:andy@willslab.co.uk">andy@willslab.co.uk</a>
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006) <em>General recognition theory of
categorization: A MATLAB toolbox</em>.  Behavior Research Methods, 38,
579-583.
</p>
<p>Ashby, F. G., &amp; Gott, R. E. (1988). <em>Decision rules in the
perception and categorization of multidimensional stimuli</em>.  Journal
of Experimental Psychology: Learning, Memory, &amp; Cognition, 14, 33-53.
</p>
<p>Ashby, F. G. (1992) <em>Multidimensional models of perception and
cognition</em>.  Lawrence Erlbaum Associates.  </p>

<hr>
<h2 id='coef.glc'>Extract 'glc' or 'gcjc' coefficients</h2><span id='topic+coef.glc'></span><span id='topic+coef.glcStruct'></span><span id='topic+coef.gcjc'></span>

<h3>Description</h3>

<p>Extracts the coefficients from the model object <code>glc</code>, <code>glcStruct</code>, or <code>gcjc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glc'
coef(object, ...)

## S3 method for class 'glcStruct'
coef(object, ...)

## S3 method for class 'gcjc'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.glc_+3A_object">object</code></td>
<td>
<p>object of class <code>glc</code> or <code>glcStruct</code></p>
</td></tr>
<tr><td><code id="coef.glc_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both the object <code>glc</code> and <code>glcStruct</code> contain the parameters for the decision boundary in the form: 
</p>
<p style="text-align: center;"><code class="reqn">
   a_1x_1 + a_2x_2 \ldots a_nx_n + b = 0
</code>
</p>

<p>This function transforms and returns the coefficients of the function solved with respect the <code class="reqn">x_n</code>.
</p>
<p>For the object <code>gcjc</code>, a list of two coefficients (Intercepts) are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
fit.2dl &lt;- glc(response ~ x + y, data=subjdemo_2d,
    category=subjdemo_2d$category, zlimit=7)
plot(fit.2dl, fitdb=FALSE)
abline(coef(fit.2dl), col = "red")
abline(coef(fit.2dl$initpar))

fit.1dx &lt;- update(fit.2dl, . ~ . -y)
abline(v=coef(fit.1dx), col="green")

fit.1dy &lt;- update(fit.2dl, . ~ . -x)
abline(h=coef(fit.1dy), col="blue")
</code></pre>

<hr>
<h2 id='dprime'>Calculate d' (d-prime)</h2><span id='topic+dprime'></span><span id='topic+dprimef'></span>

<h3>Description</h3>

<p>Obtain the standardized distance between the two probability distributions, known as d' or sensitivity index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprime(x,
    category,
    response,
    par = list(),
    zlimit = Inf,
    type = c("SampleIdeal", "Observer"))

dprimef(means, covs, noise=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dprime_+3A_x">x</code></td>
<td>
<p>a data frame or matrix containing samples from two multivariate normal distributions.</p>
</td></tr>
<tr><td><code id="dprime_+3A_category">category</code></td>
<td>
<p>a vector or factor of labels of populations to which the samples belong</p>
</td></tr>
<tr><td><code id="dprime_+3A_response">response</code></td>
<td>
<p>a vector or factor specifying the participant's classification responses for each samples</p>
</td></tr>
<tr><td><code id="dprime_+3A_par">par</code></td>
<td>
<p>object of class <code>glcStruct</code> or a named list containing a set of parameters that specify a general linear decision bound. The list should contain <code>noise</code>, <code>coeffs</code>, <code>bias</code>.</p>
</td></tr>
<tr><td><code id="dprime_+3A_zlimit">zlimit</code></td>
<td>
<p>numeric. The z-scores (or discriminant scores) beyond the specified value will be truncated and replaced with that value. Default to <code>Inf</code></p>
</td></tr>
<tr><td><code id="dprime_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of d' to be returned. If <code>SampleIdeal</code>, d' is calculated based on ideal (or true) category membership as specified in <code>category</code>. If <code>Observer</code>, d' is calculated using the <code>response</code> vector as a grouping factor.</p>
</td></tr>
<tr><td><code id="dprime_+3A_means">means</code></td>
<td>
<p>a list of numeric vectors containing the means of two distributions</p>
</td></tr>
<tr><td><code id="dprime_+3A_covs">covs</code></td>
<td>
<p>a matrix or a list of matrices containing the variance-covariance matrix of the two distributions</p>
</td></tr>
<tr><td><code id="dprime_+3A_noise">noise</code></td>
<td>
<p>numeric. perceptual and criterial noise expressed as standard deviation. Default to <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>dprime</code> estimates d' from sample data sets, whereas the function <code>dprimef</code> calculates it from population parameters.
</p>
<p>In <code>dprime</code>, if any parts of the argument <code>par</code> are missing, the function will estimate an optimal linear decision bound from supplied <code>x</code> and <code>category</code>. The argument <code>response</code> is not used if <code>type</code> is <code>SampleIdeal</code>.
</p>


<h3>Author(s)</h3>

<p>Author of the original Matlab routines: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
d2 &lt;- subjdemo_2d
db &lt;- glcStruct(noise=10, coeffs=c(0.514,-0.857),bias=-0.000154)
dprime(d2[,2:3], d2$category, d2$response, par = db, zlimit=7, type='SampleIdeal')

mc &lt;- mcovs(category ~ x + y, data=d2)
dprimef(mc$means, mc$covs)
</code></pre>

<hr>
<h2 id='extractAIC'>extractAIC method for class 'glc', 'gqc', 'gcjc', and 'grg'</h2><span id='topic+extractAIC.glc'></span><span id='topic+extractAIC.gqc'></span><span id='topic+extractAIC.grg'></span><span id='topic+extractAIC.gcjc'></span>

<h3>Description</h3>

<p>Extract Akaike's An Information Criteria from a General Linear, Quadratic, or Conjunctive Classifier, or a General Random Guessing model</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glc'
extractAIC(fit, scale, k = 2, ...)

## S3 method for class 'gqc'
extractAIC(fit, scale, k = 2, ...)

## S3 method for class 'gcjc'
extractAIC(fit, scale, k = 2, ...)

## S3 method for class 'grg'
extractAIC(fit, scale, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractAIC_+3A_fit">fit</code></td>
<td>
<p>object of class <code>glc</code>, <code>gqc</code>, <code>gcjc</code>, or <code>grg</code></p>
</td></tr>
<tr><td><code id="extractAIC_+3A_scale">scale</code></td>
<td>
<p>unused argument</p>
</td></tr>
<tr><td><code id="extractAIC_+3A_k">k</code></td>
<td>
<p>numeric specifying the penalty per parameter to be used in calculating AIC. Default to 2.</p>
</td></tr>
<tr><td><code id="extractAIC_+3A_...">...</code></td>
<td>
<p>further arguments (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As with the default method, the criterion used is
</p>
<p style="text-align: center;"><code class="reqn">AIC = - 2\log L +  k \times \mbox{df},</code>
</p>

<p>where <code class="reqn">L</code> is the likelihood and <code class="reqn">df</code> is the degrees
of freedom (i.e., the number of free parameters) of <code>fit</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length 2 including:
</p>
<table>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom for the fitted model <code>fit</code>.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike's Information Criterion for <code>fit</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
#fit a 2d suboptimal model
fit.2dl &lt;- glc(response ~ x + y, data=subjdemo_2d, 
    category=subjdemo_2d$category, zlimit=7)
extractAIC(fit.2dl)
</code></pre>

<hr>
<h2 id='gaborPatch'>
Draw a gray-scale Gabor Patch
</h2><span id='topic+gaborPatch'></span>

<h3>Description</h3>

<p>Draw a gray-scale Gabor Patch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaborPatch(sf, 
    theta = 0, 
    rad = (theta * pi)/180, 
    pc = 1, 
    sigma = 1/6, 
    psi = 0, 
    grating = c("cosine", "sine"), 
    npoints = 100, 
    trim = 0, 
    trim.col = .5,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaborPatch_+3A_sf">sf</code></td>
<td>
<p>number of cycles per image.</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_theta">theta</code></td>
<td>
<p>orientation in degree. See &lsquo;Details&rsquo;</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_rad">rad</code></td>
<td>
<p>orientation in radian</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_pc">pc</code></td>
<td>
<p>a fraction (0 to 1) specifying the peak contrast of the Gabor</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_sigma">sigma</code></td>
<td>
<p>the standard deviation of the Gaussian mask. Either a single numeric or a numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_psi">psi</code></td>
<td>
<p>phase offset in radian</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_grating">grating</code></td>
<td>
<p>type of grating to be used. Default to &lsquo;cosine&rsquo;.</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_npoints">npoints</code></td>
<td>
<p>number of points per line used to draw the patch.</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_trim">trim</code></td>
<td>
<p>Gaussian values smaller than the specified value should be trimmed.</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_trim.col">trim.col</code></td>
<td>
<p>gray level of the trimmed part of the image, between 0 (&lsquo;black&rsquo;) and 1 (&lsquo;white&rsquo;). Default to .5 (&lsquo;gray&rsquo;) Setting it to any other value or <code>NA</code> makes the trimmed part transparent.</p>
</td></tr>
<tr><td><code id="gaborPatch_+3A_...">...</code></td>
<td>
<p>additional parameters for <code><a href="Matrix.html#topic+image">image</a></code> may be passed as arguments to this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>theta</code> and <code>rad</code> is the same thing but in different units. If both are supplied, <code>rad</code> takes the precedence.
</p>


<h3>Value</h3>

<p>invisibly returns the matrix of the plotted values.
</p>


<h3>Note</h3>

<p>This function is written just for fun; it is not optimized for speed or for performance.
</p>


<h3>References</h3>

<p>Fredericksen, R. E., Bex, P. J., &amp; Verstraten, F. A. J. (1997). <em>How Big is a Gabor and Why Should We Care?</em> Journal of the Optical Society of America A. 14, 1&ndash;12. 
</p>
<p>Gabor Filter. (2010, June 5). In <em>Wikipedia, the free encyclopedia.</em> Retrieved July 7, 2010, from http://en.wikipedia.org/wiki/Gabor_filter
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An imitation of Fredericksen et al.'s (1997) Fig 1.
# that demonstrate the relation between peak contrast
# and perceived size of the Gabor

op &lt;- par(mfcol = c(3, 3), pty = "m", mai = c(0,0,0,0))
for(i in c(.85, .21, .06)){
    for(j in c(1/6, 1/7, 1/8)){
        gaborPatch(20, pc = i, sigma = j)
    }
}
par(op)

## Not run: 
# a typical plot of the stimuli and category structure
# often seen in artificial category-learning literatures.
m  &lt;-  list(c(268, 157), c(332, 93))
covs  &lt;-  matrix(c(4538, 4351, 4351, 4538), ncol = 2)
II &lt;- grtrnorm(n = 40, np = 2, means = m, covs = covs,
   clip.sd = 4, seed = 1234)
II$sf &lt;- .25+(II$x1/50)
II$theta &lt;- II$x2*(18/50)

plot(II[,2:3], xlim = c(-100,600), ylim = c(-200,500), 
    pch = 21, bg = c("white","gray")[II$category])
abline(a = -175, b = 1)

library(Hmisc)
idx &lt;- c(20, 31, 35, 49, 62)
xpos &lt;- c(0, 100, 300, 350, 550)
ypos &lt;- c(50, 300, 420, -120, 50)
for(i in 1:5)
{
    j = idx[i]
    segments(x0=II[j,"x1"], y0=II[j,"x2"], x1=xpos[i], y1=ypos[i])
    subplot(gaborPatch(sf=II[j,"sf"], theta=II[j,"theta"]), x=xpos[i], y=ypos[i])
}

## End(Not run)

</code></pre>

<hr>
<h2 id='gcjc'>General Conjunctive Classifier</h2><span id='topic+gcjc'></span><span id='topic+print.gcjc'></span>

<h3>Description</h3>

<p>Fit a general conjunctive classifier.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcjc(formula, data, category, par, config = 1, zlimit = Inf,
    fixed = list(), equal.noise = TRUE, opt = c("nlminb", "optim"), 
    lower=-Inf, upper=Inf, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcjc_+3A_formula">formula</code></td>
<td>

<p>A formula of the form <code>response ~ x1 + x2 + ...</code>, where the 
response specifies the grouping factor (generally a participant's response) and the right hand side specifies the relevant dimensions or features of the stimuli.
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_data">data</code></td>
<td>

<p>A data frame from which variables specified in <code>formula</code> are taken.
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_category">category</code></td>
<td>

<p>(Optional.) A factor specifying the true category membership of the stimuli.
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_par">par</code></td>
<td>

<p>object of class <code>gcjcStruct</code> or a named list containing a set of initial parameters - that is, <code>noise</code> and <code>bias</code> (intercepts).
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_config">config</code></td>
<td>
<p>A numeric value specifying the location of the conjunctive category in relation to the category bounds. The value 1 indicates the category is on the top right (set as default), 2 indicates the top left, 3 indicates bottom left, and 4 indicates the bottom right.
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_zlimit">zlimit</code></td>
<td>

<p>numeric. The z-scores (or discriminant scores) beyond the specified value will be truncated. Default to <code>Inf</code>.
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_fixed">fixed</code></td>
<td>

<p>A named list of logical vectors specifying whether each of <code>noise</code> and <code>bias</code> parameters should be fixed to the initial value. Default to <code>list(noise=c(FALSE, TRUE), bias=FALSE)</code>. A fatal error will be returned if set to all <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_equal.noise">equal.noise</code></td>
<td>
<p>logical. If set to <code>TRUE</code> (default), two bounds will have the same noise parameter.
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_opt">opt</code></td>
<td>

<p>A character string specifying the optimizer to be used: either <code><a href="stats.html#topic+nlminb">nlminb</a></code> (the default) or <code><a href="stats.html#topic+optim">optim</a></code>.
If &ldquo;optim&rdquo;, &ldquo;L-BFGS-B&rdquo; method is used (see &lsquo;Details&rsquo; of <code><a href="stats.html#topic+optim">optim</a></code>) .
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_lower">lower</code>, <code id="gcjc_+3A_upper">upper</code></td>
<td>

<p>Bounds on the parameters. see &lsquo;Details&rsquo; for default values.
</p>
</td></tr>
<tr><td><code id="gcjc_+3A_control">control</code></td>
<td>

<p>A list of control parameters passed to the internal optimization function. See &lsquo;Details&rsquo; of <code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>par</code> is not fully specified in the argument, the function attempts to calculate the initial parameter values based on means by category or by response.
</p>
<p>The default lower and upper values are selected based on the range of the <code>data</code> input so that the decision bound is found within the range of the data and convergence can be reached.
</p>


<h3>Value</h3>

<p>object of the class <code>gcjc</code>, i.e., a list containing the following components:
</p>
<table>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call.
</p>
</td></tr>
<tr><td><code>model</code></td>
<td>

<p>the design matrix used to fit the model.
</p>
</td></tr>
<tr><td><code>category</code></td>
<td>

<p>the category vector as specified in the input.
</p>
</td></tr>
<tr><td><code>initpar</code></td>
<td>

<p>the initial parameter used to fit the model.
</p>
</td></tr>
<tr><td><code>par</code></td>
<td>

<p>the fitted parameter.
</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>

<p>the log-likelihood at convergence.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ashby, F. G. (1992) 
<em>Multidimensional models of perception and cognition</em>. 
Lawrence Erlbaum Associates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glc">glc</a></code>,
<code><a href="#topic+logLik.gcjc">logLik.gcjc</a></code>,
<code><a href="#topic+coef.gcjc">coef.gcjc</a></code>,
<code><a href="#topic+plot.gcjc">plot.gcjc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_cj)

m.cj &lt;- gcjc(response ~ x1 + x2, data=subjdemo_cj, 
  config=2, category=subjdemo_cj$category, zlimit=7)

</code></pre>

<hr>
<h2 id='gcjcStruct'>General Conjunctive Classifier structure</h2><span id='topic+gcjcStruct'></span>

<h3>Description</h3>

<p>A list of model parameters that specify a conjunctive decision bound, containing <code>noise</code>, <code>coeffs</code>, and <code>bias</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcjcStruct(noise, bias, config=c(1,2,3,4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcjcStruct_+3A_noise">noise</code></td>
<td>
<p>a positive non-zero numeric.</p>
</td></tr>
<tr><td><code id="gcjcStruct_+3A_bias">bias</code></td>
<td>
<p>numeric vector corresponding to the intercepts of the bounds</p>
</td></tr>
<tr><td><code id="gcjcStruct_+3A_config">config</code></td>
<td>
<p>A numeric value specifying the location of the conjunctive category in relation to the category bounds. The value 1 indicates the category is on the top right (set as default), 2 indicates the top left, 3 indicates bottom left, and 4 indicates the bottom right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>gcjcStruct</code>, which is a list of a named list containing <code>noise</code>, <code>coeffs</code>, and <code>bias</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcjc">gcjc</a></code>,
<code><a href="#topic+coef.glcStruct">coef.glcStruct</a></code>,
<code><a href="#topic+logLik.glcStruct">logLik.glcStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- gcjcStruct(noise=10, bias=c(100, 200), config=1)
</code></pre>

<hr>
<h2 id='glc'>General Linear Classifier</h2><span id='topic+glc'></span><span id='topic+print.glc'></span>

<h3>Description</h3>

<p>Fit a general linear classifier (a.k.a. linear decison-bound model).</p>


<h3>Usage</h3>

<pre><code class='language-R'>glc(formula, data, category, par = list(), zlimit = Inf,
    covstruct=c("unstructured", "scaledIdentity", "diagonal", "identity"),
    fixed = list(), opt = c("nlminb", "optim"), 
    lower=-Inf, upper=Inf, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glc_+3A_formula">formula</code></td>
<td>

<p>A formula of the form <code>response ~ x1 + x2 + ...</code>, where the 
response specifies the grouping factor (generally a participant's response) and the right hand side specifies the relevant dimensions or features of the stimuli.
</p>
</td></tr>
<tr><td><code id="glc_+3A_data">data</code></td>
<td>

<p>A data frame from which variables specified in <code>formula</code> are taken.
</p>
</td></tr>
<tr><td><code id="glc_+3A_category">category</code></td>
<td>

<p>(Optional.) A factor specifying the true category membership of the stimuli.
</p>
</td></tr>
<tr><td><code id="glc_+3A_par">par</code></td>
<td>

<p>object of class <code>glcStruct</code> or named list containing a set of initial parameters (i.e., <code>noise</code>, <code>coeffs</code>, <code>bias</code>) used to fit the data.
</p>
</td></tr>
<tr><td><code id="glc_+3A_zlimit">zlimit</code></td>
<td>

<p>numeric. The z-scores (or discriminant scores) beyond the specified value will be truncated. Default to <code>Inf</code>.
</p>
</td></tr>
<tr><td><code id="glc_+3A_covstruct">covstruct</code></td>
<td>

<p>An optional character string. Only used when the initial parameters are not fully specified. see <code><a href="#topic+ldb">ldb</a></code>.
</p>
</td></tr>
<tr><td><code id="glc_+3A_fixed">fixed</code></td>
<td>

<p>A named list of logical vectors specifying whether each of <code>noise</code>, <code>coeffs</code>, and <code>bias</code> parameters should be fixed to the initial value. Default to <code>list(noise=FALSE, coeffs=FALSE, bias=FALSE</code>. A fatal error will be returned if set to all <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="glc_+3A_opt">opt</code></td>
<td>

<p>A character string specifying the optimizer to be used: either <code><a href="stats.html#topic+nlminb">nlminb</a></code> (the default) or <code><a href="stats.html#topic+optim">optim</a></code>.
If &ldquo;optim&rdquo;, &ldquo;L-BFGS-B&rdquo; method is used (see &lsquo;Details&rsquo; of <code><a href="stats.html#topic+optim">optim</a></code>) .
</p>
</td></tr>
<tr><td><code id="glc_+3A_lower">lower</code>, <code id="glc_+3A_upper">upper</code></td>
<td>

<p>Bounds on the parameters. see &lsquo;Details&rsquo; for default values.
</p>
</td></tr>
<tr><td><code id="glc_+3A_control">control</code></td>
<td>

<p>A list of control parameters passed to the internal optimization function. See &lsquo;Details&rsquo; of <code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>par</code> is not fully specified in the argument, the function attempts to calculate the initial parameter values by internally calling the functions <code>mcovs</code> and <code>ldb</code>. If <code>category</code> is also not specified, the response specified in the <code>formula</code> is used as the grouping factor in <code>mcovs</code>.
</p>
<p>The default lower and upper values vary depending on the dimension of the model (i.e., the number of variables in the right hand side of <code>formula</code>). In all cases, default lower and upper values for the <code>noise</code> parameter is .001 and 500 respectively. In cases when an one-dimensional model is fitted, lower and upper bounds for the <code>bias</code> parameters are selected based on the range of the <code>data</code> input so that the decision bound is found within the reasonable range of the data and convergence can be reached. In all other cases, <code>coeffs</code> and <code>bias</code> has no limits.
</p>
<p>When an one-dimensional model is being fit, <code>fixed$coeffs</code> always becomes <code>TRUE</code>. 
</p>


<h3>Value</h3>

<p>object of the class <code>glc</code>, i.e., a list containing the following components:
</p>
<table>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call.
</p>
</td></tr>
<tr><td><code>model</code></td>
<td>

<p>the design matrix used to fit the model.
</p>
</td></tr>
<tr><td><code>category</code></td>
<td>

<p>the category vector as specified in the input.
</p>
</td></tr>
<tr><td><code>initpar</code></td>
<td>

<p>the initial parameter used to fit the model.
</p>
</td></tr>
<tr><td><code>par</code></td>
<td>

<p>the fitted parameter.
</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>

<p>the log-likelihood at convergence.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>
<p>Ashby, F. G., &amp;  Gott, R. E. (1988). <em>Decision rules in the perception
and categorization of multidimensional stimuli</em>. 
Journal of Experimental Psychology: Learning, Memory, &amp; Cognition, 14, 33-53.
</p>
<p>Ashby, F. G. (1992) 
<em>Multidimensional models of perception and cognition</em>. 
Lawrence Erlbaum Associates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gqc">gqc</a></code>,
<code><a href="#topic+ldb">ldb</a></code>,
<code><a href="#topic+logLik.glc">logLik.glc</a></code>,
<code><a href="#topic+coef.glc">coef.glc</a></code>,
<code><a href="#topic+predict.glc">predict.glc</a></code>,
<code><a href="#topic+scale.glc">scale.glc</a></code>,
<code><a href="#topic+plot.glc">plot.glc</a></code>,
<code><a href="#topic+plot3d.glc">plot3d.glc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
d2 &lt;- subjdemo_2d
#fit a 2d suboptimal model
fit.2dl &lt;- glc(response ~ x + y, data=d2, category=d2$category, zlimit=7)
#fit a 1d model (on the dimention 'y') on the same dataset
fit.1dy &lt;- glc(response ~ y, data=d2, category=d2$category, zlimit=7)
#or using update()
#fit.1dy &lt;- update(fit.2dl, . ~ . -x)

#fit a 2d optimal model
fit.2dlopt &lt;- glc(response ~ x + y, data=d2, category=d2$category, zlimit=7, 
    fixed=list(coeffs=TRUE, bias=TRUE))

#calculate AIC and compare
AIC(fit.2dl, fit.1dy, fit.2dlopt)
</code></pre>

<hr>
<h2 id='glcStruct'>General Linear Classifier structure</h2><span id='topic+glcStruct'></span>

<h3>Description</h3>

<p>A named list of model parameters that specify a linear decision bound, containing <code>noise</code>, <code>coeffs</code>, and <code>bias</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcStruct(noise, coeffs, bias)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glcStruct_+3A_noise">noise</code></td>
<td>
<p>a positive non-zero numeric.</p>
</td></tr>
<tr><td><code id="glcStruct_+3A_coeffs">coeffs</code></td>
<td>
<p>vector. the length of the <code>coeffs</code> should correspond to the number of the model's dimension.</p>
</td></tr>
<tr><td><code id="glcStruct_+3A_bias">bias</code></td>
<td>
<p>numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>glcStruct</code>, i.e., a named list containing <code>noise</code>, <code>coeffs</code>, and <code>bias</code>. Returned values are normalized, such that each value are divided by the euclidean norm of the <code>coeffs</code> vector, and the sum of <code>coeffs^2</code> is 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glc">glc</a></code>,
<code><a href="#topic+coef.glcStruct">coef.glcStruct</a></code>,
<code><a href="#topic+logLik.glcStruct">logLik.glcStruct</a></code>,
<code><a href="#topic+old2new_par">old2new_par</a></code>,
<code><a href="#topic+new2old_par">new2old_par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- glcStruct(noise=10, coeffs=c(1, -1), bias=0)
</code></pre>

<hr>
<h2 id='gqc'>General Quadratic Classifier</h2><span id='topic+gqc'></span><span id='topic+print.gqc'></span>

<h3>Description</h3>

<p>Fit a general quadratic classifier (a.k.a. quadratic decison-bound model).</p>


<h3>Usage</h3>

<pre><code class='language-R'>gqc(formula,
    data,
    category,
    par = list(),
    zlimit = Inf,
    fixed = list(),
    opt = c("nlminb", "optim"),
    lower=-Inf,
    upper=Inf,
    control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gqc_+3A_formula">formula</code></td>
<td>

<p>A formula of the form <code>response ~ x1 + x2 + ...</code> where the 
response specifies the grouping factor (generally a participant's response) and the right hand side specifies the feature values of the classified stimuli.
</p>
</td></tr>
<tr><td><code id="gqc_+3A_data">data</code></td>
<td>

<p>A data frame from which variables specified in <code>formula</code> are taken.
</p>
</td></tr>
<tr><td><code id="gqc_+3A_category">category</code></td>
<td>

<p>(Optional.) A factor specifying the true category membership of the stimuli.
</p>
</td></tr>
<tr><td><code id="gqc_+3A_par">par</code></td>
<td>

<p>object of class <code>gqcStruct</code> or named list containing a set of initial parameters used to fit the data.
</p>
</td></tr>
<tr><td><code id="gqc_+3A_zlimit">zlimit</code></td>
<td>

<p>numeric. The z-scores (or discriminant scores) beyond the specified value will be truncated. Default to <code>Inf</code>
</p>
</td></tr>
<tr><td><code id="gqc_+3A_fixed">fixed</code></td>
<td>

<p>A named list of logical vectors specifying whether each of <code>pnoise</code>, <code>cnoise</code>, <code>coeffs</code>, and <code>bias</code> parameters should be fixed to the initial value. Default to all <code>FALSE</code>. A fatal error will result if set to all <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gqc_+3A_opt">opt</code></td>
<td>

<p>A character string specifying the optimizer to be used: either <code><a href="stats.html#topic+nlminb">nlminb</a></code> (the default) or <code><a href="stats.html#topic+optim">optim</a></code>.
If <code>"optim"</code>, <code>"L-BFGS-B"</code> method is used (see &lsquo;Details&rsquo; of <code><a href="stats.html#topic+optim">optim</a></code>)
</p>
</td></tr>
<tr><td><code id="gqc_+3A_lower">lower</code>, <code id="gqc_+3A_upper">upper</code></td>
<td>

<p>Bounds on the parameters. Default values of lower and upper are <code>c(.1, .1, rep(-Inf, length(unlist(par))-2))</code>, and <code>c(5000, 5000, rep( Inf, length(unlist(par))-2))</code>, respectively.
</p>
</td></tr>
<tr><td><code id="gqc_+3A_control">control</code></td>
<td>

<p>A list of control parameters passed to the optimizer. See &lsquo;Details&rsquo; of <code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>par</code> is not fully specified in the argument, the function attempts to calculate the initial parameter values by internally calling the functions <code>mcovs</code> and <code>qdb</code>. The response specified in the <code>formula</code> is used as the grouping factor in <code>mcovs</code>.
</p>


<h3>Value</h3>

<p>object of class <code>gqc</code>, i.e., a list containing the following components:
</p>
<table>
<tr><td><code>terms</code></td>
<td>

<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call.
</p>
</td></tr>
<tr><td><code>model</code></td>
<td>

<p>the design matrix used to fit the model.
</p>
</td></tr>
<tr><td><code>category</code></td>
<td>

<p>the category vector as specified in the input.
</p>
</td></tr>
<tr><td><code>initpar</code></td>
<td>

<p>the initial parameter used to fit the model.
</p>
</td></tr>
<tr><td><code>par</code></td>
<td>

<p>the fitted parameter.
</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>

<p>the log-likelihood at convergence.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>
<p>Ashby, F. G., &amp;  Gott, R. E. (1988). <em>Decision rules in the perception
and categorization of multidimensional stimuli</em>. 
Journal of Experimental Psychology: Learning, Memory, &amp; Cognition, 14, 33-53.
</p>
<p>Ashby, F. G. (1992) 
<em>Multidimensional models of perception and cognition</em>. 
Lawrence Erlbaum Associates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glc">glc</a></code>,
<code><a href="#topic+qdb">qdb</a></code>,
<code><a href="#topic+logLik.gqc">logLik.gqc</a></code>,
<code><a href="#topic+logLik.gqcStruct">logLik.gqcStruct</a></code>,
<code><a href="#topic+plot.gqc">plot.gqc</a></code>,
<code><a href="#topic+plot3d.gqc">plot3d.gqc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
fit.2dq &lt;- gqc(response ~ x + y, data=subjdemo_2d,
    category=subjdemo_2d$category, zlimit=7)
</code></pre>

<hr>
<h2 id='gqcStruct'>General Quadratic Classifier structure.</h2><span id='topic+gqcStruct'></span>

<h3>Description</h3>

<p>A named list of model parameters that specify a quadratic decision bound, containing <code>pnoise</code>, <code>cnoise</code>, <code>coeffs</code>, and <code>bias</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gqcStruct(pnoise, cnoise, coeffs, bias)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gqcStruct_+3A_pnoise">pnoise</code></td>
<td>
<p>a positive non-zero numeric.</p>
</td></tr>
<tr><td><code id="gqcStruct_+3A_cnoise">cnoise</code></td>
<td>
<p>a positive non-zero numeric.</p>
</td></tr>
<tr><td><code id="gqcStruct_+3A_coeffs">coeffs</code></td>
<td>
<p>a vector. The <code>length(coeffs)</code> should be equal to <code>sum(1:(dim+1)) - 1</code> where <code>dim</code> is the number of the model's dimension</p>
</td></tr>
<tr><td><code id="gqcStruct_+3A_bias">bias</code></td>
<td>
<p>numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>gqcStruct</code>, i.e., a named list containing <code>pnoise</code>, <code>cnoise</code>, <code>coeffs</code>, and <code>bias</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gqc">gqc</a></code>,
<code><a href="#topic+logLik.gqcStruct">logLik.gqcStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- gqcStruct(pnoise=10, cnoise=100, coeffs=c(1,2,3,4,5), bias=6)
</code></pre>

<hr>
<h2 id='grg'>General Random Guessing model</h2><span id='topic+grg'></span>

<h3>Description</h3>

<p>General Random Guessing model</p>


<h3>Usage</h3>

<pre><code class='language-R'>grg(response, fixed = FALSE, k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grg_+3A_response">response</code></td>
<td>

<p>A vector containing participant's classification responses.
</p>
</td></tr>
<tr><td><code id="grg_+3A_fixed">fixed</code></td>
<td>
<p>logical. If <code>TRUE</code>, Fixed Random Guessing model is fitted. If <code>FALSE</code>, General Random Guessing model is fitted. see &lsquo;Details&rsquo;
</p>
</td></tr>
<tr><td><code id="grg_+3A_k">k</code></td>
<td>
<p>numeric. the penalty per parameter to be used in calculating AIC. Default to 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that there are two categories (e.g, &lsquo;A&rsquo; and &lsquo;B&rsquo;) to which each stimulus belongs.
</p>
<p>Fixed Random Guessing model assumes that participant responded randomly without response bias; for each stimulus, probability of responding &lsquo;A&rsquo; and
&lsquo;B&rsquo; is .5. There are no free parameters in this model (i.e., df = 0).
</p>
<p>General Random Guessing model assumes that participants responded randomly but is biased toward one response. The model estimates the response bias (df = 1).
</p>


<h3>Value</h3>

<p>object of class <code>grg</code>, which is a list object containing:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>the fixed or estimated response bias</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log-likelihood of the model</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's An Information Criterion for the fitted model</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ashby, F. G., &amp;  Crossley, M. J. (2010). <em>Interactions between declarative and procedural-learning categorization systems</em>. 
Neurobiology of Learning and Memory, 94, 1-12.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glc">glc</a></code>,
<code><a href="#topic+gqc">gqc</a></code>,
<code><a href="#topic+extractAIC.grg">extractAIC.grg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
fit.grand &lt;- grg(subjdemo_2d$response, fixed=FALSE)

fit.frand &lt;- grg(subjdemo_2d$response, fixed=TRUE)
</code></pre>

<hr>
<h2 id='grtMeans'>Obtain means of two multivariate normal populations satisfying certain criteria</h2><span id='topic+grtMeans'></span>

<h3>Description</h3>

<p>Obtain means of two multivariate normal populations having the specified covariance structure and centroid, and with which classification based on the optimal decision boundary satisfies the supplied probability of correct classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grtMeans(covs, centroid, optldb, p.correct, initd = 5, stepsize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grtMeans_+3A_covs">covs</code></td>
<td>
<p>a matrix or a list of matrices specifying the covariance matrices of the variables. Each matrix should be positive-definite and symmetric.</p>
</td></tr>
<tr><td><code id="grtMeans_+3A_centroid">centroid</code></td>
<td>
<p>a vector specifying the center of the two population means</p>
</td></tr>
<tr><td><code id="grtMeans_+3A_optldb">optldb</code></td>
<td>
<p>object of class <code>glcStruct</code> or a vector of coefficients for the optimal linear decision bound.</p>
</td></tr>
<tr><td><code id="grtMeans_+3A_p.correct">p.correct</code></td>
<td>
<p>a numeric value between 0 to 1 that specifies the optimal classification performance in terms of probability of correct classification given the decision boundary <code>optbnd</code>.</p>
</td></tr>
<tr><td><code id="grtMeans_+3A_initd">initd</code></td>
<td>
<p>numeric. An initial distance between the means of two populations. Default is 5.</p>
</td></tr>
<tr><td><code id="grtMeans_+3A_stepsize">stepsize</code></td>
<td>
<p>a positive numeric specifying step size to be taken when searching for the means. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>means</code></td>
<td>
<p>a list of two vectors specifying the means of two populations.</p>
</td></tr>
<tr><td><code>covs</code></td>
<td>
<p>a matrix of (averaged) covariance.</p>
</td></tr>
<tr><td><code>p.correct</code></td>
<td>
<p>the obtained probability of correct classification.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Author of the original Matlab routine &lsquo;Design2dGRTexp&rsquo;: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ldb.p.correct">ldb.p.correct</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- grtMeans(diag(c(625,625)), centroid=c(200, 200*.6), 
    optldb=c(.6,-1,0), p.correct=.85)
</code></pre>

<hr>
<h2 id='grtrnorm'>Sample from multiple multivariate normal distributions</h2><span id='topic+grtrnorm'></span>

<h3>Description</h3>

<p>Generate one or more samples from the two or more specified multivariate normal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grtrnorm(n,
        np = 2,
        means = list(rep(0,np), rep(0,np)), 
        covs = diag(rep(1,np)), 
        clip.sd = Inf,
        tol = 1e-6,
        empirical = TRUE, 
        seed = NULL,
        response.acc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grtrnorm_+3A_n">n</code></td>
<td>
<p>the number of samples per population required</p>
</td></tr>
<tr><td><code id="grtrnorm_+3A_np">np</code></td>
<td>
<p>the number of populations to be sampled from</p>
</td></tr>
<tr><td><code id="grtrnorm_+3A_means">means</code></td>
<td>
<p>a list of vectors specifying the means of the variable for each populations</p>
</td></tr>
<tr><td><code id="grtrnorm_+3A_covs">covs</code></td>
<td>
<p>a matrix or a list of matrices specifying the covariance matrices of the variables. Each matrix should be positive-definite and symmetric.</p>
</td></tr>
<tr><td><code id="grtrnorm_+3A_clip.sd">clip.sd</code></td>
<td>
<p>an integer specifying the cutoff value of standard score. The standard score of a generated sample exceeding this value should be truncated. Default to <code>Inf</code> (no truncation).</p>
</td></tr>
<tr><td><code id="grtrnorm_+3A_tol">tol</code></td>
<td>
<p>tolerance (relative to largest variance) for numerical lack of positive-definiteness in <code>covs</code>.</p>
</td></tr>
<tr><td><code id="grtrnorm_+3A_empirical">empirical</code></td>
<td>
<p>logical. If true, <code>means</code> and <code>covs</code> specify the empirical rather than population means and covariance matrices.</p>
</td></tr>
<tr><td><code id="grtrnorm_+3A_seed">seed</code></td>
<td>
<p>an integer internally supplied as <code>seed</code> argument to the function <code><a href="base.html#topic+set.seed">set.seed</a></code>. If <code>NULL</code>, <code>.Random.seed</code> is used.</p>
</td></tr>
<tr><td><code id="grtrnorm_+3A_response.acc">response.acc</code></td>
<td>
<p>an optional numeric value between 0 and 1, specifying the classification accuracy of a hypothetical observer. See &lsquo;Details&rsquo;. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially a wrapper to the <code>mvrnorm</code> function in <code>MASS</code> package. 
</p>
<p>If the optional <code>response.acc</code> argument is supplied, hypothetical random classification responses with specified accuracy will be generated.
</p>


<h3>Value</h3>

<p>a data frame containing a column of numeric category labels and column(s) of sampled values for each variable, and optionally, a column of hypothetical responses.
</p>


<h3>Author(s)</h3>

<p>Author of the original Matlab routines: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- list(c(268,157), c(332, 93))
covs &lt;- matrix(c(4538, 4351, 4351, 4538), ncol=2)
II &lt;- grtrnorm(n=80, np=2, means=m, covs=covs)


m &lt;- list(c(283,98),c(317,98),c(283,152),c(317,152))
covs &lt;- diag(75, ncol=2, nrow=2)
CJ &lt;- grtrnorm(n=c(8,16,16,40), np=4, means=m, covs=covs)
CJ$category &lt;- c(1,1,1,2)[CJ$category]
</code></pre>

<hr>
<h2 id='ldb'>Linear Decision Bound</h2><span id='topic+ldb'></span>

<h3>Description</h3>

<p>Find coefficients of the ideal linear decision boundary given the means and covariance of two categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldb(means, covs, 
    covstruct = c("unstructured", "scaledIdentity", "diagonal", "identity"),
    noise = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldb_+3A_means">means</code></td>
<td>
<p>a list of vectors containing means of two distributions.</p>
</td></tr>
<tr><td><code id="ldb_+3A_covs">covs</code></td>
<td>
<p>a matrix or a list of matrix containing the covariance matrix common to the two distributions.</p>
</td></tr>
<tr><td><code id="ldb_+3A_covstruct">covstruct</code></td>
<td>
<p>character. If <code>"unstructured"</code>, the supplied <code>covs</code> is used as-is. If <code>"scaledIdentity"</code>, a diagonal covariance matrix with one common variance is used; when the supplied <code>covs</code> has different values on its diagonal, the mean of the diagonal is used. If <code>"diagonal"</code>, a diagonal covariance matrix with varying diagonal is used. If <code>"identity"</code>, an identity matrix is used. Default to <code>"unstructured"</code></p>
</td></tr>
<tr><td><code id="ldb_+3A_noise">noise</code></td>
<td>
<p>numeric value. See Details. Default to 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of vectors in the list <code>means</code> matters as the sign of <code>coeffs</code> and <code>bias</code> in the output will be reversed.
</p>
<p>The argument <code>noise</code> is only for convenience; the supplied value is simply bypassed to the output for the subsequent use, i.e., as object of class <code>glcStruct</code>.
</p>


<h3>Value</h3>

<p>The object of class <code><a href="#topic+glcStruct">glcStruct</a></code>
</p>


<h3>Author(s)</h3>

<p>Author of the original Matlab routine &lsquo;lindecisbnd&rsquo;: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcovs">mcovs</a></code>, 
<code><a href="#topic+qdb">qdb</a></code>,
<code><a href="#topic+glcStruct">glcStruct</a></code>, 
<code><a href="#topic+glc">glc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- list(c(187, 142), c(213.4, 97.7))
covs &lt;- diag(c(625, 625))
foo &lt;- ldb(means=m, covs=covs)

</code></pre>

<hr>
<h2 id='ldb.p.correct'>Probability of correct classification based on the optimal linear decision bound.</h2><span id='topic+ldb.p.correct'></span>

<h3>Description</h3>

<p>Estimates the probability of correct classification under the condition in which the optimal linear decision boundary is used to categorize the samples from two multivariate normal populations with the specified parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldb.p.correct(means, covs, noise = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldb.p.correct_+3A_means">means</code></td>
<td>
<p>a list of vectors, each specifying the means of a multivariate normal population.</p>
</td></tr>
<tr><td><code id="ldb.p.correct_+3A_covs">covs</code></td>
<td>
<p>a matrix or a list of matrices specifying the covariance matrix of the each multivariate normal population. If a list is given and length(covs) &gt; 2, an unweighted average of the matrices is used.</p>
</td></tr>
<tr><td><code id="ldb.p.correct_+3A_noise">noise</code></td>
<td>
<p>an optional numeric value specifying the noise associated with the decision bound. Default to 0.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Author of the original Matlab routine &lsquo;linprobcorr&rsquo;: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- grtMeans(diag(c(625,625)), centroid=c(200, 200*.6), 
    optldb=c(.6,-1,0), p.correct=.85)
ldb.p.correct(foo$means, foo$covs)
</code></pre>

<hr>
<h2 id='lines.gqcStruct'>lines Method for class 'gqc'</h2><span id='topic+lines.gqcStruct'></span>

<h3>Description</h3>

<p>Add a quadratic decision boundary line through the current plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gqcStruct'
lines(x, 
    xlim = c(0,1), ylim = c(0,1), 
    npoints = 100, col = "black", 
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.gqcStruct_+3A_x">x</code></td>
<td>
<p>object of class <code>gqcStruct</code></p>
</td></tr>
<tr><td><code id="lines.gqcStruct_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot. Default to <code>c(0,1)</code></p>
</td></tr>
<tr><td><code id="lines.gqcStruct_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. Default to <code>c(0,1)</code></p>
</td></tr>
<tr><td><code id="lines.gqcStruct_+3A_npoints">npoints</code></td>
<td>
<p>numeric. number of points per dimension used to plot the decision bound. Default is 100.</p>
</td></tr>
<tr><td><code id="lines.gqcStruct_+3A_col">col</code></td>
<td>
<p>the color to be used for the line</p>
</td></tr>
<tr><td><code id="lines.gqcStruct_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an invisible list of x- and y-coordinates of the line:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a vector of x-coordinates of the line</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector of y-coordinates of the line</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.gqc">plot.gqc</a></code>, <code>{<a href="#topic+plot3d.gqc">plot3d.gqc</a>}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
fit.2dq &lt;- gqc(response ~ x + y, data=subjdemo_2d, 
     category=subjdemo_2d$category, zlimit=7)
plot(fit.2dq, fitdb=FALSE, initdb=FALSE)
lines(fit.2dq$par, xlim=c(0,400), ylim=c(0,400), col="red")
lines(fit.2dq$initpar, xlim=c(0,400), ylim=c(0,400), col="blue")
</code></pre>

<hr>
<h2 id='logLik.glc'>Log-Likelihood of a 'glc' or 'gcjc' Object</h2><span id='topic+logLik.glc'></span><span id='topic+logLik.gcjc'></span>

<h3>Description</h3>

<p>Extract the log-likelihood of the fitted general linear or conjunctive classifier model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glc'
logLik(object, ...)

## S3 method for class 'gcjc'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.glc_+3A_object">object</code></td>
<td>
<p>object of class <code>glc</code> or <code>gcjc</code></p>
</td></tr>
<tr><td><code id="logLik.glc_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood for the general linear or conjunctive classifier represented by the estimated parameters in <code>object</code>
</p>


<h3>Note</h3>

<p>This function is intended for indirect internal use by functions such as <code>AIC</code>. 
To obtain the log-likelihood of the fitted model applied to new dataset, use <code><a href="#topic+logLik.glcStruct">logLik.glcStruct</a></code> or <code><a href="#topic+logLik.gcjcStruct">logLik.gcjcStruct</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glc">glc</a></code>, 
<code><a href="#topic+logLik.glcStruct">logLik.glcStruct</a></code>, 
<code><a href="#topic+gcjc">gcjc</a></code>, 
<code><a href="#topic+logLik.gcjcStruct">logLik.gcjcStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
fit &lt;- glc(response ~ x + y, data=subjdemo_2d, 
    category=subjdemo_2d$category, zlimit=7)
logLik(fit)
</code></pre>

<hr>
<h2 id='logLik.glcStruct'>Log-Likelihood of a 'glcStruct' or 'gcjcStruct' Object</h2><span id='topic+logLik.glcStruct'></span><span id='topic+logLik.gcjcStruct'></span>

<h3>Description</h3>

<p>Calculate the log-likelihood of the general linear or conjunctive classifier model applied to a data set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glcStruct'
logLik(object, response, x, zlimit = Inf, ...)

## S3 method for class 'gcjcStruct'
logLik(object, response, x, zlimit = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.glcStruct_+3A_object">object</code></td>
<td>
<p>object of class <code>glcStruct</code> or <code>gcjcStruct</code> containing the parameter values at which the log-likelihood is to be evaluated. </p>
</td></tr>
<tr><td><code id="logLik.glcStruct_+3A_response">response</code></td>
<td>
<p>a vector of classification responses used to calculate the log-likelihood of the model.</p>
</td></tr>
<tr><td><code id="logLik.glcStruct_+3A_x">x</code></td>
<td>
<p>a matrix or dataframe containing values for each stimulus dimensions.</p>
</td></tr> 
<tr><td><code id="logLik.glcStruct_+3A_zlimit">zlimit</code></td>
<td>
<p>integer. Used to truncate the z-scores whose absolute values are greater than <code>zlimit</code> when calculating the log-likelihood. Default to <code>Inf</code></p>
</td></tr>
<tr><td><code id="logLik.glcStruct_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood for the general linear or conjunctive classifier described by <code>object</code> fitted against the dataset given by <code>response</code> and <code>x</code>.  
</p>


<h3>Note</h3>

<p>The value of attributes, <code>attr(, "df")</code> (degrees of freedom) is calculated based on the assumption that all the parameters in <code>object</code> are free to vary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gqc">gqc</a></code>,
<code><a href="#topic+gqcStruct">gqcStruct</a></code>,
<code><a href="#topic+logLik.glc">logLik.glc</a></code>,
<code><a href="#topic+logLik.gcjc">logLik.gcjc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- list(c(187, 142), c(213, 98))
covs &lt;- diag(625, ncol=2, nrow=2)
db &lt;- ldb(means=m, covs=covs, noise=10)
data(subjdemo_2d)
logLik(db, subjdemo_2d$response, x=subjdemo_2d[2:3], zlimit=7)
</code></pre>

<hr>
<h2 id='logLik.gqc'>Log-Likelihood of a 'gqc' Object</h2><span id='topic+logLik.gqc'></span>

<h3>Description</h3>

<p>Extract the log-likelihood of the fitted general quadratic classifier model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gqc'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.gqc_+3A_object">object</code></td>
<td>
<p>object of class <code>gqc</code></p>
</td></tr>
<tr><td><code id="logLik.gqc_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood for the general quadratic classifier represented by the estimated parameters in <code>object</code>
</p>


<h3>Note</h3>

<p>This function is intended for indirect internal use by functions such as <code>AIC</code>. 
To obtain the log-likelihood of the fitted model applied to new dataset, use <code><a href="#topic+logLik.gqcStruct">logLik.gqcStruct</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gqc">gqc</a></code>, <code><a href="#topic+logLik.gqcStruct">logLik.gqcStruct</a></code>
</p>

<hr>
<h2 id='logLik.gqcStruct'>Log-Likelihood of a 'gqcStruct' Object</h2><span id='topic+logLik.gqcStruct'></span>

<h3>Description</h3>

<p>Calculate the log-likelihood of the general quadratic classifier model applied to a data set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gqcStruct'
logLik(object, response, x, zlimit = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.gqcStruct_+3A_object">object</code></td>
<td>
<p>object of class <code>gqcStruct</code></p>
</td></tr>
<tr><td><code id="logLik.gqcStruct_+3A_response">response</code></td>
<td>
<p>a vector of classification responses used to calculate the log-likelihood of the gqc model.</p>
</td></tr>
<tr><td><code id="logLik.gqcStruct_+3A_x">x</code></td>
<td>
<p>a matrix or dataframe containing values for each stimulus dimensions.</p>
</td></tr> 
<tr><td><code id="logLik.gqcStruct_+3A_zlimit">zlimit</code></td>
<td>
<p>integer. Used to truncate the z-scores whose absolute values are greater than <code>zlimit</code> when calculating the log-likelihood. Default to Inf</p>
</td></tr>
<tr><td><code id="logLik.gqcStruct_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood for the general quadratic classifier described by <code>object</code> fitted against the dataset given by <code>response</code> and <code>x</code>.  
</p>


<h3>Note</h3>

<p>The value of attributes, <code>attr(, "df")</code> (degrees of freedom) is calculated based on the assumption that all the parameters in <code>object</code> are free to vary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gqc">gqc</a></code>,
<code><a href="#topic+gqcStruct">gqcStruct</a></code>,
<code><a href="#topic+logLik.gqc">logLik.gqc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- list(c(187, 142), c(213, 98))
covs &lt;- list(diag(625, ncol=2, nrow=2), diag(600, ncol=2, nrow=2))
db &lt;- qdb(means=m, covs=covs)
data(subjdemo_2d)
logLik(db, subjdemo_2d$response, x=subjdemo_2d[2:3], zlimit=7)
</code></pre>

<hr>
<h2 id='mcovs'>Calculate sample means and covariance(s) of multivariate data</h2><span id='topic+mcovs'></span><span id='topic+mcovs.default'></span><span id='topic+mcovs.formula'></span>

<h3>Description</h3>

<p>Calculate sample means and covariance(s) of multivariate data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mcovs(x, grouping, pooled=TRUE, ...)

## S3 method for class 'formula'
mcovs(formula, data, pooled=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcovs_+3A_formula">formula</code></td>
<td>
<p>A formula in the form of <code>grouping ~ x1 + x2 + ...</code>, where the right hand side specifies the sample variables.</p>
</td></tr>
<tr><td><code id="mcovs_+3A_data">data</code></td>
<td>
<p>Data frame from which variables specified in <code>formula</code> are taken.</p>
</td></tr>
<tr><td><code id="mcovs_+3A_x">x</code></td>
<td>
<p>data frame or Matrix containing sample values.</p>
</td></tr>
<tr><td><code id="mcovs_+3A_grouping">grouping</code></td>
<td>
<p>a factor specifying the population to which the samples in <code>x</code> belong.</p>
</td></tr>
<tr><td><code id="mcovs_+3A_pooled">pooled</code></td>
<td>
<p>logical. If <code>TRUE</code>, pooled variance-covariance matrix is calculated. If <code>FALSE</code>, a list of variance-covariance matrices for each groups are calculated. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mcovs_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>total number of samples.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>number of samples per groups.</p>
</td></tr>
<tr><td><code>lev</code></td>
<td>
<p>levels of the <code>grouping</code> factor</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>a named list of vectors specifying the means for each group. Named according to <code>lev</code>.</p>
</td></tr>
<tr><td><code>covs</code></td>
<td>
<p>a named list of variance-covarinace matrix(es). Named as <code>pooled</code> if <code>pooled=TRUE</code>, otherwise according to <code>lev</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='new2old_par'>Convert 'new' to 'old' glcStruct format
</h2><span id='topic+new2old_par'></span><span id='topic+angle2cart'></span>

<h3>Description</h3>

<p>Converts the glcStruct in &lsquo;new&rsquo; format to &lsquo;old&rsquo; format whereby a vector of <code>angle</code> is converted to <code>coeffs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new2old_par(x)

angle2cart(angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new2old_par_+3A_x">x</code></td>
<td>
<p>object of class <code>glcStruct</code>.</p>
</td></tr>
<tr><td><code id="new2old_par_+3A_angle">angle</code></td>
<td>
<p>vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>new2old_par</code>, object of class <code>glcStruct</code>.
</p>
<p>For <code>angle2cart</code>, vector.
</p>


<h3>Author(s)</h3>

<p>Author of the original Matlab routines: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+old2new_par">old2new_par</a></code>
<code><a href="#topic+cart2angle">cart2angle</a></code>
<code><a href="#topic+glcStruct">glcStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- list(c(187, 142), c(213.4, 97.7))
covs &lt;- diag(c(625, 625))
foo &lt;- ldb(means=m, covs=covs)
bar &lt;- old2new_par(foo)
new2old_par(bar)

angle2cart(bar$angle)
</code></pre>

<hr>
<h2 id='old2new_par'>Convert 'old' to 'new' glcStruct format
</h2><span id='topic+old2new_par'></span><span id='topic+cart2angle'></span>

<h3>Description</h3>

<p>Converts glcStruct in the 'old' to 'new' format for more efficient optimization where <code>coeffs</code> vectors are converted to a vector of <code>angle</code> with length of <code>(coeffs) - 1</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>old2new_par(x)

cart2angle(cart)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="old2new_par_+3A_x">x</code></td>
<td>
<p>object of class <code>glcStruct</code>.</p>
</td></tr>
<tr><td><code id="old2new_par_+3A_cart">cart</code></td>
<td>
<p>vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>old2new_par</code>, object of class <code>glcStruct</code>.
</p>
<p>For <code>cart2angle</code>, vector.
</p>


<h3>Author(s)</h3>

<p>Author of the original Matlab routines: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- list(c(187, 142), c(213.4, 97.7))
covs &lt;- diag(c(625, 625))
foo &lt;- ldb(means=m, covs=covs)
old2new_par(foo)

cart2angle(foo$coeffs)
</code></pre>

<hr>
<h2 id='plot.gcjc'>Plot Method for Class 'gcjc'</h2><span id='topic+plot.gcjc'></span>

<h3>Description</h3>

<p>Plot the fitted data set and decision boundary.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcjc'
plot(x, fitdb = TRUE, initdb = FALSE, xlim = NULL, ylim = NULL, bg, pch, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gcjc_+3A_x">x</code></td>
<td>
<p>object of class <code>gcjc</code></p>
</td></tr>
<tr><td><code id="plot.gcjc_+3A_fitdb">fitdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the fitted decision bound is plotted. Default to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.gcjc_+3A_initdb">initdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the decision bound specified by the initial parameters is plotted. Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.gcjc_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot</p>
</td></tr>
<tr><td><code id="plot.gcjc_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot</p>
</td></tr>
<tr><td><code id="plot.gcjc_+3A_bg">bg</code></td>
<td>
<p>the background color to be used for points. Default is <code>c("white","gray")[response]</code> where <code>response</code> represents the response vector of the model</p>
</td></tr>
<tr><td><code id="plot.gcjc_+3A_pch">pch</code></td>
<td>
<p>the symbols to be used as points. Default is <code>c(21,24)[x$category]</code> </p>
</td></tr>
<tr><td><code id="plot.gcjc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a scatter plot of data matrix in the <code>x</code> and (optionally) decision boundary specified within (i.e., <code>x$par</code> and/or <code>x$initpar</code>). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- list(c(100,200),c(100,100),c(200,100),c(200,200))
covs &lt;- diag(30^2, ncol=2, nrow=2)
set.seed(1)
CJ &lt;- grtrnorm(n=c(50,20,10,20), np=4, means=m, covs=covs)
CJ$category &lt;- c(1,2,2,2)[CJ$category]
#create ramdom responses with 80% accuracy
CJ$response &lt;- CJ$category
set.seed(1)
incorrect &lt;- sample(1:100, size=20)
CJ$response[incorrect] &lt;- abs(CJ$response[incorrect] - 3)

#now fit the model
m.cj &lt;- gcjc(response ~ x1 + x2, data=CJ, config=2, category=CJ$category, zlimit=7)

plot(m.cj)

</code></pre>

<hr>
<h2 id='plot.glc'>Plot Method for Class 'glc'</h2><span id='topic+plot.glc'></span>

<h3>Description</h3>

<p>Plot the fitted data set and linear decision boundary.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glc'
plot(x, fitdb = TRUE, initdb = FALSE, xlim = NULL, ylim = NULL, bg, pch, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.glc_+3A_x">x</code></td>
<td>
<p>object of class <code>glc</code></p>
</td></tr>
<tr><td><code id="plot.glc_+3A_fitdb">fitdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the fitted decision bound is plotted. Default to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.glc_+3A_initdb">initdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the decision bound specified by the initial parameters is plotted. Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.glc_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot</p>
</td></tr>
<tr><td><code id="plot.glc_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot</p>
</td></tr>
<tr><td><code id="plot.glc_+3A_bg">bg</code></td>
<td>
<p>the background color to be used for points. Default is <code>c("white","gray")[response]</code> where <code>response</code> represents the response vector of the model</p>
</td></tr>
<tr><td><code id="plot.glc_+3A_pch">pch</code></td>
<td>
<p>the symbols to be used as points. Default is <code>c(21,24)[x$category]</code> </p>
</td></tr>
<tr><td><code id="plot.glc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a scatter plot of data matrix in the <code>x</code> and (optionally) decision boundary specified within (i.e., <code>x$par</code> and/or <code>x$initpar</code>). 
</p>
<p>The look of the plot differs depending on the dimension of the model. If the dimension is 1, the model matrix is plotted on the y-axis, and category vector (as in <code>x$category</code>) is plotted on the x axis. If the dimension is 2, scatter plot of the model matrix is plotted. If the dimension is 3, <code>plot3d.glc</code> is called to create a 3D scatter plot. If the dimension is greater than 3, an error message will be returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3d.glc">plot3d.glc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
fit.2dl &lt;- glc(response ~ x + y, data=subjdemo_2d, 
    category=subjdemo_2d$category, zlimit=7)
plot(fit.2dl)

#if one wants to plot decision bounds in
# colors different from the defaults
plot(fit.2dl, fitdb=FALSE)
abline(coef=coef(fit.2dl$par), col="orange")
abline(coef=coef(fit.2dl$initpar), col="purple")

</code></pre>

<hr>
<h2 id='plot.gqc'>plot Method for Class 'gqc'</h2><span id='topic+plot.gqc'></span>

<h3>Description</h3>

<p>Plot the fitted data set and quadratic decision boundary.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gqc'
plot(x, fitdb = TRUE, initdb = FALSE, 
    xlim = NULL, ylim = NULL, bg, pch, npoints = 100, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gqc_+3A_x">x</code></td>
<td>
<p>object of class <code>gqc</code></p>
</td></tr>
<tr><td><code id="plot.gqc_+3A_fitdb">fitdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the fitted decision bound will be plotted. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.gqc_+3A_initdb">initdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the decision bound specified by the initial parameters will be plotted. Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.gqc_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot. If <code>NULL</code>, limits are calculated from the model matrix. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.gqc_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. If <code>NULL</code>, limits are calculated from the model matrix. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.gqc_+3A_bg">bg</code></td>
<td>
<p>the background color to be used for points in 2D scatter plot. 
Default is <code>c("white", "gray")[response]</code> where <code>response</code> represents the response vector of the model</p>
</td></tr>
<tr><td><code id="plot.gqc_+3A_pch">pch</code></td>
<td>
<p>the symbols to be used as points in 2D scatter plot. Default is <code>c(21,24)[x$category]</code> </p>
</td></tr>
<tr><td><code id="plot.gqc_+3A_npoints">npoints</code></td>
<td>
<p>number of points per dimension used to plot the decision bound. Default is 100.</p>
</td></tr>
<tr><td><code id="plot.gqc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a scatter plot of data matrix in the <code>x</code> and (optionally) decision boundary (i.e., <code>x$par</code> and/or <code>x$initpar</code>). 
</p>
<p>The look of the plot differs depending on the dimension of the model. If the dimension is 2, scatter plot of the model matrix is plotted. If the dimension is 3, <code>plot3d.gqc</code> is called to create a 3D scatter plot. In all other cases, an error message will be returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lines.gqcStruct">lines.gqcStruct</a></code>, <code>{<a href="#topic+plot3d.gqc">plot3d.gqc</a>}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
fit.2dq &lt;- gqc(response ~ x + y, data=subjdemo_2d, 
    category=subjdemo_2d$category, zlimit=7)
plot(fit.2dq)

</code></pre>

<hr>
<h2 id='plot3d.glc'>plot3d Method for Class 'glc'</h2><span id='topic+plot3d.glc'></span>

<h3>Description</h3>

<p>plot the fitted 3D data set and linear decision boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glc'
plot3d(x, fitdb = TRUE, initdb = FALSE,
    lims = NULL, alpha = .5, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.glc_+3A_x">x</code></td>
<td>
<p>object of class <code>glc</code></p>
</td></tr>
<tr><td><code id="plot3d.glc_+3A_fitdb">fitdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the fitted decision bound will be plotted. Default to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot3d.glc_+3A_initdb">initdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the decision bound specified by the initial parameters will be plotted. Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot3d.glc_+3A_lims">lims</code></td>
<td>
<p>column matrix of the x, y, and z limits of the plot</p>
</td></tr>
<tr><td><code id="plot3d.glc_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for the decision bound surface(s) ranging from 0 (fully transparent) to 1 (opaque). Default is .5.</p>
</td></tr>
<tr><td><code id="plot3d.glc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a 3D scatter plot of data matrix in the <code>x</code> and (optionally) decision boundary specified within (i.e., <code>x$par</code> and/or <code>x$initpar</code>), using <code>points3d</code> and <code>quads3d</code> in the <code>rgl</code> package respectively.
</p>


<h3>References</h3>

<p>Daniel Adler, Oleg Nenadic and Walter Zucchini (2003) RGL: A R-library for 3D visualization with OpenGL
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.glc">plot.glc</a></code>, <code><a href="#topic+plot3d.gqc">plot3d.gqc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(subjdemo_3d)
fit.3dl &lt;- glc(response ~ x + y + z, data=subjdemo_3d,
    category=subjdemo_3d$category, zlimit=7)
plot3d(fit.3dl)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot3d.gqc'>plot3d Method for Class 'gqc'</h2><span id='topic+plot3d.gqc'></span>

<h3>Description</h3>

<p>plot the fitted 3D data set and quadratic decision boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gqc'
plot3d(x, fitdb = TRUE, initdb = FALSE,
    lims = NULL, npoints = 100, alpha = .5,
    fill = TRUE, smooth = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.gqc_+3A_x">x</code></td>
<td>
<p>object of class <code>gqc</code></p>
</td></tr>
<tr><td><code id="plot3d.gqc_+3A_fitdb">fitdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the fitted decision bound will be plotted. Default to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot3d.gqc_+3A_initdb">initdb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the decision bound specified by the initial parameters will be plotted. Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot3d.gqc_+3A_lims">lims</code></td>
<td>
<p>column matrix of the x, y, and z limits of the plot. If <code>NULL</code>, limits are calculated from the model matrix of <code>x</code>. Default to NULL.</p>
</td></tr>
<tr><td><code id="plot3d.gqc_+3A_npoints">npoints</code></td>
<td>
<p>number of points per dimension (i.e., x, y, and z) used to plot the decision bound surface. Default is 100.</p>
</td></tr>
<tr><td><code id="plot3d.gqc_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for the decision bound surface(s) ranging from 0 (fully transparent) to 1 (opaque). Default is .5</p>
</td></tr>
<tr><td><code id="plot3d.gqc_+3A_fill">fill</code></td>
<td>
<p>logical. If <code>TRUE</code>, decision bounds (if <code>fitdb</code> or <code>initdb</code> is set to <code>TRUE</code>) should be drawn with filled surfaces. If FALSE, a wire frame should be used. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot3d.gqc_+3A_smooth">smooth</code></td>
<td>
<p>logical. If <code>TRUE</code>, smooth shading should be used. Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot3d.gqc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a 3D scatter plot of data matrix of <code>x</code> and (optionally) quadratic decision boundaries specified within (i.e., <code>x$par</code> and/or <code>x$initpar</code>), using <code>points3d</code> function in the <code>rgl</code> package and <code>contour3d</code> function in the <code>misc3d</code> package respectively.
</p>


<h3>References</h3>

<p>Daniel Adler, Oleg Nenadic and Walter Zucchini (2003) RGL: A R-library for 3D visualization with OpenGL
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.gqc">plot.gqc</a></code>, <code>{<a href="#topic+plot3d.gqc">plot3d.gqc</a>}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(subjdemo_3d)
fit.3dq &lt;- gqc(response ~ x + y + z, data=subjdemo_3d,
    category=subjdemo_3d$category, zlimit=7)
plot3d(fit.3dq)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.glc'>predict method for General Linear Classifier</h2><span id='topic+predict.glc'></span>

<h3>Description</h3>

<p>Predicted classification based on &lsquo;glc&rsquo; model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glc'
predict(object, newdata, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.glc_+3A_object">object</code></td>
<td>
<p>object of class <code>glc</code>.</p>
</td></tr>
<tr><td><code id="predict.glc_+3A_newdata">newdata</code></td>
<td>
<p>a vector or a matrix containing new samples with which the classification prediction is to be made.</p>
</td></tr>
<tr><td><code id="predict.glc_+3A_seed">seed</code></td>
<td>
<p>numeric. The &lsquo;seed&rsquo; used for the random number generator.</p>
</td></tr>
<tr><td><code id="predict.glc_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function predict (or &lsquo;simulate&rsquo;) classification response of an observer whose noise and linear decision bounds are specified in <code>object</code>.
</p>
<p>The predicted category labels are matched with those used for the fit in <code>object</code>.
</p>
<p>If <code>newdata</code> is missing, the predictions are made on the data used for the fit.
</p>


<h3>Value</h3>

<p>a vector of labels of categories to which each sample in <code>newdata</code> is predicted to belong, according to the model in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Author of the original Matlab routines: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
fit.2dl &lt;- glc(response ~ x + y, data=subjdemo_2d, 
    category=subjdemo_2d$category, zlimit=7)

m &lt;- list(c(187, 142), c(213.4, 97.7))
covs &lt;- diag(c(900, 900))
newd &lt;- grtrnorm(n=20, np=2, means=m, covs=covs, seed=1234)
predict(fit.2dl, newd[,2:3], seed=1234)
</code></pre>

<hr>
<h2 id='qdb'>Quadratic Decision Bound</h2><span id='topic+qdb'></span>

<h3>Description</h3>

<p>Find coefficients of the ideal quadratic decision boundary given the means and covariance of two categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdb(means, covs, pnoise = 10, cnoise = 100, sphere = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdb_+3A_means">means</code></td>
<td>
<p>a list of vectors containing means of the two distributions.</p>
</td></tr>
<tr><td><code id="qdb_+3A_covs">covs</code></td>
<td>
<p>a list containing the covariance matrices of the two distributions.</p>
</td></tr>
<tr><td><code id="qdb_+3A_pnoise">pnoise</code>, <code id="qdb_+3A_cnoise">cnoise</code></td>
<td>
<p>numeric. Defaults set to 10, and 100, respectively. see &lsquo;Details&rsquo;
</p>
</td></tr>
<tr><td><code id="qdb_+3A_sphere">sphere</code></td>
<td>
<p>logical. If TRUE, the returned decison bound forms a circle or sphere.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of vectors in the list <code>means</code> and <code>covs</code> matters as the sign of <code>coeffs</code> and <code>bias</code> object in the output will be reversed.
</p>
<p>The argument <code>pnoise</code> and <code>cnoise</code> is only for convenience; the supplied value is simply bypassed to the output for the subsequent use, i.e., as object of class <code>gqcStruct</code>.
</p>


<h3>Value</h3>

<p>object of class <code>gqcStruct</code>
</p>


<h3>Author(s)</h3>

<p>Author of the original Matlab routine &lsquo;quaddecisbnd&rsquo;: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcovs">mcovs</a></code>, 
<code><a href="#topic+qdb">qdb</a></code>,
<code><a href="#topic+gqcStruct">gqcStruct</a></code>, 
<code><a href="#topic+gqc">gqc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- list(c(187, 142), c(213.4, 97.7))
covs &lt;- list(diag(c(625, 625)), diag(c(625, 625)))
foo &lt;- qdb(means=m, covs=covs)

</code></pre>

<hr>
<h2 id='qdb.p.correct'>the proportion correct of the quadratic decision boundary.</h2><span id='topic+qdb.p.correct'></span>

<h3>Description</h3>

<p>Calculate the proportion correct obtained by categorizing samples form one multivariate normal population using the quadratic decision boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdb.p.correct(x, qdb, refpts = colMeans(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdb.p.correct_+3A_x">x</code></td>
<td>
<p>a vector or matrix containing the values of samples from one multivariate normal population.</p>
</td></tr>
<tr><td><code id="qdb.p.correct_+3A_qdb">qdb</code></td>
<td>
<p>object of class <code>gqcStruct</code> or a vector containing the values for <code>coeffs</code> and <code>bias</code> of an quadratic decision bound.</p>
</td></tr>
<tr><td><code id="qdb.p.correct_+3A_refpts">refpts</code></td>
<td>
<p>a numeric vector used as a reference point to determine the correct side of the <code>qdb</code> for classifying <code>x</code>. The <code>length(refpts)</code> should be equal to ncol(x). Default to <code>colMeans(x)</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that all the points specified in <code>x</code> belong to just one category.
</p>


<h3>Author(s)</h3>

<p>Author of the original Matlab routine &lsquo;quadbndpercorr&rsquo;: Leola Alfonso-Reese
</p>
<p>Author of R adaptation: Kazunaga Matsuki
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(subjdemo_2d)
tmp &lt;- split(subjdemo_2d, subjdemo_2d$category)
mc &lt;- mcovs(category ~ x + y, data=subjdemo_2d, pooled=FALSE)
db &lt;- qdb(mc$means, mc$covs)
qdb.p.correct(tmp[[1]][,2:3], db)
</code></pre>

<hr>
<h2 id='scale'>Scale method for the class 'glc' and 'gqc'</h2><span id='topic+scale'></span><span id='topic+scale.glc'></span><span id='topic+scale.gqc'></span>

<h3>Description</h3>

<p>Return the discriminant scores obtained by applying the general linear classifier to the fitted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glc'
scale(x, initdb = FALSE, zlimit = Inf, ...)
## S3 method for class 'gqc'
scale(x, initdb = FALSE, zlimit = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_+3A_x">x</code></td>
<td>
<p>object of class <code>glc</code> or <code>gqc</code></p>
</td></tr>
<tr><td><code id="scale_+3A_initdb">initdb</code></td>
<td>
<p>optional logical. If <code>TRUE</code>, the returned vector represents the z-scores with respect to the initial parameters, rather than the fitted parameters. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_+3A_zlimit">zlimit</code></td>
<td>
<p>optional numeric. Used to truncate the scores beyond the speficied value. Default to <code>Inf</code></p>
</td></tr>
<tr><td><code id="scale_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The generic function <code>scale</code> is redefined to accept arguments other than <code>x</code>, <code>center</code>, and <code>scale</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(subjdemo_2d)
fit.2dl &lt;- glc(response ~ x + y, data=subjdemo_2d, 
    category=subjdemo_2d$category, zlimit=7)
scale(fit.2dl)

fit.2dq &lt;- gqc(response ~ x + y, data=subjdemo_2d, 
    category=subjdemo_2d$category, zlimit=7)
scale(fit.2dq)


## Not run: 
#plots using the discriminant scores
require(Hmisc)
options(digits=3)
fit.2dl &lt;- glc(response ~ x + y, data=subjdemo_2d, 
    category=subjdemo_2d$category, zlimit=7)
# z-scores based on the initial decision bound
# split by the true category membership
zinit &lt;- split(scale(fit.2dl, initdb=TRUE), subjdemo_2d$category)
histbackback(zinit)

# z-scores based on the fitted decision bound
# split by the participants' response
zfit1 &lt;- split(scale(fit.2dl, initdb=FALSE), subjdemo_2d$category)
histbackback(zfit1)

# z-scores based on the fitted decision bound
# split by the true category membership
zfit2 &lt;- split(scale(fit.2dl, initdb=FALSE), subjdemo_2d$response)
histbackback(zfit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='subjdemo_1d'>
Sample dataset of a categorization experiment with 1D stimuli.
</h2><span id='topic+subjdemo_1d'></span>

<h3>Description</h3>

<p>A sample one dimensional stimulus set and response data of a hypothetical participant in a two-category classification experiment involving 500 trials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subjdemo_1d
</code></pre>


<h3>Format</h3>

<p>This data frame contains 500 rows and the following columns:
</p>

<dl>
<dt><code>category</code></dt><dd>
<p>label of the category to which each stimulus belongs.
</p>
</dd>
<dt><code>x</code></dt><dd><p>value on the dimension 'x'</p>
</dd>
<dt><code>response</code></dt><dd>
<p>classification response of a participant.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>

<hr>
<h2 id='subjdemo_2d'>
Sample dataset of a categorization experiment with 2D stimuli.
</h2><span id='topic+subjdemo_2d'></span>

<h3>Description</h3>

<p>A sample two dimensional stimulus set and response data of a hypothetical participant in a two-category classification experiment involving 500 trials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subjdemo_2d
</code></pre>


<h3>Format</h3>

<p>This data frame contains 500 rows and the following columns:
</p>

<dl>
<dt><code>category</code></dt><dd>
<p>label of the category to which each stimulus belongs.
</p>
</dd>
<dt><code>x</code></dt><dd><p>value on the dimension 'x'</p>
</dd>
<dt><code>y</code></dt><dd><p>value on the dimension 'y'</p>
</dd>
<dt><code>response</code></dt><dd>
<p>classification response of a participant.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>

<hr>
<h2 id='subjdemo_3d'>
Sample dataset of a categorization experiment with 3D stimuli.
</h2><span id='topic+subjdemo_3d'></span>

<h3>Description</h3>

<p>A sample one dimensional stimulus set and response data of a hypothetical participant in a two-category classification experiment involving 500 trials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subjdemo_3d
</code></pre>


<h3>Format</h3>

<p>This data frame contains 500 rows and the following columns:
</p>

<dl>
<dt><code>category</code></dt><dd>
<p>label of the category to which each stimulus belongs.
</p>
</dd>
<dt><code>x</code></dt><dd><p>value on the dimension 'x'</p>
</dd>
<dt><code>y</code></dt><dd><p>value on the dimension 'y'</p>
</dd>
<dt><code>z</code></dt><dd><p>value on the dimension 'z'</p>
</dd>
<dt><code>response</code></dt><dd>
<p>classification response of a participant.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>


<h3>References</h3>

<p>Alfonso-Reese, L. A. (2006)
<em>General recognition theory of categorization: A MATLAB toolbox</em>.
Behavior Research Methods, 38, 579-583.
</p>

<hr>
<h2 id='subjdemo_cj'>
Sample dataset of a categorization experiment with 2D conjunctive stimuli.
</h2><span id='topic+subjdemo_cj'></span>

<h3>Description</h3>

<p>A sample two dimensional stimulus set and response data of a hypothetical participant in a two-category classification experiment involving 100 trials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subjdemo_cj
</code></pre>


<h3>Format</h3>

<p>This data frame contains 100 rows and the following columns:
</p>

<dl>
<dt><code>category</code></dt><dd>
<p>label of the category to which each stimulus belongs.
</p>
</dd>
<dt><code>x1</code></dt><dd><p>value on the dimension 'x1'</p>
</dd>
<dt><code>x2</code></dt><dd><p>value on the dimension 'x2'</p>
</dd>
<dt><code>response</code></dt><dd>
<p>classification response of a participant.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>##### the data was generated using following codes:
m &lt;- list(c(100,200),c(100,100),c(200,100),c(200,200))
covs &lt;- diag(30^2, ncol=2, nrow=2)
set.seed(1)
subjdemo_cj &lt;- grtrnorm(n=c(50,20,10,20), np=4, means=m, covs=covs)
subjdemo_cj$category &lt;- c(1,2,2,2)[subjdemo_cj$category]
##### create ramdom responses with 80% accuracy
subjdemo_cj$response &lt;- subjdemo_cj$category
set.seed(1)
incorrect &lt;- sample(1:100, size=20)
subjdemo_cj$response[incorrect] &lt;- abs(subjdemo_cj$response[incorrect] - 3)

##### plotting the dataset
with(subjdemo_cj, plot(x2 ~ x1, bg=category, pch=response))
abline(h=150, lty=2)
abline(v=150, lty=2)
</code></pre>

<hr>
<h2 id='unscale'>Un-scale or re-center the scaled or centered Matrix-like object</h2><span id='topic+unscale'></span>

<h3>Description</h3>

<p>This function revert a Matrix-like object that is scaled or centered via <code>scale.default</code> to data with the original scale/center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unscale(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unscale_+3A_x">x</code></td>
<td>
<p>numeric matrix(like object).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix that are re-centered or un-scaled, based on the value of attributes &quot;scaled:center&quot; and &quot;scaled:scale&quot; of <code>x</code>. If neither of those attributes is specified, <code>x</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale">scale</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)
x &lt;- matrix(1:10, ncol=2)
unscale(z &lt;- scale(x))

#maybe useful for truncating
trunc &lt;- 1
z[abs(z) &gt; trunc] &lt;- sign(z[abs(z) &gt; trunc])*trunc
unscale(z)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
