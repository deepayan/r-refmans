<!DOCTYPE html><html lang="en"><head><title>Help for package MCARtest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MCARtest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Amatrix'><p>Generate the matrix A, whose columns are the vertices of the marginal polytope.</p></a></li>
<li><a href='#AmatrixSparse'><p>Generate the matrix A, whose columns are the vertices of the marginal polytope, as a sparse matrix.</p></a></li>
<li><a href='#aMatrixSparseRevLex'><p>Generates the row indices used internally to generate the sparse matrix A.</p></a></li>
<li><a href='#Cimproved'><p>Calculate the critical value for our improved test</p></a></li>
<li><a href='#col_index'><p>A function indexing the columns of A</p></a></li>
<li><a href='#colVector'><p>Generates the column indices used internally to generate the sparse matrix A.</p></a></li>
<li><a href='#compute_av'><p>Compute the columnwise average of means/variances</p></a></li>
<li><a href='#computeR'><p>A function computing the incompatibility index for sequences of correlation matrices</p></a></li>
<li><a href='#ConsMinkSumHrep'><p>Calculate the H-representation of the consistent Minkowski sum</p></a></li>
<li><a href='#Csimple'><p>Calculate the critical value for our simple test</p></a></li>
<li><a href='#EMiteration'><p>Perform one step of the EM algorithm for finding the MLE under MCAR in a contingency table.</p></a></li>
<li><a href='#EquivalenceClass'><p>Simplifies H-representation by exploiting symmetry</p></a></li>
<li><a href='#FuchsTest'><p>Carry out Fuchs's test of MCAR in a contingency table, given complete and incomplete observations.</p></a></li>
<li><a href='#get_SigmaS'><p>Computes the sequence of patterns, means, variances, covariance and correlation</p>
matrices for a given dataset with missing values.</a></li>
<li><a href='#InconsMinkSumHrep'><p>Calculate the H-representation of the general (possibly inconsistent) Minkowski sum</p></a></li>
<li><a href='#infoS'><p>Calculates the total cardinality of the sample spaces.</p></a></li>
<li><a href='#infoS2'><p>Calculates the individual cardinalities of the sample spaces.</p></a></li>
<li><a href='#little_test'><p>Carry out Little's test of MCAR</p></a></li>
<li><a href='#loglik0'><p>Compute the log likelihood of a probability mass function, under MCAR, given complete and incomplete data</p></a></li>
<li><a href='#loglik1'><p>Compute the log likelihood of a probability mass function, without assuming MCAR, given complete and incomplete data</p></a></li>
<li><a href='#M'><p>Computes an inconsistency index for sequences of means.</p></a></li>
<li><a href='#MargPolyHrep'><p>Calculate the H-representation of the marginal polytope</p></a></li>
<li><a href='#margProj'><p>Internal function multiplying a mass function by the sparse matrix A.</p></a></li>
<li><a href='#MCAR_meancovTest'><p>Carry out a test of MCAR using first and second moments.</p></a></li>
<li><a href='#MLE'><p>Compute the MLE under MCAR in a contingency table using the EM algorithm, given complete and incomplete observations.</p></a></li>
<li><a href='#ProjectionTest'><p>Carry out a test of MCAR in a contingency table, given incomplete observations.</p></a></li>
<li><a href='#Rindex'><p>A function computing the incompatibility index</p></a></li>
<li><a href='#RindexDual'><p>A function computing the incompatibility index and associated closest joint mass function using the dual formulation</p></a></li>
<li><a href='#RoundErrors'><p>Round errors in halfspace representations</p></a></li>
<li><a href='#row_index'><p>A function indexing the rows of A</p></a></li>
<li><a href='#V'><p>Computes an inconsistency index for sequences of variances.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Optimal Nonparametric Testing of Missing Completely at Random</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas B. Berrett &lt;tom.berrett@warwick.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for carrying out nonparametric hypothesis tests of the MCAR hypothesis based on the theory of Frechet classes and compatibility. Also gives functions for computing halfspace representations of the marginal polytope and related geometric objects.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>lpSolve, rcdd, gtools, Epi, Rdpack, Rcpp, pracma, highs,
Matrix, Rcsdp, norm, missMethods, copula, MASS</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-29 14:55:03 UTC; u1971589</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas B. Berrett <a href="https://orcid.org/0000-0002-2005-110X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alberto Bordino [aut],
  Danat Duisenbekov [aut],
  Sean Jaffe [aut],
  Richard J. Samworth
    <a href="https://orcid.org/0000-0003-2426-4679"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-29 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Amatrix'>Generate the matrix A, whose columns are the vertices of the marginal polytope.</h2><span id='topic+Amatrix'></span>

<h3>Description</h3>

<p>Generate the matrix A, whose columns are the vertices of the marginal polytope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Amatrix(bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Amatrix_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="Amatrix_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix A.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
M=c(2,2,2)
Amatrix(bS,M)
</code></pre>

<hr>
<h2 id='AmatrixSparse'>Generate the matrix A, whose columns are the vertices of the marginal polytope, as a sparse matrix.</h2><span id='topic+AmatrixSparse'></span>

<h3>Description</h3>

<p>Generate the matrix A, whose columns are the vertices of the marginal polytope, as a sparse matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AmatrixSparse(bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AmatrixSparse_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="AmatrixSparse_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix A.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
M=c(2,2,2)
AmatrixSparse(bS,M)


</code></pre>

<hr>
<h2 id='aMatrixSparseRevLex'>Generates the row indices used internally to generate the sparse matrix A.</h2><span id='topic+aMatrixSparseRevLex'></span>

<h3>Description</h3>

<p>Generates the row indices used internally to generate the sparse matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aMatrixSparseRevLex(bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aMatrixSparseRevLex_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="aMatrixSparseRevLex_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of row indices.
</p>

<hr>
<h2 id='Cimproved'>Calculate the critical value for our improved test</h2><span id='topic+Cimproved'></span>

<h3>Description</h3>

<p>Calculate a critical value for an MCAR test based on knowledge of the facet
structure of the Minkowski sum calculated by <code>ConsMinkSumHrep</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cimproved(nS, bS, M, DR, Fp, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cimproved_+3A_ns">nS</code></td>
<td>
<p>A vector of sample sizes, with each entry corresponding to an observation pattern.</p>
</td></tr>
<tr><td><code id="Cimproved_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="Cimproved_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="Cimproved_+3A_dr">DR</code></td>
<td>
<p>The quantity <code class="reqn">D_R</code> appearing in Berrett and Samworth (2023).</p>
</td></tr>
<tr><td><code id="Cimproved_+3A_fp">Fp</code></td>
<td>
<p>The quantity <code class="reqn">F'</code> appearing in Berrett and Samworth (2023).</p>
</td></tr>
<tr><td><code id="Cimproved_+3A_alpha">alpha</code></td>
<td>
<p>The desired significance level <code class="reqn">\alpha</code> of the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The critical value <code class="reqn">C_\alpha'</code> defined in Berrett and Samworth (2023).
</p>


<h3>References</h3>

<p>Berrett TB, Samworth RJ (2023).
&ldquo;Optimal nonparametric testing of Missing Completely At Random, and its connections to compatibility.&rdquo;
<em>Ann. Statist.</em>, <b>51</b>, 2170&ndash;2193.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
r=4; s=3
M=c(r,s,2)
Cimproved(rep(1000,3),bS,M,1,(2^r-2)*(2^s-2),0.05)
</code></pre>

<hr>
<h2 id='col_index'>A function indexing the columns of A</h2><span id='topic+col_index'></span>

<h3>Description</h3>

<p>A map from the joint space to an index set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_index(M, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_index_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="col_index_+3A_x">x</code></td>
<td>
<p>An element of the joint space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive integer no greater than the cardinality of the joint space uniquely identifying <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M=c(2,2,2)
col_index(M,c(1,1,1))
col_index(M,c(1,1,2))

M=c(4,3,2)
col_index(M,c(1,1,1))
col_index(M,c(2,1,1))
col_index(M,c(1,2,1))
col_index(M,c(1,1,2))
</code></pre>

<hr>
<h2 id='colVector'>Generates the column indices used internally to generate the sparse matrix A.</h2><span id='topic+colVector'></span>

<h3>Description</h3>

<p>Generates the column indices used internally to generate the sparse matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colVector(cardS, cardChi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colVector_+3A_cards">cardS</code></td>
<td>
<p>The number of missingness patterns.</p>
</td></tr>
<tr><td><code id="colVector_+3A_cardchi">cardChi</code></td>
<td>
<p>The cardinality of the full joint space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of column indices.
</p>

<hr>
<h2 id='compute_av'>Compute the columnwise average of means/variances</h2><span id='topic+compute_av'></span>

<h3>Description</h3>

<p>A function that computes <code class="reqn">\bar{\operatorname{av}}_j(\mu_{\mathbb{S}})</code> as defined in
Section 5 in Bordino and Berrett (2024), or
<code class="reqn">\bar{\operatorname{av}}_j(\sigma^2_{\mathbb{S}})</code> as defined in Section 2 in
Bordino and Berrett (2024). The sequence of means/variances, and the
sequence of patterns, are calculated with <code>getSigmaS</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_av(type, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_av_+3A_type">type</code></td>
<td>
<p>If set equal to &quot;mean&quot;, computes <code class="reqn">\bar{\operatorname{av}}_j(\mu_{\mathbb{S}})</code>.
If set equal to &quot;var&quot;, computes <code class="reqn">\bar{\operatorname{av}}_j(\sigma^2_{\mathbb{S}})</code>.</p>
</td></tr>
<tr><td><code id="compute_av_+3A_x">X</code></td>
<td>
<p>The whole dataset with missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code class="reqn">\bar{\operatorname{av}}_j(\sigma^2_{\mathbb{S}})</code> or
<code class="reqn">\bar{\operatorname{av}}_j(\mu_{\mathbb{S}})</code>.
</p>


<h3>References</h3>

<p>Bordino A, Berrett TB (2024).
&ldquo;Tests of Missing Completely At Random based on sample covariance matrices.&rdquo;
<em>arXiv preprint arXiv:2401.05256</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)

d = 3
n = 200
SigmaS=list() #Random 2x2 correlation matrices (necessarily consistent)
for(j in 1:d){
x=runif(2,min=-1,max=1); y=runif(2,min=-1,max=1); SigmaS[[j]]=cov2cor(x%*%t(x) + y%*%t(y))
}

X = data.frame(matrix(nrow = 3*n, ncol = 3))
X[1:n, c(1,2)] = mvrnorm(n, c(0,0), SigmaS[[1]])
X[(n+1):(2*n), c(2, 3)] = mvrnorm(n, c(0,0), SigmaS[[2]])
X[(2*n+1):(3*n), c(1, 3)] = mvrnorm(n, c(0,0), SigmaS[[3]])
X = as.matrix(X)

xxx = get_SigmaS(X)$patterns
compute_av("var", X)
compute_av("mean", X)
</code></pre>

<hr>
<h2 id='computeR'>A function computing the incompatibility index for sequences of correlation matrices</h2><span id='topic+computeR'></span>

<h3>Description</h3>

<p>A function solving a SDP problem to compute the incompatibility index <code class="reqn">R()</code> for a sequence of
correlation matrices, as defined in Bordino and Berrett (2024).
Writes the SDP problem in standard primal form, and uses <code>csdp</code> to solve this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeR(patterns = list(), SigmaS = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeR_+3A_patterns">patterns</code></td>
<td>
<p>A vector with all the patterns in <code class="reqn">\mathbb{S}</code></p>
</td></tr>
<tr><td><code id="computeR_+3A_sigmas">SigmaS</code></td>
<td>
<p>The sequence of correlation matrices <code class="reqn">\Sigma_\mathbb{S}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code class="reqn">R()</code>, in the interval <code class="reqn">[0,1]</code>.
</p>
<p>The optimal <code class="reqn">X_\mathbb{S}</code> for the primal problem.
</p>
<p>The sequence of matrices <code class="reqn">X_\mathbb{S}^{0}</code> as defined in Bordino and Berrett (2024).
</p>
<p>The optimal <code class="reqn">\Sigma</code> for the dual problem.
</p>
<p>The sequence of correlation matrices <code class="reqn">\Sigma_\mathbb{S}</code> in input.
</p>


<h3>References</h3>

<p>Bordino A, Berrett TB (2024).
&ldquo;Tests of Missing Completely At Random based on sample covariance matrices.&rdquo;
<em>arXiv preprint arXiv:2401.05256</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d = 3

SigmaS=list() #Random 2x2 correlation matrices (necessarily consistent)
for(j in 1:d){
x=runif(2,min=-1,max=1); y=runif(2,min=-1,max=1)
SigmaS[[j]]=cov2cor(x%*%t(x) + y%*%t(y))
}

result = computeR(list(c(1,2),c(2,3), c(1,3)), SigmaS = SigmaS)
result$R
</code></pre>

<hr>
<h2 id='ConsMinkSumHrep'>Calculate the H-representation of the consistent Minkowski sum</h2><span id='topic+ConsMinkSumHrep'></span>

<h3>Description</h3>

<p>Computes the minimal halfspace representation of the Minkowski sum of the marginal polytope
and the consistent ball defined in Berrett and Samworth (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConsMinkSumHrep(bS, M, round = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConsMinkSumHrep_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="ConsMinkSumHrep_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="ConsMinkSumHrep_+3A_round">round</code></td>
<td>
<p>A logical value indicating whether or not to round coefficients to 15 significant figures.
The function <code>RoundErrors</code> can be used separately to substitute other values for 15. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A halfspace representation object as used by the <code>rcdd</code> package. See Geyer and Meeden (2021) for more detail.
</p>


<h3>References</h3>

<p>Berrett TB, Samworth RJ (2023).
&ldquo;Optimal nonparametric testing of Missing Completely At Random, and its connections to compatibility.&rdquo;
<em>Ann. Statist.</em>, <b>51</b>, 2170&ndash;2193.
</p>
<p>Geyer CJ, Meeden GD (2021).
<em>rcdd: Computational Geometry</em>.
<a href="https://CRAN.R-project.org/package=rcdd">https://CRAN.R-project.org/package=rcdd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
ConsMinkSumHrep(bS,c(2,2,2))

</code></pre>

<hr>
<h2 id='Csimple'>Calculate the critical value for our simple test</h2><span id='topic+Csimple'></span>

<h3>Description</h3>

<p>Calculate a simple critical value for an MCAR test using only knowledge of
the set of observation patterns and the joint observation space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Csimple(nS, bS, M, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Csimple_+3A_ns">nS</code></td>
<td>
<p>A vector of sample sizes, with each entry corresponding to an observation pattern.</p>
</td></tr>
<tr><td><code id="Csimple_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="Csimple_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="Csimple_+3A_alpha">alpha</code></td>
<td>
<p>The desired significance level <code class="reqn">\alpha</code> of the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The universal critical value defined in Berrett and Samworth (2023).
</p>


<h3>References</h3>

<p>Berrett TB, Samworth RJ (2023).
&ldquo;Optimal nonparametric testing of Missing Completely At Random, and its connections to compatibility.&rdquo;
<em>Ann. Statist.</em>, <b>51</b>, 2170&ndash;2193.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
r=4; s=3
M=c(r,s,2)
Csimple(rep(1000,3),bS,M,0.05)
</code></pre>

<hr>
<h2 id='EMiteration'>Perform one step of the EM algorithm for finding the MLE under MCAR in a contingency table.</h2><span id='topic+EMiteration'></span>

<h3>Description</h3>

<p>Perform one step of the EM algorithm for finding the MLE under MCAR in a contingency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMiteration(pt, p0h, n0, pSh, nS, bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMiteration_+3A_pt">pt</code></td>
<td>
<p>An input probability mass function on the joint space, to be updated.</p>
</td></tr>
<tr><td><code id="EMiteration_+3A_p0h">p0h</code></td>
<td>
<p>An empirical mass function calculated using complete observations.</p>
</td></tr>
<tr><td><code id="EMiteration_+3A_n0">n0</code></td>
<td>
<p>An integer giving the number of complete observations used to calculate <code>p0h</code>.</p>
</td></tr>
<tr><td><code id="EMiteration_+3A_psh">pSh</code></td>
<td>
<p>A sequence of empirical mass functions calculated using incomplete observations.</p>
</td></tr>
<tr><td><code id="EMiteration_+3A_ns">nS</code></td>
<td>
<p>A sequence of integers giving the numbers of incomplete observations used to calculate <code>pSh</code>.</p>
</td></tr>
<tr><td><code id="EMiteration_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="EMiteration_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated probability mass function on the joint space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3) # Our canonical 3d example
M=c(2,2,2)
n0=200
nS=c(200,200,200)

pS=c(0.125,0.375,0.375,0.125,0.250,0.250,0.250,0.250,0.100,0.400,0.400,0.100)
P12=pS[1:4]; P13=pS[5:8]; P23=pS[9:12]
X12=t(rmultinom(1,size=nS[1],prob=P12)/nS[1])
X13=t(rmultinom(1,size=nS[2],prob=P13)/nS[2])
X23=t(rmultinom(1,size=nS[3],prob=P23)/nS[3])
pSh=cbind(X12,X13,X23)

p0=array(0.125,dim=c(2,2,2))
p0h=array(rmultinom(1,n0,p0),dim=M)/n0

EMiteration(p0,p0h,n0,pSh,nS,bS,M)

</code></pre>

<hr>
<h2 id='EquivalenceClass'>Simplifies H-representation by exploiting symmetry</h2><span id='topic+EquivalenceClass'></span>

<h3>Description</h3>

<p>The marginal polytope and related objects have many symmetries. By relabelling the levels
of discrete variables we transform facets into other facets. This function reduces a list of
halfspace normals to its equivalence classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EquivalenceClass(bS, M, Hrep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EquivalenceClass_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="EquivalenceClass_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="EquivalenceClass_+3A_hrep">Hrep</code></td>
<td>
<p>An H-representation generated by <code>MargPolyHrep</code>, <code>ConsMinkSumHrep</code> or <code>InconsMinkSumHrep</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of representative halfspace normals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3) # Our canonical 3d example
Hrep=MargPolyHrep(bS,c(2,2,2))
EquivalenceClass(bS,c(2,2,2),Hrep)

</code></pre>

<hr>
<h2 id='FuchsTest'>Carry out Fuchs's test of MCAR in a contingency table, given complete and incomplete observations.</h2><span id='topic+FuchsTest'></span>

<h3>Description</h3>

<p>Carry out Fuchs's test of MCAR in a contingency table, given complete and incomplete observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FuchsTest(p0h, n0, pSh, nS, bS, M, Niter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FuchsTest_+3A_p0h">p0h</code></td>
<td>
<p>An empirical mass function calculated using complete observations.</p>
</td></tr>
<tr><td><code id="FuchsTest_+3A_n0">n0</code></td>
<td>
<p>An integer giving the number of complete observations used to calculate <code>p0h</code>.</p>
</td></tr>
<tr><td><code id="FuchsTest_+3A_psh">pSh</code></td>
<td>
<p>A sequence of empirical mass functions calculated using incomplete observations.</p>
</td></tr>
<tr><td><code id="FuchsTest_+3A_ns">nS</code></td>
<td>
<p>A sequence of integers giving the numbers of incomplete observations used to calculate <code>pSh</code>.</p>
</td></tr>
<tr><td><code id="FuchsTest_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="FuchsTest_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="FuchsTest_+3A_niter">Niter</code></td>
<td>
<p>An integer giving the number of iterations to be used in the EM algorithm for calculating the null MLE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value of Fuchs's test, found by comparing the log likelihood ratio statistic to the chi-squared distribution
with the appropriate number of degrees of freedom. Described in Fuchs (1982).
</p>


<h3>References</h3>

<p>Fuchs C (1982).
&ldquo;Maximum likelihood estimation and model selection in contingency tables with missing data.&rdquo;
<em>J. Amer. Statist. Assoc.</em>, <b>77</b>(378), 270&ndash;278.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3) # Our canonical 3d example
M=c(2,2,2)
n0=200
nS=c(200,200,200)

pS=c(0.125,0.375,0.375,0.125,0.250,0.250,0.250,0.250,0.100,0.400,0.400,0.100)
P12=pS[1:4]; P13=pS[5:8]; P23=pS[9:12]
X12=t(rmultinom(1,size=nS[1],prob=P12)/nS[1])
X13=t(rmultinom(1,size=nS[2],prob=P13)/nS[2])
X23=t(rmultinom(1,size=nS[3],prob=P23)/nS[3])
pSh=cbind(X12,X13,X23)

p0=array(0.125,dim=c(2,2,2))
p0h=array(rmultinom(1,n0,p0),dim=M)/n0

FuchsTest(p0h,n0,pSh,nS,bS,M,50)
</code></pre>

<hr>
<h2 id='get_SigmaS'>Computes the sequence of patterns, means, variances, covariance and correlation
matrices for a given dataset with missing values.</h2><span id='topic+get_SigmaS'></span>

<h3>Description</h3>

<p>Using the same the notation of  Bordino and Berrett (2024), computes
the sequence of patterns <code class="reqn">\mathbb{S}</code>, means <code class="reqn">\mu_\mathbb{S}</code>, variances
<code class="reqn">\sigma^2_\mathbb{S}</code>, and correlation matrices <code class="reqn">\Sigma_\mathbb{S}</code>
for a dataset with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_SigmaS(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_SigmaS_+3A_x">X</code></td>
<td>
<p>The dataset with incomplete data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>patterns</code> The sequence of patterns <code class="reqn">\mathbb{S}</code>.
</p>
<p><code>n_pattern</code> The cardinality of <code class="reqn">\mathbb{S}</code>.
</p>
<p><code>data_pattern</code> A vector where the data are grouped according to <code class="reqn">\mathbb{S}</code>.
</p>
<p><code>muS</code> The sequence of means.
</p>
<p><code>C_S</code> The sequence of covariance matrices.
</p>
<p><code>sigma_squared_S</code> The sequence of variances.
</p>
<p><code>SigmaS</code> The sequence of correlation matrices.
</p>
<p><code>ambient_dimension</code> The dimension <code class="reqn">d</code> of the data.
</p>


<h3>References</h3>

<p>Bordino A, Berrett TB (2024).
&ldquo;Tests of Missing Completely At Random based on sample covariance matrices.&rdquo;
<em>arXiv preprint arXiv:2401.05256</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(copula)
library(missMethods)
n = 1000

cp = claytonCopula(param = c(1), dim = 5)
P = mvdc(copula = cp, margins = c("exp", "exp", "exp", "exp", "exp"),
         paramMargins = list(list(1), list(1), list(1), list(1), list(1)))
X = rMvdc(n, P)
X = delete_MCAR(X, 0.1, c(1,4,5))

get_SigmaS(X)
</code></pre>

<hr>
<h2 id='InconsMinkSumHrep'>Calculate the H-representation of the general (possibly inconsistent) Minkowski sum</h2><span id='topic+InconsMinkSumHrep'></span>

<h3>Description</h3>

<p>Computes the minimal halfspace representation of the Minkowski sum of the marginal polytope and the inconsistent ball
defined in Berrett and Samworth (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InconsMinkSumHrep(bS, M, round = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InconsMinkSumHrep_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="InconsMinkSumHrep_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="InconsMinkSumHrep_+3A_round">round</code></td>
<td>
<p>A logical value indicating whether or not to round coefficients to 15 significant figures.
The function <code>RoundErrors</code> can be used separately to substitute other values for 15. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A halfspace representation object as used by the <code>rcdd</code> package. See Geyer and Meeden (2021) for more detail.
</p>


<h3>References</h3>

<p>Berrett TB, Samworth RJ (2023).
&ldquo;Optimal nonparametric testing of Missing Completely At Random, and its connections to compatibility.&rdquo;
<em>Ann. Statist.</em>, <b>51</b>, 2170&ndash;2193.
</p>
<p>Geyer CJ, Meeden GD (2021).
<em>rcdd: Computational Geometry</em>.
<a href="https://CRAN.R-project.org/package=rcdd">https://CRAN.R-project.org/package=rcdd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1, 1,0),byrow=TRUE,ncol=2)
InconsMinkSumHrep(bS,c(2,2))
</code></pre>

<hr>
<h2 id='infoS'>Calculates the total cardinality of the sample spaces.</h2><span id='topic+infoS'></span>

<h3>Description</h3>

<p>Calculates the total cardinality of the sample spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infoS(bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infoS_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="infoS_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total cardinality.
</p>

<hr>
<h2 id='infoS2'>Calculates the individual cardinalities of the sample spaces.</h2><span id='topic+infoS2'></span>

<h3>Description</h3>

<p>Calculates the individual cardinalities of the sample spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infoS2(bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infoS2_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="infoS2_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of individual cardinalities.
</p>

<hr>
<h2 id='little_test'>Carry out Little's test of MCAR</h2><span id='topic+little_test'></span>

<h3>Description</h3>

<p>Carry out Little's test of MCAR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>little_test(X, alpha, type = "mean&amp;cov")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="little_test_+3A_x">X</code></td>
<td>
<p>The dataset with incomplete data, where all the pairs of variables are observed together.</p>
</td></tr>
<tr><td><code id="little_test_+3A_alpha">alpha</code></td>
<td>
<p>The nominal level of the test.</p>
</td></tr>
<tr><td><code id="little_test_+3A_type">type</code></td>
<td>
<p>Determines the test statistic to use, based on the discussion in Section 5 in Bordino and Berrett (2024).
The default option is &quot;mean&amp;cov&quot;, and uses the test statistic <code class="reqn">d^2_{\mathrm{aug}}</code>. When set equal to &quot;cov&quot;, implements a test
of MCAR based on <code class="reqn">d^2_{\mathrm{cov}}</code>, while, when set equal to &quot;mean&quot;, implements the classical Little's test as defined in
Little (1988).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean, where TRUE stands for reject MCAR. This is computed by comparing the p-value of Little's test,
found by comparing the log likelihood ratio statistic to the chi-squared distribution with the appropriate number
of degrees of freedom, with the nominal level <code>alpha</code>. Described in Little (1988).
</p>


<h3>References</h3>

<p>Bordino A, Berrett TB (2024).
&ldquo;Tests of Missing Completely At Random based on sample covariance matrices.&rdquo;
<em>arXiv preprint arXiv:2401.05256</em>.
</p>
<p>Little RJ (1988).
&ldquo;A test of Missing Completely at Random for multivariate data with missing values.&rdquo;
<em>J. Amer. Statist. Assoc.</em>, <b>83</b>, 1198&ndash;1202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
alpha = 0.05
n = 200

SigmaS=list() #Random 2x2 correlation matrices (necessarily consistent)
for(j in 1:3){
x=runif(2,min=-1,max=1); y=runif(2,min=-1,max=1)
SigmaS[[j]]=cov2cor(x%*%t(x) + y%*%t(y))
}

X1 = mvrnorm(n, c(0,0), SigmaS[[1]])
X2 = mvrnorm(n, c(0,0), SigmaS[[2]])
X3 = mvrnorm(n, c(0,0), SigmaS[[3]])
columns = c("X1","X2","X3")
X = data.frame(matrix(nrow = 3*n, ncol = 3))
X[1:n, c("X1", "X2")] = X1
X[(n+1):(2*n), c("X2", "X3")] = X2
X[(2*n+1):(3*n), c("X1", "X3")] = X3
X = as.matrix(X)

little_test(X, alpha)
</code></pre>

<hr>
<h2 id='loglik0'>Compute the log likelihood of a probability mass function, under MCAR, given complete and incomplete data</h2><span id='topic+loglik0'></span>

<h3>Description</h3>

<p>Compute the log likelihood of a probability mass function, under MCAR, given complete and incomplete data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik0(p, p0h, n0, pSh, nS, bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik0_+3A_p">p</code></td>
<td>
<p>A probability mass function whose log likelihood is to be calculated.</p>
</td></tr>
<tr><td><code id="loglik0_+3A_p0h">p0h</code></td>
<td>
<p>An empirical mass function calculated using complete observations.</p>
</td></tr>
<tr><td><code id="loglik0_+3A_n0">n0</code></td>
<td>
<p>An integer giving the number of complete observations used to calculate <code>p0h</code>.</p>
</td></tr>
<tr><td><code id="loglik0_+3A_psh">pSh</code></td>
<td>
<p>A sequence of empirical mass functions calculated using incomplete observations.</p>
</td></tr>
<tr><td><code id="loglik0_+3A_ns">nS</code></td>
<td>
<p>A sequence of integers giving the numbers of incomplete observations used to calculate <code>pSh</code>.</p>
</td></tr>
<tr><td><code id="loglik0_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="loglik0_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the log likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3) # Our canonical 3d example
M=c(2,2,2)
n0=200
nS=c(200,200,200)

pS=c(0.125,0.375,0.375,0.125,0.250,0.250,0.250,0.250,0.100,0.400,0.400,0.100)
P12=pS[1:4]; P13=pS[5:8]; P23=pS[9:12]
X12=t(rmultinom(1,size=nS[1],prob=P12)/nS[1])
X13=t(rmultinom(1,size=nS[2],prob=P13)/nS[2])
X23=t(rmultinom(1,size=nS[3],prob=P23)/nS[3])
pSh=cbind(X12,X13,X23)

p0=array(0.125,dim=c(2,2,2))
p0h=array(rmultinom(1,n0,p0),dim=M)/n0

loglik0(p0,p0h,n0,pSh,nS,bS,M)

</code></pre>

<hr>
<h2 id='loglik1'>Compute the log likelihood of a probability mass function, without assuming MCAR, given complete and incomplete data</h2><span id='topic+loglik1'></span>

<h3>Description</h3>

<p>Compute the log likelihood of a probability mass function, without assuming MCAR, given complete and incomplete data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik1(p0, pS, p0h, n0, pSh, nS, bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik1_+3A_p0">p0</code></td>
<td>
<p>A probability mass function on the joint space.</p>
</td></tr>
<tr><td><code id="loglik1_+3A_ps">pS</code></td>
<td>
<p>A sequence of probability mass functions on the marginal spaces.</p>
</td></tr>
<tr><td><code id="loglik1_+3A_p0h">p0h</code></td>
<td>
<p>An empirical mass function calculated using complete observations.</p>
</td></tr>
<tr><td><code id="loglik1_+3A_n0">n0</code></td>
<td>
<p>An integer giving the number of complete observations used to calculate <code>p0h</code>.</p>
</td></tr>
<tr><td><code id="loglik1_+3A_psh">pSh</code></td>
<td>
<p>A sequence of empirical mass functions calculated using incomplete observations.</p>
</td></tr>
<tr><td><code id="loglik1_+3A_ns">nS</code></td>
<td>
<p>A sequence of integers giving the numbers of incomplete observations used to calculate <code>pSh</code>.</p>
</td></tr>
<tr><td><code id="loglik1_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="loglik1_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the log likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3) # Our canonical 3d example
M=c(2,2,2)
n0=200
nS=c(200,200,200)

pS=c(0.125,0.375,0.375,0.125,0.250,0.250,0.250,0.250,0.100,0.400,0.400,0.100)
P12=pS[1:4]; P13=pS[5:8]; P23=pS[9:12]
X12=t(rmultinom(1,size=nS[1],prob=P12)/nS[1])
X13=t(rmultinom(1,size=nS[2],prob=P13)/nS[2])
X23=t(rmultinom(1,size=nS[3],prob=P23)/nS[3])
pSh=cbind(X12,X13,X23)

p0=array(0.125,dim=c(2,2,2))
p0h=array(rmultinom(1,n0,p0),dim=M)/n0

loglik1(p0,pS,p0h,n0,pSh,nS,bS,M)

</code></pre>

<hr>
<h2 id='M'>Computes an inconsistency index for sequences of means.</h2><span id='topic+M'></span>

<h3>Description</h3>

<p>A function that computes the inconsistency index <code class="reqn">M(\mu_\mathbb{S})</code> for a sequence of
means, as defined in Section 5 in Bordino and Berrett (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M(mu_S, patterns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="M_+3A_mu_s">mu_S</code></td>
<td>
<p>The sequence of means <code class="reqn">\mu_\mathbb{S}</code>.</p>
</td></tr>
<tr><td><code id="M_+3A_patterns">patterns</code></td>
<td>
<p>A vector with all the patterns in <code class="reqn">\mathbb{S}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code class="reqn">M()</code>, in the interval <code class="reqn">[0,1]</code>.
</p>


<h3>References</h3>

<p>Bordino A, Berrett TB (2024).
&ldquo;Tests of Missing Completely At Random based on sample covariance matrices.&rdquo;
<em>arXiv preprint arXiv:2401.05256</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)

d = 3
n = 200
SigmaS=list() #Random 2x2 correlation matrices (necessarily consistent)
for(j in 1:d){
x=runif(2,min=-1,max=1); y=runif(2,min=-1,max=1); SigmaS[[j]]=cov2cor(x%*%t(x) + y%*%t(y))
}

X = data.frame(matrix(nrow = 3*n, ncol = 3))
X[1:n, c(1,2)] = mvrnorm(n, c(0,0), SigmaS[[1]])
X[(n+1):(2*n), c(2, 3)] = mvrnorm(n, c(0,0), SigmaS[[2]])
X[(2*n+1):(3*n), c(1, 3)] = mvrnorm(n, c(0,0), SigmaS[[3]])
X = as.matrix(X)

xxx = get_SigmaS(X)$patterns
M(get_SigmaS(X)$muS, xxx)
</code></pre>

<hr>
<h2 id='MargPolyHrep'>Calculate the H-representation of the marginal polytope</h2><span id='topic+MargPolyHrep'></span>

<h3>Description</h3>

<p>Computes the minimal halfspace representation of the marginal polytope
defined, for example, in Berrett and Samworth (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MargPolyHrep(bS, M, round = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MargPolyHrep_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="MargPolyHrep_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="MargPolyHrep_+3A_round">round</code></td>
<td>
<p>A logical value indicating whether or not to round coefficients to 15 significant figures.
The function <code>RoundErrors</code> can be used separately to substitute other values for 15. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A halfspace representation object as used by the <code>rcdd</code> package. See Geyer and Meeden (2021) for more detail.
</p>


<h3>References</h3>

<p>Berrett TB, Samworth RJ (2023).
&ldquo;Optimal nonparametric testing of Missing Completely At Random, and its connections to compatibility.&rdquo;
<em>Ann. Statist.</em>, <b>51</b>, 2170&ndash;2193.
</p>
<p>Geyer CJ, Meeden GD (2021).
<em>rcdd: Computational Geometry</em>.
<a href="https://CRAN.R-project.org/package=rcdd">https://CRAN.R-project.org/package=rcdd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
MargPolyHrep(bS,c(2,2,2))
</code></pre>

<hr>
<h2 id='margProj'>Internal function multiplying a mass function by the sparse matrix A.</h2><span id='topic+margProj'></span>

<h3>Description</h3>

<p>Internal function multiplying a mass function by the sparse matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margProj(p, bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="margProj_+3A_p">p</code></td>
<td>
<p>A subprobability mass function on the full joint space.</p>
</td></tr>
<tr><td><code id="margProj_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="margProj_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A collection of marginal mass functions.
</p>

<hr>
<h2 id='MCAR_meancovTest'>Carry out a test of MCAR using first and second moments.</h2><span id='topic+MCAR_meancovTest'></span>

<h3>Description</h3>

<p>This is the implementation of Algorithm 1 in Bordino and Berrett (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCAR_meancovTest(X, alpha, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCAR_meancovTest_+3A_x">X</code></td>
<td>
<p>The dataset with incomplete data.</p>
</td></tr>
<tr><td><code id="MCAR_meancovTest_+3A_alpha">alpha</code></td>
<td>
<p>The nominal level of the test.</p>
</td></tr>
<tr><td><code id="MCAR_meancovTest_+3A_b">B</code></td>
<td>
<p>The bootstrap sample <code class="reqn">B</code> for the bootstrap test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean, where TRUE stands for reject MCAR. This is found as outlined in
Section 5.2 in Bordino and Berrett (2024).
</p>


<h3>References</h3>

<p>Bordino A, Berrett TB (2024).
&ldquo;Tests of Missing Completely At Random based on sample covariance matrices.&rdquo;
<em>arXiv preprint arXiv:2401.05256</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
alpha = 0.05
B = 20
m = 500

SigmaS=list() #Random 2x2 correlation matrices (necessarily consistent)
for(j in 1:3){
x=runif(2,min=-1,max=1); y=runif(2,min=-1,max=1)
SigmaS[[j]]=cov2cor(x%*%t(x) + y%*%t(y))
}

X1 = mvrnorm(m, c(0,0), SigmaS[[1]])
X2 = mvrnorm(m, c(0,0), SigmaS[[2]])
X3 = mvrnorm(m, c(0,0), SigmaS[[3]])
columns = c("X1","X2","X3")
X = data.frame(matrix(nrow = 3*m, ncol = 3))
X[1:m, c("X1", "X2")] = X1
X[(m+1):(2*m), c("X2", "X3")] = X2
X[(2*m+1):(3*m), c("X1", "X3")] = X3
X = as.matrix(X)

MCAR_meancovTest(X, alpha, B)
</code></pre>

<hr>
<h2 id='MLE'>Compute the MLE under MCAR in a contingency table using the EM algorithm, given complete and incomplete observations.</h2><span id='topic+MLE'></span>

<h3>Description</h3>

<p>Compute the MLE under MCAR in a contingency table using the EM algorithm, given complete and incomplete observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLE(p0h, n0, pSh, nS, bS, M, Niter, loglik = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLE_+3A_p0h">p0h</code></td>
<td>
<p>An empirical mass function calculated using complete observations.</p>
</td></tr>
<tr><td><code id="MLE_+3A_n0">n0</code></td>
<td>
<p>An integer giving the number of complete observations used to calculate <code>p0h</code>.</p>
</td></tr>
<tr><td><code id="MLE_+3A_psh">pSh</code></td>
<td>
<p>A sequence of empirical mass functions calculated using incomplete observations.</p>
</td></tr>
<tr><td><code id="MLE_+3A_ns">nS</code></td>
<td>
<p>A sequence of integers giving the numbers of incomplete observations used to calculate <code>pSh</code>.</p>
</td></tr>
<tr><td><code id="MLE_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="MLE_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="MLE_+3A_niter">Niter</code></td>
<td>
<p>An integer giving the number of iterations to be used in the EM algorithm.</p>
</td></tr>
<tr><td><code id="MLE_+3A_loglik">loglik</code></td>
<td>
<p>A logical value indicating whether or not the log likelihoods at each step of the EM algorithm should be an output. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the EM algorithm, approximating the MLE for the probability mass function on the joint space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3) # Our canonical 3d example
M=c(2,2,2)
n0=200
nS=c(200,200,200)

pS=c(0.125,0.375,0.375,0.125,0.250,0.250,0.250,0.250,0.100,0.400,0.400,0.100)
P12=pS[1:4]; P13=pS[5:8]; P23=pS[9:12]
X12=t(rmultinom(1,size=nS[1],prob=P12)/nS[1])
X13=t(rmultinom(1,size=nS[2],prob=P13)/nS[2])
X23=t(rmultinom(1,size=nS[3],prob=P23)/nS[3])
pSh=cbind(X12,X13,X23)

p0=array(0.125,dim=c(2,2,2))
p0h=array(rmultinom(1,n0,p0),dim=M)/n0

MLE(p0h,n0,pSh,nS,bS,M,50)

trace=MLE(p0h,n0,pSh,nS,bS,M,50,loglik=TRUE)[[2]]
plot(1:50,trace,type="l")
</code></pre>

<hr>
<h2 id='ProjectionTest'>Carry out a test of MCAR in a contingency table, given incomplete observations.</h2><span id='topic+ProjectionTest'></span>

<h3>Description</h3>

<p>Carry out a test of MCAR in a contingency table, given incomplete observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectionTest(pSh, nS, bS, M, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProjectionTest_+3A_psh">pSh</code></td>
<td>
<p>A sequence of empirical mass functions calculated using incomplete observations.</p>
</td></tr>
<tr><td><code id="ProjectionTest_+3A_ns">nS</code></td>
<td>
<p>A sequence of integers giving the numbers of incomplete observations used to calculate <code>pSh</code>.</p>
</td></tr>
<tr><td><code id="ProjectionTest_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="ProjectionTest_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="ProjectionTest_+3A_b">B</code></td>
<td>
<p>An integer giving the number of bootstrap samples to be used to calibrate the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value the Monte Carlo test described in Berrett and Samworth (2023).
</p>
<p>The value of the test statistic <code class="reqn">R()</code>.
</p>


<h3>References</h3>

<p>Berrett TB, Samworth RJ (2023).
&ldquo;Optimal nonparametric testing of Missing Completely At Random, and its connections to compatibility.&rdquo;
<em>Ann. Statist.</em>, <b>51</b>, 2170&ndash;2193.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3) # Our canonical 3d example
M=c(2,2,2)
nS=c(200,200,200)

pS=c(0.125,0.375,0.375,0.125,0.250,0.250,0.250,0.250,0.100,0.400,0.400,0.100)
P12=pS[1:4]; P13=pS[5:8]; P23=pS[9:12]
X12=t(rmultinom(1,size=nS[1],prob=P12)/nS[1])
X13=t(rmultinom(1,size=nS[2],prob=P13)/nS[2])
X23=t(rmultinom(1,size=nS[3],prob=P23)/nS[3])
pSh=cbind(X12,X13,X23)

ProjectionTest(pSh,nS,bS,M,99)
</code></pre>

<hr>
<h2 id='Rindex'>A function computing the incompatibility index</h2><span id='topic+Rindex'></span>

<h3>Description</h3>

<p>A function solving a linear program to compute the incompatibility index <code class="reqn">R()</code> defined in Berrett and Samworth (2023),
in the case of having discrete random variables.
Uses <code>Amatrix</code> to define to constraint matrix and <code>lpSolve</code> to implement the linear optimisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rindex(pS, bS, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rindex_+3A_ps">pS</code></td>
<td>
<p>A sequence of probability mass functions on the marginal spaces.</p>
</td></tr>
<tr><td><code id="Rindex_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="Rindex_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code class="reqn">R()</code>, in the interval <code class="reqn">[0,1]</code>.
</p>


<h3>References</h3>

<p>Berrett TB, Samworth RJ (2023).
&ldquo;Optimal nonparametric testing of Missing Completely At Random, and its connections to compatibility.&rdquo;
<em>Ann. Statist.</em>, <b>51</b>, 2170&ndash;2193.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
M=c(2,2,2)

pS=rep(0.25,12)
Rindex(pS,bS,M)

pS=c(0.125,0.375,0.375,0.125,0.250,0.250,0.250,0.250,0.100,0.400,0.400,0.100)
Rindex(pS,bS,M)
</code></pre>

<hr>
<h2 id='RindexDual'>A function computing the incompatibility index and associated closest joint mass function using the dual formulation</h2><span id='topic+RindexDual'></span>

<h3>Description</h3>

<p>A function solving a linear program to compute the incompatibility index <code class="reqn">R()</code> defined in Berrett and Samworth (2023),
in the case of having discrete random variables.
Uses <code>Amatrix</code> to define to constraint matrix and <code>lpSolve</code> to implement the linear optimisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RindexDual(pS, bS, M, lp_solver = "default", simplex_strategy = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RindexDual_+3A_ps">pS</code></td>
<td>
<p>A sequence of probability mass functions on the marginal spaces.</p>
</td></tr>
<tr><td><code id="RindexDual_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="RindexDual_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="RindexDual_+3A_lp_solver">lp_solver</code></td>
<td>
<p>An argument passed to HiGHS specifying which solver to use.</p>
</td></tr>
<tr><td><code id="RindexDual_+3A_simplex_strategy">simplex_strategy</code></td>
<td>
<p>An argument passed to HiGHS specifying which solver to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code class="reqn">R()</code>, in the interval <code class="reqn">[0,1]</code>.
</p>
<p>The optimal solution to the linear program
</p>


<h3>References</h3>

<p>Berrett TB, Samworth RJ (2023).
&ldquo;Optimal nonparametric testing of Missing Completely At Random, and its connections to compatibility.&rdquo;
<em>Ann. Statist.</em>, <b>51</b>, 2170&ndash;2193.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
M=c(2,2,2)
A=Amatrix(bS,M)

pS=rep(0.25,12)
linprog=RindexDual(pS,bS,M)
rbind(pS,as.vector(A%*%linprog[[2]])/(1-linprog[[1]]))

pS=c(0.125,0.375,0.375,0.125,0.250,0.250,0.250,0.250,0.100,0.400,0.400,0.100)
linprog=RindexDual(pS,bS,M)
rbind(pS,as.vector(A%*%linprog[[2]])/(1-linprog[[1]]))

</code></pre>

<hr>
<h2 id='RoundErrors'>Round errors in halfspace representations</h2><span id='topic+RoundErrors'></span>

<h3>Description</h3>

<p>Round errors in halfspace representations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RoundErrors(X, digits = 15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RoundErrors_+3A_x">X</code></td>
<td>
<p>A halfspace representation to be rounded.</p>
</td></tr>
<tr><td><code id="RoundErrors_+3A_digits">digits</code></td>
<td>
<p>An integer giving the number of significant figures to be kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rounded halfspace representation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,1,0, 1,0,0,1, 0,1,0,1, 0,0,1,1),byrow=TRUE,ncol=4)
RoundErrors("9007199254740992/6004799503160661") #Occurs in ConsMinkSumHrep(bS,c(2,2,2,2))



</code></pre>

<hr>
<h2 id='row_index'>A function indexing the rows of A</h2><span id='topic+row_index'></span>

<h3>Description</h3>

<p>A map from the observation space to an index set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_index(bS, M, S, xS)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row_index_+3A_bs">bS</code></td>
<td>
<p>A binary matrix specifying the set of observation patterns. Each row encodes a single pattern.</p>
</td></tr>
<tr><td><code id="row_index_+3A_m">M</code></td>
<td>
<p>A vector of positive integers giving the alphabet sizes of the discrete variables.</p>
</td></tr>
<tr><td><code id="row_index_+3A_s">S</code></td>
<td>
<p>An integer indicating which observation pattern is of interest.</p>
</td></tr>
<tr><td><code id="row_index_+3A_xs">xS</code></td>
<td>
<p>An element of the observation space of the specified observation pattern.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive integer no larger than the cardinality of the joint space uniquely identifying <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
M=c(2,2,2)
row_index(bS,M,1,c(1,1))
row_index(bS,M,2,c(1,1))
row_index(bS,M,3,c(1,1))

bS=matrix(c(1,1,0, 1,0,1, 0,1,1),byrow=TRUE,ncol=3)
M=c(4,3,2)
row_index(bS,M,1,c(1,1))
row_index(bS,M,1,c(2,1))
row_index(bS,M,1,c(3,1))
row_index(bS,M,1,c(4,1))
row_index(bS,M,1,c(1,2))
row_index(bS,M,1,c(2,2))

</code></pre>

<hr>
<h2 id='V'>Computes an inconsistency index for sequences of variances.</h2><span id='topic+V'></span>

<h3>Description</h3>

<p>A function that computes the inconsistency index <code class="reqn">V(\sigma^2_\mathbb{S})</code> for a sequence of
variances as defined in Section 2 in Bordino and Berrett (2024), given the fact that
<code class="reqn">\bar{\operatorname{av}}(\sigma^2_{\mathbb{S}_j}) = 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>V(sigma_squared_S, patterns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="V_+3A_sigma_squared_s">sigma_squared_S</code></td>
<td>
<p>The sequence of variances <code class="reqn">\sigma_\mathbb{S}^2</code>.</p>
</td></tr>
<tr><td><code id="V_+3A_patterns">patterns</code></td>
<td>
<p>A vector with all the patterns in <code class="reqn">\mathbb{S}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code class="reqn">V()</code>, in the interval <code class="reqn">[0,1]</code>.
</p>


<h3>References</h3>

<p>Bordino A, Berrett TB (2024).
&ldquo;Tests of Missing Completely At Random based on sample covariance matrices.&rdquo;
<em>arXiv preprint arXiv:2401.05256</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)

d = 3
n = 200
SigmaS=list() #Random 2x2 correlation matrices (necessarily consistent)
for(j in 1:d){
x=runif(2,min=-1,max=1); y=runif(2,min=-1,max=1); SigmaS[[j]]=cov2cor(x%*%t(x) + y%*%t(y))
}

X = data.frame(matrix(nrow = 3*n, ncol = 3))
X[1:n, c(1,2)] = mvrnorm(n, c(0,0), SigmaS[[1]])
X[(n+1):(2*n), c(2, 3)] = mvrnorm(n, c(0,0), SigmaS[[2]])
X[(2*n+1):(3*n), c(1, 3)] = mvrnorm(n, c(0,0), SigmaS[[3]])
X = as.matrix(X)

xxx = get_SigmaS(X)$patterns
av_sigma = compute_av("var", X)
X_new = X
for (j in 1:3){
  X_new[,j] = X[,j]/sqrt(av_sigma[j])
  }

V(get_SigmaS(X_new)$sigma_squared_S, xxx)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
