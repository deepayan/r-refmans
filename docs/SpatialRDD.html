<!DOCTYPE html><html><head><title>Help for package SpatialRDD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialRDD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#assign_treated'><p>Let the package know which observations were treated</p></a></li>
<li><a href='#border_segment'><p>Border Segment Creation for FE-estimation</p></a></li>
<li><a href='#create_placebos'><p>Multiple placebocheks unified in just one list or coefplot</p></a></li>
<li><a href='#cut_off'><p>Dataset with boundaries and polygons for the SpatialRDD vignette.</p></a></li>
<li><a href='#cutoff2polygon'><p>Create (treated) polygon from line</p></a></li>
<li><a href='#discretise_border'><p>Split the RD cut-off into borderpoints</p></a></li>
<li><a href='#plotspatialrd'><p>Plot SpatialRD output</p></a></li>
<li><a href='#points2line'><p>Convert borderpoints to a line</p></a></li>
<li><a href='#polygon_full'><p>Dataset with boundaries and polygons for the SpatialRDD vignette.</p></a></li>
<li><a href='#polygon_treated'><p>Dataset with boundaries and polygons for the SpatialRDD vignette.</p></a></li>
<li><a href='#printspatialrd'><p>Print spatialrd output</p></a></li>
<li><a href='#shift_border'><p>Shift, shrink/grow, and rotate borders around</p></a></li>
<li><a href='#spatialrd'><p>non-parametric Spatial RD / GRD</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Conduct Multiple Types of Geographic Regression Discontinuity
Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatial versions of Regression Discontinuity Designs (RDDs) are becoming increasingly popular as tools for causal inference. However, conducting state-of-the-art analyses often involves tedious and time-consuming steps. This package offers comprehensive functionalities for executing all required spatial and econometric tasks in a streamlined manner. Moreover, it equips researchers with tools for performing essential placebo and balancing checks comprehensively. The fact that researchers do not have to rely on 'APIs' of external 'GIS' software ensures replicability and raises the standard for spatial RDDs.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, sf, ggplot2, rdrobust, lmtest, sandwich, cowplot,
magrittr, rlang, broom</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, tmap, rmarkdown, testthat, utils, kableExtra, lfe,
stargazer</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://axlehner.github.io/SpatialRDD/">https://axlehner.github.io/SpatialRDD/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/axlehner/SpatialRDD/issues">https://github.com/axlehner/SpatialRDD/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-07 20:28:45 UTC; alexanderlehner</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Lehner <a href="https://orcid.org/0000-0001-5885-5966"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Lehner &lt;lehner@uchicago.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 15:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See magrittr pkg documentation for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='assign_treated'>Let the package know which observations were treated</h2><span id='topic+assign_treated'></span>

<h3>Description</h3>

<p>Creates a vector with 0's and 1's to determine on which side of the cut-off each observation is. For this it is useful to have a polygon that fully describes the &quot;treated area&quot;.
If you do not have such a polygon there is a (preliminary and patchy) way implemented in the package via <code><a href="#topic+points2line">points2line</a></code> and <code><a href="#topic+cutoff2polygon">cutoff2polygon</a></code> that lets you go from points to line to &quot;treated polygon&quot; in a very crude way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_treated(data, polygon, id = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_treated_+3A_data">data</code></td>
<td>
<p>sf data frame containing point data (if you have polygons, convert first with sf::st_centroid())</p>
</td></tr>
<tr><td><code id="assign_treated_+3A_polygon">polygon</code></td>
<td>
<p>sf object with polygon geometry that fully describes the area(s) that contain the treated points</p>
</td></tr>
<tr><td><code id="assign_treated_+3A_id">id</code></td>
<td>
<p>string that represents the name of the column in the data that represents the unique identifier for each observation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of type factor with 0's and 1's. Convert with as.numeric() if you want real numbers/integers.
</p>


<h3>Note</h3>

<p>This is essentially a wrapper of <code>sf::st_intersection</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points_samp.sf &lt;- sf::st_sample(polygon_full, 100) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
# add a unique ID to each observation:
points_samp.sf$id &lt;- 1:nrow(points_samp.sf)
points_samp.sf$treated &lt;- assign_treated(points_samp.sf, polygon_treated, id = "id")

</code></pre>

<hr>
<h2 id='border_segment'>Border Segment Creation for FE-estimation</h2><span id='topic+border_segment'></span>

<h3>Description</h3>

<p>Creates <code>n</code> segments of a line (the RD cut-off) and assigns the closest border segment for each observation in the sf data frame.
Computationally these tasks are quite demanding when the sample size is big and thus might take a few seconds to complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>border_segment(data, cutoff, n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="border_segment_+3A_data">data</code></td>
<td>
<p>sf data frame containing point data</p>
</td></tr>
<tr><td><code id="border_segment_+3A_cutoff">cutoff</code></td>
<td>
<p>the RDD border in the form of a line (preferred) or borderpoints</p>
</td></tr>
<tr><td><code id="border_segment_+3A_n">n</code></td>
<td>
<p>the number of segments to be produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with factors, each category representing one segment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points_samp.sf &lt;- sf::st_sample(polygon_full, 100) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
points_samp.sf$segment10 &lt;- border_segment(points_samp.sf, cut_off, 3)

</code></pre>

<hr>
<h2 id='create_placebos'>Multiple placebocheks unified in just one list or coefplot</h2><span id='topic+create_placebos'></span>

<h3>Description</h3>

<p>Unifies <code><a href="#topic+shift_border">shift_border</a></code>, <code><a href="#topic+cutoff2polygon">cutoff2polygon</a></code>, <code><a href="#topic+assign_treated">assign_treated</a></code> in one function to carry out a myriad of placebo checks at once.
The output is either a data.frame (with or without geometry of the respective placeboline) or a coefplot.
Requires operations data.frame that contains all desired operations (columns shift.x, shift.y, scale, angle, orientation.1, orientation.2, endpoint.1, endpoint.2),
if you don't need a certain operation just use default values (e.g. 0 for angle and 1 for scale), but the column has to be there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_placebos(
  data,
  cutoff,
  formula,
  operations,
  bw_dist,
  coefplot = FALSE,
  geometry = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_placebos_+3A_data">data</code></td>
<td>
<p>sf data.frame that contains all units of observation</p>
</td></tr>
<tr><td><code id="create_placebos_+3A_cutoff">cutoff</code></td>
<td>
<p>initial RD cutoff as an sj object</p>
</td></tr>
<tr><td><code id="create_placebos_+3A_formula">formula</code></td>
<td>
<p>provide the formula you want to use for OLS, omit the treatetment dummy (if you want a univariate regression just on &quot;treated&quot;, then provide y ~ 1 as formula)</p>
</td></tr>
<tr><td><code id="create_placebos_+3A_operations">operations</code></td>
<td>
<p>container that has all the information in it on how to change the border for each placeboregression</p>
</td></tr>
<tr><td><code id="create_placebos_+3A_bw_dist">bw_dist</code></td>
<td>
<p>what is the distance for the bandwith (in CRS units, thus ideally metres)</p>
</td></tr>
<tr><td><code id="create_placebos_+3A_coefplot">coefplot</code></td>
<td>
<p>provide coefplot instead of a data.frame</p>
</td></tr>
<tr><td><code id="create_placebos_+3A_geometry">geometry</code></td>
<td>
<p>set to <code>TRUE</code> if you want to plot all the lines of the used placebo borders</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a coefplot or data.frame containing results of placebo regressions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points_samp.sf &lt;- sf::st_sample(polygon_full, 100) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
# add a unique ID to each observation:
points_samp.sf$id &lt;- 1:nrow(points_samp.sf)
points_samp.sf$treated &lt;- assign_treated(points_samp.sf, polygon_treated, id = "id")
operations.df &lt;- data.frame(operation = c("shift"),
                            shift.x = c(0),
                            shift.y = c(0),
                            scale = 1,
                            angle = 0,
                            orientation.1 = c("west"),
                            orientation.2 = c("west"),
                            endpoint.1 = c(.8),
                            endpoint.2 = c(.2))
create_placebos(data = points_samp.sf, cutoff = cut_off,
formula = id ~ 1, operations = operations.df, bw_dist = 3000)
</code></pre>

<hr>
<h2 id='cut_off'>Dataset with boundaries and polygons for the SpatialRDD vignette.</h2><span id='topic+cut_off'></span>

<h3>Description</h3>

<p>sf multilinestring representing a spatial RD cut-off
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cut_off)
</code></pre>


<h3>Format</h3>

<p>A spatial data.frame of class sf
</p>


<h3>Source</h3>

<p>Lehner, Alexander (2023) Culture, Institutions, and the Roots of Gender Inequality: 450 Years of Portuguese Colonialism in India
</p>

<hr>
<h2 id='cutoff2polygon'>Create (treated) polygon from line</h2><span id='topic+cutoff2polygon'></span>

<h3>Description</h3>

<p>Creates an approximation of a &quot;treated/untreated polygon&quot; to assign the status again to each observation after the border has been shifted.
The function extends both ends of the provided cutoff to the edge of the (imaginary) bounding box of the provided data (this ensures all observations will be included).
Key is that you provide a 2-tuple that indicates in which side of the bounding box each end should go (1st element is the one with lower x-coordinate, i.e. leftern most). Always check the output manually by plotting the polygon (e.g. with <code>tm_shape(your.polygon) + tm_polygons()</code>).
If the output polygon looks odd, a first check should be to just switch the elements from the orientation vector around! See <code>vignette(shifting_borders)</code> for details and illustrative examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutoff2polygon(data, cutoff, orientation = NA, endpoints = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff2polygon_+3A_data">data</code></td>
<td>
<p>study dataset to determine the bounding box (so that all observations are covered by the new polygons) in sf format</p>
</td></tr>
<tr><td><code id="cutoff2polygon_+3A_cutoff">cutoff</code></td>
<td>
<p>sf object of the (placebo) cut-off</p>
</td></tr>
<tr><td><code id="cutoff2polygon_+3A_orientation">orientation</code></td>
<td>
<p>in which side of the bounding box does each of the extensions of the cutoff go into? First element refers to endpoint of border with smaller x-coordinate (&quot;westernmost&quot;) (takes two of &quot;north&quot;, &quot;east&quot;, &quot;south&quot;, &quot;west&quot; in a vector, e.g. <code>c("west", "north")</code>)</p>
</td></tr>
<tr><td><code id="cutoff2polygon_+3A_endpoints">endpoints</code></td>
<td>
<p>at what position on the edge should each polygon end? (vector with two numbers between 0 and 1, where 0.5 e.g. means right in the middle of the respective edge)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a polygon as an sf object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points_samp.sf &lt;- sf::st_sample(polygon_full, 100) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
# add a unique ID to each observation:
points_samp.sf$id &lt;- 1:nrow(points_samp.sf)
cutoff2polygon(data = points_samp.sf, cutoff = cut_off,
orientation = c("west", "west"), endpoints = c(.8, .2))
</code></pre>

<hr>
<h2 id='discretise_border'>Split the RD cut-off into borderpoints</h2><span id='topic+discretise_border'></span>

<h3>Description</h3>

<p>Takes in a border in the form of a polyline (or borderpoints) and converts it into point data.
These points are later used to run separate non-parametric RD estimations which eventually allows to visualise potential heterogeneous treatment effects alongside the cut-off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretise_border(
  cutoff,
  n = 10,
  random = FALSE,
  range = FALSE,
  ymax = NA,
  ymin = NA,
  xmax = NA,
  xmin = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretise_border_+3A_cutoff">cutoff</code></td>
<td>
<p>sf object of the RD cut-off in the form of a line (not preferred, but also boundarypoints are possible)</p>
</td></tr>
<tr><td><code id="discretise_border_+3A_n">n</code></td>
<td>
<p>the number of borderpoints to be created</p>
</td></tr>
<tr><td><code id="discretise_border_+3A_random">random</code></td>
<td>
<p>whether they are randomly chosen (not desireable in most cases)</p>
</td></tr>
<tr><td><code id="discretise_border_+3A_range">range</code></td>
<td>
<p>default = FALSE, if there is a specific range (N-S or E-W) for which the points are to be drawn (useful in order to exclude sparse borderpoints with little/no oberservations around because the non-parametric RD estimation will fail)</p>
</td></tr>
<tr><td><code id="discretise_border_+3A_ymax">ymax</code></td>
<td>
<p>if range = TRUE: y coordinates</p>
</td></tr>
<tr><td><code id="discretise_border_+3A_ymin">ymin</code></td>
<td>
<p>if range = TRUE: y coordinates</p>
</td></tr>
<tr><td><code id="discretise_border_+3A_xmax">xmax</code></td>
<td>
<p>if range = TRUE: x coordinates</p>
</td></tr>
<tr><td><code id="discretise_border_+3A_xmin">xmin</code></td>
<td>
<p>if range = TRUE: x coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an sf object with selected (and evenly spaced) borderpoints
</p>


<h3>Examples</h3>

<pre><code class='language-R'>borderpoints &lt;- discretise_border(cutoff = cut_off, n = 10)

</code></pre>

<hr>
<h2 id='plotspatialrd'>Plot SpatialRD output</h2><span id='topic+plotspatialrd'></span>

<h3>Description</h3>

<p>Produces plot of GRDDseries and optionally of a map that visualises every point estimate in space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotspatialrd(SpatialRDoutput, map = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotspatialrd_+3A_spatialrdoutput">SpatialRDoutput</code></td>
<td>
<p>spatial object that is produced by an estimation with <code><a href="#topic+spatialrd">spatialrd</a></code></p>
</td></tr>
<tr><td><code id="plotspatialrd_+3A_map">map</code></td>
<td>
<p>TRUE/FALSE depending on whether mapplot is desired (make sure to set <code>spatial.objcet = TRUE</code> in the <code><a href="#topic+spatialrd">spatialrd</a></code> function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots produced with ggplot2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
points_samp.sf &lt;- sf::st_sample(polygon_full, 1000) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
# add a unique ID to each observation:
points_samp.sf$id &lt;- 1:nrow(points_samp.sf)
# assign treatment:
points_samp.sf$treated &lt;- assign_treated(points_samp.sf, polygon_treated, id = "id")
# first we define a variable for the number of "treated" and control
NTr &lt;- length(points_samp.sf$id[points_samp.sf$treated == 1])
NCo &lt;- length(points_samp.sf$id[points_samp.sf$treated == 0])
# the treated areas get a 10 percentage point higher literacy rate
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- 0.7
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- 0.6
# and we add some noise, otherwise we would obtain regression coeffictions with no standard errors
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- rnorm(NTr, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 1]
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- rnorm(NCo, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 0]

# create distance to cutoff
points_samp.sf$dist2cutoff &lt;- as.numeric(sf::st_distance(points_samp.sf, cut_off))

points_samp.sf$distrunning &lt;- points_samp.sf$dist2cutoff
# give the non-treated one's a negative score
points_samp.sf$distrunning[points_samp.sf$treated == 0] &lt;- -1 *
 points_samp.sf$distrunning[points_samp.sf$treated == 0]

# create borderpoints
borderpoints.sf &lt;- discretise_border(cutoff = cut_off, n = 10)
borderpoints.sf$id &lt;- 1:nrow(borderpoints.sf)

# finally, carry out estimation alongside the boundary:
results &lt;- spatialrd(y = "education", data = points_samp.sf, cutoff.points = borderpoints.sf,
treated = "treated", minobs = 20, spatial.object = FALSE)


plotspatialrd(results)
</code></pre>

<hr>
<h2 id='points2line'>Convert borderpoints to a line</h2><span id='topic+points2line'></span>

<h3>Description</h3>

<p>Small function that connects dots and makes them one line which can later be used as a cutoff for the RD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2line(borderpoints, crs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points2line_+3A_borderpoints">borderpoints</code></td>
<td>
<p>a set of points on a boundary</p>
</td></tr>
<tr><td><code id="points2line_+3A_crs">crs</code></td>
<td>
<p>set the coordinate reference system (CRS)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a line as an sf object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points_samp.sf &lt;- sf::st_sample(polygon_full, 2) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
points2line(points_samp.sf, crs = sf::st_crs(points_samp.sf))

</code></pre>

<hr>
<h2 id='polygon_full'>Dataset with boundaries and polygons for the SpatialRDD vignette.</h2><span id='topic+polygon_full'></span>

<h3>Description</h3>

<p>sf multipolygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(polygon_full)
</code></pre>


<h3>Format</h3>

<p>A spatial data.frame of class sf
</p>


<h3>Source</h3>

<p>Lehner, Alexander (2023) Culture, Institutions, and the Roots of Gender Inequality: 450 Years of Portuguese Colonialism in India
</p>

<hr>
<h2 id='polygon_treated'>Dataset with boundaries and polygons for the SpatialRDD vignette.</h2><span id='topic+polygon_treated'></span>

<h3>Description</h3>

<p>sf multipolygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(polygon_treated)
</code></pre>


<h3>Format</h3>

<p>A spatial data.frame of class sf
</p>


<h3>Source</h3>

<p>Lehner, Alexander (2023) Culture, Institutions, and the Roots of Gender Inequality: 450 Years of Portuguese Colonialism in India
</p>

<hr>
<h2 id='printspatialrd'>Print spatialrd output</h2><span id='topic+printspatialrd'></span>

<h3>Description</h3>

<p>Preliminary function, styling with e.g. kable and kableExtra has to be done by the user individually.
You could also just use the package of your choice to print out columns of the output from <code><a href="#topic+spatialrd">spatialrd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printspatialrd(SpatialRDoutput)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printspatialrd_+3A_spatialrdoutput">SpatialRDoutput</code></td>
<td>
<p>output file from the <code><a href="#topic+spatialrd">spatialrd</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with results from the <code><a href="#topic+spatialrd">spatialrd</a></code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
points_samp.sf &lt;- sf::st_sample(polygon_full, 1000) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
# add a unique ID to each observation:
points_samp.sf$id &lt;- 1:nrow(points_samp.sf)
# assign treatment:
points_samp.sf$treated &lt;- assign_treated(points_samp.sf, polygon_treated, id = "id")
# first we define a variable for the number of "treated" and control
NTr &lt;- length(points_samp.sf$id[points_samp.sf$treated == 1])
NCo &lt;- length(points_samp.sf$id[points_samp.sf$treated == 0])
# the treated areas get a 10 percentage point higher literacy rate
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- 0.7
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- 0.6
# and we add some noise, otherwise we would obtain regression coeffictions with no standard errors
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- rnorm(NTr, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 1]
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- rnorm(NCo, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 0]

# create distance to cutoff
points_samp.sf$dist2cutoff &lt;- as.numeric(sf::st_distance(points_samp.sf, cut_off))

points_samp.sf$distrunning &lt;- points_samp.sf$dist2cutoff
# give the non-treated one's a negative score
points_samp.sf$distrunning[points_samp.sf$treated == 0] &lt;- -1 *
 points_samp.sf$distrunning[points_samp.sf$treated == 0]

# create borderpoints
borderpoints.sf &lt;- discretise_border(cutoff = cut_off, n = 10)
borderpoints.sf$id &lt;- 1:nrow(borderpoints.sf)

# finally, carry out estimation alongside the boundary:
results &lt;- spatialrd(y = "education", data = points_samp.sf, cutoff.points = borderpoints.sf,
treated = "treated", minobs = 20, spatial.object = FALSE)
printspatialrd(results)

</code></pre>

<hr>
<h2 id='shift_border'>Shift, shrink/grow, and rotate borders around</h2><span id='topic+shift_border'></span>

<h3>Description</h3>

<p>This functions takes in a border and can either shift, shrink, or rotate it. All of them can be done together as well.
This usually takes a bit of trial and error, so make sure to plot the result each time.
For a detailed walk through check out the according vignette: <code>vignette(shifting_borders)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_border(
  border,
  operation = c("shift", "scale", "rotate"),
  shift = c(0, 0),
  scale = 1,
  angle = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_border_+3A_border">border</code></td>
<td>
<p>sf object with line geometry</p>
</td></tr>
<tr><td><code id="shift_border_+3A_operation">operation</code></td>
<td>
<p><code>"shift"</code>, <code>"rotate"</code>, <code>"scale"</code> - or a combination of them</p>
</td></tr>
<tr><td><code id="shift_border_+3A_shift">shift</code></td>
<td>
<p>if <code>operation = "shift"</code>, shift distance in CRS units (if UTM it is metres) for x and y coordinates as <code>c(dist_x, dist_y)</code></p>
</td></tr>
<tr><td><code id="shift_border_+3A_scale">scale</code></td>
<td>
<p>if <code>operation = "scale"</code>, provide shrinkage/growth factor: e.g. <code>.9</code> to shrink by 10perc. and <code>1.1</code> to increase by 10perc.</p>
</td></tr>
<tr><td><code id="shift_border_+3A_angle">angle</code></td>
<td>
<p>if <code>operation = "rotate"</code>, provide angle in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new border in the form of an sf object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shift_border(border = cut_off, operation = c("shift", "scale"),
shift = c(-5000, -3000), scale = .85)

shift_border(border = cut_off, operation = "rotate", angle = 10)


</code></pre>

<hr>
<h2 id='spatialrd'>non-parametric Spatial RD / GRD</h2><span id='topic+spatialrd'></span>

<h3>Description</h3>

<p>This function loops over all boundary points and locally estimates a non-parametric RD (using local linear regression)
using the <code>rdrobust</code> function from the <code>rdrobust</code> package from Calonico, Cattaneo, Titiunik (2014).
It takes in the discretized cutoff point file (the RDcutoff, a linestring chopped into parts by the <code><a href="#topic+discretise_border">discretise_border</a></code> function)
and the sf object (which essentially is just a conventional data.frame with a <code>geometry()</code> column) containing all the observations (treated and untreated).
The treated indicator variable has to be assigned before (potentially with <code><a href="#topic+assign_treated">assign_treated</a></code>) and be part of the sf object as a column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialrd(
  y,
  data,
  cutoff.points,
  treated,
  minobs = 50,
  bwfix_m = NA,
  sample = FALSE,
  samplesize = NA,
  sparse.exclusion = FALSE,
  store.CIs = FALSE,
  spatial.object = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialrd_+3A_y">y</code></td>
<td>
<p>The name of the dependent variable in the points frame in the form of a string</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_data">data</code></td>
<td>
<p>sf data.frame with points that describe the observations</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_cutoff.points">cutoff.points</code></td>
<td>
<p>sf object of borderpoints (provided by user or obtained with <code><a href="#topic+discretise_border">discretise_border</a></code>)</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_treated">treated</code></td>
<td>
<p>column that contains the treated dummy (as string)</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_minobs">minobs</code></td>
<td>
<p>the minimum amount of observations in each estimation for the point estimate to be included (default is 50)</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_bwfix_m">bwfix_m</code></td>
<td>
<p>fixed bandwidth in meters (in case you want to impose one yourself)</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_sample">sample</code></td>
<td>
<p>draw a random sample of points (default is FALSE)</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_samplesize">samplesize</code></td>
<td>
<p>if random, how many points</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_sparse.exclusion">sparse.exclusion</code></td>
<td>
<p>in case we want to try to exclude sparse border points before the estimation (should reduce warnings)</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_store.cis">store.CIs</code></td>
<td>
<p>set TRUE of confidence intervals should be stored</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_spatial.object">spatial.object</code></td>
<td>
<p>return a spatial object (deafult is TRUE, needed if you want to plot the point estimates on a map)?</p>
</td></tr>
<tr><td><code id="spatialrd_+3A_...">...</code></td>
<td>
<p>in addition you can use all options in <code><a href="rdrobust.html#topic+rdrobust">rdrobust</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function nests <code><a href="rdrobust.html#topic+rdrobust">rdrobust</a></code>. All its options (aside from running variable <code>x</code> and cutoff <code>c</code>) are available here as well (e.g. bw selection, cluster level, kernel, weights).
Check the documentation in the <code>rdrobust</code> package for details. (bandwidth selection default in <code>rdrobust</code> is bwselect = 'mserd')
</p>
<p>To visualise the output, use <code><a href="#topic+plotspatialrd">plotspatialrd</a></code> for a graphical representation. You can use <code><a href="#topic+printspatialrd">printspatialrd</a></code> (or an R package of your choice) for a table output. .
</p>


<h3>Value</h3>

<p>a data.frame or spatial data.frame (sf object) in case spatial.object = TRUE (default)
</p>


<h3>References</h3>

<p>Calonico, Cattaneo and Titiunik (2014): Robust Nonparametric Confidence Intervals for Regression-Discontinuity Designs, Econometrica 82(6): 2295-2326.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points_samp.sf &lt;- sf::st_sample(polygon_full, 1000) # create points
# make it an sf object bc st_sample only created the geometry list-column (sfc):
points_samp.sf &lt;- sf::st_sf(points_samp.sf)
# add a unique ID to each observation:
points_samp.sf$id &lt;- 1:nrow(points_samp.sf)
# assign treatment:
points_samp.sf$treated &lt;- assign_treated(points_samp.sf, polygon_treated, id = "id")
# first we define a variable for the number of "treated" and control
NTr &lt;- length(points_samp.sf$id[points_samp.sf$treated == 1])
NCo &lt;- length(points_samp.sf$id[points_samp.sf$treated == 0])
# the treated areas get a 10 percentage point higher literacy rate
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- 0.7
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- 0.6
# and we add some noise, otherwise we would obtain regression coeffictions with no standard errors
points_samp.sf$education[points_samp.sf$treated == 1] &lt;- rnorm(NTr, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 1]
points_samp.sf$education[points_samp.sf$treated == 0] &lt;- rnorm(NCo, mean = 0, sd = .1) +
  points_samp.sf$education[points_samp.sf$treated == 0]

# create distance to cutoff
points_samp.sf$dist2cutoff &lt;- as.numeric(sf::st_distance(points_samp.sf, cut_off))

points_samp.sf$distrunning &lt;- points_samp.sf$dist2cutoff
# give the non-treated one's a negative score
points_samp.sf$distrunning[points_samp.sf$treated == 0] &lt;- -1 *
 points_samp.sf$distrunning[points_samp.sf$treated == 0]

# create borderpoints
borderpoints.sf &lt;- discretise_border(cutoff = cut_off, n = 10)
borderpoints.sf$id &lt;- 1:nrow(borderpoints.sf)

# finally, carry out estimation alongside the boundary:
results &lt;- spatialrd(y = "education", data = points_samp.sf, cutoff.points = borderpoints.sf,
treated = "treated", minobs = 20, spatial.object = FALSE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
