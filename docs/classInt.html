<!DOCTYPE html><html><head><title>Help for package classInt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {classInt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Classify Intervals'><p>Classify univariate vector to interval</p></a></li>
<li><a href='#classIntervals'><p>Choose univariate class intervals</p></a></li>
<li><a href='#findColours'><p>assign colours to classes from classInterval object</p></a></li>
<li><a href='#findCols'><p>extract classes from classInterval object</p></a></li>
<li><a href='#getBclustClassIntervals'><p>Change breaks in a &quot;classIntervals&quot; object</p></a></li>
<li><a href='#jenks.tests'><p>Indices for assessing class intervals</p></a></li>
<li><a href='#logLik.classIntervals'><p>Log-likelihood for classIntervals objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.4-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Choose Univariate Class Intervals</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, stats, graphics, e1071, class, KernSmooth</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spData (&ge; 0.2.6.2), units, knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Selected commonly used methods for choosing univariate class intervals for mapping or other graphics purposes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-spatial.github.io/classInt/">https://r-spatial.github.io/classInt/</a>,
<a href="https://github.com/r-spatial/classInt/">https://github.com/r-spatial/classInt/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatial/classInt/issues/">https://github.com/r-spatial/classInt/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-05 08:36:55 UTC; rsb</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Bivand <a href="https://orcid.org/0000-0003-2392-6140"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Richard Dunlap [ctb],
  Diego Hernangómez <a href="https://orcid.org/0000-0001-8457-4658"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Hisaji Ono [ctb],
  Josiah Parry <a href="https://orcid.org/0000-0001-9910-865X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Matthieu Stigler <a href="https://orcid.org/0000-0002-6802-4290"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger Bivand &lt;Roger.Bivand@nhh.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-05 13:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='Classify+20Intervals'>Classify univariate vector to interval</h2><span id='topic+classify_intervals'></span>

<h3>Description</h3>

<p>Given a numeric vector classify into numeric intervals. <code>classify_intervals()</code> is a wrapper of both <code>classIntervals()</code> and <code>findCols()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_intervals(var, n, style = "quantile", rtimes = 3, ...,
 intervalClosure = c("left", "right"), dataPrecision = NULL,
 warnSmallN = TRUE, warnLargeN = TRUE, largeN = 3000L, samp_prop = 0.1,
 gr = c("[", "]"), factor = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Classify+2B20Intervals_+3A_var">var</code></td>
<td>
<p>a continuous numerical variable</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_n">n</code></td>
<td>
<p>number of classes required, if missing, <code>nclass.Sturges</code> is used; see also the &quot;dpih&quot; and &quot;headtails&quot; styles for automatic choice of the number of classes</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_style">style</code></td>
<td>
<p>chosen style: one of &quot;fixed&quot;, &quot;sd&quot;, &quot;equal&quot;, &quot;pretty&quot;, &quot;quantile&quot;, &quot;kmeans&quot;, &quot;hclust&quot;, &quot;bclust&quot;, &quot;fisher&quot;, &quot;jenks&quot;, &quot;dpih&quot;, &quot;headtails&quot;, or &quot;maximum&quot;</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_rtimes">rtimes</code></td>
<td>
<p>number of replications of var to catenate and jitter; may be used with styles &quot;kmeans&quot; or &quot;bclust&quot; in case they have difficulties reaching a classification</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_intervalclosure">intervalClosure</code></td>
<td>
<p>default &ldquo;left&rdquo;,  allows specification of whether partition intervals are closed on the left or the right (added by Richard Dunlap). Note that the sense of interval closure is hard-coded as &ldquo;right&rdquo;-closed when<code>style="jenks"</code> (see Details below).</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_dataprecision">dataPrecision</code></td>
<td>
<p>default NULL, permits rounding of the interval endpoints (added by Richard Dunlap). The data precision used for printing interval values in the legend returned by <code>findColours</code>, and in the <code>print</code> method for classIntervals objects. If intervalClosure is &ldquo;left&rdquo;, the value returned is <code>ceiling</code> of the data value multiplied by 10 to the dataPrecision power, divided by 10 to the dataPrecision power. The argument does not round <code>var</code>, the input variable.</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_warnsmalln">warnSmallN</code></td>
<td>
<p>default TRUE, if FALSE, quietens warning for n &gt;= nobs</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_warnlargen">warnLargeN</code></td>
<td>
<p>default TRUE, if FALSE large data handling not used</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_largen">largeN</code></td>
<td>
<p>default 3000L, the QGIS sampling threshold; over 3000, the observations presented to &quot;fisher&quot; and &quot;jenks&quot; are either a <code>samp_prop=</code> sample or a sample of 3000, whichever is larger</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_samp_prop">samp_prop</code></td>
<td>
<p>default 0.1, QGIS 10% sampling proportion</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_gr">gr</code></td>
<td>
<p>default <code>c("[", "]")</code>, if the <span class="pkg">units</span> package is available, <code>units::units_options("group")</code> may be used directly to give the enclosing bracket style</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the functions called in each style</p>
</td></tr>
<tr><td><code id="Classify+2B20Intervals_+3A_factor">factor</code></td>
<td>
<p>default &quot;TRUE&quot;, if &quot;TRUE&quot; returns cols as a factor with intervals as labels rather than integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same length as <code>var</code>. When <code>factor = FALSE</code> returns a factor where the levels are the interval of the observation. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classIntervals">classIntervals</a>()</code>,
<code><a href="#topic+findCols">findCols</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xvar &lt;- c(22361, 9573, 4836, 5309, 10384, 4359, 11016, 4414, 3327, 3408, 
  17816, 6909, 6936, 7990, 3758, 3569, 21965, 3605, 2181, 1892, 
  2459, 2934, 6399, 8578, 8537, 4840, 12132, 3734, 4372, 9073, 
  7508, 5203)
classIntervals(xvar, 5, "sd")
classify_intervals(xvar, 5, "sd", factor = FALSE)
classify_intervals(xvar, 5, "sd", factor = TRUE)

if (!require("spData", quietly=TRUE)) {
  message("spData package needed for examples")
  run &lt;- FALSE
} else {
  run &lt;- TRUE
}

if (run) {
  data("jenks71", package = "spData")
  x &lt;- jenks71$jenks71
  classify_intervals(x, n = 5, style = "fisher")
}

</code></pre>

<hr>
<h2 id='classIntervals'>Choose univariate class intervals</h2><span id='topic+classIntervals'></span><span id='topic+print.classIntervals'></span><span id='topic+plot.classIntervals'></span><span id='topic+nPartitions'></span><span id='topic+classIntervals2shingle'></span>

<h3>Description</h3>

<p>The function provides a uniform interface to finding class intervals for continuous numerical variables, for example for choosing colours or symbols for plotting. Class intervals are non-overlapping, and the classes are left-closed &mdash; see <code>findInterval</code>. Argument values to the style chosen are passed through the dot arguments. <code>classIntervals2shingle</code> converts a <code>classIntervals</code> object into a shingle. Labels generated in methods are like those found in <code><a href="base.html#topic+cut">cut</a></code> unless cutlabels=FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classIntervals(var, n, style = "quantile", rtimes = 3, ...,
 intervalClosure = c("left", "right"), dataPrecision = NULL,
 warnSmallN = TRUE, warnLargeN = TRUE, largeN = 3000L, samp_prop = 0.1,
 gr = c("[", "]"))
## S3 method for class 'classIntervals'
plot(x, pal, ...)
## S3 method for class 'classIntervals'
print(x, digits = getOption("digits"), ...,
 under="under", over="over", between="-", cutlabels=TRUE, unique=FALSE,big.mark=NULL)
nPartitions(x)
classIntervals2shingle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classIntervals_+3A_var">var</code></td>
<td>
<p>a continuous numerical variable</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_n">n</code></td>
<td>
<p>number of classes required, if missing, <code>nclass.Sturges</code> is used; see also the &quot;dpih&quot; and &quot;headtails&quot; styles for automatic choice of the number of classes</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_style">style</code></td>
<td>
<p>chosen style: one of &quot;fixed&quot;, &quot;sd&quot;, &quot;equal&quot;, &quot;pretty&quot;, &quot;quantile&quot;, &quot;kmeans&quot;, &quot;hclust&quot;, &quot;bclust&quot;, &quot;fisher&quot;, &quot;jenks&quot;, &quot;dpih&quot;, &quot;headtails&quot;, &quot;maximum&quot;, or &quot;box&quot;</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_rtimes">rtimes</code></td>
<td>
<p>number of replications of var to catenate and jitter; may be used with styles &quot;kmeans&quot; or &quot;bclust&quot; in case they have difficulties reaching a classification</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_intervalclosure">intervalClosure</code></td>
<td>
<p>default &ldquo;left&rdquo;,  allows specification of whether partition intervals are closed on the left or the right (added by Richard Dunlap). Note that the sense of interval closure is hard-coded as &ldquo;right&rdquo;-closed when<code>style="jenks"</code> (see Details below).</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_dataprecision">dataPrecision</code></td>
<td>
<p>default NULL, permits rounding of the interval endpoints (added by Richard Dunlap). The data precision used for printing interval values in the legend returned by <code>findColours</code>, and in the <code>print</code> method for classIntervals objects. If intervalClosure is &ldquo;left&rdquo;, the value returned is <code>ceiling</code> of the data value multiplied by 10 to the dataPrecision power, divided by 10 to the dataPrecision power. The argument does not round <code>var</code>, the input variable.</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_warnsmalln">warnSmallN</code></td>
<td>
<p>default TRUE, if FALSE, quietens warning for n &gt;= nobs</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_warnlargen">warnLargeN</code></td>
<td>
<p>default TRUE, if FALSE large data handling not used</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_largen">largeN</code></td>
<td>
<p>default 3000L, the QGIS sampling threshold; if <code>warnLargeN</code>is TRUE and the number of observations is greater than <code>largeN</code>, the observations presented to &quot;fisher&quot; and &quot;jenks&quot; are either a <code>samp_prop=</code> sample of the observations, or a sample of <code>largeN</code>, whichever is smaller</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_samp_prop">samp_prop</code></td>
<td>
<p>default 0.1, QGIS 10% sampling proportion</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_gr">gr</code></td>
<td>
<p>default <code>c("[", "]")</code>, if the <span class="pkg">units</span> package is available, <code>units::units_options("group")</code> may be used directly to give the enclosing bracket style</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the functions called in each style</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_x">x</code></td>
<td>
<p>&quot;classIntervals&quot; object for printing, conversion to shingle, or plotting</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_under">under</code></td>
<td>
<p>character string value for &quot;under&quot; in printed table labels if cutlabels=FALSE</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_over">over</code></td>
<td>
<p>character string value for &quot;over&quot; in printed table labels if cutlabels=FALSE</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_between">between</code></td>
<td>
<p>character string value for &quot;between&quot; in printed table labels if cutlabels=FALSE</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits in printed table labels</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_cutlabels">cutlabels</code></td>
<td>
<p>default TRUE, use cut-style labels in printed table labels</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_unique">unique</code></td>
<td>
<p>default FALSE; if TRUE, collapse labels of single-value classes</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_big.mark">big.mark</code></td>
<td>
<p>default NULL; an object of class <code>character</code> to specify to 'thousands' separator</p>
</td></tr>
<tr><td><code id="classIntervals_+3A_pal">pal</code></td>
<td>
<p>a character vector of at least two colour names for colour coding the class intervals in an ECDF plot; <code>colorRampPalette</code> is used internally to create the correct number of colours</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;fixed&quot; style permits a &quot;classIntervals&quot; object to be specified with given breaks, set in the <code>fixedBreaks</code> argument; the length of <code>fixedBreaks</code> should be n+1; this style can be used to insert rounded break values.
</p>
<p>The &quot;sd&quot; style chooses breaks based on <code>pretty</code> of the centred and scaled variables, and may have a number of classes different from n; the returned <code>par=</code> includes the centre and scale values. If argument <code>sd_m</code> is given as a numeric vector of multiples to apply to the standard deviation such as <code>c(-Inf, -2, -1, 0, 1, 2, +Inf)</code>
</p>
<p>The &quot;equal&quot; style divides the range of the variable into n parts.
</p>
<p>The &quot;pretty&quot; style chooses a number of breaks not necessarily equal to n using <code>pretty</code>, but likely to be legible; arguments to <code>pretty</code> may be passed through <code>...</code>.
</p>
<p>The &quot;quantile&quot; style provides quantile breaks; arguments to <code>quantile</code> may be passed through <code>...</code>.
</p>
<p>The &quot;kmeans&quot; style uses <code>kmeans</code> to generate the breaks; it may be anchored using <code>set.seed</code>; the <code>pars</code> attribute returns the kmeans object generated; if <code>kmeans</code> fails, a jittered input vector containing <code>rtimes</code> replications of <code>var</code> is tried &mdash; with few unique values in <code>var</code>, this can prove necessary; arguments to <code>kmeans</code> may be passed through <code>...</code>.
</p>
<p>The &quot;hclust&quot; style uses <code>hclust</code> to generate the breaks using hierarchical clustering; the <code>pars</code> attribute returns the hclust object generated, and can be used to find other breaks using <code>getHclustClassIntervals</code>; arguments to <code>hclust</code> may be passed through <code>...</code>.
</p>
<p>The &quot;bclust&quot; style uses <code>bclust</code> to generate the breaks using bagged clustering; it may be anchored using <code>set.seed</code>; the <code>pars</code> attribute returns the bclust object generated, and can be used to find other breaks using <code>getBclustClassIntervals</code>; if <code>bclust</code> fails, a jittered input vector containing <code>rtimes</code> replications of <code>var</code> is tried &mdash; with few unique values in <code>var</code>, this can prove necessary; arguments to <code>bclust</code> may be passed through <code>...</code>.
</p>
<p>The &quot;fisher&quot; style uses the algorithm proposed by W. D. Fisher (1958) and discussed by Slocum et al. (2005) as the Fisher-Jenks algorithm; added here thanks to Hisaji Ono. This style will subsample by default for more than 3000 observations. This style should always be preferred to &quot;jenks&quot; as it uses the original Fortran code and runs nested for-loops much faster.
</p>
<p>The &quot;jenks&quot; style has been ported from Jenks' code, and has been checked for consistency with ArcView, ArcGIS, and MapInfo (with some remaining differences); added here thanks to Hisaji Ono (originally reported as Basic, now seen as Fortran (as described in a talk last seen at http://www.irlogi.ie/wp-content/uploads/2016/11/NUIM_ChoroHarmful.pdf, slides 26-27)). Note that the sense of interval closure is reversed from the other styles, and in this implementation has to be right-closed - use cutlabels=TRUE in <code>findColours</code> on the object returned to show the closure clearly, and use <code>findCols</code> to extract the classes for each value. This style will subsample by default for more than 3000 observations.
</p>
<p>The &quot;dpih&quot; style uses the <code>dpih()</code> function from <span class="pkg">KernSmooth</span> (Wand, 1995) implementing direct plug-in methodology to select the bin width of a histogram.
</p>
<p>The &quot;headtails&quot; style uses the algorithm proposed by Bin Jiang (2013), in order to find groupings or hierarchy for data with a heavy-tailed distribution. This classification scheme partitions all of the data values around the mean into two parts and continues the process iteratively for the values (above the mean) in the head until the head part values are no longer heavy-tailed distributed. Thus, the number of classes and the class intervals are both naturally determined. By default the algorithm uses <code>thr = 0.4</code>, meaning that when the head represents more than 40% of the observations the distribution is not considered heavy-tailed. The threshold argument <code>thr</code> may be modified through <code>...</code> (see Examples).
</p>
<p>The &quot;maximum&quot; style uses the Maximum Breaks method of classification finding the k - 1 largest differences in <code>var</code>. The mean of the values that generated the largest splits is used as the interval boundary.
</p>
<p>The &quot;box&quot; style generates 7 breaks (therefore 6 categories) based on a box-and-whisker plot. First and last categories include the data values considered as outliers, and the four remaining categories are defined by the percentiles 25, 50 and 75 of the data distribution. By default, the identification of outliers is based on the interquantile range (IQR), so values lower than percentile 25 - 1.5 * IQR or higher than percentile 75 + 1.5 * IQR are considered as outliers. The multiplier applied to the IQR <code>iqr_mult = 1.5</code> may be modified through <code>...</code>; the value must not be negative. As in the <code>"quantile"</code> style, the <code>type=</code> argument may be used to choose the quantile algoritm (default 7, standard boxplots use 5 or 2). From 0.4-9 and #41, the maximum and minimum are set to <code>+Inf</code> and <code>-Inf</code> to avoid errors induced in the earlier version where breaks could cease to be strictly ascending. The <code>legacy=</code> argument with value <code>TRUE</code> may be used to revert to the previous behaviour.
</p>


<h3>Value</h3>

<p>an object of class &quot;classIntervals&quot;:
</p>
<table>
<tr><td><code>var</code></td>
<td>
<p>the input variable</p>
</td></tr>
<tr><td><code>brks</code></td>
<td>
<p>a vector of breaks</p>
</td></tr>
</table>
<p>and attributes:
</p>
<table>
<tr><td><code>style</code></td>
<td>
<p>the style used</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>parameter values used in finding breaks</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of different finite values in the input variable</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>this function's call</p>
</td></tr>
<tr><td><code>intervalClosure</code></td>
<td>
<p>string, whether closure is &ldquo;left&rdquo; or &ldquo;right&rdquo;</p>
</td></tr>
<tr><td><code>dataPrecision</code></td>
<td>
<p>the data precision used for printing interval values in the legend returned by <code>findColours</code>, and in the <code>print</code> method for classIntervals objects. If intervalClosure is &ldquo;left&rdquo;, the value returned is <code>ceiling</code> of the data value multiplied by 10 to the dataPrecision power, divided by 10 to the dataPrecision power.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>From version 0.1-11, the default representation has been changed to use <code>cutlabels=TRUE</code>, and representation within intervals has been corrected, thanks to Richard Dunlap. From version 0.1-15, the print method drops the calculation of the possible number of combinations of observations into classes, which generated warnings for n &gt; 170.</p>


<h3>Author(s)</h3>

<p>Roger Bivand &lt;Roger.Bivand@nhh.no&gt;</p>


<h3>References</h3>

<p>Armstrong, M. P., Xiao, N., Bennett, D. A., 2003. &quot;Using genetic algorithms to create multicriteria class intervals for choropleth maps&quot;. Annals, Association of American Geographers, 93 (3), 595&ndash;623;
</p>
<p>Jenks, G. F., Caspall, F. C., 1971. &quot;Error on choroplethic maps: definition, measurement, reduction&quot;. Annals, Association of American Geographers, 61 (2), 217&ndash;244;
</p>
<p>Dent, B. D., 1999, Cartography: thematic map design. McGraw-Hill, Boston, 417 pp.;
</p>
<p>Slocum TA, McMaster RB, Kessler FC, Howard HH 2005 Thematic Cartography and Geographic Visualization, Prentice Hall, Upper Saddle River NJ.;
</p>
<p>Fisher, W. D. 1958 &quot;On grouping for maximum homogeneity&quot;, Journal of the American Statistical Association, 53, pp. 789&ndash;798 (<a href="http://lib.stat.cmu.edu/cmlib/src/cluster/fish.f">http://lib.stat.cmu.edu/cmlib/src/cluster/fish.f</a>)
</p>
<p>Wand, M. P. 1995. Data-based choice of histogram binwidth. The American Statistician, 51, 59-64.
</p>
<p>Jiang, B. 2013 &quot;Head/tail breaks: A new classification scheme for data with a heavy-tailed distribution&quot;, The Professional Geographer, 65 (3), 482 – 494. (<a href="https://arxiv.org/abs/1209.2801v1">https://arxiv.org/abs/1209.2801v1</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findColours">findColours</a></code>, <code><a href="#topic+findCols">findCols</a></code>, <code><a href="base.html#topic+pretty">pretty</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="e1071.html#topic+bclust">bclust</a></code>, <code><a href="base.html#topic+findInterval">findInterval</a></code>, <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code>, <code><a href="grDevices.html#topic+nclass">nclass</a></code>, <code><a href="lattice.html#topic+shingle">shingle</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!require("spData", quietly=TRUE)) {
  message("spData package needed for examples")
  run &lt;- FALSE
} else {
  run &lt;- TRUE
}
if (run) {
data(jenks71, package="spData")
pal1 &lt;- c("wheat1", "red3")
opar &lt;- par(mfrow=c(2,3))
plot(classIntervals(jenks71$jenks71, n=5, style="fixed",
 fixedBreaks=c(15.57, 25, 50, 75, 100, 155.30)), pal=pal1, main="Fixed")
plot(classIntervals(jenks71$jenks71, n=5, style="sd"), pal=pal1, main="Pretty standard deviations")
plot(classIntervals(jenks71$jenks71, n=5, style="equal"), pal=pal1, main="Equal intervals")
plot(classIntervals(jenks71$jenks71, n=5, style="quantile"), pal=pal1, main="Quantile")
set.seed(1)
plot(classIntervals(jenks71$jenks71, n=5, style="kmeans"), pal=pal1, main="K-means")
plot(classIntervals(jenks71$jenks71, n=5, style="hclust", method="complete"),
 pal=pal1, main="Complete cluster")
}
if (run) {
plot(classIntervals(jenks71$jenks71, n=5, style="hclust", method="single"),
 pal=pal1, main="Single cluster")
set.seed(1)
plot(classIntervals(jenks71$jenks71, n=5, style="bclust", verbose=FALSE),
 pal=pal1, main="Bagged cluster")
plot(classIntervals(jenks71$jenks71, n=5, style="fisher"), pal=pal1,
 main="Fisher's method")
plot(classIntervals(jenks71$jenks71, n=5, style="jenks"), pal=pal1,
 main="Jenks' method")
 plot(classIntervals(jenks71$jenks71, style="dpih"), pal=pal1,
 main="dpih method")
 plot(classIntervals(jenks71$jenks71, style="headtails", thr = 1), pal=pal1,
 main="Head Tails method")
 }
if (run) {
 plot(classIntervals(jenks71$jenks71, style="maximum"), pal=pal1,
 main="Maximum method")
 plot(classIntervals(jenks71$jenks71, style="box"), pal=pal1,
 main="Box method")
 par(opar)
}
if (run) {
print(classIntervals(jenks71$jenks71, n=5, style="fixed",
 fixedBreaks=c(15.57, 25, 50, 75, 100, 155.30)))
}
if (run) {
print(classIntervals(jenks71$jenks71, n=5, style="sd"))
}
if (run) {
print(classIntervals(jenks71$jenks71, n=5, style="equal"))
}
if (run) {
print(classIntervals(jenks71$jenks71, n=5, style="quantile"))
}
if (run) {
set.seed(1)
print(classIntervals(jenks71$jenks71, n=5, style="kmeans"))
}
if (run) {
set.seed(1)
print(classIntervals(jenks71$jenks71, n=5, style="kmeans", intervalClosure="right"))
}
if (run) {
set.seed(1)
print(classIntervals(jenks71$jenks71, n=5, style="kmeans", dataPrecision=0))
}
if (run) {
set.seed(1)
print(classIntervals(jenks71$jenks71, n=5, style="kmeans"), cutlabels=FALSE)
}
if (run) {
print(classIntervals(jenks71$jenks71, n=5, style="hclust", method="complete"))
}
if (run) {
print(classIntervals(jenks71$jenks71, n=5, style="hclust", method="single"))
}
if (run) {
set.seed(1)
print(classIntervals(jenks71$jenks71, n=5, style="bclust", verbose=FALSE))
}
if (run) {
print(classIntervals(jenks71$jenks71, n=5, style="bclust",
 hclust.method="complete", verbose=FALSE))
}
if (run) {
print(classIntervals(jenks71$jenks71, n=5, style="fisher"))
}
if (run) {
print(classIntervals(jenks71$jenks71, n=5, style="jenks"))
}
if (run) {
print(classIntervals(jenks71$jenks71, style="dpih"))
}
if (run) {
print(classIntervals(jenks71$jenks71, style="dpih", range.x=c(0, 160)))
}
if (run) {
  print(classIntervals(jenks71$jenks71, style="headtails"))
}
if (run) {
  print(classIntervals(jenks71$jenks71, style="headtails", thr = .45))
}
if (run) {
  print(classIntervals(jenks71$jenks71, style="maximum"))
}
if (run) {
  print(classIntervals(jenks71$jenks71, style="box"))
}
if (run) {
  print(classIntervals(jenks71$jenks71, style="box", iqr_mult = 0.25))
}
x &lt;- c(0, 0, 0, 1, 2, 50)
print(classIntervals(x, n=3, style="fisher"))
print(classIntervals(x, n=3, style="jenks"))

# Argument 'unique' will collapse the label of classes containing a
# single value. This is particularly useful for 'censored' variables
# that contain for example many zeros.

data_censored&lt;-c(rep(0,10), rnorm(100, mean=20,sd=1),rep(26,10))
plot(density(data_censored))
cl2 &lt;- classIntervals(data_censored, n=5, style="jenks", dataPrecision=2)
print(cl2, unique=FALSE)
print(cl2, unique=TRUE)

## Not run: 
set.seed(1)
n &lt;- 1e+05
x &lt;- runif(n)
classIntervals(x, n=5, style="sd")
classIntervals(x, n=5, style="pretty")
classIntervals(x, n=5, style="equal")
classIntervals(x, n=5, style="quantile")
# the class intervals found vary a little because of sampling
classIntervals(x, n=5, style="kmeans")
classIntervals(x, n=5, style="fisher")
classIntervals(x, n=5, style="fisher")
classIntervals(x, n=5, style="fisher")

## End(Not run)
have_units &lt;- FALSE
if (require(units, quietly=TRUE)) have_units &lt;- TRUE
if (have_units) {
set.seed(1)
x_units &lt;- set_units(sample(seq(1, 100, 0.25), 100), km/h)
## Not run: 
classIntervals(x_units, n=5, style="sd")

## End(Not run)
}
if (have_units) {
classIntervals(x_units, n=5, style="pretty")
}
if (have_units) {
## Not run: 
classIntervals(x_units, n=5, style="equal")

## End(Not run)
}
if (have_units) {
classIntervals(x_units, n=5, style="quantile")
}
if (have_units) {
## Not run: 
classIntervals(x_units, n=5, style="kmeans")

## End(Not run)
}
if (have_units) {
classIntervals(x_units, n=5, style="fisher")
}
if (have_units) {
classIntervals(x_units, style="headtails")
}
if (have_units) {
classIntervals(x_units, style="box")
}
## Not run: 
st &lt;- Sys.time()
x_POSIXt &lt;- sample(st+((0:500)*3600), 100)
fx &lt;- st+((0:5)*3600)*100
classIntervals(x_POSIXt, style="fixed", fixedBreaks=fx)
classIntervals(x_POSIXt, n=5, style="sd")
classIntervals(x_POSIXt, n=5, style="pretty")
classIntervals(x_POSIXt, n=5, style="equal")
classIntervals(x_POSIXt, n=5, style="quantile")
classIntervals(x_POSIXt, n=5, style="kmeans")
classIntervals(x_POSIXt, n=5, style="fisher")
classIntervals(x_POSIXt, style="headtails")
classIntervals(x_POSIXt, style="maximum")
classIntervals(x_POSIXt, style="box")

## End(Not run)
# see vignette for further details
## Not run: 
# Head Tails method is suitable for right-sided heavy-tailed distributions
set.seed(1234)
# Heavy tails-----
# Pareto distributions a=7 b=14
paretodist &lt;- 7 / (1 - runif(100)) ^ (1 / 14)
# Lognorm
lognormdist &lt;- rlnorm(100)
# Weibull
weibulldist &lt;- rweibull(100, 1, scale = 5)

pal1 &lt;- c("wheat1", "red3")
opar &lt;- par(mfrow = c(1, 3))
plot(classIntervals(paretodist, style = "headtails"),
     pal = pal1,
     main = "HeadTails: Pareto Dist.")
plot(classIntervals(lognormdist, style = "headtails"),
     pal = pal1,
     main = "HeadTails: LogNormal Dist.")
plot(classIntervals(weibulldist, style = "headtails"),
     pal = pal1,
     main = "HeadTails: Weibull Dist.")
plot(classIntervals(paretodist, n = 5, style = "fisher"),
     pal = pal1,
     main = "Fisher: Pareto Dist.")
plot(classIntervals(lognormdist, n = 7, style = "fisher"),
     pal = pal1,
     main = "Fisher: LogNormal Dist.")
plot(classIntervals(weibulldist, n= 4, style = "fisher"),
     pal = pal1,
     main = "Fisher: Weibull Dist.")
par(opar)


#Non heavy tails, thr should be increased-----

#Normal dist
normdist &lt;- rnorm(100)
#Left-tailed truncated Normal distr
leftnorm &lt;- rep(normdist[normdist &lt; mean(normdist)], 2)
# Uniform distribution
unifdist &lt;- runif(100)
opar &lt;- par(mfrow = c(2, 3))
plot(classIntervals(normdist, style = "headtails"),
     pal = pal1,
     main = "Normal Dist.")
plot(classIntervals(leftnorm, style = "headtails"),
     pal = pal1,
     main = "Truncated Normal Dist.")
plot(classIntervals(unifdist, style = "headtails"),
     pal = pal1,
     main = "Uniform Dist.")
# thr should be increased for non heavy-tailed distributions
plot(
  classIntervals(normdist, style = "headtails", thr = .6),
  pal = pal1,
  main = "Normal Dist. thr = .6"
)
plot(
  classIntervals(leftnorm, style = "headtails", thr = .6),
  pal = pal1,
  main = "Truncated Normal Distribution thr = .6"
)
plot(
  classIntervals(unifdist, style = "headtails", thr = .6),
  pal = pal1,
  main = "Uniform Distribution thr = .6"
)
par(opar)

## End(Not run)
</code></pre>

<hr>
<h2 id='findColours'>assign colours to classes from classInterval object</h2><span id='topic+findColours'></span>

<h3>Description</h3>

<p>This helper function is a wrapper for <code>findCols</code> to extract classes from a &quot;classInterval&quot; object and assign colours from a palette created by <code>colorRampPalette</code> from the two or more colours given in the <code>pal</code> argument. It also returns two attributes for use in constructing a legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findColours(clI, pal, under="under", over="over", between="-", 
 digits = getOption("digits"), cutlabels=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findColours_+3A_cli">clI</code></td>
<td>
<p>a &quot;classIntervals&quot; object</p>
</td></tr>
<tr><td><code id="findColours_+3A_pal">pal</code></td>
<td>
<p>a character vector of at least two colour names; <code>colorRampPalette</code> is used internally to create the required number of colours</p>
</td></tr>
<tr><td><code id="findColours_+3A_under">under</code></td>
<td>
<p>character string value for &quot;under&quot; in legend if cutlabels=FALSE</p>
</td></tr>
<tr><td><code id="findColours_+3A_over">over</code></td>
<td>
<p>character string value for &quot;over&quot; in legend if cutlabels=FALSE</p>
</td></tr>
<tr><td><code id="findColours_+3A_between">between</code></td>
<td>
<p>character string value for &quot;between&quot; in legend if cutlabels=FALSE</p>
</td></tr>
<tr><td><code id="findColours_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits in legend</p>
</td></tr>
<tr><td><code id="findColours_+3A_cutlabels">cutlabels</code></td>
<td>
<p>use cut-style labels in legend</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of colours with attributes: &quot;table&quot;, a named frequency table; &quot;palette&quot;, a character vector of colours corresponding to the specified breaks.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand &lt;Roger.Bivand@nhh.no</p>


<h3>See Also</h3>

<p><code><a href="#topic+classIntervals">classIntervals</a></code>, <code><a href="base.html#topic+findInterval">findInterval</a></code>, <code><a href="#topic+findCols">findCols</a></code>, <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!require("spData", quietly=TRUE)) {
  message("spData package needed for examples")
  run &lt;- FALSE
} else {
  run &lt;- TRUE
}
if (run) {
data(jenks71, package="spData")
mypal &lt;- c("wheat1", "red3")
h5 &lt;- classIntervals(jenks71$jenks71, n=5, style="hclust", method="complete")
print(findColours(h5, mypal))
}
if (run) {
print(findColours(getHclustClassIntervals(h5, k=7), mypal))
}
if (run) {
h5Colours &lt;- findColours(h5, mypal)
plot(h5, mypal, main="Complete hierarchical clustering")
legend(c(95, 155), c(0.12, 0.4), fill=attr(h5Colours, "palette"),
 legend=names(attr(h5Colours, "table")), bg="white")
}
if (run) {
h5tab &lt;- attr(h5Colours, "table")
legtext &lt;- paste(names(h5tab), " (", h5tab, ")", sep="")
plot(h5, mypal, main="Complete hierarchical clustering (with counts)")
legend(c(95, 165), c(0.12, 0.4), fill=attr(h5Colours, "palette"),
 legend=legtext, bg="white")
}
</code></pre>

<hr>
<h2 id='findCols'>extract classes from classInterval object</h2><span id='topic+findCols'></span>

<h3>Description</h3>

<p>This helper function is a wrapper for <code>findInterval</code> to extract classes from a &quot;classInterval&quot; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCols(clI, factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findCols_+3A_cli">clI</code></td>
<td>
<p>a &quot;classIntervals&quot; object</p>
</td></tr>
<tr><td><code id="findCols_+3A_factor">factor</code></td>
<td>
<p>default &quot;FALSE&quot;, if &quot;TRUE&quot; returns cols as a factor with intervals as labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of class indices
</p>


<h3>Author(s)</h3>

<p>Roger Bivand &lt;Roger.Bivand@nhh.no&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+classIntervals">classIntervals</a></code>, <code><a href="base.html#topic+findInterval">findInterval</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>xvar &lt;- c(22361, 9573, 4836, 5309, 10384, 4359, 11016, 4414, 3327, 3408, 
  17816, 6909, 6936, 7990, 3758, 3569, 21965, 3605, 2181, 1892, 
  2459, 2934, 6399, 8578, 8537, 4840, 12132, 3734, 4372, 9073, 
  7508, 5203)
findCols(classIntervals(xvar, 5, "sd"), factor = FALSE)
findCols(classIntervals(xvar, 5, "sd"), factor = TRUE)
if (!require("spData", quietly=TRUE)) {
  message("spData package needed for examples")
  run &lt;- FALSE
} else {
  run &lt;- TRUE
}
if (run) {
data(jenks71, package="spData")
fix5 &lt;- classIntervals(jenks71$jenks71, n=5, style="fixed",
 fixedBreaks=c(15.57, 25, 50, 75, 100, 155.30))
print(fix5)
}
if (run) {
print(findCols(fix5))
print(findCols(fix5, factor = TRUE))
}
</code></pre>

<hr>
<h2 id='getBclustClassIntervals'>Change breaks in a &quot;classIntervals&quot; object</h2><span id='topic+getBclustClassIntervals'></span><span id='topic+getHclustClassIntervals'></span>

<h3>Description</h3>

<p>Because &quot;classIntervals&quot; objects of style &quot;hclust&quot; or &quot;bclust&quot; contain hierarchical classification trees in their &quot;par&quot; attribute, different numbers of classes can be chosen without repeating the initial classification. This function accesses the &quot;par&quot; attribute and modifies the &quot;brks&quot; member of the returned &quot;classIntervals&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBclustClassIntervals(clI, k)
getHclustClassIntervals(clI, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBclustClassIntervals_+3A_cli">clI</code></td>
<td>
<p>a &quot;classIntervals&quot; object</p>
</td></tr>
<tr><td><code id="getBclustClassIntervals_+3A_k">k</code></td>
<td>
<p>number of classes required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;classIntervals&quot; object with a &quot;modified&quot; attribute set
</p>


<h3>Author(s)</h3>

<p>Roger Bivand &lt;Roger.Bivand@nhh.no&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+classIntervals">classIntervals</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!require("spData", quietly=TRUE)) {
  message("spData package needed for examples")
  run &lt;- FALSE
} else {
  run &lt;- TRUE
}
if (run) {
data(jenks71, package="spData")
pal1 &lt;- c("wheat1", "red3")
opar &lt;- par(mfrow=c(2,2))
hCI5 &lt;- classIntervals(jenks71$jenks71, n=5, style="hclust", method="complete")
plot(attr(hCI5, "par"))
plot(hCI5, pal=pal1, main="hclust k=5")
plot(getHclustClassIntervals(hCI5, k=7), pal=pal1, main="hclust k=7")
plot(getHclustClassIntervals(hCI5, k=9), pal=pal1, main="hclust k=9")
par(opar)
}
if (run) {
set.seed(1)
bCI5 &lt;- classIntervals(jenks71$jenks71, n=5, style="bclust")
plot(attr(bCI5, "par"))
}
if (run) {
opar &lt;- par(mfrow=c(2,2))
plot(getBclustClassIntervals(bCI5, k=3), pal=pal1, main="bclust k=3")
plot(bCI5, pal=pal1, main="bclust k=5")
plot(getBclustClassIntervals(bCI5, k=7), pal=pal1, main="bclust k=7")
plot(getBclustClassIntervals(bCI5, k=9), pal=pal1, main="bclust k=9")
par(opar)
}
</code></pre>

<hr>
<h2 id='jenks.tests'>Indices for assessing class intervals</h2><span id='topic+jenks.tests'></span>

<h3>Description</h3>

<p>The function returns values of two indices for assessing class intervals: the goodness of variance fit measure, and the tabular accuracy index; optionally the overview accuracy index is also returned if the <code>area</code> argument is not missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jenks.tests(clI, area)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jenks.tests_+3A_cli">clI</code></td>
<td>
<p>a &quot;classIntervals&quot; object</p>
</td></tr>
<tr><td><code id="jenks.tests_+3A_area">area</code></td>
<td>
<p>an optional vector of object areas if the overview accuracy index is also required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goodness of variance fit measure is given by Armstrong et al. (2003, p. 600) as:
</p>
<p style="text-align: center;"><code class="reqn">GVF = 1 - \frac{\sum_{j=1}^{k}\sum_{i=1}^{N_j}{(z_{ij} - \bar{z}_j)}^2}{\sum_{i=1}^{N}{(z_{i} - \bar{z})}^2}</code>
</p>

<p>where the <code class="reqn">z_{i}, i=1,\ldots,N</code> are the observed values, <code class="reqn">k</code> is the number of classes, <code class="reqn">\bar{z}_j</code> the class mean for class <code class="reqn">j</code>, and <code class="reqn">N_j</code> the number of counties in class <code class="reqn">j</code>.
</p>
<p>The tabular accuracy index is given by Armstrong et al. (2003, p. 600) as:
</p>
<p style="text-align: center;"><code class="reqn">TAI = 1 - \frac{\sum_{j=1}^{k}\sum_{i=1}^{N_j}{|z_{ij} - \bar{z}_j|}}{\sum_{i=1}^{N}{|z_{i} - \bar{z}|}}</code>
</p>

<p>The overview accuracy index for polygon observations with known areas is given by Armstrong et al. (2003, p. 600) as:
</p>
<p style="text-align: center;"><code class="reqn">OAI = 1 - \frac{\sum_{j=1}^{k}\sum_{i=1}^{N_j}{|z_{ij} - \bar{z}_j| a_{ij}}}{\sum_{i=1}^{N}{|z_{i} - \bar{z}| a_i}}</code>
</p>

<p>where <code class="reqn">a_i, i=1,\ldots,N</code> are the polygon areas, and as above the <code class="reqn">a_{ij}</code> term is indexed over <code class="reqn">j=1,\ldots,k</code> classes, and <code class="reqn">i=1,\ldots,N_j</code> polygons in class <code class="reqn">j</code>.
</p>


<h3>Value</h3>

<p>a named vector of index values
</p>


<h3>Author(s)</h3>

<p>Roger Bivand &lt;Roger.Bivand@nhh.no&gt;</p>


<h3>References</h3>

<p>Armstrong, M. P., Xiao, N., Bennett, D. A., 2003. &quot;Using genetic algorithms to create multicriteria class intervals for choropleth maps&quot;. Annals, Association of American Geographers, 93 (3), 595&ndash;623; Jenks, G. F., Caspall, F. C., 1971. &quot;Error on choroplethic maps: definition, measurement, reduction&quot;. Annals, Association of American Geographers, 61 (2), 217&ndash;244</p>


<h3>See Also</h3>

<p><code><a href="#topic+classIntervals">classIntervals</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!require("spData", quietly=TRUE)) {
  message("spData package needed for examples")
  run &lt;- FALSE
} else {
  run &lt;- TRUE
}
if (run) {
data(jenks71, package="spData")
fix5 &lt;- classIntervals(jenks71$jenks71, n=5, style="fixed",
 fixedBreaks=c(15.57, 25, 50, 75, 100, 155.30))
print(jenks.tests(fix5, jenks71$area))
}
if (run) {
q5 &lt;- classIntervals(jenks71$jenks71, n=5, style="quantile")
print(jenks.tests(q5, jenks71$area))
}
if (run) {
set.seed(1)
k5 &lt;- classIntervals(jenks71$jenks71, n=5, style="kmeans")
print(jenks.tests(k5, jenks71$area))
}
if (run) {
h5 &lt;- classIntervals(jenks71$jenks71, n=5, style="hclust", method="complete")
print(jenks.tests(h5, jenks71$area))
}
if (run) {
print(jenks.tests(getHclustClassIntervals(h5, k=7), jenks71$area))
}
if (run) {
print(jenks.tests(getHclustClassIntervals(h5, k=9), jenks71$area))
}
if (run) {
set.seed(1)
b5 &lt;- classIntervals(jenks71$jenks71, n=5, style="bclust")
print(jenks.tests(b5, jenks71$area))
}
if (run) {
print(jenks.tests(getBclustClassIntervals(b5, k=7), jenks71$area))
}
if (run) {
print(jenks.tests(getBclustClassIntervals(b5, k=9), jenks71$area))
}
</code></pre>

<hr>
<h2 id='logLik.classIntervals'>Log-likelihood for classIntervals objects</h2><span id='topic+logLik.classIntervals'></span>

<h3>Description</h3>

<p>Log-likelihood for classIntervals objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classIntervals'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.classIntervals_+3A_object">object</code></td>
<td>
<p>A classIntervals object</p>
</td></tr>
<tr><td><code id="logLik.classIntervals_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, the likelihood is a method for minimizing the standard deviation
within an interval, and with the AIC, a per-interval penalty can be used to
maximize the information and self-similarity of data in the interval.
</p>
<p>Based on Birge 2006 and Davies 2009 (see references), interval binning
selections may be compared by likelihood to optimize the number of intervals
selected for a set of data.  The 'logLik()' function (and associated 'AIC()'
function) can be used to optimize binning by maximizing the likelihood across
choices of intervals.
</p>
<p>As illustrated by the examples below (the AIC comparison does not
specifically select 3 intervals when comparing 2, 3, and 4 intervals for data
with 3 intervals), while likelihood-based methods can provide evidence toward
optimization of binning, they are not infallible for bin selection.
</p>


<h3>Value</h3>

<p>A 'logLik' object (see 'stats::logLik').
</p>


<h3>References</h3>

<p>Lucien Birge, Yves Rozenholc.  How many bins should be put in a regular
histogram.  ESAIM: Probability and Statistics. 31 January 2006. 10:24-45.
url: https://www.esaim-ps.org/articles/ps/abs/2006/01/ps0322/ps0322.html.
doi:10.1051/ps:2006001
</p>
<p>Laurie Davies, Ursula Gather, Dan Nordman, Henrike Weinert. A comparison of
automatic histogram constructions. ESAIM: Probability and Statistics. 	11
June 2009.  13:181-196. url:
https://www.esaim-ps.org/articles/ps/abs/2009/01/ps0721/ps0721.html
doi:10.1051/ps:2008005
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- classIntervals(rnorm(100), n=5, style="fisher")
logLik(x)
AIC(x) # By having a logLik method, AIC.default is used.

# When the intervals are made of a limited number of discrete values, the
# logLik is zero by definition (the standard deviation is zero giving a dirac
# function at the discrete value indicating a density of 1 and a log-density
# of zero).
x &lt;- classIntervals(rep(1:2, each=10), n=2, style="jenks")
logLik(x)
x &lt;- classIntervals(rep(1:3, each=10), n=2, style="jenks")
logLik(x)

# With slight jitter but notable categorical intervals (at 1, 2, and 3), the
# AIC will make selection of the optimal intervals easier.
data &lt;- rep(1:3, each=100) + runif(n=300, min=-0.01, max=0.01)
x_2 &lt;- classIntervals(data, n=2, style="jenks")
x_3 &lt;- classIntervals(data, n=3, style="jenks")
x_4 &lt;- classIntervals(data, n=4, style="jenks")
AIC(x_2, x_3, x_4)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
