<!DOCTYPE html><html lang="en"><head><title>Help for package lmls</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lmls}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abdom'><p>Abdominal circumference data</p></a></li>
<li><a href='#boot'><p>Parametric bootstrap for LMLS</p></a></li>
<li><a href='#lmls'><p>Gaussian location-scale regression</p></a></li>
<li><a href='#lmls-methods'><p>Methods for LMLS</p></a></li>
<li><a href='#mcmc'><p>MCMC inference for LMLS</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#summary.lmls'><p>Summary for LMLS</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Gaussian Location-Scale Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The Gaussian location-scale regression model is a multi-predictor
    model with explanatory variables for the mean (= location) and the standard
    deviation (= scale) of a response variable. This package implements maximum
    likelihood and Markov chain Monte Carlo (MCMC) inference (using algorithms
    from Girolami and Calderhead (2011) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2010.00765.x">doi:10.1111/j.1467-9868.2010.00765.x</a>&gt;
    and Nesterov (2009) &lt;<a href="https://doi.org/10.1007%2Fs10107-007-0149-x">doi:10.1007/s10107-007-0149-x</a>&gt;), a parametric
    bootstrap algorithm, and diagnostic plots for the model class.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hriebl.github.io/lmls/">https://hriebl.github.io/lmls/</a>, <a href="https://github.com/hriebl/lmls">https://github.com/hriebl/lmls</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hriebl/lmls/issues">https://github.com/hriebl/lmls/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>generics (&ge; 0.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, coda, covr, ggplot2, knitr, mgcv, mvtnorm,
numDeriv, patchwork, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-20 18:46:55 UTC; hannes</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannes Riebl [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hannes Riebl &lt;hriebl@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-20 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abdom'>Abdominal circumference data</h2><span id='topic+abdom'></span>

<h3>Description</h3>

<p>The <code>abdom</code> data frame has 610 rows and 2 columns. The data are
measurements of abdominal circumference (response variable) taken from
fetuses during ultrasound scans at Kings College Hospital, London, at
gestational ages (explanatory variable) ranging between 12 and 42 weeks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(abdom)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>y</dt><dd><p>Abdominal circumference: a numeric vector.</p>
</dd>
<dt>x</dt><dd><p>Gestational age: a numeric vector.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were used to derive reference intervals by Chitty <em>et al.</em>
(1994) and also for comparing different reference centile methods by
Wright and Royston (1997), who also commented that the distribution of
z-scores obtained from the different fitted models &quot;has somewhat longer
tails than the normal distribution&quot;.
</p>


<h3>Source</h3>

<p>Dr. Eileen M. Wright, Department of Medical Statistics and Evaluation,
Royal Postgraduate Medical School, Du Cane Road, London, W12 0NN.
</p>
<p>The <code>abdom</code> dataset was copied into the <code>lmls</code> package from the
<code>gamlss.data</code> package. <code>gamlss.data</code> is licensed under the GPL 2 and 3.
</p>


<h3>References</h3>

<p>Chitty, L.S., Altman, D.G., Henderson, A. and Campbell, S. (1994). Charts
of fetal size: 3, abdominal measurement. <em>Br. J. Obstet. Gynaec.</em>,
<strong>101</strong>: 125–131.
</p>
<p>Wright, E.M. and Royston, P. (1997). A comparison of statistical
methods for age-related reference intervals. <em>J. R. Statist. Soc. A.</em>,
<strong>160</strong>: 47–69.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abdom)
attach(abdom)
plot(x, y)
detach(abdom)
</code></pre>

<hr>
<h2 id='boot'>Parametric bootstrap for LMLS</h2><span id='topic+boot'></span>

<h3>Description</h3>

<p>A simple parametric bootstrap algorithm for location-scale regression models
from the <code><a href="#topic+lmls">lmls()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot(m, num_samples = 1000, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot_+3A_m">m</code></td>
<td>
<p>A location-scale regression model from the <code><a href="#topic+lmls">lmls()</a></code> function.</p>
</td></tr>
<tr><td><code id="boot_+3A_num_samples">num_samples</code></td>
<td>
<p>The number of bootstrap samples to draw.</p>
</td></tr>
<tr><td><code id="boot_+3A_seed">seed</code></td>
<td>
<p>Either <code>NULL</code> or an integer that will be used in a call to
<code><a href="base.html#topic+set.seed">set.seed()</a></code> before simulating the response vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>lmls</code> S3 object, see <code><a href="#topic+lmls">lmls()</a></code>. The entry <code>boot</code> with the matrices of
bootstrap samples is added to the object as a list with the names <code>location</code>
and <code>scale</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lmls)
m &lt;- lmls(y ~ poly(x, 2), ~ x, data = abdom, light = FALSE)
m &lt;- boot(m)
summary(m, type = "boot")
hist(m$boot$scale[, 2])
</code></pre>

<hr>
<h2 id='lmls'>Gaussian location-scale regression</h2><span id='topic+lmls'></span>

<h3>Description</h3>

<p>The location-scale regression model assumes a normally distributed response
variable with one linear predictor for the mean (= the location) and one for
the standard deviation (= the scale). The standard deviation is mapped to
the linear predictor through a log link.
</p>
<p>This function sets up the model object and estimates it with maximum
likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmls(
  location,
  scale = ~1,
  data = environment(location),
  light = TRUE,
  maxit = 100,
  reltol = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmls_+3A_location">location</code></td>
<td>
<p>A two-sided formula with the response variable on the LHS
and the predictor for the mean on the RHS.</p>
</td></tr>
<tr><td><code id="lmls_+3A_scale">scale</code></td>
<td>
<p>A one-sided formula with the predictor for the standard
deviation on the RHS.</p>
</td></tr>
<tr><td><code id="lmls_+3A_data">data</code></td>
<td>
<p>A data frame (or list or environment) in which to evaluate
the <code>location</code> and <code>scale</code> formulas.</p>
</td></tr>
<tr><td><code id="lmls_+3A_light">light</code></td>
<td>
<p>If <code>TRUE</code>, the design matrices are removed from the estimated
model to save some memory.</p>
</td></tr>
<tr><td><code id="lmls_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations of the Fisher scoring
algorithm.</p>
</td></tr>
<tr><td><code id="lmls_+3A_reltol">reltol</code></td>
<td>
<p>The relative convergence tolerance of the Fisher scoring
algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted linear model for location and scale as an <code>lmls</code> S3 object.
The object has at least the following entries:
</p>

<ul>
<li> <p><code>y</code>: the response vector
</p>
</li>
<li> <p><code>nobs</code>: the number of observations
</p>
</li>
<li> <p><code>df</code>: the degrees of freedom
</p>
</li>
<li> <p><code>df.residual</code>: the residual degrees of freedom
</p>
</li>
<li> <p><code>coefficients</code>: the regression coefficients as a list with the names
<code>location</code> and <code>scale</code>
</p>
</li>
<li> <p><code>fitted.values</code>: the fitted values as a list with the names <code>location</code>
and <code>scale</code>
</p>
</li>
<li> <p><code>residuals</code>: the response residuals
</p>
</li>
<li> <p><code>coefficients</code>: the variance-covariance matrices of the regression
coefficients as a list with the names <code>location</code> and <code>scale</code>
</p>
</li>
<li> <p><code>iterations</code>: the number of iterations the Fisher scoring algorithm
took to converge
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(lmls)
m &lt;- lmls(y ~ poly(x, 2), ~ x, data = abdom)
summary(m)
plot(m)
qqnorm(m)
</code></pre>

<hr>
<h2 id='lmls-methods'>Methods for LMLS</h2><span id='topic+lmls-methods'></span><span id='topic+coef.lmls'></span><span id='topic+fitted.lmls'></span><span id='topic+predict.lmls'></span><span id='topic+residuals.lmls'></span><span id='topic+vcov.lmls'></span>

<h3>Description</h3>

<p>A couple of methods for location-scale regression models from the <code><a href="#topic+lmls">lmls()</a></code>
function are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmls'
coef(object, predictor = c("location", "scale"), ...)

## S3 method for class 'lmls'
fitted(object, predictor = c("location", "scale"), ...)

## S3 method for class 'lmls'
predict(
  object,
  newdata = NULL,
  predictor = c("location", "scale"),
  type = c("link", "response"),
  ...
)

## S3 method for class 'lmls'
residuals(object, type = c("deviance", "pearson", "response"), ...)

## S3 method for class 'lmls'
vcov(object, predictor = c("location", "scale"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmls-methods_+3A_object">object</code></td>
<td>
<p>A location-scale regression model from the <code><a href="#topic+lmls">lmls()</a></code> function.</p>
</td></tr>
<tr><td><code id="lmls-methods_+3A_predictor">predictor</code></td>
<td>
<p>The predictor to work on. Either <code>"location"</code> or <code>"scale"</code>
or both. If both, a list with the names <code>"location"</code> and
<code>"scale"</code> is returned.</p>
</td></tr>
<tr><td><code id="lmls-methods_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="lmls-methods_+3A_newdata">newdata</code></td>
<td>
<p>A data frame (or list or environment) with the covariate
values at which the predictions are computed. If <code>NULL</code>, the
predictions at the original data are returned.</p>
</td></tr>
<tr><td><code id="lmls-methods_+3A_type">type</code></td>
<td>
<p>Used by <code>predict()</code> and <code>residuals()</code>:
</p>

<ul>
<li><p> For <code>predict()</code>, <code>"link"</code> or <code>"response"</code>. If <code>"link"</code>
(default), <code class="reqn">\mu</code> and log(<code class="reqn">\sigma</code>) are returned.
If <code>"response"</code>, <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
are returned.
</p>
</li>
<li><p> For <code>residuals()</code>, <code>"deviance"</code>, <code>"pearson"</code> or
<code>"response"</code>. If <code>"deviance"</code> (default) or <code>"pearson"</code>,
(<code class="reqn">y - \mu</code>) / <code class="reqn">\sigma</code> is returned.
If <code>"response"</code>, <code class="reqn">y - \mu</code> is returned.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector for <code>residuals()</code>. For the other methods, a numeric vector
if the argument <code>predictor</code> is either <code>"location"</code> or <code>"scale"</code>, or a list
with the names <code>location</code> and <code>scale</code> if it is both.
</p>

<hr>
<h2 id='mcmc'>MCMC inference for LMLS</h2><span id='topic+mcmc'></span>

<h3>Description</h3>

<p>A Markov chain Monte Carlo (MCMC) sampler for location-scale regression
models from the <code><a href="#topic+lmls">lmls()</a></code> function. The sampler uses Gibbs updates for the
location coefficients and the Riemann manifold Metropolis-adjusted Langevin
algorithm (MMALA) from Girolami and Calderhead (2011) with the Fisher-Rao
metric tensor for the scale coefficients. The priors for the regression
coefficients are assumed to be flat.
</p>
<p>To find the optimal step size for the MMALA updates, the dual averaging
algorithm from Nesterov (2009) is used during a warm-up phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc(m, num_samples = 1000, num_warmup = 1000, target_accept = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc_+3A_m">m</code></td>
<td>
<p>A location-scale regression model from the <code><a href="#topic+lmls">lmls()</a></code> function.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_num_samples">num_samples</code></td>
<td>
<p>The number of MCMC samples after the warm-up.
Defaults to 1000.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_num_warmup">num_warmup</code></td>
<td>
<p>The number of MCMC samples for the warm-up.
Defaults to 1000.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_target_accept">target_accept</code></td>
<td>
<p>The target acceptance rate for the dual averaging
algorithm used for the warm-up. Defaults to 0.8.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>lmls</code> S3 object, see <code><a href="#topic+lmls">lmls()</a></code>. The entry <code>mcmc</code> with the matrices
of MCMC samples is added to the object as a list with the names <code>location</code>
and <code>scale</code>.
</p>


<h3>References</h3>

<p>Girolami, M. and Calderhead, B. (2011), Riemann manifold Langevin and
Hamiltonian Monte Carlo methods. Journal of the Royal Statistical Society:
Series B (Statistical Methodology), 73: 123-214.
<a href="https://doi.org/10.1111/j.1467-9868.2010.00765.x">doi:10.1111/j.1467-9868.2010.00765.x</a>
</p>
<p>Nesterov, Y. (2009), Primal-dual subgradient methods for convex problems.
Mathematical Programming, 120: 221–259. <a href="https://doi.org/10.1007/s10107-007-0149-x">doi:10.1007/s10107-007-0149-x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lmls)
m &lt;- lmls(y ~ poly(x, 2), ~ x, data = abdom, light = FALSE)
m &lt;- mcmc(m)
summary(m, type = "mcmc")
plot(m$mcmc$scale[, 2], type = "l")
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='summary.lmls'>Summary for LMLS</h2><span id='topic+summary.lmls'></span>

<h3>Description</h3>

<p>Prints a summary for location-scale regression models from the <code><a href="#topic+lmls">lmls()</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmls'
summary(
  object,
  type = c("ml", "boot", "mcmc"),
  digits = max(3, getOption("digits") - 3),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lmls_+3A_object">object</code></td>
<td>
<p>A location-scale regression model from the <code><a href="#topic+lmls">lmls()</a></code> function.</p>
</td></tr>
<tr><td><code id="summary.lmls_+3A_type">type</code></td>
<td>
<p>Either <code>"ml"</code> or <code>"boot"</code> or <code>"mcmc"</code>:
</p>

<ul>
<li><p> If <code>"ml"</code>, the maximum likelihood estimates and the
asymptotic standard errors are shown.
</p>
</li>
<li><p> If <code>"boot"</code>, the bootstrap estimates and confidence
intervals are shown.
</p>
</li>
<li><p> If <code>"mcmc"</code>, the Markov chain Monte Carlo (MCMC)
estimates and credible intervals are shown.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary.lmls_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print.</p>
</td></tr>
<tr><td><code id="summary.lmls_+3A_...">...</code></td>
<td>
<p>Passed on to <code><a href="stats.html#topic+printCoefmat">printCoefmat()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (unmodified and invisible) <code>lmls</code> S3 object, see <code><a href="#topic+lmls">lmls()</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
