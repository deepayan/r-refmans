<!DOCTYPE html><html><head><title>Help for package Rogue</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rogue}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rogue-package'><p>Rogue</p></a></li>
<li><a href='#GraphGeodesic'><p>Graph Geodesic between leaves of unweighted tree</p></a></li>
<li><a href='#RogueTaxa'><p>Drop rogue taxa to generate a more informative consensus</p></a></li>
<li><a href='#TipInstability'><p>Tip instability</p></a></li>
<li><a href='#TipVolatility'><p>Detect rogue taxa using phylogenetic information distance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Identify Rogue Taxa in Sets of Phylogenetic Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.6</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Rogue ("wildcard") taxa are leaves with uncertain phylogenetic
  position.
  Their position may vary from tree to tree under inference methods that yield a
  tree set (e.g. bootstrapping, Bayesian tree searches, maximum parsimony).
  The presence of rogue taxa in a tree set can potentially remove all
  information from a consensus tree. The information content of a consensus
  tree - a function of its resolution and branch support values - can often be
  increased by removing rogue taxa. 
  'Rogue' provides an explicitly information-theoretic approach to rogue
  detection (Smith 2022) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyab099">doi:10.1093/sysbio/syab099</a>&gt;,
  and an interface to 'RogueNaRok' (Aberer et al. 2013)
  &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsys078">doi:10.1093/sysbio/sys078</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ms609/Rogue/">https://github.com/ms609/Rogue/</a>,
<a href="https://github.com/aberer/RogueNaRok/">https://github.com/aberer/RogueNaRok/</a>,
<a href="https://github.com/ms609/RogueNaRok/">https://github.com/ms609/RogueNaRok/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ms609/Rogue/issues/">https://github.com/ms609/Rogue/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 5.0), cli (&ge; 3.0), fastmatch, grDevices, matrixStats,
Rdpack (&ge; 0.7), Rfast, stats, TreeDist (&gt; 2.2.0), TreeTools
(&ge; 1.9.1.9003), utils,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, PlotTools, rmarkdown, spelling, testthat,</td>
</tr>
<tr>
<td>Config/Needs/github-actions:</td>
<td>callr, pkgbuild, rcmdcheck,</td>
</tr>
<tr>
<td>Config/Needs/coverage:</td>
<td>covr</td>
</tr>
<tr>
<td>Config/Needs/memcheck:</td>
<td>devtools</td>
</tr>
<tr>
<td>Config/Needs/metadata:</td>
<td>codemetar</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>pkgdown</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C99</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 09:49:02 UTC; pjjg18</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin R. Smith <a href="https://orcid.org/0000-0001-5660-1727"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Andre J. Aberer [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin R. Smith &lt;martin.smith@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rogue-package'>Rogue</h2><span id='topic+Rogue'></span><span id='topic+Rogue-package'></span>

<h3>Description</h3>

<p>&quot;Rogue&quot; implements approaches to identify rogue taxa in phylogenetic
analysis.
Rogues are wildcard leaves whose uncertain position, perhaps a result of
missing or conflicting data, reduces the resolution of consensus trees
(Kearney 2002).
Consensus trees that omit rogue taxa can be more informative.
</p>


<h3>Details</h3>

<p>&quot;Rogue&quot; allows the user to select a concept of &quot;information&quot; by which the
quality of consensus trees should be evaluated, and a heuristic approach
by which rogue taxa should be identified.
</p>
<p>Rogue detection using the phylogenetic and clustering information content
measures (<abbr><span class="acronym">SPIC</span></abbr>, <abbr><span class="acronym">SCIC</span></abbr>) (Smith 2022)
is implemented using a quick heuristic that drops
the least &quot;stable&quot; leaves one at a time,
using an <em>ad hoc</em> definition of stability (Smith 2022);
and by a more exhaustive (and time-consuming) approach that considers
dropping all possible sets of up to <em>n</em> leaves
(Aberer et al. 2013).
</p>
<p>The latter heuristic is implemented for the relative bipartition
&quot;information&quot; content and Pattengale's criterion
<em>via</em> <a href="https://rnr.h-its.org/about">RogueNaRok</a> (Aberer et al. 2013).
</p>


<h4>Citing &quot;Rogue&quot;</h4>

<p>If you find this package useful in your work, Please consider citing
Smith (2021).
</p>
<p>To cite the underlying methods, please cite
Aberer et al. (2013) (&quot;RogueNaRok&quot;)
or Smith (2022) (SPIC, SCIC), as appropriate.
</p>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin R. Smith <a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a> (<a href="https://orcid.org/0000-0001-5660-1727">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Andre J. Aberer <a href="mailto:andre.aberer@googlemail.com">andre.aberer@googlemail.com</a> [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>Aberer AJ, Krompass D, Stamatakis A (2013).
&ldquo;Pruning rogue taxa improves phylogenetic accuracy: an efficient algorithm and webservice.&rdquo;
<em>Systematic Biology</em>, <b>62</b>(1), 162&ndash;166.
<a href="https://doi.org/10.1093/sysbio/sys078">doi:10.1093/sysbio/sys078</a>.<br /><br /> Kearney M (2002).
&ldquo;Fragmentary taxa, missing data, and ambiguity: mistaken assumptions and conclusions.&rdquo;
<em>Systematic Biology</em>, <b>51</b>(2), 369&ndash;381.
<a href="https://doi.org/10.1080/10635150252899824">doi:10.1080/10635150252899824</a>.<br /><br /> Smith MR (2022).
&ldquo;Using information theory to detect rogue taxa and improve consensus trees.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(5), 986&ndash;1008.
<a href="https://doi.org/10.1093/sysbio/syab099">doi:10.1093/sysbio/syab099</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ms609/Rogue/">https://github.com/ms609/Rogue/</a>
</p>
</li>
<li> <p><a href="https://github.com/aberer/RogueNaRok/">https://github.com/aberer/RogueNaRok/</a>
</p>
</li>
<li> <p><a href="https://github.com/ms609/RogueNaRok/">https://github.com/ms609/RogueNaRok/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ms609/Rogue/issues/">https://github.com/ms609/Rogue/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='GraphGeodesic'>Graph Geodesic between leaves of unweighted tree</h2><span id='topic+GraphGeodesic'></span><span id='topic+Cophenetic'></span>

<h3>Description</h3>

<p>Graph Geodesic between leaves of unweighted tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GraphGeodesic(x, nTip = length(x$tip.label), log = FALSE, asMatrix = TRUE)

Cophenetic(x, nTip = length(x$tip.label), log = FALSE, asMatrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GraphGeodesic_+3A_x">x</code></td>
<td>
<p>Object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="GraphGeodesic_+3A_ntip">nTip</code></td>
<td>
<p>Integer specifying number of leaves.</p>
</td></tr>
<tr><td><code id="GraphGeodesic_+3A_asmatrix">asMatrix</code></td>
<td>
<p>Logical specifying whether to coerce output to matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>GraphGeodesic()</code> returns an unnamed integer matrix describing the
number of edges between each pair of edges.
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith, modifying algorithm by Emmanuel Paradis
in <code>ape::dist.nodes()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GraphGeodesic(TreeTools::BalancedTree(5))
</code></pre>

<hr>
<h2 id='RogueTaxa'>Drop rogue taxa to generate a more informative consensus</h2><span id='topic+RogueTaxa'></span><span id='topic+QuickRogue'></span><span id='topic+C_RogueNaRok'></span>

<h3>Description</h3>

<p><code>RogueTaxa()</code> finds wildcard leaves whose removal increases the resolution
or branch support values of a consensus tree, using the relative
bipartition, shared phylogenetic, or mutual clustering concepts of
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RogueTaxa(
  trees,
  info = c("spic", "scic", "fspic", "fscic", "rbic"),
  return = c("taxa", "tree"),
  bestTree = NULL,
  computeSupport = TRUE,
  dropsetSize = 1,
  neverDrop = character(0),
  labelPenalty = 0,
  mreOptimization = FALSE,
  threshold = 50,
  verbose = FALSE
)

QuickRogue(
  trees,
  info = "phylogenetic",
  p = 0.5,
  log = TRUE,
  average = "median",
  deviation = "mad",
  neverDrop,
  fullSeq = FALSE,
  parallel = FALSE
)

C_RogueNaRok(
  bootTrees = "",
  runId = "tmp",
  treeFile = "",
  computeSupport = TRUE,
  dropsetSize = 1,
  excludeFile = "",
  workDir = "",
  labelPenalty = 0,
  mreOptimization = FALSE,
  threshold = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RogueTaxa_+3A_trees">trees</code></td>
<td>
<p>List of trees to analyse.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_info">info</code></td>
<td>
<p>Concept of information to employ; see details.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_return">return</code></td>
<td>
<p>If <code>taxa</code>, returns the leaves identified as rogues; if <code>tree</code>,
return a consensus tree omitting rogue taxa.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_computesupport">computeSupport</code></td>
<td>
<p>Logical: If <code>FALSE</code>, then instead of trying to maximize
the support in the consensus tree, RogueNaRok will try to maximize the number
of bipartitions in the final tree by pruning taxa.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_dropsetsize">dropsetSize</code></td>
<td>
<p>Integer specifying maximum size of dropset per iteration.
If <code>dropsetSize == n</code>, then RogueNaRok will test in each iteration which
tuple of <code>n</code> taxa increases the optimality criterion the most, pruning
taxa accordingly.
This improves the result, but run times will increase at least linearly.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_neverdrop">neverDrop</code></td>
<td>
<p>Tip labels that should not be dropped from the consensus.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_labelpenalty">labelPenalty</code></td>
<td>
<p>A weight factor to penalize for dropset size when
<code>info = "rbic"</code>.
The higher the value, the more conservative the algorithm is in pruning taxa.
The default value of <code>0</code> gives the <abbr><span class="acronym">RBIC</span></abbr>; <code>1</code> gives Pattengale's
criterion.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_threshold">threshold</code>, <code id="RogueTaxa_+3A_mreoptimization">mreOptimization</code></td>
<td>
<p>A threshold or mode for the consensus tree
that is optimized. Specify a value between 50 (majority rule consensus,
the default) and 100 (strict consensus), or set <code>mreOptimization = TRUE</code>
for the extended majority rule consensus.
Note that rogue taxa identified with respect to different thresholds can
vary substantially.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_verbose">verbose</code></td>
<td>
<p>Logical specifying whether to display output from RogueNaRok.
If <code>FALSE</code>, output will be included as an attribute of the return value.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_p">p</code></td>
<td>
<p>Proportion of trees that must contain a split before it is included
in the consensus under consideration.  0.5, the default, corresponds to a
majority rule tree; 1.0 will maximize the information content of the
strict consensus.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_log">log</code></td>
<td>
<p>Logical specifying whether to log-transform distances when
calculating leaf stability.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_average">average</code></td>
<td>
<p>Character specifying whether to use <code>"mean"</code> or <code>"median"</code>
tip distances to calculate leaf stability.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_deviation">deviation</code></td>
<td>
<p>Character specifying whether to use <code>"sd"</code> or <code>"mad"</code> to
calculate leaf stability.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_fullseq">fullSeq</code></td>
<td>
<p>Logical specifying whether to list all taxa (<code>TRUE</code>), or
only those that improve information content when all are dropped (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_parallel">parallel</code></td>
<td>
<p>Logical specifying whether parallel execution should take
place in C++.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_boottrees">bootTrees</code></td>
<td>
<p>Path to a file containing a collection of bootstrap trees.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_runid">runId</code></td>
<td>
<p>An identifier for this run, appended to output files.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_treefile">treeFile</code>, <code id="RogueTaxa_+3A_besttree">bestTree</code></td>
<td>
<p>If a single best-known tree (such as an ML or MP tree)
is provided, RogueNaRok optimizes the bootstrap support in this
best-known tree (still drawn from the bootstrap trees);
the <code>threshold</code> parameter is ignored.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_excludefile">excludeFile</code></td>
<td>
<p>Taxa in this file (one taxon per line) will not be
considered for pruning.</p>
</td></tr>
<tr><td><code id="RogueTaxa_+3A_workdir">workDir</code></td>
<td>
<p>Path to a working directory where output files are created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;Rogue&quot; or (loosely) &quot;wildcard&quot; taxa (Nixon and Wheeler 1992) are
leaves whose position in a tree is poorly constrained, typically because
much of the phylogenetic data associated with the taxon is either missing or
in conflict with other data (Kearney 2002).
</p>
<p>These functions use heuristic methods to identify rogue taxa whose removal
improves the information content of a consensus tree, by the definitions
of information discussed below.
</p>


<h3>Value</h3>

<p><code>RogueTaxa()</code> returns a <code>data.frame</code>. Each row after the first,
which describes the starting tree, describes a dropset operation.
Columns describe:
</p>

<ul>
<li> <p><code>num</code>: Sequential index of the drop operation
</p>
</li>
<li> <p><code>taxNum</code>: Numeric identifier of the dropped leaves
</p>
</li>
<li> <p><code>taxon</code>: Text identifier of dropped leaves
</p>
</li>
<li> <p><code>rawImprovement</code>: Improvement in score obtained by this operation
</p>
</li>
<li> <p><code>IC</code>: Information content of tree after dropping all leaves so far,
by the measure indicated by <code>info</code>.
</p>
</li></ul>

<p><code>C_RogueNaRok()</code> returns <code>0</code> if successful; <code>-1</code> on error.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>QuickRogue()</code>: Shortcut to &quot;fast&quot; heuristic, with option to return
evaluation of all taxa using <code>fullSeq = TRUE</code>.
</p>
</li></ul>


<h3>Information criteria</h3>

<p>The splitwise phylogenetic information content measure produces the best
results (Smith 2022).
It uses the splitwise information content as a shortcut, which involves
double counting of some information (which may or may not be desirable).
The same holds for the mutual clustering information measure; this measure
is less obviously suited to the detection of rogues.
This measure interprets split frequency as a proxy for the probability
that a split is true, which is a valid interpretation of a Bayesian posterior
sample (Holder et al. 2008),
a reasonable but imperfect interpretation of a bootstrap sample
(Berry and Gascuel 1996), and a bad interpretation of a sample of
most parsimonious trees.
</p>
<p>The &quot;relative bipartition information criterion&quot; (<abbr><span class="acronym">RBIC</span></abbr>) is
the sum of all support values divided by the maximum possible support in a
fully bifurcating tree with the initial set of taxa.
The relative bipartition information content approach employs the
'RogueNaRok' implementation (Aberer et al. 2013), which can handle
large trees relatively quickly.
The <abbr><span class="acronym">RBIC</span></abbr> is is not strictly a measure of information and can
produce undesirable results (Wilkinson and Crotti 2017).
</p>
<p><code>C_RogueNaRok()</code> directly interfaces the 'RogueNaRok' C implementation,
with no input checking; be aware that invalid input will cause undefined
behaviour and is likely to crash R.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>), linking to
<a href="https://github.com/aberer/RogueNaRok/">RogueNaRok</a>
C library by Andre Aberer (&lt;andre.aberer at googlemail.com&gt;)
</p>


<h3>References</h3>

<p>Aberer AJ, Krompass D, Stamatakis A (2013).
&ldquo;Pruning rogue taxa improves phylogenetic accuracy: an efficient algorithm and webservice.&rdquo;
<em>Systematic Biology</em>, <b>62</b>(1), 162&ndash;166.
<a href="https://doi.org/10.1093/sysbio/sys078">doi:10.1093/sysbio/sys078</a>.<br /><br /> Berry V, Gascuel O (1996).
&ldquo;On the interpretation of bootstrap trees: appropriate threshold of clade selection and induced gain.&rdquo;
<em>Molecular Biology and Evolution</em>, <b>13</b>(7), 999&ndash;1011.
<a href="https://doi.org/10.1093/molbev/13.7.999">doi:10.1093/molbev/13.7.999</a>.<br /><br /> Holder MT, Sukumaran J, Lewis PO (2008).
&ldquo;A justification for reporting the majority-rule consensus tree in Bayesian phylogenetics.&rdquo;
<em>Systematic Biology</em>, <b>57</b>(5), 814&ndash;821.
<a href="https://doi.org/10.1080/10635150802422308">doi:10.1080/10635150802422308</a>.<br /><br /> Kearney M (2002).
&ldquo;Fragmentary taxa, missing data, and ambiguity: mistaken assumptions and conclusions.&rdquo;
<em>Systematic Biology</em>, <b>51</b>(2), 369&ndash;381.
<a href="https://doi.org/10.1080/10635150252899824">doi:10.1080/10635150252899824</a>.<br /><br /> Nixon KC, Wheeler QD (1992).
&ldquo;Extinction and the origin of species.&rdquo;
In Novacek MJ, Wheeler QD (eds.), <em>Extinction and phylogeny</em>, chapter Extinction and the origin of species, 119-143.
Columbia University Press, New York.<br /><br /> Smith MR (2022).
&ldquo;Using information theory to detect rogue taxa and improve consensus trees.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(5), 986&ndash;1008.
<a href="https://doi.org/10.1093/sysbio/syab099">doi:10.1093/sysbio/syab099</a>.<br /><br /> Wilkinson M, Crotti M (2017).
&ldquo;Comments on detecting rogue taxa using RogueNaRok.&rdquo;
<em>Systematics and Biodiversity</em>, <b>15</b>(4), 291&ndash;295.
<a href="https://doi.org/10.1080/14772000.2016.1252440">doi:10.1080/14772000.2016.1252440</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", warn.conflicts = FALSE)

trees &lt;- list(read.tree(text = ("(a, (b, (c, (d, (e, (X1, X2))))));")),
              read.tree(text = ("((a, (X1, X2)), (b, (c, (d, e))));")))
RogueTaxa(trees, dropsetSize = 2)

trees &lt;- list(
     read.tree(text = "((a, y), (b, (c, (z, ((d, e), (f, (g, x)))))));"),
     read.tree(text = "(a, (b, (c, (z, (((d, y), e), (f, (g, x)))))));"),
     read.tree(text = "(a, (b, ((c, z), ((d, (e, y)), ((f, x), g)))));"),
     read.tree(text = "(a, (b, ((c, z), ((d, (e, x)), (f, (g, y))))));"),
     read.tree(text = "(a, ((b, x), ((c, z), ((d, e), (f, (g, y))))));")
     )
cons &lt;- consensus(trees, p = 0.5)
plot(cons)
LabelSplits(cons, SplitFrequency(cons, trees) / length(trees))
reduced &lt;- RogueTaxa(trees, info = "phylogenetic", ret = "tree")
plot(reduced)
LabelSplits(reduced, SplitFrequency(reduced, trees) / length(trees))

QuickRogue(trees, fullSeq = TRUE)

bootTrees &lt;- system.file("example/150.bs", package = "Rogue")
tmpDir &lt;- tempdir()
XX &lt;- capture.output( # Don't print verbose run details to console
  C_RogueNaRok(bootTrees, workDir = tmpDir)
)

# Results have been written to our temporary directory
oldwd &lt;- setwd(tmpDir)
head(read.table("RogueNaRok_droppedRogues.tmp", header = TRUE))

# Delete temporary files
file.remove("RogueNaRok_droppedRogues.tmp")
file.remove("RogueNaRok_info.tmp")

setwd(oldwd)
</code></pre>

<hr>
<h2 id='TipInstability'>Tip instability</h2><span id='topic+TipInstability'></span><span id='topic+ColByStability'></span>

<h3>Description</h3>

<p><code>TipInstability()</code> calculates the instability of each leaf in a tree.
Unstable leaves are likely to display roguish behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TipInstability(
  trees,
  log = TRUE,
  average = "mean",
  deviation = "sd",
  checkTips = TRUE,
  parallel = FALSE
)

ColByStability(
  trees,
  log = TRUE,
  average = "mean",
  deviation = "sd",
  pal = hcl.colors(131, "inferno")[1:101]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TipInstability_+3A_trees">trees</code></td>
<td>
<p>List of trees to analyse.</p>
</td></tr>
<tr><td><code id="TipInstability_+3A_log">log</code></td>
<td>
<p>Logical specifying whether to log-transform distances when
calculating leaf stability.</p>
</td></tr>
<tr><td><code id="TipInstability_+3A_average">average</code></td>
<td>
<p>Character specifying whether to use <code>"mean"</code> or <code>"median"</code>
tip distances to calculate leaf stability.</p>
</td></tr>
<tr><td><code id="TipInstability_+3A_deviation">deviation</code></td>
<td>
<p>Character specifying whether to use <code>"sd"</code> or <code>"mad"</code> to
calculate leaf stability.</p>
</td></tr>
<tr><td><code id="TipInstability_+3A_checktips">checkTips</code></td>
<td>
<p>Logical specifying whether to check that tips are numbered
consistently.</p>
</td></tr>
<tr><td><code id="TipInstability_+3A_parallel">parallel</code></td>
<td>
<p>Logical specifying whether parallel execution should take
place in C++.</p>
</td></tr>
<tr><td><code id="TipInstability_+3A_pal">pal</code></td>
<td>
<p>A vector listing a sequence of colours to be used for plotting.
The earliest entries will be assigned to the most stable tips.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Smith (2022) defines the <em>instability</em> of a pair
of leaves as the median absolute divergence in the graph geodesic
(the number of edges in the shortest path between the leaves) across all
trees, normalized against the mean graph geodesic.
The instability of a single leaf is the mean instability of all pairs that
include that leaf; higher values characterise leaves whose position is more
variable between trees.
</p>
<p>Other concepts of leaf instability include
</p>

<ul>
<li><p> The &quot;taxonomic instability index&quot;, as implemented in Mesquite:
described by Thomson and Shaffer (2010) as
<code class="reqn">\sum\limits_{(x, y), j \neq i}{\frac{|D~ijx~ - D~ijy~|}{(D~ijx~ - D~ijy~)^2}}</code>,
where <code class="reqn">D~ijx~</code> is the patristic distance (i.e. length of edges)
between leaves <code class="reqn">i</code> and <code class="reqn">j</code> in tree <code class="reqn">x</code>.
</p>
</li>
<li><p> the average stability of triplets (i.e. quartets including the root) that
include the leaf (Thorley and Wilkinson 1999), implemented in &quot;Phyutility&quot;
(Smith and Dunn 2008); and related to &quot;positional congruence&quot;
measures (Estabrook 1992; Pol and Escapa 2009).
</p>
</li></ul>



<h3>Value</h3>

<p><code>ColByStability()</code> returns a named character vector that assigns a
colour to each leaf in <code>trees</code> according to their stability.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Estabrook GF (1992).
&ldquo;Evaluating undirected positional congruence of individual taxa between two estimates of the phylogenetic tree for a group of taxa.&rdquo;
<em>Systematic Biology</em>, <b>41</b>(2), 172&ndash;177.
<a href="https://doi.org/10.1093/sysbio/41.2.172">doi:10.1093/sysbio/41.2.172</a>.<br /><br /> Pol D, Escapa IH (2009).
&ldquo;Unstable taxa in cladistic analysis: identification and the assessment of relevant characters.&rdquo;
<em>Cladistics</em>, <b>25</b>(5), 515&ndash;527.
<a href="https://doi.org/10.1111/j.1096-0031.2009.00258.x">doi:10.1111/j.1096-0031.2009.00258.x</a>.<br /><br /> Smith MR (2022).
&ldquo;Using information theory to detect rogue taxa and improve consensus trees.&rdquo;
<em>Systematic Biology</em>, <b>71</b>(5), 986&ndash;1008.
<a href="https://doi.org/10.1093/sysbio/syab099">doi:10.1093/sysbio/syab099</a>.<br /><br /> Smith SA, Dunn CW (2008).
&ldquo;Phyutility: a phyloinformatics tool for trees, alignments and molecular data.&rdquo;
<em>Bioinformatics</em>, <b>24</b>(5), 715&ndash;716.
<a href="https://doi.org/10.1093/bioinformatics/btm619">doi:10.1093/bioinformatics/btm619</a>.<br /><br /> Thomson RC, Shaffer HB (2010).
&ldquo;Sparse supermatrices for phylogenetic inference: taxonomy, alignment, rogue taxa, and the phylogeny of living turtles.&rdquo;
<em>Systematic Biology</em>, <b>59</b>(1), 42&ndash;58.
<a href="https://doi.org/10.1093/sysbio/syp075">doi:10.1093/sysbio/syp075</a>.<br /><br /> Thorley JL, Wilkinson M (1999).
&ldquo;Testing the phylogenetic stability of early tetrapods.&rdquo;
<em>Journal of Theoretical Biology</em>, <b>200</b>(3), 343&ndash;344.
<a href="https://doi.org/10.1006/jtbi.1999.0999">doi:10.1006/jtbi.1999.0999</a>.
</p>


<h3>See Also</h3>

<p>Other tip instability functions: 
<code><a href="#topic+TipVolatility">TipVolatility</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE)

# Generate some trees with a rogue taxon
trees &lt;- AddTipEverywhere(BalancedTree(8), "Rogue")[3:6]

# Display the strict consensus
plot(consensus(trees), tip.col = ColByStability(trees))

# Add a legend for the colour scale used
PlotTools::SpectrumLegend(
  "bottomleft", bty = "n", # No box
  legend = c("Unstable", "", "Stable"),
  palette = hcl.colors(131, "inferno")[1:101]
)

# Calculate leaf stability
instab &lt;- TipInstability(trees, log = FALSE, ave = "mean", dev = "mad")

# Plot a consensus that omits the least stable leaves
plot(ConsensusWithout(trees, names(instab[instab &gt; 0.2])))
</code></pre>

<hr>
<h2 id='TipVolatility'>Detect rogue taxa using phylogenetic information distance</h2><span id='topic+TipVolatility'></span>

<h3>Description</h3>

<p>Calculate the volatility of each tip: namely, the impact on the mean
phylogenetic information distance (Smith 2020) between
trees when that tip is removed.
Effective when the number of trees is small.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TipVolatility(trees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TipVolatility_+3A_trees">trees</code></td>
<td>
<p>List of trees to analyse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TipVolatility()</code> returns a named vector listing the volatility
index calculated for each leaf.
</p>


<h3>References</h3>

<p>Smith MR (2020).
&ldquo;Information theoretic Generalized Robinson&ndash;Foulds metrics for comparing phylogenetic trees.&rdquo;
<em>Bioinformatics</em>, <b>36</b>(20), 5007&ndash;5013.
<a href="https://doi.org/10.1093/bioinformatics/btaa614">doi:10.1093/bioinformatics/btaa614</a>.
</p>


<h3>See Also</h3>

<p>Other tip instability functions: 
<code><a href="#topic+TipInstability">TipInstability</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE)

# Generate some trees with two rogue taxa
trees &lt;- AddTipEverywhere(BalancedTree(8), "Rogue")
trees[] &lt;- lapply(trees, AddTip, "Rogue", "Rogue2")

# Calculate tip volatility
sb &lt;- TipVolatility(trees)

# Use volatility to colour leaves in consensus tree
sbNorm &lt;- 1 + (99 * (sb - min(sb)) / (max(sb - min(sb))))
col &lt;- hcl.colors(128, "inferno")[sbNorm]
plot(consensus(trees), tip.color = col)

# Add a legend for the colour scale used
PlotTools::SpectrumLegend(
  "bottomleft", bty = "n", # Suppress box
  inset = -0.02,           # Avoid overlap
  title = "Volatility",
  legend = signif(seq(max(sb), min(sb), length.out = 4), 3),
  palette = hcl.colors(128, "inferno")
)

# Plot consensus after removing highly volatile taxa
plot(ConsensusWithout(trees, names(sb[sb == max(sb)])))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
