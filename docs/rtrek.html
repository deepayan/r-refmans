<!DOCTYPE html><html><head><title>Help for package rtrek</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rtrek}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ma_article'><p>Read Memory Alpha article</p></a></li>
<li><a href='#ma_image'><p>Memory Alpha images</p></a></li>
<li><a href='#ma_search'><p>Memory Alpha site search</p></a></li>
<li><a href='#mb_article'><p>Read Memory Beta article</p></a></li>
<li><a href='#mb_image'><p>Memory Beta images</p></a></li>
<li><a href='#mb_search'><p>Memory Beta site search</p></a></li>
<li><a href='#mb_timeline'><p>Memory Beta timeline</p></a></li>
<li><a href='#memory_alpha'><p>Memory Alpha API</p></a></li>
<li><a href='#memory_beta'><p>Memory Beta API</p></a></li>
<li><a href='#rtrek'><p>rtrek: Data analysis relating to Star Trek.</p></a></li>
<li><a href='#st_books_wiki'><p>Go to Wikipedia entry for a specific book series</p></a></li>
<li><a href='#st_datasets'><p>Available datasets</p></a></li>
<li><a href='#st_font'><p>Preview Star Trek fonts</p></a></li>
<li><a href='#st_logo'><p>Star Trek logos</p></a></li>
<li><a href='#st_tiles'><p>Return the URL associated with a tile set</p></a></li>
<li><a href='#st_tiles_data'><p>Ancillary location data for map tiles</p></a></li>
<li><a href='#st_transcripts'><p>Import transcripts</p></a></li>
<li><a href='#stapi'><p>Retrieve Star Trek data from STAPI</p></a></li>
<li><a href='#stapiEntities'><p>Star Trek API entities.</p></a></li>
<li><a href='#stBooks'><p>Star Trek novel metadata.</p></a></li>
<li><a href='#stGeo'><p>Raster grid location data for stellar cartographic map tile sets.</p></a></li>
<li><a href='#stLogos'><p>Star Trek logos metadata.</p></a></li>
<li><a href='#stSeries'><p>Star Trek series.</p></a></li>
<li><a href='#stSpecies'><p>Species names and avatars, linked primarily from Memory Alpha.</p></a></li>
<li><a href='#stTiles'><p>Available Star Trek map tile sets.</p></a></li>
<li><a href='#theme_rtrek'><p>ggplot2 themes</p></a></li>
<li><a href='#tile_coords'><p>Simple CRS coordinates</p></a></li>
<li><a href='#tlBooks'><p>Star Trek novel-based timeline.</p></a></li>
<li><a href='#tlEvents'><p>Star Trek event-based timeline.</p></a></li>
<li><a href='#tlFootnotes'><p>Star Trek timeline footnotes.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Data Analysis Relating to Star Trek</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides datasets related to the Star Trek fictional universe and functions for working with the data.
    The package also provides access to real world datasets based on the televised series and other related licensed media productions.
    It interfaces with the Star Trek API (STAPI) (<a href="http://stapi.co/">http://stapi.co/</a>), 
    Memory Alpha (<a href="https://memory-alpha.fandom.com/wiki/Portal:Main">https://memory-alpha.fandom.com/wiki/Portal:Main</a>), and Memory Beta (<a href="https://memory-beta.fandom.com/wiki/Main_Page">https://memory-beta.fandom.com/wiki/Main_Page</a>) 
    to retrieve data, metadata and other information relating to Star Trek.
    It also contains several local datasets covering a variety of topics. 
    The package also provides functions for working with data from other Star Trek-related 
    R data packages containing larger datasets not stored in 'rtrek'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/leonawicz/rtrek">https://github.com/leonawicz/rtrek</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/leonawicz/rtrek/issues">https://github.com/leonawicz/rtrek/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, jsonlite, xml2, rvest, jpeg, purrr, ggplot2, memoise,
tibble, tidyr, downloader</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lubridate, testthat, knitr, rmarkdown, leaflet, showtext,
sysfonts, trekfont, png</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-13 18:57:03 UTC; Matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Leonawicz <a href="https://orcid.org/0000-0001-9452-2771"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Leonawicz &lt;mfleonawicz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-14 22:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ma_article'>Read Memory Alpha article</h2><span id='topic+ma_article'></span>

<h3>Description</h3>

<p>Read Memory Alpha article content and metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma_article(
  url,
  content_format = c("xml", "character"),
  content_nodes = c("h1", "h2", "h3", "h4", "h5", "h6", "p", "b", "ul"),
  browse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma_article_+3A_url">url</code></td>
<td>
<p>character, article URL. Expects package-style short URL. See
examples.</p>
</td></tr>
<tr><td><code id="ma_article_+3A_content_format">content_format</code></td>
<td>
<p>character, the format of the article main text,
<code>"xml"</code> or <code>"character"</code>.</p>
</td></tr>
<tr><td><code id="ma_article_+3A_content_nodes">content_nodes</code></td>
<td>
<p>character, which top-level nodes in the article main
text to retain.</p>
</td></tr>
<tr><td><code id="ma_article_+3A_browse">browse</code></td>
<td>
<p>logical, also open <code>url</code> in browser.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Article content is returned in a nested, tidy data frame.
</p>


<h3>Value</h3>

<p>a nested data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma_article("Azetbur")
</code></pre>

<hr>
<h2 id='ma_image'>Memory Alpha images</h2><span id='topic+ma_image'></span>

<h3>Description</h3>

<p>Download a Memory Alpha image and return a ggplot object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma_image(url, file, keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma_image_+3A_url">url</code></td>
<td>
<p>character, the short URL of the image, for example as returned by
<code>memory_alpha()</code>. See example.</p>
</td></tr>
<tr><td><code id="ma_image_+3A_file">file</code></td>
<td>
<p>character, output file name. Optional. See details.</p>
</td></tr>
<tr><td><code id="ma_image_+3A_keep">keep</code></td>
<td>
<p>logical, if <code>FALSE</code> (default) then <code>file</code> is only temporary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the downloaded file is not retained (<code>keep = FALSE</code>). The filename
is derived from <code>url</code> if <code>file</code> is not provided. Whether or not the output
file is kept, a ggplot object of the image is returned.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ma_image("File:Gowron_attempts_to_recruit_Worf.jpg")
</code></pre>

<hr>
<h2 id='ma_search'>Memory Alpha site search</h2><span id='topic+ma_search'></span>

<h3>Description</h3>

<p>Perform a Memory Alpha site search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma_search(text, browse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma_search_+3A_text">text</code></td>
<td>
<p>character, search query.</p>
</td></tr>
<tr><td><code id="ma_search_+3A_browse">browse</code></td>
<td>
<p>logical, open search results page in browser.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a data frame containing the title, truncated text
preview, and relative URL for the first page of search results. It does not
recursively collate search results through subsequent pages of results.
There could be an unexpectedly high number of pages of results depending on
the search query. Since the general nature of this search feature seems
relatively casual anyway, it aims only to provide a first page preview.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma_search("Worf")
</code></pre>

<hr>
<h2 id='mb_article'>Read Memory Beta article</h2><span id='topic+mb_article'></span>

<h3>Description</h3>

<p>Read Memory Beta article content and metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_article(
  url,
  content_format = c("xml", "character"),
  content_nodes = c("h1", "h2", "h3", "h4", "h5", "h6", "p", "b", "ul"),
  browse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_article_+3A_url">url</code></td>
<td>
<p>character, article URL. Expects package-style short URL. See
examples.</p>
</td></tr>
<tr><td><code id="mb_article_+3A_content_format">content_format</code></td>
<td>
<p>character, the format of the article main text,
<code>"xml"</code> or <code>"character"</code>.</p>
</td></tr>
<tr><td><code id="mb_article_+3A_content_nodes">content_nodes</code></td>
<td>
<p>character, which top-level nodes in the article main
text to retain.</p>
</td></tr>
<tr><td><code id="mb_article_+3A_browse">browse</code></td>
<td>
<p>logical, also open <code>url</code> in browser.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Article content is returned in a nested, tidy data frame.
</p>


<h3>Value</h3>

<p>a nested data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mb_article("Azetbur")
</code></pre>

<hr>
<h2 id='mb_image'>Memory Beta images</h2><span id='topic+mb_image'></span>

<h3>Description</h3>

<p>Download a Memory Beta image and return a ggplot object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_image(url, file, keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_image_+3A_url">url</code></td>
<td>
<p>character, the short URL of the image, for example as returned by
<code>memory_beta()</code>. See example.</p>
</td></tr>
<tr><td><code id="mb_image_+3A_file">file</code></td>
<td>
<p>character, output file name. Optional. See details.</p>
</td></tr>
<tr><td><code id="mb_image_+3A_keep">keep</code></td>
<td>
<p>logical, if <code>FALSE</code> (default) then <code>file</code> is only temporary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the downloaded file is not retained (<code>keep = FALSE</code>). The filename
is derived from <code>url</code> if <code>file</code> is not provided. Whether or not the output
file is kept, a ggplot object of the image is returned.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mb_image("File:DataBlaze.jpg")
</code></pre>

<hr>
<h2 id='mb_search'>Memory Beta site search</h2><span id='topic+mb_search'></span>

<h3>Description</h3>

<p>Perform a Memory Beta site search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_search(text, browse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_search_+3A_text">text</code></td>
<td>
<p>character, search query.</p>
</td></tr>
<tr><td><code id="mb_search_+3A_browse">browse</code></td>
<td>
<p>logical, open search results page in browser.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a data frame containing the title, truncated text
preview, and relative URL for the first page of search results. It does not
recursively collate search results through subsequent pages of results. There
could be an unexpectedly high number of pages of results depending on the
search query. Since the general nature of this search feature seems
relatively casual anyway, it aims only to provide a first page preview.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mb_search("Worf")
</code></pre>

<hr>
<h2 id='mb_timeline'>Memory Beta timeline</h2><span id='topic+mb_timeline'></span>

<h3>Description</h3>

<p>Access curated data frames containing Star Trek timeline data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_timeline(x, html = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_timeline_+3A_x">x</code></td>
<td>
<p>numeric or character, description of the desired timeline window.
See details.</p>
</td></tr>
<tr><td><code id="mb_timeline_+3A_html">html</code></td>
<td>
<p>logical, set to <code>TRUE</code> to return the <code>details</code> text column of the
<code>Events</code> data frame as basic HTML character strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The timeline data is from the
<a href="https://memory-beta.fandom.com/wiki/Memory_Beta_Chronology">Memory Beta Chronology</a>.
</p>
<p><code>x</code> can be a numeric vector of years, e.g. <code>x = 2361:2364</code>. This should only
be used if you know (or can safely assume) a year exists as a page on Memory
Beta. Check there first if unsure. <code>x</code> may otherwise be scalar character.
This can be a specific decade in the form, e.g., <code>"2370s"</code>. If a decade, it
must fall in the range from <code>"1900s"</code> through <code>"2490s"</code>. The decade option
pulls back data from the decade page entry, or if individual year pages exist
within the given decade, it will pull the data for each existing year.
</p>
<p>Special values: For the more distant past or future, use the character
options <code>x = "past"</code> or <code>x = "future"</code>. <code>x = "main"</code> will pull from the main
part of the timeline, 1900 - 2499. <code>x = "complete"</code> combines past, main, and
future in order.
</p>
<p>The distant past and future have few entries, and thus few pages. However,
both of these last two options, <code>"main"</code> and <code>complete</code>, must download a
large number of pages. For this reason, <code>rtrek</code> employs anti-DOS measures to
prevent an unwitting user from making too many requests too quickly from
Memory Beta. The function would otherwise be far faster. However, to be a
friendly neighbor in the cosmos, <code>rtrek</code> enforces a minimum one-second wait
between timeline requests. This can lead to downloading the full timeline to
take ten minutes or so even if you have a fast connection; most of the time
it takes is spent waiting patiently.
</p>
<p>Also, like other functions that work with Memory Alpha and Memory Beta data,
<code>mb_timeline</code> wraps around internal functions that are sensibly memoized.
This means that if you make the same call twice in your R session, you won't
have to wait at all, because the result is cached in memory. The call will
appear to run instantaneously the second time around, but that's because
nothing is happening other than returning the cached result from the initial
call.
</p>


<h3>Value</h3>

<p>a list of two data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mb_timeline(2360)
## Not run: 
mb_timeline("2360s")
mb_timeline("past")
mb_timeline("future")
mb_timeline("main")
mb_timeline("complete")
mb_timeline("complete", html = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='memory_alpha'>Memory Alpha API</h2><span id='topic+memory_alpha'></span>

<h3>Description</h3>

<p>Access Star Trek content from
<a href="https://memory-alpha.fandom.com/wiki/Portal:Main">Memory Alpha</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memory_alpha(endpoint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="memory_alpha_+3A_endpoint">endpoint</code></td>
<td>
<p>character, See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The content returned is always a data frame. The structure changes slightly
depending on the nature of the endpoint, but results from different endpoints
can be merged easily.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Portals</h3>

<p>At the highest level, passing <code>endpoint = "portals"</code> returns a data frame
listing the available Memory Alpha portals supported by <code>rtrek</code>. A column of
relative URLs is also included for reference, but can be ignored.
</p>


<h3>Portal Categories</h3>

<p>In all other cases, the endpoint string must begin with one of the valid
portal IDs. Passing only the ID returns a data frame with IDs and relative
URLs associated with the available categories in the specific portal. There
are two additional columns, <code>group</code> and <code>subgroup</code>, that may provide
additional grouping context for the entry IDs in larger tables. As with the
relative URLs, you do not have to make explicit use of these variables.
</p>
<p>Selecting a specific category within a portal is done by appending the portal
ID in <code>endpoint</code> with the category ID, separated by a forward slash. You can
append nested subcategory IDs with forward slashes, provided the
subcategories exist.
</p>


<h3>Articles</h3>

<p>When the endpoint is neither a top-level portal or one of a portal's
categories (or subcategories, if available), it is an article. An article is
a terminal node, meaning you cannot nest further. An article will be any
entry whose URL does not begin with <code style="white-space: pre;">&#8288;Category:&#8288;</code>. In this case, the content
returned is still a data frame for consistency, but differs substantially
from the results of non-terminal endpoints.
</p>
<p>Memory Alpha is not a database containing convenient tables. Articles
comprise the bulk of what Memory Alpha has to offer. They are not completely
unstructured text, but are loosely structured. Some assumptions are made and
<code>memory_alpha</code> returns a data frame containing article text and links. It is
up to the user what to do with this information, e.g., performing text
analyses.
</p>


<h3>Additional Notes</h3>

<p>The <code>url</code> column included in results for context uses relative paths to save
space. The full URLs all begin the same. To visit a URL directly, prepend it
with <code style="white-space: pre;">&#8288;https://memory-alpha.fandom.com/wiki/&#8288;</code>.
</p>
<p>Also note that once you know the relative URL for an article, e.g., <code>"Worf"</code>,
you do not need to traverse through one of the portals using an <code>endpoint</code>
string to retrieve its content. You can instead use <code>ma_article("Worf")</code>.
</p>
<p><code>memory_alpha()</code> provides an overview perspective on how content available at
Memory Alpha is organized and can be searched for through a variety of
hierarchical layouts. And in some cases this structure that can be obtained
in table form can be useful as data or metadata in itself. Alternatively,
<code>ma_article()</code> is focused exclusively on pulling back content from known
articles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ma_article">ma_article()</a></code>, <code><a href="#topic+memory_beta">memory_beta()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>memory_alpha("portals") # show available portals

memory_alpha("people") # show portal categories for People portal
memory_alpha("people/Klingons") # show people in Klingons subcategory
memory_alpha("people/Klingons/Worf") # return terminal article content

</code></pre>

<hr>
<h2 id='memory_beta'>Memory Beta API</h2><span id='topic+memory_beta'></span>

<h3>Description</h3>

<p>Access Star Trek content from
<a href="https://memory-beta.fandom.com/wiki/Main_Page">Memory Alpha</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memory_beta(endpoint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="memory_beta_+3A_endpoint">endpoint</code></td>
<td>
<p>character, See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The content returned is always a data frame. The structure changes slightly
depending on the nature of the endpoint, but results from different endpoints
can be merged easily.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Portals</h3>

<p>At the highest level, passing <code>endpoint = "portals"</code> returns a data frame
listing the available Memory Beta portals supported by <code>rtrek</code>. A column of
relative URLs is also included for reference, but can be ignored. Compared to
Memory Alpha, Memory Beta does not technically offer &quot;portals&quot;, but for
consistency in <code>rtrek</code>, several high level categories on Memory Beta are
treated as portal options. See <code><a href="#topic+memory_alpha">memory_alpha()</a></code> for comparison.
</p>


<h3>Portal Categories</h3>

<p>In all other cases, the endpoint string must begin with one of the valid
portal IDs. Passing only the ID returns a data frame with IDs and relative
URLs associated with the available categories in the specific portal. Unlike
<code>memory_alpha</code>, there are no <code>group</code> or <code>subgroup</code> columns. Memory Beta
offers a more consistent reliance on the simple hierarchy of categories and
articles.
</p>
<p>Selecting a specific category within a portal is done by appending the portal
ID in <code>endpoint</code> with the category ID, separated by a forward slash. You can
append nested subcategory IDs with forward slashes, provided the
subcategories exist.
</p>


<h3>Articles</h3>

<p>When the endpoint is neither a top-level portal or one of a portal's
categories (or subcategories, if available), it is an article. An article is
a terminal node, meaning you cannot nest further. An article will be any
entry whose URL does not begin with <code style="white-space: pre;">&#8288;Category:&#8288;</code>. In this case, the content
returned is still a data frame for consistency, but differs substantially
from the results of non-terminal endpoints.
</p>
<p>Memory Beta is not a database containing convenient tables. Articles comprise
the bulk of what Memory Beta has to offer. They are not completely
unstructured text, but are loosely structured. Some assumptions are made and
<code>memory_beta</code> returns a data frame containing article text and links. It is
up to the user what to do with this information, e.g., performing text
analyses.
</p>


<h3>Additional Notes</h3>

<p>The <code>url</code> column included in results for context uses relative paths to save
space. The full URLs all begin the same. To visit a URL directly, prepend it
with <code style="white-space: pre;">&#8288;https://memory-beta.fandom.com/wiki/&#8288;</code>.
</p>
<p>Also note that once you know the relative URL for an article, e.g.,
<code>"Worf"</code>, you do not need to traverse through one of the portals using an
<code>endpoint</code> string to retrieve its content. You can instead use
<code>mb_article("Worf")</code>.
</p>
<p><code>memory_beta</code> provides an overview perspective on how content available at
Memory Beta is organized and can be searched for through a variety of
hierarchical layouts. And in some cases this structure that can be obtained
in table form can be useful as data or metadata in itself. Alternatively,
<code>mb_article()</code> is focused exclusively on pulling back content from known
articles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mb_article">mb_article()</a></code>, <code><a href="#topic+memory_alpha">memory_alpha()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>memory_beta("portals") # show available portals
endpoint &lt;- "characters/Characters by races and cultures/Klingonoids/Klingons"

x &lt;- memory_beta(endpoint)
x &lt;- x[grep("Worf", x$Klingons), ]
x
memory_beta(paste0(endpoint, "/Worf")) # return terminal article content

</code></pre>

<hr>
<h2 id='rtrek'>rtrek: Data analysis relating to Star Trek.</h2><span id='topic+rtrek'></span><span id='topic+rtrek-package'></span>

<h3>Description</h3>

<p>The <code>rtrek</code> package contains a collection of Star Trek-themed datasets and R
functions to assist with their use. The package interfaces with the Star Trek
API (STAPI), Memory Alpha and Memory Beta to retrieve data, metadata and
other information relating to the Star Trek fictional universe.
</p>


<h3>Details</h3>

<p>The package also contains several local datasets covering a variety of topics
such as Star Trek timeline data, universe species data and geopolitical data.
Some of these are more information rich, while others are toy examples useful
for simple demonstrations. The bulk of Star Trek data is accessed from
external sources by API. A future version of <code>rtrek</code> will also include
summary datasets resulting from text mining analyses of Star Trek novels.
</p>

<hr>
<h2 id='st_books_wiki'>Go to Wikipedia entry for a specific book series</h2><span id='topic+st_books_wiki'></span>

<h3>Description</h3>

<p>This function opens a browser tab to the main Wikipedia entry for all Star Trek novels.
For a more complete set of Star Trek series, miniseries and anthology names and acronyms, see the <code><a href="#topic+stSeries">stSeries()</a></code> and <code><a href="#topic+stBooks">stBooks()</a></code> datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_books_wiki()
</code></pre>


<h3>Value</h3>

<p>opens a browser tab, nothing is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stBooks">stBooks()</a></code> <code><a href="#topic+stSeries">stSeries()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: st_books_wiki()
</code></pre>

<hr>
<h2 id='st_datasets'>Available datasets</h2><span id='topic+st_datasets'></span>

<h3>Description</h3>

<p>List the available datasets in the rtrek package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_datasets()
</code></pre>


<h3>Value</h3>

<p>a character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_datasets()
</code></pre>

<hr>
<h2 id='st_font'>Preview Star Trek fonts</h2><span id='topic+st_font'></span>

<h3>Description</h3>

<p>This function produces a plot showing a preview of a Star Trek font from the
<code>trekfont</code> package. It will return a message if any of <code>trekfont</code>, <code>showtext</code>
or <code>ggplot2</code> are not installed. If <code>family</code> is missing, it will return a
vector of all available font families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_font(family, size = 11)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_font_+3A_family">family</code></td>
<td>
<p>character, font family.</p>
</td></tr>
<tr><td><code id="st_font_+3A_size">size</code></td>
<td>
<p>numeric, font size passed to ggplot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In RStudio on Windows the font may not show in the RStudio graphics device.
Try using the regular R GUI.
</p>


<h3>Value</h3>

<p>a character vector, or a plot side effect. See details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(all(c("trekfont", "showtext", "ggplot2") %in% installed.packages())){
  st_font()
}
## Not run: st_font("Federation") # should be run in an interactive session
</code></pre>

<hr>
<h2 id='st_logo'>Star Trek logos</h2><span id='topic+st_logo'></span>

<h3>Description</h3>

<p>Download an image of a Star Trek logo and return a ggplot object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_logo(url, file, keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_logo_+3A_url">url</code></td>
<td>
<p>character, the url of the image, must be one from the dataset
<code><a href="#topic+stLogos">stLogos()</a></code>. See example.</p>
</td></tr>
<tr><td><code id="st_logo_+3A_file">file</code></td>
<td>
<p>character, output file name. Optional. See details.</p>
</td></tr>
<tr><td><code id="st_logo_+3A_keep">keep</code></td>
<td>
<p>logical, if <code>FALSE</code> (default) then <code>file</code> is only temporary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the downloaded file is not retained (<code>keep = FALSE</code>). The filename
is derived from <code>url</code> if <code>file</code> is not provided. These files are all .gif.
Whether or not the output file is kept, a ggplot object of the image is returned.
For more information on attribution, see <code><a href="#topic+stLogos">stLogos()</a></code>.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stLogos">stLogos()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: st_logo(stLogos$url[1])
</code></pre>

<hr>
<h2 id='st_tiles'>Return the URL associated with a tile set</h2><span id='topic+st_tiles'></span>

<h3>Description</h3>

<p>This function returns the URL associated with a tile set matching <code>id</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_tiles(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_tiles_+3A_id">id</code></td>
<td>
<p>character, name of map tile set ID. See <code><a href="#topic+stTiles">stTiles()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tile set data are stored in the <code><a href="#topic+stTiles">stTiles()</a></code> dataset. See for available IDs.
</p>


<h3>Value</h3>

<p>a character string.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stTiles">stTiles()</a></code>, <code><a href="#topic+st_tiles_data">st_tiles_data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_tiles("galaxy1")
</code></pre>

<hr>
<h2 id='st_tiles_data'>Ancillary location data for map tiles</h2><span id='topic+st_tiles_data'></span>

<h3>Description</h3>

<p>Obtain a table of ancillary data associated with various locations of
interest, given a specific map tile set ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_tiles_data(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_tiles_data_+3A_id">id</code></td>
<td>
<p>character, name of a map tile set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a small example data frame of location-specific data
along with grid cell coordinates that are specific to the requested map tile
set ID.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stTiles">stTiles()</a></code>, <code><a href="#topic+st_tiles">st_tiles()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_tiles_data("galaxy2")
</code></pre>

<hr>
<h2 id='st_transcripts'>Import transcripts</h2><span id='topic+st_transcripts'></span>

<h3>Description</h3>

<p>Download a curated data frame based on episode and movie transcripts
containing metadata and variables for analysis of scenes, character presence,
dialog, sentiment, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_transcripts(type = c("clean", "raw"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_transcripts_+3A_type">type</code></td>
<td>
<p>character, <code>"clean"</code> for curated nested data frame or <code>"raw"</code> for
unprocessed text. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame contains metadata associated with each transcript, one row per
episode. It also contains a list column. By default (<code>type = "clean"</code>), this
is a nested data frame of preprocessed text split into several variables
including the speaking character, line spoken, scene descriptions, etc. For
the raw text version, the list column contains vectors of unprocessed plain
text.
</p>
<p>Metadata includes the format (episode or movie), series, season, overall
episode number, title, production order and original airdate if available and
applicable. The two columns <code>url</code> and <code>url2</code> show where source material can
be browsed online, though not in a useful format for data analysis. The first
set is used if possible because it contains more complete, higher quality
data. When necessary, the derived data is based on text from the alternate
source.
</p>
<p>The dataset is nicely curated, but imperfect. There are text-parsing edge
cases that are difficult to handle generally. The quality varies
substantially across series. Datasets assembled based on original transcripts
are more informative, but not universally available. Other episodes are based
on transcripts derived from closed captioning, in which case more fields will
contain <code>NA</code> values.
</p>
<p>This function downloads and returns a sizable tibble data frame. Each version
is about 13-15 MB compressed. The returned tibble contains 726 rows (716
episodes and 10 movies), but each row has nested data.
</p>


<h3>Value</h3>

<p>a tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: stTranscripts &lt;- st_transcripts()
</code></pre>

<hr>
<h2 id='stapi'>Retrieve Star Trek data from STAPI</h2><span id='topic+stapi'></span>

<h3>Description</h3>

<p>Retrieve Star Trek data from the Star Trek API (STAPI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stapi(id, page = 1, uid = NULL, page_count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stapi_+3A_id">id</code></td>
<td>
<p>character, name of STAPI entity. See details.</p>
</td></tr>
<tr><td><code id="stapi_+3A_page">page</code></td>
<td>
<p>integer vector, defaults to first page.</p>
</td></tr>
<tr><td><code id="stapi_+3A_uid">uid</code></td>
<td>
<p><code>NULL</code> for search mode, character for extraction mode. See details.</p>
</td></tr>
<tr><td><code id="stapi_+3A_page_count">page_count</code></td>
<td>
<p>logical, set to <code>TRUE</code> to do a preliminary check of the
total number a pages of results available for a potential entity search.
This will only have the impact of searching the first page.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+stapiEntities">stapiEntities()</a></code> for all the currently available API entities. These are
the IDs for dataset collections or categories passed to <code>id</code>.
</p>
<p>The universal ID <code>uid</code> can be supplied to retrieve a more specific subset of
data. By default, <code>uid = NULL</code> and <code>stapi()</code> operates in search mode. As part
of a stepwise process, you can first use search mode. Then if the resulting
data frame includes a <code>uid</code> column, you can make a second call to the
function providing a specific <code>uid</code>. This puts <code>stapi()</code> into extraction mode
and will return satellite data associated with the unique entry from the
original general sweep of the entity <code>id</code>.
</p>
<p><code>rtrek</code> employs anti-DOS measures. It will not perform an API call to STAPI
more than once per second. To be an even better neighbor, you can increase
this wait time using <code>options</code>, e.g. <code>options(rtrek_antidos = 10)</code> to
increase the minimum time between API calls to ten seconds. Values less than
one are ignored (defaulting back to one second) and a warning will be thrown
when making any API call if this is the case.
</p>
<p>Currently STAPI contains primarily real world data such as episode air dates,
movie metadata, or production company information. Fictional world data is
secondary and more limited.
</p>


<h3>Value</h3>

<p>a data frame in search mode, a list in extraction mode, and nothing
is returned in page count check mode but the result is printed to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
stapi("character", page_count = TRUE) # check first
stapi("character", page = 2) |&gt; select(1:2)
Q &lt;- stapi("character", uid = "CHMA0000025118")
Q$episodes |&gt; select(uid, title, stardateFrom, stardateTo)

</code></pre>

<hr>
<h2 id='stapiEntities'>Star Trek API entities.</h2><span id='topic+stapiEntities'></span>

<h3>Description</h3>

<p>A data frame with 40 rows and 4 columns listing the available STAPI entity
IDs that can be passed to <code><a href="#topic+stapi">stapi()</a></code>, along with additional metadata regarding
the content returned form an API call to each entity. This data frame helps
you see what you will obtain from API calls beforehand. Every entity search
returns a tibble data frame, with varying numbers of columns and different
names depending on the entity content. There is also one nested column
containing the column names of the data frame returned for each entity. This
can be inspected directly for specific entities or <code>stapiEntities</code> can be
unnested with a function like <code>tidyr::unnest()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stapiEntities
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stapi">stapi()</a></code>
</p>

<hr>
<h2 id='stBooks'>Star Trek novel metadata.</h2><span id='topic+stBooks'></span>

<h3>Description</h3>

<p>A data frame with 783 rows and 11 columns containing metadata on Star Trek
novels and other books taken directly from original books. The data frame
contains most of the novels but is not comprehensive and may be out of date
temporarily whenever new novels are published. It is largely complete through
the end of 2017, though some older entries are still missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stBooks
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>


<h3>Details</h3>

<p><code>stBooks</code>: There may be some irregularities or erroneous entries based on the
imperfect methods use to compile the metadata, but it is overall an accurate
dataset.
</p>
<p>The <code>nchap</code> column is largely accurate, but imperfect. Some entries suggest a
book has an unusual number of chapters, but the parser is not perfect at
determining what constitutes a chapter. However, many of the books with
unusually high numbers of chapters are not erroneous but rather indicate a
reference book, omnibus or anthology, as opposed to a standard novel.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stSeries">stSeries()</a></code>, <code><a href="#topic+st_books_wiki">st_books_wiki()</a></code>
</p>

<hr>
<h2 id='stGeo'>Raster grid location data for stellar cartographic map tile sets.</h2><span id='topic+stGeo'></span>

<h3>Description</h3>

<p>A data frame of with 18 rows and 4 columns. This data frame has an ID column for map tile set, a column of location names, and columns of respective column and row number of each location per map tile set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stGeo
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>

<hr>
<h2 id='stLogos'>Star Trek logos metadata.</h2><span id='topic+stLogos'></span>

<h3>Description</h3>

<p>A data frame with 236 rows and 3 columns containing Star Trek logo metadata:
category, description and URL. Logo artwork credited to Kris Trigwell. The
logo images are served by st-minutiae.com for personal and fair use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stLogos
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+st_logo">st_logo()</a></code>
</p>

<hr>
<h2 id='stSeries'>Star Trek series.</h2><span id='topic+stSeries'></span>

<h3>Description</h3>

<p>A data frame with 35 rows and 3 columns containing names and abbreviations of
Star Trek series and anthologies. There are so many because the table
pertains to written works, which is inclusive of the more limited televised
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stSeries
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>


<h3>Details</h3>

<p>Some entries listed as series can be interpreted as miniseries, but that
distinction is not made here. The official line between the two is not always
clear and can also change as more novels are released.
</p>
<p>Anthologies are listed as such, rather than as series. Reference manuals have
a distinct entry. The Miscellaneous category can be considered synonymous
with All-Series/Crossover, abbreviated elsewhere as simply <code>ST</code> for Star Trek
in general, rather than as <code>MISC</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+st_books_wiki">st_books_wiki()</a></code>
</p>

<hr>
<h2 id='stSpecies'>Species names and avatars, linked primarily from Memory Alpha.</h2><span id='topic+stSpecies'></span>

<h3>Description</h3>

<p>A data frame with 9 rows and 2 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stSpecies
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>

<hr>
<h2 id='stTiles'>Available Star Trek map tile sets.</h2><span id='topic+stTiles'></span>

<h3>Description</h3>

<p>A data frame with 2 row and 8 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stTiles
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>

<hr>
<h2 id='theme_rtrek'>ggplot2 themes</h2><span id='topic+theme_rtrek'></span><span id='topic+theme_rtrek_dark'></span>

<h3>Description</h3>

<p>A collection of ggplot2 themes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_rtrek(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_rtrek_dark(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_rtrek_+3A_base_size">base_size</code></td>
<td>
<p>base font size.</p>
</td></tr>
<tr><td><code id="theme_rtrek_+3A_base_family">base_family</code></td>
<td>
<p>base font family.</p>
</td></tr>
<tr><td><code id="theme_rtrek_+3A_base_line_size">base_line_size</code></td>
<td>
<p>base size for line elements.</p>
</td></tr>
<tr><td><code id="theme_rtrek_+3A_base_rect_size">base_rect_size</code></td>
<td>
<p>base size for rect elements.</p>
</td></tr>
</table>

<hr>
<h2 id='tile_coords'>Simple CRS coordinates</h2><span id='topic+tile_coords'></span>

<h3>Description</h3>

<p>Convert <code style="white-space: pre;">&#8288;(column, row)&#8288;</code> numbers to <code style="white-space: pre;">&#8288;(x, y)&#8288;</code> coordinates for a given tile set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tile_coords(data, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tile_coords_+3A_data">data</code></td>
<td>
<p>a data frame containing columns named <code>col</code> and <code>row</code>. These
contain column-row number pairs defining matrix cells in tile set <code>id</code>. See
details.</p>
</td></tr>
<tr><td><code id="tile_coords_+3A_id">id</code></td>
<td>
<p>character, name of map tile set ID. See <code><a href="#topic+stTiles">stTiles()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts column and row indices for an available map tile set
matrix to coordinates that can be used in a Leaflet map. See <code><a href="#topic+stTiles">stTiles()</a></code> for
available tile sets.
</p>
<p><code>data</code> cannot contain columns named <code>x</code> or <code>y</code>, which are reserved for the
column-appended output data frame.
</p>
<p>Each tile set has a simple/non-geographical coordinate reference system
(CRS). Respective coordinates are based on the dimensions of the source image
used to generate each tile set. The same column and row pair will yield
different map coordinates for different tile sets. Typical for matrices,
columns are numbered increasing from left to right and rows increasing from
top to bottom. The output of <code>tile_coords()</code> is a typical Cartesian coordinate
system, increasing from left to right and bottom to top.
</p>


<h3>Value</h3>

<p>a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(row = c(0, 3222, 6445), col = c(0, 4000, 8000))
tile_coords(d, "galaxy1")
</code></pre>

<hr>
<h2 id='tlBooks'>Star Trek novel-based timeline.</h2><span id='topic+tlBooks'></span>

<h3>Description</h3>

<p>A data frame with 2122 rows and 14 columns containing Star Trek timeline
data. This dataset is novel-driven, meaning that the timeline entries (rows)
provide a chronologically ordered list of licensed Star Trek novels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tlBooks
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>


<h3>Details</h3>

<p>Specifically, this curated dataset includes data derived from historical
timeline information in the appendix of the Star Trek reference manual,
Voyages of the Imagination, which provides information on the large
collection of licensed Star Trek literature. The authors note that the
original timeline includes &quot;novels, short stories, eBooks, novelizations,
Simon &amp; Schuster Audio original audio books, Minstrel Books young adult
books, and classic novels from Bantam and Ballantine Books, published through
October 2006.&quot;
</p>
<p>While this data is very informative, it is clearly many years out of date. It
is also necessarily speculative. Settings are determined based in part on
what is interpreted to be the intention of a given author for a given
production. Nevertheless, it still represents possibly the highest quality
representation of the chronological ordering of Star Trek fiction that
combines episodes and movies with written works. The concurrent timeline of
Star Trek TV episodes and movies are interleaved with the novels and other
written fiction for fuller context resulting in a much richer timeline.
See the <code>tlEvents</code> dataset for an event-driven timeline.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tlEvents">tlEvents()</a></code> <code><a href="#topic+tlFootnotes">tlFootnotes()</a></code>
</p>

<hr>
<h2 id='tlEvents'>Star Trek event-based timeline.</h2><span id='topic+tlEvents'></span>

<h3>Description</h3>

<p>A data frame with 1241 rows and 6 columns containing Star Trek timeline data.
This dataset is event-driven, meaning that the timeline entries (rows)
provide chronologically ordered historical events from the Star Trek
universe. See the <code>tlBooks</code> dataset for an novel-driven timeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tlEvents
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>


<h3>Details</h3>

<p>As with <code>tlBooks</code>, this timeline is quite out of date. In fact it is at least
somewhat more out of date than <code>tlBooks</code>. This timeline is also more
problematic than the other, and less relevant moving forward. Its updating
essentially ceased as the other began.
</p>
<p>However, it is included because unlike <code>tlBooks</code>, which is a timeline of
production titles, this timeline dataset is event-driven. While it may now be
erroneous in places even independent from being out of date, it is useful for
its informative textual entries referencing historically significant events
in Star Trek lore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tlBooks">tlBooks()</a></code> <code><a href="#topic+tlFootnotes">tlFootnotes()</a></code>
</p>

<hr>
<h2 id='tlFootnotes'>Star Trek timeline footnotes.</h2><span id='topic+tlFootnotes'></span>

<h3>Description</h3>

<p>A data frame with 605 rows and 3 columns containing footnotes associated by
ID with various entries in package timeline datasets, <code>tlBooks</code> and
<code>tlEvents</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tlFootnotes
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tlBooks">tlBooks()</a></code> <code><a href="#topic+tlEvents">tlEvents()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
