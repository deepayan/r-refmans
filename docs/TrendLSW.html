<!DOCTYPE html><html><head><title>Help for package TrendLSW</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TrendLSW}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TrendLSW-package'>
<p>Wavelet Methods for Analysing Locally Stationary Time Series</p></a></li>
<li><a href='#Atau.mat.calc'><p>Lagged Autocorrelation Wavelet Inner Product Calculation</p></a></li>
<li><a href='#celegensbio'>
<p>Bioluminescence of C. Elegens</p></a></li>
<li><a href='#Cmat.calc'><p>Cross Autocorrelation Wavelet Inner Product Matrix Calculation</p></a></li>
<li><a href='#ewspec.diff'><p>Estimation of Evolutionary Wavelet Spectrum of Non-Zero Mean Time</p>
Series via Differencing</a></li>
<li><a href='#ewspec.trend'><p>Estimation of Evolutionary Wavelet Spectrum for Non-Zero Mean Time Series</p></a></li>
<li><a href='#get.boundary.timeseries'><p>Calculate Boundary Extended Time Series</p></a></li>
<li><a href='#plot.TLSW'><p>Plot Trend and/or Spectrum Information in a <code>TLSW</code> Object</p></a></li>
<li><a href='#print.TLSW'><p>Print an Object of Class <code>TLSW</code></p></a></li>
<li><a href='#summary.TLSW'><p>Summary of Output Provided by the <code>TLSW</code> Function</p></a></li>
<li><a href='#TLSW'><p>Estimate Trend and Spectrum of Trend Locally Stationary Wavelet Process</p></a></li>
<li><a href='#TLSWlacf'><p>Compute Localised Autocovariance Estimate of a TLSW Object</p></a></li>
<li><a href='#TLSWsim'><p>Simulate Trend Locally Stationary Wavelet Process</p></a></li>
<li><a href='#wav.diff.trend.est'><p>Wavelet Thresholding Trend Estimation of Time Series</p></a></li>
<li><a href='#wav.trend.est'><p>Linear Wavelet Thresholding Trend Estimation of Time Series</p></a></li>
<li><a href='#z.acc'>
<p>Z-Axis Acceleration for Human Activity Monitoring</p></a></li>
<li><a href='#z.labels'>
<p>Activity Labels for Human Activity Monitoring</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wavelet Methods for Analysing Locally Stationary Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Euan T. McGonigle &lt;e.t.mcgonigle@soton.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fitting models for, and simulation of, trend locally stationary 
    wavelet (TLSW) time series models, which take account of time-varying 
    trend and dependence structure in a univariate time series. The TLSW model, 
    and its estimation, is described in McGonigle, Killick and Nunes (2022a) 
    &lt;<a href="https://doi.org/10.1111%2Fjtsa.12643">doi:10.1111/jtsa.12643</a>&gt;, (2022b) &lt;<a href="https://doi.org/10.1214%2F22-EJS2044">doi:10.1214/22-EJS2044</a>&gt;. New users will 
    likely want to start with the TLSW function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>wavethresh, locits</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/EuanMcGonigle/TrendLSW">https://github.com/EuanMcGonigle/TrendLSW</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EuanMcGonigle/TrendLSW/issues">https://github.com/EuanMcGonigle/TrendLSW/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), vdiffr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-30 18:05:12 UTC; euanmcgonigle</td>
</tr>
<tr>
<td>Author:</td>
<td>Euan T. McGonigle [aut, cre],
  Rebecca Killick [aut],
  Matthew Nunes [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-30 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='TrendLSW-package'>
Wavelet Methods for Analysing Locally Stationary Time Series
</h2><span id='topic+TrendLSW-package'></span><span id='topic+TrendLSW'></span>

<h3>Description</h3>

<p>Provides wavelet-based methods for trend, spectrum and autocovariance estimation of locally
stationary time series.  See <code><a href="#topic+TLSW">TLSW</a></code> for the main estimation function.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> TrendLSW</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-04-17</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Euan T. McGonigle &lt;e.t.mcgonigle@soton.ac.uk&gt;, Rebecca Killick &lt;r.killick@lancs.ac.uk&gt;, and Matthew Nunes &lt;m.a.nunes@bath.ac.uk&gt;
</p>
<p>Maintainer: Euan T. McGonigle &lt;e.t.mcgonigle@soton.ac.uk&gt;
</p>


<h3>References</h3>

<p>Spectral estimation with differencing/nonlinear trend estimator: McGonigle, E. T., Killick, R., and Nunes, M. (2022). Modelling
time-varying first and second-order structure of time series via wavelets
and differencing. <em>Electronic Journal of Statistics</em>, 6(2), 4398-4448.
</p>
<p>Spectral estimation in presence of trend/linear trend estimator: McGonigle, E. T., Killick, R., and Nunes, M. (2022). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>
<p>LSW processes without trend: Nason, G. P., von Sachs, R., and Kroisandt, G. (2000). Wavelet processes and
adaptive estimation of the evolutionary wavelet spectrum. <em>Journal of
the Royal Statistical Society: Series B (Statistical Methodology)</em>, <b>62(2)</b>, 271&ndash;292.
</p>
<p>lacf estimation without trend: Nason, G. P. (2013). A test for second-order stationarity and approximate
confidence intervals for localized autocovariances for locally stationary
time series. <em>Journal of the Royal Statistical Society: Series B
(Statistical Methodology)</em>, <b>75(5)</b>, 879&ndash;904.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLSW">TLSW</a></code>,<code><a href="#topic+TLSWsim">TLSWsim</a></code>,<code><a href="#topic+plot.TLSW">plot.TLSW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulates an example time series and estimates its trend and evolutionary wavelet spectrum

spec &lt;- matrix(0, nrow = 9, ncol = 512)
spec[1,] &lt;- 1 + sin(seq(from = 0, to = 2 * pi, length = 512))^2

trend &lt;- seq(from = 0, to = 5, length = 512)

set.seed(1)

x &lt;- TLSWsim(trend = trend, spec = spec)

x.TLSW &lt;- TLSW(x)

summary(x.TLSW)

plot(x.TLSW)
</code></pre>

<hr>
<h2 id='Atau.mat.calc'>Lagged Autocorrelation Wavelet Inner Product Calculation</h2><span id='topic+Atau.mat.calc'></span>

<h3>Description</h3>

<p>Internal function for computing the matrix of lagged autocorrelation wavelet inner
products. This is not intended for general use by regular users of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Atau.mat.calc(J, filter.number = 1, family = "DaubExPhase", lag = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Atau.mat.calc_+3A_j">J</code></td>
<td>
<p>The dimension of the matrix required. Should be a positive integer.</p>
</td></tr>
<tr><td><code id="Atau.mat.calc_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the inner
product matrix.</p>
</td></tr>
<tr><td><code id="Atau.mat.calc_+3A_family">family</code></td>
<td>
<p>The family of wavelet used to compute the inner product
matrix.</p>
</td></tr>
<tr><td><code id="Atau.mat.calc_+3A_lag">lag</code></td>
<td>
<p>The lag of matrix to calculate. A lag of 0 corresponds to the
matrix <code class="reqn">A</code> defined in Nason et al. (2000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the lagged inner product matrix of the discrete
non-decimated autocorrelation wavelets. This matrix is used in the
calculation to correct the wavelet periodogram of the differenced time
series. With <code>lag</code> <code class="reqn">= \tau</code>, the matrix returned is the matrix <code class="reqn">A^\tau</code> in McGonigle et al. (2022).
</p>


<h3>Value</h3>

<p>A J-dimensional square matrix giving the lagged inner product
autocorrelation wavelet matrix.
</p>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Modelling
time-varying first and second-order structure of time series via wavelets
and differencing. <em>Electronic Journal of Statistics</em>, 6(2), 4398-4448.
</p>
<p>Nason, G. P., von Sachs, R., and Kroisandt, G. (2000). Wavelet processes and
adaptive estimation of the evolutionary wavelet spectrum. <em>Journal of
the Royal Statistical Society: Series B (Statistical Methodology)</em>, <b>62(2)</b>, 271&ndash;292.
</p>


<h3>See Also</h3>

<p><a href="#topic+TLSW">TLSW</a>
</p>

<hr>
<h2 id='celegensbio'>
Bioluminescence of C. Elegens
</h2><span id='topic+celegensbio'></span>

<h3>Description</h3>

<p>This dataset gives the time series of bioluminescence of an experiment monitoring C. Elegens as they feed and forage.  The observations are taken 6-minutes apart with no missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>celegensbio
</code></pre>


<h3>Format</h3>

<p>A vector of length 623.
</p>


<h3>Source</h3>

<p>Experiment from Alexandre Benedetto's research group at Lancaster University.</p>

<hr>
<h2 id='Cmat.calc'>Cross Autocorrelation Wavelet Inner Product Matrix Calculation</h2><span id='topic+Cmat.calc'></span>

<h3>Description</h3>

<p>Internal function to compute the cross autocorrelation matrix of inner products.
This is not intended for general use by regular users of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cmat.calc(
  J,
  gen.filter.number = 1,
  an.filter.number = 1,
  gen.family = "DaubExPhase",
  an.family = "DaubExPhase"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cmat.calc_+3A_j">J</code></td>
<td>
<p>The dimension of the matrix required. Should be a positive integer.</p>
</td></tr>
<tr><td><code id="Cmat.calc_+3A_gen.filter.number">gen.filter.number</code></td>
<td>
<p>The index of the generating wavelet used to compute
the inner product matrix.</p>
</td></tr>
<tr><td><code id="Cmat.calc_+3A_an.filter.number">an.filter.number</code></td>
<td>
<p>The index of the analysing wavelet used to compute
the inner product matrix.</p>
</td></tr>
<tr><td><code id="Cmat.calc_+3A_gen.family">gen.family</code></td>
<td>
<p>The family of generating wavelet used to compute the inner
product matrix.</p>
</td></tr>
<tr><td><code id="Cmat.calc_+3A_an.family">an.family</code></td>
<td>
<p>The family of analysing wavelet used to compute the inner
product matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the cross inner product matrix of the discrete
non-decimated autocorrelation wavelets. This matrix is used to correct the
wavelet periodogram analysed using a different wavelet to the wavelet that
is assumed to generate the time series. The matrix returned is the one
denoted <code class="reqn">C^{(0,1)}</code> in McGonigle et al. (2022).
</p>


<h3>Value</h3>

<p>A J-dimensional square matrix giving the cross inner product
autocorrelation wavelet matrix.
</p>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>


<h3>See Also</h3>

<p><a href="#topic+TLSW">TLSW</a>
</p>

<hr>
<h2 id='ewspec.diff'>Estimation of Evolutionary Wavelet Spectrum of Non-Zero Mean Time
Series via Differencing</h2><span id='topic+ewspec.diff'></span>

<h3>Description</h3>

<p>Internal function to estimate the evolutionary wavelet spectrum (EWS) of
a time series that may include a trend component. The estimate is computed
by taking the non-decimated wavelet transform of the first differenced time
series data, squaring it; smoothing using a running mean and then correcting
for bias using the appropriate correction matrix. Inherits the smoothing
functionality from the <code>ewspec3</code> function in the R package <code>locits</code>.
This function is not intended for general use by regular users of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewspec.diff(
  x,
  lag = 1,
  filter.number = 4,
  family = "DaubExPhase",
  binwidth = floor(2 * sqrt(length(x))),
  diff.number = 1,
  max.scale = floor(log2(length(x)) * 0.7),
  S.smooth = TRUE,
  smooth.type = "epan",
  boundary.handle = FALSE,
  AutoReflect = FALSE,
  supply.inv.mat = FALSE,
  inv.mat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewspec.diff_+3A_x">x</code></td>
<td>
<p>The time series you wish to analyse.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_lag">lag</code></td>
<td>
<p>An integer indicating which lag to use for differencing.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_filter.number">filter.number</code></td>
<td>
<p>The index number for the wavelet used to analyse the
time series. For the &quot;DaubExPhase&quot; family, the filter number can be between
1 to 10. For the &quot;DaubLeAsymm&quot; family, the filter number can be between 4 to
10.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_family">family</code></td>
<td>
<p>The family of the wavelet used. It is recommended to use
either the Daubechies Extremal Phase family, or the Daubechies Least
Asymmetric family, corresponding to the &quot;DaubExPhase&quot; or the &quot;DaubLeAsymm&quot;
options.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_binwidth">binwidth</code></td>
<td>
<p>The bin width of the running mean smoother used to smooth
the raw wavelet periodogram.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_diff.number">diff.number</code></td>
<td>
<p>The number of differences used to remove the trend of the
series. A first difference is recommended as default.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_max.scale">max.scale</code></td>
<td>
<p>The coarsest level to which the time series is analysed to.
Should be a positive integer less than <code class="reqn">J</code>, where <code class="reqn">T=2^J</code> is the length of the
time series. The default setting is <code class="reqn">0.7J</code>, to control for bias.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_s.smooth">S.smooth</code></td>
<td>
<p>Argument that dictates if smoothing is performed on the raw
wavelet periodogram.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_smooth.type">smooth.type</code></td>
<td>
<p>String indicating which type of smoothing to use on wavelet periodogram.
Can be <code>"mean"</code>, <code>"median"</code>, or <code>"epan"</code>. Default is <code>"epan"</code>.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_boundary.handle">boundary.handle</code></td>
<td>
<p>Logical variable, if TRUE, then boundary handling
will be applied when computing the periodogram. Recommended to set as FALSE,
will be set as TRUE automatically if non-dyadic data is used.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_autoreflect">AutoReflect</code></td>
<td>
<p>As in <code>wavethresh</code>. Decides whether or not the time series
is reflected when computing the wavelet transform. Strongly recommended to
leave as FALSE.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_supply.inv.mat">supply.inv.mat</code></td>
<td>
<p>Not intended for general use. If TRUE, user must supply the
appropriate correction matrix.</p>
</td></tr>
<tr><td><code id="ewspec.diff_+3A_inv.mat">inv.mat</code></td>
<td>
<p>Not intended for general use. If supply.mat is TRUE, user must supply the
appropriate correction matrix used to correct the raw wavelet periodogram.
Equal to <code class="reqn">(2A-2A_1)^{-1}</code> for first differences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes an estimate of the evolutionary wavelet spectrum of a
time series that displays nonstationary mean and autocovariance. The
estimation procedure is as follows:
</p>
<p>1. The time series is differenced to remove the trend.
</p>
<p>2. The squared modulus of the non-decimated wavelet transform is computed,
known as the raw wavelet periodogram. This is returned by the function.
</p>
<p>3. The raw wavelet periodogram is smoothed using a running mean smoother.
</p>
<p>4. The smoothed periodogram is bias corrected using the inverse of the bias
matrix.
</p>
<p>The final estimate, stored in the S component, can be plotted using the plot
function, please see the example below.
</p>


<h3>Value</h3>

<p>A list object, containing the following fields:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>The evolutionary wavelet spectral estimate of the input data. This object is of
class wd and so can be plotted and printed in the usual way using wavethresh
functionality. </p>
</td></tr>
<tr><td><code>WavPer</code></td>
<td>
<p> The raw wavelet periodogram of the input
data. The EWS estimate (above) is the smoothed corrected version of the
wavelet periodogram.</p>
</td></tr>
<tr><td><code>SmoothWavPer</code></td>
<td>
<p> The smoothed, un-corrected raw
wavelet periodogram of the input data. </p>
</td></tr>
<tr><td><code>max.scale</code>, <code>boundary.handle</code>, <code>S.smooth</code>, <code>smooth.type</code>, <code>binwidth</code>, <code>lag</code>, <code>diff.number</code></td>
<td>
<p>Input parameters</p>
</td></tr>
</table>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Modelling
time-varying first and second-order structure of time series via wavelets
and differencing. <em>Electronic Journal of Statistics</em>, 6(2), 4398-4448.
wavethresh::plot.wd(spec.est$S)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLSW">TLSW</a></code>, <code><a href="locits.html#topic+ewspec3">ewspec3</a></code>
</p>

<hr>
<h2 id='ewspec.trend'>Estimation of Evolutionary Wavelet Spectrum for Non-Zero Mean Time Series</h2><span id='topic+ewspec.trend'></span>

<h3>Description</h3>

<p>Internal function to compute the evolutionary wavelet spectrum (EWS) estimate from
a time series that may include a trend component. The estimate is computed
by taking the non-decimated wavelet transform of the time series data,
squaring it, smoothing using a running mean, and then correction for bias
using the appropriate correction matrix.
This function is not intended for general use by regular users of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewspec.trend(
  x,
  an.filter.number = 4,
  an.family = "DaubExPhase",
  gen.filter.number = an.filter.number,
  gen.family = an.family,
  binwidth = floor(2 * sqrt(length(x))),
  max.scale = floor(log2(length(x)) * 0.7),
  S.smooth = TRUE,
  smooth.type = "epan",
  AutoReflect = TRUE,
  supply.inv.mat = FALSE,
  inv.mat = NULL,
  boundary.handle = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewspec.trend_+3A_x">x</code></td>
<td>
<p>The time series you wish to analyse.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_an.filter.number">an.filter.number</code></td>
<td>
<p>The index number for the wavelet used to analyse the
time series. For the &quot;DaubExPhase&quot; family, the filter number can be between
1 to 10. For the &quot;DaubLeAsymm&quot; family, the filter number can be between 4 to
10. Similarly for gen.filter.number.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_an.family">an.family</code></td>
<td>
<p>The family of the analysing wavelet. It is recommended to
use either the Daubechies Extremal Phase family, or the Daubechies Least
Asymmetric family, corresponding to the &quot;DaubExPhase&quot; or the &quot;DaubLeAsymm&quot;
options. Similarly for gen.family.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_gen.filter.number">gen.filter.number</code></td>
<td>
<p>The index number for the wavelet that generates the
stochastic component of the time series.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_gen.family">gen.family</code></td>
<td>
<p>The family of the generating wavelet.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_binwidth">binwidth</code></td>
<td>
<p>The bin width of the running mean smoother used to smooth
the raw wavelet periodogram.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_max.scale">max.scale</code></td>
<td>
<p>The coarsest level to which the time series is analysed to.
Should be a positive integer less than J, where T=2^J is the length of the
time series. The default setting is 0.7J, to control for bias from the trend
and boundary effects.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_s.smooth">S.smooth</code></td>
<td>
<p>Argument that dictates if smoothing is performed on the raw
wavelet periodogram.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_smooth.type">smooth.type</code></td>
<td>
<p>String indicating which type of smoothing to use on wavelet periodogram.
Can be <code>"mean"</code>, <code>"median"</code>, or <code>"epan"</code>. Default is <code>"epan"</code>.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_autoreflect">AutoReflect</code></td>
<td>
<p>As in wavethresh. Decides whether or not the time series
is reflected when computing the wavelet transform. Helps estimation at the
boundaries.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_supply.inv.mat">supply.inv.mat</code></td>
<td>
<p>Not intended for general use. If TRUE, user must supply the
appropriate correction matrix</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_inv.mat">inv.mat</code></td>
<td>
<p>If supply.mat is TRUE, user must supply the appropriate
correction matrix used to correct the raw wavelet periodogram. Equal to <code class="reqn">C^{-1}</code>.</p>
</td></tr>
<tr><td><code id="ewspec.trend_+3A_boundary.handle">boundary.handle</code></td>
<td>
<p>Logical variable, if TRUE, the time series is
boundary corrected, to get a more accurate spectrum estimate at the
boundaries of the times series. If FALSE, no boundary correction is applied.
Recommended to use TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the evolutionary wavelet spectrum of a
time series that displays a smooth mean and nonstationary autocovariance.
The estimation procedure is as follows:
</p>
<p>1. The squared modulus of the non-decimated wavelet transform is computed,
known as the raw wavelet periodogram. This is returned by the function.
</p>
<p>2. The raw wavelet periodogram is smoothed using a running mean smoother.
</p>
<p>3. The smoothed periodogram is bias corrected using the inverse of the bias
matrix. The correction is applied across the finest max.scale scales. If the
analysing wavelet and generating wavelet are different, this is given by the
inverse of the <code class="reqn">C</code> matrix defined in McGonigle et al. (2022). If they are the
same, this is the inverse of the <code class="reqn">A</code> matrix, defined in Nason et al. (2000).
If you are unsure on the filter and wavelet choices, it is recommended to
use the same wavelet for generating and analysing purposes.
</p>
<p>The final estimate, stored in the S component, can be plotted using the plot
function, please see the example below.
</p>


<h3>Value</h3>

<p>A list object, containing the following fields:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>The evolutionary wavelet spectral estimate of the input data. This object is of
class wd and so can be plotted and printed in the usual way using wavethresh
functionality. </p>
</td></tr>
<tr><td><code>WavPer</code></td>
<td>
<p> The raw wavelet periodogram of the input
data. The EWS estimate (above) is the smoothed corrected version of the raw
wavelet periodogram.</p>
</td></tr>
<tr><td><code>SmoothWavPer</code></td>
<td>
<p> The smoothed, un-corrected raw
wavelet periodogram of the input data. </p>
</td></tr>
<tr><td><code>max.scale</code>, <code>boundary.handle</code>, <code>S.smooth</code>, <code>smooth.type</code>, <code>binwidth</code></td>
<td>
<p>Input parameters</p>
</td></tr>
</table>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>
<p>Nason, G. P., von Sachs, R., and Kroisandt, G. (2000). Wavelet processes and
adaptive estimation of the evolutionary wavelet spectrum. <em>Journal of
the Royal Statistical Society: Series B (Statistical Methodology)</em>, <b>62(2)</b>, 271&ndash;292.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLSW">TLSW</a></code>, <code><a href="wavethresh.html#topic+wd">wd</a></code>
</p>

<hr>
<h2 id='get.boundary.timeseries'>Calculate Boundary Extended Time Series</h2><span id='topic+get.boundary.timeseries'></span>

<h3>Description</h3>

<p>Internal function to calculate the boundary extended time series, to be used within
the <code><a href="#topic+TLSW">TLSW</a></code> function. Not recommended for general usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.boundary.timeseries(x, type = "TLSW")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.boundary.timeseries_+3A_x">x</code></td>
<td>
<p>The time series used to calculate the boundary extended version.</p>
</td></tr>
<tr><td><code id="get.boundary.timeseries_+3A_type">type</code></td>
<td>
<p>The type of boundary handling used. Either <code>"TLSW"</code> (default) for boundary
handling as described in McGonigle, E. T., Killick, R., and Nunes, M. (2022a),
or <code>"LSW.diff"</code> for a periodic version of this, used for the differencing-based functions
as described in McGonigle, E. T., Killick, R., and Nunes, M. (2022b).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 4 times the length of the input vector.
</p>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022a). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>
<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022b). Modelling
time-varying first and second-order structure of time series via wavelets
and differencing. <em>Electronic Journal of Statistics</em>, 6(2), 4398-4448.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLSW">TLSW</a></code>
</p>

<hr>
<h2 id='plot.TLSW'>Plot Trend and/or Spectrum Information in a <code>TLSW</code> Object</h2><span id='topic+plot.TLSW'></span>

<h3>Description</h3>

<p>Plots information contained within a <code>TLSW</code> object.
Depending on the <code>plot.type</code> option this will produce a plot of the data
with trend estimate overlayed, a plot of the spectral estimate, or both (default).
If the <code>TLSW</code> object does not contain trend or spectral estimates and these are requested
a warning will be given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TLSW'
plot(
  x,
  plot.type = c("trend", "spec"),
  trend.plot.args,
  spec.plot.args,
  plot.CI = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.TLSW_+3A_x">x</code></td>
<td>
<p>A <code>TLSW</code> object</p>
</td></tr>
<tr><td><code id="plot.TLSW_+3A_plot.type">plot.type</code></td>
<td>
<p>A string object indicating what is to be plotted. Can be:
</p>

<ul>
<li> <p><code>"trend"</code>: will plot the trend estimate only.
</p>
</li>
<li> <p><code>"spec"</code>: will plot the spectral estimate only.
</p>
</li>
<li> <p><code>c("trend", "spec")</code>: the default value will plot both the trend and spectral estimate.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.TLSW_+3A_trend.plot.args">trend.plot.args</code></td>
<td>
<p>A list object, that includes any choices for the graphical parameters used for plotting the trend estimate.</p>
</td></tr>
<tr><td><code id="plot.TLSW_+3A_spec.plot.args">spec.plot.args</code></td>
<td>
<p>A list object, that includes any choices for the graphical parameters used for plotting the spectral estimate.</p>
</td></tr>
<tr><td><code id="plot.TLSW_+3A_plot.ci">plot.CI</code></td>
<td>
<p>A logical variable. If TRUE, the confidence interval of the trend estimate (if computed) will be included in the plot.</p>
</td></tr>
<tr><td><code id="plot.TLSW_+3A_...">...</code></td>
<td>
<p>Any additional arguments that will be applied to the graphical parameters of both the trend and spectrum plotting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A TLSW object can be plotted using the standard <code>plot</code> function in R to display the
estimated trend function and wavelet spectrum. The estimated trend is visualised using
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>. Visualisation of the estimated spectrum is
based on <code><a href="wavethresh.html#topic+plot.wd">plot.wd</a></code>, for which credit belongs to Guy Nason.
Graphical parameters for customising the display of the trend or spectrum plots should be given
to the <code>trend.plot.args</code> and <code>spec.plot.args</code> arguments respectively.
For graphical parameters for the trend plot:
</p>

<ul>
<li><p> Parameters related to the overall plot should be provided as they usually would be when using the <code>plot</code> function,
in the <code>trend.plot.args</code> list object. For example, to change the title of the plot to &quot;Plot&quot;, use <code>main = "Plot"</code>.
</p>
</li>
<li><p> Parameters affecting the display of the estimated trend line should begin with the
prefix <code>"T."</code>. For example, to set the colour of the trend line to blue, use
<code>T.col = "blue"</code>.
</p>
</li>
<li><p> Parameters affecting the display of the confidence interval lines should begin with the
prefix <code>"CI."</code>. For example, to set the line width of the confidence interval to 2, use
<code>CI.lwd = 2</code>.
</p>
</li>
<li><p> Parameters affecting the display of the polygon drawn by the confidence interval
should begin with the prefix <code>"poly."</code>. For example, to set the colour of the
confidence interval region to green, use <code>poly.col = "green"</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Modelling
time-varying first and second-order structure of time series via wavelets
and differencing. <em>Electronic Journal of Statistics</em>, 6(2), 4398-4448.
</p>
<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLSW">TLSW</a></code>, <code><a href="#topic+summary.TLSW">summary.TLSW</a></code>, <code><a href="#topic+print.TLSW">print.TLSW</a></code>, <code><a href="wavethresh.html#topic+plot.wd">plot.wd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulates an example time series and estimates its trend and evolutionary wavelet spectrum.
# Then plots both estimates.

spec &lt;- matrix(0, nrow = 9, ncol = 512)

spec[1, ] &lt;- 4 + 4 * sin(seq(from = 0, to = 2 * pi, length = 512))^2

trend &lt;- seq(from = 0, to = 10, length = 512) + 2 * sin(seq(from = 0, to = 2 * pi, length = 512))

set.seed(1)

x &lt;- TLSWsim(trend = trend, spec = spec)

x.TLSW &lt;- TLSW(x)

plot(x.TLSW, trend.plot.args = list(
  ylab = "Simulated Data", T.col = 4,
  T.lwd = 2, T.lty = 2
))

</code></pre>

<hr>
<h2 id='print.TLSW'>Print an Object of Class <code>TLSW</code></h2><span id='topic+print.TLSW'></span>

<h3>Description</h3>

<p>Prints a <code>TLSW</code> object, alongside summary information.
The first part prints details of the class, specifically the names of elements within.
Then prints out the summary, which gives information about a <code>TLSW</code> object. If spectral
estimation was performed, then the type of smoothing and binwidth is printed,
along with the differencing performed if it is used, the maximum wavelet
scale analysed, and whether or not boundary handling was used. If trend
estimation is performed, then the type of wavelet thresholding and transform
used is printed, as well as the maximum wavelet scale used, whether or not boundary handling was used,
and the significance of the confidence interval if it was calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TLSW'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TLSW_+3A_x">x</code></td>
<td>
<p>A <code>TLSW</code> object.</p>
</td></tr>
<tr><td><code id="print.TLSW_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Modelling
time-varying first and second-order structure of time series via wavelets
and differencing. <em>Electronic Journal of Statistics</em>, 6(2), 4398-4448.
</p>
<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLSW">TLSW</a></code>, <code><a href="#topic+summary.TLSW">summary.TLSW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulates an example time series and estimates its trend and evolutionary wavelet spectrum

spec &lt;- wavethresh::cns(512)
spec &lt;- wavethresh::putD(spec, level = 8, 1 + sin(seq(from = 0, to = 2 * pi, length = 512))^2)

trend &lt;- seq(from = 0, to = 5, length = 512)

set.seed(1)

x &lt;- TLSWsim(trend = trend, spec = spec)

x.TLSW &lt;- TLSW(x)

print(x.TLSW)

</code></pre>

<hr>
<h2 id='summary.TLSW'>Summary of Output Provided by the <code>TLSW</code> Function</h2><span id='topic+summary.TLSW'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>TLSW</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TLSW'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.TLSW_+3A_object">object</code></td>
<td>
<p>A <code>TLSW</code> object.</p>
</td></tr>
<tr><td><code id="summary.TLSW_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out information about a <code>TLSW</code> object. If spectral
estimation was performed, then the type of smoothing and binwidth is printed,
along with the differencing performed if it is used, the maximum wavelet
scale analysed, and whether or not boundary handling was used. If trend
estimation is performed, then the type of wavelet thresholding and transform
used is printed, as well as the maximum wavelet scale used, whether or not boundary handling was used,
and the significance of the confidence interval if it was calculated.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Modelling
time-varying first and second-order structure of time series via wavelets
and differencing. <em>Electronic Journal of Statistics</em>, 6(2), 4398-4448.
</p>
<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLSW">TLSW</a></code>, <code><a href="#topic+print.TLSW">print.TLSW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulates an example time series and estimates its trend and evolutionary wavelet spectrum

spec &lt;- matrix(0, nrow = 10, ncol = 2^10)

spec[1, ] &lt;- seq(from = 1, to = 10, length = 1024)

trend &lt;- sin(pi * (seq(from = 0, to = 4, length = 1024)))

set.seed(1)

x &lt;- TLSWsim(trend = trend, spec = spec)

x.TLSW &lt;- TLSW(x)

summary(x.TLSW)

</code></pre>

<hr>
<h2 id='TLSW'>Estimate Trend and Spectrum of Trend Locally Stationary Wavelet Process</h2><span id='topic+TLSW'></span>

<h3>Description</h3>

<p>Using wavelet-based methods, this function estimates the trend and evolutionary
wavelet spectrum (EWS) of a nonstationary time series.
</p>
<p>Two methods are implemented (see references), the direct estimator (<code>T.est.type="linear"</code> and
<code>S.do.diff=FALSE</code>), and the difference estimator (<code>T.est.type="nonlinear"</code>) and <code>S.do.diff=TRUE</code>)
The defaults give the direct estimator.
</p>
<p>All the defaults are set carefully.  Key times to change defaults are
</p>

<ul>
<li><p> if the data contains &quot;cusps&quot;, then the difference estimator is preferred.
</p>
</li>
<li><p> to assess stability of the estimate to the wavelet, change the wavelet number <code>T.filter.number</code> and
<code>S.filter.number</code> and/or the wavelet type <code>T.family</code> and <code>S.family</code>, see details.
</p>
</li></ul>

<p>The arguments affecting trend are preceded by <code>T.</code> and those affecting spectral estimation are preceded
by <code>S.</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TLSW(
  x,
  do.trend.est = TRUE,
  do.spec.est = TRUE,
  T.est.type = "linear",
  T.filter.number = 4,
  T.family = "DaubExPhase",
  T.transform = "nondec",
  T.boundary.handle = TRUE,
  T.max.scale = floor(log2(length(x)) * 0.7),
  T.thresh.type = "hard",
  T.thresh.normal = TRUE,
  T.CI = FALSE,
  T.sig.lvl = 0.05,
  T.reps = 200,
  T.CI.type = "normal",
  T.lacf.max.lag = floor(10 * (log10(length(x)))),
  S.filter.number = 4,
  S.family = "DaubExPhase",
  S.smooth = TRUE,
  S.smooth.type = "mean",
  S.binwidth = floor(6 * sqrt(length(x))),
  S.max.scale = floor(log2(length(x)) * 0.7),
  S.boundary.handle = TRUE,
  S.inv.mat = NULL,
  S.do.diff = FALSE,
  S.lag = 1,
  S.diff.number = 1,
  gen.filter.number = S.filter.number,
  gen.family = S.family
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TLSW_+3A_x">x</code></td>
<td>
<p>The time series you wish to analyse.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_do.trend.est">do.trend.est</code></td>
<td>
<p>Logical variable, indicating whether trend estimation is to be performed on the time series.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_do.spec.est">do.spec.est</code></td>
<td>
<p>Logical variable, indicating whether spectral estimation is to be performed on the time series.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.est.type">T.est.type</code></td>
<td>
<p>String indicating type of wavelet thresholding used. Can be <code>"linear"</code> (default), which means
that all non-boundary wavelet coefficients are set to zero, or <code>"nonlinear"</code>, where
each wavelet coefficient is thresholded using a time-varying, noise-dependent threshold.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.filter.number">T.filter.number</code></td>
<td>
<p>The index number for the wavelet used for trend estimation.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.family">T.family</code></td>
<td>
<p>The family of the wavelet used for trend estimation.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.transform">T.transform</code></td>
<td>
<p>String giving the type of wavelet transform used for trend estimation.
Can be <code>"dec"</code>, in which case a standard (decimated) wavelet transform is used, or <code>"nondec"</code> (default),
in which case a nondecimated transform is used.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.boundary.handle">T.boundary.handle</code></td>
<td>
<p>Logical variable, if <code>TRUE</code>, the time series is
boundary corrected when estimating the trend.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.max.scale">T.max.scale</code></td>
<td>
<p>Integer variable, selects the number of scales of the wavelet transform to
apply thresholding to for trend estimation.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.thresh.type">T.thresh.type</code></td>
<td>
<p>String variable, used only if <code>T.est.type = "nonlinear"</code>; the type of
thresholding function used in the trend estimation. Can be
<code>"soft"</code> or <code>"hard"</code> (default).</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.thresh.normal">T.thresh.normal</code></td>
<td>
<p>Logical variable, used only if <code>T.est.type = "nonlinear"</code>;
if <code>TRUE</code>, uses a threshold assuming the data are normally
distributed. If <code>FALSE</code>, uses a larger threshold to reflect non-normality.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.ci">T.CI</code></td>
<td>
<p>Logical variable. If <code>TRUE</code>, a <code>(1-T.sig.lvl)</code> pointwise confidence interval is
computed for the trend estimate. When <code>T.transform = "dec"</code> and <code>T.est.type = "linear"</code>, this is
computed using the asymptotic distribution of the trend estimator.
Otherwise, it is computed via bootstrapping.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.sig.lvl">T.sig.lvl</code></td>
<td>
<p>Used only if <code>T.CI = TRUE</code>; a numeric value
(<code>0 &lt;= T.sig.lvl &lt;= 1</code>) with which a <code>(1-T.sig.lvl)</code> pointwise
confidence interval for the trend estimate is generated.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.reps">T.reps</code></td>
<td>
<p>Used only if <code>T.transform = "nondec"</code> and  <code>T.CI = TRUE</code>; the number of bootstrap
replications used to calculate the confidence interval.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.ci.type">T.CI.type</code></td>
<td>
<p>Used only if <code>T.transform = "nondec"</code> and <code>T.CI = TRUE</code>; the type of confidence
interval computed. Can be <code>"percentile"</code>, in which case empirical percentiles are used, or
<code>"normal"</code> (default), in which case the (symmetric) normal approximation is used.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_t.lacf.max.lag">T.lacf.max.lag</code></td>
<td>
<p>Used only if <code>T.est.type = "linear"</code> and  <code>T.CI = TRUE</code>;
the maximum lag of the autocovariance to compute needed for calculating the asymptotic confidence interval.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.filter.number">S.filter.number</code></td>
<td>
<p>The index number for the wavelet used for spectrum estimation.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.family">S.family</code></td>
<td>
<p>The family of the wavelet used for spectrum estimation.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.smooth">S.smooth</code></td>
<td>
<p>A logical variable to indicate whether smoothing is performed on the wavelet periodogram.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.smooth.type">S.smooth.type</code></td>
<td>
<p>String indicating which type of smoothing to use on wavelet periodogram.
Can be one of
</p>

<ul>
<li><p><code>"mean"</code>: (default) running mean smoother.
</p>
</li>
<li> <p><code>"median"</code>: running median smoother.
</p>
</li>
<li><p><code>"epan"</code>: Epanechnikov kernel smoother.
</p>
</li></ul>
</td></tr>
<tr><td><code id="TLSW_+3A_s.binwidth">S.binwidth</code></td>
<td>
<p>The bin width of the smoother used to smooth
the raw wavelet periodogram.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.max.scale">S.max.scale</code></td>
<td>
<p>The coarsest wavelet scale used to estimate the spectrum.
Should be a positive integer less than <code class="reqn">J</code>, where <code class="reqn">n=2^J</code> is the length of the
time series.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.boundary.handle">S.boundary.handle</code></td>
<td>
<p>Logical variable, if TRUE, the time series is
boundary corrected, to get a more accurate spectrum estimate at the
boundaries of the times series. If FALSE, no boundary correction is applied.
Recommended to use TRUE.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.inv.mat">S.inv.mat</code></td>
<td>
<p>The user can pre-calculate and supply the appropriate
correction matrix used to correct the raw wavelet periodogram. If left blank,
then the correction matrix is calculated when performing spectral estimation.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.do.diff">S.do.diff</code></td>
<td>
<p>Logical variable, indicating if the time series is to be
differenced before spectral estimation is performed.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.lag">S.lag</code></td>
<td>
<p>The lag of differencing used, only applicable if <code>S.do.dif = TRUE</code>.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_s.diff.number">S.diff.number</code></td>
<td>
<p>The number of differencing operations performed,
only applicable if <code>S.do.diff = TRUE</code>. A first difference is strongly recommended as default.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_gen.filter.number">gen.filter.number</code></td>
<td>
<p>The index number for the wavelet that generates the
stochastic component of the time series. For the &quot;DaubExPhase&quot; family, the filter number can be between
1 to 10. For the &quot;DaubLeAsymm&quot; family, the filter number can be between 4 to 10.
Recommended to leave as the default, set to the same as <code>S.filter.number</code>.</p>
</td></tr>
<tr><td><code id="TLSW_+3A_gen.family">gen.family</code></td>
<td>
<p>The family of the generating wavelet. It is recommended to
use either the Daubechies Extremal Phase family, or the Daubechies Least
Asymmetric family, corresponding to the &quot;DaubExPhase&quot; or the &quot;DaubLeAsymm&quot;
options. Recommended to leave as the default, set to the same as <code>S.family</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitted <em>trend LSW process</em> <code class="reqn">X_{t,n} </code>, <code class="reqn">t = 0, \ldots , n-1</code>, and <code class="reqn">n = 2^J</code> is
a doubly-indexed stochastic process with the following representation in the mean square sense:
</p>
<p style="text-align: center;"><code class="reqn">X_{t} = T_t + \varepsilon_t = T_t + \sum_{j = 1}^{\infty} \sum_{k \in \mathbb{Z}} w_{j,k;n} \psi_{j,k} (t) \xi_{j,k} ,</code>
</p>

<p>where <code class="reqn">\{\xi_{j,k} \}</code> is a random, uncorrelated, zero-mean orthonormal increment sequence,
<code class="reqn">\{w_{j,k;n} \}</code> is a set of amplitudes, and <code class="reqn">\{\psi_{j, k} \}_{j,k}</code> is a set of discrete
non-decimated wavelets.  The trend component <code class="reqn">T_t := T(t/n)</code> is assumed to be a general smooth (Holder)
continuous function. See the referenced papers for full details of the model.
The key considerations for users are:
</p>

<ul>
<li><p> The model assumes smooth trend and spectral components.  The larger the <code>T.filter.number</code>
the smoother the assumption on the underlying trend and similarly for <code>S.filter.number</code> and the
spectral estimate.
</p>
</li>
<li><p> The choice of wavelet (smoothness assumption) does affect the estimation so one should check the
robustness of their conclusions to the choice of wavelet (<code>T.filter.number</code> and <code>S.filter.number</code>).
This is akin to selecting the kernel in nonparametric modelling.
</p>
</li>
<li><p> The underlying methods are designed for signals of length <code class="reqn">n=2^J</code> and so modifications
are made to signals which are not of this form.  A natural approach is to extend the data (at both ends)
and the default approach does this by reflection with a trend correction to avoid discontinuities.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"TLSW"</code>, a list that contains the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code>do.spec.est</code></td>
<td>
<p>Input parameter, logical variable specifying if spectral estimation was performed.</p>
</td></tr>
<tr><td><code>spec.est</code></td>
<td>
<p>A list object, returned if <code>do.spec.est = TRUE</code>. Contains relevant input parameters
and the following fields related to the spectrum estimate:
</p>

<ul>
<li> <p><code>S</code>: The evolutionary wavelet spectral (smoothed and corrected) estimate of the input data. This object is of
class wd and so can be plotted and printed in the usual way using wavethresh
functionality.
</p>
</li>
<li> <p><code>WavPer</code>: The raw wavelet periodogram of the input
data. The EWS estimate (S, above) is the smoothed corrected version of this raw
wavelet periodogram.
</p>
</li>
<li> <p><code>SmoothWavPer</code>: The smoothed, but uncorrected raw
wavelet periodogram of the input data.
</p>
</li></ul>

</td></tr>
<tr><td><code>do.trend.est</code></td>
<td>
<p>Input parameter, logical variable specifying if trend estimation was performed.</p>
</td></tr>
<tr><td><code>trend.est</code></td>
<td>
<p>A list object, returned if <code>do.trend.est = TRUE</code>. Contains relevant input parameters
and the following fields related to the trend estimate:
</p>

<ul>
<li> <p><code>T</code>: A vector of length <code>length(x)</code> containing the trend estimate.
</p>
</li>
<li> <p><code>lower.CI</code>: Returned if <code>T.CI = TRUE</code>. The lower limit of the pointwise confidence interval.
</p>
</li>
<li> <p><code>upper.CI</code>: Returned if <code>T.CI = TRUE</code>. The upper limit of the pointwise confidence interval.
</p>
</li></ul>
</td></tr>
</table>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022a). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>
<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022b). Modelling
time-varying first and second-order structure of time series via wavelets
and differencing. <em>Electronic Journal of Statistics</em>, 6(2), 4398-4448.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.TLSW">plot.TLSW</a></code>, <code><a href="#topic+summary.TLSW">summary.TLSW</a></code>, <code><a href="#topic+print.TLSW">print.TLSW</a></code>, <code><a href="wavethresh.html#topic+wd">wd</a></code>, <code><a href="locits.html#topic+ewspec3">ewspec3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulates an example time series and estimates its trend and evolutionary wavelet spectrum

spec &lt;- matrix(0, nrow = 10, ncol = 2^10)

spec[1, ] &lt;- seq(from = 1, to = 10, length = 1024)

trend &lt;- sin(pi * (seq(from = 0, to = 4, length = 1024)))

set.seed(1)

x &lt;- TLSWsim(trend = trend, spec = spec)

plot.ts(x)

x.TLSW &lt;- TLSW(x)

summary(x.TLSW)

plot(x.TLSW) # by default plots both the trend and spectrum estimates

</code></pre>

<hr>
<h2 id='TLSWlacf'>Compute Localised Autocovariance Estimate of a TLSW Object</h2><span id='topic+TLSWlacf'></span>

<h3>Description</h3>

<p>Computes the local autocovariance and autocorrelation estimates, given an
input of an object of class TLSW containing the estimated spectrum. Provides the same functionality as the
function <code>lacf</code> from the <code>locits</code> package, but user provides an object of
class <code>TLSW</code> as the main argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TLSWlacf(x.TLSW, lag.max = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TLSWlacf_+3A_x.tlsw">x.TLSW</code></td>
<td>
<p>a <code>TLSW</code> object.</p>
</td></tr>
<tr><td><code id="TLSWlacf_+3A_lag.max">lag.max</code></td>
<td>
<p>The maximum lag of acf required. If NULL then the same
default as in the regular acf function is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lacf</code> which contains the following components:
</p>

<ul>
<li> <p><code>lacf</code>: a matrix containing the estimate of the local autocovariance. Columns represent lags
(beginning at lag 0), and rows represent time points.
</p>
</li>
<li> <p><code>lacr</code>: a matrix containing the estimate of the local autocorrelation. Columns represent lags
(beginning at lag 0), and rows represent time points.
</p>
</li>
<li> <p><code>name</code>: the name of the time series (if applicable).
</p>
</li>
<li> <p><code>date</code>: the date the function was executed.
</p>
</li>
<li> <p><code>SmoothWP</code>: The smoothed, un-corrected raw
wavelet periodogram of the input data.
</p>
</li>
<li> <p><code>S</code>: the spectral estimate used to compute the local autocovariance.
</p>
</li>
<li> <p><code>J</code>: the number of total wavelet scales.
</p>
</li></ul>



<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>
<p>Nason, G. P. (2013). A test for second-order stationarity and approximate
confidence intervals for localized autocovariances for locally stationary
time series. <em>Journal of the Royal Statistical Society: Series B
(Statistical Methodology)</em>, <b>75(5)</b>, 879&ndash;904.
</p>
<p>Nason, G. P. (2016). locits: Tests of stationarity and localized autocovariance.
R package version 1.7.3.
</p>


<h3>See Also</h3>

<p><code><a href="locits.html#topic+lacf">lacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- computes estimate of local autocovariance function


spec &lt;- matrix(0, nrow = 9, ncol = 512)
spec[2, ] &lt;- 1 + sin(seq(from = 0, to = 2 * pi, length = 512))^2

trend &lt;- seq(from = 0, to = 10, length = 512)

set.seed(123)

x &lt;- TLSWsim(trend = trend, spec = spec)

## ---- first estimate the spectrum:

x.TLSW &lt;- TLSW(x)

#---- estimate the lacf:

lacf.est &lt;- TLSWlacf(x.TLSW)

#---- plot the variance (lag 0 lacf) over time:

plot.ts(lacf.est$lacf[, 1], ylab = "Variance")
</code></pre>

<hr>
<h2 id='TLSWsim'>Simulate Trend Locally Stationary Wavelet Process</h2><span id='topic+TLSWsim'></span>

<h3>Description</h3>

<p>Simulates a trend locally stationary wavelet process with a given trend function
and spectrum. Extends the <code>LSWsim</code> function from the <code>wavethresh</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TLSWsim(
  trend,
  spec,
  filter.number = 4,
  family = "DaubExPhase",
  innov.func,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TLSWsim_+3A_trend">trend</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p>A numeric vector of length <code class="reqn">n</code> giving the values of the deterministic
trend function,
</p>
</li>
<li><p>A real-valued function of one argument defined on rescaled time <code class="reqn">[0,1)</code>.
</p>
</li></ul>

<p>When using a numeric vector for <code>trend</code>, if <code class="reqn">n</code> is not a power of 2 then <code>spec</code> must be specified using
a numeric matrix of dimensions <code class="reqn">\lfloor \log_2 (n) \rfloor \times n</code>.</p>
</td></tr>
<tr><td><code id="TLSWsim_+3A_spec">spec</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p>A <code>wavethresh</code> object of class wd which contains the spectrum for simulating
an LSW process,
</p>
</li>
<li><p>A numeric matrix of dimensions <code class="reqn">J \times n</code>, where the <code class="reqn">j</code>-th row corresponds to the spectrum values at scale <code class="reqn">j</code> and
<code class="reqn">\lfloor \log_2 (n) \rfloor = J</code>,
</p>
</li>
<li><p>A list of length <code class="reqn">J=\log_2(n)</code>, where the <code class="reqn">j</code>-th element of the list is a function of one argument specifying the spectrum
function at scale <code class="reqn">j</code> on rescaled time <code class="reqn">[0,1)</code>.
</p>
</li></ul>

<p>When using a numeric matrix for <code>spec</code>, if <code class="reqn">n</code> is not a power of 2 then <code>trend</code>
must be specified using a numeric vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="TLSWsim_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number for the wavelet used to simulate the LSW process (default 4)</p>
</td></tr>
<tr><td><code id="TLSWsim_+3A_family">family</code></td>
<td>
<p>The family of the wavelet used to simulate the LSW process (default <code>DaubExPhase</code>).</p>
</td></tr>
<tr><td><code id="TLSWsim_+3A_innov.func">innov.func</code></td>
<td>
<p>A function with first argument <code>n</code> used for simulating the innovations. By default,
normal random innovations are sampled using the <code>rnorm</code> function.</p>
</td></tr>
<tr><td><code id="TLSWsim_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the function  <code>innov.func</code> for
sampling the innovation process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">n</code>-length vector containing a TLSW process simulated from the trend and spectral description given by the trend and
spec arguments.
</p>


<h3>See Also</h3>

<p><code><a href="wavethresh.html#topic+LSWsim">LSWsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#---- simulate with numeric trend, and spec a wd object as in wavethresh-----

spec &lt;- wavethresh::cns(1024)

spec &lt;- wavethresh::putD(spec, level = 8, seq(from = 2, to = 8, length = 1024))

trend &lt;- sin(pi * (seq(from = 0, to = 4, length = 1024)))

x &lt;- TLSWsim(trend = trend, spec = spec)

plot.ts(x)

#---- simulate with numeric trend, and spec a matrix, with non-dyadic n-----

spec &lt;- matrix(0, nrow = 9, ncol = 1000)

spec[1, ] &lt;- seq(from = 1, to = 10, length = 1000)

trend &lt;- sin(pi * (seq(from = 0, to = 4, length = 1000)))

x &lt;- TLSWsim(trend = trend, spec = spec)

plot.ts(x)

#---- simulate with functional trend, and spec a list of functions-----

spec &lt;- vector(mode = "list", length = 10)

spec[[1]] &lt;- function(u) {
  1 + 9 * u
}

trend &lt;- function(u) {
  sin(pi * u)
}

x &lt;- TLSWsim(trend = trend, spec = spec)

plot.ts(x)

</code></pre>

<hr>
<h2 id='wav.diff.trend.est'>Wavelet Thresholding Trend Estimation of Time Series</h2><span id='topic+wav.diff.trend.est'></span>

<h3>Description</h3>

<p>Internal function to compute the wavelet thresholding trend estimate for a time
series that may be second-order nonstationary. The function calculates the
wavelet transform of the time series, thresholds the coefficients based on
an estimate of their variance, and inverts to give the trend estimate.
This function is not intended for general use by regular users of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wav.diff.trend.est(
  x,
  spec.est,
  filter.number = 4,
  family = "DaubExPhase",
  thresh.type = "hard",
  normal = TRUE,
  transform.type = "nondec",
  max.scale = floor(0.7 * log2(length(x))),
  boundary.handle = FALSE,
  T.CI = FALSE,
  reps = 199,
  sig.lvl = 0.05,
  confint.type = "normal",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wav.diff.trend.est_+3A_x">x</code></td>
<td>
<p>The time series you want to estimate the trend function of.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_spec.est">spec.est</code></td>
<td>
<p>You must supply the estimate of the evolutionary wavelet
spectrum of the time series. This is the output of the <code>ewspec.diff</code>
function.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_filter.number">filter.number</code></td>
<td>
<p>Selects the index of the wavelet used in the estimation
procedure. For Daubechies compactly supported wavelets the filter number is
the number of vanishing moments.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_family">family</code></td>
<td>
<p>Selects the wavelet family to use. Recommended to only use the
Daubechies compactly supported wavelets DaubExPhase and DaubLeAsymm.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_thresh.type">thresh.type</code></td>
<td>
<p>The type of thresholding function used. Currently only
<code>"soft"</code> and <code>"hard"</code> (default) are available.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_normal">normal</code></td>
<td>
<p>If TRUE, uses a threshold assuming the data are normally
distributed. If FALSE, uses a larger threshold to reflect non-normality.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_transform.type">transform.type</code></td>
<td>
<p>String giving the type of wavelet transform used.
Can be <code>"dec"</code>, in which case a standard (decimated) wavelet transform is used, or <code>"nondec"</code>,
(default) in which case a nondecimated transform is used.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_max.scale">max.scale</code></td>
<td>
<p>Selects the number of scales of the wavelet transform to
apply thresholding to. Should be a value from 1 (finest) to J-1 (coarsest),
where <code class="reqn">n =2^J</code> is the length of the time series. Recommended to use <code class="reqn">0.7 J</code>
scales.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_boundary.handle">boundary.handle</code></td>
<td>
<p>Logical variable, decides if boundary handling should
be applied to the time series before estimation.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_t.ci">T.CI</code></td>
<td>
<p>Logical variable. If <code>TRUE</code>, a bootstrapped <code>(1-sig.lvl)</code>
pointwise confidence interval is computed for the trend estimate.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_reps">reps</code></td>
<td>
<p>Used only if <code>T.CI = TRUE</code>; the number of bootstrap
replications used to calculate the confidence interval.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_sig.lvl">sig.lvl</code></td>
<td>
<p>Used only if <code>T.CI = TRUE</code>; a numeric value
(<code>0 &lt;= sig.lvl &lt;= 1</code>) with which a <code>(1-sig.lvl)</code> pointwise
confidence interval for the trend estimate is generated.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_confint.type">confint.type</code></td>
<td>
<p>Used only if <code>T.CI = TRUE</code>; the type of confidence
interval computed. Can be <code>"percentile"</code>, in which case empirical percentiles are used, or
<code>"normal"</code> (default), in which case the normal approximation is used.</p>
</td></tr>
<tr><td><code id="wav.diff.trend.est_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the <code><a href="#topic+ewspec.diff">ewspec.diff</a></code>
call, only to be used if <code>T.CI = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the trend function of a locally stationary time series, by
incorporating the evolutionary wavelet spectrum estimate in a wavelet
thresholding procedure. To use this function, first compute the spectral
estimate of the time series, using the function ewspec.diff.
</p>
<p>The function works as follows:
</p>
<p>1. The wavelet transform of the time series is calculated.
</p>
<p>2. The wavelet coefficients at scale <code class="reqn">j</code> and location <code class="reqn">k</code> are individually thresholded using the universal
threshold <code class="reqn">\hat{\sigma}_{j,k}\sqrt{2 \log n}</code>, where <code class="reqn">\hat{\sigma}_{j,k}^2</code> is an estimate of their variance. The variance
estimate is calculated using the spectral estimate, supplied by the user in
the <code>spec</code> argument.
</p>
<p>3. The inverse wavelet transform is applied to obtain the final estimate.
</p>


<h3>Value</h3>

<p>A <code>list</code> object containing the following fields:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code>filter.number</code>, <code>family</code></td>
<td>
<p>Input wavelet parameters</p>
</td></tr>
<tr><td><code>transform.type</code>, <code>max.scale</code>, <code>boundary.handle</code>, <code>thresh.type</code>, <code>normal</code>, <code>T.CI</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>A vector of length <code>length(x)</code> containing the trend estimate</p>
</td></tr>
<tr><td><code>lower.CI</code></td>
<td>
<p>Returned if <code>T.CI = TRUE</code>. The lower limit of the pointwise confidence interval</p>
</td></tr>
<tr><td><code>upper.CI</code></td>
<td>
<p>Returned if <code>T.CI = TRUE</code>. The upper limit of the pointwise confidence interval</p>
</td></tr>
<tr><td><code>reps</code></td>
<td>
<p>Returned if <code>T.CI = TRUE</code>. The number of bootstrap replicates used to compute
pointwise confidence interval</p>
</td></tr>
<tr><td><code>sig.lvl</code></td>
<td>
<p>Returned if <code>T.CI = TRUE</code>. The significance level of the pointwise confidence interval</p>
</td></tr>
</table>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Modelling
time-varying first and second-order structure of time series via wavelets
and differencing. <em>Electronic Journal of Statistics</em>, 6(2), 4398-4448.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLSW">TLSW</a></code>
</p>

<hr>
<h2 id='wav.trend.est'>Linear Wavelet Thresholding Trend Estimation of Time Series</h2><span id='topic+wav.trend.est'></span>

<h3>Description</h3>

<p>Internal function to compute the linear wavelet thresholding trend estimate for a
time series that may be second-order nonstationary. The function calculates
the wavelet transform of the time series, sets to zero the non-boundary coefficients,
then inverts the transform to obtain the estimate.
This function is not intended for general use by regular users of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wav.trend.est(
  x,
  filter.number = 4,
  family = "DaubLeAsymm",
  max.scale = floor(log2(length(x)) * 0.7),
  transform.type = "nondec",
  boundary.handle = FALSE,
  T.CI = FALSE,
  sig.lvl = 0.05,
  lag.max = floor(10 * (log10(length(x)))),
  confint.type = "normal",
  reps = 199,
  spec.est = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wav.trend.est_+3A_x">x</code></td>
<td>
<p>The time series you want to estimate the trend function of.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_filter.number">filter.number</code></td>
<td>
<p>Selects the index of the wavelet used in the estimation
procedure. For Daubechies compactly supported wavelets the filter number is
the number of vanishing moments.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_family">family</code></td>
<td>
<p>Selects the wavelet family to use. Recommended to only use the
Daubechies compactly supported wavelets DaubExPhase and DaubLeAsymm.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_max.scale">max.scale</code></td>
<td>
<p>Selects the coarsest scale of the wavelet transform to
analyse to. Should be a value from <code class="reqn">1</code> (finest) to <code class="reqn">J-1</code> (coarsest),
where <code class="reqn">n=2^J</code> is the length of the time series.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_transform.type">transform.type</code></td>
<td>
<p>The type of wavelet transform used. Can be <code>"dec"</code>
which is the standard discrete wavelet transform or <code>"nondec"</code> (default),
a non-decimated wavelet transform, but a confidence interval
cannot be calculated in this case.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_boundary.handle">boundary.handle</code></td>
<td>
<p>Logical variable. If <code>TRUE</code>, the time
series is boundary corrected, to get a less variable trend estimate at the
boundaries of the times series. If <code>FALSE</code>, no boundary correction is applied.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_t.ci">T.CI</code></td>
<td>
<p>Logical variable, only to be used if <code>transform.type = TRUE</code>.
If <code>TRUE</code>, a <code>(1-sig.lvl)</code> pointwise confidence interval is
computed for the trend estimate.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_sig.lvl">sig.lvl</code></td>
<td>
<p>Used only if <code>T.CI = TRUE</code>; a numeric value
(<code>0 &lt;= sig.lvl &lt;= 1</code>) with which a <code>(1-sig.lvl)</code> pointwise
confidence interval for the trend estimate is generated.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_lag.max">lag.max</code></td>
<td>
<p>Used only if <code>T.CI = TRUE</code>; a positive integer
specifying the maximum lag to which the local autocovariance function is
estimated.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_confint.type">confint.type</code></td>
<td>
<p>Used only if <code>T.CI = TRUE</code>; the type of confidence
interval computed. Can be <code>"percentile"</code>, in which case empirical percentiles are used, or
<code>"normal"</code> (default), in which case the normal approximation is used.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_reps">reps</code></td>
<td>
<p>Used only if <code>T.CI = TRUE</code> and <code>transform.type = "dec"</code> ; the number
of bootstrap replications used to compute the confidence interval.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_spec.est">spec.est</code></td>
<td>
<p>Used only if <code>T.CI = TRUE</code>; the spectrum estimate of the time series,
used to calculate the confidence interval for the trend estimate.</p>
</td></tr>
<tr><td><code id="wav.trend.est_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the <code><a href="#topic+ewspec.trend">ewspec.trend</a></code> call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object containing the following fields:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code>filter.number</code>, <code>family</code></td>
<td>
<p>Input wavelet parameters</p>
</td></tr>
<tr><td><code>transform.type</code>, <code>max.scale</code>, <code>boundary.handle</code>, <code>T.CI</code></td>
<td>
<p>Input parameters</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>A vector of length <code>length(x)</code> containing the trend estimate</p>
</td></tr>
<tr><td><code>lower.CI</code></td>
<td>
<p>Returned if <code>T.CI = TRUE</code>. The lower limit of the pointwise confidence interval</p>
</td></tr>
<tr><td><code>upper.CI</code></td>
<td>
<p>Returned if <code>T.CI = TRUE</code>. The upper limit of the pointwise confidence interval</p>
</td></tr>
<tr><td><code>sig.lvl</code></td>
<td>
<p>Returned if <code>T.CI = TRUE</code>. The significance level of the pointwise confidence interval</p>
</td></tr>
</table>


<h3>References</h3>

<p>McGonigle, E. T., Killick, R., and Nunes, M. (2022). Trend
locally stationary wavelet processes. <em>Journal of Time Series
Analysis</em>, 43(6), 895-917.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TLSW">TLSW</a></code>
</p>

<hr>
<h2 id='z.acc'>
Z-Axis Acceleration for Human Activity Monitoring
</h2><span id='topic+z.acc'></span>

<h3>Description</h3>

<p>This dataset is a section of data from Experiment 3, User 2, based on accelerometer readings from a smartphone (Reyes-Ortiz, Oneto, Sama, Parra, and Anguita (2016)), obtained from the UCI data repository (Kelly, Longjohn, and Nottingham (2024)). The data gives the time series of the acceleration along the Z-axis of an experiment participant as they perform the activities of walking up and downstairs several times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  z.acc
</code></pre>


<h3>Format</h3>

<p>A vector of length 6000.
</p>


<h3>Source</h3>

<p>Kelly M., Longjohn R., and Nottingham, K. (2024). The UCI Machine Learning Repository. <a href="https://doi.org/10.24432/C54G7M">doi:10.24432/C54G7M</a>.
</p>


<h3>References</h3>

<p>Reyes-Ortiz, J. L., Oneto, L., Sama, A., Parra, X., and Anguita, D. (2016). Transition-Aware Human Activity Recognition Using Smartphones. <em>Neurocomputing</em>, 171, 754–767.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+z.labels">z.labels</a></code>
</p>

<hr>
<h2 id='z.labels'>
Activity Labels for Human Activity Monitoring
</h2><span id='topic+z.labels'></span>

<h3>Description</h3>

<p>This dataset gives the labelled activities recorded during the time period of observations given in the data
object <code>z.acc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  z.labels
</code></pre>


<h3>Format</h3>

<p> A data frame with 6 rows and 3 variables:
</p>

<dl>
<dt>activity</dt><dd><p>The activity recorded, either <code>"downstairs"</code> or <code>"upstairs"</code>, corresponding to walking downstairs and upstairs respectively.</p>
</dd>
<dt>start</dt><dd><p>the starting time of the activity.</p>
</dd>
<dt>end</dt><dd><p>the ending time of the activity.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Kelly M., Longjohn R., and Nottingham, K. (2024). The UCI Machine Learning Repository. <a href="https://doi.org/10.24432/C54G7M">doi:10.24432/C54G7M</a>.
</p>


<h3>References</h3>

<p>Reyes-Ortiz, J. L., Oneto, L., Sama, A., Parra, X., and Anguita, D. (2016). Transition-Aware Human Activity Recognition Using Smartphones. <em>Neurocomputing</em>, 171, 754–767.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+z.acc">z.acc</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
