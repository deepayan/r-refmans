<!DOCTYPE html><html><head><title>Help for package speaq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {speaq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddPlottingStuff'><p>Add plotting variables</p></a></li>
<li><a href='#BuildFeatureMatrix'><p>Build a Feature matrix from the with speaq 2.0 processed data</p></a></li>
<li><a href='#BuildRawDataMatrix'><p>Build a raw data matrix (spectra) from spectra of unequal length</p></a></li>
<li><a href='#BWR'><p>BW ratio calculation</p></a></li>
<li><a href='#createNullSampling'><p>Building a null hypothesis data</p></a></li>
<li><a href='#detectSpecPeaks'><p>Peak detection for spectra</p></a></li>
<li><a href='#dohCluster'><p>CluPA function for multiple spectra.</p></a></li>
<li><a href='#dohClusterCustommedSegments'><p>Use CluPA for alignment with additional information</p></a></li>
<li><a href='#doShift'><p>Segment shift</p></a></li>
<li><a href='#drawBW'><p>BW and percentile ratios plot</p></a></li>
<li><a href='#drawSpec'><p>Spectral plot</p></a></li>
<li><a href='#drawSpecPPM'><p>Plot NMR spectra from a spectra data matrix</p></a></li>
<li><a href='#findRef'><p>Reference finding</p></a></li>
<li><a href='#findSegPeakList'><p>Selecting the peaks in a segment</p></a></li>
<li><a href='#findShiftStepFFT'><p>Finding the shift-step by using Fast Fourier Transform cross- correlation</p></a></li>
<li><a href='#getWaveletPeaks'><p>Convert raw NMR spectra to peak data by using wavelets</p></a></li>
<li><a href='#GetWinedata.subset'><p>Get subset of Winedata for code examples</p></a></li>
<li><a href='#hclust.grouping'><p>Grouping with hierarchical clustering (used in the PeakGrouper function)</p></a></li>
<li><a href='#hClustAlign'><p>CluPA function for two spectra.</p></a></li>
<li><a href='#HMDBsearchR'><p>Submit 1H NMR peaks to HMDB for compound search</p></a></li>
<li><a href='#makeSimulatedData'><p>Create a simulated NMR spectral data</p></a></li>
<li><a href='#PeakFilling'><p>Peak filling of any missed peaks</p></a></li>
<li><a href='#PeakGrouper'><p>Peak grouping with hierarchical clustering</p></a></li>
<li><a href='#regroupR'><p>Regroup faulty grouped peaks</p></a></li>
<li><a href='#relevant.features.p'><p>Identify features (columns in the datamatrix) which are significantly associated with the outcome.</p></a></li>
<li><a href='#returnLocalMaxima'><p>Local maximum detection</p></a></li>
<li><a href='#ROIplot'><p>Plot NMR spectra, together with raw and grouped peaks</p></a></li>
<li><a href='#SCANT'><p>SCAle, Normalize and Transform a data matrix</p></a></li>
<li><a href='#SilhouetR'><p>SilhouetR</p></a></li>
<li><a href='#Winedata'><p>Wine dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.7.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-20</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Nuclear Magnetic Resonance (NMR) Spectra Alignment,
Peak Based Processing, Quantitative Analysis and Visualizations</td>
</tr>
<tr>
<td>Author:</td>
<td>Charlie Beirnaert, Trung Nghia Vu, Pieter Meysman, Kris Laukens and Dirk Valkenborg</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charlie Beirnaert &lt;charlie_beirnaert@icloud.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Makes Nuclear Magnetic Resonance spectroscopy (NMR spectroscopy) data analysis as easy as possible by only requiring a small set of functions to perform an entire analysis. 'speaq' offers the possibility of raw spectra alignment and quantitation but also an analysis based on features whereby the spectra are converted to peaks which are then grouped and turned into features. These features can be processed with any number of statistical tools either included in 'speaq' or available elsewhere on CRAN. More details can be found in Vu et al. (2011) &lt;<a href="https://doi.org/10.1186%2F1471-2105-12-405">doi:10.1186/1471-2105-12-405</a>&gt; and Beirnaert et al. (2018) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1006018">doi:10.1371/journal.pcbi.1006018</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>MassSpecWavelet, cluster, parallel, doSNOW, data.table,
foreach, stats, Rfast, utils, graphics, grDevices, ggplot2,
gridExtra, reshape2, rvest, xml2, missForest, impute</td>
</tr>
<tr>
<td>Suggests:</td>
<td>datasets, knitr, rmarkdown, grid, gridBase</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-20 12:31:27 UTC; Charlie</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-23 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddPlottingStuff'>Add plotting variables</h2><span id='topic+AddPlottingStuff'></span>

<h3>Description</h3>

<p>This functions adds a few variables which make plotting features easier (and more informative). Since for example every peaks keeps it original ppm value, if you want to plot the groups this function adds the group ppm value. Also sample labels can be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddPlottingStuff(Y.peaks, X.ppm = NULL, groupLabels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddPlottingStuff_+3A_y.peaks">Y.peaks</code></td>
<td>
<p>data frame obtained from either of the 'getWaveletPeaks', 'PeakAligner' or 'PeakFilling' function.</p>
</td></tr>
<tr><td><code id="AddPlottingStuff_+3A_x.ppm">X.ppm</code></td>
<td>
<p>The vector with the ppm values (numeric vector).</p>
</td></tr>
<tr><td><code id="AddPlottingStuff_+3A_grouplabels">groupLabels</code></td>
<td>
<p>The groupLabels (numeric or factor).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with added plotting variables (groupPPM for aligned features and labels for plotting).
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset &lt;- GetWinedata.subset()
subset.spectra = as.matrix(subset$Spectra)
subset.ppm = as.numeric(subset$PPM)

test.peaks &lt;- getWaveletPeaks(Y.spec=subset.spectra, 
                              X.ppm=subset.ppm,
                              nCPU = 1) # nCPU set to 2 for the vignette build
                              
test.peaks.plot = AddPlottingStuff(test.peaks, subset.ppm, subset$Color)
#head(test.peaks.plot)

</code></pre>

<hr>
<h2 id='BuildFeatureMatrix'>Build a Feature matrix from the with speaq 2.0 processed data</h2><span id='topic+BuildFeatureMatrix'></span>

<h3>Description</h3>

<p>This function converts the grouped peak data to a matrix.
The matrix has features (peaks groups) in the columns and the value of the peak for every sample in the rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildFeatureMatrix(
  Y.data,
  var = "peakValue",
  impute = "zero",
  imputation_val = NA,
  delete.below.threshold = FALSE,
  baselineThresh = 500,
  snrThres = 3,
  thresholds.pass = "any-to-pass"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildFeatureMatrix_+3A_y.data">Y.data</code></td>
<td>
<p>The dataset after (at least) peak detection and grouping with speaq 2.0. The dataset after peak filling is recommended.</p>
</td></tr>
<tr><td><code id="BuildFeatureMatrix_+3A_var">var</code></td>
<td>
<p>The variable to be used in the Featurematrix. This can be any of 'peakIndex', 'peakPPM', 'peakValue' (default), 'peakSNR', 'peakScale', or 'Sample'.</p>
</td></tr>
<tr><td><code id="BuildFeatureMatrix_+3A_impute">impute</code></td>
<td>
<p>What to impute when a certain peak is missing for a certain sample and feature combo. Options are &quot;zero&quot; (or &quot;zeros&quot;, the default), &quot;median&quot; (imputation with feature median), &quot;randomForest&quot; (imputation with missForest function from package missForest) or kNN followed by a number indicating the amount of neighbours to use e.g. &quot;kNN5&quot; or &quot;kNN10&quot; (as per the method of Troyanskaya, 2001) or lasty &quot;User_value&quot; (this will allow the use of any value specified with the imputation_val argument e.g. the median of the raw spectra). Any other statement will produce NA's.</p>
</td></tr>
<tr><td><code id="BuildFeatureMatrix_+3A_imputation_val">imputation_val</code></td>
<td>
<p>If the &quot;User_value&quot; imputation option is chosen this value will be used to impute the missing values.</p>
</td></tr>
<tr><td><code id="BuildFeatureMatrix_+3A_delete.below.threshold">delete.below.threshold</code></td>
<td>
<p>Whether to ignore peaks for which the 'var' variable has a value below 'baselineThresh' (default = FALSE).</p>
</td></tr>
<tr><td><code id="BuildFeatureMatrix_+3A_baselinethresh">baselineThresh</code></td>
<td>
<p>The threshold for the 'var' variable that peaks have to surpass to be included in the feature matrix.</p>
</td></tr>
<tr><td><code id="BuildFeatureMatrix_+3A_snrthres">snrThres</code></td>
<td>
<p>The threshold for the signal-to-noise ratio of a peak.</p>
</td></tr>
<tr><td><code id="BuildFeatureMatrix_+3A_thresholds.pass">thresholds.pass</code></td>
<td>
<p>This variable lets users decide whether a peak has to pass all the thresholds (both snrThres and baselineThresh), or just one. (If the peak does not need to surpass any thresholds set 'delete.below.threshold' to FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix, data.matrix, with samples for rows and features for columns. The values in the matrix are those of the 'var' variable.
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>References</h3>

<p>Olga Troyanskaya, Michael Cantor, Gavin Sherlock, Pat Brown, Trevor Hastie, Robert Tibshirani, David Botstein and Russ B. Altman, Missing value estimation methods for DNA microarrays BIOINFORMATICS Vol. 17 no. 6, 2001 Pages 520-525
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset &lt;- GetWinedata.subset()
# to reduce the example time we only select spectra 1 &amp; 2
subset.spectra = as.matrix(subset$Spectra)[1:2,] 
subset.ppm = as.numeric(subset$PPM)

test.peaks &lt;- getWaveletPeaks(Y.spec=subset.spectra, 
                              X.ppm=subset.ppm,
                              nCPU = 1) # nCPU set to 2 for the vignette build

test.grouped &lt;- PeakGrouper(Y.peaks = test.peaks)
                           
test.Features &lt;- BuildFeatureMatrix(test.grouped)

        
</code></pre>

<hr>
<h2 id='BuildRawDataMatrix'>Build a raw data matrix (spectra) from spectra of unequal length</h2><span id='topic+BuildRawDataMatrix'></span>

<h3>Description</h3>

<p>This function can be used to build a data matrix from ill aligned spectra or of spectra of unequal length.
the result is a matrix whereby the first column matches (approximately) with a single left ppm value and the 
last column matches (approximately) with a single right ppm value. Crucial is that the sample rates of the machine are the same
this should be always the case otherwise comparing intensities becomes meaningless.
Note that, as standard in NMR spectra, the highest ppm value is on the left
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildRawDataMatrix(spectrum.list, ppm.list = NULL, ppm.edges.matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildRawDataMatrix_+3A_spectrum.list">spectrum.list</code></td>
<td>
<p>A list of the spectra (y-values). Since by definition some of these differ in length this has to be in list form with a single spectrum per list item.</p>
</td></tr>
<tr><td><code id="BuildRawDataMatrix_+3A_ppm.list">ppm.list</code></td>
<td>
<p>The list of corresponding ppm values (x-values) with the highest ppm-value at the beginning (left) as is the convention for NMR spectra. (This our ppm.edges.matrix has to be provided).</p>
</td></tr>
<tr><td><code id="BuildRawDataMatrix_+3A_ppm.edges.matrix">ppm.edges.matrix</code></td>
<td>
<p>The list with the starting and ending ppm values (highest ppm-value on the left/in the beginning). This or ppm.list has to be provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpectraAndPPM A list with 2 elements, the DataMatrix and the ppmMatrix.
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this is an example for 3 meaningless spectra
lengths_of_spectra &lt;- c(100,150,120)
measurement_distance &lt;- 0.01
starting_ppm_values &lt;- c(8.7, 9.0, 9.0)
spectra &lt;- list()
ppm_values &lt;- list()
for (k in 1:3) {
    spectra[[k]] &lt;- runif(lengths_of_spectra[k], min = 0, max = 10)
    
    # note the minus sign in the 'by' statement
    ppm_values[[k]] &lt;- seq(from = starting_ppm_values[k], by = -measurement_distance, 
                           length.out = lengths_of_spectra[k])  
}
new.Data &lt;- BuildRawDataMatrix(spectrum.list = spectra, ppm.list = ppm_values)
spectraMatrix &lt;- new.Data$DataMatrix
ppmMatrix &lt;- new.Data$ppmMatrix

</code></pre>

<hr>
<h2 id='BWR'>BW ratio calculation</h2><span id='topic+BWR'></span>

<h3>Description</h3>

<p>Compute the BW ratios from data groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BWR(X, groupLabel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BWR_+3A_x">X</code></td>
<td>
<p>The spectral dataset in the matrix format in which each row contains a single sample.</p>
</td></tr>
<tr><td><code id="BWR_+3A_grouplabel">groupLabel</code></td>
<td>
<p>Group label of samples in the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return BW ratio
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createNullSampling">createNullSampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
peakList &lt;- detectSpecPeaks(X,
                            nDivRange = c(128),
                            scales = seq(1, 16, 2),
                            baselineThresh = 50000,
                            SNR.Th = -1,
                            verbose=FALSE
);
resFindRef&lt;- findRef(peakList);
refInd &lt;- resFindRef$refInd;
maxShift = 50;
Y &lt;- dohCluster(X,
                peakList = peakList,
                refInd = refInd,
                maxShift  = maxShift,
                acceptLostPeak = TRUE, verbose=FALSE);
# find the BW-statistic
BW = BWR(Y, groupLabel);

</code></pre>

<hr>
<h2 id='createNullSampling'>Building a null hypothesis data</h2><span id='topic+createNullSampling'></span>

<h3>Description</h3>

<p>Create a null sampling data (N times) and write them to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNullSampling(X, groupLabel, N = 100, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNullSampling_+3A_x">X</code></td>
<td>
<p>The spectral dataset in the matrix format in which each row contains a single sample</p>
</td></tr>
<tr><td><code id="createNullSampling_+3A_grouplabel">groupLabel</code></td>
<td>
<p>Group label of samples in the dataset</p>
</td></tr>
<tr><td><code id="createNullSampling_+3A_n">N</code></td>
<td>
<p>The number of iteration for creating null sample distribution</p>
</td></tr>
<tr><td><code id="createNullSampling_+3A_verbose">verbose</code></td>
<td>
<p>A boolean value to allow print out process information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with N rows containing the null distribution.
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
peakList &lt;- detectSpecPeaks(X,
                            nDivRange = c(128),
                            scales = seq(1, 16, 2),
                            baselineThresh = 50000,
                            SNR.Th = -1,
                            verbose=FALSE
);
resFindRef&lt;- findRef(peakList);
refInd &lt;- resFindRef$refInd;
maxShift = 50;
Y &lt;- dohCluster(X,
                peakList = peakList,
                refInd = refInd,
                maxShift  = maxShift,
                acceptLostPeak = TRUE, verbose=FALSE);
# find the BW-statistic
BW = BWR(Y, groupLabel);
H0 = createNullSampling(Y, groupLabel, N = 100,verbose=FALSE)

</code></pre>

<hr>
<h2 id='detectSpecPeaks'>Peak detection for spectra</h2><span id='topic+detectSpecPeaks'></span>

<h3>Description</h3>

<p>Divide the whole spectra into smaller segments and detect peaks by using MassSpecWavelet package. 
Note that, the peak lists could be found by using other methods, this function is just a choice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectSpecPeaks(
  X,
  nDivRange = 128,
  scales = seq(1, 16, 2),
  baselineThresh = 50000,
  SNR.Th = -1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectSpecPeaks_+3A_x">X</code></td>
<td>
<p>The spectral dataset in matrix format in which each row contains a single sample</p>
</td></tr>
<tr><td><code id="detectSpecPeaks_+3A_ndivrange">nDivRange</code></td>
<td>
<p>The size of a single small segment after division of spectra</p>
</td></tr>
<tr><td><code id="detectSpecPeaks_+3A_scales">scales</code></td>
<td>
<p>The parameter of peakDetectionCWT function of MassSpecWavelet package, look it up in the original function.</p>
</td></tr>
<tr><td><code id="detectSpecPeaks_+3A_baselinethresh">baselineThresh</code></td>
<td>
<p>It will remove all peaks under an intensity set by baselineThresh.</p>
</td></tr>
<tr><td><code id="detectSpecPeaks_+3A_snr.th">SNR.Th</code></td>
<td>
<p>The parameter of peakDetectionCWT function of MassSpecWavelet package, look it up in the original function. If you set -1, the function will itself re-compute this value.</p>
</td></tr>
<tr><td><code id="detectSpecPeaks_+3A_verbose">verbose</code></td>
<td>
<p>A boolean value to allow print out process information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The peak lists of the spectra
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
peakList &lt;- detectSpecPeaks(X,
                            nDivRange = c(128),
                            scales = seq(1, 16, 2),
                            baselineThresh = 50000,
                            SNR.Th = -1,
                            verbose=FALSE
);

</code></pre>

<hr>
<h2 id='dohCluster'>CluPA function for multiple spectra.</h2><span id='topic+dohCluster'></span>

<h3>Description</h3>

<p>Use CluPA for alignment for multiple spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dohCluster(
  X,
  peakList,
  refInd = 0,
  maxShift = 100,
  acceptLostPeak = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dohCluster_+3A_x">X</code></td>
<td>
<p>The spectral dataset in the matrix format in which each row contains a single sample</p>
</td></tr>
<tr><td><code id="dohCluster_+3A_peaklist">peakList</code></td>
<td>
<p>The peak lists of the spectra</p>
</td></tr>
<tr><td><code id="dohCluster_+3A_refind">refInd</code></td>
<td>
<p>The index of the reference spectrum.</p>
</td></tr>
<tr><td><code id="dohCluster_+3A_maxshift">maxShift</code></td>
<td>
<p>The maximum number of the points for a shift step.</p>
</td></tr>
<tr><td><code id="dohCluster_+3A_acceptlostpeak">acceptLostPeak</code></td>
<td>
<p>This is an option for users, TRUE is the default value. If the users believe that all the peaks in the peak list are true positive, change it to FALSE.</p>
</td></tr>
<tr><td><code id="dohCluster_+3A_verbose">verbose</code></td>
<td>
<p>A boolean value to allow print out process information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The aligned spectra.
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dohClusterCustommedSegments">dohClusterCustommedSegments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
peakList &lt;- detectSpecPeaks(X,
                            nDivRange = c(128),
                            scales = seq(1, 16, 2),
                            baselineThresh = 50000,
                            SNR.Th = -1,
                            verbose=FALSE
);
resFindRef&lt;- findRef(peakList);
refInd &lt;- resFindRef$refInd;
maxShift = 50;
Y &lt;- dohCluster(X,
                peakList = peakList,
                refInd = refInd,
                maxShift  = maxShift,
                acceptLostPeak = TRUE, verbose=FALSE);

</code></pre>

<hr>
<h2 id='dohClusterCustommedSegments'>Use CluPA for alignment with additional information</h2><span id='topic+dohClusterCustommedSegments'></span>

<h3>Description</h3>

<p>This function integrates some additional information from user such as references for each specific segment, segment ignorance, maximum step size.. to align spectra using CluPA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dohClusterCustommedSegments(
  X,
  peakList,
  refInd,
  segmentInfoMat,
  minSegSize = 128,
  maxShift = 100,
  acceptLostPeak = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dohClusterCustommedSegments_+3A_x">X</code></td>
<td>
<p>The spectral dataset in the matrix format in which each row contains a single sample</p>
</td></tr>
<tr><td><code id="dohClusterCustommedSegments_+3A_peaklist">peakList</code></td>
<td>
<p>The peak lists of the spectra</p>
</td></tr>
<tr><td><code id="dohClusterCustommedSegments_+3A_refind">refInd</code></td>
<td>
<p>The index of the reference spectrum.</p>
</td></tr>
<tr><td><code id="dohClusterCustommedSegments_+3A_segmentinfomat">segmentInfoMat</code></td>
<td>
<p>The matrix containing the additional information for segments from the users. This parameter must be a matrix.</p>
</td></tr>
<tr><td><code id="dohClusterCustommedSegments_+3A_minsegsize">minSegSize</code></td>
<td>
<p>The minimum size of the segments which could be considered for alignment.</p>
</td></tr>
<tr><td><code id="dohClusterCustommedSegments_+3A_maxshift">maxShift</code></td>
<td>
<p>The maximum number of the points for a shift step.</p>
</td></tr>
<tr><td><code id="dohClusterCustommedSegments_+3A_acceptlostpeak">acceptLostPeak</code></td>
<td>
<p>This is an option for users, TRUE is the default value. If the users believe that all the peaks in the peak list are true positive, change it to FALSE.</p>
</td></tr>
<tr><td><code id="dohClusterCustommedSegments_+3A_verbose">verbose</code></td>
<td>
<p>A boolean value to allow print out process information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row of the segmentInfoMat matrix includes 5 values. 
For example, it could be imported from a CSV file consisting of following content:
#
begin,end,forAlign,ref,maxShift
100,200,0,0,0
450,680,1,0,50
#
Each column could be explained as the following:
* begin: the starting point of the segment.
* end: the end point of the segment.
* forAlign: the segment is aligned (1) or not (0).
* ref: the index of the reference spectrum. If 0, the algorithm will select the reference found by the reference finding step.
* maxShift: the maximum number of points of a shift to left/right.
It is worth to note that only segments with forAlign=1 (column 3) will be taken into account for spectral alignment.
</p>


<h3>Value</h3>

<p>The aligned spectral segments.
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dohCluster">dohCluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat("\n Please see more examples in the vignettes file.")
res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
peakList &lt;- detectSpecPeaks(X,
                            nDivRange = c(128),
                            scales = seq(1, 16, 2),
                            baselineThresh = 50000,
                            SNR.Th = -1,
                            verbose=FALSE
);
resFindRef&lt;- findRef(peakList);
refInd &lt;- resFindRef$refInd;
segmentInfoMat=matrix(data=c(100,200,0,0,0,
                             50,680,1,0,50),nrow=2,ncol=5,byrow=TRUE
)
colnames(segmentInfoMat)=c("begin","end","forAlign","ref","maxShift")
segmentInfoMat
maxShift = 50;
Yc &lt;- dohClusterCustommedSegments(X,
                                  peakList = peakList,
                                  refInd = refInd,
                                  maxShift  = maxShift,
                                  acceptLostPeak = TRUE,
                                  segmentInfoMat = segmentInfoMat,
                                  minSegSize = 128,
                                  verbose=FALSE)

</code></pre>

<hr>
<h2 id='doShift'>Segment shift</h2><span id='topic+doShift'></span>

<h3>Description</h3>

<p>Move a spectral segment of a sample shiftStep points to right or left
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doShift(specSeg, shiftStep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doShift_+3A_specseg">specSeg</code></td>
<td>
<p>The segment which needs to be shifted</p>
</td></tr>
<tr><td><code id="doShift_+3A_shiftstep">shiftStep</code></td>
<td>
<p>The shift step for moving. If it is a negative (positive) value, the segment is moved to left (right).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new segment after shifting.
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hClustAlign">hClustAlign</a></code>, <code><a href="#topic+findShiftStepFFT">findShiftStepFFT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
maxShift=50;
refSpec=X[1,];
tarSpec=X[2,];
adj=findShiftStepFFT(refSpec, tarSpec,maxShift=maxShift);
newTarSpec=doShift(tarSpec,adj$stepAdj);

</code></pre>

<hr>
<h2 id='drawBW'>BW and percentile ratios plot</h2><span id='topic+drawBW'></span>

<h3>Description</h3>

<p>This function is used to plot BW and percentile ratios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawBW(
  BW,
  perc,
  X,
  startP = -1,
  endP = -1,
  groupLabel = NULL,
  highBound = -1,
  lowBound = -1,
  nAxisPos = 4,
  offside = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawBW_+3A_bw">BW</code></td>
<td>
<p>An array of the BW ratios.</p>
</td></tr>
<tr><td><code id="drawBW_+3A_perc">perc</code></td>
<td>
<p>An array of the percentile ratios.</p>
</td></tr>
<tr><td><code id="drawBW_+3A_x">X</code></td>
<td>
<p>The spectral dataset in matrix format in which each row contains a single sample.</p>
</td></tr>
<tr><td><code id="drawBW_+3A_startp">startP</code></td>
<td>
<p>The starting point of the segment. If it is -1, the starting point is from beginning of the spectra.</p>
</td></tr>
<tr><td><code id="drawBW_+3A_endp">endP</code></td>
<td>
<p>The ending point of the segment. If it is -1, the ending point is the last point of the spectra.</p>
</td></tr>
<tr><td><code id="drawBW_+3A_grouplabel">groupLabel</code></td>
<td>
<p>The default value is NULL, it means that a single spectrum has a distinct color. Otherwise, the spectra is colored by their label.</p>
</td></tr>
<tr><td><code id="drawBW_+3A_highbound">highBound</code></td>
<td>
<p>Default value is -1, that means the plot covers also the highest intensity peaks in the figure. If the users want to limit the upper height of the figure, set this parameter by the limited value.</p>
</td></tr>
<tr><td><code id="drawBW_+3A_lowbound">lowBound</code></td>
<td>
<p>Default value is -1, that means the plot covers also the lowest intensity peaks in the figure. If the users want to limit the under height of the figure, set this parameter by the limited value.</p>
</td></tr>
<tr><td><code id="drawBW_+3A_naxispos">nAxisPos</code></td>
<td>
<p>The number of ticks that will be displayed in the horizontal axis.</p>
</td></tr>
<tr><td><code id="drawBW_+3A_offside">offside</code></td>
<td>
<p>The offside of values in x-axis for display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a plot containing both the BW and the spectra.
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawSpec">drawSpec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
peakList &lt;- detectSpecPeaks(X,
                            nDivRange = c(128),
                            scales = seq(1, 16, 2),
                            baselineThresh = 50000,
                            SNR.Th = -1,
                            verbose=FALSE
);
resFindRef&lt;- findRef(peakList);
refInd &lt;- resFindRef$refInd;
maxShift = 50;
Y &lt;- dohCluster(X,
                peakList = peakList,
                refInd = refInd,
                maxShift  = maxShift,
                acceptLostPeak = TRUE, verbose=FALSE);
# find the BW-statistic
BW = BWR(Y, groupLabel);
N = 100;
alpha = 0.05;
# create sampled H0 and export to file
H0 = createNullSampling(Y, groupLabel, N = N,verbose=FALSE)
#compute percentile of alpha
perc = double(ncol(Y));
alpha_corr = alpha/sum(returnLocalMaxima(Y[2,])$pkMax&gt;50000);
for (i in seq_along(perc)) {
    perc[i] = quantile(H0[,i],1-alpha_corr, type = 3);
}
drawBW(BW, perc,Y, groupLabel = groupLabel)

</code></pre>

<hr>
<h2 id='drawSpec'>Spectral plot</h2><span id='topic+drawSpec'></span>

<h3>Description</h3>

<p>This function allows to draw a segment or the whole spectra with limited high/low bounds of intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawSpec(
  X,
  startP = -1,
  endP = -1,
  groupLabel = NULL,
  useLog = -1,
  highBound = -1,
  lowBound = -1,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  nAxisPos = 4,
  offside = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawSpec_+3A_x">X</code></td>
<td>
<p>The spectral dataset in matrix format in which each row contains a single sample.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_startp">startP</code></td>
<td>
<p>The starting point of the segment. If it is -1, the starting point is from beginning of the spectra.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_endp">endP</code></td>
<td>
<p>The ending point of the segment. If it is -1, the ending point is the last point of the spectra.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_grouplabel">groupLabel</code></td>
<td>
<p>The default value is NULL, it means that a single spectrum has a distinct color. Otherwise, the spectra is colored by their label.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_uselog">useLog</code></td>
<td>
<p>The default value is -1, that means do not use a log transformation. If users want to transform the intensities to logarit values before plotting, set it to 1.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_highbound">highBound</code></td>
<td>
<p>Default value is -1, that means the plot covers also the highest intensity peaks in the figure. If the users want to limit the upper height of the figure, set this parameter by the limited value.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_lowbound">lowBound</code></td>
<td>
<p>Default value is -1, that means the plot covers also the lowest intensity peaks in the figure. If the users want to limit the under height of the figure, set this parameter by the limited value.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_xlab">xlab</code></td>
<td>
<p>The default value is NULL, if so, &quot;index&quot; is displayed at the horizontal axis.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_ylab">ylab</code></td>
<td>
<p>The default value is NULL, if so, &quot;intensity&quot; is displayed at the vertical axis.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_main">main</code></td>
<td>
<p>The default value is NULL, if so, the title shows the values of startP and endP.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_naxispos">nAxisPos</code></td>
<td>
<p>The number of ticks that you want to display in horizontal axis.</p>
</td></tr>
<tr><td><code id="drawSpec_+3A_offside">offside</code></td>
<td>
<p>The offside of values in x-axis for display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a plot of the spectra.
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawBW">drawBW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> res=makeSimulatedData();
 X=res$data;
 groupLabel=res$label;
 drawSpec(X)

</code></pre>

<hr>
<h2 id='drawSpecPPM'>Plot NMR spectra from a spectra data matrix</h2><span id='topic+drawSpecPPM'></span>

<h3>Description</h3>

<p>This function plots NMR spectra (so with the largest ppm values on the left) with a number of plotting options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawSpecPPM(
  Y.spec,
  X.ppm,
  LeftIndex = -1,
  RightIndex = -1,
  groupFactor = NULL,
  useLog = FALSE,
  maxHeight = -1,
  minHeight = -1,
  nAxisPos = 4,
  xlab = NULL,
  ylab = NULL,
  title = NULL,
  ticks = NULL,
  ROI = NULL,
  ROI.ppm = NULL,
  roiWidth = 100,
  roiWidth.ppm = NULL,
  legend.extra.x = 2,
  legend.extra.y = 2,
  legendpos = NULL,
  colourstyle = "ggplot",
  manual.colours = NULL,
  lwd = 1,
  noLegend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawSpecPPM_+3A_y.spec">Y.spec</code></td>
<td>
<p>(required) The raw spectra in matrix format (1 sample per row) or numeric vector (in case of 1 spectrum)</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_x.ppm">X.ppm</code></td>
<td>
<p>(required) The vector with the ppm values</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_leftindex">LeftIndex</code></td>
<td>
<p>The starting index of the ppm values for plotting. default = -1 indicates the first ppm (the largest) value is the start of the plot</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_rightindex">RightIndex</code></td>
<td>
<p>The stopping index for plotting. default = -1 indicates the last ppm value (the smallest) is the end of the plot</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_groupfactor">groupFactor</code></td>
<td>
<p>The groupFactors. If provided different colors will be used for each group.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_uselog">useLog</code></td>
<td>
<p>If set to 'TRUE' the spectra will be log10 transformed (default = FALSE).</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_maxheight">maxHeight</code></td>
<td>
<p>The maximal height of the plot (default = -1, this indicates no maximal value).</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_minheight">minHeight</code></td>
<td>
<p>The minimal height of the plot (default = -1, this indicates no minimal value).</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_naxispos">nAxisPos</code></td>
<td>
<p>The number of equally spaced tickmarks.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_xlab">xlab</code></td>
<td>
<p>The label on the x axis.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_ylab">ylab</code></td>
<td>
<p>The label on the y axis.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_title">title</code></td>
<td>
<p>The title of the plot.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_ticks">ticks</code></td>
<td>
<p>Position tick manually by providing ppm values.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_roi">ROI</code></td>
<td>
<p>If provided (with an index value, not a ppm value) only this region of interest will be plotted. (supply no ROI or ROI.ppm values, for the full spectrum, or specify only 1, either ROI or ROI.ppm).</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_roi.ppm">ROI.ppm</code></td>
<td>
<p>If provided (a ppm value, not an index value) only this region of interest will be plotted. (supply no ROI or ROI.ppm values, for the full spectrum, or specify only 1, either ROI or ROI.ppm).</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_roiwidth">roiWidth</code></td>
<td>
<p>The width of the ROI (region of interest) plot in index points/measurement points. The plot will span from ROI/ROI.ppm - roiWidth to ROI/ROI.ppm + roiWidth. (only supply roiWidth or roiWidth.ppm if needed).</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_roiwidth.ppm">roiWidth.ppm</code></td>
<td>
<p>The width of the ROI (region of interest) plot in ppm. The plot will span from ROI/ROI.ppm - roiWidth.ppm to ROI/ROI.ppm + roiWidth.ppm. (only supply roiWidth or roiWidth.ppm if needed).</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_legend.extra.x">legend.extra.x</code></td>
<td>
<p>Increase (or decrease) the horizontal space in the legend, this is useful for exporting larger figures.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_legend.extra.y">legend.extra.y</code></td>
<td>
<p>Increase (or decrease) the vertical space in the legend, this is useful for exporting larger figures.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_legendpos">legendpos</code></td>
<td>
<p>The position of the legend (standard R legend positioning, default = 'topleft').</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_colourstyle">colourstyle</code></td>
<td>
<p>The colours used in the plot, either standard R or ggplot colours (default).</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_manual.colours">manual.colours</code></td>
<td>
<p>Provide specific colours to be used in the plot.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_lwd">lwd</code></td>
<td>
<p>The linewidth.</p>
</td></tr>
<tr><td><code id="drawSpecPPM_+3A_nolegend">noLegend</code></td>
<td>
<p>If set to TRUE no legend will be plotted (default = FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R plot
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Winedata)
Spectra = Winedata$spectra 
ppm.wine = Winedata$ppm
wine.color = Winedata$wine.color 
drawSpecPPM(Y.spec=Spectra, X.ppm=ppm.wine, groupFactor = wine.color, 
title = 'Raw wine data spectra')


</code></pre>

<hr>
<h2 id='findRef'>Reference finding</h2><span id='topic+findRef'></span>

<h3>Description</h3>

<p>This function is to heuristically detect a reference spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findRef(peakList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findRef_+3A_peaklist">peakList</code></td>
<td>
<p>The peak lists of the spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2: refInd (The index of the reference spectrum found by the algorithm) and orderSpec (A sorted array of the spectra by their goodness values)
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>References</h3>

<p>Vu TN, Valkenborg D, Smets K, Verwaest KA, Dommisse R, Lemi\'ere F, Verschoren A, Goethals B, Laukens K. (2011) An integrated workflow for robust alignment and simplified quantitative analysis of NMR spectrometry data. BMC Bioinformatics. 2011 Oct 20;12:405.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
peakList &lt;- detectSpecPeaks(X,
                            nDivRange = c(128),
                            scales = seq(1, 16, 2),
                            baselineThresh = 50000,
                            SNR.Th = -1,
                            verbose=FALSE
);
cat("\n Find the spectrum reference...")
resFindRef&lt;- findRef(peakList);
refInd &lt;- resFindRef$refInd;
cat("\n Order of spectrum for reference  \n");
for (i in seq_along(resFindRef$orderSpec))
    cat(paste(i, ":",resFindRef$orderSpec[i],sep=""), " ");
cat("\n The reference is: ", refInd);

</code></pre>

<hr>
<h2 id='findSegPeakList'>Selecting the peaks in a segment</h2><span id='topic+findSegPeakList'></span>

<h3>Description</h3>

<p>This function is to find out which peaks belonging to a segment which ranges from startP to endP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSegPeakList(peakList, startP, endP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findSegPeakList_+3A_peaklist">peakList</code></td>
<td>
<p>The peak lists of the spectra.</p>
</td></tr>
<tr><td><code id="findSegPeakList_+3A_startp">startP</code></td>
<td>
<p>The starting point of the segment.</p>
</td></tr>
<tr><td><code id="findSegPeakList_+3A_endp">endP</code></td>
<td>
<p>The ending point of the segment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of indices of the peaks in the segment.
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dohClusterCustommedSegments">dohClusterCustommedSegments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
peakList &lt;- detectSpecPeaks(X,
                            nDivRange = c(128),
                            scales = seq(1, 16, 2),
                            baselineThresh = 50000,
                            SNR.Th = -1,
                            verbose=FALSE
                            );
cat("\n ", peakList[[1]])
segmentpeakList= findSegPeakList(peakList[[1]],400,600);
cat("\n ", segmentpeakList)     
                       
</code></pre>

<hr>
<h2 id='findShiftStepFFT'>Finding the shift-step by using Fast Fourier Transform cross- correlation</h2><span id='topic+findShiftStepFFT'></span>

<h3>Description</h3>

<p>This function uses Fast Fourier Transform cross-correlation to find out the shift step between two spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findShiftStepFFT(refSpec, tarSpec, maxShift = 0, scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findShiftStepFFT_+3A_refspec">refSpec</code></td>
<td>
<p>The reference spectrum.</p>
</td></tr>
<tr><td><code id="findShiftStepFFT_+3A_tarspec">tarSpec</code></td>
<td>
<p>The target spectrum which needs to be aligned.</p>
</td></tr>
<tr><td><code id="findShiftStepFFT_+3A_maxshift">maxShift</code></td>
<td>
<p>The maximum number of points for a shift step. If this value is zero, the algorithm will check on the whole length of the spectra.</p>
</td></tr>
<tr><td><code id="findShiftStepFFT_+3A_scale">scale</code></td>
<td>
<p>Boolean value (TRUE/FALSE) for scaling data before Fast Fourier Transform cross-correlation step. If scale=NULL but mean/median of absolute data is too small (&lt;1), the scaling will be applied. This might happen for very low abundant spectra like chromatograms. For normal NMR spectra, the scaling is usually not applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2: corValue (The best correlation value) and stepAdj (The shift step found by the algorithm)
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hClustAlign">hClustAlign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
maxShift=50;
refSpec=X[1,];
tarSpec=X[2,];
adj=findShiftStepFFT(refSpec, tarSpec,maxShift=maxShift);
                       
</code></pre>

<hr>
<h2 id='getWaveletPeaks'>Convert raw NMR spectra to peak data by using wavelets</h2><span id='topic+getWaveletPeaks'></span>

<h3>Description</h3>

<p>This function converts phase corrected NMR spectra to peak data by using wavelet based peak detection (with the MassSpecWavelet package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWaveletPeaks(
  Y.spec,
  X.ppm,
  sample.labels = NULL,
  window.width = "small",
  window.split = 4,
  scales = seq(1, 16, 1),
  baselineThresh = 1000,
  SNR.Th = -1,
  nCPU = -1,
  include_nearbyPeaks = TRUE,
  raw_peakheight = FALSE,
  duplicate_detection_multiplier = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWaveletPeaks_+3A_y.spec">Y.spec</code></td>
<td>
<p>The spectra in matrix format (rows = samples, columns = measurement points ).</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_x.ppm">X.ppm</code></td>
<td>
<p>The x/ppm values of the spectra (in single vector or matrix format).</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_sample.labels">sample.labels</code></td>
<td>
<p>The sample labels (optional), if not supplied these will simply be the sample numbers.</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_window.width">window.width</code></td>
<td>
<p>The width of the detection window for the wavelets. Because of the Fourier transform lengths of 512 ( window.width = 'small') of 1024 ( window.width = 'large') are preferable.</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_window.split">window.split</code></td>
<td>
<p>A positive, even and whole number indicating in how many parts the sliding window is split up. With every iteration the window slides one part further.</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_scales">scales</code></td>
<td>
<p>The scales to be used in the wavelet based peak detection, see <a href="MassSpecWavelet.html#topic+peakDetectionCWT">peakDetectionCWT</a>.</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_baselinethresh">baselineThresh</code></td>
<td>
<p>Peaks with a peakValue lower than this threshold will be removed (default = 1000).</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_snr.th">SNR.Th</code></td>
<td>
<p>The Signal-to-noise threshold, see <a href="MassSpecWavelet.html#topic+peakDetectionCWT">peakDetectionCWT</a>.</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_ncpu">nCPU</code></td>
<td>
<p>The amount of cpu's to be used for peak detection. If set to '-1' all available cores minus 1 will be used.</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_include_nearbypeaks">include_nearbyPeaks</code></td>
<td>
<p>If set to TRUE small peaks in the tails of larger ones will be included in the peak data, see <a href="MassSpecWavelet.html#topic+peakDetectionCWT">peakDetectionCWT</a>.</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_raw_peakheight">raw_peakheight</code></td>
<td>
<p>(default = FALSE) Whether to use the raw peak height of a peak instead of the optimal CWT coefficient (which is a measure for AUC).</p>
</td></tr>
<tr><td><code id="getWaveletPeaks_+3A_duplicate_detection_multiplier">duplicate_detection_multiplier</code></td>
<td>
<p>(default 1) In case users want to process other spectra besides NMR, this parameter will increase the limit for two peaks to be considered a duplicate detection. When dealing with more distorted spectra this parameter can be increased (recommended to not increase above 10).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The peaks detected with the wavelets.
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset &lt;- GetWinedata.subset()
# to reduce the example time we only select spectra 1 &amp; 2
subset.spectra = as.matrix(subset$Spectra)[1:2,] 
subset.ppm = as.numeric(subset$PPM)

test.peaks &lt;- getWaveletPeaks(Y.spec=subset.spectra, 
                              X.ppm=subset.ppm ,
                              nCPU = 1) # nCPU set to 2 for the vignette build

</code></pre>

<hr>
<h2 id='GetWinedata.subset'>Get subset of Winedata for code examples</h2><span id='topic+GetWinedata.subset'></span>

<h3>Description</h3>

<p>This functions extracts a small part of the Winedata to be used in code testing and code examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetWinedata.subset()
</code></pre>


<h3>Value</h3>

<p>list of 2: spectra, ppm values, color and origin.
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
subset &lt;- GetWinedata.subset()
subset.spectra = subset$Spectra
subset.ppm = subset$PPM.vector

</code></pre>

<hr>
<h2 id='hclust.grouping'>Grouping with hierarchical clustering (used in the PeakGrouper function)</h2><span id='topic+hclust.grouping'></span>

<h3>Description</h3>

<p>Internal function in the PeakGrouper function for generating the hierarchical clustering tree and cutting it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclust.grouping(
  current.peaks,
  min.samp.grp = 1,
  max.dupli.prop = 0.25,
  maxClust = 10,
  linkage = "average"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hclust.grouping_+3A_current.peaks">current.peaks</code></td>
<td>
<p>A number of neighbouring peaks to be grouped.</p>
</td></tr>
<tr><td><code id="hclust.grouping_+3A_min.samp.grp">min.samp.grp</code></td>
<td>
<p>The minimal amount of samples needed to form a group.</p>
</td></tr>
<tr><td><code id="hclust.grouping_+3A_max.dupli.prop">max.dupli.prop</code></td>
<td>
<p>The maximal duplication proportion allowed for a group to be considered a single group.</p>
</td></tr>
<tr><td><code id="hclust.grouping_+3A_maxclust">maxClust</code></td>
<td>
<p>The maximum number of clusters (depth of the tree).</p>
</td></tr>
<tr><td><code id="hclust.grouping_+3A_linkage">linkage</code></td>
<td>
<p>The linkage to be used in the hierarchical clustering. See the 'method' argument in <a href="stats.html#topic+hclust">hclust</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with grouped peaks.
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PeakGrouper">PeakGrouper</a></code>
</p>

<hr>
<h2 id='hClustAlign'>CluPA function for two spectra.</h2><span id='topic+hClustAlign'></span>

<h3>Description</h3>

<p>This function implements the idea of the CluPA algorithm to align the target spectrum against the reference spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hClustAlign(
  refSpec,
  tarSpec,
  peakList,
  peakLabel,
  startP,
  endP,
  distanceMethod = "average",
  maxShift = 0,
  acceptLostPeak = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hClustAlign_+3A_refspec">refSpec</code></td>
<td>
<p>The reference spectrum.</p>
</td></tr>
<tr><td><code id="hClustAlign_+3A_tarspec">tarSpec</code></td>
<td>
<p>The target spectrum.</p>
</td></tr>
<tr><td><code id="hClustAlign_+3A_peaklist">peakList</code></td>
<td>
<p>List of peaks of the both reference and target spectra</p>
</td></tr>
<tr><td><code id="hClustAlign_+3A_peaklabel">peakLabel</code></td>
<td>
<p>The list of the labels of the peaks</p>
</td></tr>
<tr><td><code id="hClustAlign_+3A_startp">startP</code></td>
<td>
<p>The starting point of the segment.</p>
</td></tr>
<tr><td><code id="hClustAlign_+3A_endp">endP</code></td>
<td>
<p>The ending point of the segment.</p>
</td></tr>
<tr><td><code id="hClustAlign_+3A_distancemethod">distanceMethod</code></td>
<td>
<p>The distance method for the hierarchical clustering algorithm.</p>
</td></tr>
<tr><td><code id="hClustAlign_+3A_maxshift">maxShift</code></td>
<td>
<p>The maximum number of points for a shift step.</p>
</td></tr>
<tr><td><code id="hClustAlign_+3A_acceptlostpeak">acceptLostPeak</code></td>
<td>
<p>This is an option for users, TRUE is the default value. If the users believe that all the peaks in the peak list are true positive, change it to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2: tarSpec (The target spectrum after alignment) and peakList (The peak list after alignment)
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>References</h3>

<p>Vu TN, Valkenborg D, Smets K, Verwaest KA, Dommisse R, Lemi\'ere F, Verschoren A, Goethals B, Laukens K. (2011) An integrated workflow for robust alignment and simplified quantitative analysis of NMR spectrometry data. BMC Bioinformatics. 2011 Oct 20;12:405.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dohCluster">dohCluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
peakList &lt;- detectSpecPeaks(X,
                            nDivRange = c(128),
                            scales = seq(1, 16, 2),
                            baselineThresh = 50000,
                            SNR.Th = -1,
                            verbose=FALSE
);
resFindRef&lt;- findRef(peakList);
refInd &lt;- resFindRef$refInd;
tarInd=1;
refSpec=X[refInd,];
tarSpec=X[tarInd,];
mergedPeakList=c(peakList[[refInd]],peakList[[tarInd]]);
mergedPeakLabel=double(length(mergedPeakList));
for (i in seq_along(peakList[[refInd]]) ) mergedPeakLabel[i]=1;
startP=1;
endP=length(tarSpec);
res=hClustAlign(refSpec,tarSpec,mergedPeakList,mergedPeakLabel,startP,endP,
                maxShift=50,acceptLostPeak=TRUE)
                       
</code></pre>

<hr>
<h2 id='HMDBsearchR'>Submit 1H NMR peaks to HMDB for compound search</h2><span id='topic+HMDBsearchR'></span>

<h3>Description</h3>

<p>This function allows to search HMDB from within R by simply submitting the peaks you want to search for. 
The function will open a webpage with the query results or provide a link to the HMDB page with the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMDBsearchR(peakVector, ppmTol = 0.02, returnURL = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HMDBsearchR_+3A_peakvector">peakVector</code></td>
<td>
<p>A vector with ppm values of peaks</p>
</td></tr>
<tr><td><code id="HMDBsearchR_+3A_ppmtol">ppmTol</code></td>
<td>
<p>The ppm tolerance for the HMDB search (default = 0.02).</p>
</td></tr>
<tr><td><code id="HMDBsearchR_+3A_returnurl">returnURL</code></td>
<td>
<p>Return the URL instead of opening a webpage.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Opens a webpage or returns a URL with the HMDB results
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
HMDBsearchR(peakVector = c(3.2, 3.38), ppmTol = 0.2, returnURL = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='makeSimulatedData'>Create a simulated NMR spectral data</h2><span id='topic+makeSimulatedData'></span>

<h3>Description</h3>

<p>Generate an NMR spectral data for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSimulatedData()
</code></pre>


<h3>Details</h3>

<p>We generate a NMR spectral data sets that contains two group A and group B. 
One at around 300 has a single tip and the other at around 600 has double 
tips that intentionally contains biological variation. First, a single spectrum 
is created based on statistic information (mean, standard deviation of intensity) 
achieved from real NMR spectra. Then, we randomly shift the spectrum to maximum 50 
data points and add some biological and technical variations to each point intensity 
to the spectrum to create a new spectrum. The collection of spectra from each group 
is the final dataset.
</p>


<h3>Value</h3>

<p>a list with 2 elements: data (The simulated NMR spectral data matrix) and label (Group label of each spectrum)
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- makeSimulatedData();
X &lt;- res$data;
groupLabel &lt;- res$label;

</code></pre>

<hr>
<h2 id='PeakFilling'>Peak filling of any missed peaks</h2><span id='topic+PeakFilling'></span>

<h3>Description</h3>

<p>This functions detects which samples (after grouping) are missing from every peak group and reanalyses the raw data to verify whether this peak is actually non-existent for this sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakFilling(
  Y.grouped,
  Y.spec,
  max.index.shift = 10,
  window.width = "small",
  nCPU = -1,
  FilMethod = "new"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakFilling_+3A_y.grouped">Y.grouped</code></td>
<td>
<p>Peaks groups (output from the 'PeakGrouper' function).</p>
</td></tr>
<tr><td><code id="PeakFilling_+3A_y.spec">Y.spec</code></td>
<td>
<p>The raw NMR spectra in matrix format.</p>
</td></tr>
<tr><td><code id="PeakFilling_+3A_max.index.shift">max.index.shift</code></td>
<td>
<p>Maximal shift in index between a filled peak and the group it belongs to.</p>
</td></tr>
<tr><td><code id="PeakFilling_+3A_window.width">window.width</code></td>
<td>
<p>The width of the detection window for the wavelets. Because of the Fourier transform lengths of 512 ( window.width = 'small') of 1024 ( window.width = 'large') are preferable.</p>
</td></tr>
<tr><td><code id="PeakFilling_+3A_ncpu">nCPU</code></td>
<td>
<p>The amount of cpu's to be used for peak detection. If set to '-1' all available cores minus 1 will be used.</p>
</td></tr>
<tr><td><code id="PeakFilling_+3A_filmethod">FilMethod</code></td>
<td>
<p>A more robust method for peak filling has been implemented. This is now the default. The former method can be used by specifying FilMethod == &quot;old&quot; however this will be deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with grouped peaks and possibly extra peaks obtained from the raw data (these peaks have SNR = NA).
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset &lt;- GetWinedata.subset()
# to reduce the example time we only select spectra 1 &amp; 2
subset.spectra = as.matrix(subset$Spectra)[1:2,] 
subset.ppm = as.numeric(subset$PPM)

test.peaks &lt;- getWaveletPeaks(Y.spec=subset.spectra, 
                              X.ppm=subset.ppm,
                              nCPU = 1) # nCPU set to 1 for the vignette build

test.grouped &lt;- PeakGrouper(Y.peaks = test.peaks)

test.filled &lt;- PeakFilling(Y.grouped = test.grouped, 
                           Y.spec = subset.spectra,  
                           nCPU = 1) # nCPU set to 1 for the vignette build


</code></pre>

<hr>
<h2 id='PeakGrouper'>Peak grouping with hierarchical clustering</h2><span id='topic+PeakGrouper'></span>

<h3>Description</h3>

<p>This functions groups the peaks obtained after wavelet based peak detection (with the 'getWaveletPeaks' function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakGrouper(
  Y.peaks,
  grouping.window.width = 100,
  verbose = FALSE,
  min.samp.grp = 1,
  max.dupli.prop = 0.25,
  maxClust = 10,
  Jaccard.regroup.threshold = 0.25,
  linkage = "average"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakGrouper_+3A_y.peaks">Y.peaks</code></td>
<td>
<p>data frame obtained from the 'getWaveletPeaks' function.</p>
</td></tr>
<tr><td><code id="PeakGrouper_+3A_grouping.window.width">grouping.window.width</code></td>
<td>
<p>The width of the sliding window (in measurement points). Measurements are taken for when this sliding window is taken too small, but best set this too a value that a normal peak is comfortably in a window. Note if large shifts occur in your dataset (like in the wine dataset) it is best to set this parameter larger.</p>
</td></tr>
<tr><td><code id="PeakGrouper_+3A_verbose">verbose</code></td>
<td>
<p>If set to TRUE the window selection process is documented in real time (default = FALSE).</p>
</td></tr>
<tr><td><code id="PeakGrouper_+3A_min.samp.grp">min.samp.grp</code></td>
<td>
<p>The minimal amount of samples needed to form a group, see <a href="#topic+hclust.grouping">hclust.grouping</a>.</p>
</td></tr>
<tr><td><code id="PeakGrouper_+3A_max.dupli.prop">max.dupli.prop</code></td>
<td>
<p>The maximal duplication proportion allowed for a group to be considered a single group, see <a href="#topic+hclust.grouping">hclust.grouping</a>.</p>
</td></tr>
<tr><td><code id="PeakGrouper_+3A_maxclust">maxClust</code></td>
<td>
<p>The maximum number of clusters (depth of the tree), see <a href="#topic+hclust.grouping">hclust.grouping</a>.</p>
</td></tr>
<tr><td><code id="PeakGrouper_+3A_jaccard.regroup.threshold">Jaccard.regroup.threshold</code></td>
<td>
<p>If 2 neighbouring groups have a jaccard index smaller than this 'Jaccard.regroup.threshold' (indicating that they are quite complementary as they have little peaks samples in common), then they are merged and regrouped. This situation can occur if a group is accidentally cut in half by the window approach.</p>
</td></tr>
<tr><td><code id="PeakGrouper_+3A_linkage">linkage</code></td>
<td>
<p>The linkage to be used in the hierarchical clustering. See the 'method' argument in <a href="stats.html#topic+hclust">hclust</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with grouped peaks. Peaks in a group are indicated with an identical peakIndex
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hclust.grouping">hclust.grouping</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset &lt;- GetWinedata.subset()
# to reduce the example time we only select spectra 1 &amp; 2
subset.spectra = as.matrix(subset$Spectra)[1:2,] 
subset.ppm = as.numeric(subset$PPM)

test.peaks &lt;- getWaveletPeaks(Y.spec=subset.spectra, 
                              X.ppm=subset.ppm ,
                              nCPU = 1) # nCPU set to 2 for the vignette build

test.grouped &lt;- PeakGrouper(Y.peaks = test.peaks)

</code></pre>

<hr>
<h2 id='regroupR'>Regroup faulty grouped peaks</h2><span id='topic+regroupR'></span>

<h3>Description</h3>

<p>If there are peaks wrongly grouped by the peakGrouper function, they will be regrouped by using the ppm values together with the peak signal to noise ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroupR(
  grouped.peaks,
  list.to.regroup,
  min.samp.grp = 1,
  max.dupli.prop = 0.1,
  maxClust = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regroupR_+3A_grouped.peaks">grouped.peaks</code></td>
<td>
<p>The grouped peaks data.</p>
</td></tr>
<tr><td><code id="regroupR_+3A_list.to.regroup">list.to.regroup</code></td>
<td>
<p>The peak indices of groups to regroup (the groups, indicated by their peakIndex, in 1 list item will be merged and regrouped).</p>
</td></tr>
<tr><td><code id="regroupR_+3A_min.samp.grp">min.samp.grp</code></td>
<td>
<p>The minimal amount of samples needed to form a group.</p>
</td></tr>
<tr><td><code id="regroupR_+3A_max.dupli.prop">max.dupli.prop</code></td>
<td>
<p>The maximal duplication proportion allowed for a group to be considered a single group.</p>
</td></tr>
<tr><td><code id="regroupR_+3A_maxclust">maxClust</code></td>
<td>
<p>The maximum number of clusters (depth of the tree).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with regrouped peaks.
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>

<hr>
<h2 id='relevant.features.p'>Identify features (columns in the datamatrix) which are significantly associated with the outcome.</h2><span id='topic+relevant.features.p'></span>

<h3>Description</h3>

<p>This function produces a p-value for every column in the datamatrix, corresponding to the null hypothesis that outcome/response is independent of that feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relevant.features.p(
  datamatrix,
  response,
  p.adj = "BH",
  POI = 1,
  responsevector = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relevant.features.p_+3A_datamatrix">datamatrix</code></td>
<td>
<p>The data matrix with a column for each feature.</p>
</td></tr>
<tr><td><code id="relevant.features.p_+3A_response">response</code></td>
<td>
<p>A vector or matrix of outcomes/responses (e.g. class labels). the length of this vector or the amount of rows in this matrix should match the amount of rows in datamatrix.</p>
</td></tr>
<tr><td><code id="relevant.features.p_+3A_p.adj">p.adj</code></td>
<td>
<p>The adjustment method for the p-values. Any of 'holm', 'hochberg', 'hommel', 'bonferroni', 'BH' (default), 'BY', 'fdr' or 'none' are accepted.</p>
</td></tr>
<tr><td><code id="relevant.features.p_+3A_poi">POI</code></td>
<td>
<p>Only if 'response' is a matrix! The p values of interest. This is a number indicating which column of the 'response' matrix you are interested in. POI can range from 1 (default) to the number of columns in 'response'.</p>
</td></tr>
<tr><td><code id="relevant.features.p_+3A_responsevector">responsevector</code></td>
<td>
<p>(deprecated), please use the the more general 'response' variable instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with the features and their (adjusted) p-values, one for every column in the datamatrix  .
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nSamples &lt;- 10
nFeatures &lt;- 20
data.matrix &lt;- matrix( stats::runif(n=nFeatures*nSamples, min=0,max=100), 
ncol = nFeatures, nrow = nSamples)

responseVec &lt;- c( rep(0,nSamples/2), rep(1,nSamples/2) )
p_values &lt;- relevant.features.p(datamatrix = data.matrix, response = 
responseVec, p.adj = 'none')
p_values_adjusted &lt;- relevant.features.p( datamatrix = data.matrix, 
response = responseVec, p.adj = 'bonferroni')

</code></pre>

<hr>
<h2 id='returnLocalMaxima'>Local maximum detection</h2><span id='topic+returnLocalMaxima'></span>

<h3>Description</h3>

<p>Find and return local maximum of a single spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returnLocalMaxima(spectrum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returnLocalMaxima_+3A_spectrum">spectrum</code></td>
<td>
<p>A spectral sample in the vector format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2: locMax (Locations of the found local maximum peaks) and pkMax (Intensities of the found local maximum peaks)
</p>


<h3>Author(s)</h3>

<p>Trung Nghia Vu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res=makeSimulatedData();
X=res$data;
groupLabel=res$label;
returnLocalMaxima(X[2,])
                       
</code></pre>

<hr>
<h2 id='ROIplot'>Plot NMR spectra, together with raw and grouped peaks</h2><span id='topic+ROIplot'></span>

<h3>Description</h3>

<p>This function plots NMR spectra, peak plots and grouped peak plots all in figure for easy comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROIplot(
  Y.spec,
  X.ppm,
  ungrouped.peaks,
  grouped.peaks,
  ROI = NULL,
  ROI.ppm = NULL,
  roiWidth = 100,
  roiWidth.ppm = NULL,
  groupLabels = NULL,
  output = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROIplot_+3A_y.spec">Y.spec</code></td>
<td>
<p>(required) The raw spectra in matrix format (1 sample per row) or numeric vector (in case of 1 spectrum)</p>
</td></tr>
<tr><td><code id="ROIplot_+3A_x.ppm">X.ppm</code></td>
<td>
<p>(required) The vector with the ppm values</p>
</td></tr>
<tr><td><code id="ROIplot_+3A_ungrouped.peaks">ungrouped.peaks</code></td>
<td>
<p>(required) The data resulting from peak detection with wavelets</p>
</td></tr>
<tr><td><code id="ROIplot_+3A_grouped.peaks">grouped.peaks</code></td>
<td>
<p>(required) The data after grouping (with PeakGrouper)</p>
</td></tr>
<tr><td><code id="ROIplot_+3A_roi">ROI</code></td>
<td>
<p>If provided (with an index value, not a ppm value) only this region of interest will be plotted. (supply no ROI or ROI.ppm values, for the full spectrum, or specify only 1, either ROI or ROI.ppm).</p>
</td></tr>
<tr><td><code id="ROIplot_+3A_roi.ppm">ROI.ppm</code></td>
<td>
<p>If provided (a ppm value, not an index value) only this region of interest will be plotted. (supply no ROI or ROI.ppm values, for the full spectrum, or specify only 1, either ROI or ROI.ppm).</p>
</td></tr>
<tr><td><code id="ROIplot_+3A_roiwidth">roiWidth</code></td>
<td>
<p>The width of the ROI (region of interest) plot in index points/measurement points. The plot will span from ROI/ROI.ppm - roiWidth to ROI/ROI.ppm + roiWidth. (only supply roiWidth or roiWidth.ppm if needed).</p>
</td></tr>
<tr><td><code id="ROIplot_+3A_roiwidth.ppm">roiWidth.ppm</code></td>
<td>
<p>The width of the ROI (region of interest) plot in ppm. The plot will span from ROI/ROI.ppm - roiWidth.ppm to ROI/ROI.ppm + roiWidth.ppm. (only supply roiWidth or roiWidth.ppm if needed).</p>
</td></tr>
<tr><td><code id="ROIplot_+3A_grouplabels">groupLabels</code></td>
<td>
<p>The vector with group labels (as factors)</p>
</td></tr>
<tr><td><code id="ROIplot_+3A_output">output</code></td>
<td>
<p>Whether to return a plot (default), or the individual ggplot objects (output = &quot;ggObjects&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset &lt;- GetWinedata.subset()
# to reduce the example time we only select spectra 1 &amp; 2
subset.spectra = as.matrix(subset$Spectra)[1:2,] 
subset.ppm = as.numeric(subset$PPM)

test.peaks &lt;- getWaveletPeaks(Y.spec=subset.spectra, 
                              X.ppm=subset.ppm,
                              nCPU = 1) # nCPU set to 2 for the vignette build

test.grouped &lt;- PeakGrouper(Y.peaks = test.peaks)
                           
ROI.ppm &lt;- 4.9
roiWidth.ppm &lt;- 0.15

plots &lt;- ROIplot(Y.spec = subset.spectra,
                 X.ppm =subset.ppm, 
                 ungrouped.peaks = test.peaks,
                 grouped.peaks = test.grouped ,
                 ROI.ppm = ROI.ppm,
                 roiWidth.ppm = roiWidth.ppm , 
                 output = "ggObjects"
                 )

</code></pre>

<hr>
<h2 id='SCANT'>SCAle, Normalize and Transform a data matrix</h2><span id='topic+SCANT'></span>

<h3>Description</h3>

<p>This function allows the column-wise or row-wise scaling, normalization and transformation operations on a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCANT(data.matrix, type = "unit", feature_orientation = "columns")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCANT_+3A_data.matrix">data.matrix</code></td>
<td>
<p>the data matrix to be scaled, normalized or transformed.</p>
</td></tr>
<tr><td><code id="SCANT_+3A_type">type</code></td>
<td>
<p>the operations to be performed, this can be multiple and are performed sequentially. Any of 'unit', 'pareto', 'log10', 'log2', 'center', 'range', 'vast', or 'max' are accepted.</p>
</td></tr>
<tr><td><code id="SCANT_+3A_feature_orientation">feature_orientation</code></td>
<td>
<p>default = &quot;columns&quot;. This corresponds to the default feature matrix with samples as rows and features as columns. The other option is &quot;rows&quot;: samples as columns and different features as different rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scaled, normalized and/or transformed matrix.
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>References</h3>

<p>van den Berg RA, Hoefsloot HCJ, Westerhuis JA, et al. Centering, scaling, and transformations: improving the biological information content of metabolomics data. BMC Genomics 2006; 7:142.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Samples &lt;- 10
Features &lt;- 20
data.matrix &lt;- matrix(runif(n=Features*Samples, min=0,max=100), 
ncol = Features, nrow = Samples) 

changed_matrix = SCANT(data.matrix, type=c('pareto', 'center'), feature_orientation = 'columns')

</code></pre>

<hr>
<h2 id='SilhouetR'>SilhouetR</h2><span id='topic+SilhouetR'></span>

<h3>Description</h3>

<p>This function calculate Silhouette values. The function is generic, 
as such silhouette values can be calculated between samples of different classes or 
it can be used to calculate silhouette values between different groups of peaks. 
This is the way in which it is used for the speaq package (see the example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SilhouetR(DataMatrix, GroupIndices, distance = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SilhouetR_+3A_datamatrix">DataMatrix</code></td>
<td>
<p>a matrix with the raw data, 1 variable per column.</p>
</td></tr>
<tr><td><code id="SilhouetR_+3A_groupindices">GroupIndices</code></td>
<td>
<p>The vector with the group indices (length must be equal to the amount of rows in DataMatrix).</p>
</td></tr>
<tr><td><code id="SilhouetR_+3A_distance">distance</code></td>
<td>
<p>The distance metric to be used, &quot;euclidean&quot; or &quot;manhattan&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the silhouette values. Note if a group contains only 1 no Silhouette value can be calculated (will give NA)
</p>


<h3>Author(s)</h3>

<p>Charlie Beirnaert, <a href="mailto:charlie.beirnaert@uantwerpen.be">charlie.beirnaert@uantwerpen.be</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset &lt;- GetWinedata.subset()
# to reduce the example time we only select spectra 1 &amp; 2
subset.spectra = as.matrix(subset$Spectra)[1:2,] 
subset.ppm = as.numeric(subset$PPM)

test.peaks &lt;- getWaveletPeaks(Y.spec=subset.spectra, 
                              X.ppm=subset.ppm,
                              nCPU = 1) # nCPU set to 2 for the vignette build
                              
test.grouped &lt;- PeakGrouper(Y.peaks = test.peaks)

Silhouette.values = SilhouetR(DataMatrix = test.grouped$peakPPM, 
                              test.grouped$peakIndex, 
                              distance = "euclidean")
                              
hist(Silhouette.values$SilhouetteValues)


</code></pre>

<hr>
<h2 id='Winedata'>Wine dataset</h2><span id='topic+Winedata'></span>

<h3>Description</h3>

<p>1H-NMR data of 40 wines, different origins and colors are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Winedata)
</code></pre>


<h3>Format</h3>

<p>A list with the spectra, ppm values, color and origin as list entries.
</p>


<h3>Source</h3>

<p>University of Copenhagen, Dept. of Food Science, Quality &amp; Technology. Available at 'models.life.ku.dk/datasets'
</p>


<h3>References</h3>

<p>Larsen et al. (2006) An exploratory chemometric study of 1H-NMR spectra of table wines. J.Chemom. 20 (2006) 198-208
(<a href="https://onlinelibrary.wiley.com/doi/10.1002/cem.991/full">Wiley Online Library</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Winedata)
Spectra &lt;- Winedata$spectra 
ppm.wine &lt;- Winedata$ppm 
wine.color &lt;- Winedata$wine.color 
wine.origin &lt;- Winedata$origin 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
