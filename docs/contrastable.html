<!DOCTYPE html><html lang="en"><head><title>Help for package contrastable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {contrastable}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.add_namespace'><p>Lookup namespace of contrast scheme function</p></a></li>
<li><a href='#.bundle_params'><p>Extract parameters from dots</p></a></li>
<li><a href='#.cols_where'><p>Get columns where</p></a></li>
<li><a href='#.convert_to_factors'><p>Convert non factors to factors</p></a></li>
<li><a href='#.expand_formulas'><p>Expand contrast formulas</p></a></li>
<li><a href='#.get_dimnames'><p>Get dimnames of contrasts from factor</p></a></li>
<li><a href='#.get_from_params'><p>Retrieve value from param list</p></a></li>
<li><a href='#.get_reference_level'><p>Get reference level of contrast matrix</p></a></li>
<li><a href='#.get_reference_levels'><p>Get reference levels from a (possibly set) list of contrasts</p></a></li>
<li><a href='#.get_reserved_operator'><p>Check for reserved operators</p></a></li>
<li><a href='#.get_scheme_labels'><p>Get contrast scheme labels for glimpse table</p></a></li>
<li><a href='#.glimpse_default_factors'><p>Glimpse default factors</p></a></li>
<li><a href='#.is_polynomial_scheme'><p>Check if a scheme is a polynomial scheme</p></a></li>
<li><a href='#.is_reserved_operator'><p>Check if node is a contrast-manipulation operator</p></a></li>
<li><a href='#.is_valid_contrmat'><p>Check if valid contrast</p></a></li>
<li><a href='#.make_parameters'><p>Make parameters for contrast code call</p></a></li>
<li><a href='#.make_placeholder_glimpse'><p>Make glimpse for 1-level factors</p></a></li>
<li><a href='#.msg_if_coerced_to_factors'><p>Alert user when factor coercion happens</p></a></li>
<li><a href='#.msg_if_ordered_reset'><p>Alert user when setting ordered factors</p></a></li>
<li><a href='#.msg_if_remaining_factors'><p>Alert user if there are more factors</p></a></li>
<li><a href='#.plus_to_c'><p>Handle <code>+</code> in formula LHS</p></a></li>
<li><a href='#.postprocess_matrix'><p>Postprocess contrast matrices</p></a></li>
<li><a href='#.process_code_by'><p>Process code_by</p></a></li>
<li><a href='#.process_contrasts'><p>Pass arguments to contrast code</p></a></li>
<li><a href='#.process_factor_col'><p>Process factor column</p></a></li>
<li><a href='#.reset_comparison_labels'><p>Reset comparison labels of matrix to defaults</p></a></li>
<li><a href='#.set_intercept'><p>Set intercept for contrast matrix</p></a></li>
<li><a href='#.set_param'><p>Process and set parameter</p></a></li>
<li><a href='#.split_if_language'><p>Split contrast function using parens</p></a></li>
<li><a href='#.switch_reference_if_needed'><p>Check if reference switching is necessary</p></a></li>
<li><a href='#.switch_reference_level'><p>Switch reference level in contrast matrix</p></a></li>
<li><a href='#.warn_if_mismatched_contrasts'><p>Diagnose glimpse issues and send warnings</p></a></li>
<li><a href='#.warn_if_nondefault'><p>Warn user if nondefault contrasts are set</p></a></li>
<li><a href='#.warn_if_onelevel'><p>Warn if one level factor</p></a></li>
<li><a href='#as.unordered'><p>Convert to unordered factor</p></a></li>
<li><a href='#backward_difference_code'><p>Backward difference code</p></a></li>
<li><a href='#cumulative_split_code'><p>Cumulative split contrasts</p></a></li>
<li><a href='#decompose_contrasts'><p>Decompose contrasts into new columns</p></a></li>
<li><a href='#enlist_contrasts'><p>List of contrast matrices</p></a></li>
<li><a href='#find_same_col'><p>Find column with same non-positive values</p></a></li>
<li><a href='#forward_difference_code'><p>Forward difference code</p></a></li>
<li><a href='#glimpse_contrasts'><p>Glimpse contrasts in dataframe</p></a></li>
<li><a href='#helmert_code'><p>Helmert code</p></a></li>
<li><a href='#interpret_intercept'><p>Interpret intercept from contrasts</p></a></li>
<li><a href='#is_centered'><p>Check for orthogonality</p></a></li>
<li><a href='#is_orthogonal'><p>Check for orthogonality</p></a></li>
<li><a href='#is.unordered'><p>Check for unordered factor</p></a></li>
<li><a href='#orth_polynomial_code'><p>Orthogonal Polynomial code</p></a></li>
<li><a href='#raw_polynomial_code'><p>Raw Polynomial code</p></a></li>
<li><a href='#reverse_helmert_code'><p>Reverse Helmert code</p></a></li>
<li><a href='#scaled_sum_code'><p>Scaled sum coding</p></a></li>
<li><a href='#set_contrasts'><p>Set contrasts to dataframe</p></a></li>
<li><a href='#sum_code'><p>Sum code</p></a></li>
<li><a href='#treatment_code'><p>Treatment code</p></a></li>
<li><a href='#use_contrasts'><p>Contrast code factors</p></a></li>
<li><a href='#use_contrasts.AsIs'><p>AsIs method for use_contrasts</p></a></li>
<li><a href='#use_contrasts.default'><p>Default method for use_contrasts</p></a></li>
<li><a href='#use_contrasts.function'><p>Function method for use_contrasts</p></a></li>
<li><a href='#use_contrasts.hypr'><p>Use a hypr object for contrasts</p></a></li>
<li><a href='#use_contrasts.matrix'><p>Matrix method for use_contrasts</p></a></li>
<li><a href='#use_contrasts.name'><p>Symbol method for use_contrasts</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Consistent Contrast Coding for Factors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Quickly set and summarize contrasts for factors prior to regression  analyses. Intended comparisons, baseline conditions, and intercepts can be explicitly set and documented without the user needing to directly manipulate matrices. Reviews and introductions for contrast coding are available in Brehm and Alday (2022)&lt;<a href="https://doi.org/10.1016%2Fj.jml.2022.104334">doi:10.1016/j.jml.2022.104334</a>&gt; and Schad et al. (2020)&lt;<a href="https://doi.org/10.1016%2Fj.jml.2019.104038">doi:10.1016/j.jml.2019.104038</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, crayon, glue, MASS, purrr, rlang (&ge; 0.1.2), stats,
tidyselect</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, knitr, testthat (&ge; 3.0.0), roxygen2, rmarkdown, covr,
hypr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tsostarics/contrastable">https://github.com/tsostarics/contrastable</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tsostarics/contrastable/issues">https://github.com/tsostarics/contrastable/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-30 14:29:53 UTC; Thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Sostarics <a href="https://orcid.org/0000-0002-1178-7967"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Sostarics &lt;tsostarics@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-01 14:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='.add_namespace'>Lookup namespace of contrast scheme function</h2><span id='topic+.add_namespace'></span>

<h3>Description</h3>

<p>Given the name of a contrast scheme (ie the function name that creates
the contrast matrix), lookup which namespace it belongs to and add it
to the string. Used to report which packages are used in the glimpse table,
e.g., stats, contrastable, bayesTestR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.add_namespace(scheme_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".add_namespace_+3A_scheme_names">scheme_names</code></td>
<td>
<p>Character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of updated function names with namespaces
</p>

<hr>
<h2 id='.bundle_params'>Extract parameters from dots</h2><span id='topic+.bundle_params'></span>

<h3>Description</h3>

<p>If there are any other arguments passed to a contrast coding function by
the user, ensure they're bundled together correctly. This is especially
important for setting the number of levels correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.bundle_params(factor_col, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".bundle_params_+3A_factor_col">factor_col</code></td>
<td>
<p>Factor to set contrasts to</p>
</td></tr>
<tr><td><code id=".bundle_params_+3A_...">...</code></td>
<td>
<p>Other arguments passed by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function call parameters as a list
</p>

<hr>
<h2 id='.cols_where'>Get columns where</h2><span id='topic+.cols_where'></span>

<h3>Description</h3>

<p>Helper to avoid the use of tidyselect and dplyr::select, returns either a
logical vector (optionally named) or a character vector of which columns
satisfy the given function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cols_where(model_data, fx, use_names = FALSE, return_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cols_where_+3A_model_data">model_data</code></td>
<td>
<p>Model data</p>
</td></tr>
<tr><td><code id=".cols_where_+3A_fx">fx</code></td>
<td>
<p>Function to apply, must be something that returns a logical value.
Usually either <code>is.factor</code> or <code>is.ordered</code></p>
</td></tr>
<tr><td><code id=".cols_where_+3A_use_names">use_names</code></td>
<td>
<p>Whether the resulting vector should be named</p>
</td></tr>
<tr><td><code id=".cols_where_+3A_return_names">return_names</code></td>
<td>
<p>Whether names (where the fx returns TRUE) should be
returned instead of a logical vector. Overwrites use.names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Optionally named logical vector or character vector depending on
values of <code>use_names</code> and <code>return_names</code>
</p>

<hr>
<h2 id='.convert_to_factors'>Convert non factors to factors</h2><span id='topic+.convert_to_factors'></span>

<h3>Description</h3>

<p>Helper to convert columns to factors if they aren't already
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.convert_to_factors(model_data, vars_in_model, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".convert_to_factors_+3A_model_data">model_data</code></td>
<td>
<p>Model data</p>
</td></tr>
<tr><td><code id=".convert_to_factors_+3A_vars_in_model">vars_in_model</code></td>
<td>
<p>variables specified for contrast coding from formulas</p>
</td></tr>
<tr><td><code id=".convert_to_factors_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be sent? Defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model_data with specified columns coerced to factors
</p>

<hr>
<h2 id='.expand_formulas'>Expand contrast formulas</h2><span id='topic+.expand_formulas'></span>

<h3>Description</h3>

<p>Uses <code>{tidyselect}</code> functionality to expand the left hand side of a formula
into multiple formulas. See examples of <code>enlist_contrasts</code> for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.expand_formulas(formulas, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".expand_formulas_+3A_formulas">formulas</code></td>
<td>
<p>List of formulas</p>
</td></tr>
<tr><td><code id=".expand_formulas_+3A_data">data</code></td>
<td>
<p>Dataframe to evaluate names in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of formulas
</p>

<hr>
<h2 id='.get_dimnames'>Get dimnames of contrasts from factor</h2><span id='topic+.get_dimnames'></span>

<h3>Description</h3>

<p>Given a factor, extract the row and column names of the contrasts. If they're
not set, then use default values. Also helps to catch invalid usage of
polynomial contrasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_dimnames(factor_col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_dimnames_+3A_factor_col">factor_col</code></td>
<td>
<p>Factor to extract contrasts from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of rownames and column names
</p>

<hr>
<h2 id='.get_from_params'>Retrieve value from param list</h2><span id='topic+.get_from_params'></span>

<h3>Description</h3>

<p>Helper to evaluate param entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_from_params(what, list_params, formulas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_from_params_+3A_what">what</code></td>
<td>
<p>Which parameter to retrieve</p>
</td></tr>
<tr><td><code id=".get_from_params_+3A_list_params">list_params</code></td>
<td>
<p>List of params, see <code><a href="#topic+.make_parameters">.make_parameters()</a></code></p>
</td></tr>
<tr><td><code id=".get_from_params_+3A_formulas">formulas</code></td>
<td>
<p>Formulas used to set contrasts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Requested value for each parameter as a string
</p>

<hr>
<h2 id='.get_reference_level'>Get reference level of contrast matrix</h2><span id='topic+.get_reference_level'></span>

<h3>Description</h3>

<p>Compute the reference level manually if the information isn't available
via parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_reference_level(contrast_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_reference_level_+3A_contrast_matrix">contrast_matrix</code></td>
<td>
<p>Contrast matrix, if NULL will throw an error</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+.get_reference_levels">.get_reference_levels()</a></code>
</p>

<hr>
<h2 id='.get_reference_levels'>Get reference levels from a (possibly set) list of contrasts</h2><span id='topic+.get_reference_levels'></span>

<h3>Description</h3>

<p>Given a list of contrast matrices, if the contrast matrices were explicitly
generated via formulas and they have already had their parameters parsed, use
the parameters to look up the reference level for each contrast matrix. If
the parameters have not been computed (usually because the contrasts are
using the defaults) then look up the reference level manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_reference_levels(contrast_list, list_params = NULL, formulas = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_reference_levels_+3A_contrast_list">contrast_list</code></td>
<td>
<p>List of contrasts, does not need to be named</p>
</td></tr>
<tr><td><code id=".get_reference_levels_+3A_list_params">list_params</code></td>
<td>
<p>Optional list of parameters, see <code><a href="#topic+.make_parameters">.make_parameters()</a></code>, if
NULL, then the reference level is determined from the contrast matrix
directly.</p>
</td></tr>
<tr><td><code id=".get_reference_levels_+3A_formulas">formulas</code></td>
<td>
<p>Optional list of formulas, needed if <code>params</code> are passed.
Used to get the correct environment for evaluating expressions in <code>params</code>.
If NULL, then the reference level is determiend from the contrast matrix
directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of reference levels. If a contrast matrix is not
specified for row names, the character value will denote the integer index
of the row for the reference level (usually 1).
</p>

<hr>
<h2 id='.get_reserved_operator'>Check for reserved operators</h2><span id='topic+.get_reserved_operator'></span>

<h3>Description</h3>

<p>A helper for <code><a href="#topic+.make_parameters">.make_parameters()</a></code>, which takes a symbol and checks
whether it corresponds to one of the reserved operators for the package
syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_reserved_operator(node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_reserved_operator_+3A_node">node</code></td>
<td>
<p>A symbol, extracted from a formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>node</code> is a reserved operator, then return the operator as a
string. Otherwise return the string &quot;none&quot;.
</p>

<hr>
<h2 id='.get_scheme_labels'>Get contrast scheme labels for glimpse table</h2><span id='topic+.get_scheme_labels'></span>

<h3>Description</h3>

<p>Looks up contrast functions from formulas and appends the necessary
namespaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_scheme_labels(list_params, formulas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_scheme_labels_+3A_list_params">list_params</code></td>
<td>
<p>List of params, see <code><a href="#topic+.make_parameters">.make_parameters()</a></code></p>
</td></tr>
<tr><td><code id=".get_scheme_labels_+3A_formulas">formulas</code></td>
<td>
<p>Formulas passed by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>

<hr>
<h2 id='.glimpse_default_factors'>Glimpse default factors</h2><span id='topic+.glimpse_default_factors'></span>

<h3>Description</h3>

<p>Given a dataframe with some factor columns and a character vector of which
columns you've already set yourself, look at all the other factor columns and
get a glimpse at how they're treated by the defaults specified in
<code>options('contrasts')</code>. Reference level is assumed to be the first level for
unordered factors and nonexistent for ordered factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.glimpse_default_factors(
  model_data,
  set_factors = NULL,
  show_one_level_factors = FALSE,
  minimal = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".glimpse_default_factors_+3A_model_data">model_data</code></td>
<td>
<p>Data to be passed to a model fitting function</p>
</td></tr>
<tr><td><code id=".glimpse_default_factors_+3A_set_factors">set_factors</code></td>
<td>
<p>Explicitly set columns to ignore</p>
</td></tr>
<tr><td><code id=".glimpse_default_factors_+3A_show_one_level_factors">show_one_level_factors</code></td>
<td>
<p>Logical, should factors with only one level be
included in the output? Default is FALSE to omit</p>
</td></tr>
<tr><td><code id=".glimpse_default_factors_+3A_minimal">minimal</code></td>
<td>
<p>Logical, default TRUE, whether to omit the orthogonal,
centered, dropped_trends, and explicitly_set columns from the output table</p>
</td></tr>
<tr><td><code id=".glimpse_default_factors_+3A_verbose">verbose</code></td>
<td>
<p>Logical, defaults to TRUE, whether messages should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with information about the contrasts for all remaining factor
columns
</p>

<hr>
<h2 id='.is_polynomial_scheme'>Check if a scheme is a polynomial scheme</h2><span id='topic+.is_polynomial_scheme'></span>

<h3>Description</h3>

<p>Helper to check if a contrast coding function is one of the polynomial
schemes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is_polynomial_scheme(scheme)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".is_polynomial_scheme_+3A_scheme">scheme</code></td>
<td>
<p>Contrast coding function or string of a function name</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if polynomial scheme, <code>FALSE</code> otherwise
</p>

<hr>
<h2 id='.is_reserved_operator'>Check if node is a contrast-manipulation operator</h2><span id='topic+.is_reserved_operator'></span>

<h3>Description</h3>

<p>Some symbols are reserved for the special syntax implemented by the package.
This function checks if a given node (i.e., a call) is one or more of
<code style="white-space: pre;">&#8288;+ - * |&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is_reserved_operator(node, check_sym = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".is_reserved_operator_+3A_node">node</code></td>
<td>
<p>List element</p>
</td></tr>
<tr><td><code id=".is_reserved_operator_+3A_check_sym">check_sym</code></td>
<td>
<p>If NULL (default), check all reserved operators. Otherwise,
a string that will be converted to a symbol.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>node</code> is identical to a reserved operator, otherwise
<code>FALSE</code>
</p>

<hr>
<h2 id='.is_valid_contrmat'>Check if valid contrast</h2><span id='topic+.is_valid_contrmat'></span>

<h3>Description</h3>

<p>Sometimes a user might pass a matrix that can't actually be used, in which
case we can avoid some calculations by stopping earlier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is_valid_contrmat(contrast_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".is_valid_contrmat_+3A_contrast_matrix">contrast_matrix</code></td>
<td>
<p>Contrast matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns TRUE if the contrast matrix is valid
</p>

<hr>
<h2 id='.make_parameters'>Make parameters for contrast code call</h2><span id='topic+.make_parameters'></span>

<h3>Description</h3>

<p>Given a formula, recursively go through the abstract syntax tree and
extract the necessary parameters for <code><a href="#topic+use_contrasts">use_contrasts()</a></code>. While this method is
more involved than extracting from a parsed string representation, I think
it handles matrix calls better since it plucks the call right out of
the syntax tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.make_parameters(
  formula,
  params = list(factor_col = NA, code_by = NA, reference_level = NA, intercept_level =
    NA, drop_trends = NA, labels = NULL, as_is = FALSE),
  env = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".make_parameters_+3A_formula">formula</code></td>
<td>
<p>Formula given by user</p>
</td></tr>
<tr><td><code id=".make_parameters_+3A_params">params</code></td>
<td>
<p>Parameter accumulator</p>
</td></tr>
<tr><td><code id=".make_parameters_+3A_env">env</code></td>
<td>
<p>Environment for the formula, on the first recursion this will be
pulled from <code>formula</code> and then passed to subsequent recursions. Needed to
check whether a function is actually a function.</p>
</td></tr>
<tr><td><code id=".make_parameters_+3A_verbose">verbose</code></td>
<td>
<p>Logical, default <code>TRUE</code>, whether to show drop_trends warning
if used incorrectly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of parameters that can be evaluated in
<code><a href="#topic+.process_contrasts">.process_contrasts()</a></code>
</p>

<hr>
<h2 id='.make_placeholder_glimpse'>Make glimpse for 1-level factors</h2><span id='topic+.make_placeholder_glimpse'></span>

<h3>Description</h3>

<p>If the user wants factors with only one level included, this will create
the table to present that information. It's a lot of NAs because contrasts
aren't defined for only 1 level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.make_placeholder_glimpse(model_data, one_level_factors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".make_placeholder_glimpse_+3A_model_data">model_data</code></td>
<td>
<p>Model data</p>
</td></tr>
<tr><td><code id=".make_placeholder_glimpse_+3A_one_level_factors">one_level_factors</code></td>
<td>
<p>Which factors are one level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with limited information about one level factors
</p>

<hr>
<h2 id='.msg_if_coerced_to_factors'>Alert user when factor coercion happens</h2><span id='topic+.msg_if_coerced_to_factors'></span>

<h3>Description</h3>

<p>messages the user if columns in the dataset have been coerced to a factor,
useful if you accidentally set a column with continuous data to a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.msg_if_coerced_to_factors(which_to_factors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".msg_if_coerced_to_factors_+3A_which_to_factors">which_to_factors</code></td>
<td>
<p>Names of columns that have been coerced to factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, messages the user if needed.
</p>

<hr>
<h2 id='.msg_if_ordered_reset'>Alert user when setting ordered factors</h2><span id='topic+.msg_if_ordered_reset'></span>

<h3>Description</h3>

<p>Ordered factors use orthogonal polynomials (contr.poly) by default with
k number of levels -1 (k-1) of trend comparisons. If you use these functions
to set the contrasts to something else, the ordered class (hence ordering
to the levels) will remain but the contrasts will be set to something else.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.msg_if_ordered_reset(model_data, vars_in_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".msg_if_ordered_reset_+3A_model_data">model_data</code></td>
<td>
<p>Data frame to be used with the model</p>
</td></tr>
<tr><td><code id=".msg_if_ordered_reset_+3A_vars_in_model">vars_in_model</code></td>
<td>
<p>Variables to check against</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, messages the user.
</p>

<hr>
<h2 id='.msg_if_remaining_factors'>Alert user if there are more factors</h2><span id='topic+.msg_if_remaining_factors'></span>

<h3>Description</h3>

<p>messages the user if the user has factor columns in their model data frame
that weren't specified along with any factors they DID set contrasts for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.msg_if_remaining_factors(model_data, specified_vars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".msg_if_remaining_factors_+3A_model_data">model_data</code></td>
<td>
<p>Model data</p>
</td></tr>
<tr><td><code id=".msg_if_remaining_factors_+3A_specified_vars">specified_vars</code></td>
<td>
<p>Variables specified by the user from formulas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, messages the user if needed.
</p>

<hr>
<h2 id='.plus_to_c'>Handle <code>+</code> in formula LHS</h2><span id='topic+.plus_to_c'></span>

<h3>Description</h3>

<p>Given a formula like cyl + gear ~ sum_code, this function recursively
replaces the <code>+</code> operators with <code>c</code> so that the LHS becomes <code>c(cyl, gear)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.plus_to_c(plus_expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".plus_to_c_+3A_plus_expr">plus_expr</code></td>
<td>
<p>Expression</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function doesn't recurse into other function calls, for example:
<code>cyl + gear + factor(1 + 2)</code> evaluates to <code>c(cyl, gear, factor(1+2))</code>.
</p>


<h3>Value</h3>

<p>A new expression where <code>+</code> is replaced with <code>c()</code>
</p>

<hr>
<h2 id='.postprocess_matrix'>Postprocess contrast matrices</h2><span id='topic+.postprocess_matrix'></span>

<h3>Description</h3>

<p>When using <code><a href="#topic+use_contrasts">use_contrasts()</a></code> with a function or matrix, there are shared
postprocessing steps for manipulating the contrasts to set the reference
level, intercept, and labels. If as_is is TRUE, then these post processing
steps aren't included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.postprocess_matrix(
  new_contrasts,
  code_by,
  reference_level,
  set_intercept,
  drop_trends,
  matrix_labels,
  labels,
  as_is,
  dots
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".postprocess_matrix_+3A_new_contrasts">new_contrasts</code></td>
<td>
<p>Contrast matrix passed from <code><a href="#topic+use_contrasts">use_contrasts()</a></code></p>
</td></tr>
<tr><td><code id=".postprocess_matrix_+3A_code_by">code_by</code></td>
<td>
<p>What to code with, passed from <code><a href="#topic+use_contrasts">use_contrasts()</a></code></p>
</td></tr>
<tr><td><code id=".postprocess_matrix_+3A_reference_level">reference_level</code></td>
<td>
<p>Reference level specification</p>
</td></tr>
<tr><td><code id=".postprocess_matrix_+3A_set_intercept">set_intercept</code></td>
<td>
<p>Intercept specification</p>
</td></tr>
<tr><td><code id=".postprocess_matrix_+3A_drop_trends">drop_trends</code></td>
<td>
<p>Any trends to drop</p>
</td></tr>
<tr><td><code id=".postprocess_matrix_+3A_matrix_labels">matrix_labels</code></td>
<td>
<p>Labels from the matrix dimension names</p>
</td></tr>
<tr><td><code id=".postprocess_matrix_+3A_labels">labels</code></td>
<td>
<p>User-specified labels</p>
</td></tr>
<tr><td><code id=".postprocess_matrix_+3A_as_is">as_is</code></td>
<td>
<p>Whether to use matrix as-is</p>
</td></tr>
<tr><td><code id=".postprocess_matrix_+3A_dots">dots</code></td>
<td>
<p>Any additional arguments passed with code_by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Contrast matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+use_contrasts">use_contrasts()</a></code>
</p>

<hr>
<h2 id='.process_code_by'>Process code_by</h2><span id='topic+.process_code_by'></span>

<h3>Description</h3>

<p>Handles the <code>code_by</code> parameter and checks to make sure whether we can
safely drop trends or not. Also handles any usage of <code><a href="base.html#topic+I">I()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.process_code_by(formula, params, env, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".process_code_by_+3A_formula">formula</code></td>
<td>
<p>Formula used to set contrast</p>
</td></tr>
<tr><td><code id=".process_code_by_+3A_params">params</code></td>
<td>
<p>Parameter list</p>
</td></tr>
<tr><td><code id=".process_code_by_+3A_env">env</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id=".process_code_by_+3A_verbose">verbose</code></td>
<td>
<p>Whether to throw the warning about invalid <code>-</code> usage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified parameter list with updated <code>code_by</code>
</p>

<hr>
<h2 id='.process_contrasts'>Pass arguments to contrast code</h2><span id='topic+.process_contrasts'></span>

<h3>Description</h3>

<p>Processes a formula and any arguments for the contrast matrix and sets up
the use_contrasts call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.process_contrasts(model_data, raw_formula, omit_drop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".process_contrasts_+3A_model_data">model_data</code></td>
<td>
<p>Data frame with factor column</p>
</td></tr>
<tr><td><code id=".process_contrasts_+3A_raw_formula">raw_formula</code></td>
<td>
<p>Raw formula</p>
</td></tr>
<tr><td><code id=".process_contrasts_+3A_omit_drop">omit_drop</code></td>
<td>
<p>Logical, set to TRUE when set_contrasts is used by
appending an attribute to the formula list, otherwise is FALSE (as in
enlist_contrasts)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast matrix
</p>

<hr>
<h2 id='.process_factor_col'>Process factor column</h2><span id='topic+.process_factor_col'></span>

<h3>Description</h3>

<p>This is usually the first thing to be processed in a formula like
<code>varname ~ x</code>; ensures that <code>varname</code> is treated as a factor vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.process_factor_col(cur_expr, params, env, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".process_factor_col_+3A_cur_expr">cur_expr</code></td>
<td>
<p>Current expression, see <code><a href="#topic+.make_parameters">.make_parameters()</a></code></p>
</td></tr>
<tr><td><code id=".process_factor_col_+3A_params">params</code></td>
<td>
<p>Parameter accumulator</p>
</td></tr>
<tr><td><code id=".process_factor_col_+3A_env">env</code></td>
<td>
<p>Environment for the formula, on the first recursion this will be
pulled from <code>formula</code> and then passed to subsequent recursions. Needed to
check whether a function is actually a function.</p>
</td></tr>
<tr><td><code id=".process_factor_col_+3A_verbose">verbose</code></td>
<td>
<p>Logical, default <code>TRUE</code>, whether to show drop_trends warning
if used incorrectly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter list with <code>factor_col</code> updated
</p>

<hr>
<h2 id='.reset_comparison_labels'>Reset comparison labels of matrix to defaults</h2><span id='topic+.reset_comparison_labels'></span>

<h3>Description</h3>

<p>Given a contrast matrix and a coding function used to generate it, check
whether we have default labels implemented. If so, use them if the matrix
doesn't have unique ones. If no function is provided, just use what the
matrix has or use numeric indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.reset_comparison_labels(contr_mat, coding_fx = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".reset_comparison_labels_+3A_contr_mat">contr_mat</code></td>
<td>
<p>Contrast matrix</p>
</td></tr>
<tr><td><code id=".reset_comparison_labels_+3A_coding_fx">coding_fx</code></td>
<td>
<p>Function name as a string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with column names changed if necessary
</p>

<hr>
<h2 id='.set_intercept'>Set intercept for contrast matrix</h2><span id='topic+.set_intercept'></span>

<h3>Description</h3>

<p>Given a contrast matrix and a desired level, change the intercept via
manipulating underlying hypothesis matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.set_intercept(contrast_matrix, intercept_level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".set_intercept_+3A_contrast_matrix">contrast_matrix</code></td>
<td>
<p>Contrast matrix to use</p>
</td></tr>
<tr><td><code id=".set_intercept_+3A_intercept_level">intercept_level</code></td>
<td>
<p>Level to use as intercept, must be present in the
row names of the contrast matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Manipulated contrast matrix
</p>

<hr>
<h2 id='.set_param'>Process and set parameter</h2><span id='topic+.set_param'></span>

<h3>Description</h3>

<p>Unpacks the given expression to set the parameter specified by <code>which_param</code>
to <code>params</code>. Continues recursively setting parameters via
<code><a href="#topic+.make_parameters">.make_parameters()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.set_param(cur_expr, params, env, which_param, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".set_param_+3A_cur_expr">cur_expr</code></td>
<td>
<p>Current expression, a formula or list representation thereof</p>
</td></tr>
<tr><td><code id=".set_param_+3A_params">params</code></td>
<td>
<p>Parameter accumulator</p>
</td></tr>
<tr><td><code id=".set_param_+3A_env">env</code></td>
<td>
<p>Environment for the formula, on the first recursion this will be
pulled from <code>formula</code> and then passed to subsequent recursions. Needed to
check whether a function is actually a function.</p>
</td></tr>
<tr><td><code id=".set_param_+3A_which_param">which_param</code></td>
<td>
<p>Which parameter to set, a string
for usage</p>
</td></tr>
<tr><td><code id=".set_param_+3A_verbose">verbose</code></td>
<td>
<p>Logical, default <code>TRUE</code>, whether to show drop_trends warning
if used incorrectly</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>params</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.make_parameters">.make_parameters()</a></code>
</p>

<hr>
<h2 id='.split_if_language'>Split contrast function using parens</h2><span id='topic+.split_if_language'></span>

<h3>Description</h3>

<p>If something like <code>set_contrasts(df, var ~ sum_code())</code> then what's
extracted from the formula isn't the symbol for the function <code>sum_code</code> but
a language object. This can be converted to a list to extract the function
symbol and then any arguments provided in the parens. The latter needs to
be evaluated in the original environment, for example if
<code style="white-space: pre;">&#8288;set_contrasts(df, var ~ sum_code(scores=c(.1,.5,.6))&#8288;</code> is called, the scores
list would not evaluate the <code>c(...)</code> call, yielding an error that the scores
argument isn't the right length (because it would be length 1, not 3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.split_if_language(params, var_envir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".split_if_language_+3A_params">params</code></td>
<td>
<p>Parameters extracted from formula parsing</p>
</td></tr>
<tr><td><code id=".split_if_language_+3A_var_envir">var_envir</code></td>
<td>
<p>Environment to evaluate expressions in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter list with <code>code_by</code> set to the correct symbol &amp; an
additional list entry for other arguments, which will be empty if no
arguments are provided.
</p>

<hr>
<h2 id='.switch_reference_if_needed'>Check if reference switching is necessary</h2><span id='topic+.switch_reference_if_needed'></span>

<h3>Description</h3>

<p>Check if the contrast matrix is able to switch reference levels, and if it
is requested, do so
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.switch_reference_if_needed(
  contrast_matrix,
  new_reference_label = NA,
  new_reference_index
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".switch_reference_if_needed_+3A_contrast_matrix">contrast_matrix</code></td>
<td>
<p>Contrast matrix</p>
</td></tr>
<tr><td><code id=".switch_reference_if_needed_+3A_new_reference_label">new_reference_label</code></td>
<td>
<p>Name of the level to use</p>
</td></tr>
<tr><td><code id=".switch_reference_if_needed_+3A_new_reference_index">new_reference_index</code></td>
<td>
<p>Index of the level to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Contrast matrix with reference level swapped if needed
</p>

<hr>
<h2 id='.switch_reference_level'>Switch reference level in contrast matrix</h2><span id='topic+.switch_reference_level'></span>

<h3>Description</h3>

<p>Reorders the rows of a contrast matrix to properly set the reference level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.switch_reference_level(contrast_matrix, old_reference, new_reference)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".switch_reference_level_+3A_contrast_matrix">contrast_matrix</code></td>
<td>
<p>An unlabeled contrast matrix</p>
</td></tr>
<tr><td><code id=".switch_reference_level_+3A_old_reference">old_reference</code></td>
<td>
<p>The previously specified reference level, usually the
default for the scheme found by <code>.get_reference_level</code></p>
</td></tr>
<tr><td><code id=".switch_reference_level_+3A_new_reference">new_reference</code></td>
<td>
<p>The index of the row to use as the new reference level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the reordered rows and correct values for the reference
level
</p>

<hr>
<h2 id='.warn_if_mismatched_contrasts'>Diagnose glimpse issues and send warnings</h2><span id='topic+.warn_if_mismatched_contrasts'></span>

<h3>Description</h3>

<p><code><a href="#topic+glimpse_contrasts">glimpse_contrasts()</a></code> does not modify the dataframe passed to it, which can
result in mismatches between the data the user will use and the glimpse
information presented. This runs many diagnostics to inform the use of such
mismatches and provides suggestions on how to fix the issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.warn_if_mismatched_contrasts(
  model_data,
  contrast_list,
  model_data_name,
  dots_names,
  formulas
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".warn_if_mismatched_contrasts_+3A_model_data">model_data</code></td>
<td>
<p>Data user passed to <code><a href="#topic+glimpse_contrasts">glimpse_contrasts()</a></code></p>
</td></tr>
<tr><td><code id=".warn_if_mismatched_contrasts_+3A_contrast_list">contrast_list</code></td>
<td>
<p>List of contrasts created by <code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code></p>
</td></tr>
<tr><td><code id=".warn_if_mismatched_contrasts_+3A_model_data_name">model_data_name</code></td>
<td>
<p>Name of the dataframe passed to the user, will be
truncated if it's a long expression that has (likely) been piped</p>
</td></tr>
<tr><td><code id=".warn_if_mismatched_contrasts_+3A_dots_names">dots_names</code></td>
<td>
<p>Usually &quot;...&quot;, in this case, the <code>...</code> filled in by the
user (ie contrast formulas) will need to be expanded in the suggested fixes</p>
</td></tr>
<tr><td><code id=".warn_if_mismatched_contrasts_+3A_formulas">formulas</code></td>
<td>
<p>Formulas passed by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, issues warnings to the user.
</p>

<hr>
<h2 id='.warn_if_nondefault'>Warn user if nondefault contrasts are set</h2><span id='topic+.warn_if_nondefault'></span>

<h3>Description</h3>

<p>R automatically assigns specific contrast schemes to ordered and unordered
factors as specified in <code>options('contrasts')</code> but users are of course free
to set these on the factor themselves. But, if they do this outside of a call
to <code>glimpse_contrasts</code> it's hard and time consuming to check what they set
against the different possible common schemes. So, rather than checking all
possible combinations, this will only check against the defaults R already
uses and alert the user if something else is set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.warn_if_nondefault(
  contrast_list,
  factor_names,
  factor_sizes,
  which_ordered,
  schemes_to_use
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".warn_if_nondefault_+3A_contrast_list">contrast_list</code></td>
<td>
<p>List of contrasts like that generated by
<code>enlist_contrasts</code></p>
</td></tr>
<tr><td><code id=".warn_if_nondefault_+3A_factor_names">factor_names</code></td>
<td>
<p>Names of the factors, also the names of the contrast list</p>
</td></tr>
<tr><td><code id=".warn_if_nondefault_+3A_factor_sizes">factor_sizes</code></td>
<td>
<p>Number of levels for each factor</p>
</td></tr>
<tr><td><code id=".warn_if_nondefault_+3A_which_ordered">which_ordered</code></td>
<td>
<p>Which of the factors are ordered</p>
</td></tr>
<tr><td><code id=".warn_if_nondefault_+3A_schemes_to_use">schemes_to_use</code></td>
<td>
<p>Character vector of schemes, if any don't match the
default for a factor, it will be replaced wtih ??? in th eoutput</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Warns if non default contrasts are set, returns schemes_to_use with
modifications if necessary
</p>

<hr>
<h2 id='.warn_if_onelevel'>Warn if one level factor</h2><span id='topic+.warn_if_onelevel'></span>

<h3>Description</h3>

<p>Factors with only one level happen if a character vector is converted to a
factor using <code>factor()</code> but without specifying anything for the <code>levels</code>
parameter. If you try to access or set the contrasts for a one-level factor,
you'll get an error that contrasts are undefined because you have 0 degrees
of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.warn_if_onelevel(
  one_level_factors = NULL,
  model_data = NULL,
  attempting_factors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".warn_if_onelevel_+3A_one_level_factors">one_level_factors</code></td>
<td>
<p>Character vector of which factors are one level</p>
</td></tr>
<tr><td><code id=".warn_if_onelevel_+3A_model_data">model_data</code></td>
<td>
<p>Model data to look for factor columns</p>
</td></tr>
<tr><td><code id=".warn_if_onelevel_+3A_attempting_factors">attempting_factors</code></td>
<td>
<p>Factor column names to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, warns if factors with only one level are detected.
</p>

<hr>
<h2 id='as.unordered'>Convert to unordered factor</h2><span id='topic+as.unordered'></span>

<h3>Description</h3>

<p>Unordered analogue of base R's <code>as.ordered</code>. Will convert <code>x</code> to an unordered
factor; unlike <code>as.factor()</code>, this will convert ordered factors to unordered
factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.unordered(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.unordered_+3A_x">x</code></td>
<td>
<p>Object to convert to unordered factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> as an unordered factor
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.factor">as.factor()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Convert an ordered factor to unordered
as.unordered(gl(5,1,ordered = TRUE))

# If level order is pre-specified differently from default alphabetical order
# then the ordering will be retained
as.unordered(ordered(c("a", "b", "c"), levels = c("c", "a", "b")))

# Otherwise the vector will be converted to an unordered factor with levels
# in the default alphabetical order
as.unordered(c("c", "a", "b"))

# Note that coercing integer values will sort the values to use as the levels
as.unordered(4:1)
</code></pre>

<hr>
<h2 id='backward_difference_code'>Backward difference code</h2><span id='topic+backward_difference_code'></span>

<h3>Description</h3>

<p>Compares the mean of level k to level k-1. Differs in direction from
<a href="#topic+forward_difference_code">forward_difference_code</a>, so be careful to pick the
right function.  See also <a href="MASS.html#topic+contr.sdif">contr.sdif</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backward_difference_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backward_difference_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example interpretation for a 4 level factor:
</p>

<ul>
<li><p> Intercept = Grand mean (mean of the means of each level)
</p>
</li>
<li><p> grp1 = mean(grp2) - mean(grp1)
</p>
</li>
<li><p> grp2 = mean(grp3) - mean(grp2)
</p>
</li>
<li><p> grp3 = mean(grp4) - mean(grp3)
</p>
</li></ul>



<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf &lt;- data.frame(
  grp = gl(4,5),
  resp = c(seq(1, 5), seq(5, 9), seq(10, 14), seq(15, 19))
)

mydf &lt;- set_contrasts(mydf, grp ~ backward_difference_code)

lm(resp ~ grp, data = mydf)
</code></pre>

<hr>
<h2 id='cumulative_split_code'>Cumulative split contrasts</h2><span id='topic+cumulative_split_code'></span>

<h3>Description</h3>

<p>Contrast coding scheme that repeatedly dichotomizes the factor levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative_split_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumulative_split_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This scheme is similar to Helmert contrasts, but instead of comparing one
level to the accumulated mean of all previous levels, each comparison with
this scheme splits the levels into two groups: those below and including
the current level, and those above the current level. Conceptually this is
similar to continuation ratio logits used in ordinal models. For example,
with a four level factor with levels A, B, C, and D, the comparisons would
be:
</p>

<ul>
<li><p> A vs. BCD
</p>
</li>
<li><p> AB vs. CD
</p>
</li>
<li><p> ABC vs. D
</p>
</li></ul>

<p>In other words, each comparison splits the levels into two groups.
Each of these comparisons uses the cumulative mean of all the levels in
each group. The intercept is the grand mean.
</p>


<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(111)
mydf &lt;- data.frame(
  grp = rep(c("a", "b", "c", "d"), each = 2000),
  val = c(
    rnorm(200, 2, 1),
    rnorm(200, 5, 1),
    rnorm(200, 7.5, 1),
    rnorm(200, 15, 1)
  )
) |&gt;
  set_contrasts(grp ~ cumulative_split_code |
    c("a-rest", "ab-rest", "abc-rest"))

lm(val ~ grp, data = mydf)

</code></pre>

<hr>
<h2 id='decompose_contrasts'>Decompose contrasts into new columns</h2><span id='topic+decompose_contrasts'></span>

<h3>Description</h3>

<p>Given a dataframe with factor columns, this function will extract the
contrasts from the factor column and place them inside new columns. This is
useful for cases where you want to work with the numeric values of the
contrasts. For a pedagogical example, you can explicitly show how factor
variables are transformed into numeric values. For a practical example,
you're typically allowed n-1 contrasts for n levels of a factor. If you don't
want to use all of the contrasts, you can extract the ones you want and use
them in your model. This is sometimes used with polynomial contrasts when you
don't want to use higher order polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decompose_contrasts(
  model_data,
  extract,
  remove_intercept = TRUE,
  remove_original = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decompose_contrasts_+3A_model_data">model_data</code></td>
<td>
<p>Dataframe with factor columns</p>
</td></tr>
<tr><td><code id="decompose_contrasts_+3A_extract">extract</code></td>
<td>
<p>A one-sided formula denoting the factors to extract. Note this
should ideally be what you would pass to your model fitting function, sans
any non-factors.</p>
</td></tr>
<tr><td><code id="decompose_contrasts_+3A_remove_intercept">remove_intercept</code></td>
<td>
<p>Logical, whether to remove the column corresponding
to the intercept. Default <code>TRUE</code>  since it's always just a column of 1s</p>
</td></tr>
<tr><td><code id="decompose_contrasts_+3A_remove_original">remove_original</code></td>
<td>
<p>Logical, whether to remove the original columns in
the data frame after decomposing into separate columns. Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An additional usage for this function is to compute the contrasts for
interaction terms in a model. In <code>lm(y ~ A * B)</code>, where A and B are factors,
the expanded form is <code>lm(y ~ A + B + A:B)</code> with an equation of <code class="reqn">y =
\beta_Ax_A + \beta_Bx_B + \beta_{A:B}x_Ax_B</code>. The thing to note is that the
coefficient for the interaction(s) are multiplied by the product of <code class="reqn">x_A</code>
and <code class="reqn">x_B</code>. Let's call this product <code class="reqn">x_C</code>. For example, if one value
of <code class="reqn">x_A</code> is
-1/3 and one value of <code class="reqn">x_B</code> is 2/3, then the product <code class="reqn">x_C</code> is -2/9.
But, if there are 3 levels for <code class="reqn">x_A</code> and 3 levels for <code class="reqn">x_B</code>, then we
get 4 columns for the fixed effects <em>and</em> 4 <em>more</em> columns for the
interaction terms. It can be a lot of tedious work to precompute the products
manually, so we can use this function with <code>extract_interaction = TRUE</code> to
compute everything at once.
</p>


<h3>Value</h3>

<p><code>model_data</code> but with new columns corresponding to the numeric coding
of the given factor's contrasts
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_contrasts">set_contrasts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Decompose contrasts for carb and gear columns into new columns, using
# the contrast labels used when setting the contrasts
mtcars |&gt;
  set_contrasts(
    carb ~ scaled_sum_code,
    gear ~ contr.sum | c("4-mean", "5-mean")
  ) |&gt;
  decompose_contrasts(~ carb + gear) |&gt;
  str()

# Decompose an interaction term between the two factors
mtcars |&gt;
  set_contrasts(
    carb ~ scaled_sum_code,
    gear ~ contr.sum | c("4-mean", "5-mean")
  ) |&gt;
  decompose_contrasts(~ carb * gear) |&gt;
  str()

</code></pre>

<hr>
<h2 id='enlist_contrasts'>List of contrast matrices</h2><span id='topic+enlist_contrasts'></span>

<h3>Description</h3>

<p>Returns a named list of contrast matrices to use with modeling
functions directly. See <code><a href="#topic+set_contrasts">set_contrasts()</a></code> for a function
to set contrasts directly to the dataframe. See details for syntax
information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enlist_contrasts(model_data, ..., verbose = getOption("contrastable.verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enlist_contrasts_+3A_model_data">model_data</code></td>
<td>
<p>Data frame you intend on passing to your model</p>
</td></tr>
<tr><td><code id="enlist_contrasts_+3A_...">...</code></td>
<td>
<p>A series of 2 sided formulas with factor name on the left hand
side and desired contrast scheme on the right hand side. The reference
level can be set with <code>+</code>, the intercept can be overwritten with <code>*</code>,
comparison labels can be set using <code>|</code>, and trends for polynomial coding
can be removed using <code>-</code>.</p>
</td></tr>
<tr><td><code id="enlist_contrasts_+3A_verbose">verbose</code></td>
<td>
<p>Logical, defaults to FALSE, whether messages should be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code>, <code><a href="#topic+set_contrasts">set_contrasts()</a></code>,
and <code><a href="#topic+glimpse_contrasts">glimpse_contrasts()</a></code> use special syntax to set
contrasts for multiple factors. The syntax consists of two-sided formulas
with the desired factor column on the left hand side and the contrast
specification on the right hand side. For example, <code>varname ~ scaled_sum_code</code>. Many contrasts support additional kinds of contrast
manipulations using overloaded operators:
</p>

<ul>
<li> <p><code>+ X</code>: Set the reference level to the level named X. Only supported for
schemes that have a singular reference level such as
<code><a href="#topic+sum_code">sum_code()</a></code>, <code><a href="#topic+scaled_sum_code">scaled_sum_code()</a></code>,
<code><a href="#topic+treatment_code">treatment_code()</a></code>, <code><a href="stats.html#topic+contrast">stats::contr.treatment()</a></code>,
<code><a href="stats.html#topic+contrast">stats::contr.sum()</a></code>, <code><a href="stats.html#topic+contrast">stats::contr.SAS()</a></code>. Ignored for schemes like
<code><a href="#topic+helmert_code">helmert_code()</a></code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;* X&#8288;</code>: Overwrite the intercept to the mean of the level named X
</p>
</li>
<li> <p><code>- A:B</code>: For polynomial coding schemes only, drop comparisons A through B.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;| c(...)&#8288;</code>: Change the comparison labels for the contrast matrix to the
character vector <code>c(...)</code> of length <code>n-1</code>. These labels will appear in the
output/summary of a statistical model. Note that for <code>brms::brm</code>,
instances of <code>-</code> (a minus sign) are replaced with <code>M</code>.
</p>
</li></ul>

<p>You can also specify multiple variables on the left hand side of a formula
using tidyselect helpers. See examples for more information.
</p>
<p>Typically model functions like lm will have a contrasts argument where you
can set the contrasts at model run time, rather than having to manually
change the contrasts on the underlying factor columns in your data. This
function will return such a named list of contrast matrices to pass to these
functions. Note that this function should not be used within a modeling
function call, e.g., <code>lm(y~x, data = model_data, contrasts =
enlist_contrasts(model_data, x~sum_code))</code>. Often, this will call
<code>enlist_contrasts</code> twice, rather than just once.
</p>
<p>For some model fitting functions, like <code>brms::brm</code>, there is no
contrasts argument. For such cases, use <code><a href="#topic+set_contrasts">set_contrasts()</a></code> to
set contrasts directly to the factors in a dataframe.
</p>
<p>One good way to use <code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code> is in conjunction
with <code><a href="MASS.html#topic+fractions">MASS::fractions()</a></code> to create a list of matrices that can be printed
to explicitly show the entire contrast matrices you're using for your models.
This can be especially helpful for supplementary materials in an academic
paper.
</p>
<p>Sometimes when using orthogonal polynomial contrasts from
<code><a href="stats.html#topic+contrast">stats::contr.poly()</a></code> people will drop higher level polynomials for
parsimony. Note however that these do capture some amount of variation, so
even though they're orthogonal contrasts the lower level polynomials will
have their estimates changed. Moreover, you cannot reduce a contrast matrix
to a matrix smaller than size n*n-1 in the dataframe you pass to a model
fitting function itself, as R will try to fill in the gaps with something
else. If you want to drop contrasts you'll need to use something like
<code>enlist_contrasts(df, x ~ contr.poly - 3:5)</code> and pass this to the
<code>contrasts</code> argument in the model fitting function.
</p>


<h3>Value</h3>

<p>List of named contrast matrices. Internally, if called within
set_contrasts, will return a named list with <code>contrasts</code> equal to the list
of named contrast matrices and <code>data</code> equal to the passed <code>model_data</code> with
any factor coercions applied (so that <code><a href="#topic+set_contrasts">set_contrasts()</a></code> doesn't need to do
it a second time).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_contrasts">set_contrasts()</a></code> <code><a href="#topic+glimpse_contrasts">glimpse_contrasts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_df &lt;- mtcars
my_df$gear &lt;- factor(my_df$gear)
my_df$carb &lt;- factor(my_df$carb)

# Use formulas where left hand side is the factor column name
# and the right hand side is the contrast scheme you want to use
enlist_contrasts(
  my_df,
  gear ~ scaled_sum_code,
  carb ~ helmert_code,
  verbose = FALSE
)

# Add reference levels with +
enlist_contrasts(
  my_df,
  gear ~ scaled_sum_code + 5,
  carb ~ contr.sum + 6,
  verbose = FALSE
)
# Manually specifying matrix also works
enlist_contrasts(
  my_df,
  gear ~ matrix(c(1, -1, 0, 0, -1, 1), nrow = 3),
  carb ~ forward_difference_code,
  verbose = FALSE
)

# User matrices can be assigned to a variable first, but this may make the
# comparison labels confusing. You should rename them manually to something
# that makes sense. This will invoke use_contrast_matrix, so reference levels
# specified with + will be ignored.
my_gear_contrasts &lt;- matrix(c(1, -1, 0, 0, -1, 1), nrow = 3)
colnames(my_gear_contrasts) &lt;- c("CMP1", "CMP2")
enlist_contrasts(
  my_df,
  gear ~ my_gear_contrasts,
  carb ~ forward_difference_code,
  verbose = FALSE
)


# Will inform you if there are factors you didn't set
enlist_contrasts(my_df, gear ~ scaled_sum_code)

# Use MASS::fractions to pretty print matrices for academic papers:
lapply(enlist_contrasts(my_df, gear ~ scaled_sum_code, carb ~ helmert_code),
       MASS::fractions)

# Use a list of formulas to use the same contrasts with different datasets
my_contrasts &lt;- list(gear ~ scaled_sum_code, carb ~ helmert_code)
enlist_contrasts(my_df,  my_contrasts)
enlist_contrasts(mtcars, my_contrasts)

# Use tidyselect helpers to set multiple variables at once
# These are all equivalent
contr_list1 &lt;- enlist_contrasts(mtcars,
                 cyl ~ sum_code, gear ~ sum_code,
                 verbose = FALSE)

contr_list2 &lt;- enlist_contrasts(mtcars,
                 cyl + gear ~ sum_code,
                 verbose = FALSE)

contr_list3 &lt;- enlist_contrasts(mtcars,
                 c(cyl, gear) ~ sum_code,
                 verbose = FALSE)

contr_list4 &lt;- enlist_contrasts(mtcars,
                 all_of(c('cyl', 'gear')) ~ sum_code,
                 verbose = FALSE)


these_vars &lt;- c("cyl", "gear")
contr_list5 &lt;- enlist_contrasts(mtcars,
                                all_of(these_vars) ~ sum_code,
                                verbose = FALSE)

all.equal(contr_list1, contr_list2)
all.equal(contr_list2, contr_list3)
all.equal(contr_list3, contr_list4)
all.equal(contr_list4, contr_list5)

# You can also use [tidyselect::where()] with class checking helpers:
contr_list6 &lt;- enlist_contrasts(mtcars,
                                where(is.numeric) ~ sum_code,
                                verbose = FALSE)

# Each variable name must only be set ONCE, e.g. these will fail:
try(enlist_contrasts(mtcars,
                     cyl ~ sum_code,
                     cyl ~ scaled_sum_code,
                     verbose = FALSE))
try(enlist_contrasts(mtcars,
                     cyl ~ sum_code,
                     all_of(these_vars) ~ scaled_sum_code,
                     verbose = FALSE))
try(enlist_contrasts(mtcars,
                     cyl ~ sum_code,
                     where(is.numeric) ~ scaled_sum_code,
                     verbose = FALSE))
</code></pre>

<hr>
<h2 id='find_same_col'>Find column with same non-positive values</h2><span id='topic+find_same_col'></span>

<h3>Description</h3>

<p>The inverse matrix of a contrast matrix has a useful property
where, after removing the row corresponding to the intercept,
the reference level is the column index where each value in
that column is (1) the same and (2) less than or equal to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_same_col(invmatrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_same_col_+3A_invmatrix">invmatrix</code></td>
<td>
<p>Inverse of the hypothesis matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a contrast matrix generated from an expression <code>x</code>, with
number of levels n, consider the inverse matrices from
<code>solve(.contrasts_to_hypotheses(x))</code> below for different <code>x</code>:
</p>

<ul>
<li><p> contr.treatment: The first column contains all 0s, hence
the reference level is the first level
</p>
</li>
<li><p> contr.SAS: The last column contains all 0s, hence the
reference level is the last level
</p>
</li>
<li><p> scaled_sum_code: The first column contains all -1/n, hence
the reference level is the first level
</p>
</li>
<li><p> helmert_code: While the first column contains all negative
numbers, they are not the same EXCEPT if n=2
</p>
</li></ul>

<p>Note that &quot;reference level&quot; here is defined as a level from
which every other level is compared to via pairwise comparisons.
</p>


<h3>Value</h3>

<p>Integer index of the reference level, if there is
no reference level, NA is returned
</p>

<hr>
<h2 id='forward_difference_code'>Forward difference code</h2><span id='topic+forward_difference_code'></span>

<h3>Description</h3>

<p>Compares the mean of level k to level k+1. Differs in direction from
<a href="#topic+backward_difference_code">backward_difference_code</a>, so be careful to pick the
right function. See also <a href="MASS.html#topic+contr.sdif">contr.sdif</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_difference_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward_difference_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example interpretation for a 4 level factor:
</p>

<ul>
<li><p> Intercept = Grand mean (mean of the means of each level)
</p>
</li>
<li><p> grp1 = mean(grp1) - mean(grp2)
</p>
</li>
<li><p> grp2 = mean(grp2) - mean(grp3)
</p>
</li>
<li><p> grp3 = mean(grp3) - mean(grp4)
</p>
</li></ul>



<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf &lt;- data.frame(
  grp = gl(4,5),
  resp = c(seq(1, 5), seq(5, 9), seq(10, 14), seq(15, 19))
)

mydf &lt;- set_contrasts(mydf, grp ~ forward_difference_code)

lm(resp ~ grp, data = mydf)
</code></pre>

<hr>
<h2 id='glimpse_contrasts'>Glimpse contrasts in dataframe</h2><span id='topic+glimpse_contrasts'></span>

<h3>Description</h3>

<p>Uses the same syntax as <code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code> and
<code><a href="#topic+set_contrasts">set_contrasts()</a></code>. Returns a summary table of the contrasts you've set. If
you set <code>return.list=TRUE</code> then you can access a list of contrasts in the
second element of the resulting list. The glimpse dataframe is the first
element. <code>FALSE</code> will return just the glimpse data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glimpse_contrasts(
  model_data,
  ...,
  return_list = FALSE,
  show_all_factors = TRUE,
  add_namespace = FALSE,
  show_one_level_factors = FALSE,
  minimal = TRUE,
  verbose = getOption("contrastable.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glimpse_contrasts_+3A_model_data">model_data</code></td>
<td>
<p>Data to be passed to a model fitting function</p>
</td></tr>
<tr><td><code id="glimpse_contrasts_+3A_...">...</code></td>
<td>
<p>Series of formulas</p>
</td></tr>
<tr><td><code id="glimpse_contrasts_+3A_return_list">return_list</code></td>
<td>
<p>Logical, defaults to FALSE, whether the output of
enlist_contrasts should be returned</p>
</td></tr>
<tr><td><code id="glimpse_contrasts_+3A_show_all_factors">show_all_factors</code></td>
<td>
<p>Logical, defaults to TRUE, whether the factors not
explicitly set with formulas should be included</p>
</td></tr>
<tr><td><code id="glimpse_contrasts_+3A_add_namespace">add_namespace</code></td>
<td>
<p>Logical, defaults to FALSE, whether to append the
namespace of the contrast scheme to the scheme name</p>
</td></tr>
<tr><td><code id="glimpse_contrasts_+3A_show_one_level_factors">show_one_level_factors</code></td>
<td>
<p>Logical, should factors with only one level be
included in the output? Default is FALSE to omit</p>
</td></tr>
<tr><td><code id="glimpse_contrasts_+3A_minimal">minimal</code></td>
<td>
<p>Logical, default TRUE, whether to omit the orthogonal,
centered, dropped_trends, and explicitly_set columns from the output table</p>
</td></tr>
<tr><td><code id="glimpse_contrasts_+3A_verbose">verbose</code></td>
<td>
<p>Logical, defaults to TRUE, whether messages should be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, <code>glimpse_contrasts</code> will give warnings about mismatches between
the specified contrasts and what's actually set on the factors in a
dataframe. The warnings will typically tell you how to resolve these
mismatches. See the <code>contrasts</code> and <code>warnings</code> vignettes for more
information.
</p>


<h3>Value</h3>

<p>A dataframe if return.list is FALSE, a list with a dataframe and list
of named contrasts if TRUE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code> <code><a href="#topic+set_contrasts">set_contrasts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my_contrasts &lt;- list(cyl ~ sum_code, carb ~ helmert_code)
my_data &lt;- set_contrasts(mtcars, my_contrasts, verbose = FALSE)
my_data$gear &lt;- factor(my_data$gear) # Make gear a factor manually

# View information about contrasts; gear will use default for unordered
glimpse_contrasts(my_data, my_contrasts)
</code></pre>

<hr>
<h2 id='helmert_code'>Helmert code</h2><span id='topic+helmert_code'></span>

<h3>Description</h3>

<p>R's <code><a href="stats.html#topic+contrast">stats::contr.helmert()</a></code> function is unscaled, meaning
that you need to scale the coefficients of a model fit to get the actual
comparisons of interest. This version will automatically scale the contrast
matrix such that the coefficients are the expected scaled values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helmert_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="helmert_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helmert coding compares each level to the total mean of all levels
that have come before it. Differs from backward difference coding, which
compares only pairs of levels (not a level to a cumulative mean of levels)
</p>
<p>Example interpretation for a 4 level factor:
</p>

<ul>
<li><p> Intercept = Grand mean (mean of the means of each level)
</p>
</li>
<li><p> grp2 = mean(grp2) - mean(grp1)
</p>
</li>
<li><p> grp3 = mean(grp3) - mean(grp1, grp2)
</p>
</li>
<li><p> grp4 = mean(grp4) - mean(grp1, grp2, grp3)
</p>
</li></ul>



<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydf &lt;- data.frame(
  grp = gl(4,5),
  resp = c(seq(1, 5), seq(5, 9), seq(10, 14), seq(15, 19))
)

mydf &lt;- set_contrasts(mydf, grp ~ helmert_code)
lm(resp ~ grp, data = mydf)
</code></pre>

<hr>
<h2 id='interpret_intercept'>Interpret intercept from contrasts</h2><span id='topic+interpret_intercept'></span>

<h3>Description</h3>

<p>Given a contrast matrix, try and interpret the intercept. Will usually be
either the grand mean, the mean of a reference level (e.g. contr.treatment),
the unweighted mean of multiple levels. Anything else would indicate custom
weights that the user provided, hence they should know how to interpret it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpret_intercept(contrast_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpret_intercept_+3A_contrast_matrix">contrast_matrix</code></td>
<td>
<p>Contrast matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string describing how to interpret the effect on the intercept
this coding scheme has
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interpret_intercept(contr.treatment(2)) # mean(1)
interpret_intercept(contr.SAS(2)) # mean(2)
interpret_intercept(contr.sum(2)) # grand mean

# Here there are 3 levels but the intercept is either an unweighted
# mean of 2 levels or a weighted mean of 2 levels
unweighted_intercept &lt;-
  solve(t(matrix(c(.5, .5, 0, -1, 1, 0, -1, 0, 1), nrow = 3)))[, 2:3]
weighted_intercept &lt;-
  solve(t(matrix(c(.8, .2, 0, -1, 1, 0, -1, 0, 1), nrow = 3)))[, 2:3]

interpret_intercept(unweighted_intercept) # mean(1,2)
interpret_intercept(weighted_intercept) # custom weights
</code></pre>

<hr>
<h2 id='is_centered'>Check for orthogonality</h2><span id='topic+is_centered'></span>

<h3>Description</h3>

<p>Given a contrast matrix or list of contrast matrices (eg from
<code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code>), return a logical vector of whether each contrast is
centered or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_centered(contrast_matrices, USE.NAMES = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_centered_+3A_contrast_matrices">contrast_matrices</code></td>
<td>
<p>Contrast matrix or list of contrast matrices</p>
</td></tr>
<tr><td><code id="is_centered_+3A_use.names">USE.NAMES</code></td>
<td>
<p>Logical, whether vector should be named</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector, will retain names of a passed list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_centered(treatment_code(5)) # FALSE
is_centered(scaled_sum_code(5)) # TRUE

</code></pre>

<hr>
<h2 id='is_orthogonal'>Check for orthogonality</h2><span id='topic+is_orthogonal'></span>

<h3>Description</h3>

<p>Given a contrast matrix or list of contrast matrices (eg from
<code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code> ), return a logical vector of whether each contrast is
orthogonal or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_orthogonal(contrast_matrices, USE.NAMES = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_orthogonal_+3A_contrast_matrices">contrast_matrices</code></td>
<td>
<p>Contrast matrix or list of contrast matrices</p>
</td></tr>
<tr><td><code id="is_orthogonal_+3A_use.names">USE.NAMES</code></td>
<td>
<p>Logical, whether vector should be named</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector, will retain names of a passed list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is_orthogonal(treatment_code(5)) # FALSE
is_orthogonal(helmert_code(5)) # TRUE
</code></pre>

<hr>
<h2 id='is.unordered'>Check for unordered factor</h2><span id='topic+is.unordered'></span>

<h3>Description</h3>

<p>Helper to check if a factor is exclusively unordered. is.factor(x) is TRUE
when x is unordered OR ordered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.unordered(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.unordered_+3A_x">x</code></td>
<td>
<p>a vector of data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x is an unordered factor, FALSE if x is not a factor or is an
ordered factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.unordered(gl(5,1)) # True
is.unordered(gl(5,1,ordered = TRUE)) # False
</code></pre>

<hr>
<h2 id='orth_polynomial_code'>Orthogonal Polynomial code</h2><span id='topic+orth_polynomial_code'></span><span id='topic+polynomial_code'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="stats.html#topic+contrast">stats::contr.poly()</a></code>. You can also use <code><a href="#topic+polynomial_code">polynomial_code()</a></code>
as an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orth_polynomial_code(n)

polynomial_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orth_polynomial_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For n levels of factors where k in 1:n, generate a matrix with n-1
comparisons where each comparison looks for a polynomial trend of degree k
where each polynomial is independent of the others.
</p>


<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydf &lt;- data.frame(
  grp = rep(c("a", "b", "c", "d"), each = 2000),
  val = c(
    rnorm(200, 2, 1),
    rnorm(200, 5, 1),
    rnorm(200, 7.5, 1),
    rnorm(200, 15, 1)
  )
) |&gt;
  set_contrasts(grp ~ polynomial_code)

stats::lm(val ~ grp, data = mydf)

</code></pre>

<hr>
<h2 id='raw_polynomial_code'>Raw Polynomial code</h2><span id='topic+raw_polynomial_code'></span>

<h3>Description</h3>

<p>Make raw polynomial contrast, rather than orthogonal ones. Normally you
would use orthogonal polynomials, so make sure this is what you want. Using
raw polynomials may increase the collinearity in your model, especially with
higher numbers of levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_polynomial_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_polynomial_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For n levels of factors where k in 1:n, generate a matrix with n-1
comparisons where each comparison looks for a polynomial trend of degree k,
where each polynomial may be correlated with the others. Normally you would
use orthogonal polynomials, see <code><a href="stats.html#topic+contrast">stats::contr.poly()</a></code> and
<code><a href="#topic+orth_polynomial_code">orth_polynomial_code()</a></code>
</p>


<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf &lt;- data.frame(
  grp = rep(c("a", "b", "c", "d"), each = 2000),
  val = c(
    rnorm(200, 2, 1),
    rnorm(200, 5, 1),
    rnorm(200, 7.5, 1),
    rnorm(200, 15, 1)
  )
) |&gt;
  set_contrasts(grp ~ raw_polynomial_code)

stats::lm(val ~ grp, data = mydf)
</code></pre>

<hr>
<h2 id='reverse_helmert_code'>Reverse Helmert code</h2><span id='topic+reverse_helmert_code'></span>

<h3>Description</h3>

<p>Reverse helmert coding is the same concept as helmert coding, but the order
of the groupings is reversed. See also <a href="#topic+helmert_code">helmert_code</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_helmert_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_helmert_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reverse helmert coding compares each level to the total mean of all levels
that come after it. Differs from forward difference coding, which only
compares pairs of levels (not a level to a cumulative mean of levels).
</p>
<p>Example interpretation for a 4 level factor:
</p>

<ul>
<li><p> Intercept = Grand mean (mean of the means of each level)
</p>
</li>
<li><p> grp1 = mean(grp4, grp3, grp2) - grp(1)
</p>
</li>
<li><p> grp2 = mean(grp4, grp3) - mean(grp2)
</p>
</li>
<li><p> grp3 = mean(grp3) - mean(grp4)
</p>
</li></ul>



<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydf &lt;- data.frame(
  grp = gl(4,5),
  resp = c(seq(1, 5), seq(5, 9), seq(10, 14), seq(15, 19))
)

mydf &lt;- set_contrasts(mydf, grp ~ reverse_helmert_code)
lm(resp ~ grp, data = mydf)
</code></pre>

<hr>
<h2 id='scaled_sum_code'>Scaled sum coding</h2><span id='topic+scaled_sum_code'></span>

<h3>Description</h3>

<p>Contrast coding scheme with a centered intercept and comparisons
from a baseline reference level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaled_sum_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaled_sum_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name for this contrast scheme varies widely in different fields
and across experimental psychology papers. It has been called simple, sum,
contrast, sum-to-zero, and deviation coding (among other names). This package
uses scaled sum coding to explicitly differentiate it from sum coding, which
has an implementation in base R with <code>contr.sum</code>.
</p>
<p>For n levels of factors, generate a matrix with n-1 comparisons where:
</p>

<ul>
<li><p> Reference level = -1/n
</p>
</li>
<li><p> Comparison level = (n-1)/n
</p>
</li>
<li><p> All others = -1/n
</p>
</li></ul>

<p>Example interpretation for a 4 level factor:
</p>

<ul>
<li><p> Intercept = Grand mean (mean of the means of each level)
</p>
</li>
<li><p> grp2 = mean(grp2) - mean(grp1)
</p>
</li>
<li><p> grp3 = mean(grp3) - mean(grp1)
</p>
</li>
<li><p> grp4 = mean(grp4) - mean(grp1)
</p>
</li></ul>

<p>Note: grp coefficient estimates are the same as with contr.treatment, but the
intercept is changed to the grand mean instead of the mean of grp1.
</p>
<p>It's also important to note that this coding scheme is NOT the same as
<code>contr.sum/2</code> when the number of levels is greater than 2. When n=2,
estimates with <code>contr.sum</code> can be interpreted as &quot;half the distance between
levels&quot; but when k&gt;2, <code>contr.sum</code> is to be interpreted as &quot;the distance
between this level and the GRAND MEAN&quot;. You may be tempted to use
<code>contr.sum(n)/2</code>, but this tests the hypothesis that 3/2 times the mean of a
level is equal to half the sum of the means of the other levels, i.e.,
<code class="reqn">1.5\mu_1 - .5\mu_2 - .5\mu_3 - .5\mu_4 = 0</code>, which is not likely to be
what you're looking for.
</p>


<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare these two, note that contr.sum(4)/2 is not the same
scaled_sum_code(4)
contr.sum(4)

# Here they happen to be equivalent (modulo reference level)
scaled_sum_code(2)
contr.sum(2) / 2

mydf &lt;- data.frame(
  grp = gl(4,5),
  resp = c(seq(1, 5), seq(5, 9), seq(10, 14), seq(15, 19))
)

mydf &lt;- set_contrasts(mydf, grp ~ scaled_sum_code)

lm(resp ~ grp, data = mydf)
</code></pre>

<hr>
<h2 id='set_contrasts'>Set contrasts to dataframe</h2><span id='topic+set_contrasts'></span>

<h3>Description</h3>

<p>Uses the same syntax as <code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code>,
but returns the dataframe with the new contrasts applied. Use this when
your model function doesnt have a contrasts argument and you want to avoid
writing <code style="white-space: pre;">&#8288;contrasts&lt;-&#8288;</code> multiple times. See
<code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code> for details about the
package-specific syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_contrasts(
  model_data,
  ...,
  verbose = getOption("contrastable.verbose"),
  print_contrasts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_contrasts_+3A_model_data">model_data</code></td>
<td>
<p>Data frame you intend on passing to your model</p>
</td></tr>
<tr><td><code id="set_contrasts_+3A_...">...</code></td>
<td>
<p>A series of 2 sided formulas with factor name on the left hand
side and desired contrast scheme on the right hand side. The reference
level can be set with <code>+</code>, the intercept can be overwritten with <code>*</code>,
comparison labels can be set using <code>|</code>, and trends for polynomial coding
can be removed using <code>-</code>.</p>
</td></tr>
<tr><td><code id="set_contrasts_+3A_verbose">verbose</code></td>
<td>
<p>Logical, defaults to FALSE, whether messages should be printed</p>
</td></tr>
<tr><td><code id="set_contrasts_+3A_print_contrasts">print_contrasts</code></td>
<td>
<p>Logical, default FALSE, whether to print the contrasts
set for each factor. Fractions are displayed using <code><a href="MASS.html#topic+fractions">MASS::fractions()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code>, <code><a href="#topic+set_contrasts">set_contrasts()</a></code>,
and <code><a href="#topic+glimpse_contrasts">glimpse_contrasts()</a></code> use special syntax to set
contrasts for multiple factors. The syntax consists of two-sided formulas
with the desired factor column on the left hand side and the contrast
specification on the right hand side. For example, <code>varname ~ scaled_sum_code</code>. Many contrasts support additional kinds of contrast
manipulations using overloaded operators:
</p>

<ul>
<li> <p><code>+ X</code>: Set the reference level to the level named X. Only supported for
schemes that have a singular reference level such as
<code><a href="#topic+sum_code">sum_code()</a></code>, <code><a href="#topic+scaled_sum_code">scaled_sum_code()</a></code>,
<code><a href="#topic+treatment_code">treatment_code()</a></code>, <code><a href="stats.html#topic+contrast">stats::contr.treatment()</a></code>,
<code><a href="stats.html#topic+contrast">stats::contr.sum()</a></code>, <code><a href="stats.html#topic+contrast">stats::contr.SAS()</a></code>. Ignored for schemes like
<code><a href="#topic+helmert_code">helmert_code()</a></code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;* X&#8288;</code>: Overwrite the intercept to the mean of the level named X
</p>
</li>
<li> <p><code>- A:B</code>: For polynomial coding schemes only, drop comparisons A through B.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;| c(...)&#8288;</code>: Change the comparison labels for the contrast matrix to the
character vector <code>c(...)</code> of length <code>n-1</code>. These labels will appear in the
output/summary of a statistical model. Note that for <code>brms::brm</code>,
instances of <code>-</code> (a minus sign) are replaced with <code>M</code>.
</p>
</li></ul>

<p>You can also specify multiple variables on the left hand side of a formula
using tidyselect helpers. See examples for more information.
</p>
<p>Typically model functions like lm will have a contrasts argument where you
can set the contrasts at model run time, rather than having to manually
change the contrasts on the underlying factor columns in your data. This
function will return such a named list of contrast matrices to pass to these
functions. Note that this function should not be used within a modeling
function call, e.g., <code>lm(y~x, data = model_data, contrasts =
enlist_contrasts(model_data, x~sum_code))</code>. Often, this will call
<code>enlist_contrasts</code> twice, rather than just once.
</p>
<p>For some model fitting functions, like <code>brms::brm</code>, there is no
contrasts argument. For such cases, use <code><a href="#topic+set_contrasts">set_contrasts()</a></code> to
set contrasts directly to the factors in a dataframe.
</p>
<p>One good way to use <code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code> is in conjunction
with <code><a href="MASS.html#topic+fractions">MASS::fractions()</a></code> to create a list of matrices that can be printed
to explicitly show the entire contrast matrices you're using for your models.
This can be especially helpful for supplementary materials in an academic
paper.
</p>
<p>Sometimes when using orthogonal polynomial contrasts from
<code><a href="stats.html#topic+contrast">stats::contr.poly()</a></code> people will drop higher level polynomials for
parsimony. Note however that these do capture some amount of variation, so
even though they're orthogonal contrasts the lower level polynomials will
have their estimates changed. Moreover, you cannot reduce a contrast matrix
to a matrix smaller than size n*n-1 in the dataframe you pass to a model
fitting function itself, as R will try to fill in the gaps with something
else. If you want to drop contrasts you'll need to use something like
<code>enlist_contrasts(df, x ~ contr.poly - 3:5)</code> and pass this to the
<code>contrasts</code> argument in the model fitting function.
</p>


<h3>Value</h3>

<p>The <code>model_data</code> dataframe, but with updated contrasts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code> <code><a href="#topic+glimpse_contrasts">glimpse_contrasts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(
   set_contrasts(mtcars, carb + cyl ~ helmert_code, print_contrasts = TRUE)
)

</code></pre>

<hr>
<h2 id='sum_code'>Sum code</h2><span id='topic+sum_code'></span>

<h3>Description</h3>

<p>Wrapper around <a href="stats.html#topic+contr.sum">contr.sum</a>, but ensures that the reference level
is the first level alphabetically, not the last. Returns a contrast matrix
where comparisons give differences between comparison levels and the grand
mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For n levels of factors, generate a matrix with n-1 comparisons where:
</p>

<ul>
<li><p> Reference level = -1
</p>
</li>
<li><p> Comparison level = 1
</p>
</li>
<li><p> All others = 0
</p>
</li></ul>

<p>Example interpretation for a 4 level factor:
</p>

<ul>
<li><p> Intercept = Grand mean (mean of the means of each level)
</p>
</li>
<li><p> grp2 = grp2 - mean(grp4, grp3, grp2, grp1)
</p>
</li>
<li><p> grp3 = grp3 - mean(grp4, grp3, grp2, grp1)
</p>
</li>
<li><p> grp4 =  grp4 - mean(grp4, grp3, grp2, grp1)
</p>
</li></ul>

<p>Note that when n = 2, the coefficient estimate is half of the difference
between the two levels. But, this coincidence does not hold when the number
of levels is greater than 2.
</p>


<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf &lt;- data.frame(
  grp = gl(4,5),
  resp = c(seq(1, 5), seq(5, 9), seq(10, 14), seq(15, 19))
)

mydf &lt;- set_contrasts(mydf, grp ~ sum_code)

lm(resp ~ grp, data = mydf)

</code></pre>

<hr>
<h2 id='treatment_code'>Treatment code</h2><span id='topic+treatment_code'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="stats.html#topic+contrast">stats::contr.treatment()</a></code>. Returns a contrast
matrix where comparisons give differences between each comparison level and a
baseline reference level, while the intercept equals the first level of the
factor. See <code><a href="#topic+scaled_sum_code">scaled_sum_code()</a></code> for a function that centers
the intercept on the grand mean while retaining pairwise comparisons from a
reference level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treatment_code(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treatment_code_+3A_n">n</code></td>
<td>
<p>Integer umber of factor levels to compute contrasts for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For n levels of factors, generate a matrix with n-1 comparisons
where:
</p>

<ul>
<li><p> Reference level = 0
</p>
</li>
<li><p> Comparison level = 1
</p>
</li>
<li><p> All others = 0
</p>
</li></ul>

<p>Note that this function sets the first level (alphabetically) as the
reference level while  <code><a href="stats.html#topic+contrast">stats::contr.SAS()</a></code> sets the LAST level as the
reference level. However, in functions like
<code><a href="#topic+set_contrasts">set_contrasts()</a></code>, and <code><a href="#topic+enlist_contrasts">enlist_contrasts()</a></code>, the reference level is
automatically set to be the first level alphabetically.
</p>


<h3>Value</h3>

<p>A contrast matrix with dimensions n rows and (n-1) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf &lt;- data.frame(
  grp = gl(4,5),
  resp = c(seq(1, 5), seq(5, 9), seq(10, 14), seq(15, 19))
)

mydf &lt;- set_contrasts(mydf, grp ~ treatment_code)

lm(resp ~ grp, data = mydf)

</code></pre>

<hr>
<h2 id='use_contrasts'>Contrast code factors</h2><span id='topic+use_contrasts'></span>

<h3>Description</h3>

<p>Helper to do contrast coding. There are two options:
</p>

<ul>
<li><p> Manually specify a matrix for code_by (implements use_contrast_matrix).
Reference level is automatically set to the row that's always negative.
</p>
</li>
<li><p> Specify a style of contrast coding as a function. Label of the reference
level should be specified in ...
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>use_contrasts(
  factor_col,
  code_by = NA,
  reference_level = NA,
  set_intercept = NA,
  drop_trends = NA,
  labels = NULL,
  as_is = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_contrasts_+3A_factor_col">factor_col</code></td>
<td>
<p>The factor column to use, eg data$gender</p>
</td></tr>
<tr><td><code id="use_contrasts_+3A_code_by">code_by</code></td>
<td>
<p>Either a matrix or a function</p>
</td></tr>
<tr><td><code id="use_contrasts_+3A_reference_level">reference_level</code></td>
<td>
<p>The level to use as the reference level, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts_+3A_set_intercept">set_intercept</code></td>
<td>
<p>The intercept to use, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts_+3A_drop_trends">drop_trends</code></td>
<td>
<p>Whether to drop trends, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts_+3A_labels">labels</code></td>
<td>
<p>Labels to use in the contrast matrix, must equal number of
contrasts</p>
</td></tr>
<tr><td><code id="use_contrasts_+3A_as_is">as_is</code></td>
<td>
<p>Logical, default FALSE, whether to suppress auto switching of
the reference level to the first level if not specified</p>
</td></tr>
<tr><td><code id="use_contrasts_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to use_contrast_function,
specifically, which level you want the reference level to be</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast coding matrix with labels and proper reference level
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a contrast matrix given some factor vector with the specified
# reference level
use_contrasts(gl(5,2), sum_code, reference_level = 3)

# Set column labels; order for labels is the same as the column indices
use_contrasts(gl(3,2), scaled_sum_code, labels = c("2-1", "3-1"))

my_data &lt;- mtcars
my_data$gear &lt;- factor(mtcars$gear)

MASS::fractions(use_contrasts(my_data$gear, helmert_code))

</code></pre>

<hr>
<h2 id='use_contrasts.AsIs'>AsIs method for use_contrasts</h2><span id='topic+use_contrasts.AsIs'></span>

<h3>Description</h3>

<p>Evaluates <code>code_by</code>, then applies the appropriate use_contrasts method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AsIs'
use_contrasts(
  factor_col,
  code_by = NA,
  reference_level = NA,
  set_intercept = NA,
  drop_trends = NA,
  labels = NULL,
  as_is = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_contrasts.AsIs_+3A_factor_col">factor_col</code></td>
<td>
<p>A factor vector, eg from df$factorVarName</p>
</td></tr>
<tr><td><code id="use_contrasts.AsIs_+3A_code_by">code_by</code></td>
<td>
<p>A symbol to be evaluated</p>
</td></tr>
<tr><td><code id="use_contrasts.AsIs_+3A_reference_level">reference_level</code></td>
<td>
<p>The level to use as the reference level, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts.AsIs_+3A_set_intercept">set_intercept</code></td>
<td>
<p>The intercept to use, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts.AsIs_+3A_drop_trends">drop_trends</code></td>
<td>
<p>The trends to drop, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts.AsIs_+3A_labels">labels</code></td>
<td>
<p>A vector of labels to apply to the matrix column names, default
NULL (no new labels)</p>
</td></tr>
<tr><td><code id="use_contrasts.AsIs_+3A_as_is">as_is</code></td>
<td>
<p>Logical, default FALSE, whether to leave the resulting matrix
as-is</p>
</td></tr>
<tr><td><code id="use_contrasts.AsIs_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast coding matrix with labels and proper reference level
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
use_contrasts(gl(5,1), I(scaled_sum_code))

</code></pre>

<hr>
<h2 id='use_contrasts.default'>Default method for use_contrasts</h2><span id='topic+use_contrasts.default'></span>

<h3>Description</h3>

<p>If a user doesn't specify a contrast matrix, use the defaults from options().
If the user tries to use something we don't know how to work with, throw a
warning that we'll be using the defaults from options().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
use_contrasts(
  factor_col,
  code_by = NA,
  reference_level = NA,
  set_intercept = NA,
  drop_trends = NA,
  labels = NULL,
  as_is = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_contrasts.default_+3A_factor_col">factor_col</code></td>
<td>
<p>A factor vector, eg from <code>df$factorVarName</code></p>
</td></tr>
<tr><td><code id="use_contrasts.default_+3A_code_by">code_by</code></td>
<td>
<p>Some object that's not a matrix or function. If NA, no warning
will be thrown, and the default contrasts will be used. A warning will be
thrown if it's not NA.</p>
</td></tr>
<tr><td><code id="use_contrasts.default_+3A_reference_level">reference_level</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="use_contrasts.default_+3A_set_intercept">set_intercept</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="use_contrasts.default_+3A_drop_trends">drop_trends</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="use_contrasts.default_+3A_labels">labels</code></td>
<td>
<p>A vector of labels to apply to the matrix column names, default</p>
</td></tr>
<tr><td><code id="use_contrasts.default_+3A_as_is">as_is</code></td>
<td>
<p>Logical, default FALSE, whether to leave the resulting matrix</p>
</td></tr>
<tr><td><code id="use_contrasts.default_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Contrast matrix, using the ordered or unordered default from
<code>options()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use_contrasts(gl(5,1), helmert_code) # a function
my_matrix &lt;- helmert_code(5)
use_contrasts(gl(5,1), my_matrix) # a matrix

</code></pre>

<hr>
<h2 id='use_contrasts.function'>Function method for use_contrasts</h2><span id='topic+use_contrasts.function'></span>

<h3>Description</h3>

<p>If the user provides a function, use the function and supplied arguments to
create a contrast matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
use_contrasts(
  factor_col,
  code_by = NA,
  reference_level = NA,
  set_intercept = NA,
  drop_trends = NA,
  labels = NULL,
  as_is = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_contrasts.function_+3A_factor_col">factor_col</code></td>
<td>
<p>A factor vector, eg from df$factorVarName</p>
</td></tr>
<tr><td><code id="use_contrasts.function_+3A_code_by">code_by</code></td>
<td>
<p>A function to be called, should return a contrast matrix</p>
</td></tr>
<tr><td><code id="use_contrasts.function_+3A_reference_level">reference_level</code></td>
<td>
<p>The name of the level to use as the reference level,
default NA</p>
</td></tr>
<tr><td><code id="use_contrasts.function_+3A_set_intercept">set_intercept</code></td>
<td>
<p>The intercept to use, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts.function_+3A_drop_trends">drop_trends</code></td>
<td>
<p>The trends to drop, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts.function_+3A_labels">labels</code></td>
<td>
<p>A vector of labels to apply to the matrix column names, default</p>
</td></tr>
<tr><td><code id="use_contrasts.function_+3A_as_is">as_is</code></td>
<td>
<p>Logical, default FALSE, whether to leave the resulting matrix</p>
</td></tr>
<tr><td><code id="use_contrasts.function_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>code_by()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast coding matrix with labels and proper reference level
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use_contrasts(gl(5,1), sum_code)
</code></pre>

<hr>
<h2 id='use_contrasts.hypr'>Use a hypr object for contrasts</h2><span id='topic+use_contrasts.hypr'></span>

<h3>Description</h3>

<p>Use a hypr object for contrasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hypr'
use_contrasts(
  factor_col,
  code_by = NA,
  reference_level = NA,
  set_intercept = NA,
  drop_trends = NA,
  labels = NULL,
  as_is = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_contrasts.hypr_+3A_factor_col">factor_col</code></td>
<td>
<p>A factor vector, eg from df$factorVarName</p>
</td></tr>
<tr><td><code id="use_contrasts.hypr_+3A_code_by">code_by</code></td>
<td>
<p>A hypr object created with <code>hypr::hypr()</code></p>
</td></tr>
<tr><td><code id="use_contrasts.hypr_+3A_reference_level">reference_level</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="use_contrasts.hypr_+3A_set_intercept">set_intercept</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="use_contrasts.hypr_+3A_drop_trends">drop_trends</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="use_contrasts.hypr_+3A_labels">labels</code></td>
<td>
<p>A vector of labels to apply to the matrix column names, default</p>
</td></tr>
<tr><td><code id="use_contrasts.hypr_+3A_as_is">as_is</code></td>
<td>
<p>Logical, default FALSE, whether to leave the resulting matrix</p>
</td></tr>
<tr><td><code id="use_contrasts.hypr_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Contrast matrix specified by the hypr object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hypr_obj &lt;- hypr::hypr(a ~ b, c ~ b) # centered pairwise comparisons to b

use_contrasts(factor(c('a', 'b', 'c')), hypr_obj)

</code></pre>

<hr>
<h2 id='use_contrasts.matrix'>Matrix method for use_contrasts</h2><span id='topic+use_contrasts.matrix'></span>

<h3>Description</h3>

<p>If a user provides a raw matrix, then use that matrix as the contrast matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
use_contrasts(
  factor_col,
  code_by = NA,
  reference_level = NA,
  set_intercept = NA,
  drop_trends = NA,
  labels = NULL,
  as_is = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_contrasts.matrix_+3A_factor_col">factor_col</code></td>
<td>
<p>A factor vector, eg from df$factorVarName</p>
</td></tr>
<tr><td><code id="use_contrasts.matrix_+3A_code_by">code_by</code></td>
<td>
<p>A matrix to be used as the contrast matrix, should have
the same dimensions as the contrast matrix already applied to code_by</p>
</td></tr>
<tr><td><code id="use_contrasts.matrix_+3A_reference_level">reference_level</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="use_contrasts.matrix_+3A_set_intercept">set_intercept</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="use_contrasts.matrix_+3A_drop_trends">drop_trends</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="use_contrasts.matrix_+3A_labels">labels</code></td>
<td>
<p>A vector of labels to apply to the matrix column names, default</p>
</td></tr>
<tr><td><code id="use_contrasts.matrix_+3A_as_is">as_is</code></td>
<td>
<p>Logical, default FALSE, whether to leave the resulting matrix</p>
</td></tr>
<tr><td><code id="use_contrasts.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast coding matrix with labels and proper reference level
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
contrast_matrix &lt;- sum_code(4)
use_contrasts(gl(4,1), contrast_matrix)

</code></pre>

<hr>
<h2 id='use_contrasts.name'>Symbol method for use_contrasts</h2><span id='topic+use_contrasts.name'></span>

<h3>Description</h3>

<p>Evaluates <code>code_by</code>, then applies the appropriate use_contrasts method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'name'
use_contrasts(
  factor_col,
  code_by = NA,
  reference_level = NA,
  set_intercept = NA,
  drop_trends = NA,
  labels = NULL,
  as_is = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_contrasts.name_+3A_factor_col">factor_col</code></td>
<td>
<p>A factor vector, eg from df$factorVarName</p>
</td></tr>
<tr><td><code id="use_contrasts.name_+3A_code_by">code_by</code></td>
<td>
<p>A symbol to be evaluated</p>
</td></tr>
<tr><td><code id="use_contrasts.name_+3A_reference_level">reference_level</code></td>
<td>
<p>The level to use as the reference level, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts.name_+3A_set_intercept">set_intercept</code></td>
<td>
<p>The intercept to use, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts.name_+3A_drop_trends">drop_trends</code></td>
<td>
<p>The trends to drop, default NA</p>
</td></tr>
<tr><td><code id="use_contrasts.name_+3A_labels">labels</code></td>
<td>
<p>A vector of labels to apply to the matrix column names, default
NULL (no new labels)</p>
</td></tr>
<tr><td><code id="use_contrasts.name_+3A_as_is">as_is</code></td>
<td>
<p>Logical, default FALSE, whether to leave the resulting matrix
as-is</p>
</td></tr>
<tr><td><code id="use_contrasts.name_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast coding matrix with labels and proper reference level
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aliased_scheme &lt;- sum_code
contrast_scheme &lt;- rlang::sym("aliased_scheme")

# Result will be as if sum_code was used directly
use_contrasts(gl(5,1), contrast_scheme)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
