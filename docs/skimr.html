<!DOCTYPE html><html><head><title>Help for package skimr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {skimr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#skimr-package'><p>Skim a data frame</p></a></li>
<li><a href='#deprecated-v1'><p>Deprecated functions from skimr v1</p></a></li>
<li><a href='#fix_windows_histograms'><p>Fix unicode histograms on Windows</p></a></li>
<li><a href='#focus'><p>Only show a subset of summary statistics after skimming</p></a></li>
<li><a href='#get_default_skimmers'><p>View default skimmer names and functions</p></a></li>
<li><a href='#get_skimmers'><p>Retrieve the summary functions for a specific data type</p></a></li>
<li><a href='#knit_print'><p>Provide a default printing method for knitr.</p></a></li>
<li><a href='#mutate.skim_df'><p>Mutate a skim_df</p></a></li>
<li><a href='#partition'><p>Separate a big <code>skim_df</code> into smaller data frames, by type.</p></a></li>
<li><a href='#print'><p>Print <code>skim</code> objects</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#repr'><p>Skimr printing within Jupyter notebooks</p></a></li>
<li><a href='#sfl'><p>Create a skimr function list</p></a></li>
<li><a href='#skim'><p>Skim a data frame, getting useful summary statistics</p></a></li>
<li><a href='#skim_with'><p>Set or add the summary functions for a particular type of data</p></a></li>
<li><a href='#skim-attr'><p>Functions for accessing skim_df attributes</p></a></li>
<li><a href='#skim-obj'><p>Test if an object is compatible with <code>skimr</code></p></a></li>
<li><a href='#skimr-vctrs'><p>Functions for working with the vctrs package</p></a></li>
<li><a href='#stats'><p>Summary statistic functions</p></a></li>
<li><a href='#summary.skim_df'><p>Summary function for skim_df</p></a></li>
<li><a href='#to_long'><p>Create &quot;long&quot; skim output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Compact and Flexible Summaries of Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>A simple to use summary function that can be used with pipes
    and displays nicely in the console. The default summary statistics may
    be modified by the user as can the default formatting.  Support for
    data frames and vectors is included, and users can implement their own
    skim methods for specific object types as described in a vignette.
    Default summaries include support for inline spark graphs.
    Instructions for managing these on specific operating systems are
    given in the "Using skimr" vignette and the README.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/skimr/">https://docs.ropensci.org/skimr/</a> (website),
<a href="https://github.com/ropensci/skimr/">https://github.com/ropensci/skimr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/skimr/issues">https://github.com/ropensci/skimr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr (&ge; 0.8.0), knitr (&ge; 1.2), magrittr (&ge; 1.5),
pillar (&ge; 1.6.4), purrr, repr, rlang (&ge; 0.3.1), stats,
stringr (&ge; 1.1), tibble (&ge; 2.0.0), tidyr (&ge; 1.0), tidyselect
(&ge; 1.0.0), vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, crayon, data.table, dtplyr, extrafont, haven,
lubridate, rmarkdown, testthat (&ge; 2.0.0), withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'deprecated.R' 'dplyr.R' 'stats.R' 'skim_with.R'
'get_skimmers.R' 'reshape.R' 'sfl.R' 'skim.R' 'skim_obj.R'
'skim_print.R' 'skimr-package.R' 'summary.R' 'utils.R'
'vctrs.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-23 10:37:38 UTC; elinwaring</td>
</tr>
<tr>
<td>Author:</td>
<td>Elin Waring [cre, aut],
  Michael Quinn [aut],
  Amelia McNamara [aut],
  Eduardo Arino de la Rubia [aut],
  Hao Zhu [aut],
  Julia Lowndes [ctb],
  Shannon Ellis [aut],
  Hope McLeod [ctb],
  Hadley Wickham [ctb],
  Kirill MÃ¼ller [ctb],
  RStudio, Inc. [cph] (Spark functions),
  Connor Kirkpatrick [ctb],
  Scott Brenstuhl [ctb],
  Patrick Schratz [ctb],
  lbusett [ctb],
  Mikko Korpela [ctb],
  Jennifer Thompson [ctb],
  Harris McGehee [ctb],
  Mark Roepke [ctb],
  Patrick Kennedy [ctb],
  Daniel Possenriede [ctb],
  David Zimmermann [ctb],
  Kyle Butts [ctb],
  Bastian Torges [ctb],
  Rick Saporta [ctb],
  Henry Morgan Stewart [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elin Waring &lt;elin.waring@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-23 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='skimr-package'>Skim a data frame</h2><span id='topic+skimr-package'></span><span id='topic+skimr'></span>

<h3>Description</h3>

<p>This package provides an alternative to the default summary functions
within R. The package's API is tidy, functions take data frames, return
data frames and can work as part of a pipeline. The returned <code>skimr</code>
object is subsettable and offers a human readable output.
</p>


<h3>Details</h3>

<p><code>skimr</code> is opinionated, providing a strong set of summary statistics
that are generated for a variety of different data types. It is also
provides an API for customization. Users can change both the functions
dispatched and the way the results are formatted.
</p>

<hr>
<h2 id='deprecated-v1'>Deprecated functions from skimr v1</h2><span id='topic+deprecated-v1'></span><span id='topic+skim_to_wide'></span><span id='topic+skim_to_list'></span><span id='topic+skim_format'></span>

<h3>Description</h3>

<p>Skimr used to offer functions that combined skimming with a secondary effect,
like reshaping the data, building a list or printing the results. Some of
these behaviors are no longer necessary. <code><a href="#topic+skim">skim()</a></code> always returns a wide
data frame. Others have been replaced by functions that do a single thing.
<code><a href="#topic+partition">partition()</a></code> creates a list-like object from a skimmed data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skim_to_wide(.data, ...)

skim_to_list(.data, ...)

skim_format(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecated-v1_+3A_.data">.data</code></td>
<td>
<p>A tibble, or an object that can be coerced into a tibble.</p>
</td></tr>
<tr><td><code id="deprecated-v1_+3A_...">...</code></td>
<td>
<p>Columns to select for skimming. When none are provided, the
default is to skim all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either A <code>skim_df</code> or a <code>skim_list</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>skim_to_wide()</code>: <code><a href="#topic+skim">skim()</a></code> always produces a wide data frame.
</p>
</li>
<li> <p><code>skim_to_list()</code>: <code><a href="#topic+partition">partition()</a></code> creates a list.
</p>
</li>
<li> <p><code>skim_format()</code>: <code><a href="#topic+print">print()</a></code> and <code><a href="#topic+skim_with">skim_with()</a></code> set options.
</p>
</li></ul>

<hr>
<h2 id='fix_windows_histograms'>Fix unicode histograms on Windows</h2><span id='topic+fix_windows_histograms'></span>

<h3>Description</h3>

<p>This functions changes your session's locale to address issues with printing
histograms on Windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_windows_histograms()
</code></pre>


<h3>Details</h3>

<p>There are known issues with printing the spark-histogram characters when
printing a data frame, appearing like this: &quot;&lt;U+2582&gt;&lt;U+2585&gt;&lt;U+2587&gt;&quot;.
This longstanding problem originates in the low-level code for printing
dataframes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+skim_without_charts">skim_without_charts()</a></code>
</p>

<hr>
<h2 id='focus'>Only show a subset of summary statistics after skimming</h2><span id='topic+focus'></span>

<h3>Description</h3>

<p>This function is a variant of <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> designed to work with
<code>skim_df</code> objects. When using <code>focus()</code>, <code>skimr</code> metadata columns are kept,
and <code>skimr</code> print methods are still utilized. Otherwise, the signature and
behavior is identical to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focus(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focus_+3A_.data">.data</code></td>
<td>
<p>A <code>skim_df</code> object.</p>
</td></tr>
<tr><td><code id="focus_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions separated by commas. Variable
names can be used as if they were positions in the data frame, so
expressions like x:y can be used to select a range of variables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Compare
iris %&gt;%
  skim() %&gt;%
  dplyr::select(n_missing)

iris %&gt;%
  skim() %&gt;%
  focus(n_missing)

# This is equivalent to
iris %&gt;%
  skim() %&gt;%
  dplyr::select(skim_variable, skim_type, n_missing)
</code></pre>

<hr>
<h2 id='get_default_skimmers'>View default skimmer names and functions</h2><span id='topic+get_default_skimmers'></span><span id='topic+get_one_default_skimmer'></span><span id='topic+get_default_skimmer_names'></span><span id='topic+get_one_default_skimmer_names'></span><span id='topic+get_sfl'></span>

<h3>Description</h3>

<p>These utility functions look up the currently-available defaults for one or
more <code>skim_type</code>'s. They work with all defaults in the <code>skimr</code> package, as
well as the defaults in any package that extends <code>skimr</code>. See
<code><a href="#topic+get_skimmers">get_skimmers()</a></code> for writing lookup methods for different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_default_skimmers(skim_type = NULL)

get_one_default_skimmer(skim_type)

get_default_skimmer_names(skim_type = NULL)

get_one_default_skimmer_names(skim_type)

get_sfl(skim_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_default_skimmers_+3A_skim_type">skim_type</code></td>
<td>
<p>The class of the column being skimmed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions differ in return type and whether or not the result is in
a list. <code><a href="#topic+get_default_skimmers">get_default_skimmers()</a></code> and <code><a href="#topic+get_one_default_skimmer">get_one_default_skimmer()</a></code> return
functions. The former returns functions within a typed list, i.e.
<code>list(numeric = list(...functions...))</code>.
</p>
<p>The functions differ in return type and whether or not the result is in
a list. <code><a href="#topic+get_default_skimmer_names">get_default_skimmer_names()</a></code> and <code><a href="#topic+get_one_default_skimmer_names">get_one_default_skimmer_names()</a></code>
return a list of character vectors or a single character vector.
</p>
<p><code><a href="#topic+get_sfl">get_sfl()</a></code> returns the skimmer function list for a particular <code>skim_type</code>.
It differs from <code><a href="#topic+get_default_skimmers">get_default_skimmers()</a></code> in that the returned <code>sfl</code> contains
a list of functions and a <code>skim_type</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_one_default_skimmer()</code>: Get the functions associated with one
<code>skim_type</code>.
</p>
</li>
<li> <p><code>get_default_skimmer_names()</code>: Get the names of the functions used in one
or more <code>skim_type</code>'s.
</p>
</li>
<li> <p><code>get_one_default_skimmer_names()</code>: Get the names of the functions used in one
<code>skim_type</code>.
</p>
</li>
<li> <p><code>get_sfl()</code>: Get the <code>sfl</code> for a <code>skim_type</code>.
</p>
</li></ul>

<hr>
<h2 id='get_skimmers'>Retrieve the summary functions for a specific data type</h2><span id='topic+get_skimmers'></span><span id='topic+get_skimmers.default'></span><span id='topic+get_skimmers.numeric'></span><span id='topic+get_skimmers.factor'></span><span id='topic+get_skimmers.character'></span><span id='topic+get_skimmers.logical'></span><span id='topic+get_skimmers.complex'></span><span id='topic+get_skimmers.Date'></span><span id='topic+get_skimmers.POSIXct'></span><span id='topic+get_skimmers.difftime'></span><span id='topic+get_skimmers.Timespan'></span><span id='topic+get_skimmers.ts'></span><span id='topic+get_skimmers.list'></span><span id='topic+get_skimmers.AsIs'></span><span id='topic+get_skimmers.haven_labelled'></span><span id='topic+modify_default_skimmers'></span>

<h3>Description</h3>

<p>These functions are used to set the default skimming functions for a data
type. They are combined with the base skim function list (<code>sfl</code>) in
<code><a href="#topic+skim_with">skim_with()</a></code>, to create the summary tibble for each type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_skimmers(column)

## Default S3 method:
get_skimmers(column)

## S3 method for class 'numeric'
get_skimmers(column)

## S3 method for class 'factor'
get_skimmers(column)

## S3 method for class 'character'
get_skimmers(column)

## S3 method for class 'logical'
get_skimmers(column)

## S3 method for class 'complex'
get_skimmers(column)

## S3 method for class 'Date'
get_skimmers(column)

## S3 method for class 'POSIXct'
get_skimmers(column)

## S3 method for class 'difftime'
get_skimmers(column)

## S3 method for class 'Timespan'
get_skimmers(column)

## S3 method for class 'ts'
get_skimmers(column)

## S3 method for class 'list'
get_skimmers(column)

## S3 method for class 'AsIs'
get_skimmers(column)

## S3 method for class 'haven_labelled'
get_skimmers(column)

modify_default_skimmers(skim_type, new_skim_type = NULL, new_funs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_skimmers_+3A_column">column</code></td>
<td>
<p>An atomic vector or list. A column from a data frame.</p>
</td></tr>
<tr><td><code id="get_skimmers_+3A_skim_type">skim_type</code></td>
<td>
<p>A character scalar. The class of the object with default
skimmers.</p>
</td></tr>
<tr><td><code id="get_skimmers_+3A_new_skim_type">new_skim_type</code></td>
<td>
<p>The type to assign to the looked up set of skimmers.</p>
</td></tr>
<tr><td><code id="get_skimmers_+3A_new_funs">new_funs</code></td>
<td>
<p>Replacement functions for those in</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When creating your own set of skimming functions, call <code><a href="#topic+sfl">sfl()</a></code> within a
<code><a href="#topic+get_skimmers">get_skimmers()</a></code> method for your particular type. Your call to <code><a href="#topic+sfl">sfl()</a></code> should
also provide a matching class in the <code>skim_type</code> argument.  Otherwise, it
will not be possible to dynamically reassign your default functions when
working interactively.
</p>
<p>Call <code><a href="#topic+get_default_skimmers">get_default_skimmers()</a></code> to see the functions for each type of summary
function currently supported. Call <code><a href="#topic+get_default_skimmer_names">get_default_skimmer_names()</a></code> to just see
the names of these functions. Use <code><a href="#topic+modify_default_skimmers">modify_default_skimmers()</a></code> for a method
for changing the <code>skim_type</code> or functions for a default <code>sfl</code>. This is useful
for creating new default <code>sfl</code>'s.
</p>


<h3>Value</h3>

<p>A <code>skim_function_list</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>get_skimmers(default)</code>: The default method for skimming data. Only used when
a column's data type doesn't match currently installed types. Call
<a href="#topic+get_default_skimmer_names">get_default_skimmer_names</a> to see these defaults.
</p>
</li>
<li> <p><code>get_skimmers(numeric)</code>: Summary functions for numeric columns, covering both
<code><a href="base.html#topic+double">double()</a></code> and <code><a href="base.html#topic+integer">integer()</a></code> classes: <code><a href="base.html#topic+mean">mean()</a></code>, <code><a href="stats.html#topic+sd">sd()</a></code>, <code><a href="stats.html#topic+quantile">quantile()</a></code> and
<code><a href="#topic+inline_hist">inline_hist()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(factor)</code>: Summary functions for factor columns:
<code><a href="base.html#topic+is.ordered">is.ordered()</a></code>, <code><a href="#topic+n_unique">n_unique()</a></code> and <code><a href="#topic+top_counts">top_counts()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(character)</code>: Summary functions for character columns. Also, the
default for unknown columns: <code><a href="#topic+min_char">min_char()</a></code>, <code><a href="#topic+max_char">max_char()</a></code>, <code><a href="#topic+n_empty">n_empty()</a></code>,
<code><a href="#topic+n_unique">n_unique()</a></code> and <code><a href="#topic+n_whitespace">n_whitespace()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(logical)</code>: Summary functions for logical/ boolean columns:
<code><a href="base.html#topic+mean">mean()</a></code>, which produces rates for each value, and <code><a href="#topic+top_counts">top_counts()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(complex)</code>: Summary functions for complex columns: <code><a href="base.html#topic+mean">mean()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(Date)</code>: Summary functions for <code>Date</code> columns: <code><a href="base.html#topic+min">min()</a></code>,
<code><a href="base.html#topic+max">max()</a></code>, <code><a href="stats.html#topic+median">median()</a></code> and <code><a href="#topic+n_unique">n_unique()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(POSIXct)</code>: Summary functions for <code>POSIXct</code> columns: <code><a href="base.html#topic+min">min()</a></code>,
<code><a href="base.html#topic+max">max()</a></code>, <code><a href="stats.html#topic+median">median()</a></code> and <code><a href="#topic+n_unique">n_unique()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(difftime)</code>: Summary functions for <code>difftime</code> columns: <code><a href="base.html#topic+min">min()</a></code>,
<code><a href="base.html#topic+max">max()</a></code>, <code><a href="stats.html#topic+median">median()</a></code> and <code><a href="#topic+n_unique">n_unique()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(Timespan)</code>: Summary functions for <code>Timespan</code> columns: <code><a href="base.html#topic+min">min()</a></code>,
<code><a href="base.html#topic+max">max()</a></code>, <code><a href="stats.html#topic+median">median()</a></code> and <code><a href="#topic+n_unique">n_unique()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(ts)</code>: Summary functions for <code>ts</code> columns: <code><a href="base.html#topic+min">min()</a></code>,
<code><a href="base.html#topic+max">max()</a></code>, <code><a href="stats.html#topic+median">median()</a></code> and <code><a href="#topic+n_unique">n_unique()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(list)</code>: Summary functions for <code>list</code> columns: <code><a href="#topic+n_unique">n_unique()</a></code>,
<code><a href="#topic+list_min_length">list_min_length()</a></code> and <code><a href="#topic+list_max_length">list_max_length()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(AsIs)</code>: Summary functions for <code>AsIs</code> columns: <code><a href="#topic+n_unique">n_unique()</a></code>,
<code><a href="#topic+list_min_length">list_min_length()</a></code> and <code><a href="#topic+list_max_length">list_max_length()</a></code>.
</p>
</li>
<li> <p><code>get_skimmers(haven_labelled)</code>: Summary functions for <code>haven_labelled</code> columns.
Finds the appropriate skimmers for the underlying data in the vector.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+sfl">sfl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defining default skimming functions for a new class, `my_class`.
# Note that the class argument is required for dynamic reassignment.
get_skimmers.my_class &lt;- function(column) {
  sfl(
    skim_type = "my_class",
    mean,
    sd
  )
}

# Integer and double columns are both "numeric" and are treated the same
# by default. To switch this behavior in another package, add a method.
get_skimmers.integer &lt;- function(column) {
  sfl(
    skim_type = "integer",
    p50 = ~ stats::quantile(
      .,
      probs = .50, na.rm = TRUE, names = FALSE, type = 1
    )
  )
}
x &lt;- mtcars[c("gear", "carb")]
class(x$carb) &lt;- "integer"
skim(x)
## Not run: 
# In a package, to revert to the V1 behavior of skimming separately with the
# same functions, assign the numeric `get_skimmers`.
get_skimmers.integer &lt;- skimr::get_skimmers.numeric

# Or, in a local session, use `skim_with` to create a different `skim`.
new_skim &lt;- skim_with(integer = skimr::get_skimmers.numeric())

# To apply a set of skimmers from an old type to a new type
get_skimmers.new_type &lt;- function(column) {
  modify_default_skimmers("old_type", new_skim_type = "new_type")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='knit_print'>Provide a default printing method for knitr.</h2><span id='topic+knit_print'></span><span id='topic+knit_print.skim_df'></span><span id='topic+knit_print.skim_list'></span><span id='topic+knit_print.one_skim_df'></span><span id='topic+knit_print.summary_skim_df'></span>

<h3>Description</h3>

<p>Instead of standard R output, <code>knitr</code> and <code>RMarkdown</code> documents will have
formatted <code><a href="knitr.html#topic+kable">knitr::kable()</a></code> output on return. You can disable this by setting
the chunk option <code>render = normal_print</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skim_df'
knit_print(x, options = NULL, ...)

## S3 method for class 'skim_list'
knit_print(x, options = NULL, ...)

## S3 method for class 'one_skim_df'
knit_print(x, options = NULL, ...)

## S3 method for class 'summary_skim_df'
knit_print(x, options = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_print_+3A_x">x</code></td>
<td>
<p>An R object to be printed</p>
</td></tr>
<tr><td><code id="knit_print_+3A_options">options</code></td>
<td>
<p>Options passed into the print function.</p>
</td></tr>
<tr><td><code id="knit_print_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the S3 method. Currently ignored,
except two optional arguments <code>options</code> and <code>inline</code>; see
the references below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary statistics for the original data frame can be disabled by setting
the <code>knitr</code> chunk option <code>skimr_include_summary = FALSE</code>. See
<a href="knitr.html#topic+opts_chunk">knitr::opts_chunk</a> for more information. You can change the number of digits
shown in the printed table with the <code>skimr_digits</code> chunk option.
</p>
<p>Alternatively, you can call <code><a href="dplyr.html#topic+collapse">collapse()</a></code> or <code><a href="#topic+yank">yank()</a></code> to get the particular
<code>skim_df</code> objects and format them however you like. One warning though.
Because histograms contain unicode characters, they can have unexpected
print results, as R as varying levels of unicode support. This affects
Windows users most commonly. Call <code>vignette("Using_fonts")</code> for more details.
</p>


<h3>Value</h3>

<p>A <code>knit_asis</code> object. Which is used by <code>knitr</code> when rendered.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>knit_print(skim_df)</code>: Default <code>knitr</code> print for <code>skim_df</code> objects.
</p>
</li>
<li> <p><code>knit_print(skim_list)</code>: Default <code>knitr</code> print for a <code>skim_list</code>.
</p>
</li>
<li> <p><code>knit_print(one_skim_df)</code>: Default <code>knitr</code> print within a partitioned <code>skim_df</code>.
</p>
</li>
<li> <p><code>knit_print(summary_skim_df)</code>: Default <code>knitr</code> print for <code>skim_df</code> summaries.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="knitr.html#topic+kable">knitr::kable()</a></code>
</p>

<hr>
<h2 id='mutate.skim_df'>Mutate a skim_df</h2><span id='topic+mutate.skim_df'></span>

<h3>Description</h3>

<p><code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> currently drops attributes, but we need to keep them around
for other skim behaviors. Otherwise the behavior is exactly the same. For
more information, see <a href="https://github.com/tidyverse/dplyr/issues/3429">https://github.com/tidyverse/dplyr/issues/3429</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skim_df'
mutate(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate.skim_df_+3A_.data">.data</code></td>
<td>
<p>A <code>skim_df</code>, which behaves like a <code>tbl.</code></p>
</td></tr>
<tr><td><code id="mutate.skim_df_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions, each with length 1 or the same
length as the number of rows in the group, if using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>, or
in the entire input (if not using groups). The name of each argument will
be the name of a new variable, and the value will be its corresponding
value. Use <code>NULL</code> value in <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> to drop a variable. New
variables overwrite existing variables of the same name.
</p>
<p>The arguments in <code>...</code> are automatically quoted with <code><a href="rlang.html#topic+defusing-advanced">rlang::quo()</a></code> and
evaluated with <code><a href="rlang.html#topic+eval_tidy">rlang::eval_tidy()</a></code> in the context of the data frame. They
support unquoting <a href="rlang.html#topic+topic-inject">rlang::quasiquotation</a> and splicing. See
<code>vignette("programming", package = "dplyr")</code> for an introduction to these
concepts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>skim_df</code> object, which also inherits the class(es) of the input
data. In many ways, the object behaves like a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> for the function's expected behavior.
</p>

<hr>
<h2 id='partition'>Separate a big <code>skim_df</code> into smaller data frames, by type.</h2><span id='topic+partition'></span><span id='topic+bind'></span><span id='topic+yank'></span>

<h3>Description</h3>

<p>The data frames produced by <code><a href="#topic+skim">skim()</a></code> are wide and sparse, filled with
columns that are mostly <code>NA</code>. For that reason, it can be convenient to
work with &quot;by type&quot; subsets of the original data frame. These smaller
subsets have their <code>NA</code> columns removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(data)

bind(data)

yank(data, skim_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_+3A_data">data</code></td>
<td>
<p>A <code>skim_df</code>.</p>
</td></tr>
<tr><td><code id="partition_+3A_skim_type">skim_type</code></td>
<td>
<p>A character scalar. The subtable to extract from a
<code>skim_df</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>partition()</code> creates a list of smaller <code>skim_df</code> data frames. Each entry
in the list is a data type from the original <code>skim_df</code>. The inverse of
<code>partition()</code> is <code>bind()</code>, which takes the list and produces the original
<code>skim_df</code>. While <code>partition()</code> keeps all of the subtables as list entries,
<code>yank()</code> gives you a single subtable for a data type.
</p>


<h3>Value</h3>

<p>A <code>skim_list</code> of <code>skim_df</code>'s, by type.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bind()</code>: The inverse of a <code>partition()</code>. Rebuild the original
<code>skim_df</code>.
</p>
</li>
<li> <p><code>yank()</code>: Extract a subtable from a <code>skim_df</code> with a particular
type.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Create a wide skimmed data frame (a skim_df)
skimmed &lt;- skim(iris)

# Separate into a list of subtables by type
separate &lt;- partition(skimmed)

# Put back together
identical(bind(separate), skimmed)
# &gt; TRUE

# Alternatively, get the subtable of a particular type
yank(skimmed, "factor")
</code></pre>

<hr>
<h2 id='print'>Print <code>skim</code> objects</h2><span id='topic+print'></span><span id='topic+print.skim_df'></span><span id='topic+print.skim_list'></span><span id='topic+print.summary_skim_df'></span>

<h3>Description</h3>

<p><code>skimr</code> has custom print methods for all supported objects. Default printing
methods for <code>knitr</code>/ <code>rmarkdown</code> documents is also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skim_df'
print(
  x,
  include_summary = TRUE,
  n = Inf,
  width = Inf,
  summary_rule_width = getOption("skimr_summary_rule_width", default = 40),
  ...
)

## S3 method for class 'skim_list'
print(x, n = Inf, width = Inf, ...)

## S3 method for class 'summary_skim_df'
print(x, .summary_rule_width = 40, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Object to format or print.</p>
</td></tr>
<tr><td><code id="print_+3A_include_summary">include_summary</code></td>
<td>
<p>Whether a summary of the data frame should be printed</p>
</td></tr>
<tr><td><code id="print_+3A_n">n</code></td>
<td>
<p>Number of rows to show. If <code>NULL</code>, the default, will print all rows
if less than the <code>print_max</code> <a href="pillar.html#topic+pillar_options">option</a>.
Otherwise, will print as many rows as specified by the
<code>print_min</code> <a href="pillar.html#topic+pillar_options">option</a>.</p>
</td></tr>
<tr><td><code id="print_+3A_width">width</code></td>
<td>
<p>Width of text output to generate. This defaults to <code>NULL</code>, which
means use the <code>width</code> <a href="pillar.html#topic+pillar_options">option</a>.</p>
</td></tr>
<tr><td><code id="print_+3A_summary_rule_width">summary_rule_width</code></td>
<td>
<p>Width of Data Summary cli rule, defaults to 40.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Passed on to <code><a href="pillar.html#topic+tbl_format_setup">tbl_format_setup()</a></code>.</p>
</td></tr>
<tr><td><code id="print_+3A_.summary_rule_width">.summary_rule_width</code></td>
<td>
<p>the width for the main rule above the summary.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>print(skim_df)</code>: Print a skimmed data frame (<code>skim_df</code> from <code><a href="#topic+skim">skim()</a></code>).
</p>
</li>
<li> <p><code>print(skim_list)</code>: Print a <code>skim_list</code>, a list of <code>skim_df</code> objects.
</p>
</li>
<li> <p><code>print(summary_skim_df)</code>: Print method for a <code>summary_skim_df</code> object.
</p>
</li></ul>


<h3>Printing options</h3>

<p>For better or for worse, <code>skimr</code> often produces more output than can fit in
the standard R console. Fortunately, most modern environments like RStudio
and Jupyter support more than 80 character outputs. Call
<code>options(width = 90)</code> to get a better experience with <code>skimr</code>.
</p>
<p>The print methods in <code>skimr</code> wrap those in the <a href="tibble.html#topic+formatting">tibble</a>
package. You can control printing behavior using the same global options.
</p>


<h3>Behavior in <code>dplyr</code> pipelines</h3>

<p>Printing a <code>skim_df</code> requires specific columns that might be dropped when
using <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> or <code><a href="dplyr.html#topic+summarise">dplyr::summarize()</a></code> on a <code>skim_df</code>. In those
cases, this method falls back to <code><a href="tibble.html#topic+formatting">tibble::print.tbl()</a></code>.
</p>


<h3>Options for controlling print behavior</h3>

<p>You can control the width rule line for the printed subtables with an option:
<code>skimr_table_header_width</code>.
</p>


<h3>See Also</h3>

<p><code><a href="tibble.html#topic+trunc_mat">tibble::trunc_mat()</a></code> For a list of global options for customizing
print formatting. <code><a href="crayon.html#topic+has_color">crayon::has_color()</a></code> for the variety of issues that
affect tibble's color support.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+contains'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+starts_with'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+one_of">one_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code></p>
</dd>
</dl>

<hr>
<h2 id='repr'>Skimr printing within Jupyter notebooks</h2><span id='topic+repr'></span><span id='topic+repr_text.skim_df'></span><span id='topic+repr_text.skim_list'></span><span id='topic+repr_text.one_skim_df'></span>

<h3>Description</h3>

<p>This reproduces printed results in the console. By default Jupyter kernels
render the final object in the cell. We want the version printed by
<code>skimr</code> instead of the data that it contains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skim_df'
repr_text(obj, ...)

## S3 method for class 'skim_list'
repr_text(obj, ...)

## S3 method for class 'one_skim_df'
repr_text(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repr_+3A_obj">obj</code></td>
<td>
<p>The object to <a href="#topic+print">print</a> and then return the output.</p>
</td></tr>
<tr><td><code id="repr_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. <code>invisible(NULL)</code>.
</p>

<hr>
<h2 id='sfl'>Create a skimr function list</h2><span id='topic+sfl'></span>

<h3>Description</h3>

<p>This constructor is used to create a named list of functions. It also you
also pass <code>NULL</code> to identify a skimming function that you wish to remove.
Only functions that return a single value, working with <code><a href="dplyr.html#topic+summarise">dplyr::summarize()</a></code>,
can be used within <code>sfl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfl(..., skim_type = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfl_+3A_...">...</code></td>
<td>
<p>Inherited from dplyr::data_masking() for dplyr version 1 or later
or dplyr::funs() for older versions of dplyr.
A list of functions
specified by:
</p>

<ul>
<li><p> Their name, <code>"mean"</code>
</p>
</li>
<li><p> The function itself, <code>mean</code>
</p>
</li>
<li><p> A call to the function with <code>.</code> as a dummy argument,
<code>mean(., na.rm = TRUE)</code>
</p>
</li>
<li><p> An anonymous function in <span class="pkg">purrr</span> notation, <code>~mean(., na.rm = TRUE)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="sfl_+3A_skim_type">skim_type</code></td>
<td>
<p>A character scalar. This is used to match locally-provided
skimmers with defaults. See <code><a href="#topic+get_skimmers">get_skimmers()</a></code> for more detail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sfl()</code> will automatically generate callables and names for a variety of
inputs, including functions, formulas and strings. Nonetheless, we recommend
providing names when reasonable to get better <code><a href="#topic+skim">skim()</a></code> output.
</p>


<h3>Value</h3>

<p>A <code>skimr_function_list</code>, which contains a list of <code>fun_calls</code>,
returned by <code>dplyr::funs()</code> and a list of skimming functions to drop.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+funs">dplyr::funs()</a></code>, <code><a href="#topic+skim_with">skim_with()</a></code> and <code><a href="#topic+get_skimmers">get_skimmers()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sfl's can take a variety of input formats and will generate names
# if not provided.
sfl(mad, "var", ~ length(.)^2)

# But these can generate unpredictable names in your output.
# Better to set your own names.
sfl(mad = mad, variance = "var", length_sq = ~ length(.)^2)

# sfl's can remove individual skimmers from defaults by passing NULL.
sfl(hist = NULL)

# When working interactively, you don't need to set a type.
# But you should when defining new defaults with `get_skimmers()`.
get_skimmers.my_new_class &lt;- function(column) {
  sfl(n_missing, skim_type = "my_new_class")
}
</code></pre>

<hr>
<h2 id='skim'>Skim a data frame, getting useful summary statistics</h2><span id='topic+skim'></span><span id='topic+skim_tee'></span><span id='topic+skim_without_charts'></span>

<h3>Description</h3>

<p><code>skim()</code> is an alternative to <code><a href="base.html#topic+summary">summary()</a></code>, quickly providing a broad
overview of a data frame. It handles data of all types, dispatching a
different set of summary functions based on the types of columns in the data
frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skim(data, ..., .data_name = NULL)

skim_tee(data, ..., skim_fun = skim)

skim_without_charts(data, ..., .data_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skim_+3A_data">data</code></td>
<td>
<p>A tibble, or an object that can be coerced into a tibble.</p>
</td></tr>
<tr><td><code id="skim_+3A_...">...</code></td>
<td>
<p>Columns to select for skimming. When none are provided, the
default is to skim all columns.</p>
</td></tr>
<tr><td><code id="skim_+3A_.data_name">.data_name</code></td>
<td>
<p>The name to use for the data. Defaults to the same as data.</p>
</td></tr>
<tr><td><code id="skim_+3A_skim_fun">skim_fun</code></td>
<td>
<p>The skim function used.</p>
</td></tr>
<tr><td><code id="skim_+3A_skim">skim</code></td>
<td>
<p>The skimming function to use in <code>skim_tee()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each call produces a <code>skim_df</code>, which is a fundamentally a tibble with a
special print method. One unusual feature of this data frame is pseudo-
namespace for columns. <code>skim()</code> computes statistics by data type, and it
stores them in the data frame as <code style="white-space: pre;">&#8288;&lt;type&gt;.&lt;statistic&gt;&#8288;</code>. These types are
stripped when printing the results. The &quot;base&quot; skimmers (<code>n_missing</code> and
<code>complete_rate</code>) are the only columns that don't follow this behavior.
See <code><a href="#topic+skim_with">skim_with()</a></code> for more details on customizing <code>skim()</code> and
<code><a href="#topic+get_default_skimmers">get_default_skimmers()</a></code> for a list of default functions.
</p>
<p>If you just want to see the printed output, call <code>skim_tee()</code> instead.
This function returns the original data. <code>skim_tee()</code> uses the default
<code>skim()</code>, but you can replace it with the <code>skim</code> argument.
</p>
<p>The data frame produced by <code>skim</code> is wide and sparse. To avoid type coercion
<code>skimr</code> uses a type namespace for all summary statistics. Columns for numeric
summary statistics all begin <code>numeric</code>; for factor summary statistics
begin <code>factor</code>; and so on.
</p>
<p>See <code><a href="#topic+partition">partition()</a></code> and <code><a href="#topic+yank">yank()</a></code> for methods for transforming this wide data
frame. The first function splits it into a list, with each entry
corresponding to a data type. The latter pulls a single subtable for a
particular type from the <code>skim_df</code>.
</p>
<p><code>skim()</code> is designed to operate in pipes and to generally play nicely with
other <code>tidyverse</code> functions. This means that you can use <code>tidyselect</code> helpers
within <code>skim</code> to select or drop specific columns for summary. You can also
further work with a <code>skim_df</code> using <code>dplyr</code> functions in a pipeline.
</p>


<h3>Value</h3>

<p>A <code>skim_df</code> object, which also inherits the class(es) of the input
data. In many ways, the object behaves like a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>.
</p>


<h3>Customizing skim</h3>

<p><code>skim()</code> is an intentionally simple function, with minimal arguments like
<code><a href="base.html#topic+summary">summary()</a></code>. Nonetheless, this package provides two broad approaches to
how you can customize <code>skim()</code>'s behavior. You can customize the functions
that are called to produce summary statistics with <code><a href="#topic+skim_with">skim_with()</a></code>.
</p>


<h3>Unicode rendering</h3>

<p>If the rendered examples show unencoded values such as <code style="white-space: pre;">&#8288;&lt;U+2587&gt;&#8288;</code> you will
need to change your locale to allow proper rendering. Please review the
<em>Using Skimr</em> vignette for more information
(<code>vignette("Using_skimr", package = "skimr")</code>).
</p>
<p>Otherwise, we export <code>skim_without_charts()</code> to produce summaries without the
spark graphs. These are the source of the unicode dependency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skim(iris)

# Use tidyselect
skim(iris, Species)
skim(iris, starts_with("Sepal"))
skim(iris, where(is.numeric))

# Skim also works groupwise
iris %&gt;%
  dplyr::group_by(Species) %&gt;%
  skim()

# Which five numeric columns have the greatest mean value?
# Look in the `numeric.mean` column.
iris %&gt;%
  skim() %&gt;%
  dplyr::select(numeric.mean) %&gt;%
  dplyr::top_n(5)

# Which of my columns have missing values? Use the base skimmer n_missing.
iris %&gt;%
  skim() %&gt;%
  dplyr::filter(n_missing &gt; 0)

# Use skim_tee to view the skim results and
# continue using the original data.
chickwts %&gt;%
  skim_tee() %&gt;%
  dplyr::filter(feed == "sunflower")

# Produce a summary without spark graphs
iris %&gt;%
  skim_without_charts()
</code></pre>

<hr>
<h2 id='skim_with'>Set or add the summary functions for a particular type of data</h2><span id='topic+skim_with'></span>

<h3>Description</h3>

<p>While skim is designed around having an opinionated set of defaults, you
can use this function to change the summary statistics that it returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skim_with(
  ...,
  base = sfl(n_missing = n_missing, complete_rate = complete_rate),
  append = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skim_with_+3A_...">...</code></td>
<td>
<p>One or more (<code>sfl</code>) <code>skimmer_function_list</code> objects, with an
argument name that matches a particular data type.</p>
</td></tr>
<tr><td><code id="skim_with_+3A_base">base</code></td>
<td>
<p>An <code>sfl</code> that sets skimmers for all column types.</p>
</td></tr>
<tr><td><code id="skim_with_+3A_append">append</code></td>
<td>
<p>Whether the provided options should be in addition to the
defaults already in <code>skim</code>. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>skim_with()</code> is a closure: a function that returns a new function. This
lets you have several skimming functions in a single R session, but it
also means that you need to assign the return of <code>skim_with()</code> before
you can use it.
</p>
<p>You assign values within <code>skim_with</code> by using the <code><a href="#topic+sfl">sfl()</a></code> helper (<code>skimr</code>
function list). This helper behaves mostly like <code><a href="dplyr.html#topic+funs">dplyr::funs()</a></code>, but lets
you also identify which skimming functions you want to remove, by setting
them to <code>NULL</code>. Assign an <code>sfl</code> to each column type that you wish to modify.
</p>
<p>Functions that summarize all data types, and always return the same type
of value, can be assigned to the <code>base</code> argument. The default base skimmers
compute the number of missing values <code><a href="#topic+n_missing">n_missing()</a></code> and the rate of values
being complete, i.e. not missing, <code><a href="#topic+complete_rate">complete_rate()</a></code>.
</p>
<p>When <code>append = TRUE</code> and local skimmers have names matching the names of
entries in the default <code>skim_function_list</code>, the values in the default list
are overwritten. Similarly, if <code>NULL</code> values are passed within <code>sfl()</code>, these
default skimmers are dropped. Otherwise, if <code>append = FALSE</code>, only the
locally-provided skimming functions are used.
</p>
<p>Note that <code>append</code> only applies to the <code>typed</code> skimmers (i.e. non-base).
See <code><a href="#topic+get_default_skimmer_names">get_default_skimmer_names()</a></code> for a list of defaults.
</p>


<h3>Value</h3>

<p>A new <code>skim()</code> function. This is callable. See <code><a href="#topic+skim">skim()</a></code> for more
details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use new functions for numeric functions. If you don't provide a name,
# one will be automatically generated.
my_skim &lt;- skim_with(numeric = sfl(median, mad), append = FALSE)
my_skim(faithful)

# If you want to remove a particular skimmer, set it to NULL
# This removes the inline histogram
my_skim &lt;- skim_with(numeric = sfl(hist = NULL))
my_skim(faithful)

# This works with multiple skimmers. Just match names to overwrite
my_skim &lt;- skim_with(numeric = sfl(iqr = IQR, p25 = NULL, p75 = NULL))
my_skim(faithful)

# Alternatively, set `append = FALSE` to replace the skimmers of a type.
my_skim &lt;- skim_with(numeric = sfl(mean = mean, sd = sd), append = FALSE)

# Skimmers are unary functions. Partially apply arguments during assigment.
# For example, you might want to remove NA values.
my_skim &lt;- skim_with(numeric = sfl(iqr = ~ IQR(., na.rm = TRUE)))

# Set multiple types of skimmers simultaneously.
my_skim &lt;- skim_with(numeric = sfl(mean), character = sfl(length))

# Or pass the same as a list, unquoting the input.
my_skimmers &lt;- list(numeric = sfl(mean), character = sfl(length))
my_skim &lt;- skim_with(!!!my_skimmers)

# Use the v1 base skimmers instead.
my_skim &lt;- skim_with(base = sfl(
  missing = n_missing,
  complete = n_complete,
  n = length
))

# Remove the base skimmers entirely
my_skim &lt;- skim_with(base = NULL)
</code></pre>

<hr>
<h2 id='skim-attr'>Functions for accessing skim_df attributes</h2><span id='topic+skim-attr'></span><span id='topic+data_rows'></span><span id='topic+data_cols'></span><span id='topic+df_name'></span><span id='topic+dt_key'></span><span id='topic+group_names'></span><span id='topic+base_skimmers'></span><span id='topic+skimmers_used'></span>

<h3>Description</h3>

<p>These functions simplify access to attributes contained within a <code>skim_df</code>.
While all attributes are read-only, being able to extract this information
is useful for different analyses. These functions should always be preferred
over calling base R's attribute functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_rows(object)

data_cols(object)

df_name(object)

dt_key(object)

group_names(object)

base_skimmers(object)

skimmers_used(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skim-attr_+3A_object">object</code></td>
<td>
<p>A <code>skim_df</code> or <code>skim_list</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data contained within the requested <code>skimr</code> attribute.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>data_rows()</code>: Get the number of rows in the skimmed data frame.
</p>
</li>
<li> <p><code>data_cols()</code>: Get the number of columns in the skimmed data frame.
</p>
</li>
<li> <p><code>df_name()</code>: Get the name of the skimmed data frame. This is only
available in contexts where the name can be looked up. This is often not
the case within a pipeline.
</p>
</li>
<li> <p><code>dt_key()</code>: Get the key of the skimmed data.table. This is only
available in contexts where <code>data</code> is of class <code>data.table</code>.
</p>
</li>
<li> <p><code>group_names()</code>: Get the names of the groups in the original data frame.
Only available if the data was grouped. Otherwise, <code>NULL</code>.
</p>
</li>
<li> <p><code>base_skimmers()</code>: Get the names of the base skimming functions used.
</p>
</li>
<li> <p><code>skimmers_used()</code>: Get the names of the skimming functions used, separated
by data type.
</p>
</li></ul>

<hr>
<h2 id='skim-obj'>Test if an object is compatible with <code>skimr</code></h2><span id='topic+skim-obj'></span><span id='topic+has_type_column'></span><span id='topic+has_variable_column'></span><span id='topic+has_skimr_attributes'></span><span id='topic+has_skim_type_attribute'></span><span id='topic+has_skimmers'></span><span id='topic+is_data_frame'></span><span id='topic+is_skim_df'></span><span id='topic+is_one_skim_df'></span><span id='topic+is_skim_list'></span><span id='topic+could_be_skim_df'></span><span id='topic+assert_is_skim_df'></span><span id='topic+assert_is_skim_list'></span><span id='topic+assert_is_one_skim_df'></span>

<h3>Description</h3>

<p>Objects within <code>skimr</code> are identified by a class, but they require additional
attributes and data columns for all operations to succeed. These checks help
ensure this. While they have some application externally, they are mostly
used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_type_column(object)

has_variable_column(object)

has_skimr_attributes(object)

has_skim_type_attribute(object)

has_skimmers(object)

is_data_frame(object)

is_skim_df(object)

is_one_skim_df(object)

is_skim_list(object)

could_be_skim_df(object)

assert_is_skim_df(object)

assert_is_skim_list(object)

assert_is_one_skim_df(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skim-obj_+3A_object">object</code></td>
<td>
<p>Any <code>R</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most notably, a <code>skim_df</code> has columns <code>skim_type</code> and <code>skim_variable</code>. And
has the following special attributes
</p>

<ul>
<li> <p><code>data_rows</code>: n rows in the original data
</p>
</li>
<li> <p><code>data_cols</code>: original number of columns
</p>
</li>
<li> <p><code>df_name</code>: name of the original data frame
</p>
</li>
<li> <p><code>dt_key</code>: name of the key if original is a data.table
</p>
</li>
<li> <p><code>groups</code>: if there were group variables
</p>
</li>
<li> <p><code>base_skimmers</code>: names of functions applied to all skim types
</p>
</li>
<li> <p><code>skimmers_used</code>: names of functions used to skim each type
</p>
</li></ul>

<p>The functions in these checks work like <code><a href="base.html#topic+all.equal">all.equal()</a></code>. The return <code>TRUE</code> if
the check passes, or otherwise notifies why the check failed. This makes them
more useful when throwing errors.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>has_type_column()</code>: Does the object have the <code>skim_type</code> column?
</p>
</li>
<li> <p><code>has_variable_column()</code>: Does the object have the <code>skim_variable</code> column?
</p>
</li>
<li> <p><code>has_skimr_attributes()</code>: Does the object have the appropriate <code>skimr</code> attributes?
</p>
</li>
<li> <p><code>has_skim_type_attribute()</code>: Does the object have a <code>skim_type</code> attribute? This makes
it a <code>one_skim_df</code>.
</p>
</li>
<li> <p><code>has_skimmers()</code>: Does the object have skimmers?
</p>
</li>
<li> <p><code>is_data_frame()</code>: Is the object a data frame?
</p>
</li>
<li> <p><code>is_skim_df()</code>: Is the object a <code>skim_df</code>?
</p>
</li>
<li> <p><code>is_one_skim_df()</code>: Is the object a <code>one_skim_df</code>? This is similar to a
<code>skim_df</code>, but does not have the <code>type</code> column. That is stored as an
attribute instead.
</p>
</li>
<li> <p><code>is_skim_list()</code>: Is the object a <code>skim_list</code>?
</p>
</li>
<li> <p><code>could_be_skim_df()</code>: Is this a data frame with <code>skim_variable</code> and
<code>skim_type</code> columns?
</p>
</li>
<li> <p><code>assert_is_skim_df()</code>: Stop if the object is not a <code>skim_df</code>.
</p>
</li>
<li> <p><code>assert_is_skim_list()</code>: Stop if the object is not a <code>skim_list</code>.
</p>
</li>
<li> <p><code>assert_is_one_skim_df()</code>: Stop if the object is not a <code>one_skim_df</code>.
</p>
</li></ul>

<hr>
<h2 id='skimr-vctrs'>Functions for working with the vctrs package</h2><span id='topic+skimr-vctrs'></span><span id='topic+vec_ptype2.skim_df.skim_df'></span><span id='topic+vec_ptype2.skim_df.tbl_df'></span><span id='topic+vec_ptype2.tbl_df.skim_df'></span><span id='topic+vec_cast.skim_df.skim_df'></span><span id='topic+vec_cast.skim_df.tbl_df'></span><span id='topic+vec_cast.tbl_df.skim_df'></span>

<h3>Description</h3>

<p>These make it clear that we need to use the tibble behavior when joining,
concatenating or casting <code>skim_df</code> objects. For a better discussion, on
why this is important and how these functions work, see:
<a href="https://vctrs.r-lib.org/reference/howto-faq-coercion-data-frame.html">https://vctrs.r-lib.org/reference/howto-faq-coercion-data-frame.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skim_df.skim_df'
vec_ptype2(x, y, ...)

## S3 method for class 'skim_df.tbl_df'
vec_ptype2(x, y, ...)

## S3 method for class 'tbl_df.skim_df'
vec_ptype2(x, y, ...)

## S3 method for class 'skim_df.skim_df'
vec_cast(x, to, ...)

## S3 method for class 'skim_df.tbl_df'
vec_cast(x, to, ...)

## S3 method for class 'tbl_df.skim_df'
vec_cast(x, to, ...)
</code></pre>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;vec_ptype2.*&#8288;</code> handles finding common prototypes between <code>skim_df</code> and
similar objects. <code style="white-space: pre;">&#8288;vec_cast.*&#8288;</code> handles casting between objects. Note that
as of <code style="white-space: pre;">&#8288;dplyr 1.0.2&#8288;</code>, <code><a href="dplyr.html#topic+bind">dplyr::bind_rows()</a></code> does not full support combining
attributes and <code><a href="vctrs.html#topic+vec_bind">vctrs::vec_rbind()</a></code> is preferred instead.
</p>

<hr>
<h2 id='stats'>Summary statistic functions</h2><span id='topic+stats'></span><span id='topic+n_missing'></span><span id='topic+n_complete'></span><span id='topic+complete_rate'></span><span id='topic+n_whitespace'></span><span id='topic+sorted_count'></span><span id='topic+top_counts'></span><span id='topic+inline_hist'></span><span id='topic+n_empty'></span><span id='topic+min_char'></span><span id='topic+max_char'></span><span id='topic+n_unique'></span><span id='topic+ts_start'></span><span id='topic+ts_end'></span><span id='topic+inline_linegraph'></span><span id='topic+list_lengths_min'></span><span id='topic+list_lengths_median'></span><span id='topic+list_lengths_max'></span><span id='topic+list_min_length'></span><span id='topic+list_max_length'></span>

<h3>Description</h3>

<p><code>skimr</code> provides extensions to a variety of functions with R's stats package
to simplify creating summaries of data. All functions are vectorized over the
first argument. Additional arguments should be set in the <code><a href="#topic+sfl">sfl()</a></code> that sets
the appropriate skimmers for a data type. You can use these, along with other
vectorized R functions, for creating custom sets of summary functions for
a given data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_missing(x)

n_complete(x)

complete_rate(x)

n_whitespace(x)

sorted_count(x)

top_counts(x, max_char = 3, max_levels = 4)

inline_hist(x, n_bins = 8)

n_empty(x)

min_char(x)

max_char(x)

n_unique(x)

ts_start(x)

ts_end(x)

inline_linegraph(x, length.out = 16)

list_lengths_min(x)

list_lengths_median(x)

list_lengths_max(x)

list_min_length(x)

list_max_length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="stats_+3A_max_char">max_char</code></td>
<td>
<p>In <code>top</code> = 3, max_levels = 4</p>
</td></tr>
<tr><td><code id="stats_+3A_max_levels">max_levels</code></td>
<td>
<p>The maximum number of levels to be displayed.</p>
</td></tr>
<tr><td><code id="stats_+3A_n_bins">n_bins</code></td>
<td>
<p>In <code>inline_hist</code>, the number of histogram bars.</p>
</td></tr>
<tr><td><code id="stats_+3A_length.out">length.out</code></td>
<td>
<p>In <code>inline_linegraph</code>, the length of the character time
series.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>n_missing()</code>: Calculate the sum of <code>NA</code> and <code>NULL</code> (i.e. missing) values.
</p>
</li>
<li> <p><code>n_complete()</code>: Calculate the sum of not <code>NA</code> and <code>NULL</code> (i.e. missing)
values.
</p>
</li>
<li> <p><code>complete_rate()</code>: Calculate complete values; complete values are not missing.
</p>
</li>
<li> <p><code>n_whitespace()</code>: Calculate the number of rows containing only whitespace
values using s+ regex.
</p>
</li>
<li> <p><code>sorted_count()</code>: Create a contingency table and arrange its levels in
descending order. In case of ties, the ordering of results is alphabetical
and depends upon the locale. <code>NA</code> is treated as a ordinary value for
sorting.
</p>
</li>
<li> <p><code>top_counts()</code>: Compute and collapse a contingency table into a single
character scalar. Wraps <code><a href="#topic+sorted_count">sorted_count()</a></code>.
</p>
</li>
<li> <p><code>inline_hist()</code>: Generate inline histogram for numeric variables. The
character length of the histogram is controlled by the formatting options
for character vectors.
</p>
</li>
<li> <p><code>n_empty()</code>: Calculate the number of blank values in a character vector.
A &quot;blank&quot; is equal to &quot;&quot;.
</p>
</li>
<li> <p><code>min_char()</code>: Calculate the minimum number of characters within a
character vector.
</p>
</li>
<li> <p><code>max_char()</code>: Calculate the maximum number of characters within a
character vector.
</p>
</li>
<li> <p><code>n_unique()</code>: Calculate the number of unique elements but remove <code>NA</code>.
</p>
</li>
<li> <p><code>ts_start()</code>: Get the start for a time series without the frequency.
</p>
</li>
<li> <p><code>ts_end()</code>: Get the finish for a time series without the frequency.
</p>
</li>
<li> <p><code>inline_linegraph()</code>: Generate inline line graph for time series variables. The
character length of the line graph is controlled by the formatting options
for character vectors.
Based on the function in the pillar package.
</p>
</li>
<li> <p><code>list_lengths_min()</code>: Get the length of the shortest list in a vector of lists.
</p>
</li>
<li> <p><code>list_lengths_median()</code>: Get the median length of the lists.
</p>
</li>
<li> <p><code>list_lengths_max()</code>: Get the maximum length of the lists.
</p>
</li>
<li> <p><code>list_min_length()</code>: Get the length of the shortest list in a vector of lists.
</p>
</li>
<li> <p><code>list_max_length()</code>: Get the length of the longest list in a vector of lists.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+get_skimmers">get_skimmers()</a></code> for customizing the functions called by <code><a href="#topic+skim">skim()</a></code>.
</p>

<hr>
<h2 id='summary.skim_df'>Summary function for skim_df</h2><span id='topic+summary.skim_df'></span>

<h3>Description</h3>

<p>This is a method of the generic function <code><a href="base.html#topic+summary">summary()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skim_df'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.skim_df_+3A_object">object</code></td>
<td>
<p>a skim dataframe.</p>
</td></tr>
<tr><td><code id="summary.skim_df_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the skim data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- skim(mtcars)
summary(a)
</code></pre>

<hr>
<h2 id='to_long'>Create &quot;long&quot; skim output</h2><span id='topic+to_long'></span><span id='topic+to_long.default'></span><span id='topic+to_long.skim_df'></span>

<h3>Description</h3>

<p>Skim results returned as a tidy long data frame with four columns:
variable, type, stat and formatted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_long(.data, ..., skim_fun = skim)

## Default S3 method:
to_long(.data, ..., skim_fun = skim)

## S3 method for class 'skim_df'
to_long(.data, ..., skim_fun = skim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_long_+3A_.data">.data</code></td>
<td>
<p>A data frame or an object that can be coerced into a data frame.</p>
</td></tr>
<tr><td><code id="to_long_+3A_...">...</code></td>
<td>
<p>Columns to select for skimming. When none are provided, the
default is to skim all columns.</p>
</td></tr>
<tr><td><code id="to_long_+3A_skim_fun">skim_fun</code></td>
<td>
<p>The skim function used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>to_long(default)</code>: Skim a data frame and convert the results to a
long data frame.
</p>
</li>
<li> <p><code>to_long(skim_df)</code>: Transform a skim_df to a long data frame.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>to_long(iris)
to_long(skim(iris))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
