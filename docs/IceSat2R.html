<!DOCTYPE html><html><head><title>Help for package IceSat2R</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IceSat2R}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#available_nominal_orbits'><p>Nominal mission orbits</p></a></li>
<li><a href='#available_RGTs'><p>Reference Ground Tracks (RGTs)</p></a></li>
<li><a href='#compute_elapsed_time'><p>elapsed time in hours &amp; minutes &amp; seconds</p></a></li>
<li><a href='#degrees_to_global_grid'><p>Create a global grid based on degrees</p></a></li>
<li><a href='#get_atlas_data'><p>Get ICESat-2 ATLAS data for a specific Date</p></a></li>
<li><a href='#get_level3a_data'><p>Get IceSat-2 ATLAS 'Level-3A' data for a time interval (up to 1 year)</p></a></li>
<li><a href='#get_URL_data'><p>Get the data based on the API URL</p></a></li>
<li><a href='#getTracks'><p>Get the ICESAT-2 Tracks</p></a></li>
<li><a href='#IceSat2R'><p>The &quot;IceSat2R&quot; package</p></a></li>
<li><a href='#inner_elapsed_time'><p>inner function of 'compute_elapsed_time'</p></a></li>
<li><a href='#latest_orbits'><p>Extraction of the url from the Technical Specification Website</p></a></li>
<li><a href='#leaflet_base_map'><p>a leaflet base map</p></a></li>
<li><a href='#ne_10m_glaciated_areas'><p>Natural Earth 10m Glaciated Areas (1:10 million scale)</p></a></li>
<li><a href='#overall_mission_orbits'><p>Overall Mission Orbits</p></a></li>
<li><a href='#revisit_time_RGTs'><p>Revisit Time Reference Ground Tracks and Dates</p></a></li>
<li><a href='#RGT_cycle_14'><p>Reference Ground Tracks (RGTs) for IceSat-2 Cycle 14</p></a></li>
<li><a href='#select_aoi_global_grid'><p>R6 Class to Select an Area of Interest (AOI) from a Global Grid</p></a></li>
<li><a href='#switch_abb'><p>Convert an abbreviated month name to a numeric value</p></a></li>
<li><a href='#switch_full'><p>Convert a full month name to a numeric value</p></a></li>
<li><a href='#time_specific_orbits'><p>Time Specific Orbits</p></a></li>
<li><a href='#verify_RGTs'><p>Verification of the Reference Ground Tracks (RGTs)</p></a></li>
<li><a href='#vsi_kml_from_zip'><p>Utilizing Virtual File Systems (vsi) to extract the .kml from the .zip file</p></a></li>
<li><a href='#vsi_nominal_orbits_wkt'><p>Utilizing Virtual File Systems (vsi) and Well Known Text (WKT) to access the 'nominal orbits'</p></a></li>
<li><a href='#vsi_time_specific_orbits_wkt'><p>Utilizing Virtual File Systems (vsi) and Well Known Text (WKT) to access the 'time specific orbits'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>ICESat-2 Altimeter Data using R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-17</td>
</tr>
<tr>
<td>Description:</td>
<td>Programmatic connection to the 'OpenAltimetry API' <a href="https://openaltimetry.org/data/swagger-ui/">https://openaltimetry.org/data/swagger-ui/</a> to download and process 'ATL03' (Global Geolocated Photon Data), 'ATL06' (Land Ice Height), 'ATL07' (Sea Ice Height), 'ATL08' (Land and Vegetation Height), 'ATL10' (Sea Ice Freeboard), 'ATL12' (Ocean Surface Height) and 'ATL13' (Inland Water Surface Height) 'ICESat-2' Altimeter Data. The user has the option to download the data by selecting a bounding box from a 1- or 5-degree grid globally utilizing a shiny application. The 'ICESat-2' mission collects altimetry data of the Earth's surface. The sole instrument on 'ICESat-2' is the Advanced Topographic Laser Altimeter System (ATLAS) instrument that measures ice sheet elevation change and sea ice thickness, while also generating an estimate of global vegetation biomass. 'ICESat-2' continues the important observations of ice-sheet elevation change, sea-ice freeboard, and vegetation canopy height begun by 'ICESat' in 2003.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlampros/IceSat2R">https://github.com/mlampros/IceSat2R</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlampros/IceSat2R/issues">https://github.com/mlampros/IceSat2R/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gdal-bin: apt install -y gdal-bin (deb),
libgdal-dev: apt install -y libgdal-dev (deb), libudunits2-dev:
apt install -y libudunits2-dev (deb), libgeos-dev: apt install
-y libgeos-dev (deb), libproj-dev: apt install -y libproj-dev
(deb), unzip: apt install unzip (deb)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glue, sf, lwgeom, units, data.table, httr, utils, foreach,
tools, doParallel, magrittr, leaflet, leafgl, leaflet.extras,
leafsync, miniUI, shiny, rnaturalearth, lubridate, rvest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, DT, mapview, grDevices, stargazer,
reshape2, plotly, geodist, CopernicusDEM, terra, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-17 07:25:28 UTC; lampros</td>
</tr>
<tr>
<td>Author:</td>
<td>Lampros Mouselimis
    <a href="https://orcid.org/0000-0002-8024-1546"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  OpenAltimetry.org [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lampros Mouselimis &lt;mouselimislampros@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-17 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='available_nominal_orbits'>Nominal mission orbits</h2><span id='topic+available_nominal_orbits'></span>

<h3>Description</h3>

<p>This function allows the user to view the nominal orbits (all or a selection)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_nominal_orbits(
  orbit_area = NULL,
  technical_specs_url = "https://icesat-2.gsfc.nasa.gov/science/specs",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="available_nominal_orbits_+3A_orbit_area">orbit_area</code></td>
<td>
<p>either NULL or a character string specifying the earth partition to use, it can be one of 'antarctic', 'arctic', 'western_hemisphere' and 'eastern_hemisphere'</p>
</td></tr>
<tr><td><code id="available_nominal_orbits_+3A_technical_specs_url">technical_specs_url</code></td>
<td>
<p>a character string specifying the technical specs website</p>
</td></tr>
<tr><td><code id="available_nominal_orbits_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object with the available nominal orbits
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(IceSat2R)

#.............................
# all available nominal orbits
#.............................

nomin_orb = available_nominal_orbits(verbose = TRUE)
nomin_orb

#........................
# specific nominal orbits
#........................

nomin_orb = available_nominal_orbits(orbit_area = 'arctic',
                                     verbose = TRUE)
nomin_orb

</code></pre>

<hr>
<h2 id='available_RGTs'>Reference Ground Tracks (RGTs)</h2><span id='topic+available_RGTs'></span>

<h3>Description</h3>

<p>This function returns the url's of all Reference Ground Track (RGT) cycles. Moreover, it returns the dates that belong to each RGT cycle and the names of the RGT cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_RGTs(
  only_cycle_names = FALSE,
  technical_specs_url = "https://icesat-2.gsfc.nasa.gov/science/specs",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="available_RGTs_+3A_only_cycle_names">only_cycle_names</code></td>
<td>
<p>a boolean. If TRUE then only the RGT (Reference Ground Track) cycle names will be returned. Otherwise all orbit files, dates and cycle names.</p>
</td></tr>
<tr><td><code id="available_RGTs_+3A_technical_specs_url">technical_specs_url</code></td>
<td>
<p>a character string specifying the technical specs website</p>
</td></tr>
<tr><td><code id="available_RGTs_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object with the available orbit files, dates and cycle names
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)

#.................................................
# all available orbit files, dates and cycle names
#.................................................

avail_dat = available_RGTs(only_cycle_names = FALSE,
                           verbose = TRUE)
avail_dat

#.............................
# receive only the cycle names
#.............................

avail_cycles = available_RGTs(only_cycle_names = TRUE,
                              verbose = TRUE)
avail_cycles


## End(Not run)
</code></pre>

<hr>
<h2 id='compute_elapsed_time'>elapsed time in hours &amp; minutes &amp; seconds</h2><span id='topic+compute_elapsed_time'></span>

<h3>Description</h3>

<p>elapsed time in hours &amp; minutes &amp; seconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_elapsed_time(time_start)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_elapsed_time_+3A_time_start">time_start</code></td>
<td>
<p>a numeric value specifying the start time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It does not return a value but only prints the time in form of a character string in the R session
</p>

<hr>
<h2 id='degrees_to_global_grid'>Create a global grid based on degrees</h2><span id='topic+degrees_to_global_grid'></span>

<h3>Description</h3>

<p>This function allows the user to create a degrees grid based on an input bounding box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degrees_to_global_grid(
  minx = -180,
  maxx = 180,
  maxy = 90,
  miny = -90,
  degrees = 1,
  square_geoms = TRUE,
  crs_value = 4326,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degrees_to_global_grid_+3A_minx">minx</code></td>
<td>
<p>the 'minx' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="degrees_to_global_grid_+3A_maxx">maxx</code></td>
<td>
<p>the 'maxx' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="degrees_to_global_grid_+3A_maxy">maxy</code></td>
<td>
<p>the 'maxy' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="degrees_to_global_grid_+3A_miny">miny</code></td>
<td>
<p>the 'miny' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="degrees_to_global_grid_+3A_degrees">degrees</code></td>
<td>
<p>a numeric value specifying the degrees. It defaults to 1.0</p>
</td></tr>
<tr><td><code id="degrees_to_global_grid_+3A_square_geoms">square_geoms</code></td>
<td>
<p>a boolean. If FALSE then a hexagonal grid will be created</p>
</td></tr>
<tr><td><code id="degrees_to_global_grid_+3A_crs_value">crs_value</code></td>
<td>
<p>a value. The coordinate reference system of the output grid. The crs must correspond to the EPSG of the input 'minx', 'maxx', 'miny' and 'maxy'. Moreover, the 'EPSG:4326' returns a degrees grid as output.</p>
</td></tr>
<tr><td><code id="degrees_to_global_grid_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default global input 'minx', 'maxx', 'miny' and 'maxy' correspond to a WKT of &quot;POLYGON ((-180 -90, 180 -90, 180 90, -180 90, -180 -90))&quot;
When 'minx', 'maxx', 'miny' and 'maxy' EPSG is lat,long (or 'EPSG:4326') I expect the output grid to be in 'degrees' unit. Using an EPSG other than 'EPSG:4326' might
return a different output unit (such as meters). See also the following 'Stackoverflow' thread for more information, https://stackoverflow.com/a/64903836/8302386
</p>
<p>Based on 'Approximate Metric Equivalents' 1 degree is approximately 111 km  (or 60 nautical miles), Reference: https://www.usna.edu/Users/oceano/pguth/md_help/html/approx_equivalents.htm
</p>


<h3>Value</h3>

<p>a simple features (sf) object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)

#...........................................
# 'OpenAltimetry' allows 1x1 degree bounding
# box selection for the 'atl03' Product
#...........................................

gl_grid_1_d = degrees_to_global_grid(degrees = 1.0, verbose = TRUE)
gl_grid_1_d
# summary(gl_grid_1_d$area)

#...........................................................................
# 'OpenAltimetry' allows 5x5 degree bounding box selection for the following
# Products: 'atl06', 'atl07', 'atl08', 'atl10', 'atl12', 'atl13', 'level3a'
#...........................................................................

gl_grid_5_d = degrees_to_global_grid(degrees = 5.0, verbose = TRUE)
gl_grid_5_d


## End(Not run)
</code></pre>

<hr>
<h2 id='get_atlas_data'>Get ICESat-2 ATLAS data for a specific Date</h2><span id='topic+get_atlas_data'></span>

<h3>Description</h3>

<p>This function allows the user to download ICESat-2 ATLAS Product data for a specific date, bounding box, track and beam.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_atlas_data(
  minx,
  miny,
  maxx,
  maxy,
  date,
  trackId,
  beamName = NULL,
  product = "atl03",
  client = "portal",
  photonConfidence = NULL,
  sampling = FALSE,
  outputFormat = "csv",
  file_path_zip = NULL,
  download_method = "curl",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_atlas_data_+3A_minx">minx</code></td>
<td>
<p>the 'minx' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_miny">miny</code></td>
<td>
<p>the 'miny' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_maxx">maxx</code></td>
<td>
<p>the 'maxx' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_maxy">maxy</code></td>
<td>
<p>the 'maxy' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_date">date</code></td>
<td>
<p>a character string specifying the Data collection date in the format 'yyyy-MM-dd' (such as '2020-01-01')</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_trackid">trackId</code></td>
<td>
<p>an integer specifying the 'Reference ground track ID' (see the examples section on how to come to the 'trackId' and to a bounding box of 1 or 5 degrees globally)</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_beamname">beamName</code></td>
<td>
<p>either NULL (if the 'product' parameter is not equal to 'atl03' which means data for all 6 beams will be returned) or a character string specifying the Beam Name, which can be one of the 'gt1l', 'gt1r', 'gt2l', 'gt2r', 'gt3l' or 'gt3r'</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_product">product</code></td>
<td>
<p>a character string specifying the input data product (default value is 'atl03'). It can be one of 'atl03', 'atl06', 'atl07', 'atl08', 'atl10', 'atl12' or 'atl13'</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_client">client</code></td>
<td>
<p>a character string specifying the 'Referring client'. Can be one of 'portal' or 'jupyter' (default is 'portal')</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_photonconfidence">photonConfidence</code></td>
<td>
<p>either NULL or a character string specifying the 'Confidence level of the photons'. If NULL (default) all photon data will be returned</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_sampling">sampling</code></td>
<td>
<p>a boolean. If TRUE a sampling rate of 1/1000 will be used, otherwise all data will be returned (default is FALSE)</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_outputformat">outputFormat</code></td>
<td>
<p>a character string specifying the output format of the downloaded data. One of 'csv', 'json' or 'zip'</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_file_path_zip">file_path_zip</code></td>
<td>
<p>either NULL or a character string specifying a valid path to the output .zip file. This parameter will normally be a valid path if the 'outputFormat' parameter is set to 'zip'. If it's NULL and the 'outputFormat' parameter is 'zip' then the downloaded '.zip' file will be converted and returned as a data.table object</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_download_method">download_method</code></td>
<td>
<p>a character string specifying the download method to use. Can be one of 'internal', 'wininet' (Windows only), 'libcurl', 'wget', 'curl' or 'auto'. For more information see the documentation of the 'utils::download.file()' function</p>
</td></tr>
<tr><td><code id="get_atlas_data_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>'atl03', <em>Global Geolocated Photon Data</em> (Version 4, Requests are limited to 1x1 degree spatial bounding box selection <em>unless &quot;sampling&quot; is set to true</em>)</dt><dd><p>This data set <em>(ATL03)</em> contains height above the WGS 84 ellipsoid (ITRF2014 reference frame), latitude, longitude, and time for all photons downlinked by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory. The ATL03 product was designed to be a single source for all photon data and ancillary information needed by higher-level ATLAS/ICESat-2 products. As such, it also includes spacecraft and instrument parameters and ancillary data not explicitly required for ATL03</p>
</dd>
<dt>'atl06', <em>Land Ice Height</em> (Version 4, Requests are limited to 5x5 degree spatial bounding box selection)</dt><dd><p>This data set <em>(ATL06)</em> provides geolocated, land-ice surface heights (above the WGS 84 ellipsoid, ITRF2014 reference frame), plus ancillary parameters that can be used to interpret and assess the quality of the height estimates. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl07', <em>Sea Ice Height</em> (Version 4, Requests are limited to 5x5 degree spatial bounding box selection)</dt><dd><p>The data set <em>(ATL07)</em> contains along-track heights for sea ice and open water leads (at varying length scales) relative to the WGS84 ellipsoid (ITRF2014 reference frame) after adjustment for geoidal and tidal variations, and inverted barometer effects. Height statistics and apparent reflectance are also provided. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl08', <em>Land and Vegetation Height</em> (Version 4, Requests are limited to 5x5 degree spatial bounding box selection)</dt><dd><p>This data set <em>(ATL08)</em> contains along-track heights above the WGS84 ellipsoid (ITRF2014 reference frame) for the ground and canopy surfaces. The canopy and ground surfaces are processed in fixed 100 m data segments, which typically contain more than 100 signal photons. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl10', <em>Sea Ice Freeboard</em> (Version 4, Requests are limited to 5x5 degree spatial bounding box selection)</dt><dd><p>This data set <em>(ATL10)</em> contains estimates of sea ice freeboard, calculated using three different approaches. Sea ice leads used to establish the reference sea surface and descriptive statistics used in the height estimates are also provided. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl12', <em>Ocean Surface Height</em> (Version 4, Requests are limited to 5x5 degree spatial bounding box selection)</dt><dd><p>This data set <em>(ATL12)</em> contains along-track sea surface heights at variable length scales over cloud-free regions. Estimates of height distributions, surface roughness, surface slope, and apparent reflectance are also provided. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl13', <em>Inland Water Surface Height</em> (Version 4, Requests are limited to 5x5 degree spatial bounding box selection)</dt><dd><p>This data set <em>(ATL13)</em> contains along-track water surface heights and descriptive statistics for inland water bodies. Water bodies include lakes, reservoirs, bays, and estuaries. Descriptive statistics include along-track surface slope (where data permit), mean and standard deviation, subsurface signal (532 nm) attenuation, wave height, and coarse depth to bottom topography</p>
</dd>
</dl>



<h3>Value</h3>

<p>if the 'file_path_zip' parameter is NULL it returns either a data.table (if outputFormat is 'csv') or a nested list (if outputFormat is 'json') else the file path where the .zip file is saved. In case that the 'outputFormat' is set to 'zip' and the 'file_path_zip' parameter to NULL then a data.table will be returned.
</p>


<h3>References</h3>

<p>https://openaltimetry.org/datainfo.html
</p>
<p>https://openaltimetry.org/data/swagger-ui/
</p>
<p>https://nsidc.org/data/icesat-2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)

#............................................................
# observe the available countries and continents using the
# 'rnaturalearth' R package to perform a query using map-edit
#............................................................

cntr_cnt = rnaturalearth::ne_countries(scale = 110,
                                       type = 'countries',
                                       returnclass = 'sf')

cntr_cnt = cntr_cnt[, c('sovereignt', 'continent')]

# sort(cntr_cnt$sovereignt)
# sort(unique(cntr_cnt$continent))


#............................
# Select a 'continent' as AOI   (5-degree query)
#............................

init = select_aoi_global_grid$new(area_of_interest = 'Oceania',
                                  verbose = TRUE)

init$draw_edit_aoi(degrees = 5.0, square_geoms = TRUE)
sf_obj = init$selected_areas_global_grid(plot_data = FALSE)
sf_obj

#.....................................................
# I drew a bounding box close to 'Mount Hagen Papua'
# inside one of the 5-degreee cells (after zooming-in)
#.....................................................

# mapview::mapview(sf_obj, legend = F)
# sf::st_as_text(sf::st_geometry(sf_obj))

#................................................
# to reproduce the results without selecting
# an area based on the 'draw_edit_aoi()' function
#................................................

# plg = "POLYGON ((140 -6.641235, 145 -6.641235, 145 -1.641235, 140 -1.641235, 140 -6.641235))"
# sf_obj = sf::st_as_sfc(plg, crs = 4326)


#....................................................
# first we find available ICESat-2 track-ID's
# and Dates (time interval) from a specific RGT cycle
#....................................................

approx_date_start = "2021-02-01"
approx_date_end = "2021-02-15"
# 'RGT_cycle_10'

res_rgt_many = time_specific_orbits(date_from = approx_date_start,
                                    date_to = approx_date_end,
                                    RGT_cycle = NULL,
                                    download_method = 'curl',
                                    threads = parallel::detectCores(),
                                    verbose = TRUE)
res_rgt_many

#.........................................................
# then we create the bounding box of the selected area
# and proceed to the intersection with the computed RGT's
# ( include the bounding box for reproducibility )
#.........................................................

bbx_aoi = sf::st_bbox(obj = sf_obj)
# c(xmin = 140, ymin = -6.641235, xmax = 145, ymax = -1.641235)

sf_obj_bbx = sf::st_as_sfc(bbx_aoi)

res_inters = sf::st_intersects(x = sf_obj_bbx,
                               y = sf::st_geometry(res_rgt_many),
                               sparse = TRUE)
#.....................
# matched (RGT) tracks
#.....................

df_inters = data.frame(res_inters)

if (nrow(df_inters) == 0) {
  stop("There is no intersection between the specified AOI and the RGTs!")
}


rgt_subs = res_rgt_many[df_inters$col.id, , drop = FALSE]
rgt_subs


#..........................................
# find out which of the time specific RGT's
# match the OpenAltimetry Track-ID's
#..........................................

dtbl_rgts = verify_RGTs(nsidc_rgts = rgt_subs,
                        bbx_aoi = bbx_aoi,
                        verbose = TRUE)

#...................................
# we will iterate over the available:
#    - Dates
#    - trackId's
#    - product's
# to gather the up to 5-degree data
#..................................

dates_iters = unique(dtbl_rgts$Date_time)
RGTs_iters = unique(dtbl_rgts$RGT_NSIDC)
prods_5_degrs = c('atl06', 'atl07', 'atl08', 'atl10', 'atl12', 'atl13')

dat_out = logs_out = list()

for (idx in seq_along(dates_iters)) {

  date_i = dates_iters[idx]
  rgt_i = RGTs_iters[idx]

  for (prod_i in prods_5_degrs) {

    name_iter = glue::glue("{date_i}_{rgt_i}_{prod_i}")
    cat(glue::glue("Date: '{date_i}'  RGT: '{rgt_i}'  Product: '{prod_i}'"), '\n')

    iter_dat = get_atlas_data(minx = as.numeric(bbx_aoi['xmin']),
                              miny = as.numeric(bbx_aoi['ymin']),
                              maxx = as.numeric(bbx_aoi['xmax']),
                              maxy = as.numeric(bbx_aoi['ymax']),
                              date = date_i,
                              trackId = rgt_i,
                              product = prod_i,
                              client = 'portal',
                              outputFormat = 'csv',
                              verbose = FALSE)

    iter_logs = list(Date = date_i,
                     RGT = rgt_i,
                     Product = prod_i,
                     N_rows = nrow(iter_dat))

    logs_out[[name_iter]] = data.table::setDT(iter_logs)
    dat_out[[name_iter]] = iter_dat
  }
}

#.........................................
# each sublist corresponds to a different
# parameter setting (Date, Track, Product)
#.........................................

dat_out

#.....
# Logs  (including the number of rows for each parameter setting)
#.....

dtbl_logs = data.table::rbindlist(logs_out)
dtbl_logs = subset(dtbl_logs, N_rows &gt; 0)
dtbl_logs = dtbl_logs[order(dtbl_logs$N_rows, decreasing = T), ]
dtbl_logs

#.............................................
# The Products 'atl08' and 'atl13' have data
# for the Dates and RGT's of the selected area
#.............................................

unique(dtbl_logs$Product)
# c('atl08', 'atl13')

#................
# RGT's with data
#................

unique(dtbl_logs$RGT)
# c(627, 756, 688, 619, 817)

#................
# Dates with Data
#................

unique(dtbl_logs$Date)
# c("2021-02-03", "2021-02-11", "2021-02-07", "2021-02-02", "2021-02-15")


## End(Not run)
</code></pre>

<hr>
<h2 id='get_level3a_data'>Get IceSat-2 ATLAS 'Level-3A' data for a time interval (up to 1 year)</h2><span id='topic+get_level3a_data'></span>

<h3>Description</h3>

<p>This function allows the user to download IceSat-2 ATLAS 'Level-3A' data for a specific time interval, bounding box, track and beam.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_level3a_data(
  minx,
  miny,
  maxx,
  maxy,
  startDate,
  endDate,
  trackId,
  beamName = NULL,
  product = "atl08",
  client = "portal",
  outputFormat = "csv",
  file_path_zip = NULL,
  download_method = "curl",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_level3a_data_+3A_minx">minx</code></td>
<td>
<p>the 'minx' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_miny">miny</code></td>
<td>
<p>the 'miny' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_maxx">maxx</code></td>
<td>
<p>the 'maxx' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_maxy">maxy</code></td>
<td>
<p>the 'maxy' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_startdate">startDate</code></td>
<td>
<p>a character string specifying the Data collection of the <em>start</em> Date in the format 'yyyy-MM-dd' (such as '2020-01-01')</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_enddate">endDate</code></td>
<td>
<p>a character string specifying the Data collection of the <em>end</em> Date in the format 'yyyy-MM-dd' (such as '2020-01-01')</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_trackid">trackId</code></td>
<td>
<p>an integer specifying the 'Reference ground track ID' (see the examples section on how to come to the 'trackId' and to a bounding box of 1 or 5 degrees globally)</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_beamname">beamName</code></td>
<td>
<p>either NULL (data for all 6 beams will be returned) or a character string specifying the Beam Name, It can be one of the 'gt1l', 'gt1r', 'gt2l', 'gt2r', 'gt3l' or 'gt3r'</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_product">product</code></td>
<td>
<p>a character string specifying the input data product (default value is 'atl08'). It can be one of 'atl06', 'atl07', 'atl08', 'atl10', 'atl12' or 'atl13'</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_client">client</code></td>
<td>
<p>a character string specifying the 'Referring client'. Can be one of 'portal' or 'jupyter' (default is 'portal')</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_outputformat">outputFormat</code></td>
<td>
<p>a character string specifying the output format of the downloaded data. One of 'csv', 'json' or 'zip'</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_file_path_zip">file_path_zip</code></td>
<td>
<p>either NULL or a character string specifying a valid path to the output .zip file. This parameter will normally be a valid path if the 'outputFormat' parameter is set to 'zip'. If it's NULL and the 'outputFormat' parameter is 'zip' then the downloaded '.zip' file will be converted and returned as a data.table object</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_download_method">download_method</code></td>
<td>
<p>a character string specifying the download method to use. Can be one of 'internal', 'wininet' (Windows only), 'libcurl', 'wget', 'curl' or 'auto'. For more information see the documentation of the 'utils::download.file()' function</p>
</td></tr>
<tr><td><code id="get_level3a_data_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Up to 1 year worth of ICESat-2 <em>Level-3A</em> product data can be downloaded. <em>Note:</em> requests are limited to 5x5 degree spatial bounding box selection
</p>

<dl>
<dt>'atl06', <em>Land Ice Height</em> (Version 4)</dt><dd><p>This data set <em>(ATL06)</em> provides geolocated, land-ice surface heights (above the WGS 84 ellipsoid, ITRF2014 reference frame), plus ancillary parameters that can be used to interpret and assess the quality of the height estimates. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl07', <em>Sea Ice Height</em> (Version 4)</dt><dd><p>The data set <em>(ATL07)</em> contains along-track heights for sea ice and open water leads (at varying length scales) relative to the WGS84 ellipsoid (ITRF2014 reference frame) after adjustment for geoidal and tidal variations, and inverted barometer effects. Height statistics and apparent reflectance are also provided. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl08', <em>Land and Vegetation Height</em> (Version 4)</dt><dd><p>This data set <em>(ATL08)</em> contains along-track heights above the WGS84 ellipsoid (ITRF2014 reference frame) for the ground and canopy surfaces. The canopy and ground surfaces are processed in fixed 100 m data segments, which typically contain more than 100 signal photons. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl10', <em>Sea Ice Freeboard</em> (Version 4)</dt><dd><p>This data set <em>(ATL10)</em> contains estimates of sea ice freeboard, calculated using three different approaches. Sea ice leads used to establish the reference sea surface and descriptive statistics used in the height estimates are also provided. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl12', <em>Ocean Surface Height</em> (Version 4)</dt><dd><p>This data set <em>(ATL12)</em> contains along-track sea surface heights at variable length scales over cloud-free regions. Estimates of height distributions, surface roughness, surface slope, and apparent reflectance are also provided. The data were acquired by the Advanced Topographic Laser Altimeter System (ATLAS) instrument on board the Ice, Cloud and land Elevation Satellite-2 (ICESat-2) observatory</p>
</dd>
<dt>'atl13', <em>Inland Water Surface Height</em> (Version 4)</dt><dd><p>This data set <em>(ATL13)</em> contains along-track water surface heights and descriptive statistics for inland water bodies. Water bodies include lakes, reservoirs, bays, and estuaries. Descriptive statistics include along-track surface slope (where data permit), mean and standard deviation, subsurface signal (532 nm) attenuation, wave height, and coarse depth to bottom topography</p>
</dd>
</dl>



<h3>Value</h3>

<p>if the 'file_path_zip' parameter is NULL it returns either a data.table (if outputFormat is 'csv') or a nested list (if outputFormat is 'json') else the file path where the .zip file is saved. In case that the 'outputFormat' is set to 'zip' and the 'file_path_zip' parameter to NULL then a data.table will be returned.
</p>


<h3>References</h3>

<p>https://openaltimetry.org/datainfo.html
</p>
<p>https://openaltimetry.org/data/swagger-ui/
</p>
<p>https://nsidc.org/data/icesat-2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)

#.......................................................
# parameter setting based on the output results from the
# 'examples' section of the 'get_atlas_data()' function
# so that we can iterate over the RGT's and Products for
# the specified time interval
#.......................................................

bbx = c(xmin = 140, ymin = -6.641235, xmax = 145, ymax = -1.641235)
start_date = "2021-02-03"
end_date = "2021-02-15"
RGTs = c(627, 756, 688, 619, 817)
Products = c('atl08', 'atl13')

#........................................................
# loop over the specified parameters and save the results
#........................................................

dat_out = logs_out = list()

for (prod_i in Products) {
  for (track_i in RGTs) {

    name_iter = glue::glue("{track_i}_{prod_i}")
    cat(glue::glue("RGT: '{track_i}'  Product: '{prod_i}'"), '\n')

    iter_dat = get_level3a_data(minx = as.numeric(bbx['xmin']),
                                miny = as.numeric(bbx['ymin']),
                                maxx = as.numeric(bbx['xmax']),
                                maxy = as.numeric(bbx['ymax']),
                                startDate = start_date,
                                endDate = end_date,
                                trackId = track_i,
                                beamName = NULL,        # return data of all 6 beams
                                product = prod_i,
                                client = 'portal',
                                outputFormat = 'csv',
                                verbose = FALSE)

    iter_logs = list(RGT = track_i,
                     Product = prod_i,
                     N_rows = nrow(iter_dat))

    logs_out[[name_iter]] = data.table::setDT(iter_logs)
    dat_out[[name_iter]] = iter_dat
  }
}


#.........................................
# each sublist corresponds to a different
# parameter setting (Track, Product)
#.........................................

dat_out

#.....
# Logs  (including the number of rows for each parameter setting)
#.....

dtbl_logs = data.table::rbindlist(logs_out)
dtbl_logs = subset(dtbl_logs, N_rows &gt; 0)
dtbl_logs = dtbl_logs[order(dtbl_logs$N_rows, decreasing = T), ]
dtbl_logs


## End(Not run)
</code></pre>

<hr>
<h2 id='get_URL_data'>Get the data based on the API URL</h2><span id='topic+get_URL_data'></span>

<h3>Description</h3>

<p>Get the data based on the API URL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_URL_data(
  URL,
  outputFormat = "csv",
  download_method = "curl",
  file_path_zip = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_URL_data_+3A_url">URL</code></td>
<td>
<p>a character string specifying the API command</p>
</td></tr>
<tr><td><code id="get_URL_data_+3A_outputformat">outputFormat</code></td>
<td>
<p>a character string specifying the output format of the downloaded data. One of 'csv', 'json' or 'zip'</p>
</td></tr>
<tr><td><code id="get_URL_data_+3A_download_method">download_method</code></td>
<td>
<p>a character string specifying the download method to use. Can be one of 'internal', 'wininet' (Windows only), 'libcurl', 'wget', 'curl' or 'auto'. For more information see the documentation of the 'utils::download.file()' function</p>
</td></tr>
<tr><td><code id="get_URL_data_+3A_file_path_zip">file_path_zip</code></td>
<td>
<p>either NULL or a character string specifying a valid path to the output .zip file. This parameter will normally be a valid path if the 'outputFormat' parameter is set to 'zip'. If it's NULL and the 'outputFormat' parameter is 'zip' then the downloaded '.zip' file will be converted and returned as a data.table object</p>
</td></tr>
<tr><td><code id="get_URL_data_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if the 'file_path_zip' parameter is NULL it returns either a data.table (if outputFormat is 'csv') or a nested list (if outputFormat is 'json') else the file path where the .zip file is saved. In case that the 'outputFormat' is set to 'zip' and the 'file_path_zip' parameter to NULL then a data.table will be returned.
</p>

<hr>
<h2 id='getTracks'>Get the ICESAT-2 Tracks</h2><span id='topic+getTracks'></span>

<h3>Description</h3>

<p>Get a list of ICESat-2 tracks using a bounding box as input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTracks(
  minx,
  miny,
  maxx,
  maxy,
  date,
  outputFormat = "csv",
  download_method = "curl",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTracks_+3A_minx">minx</code></td>
<td>
<p>the 'minx' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="getTracks_+3A_miny">miny</code></td>
<td>
<p>the 'miny' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="getTracks_+3A_maxx">maxx</code></td>
<td>
<p>the 'maxx' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="getTracks_+3A_maxy">maxy</code></td>
<td>
<p>the 'maxy' parameter of the bounding box</p>
</td></tr>
<tr><td><code id="getTracks_+3A_date">date</code></td>
<td>
<p>a character string specifying the Data collection date in the format 'yyyy-MM-dd' (such as '2020-01-01')</p>
</td></tr>
<tr><td><code id="getTracks_+3A_outputformat">outputFormat</code></td>
<td>
<p>a character string specifying the output format of the downloaded data. One of 'csv' or 'json'</p>
</td></tr>
<tr><td><code id="getTracks_+3A_download_method">download_method</code></td>
<td>
<p>a character string specifying the download method to use. Can be one of 'internal', 'wininet' (Windows only), 'libcurl', 'wget', 'curl' or 'auto'. For more information see the documentation of the 'utils::download.file()' function</p>
</td></tr>
<tr><td><code id="getTracks_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a data.table (if outputFormat is 'csv') or a nested list (if outputFormat is 'json')
</p>


<h3>References</h3>

<p>https://openaltimetry.org/data/swagger-ui/
</p>
<p>https://nsidc.org/data/icesat-2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)
require(magrittr)
require(sf)

sf::sf_use_s2(use_s2 = FALSE)

#..........................................................
# In case we are interested to find the ICESat-2 tracks for
#     - a specific area (or bounding box)
#     - a specific time interval (close to September 2021)
#..........................................................

#...............
# Ice sheet area
#...............

data(ne_10m_glaciated_areas)

ice_sheet = 'Kluane Ice Cap'

ice_sheet_geom = ne_10m_glaciated_areas %&gt;%
  subset(!is.na(name)) %&gt;%
  subset(name == ice_sheet)

ice_sheet_geom

#..............
# time interval
#..............

approx_date_start = "2021-09-05"
approx_date_end = "2021-09-20"

res_rgt_many = time_specific_orbits(date_from = approx_date_start,
                                    date_to = approx_date_end,
                                    RGT_cycle = NULL,
                                    download_method = 'curl',
                                    threads = parallel::detectCores(),
                                    verbose = TRUE)

res_rgt_many

# table(as.Date(res_rgt_many$Date_time))

#..............................................
# create the bounding box of the ice
# sheet so that I use the same area in the
# 'st_intersects()' and 'getTracks()' functions
# ('getTracks()' takes a bounding box as input)
#..............................................

bbx_ice_sheet = sf::st_bbox(obj = ice_sheet_geom)
sf_obj_ice_sheet = sf::st_as_sfc(bbx_ice_sheet)

#.........................................
# intersection of the Ice Sheet with
# the tracks for the specified time period
#.........................................

res_inters = sf::st_intersects(x = sf::st_geometry(sf_obj_ice_sheet),
                               y = sf::st_geometry(res_rgt_many),
                               sparse = TRUE)

#...........................................
# one or more intersected RGT's for the area
#...........................................

df_inters = data.frame(res_inters)
rgt_subs = res_rgt_many[df_inters$col.id, , drop = FALSE]


#.......................................................
# Keep the Date and the bounding box to
# verify with the 'getTracks()' function
# an alternative is to use the "verify_RGTs()" function
#.......................................................

for (item in 1:nrow(rgt_subs)) {

  dat_item = rgt_subs[item, , drop = F]
  Date = as.Date(dat_item$Date_time)

  op_tra = getTracks(minx = as.numeric(bbx_ice_sheet['xmin']),
                               miny = as.numeric(bbx_ice_sheet['ymin']),
                               maxx = as.numeric(bbx_ice_sheet['xmax']),
                               maxy = as.numeric(bbx_ice_sheet['ymax']),
                               date = as.character(Date),
                               outputFormat = 'csv',
                               download_method = 'curl',
                               verbose = FALSE)

  date_obj = dat_item$Date_time
  tim_rgt = glue::glue("Date: {date_obj} Time specific RGT: '{dat_item$RGT}'")

  if (nrow(op_tra) &gt; 0) {
    iter_op_trac = paste(op_tra$track, collapse = ', ')
    cat(glue::glue("{tim_rgt}  OpenAltimetry: '{iter_op_trac}'"), '\n')
  }
  else {
    cat(glue::glue("{tim_rgt} without an OpenAltimetry match!"), '\n')
  }
}


## End(Not run)
</code></pre>

<hr>
<h2 id='IceSat2R'>The &quot;IceSat2R&quot; package</h2><span id='topic+IceSat2R'></span>

<h3>Description</h3>

<p>An important aspect of the &quot;IceSat2R&quot; (https://cran.r-project.org/web/packages/IceSat2R/index.html) package is that it includes the code, documentation, and
examples so that users can retrieve, process, and analyze data based on specific workflows.
</p>


<h3>Details</h3>

<p>For instance,
</p>

<ul>
<li><p> A user can select an &quot;area of interest&quot; (AOI) either programmatically or interactively
</p>
</li>
<li><p> If the &quot;Reference Ground Track&quot; (RGT) is not known, the user has the option to utilize either
</p>

<ol>
<li><p> one of the &quot;overall_mission_orbits()&quot; or &quot;time_specific_orbits()&quot; to compute the RGT(s) for a pre-specified global area or for a time period, or
</p>
</li>
<li><p> one of the &quot;vsi_nominal_orbits_wkt()&quot; or &quot;vsi_time_specific_orbits_wkt()&quot; to compute the RGT(s) for a specific AOI
</p>
</li></ol>

</li>
<li><p> Once the RGT is computed it can be verified with the &quot;getTracks()&quot; function of the &quot;OpenAltimetry Web API&quot; (https://openaltimetry.org/data/swagger-ui/)
</p>
</li>
<li><p> Finally the user can utilize one of the &quot;get_atlas_data()&quot; or &quot;get_level3a_data()&quot; functions to retrieve the data for specific product(s), Date(s) and Beam(s)
</p>
</li></ul>

<p>This work-flow is illustrated also in a <a href="https://raw.githubusercontent.com/mlampros/IceSat2R/master/inst/joss_paper/figures/icesat_2_diagram.png">diagram</a>
</p>

<hr>
<h2 id='inner_elapsed_time'>inner function of 'compute_elapsed_time'</h2><span id='topic+inner_elapsed_time'></span>

<h3>Description</h3>

<p>inner function of 'compute_elapsed_time'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_elapsed_time(secs, estimated = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner_elapsed_time_+3A_secs">secs</code></td>
<td>
<p>a numeric value specifying the seconds</p>
</td></tr>
<tr><td><code id="inner_elapsed_time_+3A_estimated">estimated</code></td>
<td>
<p>a boolean. If TRUE then the output label becomes the 'Estimated time'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string showing the estimated or elapsed time
</p>

<hr>
<h2 id='latest_orbits'>Extraction of the url from the Technical Specification Website</h2><span id='topic+latest_orbits'></span>

<h3>Description</h3>

<p>This function allows the user to view the latest 'Nominal' and 'Time Specfic' orbit metadata (Url, Reference Ground Track Names, Dates and Types)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latest_orbits(
  technical_specs_url = "https://icesat-2.gsfc.nasa.gov/science/specs",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latest_orbits_+3A_technical_specs_url">technical_specs_url</code></td>
<td>
<p>a character string specifying the technical specs website</p>
</td></tr>
<tr><td><code id="latest_orbits_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'data.table' object
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)

orbs = latest_orbits(verbose = TRUE)
orbs


## End(Not run)
</code></pre>

<hr>
<h2 id='leaflet_base_map'>a leaflet base map</h2><span id='topic+leaflet_base_map'></span>

<h3>Description</h3>

<p>a leaflet base map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaflet_base_map(
  sf_obj = NULL,
  leaflet_provider_base,
  leaflet_provider_secondary,
  overlay_group = "IceSat2 1-degree",
  overlay_polylines = "Polylines",
  width = NULL,
  height = NULL,
  popup = NULL,
  collapse_layer_control = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaflet_base_map_+3A_sf_obj">sf_obj</code></td>
<td>
<p>a simple features object which must include the columns 'date' and 'size_MB' if the popup parameter is set to TRUE</p>
</td></tr>
<tr><td><code id="leaflet_base_map_+3A_leaflet_provider_base">leaflet_provider_base</code></td>
<td>
<p>a leaflet provider object</p>
</td></tr>
<tr><td><code id="leaflet_base_map_+3A_leaflet_provider_secondary">leaflet_provider_secondary</code></td>
<td>
<p>a leaflet provider object</p>
</td></tr>
<tr><td><code id="leaflet_base_map_+3A_overlay_group">overlay_group</code></td>
<td>
<p>a character string specifying the overlay group</p>
</td></tr>
<tr><td><code id="leaflet_base_map_+3A_overlay_polylines">overlay_polylines</code></td>
<td>
<p>a character string specifying the Polylines group</p>
</td></tr>
<tr><td><code id="leaflet_base_map_+3A_width">width</code></td>
<td>
<p>a numeric value specifying the width of the leaflet map</p>
</td></tr>
<tr><td><code id="leaflet_base_map_+3A_height">height</code></td>
<td>
<p>a numeric value specifying the height of the leaflet map</p>
</td></tr>
<tr><td><code id="leaflet_base_map_+3A_popup">popup</code></td>
<td>
<p>a boolean specifying if the popup should be shown or not</p>
</td></tr>
<tr><td><code id="leaflet_base_map_+3A_collapse_layer_control">collapse_layer_control</code></td>
<td>
<p>a boolean specifying if the layer-control should be collapsed or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a leaflet object (map)
</p>

<hr>
<h2 id='ne_10m_glaciated_areas'>Natural Earth 10m Glaciated Areas (1:10 million scale)</h2><span id='topic+ne_10m_glaciated_areas'></span>

<h3>Description</h3>

<p>Polygons derived from DCW (Digital Chart of the World), except for Antarctica derived from MOA. Includes name attributes for major polar glaciers.
Filtering has aggregated some minor glaciers and eliminated others from the original DCW data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ne_10m_glaciated_areas)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 68 rows and 6 columns.
</p>


<h3>Details</h3>

<p>Issues: Needs scale rank attributes
</p>
<p>Note: The original DCW data was collected decades ago. Since then many mountain glaciers have either disappeared or
diminished in size. This data theme is deliberately called &quot;glaciated areas&quot; instead of &quot;glaciers&quot; to reflect the
changeable character of glacier extents.
</p>


<h3>References</h3>

<p>https://www.naturalearthdata.com/downloads/10m-physical-vectors/10m-glaciated-areas/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(IceSat2R)
require(sf)

data(ne_10m_glaciated_areas)
</code></pre>

<hr>
<h2 id='overall_mission_orbits'>Overall Mission Orbits</h2><span id='topic+overall_mission_orbits'></span>

<h3>Description</h3>

<p>This function allows the user to view information of the nominal mission orbits and beam locations: &quot;The processed files have 7 tracks per
orbit: one for each of the six beams of ICESat-2, and the seventh for the Reference Ground Track (RGT). The RGT is an imaginary line
through the six-beam pattern that is handy for getting a sense of where the orbits fall on Earth, and which the mission uses to point the
observatory. However, the six tracks for the six beams are our best estimate of where the beams will actually fall on Earth's surface.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall_mission_orbits(
  orbit_area,
  download_method = "curl",
  threads = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overall_mission_orbits_+3A_orbit_area">orbit_area</code></td>
<td>
<p>a character string specifying the nominal mission orbits and beam locations. It can be one of 'antarctic', 'arctic', 'western_hemisphere' or 'eastern_hemisphere'</p>
</td></tr>
<tr><td><code id="overall_mission_orbits_+3A_download_method">download_method</code></td>
<td>
<p>a character string specifying the download method. Corresponds to the 'method' parameter of the 'utils::download.file()' function. Can be one of 'internal', 'wininet' (Windows only), 'libcurl', 'wget', 'curl' or 'auto'</p>
</td></tr>
<tr><td><code id="overall_mission_orbits_+3A_threads">threads</code></td>
<td>
<p>an integer that specifies the number of threads to use in parallel when processing the data</p>
</td></tr>
<tr><td><code id="overall_mission_orbits_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'sf' object of multiple tracks (see the 'LAYER' column of the output object)
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)

res_orb  = overall_mission_orbits(orbit_area = 'antarctic',
                                  download_method = 'curl',
                                  threads = 1,
                                  verbose = TRUE)
str(res_orb)

## End(Not run)
</code></pre>

<hr>
<h2 id='revisit_time_RGTs'>Revisit Time Reference Ground Tracks and Dates</h2><span id='topic+revisit_time_RGTs'></span>

<h3>Description</h3>

<p>This function shows the information of the 'available_RGTs' function and additionally it returns the .zip (kmz files) of all laser
tracks over each 91-day repeat period (revisit time). Note that the locations and times are estimates, but should be correct to
within a few minutes in time and better than 100m in the predicted locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revisit_time_RGTs(RGT_cycle = NULL, complete_date_sequence = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revisit_time_RGTs_+3A_rgt_cycle">RGT_cycle</code></td>
<td>
<p>either NULL or a character string specifying a single RGT (Reference Ground Track) as determined by the output of the 'available_RGTs(only_cycle_names = TRUE)' function. If NULL then all available Data will be returned.</p>
</td></tr>
<tr><td><code id="revisit_time_RGTs_+3A_complete_date_sequence">complete_date_sequence</code></td>
<td>
<p>a boolean. If TRUE a complete sequence of Dates will be returned, otherwise only the 'minimum' and 'maximum' Dates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ICESat-2 was in safe-hold from June 26 through July 9, 2019. ATLAS was off during this time, so data was not collected or pointed to the reference ground track.
</p>


<h3>Value</h3>

<p>a list object with the available orbit files, dates and date sequence lengths
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(IceSat2R)

#.......................................................
# receive all orbit files, dates and length of sequences
#.......................................................

rev_all = revisit_time_RGTs(RGT_cycle = NULL, complete_date_sequence = TRUE)
rev_all

#...................................................
# observe and choose one of the available RGT-cycles
#...................................................

avail_cycles = available_RGTs(only_cycle_names = TRUE,
                              verbose = TRUE)
avail_cycles

#.....................................
# receive results for a specific cycle
#.....................................

rev_cycle = revisit_time_RGTs(RGT_cycle = 'RGT_cycle_1', complete_date_sequence = FALSE)
rev_cycle
</code></pre>

<hr>
<h2 id='RGT_cycle_14'>Reference Ground Tracks (RGTs) for IceSat-2 Cycle 14</h2><span id='topic+RGT_cycle_14'></span>

<h3>Description</h3>

<p>The data includes the following columns: &quot;longitude&quot;, &quot;latitude&quot;, &quot;day_of_year&quot;, &quot;Date&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot; and &quot;RGT&quot;. The &quot;RGT&quot; column consists of
1387 Reference Ground Tracks (RGTs) for the IceSat-2 Cycle 14 (from 'December 22, 2021' to 'March 23, 2022')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RGT_cycle_14)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 131765 rows and 8 columns.
</p>


<h3>Details</h3>

<p>The following code snippet shows how to come to the &quot;RGT_cycle_14&quot; data. The same can be done with any of the available RGT Cycles. For the following code
I utilized 8 threads to speed up the pre-processing of the downloaded .kml files (the code takes approximately 15 minutes on my Linux Personal Computer),
</p>
<p><code>require(IceSat2R)</code> <br />
<code>require(magrittr)</code> <br />
<code>require(sf)</code> <br />
</p>
<p><code>avail_cycles = available_RGTs(only_cycle_names = TRUE)</code> <br />
<code>avail_cycles</code> <br />
</p>
<p><code>idx_cycle = 14</code> <br />
</p>
<p><code>choose_cycle = avail_cycles[idx_cycle]</code> <br />
<code>choose_cycle</code> <br />
</p>
<p><code>res_rgt_many = time_specific_orbits(RGT_cycle = choose_cycle, download_method = 'curl', threads = parallel::detectCores(), verbose = TRUE)</code> <br />
</p>
<p><code>RGT_cycle_14 = sf::st_coordinates(res_rgt_many)</code> <br />
<code>colnames(RGT_cycle_14) = c('longitude', 'latitude')</code> <br />
<code>RGT_cycle_14 = data.table::data.table(RGT_cycle_14)</code> <br />
<code>RGT_cycle_14$day_of_year = res_rgt_many$day_of_year</code> <br />
<code>RGT_cycle_14$Date = as.Date(res_rgt_many$Date_time)</code> <br />
<code>RGT_cycle_14$hour = lubridate::hour(res_rgt_many$Date_time)</code> <br />
<code>RGT_cycle_14$minute = lubridate::minute(res_rgt_many$Date_time)</code> <br />
<code>RGT_cycle_14$second = lubridate::second(res_rgt_many$Date_time)</code> <br />
<code>RGT_cycle_14$RGT = res_rgt_many$RGT</code> <br />
<code>RGT_cycle_14</code> <br />
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(IceSat2R)
require(data.table)

data(RGT_cycle_14)
</code></pre>

<hr>
<h2 id='select_aoi_global_grid'>R6 Class to Select an Area of Interest (AOI) from a Global Grid</h2><span id='topic+select_aoi_global_grid'></span>

<h3>Description</h3>

<p>The 'select_aoi_global_grid' class allows the user to select an Area of Interest (AOI) (see the examples section for all available options)
</p>


<h3>Usage</h3>

<pre><code class='language-R'># init &lt;- select_aoi_global_grid$new()
</code></pre>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>area_of_interest</code></dt><dd><p>an R object (character string, vector)</p>
</dd>
<dt><code>leaflet_provider_base</code></dt><dd><p>a leaflet provider object</p>
</dd>
<dt><code>leaflet_provider_secondary</code></dt><dd><p>a leaflet provider object</p>
</dd>
<dt><code>crs_value</code></dt><dd><p>a numeric value</p>
</dd>
<dt><code>use_s2</code></dt><dd><p>a boolean</p>
</dd>
<dt><code>verbose</code></dt><dd><p>a boolean</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-select_aoi_global_grid-new"><code>select_aoi_global_grid$new()</code></a>
</p>
</li>
<li> <p><a href="#method-select_aoi_global_grid-draw_edit_internal"><code>select_aoi_global_grid$draw_edit_internal()</code></a>
</p>
</li>
<li> <p><a href="#method-select_aoi_global_grid-draw_edit_aoi"><code>select_aoi_global_grid$draw_edit_aoi()</code></a>
</p>
</li>
<li> <p><a href="#method-select_aoi_global_grid-selected_areas_global_grid"><code>select_aoi_global_grid$selected_areas_global_grid()</code></a>
</p>
</li>
<li> <p><a href="#method-select_aoi_global_grid-selected_aoi_sf"><code>select_aoi_global_grid$selected_aoi_sf()</code></a>
</p>
</li>
<li> <p><a href="#method-select_aoi_global_grid-clone"><code>select_aoi_global_grid$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-select_aoi_global_grid-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method for the 'select_aoi_global_grid' R6 class
</p>


<h5>Usage</h5>

<div class="r"><pre>select_aoi_global_grid$new(
  area_of_interest = NULL,
  leaflet_provider_base = leaflet::providers$CartoDB.Positron,
  leaflet_provider_secondary = leaflet::providers$Esri.WorldImagery,
  crs_value = 4326,
  use_s2 = FALSE,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>area_of_interest</code></dt><dd><p>either NULL (which allows the user to draw the area of interest on the map) or a character string (i.e. a 'country' or a 'continent') or a named bounding box vector (such as c(xmin = 16.1, xmax = 16.6, ymax = 48.6, ymin = 47.9)). The 'countries' and 'continents' can be extracted from the &quot;rnaturalearth::ne_countries(scale = 110, type = 'countries', returnclass = 'sf')&quot; function and specifically the columns: 'sovereignt' and 'continent'</p>
</dd>
<dt><code>leaflet_provider_base</code></dt><dd><p>a leaflet provider object</p>
</dd>
<dt><code>leaflet_provider_secondary</code></dt><dd><p>a leaflet provider object</p>
</dd>
<dt><code>crs_value</code></dt><dd><p>a value. The coordinate reference system. The default value of the crs is 4326</p>
</dd>
<dt><code>use_s2</code></dt><dd><p>a boolean. If TRUE, use the s2 spherical geometry package for geographical coordinate operations (see the documentation of the 'sf::sf_use_s2()' function for more information)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>a boolean. If TRUE then information will be printed in the console</p>
</dd>
</dl>

</div>


<hr>
<a id="method-select_aoi_global_grid-draw_edit_internal"></a>



<h4>Method <code>draw_edit_internal()</code></h4>

<p>Internal Shiny application to visualize the selected area
</p>


<h5>Usage</h5>

<div class="r"><pre>select_aoi_global_grid$draw_edit_internal(lft_map)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lft_map</code></dt><dd><p>a leaflet map</p>
</dd>
</dl>

</div>


<hr>
<a id="method-select_aoi_global_grid-draw_edit_aoi"></a>



<h4>Method <code>draw_edit_aoi()</code></h4>

<p>Allows to view the Global Grid on the map including a popup that shows the Area of each grid rectangle (or hexagon). The user can then select an Area of Interest (AOI)
</p>


<h5>Usage</h5>

<div class="r"><pre>select_aoi_global_grid$draw_edit_aoi(degrees = 1, square_geoms = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>degrees</code></dt><dd><p>a numeric value. This can be either 1.0 or 5.0 to allow queries to the 'OpenAltimetry' API</p>
</dd>
<dt><code>square_geoms</code></dt><dd><p>a boolean. If FALSE then a hexagonal grid will be created</p>
</dd>
</dl>

</div>


<hr>
<a id="method-select_aoi_global_grid-selected_areas_global_grid"></a>



<h4>Method <code>selected_areas_global_grid()</code></h4>

<p>Takes the selected Area(s) of Interest (AOI) from the draw_edit_aoi() method and returns a simple features object with the corresponding n-degree grid cells
</p>


<h5>Usage</h5>

<div class="r"><pre>select_aoi_global_grid$selected_areas_global_grid(plot_data = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_data</code></dt><dd><p>a boolean specifying if the selected from the user AOI's and the corresponding grid cells should be plotted side by side. If FALSE then only the simple features object will be returned. If TRUE and the initial 'area_of_interest' parameter is NULL then a single plot will be displayed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>either an 'sfc' object (if the initial 'area_of_interest' parameter is NULL) or an 'sf' object consisting of the n-degree grid cells
</p>


<hr>
<a id="method-select_aoi_global_grid-selected_aoi_sf"></a>



<h4>Method <code>selected_aoi_sf()</code></h4>

<p>Returns the selected area of interest (AOI) by the user in form of an 'sfc' object
</p>


<h5>Usage</h5>

<div class="r"><pre>select_aoi_global_grid$selected_aoi_sf()</pre></div>



<h5>Returns</h5>

<p>an 'sfc' object
</p>


<hr>
<a id="method-select_aoi_global_grid-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>select_aoi_global_grid$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://github.com/r-spatial/mapedit/blob/master/experiments/gadget_draw2.R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)
require(magrittr)

#........................................
# 1st. Option: Select an AOI from the map
#........................................

init = select_aoi_global_grid$new(area_of_interest = NULL,
                                  verbose = TRUE)
init$draw_edit_aoi()
sf_obj = init$selected_areas_global_grid(plot_data = TRUE)
sf_obj


#...............................................
# observe the available countries and continents
# using the 'rnaturalearth' R package
#...............................................

cntr_cnt = rnaturalearth::ne_countries(scale = 110,
                                       type = 'countries',
                                       returnclass = 'sf')

cntr_cnt = cntr_cnt[, c('sovereignt', 'continent')]

# sort(cntr_cnt$sovereignt)
# sort(unique(cntr_cnt$continent))


#.......................................
# 2nd. Option: Select a 'country' as AOI   (5-degrees query)
#.......................................

init = select_aoi_global_grid$new(area_of_interest = 'Antarctica',
                                  verbose = TRUE)

init$draw_edit_aoi(degrees = 5.0, square_geoms = TRUE)
sf_obj = init$selected_areas_global_grid(plot_data = TRUE)
sf_obj


#.........................................
# 3rd. Option: Select a 'continent' as AOI   (1-degree query)
#.........................................

init = select_aoi_global_grid$new(area_of_interest = 'North America',
                                  verbose = TRUE)

init$draw_edit_aoi(degrees = 1.0, square_geoms = TRUE)
sf_obj = init$selected_areas_global_grid(plot_data = TRUE)
sf_obj


#.........................................
# 4th. Option: Use a bounding box as input  ('Greenland Ice Sheet')
#.........................................

data(ne_10m_glaciated_areas)

dat_bbx = ne_10m_glaciated_areas %&gt;%
  subset(!is.na(name)) %&gt;%
  subset(name == "Greenland Ice Sheet") %&gt;%
  sf::st_bbox(crs = 4326)

dat_bbx

init = select_aoi_global_grid$new(area_of_interest = dat_bbx,
                                  verbose = TRUE)

init$draw_edit_aoi(degrees = 1.0, square_geoms = TRUE)
sf_obj = init$selected_areas_global_grid(plot_data = TRUE)
sf_obj


#......................................................
# 5th. Option: Create a global hexagonal 5-degrees grid
#......................................................

bbx_global = c(xmin = -180, xmax = 180, ymin = -90, ymax = 90)

init = select_aoi_global_grid$new(area_of_interest = bbx_global,
                                  verbose = TRUE)

init$draw_edit_aoi(degrees = 5.0, square_geoms = FALSE)
sf_obj = init$selected_areas_global_grid(plot_data = TRUE)
sf_obj


## End(Not run)
</code></pre>

<hr>
<h2 id='switch_abb'>Convert an abbreviated month name to a numeric value</h2><span id='topic+switch_abb'></span>

<h3>Description</h3>

<p>Convert an abbreviated month name to a numeric value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_abb(month)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switch_abb_+3A_month">month</code></td>
<td>
<p>a character string specifying one of the twelve months, i.e. (&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string which will correspond to the numeric value of the input month, i.e. (&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;)
</p>

<hr>
<h2 id='switch_full'>Convert a full month name to a numeric value</h2><span id='topic+switch_full'></span>

<h3>Description</h3>

<p>Convert a full month name to a numeric value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_full(month)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switch_full_+3A_month">month</code></td>
<td>
<p>a character string specifying one of the twelve months, i.e. (&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string which will correspond to the numeric value of the input month, i.e. (&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;)
</p>

<hr>
<h2 id='time_specific_orbits'>Time Specific Orbits</h2><span id='topic+time_specific_orbits'></span>

<h3>Description</h3>

<p>This function shows the reference ground track time and locations for specific date ranges. &quot;Updated KML files have been posted to the 'tech-specs'
website (see the 'references' section for more details) containing individual files for each Reference Ground Track (RGT) with a date and time stamp
posted every 420 kilometers along-track (roughly 1 minute of flight time in between each point). The first RGT is 234; this is where the time series
begins. The date of each RGT is in the file name, so the user can easily ascertain where and when ICESat-2 will be on a particular day.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_specific_orbits(
  date_from = NULL,
  date_to = NULL,
  RGT_cycle = NULL,
  download_method = "curl",
  threads = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_specific_orbits_+3A_date_from">date_from</code></td>
<td>
<p>either NULL or a character string specifying the start date in the format 'yyyy-MM-dd' (such as '2020-01-01'). If this parameter is NULL then the 'RGT_cycle' parameter must be specified</p>
</td></tr>
<tr><td><code id="time_specific_orbits_+3A_date_to">date_to</code></td>
<td>
<p>either NULL or a character string specifying the end date in the format 'yyyy-MM-dd' (such as '2020-01-01'). If this parameter is NULL then the 'RGT_cycle' parameter must be specified</p>
</td></tr>
<tr><td><code id="time_specific_orbits_+3A_rgt_cycle">RGT_cycle</code></td>
<td>
<p>a character vector specifying the RGT (Reference Ground Track) cycle(s) (the specific revisit times of ICESAT-2). This parameter can be greater or equal to 1 with a maximum 'RGT-cycle' names as determined by the output of the 'available_RGTs(only_cycle_names = TRUE)' function. The computation time of a single 'RGT-cycle' might take approximately 15 minutes utilizing 8 threads (in parallel) and require approximately 2 GB of memory.</p>
</td></tr>
<tr><td><code id="time_specific_orbits_+3A_download_method">download_method</code></td>
<td>
<p>a character string specifying the download method. Corresponds to the 'method' parameter of the 'utils::download.file()' function. Can be one of 'internal', 'wininet' (Windows only), 'libcurl', 'wget', 'curl' or 'auto'</p>
</td></tr>
<tr><td><code id="time_specific_orbits_+3A_threads">threads</code></td>
<td>
<p>an integer that specifies the number of threads to use in parallel when processing the data</p>
</td></tr>
<tr><td><code id="time_specific_orbits_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'sf' object that will include one or more Reference Ground Tracks  (see the 'RGT' column of the output object)
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)

#................................................
# RGTs (Reference Ground Tracks) for a single day
#................................................

res_rgt_one = time_specific_orbits(date_from = '2019-06-01',
                                   date_to = '2019-06-01',
                                   download_method = 'curl',
                                   threads = 1,
                                   verbose = TRUE)
str(res_rgt_one)

#..........................................................
# RGTs (Reference Ground Tracks) for a specific time period
#..........................................................

res_rgt_many = time_specific_orbits(date_from = '2019-06-01',
                                    date_to = '2019-06-03',
                                    download_method = 'curl',
                                    threads = 1,
                                    verbose = TRUE)
str(res_rgt_many)


#.........................................................
# processing more than one RGTs for a specified date range
#.........................................................

res_rgt_inters = time_specific_orbits(date_from = '2021-03-23',
                                      date_to = '2021-03-26',
                                      download_method = 'curl',
                                      threads = 1,
                                      verbose = TRUE)
str(res_rgt_inters)

table(res_rgt_inters$cycle)
table(res_rgt_inters$day_of_year)
table(res_rgt_inters$RGT)

#...............................................................
# RGTs (Reference Ground Tracks) for a selected 'cycle'
# Observe the available RGT-cycles and use all available threads
#...............................................................

avail_cycles = available_RGTs(only_cycle_names = TRUE,
                              verbose = TRUE)
avail_cycles

choose_cycle = avail_cycles[3]

res_rgt_many = time_specific_orbits(RGT_cycle = choose_cycle,
                                    download_method = 'curl',
                                    threads = parallel::detectCores(),
                                    verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='verify_RGTs'>Verification of the Reference Ground Tracks (RGTs)</h2><span id='topic+verify_RGTs'></span>

<h3>Description</h3>

<p>This function allows the user to verify the NSIDC extracted RGTs with the corresponding OpenAltimetry using the same Dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_RGTs(nsidc_rgts, bbx_aoi, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_RGTs_+3A_nsidc_rgts">nsidc_rgts</code></td>
<td>
<p>a data.frame, data.table or tibble object that includes the columns 'Date_time' and 'RGT'</p>
</td></tr>
<tr><td><code id="verify_RGTs_+3A_bbx_aoi">bbx_aoi</code></td>
<td>
<p>a named numeric vector or an sf-bbox object with names 'xmin', 'ymin', 'xmax', 'ymax'</p>
</td></tr>
<tr><td><code id="verify_RGTs_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
<tr><td><code id="verify_RGTs_+3A_...">...</code></td>
<td>
<p>further parameters for the getTracks function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'data.table' object where it is possible that the number of the OpenAltimetry RGTs is higher compared to the NSIDC RGTs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)

rgts = data.table::setDT(list(RGT = c(1251L, 1252L, 1260L, 1267L, 1275L),
                              Date_time = c("2020-12-15", "2020-12-15",
                              "2020-12-15", "2020-12-16", "2020-12-16")))
bbx = c(xmin = -53.108876, ymin = 60.119614, xmax = -19.203521, ymax = 80.793117)

dtbl = verify_RGTs(nsidc_rgts = rgts, bbx_aoi = bbx, verbose = TRUE)
dtbl

# split by Date to observe RGTs by date

split(dtbl, by = 'Date_time')


## End(Not run)
</code></pre>

<hr>
<h2 id='vsi_kml_from_zip'>Utilizing Virtual File Systems (vsi) to extract the .kml from the .zip file</h2><span id='topic+vsi_kml_from_zip'></span>

<h3>Description</h3>

<p>This function returns the '.kml' and '.kmz' files in form of virtual file paths. Moreover, the user has the option to download these files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_kml_from_zip(
  icesat_rgt_url,
  download_zip = FALSE,
  download_method = "curl",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_kml_from_zip_+3A_icesat_rgt_url">icesat_rgt_url</code></td>
<td>
<p>a character string specifying the input .zip URL</p>
</td></tr>
<tr><td><code id="vsi_kml_from_zip_+3A_download_zip">download_zip</code></td>
<td>
<p>a boolean. If TRUE the .zip file will be first downloaded and then the .kml files will be returned, otherwise the 'gdalinfo' function will be used as input to the R 'system2()' function to read the .kml files without downloading the .zip file. The 'gdalinfo' command requires that the user has configured GDAL properly.</p>
</td></tr>
<tr><td><code id="vsi_kml_from_zip_+3A_download_method">download_method</code></td>
<td>
<p>a character string specifying the download method. Corresponds to the 'method' parameter of the 'utils::download.file()' function. Can be one of 'internal', 'wininet' (Windows only), 'libcurl', 'wget', 'curl' or 'auto'</p>
</td></tr>
<tr><td><code id="vsi_kml_from_zip_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an one column data.table of the output files
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>
<p>https://gdal.org/user/virtual_file_systems.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)

URL = 'https://icesat-2.gsfc.nasa.gov/sites/default/files/page_files/arcticallorbits.zip'

#..................................
# without downloading the .zip file
#..................................

res_out = vsi_kml_from_zip(icesat_rgt_url = URL,
                           download_zip = FALSE,
                           download_method = 'curl',
                           verbose = TRUE)
str(res_out)


#.............................
# by downloading the .zip file
#.............................

res_out = vsi_kml_from_zip(icesat_rgt_url = URL,
                           download_zip = TRUE,
                           download_method = 'curl',
                           verbose = TRUE)
str(res_out)


## End(Not run)
</code></pre>

<hr>
<h2 id='vsi_nominal_orbits_wkt'>Utilizing Virtual File Systems (vsi) and Well Known Text (WKT) to access the 'nominal orbits'</h2><span id='topic+vsi_nominal_orbits_wkt'></span>

<h3>Description</h3>

<p>Utilizing Virtual File Systems (vsi) and Well Known Text (WKT) to access the 'nominal orbits'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_nominal_orbits_wkt(
  orbit_area,
  track = "GT7",
  rgt_repeat = 1,
  wkt_filter = NULL,
  download_method = "curl",
  download_zip = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_nominal_orbits_wkt_+3A_orbit_area">orbit_area</code></td>
<td>
<p>a character string specifying the earth partition to use, it can be one of 'antarctic', 'arctic', 'western_hemisphere' and 'eastern_hemisphere'</p>
</td></tr>
<tr><td><code id="vsi_nominal_orbits_wkt_+3A_track">track</code></td>
<td>
<p>a character string specifying the orbit track. Can be one of 'GT1L','GT1R','GT2L','GT2R','GT3L','GT3R' or 'GT7'</p>
</td></tr>
<tr><td><code id="vsi_nominal_orbits_wkt_+3A_rgt_repeat">rgt_repeat</code></td>
<td>
<p>an integer specifying the orbit repeat. This parameter defaults to 1 and it is relevant if a user chooses one of the 'western_hemisphere' or 'eastern_hemisphere' where there are 8 orbit repeats, whereas for the 'antarctic' and 'arctic' there is only 1 repeat</p>
</td></tr>
<tr><td><code id="vsi_nominal_orbits_wkt_+3A_wkt_filter">wkt_filter</code></td>
<td>
<p>either NULL, or a Well Known Text (WKT) character string to allow a user to restrict to an area of interest rather than processing all data (this parameter will be used as input to the 'sf::st_read()' function)</p>
</td></tr>
<tr><td><code id="vsi_nominal_orbits_wkt_+3A_download_method">download_method</code></td>
<td>
<p>a character string specifying the download method. Corresponds to the 'method' parameter of the 'utils::download.file()' function. Can be one of 'internal', 'wininet' (Windows only), 'libcurl', 'wget', 'curl' or 'auto'</p>
</td></tr>
<tr><td><code id="vsi_nominal_orbits_wkt_+3A_download_zip">download_zip</code></td>
<td>
<p>a boolean. If TRUE the .zip file will be first downloaded and then the .kml files will be returned, otherwise the 'gdalinfo' function will be used as input to the R 'system2()' function to read the .kml files without downloading the .zip file. The 'gdalinfo' command requires that the user has configured GDAL properly. Set the parameter 'download_zip' to TRUE if GDAL is not (properly) installed.</p>
</td></tr>
<tr><td><code id="vsi_nominal_orbits_wkt_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'sf' object
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>
<p>https://gdal.org/user/virtual_file_systems.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)
require(magrittr)

#......................................
# processing all data of the orbit area
#......................................

dat_rgt = vsi_nominal_orbits_wkt(orbit_area = 'eastern_hemisphere',
                                 track = 'GT7',
                                 rgt_repeat = 1,
                                 wkt_filter = NULL,
                                 download_method = 'curl',
                                 download_zip = FALSE,
                                 verbose = TRUE)
str(dat_rgt)


#...........................................
# extracting nominal orbits only for the WKT
#...........................................

WKT = 'POLYGON ((-14.765 18.979, -11.25 18.979, -11.25 21.943, -14.765 21.943, -14.765 18.979))'

dat_rgt = vsi_nominal_orbits_wkt(orbit_area = 'western_hemisphere',
                                 track = 'GT3R',
                                 rgt_repeat = 8,
                                 wkt_filter = WKT,
                                 download_method = 'curl',
                                 download_zip = FALSE,
                                 verbose = TRUE)
str(dat_rgt)
dat_rgt[[1]]$RGT                 # Reference Ground Tracks of input WKT

#.............................
# Visualize the results
# (first compute the centroid)
#.............................

wkt_sf = sf::st_as_sfc(WKT, crs = 4326)
centr_wkt = sf::st_coordinates(sf::st_centroid(wkt_sf))

RGTs = mapview::mapview(dat_rgt, legend = F)
AOI_wkt = mapview::mapview(wkt_sf, legend = F)

lft = RGTs + AOI_wkt
lft@map %&gt;% leaflet::setView(lng = centr_wkt[, 'X'],
                             lat = centr_wkt[, 'Y'],
                             zoom = 7)

## End(Not run)
</code></pre>

<hr>
<h2 id='vsi_time_specific_orbits_wkt'>Utilizing Virtual File Systems (vsi) and Well Known Text (WKT) to access the 'time specific orbits'</h2><span id='topic+vsi_time_specific_orbits_wkt'></span>

<h3>Description</h3>

<p>Utilizing Virtual File Systems (vsi) and Well Known Text (WKT) to access the 'time specific orbits'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_time_specific_orbits_wkt(
  date_from,
  date_to,
  RGTs,
  wkt_filter = NULL,
  download_zip = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_time_specific_orbits_wkt_+3A_date_from">date_from</code></td>
<td>
<p>a character string specifying the 'start' date in the format 'yyyy-MM-dd' (such as '2020-01-01')</p>
</td></tr>
<tr><td><code id="vsi_time_specific_orbits_wkt_+3A_date_to">date_to</code></td>
<td>
<p>a character string specifying the 'end' date in the format 'yyyy-MM-dd' (such as '2020-01-01')</p>
</td></tr>
<tr><td><code id="vsi_time_specific_orbits_wkt_+3A_rgts">RGTs</code></td>
<td>
<p>a character vector (consisting of one or more) Reference Ground Track (RGT). See the Examples section on how to come to these RGTs based on the &quot;vsi_nominal_orbits_wkt()&quot; function</p>
</td></tr>
<tr><td><code id="vsi_time_specific_orbits_wkt_+3A_wkt_filter">wkt_filter</code></td>
<td>
<p>either NULL, or a Well Known Text (WKT) character string to allow a user to restrict to an area of interest rather than processing all data. It is possible that the WKT won't intersect with any of the available time specific orbits due to the sparsity of the coordinates (the output in that case will be an empty list)</p>
</td></tr>
<tr><td><code id="vsi_time_specific_orbits_wkt_+3A_download_zip">download_zip</code></td>
<td>
<p>a boolean. If TRUE the .zip file will be first downloaded and then the .kml files will be returned, otherwise the 'gdalinfo' function will be used as input to the R 'system2()' function to read the .kml files without downloading the .zip file. The 'gdalinfo' command requires that the user has configured GDAL properly. Set the parameter 'download_zip' to TRUE if GDAL is not (properly) installed.</p>
</td></tr>
<tr><td><code id="vsi_time_specific_orbits_wkt_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case that this function does not return any results (empty list object) for a specified 'wkt_filter' parameter, then use a bigger Well Known Text (WKT) area. This is required because the 'time specific orbits' (points) are quite sparse.
</p>
<p>Moreover, set the parameter 'download_zip' to TRUE if the 'gdalinfo' function returns internally an empty character string. In that case also a warning will be shown in the R session.
</p>


<h3>Value</h3>

<p>a list of 'sf' objects where each sublist will represent a different RGT cycle
</p>


<h3>References</h3>

<p>https://icesat-2.gsfc.nasa.gov/science/specs
</p>
<p>https://gdal.org/user/virtual_file_systems.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(IceSat2R)
require(magrittr)

#...........................................
# extracting nominal orbits only for the WKT
#...........................................

WKT = 'POLYGON ((-14.765 18.979, -11.25 18.979, -11.25 21.943, -14.765 21.943, -14.765 18.979))'

dat_rgt = vsi_nominal_orbits_wkt(orbit_area = 'western_hemisphere',
                                 track = 'GT3R',
                                 rgt_repeat = 8,
                                 wkt_filter = WKT,
                                 download_method = 'curl',
                                 download_zip = FALSE,
                                 verbose = TRUE)
str(dat_rgt)

out_rgt = dat_rgt[[1]]$RGT

#.........................................
# time specific RGTs (for a time interval)
# request using a single RGT cycle
#.........................................

date_start = '2020-01-01'
date_end = '2020-02-01'

orb_cyc_single = vsi_time_specific_orbits_wkt(date_from = date_start,
                                              date_to = date_end,
                                              RGTs = out_rgt,
                                              wkt_filter = WKT,
                                              verbose = TRUE)
str(orb_cyc_single)

#.........................................
# time specific RGTs (for a time interval)
# request using more than one RGT cycles
#.........................................

date_start = '2019-11-01'
date_end = '2020-01-01'

orb_cyc_multi = vsi_time_specific_orbits_wkt(date_from = date_start,
                                             date_to = date_end,
                                             RGTs = out_rgt,
                                             wkt_filter = WKT,
                                             verbose = TRUE)
str(orb_cyc_multi)
table(orb_cyc_multi$cycle)


#.......................................................
# visualization of the output cycles (including the WKT)
#.......................................................

orb_cyc_multi$cycle = as.factor(orb_cyc_multi$cycle)
mp_orb = mapview::mapview(orb_cyc_multi, legend = TRUE, zcol = 'cycle')

sf_aoi = sf::st_as_sfc(WKT, crs = 4326)
mp_aoi = mapview::mapview(sf_aoi, alpha.regions = 0.3, legend = F)

mp_orb + mp_aoi


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
