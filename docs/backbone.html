<!DOCTYPE html><html><head><title>Help for package backbone</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {backbone}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#backbone'><p>backbone: Extracts the Backbone from Graphs</p></a></li>
<li><a href='#backbone.extract'><p>Extracts a backbone network from a backbone object</p></a></li>
<li><a href='#backbone.suggest'><p>Suggest a backbone model</p></a></li>
<li><a href='#bicm'><p>Bipartite Configuration Model</p></a></li>
<li><a href='#disparity'><p>Extract backbone using the Disparity Filter</p></a></li>
<li><a href='#fastball'><p>Randomize a binary matrix using the fastball algorithm</p></a></li>
<li><a href='#fdsm'><p>Extract backbone using the Fixed Degree Sequence Model</p></a></li>
<li><a href='#fixedcol'><p>Extract backbone using the Fixed Column Model</p></a></li>
<li><a href='#fixedfill'><p>Extract backbone using the Fixed Fill Model</p></a></li>
<li><a href='#fixedrow'><p>Extract backbone using the Fixed Row Model</p></a></li>
<li><a href='#frommatrix'><p>Converts a backbone adjacency matrix to a graph object of specified class</p></a></li>
<li><a href='#global'><p>Compute global threshold backbone</p></a></li>
<li><a href='#lans'><p>Extract backbone using Locally Adaptive Network Sparsification</p></a></li>
<li><a href='#logit'><p>Logit-based probabilities for SDSM</p></a></li>
<li><a href='#loglikelihood_bicm'><p>Computes the loglikelihood for the bicm function</p></a></li>
<li><a href='#loglikelihood_hessian_diag_bicm'><p>Computes the loglikelihood hessian for the bicm function</p></a></li>
<li><a href='#loglikelihood_prime_bicm'><p>Computes the loglikelihood gradient for the bicm function</p></a></li>
<li><a href='#mlf'><p>Extract backbone using the Marginal Likelihood Filter</p></a></li>
<li><a href='#osdsm'><p>Extract backbone using the Ordinal Stochastic Degree Sequence Model</p></a></li>
<li><a href='#pb'><p>Poisson binomial distribution function</p></a></li>
<li><a href='#sdsm'><p>Extract backbone using the Stochastic Degree Sequence Model</p></a></li>
<li><a href='#sparsify'><p>Extract the backbone from a network using a sparsification model</p></a></li>
<li><a href='#sparsify.with.geometric'><p>Extract Goldberg and Roth's (2003) Geometric backbone</p></a></li>
<li><a href='#sparsify.with.gspar'><p>Extract Satuluri et al's (2011) G-spar backbone</p></a></li>
<li><a href='#sparsify.with.hypergeometric'><p>Extract Goldberg and Roth's (2003) Hypergeometric backbone</p></a></li>
<li><a href='#sparsify.with.jaccard'><p>Extract Goldberg and Roth's (2003) Jaccard backbone</p></a></li>
<li><a href='#sparsify.with.localdegree'><p>Extract Hamann et al.'s (2016) Local Degree backbone</p></a></li>
<li><a href='#sparsify.with.lspar'><p>Extract Satuluri et al's (2011) L-spar backbone</p></a></li>
<li><a href='#sparsify.with.meetmin'><p>Extract Goldberg and Roth's (2003) MeetMin backbone</p></a></li>
<li><a href='#sparsify.with.quadrilateral'><p>Extract Nocaj et al.'s (2015) Quadrilateral Simmelian backbone</p></a></li>
<li><a href='#sparsify.with.simmelian'><p>Extract Nick et al's (2013) Simmelian backbone</p></a></li>
<li><a href='#sparsify.with.skeleton'><p>Extract Karger's (1999) skeleton backbone</p></a></li>
<li><a href='#tomatrix'><p>Converts an input graph object to an adjacency/incidence matrix and identifies its characteristics</p></a></li>
<li><a href='#trials.needed'><p>Estimate number of monte carlo trials needed to estimate p-value</p></a></li>
<li><a href='#write.narrative'><p>Generates suggested manuscript text</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extracts the Backbone from Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of methods for extracting an unweighted unipartite
   graph (i.e. a backbone) from an unweighted unipartite graph, a weighted unipartite
   graph, the projection of an unweighted bipartite graph, or the projection
   of a weighted bipartite graph (Neal, 2022 &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0269137">doi:10.1371/journal.pone.0269137</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, Matrix, methods, stats, Rcpp, utils,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.zacharyneal.com/backbone">https://www.zacharyneal.com/backbone</a>,
<a href="https://github.com/zpneal/backbone">https://github.com/zpneal/backbone</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zpneal/backbone/issues">https://github.com/zpneal/backbone/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-09 17:56:55 UTC; zacharyneal</td>
</tr>
<tr>
<td>Author:</td>
<td>Zachary Neal <a href="https://orcid.org/0000-0003-3076-4995"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rachel Domagalski [ctb],
  Bruce Sagan [ctb],
  Karl Godard [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zachary Neal &lt;zpneal@msu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-09 18:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='backbone'>backbone: Extracts the Backbone from Graphs</h2><span id='topic+backbone'></span><span id='topic+backbone-package'></span>

<h3>Description</h3>

<p>Provides methods for extracting from an unweighted and sparse subgraph (i.e., a backbone)
that contains only the most &quot;important&quot; edges in a weighted bipartite projection, a non-projection
weighted network, or an unweighted network.
</p>
<p>Available backbone extraction functions include:
</p>

<ul>
<li><p> For weighted bipartite projections of weighted bipartite networks: <code><a href="#topic+osdsm">osdsm()</a></code>.
</p>
</li>
<li><p> For weighted bipartite projections of binary bipartite networks: <code><a href="#topic+fixedfill">fixedfill()</a></code>, <code><a href="#topic+fixedrow">fixedrow()</a></code>, <code><a href="#topic+fixedcol">fixedcol()</a></code>, <code><a href="#topic+sdsm">sdsm()</a></code>, and <code><a href="#topic+fdsm">fdsm()</a></code>.
</p>
</li>
<li><p> For non-projection weighted networks: <code><a href="#topic+global">global()</a></code>, <code><a href="#topic+disparity">disparity()</a></code>, <code><a href="#topic+mlf">mlf()</a></code>, <code><a href="#topic+lans">lans()</a></code>.
</p>
</li>
<li><p> For unweighted networks: <code><a href="#topic+sparsify">sparsify()</a></code>, <code><a href="#topic+sparsify.with.skeleton">sparsify.with.skeleton()</a></code>, <code><a href="#topic+sparsify.with.gspar">sparsify.with.gspar()</a></code>, <code><a href="#topic+sparsify.with.lspar">sparsify.with.lspar()</a></code>, <code><a href="#topic+sparsify.with.simmelian">sparsify.with.simmelian()</a></code>, <code><a href="#topic+sparsify.with.jaccard">sparsify.with.jaccard()</a></code>, <code><a href="#topic+sparsify.with.meetmin">sparsify.with.meetmin()</a></code>, <code><a href="#topic+sparsify.with.geometric">sparsify.with.geometric()</a></code>, <code><a href="#topic+sparsify.with.hypergeometric">sparsify.with.hypergeometric()</a></code>, <code><a href="#topic+sparsify.with.localdegree">sparsify.with.localdegree()</a></code>, <code><a href="#topic+sparsify.with.quadrilateral">sparsify.with.quadrilateral()</a></code>.
</p>
</li>
<li><p> For all networks: <code><a href="#topic+backbone.suggest">backbone.suggest()</a></code> will examine the data and suggest an appropriate backbone function
</p>
</li></ul>

<p>The package also includes some utility functions:
</p>

<ul>
<li> <p><code><a href="#topic+fastball">fastball()</a></code> - Fast marginal-preserving randomization of binary matrices
</p>
</li>
<li> <p><code><a href="#topic+bicm">bicm()</a></code> - Compute probabilities under the bipartite configuration model
</p>
</li></ul>

<p>For additional documentation and background on the package functions, see <a href="../doc/backbone.html"><code>vignette("backbone")</code></a>.
For updates, papers, presentations, and other backbone news, please see <a href="https://www.zacharyneal.com/backbone">www.rbackbone.net</a>
</p>


<h3>References</h3>

<p>Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>

<hr>
<h2 id='backbone.extract'>Extracts a backbone network from a backbone object</h2><span id='topic+backbone.extract'></span>

<h3>Description</h3>

<p><code>backbone.extract</code> returns a binary or signed adjacency matrix
containing the backbone that retains only the significant edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backbone.extract(
  bb.object,
  signed = FALSE,
  alpha = 0.05,
  mtc = "none",
  class = bb.object$class,
  narrative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backbone.extract_+3A_bb.object">bb.object</code></td>
<td>
<p>backbone: backbone S3 class object.</p>
</td></tr>
<tr><td><code id="backbone.extract_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="backbone.extract_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="backbone.extract_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="backbone.extract_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;matrix&quot;, &quot;sparseMatrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;), converted via <a href="#topic+tomatrix">tomatrix</a>.</p>
</td></tr>
<tr><td><code id="backbone.extract_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;backbone&quot; S3 class object is composed of (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>


<h3>Value</h3>

<p>backbone graph: Binary or signed backbone graph of class given in parameter <code>class</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A binary bipartite network of 30 agents &amp; 75 artifacts; agents form three communities
B &lt;- rbind(cbind(matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10)))

backbone.object &lt;- fixedrow(B, alpha = NULL)
bb &lt;- backbone.extract(backbone.object, alpha = 0.05)
</code></pre>

<hr>
<h2 id='backbone.suggest'>Suggest a backbone model</h2><span id='topic+backbone.suggest'></span>

<h3>Description</h3>

<p><code>backbone.suggest</code> suggests and optionally runs an appropriate backbone model for a graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backbone.suggest(G, s = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backbone.suggest_+3A_g">G</code></td>
<td>
<p>graph: A graph represented in an object of class matrix, sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>, dataframe, or <code><a href="igraph.html#topic+igraph">igraph</a></code>.</p>
</td></tr>
<tr><td><code id="backbone.suggest_+3A_s">s</code></td>
<td>
<p>numeric: If provided, a backbone is extracted using this value as the significance level or sparsification parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>s</code> == NULL: NULL, but a message is displayed with a suggested model.
If 0 &lt;= <code>s</code> &lt;= 1: A binary backbone graph in the same class as <code>G</code>, obtained by extracting the backbone
at the <code>s</code> significance level (if a statistical model is suggested) or using sparisfication parameter <code>s</code>
(if a sparsification model is suggested). The code used to perform the extraction, and suggested manuscript
text are displayed.
</p>


<h3>References</h3>

<p>Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(runif(100),10,10)  #A random weighted, directed graph
backbone &lt;- backbone.suggest(M)
backbone &lt;- backbone.suggest(M, s = 0.05)
</code></pre>

<hr>
<h2 id='bicm'>Bipartite Configuration Model</h2><span id='topic+bicm'></span>

<h3>Description</h3>

<p><code>bicm</code> estimates cell probabilities under the bipartite configuration model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicm(M, fitness = FALSE, tol = 1e-08, max_steps = 200, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bicm_+3A_m">M</code></td>
<td>
<p>matrix: a binary matrix</p>
</td></tr>
<tr><td><code id="bicm_+3A_fitness">fitness</code></td>
<td>
<p>boolean: FALSE returns a matrix of probabilities, TRUE returns a list of row and column fitnesses only</p>
</td></tr>
<tr><td><code id="bicm_+3A_tol">tol</code></td>
<td>
<p>numeric, tolerance of algorithm</p>
</td></tr>
<tr><td><code id="bicm_+3A_max_steps">max_steps</code></td>
<td>
<p>numeric, number of times to run <a href="#topic+loglikelihood_prime_bicm">loglikelihood_prime_bicm</a> algorithm</p>
</td></tr>
<tr><td><code id="bicm_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a binary matrix <strong>M</strong>, the Bipartite Configuration Model (BiCM; Saracco et. al. 2015) returns a valued matrix
<strong>B</strong> in which Bij is the <em>approximate</em> probability that Mij = 1 in the space of all binary matrices with
the same row and column marginals as <strong>M</strong>. The BiCM yields the closest approximations of the true probabilities
compared to other estimation methods (Neal et al., 2021), and is used by <code><a href="#topic+sdsm">sdsm()</a></code> to extract the backbone of
a bipartite projection using the stochastic degree sequence model.
</p>
<p>Matrix <strong>M</strong> is &quot;conforming&quot; if no rows and no columns contain only zeros or only ones. If <strong>M</strong> is conforming, then
<code>bicm()</code> is faster. Additionally, if <code>fitness = TRUE</code>, then <code>bicm()</code> returns a list of row and column fitnesses,
which requires less memory. Given the <em>i</em>th row's fitness Ri and the <em>j</em>th column's fitness Rj, the entry Bij in
the probability matrix can be computed as Ri x Rj/(1+(Ri x Rj)).
</p>
<p>Matrix <strong>M</strong> is &quot;non-conforming&quot; if any rows or any columns contain only zeros or only ones. If <strong>M</strong> is non-conforming,
then <code>bicm()</code> is slower and will only return a probability matrix.
</p>


<h3>Value</h3>

<p>a matrix of probabilities or a list of fitnesses
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>bicm: Saracco, F., Di Clemente, R., Gabrielli, A., &amp; Squartini, T. (2015). Randomizing bipartite networks: The case of the World Trade Web. <em>Scientific Reports, 5</em>, 10595. <a href="https://doi.org/10.1038/srep10595">doi:10.1038/srep10595</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(0,0,1,0,1,0,1,0,1),3,3)  #A binary matrix
bicm(M)
</code></pre>

<hr>
<h2 id='disparity'>Extract backbone using the Disparity Filter</h2><span id='topic+disparity'></span>

<h3>Description</h3>

<p><code>disparity</code> extracts the backbone of a weighted network using the Disparity Filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disparity(
  W,
  alpha = 0.05,
  missing.as.zero = FALSE,
  signed = FALSE,
  mtc = "none",
  class = "original",
  narrative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disparity_+3A_w">W</code></td>
<td>
<p>A positively-weighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a three-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="disparity_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="disparity_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="disparity_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="disparity_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="disparity_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>W</code>.</p>
</td></tr>
<tr><td><code id="disparity_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>disparity</code> function applies the disparity filter (Serrano et al., 2009), which compares an edge's weight to
its expected weight if a node's total degree was uniformly distributed across all its edges. The graph may be
directed or undirected, however the edge weights must be positive.
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>
<p>If <code>W</code> is an unweighted bipartite graph, then the disparity filter is applied to its weighted bipartite projection.
</p>


<h3>Value</h3>

<p>If <code>alpha</code> != NULL: Binary or signed backbone graph of class <code>class</code>.
</p>
<p>If <code>alpha</code> == NULL: An S3 backbone object containing (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model, from which a backbone can subsequently be extracted
using <code><a href="#topic+backbone.extract">backbone.extract()</a></code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>disparity filter: Serrano, M. A., Boguna, M., &amp; Vespignani, A. (2009). Extracting the multiscale backbone of complex weighted networks. <em>Proceedings of the National Academy of Sciences, 106</em>, 6483-6488. <a href="https://doi.org/10.1073/pnas.0808904106">doi:10.1073/pnas.0808904106</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A network with heterogeneous (i.e. multiscale) weights
net &lt;- matrix(c(0,10,10,10,10,75,0,0,0,0,
                10,0,1,1,1,0,0,0,0,0,
                10,1,0,1,1,0,0,0,0,0,
                10,1,1,0,1,0,0,0,0,0,
                10,1,1,1,0,0,0,0,0,0,
                75,0,0,0,0,0,100,100,100,100,
                0,0,0,0,0,100,0,10,10,10,
                0,0,0,0,0,100,10,0,10,10,
                0,0,0,0,0,100,10,10,0,10,
                0,0,0,0,0,100,10,10,10,0),10)

net &lt;- igraph::graph_from_adjacency_matrix(net, mode = "undirected", weighted = TRUE)
plot(net, edge.width = sqrt(igraph::E(net)$weight)) #A stronger clique &amp; a weaker clique

strong &lt;- igraph::delete_edges(net, which(igraph::E(net)$weight &lt; mean(igraph::E(net)$weight)))
plot(strong) #A backbone of stronger-than-average edges ignores the weaker clique

bb &lt;- disparity(net, alpha = 0.05, narrative = TRUE) #A disparity backbone...
plot(bb) #...preserves edges at multiple scales
</code></pre>

<hr>
<h2 id='fastball'>Randomize a binary matrix using the fastball algorithm</h2><span id='topic+fastball'></span>

<h3>Description</h3>

<p><code>fastball</code> randomizes a binary matrix, preserving the row and column sums
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastball(M, trades = 5 * nrow(M))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastball_+3A_m">M</code></td>
<td>
<p>matrix: a binary matrix (see details)</p>
</td></tr>
<tr><td><code id="fastball_+3A_trades">trades</code></td>
<td>
<p>integer: number of trades; the default is 5R trades (approx. mixing time)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a matrix <code>M</code>, <code>fastball</code> randomly samples a new matrix from the space of all matrices with the same row and column sums as <code>M</code>.
</p>


<h3>Value</h3>

<p>matrix: A random binary matrix with same row sums and column sums as M.
</p>


<h3>References</h3>

<p>fastball: Godard, Karl and Neal, Zachary P. 2022. fastball: A fast algorithm to sample bipartite graphs with fixed degree sequences. <em>Journal of Complex Networks</em> <a href="https://doi.org/10.1093/comnet/cnac049">doi:10.1093/comnet/cnac049</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(rbinom(200,1,0.5),10,20)  #A random 10x20 binary matrix
Mrand &lt;- fastball(M)  #Random matrix with same row and column sums
</code></pre>

<hr>
<h2 id='fdsm'>Extract backbone using the Fixed Degree Sequence Model</h2><span id='topic+fdsm'></span>

<h3>Description</h3>

<p><code>fdsm</code> extracts the backbone of a bipartite projection using the Fixed Degree Sequence Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdsm(
  B,
  alpha = 0.05,
  trials = NULL,
  missing.as.zero = FALSE,
  signed = FALSE,
  mtc = "none",
  class = "original",
  narrative = FALSE,
  progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdsm_+3A_b">B</code></td>
<td>
<p>An unweighted bipartite graph, as: (1) an incidence matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="fdsm_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="fdsm_+3A_trials">trials</code></td>
<td>
<p>numeric: the number of bipartite graphs generated to approximate the edge weight distribution. If NULL, the number of trials is selected based on <code>alpha</code> (see details)</p>
</td></tr>
<tr><td><code id="fdsm_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="fdsm_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="fdsm_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="fdsm_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>B</code>.</p>
</td></tr>
<tr><td><code id="fdsm_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
<tr><td><code id="fdsm_+3A_progress">progress</code></td>
<td>
<p>boolean: TRUE if the progress of Monte Carlo trials should be displayed.</p>
</td></tr>
<tr><td><code id="fdsm_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fdsm</code> function compares an edge's observed weight in the projection <code>B*t(B)</code> to the distribution of weights
expected in a projection obtained from a random bipartite network where both the row vertex degrees and column
vertex degrees are <em>exactly</em> fixed at their values in <code>B</code>. It uses the <code><a href="#topic+fastball">fastball()</a></code> algorithm to generate random
bipartite matrices with give row and column vertex degrees.
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>
<p>The p-values used to evaluate the statistical significance of each edge are computed using Monte Carlo methods. The number of
<code>trials</code> performed affects the precision of these p-values. This precision impacts the confidence that a given edge's p-value
is less than the desired <code>alpha</code> level, and therefore represents a statistically significant edge that should be retained in
the backbone. When <code>trials = NULL</code>, <code><a href="#topic+trials.needed">trials.needed()</a></code> is used to estimate the required number of trials to evaluate the
statistical significance of an edges' p-values.
</p>


<h3>Value</h3>

<p>If <code>alpha</code> != NULL: Binary or signed backbone graph of class <code>class</code>.
</p>
<p>If <code>alpha</code> == NULL: An S3 backbone object containing (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model, from which a backbone can subsequently be extracted
using <code><a href="#topic+backbone.extract">backbone.extract()</a></code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>fdsm: Neal, Z. P., Domagalski, R., and Sagan, B. (2021). Comparing Alternatives to the Fixed Degree Sequence Model for Extracting the Backbone of Bipartite Projections. <em>Scientific Reports</em>. <a href="https://doi.org/10.1038/s41598-021-03238-3">doi:10.1038/s41598-021-03238-3</a>
</p>
<p>fastball: Godard, Karl and Neal, Zachary P. 2022. fastball: A fast algorithm to sample bipartite graphs with fixed degree sequences. <em>Journal of Complex Networks</em> <a href="https://doi.org/10.1093/comnet/cnac049">doi:10.1093/comnet/cnac049</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A binary bipartite network of 30 agents &amp; 75 artifacts; agents form three communities
B &lt;- rbind(cbind(matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10)))

P &lt;- B%*%t(B) #An ordinary weighted projection...
plot(igraph::graph_from_adjacency_matrix(P, mode = "undirected",
                                         weighted = TRUE, diag = FALSE)) #...is a dense hairball

bb &lt;- fdsm(B, alpha = 0.05, trials = 1000, narrative = TRUE, class = "igraph") #An FDSM backbone...
plot(bb) #...is sparse with clear communities
</code></pre>

<hr>
<h2 id='fixedcol'>Extract backbone using the Fixed Column Model</h2><span id='topic+fixedcol'></span>

<h3>Description</h3>

<p><code>fixedcol</code> extracts the backbone of a bipartite projection using the Fixed Column Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixedcol(
  B,
  alpha = 0.05,
  missing.as.zero = FALSE,
  signed = FALSE,
  mtc = "none",
  class = "original",
  narrative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixedcol_+3A_b">B</code></td>
<td>
<p>An unweighted bipartite graph, as: (1) an incidence matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="fixedcol_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="fixedcol_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="fixedcol_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="fixedcol_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="fixedcol_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>B</code>.</p>
</td></tr>
<tr><td><code id="fixedcol_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This <code>fixedcol</code> function compares an edge's observed weight in the projection <code class="reqn">B*t(B)</code> to the
distribution of weights expected in a projection obtained from a random bipartite graph where
the <em>column</em> vertex degrees are fixed but the row vertex degrees are allowed to vary.
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>


<h3>Value</h3>

<p>If <code>alpha</code> != NULL: Binary or signed backbone graph of class <code>class</code>.
</p>
<p>If <code>alpha</code> == NULL: An S3 backbone object containing (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model, from which a backbone can subsequently be extracted
using <code><a href="#topic+backbone.extract">backbone.extract()</a></code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>fixedcol: Neal, Z. P., Domagalski, R., and Sagan, B. (2021). Comparing Alternatives to the Fixed Degree Sequence Model for Extracting the Backbone of Bipartite Projections. <em>Scientific Reports, 11</em>, 23929. <a href="https://doi.org/10.1038/s41598-021-03238-3">doi:10.1038/s41598-021-03238-3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A binary bipartite network of 30 agents &amp; 75 artifacts; agents form three communities
B &lt;- rbind(cbind(matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10)))

P &lt;- B%*%t(B) #An ordinary weighted projection...
plot(igraph::graph_from_adjacency_matrix(P, mode = "undirected",
                                         weighted = TRUE, diag = FALSE)) #...is a dense hairball

bb &lt;- fixedcol(B, alpha = 0.05, narrative = TRUE, class = "igraph") #A fixedcol backbone...
plot(bb) #...is sparse with clear communities
</code></pre>

<hr>
<h2 id='fixedfill'>Extract backbone using the Fixed Fill Model</h2><span id='topic+fixedfill'></span>

<h3>Description</h3>

<p><code>fixedfill</code> extracts the backbone of a bipartite projection using the Fixed Fill Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixedfill(
  B,
  alpha = 0.05,
  missing.as.zero = FALSE,
  signed = FALSE,
  mtc = "none",
  class = "original",
  narrative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixedfill_+3A_b">B</code></td>
<td>
<p>An unweighted bipartite graph, as: (1) an incidence matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="fixedfill_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="fixedfill_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="fixedfill_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="fixedfill_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="fixedfill_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>B</code>.</p>
</td></tr>
<tr><td><code id="fixedfill_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fixedfill</code> function compares an edge's observed weight in the projection <code class="reqn">B*t(B)</code> to the distribution
of weights expected in a projection obtained from a random bipartite graph where the number of edges present
(i.e., the number of cells <em>filled</em> with a 1) is equal to the number of edges in B. When B is large, this function
may be impractically slow and may return a backbone object that contains <code>NaN</code> values.
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>


<h3>Value</h3>

<p>If <code>alpha</code> != NULL: Binary or signed backbone graph of class <code>class</code>.
</p>
<p>If <code>alpha</code> == NULL: An S3 backbone object containing (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model, from which a backbone can subsequently be extracted
using <code><a href="#topic+backbone.extract">backbone.extract()</a></code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>fixedfill: Neal, Z. P., Domagalski, R., and Sagan, B. (2021). Comparing Alternatives to the Fixed Degree Sequence Model for Extracting the Backbone of Bipartite Projections. <em>Scientific Reports, 11</em>, 23929. <a href="https://doi.org/10.1038/s41598-021-03238-3">doi:10.1038/s41598-021-03238-3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A binary bipartite network of 30 agents &amp; 75 artifacts; agents form three communities
B &lt;- rbind(cbind(matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10)))

P &lt;- B%*%t(B) #An ordinary weighted projection...
plot(igraph::graph_from_adjacency_matrix(P, mode = "undirected",
                                         weighted = TRUE, diag = FALSE)) #...is a dense hairball

bb &lt;- fixedfill(B, alpha = 0.05, narrative = TRUE, class = "igraph") #A fixedfill backbone...
plot(bb) #...is sparse with clear communities
</code></pre>

<hr>
<h2 id='fixedrow'>Extract backbone using the Fixed Row Model</h2><span id='topic+fixedrow'></span>

<h3>Description</h3>

<p><code>fixedrow</code> extracts the backbone of a bipartite projection using the Fixed Row Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixedrow(
  B,
  alpha = 0.05,
  missing.as.zero = FALSE,
  signed = FALSE,
  mtc = "none",
  class = "original",
  narrative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixedrow_+3A_b">B</code></td>
<td>
<p>An unweighted bipartite graph, as: (1) an incidence matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="fixedrow_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="fixedrow_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="fixedrow_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="fixedrow_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="fixedrow_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>B</code>.</p>
</td></tr>
<tr><td><code id="fixedrow_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fixedrow</code> function compares an edge's observed weight in the projection <code class="reqn">B*t(B)</code> to the
distribution of weights expected in a projection obtained from a random bipartite graph where
the <em>row</em> vertex degrees are fixed but the column vertex degrees are allowed to vary.
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>


<h3>Value</h3>

<p>If <code>alpha</code> != NULL: Binary or signed backbone graph of class <code>class</code>.
</p>
<p>If <code>alpha</code> == NULL: An S3 backbone object containing (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model, from which a backbone can subsequently be extracted
using <code><a href="#topic+backbone.extract">backbone.extract()</a></code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>Neal, Z. P., Domagalski, R., and Sagan, B. (2021). Comparing Alternatives to the Fixed Degree Sequence Model for Extracting the Backbone of Bipartite Projections. <em>Scientific Reports, 11</em>, 23929. <a href="https://doi.org/10.1038/s41598-021-03238-3">doi:10.1038/s41598-021-03238-3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A binary bipartite network of 30 agents &amp; 75 artifacts; agents form three communities
B &lt;- rbind(cbind(matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10)))

P &lt;- B%*%t(B) #An ordinary weighted projection...
plot(igraph::graph_from_adjacency_matrix(P, mode = "undirected",
                                         weighted = TRUE, diag = FALSE)) #...is a dense hairball

bb &lt;- fixedrow(B, alpha = 0.05, narrative = TRUE, class = "igraph") #A fixedrow backbone...
plot(bb) #...is sparse with clear communities
</code></pre>

<hr>
<h2 id='frommatrix'>Converts a backbone adjacency matrix to a graph object of specified class</h2><span id='topic+frommatrix'></span>

<h3>Description</h3>

<p>Converts a backbone adjacency matrix to a graph object of specified class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frommatrix(mat, attribs = NA, convert = "matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frommatrix_+3A_mat">mat</code></td>
<td>
<p>an adjacency matrix</p>
</td></tr>
<tr><td><code id="frommatrix_+3A_attribs">attribs</code></td>
<td>
<p>dataframe: vertex attributes to be assigned in igraph object</p>
</td></tr>
<tr><td><code id="frommatrix_+3A_convert">convert</code></td>
<td>
<p>class to convert to, one of &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, or &quot;edgelist&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>backbone graph: Binary or signed backbone graph of class <code>convert</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(sample(c(-1,0,1),5*5,replace=TRUE),5,5)
test &lt;- backbone:::frommatrix(M, "Matrix")
</code></pre>

<hr>
<h2 id='global'>Compute global threshold backbone</h2><span id='topic+global'></span>

<h3>Description</h3>

<p><code>global</code> extracts the backbone of a weighted network using a global threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global(
  G,
  upper = 0,
  lower = NULL,
  keepzeros = TRUE,
  class = "original",
  narrative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global_+3A_g">G</code></td>
<td>
<p>A weighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>, or dataframe; (2) an edgelist in the form of a three-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="global_+3A_upper">upper</code></td>
<td>
<p>real, FUN, or NULL: upper threshold value or function that evaluates to an upper threshold value.</p>
</td></tr>
<tr><td><code id="global_+3A_lower">lower</code></td>
<td>
<p>real, FUN, or NULL: lower threshold value or function that evaluates to a lower threshold value.</p>
</td></tr>
<tr><td><code id="global_+3A_keepzeros">keepzeros</code></td>
<td>
<p>boolean: TRUE if zero-weight edges in <code>W</code> should be excluded from (i.e. also be zero in) the backbone</p>
</td></tr>
<tr><td><code id="global_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>W</code>.</p>
</td></tr>
<tr><td><code id="global_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>global</code> function retains a edge with weight <code>W</code> if <code>W</code> &gt; <code>upper</code>. If a <code>lower</code> threshold is also
specified, it returns a signed backbone in which an edge's weight is set to 1 if <code>W</code> &gt; <code>upper</code>,
is set to -1 if <code>W</code> &lt; <code>lower</code>, and is set to 0 otherwise. The default is an unsigned backbone containing
all edges with non-zero weights.
</p>
<p>If <code>G</code> is an unweighted bipartite graph, the global threshold is applied to its weighted bipartite projection.
</p>


<h3>Value</h3>

<p>Binary or signed backbone graph of class given in parameter <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Neal, Z. P. (2014). The backbone of bipartite projections: Inferring relationships from co-authorship, co-sponsorship, co-attendance, and other co-behaviors. <em>Social Networks, 39</em>, 84-97. <a href="https://doi.org/10.1016/j.socnet.2014.06.001">doi:10.1016/j.socnet.2014.06.001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- matrix(sample(0:5, 100, replace = TRUE), 10) #Random weighted graph
diag(G) &lt;- 0
G
global(G, narrative = TRUE)  #Keep all non-zero edges
global(G, upper = 4, lower = 2, narrative = TRUE)  #Signed with specified thresholds
global(G, upper = function(x)mean(x),  #Above-average --&gt; positive edges
          lower = function(x)mean(x), narrative = TRUE)  #Below-average --&gt; negative edges
</code></pre>

<hr>
<h2 id='lans'>Extract backbone using Locally Adaptive Network Sparsification</h2><span id='topic+lans'></span>

<h3>Description</h3>

<p><code>lans</code> extracts the backbone of a weighted network using Locally Adaptive Network Sparsification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lans(
  W,
  alpha = 0.05,
  missing.as.zero = FALSE,
  signed = FALSE,
  mtc = "none",
  class = "original",
  narrative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lans_+3A_w">W</code></td>
<td>
<p>A positively-weighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a three-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="lans_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="lans_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="lans_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="lans_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="lans_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>W</code>.</p>
</td></tr>
<tr><td><code id="lans_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lans</code> function applies Locally Adaptive Network Sparsification (LANS; Foti et al., 2011), which compares an edge's
fractional weight to the cumulative distribution function for the fractional edge weights of all edges connected to
a given node. The graph may be directed or undirected, however the edge weights must be positive.
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>
<p>If <code>W</code> is an unweighted bipartite graph, then LANS is applied to its weighted bipartite projection.
</p>


<h3>Value</h3>

<p>If <code>alpha</code> != NULL: Binary or signed backbone graph of class <code>class</code>.
</p>
<p>If <code>alpha</code> == NULL: An S3 backbone object containing (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model, from which a backbone can subsequently be extracted
using <code><a href="#topic+backbone.extract">backbone.extract()</a></code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>lans: Foti, N. J., Hughes, J. M., and Rockmore, D. N. (2011). Nonparametric Sparsification of Complex Multiscale Networks. <em>PLOS One, 6</em>, e16431. <a href="https://doi.org/10.1371/journal.pone.0016431">doi:10.1371/journal.pone.0016431</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simple star from Foti et al. (2011), Figure 2
net &lt;- matrix(c(0,2,2,2,2,
                2,0,1,1,0,
                2,1,0,0,1,
                2,1,0,0,1,
                2,0,1,1,0),5,5)
net &lt;- igraph::graph_from_adjacency_matrix(net, mode = "undirected", weighted = TRUE)
plot(net, edge.width = igraph::E(net)$weight^2)

bb &lt;- lans(net, alpha = 0.05, narrative = TRUE) #The LANS backbone
plot(bb)
</code></pre>

<hr>
<h2 id='logit'>Logit-based probabilities for SDSM</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p><code>logit</code> estimates cell probabilities under the logit model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_m">M</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a matrix <strong>M</strong>, the logit model returns a valued matrix <strong>B</strong> in which Bij is the <em>approximate</em> probability
that Mij = 1 in the space of all binary matrices with the same row and column marginals as <strong>M</strong>.
</p>
<p>The Bipartite Configuration Model (BiCM), which is available using <a href="#topic+bicm">bicm</a> is faster and yields slightly
more accurate probabilities (Neal et al., 2021). Therefore, it is the default used in <a href="#topic+sdsm">sdsm</a>. However,
the BiCM it requires the assumption that any cell in <strong>M</strong> can take a value of 0 or 1.
</p>
<p>In contrast, the logit model allows constraints on specific cells. If <strong>M</strong> represents a bipartite graph, these
constraints are equivalent to structural 0s (an edge that can never be present) and structural 1s (an edge that
must always be present). To impose such constraints, <strong>M</strong> should be binary, except that structural 0s are
represented with Mij = 10, and structural 1s are represented with Mij = 11.
</p>


<h3>Value</h3>

<p>a matrix of probabilities
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>logit model: Neal, Z. P. (2014). The backbone of bipartite projections: Inferring relationships from co-authorship, co-sponsorship, co-attendance and other co-behaviors. <em>Social Networks, 39</em>, 84-97. <a href="https://doi.org/10.1016/j.socnet.2014.06.001">doi:10.1016/j.socnet.2014.06.001</a>
</p>
<p>logit model with constraints: Neal, Z. P. and Neal, J. W. (2024). Stochastic Degree Sequence Model with Edge Constraints (SDSM-EC) for Backbone Extraction. <em>Proceedings of the 12th International Conference on Complex Networks and their Applications</em>. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(0,0,1,0,1,0,1,0,1),3,3)  #A binary matrix
logit(M)
M &lt;- matrix(c(0,10,1,0,1,0,1,0,11),3,3)  #A binary matrix with structural values
logit(M)
</code></pre>

<hr>
<h2 id='loglikelihood_bicm'>Computes the loglikelihood for the <a href="#topic+bicm">bicm</a> function</h2><span id='topic+loglikelihood_bicm'></span>

<h3>Description</h3>

<p>Computes the loglikelihood for the <a href="#topic+bicm">bicm</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood_bicm(x0, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood_bicm_+3A_x0">x0</code></td>
<td>
<p>vector, probabilities given by current step in bicm function</p>
</td></tr>
<tr><td><code id="loglikelihood_bicm_+3A_args">args</code></td>
<td>
<p>list, c(degree sequence of rows, degree sequence of cols, multiplicity of rows, multiplicity of columns)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>loglikelihood, numeric
</p>

<hr>
<h2 id='loglikelihood_hessian_diag_bicm'>Computes the loglikelihood hessian for the <a href="#topic+bicm">bicm</a> function</h2><span id='topic+loglikelihood_hessian_diag_bicm'></span>

<h3>Description</h3>

<p>Computes the loglikelihood hessian for the <a href="#topic+bicm">bicm</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood_hessian_diag_bicm(x0, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood_hessian_diag_bicm_+3A_x0">x0</code></td>
<td>
<p>vector, probabilities given by current step in bicm function</p>
</td></tr>
<tr><td><code id="loglikelihood_hessian_diag_bicm_+3A_args">args</code></td>
<td>
<p>list, c(degree sequence of rows, degree sequence of cols, multiplicity of rows, multiplicity of columns)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hessian matrix
</p>

<hr>
<h2 id='loglikelihood_prime_bicm'>Computes the loglikelihood gradient for the <a href="#topic+bicm">bicm</a> function</h2><span id='topic+loglikelihood_prime_bicm'></span>

<h3>Description</h3>

<p>Computes the loglikelihood gradient for the <a href="#topic+bicm">bicm</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood_prime_bicm(x0, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood_prime_bicm_+3A_x0">x0</code></td>
<td>
<p>vector, probabilities given by current step in bicm function</p>
</td></tr>
<tr><td><code id="loglikelihood_prime_bicm_+3A_args">args</code></td>
<td>
<p>list, c(degree sequence of rows, degree sequence of cols, multiplicity of rows, multiplicity of columns)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>loglikelihood
</p>

<hr>
<h2 id='mlf'>Extract backbone using the Marginal Likelihood Filter</h2><span id='topic+mlf'></span>

<h3>Description</h3>

<p><code>mlf</code> extracts the backbone of a weighted network using the Marginal Likelihood Filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlf(
  W,
  alpha = 0.05,
  missing.as.zero = FALSE,
  signed = FALSE,
  mtc = "none",
  class = "original",
  narrative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlf_+3A_w">W</code></td>
<td>
<p>An integer-weighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a three-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="mlf_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="mlf_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="mlf_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="mlf_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="mlf_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>W</code>.</p>
</td></tr>
<tr><td><code id="mlf_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mlf</code> function applies the marginal likelihood filter (MLF; Dianati, 2016), which compares an edge's weight to
its expected weight in a graph that preserves the total weight and preserves the degree sequence <em>on average</em>.
The graph may be directed or undirected, however the edge weights must be positive integers.
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>
<p>If <code>W</code> is an unweighted bipartite graph, then the MLF is applied to its weighted bipartite projection.
</p>


<h3>Value</h3>

<p>If <code>alpha</code> != NULL: Binary or signed backbone graph of class <code>class</code>.
</p>
<p>If <code>alpha</code> == NULL: An S3 backbone object containing (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model, from which a backbone can subsequently be extracted
using <code><a href="#topic+backbone.extract">backbone.extract()</a></code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>mlf: Dianati, N. (2016). Unwinding the hairball graph: Pruning algorithms for weighted complex networks. <em>Physical Review E, 93</em>, 012304. <a href="https://doi.org/10.1103/PhysRevE.93.012304">doi:10.1103/PhysRevE.93.012304</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A network with heterogeneous weights
net &lt;- matrix(c(0,10,10,10,10,75,0,0,0,0,
                10,0,1,1,1,0,0,0,0,0,
                10,1,0,1,1,0,0,0,0,0,
                10,1,1,0,1,0,0,0,0,0,
                10,1,1,1,0,0,0,0,0,0,
                75,0,0,0,0,0,100,100,100,100,
                0,0,0,0,0,100,0,10,10,10,
                0,0,0,0,0,100,10,0,10,10,
                0,0,0,0,0,100,10,10,0,10,
                0,0,0,0,0,100,10,10,10,0),10)

net &lt;- igraph::graph_from_adjacency_matrix(net, mode = "undirected", weighted = TRUE)
plot(net, edge.width = sqrt(igraph::E(net)$weight)) #A stronger clique &amp; a weaker clique

strong &lt;- igraph::delete_edges(net, which(igraph::E(net)$weight &lt; mean(igraph::E(net)$weight)))
plot(strong) #A backbone of stronger-than-average edges ignores the weaker clique

bb &lt;- mlf(net, alpha = 0.05, narrative = TRUE) #An MLF backbone...
plot(bb) #...preserves edges at multiple scales
</code></pre>

<hr>
<h2 id='osdsm'>Extract backbone using the Ordinal Stochastic Degree Sequence Model</h2><span id='topic+osdsm'></span>

<h3>Description</h3>

<p><code>osdsm</code> extracts the backbone of a bipartite projection using the Ordinal Stochastic Degree Sequence Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osdsm(
  B,
  alpha = 0.05,
  trials = NULL,
  missing.as.zero = FALSE,
  signed = FALSE,
  mtc = "none",
  class = "original",
  narrative = FALSE,
  progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osdsm_+3A_b">B</code></td>
<td>
<p>An ordinally weighted bipartite graph, as: (1) an incidence matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a three-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="osdsm_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="osdsm_+3A_trials">trials</code></td>
<td>
<p>integer: the number of bipartite graphs generated to approximate the edge weight distribution. If NULL, the number of trials is selected based on <code>alpha</code> (see details)</p>
</td></tr>
<tr><td><code id="osdsm_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="osdsm_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="osdsm_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="osdsm_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>B</code>.</p>
</td></tr>
<tr><td><code id="osdsm_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
<tr><td><code id="osdsm_+3A_progress">progress</code></td>
<td>
<p>boolean: TRUE if the progress of Monte Carlo trials should be displayed.</p>
</td></tr>
<tr><td><code id="osdsm_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>osdsm</code> function compares an edge's observed weight in the projection <code>B*t(B)</code> to the distribution of weights
expected in a projection obtained from a random bipartite network where both the rows and the columns contain
approximately the same number of each value. The edges in <code>B</code> must be integers, and are assumed to represent an
ordinal-level measure such as a Likert scale that starts at 0.
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>
<p>The p-values used to evaluate the statistical significance of each edge are computed using Monte Carlo methods. The number of
<code>trials</code> performed affects the precision of these p-values. This precision impacts the confidence that a given edge's p-value
is less than the desired <code>alpha</code> level, and therefore represents a statistically significant edge that should be retained in
the backbone. When <code>trials = NULL</code>, <code><a href="#topic+trials.needed">trials.needed()</a></code> is used to estimate the required number of trials to evaluate the
statistical significance of an edges' p-values.
</p>


<h3>Value</h3>

<p>If <code>alpha</code> != NULL: Binary or signed backbone graph of class <code>class</code>.
</p>
<p>If <code>alpha</code> == NULL: An S3 backbone object containing (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model, from which a backbone can subsequently be extracted
using <code><a href="#topic+backbone.extract">backbone.extract()</a></code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>osdsm: Neal, Z. P. (2017). Well connected compared to what? Rethinking frames of reference in world city network research. <em>Environment and Planning A, 49</em>, 2859-2877. <a href="https://doi.org/10.1177/0308518X16631339">doi:10.1177/0308518X16631339</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A weighted binary bipartite network of 20 agents &amp; 50 artifacts; agents form two communities
B &lt;- rbind(cbind(matrix(sample(0:3, 250, replace = TRUE, prob = ((1:4)^2)),10),
                 matrix(sample(0:3, 250, replace = TRUE, prob = ((4:1)^2)),10)),
           cbind(matrix(sample(0:3, 250, replace = TRUE, prob = ((4:1)^2)),10),
                 matrix(sample(0:3, 250, replace = TRUE, prob = ((1:4)^2)),10)))

P &lt;- B%*%t(B) #An ordinary weighted projection...
plot(igraph::graph_from_adjacency_matrix(P, mode = "undirected",
                                         weighted = TRUE, diag = FALSE)) #...is a dense hairball

bb &lt;- osdsm(B, alpha = 0.05, narrative = TRUE,  #An oSDSM backbone...
            class = "igraph", trials = 100)
plot(bb) #...is sparse with clear communities
</code></pre>

<hr>
<h2 id='pb'>Poisson binomial distribution function</h2><span id='topic+pb'></span>

<h3>Description</h3>

<p><code>pb</code> computes the poisson binomial distribution function using the refined normal approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pb(k, p, lowertail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pb_+3A_k">k</code></td>
<td>
<p>numeric: value where the pdf should be evaluated</p>
</td></tr>
<tr><td><code id="pb_+3A_p">p</code></td>
<td>
<p>vector: vector of success probabilities</p>
</td></tr>
<tr><td><code id="pb_+3A_lowertail">lowertail</code></td>
<td>
<p>boolean: If TRUE return both upper &amp; lower tail probabilities,
if FALSE return only upper tail probability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Refined Normal Approximation (RNA) offers a close approximation when <code>length(p)</code> is
large (Hong, 2013).
</p>


<h3>Value</h3>

<p>vector, length 2: The first value (if lower = TRUE) is the lower tail probability, the
probability of observing <code>k</code> or fewer successes when each trial has probability <code>p</code> of success.
The second value is the upper tail probability, the probability of observing <code>k</code> or more
successes when each trial has probability <code>p</code> of success.
</p>


<h3>References</h3>

<p>Hong, Y. (2013). On computing the distribution function for the Poisson binomial distribution. <em>Computational Statistics and Data Analysis, 59</em>, 41-51. <a href="https://doi.org/10.1016/j.csda.2012.10.006">doi:10.1016/j.csda.2012.10.006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pb(50,runif(100))
</code></pre>

<hr>
<h2 id='sdsm'>Extract backbone using the Stochastic Degree Sequence Model</h2><span id='topic+sdsm'></span>

<h3>Description</h3>

<p><code>sdsm</code> extracts the backbone of a bipartite projection using the Stochastic Degree Sequence Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdsm(
  B,
  alpha = 0.05,
  missing.as.zero = FALSE,
  signed = FALSE,
  mtc = "none",
  class = "original",
  narrative = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdsm_+3A_b">B</code></td>
<td>
<p>An unweighted bipartite graph, as: (1) an incidence matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sdsm_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="sdsm_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="sdsm_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone (see details)</p>
</td></tr>
<tr><td><code id="sdsm_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="sdsm_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>B</code>.</p>
</td></tr>
<tr><td><code id="sdsm_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
<tr><td><code id="sdsm_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sdsm</code> function compares an edge's observed weight in the projection <code>B*t(B)</code> to the distribution of weights
expected in a projection obtained from a random bipartite network where both the row vertex degrees and column
vertex degrees are <em>approximately</em> fixed at their values in <code>B</code>.
</p>
<p>When <code>signed = FALSE</code>, a one-tailed test (is the weight stronger?) is performed for each edge. The resulting backbone
contains edges whose weights are significantly <em>stronger</em> than expected in the null model. When <code>signed = TRUE</code>, a
two-tailed test (is the weight stronger or weaker?) is performed for each edge. The resulting backbone contains
positive edges for those whose weights are significantly <em>stronger</em>, and negative edges for those whose weights are
significantly <em>weaker</em>, than expected in the null model.
</p>
<p>The bipartite network <code>B</code> may contain some edges that are <em>required</em> in the null model (i.e., structural 1s); these edges should
have a weight of 11 (i.e., B_ik = 11). This network may also contain some edges that are <em>prohibited</em> in the null model
(i.e., structural 0s); these edges should have a weight of 10 (i.e., B_ik = 10). When <code>B</code> contains required or prohibited edges,
cellwise probabilities are computed using <a href="#topic+logit">logit</a> following Neal et al. (2024). Otherwise, cellwise probabilities are
computed using the faster and more accurate Bipartite Configuration Model with <a href="#topic+bicm">bicm</a> (Neal et al. 2021).
</p>


<h3>Value</h3>

<p>If <code>alpha</code> != NULL: Binary or signed backbone graph of class <code>class</code>.
</p>
<p>If <code>alpha</code> == NULL: An S3 backbone object containing (1) the weighted graph as a matrix, (2) upper-tail p-values as a
matrix, (3, if <code>signed = TRUE</code>) lower-tail p-values as a matrix, (4, if present) node attributes as a dataframe, and
(5) several properties of the original graph and backbone model, from which a backbone can subsequently be extracted
using <code><a href="#topic+backbone.extract">backbone.extract()</a></code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>sdsm: Neal, Z. P. (2014). The backbone of bipartite projections: Inferring relationships from co-authorship, co-sponsorship, co-attendance, and other co-behaviors. <em>Social Networks, 39</em>, 84-97. <a href="https://doi.org/10.1016/j.socnet.2014.06.001">doi:10.1016/j.socnet.2014.06.001</a>
</p>
<p>bicm: Neal, Z. P., Domagalski, R., and Sagan, B. (2021). Comparing Alternatives to the Fixed Degree Sequence Model for Extracting the Backbone of Bipartite Projections. <em>Scientific Reports, 11</em>, 23929. <a href="https://doi.org/10.1038/s41598-021-03238-3">doi:10.1038/s41598-021-03238-3</a>
</p>
<p>logit: Neal, Z. P. and Neal, J. W. (2024). Stochastic Degree Sequence Model with Edge Constraints (SDSM-EC) for Backbone Extraction. <em>Proceedings of the 12th International Conference on Complex Networks and their Applications</em>. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A binary bipartite network of 30 agents &amp; 75 artifacts; agents form three communities
B &lt;- rbind(cbind(matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10),
                 matrix(rbinom(250,1,.2),10)),
           cbind(matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.2),10),
                 matrix(rbinom(250,1,.8),10)))

P &lt;- B%*%t(B) #An ordinary weighted projection...
plot(igraph::graph_from_adjacency_matrix(P, mode = "undirected",
                                         weighted = TRUE, diag = FALSE)) #...is a dense hairball

bb &lt;- sdsm(B, alpha = 0.05, narrative = TRUE, class = "igraph") #An SDSM backbone...
plot(bb) #...is sparse with clear communities
</code></pre>

<hr>
<h2 id='sparsify'>Extract the backbone from a network using a sparsification model</h2><span id='topic+sparsify'></span>

<h3>Description</h3>

<p>A generic function to extract the backbone of an undirected, unipartite
network using a sparsification model described by a combination of an edge scoring metric, a
edge score normalization, and an edge score filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify(
  U,
  s,
  escore,
  normalize,
  filter,
  symmetrize = TRUE,
  umst = FALSE,
  class = "original",
  narrative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify_+3A_s">s</code></td>
<td>
<p>numeric: Sparsification parameter</p>
</td></tr>
<tr><td><code id="sparsify_+3A_escore">escore</code></td>
<td>
<p>string: Method for scoring edges' importance</p>
</td></tr>
<tr><td><code id="sparsify_+3A_normalize">normalize</code></td>
<td>
<p>string: Method for normalizing edge scores</p>
</td></tr>
<tr><td><code id="sparsify_+3A_filter">filter</code></td>
<td>
<p>string: Type of filter to apply</p>
</td></tr>
<tr><td><code id="sparsify_+3A_symmetrize">symmetrize</code></td>
<td>
<p>boolean: TRUE if the result should be symmetrized</p>
</td></tr>
<tr><td><code id="sparsify_+3A_umst">umst</code></td>
<td>
<p>boolean: TRUE if the backbone should include the union of minimum spanning trees, to ensure connectivity</p>
</td></tr>
<tr><td><code id="sparsify_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>escore</code> parameter determines how an unweighted edge's importance is calculated.
Unless noted below, scores are symmetric and larger values represent more important edges.
</p>

<ul>
<li> <p><code>random</code>: a random number drawn from a uniform distribution
</p>
</li>
<li> <p><code>betweenness</code>: edge betweenness
</p>
</li>
<li> <p><code>triangles</code>: number of triangles that include the edge
</p>
</li>
<li> <p><code>jaccard</code>: jaccard similarity coefficient of the neighborhoods of an edge's endpoints, or alternatively, triangles normalized by the size of the union of the endpoints neighborhoods
</p>
</li>
<li> <p><code>dice</code>: dice similarity coefficient of the neighborhoods of an edge's endpoints
</p>
</li>
<li> <p><code>quadrangles</code>: number of quadrangles that include the edge
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;quadrilateral embeddedness&#8288;</code>: geometric mean normalization of quadrangles
</p>
</li>
<li> <p><code>degree</code>: degree of neighbor to which an edge is adjacent (asymmetric)
</p>
</li>
<li> <p><code>meetmin</code>: triangles normalized by the smaller of the endpoints' neighborhoods' sizes
</p>
</li>
<li> <p><code>geometric</code>: triangles normalized by the product of the endpoints' neighborhoods' sizes
</p>
</li>
<li> <p><code>hypergeometric</code>: probability of the edge being included at least as many triangles if edges were random, given the size of the endpoints' neighborhoods (smaller is more important)
</p>
</li></ul>

<p>The <code>normalize</code> parameter determines whether edge scores are normalized.
</p>

<ul>
<li> <p><code>none</code>: no normalization is performed
</p>
</li>
<li> <p><code>rank</code>: scores are normalized by neighborhood rank, such that the strongest edge in a node's neighborhood is ranked 1 (asymmetric)
</p>
</li>
<li> <p><code>embeddedness</code>: scores are normalized using the maximum Jaccard coefficient of the top k-ranked neighbors of each endpoint, for all k
</p>
</li></ul>

<p>The <code>filter</code> parameter determines how edges are filtered based on their (normalized) edge scores.
</p>

<ul>
<li> <p><code>threshold</code>: Edges with scores &gt;= <code>s</code> are retained in the backbone
</p>
</li>
<li> <p><code>proportion</code>: Specifies the approximate proportion of edges to retain in the backbone
</p>
</li>
<li> <p><code>degree</code>: Retains each node's d^<code>s</code> most important edges, where d is the node's degree (requires that <code>normalize = "rank"</code>)
</p>
</li>
<li> <p><code>disparity</code>: Applies the disparity filter using <code><a href="#topic+disparity">disparity()</a></code>
</p>
</li></ul>

<p>Using <code>escore == "degree"</code> or <code>normalize == "rank"</code> can yield an assymmetric network. When <code>symmetrize == TRUE</code> (default),
after applying a filter, the network is symmetrized by such that i-j if i-&gt;j or i&lt;-j.
</p>
<p>Specific combinations of <code>escore</code>, <code>normalize</code>, <code>filter</code>, and <code>umst</code> correspond to specific sparsification models in the literature, and are available via the following wrapper functions:
<code><a href="#topic+sparsify.with.skeleton">sparsify.with.skeleton()</a></code>, <code><a href="#topic+sparsify.with.gspar">sparsify.with.gspar()</a></code>, <code><a href="#topic+sparsify.with.lspar">sparsify.with.lspar()</a></code>, <code><a href="#topic+sparsify.with.simmelian">sparsify.with.simmelian()</a></code>, <code><a href="#topic+sparsify.with.jaccard">sparsify.with.jaccard()</a></code>, <code><a href="#topic+sparsify.with.meetmin">sparsify.with.meetmin()</a></code>, <code><a href="#topic+sparsify.with.geometric">sparsify.with.geometric()</a></code>, <code><a href="#topic+sparsify.with.hypergeometric">sparsify.with.hypergeometric()</a></code>, <code><a href="#topic+sparsify.with.localdegree">sparsify.with.localdegree()</a></code>, <code><a href="#topic+sparsify.with.quadrilateral">sparsify.with.quadrilateral()</a></code>.
See the documentation for these wrapper functions for more details and the associated citation.
</p>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::sample_sbm(60, matrix(c(.75,.25,.25,.25,.75,.25,.25,.25,.75),3,3), c(20,20,20))
plot(U) #A hairball
sparse &lt;- sparsify(U, s = 0.6, escore = "jaccard", normalize = "rank",
filter = "degree", narrative = TRUE)
plot(sparse) #Clearly visible communities
</code></pre>

<hr>
<h2 id='sparsify.with.geometric'>Extract Goldberg and Roth's (2003) Geometric backbone</h2><span id='topic+sparsify.with.geometric'></span>

<h3>Description</h3>

<p><code>sparsify.with.geometric</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the geometric backbone described by Goldberg and Roth (2003).
It is equivalent to <code>sparsify(escore = "geometric", normalize = "none", filter = "threshold", umst = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.geometric(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.geometric_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.geometric_+3A_s">s</code></td>
<td>
<p>numeric: Sparsificiation threshold, 0 &lt; s &lt; 1; larger values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.geometric_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.geometric_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Goldberg, D. S., &amp; Roth, F. P. (2003). Assessing experimentally derived interactions in a small world. <em>Proceedings of the National Academy of Sciences, 100</em>, 4372-4376. <a href="https://doi.org/10.1073/pnas.0735871100">doi:10.1073/pnas.0735871100</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::sample_sbm(60, matrix(c(.75,.25,.25,.25,.75,.25,.25,.25,.75),3,3), c(20,20,20))
plot(U) #A hairball
sparse &lt;- sparsify.with.geometric(U, s = 0.25, narrative = TRUE)
plot(sparse) #Clearly visible communities
</code></pre>

<hr>
<h2 id='sparsify.with.gspar'>Extract Satuluri et al's (2011) G-spar backbone</h2><span id='topic+sparsify.with.gspar'></span>

<h3>Description</h3>

<p><code>sparsify.with.gspar</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the G-spar backbone described by Satuluri et al. (2011).
It is equivalent to <code>sparsify(escore = "jaccard", normalize = "none", filter = "proportion", umst = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.gspar(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.gspar_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.gspar_+3A_s">s</code></td>
<td>
<p>numeric: Proportion of edges to retain, 0 &lt; s &lt; 1; smaller values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.gspar_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.gspar_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Satuluri, V., Parthasarathy, S., &amp; Ruan, Y. (2011, June). Local graph sparsification for scalable clustering. In Proceedings of the 2011 ACM SIGMOD International Conference on Management of data (pp. 721-732). <a href="https://doi.org/10.1145/1989323.1989399">doi:10.1145/1989323.1989399</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::sample_sbm(60, matrix(c(.75,.25,.25,.25,.75,.25,.25,.25,.75),3,3), c(20,20,20))
plot(U) #A hairball
sparse &lt;- sparsify.with.gspar(U, s = 0.4, narrative = TRUE)
plot(sparse) #Clearly visible communities
</code></pre>

<hr>
<h2 id='sparsify.with.hypergeometric'>Extract Goldberg and Roth's (2003) Hypergeometric backbone</h2><span id='topic+sparsify.with.hypergeometric'></span>

<h3>Description</h3>

<p><code>sparsify.with.hypergeometric</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the hypergeometric backbone described by Goldberg and Roth (2003).
It is equivalent to <code>sparsify(escore = "hypergeometric", normalize = "none", filter = "threshold", umst = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.hypergeometric(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.hypergeometric_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.hypergeometric_+3A_s">s</code></td>
<td>
<p>numeric: Sparsificiation threshold, 0 &lt; s &lt; 1; smaller values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.hypergeometric_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.hypergeometric_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Goldberg, D. S., &amp; Roth, F. P. (2003). Assessing experimentally derived interactions in a small world. <em>Proceedings of the National Academy of Sciences, 100</em>, 4372-4376. <a href="https://doi.org/10.1073/pnas.0735871100">doi:10.1073/pnas.0735871100</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::sample_sbm(60, matrix(c(.75,.25,.25,.25,.75,.25,.25,.25,.75),3,3), c(20,20,20))
plot(U) #A hairball
sparse &lt;- sparsify.with.hypergeometric(U, s = 0.3, narrative = TRUE)
plot(sparse) #Clearly visible communities
</code></pre>

<hr>
<h2 id='sparsify.with.jaccard'>Extract Goldberg and Roth's (2003) Jaccard backbone</h2><span id='topic+sparsify.with.jaccard'></span>

<h3>Description</h3>

<p><code>sparsify.with.jaccard</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the jaccard backbone described by Goldberg and Roth (2003).
It is equivalent to <code>sparsify(escore = "jaccard", normalize = "none", filter = "threshold", umst = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.jaccard(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.jaccard_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.jaccard_+3A_s">s</code></td>
<td>
<p>numeric: Sparsificiation threshold, 0 &lt; s &lt; 1; larger values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.jaccard_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.jaccard_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Goldberg, D. S., &amp; Roth, F. P. (2003). Assessing experimentally derived interactions in a small world. <em>Proceedings of the National Academy of Sciences, 100</em>, 4372-4376. <a href="https://doi.org/10.1073/pnas.0735871100">doi:10.1073/pnas.0735871100</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::sample_sbm(60, matrix(c(.75,.25,.25,.25,.75,.25,.25,.25,.75),3,3), c(20,20,20))
plot(U) #A hairball
sparse &lt;- sparsify.with.jaccard(U, s = 0.3, narrative = TRUE)
plot(sparse) #Clearly visible communities
</code></pre>

<hr>
<h2 id='sparsify.with.localdegree'>Extract Hamann et al.'s (2016) Local Degree backbone</h2><span id='topic+sparsify.with.localdegree'></span>

<h3>Description</h3>

<p><code>sparsify.with.localdegree</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the local degree backbone described by Hamann et al. (2016).
It is equivalent to <code>sparsify(escore = "degree", normalize = "rank", filter = "degree", umst = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.localdegree(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.localdegree_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.localdegree_+3A_s">s</code></td>
<td>
<p>numeric: Sparsification exponent, 0 &lt; s &lt; 1; smaller values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.localdegree_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.localdegree_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Hamann, M., Lindner, G., Meyerhenke, H., Staudt, C. L., &amp; Wagner, D. (2016). Structure-preserving sparsification methods for social networks. <em>Social Network Analysis and Mining, 6</em>, 22. <a href="https://doi.org/10.1007/s13278-016-0332-2">doi:10.1007/s13278-016-0332-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::as.undirected(igraph::sample_pa(60, m = 3), mode = "collapse")
plot(U) #A hairball
sparse &lt;- sparsify.with.localdegree(U, s = 0.3, narrative = TRUE)
plot(sparse) #Clearly visible hubs
</code></pre>

<hr>
<h2 id='sparsify.with.lspar'>Extract Satuluri et al's (2011) L-spar backbone</h2><span id='topic+sparsify.with.lspar'></span>

<h3>Description</h3>

<p><code>sparsify.with.lspar</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the L-spar backbone described by Satuluri et al. (2011).
It is equivalent to <code>sparsify(escore = "jaccard", normalize = "rank", filter = "degree", umst = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.lspar(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.lspar_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.lspar_+3A_s">s</code></td>
<td>
<p>numeric: Sparsification exponent, 0 &lt; s &lt; 1; smaller values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.lspar_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.lspar_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Satuluri, V., Parthasarathy, S., &amp; Ruan, Y. (2011, June). Local graph sparsification for scalable clustering. In Proceedings of the 2011 ACM SIGMOD International Conference on Management of data (pp. 721-732). <a href="https://doi.org/10.1145/1989323.1989399">doi:10.1145/1989323.1989399</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::sample_sbm(60, matrix(c(.75,.25,.25,.25,.75,.25,.25,.25,.75),3,3), c(20,20,20))
plot(U) #A hairball
sparse &lt;- sparsify.with.lspar(U, s = 0.6, narrative = TRUE)
plot(sparse) #Clearly visible communities
</code></pre>

<hr>
<h2 id='sparsify.with.meetmin'>Extract Goldberg and Roth's (2003) MeetMin backbone</h2><span id='topic+sparsify.with.meetmin'></span>

<h3>Description</h3>

<p><code>sparsify.with.meetmin</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the meetmin backbone described by Goldberg and Roth (2003).
It is equivalent to <code>sparsify(escore = "meetmin", normalize = "none", filter = "threshold", umst = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.meetmin(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.meetmin_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.meetmin_+3A_s">s</code></td>
<td>
<p>numeric: Sparsificiation threshold, 0 &lt; s &lt; 1; larger values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.meetmin_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.meetmin_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Goldberg, D. S., &amp; Roth, F. P. (2003). Assessing experimentally derived interactions in a small world. <em>Proceedings of the National Academy of Sciences, 100</em>, 4372-4376. <a href="https://doi.org/10.1073/pnas.0735871100">doi:10.1073/pnas.0735871100</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::sample_sbm(60, matrix(c(.75,.25,.25,.25,.75,.25,.25,.25,.75),3,3), c(20,20,20))
plot(U) #A hairball
sparse &lt;- sparsify.with.meetmin(U, s = 0.5, narrative = TRUE)
plot(sparse) #Clearly visible communities
</code></pre>

<hr>
<h2 id='sparsify.with.quadrilateral'>Extract Nocaj et al.'s (2015) Quadrilateral Simmelian backbone</h2><span id='topic+sparsify.with.quadrilateral'></span>

<h3>Description</h3>

<p><code>sparsify.with.quadrilateral</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the quadrilateral Simmelian backbone described by Nocaj et al. (2015).
It is equivalent to <code>sparsify(escore = "quadrilateral embeddedness", normalize = "embeddedness", filter = "threshold", umst = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.quadrilateral(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.quadrilateral_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.quadrilateral_+3A_s">s</code></td>
<td>
<p>numeric: Sparsification exponent, 0 &lt; s &lt; 1; larger values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.quadrilateral_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.quadrilateral_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Nocaj, A., Ortmann, M., &amp; Brandes, U. (2015). Untangling the hairballs of multi-centered, small-world online social media networks. <em>Journal of Graph Algorithms and Applications, 19</em>, 595-618. <a href="https://doi.org/10.7155/jgaa.00370">doi:10.7155/jgaa.00370</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::sample_sbm(60, matrix(c(.75,.25,.25,.25,.75,.25,.25,.25,.75),3,3), c(20,20,20))
plot(U) #A hairball
sparse &lt;- sparsify.with.quadrilateral(U, s = 0.5, narrative = TRUE)
plot(sparse) #Clearly visible communities in a connected graph
</code></pre>

<hr>
<h2 id='sparsify.with.simmelian'>Extract Nick et al's (2013) Simmelian backbone</h2><span id='topic+sparsify.with.simmelian'></span>

<h3>Description</h3>

<p><code>sparsify.with.simmelian</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the simmelian backbone described by Nick et al. (2013).
It is equivalent to <code>sparsify(escore = "triangles", normalize = "embeddedness", filter = "threshold", umst = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.simmelian(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.simmelian_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.simmelian_+3A_s">s</code></td>
<td>
<p>numeric: Sparsificiation threshold, 0 &lt; s &lt; 1; larger values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.simmelian_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.simmelian_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Nick, B., Lee, C., Cunningham, P., &amp; Brandes, U. (2013, August). Simmelian backbones: Amplifying hidden homophily in facebook networks. In Proceedings of the 2013 IEEE/ACM international conference on advances in social networks analysis and mining (pp. 525-532). <a href="https://doi.org/10.1145/2492517.2492569">doi:10.1145/2492517.2492569</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::sample_sbm(60, matrix(c(.75,.25,.25,.25,.75,.25,.25,.25,.75),3,3), c(20,20,20))
plot(U) #A hairball
sparse &lt;- sparsify.with.simmelian(U, s = 0.5, narrative = TRUE)
plot(sparse) #Clearly visible communities
</code></pre>

<hr>
<h2 id='sparsify.with.skeleton'>Extract Karger's (1999) skeleton backbone</h2><span id='topic+sparsify.with.skeleton'></span>

<h3>Description</h3>

<p><code>sparsify.with.skeleton</code> is a wrapper for <code><a href="#topic+sparsify">sparsify()</a></code> that extracts the skeleton backbone described by Karger (1999),
which preserves a specified proportion of random edges. It is equivalent to <code>sparsify(escore = "random", normalize = "none", filter = "proportion", umst = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify.with.skeleton(U, s, class = "original", narrative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify.with.skeleton_+3A_u">U</code></td>
<td>
<p>An unweighted unipartite graph, as: (1) an adjacency matrix in the form of a matrix or sparse <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>; (2) an edgelist in the form of a two-column dataframe; (3) an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="sparsify.with.skeleton_+3A_s">s</code></td>
<td>
<p>numeric: Proportion of edges to retain, 0 &lt; s &lt; 1; smaller values yield sparser graphs</p>
</td></tr>
<tr><td><code id="sparsify.with.skeleton_+3A_class">class</code></td>
<td>
<p>string: the class of the returned backbone graph, one of c(&quot;original&quot;, &quot;matrix&quot;, &quot;Matrix&quot;, &quot;igraph&quot;, &quot;edgelist&quot;).
If &quot;original&quot;, the backbone graph returned is of the same class as <code>U</code>.</p>
</td></tr>
<tr><td><code id="sparsify.with.skeleton_+3A_narrative">narrative</code></td>
<td>
<p>boolean: TRUE if suggested text &amp; citations should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted, undirected, unipartite graph of class <code>class</code>.
</p>


<h3>References</h3>

<p>package: Neal, Z. P. (2022). backbone: An R Package to Extract Network Backbones. <em>PLOS ONE, 17</em>, e0269137. <a href="https://doi.org/10.1371/journal.pone.0269137">doi:10.1371/journal.pone.0269137</a>
</p>
<p>model: Karger, D. R. (1999). Random sampling in cut, flow, and network design problems. <em>Mathematics of Operations Research, 24</em>, 383-413. <a href="https://doi.org/10.1287/moor.24.2.383">doi:10.1287/moor.24.2.383</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- igraph::erdos.renyi.game(60, .5)
plot(U) #A dense graph
sparse &lt;- sparsify.with.skeleton(U, s = 0.25, narrative = TRUE)
plot(sparse) #A sparser graph
</code></pre>

<hr>
<h2 id='tomatrix'>Converts an input graph object to an adjacency/incidence matrix and identifies its characteristics</h2><span id='topic+tomatrix'></span>

<h3>Description</h3>

<p>Converts an input graph object to an adjacency/incidence matrix and identifies its characteristics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tomatrix(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tomatrix_+3A_graph">graph</code></td>
<td>
<p>A graph object of class &quot;matrix&quot;, &quot;Matrix&quot;, &quot;dataframe&quot;, <a href="igraph.html#topic+igraph">igraph</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list(summary, G, attribs)
<code>summary</code> is a dataframe containing characteristics of the supplied object
<code>G</code> is an adjacency/incidence matrix
<code>attribs</code> is a dataframe containing vertex attributes (if present in <code>graph</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(rbinom(5*5,1,.5),5,5)
test &lt;- backbone:::tomatrix(M)
</code></pre>

<hr>
<h2 id='trials.needed'>Estimate number of monte carlo trials needed to estimate p-value</h2><span id='topic+trials.needed'></span>

<h3>Description</h3>

<p><code>trials.needed</code> estimates the number of monte carlo trials needed to estimate edgewise p-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trials.needed(M, alpha, signed, missing.as.zero, mtc, how.close = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trials.needed_+3A_m">M</code></td>
<td>
<p>matrix: An adjacency matrix representing a network from which a backbone is is being extracted</p>
</td></tr>
<tr><td><code id="trials.needed_+3A_alpha">alpha</code></td>
<td>
<p>real: significance level of hypothesis test(s)</p>
</td></tr>
<tr><td><code id="trials.needed_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE for a signed backbone, FALSE for a binary backbone</p>
</td></tr>
<tr><td><code id="trials.needed_+3A_missing.as.zero">missing.as.zero</code></td>
<td>
<p>boolean: should missing edges be treated as edges with zero weight and tested for significance</p>
</td></tr>
<tr><td><code id="trials.needed_+3A_mtc">mtc</code></td>
<td>
<p>string: type of Multiple Test Correction to be applied; can be any method allowed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="trials.needed_+3A_how.close">how.close</code></td>
<td>
<p>real: How close can the empirical p-value be to alpha and still be distinguishable, expressed as a proportion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>

<hr>
<h2 id='write.narrative'>Generates suggested manuscript text</h2><span id='topic+write.narrative'></span>

<h3>Description</h3>

<p><code>write.narrative</code> displays suggested text and references that can be used in a manuscript to describe the extracted backbone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.narrative(
  agents = 0,
  artifacts = 0,
  weighted = FALSE,
  bipartite = FALSE,
  symmetric = FALSE,
  signed = FALSE,
  mtc = "none",
  alpha = NULL,
  s = NULL,
  ut = NULL,
  lt = NULL,
  trials = 0,
  escore = NULL,
  normalize = NULL,
  filter = NULL,
  umst = NULL,
  model = "",
  reduced_edges = NULL,
  reduced_nodes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.narrative_+3A_agents">agents</code></td>
<td>
<p>integer: number of agents in a bipartite graph, or nodes in a unipartite graph</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_artifacts">artifacts</code></td>
<td>
<p>integer: number of artifacts in a bipartite graph</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_weighted">weighted</code></td>
<td>
<p>boolean: TRUE if input graph was weighted</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_bipartite">bipartite</code></td>
<td>
<p>boolean: TRUE if input graph was bipartite</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_symmetric">symmetric</code></td>
<td>
<p>boolean: TRUE if input graph was symmetric</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_signed">signed</code></td>
<td>
<p>boolean: TRUE if a signed backbone was requested</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_mtc">mtc</code></td>
<td>
<p>string: type of multiple test correction</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_alpha">alpha</code></td>
<td>
<p>numeric: alpha significance threshold (used in statistical models)</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_s">s</code></td>
<td>
<p>numeric: sparsification parameter (used in sparsification models)</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_ut">ut</code></td>
<td>
<p>numeric: upper threshold (used in global threshold)</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_lt">lt</code></td>
<td>
<p>numeric: lower threshold (used in global threshold)</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_trials">trials</code></td>
<td>
<p>integer: number of trials used to estimate FDSM or oSDSM p-values</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_escore">escore</code></td>
<td>
<p>string: Method for scoring edges' importance</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_normalize">normalize</code></td>
<td>
<p>string: Method for normalizing edge scores</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_filter">filter</code></td>
<td>
<p>string: Type of filter to apply</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_umst">umst</code></td>
<td>
<p>boolean: TRUE if the backbone should include the union of minimum spanning trees, to ensure connectivity</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_model">model</code></td>
<td>
<p>string: name of backbone model</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_reduced_edges">reduced_edges</code></td>
<td>
<p>numeric: percent reduction in number of edges</p>
</td></tr>
<tr><td><code id="write.narrative_+3A_reduced_nodes">reduced_nodes</code></td>
<td>
<p>numeric: percent reduction in number of connected nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL; only displays text in the console
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
