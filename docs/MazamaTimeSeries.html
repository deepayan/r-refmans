<!DOCTYPE html><html><head><title>Help for package MazamaTimeSeries</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MazamaTimeSeries}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.flagOutliers'><p>Flag outliers in vectorized data</p></a></li>
<li><a href='#.sample'><p>General table row sampling</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#Camp_Fire'><p>Camp Fire example dataset</p></a></li>
<li><a href='#Carmel_Valley'><p>Carmel Valley example dataset</p></a></li>
<li><a href='#example_mts'><p>Example <em>mts</em> dataset</p></a></li>
<li><a href='#example_raws'><p>Example RAWS dataset</p></a></li>
<li><a href='#example_sts'><p>Example <em>sts</em> dataset</p></a></li>
<li><a href='#MazamaTimeSeries'><p>Core functionality for environmental time series</p></a></li>
<li><a href='#mts_arrange'><p>Order <em>mts</em> time series by metadata values</p></a></li>
<li><a href='#mts_check'><p>Check <em>mts</em> object for validity</p></a></li>
<li><a href='#mts_collapse'><p>Collapse an <em>mts</em> time series object into a single time series</p></a></li>
<li><a href='#mts_combine'><p>Combine multiple <em>mts</em> time series objects</p></a></li>
<li><a href='#mts_distinct'><p>Retain only distinct data records in <code>mts$data</code></p></a></li>
<li><a href='#mts_extractDataFrame'><p>Extract dataframes from <em>mts</em> objects</p></a></li>
<li><a href='#mts_filterData'><p>General purpose data filtering for <em>mts</em> time series objects</p></a></li>
<li><a href='#mts_filterDate'><p>Date filtering for <em>mts</em> time series objects</p></a></li>
<li><a href='#mts_filterDatetime'><p>Datetime filtering for <em>mts</em> time series objects</p></a></li>
<li><a href='#mts_filterMeta'><p>General purpose metadata filtering for <em>mts</em> time series objects</p></a></li>
<li><a href='#mts_getDistance'><p>Calculate distances from <em>mts</em> time series locations to a location of interest</p></a></li>
<li><a href='#mts_isEmpty'><p>Test for an empty <em>mts</em> object</p></a></li>
<li><a href='#mts_isValid'><p>Test <em>mts</em> object for correct structure</p></a></li>
<li><a href='#mts_pull'><p>Extract a column of metadata or data</p></a></li>
<li><a href='#mts_sample'><p>Sample time series for an <em>mts</em> time series object</p></a></li>
<li><a href='#mts_select'><p>Reorder and subset time series within an <em>mts</em> time series object</p></a></li>
<li><a href='#mts_selectWhere'><p>Data-based subsetting of time series within an <em>mts</em> object.</p></a></li>
<li><a href='#mts_setTimeAxis'><p>Extend/contract <em>mts</em> time series to new start and end times</p></a></li>
<li><a href='#mts_slice_head'><p>Subset time series based on their position</p></a></li>
<li><a href='#mts_summarize'><p>Create summary time series for an <em>mts</em> time series object</p></a></li>
<li><a href='#mts_trim'><p>Trim <em>mts</em> time series by removing missing values</p></a></li>
<li><a href='#mts_trimDate'><p>Trim <em>mts</em> time series object to full days</p></a></li>
<li><a href='#requiredMetaNames'><p>Required columns for the 'meta' dataframe</p></a></li>
<li><a href='#sts_check'><p>Check <em>sts</em> object for validity</p></a></li>
<li><a href='#sts_combine'><p>Combine multiple <em>sts</em> time series objects</p></a></li>
<li><a href='#sts_distinct'><p>Retain only distinct data records in <code>sts$data</code></p></a></li>
<li><a href='#sts_extractDataFrame'><p>Extract dataframes from <em>sts</em> objects</p></a></li>
<li><a href='#sts_filter'><p>General purpose data filtering for <em>sts</em> time series objects</p></a></li>
<li><a href='#sts_filterDate'><p>Date filtering for <em>sts</em> time series objects</p></a></li>
<li><a href='#sts_filterDatetime'><p>Datetime filtering for <em>sts</em> time series objects</p></a></li>
<li><a href='#sts_isEmpty'><p>Test for empty <em>sts</em> object</p></a></li>
<li><a href='#sts_isValid'><p>Test <em>sts</em> object for correct structure</p></a></li>
<li><a href='#sts_summarize'><p>Create summary time series for an <em>sts</em> time series object</p></a></li>
<li><a href='#sts_trimDate'><p>Trim <em>sts</em> time series object to full days</p></a></li>
<li><a href='#timeInfo'><p>Get time related information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Core Functionality for Environmental Time Series</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Callahan &lt;jonathan.s.callahan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Utility functions for working with environmental time series data from known 
    locations. The compact data model is structured as a list with two dataframes. A 
    'meta' dataframe contains spatial and measuring device metadata associated with 
    deployments at known locations. A 'data' dataframe contains a 'datetime' column 
    followed by columns of measurements associated with each "device-deployment".
    Ephemerides calculations are based on code originally found in NOAA's
    "Solar Calculator" <a href="https://gml.noaa.gov/grad/solcalc/">https://gml.noaa.gov/grad/solcalc/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MazamaScience/MazamaTimeSeries">https://github.com/MazamaScience/MazamaTimeSeries</a>,
<a href="https://mazamascience.github.io/MazamaTimeSeries/">https://mazamascience.github.io/MazamaTimeSeries/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MazamaScience/MazamaTimeSeries/issues">https://github.com/MazamaScience/MazamaTimeSeries/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, geodist, lubridate, magrittr, methods, MazamaCoreUtils
(&ge; 0.5.2), MazamaRollUtils (&ge; 0.1.3), rlang, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, testthat (&ge; 2.1.0), rmarkdown, roxygen2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 23:25:28 UTC; jonathancallahan</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Callahan [aut, cre],
  Hans Martin [ctb],
  Eli Grosman [ctb],
  Roger Bivand [ctb],
  Sebastian Luque [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-08 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.flagOutliers'>Flag outliers in vectorized data</h2><span id='topic+.flagOutliers'></span>

<h3>Description</h3>

<p>This function uses Hampel filter outlier detection to flag
outliers in <code>parameter</code> column of the incoming dataframe. The
<code>width</code> and <code>thresholdMin</code> parameters as passed on to the
<code><a href="MazamaRollUtils.html#topic+findOutliers">findOutliers</a></code> function.
</p>
<p>An additional boolean column named <code>&lt;parameter&gt;_outlierFlag</code> is added
to the dataframe. This column will have <code>TRUE</code> whenever an outlier is
detected for the chosen <code>parameter</code>.
</p>
<p>See <code><a href="MazamaRollUtils.html#topic+findOutliers">findOutliers</a></code> for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.flagOutliers(df = NULL, parameter = NULL, width = 23, thresholdMin = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".flagOutliers_+3A_df">df</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id=".flagOutliers_+3A_parameter">parameter</code></td>
<td>
<p>Data frame parameter to use for outlier detection.</p>
</td></tr>
<tr><td><code id=".flagOutliers_+3A_width">width</code></td>
<td>
<p>Width the rolling window.</p>
</td></tr>
<tr><td><code id=".flagOutliers_+3A_thresholdmin">thresholdMin</code></td>
<td>
<p>Minimum threshold value used to detect outliers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with an additional column identifying outliers.
</p>

<hr>
<h2 id='.sample'>General table row sampling</h2><span id='topic+.sample'></span>

<h3>Description</h3>

<p>This is a wrapper around <code><a href="base.html#topic+sample">sample</a></code> to make it
easy to select random rows from a table. Supports either integer
(<code>sampleSize</code>) or fractional (<code>sampleFraction</code>) row sampling.
For reproducible debugging, specify <code>seed</code>.
</p>
<p>If both <code>sampleSize</code> and <code>sampleFraction</code> are specified,
<code>sampleSize</code> takes precedence.
</p>
<p>Specifying <code>sampleSize</code> greater than the number of rows in the
dataframe or <code>sampleFraction &gt; 1</code> will use all rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sample(data, sampleSize = NULL, sampleFraction = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sample_+3A_data">data</code></td>
<td>
<p>Dataframe to be sampled.</p>
</td></tr>
<tr><td><code id=".sample_+3A_samplesize">sampleSize</code></td>
<td>
<p>Non-negative integer giving the number of rows to choose.</p>
</td></tr>
<tr><td><code id=".sample_+3A_samplefraction">sampleFraction</code></td>
<td>
<p>Fraction of rows to sample.</p>
</td></tr>
<tr><td><code id=".sample_+3A_seed">seed</code></td>
<td>
<p>Integer passed to <code><a href="base.html#topic+set.seed">set.seed</a></code> for reproducible sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='Camp_Fire'>Camp Fire example dataset</h2><span id='topic+Camp_Fire'></span>

<h3>Description</h3>

<p>The <code>Camp_Fire</code> dataset provides a quickly loadable
version of a <em>mts_monitor</em> object for practicing and code examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Camp_Fire
</code></pre>


<h3>Format</h3>

<p>A <em>mts</em> object with 360 rows and 134 columns of data.
</p>


<h3>Details</h3>

<p>The 2018 Camp Fire was the deadliest and most destructive wildfire in California's
history, and the most expensive natural disaster in the world in 2018 in
terms of insured losses. The fire caused at least 85 civilian fatalities and
injured 12 civilians and five firefighters. It covered an area of 153,336
acres and destroyed more than 18,000 structures, most with the first 4 hours.
Smoke from the fire resulted in the worst air pollution ever for the
San Francisco Bay Area and Sacramento Valley.
</p>
<p>This dataset was was generated on 2022-10-12 by running:
</p>
<pre>
library(AirMonitor)

Camp_Fire &lt;-
  monitor_loadAnnual(2018) %&gt;%
  monitor_filter(stateCode == 'CA') %&gt;%
  monitor_filterDate(
    startdate = 20181108,
    enddate = 20181123,
    timezone = "America/Los_Angeles"
 ) %&gt;%
 monitor_dropEmpty()

save(Camp_Fire, file = "data/Camp_Fire.rda")
</pre>

<hr>
<h2 id='Carmel_Valley'>Carmel Valley example dataset</h2><span id='topic+Carmel_Valley'></span>

<h3>Description</h3>

<p>The <code>Carmel_Valley</code> dataset provides a quickly loadable
version of a single-sensor <em>mts_monitor</em> object for practicing and code
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Carmel_Valley
</code></pre>


<h3>Format</h3>

<p>An <em>mts</em> object with 600 rows and 2 columns of data.
</p>


<h3>Details</h3>

<p>In August of 2016, the Soberanes fire in California burned along the Big Sur
coast. It was at the time the most expensive wildfire in US history. This
dataset contains PM2.5 monitoring data for the monitor in Carmel Valley which
shows heavy smoke as well as strong diurnal cycles associated with sea
breezes. Data are stored as an <em>mts</em> object and are used in some
examples in the package documentation.
</p>
<p>This dataset was generated on 2022-10-12 by running:
</p>
<pre>
library(AirMonitor)

Carmel_Valley &lt;-
  airnow_loadAnnual(2016) %&gt;%
  monitor_filterMeta(deviceDeploymentID == "a9572a904a4ed46d_840060530002") %&gt;%
  monitor_filterDate(20160722, 20160815)

save(Carmel_Valley, file = "data/Carmel_Valley.rda")
</pre>

<hr>
<h2 id='example_mts'>Example <em>mts</em> dataset</h2><span id='topic+example_mts'></span>

<h3>Description</h3>

<p>The <code>example_mts</code> dataset provides a quickly loadable
version of an <em>mts</em> object for practicing and code examples.
</p>
<p>This dataset was was generated on 2021-10-07 by running:
</p>
<pre>
library(AirSensor)

communities &lt;- c("Alhambra/Monterey Park", "El Monte")

example_mts &lt;-
  example_sensor_scaqmd %&gt;%
  sensor_filterMeta(communityRegion %in% communities)

# Add required "locationName"
example_mts$meta$locationName &lt;- example_mts$meta$siteName

save(example_mts, file = "data/example_mts.rda")
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>example_mts
</code></pre>


<h3>Format</h3>

<p>An <em>mts</em> object composed of &quot;meta&quot; and &quot;data&quot; dataframes.
</p>

<hr>
<h2 id='example_raws'>Example RAWS dataset</h2><span id='topic+example_raws'></span>

<h3>Description</h3>

<p>The <code>example_raws</code> dataset provides a quickly loadable
example of the data generated by the **RAWSmet** package. This data is a
<code>sts</code> object containing hourly measurements from a RAWS weather station
in Saddle Mountain, WA, between July 2002 and December 2017.
</p>
<p>This dataset was was generated on 2022-02-17 by running:
</p>
<pre>
library(RAWSmet)

setRawsDataDir("~/Data/RAWS")

example_raws &lt;-
  cefa_load(nwsID = "452701") %&gt;%
  raws_filterDate(20160701, 20161001)

save(example_raws, file = "data/example_raws.rda")
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>example_raws
</code></pre>


<h3>Format</h3>

<p>An <em>sts</em> object composed of &quot;meta&quot; and &quot;data&quot; dataframes.
</p>

<hr>
<h2 id='example_sts'>Example <em>sts</em> dataset</h2><span id='topic+example_sts'></span>

<h3>Description</h3>

<p>The <code>example_sts</code> dataset provides a quickly loadable
version of an <em>sts</em> object for practicing and code examples.
</p>
<p>This dataset was was generated on 2021-01-08 by running:
</p>
<pre>
library(AirSensor)

example_sts &lt;- example_pat
example_sts$meta$elevation &lt;- as.numeric(NA)
example_sts$meta$locationName &lt;- example_sts$meta$label

save(example_sts, file = "data/example_sts.rda")
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>example_sts
</code></pre>


<h3>Format</h3>

<p>An <em>sts</em> object composed of &quot;meta&quot; and &quot;data&quot; dataframes.
</p>

<hr>
<h2 id='MazamaTimeSeries'>Core functionality for environmental time series</h2><span id='topic+MazamaTimeSeries'></span><span id='topic+MazamaTimeSeries-package'></span>

<h3>Description</h3>

<p>Utility functions for working with environmental time series data from known
locations. The compact data model is structured as a list with two dataframes. A
meta' dataframe contains spatial and measuring device metadata associated with
deployments at known locations. A 'data' dataframe contains a 'datetime' column
followed by columns of measurements associated with each &quot;device-deployment&quot;.
</p>

<hr>
<h2 id='mts_arrange'>Order <em>mts</em> time series by metadata values</h2><span id='topic+mts_arrange'></span>

<h3>Description</h3>

<p>The variable(s) in <code>...</code> are used to specify columns of
<code>mts$meta</code> to use for ordering. Under the hood, this
function uses <code><a href="dplyr.html#topic+arrange">arrange</a></code> on <code>mts$meta</code> and then
reorders <code>mts$data</code> to match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_arrange(mts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_arrange_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_arrange_+3A_...">...</code></td>
<td>
<p>variables in <code>mts$meta</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reorderd version of the incoming <em>mts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

example_mts$meta$latitude[1:10]

# Filter for all labels with "SCSH"
byElevation &lt;-
  example_mts %&gt;%
  mts_arrange(latitude)

byElevation$meta$latitude[1:10]

</code></pre>

<hr>
<h2 id='mts_check'>Check <em>mts</em> object for validity</h2><span id='topic+mts_check'></span>

<h3>Description</h3>

<p>Checks on the validity of an <em>mts</em> object. If any test
fails, this function will stop with a warning message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_check(mts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_check_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> invisibly if the <em>mts</em> object is valid.
</p>


<h3>See Also</h3>

<p><a href="#topic+mts_isValid">mts_isValid</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

sts_check(example_mts)

# This would throw an error
if ( FALSE ) {

  broken_mts &lt;- example_mts
  names(broken_mts) &lt;- c('meta', 'bop')
  sts_check(broken_mts)

}

</code></pre>

<hr>
<h2 id='mts_collapse'>Collapse an <em>mts</em> time series object into a single time series</h2><span id='topic+mts_collapse'></span>

<h3>Description</h3>

<p>Collapses data from all time series in <code>mts</code> into a
single-time series <em>mts</em> object using the function provided in the
<code>FUN</code> argument. The single-time series result will be located at the mean
longitude and latitude unless <code>longitude</code> and <code>latitude</code>
are specified.
</p>
<p>Any columns of <code>mts$meta</code> that are constant across all records will be
retained in the returned <code>mts$meta</code>.
</p>
<p>The core metadata associated with this location (<em>e.g.</em>
<code>countryCode, stateCode, timezone, ...</code>) will be determined from
the most common (or average) value found in <code>mts$meta</code>. This will be
a reasonable assumption for the vast majority of intended use cases where
data from multiple devices in close proximity are averaged together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_collapse(
  mts,
  longitude = NULL,
  latitude = NULL,
  deviceID = "generatedID",
  FUN = mean,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_collapse_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_collapse_+3A_longitude">longitude</code></td>
<td>
<p>Longitude of the collapsed time series.</p>
</td></tr>
<tr><td><code id="mts_collapse_+3A_latitude">latitude</code></td>
<td>
<p>Latitude of the collapsed time series.</p>
</td></tr>
<tr><td><code id="mts_collapse_+3A_deviceid">deviceID</code></td>
<td>
<p>Device identifier for the collapsed time series.</p>
</td></tr>
<tr><td><code id="mts_collapse_+3A_fun">FUN</code></td>
<td>
<p>Function used to collapse multiple time series.</p>
</td></tr>
<tr><td><code id="mts_collapse_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether NA values should be ignored when FUN
is applied.</p>
</td></tr>
<tr><td><code id="mts_collapse_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to the <code>apply()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <em>mts</em> time series object representing a single time series.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>After <code>FUN</code> is applied, values of <code>+/-Inf</code> and <code>NaN</code> are
converted to <code>NA</code>. This is a convenience for the common case where
<code>FUN = min/max</code> or <code>FUN = mean</code> and some of the time steps have all
missing values. See the R documentation for <code>min</code> for an explanation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

mon &lt;-
  mts_collapse(
    mts = example_mts,
    deviceID = "example_ID"
  )

# mon$data now only has 2 columns
names(mon$data)

plot(mon$data, type = 'b', main = mon$meta$deviceID)

</code></pre>

<hr>
<h2 id='mts_combine'>Combine multiple <em>mts</em> time series objects</h2><span id='topic+mts_combine'></span>

<h3>Description</h3>

<p>Create a combined <em>mts</em> from any number of <em>mts</em>
objects or from a list of <em>mts</em> objects. The resulting <em>mts</em>
object with contain all <code>deviceDeploymentIDs</code> found in any incoming
<em>mts</em> and will have a regular time axis covering the the entire range
of incoming data.
</p>
<p>If incoming time ranges are non-contiguous, the resulting <em>mts</em> will
have gaps filled with <code>NA</code> values.
</p>
<p>An error is generated if the incoming <em>mts</em> objects have
non-identical metadata for the same <code>deviceDeploymentID</code> unless
<code>replaceMeta = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_combine(
  ...,
  replaceMeta = FALSE,
  overlapStrategy = c("replace all", "replace na")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_combine_+3A_...">...</code></td>
<td>
<p>Any number of valid <em>mts</em> objects.</p>
</td></tr>
<tr><td><code id="mts_combine_+3A_replacemeta">replaceMeta</code></td>
<td>
<p>Logical specifying whether to allow replacement of
metadata associated with <code>deviceDeploymentIDs</code>.</p>
</td></tr>
<tr><td><code id="mts_combine_+3A_overlapstrategy">overlapStrategy</code></td>
<td>
<p>Strategy to use when data found in time series
overlaps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <em>mts</em> time series object containing all time series found
in the incoming <code>mts</code> objects.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>Data for any <code>deviceDeploymentIDs</code> shared among <em>mts</em>
objects are combined with a &quot;later is better&quot; sensibility where any
data overlaps exist. To handle this, incoming <em>mts</em> objects are first
split into &quot;shared&quot; and &quot;unshared&quot; parts.
</p>
<p>Any &quot;shared&quot; parts are ordered based on the
time stamp of their last record. Then <code>dplyr::distinct()</code> is used to
remove records with duplicate <code>datetime</code> fields.
</p>
<p>With <code>overlapStrategy = "replace all"</code>, any data records found
in &quot;later&quot; <em>mts</em> objects are preferentially retained before the &quot;shared&quot;
data are finally reordered by ascending <code>datetime</code>.
</p>
<p>With <code>overlapStrategy = "replace missing"</code>, only missing values in &quot;earlier&quot;
<em>mts</em> objects are replaced with data records from &quot;later&quot; time series.
</p>
<p>The final step is combining the &quot;shared&quot; and &quot;unshared&quot; parts and placing
them on a uniform time axis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

ids1 &lt;- example_mts$meta$deviceDeploymentID[1:5]
ids2 &lt;- example_mts$meta$deviceDeploymentID[4:6]
ids3 &lt;- example_mts$meta$deviceDeploymentID[8:10]

mts1 &lt;-
  example_mts %&gt;%
  mts_filterMeta(deviceDeploymentID %in% ids1) %&gt;%
  mts_filterDate(20190701, 20190703)

mts2 &lt;-
  example_mts %&gt;%
  mts_filterMeta(deviceDeploymentID %in% ids2) %&gt;%
  mts_filterDate(20190704, 20190706)

mts3 &lt;-
  example_mts %&gt;%
  mts_filterMeta(deviceDeploymentID %in% ids3) %&gt;%
  mts_filterDate(20190705, 20190708)

mts &lt;- mts_combine(mts1, mts2, mts3)

# Should have 1:6 + 8:10 = 9 meta records and the full date range
nrow(mts$meta)
range(mts$data$datetime)

</code></pre>

<hr>
<h2 id='mts_distinct'>Retain only distinct data records in <code>mts$data</code></h2><span id='topic+mts_distinct'></span>

<h3>Description</h3>

<p>This function is primarily for internal use.
</p>
<p>Two successive steps are used to guarantee that the
<code>datetime</code> axis contains no repeated values:
</p>

<ol>
<li><p>remove any duplicate records
</p>
</li>
<li><p>guarantee that rows are in <code>datetime</code> order
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>mts_distinct(mts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_distinct_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <em>mts</em> object where each record is associated with a unique
time.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>

<hr>
<h2 id='mts_extractDataFrame'>Extract dataframes from <em>mts</em> objects</h2><span id='topic+mts_extractDataFrame'></span><span id='topic+mts_extractData'></span><span id='topic+mts_extractMeta'></span>

<h3>Description</h3>

<p>These functions are convenient wrappers for extracting the dataframes that
comprise an <em>mts</em> object. These functions are designed to be useful when
manipulating data in a pipeline chain using <code>%&gt;%</code>.
</p>
<p><code>mts_extractData(mts)</code> is equivalent to <code>mts$data</code>.
</p>
<p><code>mts_extractMeta(mts)</code> is equivalent to <code>mts$meta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_extractData(mts)

mts_extractMeta(mts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_extractDataFrame_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object to extract dataframe from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe from the <em>mts</em> object.
</p>

<hr>
<h2 id='mts_filterData'>General purpose data filtering for <em>mts</em> time series objects</h2><span id='topic+mts_filterData'></span>

<h3>Description</h3>

<p>A generalized data filter for <em>mts</em> objects to
choose rows/cases where conditions are true.  Multiple conditions may be
combined with <code>&amp;</code> or separated by a comma. Only rows where the condition
evaluates to TRUE are kept. Rows where the condition evaluates to <code>NA</code>
are dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_filterData(mts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_filterData_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_filterData_+3A_...">...</code></td>
<td>
<p>Logical predicates defined in terms of the variables in
<code>mts$data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>mts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>Filtering is done on variables in <code>mts$data</code> and results in an
<em>incomplete and irregular time axis</em>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mts_filterMeta">mts_filterMeta</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

# Are there any times when data exceeded 150?
sapply(example_mts$data, function(x) { any(x &gt; 150, na.rm = TRUE) })

# Show all times where da4cadd2d6ea5302_4686 &gt; 150
example_mts %&gt;%
  mts_filterData(da4cadd2d6ea5302_4686 &gt; 150) %&gt;%
  mts_extractData() %&gt;%
  dplyr::pull(datetime)

</code></pre>

<hr>
<h2 id='mts_filterDate'>Date filtering for <em>mts</em> time series objects</h2><span id='topic+mts_filterDate'></span>

<h3>Description</h3>

<p>Subsets an <em>mts</em> object by date. This function
always filters to day-boundaries. For sub-day filtering, use
<code>mts_setTimeAxis()</code>.
</p>
<p>Dates can be anything that is understood by <code>MazamaCoreUtils::parseDatetime()</code>
including either of the following recommended formats:
</p>

<ul>
<li><p><code>"YYYYmmdd"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd"</code>
</p>
</li></ul>

<p>Timezone determination precedence assumes that if you are passing in
<code>POSIXct</code> values then you know what you are doing:
</p>

<ol>
<li><p>get timezone from <code>startdate</code> if it is <code>POSIXct</code>
</p>
</li>
<li><p>use passed in <code>timezone</code>
</p>
</li>
<li><p>get timezone from <code>mts</code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>mts_filterDate(
  mts = NULL,
  startdate = NULL,
  enddate = NULL,
  timezone = NULL,
  unit = "sec",
  ceilingStart = FALSE,
  ceilingEnd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_filterDate_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_filterDate_+3A_startdate">startdate</code></td>
<td>
<p>Desired start date (ISO 8601).</p>
</td></tr>
<tr><td><code id="mts_filterDate_+3A_enddate">enddate</code></td>
<td>
<p>Desired end date (ISO 8601).</p>
</td></tr>
<tr><td><code id="mts_filterDate_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates.</p>
</td></tr>
<tr><td><code id="mts_filterDate_+3A_unit">unit</code></td>
<td>
<p>Units used to determine time at end-of-day.</p>
</td></tr>
<tr><td><code id="mts_filterDate_+3A_ceilingstart">ceilingStart</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>startdate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code>.</p>
</td></tr>
<tr><td><code id="mts_filterDate_+3A_ceilingend">ceilingEnd</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>enddate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>mts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>The returned data will run from the beginning of <code>startdate</code> until
the <strong>beginning</strong> of <code>enddate</code> &ndash; <em>i.e.</em> no values associated
with <code>enddate</code> will be returned. The exception being when
<code>enddate</code> is less than 24 hours after <code>startdate</code>. In that case, a
single day is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+mts_setTimeAxis">mts_setTimeAxis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

example_mts %&gt;%
  mts_filterDate(
    startdate = 20190703,
    enddate = 20190706
  ) %&gt;%
  mts_extractData() %&gt;%
  dplyr::pull(datetime) %&gt;%
  range()

</code></pre>

<hr>
<h2 id='mts_filterDatetime'>Datetime filtering for <em>mts</em> time series objects</h2><span id='topic+mts_filterDatetime'></span>

<h3>Description</h3>

<p><strong><code>DEPRECATED -- use <a href="#topic+mts_setTimeAxis">mts_setTimeAxis</a></code></strong>.
</p>
<p>Subsets an <code>mts</code> object by datetime. This function
allows for sub-day filtering as opposed to <code>mts_filterDate()</code> which
always filters to day-boundaries. Both the <code>startdate</code> and the
<code>enddate</code> will be included in the subset.
</p>
<p>Datetimes can be anything that is understood by
<code>MazamaCoreUtils::parseDatetime()</code>. For non-<code>POSIXct</code> values,
the recommended format is <code>"YYYY-mm-dd HH:MM:SS"</code>.
</p>
<p>Timezone determination precedence assumes that if you are passing in
<code>POSIXct</code> values then you know what you are doing:
</p>

<ol>
<li><p>get timezone from <code>startdate</code> if it is <code>POSIXct</code>
</p>
</li>
<li><p>use passed in <code>timezone</code>
</p>
</li>
<li><p>get timezone from <code>mts</code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>mts_filterDatetime(
  mts = NULL,
  startdate = NULL,
  enddate = NULL,
  timezone = NULL,
  unit = "sec",
  ceilingStart = FALSE,
  ceilingEnd = FALSE,
  includeEnd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_filterDatetime_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_filterDatetime_+3A_startdate">startdate</code></td>
<td>
<p>Desired start datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="mts_filterDatetime_+3A_enddate">enddate</code></td>
<td>
<p>Desired end datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="mts_filterDatetime_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates.</p>
</td></tr>
<tr><td><code id="mts_filterDatetime_+3A_unit">unit</code></td>
<td>
<p>Datetimes will be rounded to the nearest <code>unit</code>.</p>
</td></tr>
<tr><td><code id="mts_filterDatetime_+3A_ceilingstart">ceilingStart</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>startdate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code> when rounding.</p>
</td></tr>
<tr><td><code id="mts_filterDatetime_+3A_ceilingend">ceilingEnd</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>enddate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code> when rounding.</p>
</td></tr>
<tr><td><code id="mts_filterDatetime_+3A_includeend">includeEnd</code></td>
<td>
<p>Logical specifying that records associated with <code>enddate</code>
should be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>mts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>This function is deprecated as of <strong>MazamaTimeSeries 0.2.15</strong>.
Please use <a href="#topic+mts_setTimeAxis">mts_setTimeAxis</a> to shorten or lengthen the time axis
of an <em>mts</em> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+mts_filterData">mts_filterData</a>
</p>
<p><a href="#topic+mts_filterDate">mts_filterDate</a>
</p>
<p><a href="#topic+mts_filterMeta">mts_filterMeta</a>
</p>

<hr>
<h2 id='mts_filterMeta'>General purpose metadata filtering for <em>mts</em> time series objects</h2><span id='topic+mts_filterMeta'></span>

<h3>Description</h3>

<p>A generalized metadata filter for <em>mts</em> objects to
choose rows/cases where conditions are true.  Multiple conditions are
combined with <code>&amp;</code> or separated by a comma. Only rows where the condition
evaluates to TRUE are kept. Rows where the condition evaluates to FALSE or
<code>NA</code> are dropped.
</p>
<p>If an empty <em>mts</em> object is passed in, it is immediately returned,
allowing for multiple filtering steps to be piped together and only checking
for an empty <em>mts</em> object at the end of the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_filterMeta(mts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_filterMeta_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_filterMeta_+3A_...">...</code></td>
<td>
<p>Logical predicates defined in terms of the variables in
<code>mts$meta</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>mts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>Filtering is done on variables in <code>mts$meta</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mts_filterData">mts_filterData</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

# Filter for all labels with "SCSH"
scap &lt;-
  example_mts %&gt;%
  mts_filterMeta(communityRegion == "El Monte")

dplyr::select(scap$meta, ID, label, longitude, latitude, communityRegion)

head(scap$data)

</code></pre>

<hr>
<h2 id='mts_getDistance'>Calculate distances from <em>mts</em> time series locations to a location of interest</h2><span id='topic+mts_getDistance'></span>

<h3>Description</h3>

<p>This function uses the [geodist] package to return the distances (meters)
between <code>mts</code> locations
and a location of interest. These distances can be used to create a
mask identifying monitors within a certain radius of the location of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_getDistance(
  mts = NULL,
  longitude = NULL,
  latitude = NULL,
  measure = c("geodesic", "haversine", "vincenty", "cheap")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_getDistance_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_getDistance_+3A_longitude">longitude</code></td>
<td>
<p>Longitude of the location of interest.</p>
</td></tr>
<tr><td><code id="mts_getDistance_+3A_latitude">latitude</code></td>
<td>
<p>Latitude of the location of interest.</p>
</td></tr>
<tr><td><code id="mts_getDistance_+3A_measure">measure</code></td>
<td>
<p>One of &quot;geodesic&quot;, &quot;haversine&quot;, &quot;vincenty&quot; or &quot;cheap&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of of distances (meters) named by <code>deviceDeploymentID</code>.
</p>


<h3>Note</h3>

<p>The measure <code>"cheap"</code> may be used to speed things up depending on
the spatial scale being considered. Distances calculated with
<code>measure = "cheap"</code> will vary by a few meters compared with those
calculated using <code>measure = "geodesic"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

# Garfield Medical Center in LA
longitude &lt;- -118.12321
latitude &lt;- 34.06775

distances &lt;- mts_getDistance(
  mts = example_mts,
  longitude = longitude,
  latitude = latitude
)

# Which sensors are within 1000 meters of Garfield Med Ctr?
distances[distances &lt;= 1000]

</code></pre>

<hr>
<h2 id='mts_isEmpty'>Test for an empty <em>mts</em> object</h2><span id='topic+mts_isEmpty'></span>

<h3>Description</h3>

<p>Convenience function for <code>nrow(mts$data) == 0</code>.
This makes for more readable code in functions that need to test for this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_isEmpty(mts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_isEmpty_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if no data exist in <code>mts</code>, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

mts_isEmpty(example_mts)

</code></pre>

<hr>
<h2 id='mts_isValid'>Test <em>mts</em> object for correct structure</h2><span id='topic+mts_isValid'></span>

<h3>Description</h3>

<p>The <code>mts</code> is checked for the presence of core
<code>meta</code> and <code>data</code> columns.
</p>
<p>Core <code>meta</code> columns include:
</p>

<ul>
<li><p><code>deviceDeploymentID</code> &ndash; unique identifier (see <a href="https://mazamascience.github.io/MazamaLocationUtils/">MazmaLocationUtils</a>)
</p>
</li>
<li><p><code>deviceID</code> &ndash; device identifier
</p>
</li>
<li><p><code>locationID</code> &ndash; location identifier (see <a href="https://mazamascience.github.io/MazamaLocationUtils/">MazmaLocationUtils</a>)
</p>
</li>
<li><p><code>locationName</code> &ndash; English language name
</p>
</li>
<li><p><code>longitude</code> &ndash; decimal degrees E
</p>
</li>
<li><p><code>latitude</code> &ndash; decimal degrees N
</p>
</li>
<li><p><code>elevation</code> &ndash; elevation of station in m
</p>
</li>
<li><p><code>countryCode</code> &ndash; ISO 3166-1 alpha-2
</p>
</li>
<li><p><code>stateCode</code> &ndash; ISO 3166-2 alpha-2
</p>
</li>
<li><p><code>timezone</code> &ndash; Olson time zone
</p>
</li></ul>

<p>Core <code>data</code> columns include:
</p>

<ul>
<li><p><code>datetime</code> &ndash; measurement time (UTC)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mts_isValid(mts = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_isValid_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object</p>
</td></tr>
<tr><td><code id="mts_isValid_+3A_verbose">verbose</code></td>
<td>
<p>Logical specifying whether to produce detailed warning messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>TRUE</code> if <code>mts</code> has the correct structure,
<code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p><a href="#topic+mts_check">mts_check</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

print(mts_isValid(example_mts))

</code></pre>

<hr>
<h2 id='mts_pull'>Extract a column of metadata or data</h2><span id='topic+mts_pull'></span>

<h3>Description</h3>

<p>This function acts similarly to <code>dplyr::pull()</code> working on
<code>mts$meta</code> or <code>mts$data</code>. Data are returned as a simple array.
Data are pulled from whichever dataframe contains <code>var</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_pull(mts = NULL, var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_pull_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_pull_+3A_var">var</code></td>
<td>
<p>A variable name found in the <code>meta</code> or <code>data</code>
dataframe of the incoming <em>mts</em> time series object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

# Metadata
example_mts %&gt;%
  mts_pull("communityRegion") %&gt;%
  table() %&gt;%
  sort(decreasing = TRUE)

# Data for a specific ID
example_mts %&gt;%
  mts_pull("da4cadd2d6ea5302_4686")

</code></pre>

<hr>
<h2 id='mts_sample'>Sample time series for an <em>mts</em> time series object</h2><span id='topic+mts_sample'></span>

<h3>Description</h3>

<p>Reduce the number of records (timesteps) in the <code>data</code>
dataframe of the incoming <code>mts</code> through random sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_sample(
  mts = NULL,
  sampleSize = 5000,
  seed = NULL,
  keepOutliers = FALSE,
  width = 5,
  thresholdMin = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_sample_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_sample_+3A_samplesize">sampleSize</code></td>
<td>
<p>Non-negative integer giving the number of rows to choose.</p>
</td></tr>
<tr><td><code id="mts_sample_+3A_seed">seed</code></td>
<td>
<p>Integer passed to <code><a href="base.html#topic+set.seed">set.seed</a></code> for reproducible sampling.</p>
</td></tr>
<tr><td><code id="mts_sample_+3A_keepoutliers">keepOutliers</code></td>
<td>
<p>Logical specifying a graphics focused sampling algorithm
that retains outliers (see Details).</p>
</td></tr>
<tr><td><code id="mts_sample_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window used for outlier detection.</p>
</td></tr>
<tr><td><code id="mts_sample_+3A_thresholdmin">thresholdMin</code></td>
<td>
<p>Numeric threshold for outlier detection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>keepOutliers = FALSE</code>, random sampling is used to provide
a statistically relevant subsample of the data.
</p>


<h3>Value</h3>

<p>A subset of the given <em>mts</em> object.
</p>
<p>An <em>mts</em> time series object with fewer timesteps.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Outlier Detection</h3>

<p>When <code>keepOutliers = TRUE</code>, a customized sampling algorithm is used that
attempts to create subsets for use in plotting that create plots that are
visually identical to plots using all data. This is accomplished by
preserving outliers and only sampling data in regions where overplotting
is expected.
</p>
<p>The process is as follows:
</p>

<ol>
<li><p>find outliers using <code>MazamaRollUtils::findOutliers()</code>
</p>
</li>
<li><p>create a subset consisting of only outliers
</p>
</li>
<li><p>sample the remaining data
</p>
</li>
<li><p>merge the outliers and sampled data
</p>
</li></ol>

<p>This algorithm works best when the <em>mts</em> object has only one or two
timeseries.
</p>
<p>The <code>width</code> and <code>thresholdMin</code> parameters determine the number of
outliers detected. For hourly data, a <code>width</code> of 5 and a <code>thresholdMin</code>
of 3 or 4 seem to find many visually obvious outliers.
</p>
<p>Users attempting to optimize plotting speed for lengthy time series are
encouraged to experiment with these two parameters along with
<code>sampleSize</code> and review the results visually.
</p>
<p>See <code>MazamaRollUtils::findOutliers()</code>.
</p>

<hr>
<h2 id='mts_select'>Reorder and subset time series within an <em>mts</em> time series object</h2><span id='topic+mts_select'></span>

<h3>Description</h3>

<p>This function acts similarly to <code>dplyr::select()</code> working on
<code>mts$data</code>. The returned <em>mts</em> object will contain only those
time series identified by <code>deviceDeploymentID</code> in the order specified.
</p>
<p>This can be used the specify a preferred order and is helpful when using
faceted plot functions based on
<a href="https://ggplot2.tidyverse.org">ggplot</a>
such as those found in the
<a href="https://mazamascience.github.io/AirMonitorPlots/">AirMonitorPlots</a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_select(mts = NULL, deviceDeploymentID = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_select_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_select_+3A_devicedeploymentid">deviceDeploymentID</code></td>
<td>
<p>Vector of timeseries unique identifiers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reordered (subset) of the incoming <em>mts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>See Also</h3>

<p><a href="#topic+mts_selectWhere">mts_selectWhere</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

# Filter for "El Monte"
El_Monte &lt;-
  example_mts %&gt;%
  mts_filterMeta(communityRegion == "El Monte")

ids &lt;- El_Monte$meta$deviceDeploymentID
rev_ids &lt;- rev(ids)

print(ids)
print(rev_ids)

rev_El_Monte &lt;-
  example_mts %&gt;%
  mts_select(rev_ids)

print(rev_El_Monte$meta$deviceDeploymentID)

</code></pre>

<hr>
<h2 id='mts_selectWhere'>Data-based subsetting of time series within an <em>mts</em> object.</h2><span id='topic+mts_selectWhere'></span>

<h3>Description</h3>

<p>Subsetting of <code>mts</code> acts similarly to <code>tidyselect::where()</code> working on
<code>mts$data</code>. The returned <em>mts</em> object will contain only
those time series where <code>FUN</code> applied to the time series data returns <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_selectWhere(mts, FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_selectWhere_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_selectWhere_+3A_fun">FUN</code></td>
<td>
<p>A function applied to time series data that returns TRUE or FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>mts</em> object. (A list with
<code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>See Also</h3>

<p><a href="#topic+mts_select">mts_select</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

# Show all Camp_Fire locations
Camp_Fire$meta$locationName

# Set a threshold
threshold &lt;- 500

# Find time series with data at or above this threshold
worst_sites &lt;-
  Camp_Fire %&gt;%
  mts_selectWhere(
    function(x) { any(x &gt;= threshold, na.rm = TRUE) }
  )

# Show the worst locations
worst_sites$meta$locationName

</code></pre>

<hr>
<h2 id='mts_setTimeAxis'>Extend/contract <em>mts</em> time series to new start and end times</h2><span id='topic+mts_setTimeAxis'></span>

<h3>Description</h3>

<p>Extends or contracts the time range of an <em>mts</em> object by
adding/removing time steps at the start and end and filling any new time
steps with missing values. The resulting time axis is guaranteed to be
a regular, hourly axis with no gaps using the same timezone as the incoming
<em>mts</em> object. This is useful when you want to place separate <em>mts</em>
objects on the same time axis for plotting.
</p>
<p>Dates can be anything that is understood by <code>MazamaCoreUtils::parseDatetime()</code>
including either of the following recommended formats:
</p>

<ul>
<li><p><code>"YYYYmmdd"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd"</code>
</p>
</li></ul>

<p>Timezone determination precedence assumes that if you are passing in
<code>POSIXct</code> values then you know what you are doing:
</p>

<ol>
<li><p>get timezone from <code>startdate</code> if it is <code>POSIXct</code>
</p>
</li>
<li><p>use passed in <code>timezone</code>
</p>
</li>
<li><p>get timezone from <code>mts</code>
</p>
</li></ol>

<p>If either <code>startdate</code> or <code>enddate</code> is missing, the start or end of
the timeseries in <code>mts</code> will be used.
</p>
<p>If neither <code>startdate</code> nor <code>enddate</code> is a <code>POSIXct</code> value
AND no <code>timezone</code> is supplied, the timezone will be inferred from
the most common timezone found in <code>mts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_setTimeAxis(mts = NULL, startdate = NULL, enddate = NULL, timezone = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_setTimeAxis_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_setTimeAxis_+3A_startdate">startdate</code></td>
<td>
<p>Desired start date (ISO 8601).</p>
</td></tr>
<tr><td><code id="mts_setTimeAxis_+3A_enddate">enddate</code></td>
<td>
<p>Desired end date (ISO 8601).</p>
</td></tr>
<tr><td><code id="mts_setTimeAxis_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret <code>startdate</code> and <code>enddate</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The incoming <em>mts</em> time series object defined on a new time axis.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

# Default range
range(example_mts$data$datetime)

# One-sided extend with user specified timezone
example_mts %&gt;%
  mts_setTimeAxis(enddate = 20190815, timezone = "UTC") %&gt;%
  mts_extractData() %&gt;%
  dplyr::pull(datetime) %&gt;%
  range()

# Two-sided extend with user specified timezone
example_mts %&gt;%
  mts_setTimeAxis(20190615, 20190815, timezone = "UTC") %&gt;%
  mts_extractData() %&gt;%
  dplyr::pull(datetime) %&gt;%
  range()

# Two-sided extend without timezone (uses timezone from mts$meta$timezone)
example_mts %&gt;%
  mts_setTimeAxis(20190615, 20190815) %&gt;%
  mts_extractData() %&gt;%
  dplyr::pull(datetime) %&gt;%
  range()

</code></pre>

<hr>
<h2 id='mts_slice_head'>Subset time series based on their position</h2><span id='topic+mts_slice_head'></span><span id='topic+mts_slice_tail'></span>

<h3>Description</h3>

<p>An <em>mts</em> object is reduced so as to contain only the first
or last <code>n</code> timeseries. These functions work similarly to
<code><a href="dplyr.html#topic+slice_head">dplyr::slice_head</a></code> and
<code><a href="dplyr.html#topic+slice_tail">dplyr::slice_tail</a></code>
but apply to both dataframes in the <em>mts</em> object.
</p>
<p>This is primarily useful when the <em>mts</em> object has been ordered by a
previous call to <code><a href="#topic+mts_arrange">mts_arrange</a></code> or by some other means.
</p>
<p><code>slice_head()</code> selects the first and <code>slice_tail()</code> the last timeseries
in the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_slice_head(mts, n = 5)

mts_slice_tail(mts, n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_slice_head_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_slice_head_+3A_n">n</code></td>
<td>
<p>Number of rows of <code>mts$meta</code> to select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>mts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

# Find lowest elevation sites
Camp_Fire %&gt;%
  mts_filterMeta(!is.na(elevation)) %&gt;%
  mts_arrange(elevation) %&gt;%
  mts_slice_head(n = 5) %&gt;%
  mts_extractMeta() %&gt;%
  dplyr::select(elevation, locationName)

# Find highest elevation sites
Camp_Fire %&gt;%
  mts_filterMeta(!is.na(elevation)) %&gt;%
  mts_arrange(elevation) %&gt;%
  mts_slice_tail(n = 5) %&gt;%
  mts_extractMeta() %&gt;%
  dplyr::select(elevation, locationName)

</code></pre>

<hr>
<h2 id='mts_summarize'>Create summary time series for an <em>mts</em> time series object</h2><span id='topic+mts_summarize'></span>

<h3>Description</h3>

<p>Individual time series in <code>mts$data</code> are grouped by <code>unit</code> and then
summarized using <code>FUN</code>.
</p>
<p>The most typical use case is creating daily averages where each day begins at
midnight. This function interprets times using the <code>mts$data$datetime</code>
<code>tzone</code> attribute so be sure that is set properly.
</p>
<p>Day boundaries are calculated using the specified <code>timezone</code> or, if
<code>NULL</code>, the most common (hopefully only!) time zone found in
<code>mts$meta$timezone</code>. Leaving <code>timezone = NULL</code>, the default,
results in &quot;local time&quot; date filtering which is the most common use case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_summarize(
  mts,
  timezone = NULL,
  unit = c("day", "week", "month", "year"),
  FUN = NULL,
  ...,
  minCount = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_summarize_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_summarize_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates.</p>
</td></tr>
<tr><td><code id="mts_summarize_+3A_unit">unit</code></td>
<td>
<p>Unit used to summarize by (<em>e.g.</em> &quot;day&quot;).</p>
</td></tr>
<tr><td><code id="mts_summarize_+3A_fun">FUN</code></td>
<td>
<p>Function used to summarize time series.</p>
</td></tr>
<tr><td><code id="mts_summarize_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>FUN</code>
(_e.g._ <code>na.rm = TRUE</code>).</p>
</td></tr>
<tr><td><code id="mts_summarize_+3A_mincount">minCount</code></td>
<td>
<p>Minimum number of valid data records required to calculate
summaries. Time periods with fewer valid records will be assigned <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <em>mts</em> time series object containing daily (or other)
statistical summaries.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>Because the returned <em>mts</em> object is defined on a daily axis in a
specific time zone, it is important that the incoming <code>mts</code> contain
timeseries associated with a single time zone.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

daily &lt;-
  mts_summarize(
    mts = Carmel_Valley,
    timezone = NULL,
    unit = "day",
    FUN = mean,
    na.rm = TRUE,
    minCount = 18
  )

# Daily means
head(daily$data)

</code></pre>

<hr>
<h2 id='mts_trim'>Trim <em>mts</em> time series by removing missing values</h2><span id='topic+mts_trim'></span>

<h3>Description</h3>

<p>Trims the time range of an <em>mts</em> object by removing
time steps from the start and end that contain only missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_trim(mts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_trim_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>mts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

# Untrimmed range
range(example_mts$data$datetime)

# Replace the first 50 data values for all non-"datetime" columns
example_mts$data[1:50, -1] &lt;- NA

# Trimmed range
mts_trimmed &lt;- mts_trim(example_mts)
range(mts_trimmed$data$datetime)
</code></pre>

<hr>
<h2 id='mts_trimDate'>Trim <em>mts</em> time series object to full days</h2><span id='topic+mts_trimDate'></span>

<h3>Description</h3>

<p>Trims the date range of an <em>mts</em> object to local time date
boundaries which are within the time range of the <em>mts</em> object.
This has the effect of removing partial-day data records at the start and
end of the timeseries and is useful when calculating full-day statistics.
</p>
<p>By default, multi-day periods of all-missing data at the beginning and end
of the timeseries are removed before trimming to date boundaries. If
<code>trimEmptyDays = FALSE</code> all records are retained except for partial days
beyond the first and after the last date boundary.
</p>
<p>Day boundaries are calculated using the specified <code>timezone</code> or, if
<code>NULL</code>,  <code>mts$meta$timezone</code>. Leaving <code>timezone = NULL</code>, the
default, results in &quot;local time&quot; date filtering which is the most
common use case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_trimDate(mts = NULL, timezone = NULL, trimEmptyDays = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_trimDate_+3A_mts">mts</code></td>
<td>
<p><em>mts</em> object.</p>
</td></tr>
<tr><td><code id="mts_trimDate_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates.</p>
</td></tr>
<tr><td><code id="mts_trimDate_+3A_trimemptydays">trimEmptyDays</code></td>
<td>
<p>Logical specifying whether to remove days with no data
at the beginning and end of the time range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>mts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

UTC_week &lt;- mts_filterDate(
  example_mts,
  startdate = 20190703,
  enddate = 20190706,
  timezone = "UTC"
)

# UTC day boundaries
range(UTC_week$data$datetime)

# Trim to local time day boundaries
local_week &lt;- mts_trimDate(UTC_week)
range(local_week$data$datetime)

</code></pre>

<hr>
<h2 id='requiredMetaNames'>Required columns for the 'meta' dataframe</h2><span id='topic+requiredMetaNames'></span>

<h3>Description</h3>

<p>The 'meta' dataframe found in <em>sts</em> and <em>mts</em> objects
is required to have a minimum set of information for proper functioning of
the package. The names of these columns are specified in
<code>requiredMetaNames</code> and include:
</p>

<ul>
<li><p><code>deviceDeploymentID</code> &ndash; unique identifier (see <a href="https://mazamascience.github.io/MazamaLocationUtils/">MazmaLocationUtils</a>)
</p>
</li>
<li><p><code>deviceID</code> &ndash; device identifier
</p>
</li>
<li><p><code>locationID</code> &ndash; location identifier (see <a href="https://mazamascience.github.io/MazamaLocationUtils/">MazmaLocationUtils</a>)
</p>
</li>
<li><p><code>locationName</code> &ndash; English language name
</p>
</li>
<li><p><code>longitude</code> &ndash; decimal degrees E
</p>
</li>
<li><p><code>latitude</code> &ndash; decimal degrees N
</p>
</li>
<li><p><code>elevation</code> &ndash; elevation of station in m
</p>
</li>
<li><p><code>countryCode</code> &ndash; ISO 3166-1 alpha-2
</p>
</li>
<li><p><code>stateCode</code> &ndash; ISO 3166-2 alpha-2
</p>
</li>
<li><p><code>timezone</code> &ndash; Olson time zone
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>requiredMetaNames
</code></pre>


<h3>Format</h3>

<p>A vector with 10 elements
</p>


<h3>Details</h3>

<p>requiredMetaNames
</p>

<hr>
<h2 id='sts_check'>Check <em>sts</em> object for validity</h2><span id='topic+sts_check'></span>

<h3>Description</h3>

<p>Checks on the validity of an <em>sts</em> object. If any test
fails, this function will stop with a warning message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sts_check(sts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_check_+3A_sts">sts</code></td>
<td>
<p><em>sts</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> invisibly if the <em>sts</em> object is valid.
</p>


<h3>See Also</h3>

<p><a href="#topic+sts_isValid">sts_isValid</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

sts_check(example_sts)

# This would throw an error
if ( FALSE ) {

  broken_sts &lt;- example_sts
  names(broken_sts) &lt;- c('meta', 'bop')
  sts_check(broken_sts)

}

</code></pre>

<hr>
<h2 id='sts_combine'>Combine multiple <em>sts</em> time series objects</h2><span id='topic+sts_combine'></span>

<h3>Description</h3>

<p>Create a merged timeseries using of any number of <em>sts</em>
objects for a single sensor. If <em>sts</em> objects are non-contiguous, the
resulting <em>sts</em> will have gaps.
</p>
<p>An error is generated if the incoming <em>sts</em> objects have
non-identical <code>deviceDeploymentIDs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sts_combine(..., replaceMeta = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_combine_+3A_...">...</code></td>
<td>
<p>Any number of valid SingleTimeSeries <em>sts</em> objects associated
with a single <code>deviceDeploymentID</code>.</p>
</td></tr>
<tr><td><code id="sts_combine_+3A_replacemeta">replaceMeta</code></td>
<td>
<p>Logical specifying whether to allow replacement of
metadata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SingleTimeSeries <em>sts</em> time series object containing
records from all incoming <code>sts</code> time series objects.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>Data are combined with a &quot;later is better&quot; sensibility where any
data overlaps exist. To handle this, incoming <em>sts</em> objects are first
split into &quot;shared&quot; and &quot;unshared&quot; parts.
</p>
<p>Any &quot;shared&quot; parts are ordered based on the
time stamp of their last record. Then <code>dplyr::distinct()</code> is used to
remove records with duplicate <code>datetime</code> fields. Any data records found
in &quot;later&quot; <em>sts</em> objects are preferentially retained before the &quot;shared&quot;
data are finally reordered by ascending <code>datetime</code>.
</p>
<p>The final step is combining the &quot;shared&quot; and &quot;unshared&quot; parts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

aug01_08 &lt;-
  example_sts %&gt;%
  sts_filterDate(20180801, 20180808)

aug15_22 &lt;-
  example_sts %&gt;%
  sts_filterDate(20180815, 20180822)

aug01_22 &lt;- sts_combine(aug01_08, aug15_22)

plot(aug01_22$data$datetime)
</code></pre>

<hr>
<h2 id='sts_distinct'>Retain only distinct data records in <code>sts$data</code></h2><span id='topic+sts_distinct'></span>

<h3>Description</h3>

<p>Three successive steps are used to guarantee that the
<code>datetime</code> axis contains no repeated values:
</p>

<ol>
<li><p>remove any duplicate records
</p>
</li>
<li><p>guarantee that rows are in <code>datetime</code> order
</p>
</li>
<li><p>average together fields for any remaining records that share the same
<code>datetime</code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>sts_distinct(sts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_distinct_+3A_sts">sts</code></td>
<td>
<p><em>sts</em> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <em>sts</em> object where each record is associated with a unique
time.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>

<hr>
<h2 id='sts_extractDataFrame'>Extract dataframes from <em>sts</em> objects</h2><span id='topic+sts_extractDataFrame'></span><span id='topic+sts_extractData'></span><span id='topic+sts_extractMeta'></span>

<h3>Description</h3>

<p>These functions are convenient wrappers for extracting the dataframes that
comprise a <em>sts</em> object. These functions are designed to be useful when
manipulating data in a pipeline using <code>%&gt;%</code>.
</p>
<p>Below is a table showing equivalent operations for each function.
</p>
<p><code>sts_extractData(sts)</code> is equivalent to <code>sts$data</code>.
</p>
<p><code>sts_extractMeta(sts)</code> is equivalent to <code>sts$meta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sts_extractData(sts)

sts_extractMeta(sts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_extractDataFrame_+3A_sts">sts</code></td>
<td>
<p><em>sts</em> object to extract dataframe from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe from the <em>sts</em> object.
</p>

<hr>
<h2 id='sts_filter'>General purpose data filtering for <em>sts</em> time series objects</h2><span id='topic+sts_filter'></span>

<h3>Description</h3>

<p>A generalized data filter for <em>sts</em> objects to
choose rows/cases where conditions are true.  Multiple conditions are
combined with <code>&amp;</code> or separated by a comma. Only rows where the condition
evaluates to TRUE are kept. Rows where the condition evaluates to <code>NA</code>
are dropped.
</p>
<p>If an empty <em>sts</em> object is passed in, it is immediately returned,
allowing for multiple filtering steps to be piped together and only checking
for an empty <em>sts</em> object at the end of the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sts_filter(sts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_filter_+3A_sts">sts</code></td>
<td>
<p><em>sts</em> object.</p>
</td></tr>
<tr><td><code id="sts_filter_+3A_...">...</code></td>
<td>
<p>Logical predicates defined in terms of the variables in
<code>sts$data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <code>sts</code> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>Filtering is done on values in <code>sts$data</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+sts_filterDate">sts_filterDate</a>
</p>
<p><a href="#topic+sts_filterDatetime">sts_filterDatetime</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MazamaTimeSeries)

unhealthy &lt;- sts_filter(example_sts, pm25_A &gt; 55.5, pm25_B &gt; 55.5)
head(unhealthy$data)

</code></pre>

<hr>
<h2 id='sts_filterDate'>Date filtering for <em>sts</em> time series objects</h2><span id='topic+sts_filterDate'></span>

<h3>Description</h3>

<p>Subsets a MazamaSingleTimeseries object by date. This function
always filters to day-boundaries. For sub-day filtering, use
<code>sts_filterDatetime()</code>.
</p>
<p>Dates can be anything that is understood by <code>MazamaCoreUtils::parseDatetime()</code>
including either of the following recommended formats:
</p>

<ul>
<li><p><code>"YYYYmmdd"</code>
</p>
</li>
<li><p><code>"YYYY-mm-dd"</code>
</p>
</li></ul>

<p>Timezone determination precedence assumes that if you are passing in
<code>POSIXct</code> values then you know what you are doing.
</p>

<ol>
<li><p>get timezone from <code>startdate</code> if it is <code>POSIXct</code>
</p>
</li>
<li><p>use passed in <code>timezone</code>
</p>
</li>
<li><p>get timezone from <code>sts</code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>sts_filterDate(
  sts = NULL,
  startdate = NULL,
  enddate = NULL,
  timezone = NULL,
  unit = "sec",
  ceilingStart = FALSE,
  ceilingEnd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_filterDate_+3A_sts">sts</code></td>
<td>
<p>MazamaSingleTimeseries <em>sts</em> object.</p>
</td></tr>
<tr><td><code id="sts_filterDate_+3A_startdate">startdate</code></td>
<td>
<p>Desired start datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="sts_filterDate_+3A_enddate">enddate</code></td>
<td>
<p>Desired end datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="sts_filterDate_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates.</p>
</td></tr>
<tr><td><code id="sts_filterDate_+3A_unit">unit</code></td>
<td>
<p>Units used to determine time at end-of-day.</p>
</td></tr>
<tr><td><code id="sts_filterDate_+3A_ceilingstart">ceilingStart</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>startdate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
<tr><td><code id="sts_filterDate_+3A_ceilingend">ceilingEnd</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>enddate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>sts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>The returned data will run from the beginning of <code>startdate</code> until
the <strong>beginning</strong> of <code>enddate</code> &ndash; <em>i.e.</em> no values associated
with <code>enddate</code> will be returned. The exception being when
<code>enddate</code> is less than 24 hours after <code>startdate</code>. In that case, a
single day is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+sts_filter">sts_filter</a>
</p>
<p><a href="#topic+sts_filterDatetime">sts_filterDatetime</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

example_sts %&gt;%
  sts_filterDate(startdate = 20180808, enddate = 20180815) %&gt;%
  sts_extractData() %&gt;%
  head()

</code></pre>

<hr>
<h2 id='sts_filterDatetime'>Datetime filtering for <em>sts</em> time series objects</h2><span id='topic+sts_filterDatetime'></span>

<h3>Description</h3>

<p>Subsets a MazamaSingleTimeseries object by datetime. This function
allows for sub-day filtering as opposed to <code>sts_filterDate()</code> which
always filters to day-boundaries.
</p>
<p>Datetimes can be anything that is understood by
<code>MazamaCoreUtils::parseDatetime()</code>. For non-<code>POSIXct</code> values,
the recommended format is <code>"YYYY-mm-dd HH:MM:SS"</code>.
</p>
<p>Timezone determination precedence assumes that if you are passing in
<code>POSIXct</code> values then you know what you are doing.
</p>

<ol>
<li><p>get timezone from <code>startdate</code> if it is <code>POSIXct</code>
</p>
</li>
<li><p>use passed in <code>timezone</code>
</p>
</li>
<li><p>get timezone from <code>sts</code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>sts_filterDatetime(
  sts = NULL,
  startdate = NULL,
  enddate = NULL,
  timezone = NULL,
  unit = "sec",
  ceilingStart = FALSE,
  ceilingEnd = FALSE,
  includeEnd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_filterDatetime_+3A_sts">sts</code></td>
<td>
<p>MazamaSingleTimeseries <em>sts</em> object.</p>
</td></tr>
<tr><td><code id="sts_filterDatetime_+3A_startdate">startdate</code></td>
<td>
<p>Desired start datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="sts_filterDatetime_+3A_enddate">enddate</code></td>
<td>
<p>Desired end datetime (ISO 8601).</p>
</td></tr>
<tr><td><code id="sts_filterDatetime_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates.</p>
</td></tr>
<tr><td><code id="sts_filterDatetime_+3A_unit">unit</code></td>
<td>
<p>Units used to determine time at end-of-day.</p>
</td></tr>
<tr><td><code id="sts_filterDatetime_+3A_ceilingstart">ceilingStart</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>startdate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
<tr><td><code id="sts_filterDatetime_+3A_ceilingend">ceilingEnd</code></td>
<td>
<p>Logical instruction to apply
<code><a href="lubridate.html#topic+ceiling_date">ceiling_date</a></code> to the <code>enddate</code> rather than
<code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
<tr><td><code id="sts_filterDatetime_+3A_includeend">includeEnd</code></td>
<td>
<p>Logical specifying that records associated with <code>enddate</code>
should be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>sts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Note</h3>

<p>The returned <code>sts</code> object will contain data running from the
beginning of <code>startdate</code> until
the <strong>beginning</strong> of <code>enddate</code> &ndash; <em>i.e.</em> no values associated
with <code>enddate</code> will be returned. To include <code>enddate</code> you can
specify <code>includeEnd = TRUE</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+sts_filter">sts_filter</a>
</p>
<p><a href="#topic+sts_filterDate">sts_filterDate</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

example_sts %&gt;%
  sts_filterDatetime(
    startdate = "2018-08-08 06:00:00",
    enddate = "2018-08-14 18:00:00"
  ) %&gt;%
  sts_extractData() %&gt;%
  head()

</code></pre>

<hr>
<h2 id='sts_isEmpty'>Test for empty <em>sts</em> object</h2><span id='topic+sts_isEmpty'></span>

<h3>Description</h3>

<p>Convenience function for <code>nrow(sts$data) == 0</code>.
This makes for more readable code in functions that need to test for this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sts_isEmpty(sts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_isEmpty_+3A_sts">sts</code></td>
<td>
<p><em>sts</em> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if no data exist in <code>sts</code>, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

sts_isEmpty(example_sts)

</code></pre>

<hr>
<h2 id='sts_isValid'>Test <em>sts</em> object for correct structure</h2><span id='topic+sts_isValid'></span>

<h3>Description</h3>

<p>The <code>sts</code> is checked for the presence of core
<code>meta</code> and <code>data</code> columns.
</p>
<p>Core <code>meta</code> columns include:
</p>

<ul>
<li><p><code>deviceDeploymentID</code> &ndash; unique identifier (see <a href="https://mazamascience.github.io/MazamaLocationUtils/">MazmaLocationUtils</a>)
</p>
</li>
<li><p><code>deviceID</code> &ndash; device identifier
</p>
</li>
<li><p><code>locationID</code> &ndash; location identifier (see <a href="https://mazamascience.github.io/MazamaLocationUtils/">MazmaLocationUtils</a>)
</p>
</li>
<li><p><code>locationName</code> &ndash; English language name
</p>
</li>
<li><p><code>longitude</code> &ndash; decimal degrees E
</p>
</li>
<li><p><code>latitude</code> &ndash; decimal degrees N
</p>
</li>
<li><p><code>elevation</code> &ndash; elevation of station in m
</p>
</li>
<li><p><code>countryCode</code> &ndash; ISO 3166-1 alpha-2
</p>
</li>
<li><p><code>stateCode</code> &ndash; ISO 3166-2 alpha-2
</p>
</li>
<li><p><code>timezone</code> &ndash; Olson time zone
</p>
</li></ul>

<p>Core <code>data</code> columns include:
</p>

<ul>
<li><p><code>datetime</code> &ndash; measurement time (UTC)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sts_isValid(sts = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_isValid_+3A_sts">sts</code></td>
<td>
<p><em>sts</em> object</p>
</td></tr>
<tr><td><code id="sts_isValid_+3A_verbose">verbose</code></td>
<td>
<p>Logical specifying whether to produce detailed warning messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>sts</code> has the correct structure,
<code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

sts_isValid(example_sts)

</code></pre>

<hr>
<h2 id='sts_summarize'>Create summary time series for an <em>sts</em> time series object</h2><span id='topic+sts_summarize'></span>

<h3>Description</h3>

<p>Columns of numeric data in <code>sts$data</code> are grouped by <code>unit</code> and then
summarized using <code>FUN</code>.
</p>
<p>Columns with non-numeric data are summarized by just picking the first
occurrence in each <code>unit</code>. This preserves the utility of columns
containing repeated metadata.
</p>
<p>The most typical use case is creating daily averages where each day begins at
midnight. Day boundaries are calculated using the specified <code>timezone</code>
or, if <code>NULL</code>, the time zone found in <code>sts$meta$timezone[1]</code>.
Leaving <code>timezone = NULL</code>, the default, results in &quot;local time&quot; date
filtering which is the most common use case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sts_summarize(
  sts,
  timezone = NULL,
  unit = c("day", "week", "month", "year"),
  FUN = NULL,
  ...,
  minCount = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_summarize_+3A_sts">sts</code></td>
<td>
<p><em>sts</em> object.</p>
</td></tr>
<tr><td><code id="sts_summarize_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates.</p>
</td></tr>
<tr><td><code id="sts_summarize_+3A_unit">unit</code></td>
<td>
<p>Unit used to summarize by (<em>e.g.</em> &quot;day&quot;).</p>
</td></tr>
<tr><td><code id="sts_summarize_+3A_fun">FUN</code></td>
<td>
<p>Function used to summarize time series.</p>
</td></tr>
<tr><td><code id="sts_summarize_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>FUN</code>
(_e.g._ <code>na.rm = TRUE</code>).</p>
</td></tr>
<tr><td><code id="sts_summarize_+3A_mincount">minCount</code></td>
<td>
<p>Minimum number of valid data records required to calculate
summaries. Time periods with fewer valid records will be assigned <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <em>sts</em> time series object containing daily (or other)
statistical summaries.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>

<hr>
<h2 id='sts_trimDate'>Trim <em>sts</em> time series object to full days</h2><span id='topic+sts_trimDate'></span>

<h3>Description</h3>

<p>Trims the date range of a <em>sts</em> object to local time date
boundaries which are <em>within</em> the range of data. This has the effect
of removing partial-day data records at the start and end of the timeseries
and is useful when calculating full-day statistics.
</p>
<p>Day boundaries are calculated using the specified <code>timezone</code> or, if
<code>NULL</code>, from <code>sts$meta$timezone</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sts_trimDate(sts = NULL, timezone = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sts_trimDate_+3A_sts">sts</code></td>
<td>
<p>SingleTimeSeries <em>sts</em> object.</p>
</td></tr>
<tr><td><code id="sts_trimDate_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone used to interpret dates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the incoming <em>sts</em> time series object.
(A list with <code>meta</code> and <code>data</code> dataframes.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

UTC_week &lt;- sts_filterDate(
  example_sts,
  startdate = 20180808,
  enddate = 20180815,
  timezone = "UTC"
)

# UTC day boundaries
head(UTC_week$data)

# Trim to local time day boundaries
local_week &lt;- sts_trimDate(UTC_week)
head(local_week$data)

</code></pre>

<hr>
<h2 id='timeInfo'>Get time related information</h2><span id='topic+timeInfo'></span>

<h3>Description</h3>

<p>Calculate the local time at the target location, as well as
sunrise, sunset and solar noon times, and create several temporal masks.
</p>
<p>The returned dataframe will have as many rows as the length of the incoming
UTC <code>time</code> vector and will contain the following columns:
</p>

<ul>
<li><p><code>localStdTime_UTC</code> &ndash; UTC representation of local <strong>standard</strong> time
</p>
</li>
<li><p><code>daylightSavings</code> &ndash; logical mask = TRUE if daylight savings is in effect
</p>
</li>
<li><p><code>localTime</code> &ndash; local clock time
</p>
</li>
<li><p><code>sunrise</code> &ndash; time of sunrise on each localTime day
</p>
</li>
<li><p><code>sunset</code> &ndash; time of sunset on each localTime day
</p>
</li>
<li><p><code>solarnoon</code> &ndash; time of solar noon on each localTime day
</p>
</li>
<li><p><code>day</code> &ndash; logical mask = TRUE between sunrise and sunset
</p>
</li>
<li><p><code>morning</code> &ndash; logical mask = TRUE between sunrise and solarnoon
</p>
</li>
<li><p><code>afternoon</code> &ndash; logical mask = TRUE between solarnoon and sunset
</p>
</li>
<li><p><code>night</code> &ndash; logical mask = opposite of day
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>timeInfo(time = NULL, longitude = NULL, latitude = NULL, timezone = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeInfo_+3A_time">time</code></td>
<td>
<p>POSIXct vector with specified timezone,</p>
</td></tr>
<tr><td><code id="timeInfo_+3A_longitude">longitude</code></td>
<td>
<p>Longitude of the location of interest.</p>
</td></tr>
<tr><td><code id="timeInfo_+3A_latitude">latitude</code></td>
<td>
<p>Latitude of the location of interest.</p>
</td></tr>
<tr><td><code id="timeInfo_+3A_timezone">timezone</code></td>
<td>
<p>Olson timezone at the location of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOAA used the reference below to develop their Sunrise/Sunset
</p>
<p><a href="https://gml.noaa.gov/grad/solcalc/sunrise.html">https://gml.noaa.gov/grad/solcalc/sunrise.html</a> and Solar
Position
</p>
<p><a href="https://gml.noaa.gov/grad/solcalc/azel.html">https://gml.noaa.gov/grad/solcalc/azel.html</a>
Calculators.  The algorithms include corrections for atmospheric
refraction effects.
</p>
<p>Input can consist of one location and at least one POSIXct times, or one
POSIXct time and at least one location.  <var>solarDep</var> is recycled as
needed.
</p>
<p>Do not use the daylight savings time zone string for supplying
<var>dateTime</var>, as many OS will not be able to properly set it to
standard time when needed.
</p>
<p>The <code>localStdTime_UTC</code> column in the returned dataframe is primarily for
internal use and provides an important tool for creating LST daily averages
and LST axis labeling.
</p>


<h3>Value</h3>

<p>A dataframe with times and masks.
</p>


<h3>Attribution</h3>

<p>Internal functions used for ephemerides calculations were copied verbatim
from the now deprecated <strong>maptools</strong> package source
code in an effort to reduce the number of package dependencies.
</p>


<h3>Warning</h3>

<p>Compared to NOAA's original Javascript code, the sunrise and sunset estimates
from this translation may differ by +/- 1 minute, based on tests using
selected locations spanning the globe. This translation does not include
calculation of prior or next sunrises/sunsets for locations above the Arctic
Circle or below the Antarctic Circle.
</p>


<h3>Local Standard Time</h3>

<p>US EPA regulations mandate that daily averages be calculated
based on &quot;Local Standard Time&quot; (LST) (<em>i.e. never shifting to daylight
savings</em>). To ease work in a regulatory context, LST times are included in the
returned dataframe.
</p>


<h3>References</h3>

<p>Meeus, J. (1991) Astronomical Algorithms. Willmann-Bell, Inc.
</p>


<h3>Note</h3>

<p>NOAA notes that “for latitudes greater than 72 degrees N and S,
calculations are accurate to within 10 minutes. For latitudes less than +/-
72 degrees accuracy is approximately one minute.”
</p>


<h3>Author(s)</h3>

<p>Sebastian P. Luque <a href="mailto:spluque@gmail.com">spluque@gmail.com</a>, translated from
Greg Pelletier's <a href="mailto:gpel461@ecy.wa.gov">gpel461@ecy.wa.gov</a> VBA code (available from
<a href="https://ecology.wa.gov/Research-Data/Data-resources/Models-spreadsheets/Modeling-the-environment/Models-tools-for-TMDLs">https://ecology.wa.gov/Research-Data/Data-resources/Models-spreadsheets/Modeling-the-environment/Models-tools-for-TMDLs</a>), who in turn
translated it from original Javascript code by NOAA (see Details).
Roger Bivand <a href="mailto:roger.bivand@nhh.no">roger.bivand@nhh.no</a> adapted the code to work with
<strong>sp</strong> classes. Jonathan Callahan <a href="mailto:jonathan.callahan@gmail.com">jonathan.callahan@gmail.com</a>
adapted the source code from the <strong>maptools</strong> package to work with
<a href="https://mazamascience.github.io/MazamaTimeSeries/">MazmaTimeSeries</a> classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaTimeSeries)

Carmel &lt;-
  Carmel_Valley %&gt;%
  mts_filterDate(20160801, 20160810)

# Create timeInfo object for this monitor
ti &lt;- timeInfo(
  Carmel$data$datetime,
  Carmel$meta$longitude,
  Carmel$meta$latitude,
  Carmel$meta$timezone
)

t(ti[6:9,])

# Subset the data based on day/night masks
data_day &lt;- Carmel$data[ti$day,]
data_night &lt;- Carmel$data[ti$night,]

# Build two monitor objects
Carmel_day &lt;- list(meta = Carmel$meta, data = data_day)
Carmel_night &lt;- list(meta = Carmel$meta, data = data_night)

# Plot them
plot(Carmel_day$data, pch = 8, col = 'goldenrod')
points(Carmel_night$data, pch = 16, col = 'darkblue')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
