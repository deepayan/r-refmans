<!DOCTYPE html><html lang="en"><head><title>Help for package qch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qch-package'><p>qch: Query Composite Hypotheses</p></a></li>
<li><a href='#Copula.Hconfig_gaussian_density'><p>Gaussian copula density for each Hconfiguration.</p></a></li>
<li><a href='#EM_calibration_gaussian'><p>EM calibration in the case of the gaussian copula (unsigned)</p></a></li>
<li><a href='#EM_calibration_gaussian_memory'><p>EM calibration in the case of the gaussian copula (unsigned) with memory management</p></a></li>
<li><a href='#EM_calibration_indep'><p>EM calibration in the case of conditional independence</p></a></li>
<li><a href='#EM_calibration_indep_memory'><p>EM calibration in the case of conditional independence with memory management (unsigned)</p></a></li>
<li><a href='#f1_separation_signed'><p>Signed case function: Separate f1 into f+ and f-</p></a></li>
<li><a href='#FastKerFdr_signed'><p>FastKerFdr signed</p></a></li>
<li><a href='#FastKerFdr_unsigned'><p>FastKerFdr unsigned</p></a></li>
<li><a href='#fHconfig_sum_update_gaussian_copula_ptr_parallel'><p>Computation of the sum sum_c(w_c*psi_c) using Gaussian copula parallelized version</p></a></li>
<li><a href='#fHconfig_sum_update_ptr_parallel'><p>Computation of the sum sum_c(w_c*psi_c) parallelized version</p></a></li>
<li><a href='#gaussian_copula_density'><p>Gaussian copula density</p></a></li>
<li><a href='#GetH1AtLeast'><p>Specify the configurations corresponding to the composite <code class="reqn">H_1</code> test &quot;AtLeast&quot;.</p></a></li>
<li><a href='#GetH1Equal'><p>Specify the configurations corresponding to the composite <code class="reqn">H_1</code> test &quot;Equal&quot;.</p></a></li>
<li><a href='#GetHconfig'><p>Generate the <code class="reqn">H_0</code>/<code class="reqn">H_1</code> configurations.</p></a></li>
<li><a href='#prior_update_arma_ptr_parallel'><p>Update of the prior estimate in EM algo parallelized version</p></a></li>
<li><a href='#prior_update_gaussian_copula_ptr_parallel'><p>Update of the prior estimate in EM algo using Gaussian copula, parallelized version</p></a></li>
<li><a href='#PvalSets'><p>Synthetic example to illustrate the main qch functions</p></a></li>
<li><a href='#PvalSets_cor'><p>Synthetic example to illustrate the main qch functions using gaussian copula</p></a></li>
<li><a href='#qch.fit'><p>Infer posterior probabilities of <code class="reqn">H_0</code>/<code class="reqn">H_1</code> configurations.</p></a></li>
<li><a href='#qch.test'><p>Perform composite hypothesis testing.</p></a></li>
<li><a href='#R_MLE_update_gaussian_copula_ptr_parallel'><p>Update the estimate of R correlation matrix of the gaussian copula, parallelized version</p></a></li>
<li><a href='#R.MLE'><p>Gaussian copula correlation matrix Maximum Likelihood estimator.</p></a></li>
<li><a href='#R.MLE.check'><p>Check the Gaussian copula correlation matrix Maximum Likelihood estimator</p></a></li>
<li><a href='#R.MLE.memory'><p>Gaussian copula correlation matrix Maximum Likelihood estimator (memory handling)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Query Composite Hypotheses</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tristan Mary-Huard &lt;tristan.mary-huard@agroparistech.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for the joint analysis of Q sets of
    p-values obtained for the same list of items. This joint analysis is
    performed by querying a composite hypothesis, i.e. an arbitrary
    complex combination of simple hypotheses, as described in Mary-Huard
    et al. (2021) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtab592">doi:10.1093/bioinformatics/btab592</a>&gt; and De Walsche et
    al.(2023) &lt;<a href="https://doi.org/10.1101%2F2024.03.17.585412">doi:10.1101/2024.03.17.585412</a>&gt;. In this approach, the
    Q-uplet of p-values associated with each item is distributed as a
    multivariate mixture, where each of the 2^Q components corresponds to
    a specific combination of simple hypotheses. The dependence between
    the p-value series is considered using a Gaussian copula function. A
    p-value for the composite hypothesis test is derived from the
    posterior probabilities.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>copula, dplyr, graphics, ks, purrr, qvalue, Rcpp, stats,
stringr, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-29 18:49:46 UTC; Annaig</td>
</tr>
<tr>
<td>Author:</td>
<td>Tristan Mary-Huard
    <a href="https://orcid.org/0000-0002-3839-9067"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Annaig De Walsche <a href="https://orcid.org/0000-0003-0603-1716"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Franck Gauthier <a href="https://orcid.org/0000-0003-0574-065X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-29 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='qch-package'>qch: Query Composite Hypotheses</h2><span id='topic+qch'></span><span id='topic+qch-package'></span>

<h3>Description</h3>

<p>Provides functions for the joint analysis of Q sets of p-values obtained for the same list of items. This joint analysis is performed by querying a composite hypothesis, i.e. an arbitrary complex combination of simple hypotheses, as described in Mary-Huard et al. (2021) <a href="https://doi.org/10.1093/bioinformatics/btab592">doi:10.1093/bioinformatics/btab592</a> and De Walsche et al.(2023) <a href="https://doi.org/10.1101/2024.03.17.585412">doi:10.1101/2024.03.17.585412</a>. In this approach, the Q-uplet of p-values associated with each item is distributed as a multivariate mixture, where each of the 2^Q components corresponds to a specific combination of simple hypotheses. The dependence between the p-value series is considered using a Gaussian copula function. A p-value for the composite hypothesis test is derived from the posterior probabilities.
</p>


<h3>Details</h3>

<p>The main functions of the package <code><a href="#topic+GetHconfig">GetHconfig</a></code>, <code><a href="#topic+GetH1AtLeast">GetH1AtLeast</a></code>,
<code><a href="#topic+GetH1Equal">GetH1Equal</a></code>,
<code><a href="#topic+qch.fit">qch.fit</a></code> and <code><a href="#topic+qch.test">qch.test</a></code> correspond to the
4 steps for querying a composite hypothesis:
</p>

<ul>
<li><p> Building all possible combination of simple hypotheses <code class="reqn">H_0</code>/<code class="reqn">H_1</code>
</p>
</li>
<li><p> Composite alternative hypothesis formulation
</p>
</li>
<li><p> Inferring the null distribution
</p>
</li>
<li><p> Testing the composite null hypothesis
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tristan Mary-Huard <a href="mailto:tristan.mary-huard@agroparistech.fr">tristan.mary-huard@agroparistech.fr</a> (<a href="https://orcid.org/0000-0002-3839-9067">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Annaig De Walsche <a href="mailto:annaig.de-walsche@inrae.fr">annaig.de-walsche@inrae.fr</a> (<a href="https://orcid.org/0000-0003-0603-1716">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Franck Gauthier <a href="mailto:franck.gauthier@inrae.fr">franck.gauthier@inrae.fr</a> (<a href="https://orcid.org/0000-0003-0574-065X">ORCID</a>) [contributor]
</p>
</li></ul>


<hr>
<h2 id='Copula.Hconfig_gaussian_density'>Gaussian copula density for each Hconfiguration.</h2><span id='topic+Copula.Hconfig_gaussian_density'></span>

<h3>Description</h3>

<p>Gaussian copula density for each Hconfiguration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Copula.Hconfig_gaussian_density(Hconfig, F0Mat, F1Mat, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Copula.Hconfig_gaussian_density_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of H0 and H1 hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="Copula.Hconfig_gaussian_density_+3A_f0mat">F0Mat</code></td>
<td>
<p>a matrix containing the evaluation of the marginal cdf under H0 at each items, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="Copula.Hconfig_gaussian_density_+3A_f1mat">F1Mat</code></td>
<td>
<p>a matrix containing the evaluation of the marginal cdf under H1 at each items, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="Copula.Hconfig_gaussian_density_+3A_r">R</code></td>
<td>
<p>the correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the evaluation of the Gaussian density function for each Hconfiguration in columns.
</p>

<hr>
<h2 id='EM_calibration_gaussian'>EM calibration in the case of the gaussian copula (unsigned)</h2><span id='topic+EM_calibration_gaussian'></span>

<h3>Description</h3>

<p>EM calibration in the case of the gaussian copula (unsigned)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM_calibration_gaussian(
  Hconfig,
  F0Mat,
  F1Mat,
  fHconfig,
  R.init,
  Prior.init,
  Precision = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_calibration_gaussian_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of H0 and H1 hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_+3A_f0mat">F0Mat</code></td>
<td>
<p>a matrix containing the evaluation of the marginal cdf under H0 at each items, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_+3A_f1mat">F1Mat</code></td>
<td>
<p>a matrix containing the evaluation of the marginal cdf under H1 at each items, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_+3A_fhconfig">fHconfig</code></td>
<td>
<p>a matrix containing config densities evaluated at each items, each column corresponding to a configurations.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_+3A_r.init">R.init</code></td>
<td>
<p>the initialization of the correlation matrix of the gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_+3A_prior.init">Prior.init</code></td>
<td>
<p>the initialization of prior probabilities for each of the H-configurations.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_+3A_precision">Precision</code></td>
<td>
<p>Precision for the stop criterion. (Default is 1e-6)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 objects 'priorHconfig' and 'Rcopula'.
Object 'priorHconfig' is a vector of estimated prior probabilities for each of the H-configurations.
Object 'Rcopula' is the estimated correlation matrix of the gaussian copula.
</p>

<hr>
<h2 id='EM_calibration_gaussian_memory'>EM calibration in the case of the gaussian copula (unsigned) with memory management</h2><span id='topic+EM_calibration_gaussian_memory'></span>

<h3>Description</h3>

<p>EM calibration in the case of the gaussian copula (unsigned) with memory management
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM_calibration_gaussian_memory(
  Logf0Mat,
  Logf1Mat,
  F0Mat,
  F1Mat,
  Prior.init,
  R.init,
  Hconfig,
  Precision = 1e-06,
  threads_nb
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_calibration_gaussian_memory_+3A_logf0mat">Logf0Mat</code></td>
<td>
<p>a matrix containing the log(f0(xi_q))</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_memory_+3A_logf1mat">Logf1Mat</code></td>
<td>
<p>a matrix containing the log(f1(xi_q))</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_memory_+3A_f0mat">F0Mat</code></td>
<td>
<p>a matrix containing the evaluation of the marginal cdf under H0 at each items, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_memory_+3A_f1mat">F1Mat</code></td>
<td>
<p>a matrix containing the evaluation of the marginal cdf under H1 at each items, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_memory_+3A_prior.init">Prior.init</code></td>
<td>
<p>the initialization of prior probabilities for each of the H-configurations.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_memory_+3A_r.init">R.init</code></td>
<td>
<p>the initialization of the correlation matrix of the gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_memory_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of H0 and H1 hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_memory_+3A_precision">Precision</code></td>
<td>
<p>Precision for the stop criterion. (Default is 1e-6)</p>
</td></tr>
<tr><td><code id="EM_calibration_gaussian_memory_+3A_threads_nb">threads_nb</code></td>
<td>
<p>The number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 objects 'priorHconfig' and 'Rcopula'.
Object 'priorHconfig' is a vector of estimated prior probabilities for each of the H-configurations.
Object 'Rcopula' is the estimated correlation matrix of the gaussian copula.
</p>

<hr>
<h2 id='EM_calibration_indep'>EM calibration in the case of conditional independence</h2><span id='topic+EM_calibration_indep'></span>

<h3>Description</h3>

<p>EM calibration in the case of conditional independence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM_calibration_indep(fHconfig, Prior.init, Precision = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_calibration_indep_+3A_fhconfig">fHconfig</code></td>
<td>
<p>a matrix containing config densities evaluated at each items, each column corresponding to a configurations.</p>
</td></tr>
<tr><td><code id="EM_calibration_indep_+3A_prior.init">Prior.init</code></td>
<td>
<p>the initialization of prior probabilities for each of the H-configurations.</p>
</td></tr>
<tr><td><code id="EM_calibration_indep_+3A_precision">Precision</code></td>
<td>
<p>Precision for the stop criterion. (Default is 1e-6)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of estimated prior probabilities for each of the H-configurations.
</p>

<hr>
<h2 id='EM_calibration_indep_memory'>EM calibration in the case of conditional independence with memory management (unsigned)</h2><span id='topic+EM_calibration_indep_memory'></span>

<h3>Description</h3>

<p>EM calibration in the case of conditional independence with memory management (unsigned)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM_calibration_indep_memory(
  Logf0Mat,
  Logf1Mat,
  Prior.init,
  Hconfig,
  Precision = 1e-06,
  threads_nb
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_calibration_indep_memory_+3A_logf0mat">Logf0Mat</code></td>
<td>
<p>a matrix containing the log(f0(xi_q))</p>
</td></tr>
<tr><td><code id="EM_calibration_indep_memory_+3A_logf1mat">Logf1Mat</code></td>
<td>
<p>a matrix containing the log(f1(xi_q))</p>
</td></tr>
<tr><td><code id="EM_calibration_indep_memory_+3A_prior.init">Prior.init</code></td>
<td>
<p>the initialization of prior probabilities for each of the H-configurations.</p>
</td></tr>
<tr><td><code id="EM_calibration_indep_memory_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of H0 and H1 hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="EM_calibration_indep_memory_+3A_precision">Precision</code></td>
<td>
<p>Precision for the stop criterion. (Default is 1e-6)</p>
</td></tr>
<tr><td><code id="EM_calibration_indep_memory_+3A_threads_nb">threads_nb</code></td>
<td>
<p>The number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of estimated prior probabilities for each of the H-configurations.
</p>

<hr>
<h2 id='f1_separation_signed'>Signed case function: Separate f1 into f+ and f-</h2><span id='topic+f1_separation_signed'></span>

<h3>Description</h3>

<p>Signed case function: Separate f1 into f+ and f-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f1_separation_signed(XMat, f0Mat, f1Mat, p0, plotting = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f1_separation_signed_+3A_xmat">XMat</code></td>
<td>
<p>a matrix of probit-transformed p-values, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="f1_separation_signed_+3A_f0mat">f0Mat</code></td>
<td>
<p>a matrix containing the evaluation of the marginal density functions under H0 at each items, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="f1_separation_signed_+3A_f1mat">f1Mat</code></td>
<td>
<p>a matrix containing the evaluation of the marginal density functions under H1 at each items, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="f1_separation_signed_+3A_p0">p0</code></td>
<td>
<p>the proportions of H0 items for each series.</p>
</td></tr>
<tr><td><code id="f1_separation_signed_+3A_plotting">plotting</code></td>
<td>
<p>boolean, should some diagnostic graphs be plotted. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 4 objects 'f1plusMat', 'f1minusMat', 'p1plus', 'p1minus'.
Object 'f1plusMat' is a matrix containing the evaluation of the marginal density functions under H1plus at each items, each column corresponding to a p-value serie.
Object 'f1minusMat' is a matrix containing the evaluation of the marginal density functions under H1minus at each items, each column corresponding to a p-value serie.
Object 'p1plus' is an estimate of the proportions of H1plus items for each series.
Object 'p1minus' is an estimate of the proportions of H1minus items for each series.
</p>

<hr>
<h2 id='FastKerFdr_signed'>FastKerFdr signed</h2><span id='topic+FastKerFdr_signed'></span>

<h3>Description</h3>

<p>FastKerFdr signed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FastKerFdr_signed(X, p0 = NULL, plotting = FALSE, NbKnot = 1e+05, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FastKerFdr_signed_+3A_x">X</code></td>
<td>
<p>a vector of probit-transformed p-values (corresponding to a p-value serie)</p>
</td></tr>
<tr><td><code id="FastKerFdr_signed_+3A_p0">p0</code></td>
<td>
<p>a priori proportion of H0 hypotheses</p>
</td></tr>
<tr><td><code id="FastKerFdr_signed_+3A_plotting">plotting</code></td>
<td>
<p>boolean, should some diagnostic graphs be plotted. Default is FALSE.</p>
</td></tr>
<tr><td><code id="FastKerFdr_signed_+3A_nbknot">NbKnot</code></td>
<td>
<p>The (maximum) number of knot for the kde procedure. Default is 1e5</p>
</td></tr>
<tr><td><code id="FastKerFdr_signed_+3A_tol">tol</code></td>
<td>
<p>a tolerance value for convergence. Default is 1e-5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 objects.
Object 'p0' is an estimate of the proportion of H0 hypotheses,
Object 'tau' is the vector of H1 posteriors,
Object 'f1' is a numeric vector, each coordinate i corresponding to the evaluation of the H1 density at point xi, where xi is the ith item in X.
Object 'F1' is a numeric vector, each coordinate i corresponding to the evaluation of the H1 ;cdf at point xi, where xi is the ith item in X.
</p>

<hr>
<h2 id='FastKerFdr_unsigned'>FastKerFdr unsigned</h2><span id='topic+FastKerFdr_unsigned'></span>

<h3>Description</h3>

<p>FastKerFdr unsigned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FastKerFdr_unsigned(
  X,
  p0 = NULL,
  plotting = FALSE,
  NbKnot = 1e+05,
  tol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FastKerFdr_unsigned_+3A_x">X</code></td>
<td>
<p>a vector of probit-transformed p-values (corresponding to a p-value serie)</p>
</td></tr>
<tr><td><code id="FastKerFdr_unsigned_+3A_p0">p0</code></td>
<td>
<p>a priori proportion of H0 hypotheses</p>
</td></tr>
<tr><td><code id="FastKerFdr_unsigned_+3A_plotting">plotting</code></td>
<td>
<p>boolean, should some diagnostic graphs be plotted. Default is FALSE.</p>
</td></tr>
<tr><td><code id="FastKerFdr_unsigned_+3A_nbknot">NbKnot</code></td>
<td>
<p>The (maximum) number of knot for the kde procedure. Default is 1e5</p>
</td></tr>
<tr><td><code id="FastKerFdr_unsigned_+3A_tol">tol</code></td>
<td>
<p>a tolerance value for convergence. Default is 1e-5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 objects.
Object 'p0' is an estimate of the proportion of H0 hypotheses,
Object 'tau' is the vector of H1 posteriors,
Object 'f1' is a numeric vector, each coordinate i corresponding to the evaluation of the H1 density at point xi, where xi is the ith item in X.
Object 'F1' is a numeric vector, each coordinate i corresponding to the evaluation of the H1 ;cdf at point xi, where xi is the ith item in X.
</p>

<hr>
<h2 id='fHconfig_sum_update_gaussian_copula_ptr_parallel'>Computation of the sum sum_c(w_c*psi_c) using Gaussian copula parallelized version</h2><span id='topic+fHconfig_sum_update_gaussian_copula_ptr_parallel'></span>

<h3>Description</h3>

<p>Computation of the sum sum_c(w_c*psi_c) using Gaussian copula parallelized version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fHconfig_sum_update_gaussian_copula_ptr_parallel(
  Hconfig,
  NewPrior,
  Logf0Mat,
  Logf1Mat,
  zeta0,
  zeta1,
  R,
  Rinv,
  threads_nb = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fHconfig_sum_update_gaussian_copula_ptr_parallel_+3A_hconfig">Hconfig</code></td>
<td>
<p>list of  vector of 0 and 1, corresponding to the configurations</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_gaussian_copula_ptr_parallel_+3A_newprior">NewPrior</code></td>
<td>
<p>a double vector containing the prior w_c</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_gaussian_copula_ptr_parallel_+3A_logf0mat">Logf0Mat</code></td>
<td>
<p>a double matrix containing the log(f0(xi_q))</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_gaussian_copula_ptr_parallel_+3A_logf1mat">Logf1Mat</code></td>
<td>
<p>a double matrix containing the log(f1(xi_q))</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_gaussian_copula_ptr_parallel_+3A_zeta0">zeta0</code></td>
<td>
<p>a double matrix containing the qnorm(F0(x_iq))</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_gaussian_copula_ptr_parallel_+3A_zeta1">zeta1</code></td>
<td>
<p>a double matrix containing the qnorm(F1(x_iq))</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_gaussian_copula_ptr_parallel_+3A_r">R</code></td>
<td>
<p>a double matrix corresponding to the copula parameter</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_gaussian_copula_ptr_parallel_+3A_rinv">Rinv</code></td>
<td>
<p>a double matrix corresponding to the inverse copula parameter</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_gaussian_copula_ptr_parallel_+3A_threads_nb">threads_nb</code></td>
<td>
<p>an int the number of threads</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a double vector containing sum_c(w_c*psi_c)
</p>

<hr>
<h2 id='fHconfig_sum_update_ptr_parallel'>Computation of the sum sum_c(w_c*psi_c) parallelized version</h2><span id='topic+fHconfig_sum_update_ptr_parallel'></span>

<h3>Description</h3>

<p>Computation of the sum sum_c(w_c*psi_c) parallelized version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fHconfig_sum_update_ptr_parallel(
  Hconfig,
  NewPrior,
  Logf0Mat,
  Logf1Mat,
  threads_nb = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fHconfig_sum_update_ptr_parallel_+3A_hconfig">Hconfig</code></td>
<td>
<p>list of  vector of 0 and 1, corresponding to the configurations</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_ptr_parallel_+3A_newprior">NewPrior</code></td>
<td>
<p>a double vector containing the prior w_c</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_ptr_parallel_+3A_logf0mat">Logf0Mat</code></td>
<td>
<p>a double matrix containing the log(f0(xi_q))</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_ptr_parallel_+3A_logf1mat">Logf1Mat</code></td>
<td>
<p>a double matrix containing the log(f1(xi_q))</p>
</td></tr>
<tr><td><code id="fHconfig_sum_update_ptr_parallel_+3A_threads_nb">threads_nb</code></td>
<td>
<p>an int the number of threads</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a double vector containing sum_c(w_c*psi_c)
</p>

<hr>
<h2 id='gaussian_copula_density'>Gaussian copula density</h2><span id='topic+gaussian_copula_density'></span>

<h3>Description</h3>

<p>Gaussian copula density
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_copula_density(zeta, R, Rinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussian_copula_density_+3A_zeta">zeta</code></td>
<td>
<p>the matrix of probit-transformed observations.</p>
</td></tr>
<tr><td><code id="gaussian_copula_density_+3A_r">R</code></td>
<td>
<p>the correlation matrix.</p>
</td></tr>
<tr><td><code id="gaussian_copula_density_+3A_rinv">Rinv</code></td>
<td>
<p>the inverse correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, each coordinate i corresponding to the evaluation of the Gaussian copula density function at observation zeta_i.
</p>

<hr>
<h2 id='GetH1AtLeast'>Specify the configurations corresponding to the composite <code class="reqn">H_1</code> test &quot;AtLeast&quot;.</h2><span id='topic+GetH1AtLeast'></span>

<h3>Description</h3>

<p>Specify which configurations among <code>Hconfig</code> correspond
to the composite alternative hypothesis : {at least &quot;<code>AtLeast</code>&quot; <code class="reqn">H_1</code> hypotheses are of interest }
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetH1AtLeast(Hconfig, AtLeast, Consecutive = FALSE, SameSign = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetH1AtLeast_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of <code class="reqn">H_0</code> and <code class="reqn">H_1</code> hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="GetH1AtLeast_+3A_atleast">AtLeast</code></td>
<td>
<p>How many <code class="reqn">H_1</code> hypotheses at least for the item to be of interest ? (an integer or a vector).</p>
</td></tr>
<tr><td><code id="GetH1AtLeast_+3A_consecutive">Consecutive</code></td>
<td>
<p>Should the significant test series be consecutive ? (optional, default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="GetH1AtLeast_+3A_samesign">SameSign</code></td>
<td>
<p>Should the significant test series have the same sign ? (optional, default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector '<code>Hconfig.H1</code>' of components of <code>Hconfig</code> that correspond to the '<code>AtLeast</code>' specification.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetH1Equal">GetH1Equal()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetH1AtLeast(GetHconfig(4),2)

</code></pre>

<hr>
<h2 id='GetH1Equal'>Specify the configurations corresponding to the composite <code class="reqn">H_1</code> test &quot;Equal&quot;.</h2><span id='topic+GetH1Equal'></span>

<h3>Description</h3>

<p>Specify which configurations among <code>Hconfig</code> correspond
to the composite alternative hypothesis :{Exaltly &quot;<code>Equal</code>&quot; <code class="reqn">H_1</code> hypotheses are of interest }
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetH1Equal(Hconfig, Equal, Consecutive = FALSE, SameSign = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetH1Equal_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of H0 and H1 hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="GetH1Equal_+3A_equal">Equal</code></td>
<td>
<p>What is the exact number of <code class="reqn">H_1</code> hypotheses for the item to be of interest? (an integer or a vector).</p>
</td></tr>
<tr><td><code id="GetH1Equal_+3A_consecutive">Consecutive</code></td>
<td>
<p>Should the significant test series be consecutive ? (optional, default is FALSE).</p>
</td></tr>
<tr><td><code id="GetH1Equal_+3A_samesign">SameSign</code></td>
<td>
<p>Should the significant test series have the same sign ? (optional, default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector '<code>Hconfig.H1</code>' of components of <code>Hconfig</code> that correspond to the '<code>Equal</code>' specification.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetH1AtLeast">GetH1AtLeast()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetH1Equal(GetHconfig(4),2)

</code></pre>

<hr>
<h2 id='GetHconfig'>Generate the <code class="reqn">H_0</code>/<code class="reqn">H_1</code> configurations.</h2><span id='topic+GetHconfig'></span>

<h3>Description</h3>

<p>Generate all possible combination of simple hypotheses <code class="reqn">H_0</code>/<code class="reqn">H_1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetHconfig(Q, Signed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetHconfig_+3A_q">Q</code></td>
<td>
<p>The number of test series to be combined.</p>
</td></tr>
<tr><td><code id="GetHconfig_+3A_signed">Signed</code></td>
<td>
<p>Should the sign of the effect be taken into account? (optional, default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list '<code>Hconfig</code>' of all possible combination of <code class="reqn">H_0</code> and <code class="reqn">H_1</code> hypotheses among <code class="reqn">Q</code> hypotheses tested.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetHconfig(4)

</code></pre>

<hr>
<h2 id='prior_update_arma_ptr_parallel'>Update of the prior estimate in EM algo parallelized version</h2><span id='topic+prior_update_arma_ptr_parallel'></span>

<h3>Description</h3>

<p>Update of the prior estimate in EM algo parallelized version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_update_arma_ptr_parallel(
  Hconfig,
  fHconfig_sum,
  OldPrior,
  Logf0Mat,
  Logf1Mat,
  threads_nb = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_update_arma_ptr_parallel_+3A_hconfig">Hconfig</code></td>
<td>
<p>list of  vector of 0 and 1, corresponding to the configurations</p>
</td></tr>
<tr><td><code id="prior_update_arma_ptr_parallel_+3A_fhconfig_sum">fHconfig_sum</code></td>
<td>
<p>a double vector containing sum_c(w_c*psi_c), obtained by fHconfig_sum_update_ptr_parallel()</p>
</td></tr>
<tr><td><code id="prior_update_arma_ptr_parallel_+3A_oldprior">OldPrior</code></td>
<td>
<p>a double vector containing the prior w_c</p>
</td></tr>
<tr><td><code id="prior_update_arma_ptr_parallel_+3A_logf0mat">Logf0Mat</code></td>
<td>
<p>a double matrix containing the log(f0(xi_q))</p>
</td></tr>
<tr><td><code id="prior_update_arma_ptr_parallel_+3A_logf1mat">Logf1Mat</code></td>
<td>
<p>a double matrix containing the log(f1(xi_q))</p>
</td></tr>
<tr><td><code id="prior_update_arma_ptr_parallel_+3A_threads_nb">threads_nb</code></td>
<td>
<p>an int the number of threads</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a double vector containing the new estimate of prior w_c
</p>

<hr>
<h2 id='prior_update_gaussian_copula_ptr_parallel'>Update of the prior estimate in EM algo using Gaussian copula, parallelized version</h2><span id='topic+prior_update_gaussian_copula_ptr_parallel'></span>

<h3>Description</h3>

<p>Update of the prior estimate in EM algo using Gaussian copula, parallelized version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_update_gaussian_copula_ptr_parallel(
  Hconfig,
  fHconfig_sum,
  OldPrior,
  Logf0Mat,
  Logf1Mat,
  zeta0,
  zeta1,
  R,
  Rinv,
  threads_nb = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_hconfig">Hconfig</code></td>
<td>
<p>list of  vector of 0 and 1, corresponding to the configurations</p>
</td></tr>
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_fhconfig_sum">fHconfig_sum</code></td>
<td>
<p>a double vector containing sum_c(w_c*psi_c), obtained by fHconfig_sum_update_ptr_parallel()</p>
</td></tr>
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_oldprior">OldPrior</code></td>
<td>
<p>a double vector containing the prior w_c</p>
</td></tr>
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_logf0mat">Logf0Mat</code></td>
<td>
<p>a double matrix containing the log(f0(xi_q))</p>
</td></tr>
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_logf1mat">Logf1Mat</code></td>
<td>
<p>a double matrix containing the log(f1(xi_q))</p>
</td></tr>
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_zeta0">zeta0</code></td>
<td>
<p>a double matrix containing the qnorm(F0(x_iq))</p>
</td></tr>
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_zeta1">zeta1</code></td>
<td>
<p>a double matrix containing the qnorm(F1(x_iq))</p>
</td></tr>
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_r">R</code></td>
<td>
<p>a double matrix corresponding to the copula parameter</p>
</td></tr>
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_rinv">Rinv</code></td>
<td>
<p>a double matrix corresponding to the inverse copula parameter</p>
</td></tr>
<tr><td><code id="prior_update_gaussian_copula_ptr_parallel_+3A_threads_nb">threads_nb</code></td>
<td>
<p>an int the number of threads</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a double vector containing the new estimate of prior w_c
</p>

<hr>
<h2 id='PvalSets'>Synthetic example to illustrate the main qch functions</h2><span id='topic+PvalSets'></span>

<h3>Description</h3>

<p>PvalSets is a data.frame with 10,000 rows and 3 columns. Each row corresponds to an item,
columns 'Pval1' and 'Pval2'  each correspond to a test serie over the items, and column 'Class'
provides the truth, i.e. if item <code class="reqn">i</code> belongs to class 1 then the H0 hypothesis is true for the 2 tests,
if item <code class="reqn">i</code> belongs to class 2 (resp. 3) then the H0 hypothesis is true for the first (resp. second)
test only, and if item <code class="reqn">i</code> belongs to class 4 then both H0 hypotheses are false (for the first
and the second test).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PvalSets
</code></pre>


<h3>Format</h3>

<p>A data.frame
</p>

<hr>
<h2 id='PvalSets_cor'>Synthetic example to illustrate the main qch functions using gaussian copula</h2><span id='topic+PvalSets_cor'></span>

<h3>Description</h3>

<p>PvalSets_cor is a data.frame with 10,000 rows and 3 columns. Each row corresponds to an item,
columns 'Pval1' and 'Pval2'  each correspond to a test serie over the items, and column 'Class'
provides the truth, i.e. if item <code class="reqn">i</code> belongs to class 1 then the H0 hypothesis is true for the 2 tests,
if item <code class="reqn">i</code> belongs to class 2 (resp. 3) then the H0 hypothesis is true for the first (resp. second)
test only, and if item <code class="reqn">i</code> belongs to class 4 then both H0 hypotheses are false (for the first
and the second test). The correlation between the two pvalues series within each class is 0.3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PvalSets_cor
</code></pre>


<h3>Format</h3>

<p>A data.frame
</p>

<hr>
<h2 id='qch.fit'>Infer posterior probabilities of <code class="reqn">H_0</code>/<code class="reqn">H_1</code> configurations.</h2><span id='topic+qch.fit'></span>

<h3>Description</h3>

<p>For each item, estimate the posterior probability for each configuration.
This function use either the model accounting for the dependence structure
through a Gaussian copula function (<code>copula=="gaussian"</code>) or
assuming the conditional independence (<code>copula=="indep"</code>).
Utilizes parallel computing, when available. For package documentation, see <code><a href="#topic+qch-package">qch-package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qch.fit(
  pValMat,
  EffectMat = NULL,
  Hconfig,
  copula = "indep",
  threads_nb = 0,
  plotting = FALSE,
  Precision = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qch.fit_+3A_pvalmat">pValMat</code></td>
<td>
<p>A matrix of p-values, each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="qch.fit_+3A_effectmat">EffectMat</code></td>
<td>
<p>A matrix of estimated effects corresponding to the p-values contained in pValMat. If specified, the procedure will account for the direction of the effect. (optional, default is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="qch.fit_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of <code class="reqn">H_0</code> and <code class="reqn">H_1</code> hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="qch.fit_+3A_copula">copula</code></td>
<td>
<p>A string specifying the form of copula to use. Possible values are &quot;<code>indep</code>&quot;and &quot;<code>gaussian</code>&quot;. Default is &quot;<code>indep</code>&quot; corresponding to the independent case.</p>
</td></tr>
<tr><td><code id="qch.fit_+3A_threads_nb">threads_nb</code></td>
<td>
<p>The number of threads to use. The number of thread will set to the number of core available by default.</p>
</td></tr>
<tr><td><code id="qch.fit_+3A_plotting">plotting</code></td>
<td>
<p>A boolean. Should some diagnostic graphs be plotted ? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="qch.fit_+3A_precision">Precision</code></td>
<td>
<p>The precision for EM algorithm to infer the parameters. Default is <code>1e-6</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>prior</code> </td><td style="text-align: left;"> vector of estimated prior probabilities
for each of the H-configurations.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Rcopula</code> </td><td style="text-align: left;"> the estimated correlation matrix of the Gaussian copula.
(if applicable)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Hconfig</code> </td><td style="text-align: left;"> the list of all configurations.
</td>
</tr>

</table>


<ul>
<li><p> If the storage permits, the list will additionally contain:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>posterior</code> </td><td style="text-align: left;"> matrix providing for each item (in row) its posterior probability to
belong to each of the H-configurations (in columns).</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>fHconfig</code> </td><td style="text-align: left;"> matrix containing <code class="reqn">\psi_c</code> densities evaluated at each items,
each column corresponding to a configuration.
</td>
</tr>

</table>

</li>
<li><p> Else, the list will additionally contain:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>f0Mat</code> </td><td style="text-align: left;"> matrix containing the evaluation of the marginal densities under <code class="reqn">H_0</code> at each items,
each column corresponding to a p-value serie.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>f1Mat</code> </td><td style="text-align: left;"> matrix containing the evaluation of the marginal densities under <code class="reqn">H_1</code> at each items,
each column corresponding to a p-value serie.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>F0Mat</code> </td><td style="text-align: left;"> matrix containing the evaluation of the marginal cdf under <code class="reqn">H_0</code> at each items,
each column corresponding to a p-value serie.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>F1Mat</code> </td><td style="text-align: left;"> matrix containing the evaluation of the marginal cdf under <code class="reqn">H_1</code> at each items,
each column corresponding to a p-value serie.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>fHconfig_sum</code> </td><td style="text-align: left;"> vector containing <code class="reqn">(\sum_cw_c\psi_c(Z_i))</code> for each items <code class="reqn">i</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

</li></ul>

<p>The elements of interest are the posterior probabilities matrix, <code>posterior</code>,
the estimated proportion of observations belonging to each configuration, <code>prior</code>, and
the estimated correlation matrix of the Gaussian copula, <code>Rcopula</code>.
The remaining elements are returned primarily for use by other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PvalSets_cor)
PvalMat &lt;- as.matrix(PvalSets_cor[,-3])
## Build the Hconfig objects
Q &lt;- 2
Hconfig &lt;- GetHconfig(Q)

## Run the function
res.fit &lt;- qch.fit(pValMat = PvalMat,Hconfig = Hconfig,copula="gaussian")

## Display the prior of each class of items
res.fit$prior

## Display the correlation estimate of the gaussian copula
res.fit$Rcopula

## Display the first posteriors
head(res.fit$posterior)
</code></pre>

<hr>
<h2 id='qch.test'>Perform composite hypothesis testing.</h2><span id='topic+qch.test'></span>

<h3>Description</h3>

<p>Perform any composite hypothesis test by specifying
the configurations '<code>Hconfig.H1</code>' corresponding to the composite alternative hypothesis
among all configurations '<code>Hconfig</code>'.
</p>
<p>By default, the function performs the composite hypothesis test of being associated with &quot;at least <code class="reqn">q</code>&quot; simple tests, for <code class="reqn">q=1,..Q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qch.test(res.qch.fit, Hconfig, Hconfig.H1 = NULL, Alpha = 0.05, threads_nb = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qch.test_+3A_res.qch.fit">res.qch.fit</code></td>
<td>
<p>The result provided by the <code><a href="#topic+qch.fit">qch.fit()</a></code> function.</p>
</td></tr>
<tr><td><code id="qch.test_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of <code class="reqn">H_0</code> and <code class="reqn">H_1</code> hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="qch.test_+3A_hconfig.h1">Hconfig.H1</code></td>
<td>
<p>An integer vector (or a list of such vector) of the <code>Hconfig</code> index corresponding to the composite alternative hypothesis configuration(s).
Can be generated by the <code><a href="#topic+GetH1AtLeast">GetH1AtLeast()</a></code> or <code><a href="#topic+GetH1Equal">GetH1Equal()</a></code> functions.
If <code>NULL</code>, the composite hyporhesis tests of being associated with &quot;at least <code class="reqn">q</code>&quot; simple tests, for q=1,..Q are performed.</p>
</td></tr>
<tr><td><code id="qch.test_+3A_alpha">Alpha</code></td>
<td>
<p>the nominal Type I error rate for FDR control. Default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="qch.test_+3A_threads_nb">threads_nb</code></td>
<td>
<p>The number of threads to use. The number of thread will set to the number of core available by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>Rejection</code> </td><td style="text-align: left;"> a matrix providing for each item the result of the composite hypothesis test,
after adaptive Benjamin-HÃ¶chberg multiple testing correction.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lFDR</code> </td><td style="text-align: left;"> a matrix providing for each item its local FDR estimate.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Pvalues</code> </td><td style="text-align: left;"> a matrix providing for each item its p-value of the composite hypothesis test.
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+qch.fit">qch.fit()</a></code>, <code><a href="#topic+GetH1AtLeast">GetH1AtLeast()</a></code>,<code><a href="#topic+GetH1Equal">GetH1Equal()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PvalSets_cor)
PvalMat &lt;- as.matrix(PvalSets_cor[,-3])
Truth &lt;- PvalSets[,3]

## Build the Hconfig objects
Q &lt;- 2
Hconfig &lt;- GetHconfig(Q)

## Infer the posteriors
res.fit &lt;- qch.fit(pValMat = PvalMat, Hconfig = Hconfig, copula="gaussian")

## Run the test procedure with FDR control
H1config &lt;- GetH1AtLeast(Hconfig,2)
res.test &lt;- qch.test(res.qch.fit = res.fit,Hconfig = Hconfig, Hconfig.H1 = H1config)
table(res.test$Rejection$AtLeast_2,Truth==4)


</code></pre>

<hr>
<h2 id='R_MLE_update_gaussian_copula_ptr_parallel'>Update the estimate of R correlation matrix of the gaussian copula, parallelized version</h2><span id='topic+R_MLE_update_gaussian_copula_ptr_parallel'></span>

<h3>Description</h3>

<p>Update the estimate of R correlation matrix of the gaussian copula, parallelized version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_MLE_update_gaussian_copula_ptr_parallel(
  Hconfig,
  fHconfig_sum,
  OldPrior,
  Logf0Mat,
  Logf1Mat,
  zeta0,
  zeta1,
  OldR,
  OldRinv,
  RhoIndex,
  threads_nb = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_hconfig">Hconfig</code></td>
<td>
<p>list of vector of 0 and 1, corresponding to the configurations</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_fhconfig_sum">fHconfig_sum</code></td>
<td>
<p>a double vector containing sum_c(w_c*psi_c), obtained by fHconfig_sum_update_ptr_parallel()</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_oldprior">OldPrior</code></td>
<td>
<p>a double vector containing the prior w_c</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_logf0mat">Logf0Mat</code></td>
<td>
<p>a double matrix containing the log(f0(xi_q))</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_logf1mat">Logf1Mat</code></td>
<td>
<p>a double matrix containing the log(f1(xi_q))</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_zeta0">zeta0</code></td>
<td>
<p>a double matrix containing the qnorm(F0(x_iq))</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_zeta1">zeta1</code></td>
<td>
<p>a double matrix containing the qnorm(F1(x_iq))</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_oldr">OldR</code></td>
<td>
<p>a double matrix corresponding to the copula parameter</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_oldrinv">OldRinv</code></td>
<td>
<p>a double matrix corresponding to the inverse copula parameter</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_rhoindex">RhoIndex</code></td>
<td>
<p>a int matrix containing the index of lower triangular part of a matrix</p>
</td></tr>
<tr><td><code id="R_MLE_update_gaussian_copula_ptr_parallel_+3A_threads_nb">threads_nb</code></td>
<td>
<p>an int the number of threads</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a double vector containing the lower triangular part of the MLE of R
</p>

<hr>
<h2 id='R.MLE'>Gaussian copula correlation matrix Maximum Likelihood estimator.</h2><span id='topic+R.MLE'></span>

<h3>Description</h3>

<p>Gaussian copula correlation matrix Maximum Likelihood estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.MLE(Hconfig, zeta0, zeta1, Tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.MLE_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of H0 and H1 hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="R.MLE_+3A_zeta0">zeta0</code></td>
<td>
<p>a matrix containing the Phi(F_0(Z_iq)), each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="R.MLE_+3A_zeta1">zeta1</code></td>
<td>
<p>a matrix containing the Phi(F_1(Z_iq)), each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="R.MLE_+3A_tau">Tau</code></td>
<td>
<p>a matrix providing for each item (in row) its posterior probability to belong to each of the H-configurations (in columns).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate of the correlation matrix.
</p>

<hr>
<h2 id='R.MLE.check'>Check the Gaussian copula correlation matrix Maximum Likelihood estimator</h2><span id='topic+R.MLE.check'></span>

<h3>Description</h3>

<p>Check the Gaussian copula correlation matrix Maximum Likelihood estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.MLE.check(R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.MLE.check_+3A_r">R</code></td>
<td>
<p>Estimate of the correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate of the correlation matrix.
</p>

<hr>
<h2 id='R.MLE.memory'>Gaussian copula correlation matrix Maximum Likelihood estimator (memory handling)</h2><span id='topic+R.MLE.memory'></span>

<h3>Description</h3>

<p>Gaussian copula correlation matrix Maximum Likelihood estimator (memory handling)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.MLE.memory(
  Hconfig,
  fHconfig_sum,
  OldPrior,
  Logf0Mat,
  Logf1Mat,
  zeta0,
  zeta1,
  OldR,
  OldRinv
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.MLE.memory_+3A_hconfig">Hconfig</code></td>
<td>
<p>A list of all possible combination of H0 and H1 hypotheses generated by the <code><a href="#topic+GetHconfig">GetHconfig()</a></code> function.</p>
</td></tr>
<tr><td><code id="R.MLE.memory_+3A_fhconfig_sum">fHconfig_sum</code></td>
<td>
<p>a vector containing sum_c(w_c*psi_c) for each items.</p>
</td></tr>
<tr><td><code id="R.MLE.memory_+3A_oldprior">OldPrior</code></td>
<td>
<p>a vector containing the prior probabilities for each of the H-configurations.</p>
</td></tr>
<tr><td><code id="R.MLE.memory_+3A_logf0mat">Logf0Mat</code></td>
<td>
<p>a matrix containing log(f0Mat), each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="R.MLE.memory_+3A_logf1mat">Logf1Mat</code></td>
<td>
<p>a matrix containing log(f1Mat), each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="R.MLE.memory_+3A_zeta0">zeta0</code></td>
<td>
<p>a matrix containing qnorm(F0Mat), each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="R.MLE.memory_+3A_zeta1">zeta1</code></td>
<td>
<p>a matrix containing qnorm(F1Mat), each column corresponding to a p-value serie.</p>
</td></tr>
<tr><td><code id="R.MLE.memory_+3A_oldr">OldR</code></td>
<td>
<p>the copula correlation matrix.</p>
</td></tr>
<tr><td><code id="R.MLE.memory_+3A_oldrinv">OldRinv</code></td>
<td>
<p>the inverse of copula correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate of the correlation matrix.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
