<!DOCTYPE html><html><head><title>Help for package vegdata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vegdata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#child'><p>Search taxonomic reference lists including concept synonomy and taxonomic hierarchy.</p></a></li>
<li><a href='#comb.species'><p>Combine species in vegetation matrix</p></a></li>
<li><a href='#cwm'><p>Indicate site conditions with community weighted mean values of traits or with mode of gradient classes (sum of species amplitudes).</p></a></li>
<li><a href='#db_download'><p>Download taxonomic databases</p></a></li>
<li><a href='#db_path'><p>database path</p></a></li>
<li><a href='#elbaue'><p>This is an example vegetation dataset to be included in package vegdata</p></a></li>
<li><a href='#lc.0'><p>Layer combinations</p></a></li>
<li><a href='#lc.1'><p>Layer combinations</p></a></li>
<li><a href='#lc.all'><p>Layer combinations</p></a></li>
<li><a href='#parent'><p>#' Parents of a taxon</p></a></li>
<li><a href='#parse.taxa'><p>Parse taxon strings into genus part and epitheta</p></a></li>
<li><a href='#recode.species'><p>Recode species names, lettercodes or ID's</p></a></li>
<li><a href='#sql_collect'><p>Query and get data back into a data.frame</p></a></li>
<li><a href='#src_vegdata'><p>src - dplyr src objects</p></a></li>
<li><a href='#syn'><p>Search synonyms of a taxon</p></a></li>
<li><a href='#syntab'><p>Syntaxonomic frequency tables</p></a></li>
<li><a href='#tax'><p>Search taxonomic reference lists including concept synonomy and taxonomic hierarchy.</p></a></li>
<li><a href='#taxlevels'><p>Taxonomic hierarchy levels</p></a></li>
<li><a href='#taxname.abbr'><p>Standardisation of taxonomic names, especially taxon rank indicators and hybrid signs</p>
name taxname.abbr</a></li>
<li><a href='#taxname.removeAuthors'><p>Remove name authors from taxon names</p></a></li>
<li><a href='#taxname.simpl'><p>Simplify name parts for better string matching</p></a></li>
<li><a href='#taxval'><p>Handling of taxonomy in vegetation data.</p></a></li>
<li><a href='#TCS.replace'><p>Standardise taxon list field names to match the Taxonomic Concept Transfer Schema (TCS)</p></a></li>
<li><a href='#tdb_cache'><p>Caching</p></a></li>
<li><a href='#tv.bib'><p>Check bibliographic references from Turboveg codes</p></a></li>
<li><a href='#tv.coverperc'><p>Cover code translation</p></a></li>
<li><a href='#tv.db'><p>Read list of available Turboveg2 databases in given Turboveg directory</p></a></li>
<li><a href='#tv.home'><p>Where is your Turboveg 2 installation path?</p></a></li>
<li><a href='#tv.metadata'><p>Show metainfo of vegetation database or ecodbase</p></a></li>
<li><a href='#tv.obs'><p>Dataframe of plot-species observations directly from Turboveg</p></a></li>
<li><a href='#tv.readXML'><p>Reads a Turboveg XML file</p></a></li>
<li><a href='#tv.refl'><p>Taxon reference list to be used</p></a></li>
<li><a href='#TV.replace'><p>Rename data.frame columns to match Turboveg 2 conventions</p></a></li>
<li><a href='#tv.site'><p>Load site data from Turboveg Database</p></a></li>
<li><a href='#tv.traits'><p>Load species traits from Turboveg reference list</p></a></li>
<li><a href='#tv.veg'><p>Tabulates vegetation tables from Turboveg database</p></a></li>
<li><a href='#tv.write'><p>Write species-plot observations and site information to Turboveg database.</p></a></li>
<li><a href='#vegdata-package'><p>Functions to access data from vegetation databases and evaluate taxon names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9.12</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Access Vegetation Databases and Treat Taxonomy</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Jansen &lt;florian.jansen@uni-rostock.de&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Jansen &lt;florian.jansen@uni-rostock.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), foreign</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl (&ge; 2.4), DBI (&ge; 0.6-1), RSQLite (&ge; 1.1.2), dplyr (&ge;
0.7.0), dbplyr (&ge; 1.0.0), magrittr (&ge; 1.5), hoardr (&ge;
0.1.0), indicspecies, utils, xml2 (&ge; 1.3.0), httr, stringr,
plyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>labdsv, interp, vegan, uuid, knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>Yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Handling of vegetation data from different sources (
	Turboveg 2.0 <a href="https://www.synbiosys.alterra.nl/turboveg/">https://www.synbiosys.alterra.nl/turboveg/</a>; 
	the German national repository <a href="https://www.vegetweb.de">https://www.vegetweb.de</a> and others. 
    Taxonomic harmonization (given appropriate taxonomic lists,
    e.g. the German taxonomic standard list "GermanSL", <a href="https://germansl.infinitenature.org">https://germansl.infinitenature.org</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://germansl.infinitenature.org">https://germansl.infinitenature.org</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 17:48:12 UTC; jansen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-29 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='child'>Search taxonomic reference lists including concept synonomy and taxonomic hierarchy.</h2><span id='topic+child'></span>

<h3>Description</h3>

<p>Search all (accepted) children of a taxon down to gen generations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>child(x, refl, gen = 3, syn = FALSE, include.parent = FALSE, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="child_+3A_x">x</code></td>
<td>
<p>Species number, lettercode or species name(s)</p>
</td></tr>
<tr><td><code id="child_+3A_refl">refl</code></td>
<td>
<p>Taxonomic reference list</p>
</td></tr>
<tr><td><code id="child_+3A_gen">gen</code></td>
<td>
<p>Number of child generations to return</p>
</td></tr>
<tr><td><code id="child_+3A_syn">syn</code></td>
<td>
<p>Should synonyms be included in results</p>
</td></tr>
<tr><td><code id="child_+3A_include.parent">include.parent</code></td>
<td>
<p>Should the parent taxon be included in results</p>
</td></tr>
<tr><td><code id="child_+3A_quiet">quiet</code></td>
<td>
<p>Hide screen messages</p>
</td></tr>
<tr><td><code id="child_+3A_...">...</code></td>
<td>
<p>additional paarmeters for function tax</p>
</td></tr>
</table>


<h3>Details</h3>

<p><dfn>concept</dfn>: GermanSL is a list with a single taxon view according to the standard lists of the different taxon groups (e.g Wisskirchen and Haeupler for higher plants, see).
Nevertheless a huge number of synonyms is included which allows in many cases the transformation into different concepts.
For illustration the concept of <em>Armeria maritima</em> from Korneck 1996 is included, which accepts e.g. <em>Armeria maritima ssp. bottendorfensis</em>.
<dfn>parse.taxa</dfn>: parse genus and epitheta from name strings.
<dfn>taxname.removeAuthors</dfn> Remove name authors from full scientific name strings.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Jansen, F. and Dengler, J. (2008) GermanSL - eine universelle taxonomische Referenzliste f√ºr Vegetationsdatenbanken. Tuexenia, 28, 239-253.
</p>

<hr>
<h2 id='comb.species'>Combine species in vegetation matrix</h2><span id='topic+comb.species'></span>

<h3>Description</h3>

<p>Combine species in vegetation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb.species(x, sel, newname, refl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb.species_+3A_x">x</code></td>
<td>
<p>(veg) vegetation matrix of class veg</p>
</td></tr>
<tr><td><code id="comb.species_+3A_sel">sel</code></td>
<td>
<p>(character) vector of species to combine</p>
</td></tr>
<tr><td><code id="comb.species_+3A_newname">newname</code></td>
<td>
<p>(character) name of the new taxon</p>
</td></tr>
<tr><td><code id="comb.species_+3A_refl">refl</code></td>
<td>
<p>(character) Name of taxonomic reference list</p>
</td></tr>
</table>

<hr>
<h2 id='cwm'>Indicate site conditions with community weighted mean values of traits or with mode of gradient classes (sum of species amplitudes).</h2><span id='topic+cwm'></span>

<h3>Description</h3>

<p>Calculates community weighted mean trait values, like mean Ellenberg indicator values.
Alternatively (method = 'mode') environmental conditions can be calculated according to the concept of sums of amplitudes of species along ecological gradients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwm(veg, refl, trait.db = 'ecodbase.dbf', ivname, keyname = 'LETTERCODE',
      method, weight, db, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cwm_+3A_veg">veg</code></td>
<td>
<p>Vegetation matrix with plots in rows and species in columns</p>
</td></tr>
<tr><td><code id="cwm_+3A_refl">refl</code></td>
<td>
<p>Name of Turboveg taxonomic reference list</p>
</td></tr>
<tr><td><code id="cwm_+3A_trait.db">trait.db</code></td>
<td>
<p>data frame with species trait values</p>
</td></tr>
<tr><td><code id="cwm_+3A_ivname">ivname</code></td>
<td>
<p>Name of the trait in trait.db to be used</p>
</td></tr>
<tr><td><code id="cwm_+3A_keyname">keyname</code></td>
<td>
<p>Name of the column in trait dataframe to join with colnames of veg table</p>
</td></tr>
<tr><td><code id="cwm_+3A_method">method</code></td>
<td>
<p>mean (weighted value of single traits, or mode (maximum) of trait classes)</p>
</td></tr>
<tr><td><code id="cwm_+3A_weight">weight</code></td>
<td>
<p>additional weight, e.g niche breath of species</p>
</td></tr>
<tr><td><code id="cwm_+3A_db">db</code></td>
<td>
<p>name of Turboveg database</p>
</td></tr>
<tr><td><code id="cwm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trait values of 0 will be handled as NA values because Turboveg dBase can not handle NA values properly.
</p>


<h3>Value</h3>

<p>Vector with the ecological classification of sites. Either mean trait values or mode of gradient classes.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    db &lt;- 'elbaue'
    veg &lt;- tv.veg(db, cover.transform='sqrt', check.critical = FALSE)
    site &lt;- tv.site(db, verbose = FALSE)
    #' Exclude plots with very high water level fluctuation
    veg &lt;- veg[site$SDGL &lt; 60,]
    veg &lt;- veg[,colSums(veg) &gt; 0]
    site &lt;- site[site$SDGL &lt; 60,]
    #' Load species trait value database
    traits &lt;- tv.traits(db)

    #' Mean indicator values of Ellenberg F values
    mEIV_F &lt;- cwm(veg, trait.db = traits, ivname = 'OEK_F', method = 'mean')
    plot(site$MGL, mEIV_F, xlab = 'Mean groundwater level')

    #' Mode (most frequent level) of Ellenberg F values
    ilevel &lt;- cwm(veg, trait.db = traitmat, ivname = as.character(1:11), method = 'mode')
    mode &lt;- as.numeric(cwm(veg, trait.db = traits, ivname = 'OEK_F', method = 'mode'))
    boxplot(site$MGL ~ mode)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='db_download'>Download taxonomic databases</h2><span id='topic+db_download'></span><span id='topic+db_download_eurosl'></span><span id='topic+db_download_germansl'></span>

<h3>Description</h3>

<p>Download taxonomic databases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_download_eurosl(version = "latest", verbose = TRUE, overwrite = FALSE)

db_download_germansl(version = "latest", verbose = TRUE, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_download_+3A_version">version</code></td>
<td>
<p>(character) desired version number of the list</p>
</td></tr>
<tr><td><code id="db_download_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Print messages. Default: 'TRUE'</p>
</td></tr>
<tr><td><code id="db_download_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) If 'TRUE' force an update by overwriting
previously downloaded data. Default: 'FALSE'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Downloads sql database, cleans up unneeded files, returns path
to sql file
</p>


<h3>Value</h3>

<p>(character) path to the downloaded SQL database
</p>


<h3>See Also</h3>

<p>[tdb_cache]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# EuroSL
# db_download_eurosl()
# src_eurosl()

# GermanSL
# db_download_germansl()
# db_download_germansl(overwrite=TRUE) # overwrite - download again
# src_germansl()


## End(Not run)
</code></pre>

<hr>
<h2 id='db_path'>database path</h2><span id='topic+db_path'></span>

<h3>Description</h3>

<p>database path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_path(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_path_+3A_db">db</code></td>
<td>
<p>(character) db name. one of: eurosl, germansl</p>
</td></tr>
</table>

<hr>
<h2 id='elbaue'>This is an example vegetation dataset to be included in package vegdata</h2><span id='topic+elbaue'></span>

<h3>Description</h3>

<p>This is an example vegetation dataset to be included in package vegdata
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>References</h3>

<p><a href="https://www.vegetweb.de">https://www.vegetweb.de</a>
</p>

<hr>
<h2 id='lc.0'>Layer combinations</h2><span id='topic+lc.0'></span>

<h3>Description</h3>

<p>datasets with layer codes and how they should be combined
in vegetation anlyses. lc.o: do not combine any layers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lc.0
</code></pre>


<h3>Format</h3>

<p>A data frame with rows and 2 variables:
</p>

<dl>
<dt>LAYER</dt><dd><p>Layer code, i.e. 0:9 for Turboveg</p>
</dd>
<dt>COMB</dt><dd><p>Combinations. Same integer means, they will be combined</p>
</dd>
</dl>


<hr>
<h2 id='lc.1'>Layer combinations</h2><span id='topic+lc.1'></span>

<h3>Description</h3>

<p>datasets with layer codes and how they should be combined
in vegetation anlyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lc.1
</code></pre>


<h3>Format</h3>

<p>A data frame with rows and 3 variables:
</p>

<dl>
<dt>LAYER</dt><dd><p>Layer code, i.e. 0:9 for Turboveg</p>
</dd>
<dt>COMB</dt><dd><p>Combinations. Same integer means, they will be combined</p>
</dd>
</dl>


<hr>
<h2 id='lc.all'>Layer combinations</h2><span id='topic+lc.all'></span>

<h3>Description</h3>

<p>combine all layers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lc.all
</code></pre>


<h3>Format</h3>

<p>A data frame with rows and 2 variables:
</p>

<dl>
<dt>LAYER</dt><dd><p>Layer code, i.e. 0:9 for Turboveg</p>
</dd>
<dt>COMB</dt><dd><p>Combinations. Same integer means, they will be combined</p>
</dd>
</dl>


<hr>
<h2 id='parent'>#' Parents of a taxon</h2><span id='topic+parent'></span>

<h3>Description</h3>

<p>#' Parents of a taxon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parent(x, refl = tv.refl(), rank, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent_+3A_x">x</code></td>
<td>
<p>Species number, lettercode or species name(s)</p>
</td></tr>
<tr><td><code id="parent_+3A_refl">refl</code></td>
<td>
<p>Taxonomic reference list</p>
</td></tr>
<tr><td><code id="parent_+3A_rank">rank</code></td>
<td>
<p>taxonomic level of taxa to find</p>
</td></tr>
<tr><td><code id="parent_+3A_quiet">quiet</code></td>
<td>
<p>Hide screen messages</p>
</td></tr>
<tr><td><code id="parent_+3A_...">...</code></td>
<td>
<p>additional attributes for function tax</p>
</td></tr>
</table>


<h3>Details</h3>

<p><dfn>concept</dfn>: GermanSL is a list with a single taxon view according to the standard lists of the different taxon groups (e.g Wisskirchen and Haeupler for higher plants, see).
Nevertheless a huge number of synonyms is included which allows in many cases the transformation into different concepts.
For illustration the concept of <em>Armeria maritima</em> from Korneck 1996 is included, which accepts e.g. <em>Armeria maritima ssp. bottendorfensis</em>.
<dfn>parse.taxa</dfn>: parse genus and epitheta from name strings.
<dfn>taxname.removeAuthors</dfn> Remove name authors from full scientific name strings.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Jansen, F. and Dengler, J. (2008) GermanSL - eine universelle taxonomische Referenzliste f√ºr Vegetationsdatenbanken. Tuexenia, 28, 239-253.
</p>

<hr>
<h2 id='parse.taxa'>Parse taxon strings into genus part and epitheta</h2><span id='topic+parse.taxa'></span>

<h3>Description</h3>

<p>Parse taxon strings into genus part and epitheta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.taxa(x, epis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.taxa_+3A_x">x</code></td>
<td>
<p>(character) taxon names</p>
</td></tr>
<tr><td><code id="parse.taxa_+3A_epis">epis</code></td>
<td>
<p>(character) vector of separators for epithets (like e.g. &quot;subsp.&quot;)</p>
</td></tr>
</table>

<hr>
<h2 id='recode.species'>Recode species names, lettercodes or ID's</h2><span id='topic+recode.species'></span>

<h3>Description</h3>

<p>Recode species names, lettercodes or ID's
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode.species(
  x,
  names = c("shortletters", "Numbers", "ScientificNames"),
  refl
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode.species_+3A_x">x</code></td>
<td>
<p>vector of species</p>
</td></tr>
<tr><td><code id="recode.species_+3A_names">names</code></td>
<td>
<p>one of 7digit shortletter codes, species id's or scientific species names</p>
</td></tr>
<tr><td><code id="recode.species_+3A_refl">refl</code></td>
<td>
<p>(character) name of taxon reference list</p>
</td></tr>
</table>

<hr>
<h2 id='sql_collect'>Query and get data back into a data.frame</h2><span id='topic+sql_collect'></span>

<h3>Description</h3>

<p>Query and get data back into a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_collect(src, query, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_collect_+3A_src">src</code></td>
<td>
<p>(src) An 'src' object, result of calling [src_germansl()],
[src_eurosl()]</p>
</td></tr>
<tr><td><code id="sql_collect_+3A_query">query</code></td>
<td>
<p>(character) A SQL query</p>
</td></tr>
<tr><td><code id="sql_collect_+3A_...">...</code></td>
<td>
<p>further args passed on to [dplyr::tbl()]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>we run [dplyr::tbl()], then [dplyr::collect()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
src &lt;- src_germansl()
sql_collect(src, "select * from GermanSL limit 5")
## or pipe the src to sql_collect
src %&gt;% sql_collect("select * from GermanSL limit 5")

## End(Not run)
</code></pre>

<hr>
<h2 id='src_vegdata'>src - dplyr src objects</h2><span id='topic+src_vegdata'></span><span id='topic+src_eurosl'></span><span id='topic+src_germansl'></span>

<h3>Description</h3>

<p>src - dplyr src objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_eurosl(path = db_path("eurosl"), ...)

src_germansl(path = db_path("germansl"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="src_vegdata_+3A_path">path</code></td>
<td>
<p>(character) path to SQLite database. by default
we use the function [db_path()] to get the path</p>
</td></tr>
<tr><td><code id="src_vegdata_+3A_...">...</code></td>
<td>
<p>Further args passed on to [DBI::dbConnect()]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an src object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# src_eurosl()
# src_germansl()

## End(Not run)
</code></pre>

<hr>
<h2 id='syn'>Search synonyms of a taxon</h2><span id='topic+syn'></span>

<h3>Description</h3>

<p>Search synonyms of a taxon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn(x, refl = tv.refl(), quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn_+3A_x">x</code></td>
<td>
<p>Species number, lettercode or species name(s)</p>
</td></tr>
<tr><td><code id="syn_+3A_refl">refl</code></td>
<td>
<p>Taxonomic reference list</p>
</td></tr>
<tr><td><code id="syn_+3A_quiet">quiet</code></td>
<td>
<p>Hide screen messages</p>
</td></tr>
<tr><td><code id="syn_+3A_...">...</code></td>
<td>
<p>additional attributes for function tax</p>
</td></tr>
</table>


<h3>Details</h3>

<p><dfn>concept</dfn>: GermanSL is a list with a single taxon view according to the standard lists of the different taxon groups (e.g Wisskirchen and Haeupler for higher plants, see).
Nevertheless a huge number of synonyms is included which allows in many cases the transformation into different concepts.
For illustration the concept of <em>Armeria maritima</em> from Korneck 1996 is included, which accepts e.g. <em>Armeria maritima ssp. bottendorfensis</em>.
<dfn>parse.taxa</dfn>: parse genus and epitheta from name strings.
<dfn>taxname.removeAuthors</dfn> Remove name authors from full scientific name strings.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Jansen, F. and Dengler, J. (2008) GermanSL - eine universelle taxonomische Referenzliste f√ºr Vegetationsdatenbanken. Tuexenia, 28, 239-253.
</p>

<hr>
<h2 id='syntab'>Syntaxonomic frequency tables</h2><span id='topic+syntab'></span><span id='topic+print.syntab'></span>

<h3>Description</h3>

<p>Calculate and display relative or absolute frequency tables with or without use of function multipatt from package indicspecies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syntab(veg, clust, type = c('rel','abs','mean.cover'), mupa, dec=0, refl, ...)

## S3 method for class 'syntab'
print(x, zero.print = ".", trait, limit = 1, minstat = 0, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syntab_+3A_veg">veg</code></td>
<td>
<p>Vegetation dataframe</p>
</td></tr>
<tr><td><code id="syntab_+3A_clust">clust</code></td>
<td>
<p>Vector with cluster information with length equal to number of rows of veg</p>
</td></tr>
<tr><td><code id="syntab_+3A_type">type</code></td>
<td>
<p>Relative or absolute frequency, mean species response values or strength of association.</p>
</td></tr>
<tr><td><code id="syntab_+3A_mupa">mupa</code></td>
<td>
<p>Either logical for (not) using multipatt from package indicspecies to detect significance of cluster association strength or supply output from previous use of multipatt.</p>
</td></tr>
<tr><td><code id="syntab_+3A_dec">dec</code></td>
<td>
<p>Number of decimals in result.</p>
</td></tr>
<tr><td><code id="syntab_+3A_refl">refl</code></td>
<td>
<p>Name of Turboveg taxonomic reference list to use for fullnames.</p>
</td></tr>
<tr><td><code id="syntab_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="syntab_+3A_x">x</code></td>
<td>
<p>Object from function syntab</p>
</td></tr>
<tr><td><code id="syntab_+3A_zero.print">zero.print</code></td>
<td>
<p>Replacement for zero values.</p>
</td></tr>
<tr><td><code id="syntab_+3A_trait">trait</code></td>
<td>
<p>Optional vector of trait values to be plotted behind the species.</p>
</td></tr>
<tr><td><code id="syntab_+3A_limit">limit</code></td>
<td>
<p>Minimum value to display.</p>
</td></tr>
<tr><td><code id="syntab_+3A_minstat">minstat</code></td>
<td>
<p>Minimal indicator value</p>
</td></tr>
<tr><td><code id="syntab_+3A_alpha">alpha</code></td>
<td>
<p>Significance threshold.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>See Also</h3>

<p>Package indicspecies with function <a href="indicspecies.html#topic+multipatt">multipatt</a> for indicator species analysis along multiple cluster combinations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 elbaue &lt;- tv.veg('elbaue')
 elbaue.env &lt;- tv.site('elbaue')
 clust &lt;- vector('integer', nrow(elbaue.env))
 clust[elbaue.env$MGL &lt; -50 &amp; elbaue.env$SDGL &lt; 50] &lt;- 1
 clust[elbaue.env$MGL &lt; -50 &amp; elbaue.env$SDGL &gt;= 50] &lt;- 2
 clust[elbaue.env$MGL &gt;= -50 &amp; elbaue.env$SDGL &gt;= 50] &lt;- 3
 clust[elbaue.env$MGL &gt;= -50 &amp; elbaue.env$SDGL &lt; 50] &lt;- 4
 levels(clust) &lt;- c('dry.ld','dry.hd', 'wet.hd','wet.ld')
 traits &lt;- tv.traits()
 m &lt;- match(rownames(st$syntab), traits$LETTERCODE, nomatch = 0)
 trait &lt;- traits[m, c("OEK_F","OEK_N")]
 rownames(trait) &lt;- traits$LETTERCODE[m]
 st &lt;- syntab(elbaue, clust, mupa=TRUE)
 print(st, limit=30, trait=trait)
 #'  Manipulation of the syntaxonomic table
 sttable &lt;- st$syntab
 sttable &lt;- sttable[sttable$p.value &lt; 0.05 &amp; !is.na(sttable$p.value),
 !names(sttable) %in% c('stat')]
 taxa &lt;- tax(rownames(sttable))
 rownames(sttable) &lt;- taxa[match(rownames(sttable), taxa$LETTERCODE, nomatch = 0),'TaxonName']
 write.csv(sttable, 'sttable.csv')

## End(Not run)

</code></pre>

<hr>
<h2 id='tax'>Search taxonomic reference lists including concept synonomy and taxonomic hierarchy.</h2><span id='topic+tax'></span>

<h3>Description</h3>

<p>Input is either species number (integer), shortletter (7 characters) or full (exact!) species name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tax(x, refl, detailed = TRUE, syn = TRUE, concept = NULL, strict = FALSE,
                        simplify = FALSE, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tax_+3A_x">x</code></td>
<td>
<p>Species number, lettercode or species name(s)</p>
</td></tr>
<tr><td><code id="tax_+3A_refl">refl</code></td>
<td>
<p>Taxonomic reference list</p>
</td></tr>
<tr><td><code id="tax_+3A_detailed">detailed</code></td>
<td>
<p>In old Turboveg versions detailed taxonomic information could only be given in an extra file which was called tax.dbf in GermanSL. Compatibility mode.</p>
</td></tr>
<tr><td><code id="tax_+3A_syn">syn</code></td>
<td>
<p>Return also synonym names</p>
</td></tr>
<tr><td><code id="tax_+3A_concept">concept</code></td>
<td>
<p>Name of the file with an alternative taxon view stored in the reference list directory, see details.</p>
</td></tr>
<tr><td><code id="tax_+3A_strict">strict</code></td>
<td>
<p>Exact match or partial matching with <code><a href="base.html#topic+grep">grep</a></code></p>
</td></tr>
<tr><td><code id="tax_+3A_simplify">simplify</code></td>
<td>
<p>Should taxname.simplify be applied to find species</p>
</td></tr>
<tr><td><code id="tax_+3A_quiet">quiet</code></td>
<td>
<p>Hide screen messages</p>
</td></tr>
<tr><td><code id="tax_+3A_...">...</code></td>
<td>
<p>additional attributes for taxname.abbr or taxname.simplify</p>
</td></tr>
</table>


<h3>Details</h3>

<p><dfn>concept</dfn>: GermanSL is a list with a single taxon view according to the standard lists of the different taxon groups (e.g Wisskirchen and Haeupler for higher plants, see).
Nevertheless a huge number of synonyms is included which allows in many cases the transformation into different concepts.
For illustration the concept of <em>Armeria maritima</em> from Korneck 1996 is included, which accepts e.g. <em>Armeria maritima ssp. bottendorfensis</em>.
<dfn>parse.taxa</dfn>: parse genus and epitheta from name strings.
<dfn>taxname.removeAuthors</dfn> Remove name authors from full scientific name strings.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Jansen, F. and Dengler, J. (2008) GermanSL - eine universelle taxonomische Referenzliste f√ºr Vegetationsdatenbanken. Tuexenia, 28, 239-253.
</p>

<hr>
<h2 id='taxlevels'>Taxonomic hierarchy levels</h2><span id='topic+taxlevels'></span>

<h3>Description</h3>

<p>hierarchy of taxon levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxlevels
</code></pre>


<h3>Format</h3>

<p>A data frame with rows and 3 variables:
</p>

<dl>
<dt>rank</dt><dd><p>Layer code, i.e. 0:9 for Turboveg</p>
</dd>
<dt>level</dt><dd><p>Combinations. Same integer means, they will be combined</p>
</dd>
<dt>Euro.Med</dt><dd><p>taxon level name in http://www.europlusmed.org/ database</p>
</dd>
<dt>description</dt><dd><p>Explanation of level codes</p>
</dd>
</dl>


<hr>
<h2 id='taxname.abbr'>Standardisation of taxonomic names, especially taxon rank indicators and hybrid signs
name taxname.abbr</h2><span id='topic+taxname.abbr'></span>

<h3>Description</h3>

<p>Standardisation of taxonomic names, especially taxon rank indicators and hybrid signs
name taxname.abbr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxname.abbr(x, hybrid = TRUE, concept = FALSE, species = TRUE, cf = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taxname.abbr_+3A_x">x</code></td>
<td>
<p>(integer or character) Species number, lettercode or species name(s)</p>
</td></tr>
<tr><td><code id="taxname.abbr_+3A_hybrid">hybrid</code></td>
<td>
<p>(logical) remove hybrid markers for comparisons</p>
</td></tr>
<tr><td><code id="taxname.abbr_+3A_concept">concept</code></td>
<td>
<p>(logical) remove concept additions like &quot;s. str.&quot;, &quot;s. l.</p>
</td></tr>
<tr><td><code id="taxname.abbr_+3A_species">species</code></td>
<td>
<p>(logical) remove &quot;spec.&quot;, &quot;sp.&quot;, or &quot;species&quot; for genus level taxa</p>
</td></tr>
<tr><td><code id="taxname.abbr_+3A_cf">cf</code></td>
<td>
<p>(logical) remove 'in doubt' marker</p>
</td></tr>
<tr><td><code id="taxname.abbr_+3A_...">...</code></td>
<td>
<p>additional attributes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Jansen florian.jansen@uni-rostock.de
</p>

<hr>
<h2 id='taxname.removeAuthors'>Remove name authors from taxon names</h2><span id='topic+taxname.removeAuthors'></span>

<h3>Description</h3>

<p>Remove name authors from taxon names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxname.removeAuthors(x, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taxname.removeAuthors_+3A_x">x</code></td>
<td>
<p>(character) vector of taxon names</p>
</td></tr>
<tr><td><code id="taxname.removeAuthors_+3A_sep">sep</code></td>
<td>
<p>(character) vector of rank indicators</p>
</td></tr>
</table>

<hr>
<h2 id='taxname.simpl'>Simplify name parts for better string matching</h2><span id='topic+taxname.simpl'></span><span id='topic+taxname.simplify'></span>

<h3>Description</h3>

<p>Simplify name parts for better string matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxname.simplify(
  x,
  genus = TRUE,
  epithet = TRUE,
  concept = TRUE,
  rank = TRUE,
  tax.status = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taxname.simpl_+3A_x">x</code></td>
<td>
<p>(integer or character) Species number, lettercode or species name(s)</p>
</td></tr>
<tr><td><code id="taxname.simpl_+3A_genus">genus</code></td>
<td>
<p>(logical) simplify genus name part</p>
</td></tr>
<tr><td><code id="taxname.simpl_+3A_epithet">epithet</code></td>
<td>
<p>(logical) simplify epithet(s)</p>
</td></tr>
<tr><td><code id="taxname.simpl_+3A_concept">concept</code></td>
<td>
<p>(logical) remove name parts which describe taxon concept size like &quot;s. str.&quot;,&quot;s. l.&quot;</p>
</td></tr>
<tr><td><code id="taxname.simpl_+3A_rank">rank</code></td>
<td>
<p>(logical) remove rank specifications</p>
</td></tr>
<tr><td><code id="taxname.simpl_+3A_tax.status">tax.status</code></td>
<td>
<p>(logical) remove taxon status like 'nom. illeg.' or 'auct.'</p>
</td></tr>
<tr><td><code id="taxname.simpl_+3A_...">...</code></td>
<td>
<p>additional attributes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>taxname.abbr will be applied beforehand automatically. The function simplifies name parts which are empirically unstable, i.e. sylvatica might also written as silvatica, or majus vs. maius. Sex of latin genus or epithet name parts often change and are therefore deleted (us vs. a, ea vs. eos, etc.). Hybrid signs are removed. taxname.simpl works well for plant names, but be careful with very long name lists or if combined with animal taxa which are sometimes very short and can be confused after applying taxname.simpl
</p>


<h3>Author(s)</h3>

<p>Florian Jansen florian.jansen@uni-rostock.de
</p>

<hr>
<h2 id='taxval'>Handling of taxonomy in vegetation data.</h2><span id='topic+taxval'></span>

<h3>Description</h3>

<p>Performs taxonomic valuation of species names according to synonomy, taxonomic level, unambiguous biotic content etc.
Necessary prerequisite is information about taxonomic status (synonomy) and hierarchy (next higher aggregate).
Until now only applicable for reference list 'GermanSL' (&gt;= version 1.1, see References Section), which is valid in Germany and adjacent countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxval(obs, refl, db, ag = c('conflict', 'adapt', 'preserve'), rank,
mono = c('species', 'higher', 'lower', 'preserve'), monolist = "monotypic-D",
maxtaxlevel = 'AGG', check.critical = TRUE, interactive = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taxval_+3A_obs">obs</code></td>
<td>
<p>data.frame of observations in TURBOVEG format, for example loaded with <code><a href="#topic+tv.obs">tv.obs</a></code></p>
</td></tr>
<tr><td><code id="taxval_+3A_refl">refl</code></td>
<td>
<p>Name of taxonomic reference list</p>
</td></tr>
<tr><td><code id="taxval_+3A_db">db</code></td>
<td>
<p>a name of a Turboveg database directory containing <code>tvabund.dbf</code>, <code>tvhabita.dbf</code> and <code>twin.set</code></p>
</td></tr>
<tr><td><code id="taxval_+3A_ag">ag</code></td>
<td>
<p>Treatment of children and parents within the dataset, see details</p>
</td></tr>
<tr><td><code id="taxval_+3A_rank">rank</code></td>
<td>
<p>If ag='adapt', rank specifies the taxonomic rank to which taxa should be coarsened to. All higher taxa in this taxonomic tree will be deleted, see maxtaxlevel.</p>
</td></tr>
<tr><td><code id="taxval_+3A_mono">mono</code></td>
<td>
<p>Should monotypic taxa be combined at subspecies = <span class="option">lower</span> or species level = <span class="option">higher</span></p>
</td></tr>
<tr><td><code id="taxval_+3A_monolist">monolist</code></td>
<td>
<p>Name of monotypic species list, must be in dBase format and in the same directory as the reference list, e.g. <code>"monotypic-D"</code> for the area of Germany.</p>
</td></tr>
<tr><td><code id="taxval_+3A_maxtaxlevel">maxtaxlevel</code></td>
<td>
<p>Maximum taxonomic levels to be used. See details.</p>
</td></tr>
<tr><td><code id="taxval_+3A_check.critical">check.critical</code></td>
<td>
<p>Check for critical names in your dataset and give warnings.'</p>
</td></tr>
<tr><td><code id="taxval_+3A_interactive">interactive</code></td>
<td>
<p>Do you want to adapt the list of changes.</p>
</td></tr>
<tr><td><code id="taxval_+3A_...">...</code></td>
<td>
<p>Other parameters passed to functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Working with vegetation datasets, especially from different sources needs taxonomic valuation. The function tries to automate this process. Therefore the German taxonomic reference list (GermanSL, <a href="https://germansl.infinitenature.org">https://germansl.infinitenature.org</a> ) contains additional taxon attributes (tax.dbf) and monotypic taxa of Germany (monotypic.dbf). Without an appropriate species list (see <code><a href="#topic+tax">tax</a></code>) the function will not work.
</p>
<p>The taxonomic reference list needs Taxonrank corresponding to values given in  taxlevels
Possible values for adapting the taxonomic hierarchy within the dataset (child/parent taxa) are: <code>preserve</code>: Leave everything untouched. <code>conflict</code>: Dissolve only in case of conflicts, e.g. if a subspecies occurs also at the species level within the same dataset. In this case the subspecies will be aggregated to the higher level. <code>adapt</code>: Dissolve all nested taxa to e.g. species level for option ag. For this option also option <code>rank</code>, specifying the rank to which the taxa shall be adapted, must be given.
</p>
<p>Monotypic taxa, e.g. a species which occur only with 1 subspecies in the survey area. They have to be combined, since otherwise two different (valid) taxa would denominate the same entity. If lower the higher taxon (e.g. species rank) is replaced by the lower level (subspecies rank). If neither <code>lower</code> nor <code>higher</code> monotypic species are preserved. Since the list of monotypic species strongly depends on the considered area you have to choose, which area is covered by your database and create an appropriate list of monotypic taxa. Within the package <code>"monotypic-D.csv"</code> is provided as a compilation of monotypic species within the GermanSL list.
</p>
<p>Option maxtaxlevel determines the maximum taxonomic level within the given names, which should be used. All higher taxon observations are deleted. If you have a single field observation determined as <em>Asteraceae spec.</em> all your obervations of taxa from that family will be aggregated to the family level, if you choose ag=conflict.
</p>
<p><code>Interactive</code> If you want to manually adapt the taxonomic harmonization <code>interactive=TRUE</code> will create a table with all original names and NewTaxonID's according to the chosen rules. The table will be saved as <code>taxvalDecisionTable.csv</code> in your actual working directory. You can manipulate the column NewTaxonID. If you run <code>taxval</code> again (e.g. through function <code><a href="#topic+tv.veg">tv.veg</a></code>) and a file with this name exist in your working directory, it will be used.
</p>


<h3>Value</h3>

<p>Functions return the input dataframe of observations with harmonised taxon numbers.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Jansen, F. and Dengler, J. (2008) GermanSL - eine universelle taxonomische Referenzliste f\&quot;ur Vegetationsdatenbanken. Tuexenia, 28, 239-253.
Jansen, F. and Dengler, J. (2010) Plant names in vegetation databases - a neglected source of bias. Journal of Vegetation Science, 21, 1179-1186.
</p>


<h3>See Also</h3>

<p>tv.veg, tv.obs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Turboveg installation needed
 obs &lt;- taxval(db='taxatest')
# For explanations see vignette('vegdata').

 veg &lt;- tv.veg('taxatest')
 veg &lt;- comb.species(veg, c('ARMEM-E','ARMEM-H'))

## End(Not run)

</code></pre>

<hr>
<h2 id='TCS.replace'>Standardise taxon list field names to match the Taxonomic Concept Transfer Schema (TCS)</h2><span id='topic+TCS.replace'></span>

<h3>Description</h3>

<p>Applies Taxonomic Concept Transfer Schema (TCS) to the different name list conventions of different sources
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TCS.replace(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TCS.replace_+3A_x">x</code></td>
<td>
<p>(character) string of column names used in data.frames storing taxon lists</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Jansen florian.jansen@uni-rostock.de
</p>


<h3>References</h3>

<p>Taxonomic Names and Concepts interest group. 2006. Taxonomic Concept Transfer Schema (TCS), version 1.01. Biodiversity Information Standards (TDWG) http://www.tdwg.org/standards/117
</p>

<hr>
<h2 id='tdb_cache'>Caching</h2><span id='topic+tdb_cache'></span>

<h3>Description</h3>

<p>Manage cached vegdata files with <span class="pkg">hoardr</span>
</p>


<h3>Details</h3>

<p>'cache_delete' only accepts 1 file name, while
&lsquo;cache_delete_all' doesn&rsquo;t accept any names, but deletes all files.
For deleting many specific files, use 'cache_delete' in a [lapply()]
type call
</p>


<h3>Useful user functions</h3>

<p>- 'tdb_cache$cache_path_get()' get cache path
- 'tdb_cache$cache_path_set()' set cache path
- 'tdb_cache$list()' returns a character vector of full
path file names
- 'tdb_cache$files()' returns file objects with metadata
- 'tdb_cache$details()' returns files with details
- 'tdb_cache$delete()' delete specific files
- 'tdb_cache$delete_all()' delete all files, returns nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tdb_cache

# list files in cache
tdb_cache$list()

# delete certain database files
# tdb_cache$delete("file path")
# tdb_cache$list()

# delete all files in cache
# tdb_cache$delete_all()
# tdb_cache$list()

## End(Not run)
</code></pre>

<hr>
<h2 id='tv.bib'>Check bibliographic references from Turboveg codes</h2><span id='topic+tv.bib'></span>

<h3>Description</h3>

<p>Check bibliographic references from Turboveg codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.bib(x = "all", db, dict = tv.dict(db), quiet = FALSE, tv_home, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.bib_+3A_x">x</code></td>
<td>
<p>(character) Turboveg reference code(s), e.g. &quot;000001&quot;</p>
</td></tr>
<tr><td><code id="tv.bib_+3A_db">db</code></td>
<td>
<p>(character) Database name. Needed to select appropriate TV Dictionary folder.</p>
</td></tr>
<tr><td><code id="tv.bib_+3A_dict">dict</code></td>
<td>
<p>(character) Name of Turboveg Dictionary (term lists for header data) if not the default one.</p>
</td></tr>
<tr><td><code id="tv.bib_+3A_quiet">quiet</code></td>
<td>
<p>(logical) If you want to print the reference to the screen.</p>
</td></tr>
<tr><td><code id="tv.bib_+3A_tv_home">tv_home</code></td>
<td>
<p>(character) Turbowin installation path. If not specified function [tv.home()] tries to discover.</p>
</td></tr>
<tr><td><code id="tv.bib_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of (selected) bibliographic references (when assigned to an object).
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>

<hr>
<h2 id='tv.coverperc'>Cover code translation</h2><span id='topic+tv.coverperc'></span>

<h3>Description</h3>

<p>Translate cover code into percentage cover values for Turboveg database observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.coverperc(db, obs, RelScale, tv_home, tvscale, quiet = FALSE,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.coverperc_+3A_db">db</code></td>
<td>
<p>the name of the Turboveg database</p>
</td></tr>
<tr><td><code id="tv.coverperc_+3A_obs">obs</code></td>
<td>
<p>dataframe of observations, containing Cover Codes, coded in tvscale.dbf of Turboveg installation</p>
</td></tr>
<tr><td><code id="tv.coverperc_+3A_relscale">RelScale</code></td>
<td>
<p>Dataframe of CoverScale codes per releve, if empty it is read from the database</p>
</td></tr>
<tr><td><code id="tv.coverperc_+3A_tv_home">tv_home</code></td>
<td>
<p>Path to Turboveg installation</p>
</td></tr>
<tr><td><code id="tv.coverperc_+3A_tvscale">tvscale</code></td>
<td>
<p>Cover scale</p>
</td></tr>
<tr><td><code id="tv.coverperc_+3A_quiet">quiet</code></td>
<td>
<p>Suppress messages</p>
</td></tr>
<tr><td><code id="tv.coverperc_+3A_...">...</code></td>
<td>
<p>Further options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of observations with additional column COVER_PERC
</p>
<p>keywords Turboveg
</p>

<hr>
<h2 id='tv.db'>Read list of available Turboveg2 databases in given Turboveg directory</h2><span id='topic+tv.db'></span><span id='topic+tv.dict'></span>

<h3>Description</h3>

<p>Read list of available Turboveg2 databases in given Turboveg directory
</p>
<p>Read list of available Turboveg2 databases in given Turboveg directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.db(path)

tv.dict(db, tv_home)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.db_+3A_path">path</code></td>
<td>
<p>(character) directory path inside Turboveg/data directory</p>
</td></tr>
<tr><td><code id="tv.db_+3A_db">db</code></td>
<td>
<p>(character) name of Turboveg database/directory</p>
</td></tr>
<tr><td><code id="tv.db_+3A_tv_home">tv_home</code></td>
<td>
<p>(character) path of Turboveg instalation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of databases below specified path
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>

<hr>
<h2 id='tv.home'>Where is your Turboveg 2 installation path?</h2><span id='topic+tv.home'></span>

<h3>Description</h3>

<p>Reads and sets invisbly option('tv_home')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.home(check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.home_+3A_check">check</code></td>
<td>
<p>(logical) reset even if option('tv_home') is already set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reads and sets invisbly option('tv_home')
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>

<hr>
<h2 id='tv.metadata'>Show metainfo of vegetation database or ecodbase</h2><span id='topic+tv.metadata'></span>

<h3>Description</h3>

<p>Showing &quot;metadata.txt&quot; when specified and saved in Turboveg database directory.
When db = 'eco' and refl specified, metainfo of species attribute table is displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.metadata(db, refl, tv_home, filename = 'metadata.txt', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.metadata_+3A_db">db</code></td>
<td>
<p>Turboveg database name</p>
</td></tr>
<tr><td><code id="tv.metadata_+3A_refl">refl</code></td>
<td>
<p>Turboveg taxonomic reference list, declaration only necessary for ecodbase info</p>
</td></tr>
<tr><td><code id="tv.metadata_+3A_tv_home">tv_home</code></td>
<td>
<p>Turboveg installation path</p>
</td></tr>
<tr><td><code id="tv.metadata_+3A_filename">filename</code></td>
<td>
<p>Name of metainfo file residing in database directory</p>
</td></tr>
<tr><td><code id="tv.metadata_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because Turboveg provides no formalised method to store information about database fields,
I suggest to save a simple text file, named for example &quot;metadata.txt&quot; into the directory of your Turboveg database.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>

<hr>
<h2 id='tv.obs'>Dataframe of plot-species observations directly from Turboveg</h2><span id='topic+tv.obs'></span>

<h3>Description</h3>

<p>Dataframe of plot-species observations directly from Turboveg.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.obs(db, tv_home, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.obs_+3A_db">db</code></td>
<td>
<p>(character) Name of your Turboveg database. This is the directory name containing tvabund.dbf, tvhabita.dbf and tvwin.set. Please include pathnames below but not above Turbowin/Data.</p>
</td></tr>
<tr><td><code id="tv.obs_+3A_tv_home">tv_home</code></td>
<td>
<p>(character) Turbowin installation path. If not specified function <code><a href="#topic+tv.home">tv.home</a></code> tries to discover.</p>
</td></tr>
<tr><td><code id="tv.obs_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame of species occurrences in Turboveg format, that is every occurrence is a row with releve number, species number, layer, cover code and optional additional species-plot information.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tv.veg">tv.veg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    # Turboveg installation needed
    obs &lt;- tv.obs('taxatest')
    head(obs)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='tv.readXML'>Reads a Turboveg XML file</h2><span id='topic+tv.readXML'></span>

<h3>Description</h3>

<p>Reads Turboveg XML formatted files species-plot observations and site information into a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.readXML(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.readXML_+3A_file">file</code></td>
<td>
<p>(character) Path name of the Turboveg XML file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 list with elements tvwin, tvadmin, site, and obs
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tv.veg">tv.veg</a></code>, <code><a href="#topic+tv.site">tv.site</a></code>
</p>

<hr>
<h2 id='tv.refl'>Taxon reference list to be used</h2><span id='topic+tv.refl'></span>

<h3>Description</h3>

<p>Taxon reference list to be used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.refl(refl, db, tv_home)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.refl_+3A_refl">refl</code></td>
<td>
<p>name of reference list</p>
</td></tr>
<tr><td><code id="tv.refl_+3A_db">db</code></td>
<td>
<p>Turboveg database name</p>
</td></tr>
<tr><td><code id="tv.refl_+3A_tv_home">tv_home</code></td>
<td>
<p>Turboveg installation path</p>
</td></tr>
</table>

<hr>
<h2 id='TV.replace'>Rename data.frame columns to match Turboveg 2 conventions</h2><span id='topic+TV.replace'></span>

<h3>Description</h3>

<p>Rename data.frame columns to match Turboveg 2 conventions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TV.replace(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TV.replace_+3A_x">x</code></td>
<td>
<p>(character) string vector of column names</p>
</td></tr>
</table>

<hr>
<h2 id='tv.site'>Load site data from Turboveg Database</h2><span id='topic+tv.site'></span>

<h3>Description</h3>

<p>Loading Turboveg header data and do basic data evaluation. Empty columns are eliminated and warnings about possibly wrong '0' values are performed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.site(db, tv_home, drop=TRUE, common.only = FALSE, verbose = TRUE, replace.names, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.site_+3A_db">db</code></td>
<td>
<p>(character) Name of your Turboveg database(s). Directory name containing tvabund.dbf, tvhabita.dbf and tvwin.set.</p>
</td></tr>
<tr><td><code id="tv.site_+3A_tv_home">tv_home</code></td>
<td>
<p>(character) Turbowin installation path. Optional, if Turbowin is either on &quot;C:/Turbowin&quot; or &quot;C:/Programme/Turbowin&quot;.</p>
</td></tr>
<tr><td><code id="tv.site_+3A_drop">drop</code></td>
<td>
<p>(logical) Drop variables without values.</p>
</td></tr>
<tr><td><code id="tv.site_+3A_common.only">common.only</code></td>
<td>
<p>(logical) Import only header data with the same name in all databases.</p>
</td></tr>
<tr><td><code id="tv.site_+3A_verbose">verbose</code></td>
<td>
<p>(logical) print warnings and hints</p>
</td></tr>
<tr><td><code id="tv.site_+3A_replace.names">replace.names</code></td>
<td>
<p>(data.frame) replace variable names. Useful if using multiple source databases. Data frame with names to be replaced in first and replacing names in second column.</p>
</td></tr>
<tr><td><code id="tv.site_+3A_...">...</code></td>
<td>
<p>Additional options like <code>dec</code> for type.convert</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please specify pathnames below but not above Turbowin/Data. Can be a single database or a character vector of multiple databases. In the latter case you have to assure, that all databases use the same taxonomic reference list.
</p>
<p>You can use the example in the final output line to make a summary statistic for attributes with potentially misleading '0' values. Just delete the \&quot; at beginning and end.
</p>


<h3>Value</h3>

<p>data.frame of site variables.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>

<hr>
<h2 id='tv.traits'>Load species traits from Turboveg reference list</h2><span id='topic+tv.traits'></span><span id='topic+tv.eco'></span>

<h3>Description</h3>

<p>Loading Turboveg ecodbase or any other specified dBase file in this directory and do basic data evaluation. Empty columns are eliminated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.traits(db, trait.db = 'ecodbase.dbf', refl, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.traits_+3A_db">db</code></td>
<td>
<p>Path name to the Turboveg database directory</p>
</td></tr>
<tr><td><code id="tv.traits_+3A_trait.db">trait.db</code></td>
<td>
<p>Name of species trait dBase file, default is 'ecodbase'</p>
</td></tr>
<tr><td><code id="tv.traits_+3A_refl">refl</code></td>
<td>
<p>Name of the taxonomic reference list, if veg is not loaded with tv.veg</p>
</td></tr>
<tr><td><code id="tv.traits_+3A_...">...</code></td>
<td>
<p>additional arguments for tv.traits</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can use the final output line to make a summary statistic for attributes with potentially misleading '0' values.
</p>


<h3>Value</h3>

<p>data.frame of ecological traits, see <code>metainfo(refl, eco=TRUE)</code>
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>

<hr>
<h2 id='tv.veg'>Tabulates vegetation tables from Turboveg database</h2><span id='topic+tv.veg'></span>

<h3>Description</h3>

<p>Tabulates vegetation tables from Turboveg resp. VegetWeb database, including taxonomic emendation and layer combination. Using various default parameters for the included functions.
It is a wrapper for *tv.obs*, *taxval*, *tv.coverperc* and creating a vegetation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.veg(db, taxval=TRUE,tv_home,convcode=TRUE,
lc = c("layer","mean","max","sum","first"),
pseudo, values='COVER_PERC', spcnames=c('shortletters','ScientificNames','Numbers'),
dec = 0, cover.transform = c('no', 'pa', 'sqrt'), obs, site, refl, RelScale, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.veg_+3A_db">db</code></td>
<td>
<p>Name of your Turboveg database. Directory name containing tvabund.dbf, tvhabita.dbf and tvwin.set. Please specify pathnames below (if you sorted your databases in subfolders) but not above Turbowin/Data.</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_taxval">taxval</code></td>
<td>
<p>Should taxonomic valuation (see <code><a href="#topic+taxval">taxval</a></code>) be performed?</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_tv_home">tv_home</code></td>
<td>
<p>Turbowin installation path.</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_convcode">convcode</code></td>
<td>
<p>Should cover code be converted to percentage values?</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_lc">lc</code></td>
<td>
<p>Layer combination type. Possible values: layer (default), sum, mean or max, see details</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_pseudo">pseudo</code></td>
<td>
<p>List used for layer combinations, see details</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_values">values</code></td>
<td>
<p>Name of the variable which should be used for the vegetations matrix.</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_spcnames">spcnames</code></td>
<td>
<p>Should species numbers be replaced by shortletters or ScientificNames? Layer information is appended with dot.</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_dec">dec</code></td>
<td>
<p>Number of decimals for cover values in the resulting vegetation matrix.</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_cover.transform">cover.transform</code></td>
<td>
<p>If you want to transform the abundancce values within your samples
you can choose 'pa' for presence-absence or 'sqrt' for the <code>dec</code> rounded square root.</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_obs">obs</code></td>
<td>
<p>Observations, optional</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_site">site</code></td>
<td>
<p>plot header data, see <code><a href="#topic+tv.site">tv.site</a></code></p>
</td></tr>
<tr><td><code id="tv.veg_+3A_refl">refl</code></td>
<td>
<p>Taxonomic reference list, optional</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_relscale">RelScale</code></td>
<td>
<p>Vector with Cover Scale code per Releve.</p>
</td></tr>
<tr><td><code id="tv.veg_+3A_...">...</code></td>
<td>
<p>additional arguments for included functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>layer</code> means, the different layers are combined assuming there independence (a species occurring in two layers with a cover of 50% will result in a overall cover of 75%. <code>sum</code> will sum up cover values of all layers With option <code>pseudo</code> you can decide, which layers should be combined. Give a list with a combination data.frame and second the name of the column for combination. The default is <code>pseudo = list(lc.1, c('LAYER'))</code>, where lc.1 is a data.frame <code>data(lc.1)</code>, which will combine all tree layers, all shrub layers and all layers below shrubs. An alternative would be data(lc.all), combining all layers. With option pseudo=NULL there will be no layer aggregation.
</p>


<h3>Value</h3>

<p>an object of class matrix with (combined) cover values.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen <a href="mailto:florian.jansen@uni-rostock.de">florian.jansen@uni-rostock.de</a>
</p>


<h3>See Also</h3>


<p><code><a href="#topic+taxval">taxval</a></code>, <code><a href="#topic+tv.coverperc">tv.coverperc</a></code>, <code><a href="#topic+tv.obs">tv.obs</a></code>, <code><a href="#topic+tv.site">tv.site</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    vignette("vegdata")
    #' If you have Turboveg installed on your computer try for a beginning
    #' tv.veg('databasename', tax=FALSE).
    args(tv.veg)
    help('taxval')

    veg &lt;- tv.veg('taxatest')
    names(veg)
    tv.veg('taxatest', uncertain=list('DET_CERT', data.frame(0:2,c('pres','agg','agg'))),
           pseudo=list(lc.0,'LAYER'), genus = 'delete')
  
## End(Not run)

</code></pre>

<hr>
<h2 id='tv.write'>Write species-plot observations and site information to Turboveg database.</h2><span id='topic+tv.write'></span>

<h3>Description</h3>

<p>Write species-plot observations and site information to Turboveg database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tv.write(x, site, name, tvadmin, remarks, dict = "", cover = c("code", "perc"),
drop = FALSE, obl = TRUE, overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tv.write_+3A_x">x</code></td>
<td>
<p>(data.frame) Either observations data.frame with RELEVE_NR, TaxonUsageID and COVER_CODE (see <a href="#topic+tv.obs">tv.obs</a>) columns or vegetation matrix of class &quot;veg&quot;.</p>
</td></tr>
<tr><td><code id="tv.write_+3A_site">site</code></td>
<td>
<p>(character) Header data for plots.</p>
</td></tr>
<tr><td><code id="tv.write_+3A_name">name</code></td>
<td>
<p>(character) Name of the new database.</p>
</td></tr>
<tr><td><code id="tv.write_+3A_tvadmin">tvadmin</code></td>
<td>
<p>(data.frame) Dataframe with plot UUID's and Turboveg columns from TvAdmin.dbf. A new file with new unique identifiers will be created if omitted.</p>
</td></tr>
<tr><td><code id="tv.write_+3A_remarks">remarks</code></td>
<td>
<p>(data.frame) Remarks in Turboveg format if the comments for individual plots exceed 254 characters. See remarks.dbf in Turboveg databases. An empty file will be created if omitted.</p>
</td></tr>
<tr><td><code id="tv.write_+3A_dict">dict</code></td>
<td>
<p>(character) Turboveg dictionary name</p>
</td></tr>
<tr><td><code id="tv.write_+3A_cover">cover</code></td>
<td>
<p>(logical) Use of covercodes or (mean) cover percentages, see Details.</p>
</td></tr>
<tr><td><code id="tv.write_+3A_drop">drop</code></td>
<td>
<p>(logical) Drop columns which are empty or contain only NA values.</p>
</td></tr>
<tr><td><code id="tv.write_+3A_obl">obl</code></td>
<td>
<p>(logical) Add obligatory fields defined in the TV dictionary but not present in the site data table.</p>
</td></tr>
<tr><td><code id="tv.write_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) Should an existing database be overwritten.</p>
</td></tr>
<tr><td><code id="tv.write_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default Covercode is written to Turboveg. This is only meaningful, if correct CoverScales are given in the site dataframe. Unique plot ID's are stored in *TvAdmin.dbf*. If you want to preserve already given UUID's you have to prepare an appropriate data.frame. Look for existing *TvAdmin.dbf* files for necessary columns.
</p>


<h3>Value</h3>

<p>Five files will be created in &quot;tv_home/Data/databasename&quot; directory. *tvabund.dbf* with occurrence information n long format, *tvhabita.dbf* with plot information, remarks.dbf with comments longer then 255 characters, *TvAdmin.dbf* with plot UUID's and tvwin.dbf with information about taxonomic reference list, and dictionary used.
</p>


<h3>Author(s)</h3>

<p>Florian Jansen @email florian.jansen@uni-rostock.de
</p>


<h3>See Also</h3>

<p>tv.veg
</p>

<hr>
<h2 id='vegdata-package'>Functions to access data from vegetation databases and evaluate taxon names</h2><span id='topic+vegdata'></span><span id='topic+vegdata-package'></span>

<h3>Description</h3>

<p>Handling of vegetation data from different sources ( Turboveg 2.0 <a href="https://www.synbiosys.alterra.nl/turboveg/">https://www.synbiosys.alterra.nl/turboveg/</a>; the German national repository <a href="https://www.vegetweb.de">https://www.vegetweb.de</a> and others. Taxonomic harmonization (given appropriate taxonomic lists, e.g. the German taxonomic standard list &quot;GermanSL&quot;, <a href="https://germansl.infinitenature.org">https://germansl.infinitenature.org</a>).
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://germansl.infinitenature.org">https://germansl.infinitenature.org</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
