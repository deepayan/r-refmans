<!DOCTYPE html><html lang="en"><head><title>Help for package protti</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {protti}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyse_functional_network'><p>Analyse protein interaction network for significant hits</p></a></li>
<li><a href='#anova_protti'><p>Perform ANOVA</p></a></li>
<li><a href='#assign_missingness'><p>Assignment of missingness types</p></a></li>
<li><a href='#assign_peptide_type'><p>Assign peptide type</p></a></li>
<li><a href='#barcode_plot'><p>Barcode plot</p></a></li>
<li><a href='#calculate_aa_scores'><p>Calculate scores for each amino acid position in a protein sequence</p></a></li>
<li><a href='#calculate_diff_abundance'><p>Calculate differential abundance between conditions</p></a></li>
<li><a href='#calculate_go_enrichment'><p>Perform gene ontology enrichment analysis</p></a></li>
<li><a href='#calculate_imputation'><p>Sampling of values for imputation</p></a></li>
<li><a href='#calculate_kegg_enrichment'><p>Perform KEGG pathway enrichment analysis</p></a></li>
<li><a href='#calculate_protein_abundance'><p>Label-free protein quantification</p></a></li>
<li><a href='#calculate_sequence_coverage'><p>Protein sequence coverage</p></a></li>
<li><a href='#calculate_treatment_enrichment'><p>Check treatment enrichment</p></a></li>
<li><a href='#correct_lip_for_abundance'><p>Protein abundance correction for LiP-data</p></a></li>
<li><a href='#create_queue'><p>Creates a mass spectrometer queue for Xcalibur</p></a></li>
<li><a href='#create_structure_contact_map'><p>Creates a contact map of all atoms from a structure file</p></a></li>
<li><a href='#create_synthetic_data'><p>Creates a synthetic limited proteolysis proteomics dataset</p></a></li>
<li><a href='#diff_abundance'><p>Calculate differential abundance between conditions</p></a></li>
<li><a href='#drc_4p'><p>Dose response curve helper function</p></a></li>
<li><a href='#drc_4p_plot'><p>Plotting of four-parameter dose response curves</p></a></li>
<li><a href='#extract_metal_binders'><p>Extract metal-binding protein information from UniProt</p></a></li>
<li><a href='#fetch_alphafold_aligned_error'><p>Fetch AlphaFold aligned error</p></a></li>
<li><a href='#fetch_alphafold_prediction'><p>Fetch AlphaFold prediction</p></a></li>
<li><a href='#fetch_chebi'><p>Fetch ChEBI database information</p></a></li>
<li><a href='#fetch_eco'><p>Fetch evidence &amp; conclusion ontology</p></a></li>
<li><a href='#fetch_go'><p>Fetch gene ontology information from geneontology.org</p></a></li>
<li><a href='#fetch_kegg'><p>Fetch KEGG pathway data from KEGG</p></a></li>
<li><a href='#fetch_metal_pdb'><p>Fetch structural information about protein-metal binding from MetalPDB</p></a></li>
<li><a href='#fetch_mobidb'><p>Fetch protein disorder and mobility information from MobiDB</p></a></li>
<li><a href='#fetch_pdb'><p>Fetch structure information from RCSB</p></a></li>
<li><a href='#fetch_pdb_structure'><p>Fetch PDB structure atom data from RCSB</p></a></li>
<li><a href='#fetch_quickgo'><p>Fetch information from the QuickGO API</p></a></li>
<li><a href='#fetch_uniprot'><p>Fetch protein data from UniProt</p></a></li>
<li><a href='#fetch_uniprot_proteome'><p>Fetch proteome data from UniProt</p></a></li>
<li><a href='#filter_cv'><p>Data filtering based on coefficients of variation (CV)</p></a></li>
<li><a href='#find_all_subs'><p>Find all sub IDs of an ID in a network</p></a></li>
<li><a href='#find_chebis'><p>Find ChEBI IDs for name patterns</p></a></li>
<li><a href='#find_peptide'><p>Find peptide location</p></a></li>
<li><a href='#find_peptide_in_structure'><p>Finds peptide positions in a PDB structure based on positional matching</p></a></li>
<li><a href='#fit_drc_4p'><p>Fitting four-parameter dose response curves</p></a></li>
<li><a href='#go_enrichment'><p>Perform gene ontology enrichment analysis</p></a></li>
<li><a href='#impute'><p>Imputation of missing values</p></a></li>
<li><a href='#kegg_enrichment'><p>Perform KEGG pathway enrichment analysis</p></a></li>
<li><a href='#mako_colours'><p>Viridis colour scheme</p></a></li>
<li><a href='#map_peptides_on_structure'><p>Maps peptides onto a PDB structure or AlphaFold prediction</p></a></li>
<li><a href='#median_normalisation'><p>Intensity normalisation</p></a></li>
<li><a href='#metal_chebi_uniprot'><p>List of metal-related ChEBI IDs in UniProt</p></a></li>
<li><a href='#metal_go_slim_subset'><p>Molecular function gene ontology metal subset</p></a></li>
<li><a href='#metal_list'><p>List of metals</p></a></li>
<li><a href='#network_analysis'><p>Analyse protein interaction network for significant hits</p></a></li>
<li><a href='#normalise'><p>Intensity normalisation</p></a></li>
<li><a href='#parallel_create_structure_contact_map'><p>Creates a contact map of all atoms from a structure file (using parallel processing)</p></a></li>
<li><a href='#parallel_fit_drc_4p'><p>Fitting four-parameter dose response curves (using parallel processing)</p></a></li>
<li><a href='#peptide_profile_plot'><p>Peptide abundance profile plot</p></a></li>
<li><a href='#peptide_type'><p>Assign peptide type</p></a></li>
<li><a href='#plot_drc_4p'><p>Perform gene ontology enrichment analysis</p></a></li>
<li><a href='#plot_peptide_profiles'><p>Peptide abundance profile plot</p></a></li>
<li><a href='#plot_pval_distribution'><p>Plot histogram of p-value distribution</p></a></li>
<li><a href='#predict_alphafold_domain'><p>Predict protein domains of AlphaFold predictions</p></a></li>
<li><a href='#protti_colours'><p>Colour scheme for protti</p></a></li>
<li><a href='#ptsi_pgk'><p>Structural analysis example data</p></a></li>
<li><a href='#pval_distribution_plot'><p>Plot histogram of p-value distribution</p></a></li>
<li><a href='#qc_charge_states'><p>Check charge state distribution</p></a></li>
<li><a href='#qc_contaminants'><p>Percentage of contaminants per sample</p></a></li>
<li><a href='#qc_cvs'><p>Check CV distribution</p></a></li>
<li><a href='#qc_data_completeness'><p>Data completeness</p></a></li>
<li><a href='#qc_ids'><p>Check number of precursor, peptide or protein IDs</p></a></li>
<li><a href='#qc_intensity_distribution'><p>Check intensity distribution per sample and overall</p></a></li>
<li><a href='#qc_median_intensities'><p>Median run intensities</p></a></li>
<li><a href='#qc_missed_cleavages'><p>Check missed cleavages</p></a></li>
<li><a href='#qc_pca'><p>Plot principal component analysis</p></a></li>
<li><a href='#qc_peak_width'><p>Peak width over retention time</p></a></li>
<li><a href='#qc_peptide_type'><p>Check peptide type percentage share</p></a></li>
<li><a href='#qc_proteome_coverage'><p>Proteome coverage per sample and total</p></a></li>
<li><a href='#qc_ranked_intensities'><p>Check ranked intensities</p></a></li>
<li><a href='#qc_sample_correlation'><p>Correlation based hirachical clustering of samples</p></a></li>
<li><a href='#qc_sequence_coverage'><p>Protein coverage distribution</p></a></li>
<li><a href='#randomise_queue'><p>Randomise samples in MS queue</p></a></li>
<li><a href='#rapamycin_10uM'><p>Rapamycin 10 uM example data</p></a></li>
<li><a href='#rapamycin_dose_response'><p>Rapamycin dose response example data</p></a></li>
<li><a href='#read_protti'><p>Read, clean and convert</p></a></li>
<li><a href='#replace_identified_by_x'><p>Replace identified positions in protein sequence by &quot;x&quot;</p></a></li>
<li><a href='#scale_protti'><p>Scaling a vector</p></a></li>
<li><a href='#sequence_coverage'><p>Protein sequence coverage</p></a></li>
<li><a href='#split_metal_name'><p>Convert metal names to search pattern</p></a></li>
<li><a href='#treatment_enrichment'><p>Check treatment enrichment</p></a></li>
<li><a href='#try_query'><p>Query from URL</p></a></li>
<li><a href='#ttest_protti'><p>Perform Welch's t-test</p></a></li>
<li><a href='#viridis_colours'><p>Viridis colour scheme</p></a></li>
<li><a href='#volcano_plot'><p>Volcano plot</p></a></li>
<li><a href='#volcano_protti'><p>Volcano plot</p></a></li>
<li><a href='#woods_plot'><p>Woods' plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bottom-Up Proteomics and LiP-MS Quality Control and Data
Analysis Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Useful functions and workflows for proteomics quality control and data analysis of both limited proteolysis-coupled mass spectrometry (LiP-MS) (Feng et. al. (2014) &lt;<a href="https://doi.org/10.1038%2Fnbt.2999">doi:10.1038/nbt.2999</a>&gt;) and regular bottom-up proteomics experiments. Data generated with search tools such as 'Spectronaut', 'MaxQuant' and 'Proteome Discover' can be easily used due to flexibility of functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, dplyr, stringr, magrittr, data.table, janitor,
progress, purrr, tidyr, ggplot2, forcats, tibble, plotly,
ggrepel, utils, grDevices, curl, readr, lifecycle, httr,
methods, R.utils, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown, shiny, r3dmol, proDA,
limma, dendextend, pheatmap, heatmaply, furrr, future,
parallel, seriation, drc, igraph, stringi, STRINGdb, iq,
scales, farver, ggforce, xml2, jsonlite</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jpquast/protti">https://github.com/jpquast/protti</a>,
<a href="https://jpquast.github.io/protti/">https://jpquast.github.io/protti/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jpquast/protti/issues">https://github.com/jpquast/protti/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-21 22:14:07 UTC; jan-philippquast</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan-Philipp Quast <a href="https://orcid.org/0000-0003-2713-778X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Dina Schuster <a href="https://orcid.org/0000-0001-6611-8237"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  ETH Zurich [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan-Philipp Quast &lt;quast@imsb.biol.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-21 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyse_functional_network'>Analyse protein interaction network for significant hits</h2><span id='topic+analyse_functional_network'></span>

<h3>Description</h3>

<p>The STRING database provides a resource for known and predicted protein-protein interactions.
The type of interactions include direct (physical) and indirect (functional) interactions.
Through the R package <code>STRINGdb</code> this resource if provided to R users. This function
provides a convenient wrapper for <code>STRINGdb</code> functions that allow an easy use within the
protti pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_functional_network(
  data,
  protein_id,
  string_id,
  organism_id,
  version = "12.0",
  score_threshold = 900,
  binds_treatment = NULL,
  halo_color = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyse_functional_network_+3A_data">data</code></td>
<td>
<p>a data frame that contains significantly changing proteins (STRINGdb is only able
to plot 400 proteins at a time so do not provide more for network plots). Information about
treatment binding can be provided and will be displayed as colorful halos around the proteins
in the network.</p>
</td></tr>
<tr><td><code id="analyse_functional_network_+3A_protein_id">protein_id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the protein
accession numbers.</p>
</td></tr>
<tr><td><code id="analyse_functional_network_+3A_string_id">string_id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains STRING database
identifiers. These can be obtained from UniProt.</p>
</td></tr>
<tr><td><code id="analyse_functional_network_+3A_organism_id">organism_id</code></td>
<td>
<p>a numeric value specifying an organism ID (NCBI taxon-ID). This can be
obtained from
<a href="https://string-db.org/cgi/input?sessionId=bpvps5GS2As6&amp;input_page_show_search=on">here</a>.
H. sapiens: 9606, S. cerevisiae: 4932, E. coli: 511145.</p>
</td></tr>
<tr><td><code id="analyse_functional_network_+3A_version">version</code></td>
<td>
<p>a character value that specifies the version of STRINGdb to be used.
Default is 12.0.</p>
</td></tr>
<tr><td><code id="analyse_functional_network_+3A_score_threshold">score_threshold</code></td>
<td>
<p>a numeric value specifying the interaction score that based on
<a href="https://string-db.org/cgi/info?sessionId=bBP5N4cIf0PA&amp;footer_active_subpage=scores">STRING</a>
has to be between 0 and 1000. A score closer to 1000 is related to a higher confidence for the
interaction. The default value is 900.</p>
</td></tr>
<tr><td><code id="analyse_functional_network_+3A_binds_treatment">binds_treatment</code></td>
<td>
<p>a logical column in the <code>data</code> data frame that indicates if the
corresponding protein binds to the treatment. This information can be obtained from different
databases, e.g UniProt.</p>
</td></tr>
<tr><td><code id="analyse_functional_network_+3A_halo_color">halo_color</code></td>
<td>
<p>optional, character value with a color hex-code. This is the color of the
halo of proteins that bind the treatment.</p>
</td></tr>
<tr><td><code id="analyse_functional_network_+3A_plot">plot</code></td>
<td>
<p>a logical that indicates whether the result should be plotted or returned as a table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network plot displaying interactions of the provided proteins. If
<code>binds_treatment</code> was provided halos around the proteins show which proteins interact with
the treatment. If <code>plot = FALSE</code> a data frame with interaction information is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create example data
data &lt;- data.frame(
  uniprot_id = c(
    "P0A7R1",
    "P02359",
    "P60624",
    "P0A7M2",
    "P0A7X3",
    "P0AGD3"
  ),
  xref_string = c(
    "511145.b4203;",
    "511145.b3341;",
    "511145.b3309;",
    "511145.b3637;",
    "511145.b3230;",
    "511145.b1656;"
  ),
  is_known = c(
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    FALSE
  )
)

# Perform network analysis
network &lt;- analyse_functional_network(
  data,
  protein_id = uniprot_id,
  string_id = xref_string,
  organism_id = 511145,
  binds_treatment = is_known,
  plot = TRUE
)

network

</code></pre>

<hr>
<h2 id='anova_protti'>Perform ANOVA</h2><span id='topic+anova_protti'></span>

<h3>Description</h3>

<p>Performs an ANOVA statistical test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anova_protti(data, grouping, condition, mean_ratio, sd, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova_protti_+3A_data">data</code></td>
<td>
<p>a data frame containing at least the input variables.</p>
</td></tr>
<tr><td><code id="anova_protti_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains precursor or
peptide identifiers.</p>
</td></tr>
<tr><td><code id="anova_protti_+3A_condition">condition</code></td>
<td>
<p>a character or numeric column in the <code>data</code> data frame that contains the
conditions.</p>
</td></tr>
<tr><td><code id="anova_protti_+3A_mean_ratio">mean_ratio</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains mean intensities
or mean intensity ratios.</p>
</td></tr>
<tr><td><code id="anova_protti_+3A_sd">sd</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the standard deviation
corresponding to the mean.</p>
</td></tr>
<tr><td><code id="anova_protti_+3A_n">n</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the number of replicates
for which the corresponding mean was calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame that contains the within group error (<code>ms_group</code>) and the between
group error (<code>ms_error</code>), f statistic and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  precursor = c("A", "A", "A", "B", "B", "B"),
  condition = c("C1", "C2", "C3", "C1", "C2", "C3"),
  mean = c(10, 12, 20, 11, 12, 8),
  sd = c(2, 1, 1.5, 1, 2, 4),
  n = c(4, 4, 4, 4, 4, 4)
)

anova_protti(
  data,
  grouping = precursor,
  condition = condition,
  mean = mean,
  sd = sd,
  n = n
)
</code></pre>

<hr>
<h2 id='assign_missingness'>Assignment of missingness types</h2><span id='topic+assign_missingness'></span>

<h3>Description</h3>

<p>The type of missingness (missing at random, missing not at random) is assigned based on the
comparison of a reference condition and every other condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_missingness(
  data,
  sample,
  condition,
  grouping,
  intensity,
  ref_condition = "all",
  completeness_MAR = 0.7,
  completeness_MNAR = 0.2,
  retain_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_missingness_+3A_data">data</code></td>
<td>
<p>a data frame containing at least the input variables.</p>
</td></tr>
<tr><td><code id="assign_missingness_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample name.</p>
</td></tr>
<tr><td><code id="assign_missingness_+3A_condition">condition</code></td>
<td>
<p>a character or numeric column in the <code>data</code> data frame that contains the
conditions.</p>
</td></tr>
<tr><td><code id="assign_missingness_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains protein, precursor or
peptide identifiers.</p>
</td></tr>
<tr><td><code id="assign_missingness_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains intensity values that
relate to the <code>grouping</code> variable.</p>
</td></tr>
<tr><td><code id="assign_missingness_+3A_ref_condition">ref_condition</code></td>
<td>
<p>a character vector providing the condition that is used as a reference for
missingness determination. Instead of providing one reference condition, &quot;all&quot; can be supplied,
which will create all pairwise condition pairs. By default <code>ref_condition = "all"</code>.</p>
</td></tr>
<tr><td><code id="assign_missingness_+3A_completeness_mar">completeness_MAR</code></td>
<td>
<p>a numeric value that specifies the minimal degree of data completeness to
be considered as MAR. Value has to be between 0 and 1, default is 0.7. It is multiplied with
the number of replicates and then adjusted downward. The resulting number is the minimal number
of observations for each condition to be considered as MAR. This number is always at least 1.</p>
</td></tr>
<tr><td><code id="assign_missingness_+3A_completeness_mnar">completeness_MNAR</code></td>
<td>
<p>a numeric value that specifies the maximal degree of data completeness to
be considered as MNAR. Value has to be between 0 and 1, default is 0.20. It is multiplied with
the number of replicates and then adjusted downward. The resulting number is the maximal number
of observations for one condition to be considered as MNAR when the other condition is complete.</p>
</td></tr>
<tr><td><code id="assign_missingness_+3A_retain_columns">retain_columns</code></td>
<td>
<p>a vector that indicates columns that should be retained from the input
data frame. Default is not retaining additional columns <code>retain_columns = NULL</code>. Specific
columns can be retained by providing their names (not in quotations marks, just like other
column names, but in a vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the reference condition paired with each treatment condition.
The <code>comparison</code> column contains the comparison name for the specific treatment/reference
pair. The <code>missingness</code> column reports the type of missingness.
</p>

<ul>
<li><p> &quot;complete&quot;: No missing values for every replicate of this reference/treatment pair for
the specific grouping variable.
</p>
</li>
<li><p> &quot;MNAR&quot;: Missing not at random. All replicates of either the reference or treatment
condition have missing values for the specific grouping variable.
</p>
</li>
<li><p> &quot;MAR&quot;: Missing at random. At least n-1 replicates have missing values for the
reference/treatment pair for the specific grouping varible.
</p>
</li>
<li><p> NA: The comparison is not complete enough to fall into any other category. It will not
be imputed if imputation is performed. For statistical significance testing these comparisons
are filtered out after the test and prior to p-value adjustment. This can be prevented by setting
<code>filter_NA_missingness = FALSE</code> in the <code>calculate_diff_abundance()</code> function.
</p>
</li></ul>

<p>The type of missingness has an influence on the way values are imputeted if imputation is
performed subsequently using the <code>impute()</code> function. How each type of missingness is
specifically imputed can be found in the function description. The type of missingness
assigned to a comparison does not have any influence on the statistical test in the
<code>calculate_diff_abundance()</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 10,
  frac_change = 0.5,
  n_replicates = 4,
  n_conditions = 2,
  method = "effect_random",
  additional_metadata = FALSE
)

head(data, n = 24)

# Assign missingness information
data_missing &lt;- assign_missingness(
  data,
  sample = sample,
  condition = condition,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  ref_condition = "all",
  retain_columns = c(protein)
)

head(data_missing, n = 24)
</code></pre>

<hr>
<h2 id='assign_peptide_type'>Assign peptide type</h2><span id='topic+assign_peptide_type'></span>

<h3>Description</h3>

<p>Based on preceding and C-terminal amino acid, the peptide type of a given peptide is assigned.
Peptides with preceeding and C-terminal lysine or arginine are considered fully-tryptic. If a
peptide is located at the N- or C-terminus of a protein and fulfills the criterium to be
fully-tryptic otherwise, it is also considered as fully-tryptic. Peptides that only fulfill the
criterium on one terminus are semi-tryptic peptides. Lastly, peptides that are not fulfilling
the criteria for both termini are non-tryptic peptides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_peptide_type(
  data,
  aa_before = aa_before,
  last_aa = last_aa,
  aa_after = aa_after
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_peptide_type_+3A_data">data</code></td>
<td>
<p>a data frame containing at least information about the preceding and C-terminal
amino acids of peptides.</p>
</td></tr>
<tr><td><code id="assign_peptide_type_+3A_aa_before">aa_before</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the preceding amino
acid as one letter code.</p>
</td></tr>
<tr><td><code id="assign_peptide_type_+3A_last_aa">last_aa</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the C-terminal amino
acid as one letter code.</p>
</td></tr>
<tr><td><code id="assign_peptide_type_+3A_aa_after">aa_after</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the following amino
acid as one letter code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the input data and an additional column with the peptide
type information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  aa_before = c("K", "S", "T"),
  last_aa = c("R", "K", "Y"),
  aa_after = c("T", "R", "T")
)

assign_peptide_type(data, aa_before, last_aa, aa_after)
</code></pre>

<hr>
<h2 id='barcode_plot'>Barcode plot</h2><span id='topic+barcode_plot'></span>

<h3>Description</h3>

<p>Plots a &quot;barcode plot&quot; - a vertical line for each identified peptide. Peptides can be colored based on an additional variable. Also differential
abundance can be displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barcode_plot(
  data,
  start_position,
  end_position,
  protein_length,
  coverage = NULL,
  colouring = NULL,
  fill_colour_gradient = protti::mako_colours,
  fill_colour_discrete = c("#999999", protti::protti_colours),
  protein_id = NULL,
  facet = NULL,
  facet_n_col = 4,
  cutoffs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barcode_plot_+3A_data">data</code></td>
<td>
<p>a data frame containing differential abundance, start and end peptide or precursor positions and protein length.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_start_position">start_position</code></td>
<td>
<p>a numeric column in the data frame containing the start positions for each peptide or precursor.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_end_position">end_position</code></td>
<td>
<p>a numeric column in the data frame containing the end positions for each peptide or precursor.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_protein_length">protein_length</code></td>
<td>
<p>a numeric column in the data frame containing the length of the protein.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_coverage">coverage</code></td>
<td>
<p>optional, numeric column in the data frame containing coverage in percent. Will appear in the title of the barcode if provided.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_colouring">colouring</code></td>
<td>
<p>optional, column in the data frame containing information by which peptide or precursors should
be colored.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_fill_colour_gradient">fill_colour_gradient</code></td>
<td>
<p>a vector that contains colours that should be used to create a colour gradient
for the barcode plot bars if the <code>colouring</code> argument is continuous. Default is <code>mako_colours</code>.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_fill_colour_discrete">fill_colour_discrete</code></td>
<td>
<p>a vector that contains colours that should be used to fill the barcode plot bars
if the <code>colouring</code> argument is discrete. Default is <code>protti_colours</code>.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_protein_id">protein_id</code></td>
<td>
<p>optional, column in the data frame containing protein identifiers. Required if only one protein
should be plotted and the data frame contains only information for this protein.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_facet">facet</code></td>
<td>
<p>optional, column in the data frame containing information by which data should be faceted. This can be
protein identifiers. Only 20 proteins are plotted at a time, the rest is ignored. If more should be plotted, a mapper over a
subsetted data frame should be created.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_facet_n_col">facet_n_col</code></td>
<td>
<p>a numeric value that specifies the number of columns the faceted plot should have
if a column name is provided to group. The default is 4.</p>
</td></tr>
<tr><td><code id="barcode_plot_+3A_cutoffs">cutoffs</code></td>
<td>
<p>optional argument specifying the log2 fold change and significance cutoffs used for highlighting peptides.
If this argument is provided colouring information will be overwritten with peptides that fulfill this condition.
The cutoff should be provided in a vector of the form c(diff = 2, pval = 0.05). The name of the cutoff should reflect the
column name that contains this information (log2 fold changes, p-values or adjusted p-values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A barcode plot is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- data.frame(
  start = c(5, 40, 55, 130, 181, 195),
  end = c(11, 51, 60, 145, 187, 200),
  length = rep(200, 6),
  pg_protein_accessions = rep("Protein 1", 6),
  diff = c(1, 2, 5, 2, 1, 1),
  pval = c(0.1, 0.01, 0.01, 0.2, 0.2, 0.01)
)

barcode_plot(
  data,
  start_position = start,
  end_position = end,
  protein_length = length,
  facet = pg_protein_accessions,
  cutoffs = c(diff = 2, pval = 0.05)
)
</code></pre>

<hr>
<h2 id='calculate_aa_scores'>Calculate scores for each amino acid position in a protein sequence</h2><span id='topic+calculate_aa_scores'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Calculate a score for each amino acid position in a protein sequence based on the product of the
-log10(adjusted p-value) and the absolute log2(fold change) per peptide covering this amino acid. In detail, all the
peptides are aligned along the sequence of the corresponding protein, and the average score per
amino acid position is computed. In a limited proteolysis coupled to mass spectrometry (LiP-MS)
experiment, the score allows to prioritize and narrow down structurally affected regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_aa_scores(
  data,
  protein,
  diff = diff,
  adj_pval = adj_pval,
  start_position,
  end_position,
  retain_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_aa_scores_+3A_data">data</code></td>
<td>
<p>a data frame containing at least the input columns.</p>
</td></tr>
<tr><td><code id="calculate_aa_scores_+3A_protein">protein</code></td>
<td>
<p>a character column in the data frame containing the protein identifier or name.</p>
</td></tr>
<tr><td><code id="calculate_aa_scores_+3A_diff">diff</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame containing the log2 fold change.</p>
</td></tr>
<tr><td><code id="calculate_aa_scores_+3A_adj_pval">adj_pval</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame containing the adjusted p-value.</p>
</td></tr>
<tr><td><code id="calculate_aa_scores_+3A_start_position">start_position</code></td>
<td>
<p>a numeric column <code>data</code> in the data frame containing the start position
of a peptide or precursor.</p>
</td></tr>
<tr><td><code id="calculate_aa_scores_+3A_end_position">end_position</code></td>
<td>
<p>a numeric column in the data frame containing the end position of a peptide or
precursor.</p>
</td></tr>
<tr><td><code id="calculate_aa_scores_+3A_retain_columns">retain_columns</code></td>
<td>
<p>a vector indicating if certain columns should be retained from the input
data frame. Default is not retaining additional columns <code>retain_columns = NULL</code>. Specific
columns can be retained by providing their names (not in quotations marks, just like other
column names, but in a vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the aggregated scores per amino acid position, enabling to
draw fingerprints for each individual protein.
</p>


<h3>Author(s)</h3>

<p>Patrick Stalder
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- data.frame(
  pg_protein_accessions = c(rep("protein_1", 10)),
  diff = c(2, -3, 1, 2, 3, -3, 5, 1, -0.5, 2),
  adj_pval = c(0.001, 0.01, 0.2, 0.05, 0.002, 0.5, 0.4, 0.7, 0.001, 0.02),
  start = c(1, 3, 5, 10, 15, 25, 28, 30, 41, 51),
  end = c(6, 8, 10, 16, 23, 35, 35, 35, 48, 55)
)
calculate_aa_scores(
  data,
  protein = pg_protein_accessions,
  diff = diff,
  adj_pval = adj_pval,
  start_position = start,
  end_position = end
)
</code></pre>

<hr>
<h2 id='calculate_diff_abundance'>Calculate differential abundance between conditions</h2><span id='topic+calculate_diff_abundance'></span>

<h3>Description</h3>

<p>Performs differential abundance calculations and statistical hypothesis tests on data frames
with protein, peptide or precursor data. Different methods for statistical testing are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_diff_abundance(
  data,
  sample,
  condition,
  grouping,
  intensity_log2,
  missingness = missingness,
  comparison = comparison,
  mean = NULL,
  sd = NULL,
  n_samples = NULL,
  ref_condition = "all",
  filter_NA_missingness = TRUE,
  method = c("moderated_t-test", "t-test", "t-test_mean_sd", "proDA"),
  p_adj_method = "BH",
  retain_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_diff_abundance_+3A_data">data</code></td>
<td>
<p>a data frame containing at least the input variables that are required for the
selected method. Ideally the output of <code>assign_missingness</code> or <code>impute</code> is used.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample name.
Is not required if <code>method = "t-test_mean_sd"</code>.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_condition">condition</code></td>
<td>
<p>a character or numeric column in the <code>data</code> data frame that contains the
conditions.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains precursor,
peptide or protein identifiers.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_intensity_log2">intensity_log2</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains intensity
values. The intensity values need to be log2 transformed. Is not required if
<code>method = "t-test_mean_sd"</code>.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_missingness">missingness</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains missingness
information. Can be obtained by calling <code>assign_missingness()</code>. Is not required if
<code>method = "t-test_mean_sd"</code>. The type of missingness assigned to a comparison does not have
any influence on the statistical test. However, if <code>filter_NA_missingness = TRUE</code> and
<code>method = "proDA"</code>, then comparisons with missingness <code>NA</code> are filtered out prior
to p-value adjustment.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_comparison">comparison</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains information of
treatment/reference condition pairs. Can be obtained by calling <code>assign_missingness</code>.
Comparisons need to be in the form condition1_vs_condition2, meaning two compared conditions are
separated by <code>"_vs_"</code>. This column determines for which condition pairs differential
abundances are calculated. Is not required if <code>method = "t-test_mean_sd"</code>, in that case
please provide a reference condition with the ref_condition argument.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_mean">mean</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains mean values for two
conditions. Is only required if <code>method = "t-test_mean_sd"</code>.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_sd">sd</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains standard deviations for
two conditions. Is only required if <code>method = "t-test_mean_sd"</code>.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_n_samples">n_samples</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the number of
samples per condition for two conditions. Is only required if <code>method = "t-test_mean_sd"</code>.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_ref_condition">ref_condition</code></td>
<td>
<p>optional, character value providing the condition that is used as a
reference for differential abundance calculation. Only required for <code>method = "t-test_mean_sd"</code>.
Instead of providing one reference condition, &quot;all&quot; can be supplied, which will create all
pairwise condition pairs. By default <code>ref_condition = "all"</code>.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_filter_na_missingness">filter_NA_missingness</code></td>
<td>
<p>a logical value, default is <code>TRUE</code>. For all methods except
<code>"t-test_mean_sd"</code> missingness information has to be provided. This information can be
for example obtained by calling <code>assign_missingness()</code>. If a reference/treatment pair has
too few samples to be considered robust based on user defined cutoffs, it is annotated with <code>NA</code>
as missingness by the <code>assign_missingness()</code> function. If this argument is <code>TRUE</code>,
these <code>NA</code> reference/treatment pairs are filtered out. For <code>method = "proDA"</code> this
is done before the p-value adjustment.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_method">method</code></td>
<td>
<p>a character value, specifies the method used for statistical hypothesis testing.
Methods include Welch test (<code>"t-test"</code>), a Welch test on means, standard deviations and
number of replicates (<code>"t-test_mean_sd"</code>) and a moderated t-test based on the <code>limma</code>
package (<code>"moderated_t-test"</code>). More information on the moderated t-test can be found in
the <code>limma</code> documentation. Furthermore, the <code>proDA</code> package specific method (<code>"proDA"</code>)
can be used to infer means across samples based on a probabilistic dropout model. This
eliminates the need for data imputation since missing values are inferred from the model. More
information can be found in the <code>proDA</code> documentation. We do not recommend using the
<code>moderated_t-test</code> or <code>proDA</code> method if the data was filtered for low CVs or imputation
was performed. Default is <code>method = "moderated_t-test"</code>.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_p_adj_method">p_adj_method</code></td>
<td>
<p>a character value, specifies the p-value correction method. Possible
methods are c(&quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;). Default
method is <code>"BH"</code>.</p>
</td></tr>
<tr><td><code id="calculate_diff_abundance_+3A_retain_columns">retain_columns</code></td>
<td>
<p>a vector indicating if certain columns should be retained from the input
data frame. Default is not retaining additional columns <code>retain_columns = NULL</code>. Specific
columns can be retained by providing their names (not in quotations marks, just like other
column names, but in a vector). Please note that if you retain columns that have multiple
rows per grouped variable there will be duplicated rows in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains differential abundances (<code>diff</code>), p-values (<code>pval</code>)
and adjusted p-values (<code>adj_pval</code>) for each protein, peptide or precursor (depending on
the <code>grouping</code> variable) and the associated treatment/reference pair. Depending on the
method the data frame contains additional columns:
</p>

<ul>
<li><p> &quot;t-test&quot;: The <code>std_error</code> column contains the standard error of the differential
abundances. <code>n_obs</code> contains the number of observations for the specific protein, peptide
or precursor (depending on the <code>grouping</code> variable) and the associated treatment/reference pair.
</p>
</li>
<li><p> &quot;t-test_mean_sd&quot;: Columns labeled as control refer to the second condition of the
comparison pairs. Treated refers to the first condition. <code>mean_control</code> and <code>mean_treated</code>
columns contain the means for the reference and treatment condition, respectively. <code>sd_control</code>
and <code>sd_treated</code> columns contain the standard deviations for the reference and treatment
condition, respectively. <code>n_control</code> and <code>n_treated</code> columns contain the numbers of
samples for the reference and treatment condition, respectively. The <code>std_error</code> column
contains the standard error of the differential abundances. <code>t_statistic</code> contains the
t_statistic for the t-test.
</p>
</li>
<li><p> &quot;moderated_t-test&quot;: <code>CI_2.5</code> and <code>CI_97.5</code> contain the 2.5% and 97.5%
confidence interval borders for differential abundances. <code>avg_abundance</code> contains average
abundances for treatment/reference pairs (mean of the two group means). <code>t_statistic</code>
contains the t_statistic for the t-test. <code>B</code> The B-statistic is the log-odds that the
protein, peptide or precursor (depending on <code>grouping</code>) has a differential abundance
between the two groups. Suppose B=1.5. The odds of differential abundance is exp(1.5)=4.48, i.e,
about four and a half to one. The probability that there is a differential abundance is
4.48/(1+4.48)=0.82, i.e., the probability is about 82% that this group is differentially
abundant. A B-statistic of zero corresponds to a 50-50 chance that the group is differentially
abundant.<code>n_obs</code> contains the number of observations for the specific protein, peptide or
precursor (depending on the <code>grouping</code> variable) and the associated treatment/reference pair.
</p>
</li>
<li><p> &quot;proDA&quot;: The <code>std_error</code> column contains the standard error of the differential
abundances. <code>avg_abundance</code> contains average abundances for treatment/reference pairs
(mean of the two group means). <code>t_statistic</code> contains the t_statistic for the t-test.
<code>n_obs</code> contains the number of observations for the specific protein, peptide or precursor
(depending on the <code>grouping</code> variable) and the associated treatment/reference pair.
</p>
</li></ul>

<p>For all methods execept <code>"proDA"</code>, the p-value adjustment is performed only on the
proportion of data that contains a p-value that is not <code>NA</code>. For <code>"proDA"</code> the
p-value adjustment is either performed on the complete dataset (<code>filter_NA_missingness = TRUE</code>)
or on the subset of the dataset with missingness that is not <code>NA</code> (<code>filter_NA_missingness = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create synthetic data
data &lt;- create_synthetic_data(
  n_proteins = 10,
  frac_change = 0.5,
  n_replicates = 4,
  n_conditions = 2,
  method = "effect_random",
  additional_metadata = FALSE
)

# Assign missingness information
data_missing &lt;- assign_missingness(
  data,
  sample = sample,
  condition = condition,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  ref_condition = "all",
  retain_columns = c(protein, change_peptide)
)

# Calculate differential abundances
# Using "moderated_t-test" and "proDA" improves
# true positive recovery progressively
diff &lt;- calculate_diff_abundance(
  data = data_missing,
  sample = sample,
  condition = condition,
  grouping = peptide,
  intensity_log2 = peptide_intensity_missing,
  missingness = missingness,
  comparison = comparison,
  method = "t-test",
  retain_columns = c(protein, change_peptide)
)

head(diff, n = 10)
</code></pre>

<hr>
<h2 id='calculate_go_enrichment'>Perform gene ontology enrichment analysis</h2><span id='topic+calculate_go_enrichment'></span>

<h3>Description</h3>

<p>Analyses enrichment of gene ontology terms associated with proteins in the fraction of
significant proteins compared to all detected proteins. A two-sided Fisher's exact test is
performed to test significance of enrichment or depletion. GO annotations can be provided to
this function either through UniProt <code>go_annotations_uniprot</code>, through a table obtained
with <code>fetch_go</code> in the <code>go_data</code> argument or GO annotations are fetched automatically
by the function by providing <code>ontology_type</code> and <code>organism_id</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_go_enrichment(
  data,
  protein_id,
  is_significant,
  group = NULL,
  y_axis_free = TRUE,
  facet_n_col = 2,
  go_annotations_uniprot = NULL,
  ontology_type,
  organism_id = NULL,
  go_data = NULL,
  plot = TRUE,
  plot_style = "barplot",
  plot_title = "Gene ontology enrichment of significant proteins",
  barplot_fill_colour = c("#56B4E9", "#E76145"),
  heatmap_fill_colour = protti::mako_colours,
  heatmap_fill_colour_rev = TRUE,
  label = TRUE,
  enrichment_type = "all",
  replace_long_name = TRUE,
  label_move_frac = 0.2,
  min_n_detected_proteins_in_process = 1,
  plot_cutoff = "adj_pval top10"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_go_enrichment_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_protein_id">protein_id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the protein
accession numbers.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_is_significant">is_significant</code></td>
<td>
<p>a logical column in the <code>data</code> data frame that indicates if the
corresponding protein has a significantly changing peptide. The input data frame may contain
peptide level information with significance information. The function is able to extract
protein level information from this.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_group">group</code></td>
<td>
<p>optional, character column in the <code>data</code> data frame that contains information by
which the analysis should be grouped. The analysis will be performed separately for each of the
groups. This is most likely a column that labels separate comparisons of different conditions.
In protti the <code>assign_missingness()</code> function creates such a column automatically.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_y_axis_free">y_axis_free</code></td>
<td>
<p>a logical value that specifies if the y-axis of the plot should be &quot;free&quot;
for each facet if a grouping variable is provided. Default is <code>TRUE</code>. If <code>FALSE</code> is selected
it is easier to compare GO categories directly with each other.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_facet_n_col">facet_n_col</code></td>
<td>
<p>a numeric value that specifies the number of columns the faceted plot should have
if a column name is provided to group. The default is 2.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_go_annotations_uniprot">go_annotations_uniprot</code></td>
<td>
<p>recommended, a character column in the <code>data</code> data frame
that contains gene ontology annotations obtained from UniProt using <code>fetch_uniprot</code>.
These annotations are already separated into the desired ontology type so the argument
<code>ontology_type</code> is not required.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_ontology_type">ontology_type</code></td>
<td>
<p>optional, character value specifying the type of ontology that should
be used. Possible values are molecular function (MF), biological process (BP), cellular component
(CC). This argument is not required if GO annotations are provided from UniProt in
<code>go_annotations_uniprot</code>. It is required if annotations are provided through <code>go_data</code> or
automatically fetched.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_organism_id">organism_id</code></td>
<td>
<p>optional, character value specifying an NCBI taxonomy identifier of an
organism (TaxId). Possible inputs include only: &quot;9606&quot; (Human), &quot;559292&quot; (Yeast) and &quot;83333&quot;
(E. coli). Is only necessary if GO data is not provided either by <code>go_annotations_uniprot</code>
or in <code>go_data</code>.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_go_data">go_data</code></td>
<td>
<p>Optional, a data frame that can be obtained with <code>fetch_go()</code>. If you provide
data not obtained with <code>fetch_go()</code> make sure column names for protein ID (<code>db_id</code>) and GO ID
(<code>go_id</code>) are the same as for data obtained with <code>fetch_go()</code>.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_plot">plot</code></td>
<td>
<p>a logical argument indicating whether the result should be plotted or returned as a table.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_plot_style">plot_style</code></td>
<td>
<p>a character argument that specifies the plot style. Can be either &quot;barplot&quot; (default)
or &quot;heatmap&quot;. The &quot;heatmap&quot; plot is especially useful for the comparison of multiple groups. We recommend,
however, that you use it only with <code>enrichment_type = "enriched"</code> or <code style="white-space: pre;">&#8288;enrichment_type = "deenriched&#8288;</code>,
because otherwise it is not possible to distinguish between enrichment and deenrichment in the plot.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_plot_title">plot_title</code></td>
<td>
<p>a character value that specifies the title of the plot. The default is &quot;Gene ontology
enrichment of significant proteins&quot;.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_barplot_fill_colour">barplot_fill_colour</code></td>
<td>
<p>a vector that contains two colours that should be used as the fill colours for
deenriched and enriched GO terms, respectively. If <code>enrichment_type = "enriched"</code> or <code style="white-space: pre;">&#8288;"deenriched&#8288;</code>, please
still provide two values in the vector, the colour not used for the plot can be <code>NA</code> in this case. E.g.
<code>c(NA, "red")</code> for <code>enrichment_type = "enriched"</code>.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_heatmap_fill_colour">heatmap_fill_colour</code></td>
<td>
<p>a vector that contains colours that should be used to create the gradient in the
heatmap plot. Default is <code>mako_colours</code>.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_heatmap_fill_colour_rev">heatmap_fill_colour_rev</code></td>
<td>
<p>a logical value that specifies if the provided colours in <code>heatmap_fill_colour</code>
should be reversed in order. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_label">label</code></td>
<td>
<p>a logical argument indicating whether labels should be added to the plot.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_enrichment_type">enrichment_type</code></td>
<td>
<p>a character argument that is either &quot;all&quot;, &quot;enriched&quot; or &quot;deenriched&quot;. This
determines if the enrichment analysis should be performed in order to check for both enrichemnt and
deenrichemnt or only one of the two. This affects the statistics performed and therefore also the displayed
plot.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_replace_long_name">replace_long_name</code></td>
<td>
<p>a logical argument that specifies if GO term names above 50 characters should
be replaced by the GO ID instead for the plot. This ensures that the plotting area doesn't become
too small due to the long name. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_label_move_frac">label_move_frac</code></td>
<td>
<p>a numeric argument between 0 and 1 that specifies which labels should be
moved outside of the bar. The default is 0.2, which means that the labels of all bars that have a size
of 20% or less of the largest bar are moved to the right of the bar. This prevents labels from
overlapping with the bar boundaries.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_min_n_detected_proteins_in_process">min_n_detected_proteins_in_process</code></td>
<td>
<p>is a numeric argument that specifies the minimum number of
detected proteins required for a GO term to be displayed in the plot. The default is 1, meaning
no filtering of the plotted data is performed. This argument does not affect any computations or
the returned data if <code>plot = FALSE</code>. This argument is useful in order to remove terms that were only
detected in for example 1 protein. Even though these terms are sometimes significant, they are not
really relevant.</p>
</td></tr>
<tr><td><code id="calculate_go_enrichment_+3A_plot_cutoff">plot_cutoff</code></td>
<td>
<p>a character value indicating if the plot should contain the top n (e.g. top10) most
significant proteins (p-value or adjusted p-value), or if a significance cutoff should be used
to determine the number of GO terms in the plot. This information should be provided with the
type first followed by the threshold separated by a space. Example are
<code>plot_cutoff = "adj_pval top10"</code>, <code>plot_cutoff = "pval 0.05"</code> or
<code>plot_cutoff = "adj_pval 0.01"</code>. The threshold can be chosen freely. The default value is
<code>"adj_pval top10"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bar plot or heatmap (depending on <code>plot_style</code>). By default the bar plot displays negative log10
adjusted p-values for the top 10 enriched or deenriched gene ontology terms. Alternatively, plot cutoffs
can be chosen individually with the <code>plot_cutoff</code> argument. Bars are colored according to the direction
of the enrichment (enriched or deenriched). If a heatmap is returned, terms are organised on the y-axis, while
the colour of each tile represents the negative log10 adjusted p-value (default). If a <code>group</code> column
is provided the x-axis contains all groups. If <code>plot = FALSE</code>, a data frame is returned. P-values are adjusted with
Benjamini-Hochberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(dplyr)
library(stringr)

# Create example data
# Contains artificial de-enrichment for ribosomes.
uniprot_go_data &lt;- fetch_uniprot_proteome(
  organism_id = 83333,
  columns = c(
    "accession",
    "go_f"
  )
)

if (!is(uniprot_go_data, "character")) {
  data &lt;- uniprot_go_data %&gt;%
    mutate(significant = c(
      rep(TRUE, 1000),
      rep(FALSE, n() - 1000)
    )) %&gt;%
    mutate(significant = ifelse(
      str_detect(
        go_f,
        pattern = "ribosome"
      ),
      FALSE,
      significant
    )) %&gt;%
    mutate(group = c(
      rep("A", 500),
      rep("B", 500),
      rep("A", (n() - 1000) / 2),
      rep("B", round((n() - 1000) / 2))
    ))

  # Plot gene ontology enrichment
  calculate_go_enrichment(
    data,
    protein_id = accession,
    go_annotations_uniprot = go_f,
    is_significant = significant,
    plot = TRUE,
    plot_cutoff = "pval 0.01"
  )

  # Plot gene ontology enrichment with group
  calculate_go_enrichment(
    data,
    protein_id = accession,
    go_annotations_uniprot = go_f,
    is_significant = significant,
    group = group,
    facet_n_col = 1,
    plot = TRUE,
    plot_cutoff = "pval 0.01"
  )

  # Plot gene ontology enrichment with group in a heatmap plot
  calculate_go_enrichment(
    data,
    protein_id = accession,
    group = group,
    go_annotations_uniprot = go_f,
    is_significant = significant,
    min_n_detected_proteins_in_process = 15,
    plot = TRUE,
    label = TRUE,
    plot_style = "heatmap",
    enrichment_type = "enriched",
    plot_cutoff = "pval 0.01"
  )

  # Calculate gene ontology enrichment
  go_enrichment &lt;- calculate_go_enrichment(
    data,
    protein_id = accession,
    go_annotations_uniprot = go_f,
    is_significant = significant,
    plot = FALSE,
  )

  head(go_enrichment, n = 10)
}

</code></pre>

<hr>
<h2 id='calculate_imputation'>Sampling of values for imputation</h2><span id='topic+calculate_imputation'></span>

<h3>Description</h3>

<p><code>calculate_imputation</code> is a helper function that is used in the <code>impute</code> function.
Depending on the type of missingness and method, it samples values from a normal distribution
that can be used for the imputation. Note: The input intensities should be log2 transformed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_imputation(
  min = NULL,
  noise = NULL,
  mean = NULL,
  sd,
  missingness = c("MNAR", "MAR"),
  method = c("ludovic", "noise"),
  skip_log2_transform_error = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_imputation_+3A_min">min</code></td>
<td>
<p>a numeric value specifying the minimal intensity value of the precursor/peptide.
Is only required if <code>method = "ludovic"</code> and <code>missingness = "MNAR"</code>.</p>
</td></tr>
<tr><td><code id="calculate_imputation_+3A_noise">noise</code></td>
<td>
<p>a numeric value specifying a noise value for the precursor/peptide. Is only
required if <code>method = "noise"</code> and <code>missingness = "MNAR"</code>.</p>
</td></tr>
<tr><td><code id="calculate_imputation_+3A_mean">mean</code></td>
<td>
<p>a numeric value specifying the mean intensity value of the condition with missing
values for a given precursor/peptide. Is only required if <code>missingness = "MAR"</code>.</p>
</td></tr>
<tr><td><code id="calculate_imputation_+3A_sd">sd</code></td>
<td>
<p>a numeric value specifying the mean of the standard deviation of all conditions for
a given precursor/peptide.</p>
</td></tr>
<tr><td><code id="calculate_imputation_+3A_missingness">missingness</code></td>
<td>
<p>a character value specifying the missingness type of the data determines
how values for imputation are sampled. This can be <code>"MAR"</code> or <code>"MNAR"</code>.</p>
</td></tr>
<tr><td><code id="calculate_imputation_+3A_method">method</code></td>
<td>
<p>a character value specifying the method to be used for imputation. For
<code>method = "ludovic"</code>, MNAR missingness is sampled around a value that is three lower
(log2) than the lowest intensity value recorded for the precursor/peptide. For
<code>method = "noise"</code>, MNAR missingness is sampled around the noise value for the
precursor/peptide.</p>
</td></tr>
<tr><td><code id="calculate_imputation_+3A_skip_log2_transform_error">skip_log2_transform_error</code></td>
<td>
<p>a logical value, if FALSE a check is performed to validate that
input values are log2 transformed. If input values are &gt; 40 the test is failed and an error is
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value sampled from a normal distribution with the input parameters. Method specifics
are applied to input parameters prior to sampling.
</p>

<hr>
<h2 id='calculate_kegg_enrichment'>Perform KEGG pathway enrichment analysis</h2><span id='topic+calculate_kegg_enrichment'></span>

<h3>Description</h3>

<p>Analyses enrichment of KEGG pathways associated with proteins in the fraction of significant
proteins compared to all detected proteins. A Fisher's exact test is performed to test
significance of enrichment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_kegg_enrichment(
  data,
  protein_id,
  is_significant,
  pathway_id = pathway_id,
  pathway_name = pathway_name,
  plot = TRUE,
  plot_cutoff = "adj_pval top10"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_kegg_enrichment_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="calculate_kegg_enrichment_+3A_protein_id">protein_id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the protein
accession numbers.</p>
</td></tr>
<tr><td><code id="calculate_kegg_enrichment_+3A_is_significant">is_significant</code></td>
<td>
<p>a logical column in the <code>data</code> data frame that indicates if the
corresponding protein has a significantly changing peptide. The input data frame may contain
peptide level information with significance information. The function is able to extract
protein level information from this.</p>
</td></tr>
<tr><td><code id="calculate_kegg_enrichment_+3A_pathway_id">pathway_id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains KEGG pathway
identifiers. These can be obtained from KEGG using <code>fetch_kegg</code>.</p>
</td></tr>
<tr><td><code id="calculate_kegg_enrichment_+3A_pathway_name">pathway_name</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains KEGG pathway
names. These can be obtained from KEGG using <code>fetch_kegg</code>.</p>
</td></tr>
<tr><td><code id="calculate_kegg_enrichment_+3A_plot">plot</code></td>
<td>
<p>a logical value indicating whether the result should be plotted or returned as a
table.</p>
</td></tr>
<tr><td><code id="calculate_kegg_enrichment_+3A_plot_cutoff">plot_cutoff</code></td>
<td>
<p>a character value indicating if the plot should contain the top 10 most
significant proteins (p-value or adjusted p-value), or if a significance cutoff should be used
to determine the number of GO terms in the plot. This information should be provided with the
type first followed by the threshold separated by a space. Example are
<code>plot_cutoff = "adj_pval top10"</code>, <code>plot_cutoff = "pval 0.05"</code> or
<code>plot_cutoff = "adj_pval 0.01"</code>. The threshold can be chosen freely.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bar plot displaying negative log10 adjusted p-values for the top 10 enriched pathways.
Bars are coloured according to the direction of the enrichment. If <code>plot = FALSE</code>, a data
frame is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(dplyr)

set.seed(123) # Makes example reproducible

# Create example data
kegg_data &lt;- fetch_kegg(species = "eco")

if (!is.null(kegg_data)) { # only proceed if information was retrieved
  data &lt;- kegg_data %&gt;%
    group_by(uniprot_id) %&gt;%
    mutate(significant = rep(
      sample(
        x = c(TRUE, FALSE),
        size = 1,
        replace = TRUE,
        prob = c(0.2, 0.8)
      ),
      n = n()
    ))

  # Plot KEGG enrichment
  calculate_kegg_enrichment(
    data,
    protein_id = uniprot_id,
    is_significant = significant,
    pathway_id = pathway_id,
    pathway_name = pathway_name,
    plot = TRUE,
    plot_cutoff = "pval 0.05"
  )

  # Calculate KEGG enrichment
  kegg &lt;- calculate_kegg_enrichment(
    data,
    protein_id = uniprot_id,
    is_significant = significant,
    pathway_id = pathway_id,
    pathway_name = pathway_name,
    plot = FALSE
  )

  head(kegg, n = 10)
}

</code></pre>

<hr>
<h2 id='calculate_protein_abundance'>Label-free protein quantification</h2><span id='topic+calculate_protein_abundance'></span>

<h3>Description</h3>

<p>Determines relative protein abundances from ion quantification. Only proteins with at least
three peptides are considered for quantification. The three peptide rule applies for each
sample independently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_protein_abundance(
  data,
  sample,
  protein_id,
  precursor,
  peptide,
  intensity_log2,
  min_n_peptides = 3,
  method = "sum",
  for_plot = FALSE,
  retain_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_protein_abundance_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="calculate_protein_abundance_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample name.</p>
</td></tr>
<tr><td><code id="calculate_protein_abundance_+3A_protein_id">protein_id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the protein
accession numbers.</p>
</td></tr>
<tr><td><code id="calculate_protein_abundance_+3A_precursor">precursor</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains precursors.</p>
</td></tr>
<tr><td><code id="calculate_protein_abundance_+3A_peptide">peptide</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains peptide sequences.
This column is needed to filter for proteins with at least 3 unique peptides. This can equate
to more than three precursors. The quantification is done on the precursor level.</p>
</td></tr>
<tr><td><code id="calculate_protein_abundance_+3A_intensity_log2">intensity_log2</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains log2
transformed precursor intensities.</p>
</td></tr>
<tr><td><code id="calculate_protein_abundance_+3A_min_n_peptides">min_n_peptides</code></td>
<td>
<p>An integer specifying the minimum number of peptides required
for a protein to be included in the analysis. The default value is 3, which means
proteins with fewer than three unique peptides will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="calculate_protein_abundance_+3A_method">method</code></td>
<td>
<p>a character value specifying with which method protein quantities should be
calculated. Possible options include <code>"sum"</code>, which takes the sum of all precursor
intensities as the protein abundance. Another option is <code>"iq"</code>, which performs protein
quantification based on a maximal peptide ratio extraction algorithm that is adapted from the
MaxLFQ algorithm of the MaxQuant software. Functions from the
<code>iq</code> package (<a href="https://doi.org/10.1093/bioinformatics/btz961">doi:10.1093/bioinformatics/btz961</a>) are used. Default is <code>"iq"</code>.</p>
</td></tr>
<tr><td><code id="calculate_protein_abundance_+3A_for_plot">for_plot</code></td>
<td>
<p>a logical value indicating whether the result should be only protein intensities
or protein intensities together with precursor intensities that can be used for plotting using
<code>peptide_profile_plot()</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculate_protein_abundance_+3A_retain_columns">retain_columns</code></td>
<td>
<p>a vector indicating if certain columns should be retained from the input
data frame. Default is not retaining additional columns <code>retain_columns = NULL</code>. Specific
columns can be retained by providing their names (not in quotations marks, just like other
column names, but in a vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>for_plot = FALSE</code>, protein abundances are returned, if <code>for_plot = TRUE</code>
also precursor intensities are returned in a data frame. The later output is ideal for plotting
with <code>peptide_profile_plot()</code> and can be filtered to only include protein abundances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create example data
data &lt;- data.frame(
  sample = c(
    rep("S1", 6),
    rep("S2", 6),
    rep("S1", 2),
    rep("S2", 2)
  ),
  protein_id = c(
    rep("P1", 12),
    rep("P2", 4)
  ),
  precursor = c(
    rep(c("A1", "A2", "B1", "B2", "C1", "D1"), 2),
    rep(c("E1", "F1"), 2)
  ),
  peptide = c(
    rep(c("A", "A", "B", "B", "C", "D"), 2),
    rep(c("E", "F"), 2)
  ),
  intensity = c(
    rnorm(n = 6, mean = 15, sd = 2),
    rnorm(n = 6, mean = 21, sd = 1),
    rnorm(n = 2, mean = 15, sd = 1),
    rnorm(n = 2, mean = 15, sd = 2)
  )
)

data

# Calculate protein abundances
protein_abundance &lt;- calculate_protein_abundance(
  data,
  sample = sample,
  protein_id = protein_id,
  precursor = precursor,
  peptide = peptide,
  intensity_log2 = intensity,
  method = "sum",
  for_plot = FALSE
)

protein_abundance

# Calculate protein abundances and retain precursor
# abundances that can be used in a peptide profile plot
complete_abundances &lt;- calculate_protein_abundance(
  data,
  sample = sample,
  protein_id = protein_id,
  precursor = precursor,
  peptide = peptide,
  intensity_log2 = intensity,
  method = "sum",
  for_plot = TRUE
)

complete_abundances

</code></pre>

<hr>
<h2 id='calculate_sequence_coverage'>Protein sequence coverage</h2><span id='topic+calculate_sequence_coverage'></span>

<h3>Description</h3>

<p>Calculate sequence coverage for each identified protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_sequence_coverage(data, protein_sequence, peptides)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_sequence_coverage_+3A_data">data</code></td>
<td>
<p>a data frame containing at least the protein sequence and the identified peptides
as columns.</p>
</td></tr>
<tr><td><code id="calculate_sequence_coverage_+3A_protein_sequence">protein_sequence</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains protein
sequences. Can be obtained by using the function <code>fetch_uniprot()</code></p>
</td></tr>
<tr><td><code id="calculate_sequence_coverage_+3A_peptides">peptides</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the identified
peptides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new column in the <code>data</code> data frame containing the calculated sequence coverage
for each identified protein
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  protein_sequence = c("abcdefghijklmnop", "abcdefghijklmnop"),
  pep_stripped_sequence = c("abc", "jklmn")
)

calculate_sequence_coverage(
  data,
  protein_sequence = protein_sequence,
  peptides = pep_stripped_sequence
)
</code></pre>

<hr>
<h2 id='calculate_treatment_enrichment'>Check treatment enrichment</h2><span id='topic+calculate_treatment_enrichment'></span>

<h3>Description</h3>

<p>Check for an enrichment of proteins interacting with the treatment in significantly changing
proteins as compared to all proteins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_treatment_enrichment(
  data,
  protein_id,
  is_significant,
  binds_treatment,
  group = NULL,
  treatment_name,
  plot = TRUE,
  fill_colours = protti::protti_colours,
  fill_by_group = FALSE,
  facet_n_col = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_treatment_enrichment_+3A_data">data</code></td>
<td>
<p>a data frame contains at least the input variables.</p>
</td></tr>
<tr><td><code id="calculate_treatment_enrichment_+3A_protein_id">protein_id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the protein
accession numbers.</p>
</td></tr>
<tr><td><code id="calculate_treatment_enrichment_+3A_is_significant">is_significant</code></td>
<td>
<p>a logical column in the <code>data</code> data frame that indicates if the
corresponding protein has a significantly changing peptide. The input data frame may contain
peptide level information with significance information. The function is able to extract protein
level information from this.</p>
</td></tr>
<tr><td><code id="calculate_treatment_enrichment_+3A_binds_treatment">binds_treatment</code></td>
<td>
<p>a logical column in the <code>data</code> data frame that indicates if the
corresponding protein binds to the treatment. This information can be obtained from different
databases, e.g. UniProt.</p>
</td></tr>
<tr><td><code id="calculate_treatment_enrichment_+3A_group">group</code></td>
<td>
<p>optional, character column in the <code>data</code> data frame that contains information by
which the analysis should be grouped. The analysis will be performed separately for each of the
groups. This is most likely a column that labels separate comparisons of different conditions.
In protti the <code>assign_missingness()</code> function creates such a column automatically.</p>
</td></tr>
<tr><td><code id="calculate_treatment_enrichment_+3A_treatment_name">treatment_name</code></td>
<td>
<p>a character value that indicates the treatment name. It will be included
in the plot title.</p>
</td></tr>
<tr><td><code id="calculate_treatment_enrichment_+3A_plot">plot</code></td>
<td>
<p>a logical value indicating whether the result should be plotted or returned as a
table.</p>
</td></tr>
<tr><td><code id="calculate_treatment_enrichment_+3A_fill_colours">fill_colours</code></td>
<td>
<p>a character vector that specifies the fill colours of the plot.</p>
</td></tr>
<tr><td><code id="calculate_treatment_enrichment_+3A_fill_by_group">fill_by_group</code></td>
<td>
<p>a logical value that specifies if the bars in the plot should be filled by group
if the group argument is provided. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculate_treatment_enrichment_+3A_facet_n_col">facet_n_col</code></td>
<td>
<p>a numeric value that specifies the number of columns the facet plot should have if
a <code>group</code> column was provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bar plot displaying the percentage of all detected proteins and all significant proteins
that bind to the treatment. A Fisher's exact test is performed to calculate the significance of
the enrichment in significant proteins compared to all proteins. The result is reported as a
p-value. If <code>plot = FALSE</code> a contingency table in long format is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create example data
data &lt;- data.frame(
  protein_id = c(paste0("protein", 1:50)),
  significant = c(
    rep(TRUE, 20),
    rep(FALSE, 30)
  ),
  binds_treatment = c(
    rep(TRUE, 10),
    rep(FALSE, 10),
    rep(TRUE, 5),
    rep(FALSE, 25)
  ),
  group = c(
    rep("A", 5),
    rep("B", 15),
    rep("A", 15),
    rep("B", 15)
  )
)

# Plot treatment enrichment
calculate_treatment_enrichment(
  data,
  protein_id = protein_id,
  is_significant = significant,
  binds_treatment = binds_treatment,
  treatment_name = "Rapamycin",
  plot = TRUE
)

# Plot treatment enrichment by group
calculate_treatment_enrichment(
  data,
  protein_id = protein_id,
  group = group,
  is_significant = significant,
  binds_treatment = binds_treatment,
  treatment_name = "Rapamycin",
  plot = TRUE,
  fill_by_group = TRUE
)

# Calculate treatment enrichment
enrichment &lt;- calculate_treatment_enrichment(
  data,
  protein_id = protein_id,
  is_significant = significant,
  binds_treatment = binds_treatment,
  plot = FALSE
)

enrichment
</code></pre>

<hr>
<h2 id='correct_lip_for_abundance'>Protein abundance correction for LiP-data</h2><span id='topic+correct_lip_for_abundance'></span>

<h3>Description</h3>

<p>Performs the correction of LiP-peptides for changes in protein abundance and
calculates their significance using a t-test. This function was implemented based
on the <a href="https://www.bioconductor.org/packages/release/bioc/html/MSstatsLiP.html">MSstatsLiP</a>
package developed by the Vitek lab.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_lip_for_abundance(
  lip_data,
  trp_data,
  protein_id,
  grouping,
  comparison = comparison,
  diff = diff,
  n_obs = n_obs,
  std_error = std_error,
  p_adj_method = "BH",
  retain_columns = NULL,
  method = c("satterthwaite", "no_df_approximation")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_lip_for_abundance_+3A_lip_data">lip_data</code></td>
<td>
<p>a data frame containing at least the input variables. Ideally,
the result from the <code>calculate_diff_abundance</code> function is used.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_trp_data">trp_data</code></td>
<td>
<p>a data frame containing at least the input variables minus the grouping column. Ideally,
the result from the <code>calculate_diff_abundance</code> function is used.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_protein_id">protein_id</code></td>
<td>
<p>a character column in the <code>lip_data</code> and <code>trp_data</code> data frames
that contains protein identifiers.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>lip_data</code> data frame that contains precursor or
peptide identifiers.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_comparison">comparison</code></td>
<td>
<p>a character column in the <code>lip_data</code> and <code>trp_data</code> data frames
that contains the comparisons between conditions.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_diff">diff</code></td>
<td>
<p>a numeric column in the <code>lip_data</code> and <code>trp_data</code> data frames
that contains log2-fold changes for peptide or protein quantities.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_n_obs">n_obs</code></td>
<td>
<p>a numeric column in the <code>lip_data</code> and <code>trp_data</code> data frames
containing the number of observations used to calculate fold changes.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_std_error">std_error</code></td>
<td>
<p>a numeric column in the <code>lip_data</code> and <code>trp_data</code> data frames
containing the standard error of fold changes.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_p_adj_method">p_adj_method</code></td>
<td>
<p>a character value, specifies the p-value correction method. Possible
methods are c(&quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;). Default
method is <code>"BH"</code>.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_retain_columns">retain_columns</code></td>
<td>
<p>a vector indicating if certain columns should be retained from the input
data frame. Default is not retaining additional columns <code>retain_columns = NULL</code>. Specific
columns can be retained by providing their names (not in quotations marks, just like other
column names, but in a vector). Please note that if you retain columns that have multiple
rows per grouped variable there will be duplicated rows in the output.</p>
</td></tr>
<tr><td><code id="correct_lip_for_abundance_+3A_method">method</code></td>
<td>
<p>a character value, specifies the method used to estimate the degrees of freedom.
Possible methods are c(&quot;satterthwaite&quot;, &quot;no_df_approximation&quot;). <code>satterthwaite</code> uses the Welch-Satterthwaite
equation to estimate the pooled degrees of freedom, as described in https://doi.org/10.1016/j.mcpro.2022.100477 and
implemented in the MSstatsLiP package. This approach respects the number of protein measurements for the degrees of freedom.
<code>no_df_approximation</code> just takes the number of peptides into account when calculating the degrees of freedom.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing corrected differential abundances (<code>adj_diff</code>, adjusted
standard errors (<code>adj_std_error</code>), degrees of freedom (<code>df</code>), pvalues (<code>pval</code>) and
adjusted p-values (<code>adj_pval</code>)
</p>


<h3>Author(s)</h3>

<p>Aaron Fehr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries

library(dplyr)

# Load example data and simulate tryptic data by summing up precursors

data &lt;- rapamycin_10uM

data_trp &lt;- data %&gt;%
  dplyr::group_by(pg_protein_accessions, r_file_name) %&gt;%
  dplyr::mutate(pg_quantity = sum(fg_quantity)) %&gt;%
  dplyr::distinct(
    r_condition,
    r_file_name,
    pg_protein_accessions,
    pg_quantity
  )


# Calculate differential abundances for LiP and Trp data

diff_lip &lt;- data %&gt;%
  dplyr::mutate(fg_intensity_log2 = log2(fg_quantity)) %&gt;%
  assign_missingness(
    sample = r_file_name,
    condition = r_condition,
    intensity = fg_intensity_log2,
    grouping = eg_precursor_id,
    ref_condition = "control",
    retain_columns = "pg_protein_accessions"
  ) %&gt;%
  calculate_diff_abundance(
    sample = r_file_name,
    condition = r_condition,
    grouping = eg_precursor_id,
    intensity_log2 = fg_intensity_log2,
    comparison = comparison,
    method = "t-test",
    retain_columns = "pg_protein_accessions"
  )


diff_trp &lt;- data_trp %&gt;%
  dplyr::mutate(pg_intensity_log2 = log2(pg_quantity)) %&gt;%
  assign_missingness(
    sample = r_file_name,
    condition = r_condition,
    intensity = pg_intensity_log2,
    grouping = pg_protein_accessions,
    ref_condition = "control"
  ) %&gt;%
  calculate_diff_abundance(
    sample = r_file_name,
    condition = r_condition,
    grouping = pg_protein_accessions,
    intensity_log2 = pg_intensity_log2,
    comparison = comparison,
    method = "t-test"
  )

# Correct for abundance changes

corrected &lt;- correct_lip_for_abundance(
  lip_data = diff_lip,
  trp_data = diff_trp,
  protein_id = pg_protein_accessions,
  grouping = eg_precursor_id,
  retain_columns = c("missingness"),
  method = "satterthwaite"
)

head(corrected, n = 10)
</code></pre>

<hr>
<h2 id='create_queue'>Creates a mass spectrometer queue for Xcalibur</h2><span id='topic+create_queue'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This function creates a measurement queue for sample acquisition for the software Xcalibur.
All possible combinations of the provided information will be created to make file and
sample names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_queue(
  date = NULL,
  instrument = NULL,
  user = NULL,
  measurement_type = NULL,
  experiment_name = NULL,
  digestion = NULL,
  treatment_type_1 = NULL,
  treatment_type_2 = NULL,
  treatment_dose_1 = NULL,
  treatment_dose_2 = NULL,
  treatment_unit_1 = NULL,
  treatment_unit_2 = NULL,
  n_replicates = NULL,
  number_runs = FALSE,
  organism = NULL,
  exclude_combinations = NULL,
  inj_vol = NA,
  data_path = NA,
  method_path = NA,
  position_row = NA,
  position_column = NA,
  blank_every_n = NULL,
  blank_position = NA,
  blank_method_path = NA,
  blank_inj_vol = 1,
  export = FALSE,
  export_to_queue = FALSE,
  queue_path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_queue_+3A_date">date</code></td>
<td>
<p>optional, character value indicating the start date of the measurements.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_instrument">instrument</code></td>
<td>
<p>optional, character value indicating the instrument initials.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_user">user</code></td>
<td>
<p>optional, character value indicating the user name.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_measurement_type">measurement_type</code></td>
<td>
<p>optional, character value indicating the measurement type of the
samples (e.g &quot;DIA&quot;, &quot;DDA&quot;, &quot;library&quot; etc.).</p>
</td></tr>
<tr><td><code id="create_queue_+3A_experiment_name">experiment_name</code></td>
<td>
<p>optional, character value indicating the name of the experiment.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_digestion">digestion</code></td>
<td>
<p>optional, character vector indicating the digestion types used in this
experiment (e.g &quot;LiP&quot; and/or &quot;tryptic control&quot;).</p>
</td></tr>
<tr><td><code id="create_queue_+3A_treatment_type_1">treatment_type_1</code></td>
<td>
<p>optional, character vector indicating the name of the treatment.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_treatment_type_2">treatment_type_2</code></td>
<td>
<p>optional, character vector indicating the name of a second treatment
that was combined with the first treatment.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_treatment_dose_1">treatment_dose_1</code></td>
<td>
<p>optional, numeric vector indicating the doses used for treatment 1.
These can be concentrations or times etc.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_treatment_dose_2">treatment_dose_2</code></td>
<td>
<p>optional, numeric vector indicating the doses used for treatment 2.
These can be concentrations or times etc.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_treatment_unit_1">treatment_unit_1</code></td>
<td>
<p>optional, character vector indicating the unit of the doses for
treatment 1 (e.g min, mM, etc.).</p>
</td></tr>
<tr><td><code id="create_queue_+3A_treatment_unit_2">treatment_unit_2</code></td>
<td>
<p>optional, character vector indicating the unit of the doses for
treatment 2 (e.g min, mM, etc.).</p>
</td></tr>
<tr><td><code id="create_queue_+3A_n_replicates">n_replicates</code></td>
<td>
<p>optional, a numeric value indicating the number of replicates used per sample.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_number_runs">number_runs</code></td>
<td>
<p>a logical that specifies if file names should be numbered from 1:n instead of
adding experiment information. Default is FALSE.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_organism">organism</code></td>
<td>
<p>optional, character value indicating the name of the organism used.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_exclude_combinations">exclude_combinations</code></td>
<td>
<p>optional, list of lists that contains vectors of treatment types and
treatment doses of which combinations should be excluded from the final queue.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_inj_vol">inj_vol</code></td>
<td>
<p>a numeric value indicating the volume used for injection in microliter. Will be
<code>NA</code> if not specified. Then it needs to be manually specified before the queue can be used.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_data_path">data_path</code></td>
<td>
<p>a character value indicating the file path where the MS raw data should be saved.
Backslashes should be escaped by another backslash. Will be <code>NA</code> if not specified, but
needs to be specified later on then.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_method_path">method_path</code></td>
<td>
<p>a character value indicating the file path of the MS acquisition method.
Backslashes should be escaped by another backslash. Will be <code>NA</code> if not specified, but
needs to be specified later on then.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_position_row">position_row</code></td>
<td>
<p>a character vector that contains row positions that can be used for the
samples (e.g c(&quot;A&quot;, &quot;B&quot;)). If the number of specified rows and columns does not equal the total
number of samples, positions will be repeated.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_position_column">position_column</code></td>
<td>
<p>a character vector that contains column positions that can be used for the
samples (e.g 8). If the number of specified rows and columns does not equal the total number
of samples, positions will be repeated.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_blank_every_n">blank_every_n</code></td>
<td>
<p>optional, numeric value that specifies in which intervals a blank sample
should be inserted.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_blank_position">blank_position</code></td>
<td>
<p>a character value that specifies the plate position of the blank. Will be
<code>NA</code> if not specified, but needs to be specified later on then.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_blank_method_path">blank_method_path</code></td>
<td>
<p>a character value that specifies the file path of the MS acquisition
method of the blank. Backslashes should be escaped by another backslash. Will be <code>NA</code> if
not specified, but needs to be specified later on then.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_blank_inj_vol">blank_inj_vol</code></td>
<td>
<p>a numeric value that specifies the injection volume of the blank sample.
Will be <code>NA</code> if not specified, but needs to be specified later on then.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_export">export</code></td>
<td>
<p>a logical value that specifies if the queue should be exported from R and saved
as a .csv file. Default is TRUE. Further options for export can be adjusted with the
<code>export_to_queue</code> and <code>queue_path</code> arguments.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_export_to_queue">export_to_queue</code></td>
<td>
<p>a logical value that specifies if the resulting queue should be appended
to an already existing queue. If false result will be saved as <code>queue.csv</code>.</p>
</td></tr>
<tr><td><code id="create_queue_+3A_queue_path">queue_path</code></td>
<td>
<p>optional, a character value that specifies the file path to a queue file to
which the generated queue should be appended if <code>export_to_queue = TRUE</code>. If not specified
queue file can be chosen interactively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>export_to_queue = FALSE</code> a file named <code>queue.csv</code> will be returned that
contains the generated queue. If <code>export_to_queue = TRUE</code>, the resulting generated queue
will be appended to an already existing queue that needs to be specified either interactively
or through the argument <code>queue_path</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_queue(
  date = c("200722"),
  instrument = c("EX1"),
  user = c("jquast"),
  measurement_type = c("DIA"),
  experiment_name = c("JPQ031"),
  digestion = c("LiP", "tryptic control"),
  treatment_type_1 = c("EDTA", "H2O"),
  treatment_type_2 = c("Zeba", "unfiltered"),
  treatment_dose_1 = c(10, 30, 60),
  treatment_unit_1 = c("min"),
  n_replicates = 4,
  number_runs = FALSE,
  organism = c("E. coli"),
  exclude_combinations = list(list(
    treatment_type_1 = c("H2O"),
    treatment_type_2 = c("Zeba", "unfiltered"),
    treatment_dose_1 = c(10, 30)
  )),
  inj_vol = c(2),
  data_path = "D:\\2007_Data",
  method_path = "C:\\Xcalibur\\methods\\DIA_120min",
  position_row = c("A", "B", "C", "D", "E", "F"),
  position_column = 8,
  blank_every_n = 4,
  blank_position = "1-V1",
  blank_method_path = "C:\\Xcalibur\\methods\\blank"
)
</code></pre>

<hr>
<h2 id='create_structure_contact_map'>Creates a contact map of all atoms from a structure file</h2><span id='topic+create_structure_contact_map'></span>

<h3>Description</h3>

<p>Creates a contact map of a subset or of all atom or residue distances in a structure or
AlphaFold prediction file. Contact maps are a useful tool for the identification of protein
regions that are in close proximity in the folded protein. Additionally, regions that are
interacting closely with a small molecule or metal ion can be easily identified without the
need to open the structure in programs such as PyMOL or ChimeraX. For large datasets (more
than 40 contact maps) it is recommended to use the <code>parallel_create_structure_contact_map()</code>
function instead, regardless of if maps should be created in parallel or sequential.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_structure_contact_map(
  data,
  data2 = NULL,
  id,
  chain = NULL,
  auth_seq_id = NULL,
  distance_cutoff = 10,
  pdb_model_number_selection = c(0, 1),
  return_min_residue_distance = TRUE,
  show_progress = TRUE,
  export = FALSE,
  export_location = NULL,
  structure_file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_structure_contact_map_+3A_data">data</code></td>
<td>
<p>a data frame containing at least a column with PDB ID information of which the name
can be provided to the <code>id</code> argument. If only this column is provided, all atom or residue
distances are calculated. Additionally, a chain column can be present in the data frame of which
the name can be provided to the <code>chain</code> argument. If chains are provided, only distances
of this chain relative to the rest of the structure are calculated. Multiple chains can be
provided in multiple rows. If chains are provided for one structure but not for another, the
rows should contain NAs. Furthermore, specific residue positions can be provided in the <code>auth_seq_id</code>
column if the selection should be further reduced. It is not recommended to create full
contact maps for more than a few structures due to time and memory limitations. If contact maps are
created only for small regions it is possible to create multiple maps at once. By default distances
of regions provided in this data frame to the complete structure are computed. If distances of regions
from this data frame to another specific subset of regions should be computed, the second subset
of regions can be provided through the optional <code>data2</code> argument.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_data2">data2</code></td>
<td>
<p>optional, a data frame that contains a subset of regions for which distances to regions
provided in the <code>data</code> data frame should be computed. If regions from the <code>data</code> data
frame should be compared to the whole structure, data2 does not need to be provided.
This data frame should have the same structure and column names as the <code>data</code> data frame.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_id">id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains PDB or UniProt IDs for
structures or AlphaFold predictions of which contact maps should be created. If a structure not
downloaded directly from PDB is provided (i.e. a locally stored structure file) to the
<code>structure_file</code> argument, this column should contain &quot;my_structure&quot; as content.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_chain">chain</code></td>
<td>
<p>optional, a character column in the <code>data</code> data frame that contains chain
identifiers for the structure file. Identifiers defined by the structure author should be used.
Distances will be only calculated between the provided chains and the rest of the structure.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_auth_seq_id">auth_seq_id</code></td>
<td>
<p>optional, a character (or numeric) column in the <code>data</code> data frame
that contains semicolon separated positions of regions for which distances should be calculated.
This always needs to be provided in combination with a corresponding chain in <code>chain</code>.
The position should match the positioning defined by the structure author. For
PDB structures this information can be obtained from the <code>find_peptide_in_structure</code>
function. The corresponding column in the output is called <code>auth_seq_id</code>. If an
AlphaFold prediction is provided, UniProt positions should be used. If signal positions
and not stretches of amino acids are provided, the column can be numeric and does not need
to contain the semicolon separator.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_distance_cutoff">distance_cutoff</code></td>
<td>
<p>a numeric value specifying the distance cutoff in Angstrom. All values
for pairwise comparisons are calculated but only values smaller than this cutoff will be
returned in the output. If a cutoff of e.g. 5 is selected then only residues with a distance of
5 Angstrom and less are returned. Using a small value can reduce the size of the contact map
drastically and is therefore recommended. The default value is 10.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_pdb_model_number_selection">pdb_model_number_selection</code></td>
<td>
<p>a numeric vector specifying which models from the structure
files should be considered for contact maps. E.g. NMR models often have many models in one file.
The default for this argument is c(0, 1). This means the first model of each structure file is
selected for contact map calculations. For AlphaFold predictions the model number is 0
(only .pdb files), therefore this case is also included here.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_return_min_residue_distance">return_min_residue_distance</code></td>
<td>
<p>a logical value that specifies if the contact map should be
returned for all atom distances or the minimum residue distances. Minimum residue distances are
smaller in size. If atom distances are not strictly needed it is recommended to set this
argument to TRUE. The default is TRUE.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value that specifies if a progress bar will be shown (default
is TRUE).</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_export">export</code></td>
<td>
<p>a logical value that indicates if contact maps should be exported as &quot;.csv&quot;. The
name of the file will be the structure ID. Default is <code>export = FALSE</code>.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_export_location">export_location</code></td>
<td>
<p>optional, a character value that specifies the path to the location in
which the contact map should be saved if <code>export = TRUE</code>. If left empty, they will be
saved in the current working directory. The location should be provided in the following format
&quot;folderA/folderB&quot;.</p>
</td></tr>
<tr><td><code id="create_structure_contact_map_+3A_structure_file">structure_file</code></td>
<td>
<p>optional, a character value that specifies the path to the location and
name of a structure file in &quot;.cif&quot; or &quot;.pdb&quot; format for which a contact map should be created.
All other arguments can be provided as usual with the exception of the <code>id</code> column in the
<code>data</code> data frame, which should not contain a PDB or UniProt ID but a character vector
containing only &quot;my_structure&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of contact maps for each PDB or UniProt ID provided in the input is returned.
If the <code>export</code> argument is TRUE, each contact map will be saved as a &quot;.csv&quot; file in the
current working directory or the location provided to the <code>export_location</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create example data
data &lt;- data.frame(
  pdb_id = c("6NPF", "1C14", "3NIR"),
  chain = c("A", "A", NA),
  auth_seq_id = c("1;2;3;4;5;6;7", NA, NA)
)

# Create contact map
contact_maps &lt;- create_structure_contact_map(
  data = data,
  id = pdb_id,
  chain = chain,
  auth_seq_id = auth_seq_id,
  return_min_residue_distance = TRUE
)

str(contact_maps[["3NIR"]])

contact_maps

</code></pre>

<hr>
<h2 id='create_synthetic_data'>Creates a synthetic limited proteolysis proteomics dataset</h2><span id='topic+create_synthetic_data'></span>

<h3>Description</h3>

<p>This function creates a synthetic limited proteolysis proteomics dataset that can be used to
test functions while knowing the ground truth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_synthetic_data(
  n_proteins,
  frac_change,
  n_replicates,
  n_conditions,
  method = "effect_random",
  concentrations = NULL,
  median_offset_sd = 0.05,
  mean_protein_intensity = 16.88,
  sd_protein_intensity = 1.4,
  mean_n_peptides = 12.75,
  size_n_peptides = 0.9,
  mean_sd_peptides = 1.7,
  sd_sd_peptides = 0.75,
  mean_log_replicates = -2.2,
  sd_log_replicates = 1.05,
  effect_sd = 2,
  dropout_curve_inflection = 14,
  dropout_curve_sd = -1.2,
  additional_metadata = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_synthetic_data_+3A_n_proteins">n_proteins</code></td>
<td>
<p>a numeric value that specifies the number of proteins in the synthetic dataset.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_frac_change">frac_change</code></td>
<td>
<p>a numeric value that specifies the fraction of proteins that has a peptide
changing in abundance. So far only one peptide per protein is changing.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_n_replicates">n_replicates</code></td>
<td>
<p>a numeric value that specifies the number of replicates per condition.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_n_conditions">n_conditions</code></td>
<td>
<p>a numeric value that specifies the number of conditions.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_method">method</code></td>
<td>
<p>a character value that specifies the method type for the random sampling of
significantly changing peptides. If <code>method = "effect_random"</code>, the effect for each
condition is randomly sampled and conditions do not depend on each other. If
<code>method = "dose_response"</code>, the effect is sampled based on a dose response curve and
conditions are related to each other depending on the curve shape. In this case the
concentrations argument needs to be specified.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_concentrations">concentrations</code></td>
<td>
<p>a numeric vector of length equal to the number of conditions, only needs
to be specified if <code>method = "dose_response"</code>. This allows equal sampling of peptide
intensities. It ensures that the same positions of dose response curves are sampled for each
peptide based on the provided concentrations.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_median_offset_sd">median_offset_sd</code></td>
<td>
<p>a numeric value that specifies the standard deviation of normal
distribution that is used for sampling of inter-sample-differences. Default is 0.05.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_mean_protein_intensity">mean_protein_intensity</code></td>
<td>
<p>a numeric value that specifies the mean of the protein intensity
distribution. Default: 16.8.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_sd_protein_intensity">sd_protein_intensity</code></td>
<td>
<p>a numeric value that specifies the standard deviation of the
protein intensity distribution. Default: 1.4.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_mean_n_peptides">mean_n_peptides</code></td>
<td>
<p>a numeric value that specifies the mean number of peptides per protein.
Default: 12.75.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_size_n_peptides">size_n_peptides</code></td>
<td>
<p>a numeric value that specifies the dispersion parameter (the shape
parameter of the gamma mixing distribution). Can be theoretically calculated as
<code>mean + mean^2/variance</code>, however, it should be rather obtained by fitting the negative
binomial distribution to real data. This can be done by using the <code>optim</code> function (see
Example section). Default: 0.9.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_mean_sd_peptides">mean_sd_peptides</code></td>
<td>
<p>a numeric value that specifies the mean of peptide intensity standard
deviations within a protein. Default: 1.7.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_sd_sd_peptides">sd_sd_peptides</code></td>
<td>
<p>a numeric value that specifies the standard deviation of peptide intensity
standard deviation within a protein. Default: 0.75.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_mean_log_replicates">mean_log_replicates</code>, <code id="create_synthetic_data_+3A_sd_log_replicates">sd_log_replicates</code></td>
<td>
<p>a numeric value that specifies the <code>meanlog</code>
and <code>sdlog</code> of the log normal distribution of replicate standard deviations. Can be
obtained by fitting a log normal distribution to the distribution of replicate standard
deviations from a real dataset. This can be done using the <code>optim</code> function (see Example
section). Default: -2.2 and 1.05.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_effect_sd">effect_sd</code></td>
<td>
<p>a numeric value that specifies the standard deviation of a normal distribution
around <code>mean = 0</code> that is used to sample the effect of significantly changeing peptides.
Default: 2.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_dropout_curve_inflection">dropout_curve_inflection</code></td>
<td>
<p>a numeric value that specifies the intensity inflection point
of a probabilistic dropout curve that is used to sample intensity dependent missing values.
This argument determines how many missing values there are in the dataset. Default: 14.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_dropout_curve_sd">dropout_curve_sd</code></td>
<td>
<p>a numeric value that specifies the standard deviation of the
probabilistic dropout curve. Needs to be negative to sample a droupout towards low intensities.
Default: -1.2.</p>
</td></tr>
<tr><td><code id="create_synthetic_data_+3A_additional_metadata">additional_metadata</code></td>
<td>
<p>a logical value that determines if metadata such as protein
coverage, missed cleavages and charge state should be sampled and added to the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains complete peptide intensities and peptide intensities with
values that were created based on a probabilistic dropout curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_synthetic_data(
  n_proteins = 10,
  frac_change = 0.1,
  n_replicates = 3,
  n_conditions = 2
)

# determination of mean_n_peptides and size_n_peptides parameters based on real data (count)
# example peptide count per protein
count &lt;- c(6, 3, 2, 0, 1, 0, 1, 2, 2, 0)
theta &lt;- c(mu = 1, k = 1)
negbinom &lt;- function(theta) {
  -sum(stats::dnbinom(count, mu = theta[1], size = theta[2], log = TRUE))
}
fit &lt;- stats::optim(theta, negbinom)
fit

# determination of mean_log_replicates and sd_log_replicates parameters
# based on real data (standard_deviations)

# example standard deviations of replicates
standard_deviations &lt;- c(0.61, 0.54, 0.2, 1.2, 0.8, 0.3, 0.2, 0.6)
theta2 &lt;- c(meanlog = 1, sdlog = 1)
lognorm &lt;- function(theta2) {
  -sum(stats::dlnorm(standard_deviations, meanlog = theta2[1], sdlog = theta2[2], log = TRUE))
}
fit2 &lt;- stats::optim(theta2, lognorm)
fit2
</code></pre>

<hr>
<h2 id='diff_abundance'>Calculate differential abundance between conditions</h2><span id='topic+diff_abundance'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>calculate_diff_abundance()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_abundance(...)
</code></pre>


<h3>Value</h3>

<p>A data frame that contains differential abundances (<code>diff</code>), p-values (<code>pval</code>)
and adjusted p-values (<code>adj_pval</code>) for each protein, peptide or precursor (depending on
the <code>grouping</code> variable) and the associated treatment/reference pair. Depending on the
method the data frame contains additional columns:
</p>

<ul>
<li><p> &quot;t-test&quot;: The <code>std_error</code> column contains the standard error of the differential
abundances. <code>n_obs</code> contains the number of observations for the specific protein, peptide
or precursor (depending on the <code>grouping</code> variable) and the associated treatment/reference pair.
</p>
</li>
<li><p> &quot;t-test_mean_sd&quot;: Columns labeled as control refer to the second condition of the
comparison pairs. Treated refers to the first condition. <code>mean_control</code> and <code>mean_treated</code>
columns contain the means for the reference and treatment condition, respectively. <code>sd_control</code>
and <code>sd_treated</code> columns contain the standard deviations for the reference and treatment
condition, respectively. <code>n_control</code> and <code>n_treated</code> columns contain the numbers of
samples for the reference and treatment condition, respectively. The <code>std_error</code> column
contains the standard error of the differential abundances. <code>t_statistic</code> contains the
t_statistic for the t-test.
</p>
</li>
<li><p> &quot;moderated_t-test&quot;: <code>CI_2.5</code> and <code>CI_97.5</code> contain the 2.5% and 97.5%
confidence interval borders for differential abundances. <code>avg_abundance</code> contains average
abundances for treatment/reference pairs (mean of the two group means). <code>t_statistic</code>
contains the t_statistic for the t-test. <code>B</code> The B-statistic is the log-odds that the
protein, peptide or precursor (depending on <code>grouping</code>) has a differential abundance
between the two groups. Suppose B=1.5. The odds of differential abundance is exp(1.5)=4.48, i.e,
about four and a half to one. The probability that there is a differential abundance is
4.48/(1+4.48)=0.82, i.e., the probability is about 82% that this group is differentially
abundant. A B-statistic of zero corresponds to a 50-50 chance that the group is differentially
abundant.<code>n_obs</code> contains the number of observations for the specific protein, peptide or
precursor (depending on the <code>grouping</code> variable) and the associated treatment/reference pair.
</p>
</li>
<li><p> &quot;proDA&quot;: The <code>std_error</code> column contains the standard error of the differential
abundances. <code>avg_abundance</code> contains average abundances for treatment/reference pairs
(mean of the two group means). <code>t_statistic</code> contains the t_statistic for the t-test.
<code>n_obs</code> contains the number of observations for the specific protein, peptide or precursor
(depending on the <code>grouping</code> variable) and the associated treatment/reference pair.
</p>
</li></ul>


<hr>
<h2 id='drc_4p'>Dose response curve helper function</h2><span id='topic+drc_4p'></span>

<h3>Description</h3>

<p>This function peforms the four-parameter dose response curve fit. It is the helper function
for the fit in the <code>fit_drc_4p</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drc_4p(data, response, dose, log_logarithmic = TRUE, pb = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drc_4p_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the dose and response column the model should
be fitted to.</p>
</td></tr>
<tr><td><code id="drc_4p_+3A_response">response</code></td>
<td>
<p>a numeric column that contains the response values.</p>
</td></tr>
<tr><td><code id="drc_4p_+3A_dose">dose</code></td>
<td>
<p>a numeric column that contains the dose values.</p>
</td></tr>
<tr><td><code id="drc_4p_+3A_log_logarithmic">log_logarithmic</code></td>
<td>
<p>a logical value indicating if a logarithmic or log-logarithmic model is
fitted. If response values form a symmetric curve for non-log transformed dose values, a
logarithmic model instead of a log-logarithmic model should be used. Usually biological dose
response data has a log-logarithmic distribution, which is the reason this is the default.
Log-logarithmic models are symmetric if dose values are log transformed.</p>
</td></tr>
<tr><td><code id="drc_4p_+3A_pb">pb</code></td>
<td>
<p>progress bar object. This is only necessary if the function is used in an iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>drc</code>. If no fit was performed a character vector with content
&quot;no_fit&quot;.
</p>

<hr>
<h2 id='drc_4p_plot'>Plotting of four-parameter dose response curves</h2><span id='topic+drc_4p_plot'></span>

<h3>Description</h3>

<p>Function for plotting four-parameter dose response curves for each group (precursor, peptide or
protein), based on output from <code>fit_drc_4p</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drc_4p_plot(
  data,
  grouping,
  response,
  dose,
  targets,
  unit = "uM",
  y_axis_name = "Response",
  facet_title_size = 15,
  facet = TRUE,
  scales = "free",
  x_axis_scale_log10 = TRUE,
  x_axis_limits = c(NA, NA),
  colours = NULL,
  export = FALSE,
  export_height = 25,
  export_width = 30,
  export_name = "dose-response_curves"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drc_4p_plot_+3A_data">data</code></td>
<td>
<p>a data frame that is obtained by calling the <code>fit_drc_4p</code> function.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the precursor,
peptide or protein identifiers.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_response">response</code></td>
<td>
<p>a numeric column in a nested data frame called <code>plot_points</code> that is part
of the <code>data</code> data frame. This column contains the response values, e.g. log2 transformed
intensities.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_dose">dose</code></td>
<td>
<p>a numeric column in a nested data frame called <code>plot_points</code> that is part
of the <code>data</code> data frame. This column contains the dose values, e.g. the treatment
concentrations.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_targets">targets</code></td>
<td>
<p>a character vector that specifies the names of the precursors, peptides or
proteins (depending on <code>grouping</code>) that should be plotted. This can also be <code>"all"</code>
if plots for all curve fits should be created.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_unit">unit</code></td>
<td>
<p>a character value specifying the unit of the concentration.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_y_axis_name">y_axis_name</code></td>
<td>
<p>a character value specifying the name of the y-axis of the plot.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_facet_title_size">facet_title_size</code></td>
<td>
<p>a numeric value that specifies the size of the facet title. Default is 15.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_facet">facet</code></td>
<td>
<p>a logical value that indicates if plots should be summarised into facets of 20
plots. This is recommended for many plots.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_scales">scales</code></td>
<td>
<p>a character value that specifies if the scales in faceted plots (if more than one
target was provided) should be <code>"free"</code> or <code>"fixed"</code>.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_x_axis_scale_log10">x_axis_scale_log10</code></td>
<td>
<p>a logical value that indicates if the x-axis scale should be log10
transformed.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_x_axis_limits">x_axis_limits</code></td>
<td>
<p>a numeric vector of length 2, defining the lower and upper x-axis limit. The
default is <code>c(NA, NA)</code>, meaning the limits are not defined by the user but by the data.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_colours">colours</code></td>
<td>
<p>a character vector containing at least three colours. The first is used for the points,
the second for the confidence interval and the third for the curve. By default the first two
protti colours are used for the points and confidence interval and the curve is black.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_export">export</code></td>
<td>
<p>a logical value that indicates if plots should be exported as PDF. The output
directory will be the current working directory. The name of the file can be chosen using the
<code>export_name</code> argument. If only one target is selected and <code>export = TRUE</code>,
the plot is exported and in addition returned in R.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_export_height">export_height</code></td>
<td>
<p>a numeric value that specifies the plot height in inches for an exported plot.
The default is <code>25</code>. For a non-facet plot we recommend using 8.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_export_width">export_width</code></td>
<td>
<p>a numeric value that specifies the plot height in inches for an exported plot.
The default is <code>30</code>. For a non-facet plot we recommend using 12.</p>
</td></tr>
<tr><td><code id="drc_4p_plot_+3A_export_name">export_name</code></td>
<td>
<p>a character value providing the name of the exported file if
<code>export = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>targets = "all"</code> a list containing plots for every unique identifier in the
<code>grouping</code> variable is created. Otherwise a plot for the specified targets is created with
maximally 20 facets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 2,
  frac_change = 1,
  n_replicates = 3,
  n_conditions = 8,
  method = "dose_response",
  concentrations = c(0, 1, 10, 50, 100, 500, 1000, 5000),
  additional_metadata = FALSE
)

# Perform dose response curve fit
drc_fit &lt;- fit_drc_4p(
  data = data,
  sample = sample,
  grouping = peptide,
  response = peptide_intensity_missing,
  dose = concentration,
  retain_columns = c(protein)
)

str(drc_fit)

# Plot dose response curves
if (!is.null(drc_fit)) {
  drc_4p_plot(
    data = drc_fit,
    grouping = peptide,
    response = peptide_intensity_missing,
    dose = concentration,
    targets = c("peptide_2_1", "peptide_2_3"),
    unit = "pM"
  )
}

</code></pre>

<hr>
<h2 id='extract_metal_binders'>Extract metal-binding protein information from UniProt</h2><span id='topic+extract_metal_binders'></span>

<h3>Description</h3>

<p>Information of metal binding proteins is extracted from UniProt data retrieved with
<code>fetch_uniprot</code> as well as QuickGO data retrieved with <code>fetch_quickgo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_metal_binders(
  data_uniprot,
  data_quickgo,
  data_chebi = NULL,
  data_chebi_relation = NULL,
  data_eco = NULL,
  data_eco_relation = NULL,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_metal_binders_+3A_data_uniprot">data_uniprot</code></td>
<td>
<p>a data frame containing at least the <code>ft_binding</code>, <code>cc_cofactor</code>
and <code>cc_catalytic_activity</code> columns.</p>
</td></tr>
<tr><td><code id="extract_metal_binders_+3A_data_quickgo">data_quickgo</code></td>
<td>
<p>a data frame containing molecular function gene ontology information for at
least the proteins of interest. This data should be obtained by calling <code>fetch_quickgo()</code>.</p>
</td></tr>
<tr><td><code id="extract_metal_binders_+3A_data_chebi">data_chebi</code></td>
<td>
<p>optional, a data frame that can be manually obtained with <code>fetch_chebi(stars = c(2, 3))</code>.
It should contain 2 and 3 star entries. If not provided it will be fetched within the function. If the
function is run many times it is recommended to provide the data frame to save time.</p>
</td></tr>
<tr><td><code id="extract_metal_binders_+3A_data_chebi_relation">data_chebi_relation</code></td>
<td>
<p>optional, a data frame that can be manually obtained with
<code>fetch_chebi(relation = TRUE)</code>. If not provided it will be fetched within the function.
If the function is run many times it is recommended to provide the data frame to save time.</p>
</td></tr>
<tr><td><code id="extract_metal_binders_+3A_data_eco">data_eco</code></td>
<td>
<p>optional, a data frame that contains evidence and conclusion ontology data that can be
obtained by calling <code>fetch_eco()</code>. If not provided it will be fetched within the function.
If the function is run many times it is recommended to provide the data frame to save time.</p>
</td></tr>
<tr><td><code id="extract_metal_binders_+3A_data_eco_relation">data_eco_relation</code></td>
<td>
<p>optional, a data frame that contains relational evidence and conclusion
ontology data that can be obtained by calling <code>fetch_eco(return_relation = TRUE)</code>. If not provided it
will be fetched within the function. If the function is run many times it is recommended to provide
the data frame to save time.</p>
</td></tr>
<tr><td><code id="extract_metal_binders_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value that specifies if progress will be shown (default is TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing information on protein metal binding state. It contains the
following columns:
</p>

<ul>
<li> <p><code>accession</code>: UniProt protein identifier.
</p>
</li>
<li> <p><code>most_specific_id</code>: ChEBI ID that is most specific for the position after combining information from all sources.
Can be multiple IDs separated by &quot;,&quot; if a position appears multiple times due to multiple fitting IDs.
</p>
</li>
<li> <p><code>most_specific_id_name</code>: The name of the ID in the <code>most_specific_id</code> column. This information is based on
ChEBI.
</p>
</li>
<li> <p><code>ligand_identifier</code>: A ligand identifier that is unique per ligand per protein. It consists of the ligand ID and
ligand name. The ligand ID counts the number of ligands of the same type per protein.
</p>
</li>
<li> <p><code>ligand_position</code>: The amino acid position of the residue interacting with the ligand.
</p>
</li>
<li> <p><code>binding_mode</code>: Contains information about the way the amino acid residue interacts with the ligand. If it is
&quot;covalent&quot; then the residue is not in contact with the metal directly but only the cofactor that binds the metal.
</p>
</li>
<li> <p><code>metal_function</code>: Contains information about the function of the metal. E.g. &quot;catalytic&quot;.
</p>
</li>
<li> <p><code>metal_id_part</code>: Contains a ChEBI ID that identifiers the metal part of the ligand. This is always the metal atom.
</p>
</li>
<li> <p><code>metal_id_part_name</code>: The name of the ID in the <code>metal_id_part</code> column. This information is based on
ChEBI.
</p>
</li>
<li> <p><code>note</code>: Contains notes associated with information based on cofactors.
</p>
</li>
<li> <p><code>chebi_id</code>: Contains the original ChEBI IDs the information is based on.
</p>
</li>
<li> <p><code>source</code>: Contains the sources of the information. This can consist of &quot;binding&quot;, &quot;cofactor&quot;, &quot;catalytic_activity&quot;
and &quot;go_term&quot;.
</p>
</li>
<li> <p><code>eco</code>: If there is evidence the annotation is based on it is annotated with an ECO ID, which is split by source.
</p>
</li>
<li> <p><code>eco_type</code>: The ECO identifier can fall into the &quot;manual_assertion&quot; group for manually curated annotations or the
&quot;automatic_assertion&quot; group for automatically generated annotations. If there is no evidence it is annotated as
&quot;automatic_assertion&quot;. The information is split by source.
</p>
</li>
<li> <p><code>evidence_source</code>: The original sources (e.g. literature, PDB) of evidence annotations split by source.
</p>
</li>
<li> <p><code>reaction</code>: Contains information about the chemical reaction catalysed by the protein that involves the metal.
Can contain the EC ID, Rhea ID, direction specific Rhea ID, direction of the reaction and evidence for the direction.
</p>
</li>
<li> <p><code>go_term</code>: Contains gene ontology terms if there are any metal related ones associated with the annotation.
</p>
</li>
<li> <p><code>go_name</code>: Contains gene ontology names if there are any metal related ones associated with the annotation.
</p>
</li>
<li> <p><code>assigned_by</code>: Contains information about the source of the gene ontology term assignment.
</p>
</li>
<li> <p><code>database</code>: Contains information about the source of the ChEBI annotation associated with gene ontology terms.
</p>
</li></ul>

<p>For each protein identifier the data frame contains information on the bound ligand as well as on its position if it is known.
Since information about metal ligands can come from multiple sources, additional information (e.g. evidence) is nested in the returned
data frame. In order to unnest the relevant information the following steps have to be taken: It is
possible that there are multiple IDs in the &quot;most_specific_id&quot; column. This means that one position cannot be uniquely
attributed to one specific ligand even with the same ligand_identifier. Apart from the &quot;most_specific_id&quot; column, in
which those instances are separated by &quot;,&quot;, in other columns the relevant information is separated by &quot;||&quot;. Then
information should be split based on the source (not the <code>source</code> column, that one can be removed from the data
frame). There are certain columns associated with specific sources (e.g. <code>go_term</code> is associated
with the <code>"go_term"</code> source). Values of columns not relevant for a certain source should be replaced with <code>NA</code>.
Since a <code>most_specific_id</code> can have multiple <code>chebi_id</code>s associated with it we need to unnest the <code>chebi_id</code>
column and associated columns in which information is separated by &quot;|&quot;. Afterwards evidence and additional information can be
unnested by first splitting data for &quot;;;&quot; and then for &quot;;&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create example data

uniprot_ids &lt;- c("P00393", "P06129", "A0A0C5Q309", "A0A0C9VD04")

## UniProt data
data_uniprot &lt;- fetch_uniprot(
  uniprot_ids = uniprot_ids,
  columns = c(
    "ft_binding",
    "cc_cofactor",
    "cc_catalytic_activity"
  )
)

## QuickGO data
data_quickgo &lt;- fetch_quickgo(
  id_annotations = uniprot_ids,
  ontology_annotations = "molecular_function"
)

## ChEBI data (2 and 3 star entries)
data_chebi &lt;- fetch_chebi(stars = c(2, 3))
data_chebi_relation &lt;- fetch_chebi(relation = TRUE)

## ECO data
eco &lt;- fetch_eco()
eco_relation &lt;- fetch_eco(return_relation = TRUE)

# Extract metal binding information
metal_info &lt;- extract_metal_binders(
  data_uniprot = data_uniprot,
  data_quickgo = data_quickgo,
  data_chebi = data_chebi,
  data_chebi_relation = data_chebi_relation,
  data_eco = eco,
  data_eco_relation = eco_relation
)

metal_info

</code></pre>

<hr>
<h2 id='fetch_alphafold_aligned_error'>Fetch AlphaFold aligned error</h2><span id='topic+fetch_alphafold_aligned_error'></span>

<h3>Description</h3>

<p>Fetches the aligned error for AlphaFold predictions for provided proteins.
The aligned error is useful for assessing inter-domain accuracy. In detail it
represents the expected position error at residue x (scored residue), when
the predicted and true structures are aligned on residue y (aligned residue).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_alphafold_aligned_error(
  uniprot_ids = NULL,
  error_cutoff = 20,
  timeout = 30,
  max_tries = 1,
  return_data_frame = FALSE,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_alphafold_aligned_error_+3A_uniprot_ids">uniprot_ids</code></td>
<td>
<p>a character vector of UniProt identifiers for which predictions
should be fetched.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_aligned_error_+3A_error_cutoff">error_cutoff</code></td>
<td>
<p>a numeric value specifying the maximum position error (in Angstroms) that should be retained.
setting this value to a low number reduces the size of the retrieved data. Default is 20.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_aligned_error_+3A_timeout">timeout</code></td>
<td>
<p>a numeric value specifying the time in seconds until the download times out.
The default is 30 seconds.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_aligned_error_+3A_max_tries">max_tries</code></td>
<td>
<p>a numeric value that specifies the number of times the function tries to download
the data in case an error occurs. The default is 1.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_aligned_error_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>a logical value; if <code>TRUE</code> a data frame instead of a list
is returned. It is recommended to only use this if information for few proteins is retrieved.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_aligned_error_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value; if <code>TRUE</code> a progress bar will be shown.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains aligned errors for AlphaFold predictions. If return_data_frame is
TRUE, a data frame with this information is returned instead. The data frame contains the
following columns:
</p>

<ul>
<li><p> scored_residue: The error for this position is calculated based on the alignment to the
aligned residue.
</p>
</li>
<li><p> aligned_residue: The residue that is aligned for the calculation of the error of the scored
residue
</p>
</li>
<li><p> error: The predicted aligned error computed by alpha fold.
</p>
</li>
<li><p> accession: The UniProt protein identifier.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
aligned_error &lt;- fetch_alphafold_aligned_error(
  uniprot_ids = c("F4HVG8", "O15552"),
  error_cutoff = 5,
  return_data_frame = TRUE
)

head(aligned_error, n = 10)

</code></pre>

<hr>
<h2 id='fetch_alphafold_prediction'>Fetch AlphaFold prediction</h2><span id='topic+fetch_alphafold_prediction'></span>

<h3>Description</h3>

<p>Fetches atom level data for AlphaFold predictions either for selected proteins or whole
organisms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_alphafold_prediction(
  uniprot_ids = NULL,
  organism_name = NULL,
  version = "v4",
  timeout = 3600,
  max_tries = 5,
  return_data_frame = FALSE,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_alphafold_prediction_+3A_uniprot_ids">uniprot_ids</code></td>
<td>
<p>optional, a character vector of UniProt identifiers for which predictions
should be fetched. This argument is mutually exclusive to the <code>organism_name</code> argument.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_prediction_+3A_organism_name">organism_name</code></td>
<td>
<p>optional, a character value providing the name of an organism for which
all available AlphaFold predictions should be retreived. The name should be the capitalised
scientific species name (e.g. &quot;Homo sapiens&quot;). <strong>Note:</strong> Some organisms contain a lot of
predictions which might take a considerable amount of time and memory to fetch. Therefore, you
should be sure that your system can handle fetching predictions for these organisms. This
argument is mutually exclusive to the <code>uniprot_ids</code> argument.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_prediction_+3A_version">version</code></td>
<td>
<p>a character value that specifies the alphafold version that should be used. This
is regularly updated by the database. We always try to make the current version the default version.
Available version can be found here: https://ftp.ebi.ac.uk/pub/databases/alphafold/</p>
</td></tr>
<tr><td><code id="fetch_alphafold_prediction_+3A_timeout">timeout</code></td>
<td>
<p>a numeric value specifying the time in seconds until the download of an organism
archive times out. The default is 3600 seconds.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_prediction_+3A_max_tries">max_tries</code></td>
<td>
<p>a numeric value that specifies the number of times the function tries to download
the data in case an error occurs. The default is 5. This only applies if <code>uniprot_ids</code> were provided.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_prediction_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>a logical value that specifies if true, a data frame instead of a list
is returned. It is recommended to only use this if information for few proteins is retrieved.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="fetch_alphafold_prediction_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value that specifies if true, a progress bar will be shown.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains atom level data for AlphaFold predictions. If return_data_frame is
TRUE, a data frame with this information is returned instead. The data frame contains the
following columns:
</p>

<ul>
<li><p> label_id: Uniquely identifies every atom in the prediction following the standardised
convention for mmCIF files.
</p>
</li>
<li><p> type_symbol: The code used to identify the atom species representing this atom type.
This code is the element symbol.
</p>
</li>
<li><p> label_atom_id: Uniquely identifies every atom for the given residue following the
standardised convention for mmCIF files.
</p>
</li>
<li><p> label_comp_id: A chemical identifier for the residue. This is the three- letter code
for the amino acid.
</p>
</li>
<li><p> label_asym_id: Chain identifier following the standardised convention for mmCIF files.
Since every prediction only contains one protein this is always &quot;A&quot;.
</p>
</li>
<li><p> label_seq_id: Uniquely and sequentially identifies residues for each protein. The
numbering corresponds to the UniProt amino acid positions.
</p>
</li>
<li><p> x: The x coordinate of the atom.
</p>
</li>
<li><p> y: The y coordinate of the atom.
</p>
</li>
<li><p> z: The z coordinate of the atom.
</p>
</li>
<li><p> prediction_score: Contains the prediction score for each residue.
</p>
</li>
<li><p> auth_seq_id: Same as <code>label_seq_id</code>. But of type character.
</p>
</li>
<li><p> auth_comp_id: Same as <code>label_comp_id</code>.
</p>
</li>
<li><p> auth_asym_id: Same as <code>label_asym_id</code>.
</p>
</li>
<li><p> uniprot_id: The UniProt identifier of the predicted protein.
</p>
</li>
<li><p> score_quality: Score annotations.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
alphafold &lt;- fetch_alphafold_prediction(
  uniprot_ids = c("F4HVG8", "O15552"),
  return_data_frame = TRUE
)

head(alphafold, n = 10)

</code></pre>

<hr>
<h2 id='fetch_chebi'>Fetch ChEBI database information</h2><span id='topic+fetch_chebi'></span>

<h3>Description</h3>

<p>Fetches information from the ChEBI database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_chebi(relation = FALSE, stars = c(3), timeout = 60)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_chebi_+3A_relation">relation</code></td>
<td>
<p>a logical value that indicates if ChEBI Ontology data will be returned instead
the main compound data. This data can be used to check the relations of ChEBI ID's to each other.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="fetch_chebi_+3A_stars">stars</code></td>
<td>
<p>a numeric vector indicating the &quot;star&quot; level (confidence) for which entries should
be retrieved (Possible levels are 1, 2 and 3). Default is <code>c(3)</code> retrieving only &quot;3-star&quot;
entries, which are manually annotated by the ChEBI curator team.</p>
</td></tr>
<tr><td><code id="fetch_chebi_+3A_timeout">timeout</code></td>
<td>
<p>a numeric value specifying the time in seconds until the download of an organism
archive times out. The default is 60 seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains information about each molecule in the ChEBI database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chebi &lt;- fetch_chebi()

head(chebi)

</code></pre>

<hr>
<h2 id='fetch_eco'>Fetch evidence &amp; conclusion ontology</h2><span id='topic+fetch_eco'></span>

<h3>Description</h3>

<p>Fetches all evidence &amp; conclusion ontology (ECO) information from the QuickGO EBI database. The ECO project is
maintained through a public <a href="https://github.com/evidenceontology/evidenceontology">GitHub repository</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_eco(
  return_relation = FALSE,
  return_history = FALSE,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_eco_+3A_return_relation">return_relation</code></td>
<td>
<p>a logical value that indicates if relational information should be returned instead
the main descriptive information. This data can be used to check the relations of ECO terms to each other.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="fetch_eco_+3A_return_history">return_history</code></td>
<td>
<p>a logical value that indicates if the entry history of an ECO term should be
returned instead the main descriptive information.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="fetch_eco_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value that indicates if a progress bar will be shown.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to the GitHub repository ECO is defined as follows:
</p>
<p>&quot;The Evidence &amp; Conclusion Ontology (ECO) describes types of scientific evidence within the
biological research domain that arise from laboratory experiments, computational methods,
literature curation, or other means. Researchers use evidence to support conclusions
that arise out of scientific research. Documenting evidence during scientific research
is essential, because evidence gives us a sense of why we believe what we think we know.
Conclusions are asserted as statements about things that are believed to be true, for
example that a protein has a particular function (i.e. a protein functional annotation) or
that a disease is associated with a particular gene variant (i.e. a phenotype-gene association).
A systematic and structured (i.e. ontological) classification of evidence allows us to store,
retreive, share, and compare data associated with that evidence using computers, which are
essential to navigating the ever-growing (in size and complexity) corpus of scientific
information.&quot;
</p>
<p>More information can be found in their publication (<a href="https://doi.org/10.1093/nar/gky1036">doi:10.1093/nar/gky1036</a>).
</p>


<h3>Value</h3>

<p>A data frame that contains descriptive information about each ECO term in the EBI database.
If either <code>return_relation</code> or <code>return_history</code> is set to <code>TRUE</code>, the respective information is
returned instead of the usual output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
eco &lt;- fetch_eco()

head(eco)

</code></pre>

<hr>
<h2 id='fetch_go'>Fetch gene ontology information from geneontology.org</h2><span id='topic+fetch_go'></span>

<h3>Description</h3>

<p>Fetches gene ontology data from geneontology.org for the provided organism ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_go(organism_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_go_+3A_organism_id">organism_id</code></td>
<td>
<p>a character value NCBI taxonomy identifier of an organism (TaxId).
Possible inputs inlude only: &quot;9606&quot; (Human), &quot;559292&quot; (Yeast) and &quot;83333&quot; (E. coli).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains gene ontology mappings to UniProt or SGD IDs. The original
file is a .GAF file. A detailed description of all columns can be found here:
http://geneontology.org/docs/go-annotation-file-gaf-format-2.1/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
go &lt;- fetch_go("9606")

head(go)

</code></pre>

<hr>
<h2 id='fetch_kegg'>Fetch KEGG pathway data from KEGG</h2><span id='topic+fetch_kegg'></span>

<h3>Description</h3>

<p>Fetches gene IDs and corresponding pathway IDs and names for the provided organism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_kegg(species)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_kegg_+3A_species">species</code></td>
<td>
<p>a character value providing an abreviated species name. &quot;hsa&quot; for human, &quot;eco&quot;
for E. coli and &quot;sce&quot; for S. cerevisiae. Additional possible names can be found for
<a href="https://www.genome.jp/kegg-bin/show_organism?category=Eukaryotes">eukaryotes</a> and for
<a href="https://www.genome.jp/kegg-bin/show_organism?category=Prokaryotes">prokaryotes</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains gene IDs with corresponding pathway IDs and names for a
selected organism.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kegg &lt;- fetch_kegg(species = "hsa")

head(kegg)

</code></pre>

<hr>
<h2 id='fetch_metal_pdb'>Fetch structural information about protein-metal binding from MetalPDB</h2><span id='topic+fetch_metal_pdb'></span>

<h3>Description</h3>

<p>Fetches information about protein-metal binding sites from the
MetalPDB database. A complete list of different possible search
queries can be found on their website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_metal_pdb(
  id_type = "uniprot",
  id_value,
  site_type = NULL,
  pfam = NULL,
  cath = NULL,
  scop = NULL,
  representative = NULL,
  metal = NULL,
  ligands = NULL,
  geometry = NULL,
  coordination = NULL,
  donors = NULL,
  columns = NULL,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_metal_pdb_+3A_id_type">id_type</code></td>
<td>
<p>a character value that specifies the type of the IDs provided to <code>id_value</code>.
Default is &quot;uniprot&quot;. Possible options include: &quot;uniprot&quot;, &quot;pdb&quot;, &quot;ec_number&quot;, &quot;molecule&quot; and
&quot;organism&quot;.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_id_value">id_value</code></td>
<td>
<p>a character vector supplying IDs that are of the ID type that was specified in
<code>id_type</code>. E.g. UniProt IDs. Information for these IDs will be retreived.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_site_type">site_type</code></td>
<td>
<p>optional, a character value that specifies a nuclearity for which information
should be retrieved. The specific nuclearity can be supplied as e.g. &quot;tetranuclear&quot;.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_pfam">pfam</code></td>
<td>
<p>optional, a character value that specifies a Pfam domain for which information
should be retrieved. The domain can be specified as e.g. &quot;Carb_anhydrase&quot;.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_cath">cath</code></td>
<td>
<p>optional, a character value that specifies a CATH ID for which information
should be retrieved. The ID can be specified as e.g. &quot;3.10.200.10&quot;.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_scop">scop</code></td>
<td>
<p>optional, a character value that specifies a SCOP ID for which information
should be retrieved. The ID can be specified as e.g. &quot;b.74.1.1&quot;.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_representative">representative</code></td>
<td>
<p>optional, a logical that indicates if only information of representative
sites of a family should be retrieved it can be specified here. A representative site is a
site selected to represent a cluster of equivalent sites. The selection is done by choosing
the PDB structure with the best X-ray resolution among those containing the sites in the
cluster. NMR structures are generally discarded in favor of X-ray structures, unless all the
sites in the cluster are found in NMR structures. If it is <code>TRUE</code>, only representative
sites are retrieved, if it is <code>FALSE</code>, all sites are retrieved.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_metal">metal</code></td>
<td>
<p>optional, a character value that specifies a metal for which information
should be retrieved. The metal can be specified as e.g. &quot;Zn&quot;.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_ligands">ligands</code></td>
<td>
<p>optional, a character value that specifies a metal ligand residue for which
information should be retrieved. The ligand can be specified as e.g. &quot;His&quot;.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_geometry">geometry</code></td>
<td>
<p>optional, a character value that specifies a metal site geometry for which
information should be retrieved. The geometry can be specified here based on the three letter
code for geometries provided on their website.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_coordination">coordination</code></td>
<td>
<p>optional, a character value that specifies a coordination number for which
information should be retrieved. The number can be specified as e.g. &quot;3&quot;.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_donors">donors</code></td>
<td>
<p>optional, a character value that specifies a metal ligand atom for which
information should be retrieved. The atom can be specified as e.g. &quot;S&quot; for sulfur.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_columns">columns</code></td>
<td>
<p>optional, a character vector that specifies specific columns that should be
retrieved based on the MetalPDB website. If
nothing is supplied here, all possible columns will be retrieved.</p>
</td></tr>
<tr><td><code id="fetch_metal_pdb_+3A_show_progress">show_progress</code></td>
<td>
<p>logical, if true, a progress bar will be shown. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains information about protein-metal binding sites. The data
frame contains some columns that might not be self explanatory.
</p>

<ul>
<li><p> auth_id_metal: Unique structure atom identifier of the metal, which is provided by
the author of the structure in order to match the identification used in the publication
that describes the structure.
</p>
</li>
<li><p> auth_seq_id_metal: Residue identifier of the metal, which is provided by the author of
the structure in order to match the identification used in the publication that describes the
structure.
</p>
</li>
<li><p> pattern: Metal pattern for each metal bound by the structure.
</p>
</li>
<li><p> is_representative: A representative site is a site selected to represent a cluster of
equivalent sites. The selection is done by choosing the PDB structure with the best X-ray
resolution among those containing the sites in the cluster. NMR structures are generally
discarded in favor of X-ray structures, unless all the sites in the cluster are found in NMR
structures.
</p>
</li>
<li><p> auth_asym_id_ligand: Chain identifier of the metal-coordinating ligand residues, which
is provided by the author of the structure in order to match the identification used in the
publication that describes the structure.
</p>
</li>
<li><p> auth_seq_id_ligand: Residue identifier of the metal-coordinating ligand residues, which
is provided by the author of the structure in order to match the identification used in the
publication that describes the structure.
</p>
</li>
<li><p> auth_id_ligand: Unique structure atom identifier of the metal-coordinating ligand r
esidues, which is provided by the author of the structure in order to match the identification
used in the publication that describes the structure.
</p>
</li>
<li><p> auth_atom_id_ligand: Unique residue specific atom identifier of the metal-coordinating
ligand residues, which is provided by the author of the structure in order to match the
identification used in the publication that describes the structure.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
head(fetch_metal_pdb(id_value = c("P42345", "P00918")))

fetch_metal_pdb(id_type = "pdb", id_value = c("1g54"), metal = "Zn")


</code></pre>

<hr>
<h2 id='fetch_mobidb'>Fetch protein disorder and mobility information from MobiDB</h2><span id='topic+fetch_mobidb'></span>

<h3>Description</h3>

<p>Fetches information about disordered and flexible protein regions from MobiDB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_mobidb(
  uniprot_ids = NULL,
  organism_id = NULL,
  show_progress = TRUE,
  timeout = 60,
  max_tries = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_mobidb_+3A_uniprot_ids">uniprot_ids</code></td>
<td>
<p>optional, a character vector of UniProt identifiers for which information
should be fetched. This argument is mutually exclusive to the <code>organism_id</code> argument.</p>
</td></tr>
<tr><td><code id="fetch_mobidb_+3A_organism_id">organism_id</code></td>
<td>
<p>optional, a character value providing the NCBI taxonomy identifier of an organism
(TaxId) of an organism for which all available information should be retreived. This
argument is mutually exclusive to the <code>uniprot_ids</code> argument.</p>
</td></tr>
<tr><td><code id="fetch_mobidb_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value; if <code>TRUE</code> a progress bar will be shown.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fetch_mobidb_+3A_timeout">timeout</code></td>
<td>
<p>a numeric value specifying the time in seconds until the download of an organism
archive times out. The default is 60 seconds.</p>
</td></tr>
<tr><td><code id="fetch_mobidb_+3A_max_tries">max_tries</code></td>
<td>
<p>a numeric value that specifies the number of times the function tries to download
the data in case an error occurs. The default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains start and end positions for disordered and flexible protein
regions. The <code>feature</code> column contains information on the source of this
annotation. More information on the source can be found
<a href="https://mobidb.org/about/mobidb">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fetch_mobidb(
  uniprot_ids = c("P0A799", "P62707")
)

</code></pre>

<hr>
<h2 id='fetch_pdb'>Fetch structure information from RCSB</h2><span id='topic+fetch_pdb'></span>

<h3>Description</h3>

<p>Fetches structure metadata from RCSB. If you want to retrieve atom data such as positions, use
the function <code>fetch_pdb_structure()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_pdb(pdb_ids, batchsize = 100, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_pdb_+3A_pdb_ids">pdb_ids</code></td>
<td>
<p>a character vector of PDB identifiers.</p>
</td></tr>
<tr><td><code id="fetch_pdb_+3A_batchsize">batchsize</code></td>
<td>
<p>a numeric value that specifies the number of structures to be processed in a
single query. Default is 100.</p>
</td></tr>
<tr><td><code id="fetch_pdb_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value that indicates if a progress bar will be shown. Default is
TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains structure metadata for the PDB IDs provided. The data frame
contains some columns that might not be self explanatory.
</p>

<ul>
<li><p> auth_asym_id: Chain identifier provided by the author of the structure in order to
match the identification used in the publication that describes the structure.
</p>
</li>
<li><p> label_asym_id: Chain identifier following the standardised convention for mmCIF files.
</p>
</li>
<li><p> entity_beg_seq_id, ref_beg_seq_id, length, pdb_sequence: <code>entity_beg_seq_id</code> is a
position in the structure sequence (<code>pdb_sequence</code>) that matches the position given in
<code>ref_beg_seq_id</code>, which is a position within the protein sequence (not included in the
data frame). <code>length</code> identifies the stretch of sequence for which positions match
accordingly between structure and protein sequence. <code>entity_beg_seq_id</code> is a residue ID
based on the standardised convention for mmCIF files.
</p>
</li>
<li><p> auth_seq_id: Residue identifier provided by the author of the structure in order to
match the identification used in the publication that describes the structure. This character
vector has the same length as the <code>pdb_sequence</code> and each position is the identifier for
the matching amino acid position in <code>pdb_sequence</code>. The contained values are not
necessarily numbers and the values do not have to be positive.
</p>
</li>
<li><p> modified_monomer: Is composed of first the composition ID of the modification, followed
by the <code>label_seq_id</code> position. In parenthesis are the parent monomer identifiers as
they appear in the sequence.
</p>
</li>
<li><p> ligand_*: Any column starting with the <code>ligand_*</code> prefix contains information about
the position, identity and donors for ligand binding sites. If there are multiple entities of
ligands they are separated by &quot;|&quot;. Specific donor level information is separated by &quot;;&quot;.
</p>
</li>
<li><p> secondar_structure: Contains information about helix and sheet secondary structure elements.
Individual regions are separated by &quot;;&quot;.
</p>
</li>
<li><p> unmodeled_structure: Contains information about unmodeled or partially modeled regions in
the model. Individual regions are separated by &quot;;&quot;.
</p>
</li>
<li><p> auth_seq_id_original: In some cases the sequence positions do not match the number of residues
in the sequence either because positions are missing or duplicated. This always coincides with modified
residues, however does not always occur when there is a modified residue in the sequence. This column
contains the original <code>auth_seq_id</code> information that does not have these positions corrected.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
pdb &lt;- fetch_pdb(pdb_ids = c("6HG1", "1E9I", "6D3Q", "4JHW"))

head(pdb)

</code></pre>

<hr>
<h2 id='fetch_pdb_structure'>Fetch PDB structure atom data from RCSB</h2><span id='topic+fetch_pdb_structure'></span>

<h3>Description</h3>

<p>Fetches atom data for a PDB structure from RCSB. If you want to retrieve metadata about PDB
structures, use the function <code>fetch_pdb()</code>. The information retrieved is based on the
.cif file of the structure, which may vary from the .pdb file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_pdb_structure(pdb_ids, return_data_frame = FALSE, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_pdb_structure_+3A_pdb_ids">pdb_ids</code></td>
<td>
<p>a character vector of PDB identifiers.</p>
</td></tr>
<tr><td><code id="fetch_pdb_structure_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>a logical value that indicates if a data frame instead of a list is
returned. It is recommended to only use this if not many pdb structures are retrieved. Default
is FALSE.</p>
</td></tr>
<tr><td><code id="fetch_pdb_structure_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value that indicates if a progress bar will be shown.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains atom data for each PDB structures provided. If return_data_frame is
TRUE, a data frame with this information is returned instead. The data frame contains the
following columns:
</p>

<ul>
<li><p> label_id: Uniquely identifies every atom in the structure following the standardised
convention for mmCIF files. Example value: &quot;5&quot;, &quot;C12&quot;, &quot;Ca3g28&quot;, &quot;Fe3+17&quot;, &quot;H*251&quot;, &quot;boron2a&quot;,
&quot;C a phe 83 a 0&quot;, &quot;Zn Zn 301 A 0&quot;
</p>
</li>
<li><p> type_symbol: The code used to identify the atom species representing this atom type.
Normally this code is the element symbol. The code may be composed of any character except an
underscore with the additional proviso that digits designate an oxidation state and must be
followed by a + or - character. Example values: &quot;C&quot;, &quot;Cu2+&quot;, &quot;H(SDS)&quot;, &quot;dummy&quot;, &quot;FeNi&quot;.
</p>
</li>
<li><p> label_atom_id: Uniquely identifies every atom for the given residue following the
standardised convention for mmCIF files. Example values: &quot;CA&quot;, &quot;HB1&quot;, &quot;CB&quot;, &quot;N&quot;
</p>
</li>
<li><p> label_comp_id: A chemical identifier for the residue. For protein polymer entities,
this is the three- letter code for the amino acid. For nucleic acid polymer entities, this is
the one-letter code for the base. Example values: &quot;ala&quot;, &quot;val&quot;, &quot;A&quot;, &quot;C&quot;.
</p>
</li>
<li><p> label_asym_id: Chain identifier following the standardised convention for mmCIF files.
Example values: &quot;1&quot;, &quot;A&quot;, &quot;2B3&quot;.
</p>
</li>
<li><p> entity_id: Records details about the molecular entities that are present in the
crystallographic structure. Usually all different types of molecular entities such as polymer
entities, non-polymer entities or water molecules are numbered once for each structure. Each
type of non-polymer entity has its own number. Thus, the highest number in this column
represents the number of different molecule types in the structure.
</p>
</li>
<li><p> label_seq_id: Uniquely and sequentially identifies residues for each <code>label_asym_id</code>.
This is always a number and the sequence of numbers always progresses in increasing numerical order.
</p>
</li>
<li><p> x: The x coordinate of the atom.
</p>
</li>
<li><p> y: The y coordinate of the atom.
</p>
</li>
<li><p> z: The z coordinate of the atom.
</p>
</li>
<li><p> site_occupancy: The fraction of the atom type present at this site.
</p>
</li>
<li><p> b_iso_or_equivalent: Contains the B-factor or isotopic atomic displacement factor for
each atom.
</p>
</li>
<li><p> formal_charge: The net integer charge assigned to this atom. This is the formal charge
assignment normally found in chemical diagrams. It is currently only assigned in a small subset
of structures.
</p>
</li>
<li><p> auth_seq_id: An alternative residue identifier (<code>label_seq_id</code>) provided by the
author of the structure in order to match the identification used in the publication that
describes the structure. This does not need to be numeric and is therefore of type character.
</p>
</li>
<li><p> auth_comp_id: An alternative chemical identifier (<code>label_comp_id</code>) provided by the
author of the structure in order to match the identification used in the publication that
describes the structure.
</p>
</li>
<li><p> auth_asym_id: An alternative chain identifier (<code>label_asym_id</code>) provided by the
author of the structure in order to match the identification used in the publication that
describes the structure.
</p>
</li>
<li><p> pdb_model_number: The PDB model number.
</p>
</li>
<li><p> pdb_id: The protein database identifier for the structure.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
pdb_structure &lt;- fetch_pdb_structure(
  pdb_ids = c("6HG1", "1E9I", "6D3Q", "4JHW"),
  return_data_frame = TRUE
)

head(pdb_structure, n = 10)

</code></pre>

<hr>
<h2 id='fetch_quickgo'>Fetch information from the QuickGO API</h2><span id='topic+fetch_quickgo'></span>

<h3>Description</h3>

<p>Fetches gene ontology (GO) annotations, terms or slims from the QuickGO EBI database.
Annotations can be retrieved for specific UniProt IDs or NCBI taxonomy identifiers. When
terms are retrieved, a complete list of all GO terms is returned. For the generation of
a slim dataset you can provide GO IDs that should be considered. A slim dataset is a subset
GO dataset that considers all child terms of the supplied IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_quickgo(
  type = "annotations",
  id_annotations = NULL,
  taxon_id_annotations = NULL,
  ontology_annotations = "all",
  go_id_slims = NULL,
  relations_slims = c("is_a", "part_of", "regulates", "occurs_in"),
  timeout = 1200,
  max_tries = 2,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_quickgo_+3A_type">type</code></td>
<td>
<p>a character value that indicates if gene ontology terms, annotations or slims
should be retrieved. The possible values therefore include &quot;annotations&quot;, &quot;terms&quot; and &quot;slims&quot;.
If annotations are retrieved, the maximum number of results is 2,000,000.</p>
</td></tr>
<tr><td><code id="fetch_quickgo_+3A_id_annotations">id_annotations</code></td>
<td>
<p>an optional character vector that specifies UniProt IDs for which GO annotations
should be retrieved. This argument should only be provided if annotations are retrieved.</p>
</td></tr>
<tr><td><code id="fetch_quickgo_+3A_taxon_id_annotations">taxon_id_annotations</code></td>
<td>
<p>an optional character value that specifies the NCBI taxonomy identifier (TaxId)
for an organism for which GO annotations should be retrieved.
This argument should only be provided if annotations are retrieved.</p>
</td></tr>
<tr><td><code id="fetch_quickgo_+3A_ontology_annotations">ontology_annotations</code></td>
<td>
<p>an optional character value that specifies the ontology that should be retrieved.
This can either have the values &quot;all&quot;, &quot;molecular_function&quot;, &quot;biological_process&quot; or
&quot;cellular_component&quot;. This argument should only be provided if annotations are retrieved.</p>
</td></tr>
<tr><td><code id="fetch_quickgo_+3A_go_id_slims">go_id_slims</code></td>
<td>
<p>an optional character vector that specifies gene ontology IDs (e.g. GO:0046872) for which
a slim go set should be generated. This argument should only be provided if slims are retrieved.</p>
</td></tr>
<tr><td><code id="fetch_quickgo_+3A_relations_slims">relations_slims</code></td>
<td>
<p>an optional character vector that specifies the relations of GO IDs that should be
considered for the generation of the slim dataset. This argument should only be provided if slims are retrieved.</p>
</td></tr>
<tr><td><code id="fetch_quickgo_+3A_timeout">timeout</code></td>
<td>
<p>a numeric value specifying the time in seconds until the download times out.
The default is 1200 seconds.</p>
</td></tr>
<tr><td><code id="fetch_quickgo_+3A_max_tries">max_tries</code></td>
<td>
<p>a numeric value that specifies the number of times the function tries to download
the data in case an error occurs. The default is 2.</p>
</td></tr>
<tr><td><code id="fetch_quickgo_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value that indicates if a progress bar will be shown.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains descriptive information about gene ontology annotations, terms or slims
depending on what the input &quot;type&quot; was.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Annotations
annotations &lt;- fetch_quickgo(
  type = "annotations",
  id = c("P63328", "Q4FFP4"),
  ontology = "molecular_function"
)

head(annotations)

# Terms
terms &lt;- fetch_quickgo(type = "terms")

head(terms)

# Slims
slims &lt;- fetch_quickgo(
  type = "slims",
  go_id_slims = c("GO:0046872", "GO:0051540")
)

head(slims)

</code></pre>

<hr>
<h2 id='fetch_uniprot'>Fetch protein data from UniProt</h2><span id='topic+fetch_uniprot'></span>

<h3>Description</h3>

<p>Fetches protein metadata from UniProt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_uniprot(
  uniprot_ids,
  columns = c("protein_name", "length", "sequence", "gene_names", "xref_geneid",
    "xref_string", "go_f", "go_p", "go_c", "cc_interaction", "ft_act_site", "ft_binding",
    "cc_cofactor", "cc_catalytic_activity", "xref_pdb"),
  batchsize = 200,
  max_tries = 10,
  timeout = 20,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_uniprot_+3A_uniprot_ids">uniprot_ids</code></td>
<td>
<p>a character vector of UniProt accession numbers.</p>
</td></tr>
<tr><td><code id="fetch_uniprot_+3A_columns">columns</code></td>
<td>
<p>a character vector of metadata columns that should be imported from UniProt (all
possible columns can be found <a href="https://www.uniprot.org/help/return_fields">here</a>. For
cross-referenced database provide the database name with the prefix &quot;xref_&quot;, e.g. <code>"xref_pdb"</code>)</p>
</td></tr>
<tr><td><code id="fetch_uniprot_+3A_batchsize">batchsize</code></td>
<td>
<p>a numeric value that specifies the number of proteins processed in a single
single query. Default and max value is 200.</p>
</td></tr>
<tr><td><code id="fetch_uniprot_+3A_max_tries">max_tries</code></td>
<td>
<p>a numeric value that specifies the number of times the function tries to download
the data in case an error occurs.</p>
</td></tr>
<tr><td><code id="fetch_uniprot_+3A_timeout">timeout</code></td>
<td>
<p>a numeric value that specifies the maximum request time per try. Default is 20 seconds.</p>
</td></tr>
<tr><td><code id="fetch_uniprot_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value that determines if a progress bar will be shown. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains all protein metadata specified in <code>columns</code> for the
proteins provided. The <code>input_id</code> column contains the provided UniProt IDs. If an invalid ID
was provided that contains a valid UniProt ID, the valid portion of the ID is still fetched and
present in the <code>accession</code> column, while the <code>input_id</code> column contains the original not completely
valid ID.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fetch_uniprot(c("P36578", "O43324", "Q00796"))

# Not completely valid ID
fetch_uniprot(c("P02545", "P02545;P20700"))

</code></pre>

<hr>
<h2 id='fetch_uniprot_proteome'>Fetch proteome data from UniProt</h2><span id='topic+fetch_uniprot_proteome'></span>

<h3>Description</h3>

<p>Fetches proteome data from UniProt for the provided organism ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_uniprot_proteome(
  organism_id,
  columns = c("accession"),
  reviewed = TRUE,
  timeout = 120,
  max_tries = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_uniprot_proteome_+3A_organism_id">organism_id</code></td>
<td>
<p>a numeric value that specifies the NCBI taxonomy identifier (TaxId) for an
organism.</p>
</td></tr>
<tr><td><code id="fetch_uniprot_proteome_+3A_columns">columns</code></td>
<td>
<p>a character vector of metadata columns that should be imported from UniProt (all
possible columns can be found <a href="https://www.uniprot.org/help/return_fields">here</a>. For
cross-referenced database provide the database name with the prefix &quot;xref_&quot;, e.g. <code>"xref_pdb"</code>).
Note: Not more than one or two columns should be selected otherwise the function will not be
able to efficiently retrieve the information. If more information is needed, <code>fetch_uniprot()</code>
can be used with the IDs retrieved by this function.</p>
</td></tr>
<tr><td><code id="fetch_uniprot_proteome_+3A_reviewed">reviewed</code></td>
<td>
<p>a logical value that determines if only reviewed protein entries will be retrieved.</p>
</td></tr>
<tr><td><code id="fetch_uniprot_proteome_+3A_timeout">timeout</code></td>
<td>
<p>a numeric value specifying the time in seconds until the download times out.
The default is 60 seconds.</p>
</td></tr>
<tr><td><code id="fetch_uniprot_proteome_+3A_max_tries">max_tries</code></td>
<td>
<p>a numeric value that specifies the number of times the function tries to download
the data in case an error occurs. The default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains all protein metadata specified in <code>columns</code> for the
organism of choice.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(fetch_uniprot_proteome(9606))

</code></pre>

<hr>
<h2 id='filter_cv'>Data filtering based on coefficients of variation (CV)</h2><span id='topic+filter_cv'></span>

<h3>Description</h3>

<p>Filters the input data based on precursor, peptide or protein intensity coefficients of variation.
The function should be used to ensure that only robust measurements and quantifications are used for
data analysis. It is advised to use the function after inspection of raw values (quality control)
and median normalisation. Generally, the function calculates CVs of each peptide, precursor or
protein for each condition and removes peptides, precursors or proteins that have a CV above
the cutoff in less than the (user-defined) required number of conditions. Since the user-defined
cutoff is fixed and does not depend on the number of conditions that have detected values, the
function might bias for data completeness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_cv(
  data,
  grouping,
  condition,
  log2_intensity,
  cv_limit = 0.25,
  min_conditions,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_cv_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="filter_cv_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the grouping
variable that can be either precursors, peptides or proteins.</p>
</td></tr>
<tr><td><code id="filter_cv_+3A_condition">condition</code></td>
<td>
<p>a character or numeric column in the <code>data</code> data frame that contains
information on the sample condition.</p>
</td></tr>
<tr><td><code id="filter_cv_+3A_log2_intensity">log2_intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains log2
transformed intensities.</p>
</td></tr>
<tr><td><code id="filter_cv_+3A_cv_limit">cv_limit</code></td>
<td>
<p>optional, a numeric value that specifies the CV cutoff that will be applied.
Default is 0.25.</p>
</td></tr>
<tr><td><code id="filter_cv_+3A_min_conditions">min_conditions</code></td>
<td>
<p>a numeric value that specifies the minimum number of conditions for
which grouping CVs should be below the cutoff.</p>
</td></tr>
<tr><td><code id="filter_cv_+3A_silent">silent</code></td>
<td>
<p>a logical value that specifies if a message with the number of filtered out
conditions should be returned. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The CV filtered data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create synthetic data
data &lt;- create_synthetic_data(
  n_proteins = 50,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random",
  additional_metadata = FALSE
)

# Filter coefficients of variation
data_filtered &lt;- filter_cv(
  data = data,
  grouping = peptide,
  condition = condition,
  log2_intensity = peptide_intensity_missing,
  cv_limit = 0.25,
  min_conditions = 2
)
</code></pre>

<hr>
<h2 id='find_all_subs'>Find all sub IDs of an ID in a network</h2><span id='topic+find_all_subs'></span>

<h3>Description</h3>

<p>For a given ID, find all sub IDs and their sub IDs etc. The type of
relationship can be selected too. This is a helper function for other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_all_subs(
  data,
  ids,
  main_id = id,
  type = type,
  accepted_types = "is_a",
  exclude_parent_id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_all_subs_+3A_data">data</code></td>
<td>
<p>a data frame that contains relational information on IDs (main_id) their sub
IDs (sub_id) and their relationship (type). For ChEBI this data frame can be obtained by calling
<code>fetch_chebi(relation = TRUE)</code>. For ECO data it can be obtained by calling fetch_eco(relation = TRUE).</p>
</td></tr>
<tr><td><code id="find_all_subs_+3A_ids">ids</code></td>
<td>
<p>a character vector of IDs for which sub IDs should be searched.</p>
</td></tr>
<tr><td><code id="find_all_subs_+3A_main_id">main_id</code></td>
<td>
<p>a character or integer column containing IDs. Default is <code>id</code> for ChEBI IDs.</p>
</td></tr>
<tr><td><code id="find_all_subs_+3A_type">type</code></td>
<td>
<p>a character column that contains the type of interactions. Default is <code>type</code> for ChEBI IDs.</p>
</td></tr>
<tr><td><code id="find_all_subs_+3A_accepted_types">accepted_types</code></td>
<td>
<p>a character vector containing the accepted_types of relationships that should be considered
for the search. It is possible to use &quot;all&quot; relationships. The default type is &quot;is_a&quot;. A list of
possible relationships for e.g. ChEBI IDs can be found
<a href="https://docs.google.com/document/d/1_w-DwBdCCOh1gMeeP6yqGzcnkpbHYOa3AGSODe5epcg/edit#heading=h.hnsqoqu978s5">here</a>.</p>
</td></tr>
<tr><td><code id="find_all_subs_+3A_exclude_parent_id">exclude_parent_id</code></td>
<td>
<p>a logical value that specifies if the parent ID should be included in
the returned list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors containing the provided ID and all of its sub IDs. It
contains one element per input ID.
</p>

<hr>
<h2 id='find_chebis'>Find ChEBI IDs for name patterns</h2><span id='topic+find_chebis'></span>

<h3>Description</h3>

<p>Search for chebi IDs that match a specific name pattern. A list of corresponding ChEBI IDs is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_chebis(chebi_data, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_chebis_+3A_chebi_data">chebi_data</code></td>
<td>
<p>a data frame that contains at least information on ChEBI IDs (id) and their
names (name). This data frame can be obtained by calling <code>fetch_chebi()</code>. Ideally this
should be subsetted to only contain molecules of a specific type e.g. metals. This can be
achieved by calling <code>find_all_subs</code> with a general ID such as &quot;25213&quot; (Metal cation) and
then subset the complete ChEBI database to only include the returned sub-IDs. Using a subsetted
database ensures better search results. This is a helper function for other functions.</p>
</td></tr>
<tr><td><code id="find_chebis_+3A_pattern">pattern</code></td>
<td>
<p>a character vector that contains names or name patterns of molecules. Name
patterns can be for example obtained with the <code>split_metal_name</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors containing ChEBI IDs that have a name matching the supplied
pattern. It contains one element per pattern.
</p>

<hr>
<h2 id='find_peptide'>Find peptide location</h2><span id='topic+find_peptide'></span>

<h3>Description</h3>

<p>The position of the given peptide sequence is searched within the given protein sequence. In
addition the last amino acid of the peptide and the amino acid right before are reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_peptide(data, protein_sequence, peptide_sequence)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_peptide_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the protein and peptide sequence.</p>
</td></tr>
<tr><td><code id="find_peptide_+3A_protein_sequence">protein_sequence</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the
protein sequence.</p>
</td></tr>
<tr><td><code id="find_peptide_+3A_peptide_sequence">peptide_sequence</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the
peptide sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the input data and four additional columns with peptide
start and end position, the last amino acid and the amino acid before the peptide.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create example data
data &lt;- data.frame(
  protein_sequence = c("abcdefg"),
  peptide_sequence = c("cde")
)

# Find peptide
find_peptide(
  data = data,
  protein_sequence = protein_sequence,
  peptide_sequence = peptide_sequence
)
</code></pre>

<hr>
<h2 id='find_peptide_in_structure'>Finds peptide positions in a PDB structure based on positional matching</h2><span id='topic+find_peptide_in_structure'></span>

<h3>Description</h3>

<p>Finds peptide positions in a PDB structure. Often positions of peptides in UniProt and a PDB
structure are different due to different lengths of structures. This function maps a peptide
based on its UniProt positions onto a PDB structure. This method is superior to sequence
alignment of the peptide to the PDB structure sequence, since it can also match the peptide if
there are truncations or mismatches. This function also provides an easy way to check if a
peptide is present in a PDB structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_peptide_in_structure(
  peptide_data,
  peptide,
  start,
  end,
  uniprot_id,
  pdb_data = NULL,
  retain_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_peptide_in_structure_+3A_peptide_data">peptide_data</code></td>
<td>
<p>a data frame containing at least the input columns to this function.</p>
</td></tr>
<tr><td><code id="find_peptide_in_structure_+3A_peptide">peptide</code></td>
<td>
<p>a character column in the <code>peptide_data</code> data frame that contains the
sequence or any other unique identifier for the peptide that should be found.</p>
</td></tr>
<tr><td><code id="find_peptide_in_structure_+3A_start">start</code></td>
<td>
<p>a numeric column in the <code>peptide_data</code> data frame that contains start positions
of peptides.</p>
</td></tr>
<tr><td><code id="find_peptide_in_structure_+3A_end">end</code></td>
<td>
<p>a numeric column in the <code>peptide_data</code> data frame that contains end positions of
peptides.</p>
</td></tr>
<tr><td><code id="find_peptide_in_structure_+3A_uniprot_id">uniprot_id</code></td>
<td>
<p>a character column in the <code>peptide_data</code> data frame that contains UniProt
identifiers that correspond to the peptides.</p>
</td></tr>
<tr><td><code id="find_peptide_in_structure_+3A_pdb_data">pdb_data</code></td>
<td>
<p>optional, a data frame containing data obtained with <code>fetch_pdb()</code>. If not
provided, information is fetched automatically. If this function should be run multiple times
it is faster to fetch the information once and provide it to the function. If provided, make
sure that the column names are identical to the ones that would be obtained by calling <code>fetch_pdb()</code>.</p>
</td></tr>
<tr><td><code id="find_peptide_in_structure_+3A_retain_columns">retain_columns</code></td>
<td>
<p>a vector indicating if certain columns should be retained from the input
data frame. Default is not retaining additional columns <code>retain_columns = NULL</code>. Specific
columns can be retained by providing their names (not in quotations marks, just like other
column names, but in a vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains peptide positions in the corresponding PDB structures. If a
peptide is not found in any structure or no structure is associated with the protein, the data
frame contains NAs values for the output columns. The data frame contains the following and
additional columns:
</p>

<ul>
<li><p> auth_asym_id: Chain identifier provided by the author of the structure in order to
match the identification used in the publication that describes the structure.
</p>
</li>
<li><p> label_asym_id: Chain identifier following the standardised convention for mmCIF files.
</p>
</li>
<li><p> peptide_seq_in_pdb: The sequence of the peptide mapped to the structure. If the
peptide only maps partially, then only the part of the sequence that maps on the structure is
returned.
</p>
</li>
<li><p> fit_type: The fit type is either &quot;partial&quot; or &quot;fully&quot; and it indicates if the complete
peptide or only part of it was found in the structure.
</p>
</li>
<li><p> label_seq_id_start: Contains the first residue position of the peptide in the structure
following the standardised convention for mmCIF files.
</p>
</li>
<li><p> label_seq_id_end: Contains the last residue position of the peptide in the structure
following the standardised convention for mmCIF files.
</p>
</li>
<li><p> auth_seq_id_start: Contains the first residue position of the peptide in the structure
based on the alternative residue identifier provided by the author of the structure in order
to match the identification used in the publication that describes the structure. This does
not need to be numeric and is therefore of type character.
</p>
</li>
<li><p> auth_seq_id_end: Contains the last residue position of the peptide in the structure
based on the alternative residue identifier provided by the author of the structure in order
to match the identification used in the publication that describes the structure. This does
not need to be numeric and is therefore of type character.
</p>
</li>
<li><p> auth_seq_id: Contains all positions (separated by &quot;;&quot;) of the peptide in the structure
based on the alternative residue identifier provided by the author of the structure in order
to match the identification used in the publication that describes the structure. This does
not need to be numeric and is therefore of type character.
</p>
</li>
<li><p> n_peptides: The number of peptides from one protein that were searched for within the
current structure.
</p>
</li>
<li><p> n_peptides_in_structure: The number of peptides from one protein that were found within
the current structure.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Create example data
peptide_data &lt;- data.frame(
  uniprot_id = c("P0A8T7", "P0A8T7", "P60906"),
  peptide_sequence = c(
    "SGIVSFGKETKGKRRLVITPVDGSDPYEEMIPKWRQLNV",
    "NVFEGERVER",
    "AIGEVTDVVEKE"
  ),
  start = c(1160, 1197, 55),
  end = c(1198, 1206, 66)
)

# Find peptides in protein structure
peptide_in_structure &lt;- find_peptide_in_structure(
  peptide_data = peptide_data,
  peptide = peptide_sequence,
  start = start,
  end = end,
  uniprot_id = uniprot_id
)

head(peptide_in_structure, n = 10)

</code></pre>

<hr>
<h2 id='fit_drc_4p'>Fitting four-parameter dose response curves</h2><span id='topic+fit_drc_4p'></span>

<h3>Description</h3>

<p>Function for fitting four-parameter dose response curves for each group (precursor, peptide or
protein). In addition it can annotate data based on completeness, the completeness distribution
and statistical testing using ANOVA. Filtering by the function is only performed based on completeness
if selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_drc_4p(
  data,
  sample,
  grouping,
  response,
  dose,
  filter = "post",
  replicate_completeness = 0.7,
  condition_completeness = 0.5,
  n_replicate_completeness = NULL,
  n_condition_completeness = NULL,
  complete_doses = NULL,
  anova_cutoff = 0.05,
  correlation_cutoff = 0.8,
  log_logarithmic = TRUE,
  include_models = FALSE,
  retain_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_drc_4p_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the precursor,
peptide or protein identifiers.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_response">response</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the response
values, e.g. log2 transformed intensities.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_dose">dose</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the dose values, e.g.
the treatment concentrations.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_filter">filter</code></td>
<td>
<p>a character value that can either be <code>"pre"</code>, <code>"post"</code> or <code>"none"</code>. The data is
annotated for completeness, ANOVA significance and the completeness distribution along
the doses (<code>"pre"</code> and <code>"post"</code>). The combined output of this filtering step can be found in
the <code>passed_filter</code> column and depends on the cutoffs provided to the function. Note that this
is only an annotation and nothing is removed from the output. If <code>"pre"</code> is selected then, in
addition to the annotation, the data is filtered for completeness based on the condition completeness
prior to the curve fitting and ANOVA calculation and p-value adjustment. This has the benefit that less
curves need to be fitted and that the ANOVA p-value adjustment is done only on the relevant set of tests.
If <code>"none"</code> is selected the data will be neither annotated nor filtered.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_replicate_completeness">replicate_completeness</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> please use <code>n_replicate_completeness</code> instead.
A numeric value which similar to <code>completenss_MAR</code> of the
<code>assign_missingness</code> function sets a threshold for the completeness of data. In contrast
to <code>assign_missingness</code> it only determines the completeness for one condition and not the
comparison of two conditions. The threshold is used to calculate a minimal degree of data
completeness. The value provided to this argument has to be between 0 and 1, default is 0.7.
It is multiplied with the number of replicates and then adjusted downward. The resulting number
is the minimal number of observations that a condition needs to have to be considered &quot;complete
enough&quot; for the <code>condition_completeness</code> argument.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_condition_completeness">condition_completeness</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> please use <code>n_condition_completeness</code> instead.
A numeric value which determines how many conditions need to at
least fulfill the &quot;complete enough&quot; criteria set with <code>replicate_completeness</code>. The
value provided to this argument has to be between 0 and 1, default is 0.5. It is multiplied with
the number of conditions and then adjusted downward. The resulting number is the minimal number
of conditions that need to fulfill the <code>replicate_completeness</code> argument for a peptide to
pass the filtering.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_n_replicate_completeness">n_replicate_completeness</code></td>
<td>
<p>a numeric value that defines the minimal number of observations that a
condition (concentration) needs to have to be considered &quot;complete enough&quot; for the <code>n_condition_completeness</code>
argument. E.g. if each concentration has 4 replicates this argument could be set to 3 to allow for one
replicate to be missing for the completeness criteria.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_n_condition_completeness">n_condition_completeness</code></td>
<td>
<p>a numeric value that defines the minimal number
of conditions that need to fulfill the <code>n_replicate_completeness</code> argument for a feature to
pass the filtering. E.g. if an experiment has 12 concentrations, this argument could be set
to 6 to define that at least 6 of 12 concentrations need to make the replicate completeness cutoff.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_complete_doses">complete_doses</code></td>
<td>
<p>an optional numeric vector that supplies all the actually used doses (concentrations)
to the function. Usually the function extracts this information from the supplied data. However,
for incomplete datasets the total number of assumed doses might be wrong. Therefore, it becomes
important to provide this argument when the dataset is small and potentially incomplete. This
information is only used for the missing not at random (MNAR) estimations.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_anova_cutoff">anova_cutoff</code></td>
<td>
<p>a numeric value that specifies the ANOVA adjusted p-value cutoff used for
data filtering. Any fits with an adjusted ANOVA p-value bellow the cutoff will be considered
for scoring. The default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_correlation_cutoff">correlation_cutoff</code></td>
<td>
<p>a numeric value that specifies the correlation cutoff used for data
filtering. Any fits with a correlation above the cutoff will be considered for scoring.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_log_logarithmic">log_logarithmic</code></td>
<td>
<p>a logical value that indicates if a logarithmic or log-logarithmic model
is fitted. If response values form a symmetric curve for non-log transformed dose values, a
logarithmic model instead of a log-logarithmic model should be used. Usually biological dose
response data has a log-logarithmic distribution, which is the reason this is the default.
Log-logarithmic models are symmetric if dose values are log transformed.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_include_models">include_models</code></td>
<td>
<p>a logical value that indicates if model fit objects should be exported.
These are usually very large and not necessary for further analysis.</p>
</td></tr>
<tr><td><code id="fit_drc_4p_+3A_retain_columns">retain_columns</code></td>
<td>
<p>a vector that specifies columns that should be retained from the input
data frame. Default is not retaining additional columns <code>retain_columns = NULL</code>. Specific
columns can be retained by providing their names (not in quotations marks, just like other
column names, but in a vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data filtering options are selected, data is annotated based on multiple criteria.
If <code>"post"</code> is selected the data is annotated based on completeness, the completeness distribution, the
adjusted ANOVA p-value cutoff and a correlation cutoff. Completeness of features is determined based on
the <code>n_replicate_completeness</code> and <code>n_condition_completeness</code> arguments. The completeness distribution determines
if there is a distribution of not random missingness of data along the dose. For this it is checked if half of a
features values (+/-1 value) pass the replicate completeness criteria and half do not pass it. In order to fall into
this category, the values that fulfill the completeness cutoff and the ones that do not fulfill it
need to be consecutive, meaning located next to each other based on their concentration values. Furthermore,
the values that do not pass the completeness cutoff need to be lower in intensity. Lastly, the difference
between the two groups is tested for statistical significance using a Welch's t-test and a
cutoff of p &lt;= 0.1 (we want to mainly discard curves that falsely fit the other criteria but that
have clearly non-significant differences in mean). This allows curves to be considered that have
missing values in half of their observations due to a decrease in intensity. It can be thought
of as conditions that are missing not at random (MNAR). It is often the case that those entities
do not have a significant p-value since half of their conditions are not considered due to data
missingness. The ANOVA test is performed on the features by concentration. If it is significant it is
likely that there is some response. However, this test would also be significant even if there is one
outlier concentration so it should only be used only in combination with other cutoffs to determine
if a feature is significant. The <code>passed_filter</code> column is <code>TRUE</code> for all the
features that pass the above mentioned criteria and that have a correlation greater than the cutoff
(default is 0.8) and the adjusted ANOVA p-value below the cutoff (default is 0.05).
</p>
<p>The final list is ranked based on a score calculated on entities that pass the filter.
The score is the negative log10 of the adjusted ANOVA p-value scaled between 0 and 1 and the
correlation scaled between 0 and 1 summed up and divided by 2. Thus, the highest score an
entity can have is 1 with both the highest correlation and adjusted p-value. The rank is
corresponding to this score. Please note, that entities with MNAR conditions might have a
lower score due to the missing or non-significant ANOVA p-value. If no score could be calculated
the usual way these cases receive a score of 0. You should have a look at curves that are TRUE
for <code>dose_MNAR</code> in more detail.
</p>
<p>If the <code>"pre"</code> option is selected for the <code>filter</code> argument then the data is filtered for completeness
prior to curve fitting and the ANOVA test. Otherwise annotation is performed exactly as mentioned above.
We recommend the <code>"pre"</code> option because it leaves you with not only the likely hits of your treatment, but
also with rather high confidence true negative results. This is because the filtered data has a high
degree of completeness making it unlikely that a real dose-response curve is missed due to data missingness.
</p>
<p>Please note that in general, curves are only fitted if there are at least 5 conditions with data points present
to ensure that there is potential for a good curve fit. This is done independent of the selected filtering option.
</p>


<h3>Value</h3>

<p>If <code>include_models = FALSE</code> a data frame is returned that contains correlations
of predicted to measured values as a measure of the goodness of the curve fit, an associated
p-value and the four parameters of the model for each group. Furthermore, input data for plots
is returned in the columns <code>plot_curve</code> (curve and confidence interval) and <code>plot_points</code>
(measured points). If <code>include_models = TURE</code>, a list is returned that contains:
</p>

<ul>
<li> <p><code>fit_objects</code>: The fit objects of type <code>drc</code> for each group.
</p>
</li>
<li> <p><code>correlations</code>: The correlation data frame described above
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(dplyr)

set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 2,
  frac_change = 1,
  n_replicates = 3,
  n_conditions = 8,
  method = "dose_response",
  concentrations = c(0, 1, 10, 50, 100, 500, 1000, 5000),
  additional_metadata = FALSE
)

# Perform dose response curve fit
drc_fit &lt;- fit_drc_4p(
  data = data,
  sample = sample,
  grouping = peptide,
  response = peptide_intensity_missing,
  dose = concentration,
  n_replicate_completeness = 2,
  n_condition_completeness = 5,
  retain_columns = c(protein, change_peptide)
)

glimpse(drc_fit)

head(drc_fit, n = 10)

</code></pre>

<hr>
<h2 id='go_enrichment'>Perform gene ontology enrichment analysis</h2><span id='topic+go_enrichment'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>calculate_go_enrichment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>go_enrichment(...)
</code></pre>


<h3>Value</h3>

<p>A bar plot displaying negative log10 adjusted p-values for the top 10 enriched or
depleted gene ontology terms. Alternatively, plot cutoffs can be chosen individually with the
<code>plot_cutoff</code> argument. Bars are colored according to the direction of the enrichment
(enriched or deenriched). If <code>plot = FALSE</code>, a data frame is returned. P-values are
adjusted with Benjamini-Hochberg.
</p>

<hr>
<h2 id='impute'>Imputation of missing values</h2><span id='topic+impute'></span>

<h3>Description</h3>

<p><code>impute</code> is calculating imputation values for missing data depending on the selected
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute(
  data,
  sample,
  grouping,
  intensity_log2,
  condition,
  comparison = comparison,
  missingness = missingness,
  noise = NULL,
  method = "ludovic",
  skip_log2_transform_error = FALSE,
  retain_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute_+3A_data">data</code></td>
<td>
<p>a data frame that is ideally the output from the <code>assign_missingness</code> function.
It should containing at least the input variables. For each &quot;reference_vs_treatment&quot; comparison,
there should be the pair of the reference and treatment condition. That means the reference
condition should be doublicated once for every treatment.</p>
</td></tr>
<tr><td><code id="impute_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="impute_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the precursor or
peptide identifiers.</p>
</td></tr>
<tr><td><code id="impute_+3A_intensity_log2">intensity_log2</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the intensity
values.</p>
</td></tr>
<tr><td><code id="impute_+3A_condition">condition</code></td>
<td>
<p>a character or numeric column in the <code>data</code> data frame that contains the
the conditions.</p>
</td></tr>
<tr><td><code id="impute_+3A_comparison">comparison</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the the
comparisons of treatment/reference pairs. This is an output of the <code>assign_missingnes</code>
function.</p>
</td></tr>
<tr><td><code id="impute_+3A_missingness">missingness</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the
missingness type of the data determines how values for imputation are sampled. This should at
least contain <code>"MAR"</code> or <code>"MNAR"</code>. Missingness assigned as <code>NA</code> will not be imputed.</p>
</td></tr>
<tr><td><code id="impute_+3A_noise">noise</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the noise value for
the precursor/peptide. Is only required if <code>method = "noise"</code>. Note: Noise values need to
be log2 transformed.</p>
</td></tr>
<tr><td><code id="impute_+3A_method">method</code></td>
<td>
<p>a character value that specifies the method to be used for imputation. For
<code>method = "ludovic"</code>, MNAR missingness is sampled from a normal distribution around a
value that is three lower (log2) than the lowest intensity value recorded for the
precursor/peptide and that has a spread of the mean standard deviation for the
precursor/peptide. For <code>method = "noise"</code>, MNAR missingness is sampled from a normal
distribution around the mean noise for the precursor/peptide and that has a spread of the
mean standard deviation (from each condition) for the precursor/peptide. Both methods impute
MAR data using the mean and variance of the condition with the missing data.</p>
</td></tr>
<tr><td><code id="impute_+3A_skip_log2_transform_error">skip_log2_transform_error</code></td>
<td>
<p>a logical value that determines if a check is performed to
validate that input values are log2 transformed. If input values are &gt; 40 the test is failed
and an error is returned.</p>
</td></tr>
<tr><td><code id="impute_+3A_retain_columns">retain_columns</code></td>
<td>
<p>a vector that indicates columns that should be retained from the input
data frame. Default is not retaining additional columns <code>retain_columns = NULL</code>. Specific
columns can be retained by providing their names (not in quotations marks, just like other
column names, but in a vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains an <code>imputed_intensity</code> and <code>imputed</code> column in
addition to the required input columns. The <code>imputed</code> column indicates if a value was
imputed. The <code>imputed_intensity</code> column contains imputed intensity values for previously
missing intensities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 10,
  frac_change = 0.5,
  n_replicates = 4,
  n_conditions = 2,
  method = "effect_random",
  additional_metadata = FALSE
)

head(data, n = 24)

# Assign missingness information
data_missing &lt;- assign_missingness(
  data,
  sample = sample,
  condition = condition,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  ref_condition = "all",
  retain_columns = c(protein, peptide_intensity)
)

head(data_missing, n = 24)

# Perform imputation
data_imputed &lt;- impute(
  data_missing,
  sample = sample,
  grouping = peptide,
  intensity_log2 = peptide_intensity_missing,
  condition = condition,
  comparison = comparison,
  missingness = missingness,
  method = "ludovic",
  retain_columns = c(protein, peptide_intensity)
)

head(data_imputed, n = 24)
</code></pre>

<hr>
<h2 id='kegg_enrichment'>Perform KEGG pathway enrichment analysis</h2><span id='topic+kegg_enrichment'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>calculate_kegg_enrichment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kegg_enrichment(...)
</code></pre>


<h3>Value</h3>

<p>A bar plot displaying negative log10 adjusted p-values for the top 10 enriched pathways.
Bars are coloured according to the direction of the enrichment. If <code>plot = FALSE</code>, a data
frame is returned.
</p>

<hr>
<h2 id='mako_colours'>Viridis colour scheme</h2><span id='topic+mako_colours'></span>

<h3>Description</h3>

<p>A perceptually uniform colour scheme originally created for the Seaborn python package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mako_colours
</code></pre>


<h3>Format</h3>

<p>A vector containing 256 colours
</p>


<h3>Source</h3>

<p>created for the Seaborn statistical data visualization package for Python
</p>

<hr>
<h2 id='map_peptides_on_structure'>Maps peptides onto a PDB structure or AlphaFold prediction</h2><span id='topic+map_peptides_on_structure'></span>

<h3>Description</h3>

<p>Peptides are mapped onto PDB structures or AlphaFold prediction based on their positions.
This is accomplished by replacing the B-factor information in the structure file with
values that allow highlighting of peptides, protein regions or amino acids when the structure
is coloured by B-factor. In addition to simply highlighting peptides, protein regions or amino
acids, a continuous variable such as fold changes associated with them can be mapped onto the
structure as a colour gradient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_peptides_on_structure(
  peptide_data,
  uniprot_id,
  pdb_id,
  chain,
  auth_seq_id,
  map_value,
  file_format = ".cif",
  scale_per_structure = TRUE,
  export_location = NULL,
  structure_file = NULL,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_peptides_on_structure_+3A_peptide_data">peptide_data</code></td>
<td>
<p>a data frame that contains the input columns to this function. If structure
or prediction files should be fetched automatically, please provide column names to the following
arguments: <strong>uniprot_id</strong>, <strong>pdb_id</strong>, <strong>chain</strong>, <strong>auth_seq_id</strong>,
<strong>map_value</strong>. If no PDB structure for a protein is available the <code>pdb_id</code> and <code>chain</code>
column should contain NA at these positions. If a structure or prediction file is provided in the
<code>structure_file</code> argument, this data frame should only contain information associated with
the provided structure. In case of a user provided structure, column names should be provided to
the following arguments: <strong>uniprot_id</strong>, <strong>chain</strong>, <strong>auth_seq_id</strong>, <strong>map_value</strong>.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_uniprot_id">uniprot_id</code></td>
<td>
<p>a character column in the <code>peptide_data</code> data frame that contains UniProt
identifiers for a corresponding peptide, protein region or amino acid.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_pdb_id">pdb_id</code></td>
<td>
<p>a character column in the <code>peptide_data</code> data frame that contains PDB
identifiers for structures in which a corresponding peptide, protein region or amino acid is found.
If a protein prediction should be fetched from AlphaFold, this column should contain NA. This
column is not required if a structure or prediction file is provided in the <code>structure_file</code>
argument.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_chain">chain</code></td>
<td>
<p>a character column in the <code>peptide_data</code> data frame that contains the name of
the chain from the PDB structure in which the peptide, protein region or amino acid is found.
If a protein prediction should be fetched from AlphaFold, this column should contain NA. If an
AlphaFold prediction is provided to the <code>structure_file</code> argument the chain should be
provided as usual (All AlphaFold predictions only have chain A). <strong>Important:</strong> please provide
the author defined chain definitions for both &quot;.cif&quot; and &quot;.pdb&quot; files. When the output of the
<code>find_peptide_in_structure</code> function is used as the input for this function, this
corresponds to the <code>auth_asym_id</code> column.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_auth_seq_id">auth_seq_id</code></td>
<td>
<p>optional, a character (or numeric) column in the <code>peptide_data</code> data frame
that contains semicolon separated positions of peptides, protein regions or amino acids in the
corresponding PDB structure or AlphaFold prediction. This information can be obtained from the
<code>find_peptide_in_structure</code> function. The corresponding column in the output is called
<code>auth_seq_id</code>. In case of AlphaFold predictions, UniProt positions should be used. If
signal positions and not stretches of amino acids are provided, the column can be numeric and
does not need to contain the semicolon separator.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_map_value">map_value</code></td>
<td>
<p>a numeric column in the <code>peptide_data</code> data frame that contains a value
associated with each peptide, protein region or amino acid. If one start to end position pair
has multiple different map values, the maximum will be used. This value will be displayed as a
colour gradient when mapped onto the structure. The value can for example be the fold change,
p-value or score associated with each peptide, protein region or amino acid (selection). If
the selections should be displayed with just one colour, the value in this column should be
the same for every selection. For the mapping, values are scaled between 50 and 100. Regions
in the structure that do not map any selection receive a value of 0. If an amino acid position
is associated with multiple mapped values, e.g. from different peptides, the maximum mapped
value will be displayed.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_file_format">file_format</code></td>
<td>
<p>a character vector containing the file format of the structure that will be
fetched from the database for the PDB identifiers provided in the <code>pdb_id</code> column. This
can be either &quot;.cif&quot; or &quot;.pdb&quot;. The default is <code>".cif"</code>. We recommend using &quot;.cif&quot; files
since every structure contains a &quot;.cif&quot; file but not every structure contains a &quot;.pdb&quot; file.
Fetching and mapping onto &quot;.cif&quot; files takes longer than for &quot;.pdb&quot; files. If a structure file
is provided in the <code>structure_file</code> argument, the file format is detected automatically
and does not need to be provided.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_scale_per_structure">scale_per_structure</code></td>
<td>
<p>a logical value that specifies if scaling should be performed for
each structure independently (TRUE) or over the whole data set (FALSE). The default is TRUE,
which scales the scores of each structure independently so that each structure has a score
range from 50 to 100.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_export_location">export_location</code></td>
<td>
<p>optional, a character argument specifying the path to the location in
which the fetched and altered structure files should be saved. If left empty, they will be
saved in the current working directory. The location should be provided in the following
format &quot;folderA/folderB&quot;.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_structure_file">structure_file</code></td>
<td>
<p>optional, a character argument specifying the path to the location and
name of a structure file in &quot;.cif&quot; or &quot;.pdb&quot; format. If a structure is provided the <code>peptide_data</code>
data frame should only contain mapping information for this structure.</p>
</td></tr>
<tr><td><code id="map_peptides_on_structure_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical, if <code>show_progress = TRUE</code>, a progress bar will be shown
(default is TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function exports a modified &quot;.pdb&quot; or &quot;.cif&quot; structure file. B-factors have been
replaced with scaled (50-100) values provided in the <code>map_value</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load libraries
library(dplyr)

# Create example data
peptide_data &lt;- data.frame(
  uniprot_id = c("P0A8T7", "P0A8T7", "P60906"),
  peptide_sequence = c(
    "SGIVSFGKETKGKRRLVITPVDGSDPYEEMIPKWRQLNV",
    "NVFEGERVER",
    "AIGEVTDVVEKE"
  ),
  start = c(1160, 1197, 55),
  end = c(1198, 1206, 66),
  map_value = c(70, 100, 100)
)

# Find peptide positions in structures
positions_structure &lt;- find_peptide_in_structure(
  peptide_data = peptide_data,
  peptide = peptide_sequence,
  start = start,
  end = end,
  uniprot_id = uniprot_id,
  retain_columns = c(map_value)) %&gt;%
  filter(pdb_ids %in% c("6UU2", "2EL9"))

# Map peptides on structures
# You can determine the preferred output location
# with the export_location argument. Currently it
# is saved in the working directory.
map_peptides_on_structure(
  peptide_data = positions_structure,
  uniprot_id = uniprot_id,
  pdb_id = pdb_ids,
  chain = auth_asym_id,
  auth_seq_id = auth_seq_id,
  map_value = map_value,
  file_format = ".pdb",
  export_location = getwd()
)



</code></pre>

<hr>
<h2 id='median_normalisation'>Intensity normalisation</h2><span id='topic+median_normalisation'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>normalise()</code>.
The normalisation method in the new function needs to be provided as an argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_normalisation(...)
</code></pre>


<h3>Value</h3>

<p>A data frame with a column called <code>normalised_intensity_log2</code> containing the
normalised intensity values.
</p>

<hr>
<h2 id='metal_chebi_uniprot'>List of metal-related ChEBI IDs in UniProt</h2><span id='topic+metal_chebi_uniprot'></span>

<h3>Description</h3>

<p>A list that contains all ChEBI IDs that appear in UniProt and that contain either a metal atom
in their formula or that do not have a formula but the ChEBI term is related to metals.
This was last updated on the 19/02/24.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metal_chebi_uniprot
</code></pre>


<h3>Format</h3>

<p>A data.frame containing information retrieved from ChEBI using <code>fetch_chebi(stars = c(2, 3))</code>,
filtered using symbols in the <code>metal_list</code> and manual annotation of metal related ChEBI IDs that do not
contain a formula.
</p>


<h3>Source</h3>

<p>UniProt (cc_cofactor, cc_catalytic_activity, ft_binding) and ChEBI
</p>

<hr>
<h2 id='metal_go_slim_subset'>Molecular function gene ontology metal subset</h2><span id='topic+metal_go_slim_subset'></span>

<h3>Description</h3>

<p>A subset of molecular function gene ontology terms related to metals that was created
using the slimming process provided by the QuickGO EBI database.
This was last updated on the 19/02/24.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metal_go_slim_subset
</code></pre>


<h3>Format</h3>

<p>A data.frame containing a slim subset of molecular function gene ontology terms
that are related to metal binding. The <code>slims_from_id</code> column contains all IDs relevant
in this subset while the <code>slims_to_ids</code> column contains the starting IDs. If ChEBI IDs
have been annotated manually this is indicated in the <code>database</code> column.
</p>


<h3>Source</h3>

<p>QuickGO and ChEBI
</p>

<hr>
<h2 id='metal_list'>List of metals</h2><span id='topic+metal_list'></span>

<h3>Description</h3>

<p>A list of all metals and metalloids in the periodic table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metal_list
</code></pre>


<h3>Format</h3>

<p>A data.frame containing the columns <code>atomic_number</code>, <code>symbol</code>, <code>name</code>,
<code>type</code>, <code>chebi_id</code>.
</p>


<h3>Source</h3>

<p>https://en.wikipedia.org/wiki/Metal and https://en.wikipedia.org/wiki/Metalloid
</p>

<hr>
<h2 id='network_analysis'>Analyse protein interaction network for significant hits</h2><span id='topic+network_analysis'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>analyse_functional_network()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_analysis(...)
</code></pre>


<h3>Value</h3>

<p>A network plot displaying interactions of the provided proteins. If
<code>binds_treatment</code> was provided halos around the proteins show which proteins interact with
the treatment. If <code>plot = FALSE</code> a data frame with interaction information is returned.
</p>

<hr>
<h2 id='normalise'>Intensity normalisation</h2><span id='topic+normalise'></span>

<h3>Description</h3>

<p>Performs normalisation on intensities. For median normalisation the normalised intensity is the
original intensity minus the run median plus the global median. This is also the way it is
implemented in the Spectronaut search engine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(data, sample, intensity_log2, method = "median")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise_+3A_data">data</code></td>
<td>
<p>a data frame containing at least sample names and intensity values. Please note that if the
data frame is grouped, the normalisation will be computed by group.</p>
</td></tr>
<tr><td><code id="normalise_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="normalise_+3A_intensity_log2">intensity_log2</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the log2 transformed
intensity values to be normalised.</p>
</td></tr>
<tr><td><code id="normalise_+3A_method">method</code></td>
<td>
<p>a character value specifying the method to be used for normalisation. Default
is &quot;median&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a column called <code>normalised_intensity_log2</code> containing the
normalised intensity values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  r_file_name = c("s1", "s2", "s3", "s1", "s2", "s3"),
  intensity_log2 = c(18, 19, 17, 20, 21, 19)
)

normalise(data,
  sample = r_file_name,
  intensity_log2 = intensity_log2,
  method = "median"
)
</code></pre>

<hr>
<h2 id='parallel_create_structure_contact_map'>Creates a contact map of all atoms from a structure file (using parallel processing)</h2><span id='topic+parallel_create_structure_contact_map'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code>create_structure_contact_map()</code> that allows the use of all
system cores for the creation of contact maps. Alternatively, it can be used for sequential
processing of large datasets. The benefit of this function over <code>create_structure_contact_map()</code>
is that it processes contact maps in batches, which is recommended for large datasets. If used
for parallel processing it should only be used on systems that have enough memory available.
Workers can either be set up manually before running the function with
<code>future::plan(multisession)</code> or automatically by the function (maximum number of workers
is 12 in this case). If workers are set up manually the <code>processing_type</code> argument should
be set to &quot;parallel manual&quot;. In this case workers can be terminated after completion with
<code>future::plan(sequential)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel_create_structure_contact_map(
  data,
  data2 = NULL,
  id,
  chain = NULL,
  auth_seq_id = NULL,
  distance_cutoff = 10,
  pdb_model_number_selection = c(0, 1),
  return_min_residue_distance = TRUE,
  export = FALSE,
  export_location = NULL,
  split_n = 40,
  processing_type = "parallel"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallel_create_structure_contact_map_+3A_data">data</code></td>
<td>
<p>a data frame containing at least a column with PDB ID information of which the name
can be provided to the <code>id</code> argument. If only this column is provided, all atom or residue
distances are calculated. Additionally, a chain column can be present in the data frame of which
the name can be provided to the <code>chain</code> argument. If chains are provided, only distances
of this chain relative to the rest of the structure are calculated. Multiple chains can be
provided in multiple rows. If chains are provided for one structure but not for another, the
rows should contain NAs. Furthermore, specific residue positions can be provided in the <code>auth_seq_id</code>
column if the selection should be further reduced. It is not recommended to create full
contact maps for more than a few structures due to time and memory limitations. If contact maps are
created only for small regions it is possible to create multiple maps at once. By default distances
of regions provided in this data frame to the complete structure are computed. If distances of regions
from this data frame to another specific subset of regions should be computed, the second subset
of regions can be provided through the optional <code>data2</code> argument.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_data2">data2</code></td>
<td>
<p>optional, a data frame that contains a subset of regions for which distances to regions
provided in the <code>data</code> data frame should be computed. If regions from the <code>data</code> data
frame should be compared to the whole structure, data2 does not need to be provided.
This data frame should have the same structure and column names as the <code>data</code> data frame.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_id">id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains PDB or UniProt IDs for
structures or AlphaFold predictions of which contact maps should be created. If a structure not
downloaded directly from PDB is provided (i.e. a locally stored structure file) to the
<code>structure_file</code> argument, this column should contain &quot;my_structure&quot; as content.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_chain">chain</code></td>
<td>
<p>optional, a character column in the <code>data</code> data frame that contains chain
identifiers for the structure file. Identifiers defined by the structure author should be used.
Distances will be only calculated between the provided chains and the rest of the structure.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_auth_seq_id">auth_seq_id</code></td>
<td>
<p>optional, a character (or numeric) column in the <code>data</code> data frame
that contains semicolon separated positions of regions for which distances should be calculated.
This always needs to be provided in combination with a corresponding chain in <code>chain</code>.
The position should match the positioning defined by the structure author. For
PDB structures this information can be obtained from the <code>find_peptide_in_structure</code>
function. The corresponding column in the output is called <code>auth_seq_id</code>. If an
AlphaFold prediction is provided, UniProt positions should be used. If single positions
and not stretches of amino acids are provided, the column can be numeric and does not need
to contain the semicolon separator.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_distance_cutoff">distance_cutoff</code></td>
<td>
<p>a numeric value specifying the distance cutoff in Angstrom. All values
for pairwise comparisons are calculated but only values smaller than this cutoff will be
returned in the output. If a cutoff of e.g. 5 is selected then only residues with a distance of
5 Angstrom and less are returned. Using a small value can reduce the size of the contact map
drastically and is therefore recommended. The default value is 10.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_pdb_model_number_selection">pdb_model_number_selection</code></td>
<td>
<p>a numeric vector specifying which models from the structure
files should be considered for contact maps. E.g. NMR models often have many models in one file.
The default for this argument is c(0, 1). This means the first model of each structure file is
selected for contact map calculations. For AlphaFold predictions the model number is 0
(only .pdb files), therefore this case is also included here.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_return_min_residue_distance">return_min_residue_distance</code></td>
<td>
<p>a logical value that specifies if the contact map should be
returned for all atom distances or the minimum residue distances. Minimum residue distances are
smaller in size. If atom distances are not strictly needed it is recommended to set this
argument to TRUE. The default is TRUE.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_export">export</code></td>
<td>
<p>a logical value that indicates if contact maps should be exported as &quot;.csv&quot;. The
name of the file will be the structure ID. Default is <code>export = FALSE</code>.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_export_location">export_location</code></td>
<td>
<p>optional, a character value that specifies the path to the location in
which the contact map should be saved if <code>export = TRUE</code>. If left empty, they will be
saved in the current working directory. The location should be provided in the following format
&quot;folderA/folderB&quot;.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_split_n">split_n</code></td>
<td>
<p>a numeric value that specifies the number of structures that should be included
in each batch. Default is 40.</p>
</td></tr>
<tr><td><code id="parallel_create_structure_contact_map_+3A_processing_type">processing_type</code></td>
<td>
<p>a character value that is either &quot;parallel&quot; for parallel processing or
&quot;sequential&quot; for sequential processing. Alternatively it can also be &quot;parallel manual&quot; in this
case you have to set up the number of cores on your own using the <code>future::plan(multisession)</code>
function. The default is &quot;parallel&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of contact maps for each PDB or UniProt ID provided in the input is returned.
If the <code>export</code> argument is TRUE, each contact map will be saved as a &quot;.csv&quot; file in the
current working directory or the location provided to the <code>export_location</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create example data
data &lt;- data.frame(
  pdb_id = c("6NPF", "1C14", "3NIR"),
  chain = c("A", "A", NA),
  auth_seq_id = c("1;2;3;4;5;6;7", NA, NA)
)

# Create contact map
contact_maps &lt;- parallel_create_structure_contact_map(
  data = data,
  id = pdb_id,
  chain = chain,
  auth_seq_id = auth_seq_id,
  split_n = 1,
)

str(contact_maps[["3NIR"]])

contact_maps

## End(Not run)
</code></pre>

<hr>
<h2 id='parallel_fit_drc_4p'>Fitting four-parameter dose response curves (using parallel processing)</h2><span id='topic+parallel_fit_drc_4p'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code>fit_drc_4p</code> that allows the use of all system cores for
model fitting. It should only be used on systems that have enough memory available. Workers can
either be set up manually before running the function with <code>future::plan(multisession)</code> or
automatically by the function (maximum number of workers is 12 in this case). If workers are set
up manually the number of cores should be provided to <code>n_cores</code>. Worker can be terminated
after completion with <code>future::plan(sequential)</code>. It is not possible to export the
individual fit objects when using this function as compared to the non parallel function as
they are too large for efficient export from the workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel_fit_drc_4p(
  data,
  sample,
  grouping,
  response,
  dose,
  filter = "post",
  replicate_completeness = 0.7,
  condition_completeness = 0.5,
  n_replicate_completeness = NULL,
  n_condition_completeness = NULL,
  complete_doses = NULL,
  anova_cutoff = 0.05,
  correlation_cutoff = 0.8,
  log_logarithmic = TRUE,
  retain_columns = NULL,
  n_cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallel_fit_drc_4p_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the precursor,
peptide or protein identifiers.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_response">response</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the response
values, e.g. log2 transformed intensities.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_dose">dose</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the dose values, e.g.
the treatment concentrations.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_filter">filter</code></td>
<td>
<p>a character value that can either be <code>"pre"</code>, <code>"post"</code> or <code>"none"</code>. The data is
annotated for completeness, ANOVA significance and the completeness distribution along
the doses (<code>"pre"</code> and <code>"post"</code>). The combined output of this filtering step can be found in
the <code>passed_filter</code> column and depends on the cutoffs provided to the function. Note that this
is only an annotation and nothing is removed from the output. If <code>"pre"</code> is selected then, in
addition to the annotation, the data is filtered for completeness based on the condition completeness
prior to the curve fitting and ANOVA calculation and p-value adjustment. This has the benefit that less
curves need to be fitted and that the ANOVA p-value adjustment is done only on the relevant set of tests.
If <code>"none"</code> is selected the data will be neither annotated nor filtered.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_replicate_completeness">replicate_completeness</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> please use <code>n_replicate_completeness</code> instead.
A numeric value which similar to <code>completenss_MAR</code> of the
<code>assign_missingness</code> function sets a threshold for the completeness of data. In contrast
to <code>assign_missingness</code> it only determines the completeness for one condition and not the
comparison of two conditions. The threshold is used to calculate a minimal degree of data
completeness. The value provided to this argument has to be between 0 and 1, default is 0.7.
It is multiplied with the number of replicates and then adjusted downward. The resulting number
is the minimal number of observations that a condition needs to have to be considered &quot;complete
enough&quot; for the <code>condition_completeness</code> argument.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_condition_completeness">condition_completeness</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> please use <code>n_condition_completeness</code> instead.
A numeric value which determines how many conditions need to at
least fulfill the &quot;complete enough&quot; criteria set with <code>replicate_completeness</code>. The
value provided to this argument has to be between 0 and 1, default is 0.5. It is multiplied with
the number of conditions and then adjusted downward. The resulting number is the minimal number
of conditions that need to fulfill the <code>replicate_completeness</code> argument for a peptide to
pass the filtering.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_n_replicate_completeness">n_replicate_completeness</code></td>
<td>
<p>a numeric value that defines the minimal number of observations that a
condition (concentration) needs to have to be considered &quot;complete enough&quot; for the <code>n_condition_completeness</code>
argument. E.g. if each concentration has 4 replicates this argument could be set to 3 to allow for one
replicate to be missing for the completeness criteria.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_n_condition_completeness">n_condition_completeness</code></td>
<td>
<p>a numeric value that defines the minimal number
of conditions that need to fulfill the <code>n_replicate_completeness</code> argument for a feature to
pass the filtering. E.g. if an experiment has 12 concentrations, this argument could be set
to 6 to define that at least 6 of 12 concentrations need to make the replicate completeness cutoff.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_complete_doses">complete_doses</code></td>
<td>
<p>an optional numeric vector that supplies all the actually used doses (concentrations)
to the function. Usually the function extracts this information from the supplied data. However,
for incomplete datasets the total number of assumed doses might be wrong. This might especially affect
parallel fitting of curves since the dataset is split up into smaller pieces. Therefore, it becomes
important to provide this argument especially when the dataset is small and potentially incomplete. This
information is only used for the missing not at random (MNAR) estimations.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_anova_cutoff">anova_cutoff</code></td>
<td>
<p>a numeric value that specifies the ANOVA adjusted p-value cutoff used for
data filtering. Any fits with an adjusted ANOVA p-value bellow the cutoff will be considered
for scoring. The default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_correlation_cutoff">correlation_cutoff</code></td>
<td>
<p>a numeric value that specifies the correlation cutoff used for data
filtering. Any fits with a correlation above the cutoff will be considered for scoring.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_log_logarithmic">log_logarithmic</code></td>
<td>
<p>a logical value that indicates if a logarithmic or log-logarithmic model
is fitted. If response values form a symmetric curve for non-log transformed dose values, a
logarithmic model instead of a log-logarithmic model should be used. Usually biological dose
response data has a log-logarithmic distribution, which is the reason this is the default.
Log-logarithmic models are symmetric if dose values are log transformed.</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_retain_columns">retain_columns</code></td>
<td>
<p>a vector that specifies columns that should be retained from the input
data frame. Default is not retaining additional columns <code>retain_columns = NULL</code>. Specific
columns can be retained by providing their names (not in quotations marks, just like other
column names, but in a vector).</p>
</td></tr>
<tr><td><code id="parallel_fit_drc_4p_+3A_n_cores">n_cores</code></td>
<td>
<p>optional, a numeric value that specifies the number of cores used if workers
are set up manually.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data filtering options are selected, data is annotated based on multiple criteria.
If <code>"post"</code> is selected the data is annotated based on completeness, the completeness distribution, the
adjusted ANOVA p-value cutoff and a correlation cutoff. Completeness of features is determined based on
the <code>n_replicate_completeness</code> and <code>n_condition_completeness</code> arguments. The completeness distribution determines
if there is a distribution of not random missingness of data along the dose. For this it is checked if half of a
features values (+/-1 value) pass the replicate completeness criteria and half do not pass it. In order to fall into
this category, the values that fulfill the completeness cutoff and the ones that do not fulfill it
need to be consecutive, meaning located next to each other based on their concentration values. Furthermore,
the values that do not pass the completeness cutoff need to be lower in intensity. Lastly, the difference
between the two groups is tested for statistical significance using a Welch's t-test and a
cutoff of p &lt;= 0.1 (we want to mainly discard curves that falsely fit the other criteria but that
have clearly non-significant differences in mean). This allows curves to be considered that have
missing values in half of their observations due to a decrease in intensity. It can be thought
of as conditions that are missing not at random (MNAR). It is often the case that those entities
do not have a significant p-value since half of their conditions are not considered due to data
missingness. The ANOVA test is performed on the features by concentration. If it is significant it is
likely that there is some response. However, this test would also be significant even if there is one
outlier concentration so it should only be used only in combination with other cutoffs to determine
if a feature is significant. The <code>passed_filter</code> column is <code>TRUE</code> for all the
features that pass the above mentioned criteria and that have a correlation greater than the cutoff
(default is 0.8) and the adjusted ANOVA p-value below the cutoff (default is 0.05).
</p>
<p>The final list is ranked based on a score calculated on entities that pass the filter.
The score is the negative log10 of the adjusted ANOVA p-value scaled between 0 and 1 and the
correlation scaled between 0 and 1 summed up and divided by 2. Thus, the highest score an
entity can have is 1 with both the highest correlation and adjusted p-value. The rank is
corresponding to this score. Please note, that entities with MNAR conditions might have a
lower score due to the missing or non-significant ANOVA p-value. If no score could be calculated
the usual way these cases receive a score of 0. You should have a look at curves that are TRUE
for <code>dose_MNAR</code> in more detail.
</p>
<p>If the <code>"pre"</code> option is selected for the <code>filter</code> argument then the data is filtered for completeness
prior to curve fitting and the ANOVA test. Otherwise annotation is performed exactly as mentioned above.
We recommend the <code>"pre"</code> option because it leaves you with not only the likely hits of your treatment, but
also with rather high confidence true negative results. This is because the filtered data has a high
degree of completeness making it unlikely that a real dose-response curve is missed due to data missingness.
</p>
<p>Please note that in general, curves are only fitted if there are at least 5 conditions with data points present
to ensure that there is potential for a good curve fit. This is done independent of the selected filtering option.
</p>


<h3>Value</h3>

<p>A data frame is returned that contains correlations of predicted to measured values as
a measure of the goodness of the curve fit, an associated p-value and the four parameters of
the model for each group. Furthermore, input data for plots is returned in the columns <code>plot_curve</code>
(curve and confidence interval) and <code>plot_points</code> (measured points).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load libraries
library(dplyr)

set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 2,
  frac_change = 1,
  n_replicates = 3,
  n_conditions = 8,
  method = "dose_response",
  concentrations = c(0, 1, 10, 50, 100, 500, 1000, 5000),
  additional_metadata = FALSE
)

# Perform dose response curve fit
drc_fit &lt;- parallel_fit_drc_4p(
  data = data,
  sample = sample,
  grouping = peptide,
  response = peptide_intensity_missing,
  dose = concentration,
  n_replicate_completeness = 2,
  n_condition_completeness = 5,
  retain_columns = c(protein, change_peptide)
)

glimpse(drc_fit)

head(drc_fit, n = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='peptide_profile_plot'>Peptide abundance profile plot</h2><span id='topic+peptide_profile_plot'></span>

<h3>Description</h3>

<p>Creates a plot of peptide abundances across samples. This is helpful to investigate effects of
peptide and protein abundance changes in different samples and conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peptide_profile_plot(
  data,
  sample,
  peptide,
  intensity_log2,
  grouping,
  targets,
  complete_sample = FALSE,
  protein_abundance_plot = FALSE,
  interactive = FALSE,
  export = FALSE,
  export_name = "peptide_profile_plots"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peptide_profile_plot_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains sample names.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_peptide">peptide</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains peptide or
precursor names.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_intensity_log2">intensity_log2</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains log2
transformed intensities.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains groups by which
the data should be split. This can be for example protein IDs.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_targets">targets</code></td>
<td>
<p>a character vector that specifies elements of the grouping column which should
be plotted. This can also be <code>"all"</code> if plots for all groups should be created. Depending
on the number of elements in your grouping column this can be many plots.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_complete_sample">complete_sample</code></td>
<td>
<p>a logical value that indicates if samples that are completely missing for
a given protein should be shown on the x-axis of the plot anyway. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_protein_abundance_plot">protein_abundance_plot</code></td>
<td>
<p>a logical value. If the input for this plot comes directly from
<code>calculate_protein_abundance</code> this argument can be set to <code>TRUE</code>. This displays all
peptides in gray, while the protein abundance is displayed in green.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that indicates whether the plot should be interactive
(default is FALSE). If this is TRUE only one target can be supplied to the function. Interactive
plots cannot be exported either.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_export">export</code></td>
<td>
<p>a logical value that indicates if plots should be exported as PDF. The output
directory will be the current working directory. The name of the file can be chosen using the
<code>export_name</code> argument.</p>
</td></tr>
<tr><td><code id="peptide_profile_plot_+3A_export_name">export_name</code></td>
<td>
<p>a character vector that provides the name of the exported file if
<code>export = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of peptide profile plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create example data
data &lt;- data.frame(
  sample = c(
    rep("S1", 6),
    rep("S2", 6),
    rep("S1", 2),
    rep("S2", 2)
  ),
  protein_id = c(
    rep("P1", 12),
    rep("P2", 4)
  ),
  precursor = c(
    rep(c("A1", "A2", "B1", "B2", "C1", "D1"), 2),
    rep(c("E1", "F1"), 2)
  ),
  peptide = c(
    rep(c("A", "A", "B", "B", "C", "D"), 2),
    rep(c("E", "F"), 2)
  ),
  intensity = c(
    rnorm(n = 6, mean = 15, sd = 2),
    rnorm(n = 6, mean = 21, sd = 1),
    rnorm(n = 2, mean = 15, sd = 1),
    rnorm(n = 2, mean = 15, sd = 2)
  )
)

# Calculate protein abundances and retain precursor
# abundances that can be used in a peptide profile plot
complete_abundances &lt;- calculate_protein_abundance(
  data,
  sample = sample,
  protein_id = protein_id,
  precursor = precursor,
  peptide = peptide,
  intensity_log2 = intensity,
  method = "sum",
  for_plot = TRUE
)

# Plot protein abundance profile
# protein_abundance_plot can be set to
# FALSE to to also colour precursors
peptide_profile_plot(
  data = complete_abundances,
  sample = sample,
  peptide = precursor,
  intensity_log2 = intensity,
  grouping = protein_id,
  targets = c("P1"),
  protein_abundance_plot = TRUE
)

</code></pre>

<hr>
<h2 id='peptide_type'>Assign peptide type</h2><span id='topic+peptide_type'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>assign_peptide_type()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peptide_type(...)
</code></pre>


<h3>Value</h3>

<p>A data frame that contains the input data and an additional column with the peptide
type information.
</p>

<hr>
<h2 id='plot_drc_4p'>Perform gene ontology enrichment analysis</h2><span id='topic+plot_drc_4p'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>drc_4p_plot()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_drc_4p(...)
</code></pre>


<h3>Value</h3>

<p>If <code>targets = "all"</code> a list containing plots for every unique identifier in the
<code>grouping</code> variable is created. Otherwise a plot for the specified targets is created with
maximally 20 facets.
</p>

<hr>
<h2 id='plot_peptide_profiles'>Peptide abundance profile plot</h2><span id='topic+plot_peptide_profiles'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>peptide_profile_plot()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_peptide_profiles(...)
</code></pre>


<h3>Value</h3>

<p>A list of peptide profile plots.
</p>

<hr>
<h2 id='plot_pval_distribution'>Plot histogram of p-value distribution</h2><span id='topic+plot_pval_distribution'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>pval_distribution_plot()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pval_distribution(...)
</code></pre>


<h3>Value</h3>

<p>A histogram plot that shows the p-value distribution.
</p>

<hr>
<h2 id='predict_alphafold_domain'>Predict protein domains of AlphaFold predictions</h2><span id='topic+predict_alphafold_domain'></span>

<h3>Description</h3>

<p>Uses the predicted aligned error (PAE) of AlphaFold predictions to find possible protein domains.
A graph-based community clustering algorithm (Leiden clustering) is used on the predicted error
(distance) between residues of a protein in order to infer pseudo-rigid groups in the protein. This is
for example useful in order to know which parts of protein predictions are likely in a fixed relative
position towards each other and which might have varying distances.
This function is based on python code written by Tristan Croll. The original code can be found on his
<a href="https://github.com/tristanic/pae_to_domains">GitHub page</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_alphafold_domain(
  pae_list,
  pae_power = 1,
  pae_cutoff = 5,
  graph_resolution = 1,
  return_data_frame = FALSE,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_alphafold_domain_+3A_pae_list">pae_list</code></td>
<td>
<p>a list of proteins that contains aligned errors for their AlphaFold predictions.
This list can be retrieved with the <code>fetch_alphafold_aligned_error()</code> function. It should contain a
column containing the scored residue (<code>scored_residue</code>), the aligned residue (<code>aligned_residue</code>) and
the predicted aligned error (<code>error</code>).</p>
</td></tr>
<tr><td><code id="predict_alphafold_domain_+3A_pae_power">pae_power</code></td>
<td>
<p>a numeric value, each edge in the graph will be weighted proportional to (<code>1 / pae^pae_power</code>).
Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="predict_alphafold_domain_+3A_pae_cutoff">pae_cutoff</code></td>
<td>
<p>a numeric value, graph edges will only be created for residue pairs with <code>pae &lt; pae_cutoff</code>.
Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="predict_alphafold_domain_+3A_graph_resolution">graph_resolution</code></td>
<td>
<p>a numeric value that regulates how aggressive the clustering algorithm is. Smaller values
lead to larger clusters. Value should be larger than zero, and values larger than 5 are unlikely to be useful.
Higher values lead to stricter (i.e. smaller) clusters. The value is provided to the Leiden clustering algorithm
of the <code>igraph</code> package as <code>graph_resolution / 100</code>. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="predict_alphafold_domain_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>a logical value; if <code>TRUE</code> a data frame instead of a list
is returned. It is recommended to only use this if information for few proteins is retrieved.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict_alphafold_domain_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value that specifies if a progress bar will be shown. Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the provided proteins that contains domain assignments for each residue. If <code>return_data_frame</code> is
<code>TRUE</code>, a data frame with this information is returned instead. The data frame contains the
following columns:
</p>

<ul>
<li><p> residue: The protein residue number.
</p>
</li>
<li><p> domain: A numeric value representing a distinct predicted domain in the protein.
</p>
</li>
<li><p> accession: The UniProt protein identifier.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Fetch aligned errors
aligned_error &lt;- fetch_alphafold_aligned_error(
  uniprot_ids = c("F4HVG8", "O15552"),
  error_cutoff = 4
)

# Predict protein domains
af_domains &lt;- predict_alphafold_domain(
  pae_list = aligned_error,
  return_data_frame = TRUE
)

head(af_domains, n = 10)

</code></pre>

<hr>
<h2 id='protti_colours'>Colour scheme for protti</h2><span id='topic+protti_colours'></span>

<h3>Description</h3>

<p>A colour scheme for protti that contains 100 colours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protti_colours
</code></pre>


<h3>Format</h3>

<p>A vector containing 100 colours
</p>


<h3>Source</h3>

<p>Dina's imagination.
</p>

<hr>
<h2 id='ptsi_pgk'>Structural analysis example data</h2><span id='topic+ptsi_pgk'></span>

<h3>Description</h3>

<p>Example data used for the vignette about structural analysis. The data was obtained from
Cappelletti et al. 2021 (<a href="https://doi.org/10.1016/j.cell.2020.12.021">doi:10.1016/j.cell.2020.12.021</a>)
and corresponds to two separate experiments. Both experiments were limited proteolyis coupled to
mass spectrometry (LiP-MS) experiments conducted on purified proteins. The first protein is
phosphoglycerate kinase 1 (pgk) and it was treated with 25mM 3-phosphoglyceric acid (3PG).
The second protein is phosphoenolpyruvate-protein phosphotransferase (ptsI) and it was treated
with 25mM fructose 1,6-bisphosphatase (FBP). From both experiments only peptides belonging to
either protein were used for this data set. The ptsI data set contains precursor level data
while the pgk data set contains peptide level data. The pgk data can be obtained from
supplementary table 3 from the tab named &quot;pgk+3PG&quot;. The ptsI data is only included as raw data
and was analysed using the functions of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptsi_pgk
</code></pre>


<h3>Format</h3>

<p>A data frame containing differential abundances and adjusted p-values for
peptides/precursors of two proteins.
</p>


<h3>Source</h3>

<p>Cappelletti V, Hauser T, Piazza I, Pepelnjak M, Malinovska L, Fuhrer T, Li Y, Drig C,
Boersema P, Gillet L, Grossbach J, Dugourd A, Saez-Rodriguez J, Beyer A, Zamboni N, Caflisch A,
de Souza N, Picotti P. Dynamic 3D proteomes reveal protein functional alterations at high
resolution in situ. Cell. 2021 Jan 21;184(2):545-559.e22. <a href="https://doi.org/10.1016/j.cell.2020.12.021">doi:10.1016/j.cell.2020.12.021</a>.
Epub 2020 Dec 23. PMID: 33357446; PMCID: PMC7836100.
</p>

<hr>
<h2 id='pval_distribution_plot'>Plot histogram of p-value distribution</h2><span id='topic+pval_distribution_plot'></span>

<h3>Description</h3>

<p>Plots the distribution of p-values derived from any statistical test as a histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval_distribution_plot(data, grouping, pval, facet_by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval_distribution_plot_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least grouping identifiers (precursor, peptide or
protein) and p-values derived from any statistical test.</p>
</td></tr>
<tr><td><code id="pval_distribution_plot_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains either precursor,
peptide or protein identifiers. For each entry in this column there should be one unique p-value.
That means the statistical test that created the p-value should have been performed on the
level of the content of this column.</p>
</td></tr>
<tr><td><code id="pval_distribution_plot_+3A_pval">pval</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains p-values.</p>
</td></tr>
<tr><td><code id="pval_distribution_plot_+3A_facet_by">facet_by</code></td>
<td>
<p>optional, a character column that contains information by which the data should
be faceted into multiple plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A histogram plot that shows the p-value distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create example data
data &lt;- data.frame(
  peptide = paste0("peptide", 1:1000),
  pval = runif(n = 1000)
)

# Plot p-values
pval_distribution_plot(
  data = data,
  grouping = peptide,
  pval = pval
)
</code></pre>

<hr>
<h2 id='qc_charge_states'>Check charge state distribution</h2><span id='topic+qc_charge_states'></span>

<h3>Description</h3>

<p>Calculates the charge state distribution for each sample (by count or intensity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_charge_states(
  data,
  sample,
  grouping,
  charge_states,
  intensity = NULL,
  remove_na_intensities = TRUE,
  method = "count",
  plot = FALSE,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_charge_states_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least sample names, peptide or precursor identifiers
and missed cleavage counts for each peptide or precursor.</p>
</td></tr>
<tr><td><code id="qc_charge_states_+3A_sample">sample</code></td>
<td>
<p>a character or factor column in the <code>data</code> data frame that contains the sample name.</p>
</td></tr>
<tr><td><code id="qc_charge_states_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains either precursor or
peptide identifiers.</p>
</td></tr>
<tr><td><code id="qc_charge_states_+3A_charge_states">charge_states</code></td>
<td>
<p>a character or numeric column in the <code>data</code> data frame that contains
the different charge states assigned to the precursor or peptide.</p>
</td></tr>
<tr><td><code id="qc_charge_states_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the corresponding
raw or normalised intensity values (not log2) for each peptide or precursor. Required when
&quot;intensity&quot; is chosen as the method.</p>
</td></tr>
<tr><td><code id="qc_charge_states_+3A_remove_na_intensities">remove_na_intensities</code></td>
<td>
<p>a logical value that specifies if sample/grouping combinations with
intensities that are NA (not quantified IDs) should be dropped from the data frame for analysis
of missed cleavages. Default is TRUE since we are usually interested in quantifiable peptides.
This is only relevant for method = &quot;count&quot;.</p>
</td></tr>
<tr><td><code id="qc_charge_states_+3A_method">method</code></td>
<td>
<p>a character value that indicates the method used for evaluation. &quot;count&quot;
calculates the charge state distribution based on counts of the corresponding peptides or
precursors in the charge state group, &quot;intensity&quot; calculates the percentage of precursors or
peptides in each charge state group based on the corresponding intensity values.</p>
</td></tr>
<tr><td><code id="qc_charge_states_+3A_plot">plot</code></td>
<td>
<p>a logical value that indicates whether the result should be plotted.</p>
</td></tr>
<tr><td><code id="qc_charge_states_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive
(default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the calculated percentage made up by the sum of either
all counts or intensities of peptides or precursors of the corresponding charge state
(depending on which method is chosen).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load libraries
library(dplyr)

set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
) %&gt;%
  mutate(intensity_non_log2 = 2^peptide_intensity_missing)

# Calculate charge percentages
qc_charge_states(
  data = data,
  sample = sample,
  grouping = peptide,
  charge_states = charge,
  intensity = intensity_non_log2,
  method = "intensity",
  plot = FALSE
)

# Plot charge states
qc_charge_states(
  data = data,
  sample = sample,
  grouping = peptide,
  charge_states = charge,
  intensity = intensity_non_log2,
  method = "intensity",
  plot = TRUE
)
</code></pre>

<hr>
<h2 id='qc_contaminants'>Percentage of contaminants per sample</h2><span id='topic+qc_contaminants'></span>

<h3>Description</h3>

<p>Calculates the percentage of contaminating proteins as the share of total intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_contaminants(
  data,
  sample,
  protein,
  is_contaminant,
  intensity,
  n_contaminants = 5,
  plot = TRUE,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_contaminants_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="qc_contaminants_+3A_sample">sample</code></td>
<td>
<p>a character or factor column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="qc_contaminants_+3A_protein">protein</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains protein IDs or
protein names.</p>
</td></tr>
<tr><td><code id="qc_contaminants_+3A_is_contaminant">is_contaminant</code></td>
<td>
<p>a logical column that indicates if the protein is a contaminant.</p>
</td></tr>
<tr><td><code id="qc_contaminants_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the corresponding
raw or normalised intensity values (not log2).</p>
</td></tr>
<tr><td><code id="qc_contaminants_+3A_n_contaminants">n_contaminants</code></td>
<td>
<p>a numeric value that indicates how many contaminants should be displayed
individually. The rest is combined to a group called &quot;other&quot;. The default is 5.</p>
</td></tr>
<tr><td><code id="qc_contaminants_+3A_plot">plot</code></td>
<td>
<p>a logical value that indicates if a plot is returned. If FALSE a table is returned.</p>
</td></tr>
<tr><td><code id="qc_contaminants_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that indicates if the plot is made interactive using the r
package <code>plotly</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bar plot that displays the percentage of contaminating proteins over all samples.
If <code>plot = FALSE</code> a data frame is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  sample = c(rep("sample_1", 10), rep("sample_2", 10)),
  leading_razor_protein = c(rep(c("P1", "P1", "P1", "P2", "P2", "P2", "P2", "P3", "P3", "P3"), 2)),
  potential_contaminant = c(rep(c(rep(TRUE, 7), rep(FALSE, 3)), 2)),
  intensity = c(rep(1, 2), rep(4, 4), rep(6, 4), rep(2, 3), rep(3, 5), rep(4, 2))
)

qc_contaminants(
  data,
  sample = sample,
  protein = leading_razor_protein,
  is_contaminant = potential_contaminant,
  intensity = intensity
)
</code></pre>

<hr>
<h2 id='qc_cvs'>Check CV distribution</h2><span id='topic+qc_cvs'></span>

<h3>Description</h3>

<p>Calculates and plots the coefficients of variation for the selected grouping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_cvs(
  data,
  grouping,
  condition,
  intensity,
  plot = TRUE,
  plot_style = "density",
  max_cv = 200
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_cvs_+3A_data">data</code></td>
<td>
<p>a data frame containing at least peptide, precursor or protein identifiers,
information on conditions and intensity values for each peptide, precursor or protein.</p>
</td></tr>
<tr><td><code id="qc_cvs_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the grouping
variables (e.g. peptides, precursors or proteins).</p>
</td></tr>
<tr><td><code id="qc_cvs_+3A_condition">condition</code></td>
<td>
<p>a character or factor column in the <code>data</code> data frame that contains condition information
(e.g. &quot;treated&quot; and &quot;control&quot;).</p>
</td></tr>
<tr><td><code id="qc_cvs_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the corresponding
raw or untransformed normalised intensity values for each peptide or precursor.</p>
</td></tr>
<tr><td><code id="qc_cvs_+3A_plot">plot</code></td>
<td>
<p>a logical value that indicates whether the result should be plotted.</p>
</td></tr>
<tr><td><code id="qc_cvs_+3A_plot_style">plot_style</code></td>
<td>
<p>a character value that indicates the plotting style. <code>plot_style = "boxplot"</code>
plots a boxplot, whereas <code>plot_style = "density"</code> plots the CV density distribution.
<code>plot_style = "violin"</code> returns a violin plot. Default is <code>plot_style = "density"</code>.</p>
</td></tr>
<tr><td><code id="qc_cvs_+3A_max_cv">max_cv</code></td>
<td>
<p>a numeric value that specifies the maximum percentage of CVs that should be included
in the returned plot. The default value is <code>max_cv = 200</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a data frame with the median CVs in % or a plot showing the distribution of the CVs
is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load libraries
library(dplyr)

set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
) %&gt;%
  mutate(intensity_non_log2 = 2^peptide_intensity_missing)

# Calculate coefficients of variation
qc_cvs(
  data = data,
  grouping = peptide,
  condition = condition,
  intensity = intensity_non_log2,
  plot = FALSE
)

# Plot coefficients of variation
# Different plot styles are available
qc_cvs(
  data = data,
  grouping = peptide,
  condition = condition,
  intensity = intensity_non_log2,
  plot = TRUE,
  plot_style = "violin"
)
</code></pre>

<hr>
<h2 id='qc_data_completeness'>Data completeness</h2><span id='topic+qc_data_completeness'></span>

<h3>Description</h3>

<p>Calculates the percentage of data completeness. That means, what percentage of all detected
precursors is present in each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_data_completeness(
  data,
  sample,
  grouping,
  intensity,
  digestion = NULL,
  plot = TRUE,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_data_completeness_+3A_data">data</code></td>
<td>
<p>a data frame containing at least the input variables.</p>
</td></tr>
<tr><td><code id="qc_data_completeness_+3A_sample">sample</code></td>
<td>
<p>a character or factor column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="qc_data_completeness_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains either precursor
or peptide identifiers.</p>
</td></tr>
<tr><td><code id="qc_data_completeness_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains any intensity
intensity values that missingness should be determined for.</p>
</td></tr>
<tr><td><code id="qc_data_completeness_+3A_digestion">digestion</code></td>
<td>
<p>optional, a character column in the <code>data</code> data frame that indicates the
mode of digestion (limited proteolysis or tryptic digest). Alternatively, any other variable
by which the data should be split can be provided.</p>
</td></tr>
<tr><td><code id="qc_data_completeness_+3A_plot">plot</code></td>
<td>
<p>a logical value that indicates whether the result should be plotted.</p>
</td></tr>
<tr><td><code id="qc_data_completeness_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive
(default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bar plot that displays the percentage of data completeness over all samples.
If <code>plot = FALSE</code> a data frame is returned. If <code>interactive = TRUE</code>, the plot is
interactive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
)

# Determine data completeness
qc_data_completeness(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  plot = FALSE
)

# Plot data completeness
qc_data_completeness(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  plot = TRUE
)
</code></pre>

<hr>
<h2 id='qc_ids'>Check number of precursor, peptide or protein IDs</h2><span id='topic+qc_ids'></span>

<h3>Description</h3>

<p>Returns a plot or table of the number of IDs for each sample. The default settings remove
grouping variables without quantitative information (intensity is NA). These will not be
counted as IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_ids(
  data,
  sample,
  grouping,
  intensity,
  remove_na_intensities = TRUE,
  condition = NULL,
  title = "ID count per sample",
  plot = TRUE,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_ids_+3A_data">data</code></td>
<td>
<p>a data frame containing at least sample names and precursor/peptide/protein IDs.</p>
</td></tr>
<tr><td><code id="qc_ids_+3A_sample">sample</code></td>
<td>
<p>a character or factor column in the <code>data</code> data frame that contains the sample name.</p>
</td></tr>
<tr><td><code id="qc_ids_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains either precursor or
peptide identifiers.</p>
</td></tr>
<tr><td><code id="qc_ids_+3A_intensity">intensity</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains raw or log2
transformed intensities. If <code>remove_na_intensities = FALSE</code>, this argument is optional.</p>
</td></tr>
<tr><td><code id="qc_ids_+3A_remove_na_intensities">remove_na_intensities</code></td>
<td>
<p>a logical value that specifies if sample/grouping combinations with
intensities that are NA (not quantified IDs) should be dropped from the data frame. Default is
TRUE since we are usually interested in the number of quantifiable IDs.</p>
</td></tr>
<tr><td><code id="qc_ids_+3A_condition">condition</code></td>
<td>
<p>optional, a column in the <code>data</code> data frame that contains condition information
(e.g. &quot;treated&quot; and &quot;control&quot;). If this column is provided, the bars in the plot will be coloured
according to the condition.</p>
</td></tr>
<tr><td><code id="qc_ids_+3A_title">title</code></td>
<td>
<p>optional, a character value that specifies the plot title (default is &quot;ID count
per sample&quot;).</p>
</td></tr>
<tr><td><code id="qc_ids_+3A_plot">plot</code></td>
<td>
<p>a logical value that indicates whether the result should be plotted.</p>
</td></tr>
<tr><td><code id="qc_ids_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive
(default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bar plot with the height corresponding to the number of IDs, each bar represents one
sample (if <code>plot = TRUE</code>). If <code>plot = FALSE</code> a table with ID counts is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
)

# Calculate number of identifications
qc_ids(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  condition = condition,
  plot = FALSE
)

# Plot number of identifications
qc_ids(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  condition = condition,
  plot = TRUE
)
</code></pre>

<hr>
<h2 id='qc_intensity_distribution'>Check intensity distribution per sample and overall</h2><span id='topic+qc_intensity_distribution'></span>

<h3>Description</h3>

<p>Plots the overall or sample-wise distribution of all peptide intensities as a boxplot or
histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_intensity_distribution(
  data,
  sample = NULL,
  grouping,
  intensity_log2,
  plot_style
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_intensity_distribution_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least sample names, grouping identifiers (precursor,
peptide or protein) and log2 transformed intensities for each grouping identifier.</p>
</td></tr>
<tr><td><code id="qc_intensity_distribution_+3A_sample">sample</code></td>
<td>
<p>an optional character or factor column in the <code>data</code> data frame that contains the
sample name. If the sample column is of type factor, the ordering is based on the factor
levels. NOTE: If the overall distribution should be returned please do not provide the name of the
sample column.</p>
</td></tr>
<tr><td><code id="qc_intensity_distribution_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the grouping
variables (e.g. peptides, precursors or proteins).</p>
</td></tr>
<tr><td><code id="qc_intensity_distribution_+3A_intensity_log2">intensity_log2</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the log2
transformed intensities of each grouping identifier sample combination.</p>
</td></tr>
<tr><td><code id="qc_intensity_distribution_+3A_plot_style">plot_style</code></td>
<td>
<p>a character value that indicates the plot type. This can be either
&quot;histogram&quot;, &quot;boxplot&quot; or &quot;violin&quot;. Plot style &quot;boxplot&quot; and &quot;violin&quot; can only be used if a
sample column is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A histogram or boxplot that shows the intensity distribution over all samples or by
sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
)

# Plot intensity distribution
# The plot style can be changed
qc_intensity_distribution(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity_log2 = peptide_intensity_missing,
  plot_style = "boxplot"
)
</code></pre>

<hr>
<h2 id='qc_median_intensities'>Median run intensities</h2><span id='topic+qc_median_intensities'></span>

<h3>Description</h3>

<p>Median intensities per run are returned either as a plot or a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_median_intensities(
  data,
  sample,
  grouping,
  intensity,
  plot = TRUE,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_median_intensities_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="qc_median_intensities_+3A_sample">sample</code></td>
<td>
<p>a character or factor column in the <code>data</code> data frame that contains the sample name.</p>
</td></tr>
<tr><td><code id="qc_median_intensities_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains either precursor or
peptide identifiers.</p>
</td></tr>
<tr><td><code id="qc_median_intensities_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains intensity values.
The intensity should be ideally log2 transformed, but also non-transformed values can be used.</p>
</td></tr>
<tr><td><code id="qc_median_intensities_+3A_plot">plot</code></td>
<td>
<p>a logical value that indicates whether the result should be plotted.</p>
</td></tr>
<tr><td><code id="qc_median_intensities_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive
(default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot that displays median intensity over all samples. If <code>plot = FALSE</code> a data
frame containing median intensities is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
)

# Calculate median intensities
qc_median_intensities(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  plot = FALSE
)

# Plot median intensities
qc_median_intensities(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  plot = TRUE
)
</code></pre>

<hr>
<h2 id='qc_missed_cleavages'>Check missed cleavages</h2><span id='topic+qc_missed_cleavages'></span>

<h3>Description</h3>

<p>Calculates the percentage of missed cleavages for each sample (by count or intensity). The
default settings remove grouping variables without quantitative information (intensity is NA).
These will not be used for the calculation of missed cleavage percentages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_missed_cleavages(
  data,
  sample,
  grouping,
  missed_cleavages,
  intensity,
  remove_na_intensities = TRUE,
  method = "count",
  plot = FALSE,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_missed_cleavages_+3A_data">data</code></td>
<td>
<p>a data frame containing at least sample names, peptide or precursor identifiers
and missed cleavage counts for each peptide or precursor.</p>
</td></tr>
<tr><td><code id="qc_missed_cleavages_+3A_sample">sample</code></td>
<td>
<p>a character or factor column in the <code>data</code> data frame that contains the sample name.</p>
</td></tr>
<tr><td><code id="qc_missed_cleavages_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains either precursor or
peptide identifiers.</p>
</td></tr>
<tr><td><code id="qc_missed_cleavages_+3A_missed_cleavages">missed_cleavages</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the counts
of missed cleavages per peptide or precursor.</p>
</td></tr>
<tr><td><code id="qc_missed_cleavages_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the corresponding
raw or normalised intensity values (not log2) for each peptide or precursor. Required when
&quot;intensity&quot; is chosen as the method.</p>
</td></tr>
<tr><td><code id="qc_missed_cleavages_+3A_remove_na_intensities">remove_na_intensities</code></td>
<td>
<p>a logical value that specifies if sample/grouping combinations with
intensities that are NA (not quantified IDs) should be dropped from the data frame for analysis
of missed cleavages. Default is TRUE since we are usually interested in quantifiable peptides.
This is only relevant for method = &quot;count&quot;.</p>
</td></tr>
<tr><td><code id="qc_missed_cleavages_+3A_method">method</code></td>
<td>
<p>a character value that indicates the method used for evaluation. &quot;count&quot;
calculates the percentage of missed cleavages based on counts of the corresponding peptide or
precursor, &quot;intensity&quot; calculates the percentage of missed cleavages by intensity of the
corresponding peptide or precursor.</p>
</td></tr>
<tr><td><code id="qc_missed_cleavages_+3A_plot">plot</code></td>
<td>
<p>a logical value that indicates whether the result should be plotted.</p>
</td></tr>
<tr><td><code id="qc_missed_cleavages_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive
(default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the calculated percentage made up by the sum of all peptides
or precursors containing the corresponding amount of missed cleavages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
) %&gt;%
  mutate(intensity_non_log2 = 2^peptide_intensity_missing)

# Calculate missed cleavage percentages
qc_missed_cleavages(
  data = data,
  sample = sample,
  grouping = peptide,
  missed_cleavages = n_missed_cleavage,
  intensity = intensity_non_log2,
  method = "intensity",
  plot = FALSE
)

# Plot missed cleavages
qc_missed_cleavages(
  data = data,
  sample = sample,
  grouping = peptide,
  missed_cleavages = n_missed_cleavage,
  intensity = intensity_non_log2,
  method = "intensity",
  plot = TRUE
)
</code></pre>

<hr>
<h2 id='qc_pca'>Plot principal component analysis</h2><span id='topic+qc_pca'></span>

<h3>Description</h3>

<p>Plots a principal component analysis based on peptide or precursor intensities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_pca(
  data,
  sample,
  grouping,
  intensity,
  condition,
  components = c("PC1", "PC2"),
  digestion = NULL,
  plot_style = "pca"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_pca_+3A_data">data</code></td>
<td>
<p>a data frame that contains sample names, peptide or precursor identifiers,
corresponding intensities and a condition column indicating e.g. the treatment.</p>
</td></tr>
<tr><td><code id="qc_pca_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample name.</p>
</td></tr>
<tr><td><code id="qc_pca_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains either precursor
or peptide identifiers.</p>
</td></tr>
<tr><td><code id="qc_pca_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the corresponding
intensity values for each peptide or precursor.</p>
</td></tr>
<tr><td><code id="qc_pca_+3A_condition">condition</code></td>
<td>
<p>a numeric or character column in the <code>data</code> data frame that contains condition information
(e.g. &quot;treated&quot; and &quot;control&quot;).</p>
</td></tr>
<tr><td><code id="qc_pca_+3A_components">components</code></td>
<td>
<p>a character vector indicating the two components that should be displayed in
the plot. By default these are PC1 and PC2. You can provide these using a character vector of
the form c(&quot;PC1&quot;, &quot;PC2&quot;).</p>
</td></tr>
<tr><td><code id="qc_pca_+3A_digestion">digestion</code></td>
<td>
<p>optional, a character column in the <code>data</code> data frame that indicates the
mode of digestion (limited proteolysis or tryptic digest). Alternatively, any other variable
by which the data should be split can be provided.</p>
</td></tr>
<tr><td><code id="qc_pca_+3A_plot_style">plot_style</code></td>
<td>
<p>a character value that specifies what plot should be returned. If
<code>plot_style = "pca"</code> is selected the two PCA components supplied with the <code>components</code> argument
are plottet against each other. This is the default. <code>plot_style = "scree"</code> returns a scree
plot that displays the variance explained by each principal component in percent. The scree is
useful for checking if any other than the default first two components should be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A principal component analysis plot showing PC1 and PC2. If <code>plot_style = "scree"</code>, a
scree plot for all dimensions is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
)

# Plot scree plot
qc_pca(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  condition = condition,
  plot_style = "scree"
)

# Plot principal components
qc_pca(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  condition = condition
)
</code></pre>

<hr>
<h2 id='qc_peak_width'>Peak width over retention time</h2><span id='topic+qc_peak_width'></span>

<h3>Description</h3>

<p>Plots one minute binned median precursor elution peak width over retention time for each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_peak_width(
  data,
  sample,
  intensity,
  retention_time,
  peak_width = NULL,
  retention_time_start = NULL,
  retention_time_end = NULL,
  remove_na_intensities = TRUE,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_peak_width_+3A_data">data</code></td>
<td>
<p>a data frame containing at least sample names and protein IDs.</p>
</td></tr>
<tr><td><code id="qc_peak_width_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="qc_peak_width_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains intensities. If
<code>remove_na_intensities = FALSE</code>, this argument is not required.</p>
</td></tr>
<tr><td><code id="qc_peak_width_+3A_retention_time">retention_time</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains retention
times of precursors.</p>
</td></tr>
<tr><td><code id="qc_peak_width_+3A_peak_width">peak_width</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains peak width
information. It is not required if <code>retention_time_start</code> and <code>retention_time_end</code>
columns are provided.</p>
</td></tr>
<tr><td><code id="qc_peak_width_+3A_retention_time_start">retention_time_start</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the
start time of the precursor elution peak. It is not required if the <code>peak_width</code> column
is provided.</p>
</td></tr>
<tr><td><code id="qc_peak_width_+3A_retention_time_end">retention_time_end</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the end
time of the precursor elution peak. It is not required if the <code>peak_width</code> column is
provided.</p>
</td></tr>
<tr><td><code id="qc_peak_width_+3A_remove_na_intensities">remove_na_intensities</code></td>
<td>
<p>a logical value that specifies if sample/grouping combinations
with intensities that are NA (not quantified IDs) should be dropped from the data frame.
Default is TRUE since we are usually interested in the peak width of quantifiable data.</p>
</td></tr>
<tr><td><code id="qc_peak_width_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive
(default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line plot displaying one minute binned median precursor elution peak width over
retention time for each sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- data.frame(
  r_file_name = c(rep("sample_1", 10), rep("sample2", 10)),
  fg_quantity = c(rep(2000, 20)),
  eg_mean_apex_rt = c(rep(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 2)),
  eg_start_rt = c(0.5, 1, 3, 4, 5, 6, 7, 7.5, 8, 9, 1, 2, 2, 3, 4, 5, 5, 8, 9, 9),
  eg_end_rt = c(
    1.5, 2, 3.1, 4.5, 5.8, 6.6, 8, 8, 8.4,
    9.1, 3, 2.2, 4, 3.4, 4.5, 5.5, 5.6, 8.3, 10, 12
  )
)
qc_peak_width(
  data,
  sample = r_file_name,
  intensity = fg_quantity,
  retention_time = eg_mean_apex_rt,
  retention_time_start = eg_start_rt,
  retention_time_end = eg_end_rt
)
</code></pre>

<hr>
<h2 id='qc_peptide_type'>Check peptide type percentage share</h2><span id='topic+qc_peptide_type'></span>

<h3>Description</h3>

<p>Calculates the percentage share of each peptide types (fully-tryptic, semi-tryptic,
non-tryptic) for each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_peptide_type(
  data,
  sample,
  peptide,
  pep_type,
  intensity,
  remove_na_intensities = TRUE,
  method = "count",
  plot = FALSE,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_peptide_type_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input columns.</p>
</td></tr>
<tr><td><code id="qc_peptide_type_+3A_sample">sample</code></td>
<td>
<p>a character or factor column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="qc_peptide_type_+3A_peptide">peptide</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the peptide
sequence.</p>
</td></tr>
<tr><td><code id="qc_peptide_type_+3A_pep_type">pep_type</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the peptide
type. Can be obtained using the <code>find_peptide</code> and <code>assign_peptide_type</code> function
together.</p>
</td></tr>
<tr><td><code id="qc_peptide_type_+3A_intensity">intensity</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the corresponding
raw or normalised intensity values (not log2) for each peptide or precursor. Required when
&quot;intensity&quot; is chosen as the method.</p>
</td></tr>
<tr><td><code id="qc_peptide_type_+3A_remove_na_intensities">remove_na_intensities</code></td>
<td>
<p>a logical value that specifies if sample/peptide combinations with
intensities that are NA (not quantified IDs) should be dropped from the data frame for analysis
of peptide type distributions. Default is TRUE since we are usually interested in the peptide
type distribution of quantifiable IDs. This is only relevant for method = &quot;count&quot;.</p>
</td></tr>
<tr><td><code id="qc_peptide_type_+3A_method">method</code></td>
<td>
<p>a character value that indicates the method used for evaluation.
<code>method = "intensity"</code> calculates the peptide type percentage by intensity, whereas
<code>method = "count"</code> calculates the percentage by peptide ID count. Default is
<code>method = count</code>.</p>
</td></tr>
<tr><td><code id="qc_peptide_type_+3A_plot">plot</code></td>
<td>
<p>a logical value that indicates whether the result should be plotted.</p>
</td></tr>
<tr><td><code id="qc_peptide_type_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that indicates whether the plot should be interactive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the calculated percentage shares of each peptide type per
sample. The <code>count</code> column contains the number of peptides with a specific type. The
<code>peptide_type_percent</code> column contains the percentage share of a specific peptide type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load libraries
library(dplyr)

set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
) %&gt;%
  mutate(intensity_non_log2 = 2^peptide_intensity_missing)

# Determine peptide type percentages
qc_peptide_type(
  data = data,
  sample = sample,
  peptide = peptide,
  pep_type = pep_type,
  intensity = intensity_non_log2,
  method = "intensity",
  plot = FALSE
)

# Plot peptide type
qc_peptide_type(
  data = data,
  sample = sample,
  peptide = peptide,
  pep_type = pep_type,
  intensity = intensity_non_log2,
  method = "intensity",
  plot = TRUE
)
</code></pre>

<hr>
<h2 id='qc_proteome_coverage'>Proteome coverage per sample and total</h2><span id='topic+qc_proteome_coverage'></span>

<h3>Description</h3>

<p>Calculates the proteome coverage for each samples and for all samples combined. In other words t
he fraction of detected proteins to all proteins in the proteome is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_proteome_coverage(
  data,
  sample,
  protein_id,
  organism_id,
  reviewed = TRUE,
  plot = TRUE,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_proteome_coverage_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least sample names and protein ID's.</p>
</td></tr>
<tr><td><code id="qc_proteome_coverage_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample name.</p>
</td></tr>
<tr><td><code id="qc_proteome_coverage_+3A_protein_id">protein_id</code></td>
<td>
<p>a character or numeric column in the <code>data</code> data frame that contains
protein identifiers such as UniProt accessions.</p>
</td></tr>
<tr><td><code id="qc_proteome_coverage_+3A_organism_id">organism_id</code></td>
<td>
<p>a numeric value that specifies a NCBI taxonomy identifier (TaxId) of the
organism used. Human: 9606, S. cerevisiae: 559292, E. coli: 83333.</p>
</td></tr>
<tr><td><code id="qc_proteome_coverage_+3A_reviewed">reviewed</code></td>
<td>
<p>a logical value that determines if only reviewed protein entries will be considered
as the full proteome. Default is TRUE.</p>
</td></tr>
<tr><td><code id="qc_proteome_coverage_+3A_plot">plot</code></td>
<td>
<p>a logical value that specifies whether the result should be plotted.</p>
</td></tr>
<tr><td><code id="qc_proteome_coverage_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that indicates whether the plot should be interactive
(default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bar plot showing the percentage of of the proteome detected and undetected in total
and for each sample. If <code>plot = FALSE</code> a data frame containing the numbers is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create example data
proteome &lt;- data.frame(id = 1:4518)
data &lt;- data.frame(
  sample = c(rep("A", 101), rep("B", 1000), rep("C", 1000)),
  protein_id = c(proteome$id[1:100], proteome$id[1:1000], proteome$id[1000:2000])
)

# Calculate proteome coverage
qc_proteome_coverage(
  data = data,
  sample = sample,
  protein_id = protein_id,
  organism_id = 83333,
  plot = FALSE
)

# Plot proteome coverage
qc_proteome_coverage(
  data = data,
  sample = sample,
  protein_id = protein_id,
  organism_id = 83333,
  plot = TRUE
)

</code></pre>

<hr>
<h2 id='qc_ranked_intensities'>Check ranked intensities</h2><span id='topic+qc_ranked_intensities'></span>

<h3>Description</h3>

<p>Calculates and plots ranked intensities for proteins, peptides or precursors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_ranked_intensities(
  data,
  sample,
  grouping,
  intensity_log2,
  facet = FALSE,
  plot = FALSE,
  y_axis_transformation = "log10",
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_ranked_intensities_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least sample names, grouping identifiers (precursor,
peptide or protein) and log2 transformed intensities for each grouping identifier.</p>
</td></tr>
<tr><td><code id="qc_ranked_intensities_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="qc_ranked_intensities_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains protein, precursor,
or peptide identifiers.</p>
</td></tr>
<tr><td><code id="qc_ranked_intensities_+3A_intensity_log2">intensity_log2</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the log2
transformed intensities of the selected grouping variable.</p>
</td></tr>
<tr><td><code id="qc_ranked_intensities_+3A_facet">facet</code></td>
<td>
<p>a logical value that specifies whether the calculation should be done group wise by
sample and if the resulting plot should be faceted by sample. (default is <code>FALSE</code>).
If <code>facet = FALSE</code> the median of each protein intensity will be returned.</p>
</td></tr>
<tr><td><code id="qc_ranked_intensities_+3A_plot">plot</code></td>
<td>
<p>a logical value that specifies whether the result should be plotted (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="qc_ranked_intensities_+3A_y_axis_transformation">y_axis_transformation</code></td>
<td>
<p>a character value that determines that y-axis transformation. The
value is either &quot;log2&quot; or &quot;log10&quot; (default is &quot;log10&quot;).</p>
</td></tr>
<tr><td><code id="qc_ranked_intensities_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the ranked intensities is returned. If <code>plot = TRUE</code> a plot
is returned. The intensities are log10 transformed for the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create synthetic data
data &lt;- create_synthetic_data(
  n_proteins = 50,
  frac_change = 0.05,
  n_replicates = 4,
  n_conditions = 3,
  method = "effect_random",
  additional_metadata = FALSE
)

# Plot ranked intensities for all samples combined
qc_ranked_intensities(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity_log2 = peptide_intensity,
  plot = TRUE,
)

# Plot ranked intensities for each sample separately
qc_ranked_intensities(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity_log2 = peptide_intensity,
  plot = TRUE,
  facet = TRUE
)

</code></pre>

<hr>
<h2 id='qc_sample_correlation'>Correlation based hirachical clustering of samples</h2><span id='topic+qc_sample_correlation'></span>

<h3>Description</h3>

<p>A correlation heatmap is created that uses hirachical clustering to determine sample similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_sample_correlation(
  data,
  sample,
  grouping,
  intensity_log2,
  condition,
  digestion = NULL,
  run_order = NULL,
  method = "spearman",
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_sample_correlation_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="qc_sample_correlation_+3A_sample">sample</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the sample names.</p>
</td></tr>
<tr><td><code id="qc_sample_correlation_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains precursor or
peptide identifiers.</p>
</td></tr>
<tr><td><code id="qc_sample_correlation_+3A_intensity_log2">intensity_log2</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains log2
intensity values.</p>
</td></tr>
<tr><td><code id="qc_sample_correlation_+3A_condition">condition</code></td>
<td>
<p>a character or numeric column in the <code>data</code> data frame that contains the
conditions.</p>
</td></tr>
<tr><td><code id="qc_sample_correlation_+3A_digestion">digestion</code></td>
<td>
<p>optional, a character column in the <code>data</code> data frame that contains
information about the digestion method used. e.g. &quot;LiP&quot; or &quot;tryptic control&quot;.</p>
</td></tr>
<tr><td><code id="qc_sample_correlation_+3A_run_order">run_order</code></td>
<td>
<p>optional, a character or numeric column in the <code>data</code> data frame that
contains the order in which samples were measured. Useful to investigate batch effects due to
run order.</p>
</td></tr>
<tr><td><code id="qc_sample_correlation_+3A_method">method</code></td>
<td>
<p>a character value that specifies the method to be used for correlation.
<code>"spearman"</code> is the default but can be changed to <code>"pearson"</code> or <code>"kendall"</code>.</p>
</td></tr>
<tr><td><code id="qc_sample_correlation_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive.
Determines if an interactive or static heatmap should be created using <code>heatmaply</code> or
<code>pheatmap</code>, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation heatmap that compares each sample. The dendrogram is sorted by optimal
leaf ordering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
)

# Create sample correlation heatmap
qc_sample_correlation(
  data = data,
  sample = sample,
  grouping = peptide,
  intensity_log2 = peptide_intensity_missing,
  condition = condition
)

</code></pre>

<hr>
<h2 id='qc_sequence_coverage'>Protein coverage distribution</h2><span id='topic+qc_sequence_coverage'></span>

<h3>Description</h3>

<p>Plots the distribution of protein coverages in a histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_sequence_coverage(
  data,
  protein_identifier,
  coverage,
  sample = NULL,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_sequence_coverage_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="qc_sequence_coverage_+3A_protein_identifier">protein_identifier</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains protein
identifiers.</p>
</td></tr>
<tr><td><code id="qc_sequence_coverage_+3A_coverage">coverage</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains protein coverage
in percent. This information can be obtained using the <code><a href="#topic+sequence_coverage">sequence_coverage</a></code> function.</p>
</td></tr>
<tr><td><code id="qc_sequence_coverage_+3A_sample">sample</code></td>
<td>
<p>optional, a character or factor column in the <code>data</code> data frame that contains sample names.
Please only provide this argument if you want to facet the distribution plot by sample
otherwise do not provide this argument.</p>
</td></tr>
<tr><td><code id="qc_sequence_coverage_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive
(default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A protein coverage histogram with 5 percent binwidth. The vertical dotted line
indicates the median.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sequence_coverage">sequence_coverage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create example data
data &lt;- create_synthetic_data(
  n_proteins = 100,
  frac_change = 0.05,
  n_replicates = 3,
  n_conditions = 2,
  method = "effect_random"
)

# Plot sequence coverage
qc_sequence_coverage(
  data = data,
  protein_identifier = protein,
  coverage = coverage
)
</code></pre>

<hr>
<h2 id='randomise_queue'>Randomise samples in MS queue</h2><span id='topic+randomise_queue'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This function randomises the order of samples in an MS queue. QC and Blank samples are left in
place. It is also possible to randomise only parts of the queue. Before running this make sure
to set a specific seed with the <code>set.seed()</code> function. This ensures that the randomisation
of the result is consistent if the function is run again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomise_queue(data = NULL, rows = NULL, export = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomise_queue_+3A_data">data</code></td>
<td>
<p>optional, a data frame that contains a queue. If not provided a queue file can be
chosen interactively.</p>
</td></tr>
<tr><td><code id="randomise_queue_+3A_rows">rows</code></td>
<td>
<p>optional, a numeric vector that specifies a range of rows in for which samples
should be randomized.</p>
</td></tr>
<tr><td><code id="randomise_queue_+3A_export">export</code></td>
<td>
<p>a logical value that determines if a <code>"randomised_queue.csv"</code> file will be
saved in the working directory. If FALSE a data frame will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>export = TRUE</code> a <code>"randomised_queue.csv"</code> file will be saved in the
working directory. If <code>export = FALSE</code> a data frame that contains the randomised queue
is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>queue &lt;- create_queue(
  date = c("200722"),
  instrument = c("EX1"),
  user = c("jquast"),
  measurement_type = c("DIA"),
  experiment_name = c("JPQ031"),
  digestion = c("LiP", "tryptic control"),
  treatment_type_1 = c("EDTA", "H2O"),
  treatment_type_2 = c("Zeba", "unfiltered"),
  treatment_dose_1 = c(10, 30, 60),
  treatment_unit_1 = c("min"),
  n_replicates = 4,
  number_runs = FALSE,
  organism = c("E. coli"),
  exclude_combinations = list(list(
    treatment_type_1 = c("H2O"),
    treatment_type_2 = c("Zeba", "unfiltered"),
    treatment_dose_1 = c(10, 30)
  )),
  inj_vol = c(2),
  data_path = "D:\\2007_Data",
  method_path = "C:\\Xcalibur\\methods\\DIA_120min",
  position_row = c("A", "B", "C", "D", "E", "F"),
  position_column = 8,
  blank_every_n = 4,
  blank_position = "1-V1",
  blank_method_path = "C:\\Xcalibur\\methods\\blank"
)

head(queue, n = 20)

randomised_queue &lt;- randomise_queue(
  data = queue,
  export = FALSE
)

head(randomised_queue, n = 20)
</code></pre>

<hr>
<h2 id='rapamycin_10uM'>Rapamycin 10 uM example data</h2><span id='topic+rapamycin_10uM'></span>

<h3>Description</h3>

<p>Rapamycin example data used for the vignette about binary control/treated data. The data was
obtained from <a href="https://www.nature.com/articles/s41467-020-18071-x">Piazza 2020</a>
and corresponds to experiment 18. FKBP1A the rapamycin binding protein and 49 other randomly
sampled proteins were used for this example dataset. Furthermore, only the DMSO control and the
10 uM condition were used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapamycin_10uM
</code></pre>


<h3>Format</h3>

<p>A data frame containing peptide level data from a Spectronaut report.
</p>


<h3>Source</h3>

<p>Piazza, I., Beaton, N., Bruderer, R. et al. A machine learning-based chemoproteomic
approach to identify drug targets and binding sites in complex proteomes. Nat Commun 11, 4200
(2020). <a href="https://doi.org/10.1038/s41467-020-18071-x">doi:10.1038/s41467-020-18071-x</a>
</p>

<hr>
<h2 id='rapamycin_dose_response'>Rapamycin dose response example data</h2><span id='topic+rapamycin_dose_response'></span>

<h3>Description</h3>

<p>Rapamycin example data used for the vignette about dose response data. The data was obtained
from <a href="https://www.nature.com/articles/s41467-020-18071-x">Piazza 2020</a> and corresponds
to experiment 18. FKBP1A the rapamycin binding protein and 39 other randomly sampled proteins
were used for this example dataset. The concentration range includes the following points:
0 (DMSO control), 10 pM, 100 pM, 1 nM, 10 nM, 100 nM, 1 uM, 10 uM and 100 uM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rapamycin_dose_response
</code></pre>


<h3>Format</h3>

<p>A data frame containing peptide level data from a Spectronaut report.
</p>


<h3>Source</h3>

<p>Piazza, I., Beaton, N., Bruderer, R. et al. A machine learning-based chemoproteomic
approach to identify drug targets and binding sites in complex proteomes. Nat Commun 11, 4200
(2020). <a href="https://doi.org/10.1038/s41467-020-18071-x">doi:10.1038/s41467-020-18071-x</a>
</p>

<hr>
<h2 id='read_protti'>Read, clean and convert</h2><span id='topic+read_protti'></span>

<h3>Description</h3>

<p>The function uses the very fast <code>fread</code> function form the <code>data.table</code> package. The
column names of the resulting data table are made more r-friendly using <code>clean_names</code> from
the <code>janitor</code> package. It replaces &quot;.&quot; and &quot; &quot; with &quot;_&quot; and converts names to lower case
which is also known as snake_case. In the end the data table is converted to a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_protti(filename, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_protti_+3A_filename">filename</code></td>
<td>
<p>a character value that specifies the path to the file.</p>
</td></tr>
<tr><td><code id="read_protti_+3A_...">...</code></td>
<td>
<p>additional arguments for the fread function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (with class tibble) that contains the content of the specified file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
read_protti("folder\\filename")

## End(Not run)
</code></pre>

<hr>
<h2 id='replace_identified_by_x'>Replace identified positions in protein sequence by &quot;x&quot;</h2><span id='topic+replace_identified_by_x'></span>

<h3>Description</h3>

<p>Helper function for the calculation of sequence coverage, replaces identified positions with an
&quot;x&quot; within the protein sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_identified_by_x(sequence, positions_start, positions_end)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_identified_by_x_+3A_sequence">sequence</code></td>
<td>
<p>a character value that contains the protein sequence.</p>
</td></tr>
<tr><td><code id="replace_identified_by_x_+3A_positions_start">positions_start</code></td>
<td>
<p>a numeric vector of start positions of the identified peptides.</p>
</td></tr>
<tr><td><code id="replace_identified_by_x_+3A_positions_end">positions_end</code></td>
<td>
<p>a numeric vector of end positions of the identified peptides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector that contains the modified protein sequence with each identified
position replaced by &quot;x&quot;.
</p>

<hr>
<h2 id='scale_protti'>Scaling a vector</h2><span id='topic+scale_protti'></span>

<h3>Description</h3>

<p><code>scale_protti</code> is used to scale a numeric vector either between 0 and 1 or around a
centered value using the standard deviation. If a vector containing only one value or
repeatedly the same value is provided, 1 is returned as the scaled value for <code>method = "01"</code>
and 0 is returned for <code>metod = "center"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_protti(x, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_protti_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="scale_protti_+3A_method">method</code></td>
<td>
<p>a character value that specifies the method to be used for scaling. &quot;01&quot; scales
the vector between 0 and 1. &quot;center&quot; scales the vector equal to <code>base::scale</code> around a
center. This is done by subtracting the mean from every value and then deviding them by the
standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scaled numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale_protti(c(1, 2, 1, 4, 6, 8), method = "01")
</code></pre>

<hr>
<h2 id='sequence_coverage'>Protein sequence coverage</h2><span id='topic+sequence_coverage'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>calculate_sequence_coverage()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_coverage(...)
</code></pre>


<h3>Value</h3>

<p>A new column in the <code>data</code> data frame containing the calculated sequence coverage
for each identified protein
</p>

<hr>
<h2 id='split_metal_name'>Convert metal names to search pattern</h2><span id='topic+split_metal_name'></span>

<h3>Description</h3>

<p>Converts a vector of metal names extracted from the <code>ft_metal</code> column
obtained with <code>fetch_uniprot</code> to a pattern that can be used to search for corresponding
ChEBI IDs. This is used as a helper function for other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_metal_name(metal_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_metal_name_+3A_metal_names">metal_names</code></td>
<td>
<p>a character vector containing names of metals and metal containing molecules.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with metal name search patterns.
</p>

<hr>
<h2 id='treatment_enrichment'>Check treatment enrichment</h2><span id='topic+treatment_enrichment'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>calculate_treatment_enrichment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treatment_enrichment(...)
</code></pre>


<h3>Value</h3>

<p>A bar plot displaying the percentage of all detect proteins and all significant proteins
that bind to the treatment. A Fisher's exact test is performed to calculate the significance of
the enrichment in significant proteins compared to all proteins. The result is reported as a
p-value. If <code>plot = FALSE</code> a contingency table in long format is returned.
</p>

<hr>
<h2 id='try_query'>Query from URL</h2><span id='topic+try_query'></span>

<h3>Description</h3>

<p>Downloads data table from URL. If an error occurs during the query (for example due to no
connection) the function waits 3 seconds and tries again. If no result could be obtained
after the given number of tries a message indicating the problem is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_query(
  url,
  max_tries = 5,
  silent = TRUE,
  type = "text/tab-separated-values",
  timeout = 60,
  accept = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try_query_+3A_url">url</code></td>
<td>
<p>a character value of an URL to the website that contains the table that should be
downloaded.</p>
</td></tr>
<tr><td><code id="try_query_+3A_max_tries">max_tries</code></td>
<td>
<p>a numeric value that specifies the number of times the function tries to download
the data in case an error occurs. Default is 5.</p>
</td></tr>
<tr><td><code id="try_query_+3A_silent">silent</code></td>
<td>
<p>a logical value that specifies if individual messages are printed after each try
that failed.</p>
</td></tr>
<tr><td><code id="try_query_+3A_type">type</code></td>
<td>
<p>a character value that specifies the type of data at the target URL. Options are
all options that can be supplied to httr::content, these include e.g.
&quot;text/tab-separated-values&quot;, &quot;application/json&quot; and &quot;txt/csv&quot;. Default is &quot;text/tab-separated-values&quot;.</p>
</td></tr>
<tr><td><code id="try_query_+3A_timeout">timeout</code></td>
<td>
<p>a numeric value that specifies the maximum request time. Default is 60 seconds.</p>
</td></tr>
<tr><td><code id="try_query_+3A_accept">accept</code></td>
<td>
<p>a character value that specifies the type of data that should be sent by the API if
it uses content negotiation. The default is NULL and it should only be set for APIs that use
content negotiation.</p>
</td></tr>
<tr><td><code id="try_query_+3A_...">...</code></td>
<td>
<p>other parameters supplied to the parsing function used by httr::content.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the table from the url.
</p>

<hr>
<h2 id='ttest_protti'>Perform Welch's t-test</h2><span id='topic+ttest_protti'></span>

<h3>Description</h3>

<p>Performs a Welch's t-test and calculates p-values between two groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttest_protti(mean1, mean2, sd1, sd2, n1, n2, log_values = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ttest_protti_+3A_mean1">mean1</code></td>
<td>
<p>a numeric vector that contains the means of group1.</p>
</td></tr>
<tr><td><code id="ttest_protti_+3A_mean2">mean2</code></td>
<td>
<p>a numeric vector that contains the means of group2.</p>
</td></tr>
<tr><td><code id="ttest_protti_+3A_sd1">sd1</code></td>
<td>
<p>a numeric vector that contains the standard deviations of group1.</p>
</td></tr>
<tr><td><code id="ttest_protti_+3A_sd2">sd2</code></td>
<td>
<p>a numeric vector that contains the standard deviations of group2.</p>
</td></tr>
<tr><td><code id="ttest_protti_+3A_n1">n1</code></td>
<td>
<p>a numeric vector that contains the number of replicates used for the calculation of
each mean and standard deviation of group1.</p>
</td></tr>
<tr><td><code id="ttest_protti_+3A_n2">n2</code></td>
<td>
<p>a numeric vector that contains the number of replicates used for the calculation of
each mean and standard deviation of group2.</p>
</td></tr>
<tr><td><code id="ttest_protti_+3A_log_values">log_values</code></td>
<td>
<p>a logical value that indicates if values are log transformed. This determines
how fold changes are calculated. Default is <code>log_values = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the calculated differences of means, standard error, t
statistic and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ttest_protti(
  mean1 = 10,
  mean2 = 15.5,
  sd1 = 1,
  sd2 = 0.5,
  n1 = 3,
  n2 = 3
)
</code></pre>

<hr>
<h2 id='viridis_colours'>Viridis colour scheme</h2><span id='topic+viridis_colours'></span>

<h3>Description</h3>

<p>A colour scheme by the viridis colour scheme from the viridis R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viridis_colours
</code></pre>


<h3>Format</h3>

<p>A vector containing 256 colours
</p>


<h3>Source</h3>

<p>viridis R package, created by Stfan van der Walt (stefanv) and Nathaniel Smith (njsmith)
</p>

<hr>
<h2 id='volcano_plot'>Volcano plot</h2><span id='topic+volcano_plot'></span>

<h3>Description</h3>

<p>Plots a volcano plot for the given input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volcano_plot(
  data,
  grouping,
  log2FC,
  significance,
  method,
  target_column = NULL,
  target = NULL,
  facet_by = NULL,
  facet_scales = "fixed",
  title = "Volcano plot",
  x_axis_label = "log2(fold change)",
  y_axis_label = "-log10(p-value)",
  legend_label = "Target",
  colour = NULL,
  log2FC_cutoff = 1,
  significance_cutoff = 0.01,
  interactive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volcano_plot_+3A_data">data</code></td>
<td>
<p>a data frame that contains at least the input variables.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_grouping">grouping</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains either precursor
or peptide identifiers.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_log2fc">log2FC</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the log2
transfromed fold changes between two conditions.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_significance">significance</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains the p-value
or adjusted p-value for the corresponding fold changes. The values in this column will be
transformed using the -log10 and displayed on the y-axis of the plot.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_method">method</code></td>
<td>
<p>a character value that specifies the method used for the plot.
<code>method = "target"</code> highlights your protein, proteins or any other entities of interest
(specified in the <code>target</code> argument) in the volcano plot. <code>method = "significant"</code>
highlights all significantly changing entities.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_target_column">target_column</code></td>
<td>
<p>optional, a column required for <code>method = "target"</code>, can contain for
example protein identifiers or a logical that marks certain proteins such as proteins that are
known to interact with the treatment. Can also be provided if <code>method = "significant"</code>
to label data points in an interactive plot.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_target">target</code></td>
<td>
<p>optional, a vector required for <code>method = "target"</code>. It
can contain one or more specific entities of the column provided in <code>target_column</code>. This
can be for example a protein ID if <code>target_column</code> contains protein IDs or TRUE or FALSE
for a logical column.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_facet_by">facet_by</code></td>
<td>
<p>optional, a character column that contains information by which the data should
be faceted into multiple plots.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_facet_scales">facet_scales</code></td>
<td>
<p>a character value that specifies if the scales should be &quot;free&quot;, &quot;fixed&quot;,
&quot;free_x&quot; or &quot;free_y&quot;, if a faceted plot is created. These inputs are directly supplied to the
<code>scales</code> argument of <code>ggplot2::facet_wrap()</code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_title">title</code></td>
<td>
<p>optional, a character value that specifies the title of the volcano plot. Default
is &quot;Volcano plot&quot;.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_x_axis_label">x_axis_label</code></td>
<td>
<p>optional, a character value that specifies the x-axis label. Default is
&quot;log2(fold change)&quot;.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_y_axis_label">y_axis_label</code></td>
<td>
<p>optional, a character value that specifies the y-axis label. Default is
&quot;-log10(q-value)&quot;.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_legend_label">legend_label</code></td>
<td>
<p>optional, a character value that specifies the legend label. Default is
&quot;Target&quot;.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_colour">colour</code></td>
<td>
<p>optional, a character vector containing colours that should be used to colour
points according to the selected method. IMPORTANT: the first value in the vector is the
default point colour, the additional values specify colouring of target or significant points.
E.g. <code>c("grey60", "#5680C1")</code> to achieve the same colouring as the default for the &quot;significant&quot;
method.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_log2fc_cutoff">log2FC_cutoff</code></td>
<td>
<p>optional, a numeric value that specifies the log2 transformed fold change
cutoff used for the vertical lines, which can be used to assess the significance of changes.
Default value is 1.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>optional, a character vector that specifies the p-value cutoff used
for the horizontal cutoff line, which can be used to assess the significance of changes. The
vector can consist solely of one element, which is the cutoff value. In that case the cutoff
will be applied directly to the plot. Alternatively, a second element can be provided to the
vector that specifies a column in the <code>data</code> data frame which contains e.g. adjusted
p-values. In that case the y-axis of the plot could display p-values that are provided to the
<code>significance</code> argument, while the horizontal cutoff line is on the scale of adjusted
p-values transformed to the scale of p-values. The provided vector can be e.g.
<code>c(0.05, "adj_pval")</code>. In that case the function looks for the closest adjusted p-value
above and below 0.05 and takes the mean of the corresponding p-values as the cutoff line. If
there is no adjusted p-value in the data that is below 0.05 no line is displayed. This allows
the user to display volcano plots using p-values while using adjusted p-values for the cutoff
criteria. This is often preferred because adjusted p-values are related to unadjusted p-values
often in a complex way that makes them hard to be interpret when plotted. Default is <code>c(0.01)</code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_interactive">interactive</code></td>
<td>
<p>a logical value that specifies whether the plot should be interactive
(default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the method used a volcano plot with either highlighted targets
(<code>method = "target"</code>) or highlighted significant proteins (<code>method = "significant"</code>)
is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # Makes example reproducible

# Create synthetic data
data &lt;- create_synthetic_data(
  n_proteins = 10,
  frac_change = 0.5,
  n_replicates = 4,
  n_conditions = 3,
  method = "effect_random",
  additional_metadata = FALSE
)

# Assign missingness information
data_missing &lt;- assign_missingness(
  data,
  sample = sample,
  condition = condition,
  grouping = peptide,
  intensity = peptide_intensity_missing,
  ref_condition = "all",
  retain_columns = c(protein, change_peptide)
)

# Calculate differential abundances
diff &lt;- calculate_diff_abundance(
  data = data_missing,
  sample = sample,
  condition = condition,
  grouping = peptide,
  intensity_log2 = peptide_intensity_missing,
  missingness = missingness,
  comparison = comparison,
  method = "t-test",
  retain_columns = c(protein, change_peptide)
)

volcano_plot(
  data = diff,
  grouping = peptide,
  log2FC = diff,
  significance = pval,
  method = "target",
  target_column = change_peptide,
  target = TRUE,
  facet_by = comparison,
  significance_cutoff = c(0.05, "adj_pval")
)
</code></pre>

<hr>
<h2 id='volcano_protti'>Volcano plot</h2><span id='topic+volcano_protti'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated due to its name changing to <code>volcano_plot()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volcano_protti(...)
</code></pre>


<h3>Value</h3>

<p>Depending on the method used a volcano plot with either highlighted targets
(<code>method = "target"</code>) or highlighted significant proteins (<code>method = "significant"</code>)
is returned.
</p>

<hr>
<h2 id='woods_plot'>Woods' plot</h2><span id='topic+woods_plot'></span>

<h3>Description</h3>

<p>Creates a Woods' plot that plots log2 fold change of peptides or precursors along the protein
sequence. The peptides or precursors are located on the x-axis based on their start and end
positions. The position on the y-axis displays the fold change. The vertical size (y-axis) of
the box representing the peptides or precursors do not have any meaning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>woods_plot(
  data,
  fold_change,
  start_position,
  end_position,
  protein_length,
  coverage = NULL,
  protein_id,
  targets = "all",
  facet = TRUE,
  colouring = NULL,
  fold_change_cutoff = 1,
  highlight = NULL,
  export = FALSE,
  export_name = "woods_plots"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="woods_plot_+3A_data">data</code></td>
<td>
<p>a data frame that contains differential abundance, start and end peptide or
precursor positions, protein length and optionally a variable based on which peptides or
precursors should be coloured.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_fold_change">fold_change</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains log2 fold
changes.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_start_position">start_position</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the start
positions for each peptide or precursor.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_end_position">end_position</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the end
positions for each peptide or precursor.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_protein_length">protein_length</code></td>
<td>
<p>a numeric column in the <code>data</code> data frame that contains the length
of the protein.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_coverage">coverage</code></td>
<td>
<p>optional, a numeric column in the <code>data</code> data frame that contains coverage
in percent. Will appear in the title of the Woods' plot if provided.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_protein_id">protein_id</code></td>
<td>
<p>a character column in the <code>data</code> data frame that contains protein
identifiers.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_targets">targets</code></td>
<td>
<p>a character vector that specifies the identifiers of the proteins (depending on
<code>protein_id</code>) that should be plotted. This can also be <code>"all"</code> if plots for all
proteins should be created. Default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_facet">facet</code></td>
<td>
<p>a logical value that indicates if plots should be summarised into facets of 20
plots. This is recommended for many plots. Default is <code>facet = TRUE</code>.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_colouring">colouring</code></td>
<td>
<p>optional, a character or numeric (discrete or continous) column in the data
frame containing information by which peptide or precursors should be coloured.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_fold_change_cutoff">fold_change_cutoff</code></td>
<td>
<p>optional, a numeric value that specifies the log2 fold change cutoff
used in the plot. The default value is 2.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_highlight">highlight</code></td>
<td>
<p>optional, a logical column that specifies whether specific peptides or
precursors should be highlighted with an asterisk.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_export">export</code></td>
<td>
<p>a logical value that indicates if plots should be exported as PDF. The output
directory will be the current working directory. The name of the file can be chosen using the
<code>export_name</code> argument. Default is <code>export = FALSE</code>.</p>
</td></tr>
<tr><td><code id="woods_plot_+3A_export_name">export_name</code></td>
<td>
<p>a character vector that provides the name of the exported file if
<code>export = TRUE</code>. Default is <code>export_name = "woods_plots"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing Woods' plots is returned. Plotting peptide or precursor log2 fold
changes along the protein sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create example data
data &lt;- data.frame(
  fold_change = c(2.3, 0.3, -0.4, -4, 1),
  pval = c(0.001, 0.7, 0.9, 0.003, 0.03),
  start = c(20, 30, 45, 90, 140),
  end = c(33, 40, 64, 100, 145),
  protein_length = c(rep(150, 5)),
  protein_id = c(rep("P1", 5))
)

# Plot Woods' plot
woods_plot(
  data = data,
  fold_change = fold_change,
  start_position = start,
  end_position = end,
  protein_length = protein_length,
  protein_id = protein_id,
  colouring = pval
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
