<!DOCTYPE html><html><head><title>Help for package memisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {memisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Memisc'><p>Introduction to the 'memisc' Package</p></a></li>
<li><a href='#annotations'><p>Adding Annotations to Objects</p></a></li>
<li><a href='#applyTemplate'><p>Apply a Formatting Template to a Numeric or Character Vector</p></a></li>
<li><a href='#as.array'><p>Converting Data Frames into Arrays</p></a></li>
<li><a href='#as.symbols'><p>Construction of Lists of Symbols</p></a></li>
<li><a href='#assign_if'><p>Assign a values to a variable for instances where a condition is</p>
met</a></li>
<li><a href='#attr-operators'><p>Operators for Setting Annotations and Attributes</p></a></li>
<li><a href='#By'><p>Conditional Evaluation of an Expression</p></a></li>
<li><a href='#cases'><p>Distinguish between Cases Specified by Logical Conditions</p></a></li>
<li><a href='#coarsen'><p>Coarsen a vector into a factor with a lower number of levels</p></a></li>
<li><a href='#codebook'><p>Generate a Codebook of a Data Set</p></a></li>
<li><a href='#codeplan'><p>Describe structure of Data Sets and Importers</p></a></li>
<li><a href='#collect'><p>Collect Objects</p></a></li>
<li><a href='#contr'><p>Convenience Methods for Setting Contrasts</p></a></li>
<li><a href='#contract'><p>Contract data into pattern-frequency format</p></a></li>
<li><a href='#data.set'><p>Data Set Objects</p></a></li>
<li><a href='#data.set+20manipulation'><p>Manipulation of Data Sets</p></a></li>
<li><a href='#deduplicate_labels'><p>Handle duplicated labels</p></a></li>
<li><a href='#Descriptives'><p>Vectors of Univariate Sample Statistics</p></a></li>
<li><a href='#dimrename'><p>Change dimnames, rownames, or colnames</p></a></li>
<li><a href='#duplicated_labels'><p>Check for and report duplicated labels</p></a></li>
<li><a href='#foreach'><p>Loop over Variables in a Data Frame or Environment</p></a></li>
<li><a href='#format_html'>
<p>Format Objects in HTML, show the HTML Format or Write it to a File</p></a></li>
<li><a href='#format_html.codebook'>
<p>Format Codebooks as HTML</p></a></li>
<li><a href='#format_html.ftable'>
<p>Format &quot;Flattened Tables&quot; as HTML</p></a></li>
<li><a href='#format_md'>
<p>Format Codebooks as Markdown</p></a></li>
<li><a href='#ftable-matrix'>
<p>Combining flattened tables.</p></a></li>
<li><a href='#genTable'><p>Generic Tables and Data Frames of Descriptive Statistics</p></a></li>
<li><a href='#getSummary'><p>Get Model Summaries for Use with &quot;mtable&quot;</p></a></li>
<li><a href='#Groups'><p>Operate on grouped data in data frames and data sets</p></a></li>
<li><a href='#html'>
<p>Building Blocks for HTML Code</p></a></li>
<li><a href='#Iconv'><p>Convert Annotations, and Value Labels between Encodings</p></a></li>
<li><a href='#importers'><p>Object Oriented Interface to Foreign Files</p></a></li>
<li><a href='#items'><p>Survey Items</p></a></li>
<li><a href='#items-to-vectors'><p>How Survey Items Are Converted into &quot;Ordinary&quot; Data Vectors</p></a></li>
<li><a href='#labels'><p>Value Labels</p></a></li>
<li><a href='#List'><p>Create a list and conveniently supply names to its elements</p></a></li>
<li><a href='#Mean'><p>Convenience wrappers for common statistical functions</p></a></li>
<li><a href='#Means'><p>Means for groups of observations</p></a></li>
<li><a href='#measurement'><p>Levels of Measurement of Survey Items</p></a></li>
<li><a href='#measurement_autolevel'><p>Automatically Adapt Measurement Levels</p></a></li>
<li><a href='#memisc-deprecated'><p>Deprecated Functions in Package <span class="pkg">memisc</span></p></a></li>
<li><a href='#mtable'><p>Comparative Table of Model Estimates</p></a></li>
<li><a href='#mtable_format_delim'><p>Format for 'mtable' Objects for Writing into File</p></a></li>
<li><a href='#mtable_format_html'><p>HTML Formatting for 'mtable' Results</p></a></li>
<li><a href='#mtable_format_latex'><p>Format 'mtable' Results for LaTeX</p></a></li>
<li><a href='#mtable_format_print'><p>Print Format for 'mtable' Objects</p></a></li>
<li><a href='#neg2mis'><p>Mark Negative Values as Missing</p></a></li>
<li><a href='#negative+20match'><p>Negative Match</p></a></li>
<li><a href='#percent'><p>Table of Percentages with Percentage Base</p></a></li>
<li><a href='#percentages'>
<p>Easy Creation of Tables of Percentages</p></a></li>
<li><a href='#query'><p>Query an Object for Information</p></a></li>
<li><a href='#recode'><p>Recode Items, Factors and Numeric Vectors</p></a></li>
<li><a href='#relabel'><p>Change labels of factors or labelled objects</p></a></li>
<li><a href='#rename'><p>Change Names of a Named Object</p></a></li>
<li><a href='#reorder.array'><p>Reorder an Array or Matrix</p></a></li>
<li><a href='#Reshape'><p>Reshape data frames or data sets</p></a></li>
<li><a href='#retain'><p>Retain Objects in an Environment</p></a></li>
<li><a href='#reversed'><p>Reverse the codes of a survey item or the levels of a factor</p></a></li>
<li><a href='#sample-methods'><p>Take a Sample from a Data Frame-like Object</p></a></li>
<li><a href='#Sapply'><p>A Dimension Preserving Variant of &quot;sapply&quot; and &quot;lapply&quot;</p></a></li>
<li><a href='#sort-methods'><p>Convenience Methods to Sort Data Frames and Data Sets</p></a></li>
<li><a href='#styles'><p>Formatting Styles for Coefficients, Factor Contrasts, and Summary Statistics</p></a></li>
<li><a href='#Substitute'><p>Substitutions in Language Objects</p></a></li>
<li><a href='#Table'><p>One-Dimensional Table of Frequences and/or Percentages</p></a></li>
<li><a href='#tibbles'><p>Interface to Packages 'tibble' and 'haven'</p></a></li>
<li><a href='#to.data.frame'><p>Convert an Array into a Data Frame</p></a></li>
<li><a href='#toLatex'><p>Additional Methods for LaTeX Representations for R objects</p></a></li>
<li><a href='#trim_labels'><p>Trim Codes from the Labels of an Item</p></a></li>
<li><a href='#Utility+20classes'><p>Named Lists, Lists of Items, and Atomic Vectors</p></a></li>
<li><a href='#value.filter'><p>Value Filters</p></a></li>
<li><a href='#view'><p>A Generic Viewing Function</p></a></li>
<li><a href='#view_html'><p>HTML Output for 'view.</p></a></li>
<li><a href='#wild.codes'>
<p>Table of frequencies for unlabelled codes</p></a></li>
<li><a href='#within-operators'><p>Operators to abbreviate use of &quot;with&quot; and &quot;within&quot;</p></a></li>
<li><a href='#withSE'><p>Add Alternative Variance Estimates to Models Estimates</p></a></li>
<li><a href='#Write'><p>Write Codebooks and Variable Descriptions into a Text File</p></a></li>
<li><a href='#xapply'><p>Apply a function to ranges of variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Management of Survey Data and Presentation of Analysis Results</td>
</tr>
<tr>
<td>Version:</td>
<td>0.99.31.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Elff (with contributions from Christopher N. Lawrence, Dave Atkins,
        Jason W. Morgan, Achim Zeileis, Mael Astruc-Le Souder, Kiril Mueller, and Pieter Schoonees)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Elff &lt;memisc@elff.eu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An infrastructure for the management of survey data including
        value labels, definable missing values, recoding of variables,
        production of code books, and import of (subsets of) 'SPSS' and
        'Stata' files is provided. Further, the package allows to produce
        tables and data frames of arbitrary descriptive statistics and
        (almost) publication-ready tables of regression model
        estimates, which can be exported to 'LaTeX' and HTML.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>Yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), lattice, stats, methods, utils, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>splines, knitr, rmarkdown, sandwich</td>
</tr>
<tr>
<td>Enhances:</td>
<td>AER, car, eha, lme4, ordinal, simex, tibble, haven</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, data.table, yaml, jsonlite</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://memisc.elff.eu">http://memisc.elff.eu</a>,<a href="https://github.com/melff/memisc/">https://github.com/melff/memisc/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/melff/memisc/issues">https://github.com/melff/memisc/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 20:39:41 UTC; elff</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Memisc'>Introduction to the 'memisc' Package</h2><span id='topic+memisc-package'></span><span id='topic+memisc'></span>

<h3>Description</h3>

<p>This package collects an assortment of tools that are intended to make
work with <code>R</code> easier for the author of this package
and are submitted to the public in the hope that they will be also be useful to others.
</p>
<p>The tools in this package can be grouped into four major categories:
</p>

<ul>
<li><p> Data preparation and management
</p>
</li>
<li><p> Data analysis
</p>
</li>
<li><p> Presentation of analysis results
</p>
</li>
<li><p> Programming
</p>
</li></ul>



<h3>Data preparation and management</h3>



<h4>Survey Items</h4>

<p><code>memisc</code> provides facilities to work with what users from other
packages like SPSS, SAS, or Stata know as &lsquo;variable labels&rsquo;, &lsquo;value labels&rsquo;
and &lsquo;user-defined missing values&rsquo;. In the context of this package these
aspects of the data are represented by the <code>"description"</code>,
<code>"labels"</code>, and <code>"missing.values"</code> attributes of a
data vector. 
These facilities are useful, for example, if you work with
survey data that contain coded items like vote intention that
may have the following structure:
</p>
<p>Question: &ldquo;If there was a parliamentary election next tuesday, which party would you vote for?&rdquo;
</p>

<table>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> Conservative Party </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Labour Party </td>
</tr>
<tr>
 <td style="text-align: right;">
    3 </td><td style="text-align: left;"> Liberal Democrat Party </td>
</tr>
<tr>
 <td style="text-align: right;">
    4 </td><td style="text-align: left;"> Scottish Nation Party </td>
</tr>
<tr>
 <td style="text-align: right;">
    5 </td><td style="text-align: left;"> Plaid Cymru </td>
</tr>
<tr>
 <td style="text-align: right;">
    6 </td><td style="text-align: left;"> Green Party </td>
</tr>
<tr>
 <td style="text-align: right;">
    7 </td><td style="text-align: left;"> British National Party </td>
</tr>
<tr>
 <td style="text-align: right;">
    8 </td><td style="text-align: left;"> Other party </td>
</tr>
<tr>
 <td style="text-align: right;">
    96 </td><td style="text-align: left;"> Not allowed to vote </td>
</tr>
<tr>
 <td style="text-align: right;">
    97 </td><td style="text-align: left;"> Would not vote </td>
</tr>
<tr>
 <td style="text-align: right;">
    98 </td><td style="text-align: left;"> Would vote, do not know yet for which party </td>
</tr>
<tr>
 <td style="text-align: right;">
    99 </td><td style="text-align: left;"> No answer 
  </td>
</tr>

</table>

<p>A statistical package like SPSS allows to
attach labels like &lsquo;Conservative Party&rsquo;, &lsquo;Labour Party&rsquo;, etc.
to the codes 1,2,3, etc. and to mark
mark the codes 96, 97, 98, 99
as &lsquo;missing&rsquo; and thus to exclude these variables from statistical
analyses. <code>memisc</code> provides similar facilities.
Labels can be attached to codes by calls like <code><a href="#topic+labels">labels</a>(x) &lt;- something</code>
and expendanded by calls like <code><a href="#topic+labels">labels</a>(x) &lt;- <a href="#topic+labels">labels</a>(x) + something</code>,
codes can be marked as &lsquo;missing&rsquo; by
calls like <code><a href="#topic+missing.values">missing.values</a>(x) &lt;- something</code> and
<code><a href="#topic+missing.values">missing.values</a>(x) &lt;- <a href="#topic+missing.values">missing.values</a>(x) + something</code>.
</p>
<p><code>memisc</code> defines a class called &quot;data.set&quot;, which is similar to the class &quot;data.frame&quot;.
The main difference is that it is especially geared toward containing survey item data.
Transformations of and within &quot;data.set&quot; objects retain the information about
value labels, missing values etc. Using <code>as.data.frame</code> sets the data up for
<em>R</em>'s statistical functions, but doing this explicitely is seldom necessary.
See <code><a href="#topic+data.set">data.set</a></code>.
</p>



<h4>More Convenient Import of External Data</h4>

<p>Survey data sets are often relative large and contain up to a few thousand variables.
For specific analyses one needs however only a relatively small subset of these variables.
Although modern computers have enough RAM to load such data sets completely into an R session,
this is not very efficient having to drop most of the variables after loading. Also, loading
such a large data set completely can be time-consuming, because R has to allocate space for
each of the many variables. Loading just the subset of variables really needed for an analysis
is more efficient and convenient - it tends to be much quicker. Thus this package provides
facilities to load such subsets of variables, without the need to load a complete data set.
Further, the loading of data from SPSS files is organized in such a way that all informations
about variable labels, value labels, and user-defined missing values are retained.
This is made possible by the definition of <code><a href="#topic+importer">importer</a></code> objects, for which
a <code><a href="base.html#topic+subset">subset</a></code> method exists. <code><a href="#topic+importer">importer</a></code> objects contain only
the information about the variables in the external data set but not the data.
The data itself is loaded into memory when the functions <code>subset</code> or <code><a href="#topic+as.data.set">as.data.set</a></code>
are used.
</p>



<h4>Recoding</h4>

<p><code>memisc</code> also contains facilities for recoding
survey items. Simple recodings, for example collapsing answer
categories, can be done using the function <code><a href="#topic+recode">recode</a></code>. More
complex recodings, for example the construction of indices from
multiple items, and complex case distinctions, can be done
using the function <code><a href="#topic+cases">cases</a></code>. This function may also
be useful for programming, in so far as it is a generalization of
<code><a href="base.html#topic+ifelse">ifelse</a></code>.
</p>



<h4>Code Books</h4>

<p>There is a function <code><a href="#topic+codebook">codebook</a></code> which produces a code book of an
external data set or an internal &quot;data.set&quot; object. A codebook contains in a
conveniently formatted way concise information about every variable in a data set,
such as which value labels and missing values are defined and some univariate statistics.
</p>
<p>An extended example of all these facilities is contained in the vignette &quot;anes48&quot;,
and in <code>demo(anes48)</code>
</p>



<h3>Data Analysis</h3>



<h4>Tables and Data Frames of Descriptive Statistics</h4>

<p><code><a href="#topic+genTable">genTable</a></code> is a generalization of <code><a href="stats.html#topic+xtabs">xtabs</a></code>:
Instead of counts, also descriptive statistics like means or variances
can be reported conditional on levels of factors. Also conditional
percentages of a factor can be obtained using this function.
</p>
<p>In addition an <code>Aggregate</code> 
function is provided, which has the same syntax as <code>genTable</code>, but
gives a data frame of descriptive statistics instead of a <code>table</code>
object. 
</p>



<h4>Per-Subset Analysis</h4>

<p><code><a href="#topic+By">By</a></code> is a variant of the
standard function <code><a href="base.html#topic+by">by</a></code>: Conditioning factors
are specified by a formula and are
obtained from the data frame the subsets of which are to be analysed.
Therefore there is no need to <code><a href="base.html#topic+attach">attach</a></code> the data frame
or to use the dollar operator.
</p>



<h3>Presentation of Results of Statistical Analysis</h3>



<h4>Publication-Ready Tables of Coefficients</h4>

<p>Journals of the Political and Social Sciences usually require
that estimates of regression models are presented in the following
form:
</p>
<pre>
    ==================================================
                    Model 1     Model 2     Model 3
    --------------------------------------------------
    Coefficients
    (Intercept)     30.628***    6.360***   28.566***
                    (7.409)     (1.252)     (7.355)
    pop15           -0.471**                -0.461**
                    (0.147)                 (0.145)
    pop75           -1.934                  -1.691
                    (1.041)                 (1.084)
    dpi                          0.001      -0.000
                                (0.001)     (0.001)
    ddpi                         0.529*      0.410*
                                (0.210)     (0.196)
    --------------------------------------------------
    Summaries
    R-squared         0.262       0.162       0.338
    adj. R-squared    0.230       0.126       0.280
    N                50          50          50
    ==================================================
</pre>
<p>Such tables of coefficient estimates can be produced
by <code><a href="#topic+mtable">mtable</a></code>. To see some of the possibilities of
this function, use <code>example(mtable)</code>.
</p>



<h4>LaTeX Representation of R Objects</h4>

<p>Output produced by <code><a href="#topic+mtable">mtable</a></code> can be transformed into
LaTeX tables by an appropriate method of the generic function
<code><a href="utils.html#topic+toLatex">toLatex</a></code> which is defined in the package
<code>utils</code>. In addition, <code>memisc</code> defines <code>toLatex</code> methods
for matrices and <code><a href="stats.html#topic+ftable">ftable</a></code> objects. Note that
results produced by <code><a href="#topic+genTable">genTable</a></code> can be coerced into
<code><a href="stats.html#topic+ftable">ftable</a></code> objects. Also, a default method
for the <code>toLatex</code> function is defined which coerces its
argument to a matrix and applies the matrix method of <code>toLatex</code>.
</p>



<h3>Programming</h3>



<h4>Looping over Variables</h4>

<p>Sometimes users want to contruct loops that run over variables rather than values.
For example, if one wants to set the missing values of a battery of items.
For this purpose, the package contains the function <code><a href="#topic+foreach">foreach</a></code>.
To set 8 and 9 as missing values for the items <code>knowledge1</code>,
<code>knowledge2</code>, <code>knowledge3</code>, one can use
</p>
<pre>
    foreach(x=c(knowledge1,knowledge2,knowledge3),
        missing.values(x) &lt;- 8:9)
  </pre>



<h4>Changing Names of Objects and Labels of Factors</h4>

<p><code>R</code> already makes it possible to change the names of an object.
Substituting the <code><a href="base.html#topic+names">names</a></code> or <code><a href="base.html#topic+dimnames">dimnames</a></code>
can be done with some programming tricks. This package defines
the function <code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+dimrename">dimrename</a></code>, <code><a href="#topic+colrename">colrename</a></code>, and <code><a href="#topic+rowrename">rowrename</a></code>
that implement these tricks in a convenient way, so that programmers
(like the author of this package) need not reinvent the weel in
every instance of changing names of an object.
</p>



<h4>Dimension-Preserving Versions of <code>lapply</code> and <code>sapply</code></h4>

<p>If a function that is involved in a call to 
<code><a href="base.html#topic+lapply">sapply</a></code> returns a result an array or a matrix, the
dimensional information gets lost. Also, if a list object to which
<code><a href="base.html#topic+lapply">lapply</a></code> or <code><a href="base.html#topic+lapply">sapply</a></code> are applied
have a dimension attribute, the result looses this information.
The functions <code><a href="#topic+Lapply">Lapply</a></code> and
<code><a href="#topic+Sapply">Sapply</a></code> defined in this package preserve such
dimensional information.
</p>



<h4>Combining Vectors and Arrays by Names</h4>

<p>The generic function <code><a href="#topic+collect">collect</a></code> collects several objects of the
same mode into one object, using their names, <code>rownames</code>,
<code>colnames</code> and/or <code>dimnames</code>. There are methods for
atomic vectors, arrays (including matrices), and data frames.
For example
</p>
<pre>
  a &lt;- c(a=1,b=2)
  b &lt;- c(a=10,c=30)
  collect(a,b)
  </pre>
<p>leads to
</p>
<pre>
     x  y
  a  1 10
  b  2 NA
  c NA 30
  </pre>



<h4>Reordering of Matrices and Arrays</h4>

<p>The <code>memisc</code> package includes a <code><a href="#topic+reorder">reorder</a></code>
method for arrays and matrices. For example, the matrix
method by default reorders the rows of a matrix according the results
of a function.
</p>


<hr>
<h2 id='annotations'>Adding Annotations to Objects</h2><span id='topic+annotation'></span><span id='topic+annotation+2CANY-method'></span><span id='topic+annotation+2Citem-method'></span><span id='topic+annotation+2Cdata.set-method'></span><span id='topic+annotation+3C-'></span><span id='topic+annotation+3C-+2CANY+2CNULL-method'></span><span id='topic+annotation+3C-+2CANY+2Ccharacter-method'></span><span id='topic+annotation+3C-+2CANY+2Cannotation-method'></span><span id='topic+annotation+3C-+2Citem+2Cannotation-method'></span><span id='topic+annotation+3C-+2Cvector+2Cannotation-method'></span><span id='topic+description'></span><span id='topic+description+2Cdata.set-method'></span><span id='topic+description+2Cimporter-method'></span><span id='topic+description+2Cdata.frame-method'></span><span id='topic+description+2Ctbl_df-method'></span><span id='topic+description+3C-'></span><span id='topic+wording'></span><span id='topic+wording+3C-'></span><span id='topic+annotation-class'></span><span id='topic+show+2Cannotation-method'></span>

<h3>Description</h3>

<p>Annotations, that is, objects of class <code>"annotation"</code>,
are character vectors with all their elements named.
Only one method is defined for this subclass of character vectors,
a method for <code><a href="methods.html#topic+show">show</a></code>, that shows the annotation in
a nicely formatted way. Annotations of an object can be obtained
via the function <code>annotation(x)</code> and can be set via
<code>annotation(x)&lt;-value</code>.
</p>
<p>Elements of an annotation with names <code>"description"</code>
and <code>"wording"</code> have a special meaning.
The first kind can be obtained and set via
<code>description(x)</code> and <code>description(x)&lt;-value</code>,
the second kind can be obtained via
<code>wording(x)</code> and <code>wording(x)&lt;-value</code>.
<code>"description"</code> elements are used in way the &quot;variable labels&quot;
are used in SPSS and Stata. <code>"wording"</code> elements of annotation
objects are meant to contain the question wording of a questionnaire
item represented by an <code>"item"</code> objects.
These elements of annotations are treated in a special way
in the output of the <code>coodbook</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation(x)
## S4 method for signature 'ANY'
annotation(x)
## S4 method for signature 'item'
annotation(x)
## S4 method for signature 'data.set'
annotation(x)
annotation(x)&lt;-value
## S4 replacement method for signature 'ANY,character'
annotation(x)&lt;-value
## S4 replacement method for signature 'ANY,annotation'
annotation(x)&lt;-value
## S4 replacement method for signature 'item,annotation'
annotation(x)&lt;-value
## S4 replacement method for signature 'vector,annotation'
annotation(x)&lt;-value

description(x)
description(x)&lt;-value

wording(x)
wording(x)&lt;-value

## S4 method for signature 'data.set'
description(x)
## S4 method for signature 'importer'
description(x)
## S4 method for signature 'data.frame'
description(x)
## S4 method for signature 'tbl_df'
description(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotations_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="annotations_+3A_value">value</code></td>
<td>
<p>a character or annotation object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>annotation(x)</code> returns an object of class <code>"annotation"</code>,
which is a named character.
<code>description(x)</code> and <code>wording(x)</code> each usually return a character string.
If <code>description(x)</code> is applied to a <code><a href="#topic+data.set">data.set</a></code> or an <code><a href="#topic+importer">importer</a></code> object,
however, a character vector is returned, which is named after the
variables in the data set or the external file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vote &lt;- sample(c(1,2,3,8,9,97,99),size=30,replace=TRUE)
labels(vote) &lt;- c(Conservatives         =  1,
                    Labour                =  2,
                    "Liberal Democrats"   =  3,
                    "Don't know"          =  8,
                    "Answer refused"      =  9,
                    "Not applicable"      = 97,
                    "Not asked in survey" = 99
                    )
missing.values(vote) &lt;- c(97,99)
description(vote) &lt;- "Vote intention"
wording(vote) &lt;- "If a general election would take place next tuesday,
                    the candidate of which party would you vote for?"
annotation(vote)
annotation(vote)["Remark"] &lt;- "This is not a real questionnaire item, of course ..."
codebook(vote)
</code></pre>

<hr>
<h2 id='applyTemplate'>Apply a Formatting Template to a Numeric or Character Vector</h2><span id='topic+applyTemplate'></span><span id='topic+template'></span>

<h3>Description</h3>

<p><code>applyTemplate</code> is called internally by <code><a href="#topic+mtable">mtable</a></code>
to format coefficients and summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyTemplate(x,template,float.style=getOption("float.style"),
                      digits=min(3,getOption("digits")),
                      signif.symbols=getOption("signif.symbols"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyTemplate_+3A_x">x</code></td>
<td>
<p>a numeric or character vector to be formatted</p>
</td></tr>
<tr><td><code id="applyTemplate_+3A_template">template</code></td>
<td>
<p>a character vector that defines the template, see details.</p>
</td></tr>
<tr><td><code id="applyTemplate_+3A_float.style">float.style</code></td>
<td>
<p>A character string that is passed to <code><a href="base.html#topic+formatC">formatC</a></code>
by <code>applyTemplate</code>; valid values
are <code>"e"</code>, <code>"f"</code>, <code>"g"</code>, <code>"fg"</code>,
<code>"E"</code>, and <code>"G"</code>. By default, the <code>float.style</code> 
setting of <code><a href="base.html#topic+options">options</a></code> is used. The &lsquo;factory fresh&rsquo; setting is
<code>options(float.style="f")</code>
</p>
</td></tr>
<tr><td><code id="applyTemplate_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to use if not specified in
the template.</p>
</td></tr>
<tr><td><code id="applyTemplate_+3A_signif.symbols">signif.symbols</code></td>
<td>
<p>a named vector that specifies how significance levels
are symbolically indicated, values of the vector specify
significance levels and names specify the symbols. By default, the 
<code>signif.symbols</code> setting of <code><a href="base.html#topic+options">options</a></code> is used. The &quot;factory-fresh&quot; setting is
<code>options(signif.symbols=c("***"=.001,"**"=.01,"*"=.05))</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Character vectors that are used as templates may be arbitrary. However,
certain character sequences may form <em>template expressions</em>.
A template expression is of the form <code>($&lt;POS&gt;:&lt;Format spec&gt;)</code>,
where &quot;<code>($</code>&quot; indicates the start of a template expression,
&quot;<code>&lt;POS&gt;</code>&quot; stands for either an index or name that selects an
element from <code>x</code> and &quot;<code>&lt;Format spec&gt;</code>&quot; stands for a
<em>format specifier</em>. It may contain an letter indicating the
style in which the vector element selected by <code>&lt;POS&gt;</code>
will be formatted by <code><a href="base.html#topic+formatC">formatC</a></code>, it may contain
a number as the number of significant digits, a &quot;<code>#</code>&quot;
indicating that the number of signifcant digits will be at most that given
by <code>getOption("digits")</code>, or <code>*</code> that means that
the value will be formatted as a significance symbol.
</p>


<h3>Value</h3>

<p><code>applyTemplate</code> returns a character vector in which template
expressions in <code>template</code> are substituted by formatted values from <code>x</code>.
If <code>template</code> is an array then the return value is also an array of
the same shape.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>applyTemplate(c(a=.0000000000000304,b=3),template=c("($1:g7#)($a:*)"," (($1:f2)) "))
applyTemplate(c(a=.0000000000000304,b=3),template=c("($a:g7#)($a:*)"," (($b:f2)) "))
</code></pre>

<hr>
<h2 id='as.array'>Converting Data Frames into Arrays</h2><span id='topic+as.array'></span><span id='topic+as.array+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>The <code>as.array</code> for data frames
takes all factors in a data frame and uses them
to define the dimensions of the resulting array,
and fills the array with the values of
the remaining numeric variables.
</p>
<p>Currently, the data frame must contain all
combinations of factor levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
as.array(x,data.name=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.array_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="as.array_+3A_data.name">data.name</code></td>
<td>

<p>a character string, giving the name
attached to the dimension
that corresponds to the
numerical variables in the data frame
(that is, the <code>name</code> attached to
the corresponding element of the
<code>dimnames</code> list).
</p>
</td></tr>
<tr><td><code id="as.array_+3A_...">...</code></td>
<td>
<p>other arguments, ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BerkeleyAdmissions &lt;- to.data.frame(UCBAdmissions)
BerkeleyAdmissions
as.array(BerkeleyAdmissions,data.name="Admit")
try(as.array(BerkeleyAdmissions[-1,],data.name="Admit"))
</code></pre>

<hr>
<h2 id='as.symbols'>Construction of Lists of Symbols</h2><span id='topic+as.symbols'></span><span id='topic+syms'></span>

<h3>Description</h3>

<p><code>as.symbols</code> and <code>syms</code> are functions potentially useful
in connection with <code>foreach</code> and <code>xapply</code>.
<code>as.symbols</code> produces a list of symbols from a character vector,
while <code>syms</code> returns a list of symbols from symbols given as arguments,
but it can be used to construct patterns of symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.symbols(x)
syms(...,paste=FALSE,sep="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.symbols_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="as.symbols_+3A_...">...</code></td>
<td>
<p>character strings or (unquoted) variable names</p>
</td></tr>
<tr><td><code id="as.symbols_+3A_paste">paste</code></td>
<td>
<p>logical value; should the character strings
<code><a href="base.html#topic+paste">paste</a></code>d into one string?</p>
</td></tr>
<tr><td><code id="as.symbols_+3A_sep">sep</code></td>
<td>
<p>a separator string, passed to <code><a href="base.html#topic+paste">paste</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of language symbols (results of <code><a href="base.html#topic+as.symbol">as.symbol</a></code> - not graphical
symbols!).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.symbols(letters[1:8])
  syms("a",1:3,paste=TRUE)

  sapply(syms("a",1:3,paste=TRUE),typeof)
</code></pre>

<hr>
<h2 id='assign_if'>Assign a values to a variable for instances where a condition is
met</h2><span id='topic+assign_if'></span><span id='topic++25if+25'></span>

<h3>Description</h3>

<p>The <code>%if%</code> operator allows to assign values to a variable only if
a condition is met i.e. results in <code>TRUE</code>. It is supposed to
be used similar to the <code>replace ... if</code> construct in Stata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expr %if% condition
# For example
# (variable &lt;- value) %if% (other_variable == 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_if_+3A_expr">expr</code></td>
<td>
<p>An expression that assigns a value to variable</p>
</td></tr>
<tr><td><code id="assign_if_+3A_condition">condition</code></td>
<td>
<p>A logical vector or a an expression that evaluates
to a logical vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'value' that is assigned to the variable in <code>expr</code>
should either be a scalar, a vector with as many elements as the
condition vector has, or as many elements as the number of elements
in the condition vector that are equal (or evaluate to) <code>TRUE</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(test_var &lt;- 1) %if% (1:7 &gt; 3)

test_var

(test_var &lt;- 2) %if% (1:7 &lt;= 3)
test_var

(test_var &lt;- 100*test_var) %if% (1:7%%2==0)
test_var

# This creates a warning about non-matching lengths.
(test_var &lt;- 500:501) %if% (1:7 &lt;= 3)
test_var

(test_var &lt;- 501:503) %if% (1:7 &lt;= 3)
test_var

(test_var &lt;- 401:407) %if% (1:7 &lt;= 3)
test_var
</code></pre>

<hr>
<h2 id='attr-operators'>Operators for Setting Annotations and Attributes</h2><span id='topic++25+23+25'></span><span id='topic++25+23+23+25'></span><span id='topic++25+40+25'></span><span id='topic++25+40+25+3C-'></span>

<h3>Description</h3>

<p>The operator <code>%#%</code> can be used to attach a
<code><a href="#topic+description">description</a></code> annotation to an object. <code>%##%</code> can be
used to attach a character vector of annotations to an object.
<code>%@%</code> returns the attribute with the name given as second
argument. With <code>%@%</code> it is also possible to assign attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  x %#% descr
  x %##% annot
  x %@% nm
  x %@% nm &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attr-operators_+3A_x">x</code></td>
<td>
<p>an object, usually and <code><a href="#topic+item">item</a></code> or a vector.</p>
</td></tr>
<tr><td><code id="attr-operators_+3A_descr">descr</code></td>
<td>
<p>a character string</p>
</td></tr>
<tr><td><code id="attr-operators_+3A_annot">annot</code></td>
<td>
<p>a named character vector; its contents are added to the
&quot;annotation&quot; attribute of <code>x</code>. Existing elements are kept.</p>
</td></tr>
<tr><td><code id="attr-operators_+3A_nm">nm</code></td>
<td>
<p>a character string, the name of the attribute being set or
requested.</p>
</td></tr>
<tr><td><code id="attr-operators_+3A_value">value</code></td>
<td>
<p>any kind of object that can be attached as an attribute.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>test1 &lt;- 1 %#% "One"
# This is equivalent to:
# test &lt;- 1
# description(test) &lt;- "One"
description(test1)
# Results in "One"

# Not that it makes sense, but ...
test2 &lt;- 2 %##% c(
                    Precedessor = 0,
                    Successor   = 2
                 )
# This is equivalent to:
# test2 &lt;- 2
# annotation(test2) &lt;- c(
#                    Precedessor = 0,
#                    Successor   = 2
#                 )
annotation(test2)

# The following examples are equivalent to
# attr(test2,"annotation")
test2 %@% annotation

test2 %@% "annotation"

test2 %@% another.attribute &lt;- 42
# This is equivalent to attr(test2,"another.attribute") &lt;- 42

attributes(test2)
</code></pre>

<hr>
<h2 id='By'>Conditional Evaluation of an Expression</h2><span id='topic+By'></span>

<h3>Description</h3>

<p>The function <code>By</code> evaluates an expression within subsets of
a data frame, where the subsets are defined by a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>By(formula,expr,data=parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="By_+3A_formula">formula</code></td>
<td>
<p>an expression or (preferably) a formula
containing the names of conditioning variables or factors.</p>
</td></tr>
<tr><td><code id="By_+3A_expr">expr</code></td>
<td>
<p>an expression that is evaluated for any unique combination
of values of the variables contained in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="By_+3A_data">data</code></td>
<td>
<p>a data frame, an object that can be coerced into
a data frame (for example, a <a href="base.html#topic+table">table</a>), or an environment,
from which values for the variables in <code>formula</code>
or <code>expr</code> are taken.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;by&quot;, giving the results for each combination of values
of variables in <code>formula</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
berkeley &lt;- Aggregate(Table(Admit,Freq)~.,data=UCBAdmissions)
(Bres &lt;- By(~Dept,glm(cbind(Admitted,Rejected)~Gender,family="binomial"),data=berkeley))
# The results all have 'data' components
str(Bres[[1]]$data)

attach(berkeley)
(Bres &lt;- By(~Dept,glm(cbind(Admitted,Rejected)~Gender,family="binomial")))
detach(berkeley)

</code></pre>

<hr>
<h2 id='cases'>Distinguish between Cases Specified by Logical Conditions</h2><span id='topic+cases'></span>

<h3>Description</h3>

<p><code>cases</code> allows to distinguish several cases defined logical
conditions. It can be used to code these cases into a vector. The
function can be considered as a multi-condition generalization of
<code><a href="base.html#topic+ifelse">ifelse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cases(...,check.xor=c("warn","stop","ignore"),
      .default=NA,.complete=FALSE,
      check.na=c("warn","stop","ignore"),
      na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cases_+3A_...">...</code></td>
<td>
<p>A sequence of logical expressions or assignment expressions containing
logical expressions as &quot;right hand side&quot;.</p>
</td></tr>
<tr><td><code id="cases_+3A_check.xor">check.xor</code></td>
<td>
<p>character (either <code>"warn"</code>, <code>"stop"</code>, or  <code>"ignore"</code>)
or logical; if <code>TRUE</code> or equal to <code>"stop"</code> or 
<code>"warn"</code>, 
<code>cases</code> checks whether the case
conditions are mutually exclusive. If this is not
satisfied and <code>check.xor</code> equals <code>"warn"</code> (the default), a warning is shown,
otherwise an error exception is raised.</p>
</td></tr>
<tr><td><code id="cases_+3A_.default">.default</code></td>
<td>
<p>a value to be used for unsatisfied conditions.</p>
</td></tr>
<tr><td><code id="cases_+3A_.complete">.complete</code></td>
<td>
<p>logical, if <code>TRUE</code> an additional factor level is
created for the unsatisfied conditions.</p>
</td></tr>
<tr><td><code id="cases_+3A_check.na">check.na</code></td>
<td>
<p>character (either <code>"warn"</code>, <code>"stop"</code>, or  <code>"ignore"</code>)
or logical; if <code>TRUE</code> or equal to <code>"stop"</code> or 
<code>"warn"</code>, <code>cases</code> checks, whether any of the case
conditions evaluates to <code>NA</code>.
If that case, if <code>check.na</code> is <code>TRUE</code> or equals
<code>"stop"</code> an error exception is raised, while if <code>check.na</code>
equals <code>"warn"</code> (the default) a warning is shown.</p>
</td></tr>
<tr><td><code id="cases_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value; how to handle <code>NA</code>s (if they do not
already lead to an error exception). If <code>FALSE</code> if <em>any</em> of the
conditions evaluates to <code>NA</code>, the corresponding value of the
result vector is <code>NA</code>. If <code>TRUE</code> (the default), the
resulting vector or factor is <code>NA</code> only for instances where all
conditions result in <code>NA</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two distinct ways to use this function. Either the
function can be used to construct a factor that represents
several logical cases or it can be used to conditionally
evaluate an expression in a manner similar to <code><a href="base.html#topic+ifelse">ifelse</a></code>.
</p>
<p>For the first use, the <code>...</code> arguments have to be a series of
logical expressions. <code>cases</code> then returns a factor
with as many levels as logical expressions given as
<code>...</code> arguments. The resulting factor will attain its
first level if the first condition is TRUE, otherwise it will attain its
second level if the second condition is TRUE, etc.
The levels will be named after the conditions or, if name tags are
attached to the logical expressions, after the tags of the expressions.
Not that the logical expressions all need to evaluate to logical vectors
of the same length, otherwise an error condition is raised.
If <code>.complete</code> is <code>TRUE</code> then an additional factor level is
created for the conditions not satisfied for any of the cases.
</p>
<p>For the second use, the <code>...</code> arguments have to be a series
of assignment expression of the type <code>&lt;expression&gt; &lt;- &lt;logical expression&gt;</code>
or <code>&lt;logical expression&gt; -&gt; &lt;expression&gt;</code>. For cases
in which the first logical expression is TRUE, the result of first expression that
appears on the other side of the assignment operator become elements of the
vector returned by <code>cases</code>, for cases in which the second logical expression is TRUE,
the result of the second expression that appears on the other side
of the assignment operator become elements of the
vector returned by <code>cases</code>, etc.
For cases that do not satisfy any of the given conditions the value of
the <code>.default</code> argument is used. 
Note that the logical expressions also here all need to evaluate to logical
vectors of the same length. The expressions on the other side of the
assignment operator should also be either vectors of the same length
and mode or should scalars of the same mode, otherwise unpredictable
results may occur.
</p>


<h3>Value</h3>

<p>If it is called with logical expressions as ... arguments,
<code>cases</code> returns a factor, if it is called with
assignment expressions the function returns a vector with the
same mode as the results of the &quot;assigned&quot; expressions
and with the same length as the logical conditions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples of the first kind of usage of the function
#
df &lt;- data.frame(x = rnorm(n=20), y = rnorm(n=20))
df &lt;- df[do.call(order,df),]
(df &lt;- within(df,{
  x1=cases(x&gt;0,x&lt;=0)
  y1=cases(y&gt;0,y&lt;=0)
  z1=cases(
    "Condition 1"=x&lt;0,
    "Condition 2"=y&lt;0,# only applies if x &gt;= 0
    "Condition 3"=TRUE
    )
  z2=cases(x&lt;0,(x&gt;=0 &amp; y &lt;0), (x&gt;=0 &amp; y &gt;=0))
  }))
xtabs(~x1+y1,data=df)
dd &lt;- with(df,
  try(cases(x&lt;0,
            x&gt;=0,
            x&gt;1,
            check.xor=TRUE)# let's be fussy
            )
  )
dd &lt;- with(df,
  try(cases(x&lt;0,x&gt;=0,x&gt;1))
  )
genTable(range(x)~dd,data=df)

# An example of the second kind of usage of the function:
# A construction of a non-smooth function
#
fun &lt;- function(x)
  cases(
    x==0      -&gt; 1,
    abs(x)&gt; 1 -&gt; abs(x),
    abs(x)&lt;=1 -&gt; x^2
  )
x &lt;- seq(from=-2,to=2,length=101)
plot(fun(x)~x)

# Demo of the new .default and .complete arguments
x &lt;- seq(from=-2,to=2)
cases(a = x &lt; -1,
      b = x &gt; 1,
      .complete = TRUE)
cases(x &lt; -1,
      x &gt; 1,
      .complete = TRUE)
cases(1 &lt;- x &lt; -1,
      3 &lt;- x &gt; 1,
      .default = 2)

threshhold &lt;- 5
d &lt;- c(1:10, NaN)

d1 &lt;- cases(
  d &gt; threshhold -&gt; 1,
  d &lt;= threshhold -&gt; 2
)

d2 &lt;- cases(
  is.na(d) -&gt; 0,
  d &gt; threshhold -&gt; 1,
  d &lt;= threshhold -&gt; 2
)

# Leads to missing values because some of the conditions result in missing
# even though they could be 'captured'
d3 &lt;- cases(
  is.na(d) -&gt; 0,
  d &gt; threshhold -&gt; 1,
  d &lt;= threshhold -&gt; 2,
  na.rm=FALSE
)

d4 &lt;- cases(
  is.na(d) -&gt; 0,
  d &gt; threshhold +2 -&gt; 1,
  d &lt;= threshhold -&gt; 2,
  na.rm=FALSE
)

cbind(d,d1,d2,d3,d4)

cases(
  d &gt; threshhold,
  d &lt;= threshhold
)

cases(
  is.na(d),
  d &gt; threshhold,
  d &lt;= threshhold
)

cases(
  d &gt; threshhold,
  d &lt;= threshhold,
  .complete=TRUE
)

cases(
  d &gt; threshhold + 2,
  d &lt;= threshhold,
  .complete=TRUE
)
</code></pre>

<hr>
<h2 id='coarsen'>Coarsen a vector into a factor with a lower number of levels</h2><span id='topic+coarsen'></span><span id='topic+coarsen.numeric'></span>

<h3>Description</h3>

<p><code>coarsen</code> can be used to obtain a factor from a vector, similar
to <code><a href="base.html#topic+cut">cut</a></code>, but with less technical and more &quot;aesthetic&quot;
labels of the factor levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coarsen(x,...)
## S3 method for class 'numeric'
coarsen(x,
        n=5,
        pretty=TRUE,
        quantiles=!pretty,
        breaks=NULL,
        brackets=FALSE,
        sep=if(brackets)";"else if(quantiles) "-" else " - ",
        left="[",
        right="]",
        range=FALSE,
        labels=NULL,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coarsen_+3A_x">x</code></td>
<td>
<p>a vector, usually a numeric vector</p>
</td></tr>
<tr><td><code id="coarsen_+3A_n">n</code></td>
<td>
<p>number of categories of the resulting factor</p>
</td></tr>
<tr><td><code id="coarsen_+3A_pretty">pretty</code></td>
<td>
<p>a logical value, whether <code><a href="base.html#topic+pretty">pretty</a></code>
should be used to compute the breaks.</p>
</td></tr>
<tr><td><code id="coarsen_+3A_quantiles">quantiles</code></td>
<td>
<p>a logical value, whether <code><a href="stats.html#topic+quantile">quantile</a></code>
should be used to compute the breaks.</p>
</td></tr>
<tr><td><code id="coarsen_+3A_breaks">breaks</code></td>
<td>
<p>a vector of break points or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="coarsen_+3A_brackets">brackets</code></td>
<td>
<p>a logical value, whether the labels should include brackets.</p>
</td></tr>
<tr><td><code id="coarsen_+3A_sep">sep</code></td>
<td>
<p>a character string, used as a separator between upper and
lower boundaries in the labels.</p>
</td></tr>
<tr><td><code id="coarsen_+3A_left">left</code></td>
<td>
<p>a character string, to be used as the left bracket</p>
</td></tr>
<tr><td><code id="coarsen_+3A_right">right</code></td>
<td>
<p>a character string, to be used as the right bracket</p>
</td></tr>
<tr><td><code id="coarsen_+3A_range">range</code></td>
<td>
<p>a logical value, whether the minimum and maximum of
<code>x</code> should be included into <code>breaks</code>.</p>
</td></tr>
<tr><td><code id="coarsen_+3A_labels">labels</code></td>
<td>
<p>an optional character vector of labels.</p>
</td></tr>
<tr><td><code id="coarsen_+3A_...">...</code></td>
<td>
<p>further arguments, passed on to <code><a href="base.html#topic+pretty">pretty</a></code>
or <code><a href="stats.html#topic+quantile">quantile</a></code> if applicable.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(200)

table(coarsen(x))

table(coarsen(x,quantiles=TRUE))

table(coarsen(x,brackets=TRUE))

table(coarsen(x,breaks=c(-1,0,1)))

table(coarsen(x,breaks=c(-1,0,1),
              range=TRUE,labels=letters[1:4]))

</code></pre>

<hr>
<h2 id='codebook'>Generate a Codebook of a Data Set</h2><span id='topic+codebook'></span><span id='topic+codebook+2CANY-method'></span><span id='topic+codebook+2Citem-method'></span><span id='topic+codebook+2Cdata.set-method'></span><span id='topic+codebook+2Cimporter-method'></span><span id='topic+codebook+2CNULL-method'></span><span id='topic+codebook+2Catomic-method'></span><span id='topic+codebook+2Cdata.frame-method'></span><span id='topic+codebook+2Ctbl_df-method'></span><span id='topic+codebook+2Cfactor-method'></span><span id='topic+codebook-class'></span><span id='topic+format+2CcodebookEntry-method'></span><span id='topic+show+2Ccodebook-method'></span><span id='topic+as.character+2Ccodebook-method'></span><span id='topic++24+2Ccodebook-method'></span><span id='topic++5B+2Ccodebook+2Catomic+2Cmissing+2CANY-method'></span><span id='topic++5B+5B+2Ccodebook-method'></span>

<h3>Description</h3>

<p>Function <code>codebook</code> collects documentation about an item,
or the items in a data set or external data file. It returns
an object that, when <code>show</code>n, print this documentation
in a nicely formatted way. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codebook(x, weights = NULL, unweighted = TRUE, ...)
## S4 method for signature 'item'
codebook(x, weights = NULL, unweighted = TRUE, ...)
## S4 method for signature 'atomic'
codebook(x, weights = NULL, unweighted = TRUE, ...)
## S4 method for signature 'factor'
codebook(x, weights = NULL, unweighted = TRUE, ...)
## S4 method for signature 'data.set'
codebook(x, weights = NULL, unweighted = TRUE, ...)
## S4 method for signature 'importer'
codebook(x, weights = NULL, unweighted = TRUE, ...)
## S4 method for signature 'data.frame'
codebook(x, weights = NULL, unweighted = TRUE, ...)
## S4 method for signature 'tbl_df'
codebook(x, weights = NULL, unweighted = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codebook_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+item">item</a></code>, numeric or character vector, factor,
<code><a href="#topic+data.set">data.set</a></code>, <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="#topic+importer">importer</a></code> object for <code>codebook()</code></p>
</td></tr>
<tr><td><code id="codebook_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights.</p>
</td></tr>
<tr><td><code id="codebook_+3A_unweighted">unweighted</code></td>
<td>
<p>an optional logical vector; if weights are given, it
determines of only summaries of weighted data are show or also summaries of
unweighted data.</p>
</td></tr>
<tr><td><code id="codebook_+3A_...">...</code></td>
<td>
<p>other arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;codebook&quot;, for which a <code><a href="methods.html#topic+show">show</a></code> method exists that
produces a nicely formatted output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Data &lt;- data.set(
          vote = sample(c(1,2,3,8,9,97,99),size=300,replace=TRUE),
          region = sample(c(rep(1,3),rep(2,2),3,99),size=300,replace=TRUE),
          income = exp(rnorm(300,sd=.7))*2000
          )

Data &lt;- within(Data,{
  description(vote) &lt;- "Vote intention"
  description(region) &lt;- "Region of residence"
  description(income) &lt;- "Household income"
  wording(vote) &lt;- "If a general election would take place next tuesday,
                    the candidate of which party would you vote for?"
  wording(income) &lt;- "All things taken into account, how much do all
                    household members earn in sum?"
  foreach(x=c(vote,region),{
    measurement(x) &lt;- "nominal"
    })
  measurement(income) &lt;- "ratio"
  labels(vote) &lt;- c(
                    Conservatives         =  1,
                    Labour                =  2,
                    "Liberal Democrats"   =  3,
                    "Don't know"          =  8,
                    "Answer refused"      =  9,
                    "Not applicable"      = 97,
                    "Not asked in survey" = 99)
  labels(region) &lt;- c(
                    England               =  1,
                    Scotland              =  2,
                    Wales                 =  3,
                    "Not applicable"      = 97,
                    "Not asked in survey" = 99)
  foreach(x=c(vote,region,income),{
    annotation(x)["Remark"] &lt;- "This is not a real survey item, of course ..."
    })
  missing.values(vote) &lt;- c(8,9,97,99)
  missing.values(region) &lt;- c(97,99)
})

description(Data)

codebook(Data)

codebook(Data)$vote
codebook(Data)[2]

codebook(Data[2])
 
DataFr &lt;- as.data.frame(Data)
DataHv &lt;- as_haven(Data,user_na=TRUE)

codebook(DataFr)
codebook(DataHv)

   
## Not run: 
Write(description(Data),
           file="Data-desc.txt")
Write(codebook(Data),
           file="Data-cdbk.txt")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='codeplan'>Describe structure of Data Sets and Importers</h2><span id='topic+codeplan'></span><span id='topic+codeplan+2CANY-method'></span><span id='topic+codeplan+2Citem.list-method'></span><span id='topic+codeplan+2Citem-method'></span><span id='topic+codeplan+3C-'></span><span id='topic+setCodeplan'></span><span id='topic+setCodeplan+2Cdata.frame+2Ccodeplan-method'></span><span id='topic+setCodeplan+2Cdata.frame+2CNULL-method'></span><span id='topic+setCodeplan+2Cdata.set+2Ccodeplan-method'></span><span id='topic+setCodeplan+2Cdata.set+2CNULL-method'></span><span id='topic+setCodeplan+2Citem+2Ccodeplan-method'></span><span id='topic+setCodeplan+2Citem+2CNULL-method'></span><span id='topic+setCodeplan+2Catomic+2Ccodeplan-method'></span><span id='topic+setCodeplan+2Catomic+2CNULL-method'></span><span id='topic+read_codeplan'></span><span id='topic+write_codeplan'></span>

<h3>Description</h3>

<p>The function <code>codeplan()</code> creates a data frame that
describes the structure of an item list (a <code>data.set</code> object or
an <code>importer</code> object), so that this structure can be stored and
and recovered. The resulting data frame has a particular print method
that delimits the output to one line per variable.
</p>
<p>With <code>setCodeplan</code> an item list structure (as returned by <code>codeplan()</code>)
can be applied to a data frame or data set. It is also possible to use an
assignment like <code>codeplan(x) &lt;- value</code> to a similar effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codeplan(x)
## S4 method for signature 'item.list'
codeplan(x)
## S4 method for signature 'item'
codeplan(x)
setCodeplan(x,value)
## S4 method for signature 'data.frame,codeplan'
setCodeplan(x,value)
## S4 method for signature 'data.frame,NULL'
setCodeplan(x,value)
## S4 method for signature 'data.set,codeplan'
setCodeplan(x,value)
## S4 method for signature 'data.set,NULL'
setCodeplan(x,value)
## S4 method for signature 'item,codeplan'
setCodeplan(x,value)
## S4 method for signature 'item,NULL'
setCodeplan(x,value)
## S4 method for signature 'atomic,codeplan'
setCodeplan(x,value)
## S4 method for signature 'atomic,NULL'
setCodeplan(x,value)
codeplan(x) &lt;- value
read_codeplan(filename,type)
write_codeplan(x,filename,type,pretty)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codeplan_+3A_x">x</code></td>
<td>
<p>for <code>codeplan(x)</code> an object that inherits from class <code>"item.list"</code>,
i.e. can be a <code>"data.set"</code> object or an <code>"importer"</code>
object, it can also be an object that inherits from class
<code>"item"</code>.
For <code>write_codeplan</code> an object from class <code>"codeplan"</code>.</p>
</td></tr>
<tr><td><code id="codeplan_+3A_value">value</code></td>
<td>
<p>an object as it would be returned by <code>codeplan(x)</code>
or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="codeplan_+3A_filename">filename</code></td>
<td>
<p>a character string, the name of the file that is to be
read or to be written.</p>
</td></tr>
<tr><td><code id="codeplan_+3A_type">type</code></td>
<td>
<p>a character string (either &quot;yaml&quot; or &quot;json&quot;) oder NULL (the default), gives the type
of the file into which the codeplan is written or from
which it is read.
If <code>type</code> is NULL then the file type is inferred from
the file name ending (&quot;.yaml&quot; or &quot;,yml&quot; for &quot;yaml&quot;,
&quot;.json&quot; for &quot;json&quot;).
</p>
</td></tr>
<tr><td><code id="codeplan_+3A_pretty">pretty</code></td>
<td>
<p>a logical value, whether the JSON output created by <code>write_codeplan(...)</code> should be prettified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If applicable, <code>codeplan</code> returns a list with
additional S3 class attribute <code>"codeplan"</code>. For arguments for
which the relevant information does not exist, the function returns <code>NULL</code>.
</p>
<p>The list has at least one element or several elements, named after the
variable in the &quot;item.list&quot; or &quot;data.set&quot; <code>x</code>. Each list element
is a list itself with the following elements:
</p>
<table>
<tr><td><code>annotation</code></td>
<td>
<p>a named character vector,</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>a named list of labels and labelled values</p>
</td></tr>
<tr><td><code>value.filter</code></td>
<td>
<p>a list with at least two elements named
&quot;class&quot; and &quot;filter&quot;, and optionally another element named
&quot;range&quot;. The &quot;class&quot; element determines the class of the
value filter and equals either &quot;missing.values&quot;, &quot;valid.values&quot;,
or &quot;valid.range&quot;. An element named &quot;range&quot; may only be needed
if &quot;class&quot; is &quot;missing.values&quot;, as it is possible (like in SPSS)
to have <em>both</em> individual missing values and a range of
missing values.
</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>
<p>a character string that describes storage mode, such as <code>"character"</code>,
<code>"integer"</code>, or <code>"numeric"</code>.</p>
</td></tr>
<tr><td><code>measurement</code></td>
<td>
<p>a character string with the measurement level,
<code>"nominal"</code>, <code>"ordinal"</code>, <code>"interval"</code>, or
<code>"ratio"</code>.</p>
</td></tr>
</table>
<p>If <code>codeplan(x)&lt;-value</code> or <code>setCodeplan(x,value)</code> is used
and <code>value</code> is <code>NULL</code>, all the special information about
annotation, labels, value filters, etc. is removed from the resulting
object, which then is usually a mere atomic vector or data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Data1 &lt;- data.set(
          vote = sample(c(1,2,3,8,9,97,99),size=300,replace=TRUE),
          region = sample(c(rep(1,3),rep(2,2),3,99),size=300,replace=TRUE),
          income = exp(rnorm(300,sd=.7))*2000
          )

Data1 &lt;- within(Data1,{
  description(vote) &lt;- "Vote intention"
  description(region) &lt;- "Region of residence"
  description(income) &lt;- "Household income"
  foreach(x=c(vote,region),{
    measurement(x) &lt;- "nominal"
    })
  measurement(income) &lt;- "ratio"
  labels(vote) &lt;- c(
                    Conservatives         =  1,
                    Labour                =  2,
                    "Liberal Democrats"   =  3,
                    "Don't know"          =  8,
                    "Answer refused"      =  9,
                    "Not applicable"      = 97,
                    "Not asked in survey" = 99)
  labels(region) &lt;- c(
                    England               =  1,
                    Scotland              =  2,
                    Wales                 =  3,
                    "Not applicable"      = 97,
                    "Not asked in survey" = 99)
  foreach(x=c(vote,region,income),{
    annotation(x)["Remark"] &lt;- "This is not a real survey item, of course ..."
    })
  missing.values(vote) &lt;- c(8,9,97,99)
  missing.values(region) &lt;- c(97,99)
})
cpData1 &lt;- codeplan(Data1)

Data2 &lt;- data.frame(
          vote = sample(c(1,2,3,8,9,97,99),size=300,replace=TRUE),
          region = sample(c(rep(1,3),rep(2,2),3,99),size=300,replace=TRUE),
          income = exp(rnorm(300,sd=.7))*2000
          )
codeplan(Data2) &lt;- cpData1
codeplan(Data2)
codebook(Data2)

# Note the difference between 'as.data.frame' and setting
# the codeplan to NULL:
Data2df &lt;- as.data.frame(Data2)
codeplan(Data2) &lt;- NULL
str(Data2)
str(Data2df)
codeplan(Data2) &lt;- NULL # Does not change anything

# Codeplans of survey items can also be inquired and manipulated:
vote &lt;- Data1$vote
str(vote)
cp.vote &lt;- codeplan(vote)
codeplan(vote) &lt;- NULL
str(vote)
codeplan(vote) &lt;- cp.vote
vote

fn.json &lt;- paste0(tempfile(),".json")
write_codeplan(codeplan(Data1),filename=fn.json)
codeplan(Data2) &lt;- read_codeplan(fn.json)
codeplan(Data2)
</code></pre>

<hr>
<h2 id='collect'>Collect Objects</h2><span id='topic+collect'></span><span id='topic+collect.default'></span><span id='topic+collect.array'></span><span id='topic+collect.matrix'></span><span id='topic+collect.table'></span><span id='topic+collect.data.frame'></span><span id='topic+collect.data.set'></span>

<h3>Description</h3>

<p><code>collect</code> gathers several objects into one, matching the
elements or subsets of the objects by <code><a href="base.html#topic+names">names</a></code> or <code><a href="base.html#topic+dimnames">dimnames</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect(...,names=NULL,inclusive=TRUE)
## Default S3 method:
collect(...,names=NULL,inclusive=TRUE)
## S3 method for class 'array'
collect(...,names=NULL,inclusive=TRUE)
## S3 method for class 'matrix'
collect(...,names=NULL,inclusive=TRUE)
## S3 method for class 'table'
collect(...,names=NULL,sourcename=".origin",fill=0)
## S3 method for class 'data.frame'
collect(...,names=NULL,inclusive=TRUE,
                                  fussy=FALSE,warn=TRUE,
                                  detailed.warnings=FALSE,use.last=FALSE,
                                  sourcename=".origin")
## S3 method for class 'data.set'
collect(...,names=NULL,inclusive=TRUE,
                                  fussy=FALSE,warn=TRUE,
                                  detailed.warnings=FALSE,use.last=FALSE,
                                  sourcename=".origin")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect_+3A_...">...</code></td>
<td>
<p>more atomic vectors, arrays, matrices, tables, data.frames or data.sets</p>
</td></tr>
<tr><td><code id="collect_+3A_names">names</code></td>
<td>
<p>optional character vector; in case of the default and array methods,
giving <code><a href="base.html#topic+dimnames">dimnames</a></code> for the new dimension that identifies the
collected objects; in case of the data.frame and data.set methods,
levels of a factor indentifying the collected objects.
</p>
</td></tr>
<tr><td><code id="collect_+3A_inclusive">inclusive</code></td>
<td>
<p>logical, defaults to TRUE; should unmatched elements included? See details below.</p>
</td></tr>
<tr><td><code id="collect_+3A_fussy">fussy</code></td>
<td>
<p>logical, defaults to FALSE; should it count as an error, if variables with same
names of collected data.frames/data.sets have different attributes?</p>
</td></tr>
<tr><td><code id="collect_+3A_warn">warn</code></td>
<td>
<p>logical, defaults to TRUE; should an warning be given, if variables with same
names of collected data.frames/data.sets have different attributes?</p>
</td></tr>
<tr><td><code id="collect_+3A_detailed.warnings">detailed.warnings</code></td>
<td>
<p>logical, whether the attributes of each
variable should be printed if they differ, and if <code>warn</code> or
<code>fuzzy</code> is TRUE.</p>
</td></tr>
<tr><td><code id="collect_+3A_use.last">use.last</code></td>
<td>
<p>logical, defaults to FALSE. If the function is
applied to data frames or similar objects, attributes of variables
may differ between data frames (or other objects, respectively). If
this argument is TRUE, then the attributes are harmonised based on
the variables in the last data frame/object, otherwise the
attributes of variables in the first data frame/object are used for harmonisation.
</p>
</td></tr>
<tr><td><code id="collect_+3A_sourcename">sourcename</code></td>
<td>
<p>name of the factor that identifies the collected data.frames or data.sets</p>
</td></tr>
<tr><td><code id="collect_+3A_fill">fill</code></td>
<td>
<p>numeric; with what to fill empty table cells, defaults to zero, assuming
the table contains counts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> and all following ... arguments are vectors of the same mode (numeric,character, or logical)
the result is a matrix with as many columns as vectors. If argument <code>inclusive</code> is TRUE,
then the number of rows equals the number of names that appear at least once in each of the
vector names and the matrix is filled with <code>NA</code> where necessary,
otherwise the number of rows equals the number of names that are present in <em>all</em>
vector names.
</p>
<p>If <code>x</code> and all ... arguments are matrices or arrays of the same mode (numeric,character, or logical)
and <code class="reqn">n</code> dimension the result will be a <code class="reqn">n+1</code> dimensional array or table. The extend of the
<code class="reqn">n+1</code>th dimension equals the number of matrix, array or table arguments,
the extends of the lower dimension depends on the <code>inclusive</code> argument:
either they equal to the number of dimnames that appear at least once for each given
dimension and the array is filled with <code>NA</code> where necessary,
or they equal to the number of dimnames that appear in all arguments
for each given dimension.
</p>
<p>If <code>x</code> and all ... arguments are data frames or data sets, the
result is a data frame or data set.
The number of variables of the resulting data frame or data set depends on
the <code>inclusive</code> argument. If it is true, the number of variables
equals the number of variables that appear in each of the arguments at least once
and variables are filled with <code>NA</code> where necessary, otherwise the
number of variables equals the number of variables that are present in
all arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(a=1,b=2)
y &lt;- c(a=10,c=30)

x
y

collect(x,y)
collect(x,y,inclusive=FALSE)

X &lt;- matrix(1,nrow=2,ncol=2,dimnames=list(letters[1:2],LETTERS[1:2]))
Y &lt;- matrix(2,nrow=3,ncol=2,dimnames=list(letters[1:3],LETTERS[1:2]))
Z &lt;- matrix(3,nrow=2,ncol=3,dimnames=list(letters[1:2],LETTERS[1:3]))

X
Y
Z

collect(X,Y,Z)
collect(X,Y,Z,inclusive=FALSE)

X &lt;- matrix(1,nrow=2,ncol=2,dimnames=list(a=letters[1:2],b=LETTERS[1:2]))
Y &lt;- matrix(2,nrow=3,ncol=2,dimnames=list(a=letters[1:3],c=LETTERS[1:2]))
Z &lt;- matrix(3,nrow=2,ncol=3,dimnames=list(a=letters[1:2],c=LETTERS[1:3]))

collect(X,Y,Z)
collect(X,Y,Z,inclusive=FALSE)

df1 &lt;- data.frame(a=rep(1,5),b=rep(1,5))
df2 &lt;- data.frame(a=rep(2,5),b=rep(2,5),c=rep(2,5))
collect(df1,df2)
collect(df1,df2,inclusive=FALSE)

data(UCBAdmissions)
Male &lt;- as.table(UCBAdmissions[,1,])
Female &lt;- as.table(UCBAdmissions[,2,])
collect(Male,Female,sourcename="Gender")
collect(unclass(Male),unclass(Female))

Male1 &lt;- as.table(UCBAdmissions[,1,-1])
Female2 &lt;- as.table(UCBAdmissions[,2,-2])
Female3 &lt;- as.table(UCBAdmissions[,2,-3])
collect(Male=Male1,Female=Female2,sourcename="Gender")
collect(Male=Male1,Female=Female3,sourcename="Gender")
collect(Male=Male1,Female=Female3,sourcename="Gender",fill=NA)

f1 &lt;- gl(3,5,labels=letters[1:3])
f2 &lt;- gl(3,6,labels=letters[1:3])
collect(f1=table(f1),f2=table(f2))

ds1 &lt;- data.set(x = 1:3)
ds2 &lt;- data.set(x = 4:9,
                y = 1:6)
collect(ds1,ds2)

</code></pre>

<hr>
<h2 id='contr'>Convenience Methods for Setting Contrasts</h2><span id='topic+contr.treatment'></span><span id='topic+contr.sum'></span><span id='topic+contr'></span><span id='topic+contrasts'></span><span id='topic+contrasts+2Citem-method'></span><span id='topic+contrasts+2CANY-method'></span><span id='topic+contrasts+3C-'></span><span id='topic+contrasts+3C-+2Citem-method'></span><span id='topic+contrasts+3C-+2CANY-method'></span>

<h3>Description</h3>

<p>This package provides modified versions of
<code><a href="stats.html#topic+contrast">contr.treatment</a></code> and
<code><a href="stats.html#topic+contrast">contr.sum</a></code>. <code>contr.sum</code>
gains an optional <code>base</code> argument, analog to the
one of <code>contr.treatment</code>, furthermore,
the <code>base</code> argument may be the name of a
factor level.
</p>
<p><code>contr</code> returns a function that calls either
<code>contr.treatment</code>, <code>contr.sum</code>, etc.,
according to the value given to its first argument.
</p>
<p>The <code>contrasts</code> method for <code>"item"</code> objects
returns a contrast matrix or a function to produce
a contrast matrix for the factor into which
the item would be coerced via <code>as.factor</code> or <code>as.ordered</code>.
This matrix or function can be specified by
using <code>contrasts(x)&lt;-value</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr(type,...)
contr.treatment(n, base=1,contrasts=TRUE)
contr.sum(n,base=NULL,contrasts=TRUE)
## S4 method for signature 'item'
contrasts(x,contrasts=TRUE,...)
## S4 replacement method for signature 'item'
contrasts(x,how.many) &lt;- value
# These methods are defined implicitely by making 'contrasts' generic.
## S4 method for signature 'ANY'
contrasts(x,contrasts=TRUE,...)
## S4 replacement method for signature 'ANY'
contrasts(x,how.many) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr_+3A_type">type</code></td>
<td>
<p>a character vector, specifying the type of the contrasts.
This argument should have a value such that, if e.g. <code>type="something"</code>,
then there is a function <code>contr.something</code> that produces
a contrast matrix.
</p>
</td></tr>
<tr><td><code id="contr_+3A_...">...</code></td>
<td>
<p>further arguments, passed to <code>contr.treatment</code>, etc. </p>
</td></tr>
<tr><td><code id="contr_+3A_n">n</code></td>
<td>
<p>a number of factor levels or a vector of factor levels names, see e.g. <code><a href="stats.html#topic+contrast">contr.treatment</a></code>.</p>
</td></tr>
<tr><td><code id="contr_+3A_base">base</code></td>
<td>
<p>a number of a factor level or the names of a factor level,
which specifies the baseline category,
see e.g. <code><a href="stats.html#topic+contrast">contr.treatment</a></code> or NULL.
</p>
</td></tr>
<tr><td><code id="contr_+3A_contrasts">contrasts</code></td>
<td>
<p>a logical value, see  <code><a href="stats.html#topic+contrasts">contrasts</a></code></p>
</td></tr>
<tr><td><code id="contr_+3A_how.many">how.many</code></td>
<td>
<p>the number of contrasts to generate, see <code><a href="stats.html#topic+contrasts">contrasts</a></code></p>
</td></tr>
<tr><td><code id="contr_+3A_x">x</code></td>
<td>
<p>a factor or an object of class &quot;item&quot;</p>
</td></tr>
<tr><td><code id="contr_+3A_value">value</code></td>
<td>
<p>a matrix, a function or the name of a function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>contr</code> returns a funtion that calls one of <code>contr.treatment</code>,
<code>contr.sum,...</code>.
<code>contr.treatment</code> and <code>contr.sum</code> return contrast matrices.
<code>contrasts(x)</code> returns the &quot;contrasts&quot; attribute of an
object, which may be a function name, a function, a contrast matrix or NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctr.t &lt;- contr("treatment",base="c")
ctr.t
ctr.s &lt;- contr("sum",base="c")
ctr.h &lt;- contr("helmert")
ctr.t(letters[1:7])
ctr.s(letters[1:7])
ctr.h(letters[1:7])

x &lt;- factor(rep(letters[1:5],3))
contrasts(x)
x &lt;- as.item(x)
contrasts(x)
contrasts(x) &lt;- contr.sum(letters[1:5],base="c")
contrasts(x)
missing.values(x) &lt;- 5
contrasts(x)
contrasts(as.factor(x))

# Obviously setting missing values after specifying
# contrast matrix breaks the contrasts.
# Using the 'contr' function, however, prevents this:

missing.values(x) &lt;- NULL
contrasts(x) &lt;- contr("sum",base="c")
contrasts(x)
missing.values(x) &lt;- 5
contrasts(x)
contrasts(as.factor(x))
</code></pre>

<hr>
<h2 id='contract'>Contract data into pattern-frequency format</h2><span id='topic+contract'></span><span id='topic+contract.data.frame'></span><span id='topic+contract.data.set'></span>

<h3>Description</h3>

<p><code>contract()</code> contracts data into pattern-frequency format, similar
to a contatenation of <code>table()</code> (or <code>xtabs</code>) and
<code>as.data.frame()</code>. Yet it uses much less memory if patterns
are sparse, because it does not create rows for patterns that do not occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract(x,...)
## S3 method for class 'data.frame'
contract(x,by=NULL, weights=NULL,name="Freq",
    force.name=FALSE,sort=FALSE,drop.na=TRUE,...)
## S3 method for class 'data.set'
contract(x,by=NULL, weights=NULL,name="Freq",
    force.name=FALSE,sort=FALSE,drop.na=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contract_+3A_x">x</code></td>
<td>

<p>an object of class <code>"data.frame"</code> or <code>"data.set"</code>.
</p>
</td></tr>
<tr><td><code id="contract_+3A_by">by</code></td>
<td>
<p>the formula or a vector of variable names (quoted or not quoted).
Specifies the patterns (and optionally weights).
If <code>by</code> is a formula, then the right-hand side specifies the
variables the value patterns of which are counted.
If the left-hand side of the formula is (the name of) a numeric
vector, its values are used as weights (in which case the
<code>weights</code> argument will be ignored.) If the left-hand side of
the formula is (the name of) a factor, counts are computed  in
separate columns for each of its levels.
</p>
</td></tr>
<tr><td><code id="contract_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="contract_+3A_name">name</code></td>
<td>
<p>a character string, the name of the variable that
containts the frequency counts of the value patterns.</p>
</td></tr>
<tr><td><code id="contract_+3A_force.name">force.name</code></td>
<td>
<p>a logical value, defaults to <code>FALSE</code>. If
<code>TRUE</code> and the left-hand side of <code>by</code> formula is a factor,
the names of the columns with the counts are combinations of the
labels of the factor levels and the argument of <code>name</code>; if
<code>FALSE</code>, the column names are created from the labels of the
factor levels only.
</p>
</td></tr>
<tr><td><code id="contract_+3A_sort">sort</code></td>
<td>
<p>a logical value, defaults to <code>FALSE</code>. If <code>TRUE</code>,
the resulting data set is sorted by the variables that define the
patterns. If <code>FALSE</code>, the row of the resulting data frame or
data set are ordered according to the occurrence of the patterns. 
</p>
</td></tr>
<tr><td><code id="contract_+3A_drop.na">drop.na</code></td>
<td>
<p>a logical value, defaults to <code>TRUE</code>. If
<code>FALSE</code>, patterns that involve <code>NA</code> are included in the
resulting data frame or data set.</p>
</td></tr>
<tr><td><code id="contract_+3A_...">...</code></td>
<td>
<p>further arguments, passed to methods or ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a data fame, the value of <code>contract()</code> is also a
data frame. If it is a <code>"data.set"</code> object, the result is also a
<code>"data.set"</code> object. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_ &lt;- sample(iris,size=nrow(iris),replace=TRUE)
w &lt;- rep(1,nrow(iris_))
contract(iris[4:5])
contract(iris[4:5],sort=TRUE)
contract(iris[4:5],weights=w,sort=TRUE)
contract(iris,by=c(Petal.Width,Species),sort=TRUE)
contract(iris,by=~Petal.Width+Species)
contract(iris,by=w~Species)

library(MASS)
contract(housing,
         by=Sat~Infl+Type+Cont,
         weights=Freq)

contract(housing,
         by=Sat~Infl+Type+Cont,
         weights=Freq,
         name="housing",force.name=TRUE
         )
</code></pre>

<hr>
<h2 id='data.set'>Data Set Objects</h2><span id='topic+data.set'></span><span id='topic+data.set-class'></span><span id='topic+initialize+2Cdata.set-method'></span><span id='topic+is.data.set'></span><span id='topic+within+2Cdata.set-method'></span><span id='topic+print+2Cdata.set-method'></span><span id='topic+format+2Cdata.set-method'></span><span id='topic+show+2Cdata.set-method'></span><span id='topic+summary+2Cdata.set-method'></span><span id='topic+as.data.frame.data.set'></span><span id='topic+str.data.set'></span><span id='topic+as.data.set'></span><span id='topic+as.data.set+2Clist-method'></span><span id='topic++5B+3C-+2Cdata.set-method'></span><span id='topic++5B+2Cdata.set+2Catomic+2Catomic+2CANY-method'></span><span id='topic++5B+2Cdata.set+2Catomic+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdata.set+2Cmissing+2Catomic+2CANY-method'></span><span id='topic++5B+2Cdata.set+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic+dim+2Cdata.set-method'></span><span id='topic+dimnames+2Cdata.set-method'></span><span id='topic+dimnames+3C-+2Cdata.set-method'></span><span id='topic+row.names+2Cdata.set-method'></span><span id='topic+head+2Cdata.set-method'></span><span id='topic+tail+2Cdata.set-method'></span><span id='topic+tail+2Cdata.set-method'></span><span id='topic+as.data.table.data.set'></span><span id='topic+dsView'></span>

<h3>Description</h3>

<p><code>"data.set"</code> objects are collections of <code>"item"</code> objects,
with similar semantics as data frames. They are distinguished
from data frames so that coercion by <code>as.data.fame</code>
leads to a data frame that contains only vectors and factors.
Nevertheless most methods for data frames are inherited by
data sets, except for the method for the <code>within</code> generic
function. For the <code>within</code> method for data sets, see the details section.
</p>
<p>Thus data preparation using data sets retains all informations
about item annotations, labels, missing values etc.
While (mostly automatic) conversion of data sets into data
frames makes the data amenable for the use of R's statistical
functions.
</p>
<p><code>dsView</code> is a function that displays data sets in a similar
manner as <code>View</code> displays data frames. (<code>View</code> works
with data sets as well, but changes them first into data frames.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.set(...,row.names = NULL, check.rows = FALSE, check.names = TRUE,
    stringsAsFactors = FALSE, document = NULL)
as.data.set(x, row.names=NULL, ...)
## S4 method for signature 'list'
as.data.set(x,row.names=NULL,...)
is.data.set(x)
## S3 method for class 'data.set'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
## S4 method for signature 'data.set'
within(data, expr, ...)

dsView(x)

## S4 method for signature 'data.set'
head(x,n=20,...)
## S4 method for signature 'data.set'
tail(x,n=20,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.set_+3A_...">...</code></td>
<td>

<p>For the <code>data.set</code> function several vectors or items,
for <code>within</code> further, ignored arguments.
</p>
</td></tr>
<tr><td><code id="data.set_+3A_row.names">row.names</code>, <code id="data.set_+3A_check.rows">check.rows</code>, <code id="data.set_+3A_check.names">check.names</code>, <code id="data.set_+3A_stringsasfactors">stringsAsFactors</code>, <code id="data.set_+3A_optional">optional</code></td>
<td>
<p>arguments
as in <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>,
respectively.
</p>
</td></tr>
<tr><td><code id="data.set_+3A_document">document</code></td>
<td>
<p>NULL or an optional character vector that contains
documenation of the data.</p>
</td></tr>
<tr><td><code id="data.set_+3A_x">x</code></td>
<td>
<p>for <code>is.data.set(x)</code>, any object; for
<code>as.data.frame(x,...)</code> and <code>dsView(x)</code> a &quot;data.set&quot; object.</p>
</td></tr>
<tr><td><code id="data.set_+3A_data">data</code></td>
<td>
<p>a data set, that is, an object of class &quot;data.set&quot;. </p>
</td></tr>
<tr><td><code id="data.set_+3A_expr">expr</code></td>
<td>
<p>an expression, or several expressions enclosed in curly braces.</p>
</td></tr>
<tr><td><code id="data.set_+3A_n">n</code></td>
<td>
<p>integer; the number of rows to be shown by <code>head</code> or <code>tail</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>as.data.frame</code> method for data sets is just a copy
of the method for list. Consequently, all items in the data set
are coerced in accordance to their <code><a href="#topic+measurement">measurement</a></code> setting,
see <code><a href="#topic+as.vector+2Citem-method">as.vector,item-method</a></code> and <code><a href="#topic+measurement">measurement</a></code>.
</p>
<p>The <code>within</code> method for data sets has the same effect as
the <code><a href="base.html#topic+with">within</a></code> method for data frames, apart from two differences:
all results of the computations are coerced into items if
they have the appropriate length, otherwise, they are automatically
dropped.
</p>
<p>Currently only one method for the generic function <code>as.data.set</code>
is defined: a method for &quot;importer&quot; objects.
</p>


<h3>Value</h3>

<p><code>data.set</code> and the <code>within</code> method for
data sets returns a &quot;data.set&quot; object, <code>is.data.set</code>
returns a logical value, and <code>as.data.frame</code> returns
a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Data &lt;- data.set(
          vote = sample(c(1,2,3,8,9,97,99),size=300,replace=TRUE),
          region = sample(c(rep(1,3),rep(2,2),3,99),size=300,replace=TRUE),
          income = exp(rnorm(300,sd=.7))*2000
          )

Data &lt;- within(Data,{
  description(vote) &lt;- "Vote intention"
  description(region) &lt;- "Region of residence"
  description(income) &lt;- "Household income"
  wording(vote) &lt;- "If a general election would take place next tuesday,
                    the candidate of which party would you vote for?"
  wording(income) &lt;- "All things taken into account, how much do all
                    household members earn in sum?"
  foreach(x=c(vote,region),{
    measurement(x) &lt;- "nominal"
    })
  measurement(income) &lt;- "ratio"
  labels(vote) &lt;- c(
                    Conservatives         =  1,
                    Labour                =  2,
                    "Liberal Democrats"   =  3,
                    "Don't know"          =  8,
                    "Answer refused"      =  9,
                    "Not applicable"      = 97,
                    "Not asked in survey" = 99)
  labels(region) &lt;- c(
                    England               =  1,
                    Scotland              =  2,
                    Wales                 =  3,
                    "Not applicable"      = 97,
                    "Not asked in survey" = 99)
  foreach(x=c(vote,region,income),{
    annotation(x)["Remark"] &lt;- "This is not a real survey item, of course ..."
    })
  missing.values(vote) &lt;- c(8,9,97,99)
  missing.values(region) &lt;- c(97,99)

  # These to variables do not appear in the
  # the resulting data set, since they have the wrong length.
  junk1 &lt;- 1:5
  junk2 &lt;- matrix(5,4,4)
  
})
# Since data sets may be huge, only a
# part of them are 'show'n
Data

## Not run: 

# If we insist on seeing all, we can use 'print' instead
print(Data)

## End(Not run)

str(Data)
summary(Data)

## Not run: 
# If we want to 'View' a data set we can use 'dsView'
dsView(Data)
# Works also, but changes the data set into a data frame first:
View(Data)

## End(Not run)

Data[[1]]
Data[1,]
head(as.data.frame(Data))

EnglandData &lt;- subset(Data,region == "England")
EnglandData

xtabs(~vote+region,data=Data)
xtabs(~vote+region,data=within(Data, vote &lt;- include.missings(vote)))
</code></pre>

<hr>
<h2 id='data.set+20manipulation'>Manipulation of Data Sets</h2><span id='topic+subset.data.set'></span><span id='topic+unique+2Cdata.set-method'></span><span id='topic+merge+2Cdata.set+2Cdata.set-method'></span><span id='topic+merge+2Cdata.set+2Cdata.frame-method'></span><span id='topic+merge+2Cdata.frame+2Cdata.set-method'></span><span id='topic+cbind.data.set'></span><span id='topic+rbind.data.set'></span>

<h3>Description</h3>

<p>Like data frames, <code>data.set</code> objects have
<code><a href="base.html#topic+subset">subset</a></code>, <code><a href="base.html#topic+unique">unique</a></code>,
<code><a href="base.html#topic+cbind">cbind</a></code>, <code><a href="base.html#topic+cbind">rbind</a></code>,
<code><a href="base.html#topic+merge">merge</a></code> methods defined for them.
</p>
<p>The semantics are basically the same as the methods defined
for data frames in the <code>base</code> package, with the only difference
that the return values are <code>data.set</code> objects.
In fact, the methods described here are front-ends to the
corresponding methods for data frames, which are constructed
such that the &quot;extra&quot; information attached to variables within
<code>data.set</code> objects, that is, to <code>item</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.set'
subset(x, subset, select, drop = FALSE, ...)

## S4 method for signature 'data.set'
unique(x, incomparables = FALSE, ...)

## S3 method for class 'data.set'
cbind(..., deparse.level = 1)

## S3 method for class 'data.set'
rbind(..., deparse.level = 1)

## S4 method for signature 'data.set,data.set'
merge(x,y, ...)

## S4 method for signature 'data.set,data.frame'
merge(x,y, ...)

## S4 method for signature 'data.frame,data.set'
merge(x,y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.set+2B20manipulation_+3A_x">x</code>, <code id="data.set+2B20manipulation_+3A_y">y</code></td>
<td>
<p><code>data.set</code> objects. On of the arguments to
<code>merge</code> may also be an object coercable into a data frame
and the result still is a <code>data.set</code> object.
</p>
</td></tr>
<tr><td><code id="data.set+2B20manipulation_+3A_subset">subset</code></td>
<td>
<p>a logical expression, used to select observations from
the data set.</p>
</td></tr>
<tr><td><code id="data.set+2B20manipulation_+3A_select">select</code></td>
<td>
<p>a vector with variablen names, which are retained in the
data subset.</p>
</td></tr>
<tr><td><code id="data.set+2B20manipulation_+3A_drop">drop</code></td>
<td>
<p>logical; if <code>TRUE</code> and the result has only one
column, the result is an item and not a data set.</p>
</td></tr>
<tr><td><code id="data.set+2B20manipulation_+3A_...">...</code></td>
<td>
<p>for <code>subset</code>: a logical vector
of the same length as the number of rows of the <code>data.set</code>
and, optionally, a vector of variable names (tagged as <code>select</code>);
for <code>unique</code>: further arguments, ignored;
for <code>cbind</code>, <code>rbind</code>: objects coercable
into data frames, with at least one being a <code>data.set</code>
object;
for <code>merge</code>: further arguments
such as arguments tagged with <code>by</code>, <code>by.x</code>, <code>by.y</code>,
etc. that specify the variables by which to merge
the data sets of data frames <code>x</code> and <code>y</code>.
</p>
</td></tr>
<tr><td><code id="data.set+2B20manipulation_+3A_incomparables">incomparables</code></td>
<td>
<p>a vector of values that cannot be compared. See
<code><a href="base.html#topic+unique">unique</a></code>.
</p>
</td></tr>
<tr><td><code id="data.set+2B20manipulation_+3A_deparse.level">deparse.level</code></td>
<td>
<p>an argument retained for
reasons of compatibility of the default methods
of <code><a href="base.html#topic+cbind">cbind</a></code> and <code><a href="base.html#topic+cbind">rbind</a></code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ds1 &lt;- data.set(
      a = rep(1:3,5),
      b = rep(1:5,each=3)
  )
ds2 &lt;- data.set(
      a = c(3:1,3,3),
      b = 1:5
  )

ds1 &lt;- within(ds1,{
      description(a) &lt;- "Example variable 'a'"
      description(b) &lt;- "Example variable 'b'"
  })

ds2 &lt;- within(ds2,{
      description(a) &lt;- "Example variable 'a'"
      description(b) &lt;- "Example variable 'b'"
  })

str(ds3 &lt;- rbind(ds1,ds2))
description(ds3)

ds3 &lt;- within(ds1,{
        c &lt;- a
        d &lt;- b
        description(c) &lt;- "Copy of variable 'a'"
        description(d) &lt;- "Copy of variable 'b'"
        rm(a,b)
    })
str(ds4 &lt;- cbind(ds1,ds3))
description(ds4)

ds5 &lt;- data.set(
        c = 1:3,
        d = c(1,1,2)
        )
ds5 &lt;- within(ds5,{
      description(c) &lt;- "Example variable 'c'"
      description(d) &lt;- "Example variable 'd'"
  })
str(ds6 &lt;- merge(ds1,ds5,by.x="a",by.y="c"))

# Note that the attributes of the left-hand variables
# have priority.
description(ds6)
</code></pre>

<hr>
<h2 id='deduplicate_labels'>Handle duplicated labels</h2><span id='topic+deduplicate_labels'></span><span id='topic+deduplicate_labels.item'></span><span id='topic+deduplicate_labels.item.list'></span>

<h3>Description</h3>

<p>The function <code>deduplicate_labels</code> can be used with &quot;item&quot; objects,
&quot;importer&quot; objects or &quot;data.set&quot; objects to deal with 
duplicate labels,
i.e. labels that are attached to more than
one code. There are several ways to de-duplicate labels: by combining
values that share their label or by making labels duplicate labels distinct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deduplicate_labels(x,...)
## S3 method for class 'item'
deduplicate_labels(x,
    method=c("combine codes",
             "prefix values",
             "postfix values"),...)
# Applicable to 'importer' objects and 'data.set' objects
## S3 method for class 'item.list'
deduplicate_labels(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deduplicate_labels_+3A_x">x</code></td>
<td>
<p>an item with value labels or that contains items with
value labels</p>
</td></tr>
<tr><td><code id="deduplicate_labels_+3A_method">method</code></td>
<td>
<p>a character string that determines the method to
make value labels unique.</p>
</td></tr>
<tr><td><code id="deduplicate_labels_+3A_...">...</code></td>
<td>
<p>other arguments, passed to specific methods of the
generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>deduplicate_labels</code> a copy of <code>x</code>
that has unqiue value labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- as.item(rep(1:5,4),
              labels=c(
                  A = 1,
                  A = 2,
                  B = 3,
                  B = 4,
                  C = 5
              ),
              annotation = c(
                  description="Yet another test"
))
              
x2 &lt;- as.item(rep(1:4,5),
              labels=c(
                  i   = 1,
                  ii  = 2,
                  iii = 3,
                  iii = 4
                  ),
              annotation = c(
                  description="Still another test"
))

x3 &lt;- as.item(rep(1:2,10),
              labels=c(
                  a = 1,
                  b = 2
                  ),
              annotation = c(
                  description="Still another test"
))
                            
codebook(deduplicate_labels(x1))
codebook(deduplicate_labels(x1,method="prefix"))
codebook(deduplicate_labels(x1,method="postfix"))

ds &lt;- data.set(x1,x2,x3)
codebook(deduplicate_labels(ds))
codebook(deduplicate_labels(ds,method="prefix"))
codebook(deduplicate_labels(ds,method="postfix"))

</code></pre>

<hr>
<h2 id='Descriptives'>Vectors of Univariate Sample Statistics</h2><span id='topic+Descriptives'></span><span id='topic+Descriptives+2CANY-method'></span><span id='topic+Descriptives+2Catomic-method'></span><span id='topic+Descriptives+2Citem.vector-method'></span>

<h3>Description</h3>

<p><code>Descriptives(x)</code> gives a vector of sample statistics
for use in <code><a href="#topic+codebook">codebook</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Descriptives(x,...)
## S4 method for signature 'atomic'
Descriptives(x, weights = NULL, ...)
## S4 method for signature 'item.vector'
Descriptives(x, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Descriptives_+3A_x">x</code></td>
<td>
<p>an atomic vector or <code>"item.vector"</code> object. </p>
</td></tr>
<tr><td><code id="Descriptives_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights.</p>
</td></tr>
<tr><td><code id="Descriptives_+3A_...">...</code></td>
<td>
<p>further arguments, to be passed to future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of sample statistics, containing the range, the
mean, the standard deviation, the skewness and the (excess) kurtosis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
Descriptives(x)
</code></pre>

<hr>
<h2 id='dimrename'>Change dimnames, rownames, or colnames</h2><span id='topic+dimrename'></span><span id='topic+colrename'></span><span id='topic+rowrename'></span>

<h3>Description</h3>

<p>These functions provide an easy way to change the <code>dimnames</code>, <code>rownames</code> or <code>colnames</code> of
an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimrename(x, dim = 1, ..., gsub = FALSE, fixed = TRUE, warn = TRUE)
rowrename(x, ..., gsub = FALSE, fixed = TRUE, warn = TRUE)
colrename(x, ..., gsub = FALSE, fixed = TRUE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimrename_+3A_x">x</code></td>
<td>
<p>An array with dimnames</p>
</td></tr>
<tr><td><code id="dimrename_+3A_dim">dim</code></td>
<td>
<p>A vector that indicates the dimensions</p>
</td></tr>
<tr><td><code id="dimrename_+3A_...">...</code></td>
<td>
<p>A sequence of named arguments</p>
</td></tr>
<tr><td><code id="dimrename_+3A_gsub">gsub</code></td>
<td>
<p>a logical value; if TRUE, <code><a href="base.html#topic+gsub">gsub</a></code> is used to change the
<code>dimnames</code> of the object.
That is, instead of substituting whole names, substrings of the
<code>dimnames</code> of the object can changed.
</p>
</td></tr>
<tr><td><code id="dimrename_+3A_fixed">fixed</code></td>
<td>
<p>a logical value, passed to <code><a href="base.html#topic+gsub">gsub</a></code>. If TRUE,
substitutions are by fixed strings and not by regular expressions.</p>
</td></tr>
<tr><td><code id="dimrename_+3A_warn">warn</code></td>
<td>
<p>logical; should a warning be issued if the pattern is not found?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dimrename</code> changes the dimnames of <code>x</code> along dimension(s) <code>dim</code> according to the
remaining arguments. The argument names are the <em>old</em>
names, the values are the new names.
<code>rowrename</code> is a shorthand for changing the rownames,
<code>colrename</code> is a shorthand for changing the colnames of a matrix
or matrix-like object.
</p>
<p>If <code>gsub</code> is FALSE, argument tags are the <em>old</em>
<code>dimnames</code>, the values are the new <code>dimnames</code>.
If <code>gsub</code> is TRUE, arguments are substrings of the <code>dimnames</code>
that are substituted by the argument values.
</p>


<h3>Value</h3>

<p>Object <code>x</code> with changed dimnames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1,2,2)
rownames(m) &lt;- letters[1:2]
colnames(m) &lt;- LETTERS[1:2]
m
dimrename(m,1,a="first",b="second")
dimrename(m,1,A="first",B="second")
dimrename(m,2,"A"="first",B="second")

rowrename(m,a="first",b="second")
colrename(m,"A"="first",B="second")

# Since version 0.99.22 - the following also works:

dimrename(m,1,a=first,b=second)
dimrename(m,1,A=first,B=second)
dimrename(m,2,A=first,B=second)
</code></pre>

<hr>
<h2 id='duplicated_labels'>Check for and report duplicated labels</h2><span id='topic+duplicated_labels'></span><span id='topic+duplicated_labels.item'></span><span id='topic+duplicated_labels.item.list'></span>

<h3>Description</h3>

<p>The function <code>duplicated_labels</code> can be used with &quot;item&quot; objects,
&quot;importer&quot; objects or &quot;data.set&quot; objects to check whether items
contain duplicate labels, i.e. labels that are attached to more than
one code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicated_labels(x)
## S3 method for class 'item'
duplicated_labels(x)
# Applicable to 'importer' objects and 'data.set' objects
## S3 method for class 'item.list'
duplicated_labels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicated_labels_+3A_x">x</code></td>
<td>
<p>an item with value labels or that contains items with
value labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>duplicate.labels</code> returns a list with a class
attribute, which allows pretty printing of duplicated value labels</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- as.item(rep(1:5,4),
              labels=c(
                  A = 1,
                  A = 2,
                  B = 3,
                  B = 4,
                  C = 5
              ),
              annotation = c(
                  description="Yet another test"
))
              
x2 &lt;- as.item(rep(1:4,5),
              labels=c(
                  i   = 1,
                  ii  = 2,
                  iii = 3,
                  iii = 4
                  ),
              annotation = c(
                  description="Still another test"
))

x3 &lt;- as.item(rep(1:2,10),
              labels=c(
                  a = 1,
                  b = 2
                  ),
              annotation = c(
                  description="Still another test"
))
                            
duplicated_labels(x1)
ds &lt;- data.set(x1,x2,x3)
duplicated_labels(ds)
codebook(ds)

nes1948.por &lt;- unzip(system.file("anes/NES1948.ZIP",package="memisc"),
                     "NES1948.POR",exdir=tempfile())
nes1948 &lt;- spss.portable.file(nes1948.por)
duplicated_labels(nes1948)             
</code></pre>

<hr>
<h2 id='foreach'>Loop over Variables in a Data Frame or Environment</h2><span id='topic+foreach'></span>

<h3>Description</h3>

<p><code>foreach</code> evaluates an expression given as untagged argument by substituting
in variables. The expression may also contain assignments, which take effect in
the caller's environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  foreach(...,.sorted,.outer=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreach_+3A_...">...</code></td>
<td>
<p>tagged and untagged arguments.
The tagged arguments define the 'variables' that are looped over,
the first untagged argument defines the expression wich is
evaluated.
</p>
</td></tr>
<tr><td><code id="foreach_+3A_.sorted">.sorted</code></td>
<td>
<p>an optional logical value; relevant only
when a range of variable is specified using the column operator
&quot;<code>:</code>&quot;. Decises whether variable names should be sorted
alphabetically before the range of variables are created.
</p>
<p>If this argument missing, its default value is TRUE, if <code>foreach()</code> is called
in the global environment, otherwise it is FALSE.
</p>
</td></tr>
<tr><td><code id="foreach_+3A_.outer">.outer</code></td>
<td>
<p>an optional logical value; if TRUE, each combination of
the variables is used to evaluate the expression,
if FALSE (the default) then the variables all need to have
the same length and the corresponding values of the
variables are used in the evaluation of the expression.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
y &lt;- -(1:3)
z &lt;- c("Uri","Schwyz","Unterwalden")
print(x)
print(y)
print(z)
foreach(var=c(x,y,z),          # assigns names
  names(var) &lt;- letters[1:3]   # to the elements of x, y, and z
  )
print(x)
print(y)
print(z)

ds &lt;- data.set(
        a = c(1,2,3,2,3,8,9),
        b = c(2,8,3,2,1,8,9),
        c = c(1,3,2,1,2,8,8)
      )
print(ds)
ds &lt;- within(ds,{ 
      description(a) &lt;- "First item in questionnaire"
      description(b) &lt;- "Second item in questionnaire"
      description(c) &lt;- "Third item in questionnaire"
      
      wording(a) &lt;- "What number do you like first?"
      wording(b) &lt;- "What number do you like second?"
      wording(c) &lt;- "What number do you like third?"

      foreach(x=a:c,{ # Lazy data documentation:
        labels(x) &lt;- c(    # a,b,c get value labels in one statement
                         one = 1,
                         two = 2,
                       three = 3,
                "don't know" = 8,
         "refused to answer" = 9)
        missing.values(x) &lt;- c(8,9)
        })
      })
      
codebook(ds)

# The colon-operator respects the order of the variables
# in the data set, if .sorted=FALSE
with(ds[c(3,1,2)],
     foreach(x=a:c,
             print(description(x))
            ))

# Since .sorted=TRUE, the colon operator creates a range 
# of alphabetically sorted variables.
with(ds[c(3,1,2)],
     foreach(x=a:c,
             print(description(x)),
             .sorted=TRUE
            ))

# The variables in reverse order
with(ds,
     foreach(x=c:a,
             print(description(x))
            ))

# The colon operator can be combined with the 
# concatenation function
with(ds,
     foreach(x=c(a:b,c,c,b:a),
             print(description(x))
            ))

# Variables can also be selected by regular expressions.
with(ds,
     foreach(x=rx("[a-b]"),
             print(description(x))
            ))

# A demonstration for '.outer=TRUE'
foreach(l=letters[1:2],
        i=1:3,
        cat(paste0(l,i,"\n")),
        .outer=TRUE)

</code></pre>

<hr>
<h2 id='format_html'>
Format Objects in HTML, show the HTML Format or Write it to a File
</h2><span id='topic+show_html'></span><span id='topic+format_html'></span><span id='topic+write_html'></span><span id='topic+df_format_stdstyle'></span><span id='topic+mat_format_stdstyle'></span><span id='topic+format_html.data.frame'></span><span id='topic+format_html.matrix'></span>

<h3>Description</h3>

<p><code>show_html</code> is for showing objects in a convenient way in HTML format. 
<code>write_html</code> writes them in HTML format into a file.
Both functions call the generic <code>format_html</code> for the format conversion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_html(x, output = NULL, ...)
write_html(x, file, ...)

format_html(x, ...)

## S3 method for class 'data.frame'
format_html(x,
    toprule=2,midrule=1,bottomrule=2,
    split.dec=TRUE,
    row.names=TRUE,
    digits=getOption("digits"),
    format="f",
    style=df_format_stdstyle,
    margin="2ex auto", 
    ...)
    
## S3 method for class 'matrix'
format_html(x,
    toprule=2,midrule=1,bottomrule=2,
    split.dec=TRUE,
    formatC=FALSE,
    digits=getOption("digits"),
    format="f",
    style=mat_format_stdstyle,
    margin="2ex auto", 
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_html_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="format_html_+3A_output">output</code></td>
<td>
<p>character string or a function
that determines how the HTML formatted object is shown.
</p>
<p>If <code>output</code> is a function, it is called with the path
of a (temporary) file with HTML code, e.g. <em>RStudio</em>'s <code>viewer</code>
function (which is available in the package <code>rstudioapi</code>.
</p>
<p>If <code>output</code> equals &quot;stdout&quot;, the HTML code is written to the 
standard output stream (for use e.g. in output produced with <code>knitr</code>),
if &quot;file-show&quot;, the contents of a file with the HTML code is shown
via <code><a href="base.html#topic+file.show">file.show</a></code>, and
if &quot;browser&quot;, the contents of a file with the HTML code is shown
by the standard browser (via <code><a href="utils.html#topic+browseURL">browseURL</a></code>).
</p>
<p>This arguments has different defaults, depending of the type of
the session. In non-interactive sessions, the default is
&quot;console&quot;, in interactive sessions other than RStudio,
it is &quot;browser&quot;, in interactive sessions with RStudio
it is &quot;file-show&quot;.
</p>
<p>These default settings can be overriden by the option &quot;html_viewer&quot;
(see <code><a href="base.html#topic+options">options</a></code>).
</p>
</td></tr>
<tr><td><code id="format_html_+3A_file">file</code></td>
<td>
<p>character string; name or path of the file where to
write the HTML code to.</p>
</td></tr>
<tr><td><code id="format_html_+3A_toprule">toprule</code></td>
<td>
<p>integer;
thickness in pixels of rule at the top of the table.</p>
</td></tr>
<tr><td><code id="format_html_+3A_midrule">midrule</code></td>
<td>
<p>integer;
thickness in pixels of rules within the table.</p>
</td></tr>
<tr><td><code id="format_html_+3A_bottomrule">bottomrule</code></td>
<td>
<p>integer;
thickness in pixels of rule at the bottom of the table.</p>
</td></tr>
<tr><td><code id="format_html_+3A_split.dec">split.dec</code></td>
<td>
<p>logical; whether numbers should be centered
at the decimal point by splitting the table cells.</p>
</td></tr>
<tr><td><code id="format_html_+3A_row.names">row.names</code></td>
<td>
<p>logical; whether row names should be shown/exported.</p>
</td></tr>
<tr><td><code id="format_html_+3A_digits">digits</code></td>
<td>
<p>number of digits to be shown after the decimal dot. This is only useful, if
the &quot;ftable&quot; object was created from a table created with <code><a href="#topic+genTable">genTable</a></code> or the like.</p>
</td></tr>
<tr><td><code id="format_html_+3A_formatc">formatC</code></td>
<td>
<p>logical; whether to use <code><a href="base.html#topic+formatC">formatC</a></code> instead
of <code><a href="base.html#topic+format">format</a></code> to format cell contents.</p>
</td></tr>
<tr><td><code id="format_html_+3A_format">format</code></td>
<td>
<p>a format string for <code><a href="base.html#topic+formatC">formatC</a></code></p>
</td></tr>
<tr><td><code id="format_html_+3A_style">style</code></td>
<td>
<p>string containing the stanard CSS styling of table cells.</p>
</td></tr>
<tr><td><code id="format_html_+3A_margin">margin</code></td>
<td>
<p>character string, determines the margin and thus
the position of the HTML table.</p>
</td></tr>
<tr><td><code id="format_html_+3A_...">...</code></td>
<td>
<p>other arguments, passed on to formatter functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>format_html</code> character string with code suitable for inclusion into a HTML-file.
</p>

<hr>
<h2 id='format_html.codebook'>
Format Codebooks as HTML
</h2><span id='topic+format_html.codebook'></span>

<h3>Description</h3>

<p>This is the method of <code><a href="#topic+format_html">format_html</a></code> for &quot;codebook&quot; objects as created
by the eponymous function (see <code><a href="#topic+codebook">codebook</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'codebook'
format_html(x, 
    toprule = 2, midrule = 1, 
    padding = 3, 
    var_tag = "code", 
    varid_prefix = "", title_tag = "p",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_html.codebook_+3A_x">x</code></td>
<td>
<p>a &quot;codebook&quot; object</p>
</td></tr>
<tr><td><code id="format_html.codebook_+3A_toprule">toprule</code></td>
<td>
<p>a non-negative integer; thickness of the line (in pixels) at the top of each
codebook entry</p>
</td></tr>
<tr><td><code id="format_html.codebook_+3A_midrule">midrule</code></td>
<td>
<p>a non-negative integer; thickness of the line (in pixels) that separates the
header of an codebook entry from its body</p>
</td></tr>
<tr><td><code id="format_html.codebook_+3A_padding">padding</code></td>
<td>
<p>a non-negative integer; left-hand padding in &quot;ex&quot; of the 
codebook entry contents</p>
</td></tr>
<tr><td><code id="format_html.codebook_+3A_var_tag">var_tag</code></td>
<td>
<p>character string; the HTML tag that contains the 
name of the variable</p>
</td></tr>
<tr><td><code id="format_html.codebook_+3A_varid_prefix">varid_prefix</code></td>
<td>
<p>character string; a prefix added to 
the anchor IDs of the code entry titles (to facilitate the 
creation of tables of contents etc.)</p>
</td></tr>
<tr><td><code id="format_html.codebook_+3A_title_tag">title_tag</code></td>
<td>
<p>character string; the HTML tag that contains 
the title of the codebook entry (the variable name and its description)</p>
</td></tr>
<tr><td><code id="format_html.codebook_+3A_...">...</code></td>
<td>
<p>further arguments, ignored.</p>
</td></tr></table>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+format_html">format_html</a></code>, <code><a href="#topic+show_html">show_html</a></code>, <code><a href="#topic+write_html">write_html</a></code>.
</p>

<hr>
<h2 id='format_html.ftable'>
Format &quot;Flattened Tables&quot; as HTML
</h2><span id='topic+format_html.ftable'></span><span id='topic+format_html.ftable_matrix'></span><span id='topic+ftable_format_stdstyle'></span>

<h3>Description</h3>

<p>This is the method of <code><a href="#topic+format_html">format_html</a></code> for &quot;ftable&quot; objects (i.e. flattened
contingency tables)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ftable'
format_html(x, 
                   show.titles = TRUE, 
                   digits = 0, 
                   format = "f", 
                   toprule = 2, midrule = 1, bottomrule = 2, 
                   split.dec = TRUE, 
                   style = ftable_format_stdstyle,
                   margin="2ex auto", 
                   ...)
## S3 method for class 'ftable_matrix'
format_html(x,
                   show.titles=TRUE,
                   digits=0,
                   format="f",
                   toprule=2,midrule=1,bottomrule=2,
                   split.dec=TRUE,
                   style = ftable_format_stdstyle,
                   margin="2ex auto", 
                   varontop,varinfront,
                   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_html.ftable_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+ftable">ftable</a></code>.</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_show.titles">show.titles</code></td>
<td>
<p>logical; should the names of the cross-classified variables be shown?</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_digits">digits</code></td>
<td>
<p>number of digits to be shown after the decimal dot. This is only useful, if
the &quot;ftable&quot; object was created from a table created with <code><a href="#topic+genTable">genTable</a></code> or the like.</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_format">format</code></td>
<td>
<p>a format string for <code><a href="base.html#topic+formatC">formatC</a></code></p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_toprule">toprule</code></td>
<td>
<p>integer;
thickness in pixels of rule at the top of the table.</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_midrule">midrule</code></td>
<td>
<p>integer;
thickness in pixels of rules within the table.</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_bottomrule">bottomrule</code></td>
<td>
<p>integer;
thickness in pixels of rule at the bottom of the table.</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_split.dec">split.dec</code></td>
<td>
<p>logical; whether numbers should be centered
at the decimal point by splitting the table cells.</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_style">style</code></td>
<td>
<p>string containing the stanard CSS styling of table cells.</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_margin">margin</code></td>
<td>
<p>character string, determines the margin and thus
the position of the HTML table.</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_varontop">varontop</code></td>
<td>
<p>logical; whether names of column variables should appear on top of factor levels</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_varinfront">varinfront</code></td>
<td>
<p>logical; whether names of row variables should appear in front of factor levels</p>
</td></tr>
<tr><td><code id="format_html.ftable_+3A_...">...</code></td>
<td>
<p>further arguments, ignored.</p>
</td></tr></table>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+format_html">format_html</a></code>, <code><a href="#topic+show_html">show_html</a></code>, <code><a href="#topic+write_html">write_html</a></code>.
</p>

<hr>
<h2 id='format_md'>
Format Codebooks as Markdown
</h2><span id='topic+format_md'></span><span id='topic+format_md.codebook'></span><span id='topic+format_md.codebookEntry'></span>

<h3>Description</h3>

<p><code>format_md</code> is for showing objects in a convenient way in Markdown
format. Can be included to Rmarkdown file with the <code>cat()</code> function and the
<code>results='asis'</code> code block option. The following example should be runned
in a Rmd file with different output formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'codebook'
format_md(x, ...)
## S3 method for class 'codebookEntry'
format_md(x, name = "", add_rules = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_md_+3A_x">x</code></td>
<td>
<p>a &quot;codebook&quot; or &quot;codebookEntry&quot; object</p>
</td></tr>
<tr><td><code id="format_md_+3A_name">name</code></td>
<td>
<p>a string; the variable name</p>
</td></tr>
<tr><td><code id="format_md_+3A_add_rules">add_rules</code></td>
<td>
<p>a boolean value; if TRUE adds a horizontal rules before and after the title</p>
</td></tr>
<tr><td><code id="format_md_+3A_...">...</code></td>
<td>
<p>further arguments, passed to other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>format_md</code> character string with code suitable for inclusion into a Markdown-file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(memisc)

Data1 &lt;- data.set(
  vote = sample(c(1,2,3,8,9,97,99),size=300,replace=TRUE),
  region = sample(c(rep(1,3),rep(2,2),3,99),size=300,replace=TRUE),
  income = exp(rnorm(300,sd=.7))*2000
)

Data1 &lt;- within(Data1,{
  description(vote) &lt;- "Vote intention"
  description(region) &lt;- "Region of residence"
  description(income) &lt;- "Household income"
  foreach(x=c(vote,region),{
    measurement(x) &lt;- "nominal"
  })
  measurement(income) &lt;- "ratio"
  labels(vote) &lt;- c(
    Conservatives         =  1,
    Labour                =  2,
    "Liberal Democrats"   =  3,
    "Don't know"          =  8,
    "Answer refused"      =  9,
    "Not applicable"      = 97,
    "Not asked in survey" = 99)
  labels(region) &lt;- c(
    England               =  1,
    Scotland              =  2,
    Wales                 =  3,
    "Not applicable"      = 97,
    "Not asked in survey" = 99)
  foreach(x=c(vote,region,income),{
    annotation(x)["Remark"] &lt;- "This is not a real survey item, of course ..."
  })
  missing.values(vote) &lt;- c(8,9,97,99)
  missing.values(region) &lt;- c(97,99)
})

codebook_data &lt;- codebook(Data1)

codebook_md &lt;- format_md(codebook_data, digits = 2)

writeLines(codebook_md)

## Not run: 
writeLines(codebook_md,con="codebook-example.md")

## End(Not run)
 
</code></pre>

<hr>
<h2 id='ftable-matrix'>
Combining flattened tables.
</h2><span id='topic+ftable_matrix'></span><span id='topic+cbind.ftable'></span><span id='topic+rbind.ftable'></span><span id='topic+cbind.ftable_matrix'></span><span id='topic+rbind.ftable_matrix'></span><span id='topic+format.ftable_matrix'></span><span id='topic+print.ftable_matrix'></span><span id='topic+Write.ftable_matrix'></span>

<h3>Description</h3>

<p>With the method functions described here, flattened (contingency) tables can be combined
into more complex objects, of class <code>"ftable_matrix"</code>. For objects of these class 
<code>format</code> and <code>print</code> methods are provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ftable'
cbind(..., deparse.level=1)

## S3 method for class 'ftable'
rbind(..., deparse.level=1)

## S3 method for class 'ftable_matrix'
cbind(..., deparse.level=1)

## S3 method for class 'ftable_matrix'
rbind(..., deparse.level=1)

## S3 method for class 'ftable_matrix'
format(x,quote=TRUE,digits=0,format="f",...)

## S3 method for class 'ftable_matrix'
Write(x,
                            file = "",
                            quote = TRUE,
                            append = FALSE,
                            digits = 0,
                            ...)
                            
## S3 method for class 'ftable_matrix'
print(x,quote=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ftable-matrix_+3A_...">...</code></td>
<td>
<p>for <code>cbind</code> and <code>rbind</code> methods, two or more objects
of class <code>"ftable"</code> or <code>"ftable_matrix"</code>; for the other methods: further 
arguments, ignored.</p>
</td></tr>
<tr><td><code id="ftable-matrix_+3A_deparse.level">deparse.level</code></td>
<td>
<p>ignored, retained for compatibility reasons only.</p>
</td></tr>
<tr><td><code id="ftable-matrix_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="ftable-matrix_+3A_quote">quote</code></td>
<td>
<p>logical, indicating whether or not strings should be printed with 
surrounding quotes.</p>
</td></tr> 
<tr><td><code id="ftable-matrix_+3A_digits">digits</code></td>
<td>
<p>numeric or integer, number of significant digits to be shown.</p>
</td></tr>
<tr><td><code id="ftable-matrix_+3A_format">format</code></td>
<td>
<p>a format string as in <code><a href="base.html#topic+formatC">formatC</a></code></p>
</td></tr> 
<tr><td><code id="ftable-matrix_+3A_file">file</code></td>
<td>
<p>character string, containing a file path.</p>
</td></tr>
<tr><td><code id="ftable-matrix_+3A_append">append</code></td>
<td>
<p>logical, should the output appended to the file?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cbind</code> and <code>rbind</code>, when used with <code>"ftable"</code> or <code>"ftable_matrix"</code>
objects, return objects of class <code>"ftable_matrix"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ft1 &lt;- ftable(Sex~Survived,Titanic)
ft2 &lt;- ftable(Age+Class~Survived,Titanic)
ft3 &lt;- ftable(Survived~Class,Titanic)
ft4 &lt;- ftable(Survived~Age,Titanic)
ft5 &lt;- ftable(Survived~Sex,Titanic)

tab10 &lt;- xtabs(Freq~Survived,Titanic)

(c12.10 &lt;- cbind(ft1,ft2,Total=tab10))
(r345.10 &lt;- rbind(ft3,ft4,ft5,Total=tab10))

## Not run: 
tf &lt;- tempfile()
Write(c12.10,file=tf)
file.show(tf)

## End(Not run)
</code></pre>

<hr>
<h2 id='genTable'>Generic Tables and Data Frames of Descriptive Statistics</h2><span id='topic+Aggregate'></span><span id='topic+genTable'></span>

<h3>Description</h3>

<p><code>genTable</code> creates a table of arbitrary summaries conditional on
given values of independent variables given by a formula.
</p>
<p><code>Aggregate</code> does the same, but returns a <code>data.frame</code> instead.
</p>
<p><code>fapply</code> is a generic function that dispatches on its <code>data</code>
argument. It is called internally by <code>Aggregate</code> and <code>genTable</code>.
Methods for this function can be used to adapt <code>Aggregate</code> and
<code>genTable</code> to data sources other than data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aggregate(formula, data=parent.frame(), subset=NULL,
          names=NULL, addFreq=TRUE, drop = TRUE, as.vars=1,
          ...)

genTable(formula, data=parent.frame(), subset=NULL,
         names=NULL, addFreq=TRUE,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTable_+3A_formula">formula</code></td>
<td>
<p>a formula. The right hand side includes one or more
grouping variables separated by '+'. These may be factors, numeric,
or character vectors. The left hand side may be empty,
a numerical variable, a factor, or an expression.
See details below.</p>
</td></tr>
<tr><td><code id="genTable_+3A_data">data</code></td>
<td>
<p>an environment or data frame or an object coercable into a data frame.</p>
</td></tr>
<tr><td><code id="genTable_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="genTable_+3A_names">names</code></td>
<td>
<p>an optional character vector giving names to the
result(s) yielded by the expression on the left hand side of <code>formula</code>.
This argument may be redundant if the left hand side results in is a named vector.
(See the example below.)</p>
</td></tr>
<tr><td><code id="genTable_+3A_addfreq">addFreq</code></td>
<td>
<p>a logical value. If <code>TRUE</code> and
<code>data</code> is a table or a data frame with a variable
named &quot;Freq&quot;, a call to
<code>table</code>, <code><a href="#topic+Table">Table</a></code>, <code><a href="#topic+percent">percent</a></code>, or <code><a href="#topic+nvalid">nvalid</a></code>
is supplied by an additional argument <code>Freq</code>
and a call to <code>table</code> is translated into
a call to <code>Table</code>.
</p>
</td></tr>
<tr><td><code id="genTable_+3A_drop">drop</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, empty groups (i.e. when
there are no observations in the aggregated data frame that contain
the defining combination of values or factor levels of the
conditioning variables in <code>by</code>) are dropped from the result of
<code>Aggregate</code>. Otherwise, result are filled with <code>NA</code>, where appropriate.
</p>
</td></tr>
<tr><td><code id="genTable_+3A_as.vars">as.vars</code></td>
<td>
<p>an integer; relevant only if the left hand side of the formula returns
an array or a matrix - which dimension (rows, columns, or layers etc.) will transformed to
variables? Defaults to columns in case of matrices and to the highest dimensional extend
in case of arrays.</p>
</td></tr>
<tr><td><code id="genTable_+3A_...">...</code></td>
<td>
<p>further arguments, passed to methods or ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an expression is given as left hand side of the formula, its
value is computed for any combination of values of the values on the
right hand side. If the right hand side is a dot, then all
variables in <code>data</code> are added to the right hand side of the
formula.
</p>
<p>If no expression is given as left hand side,
then the frequency counts for the respective
value combinations of the right hand variables are computed.
</p>
<p>If a single factor is on the left hand side, then the left hand side is
translated into an appropriate
call to <code>table()</code>. Note that also in this case <code>addFreq</code> takes effect.
</p>
<p>If a single numeric variable is on the left hand side, frequency
counts weighted by this variable are computed. In these cases,
<code>genTable</code> is equivalent to <code><a href="stats.html#topic+xtabs">xtabs</a></code> and
<code>Aggregate</code> is equivalent to <code>as.data.frame(xtabs(...))</code>.
</p>


<h3>Value</h3>

<p><code>Aggregate</code>
results in a data frame with conditional summaries and unique value combinations
of conditioning variables.
</p>
<p><code>genTable</code> returns a <a href="base.html#topic+table">table</a>, that is, an array with class <code>"table"</code>.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+aggregate.data.frame">aggregate.data.frame</a>, <a href="stats.html#topic+xtabs">xtabs</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>ex.data &lt;- expand.grid(mu=c(0,100),sigma=c(1,10))[rep(1:4,rep(100,4)),]
ex.data &lt;- within(ex.data,
                  x&lt;-rnorm(
                    n=nrow(ex.data),
                    mean=mu,
                    sd=sigma
                    )
                  )

Aggregate(~mu+sigma,data=ex.data)
Aggregate(mean(x)~mu+sigma,data=ex.data)
Aggregate(mean(x)~mu+sigma,data=ex.data,name="Average")
Aggregate(c(mean(x),sd(x))~mu+sigma,data=ex.data)
Aggregate(c(Mean=mean(x),StDev=sd(x),N=length(x))~mu+sigma,data=ex.data)
genTable(c(Mean=mean(x),StDev=sd(x),N=length(x))~mu+sigma,data=ex.data)

Aggregate(table(Admit)~.,data=UCBAdmissions)
Aggregate(Table(Admit,Freq)~.,data=UCBAdmissions)
Aggregate(Admit~.,data=UCBAdmissions)
Aggregate(percent(Admit)~.,data=UCBAdmissions)
Aggregate(percent(Admit)~Gender,data=UCBAdmissions)
Aggregate(percent(Admit)~Dept,data=UCBAdmissions)
Aggregate(percent(Gender)~Dept,data=UCBAdmissions)
Aggregate(percent(Admit)~Dept,data=UCBAdmissions,Gender=="Female")
genTable(percent(Admit)~Dept,data=UCBAdmissions,Gender=="Female")
</code></pre>

<hr>
<h2 id='getSummary'>Get Model Summaries for Use with &quot;mtable&quot;</h2><span id='topic+getSummary'></span><span id='topic+getSummary_expcoef'></span><span id='topic+getSummary.lm'></span><span id='topic+getSummary.glm'></span><span id='topic+getSummary.clm'></span><span id='topic+getSummary.polr'></span><span id='topic+getSummary.simex'></span><span id='topic+getSummary_expcoef.default'></span><span id='topic+getSummary.aftreg'></span><span id='topic+getSummary.coxph'></span><span id='topic+getSummary.phreg'></span><span id='topic+getSummary.survreg'></span><span id='topic+getSummary.weibreg'></span><span id='topic+getSummary.merMod'></span><span id='topic+getSummary.ivreg'></span><span id='topic+getSummary.tobit'></span><span id='topic+getSummary.hurdle'></span><span id='topic+getSummary.zeroinfl'></span><span id='topic+getSummary.betareg'></span><span id='topic+getSummary.multinom'></span>

<h3>Description</h3>

<p>A generic function and methods to collect coefficients
and summary statistics from a model object. It is used in <code><a href="#topic+mtable">mtable</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  ## S3 method for class 'lm'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'glm'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'merMod'
getSummary(obj, alpha=.05, ...)

# These are contributed by Christopher N. Lawrence
  ## S3 method for class 'clm'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'polr'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'simex'
getSummary(obj, alpha=.05,...)

# These are contributed by Jason W. Morgan
  ## S3 method for class 'aftreg'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'coxph'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'phreg'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'survreg'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'weibreg'
getSummary(obj, alpha=.05,...)

# These are contributed by Achim Zeileis
  ## S3 method for class 'ivreg'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'tobit'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'hurdle'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'zeroinfl'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'betareg'
getSummary(obj, alpha=.05,...)
  ## S3 method for class 'multinom'
getSummary(obj, alpha=.05,...)
  
# A variant that reports exponentiated coefficients.
# The default method calls 'getSummary()' internally and should
# be applicable to all classes for which 'getSummary()' methods exist.
getSummary_expcoef(obj, alpha=.05,...)
  ## Default S3 method:
getSummary_expcoef(obj, alpha=.05,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSummary_+3A_obj">obj</code></td>
<td>
<p>a model object, e.g. of class <code>lm</code> or <code>glm</code></p>
</td></tr>
<tr><td><code id="getSummary_+3A_alpha">alpha</code></td>
<td>
<p>level of the confidence intervals; their coverage should
be 1-alpha/2 </p>
</td></tr>
<tr><td><code id="getSummary_+3A_...">...</code></td>
<td>
<p>further arguments; ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function <code>getSummary</code> is called by <code><a href="#topic+mtable">mtable</a></code>
in order to obtain the coefficients and summaries of model objects.
In order to adapt <code><a href="#topic+mtable">mtable</a></code> to models of classes other
than <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> one needs to
define <code>getSummary</code> methods for these classes and
to set a summary template via <code><a href="#topic+setSummaryTemplate">setSummaryTemplate</a></code>
</p>


<h3>Value</h3>

<p>Any method of <code>getSummary</code> must return a list with the following
components:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>an array with coefficient estimates;
the lowest dimension <em>must</em> have the following
names and meanings:
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>est</code> </td><td style="text-align: center;">  </td><td style="text-align: left;"> the coefficient estimates,</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>se</code>  </td><td style="text-align: center;">  </td><td style="text-align: left;"> the estimated standard errors,</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>stat</code></td><td style="text-align: center;">  </td><td style="text-align: left;"> t- or Wald-z statistics,</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>p</code>   </td><td style="text-align: center;">  </td><td style="text-align: left;"> significance levels of the statistics,</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>lwr</code> </td><td style="text-align: center;">  </td><td style="text-align: left;"> lower confidence limits, </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>upr</code> </td><td style="text-align: center;">  </td><td style="text-align: left;"> upper confidence limits. </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td>
</tr>

</table>

<p>The higher dimensions of the array correspond to
the individual coefficients and, in multi-equation models,
to the model equations.
</p>
</td></tr>
<tr><td><code>sumstat</code></td>
<td>
<p>a vector containing the model summary statistics;
the components may have arbitrary names.</p>
</td></tr>
</table>

<hr>
<h2 id='Groups'>Operate on grouped data in data frames and data sets</h2><span id='topic+Groups'></span><span id='topic+Groups.data.set'></span><span id='topic+Groups.data.frame'></span><span id='topic+grouped.data'></span><span id='topic+Groups.grouped.data'></span><span id='topic+with.grouped.data'></span><span id='topic+within.grouped.data'></span><span id='topic+recombine'></span><span id='topic+recombine.grouped.data.frame'></span><span id='topic+recombine.grouped.data.set'></span><span id='topic+as.data.frame.grouped.data'></span><span id='topic+as.data.set+2Cgrouped.data.frame-method'></span><span id='topic+as.data.set+2Cgrouped.data.set-method'></span><span id='topic+withGroups'></span><span id='topic+withinGroups'></span>

<h3>Description</h3>

<p><code>Group</code> creates a grouped variant of an object of
class &quot;data.frame&quot; or of class &quot;data.set&quot;, for which methods for
<code>with</code> and <code>within</code> are defined, so that these well-known
functions can be applied &quot;groupwise&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Create an object of class "grouped.data" from a
# data frame or a data set.
Groups(data,by,...)
## S3 method for class 'data.frame'
Groups(data,by,...)
## S3 method for class 'data.set'
Groups(data,by,...)
## S3 method for class 'grouped.data'
Groups(data,by,...)

# Recombine grouped data into a data fame or a data set
recombine(x,...)
## S3 method for class 'grouped.data.frame'
recombine(x,...)
## S3 method for class 'grouped.data.set'
recombine(x,...)

# Recombine grouped data and coerce the result appropriately:
## S3 method for class 'grouped.data'
as.data.frame(x,...)
## S4 method for signature 'grouped.data.frame'
as.data.set(x,row.names=NULL,...)
## S4 method for signature 'grouped.data.set'
as.data.set(x,row.names=NULL,...)

# Methods of the generics "with" and "within" for grouped data
## S3 method for class 'grouped.data'
with(data,expr,...)
## S3 method for class 'grouped.data'
within(data,expr,recombine=FALSE,...)

# This is equivalent to with(Groups(data,by),expr,...)
withGroups(data,by,expr,...)
# This is equivalent to within(Groups(data,by),expr,recombine,...)
withinGroups(data,by,expr,recombine=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Groups_+3A_data">data</code></td>
<td>
<p>an object of the classes &quot;data.frame&quot;, &quot;data.set&quot; if an
argument to <code>Groups</code>, <code>withGroups</code>, <code>withinGroups</code>,
</p>
</td></tr>
<tr><td><code id="Groups_+3A_by">by</code></td>
<td>
<p>a formula with the factors the levels of which define the
groups.</p>
</td></tr>
<tr><td><code id="Groups_+3A_expr">expr</code></td>
<td>
<p>an expression, or several expressions enclosed in curly
braces.</p>
</td></tr>
<tr><td><code id="Groups_+3A_recombine">recombine</code></td>
<td>
<p>a logical vector; should the resulting grouped
data be recombined?</p>
</td></tr>
<tr><td><code id="Groups_+3A_x">x</code></td>
<td>
<p>an object of class &quot;grouped.data&quot;.</p>
</td></tr>
<tr><td><code id="Groups_+3A_row.names">row.names</code></td>
<td>
<p>an optional character vector with row names.</p>
</td></tr>
<tr><td><code id="Groups_+3A_...">...</code></td>
<td>
<p>other arguments, ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When applied to a data frame <code>Groups</code> returns an object with class attributes
&quot;grouped.data.frame&quot;, &quot;grouped.data&quot;, and &quot;data.frame&quot;, when applied do an object with class
&quot;data.set&quot;, it returns an object with class attributes &quot;grouped.data.set&quot;,
&quot;grouped.data&quot;, and &quot;data.set&quot;.
</p>
<p>When applied to objects with class attributed
&quot;grouped.data&quot;, both the functions <code>with()</code> amd <code>within()</code>
evaluate <code>expr</code> separately for each group defined by
<code>Groups</code>. <code>with()</code> returns an array composed of the results
of <code>expr</code>, while <code>within()</code> returns a modified copy of its
<code>data</code> argument, which will be a &quot;grouped.data&quot; object
(&quot;grouped.data.frame&quot; or &quot;grouped.data.set&quot;), unless the argument
<code>recombine=TRUE</code> is set.
</p>
<p>The expression <code>expr</code> may contain references to the variables
<code>n_</code>, <code>N_</code>, and <code>i_</code>. <code>n_</code> is equal to the size of
the respective group (the number of rows belonging to it), while
<code>N_</code> is equal to the total number of observations in all
groups. The variable <code>i_</code> equals to the indices of the rows
belonging to the respective group of observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>some.data &lt;- data.frame(x=rnorm(n=100))
some.data &lt;- within(some.data,{
    f &lt;- factor(rep(1:4,each=25),labels=letters[1:4])
    g &lt;- factor(rep(1:5,each=4,5),labels=LETTERS[1:5])
    y &lt;- x + rep(1:4,each=25) +  0.75*rep(1:5,each=4,5)
})

# For demonstration purposes, we create an
# 'empty' group:
some.data &lt;- subset(some.data,
                       f!="a" | g!="C")

some.grouped.data &lt;- Groups(some.data,
                           ~f+g)    

# Computing the means of y for each combination f and g
group.means &lt;- with(some.grouped.data,
                    mean(y))
group.means

# Obtaining a groupwise centered variant of y
some.grouped.data &lt;- within(some.grouped.data,{
    y.cent &lt;- y - mean(y)
},recombine=FALSE)

# The groupwise centered variable should have zero mean
# whithin each group
group.means &lt;- with(some.grouped.data,
                    round(mean(y.cent),15))
group.means

# The following demonstrates the use of n_, N_, and i_
# An external copy of y
y1 &lt;- some.data$y
group.means.n &lt;- with(some.grouped.data,
                      c(mean(y),  # Group means for y
                        n_,       # Group sizes
                        sum(y)/n_,# Group means for y
                        n_/N_,    # Relative group sizes
                        sum(y1)/N_,# NOT the grand mean
                        sum(y1[i_])/n_)) # Group mean for y1
group.means.n

# Names can be attached to the groupwise results
with(some.grouped.data,
     c(Centered=round(mean(y.cent),15),
       Uncentered=mean(y)))

some.data.ungrouped &lt;- recombine(some.grouped.data)
str(some.data.ungrouped)

# It all works with "data.set" objects
some.dataset &lt;- as.data.set(some.data)
some.grouped.dataset &lt;- Groups(some.dataset,~f+g)

with(some.grouped.dataset,
     c(Mean=mean(y),
       Variance=var(y)))

# The following two expressions are equivalent:
with(Groups(some.data,~f+g),mean(y))
withGroups(some.data,~f+g,mean(y))

# The following two expressions are equivalent:
some.data &lt;- within(Groups(some.data,~f+g),{
    y.cent &lt;- y - mean(y)
    y.cent.1 &lt;- y - sum(y)/n_
})

some.data &lt;- withinGroups(some.data,~f+g,{
    y.cent &lt;- y - mean(y)
    y.cent.1 &lt;- y - sum(y)/n_
})

# Both variants of groupwise centred varaibles should
# have zero groupwise means:
withGroups(some.data,~f+g,{
    c(round(mean(y.cent),15),
      round(mean(y.cent.1),15))
})

</code></pre>

<hr>
<h2 id='html'>
Building Blocks for HTML Code
</h2><span id='topic+html'></span><span id='topic+print.html_elem'></span><span id='topic+as.character.html_elem'></span><span id='topic+c.html_elem'></span><span id='topic+html_group'></span><span id='topic+as.html_group'></span><span id='topic+as.character.html_group'></span><span id='topic+print.html_group'></span><span id='topic++5B.html_group'></span><span id='topic++5B+3C-.html_group'></span><span id='topic+c.html_group'></span><span id='topic+content'></span><span id='topic+content+3C-'></span><span id='topic+setContent'></span><span id='topic+attribs'></span><span id='topic+attribs+3C-'></span><span id='topic+setAttribs'></span><span id='topic+setAttribs.character'></span><span id='topic+setAttribs.html_elem'></span><span id='topic+setAttribs.html_group'></span><span id='topic++5B+3C-.html_attributes'></span><span id='topic+css'></span><span id='topic+as.css'></span><span id='topic+style'></span><span id='topic+style+3C-'></span><span id='topic+setStyle'></span><span id='topic+setStyle.character'></span><span id='topic+setStyle.html_elem'></span><span id='topic+setStyle.html_group'></span><span id='topic+as.character.css'></span><span id='topic+print.css'></span><span id='topic++5B+3C-.css'></span>

<h3>Description</h3>

<p>The functions described here form building blocks for
the <code><a href="#topic+format_html">format_html</a></code> methods functions for <code>codebook</code>,
<code>ftable</code>, <code>ftable_matrix</code>, and <code>mtable</code> objects, etc.
</p>
<p>The most basic of these functions is <code>html</code>, which constructs an
object that represents a minimal piece of HTML code and is member of the
class <code>"html_elem"</code>. Unlike a character string containing HTML
code, the resulting code element can relatively easily modified using
other functions presented here. The actual code is created when the
function <code>as.character</code> is applied to these objects.
</p>
<p>Longer sequences of HTML code can be prepared by 
concatenating them with <code>c</code>, or by <code>html_group</code>,
or by applying <code>as.html_group</code> to a list of 
<code>"html_elem"</code> objects. All these result in objects
of class <code>"html_group"</code>.
</p>
<p>Attributes (such as class, id etc.) of HTML elements can be added to the
call to <code>html</code>, but can also later recalled or modified with
<code>attribs</code> or <code>setAttribs</code>. An important attribute
is the style attribute, which can contain CSS styling. It can
be recalled or modified with <code>style</code> or <code>setStyle</code>. Styling
strings can also be created with <code>hmtl_style</code> or <code>as.css</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html(tag, ..., .content = NULL, linebreak = FALSE)
html_group(...)
as.html_group(x)

content(x)
content(x)&lt;-value
setContent(x,value)

attribs(x)
attribs(x)&lt;-value
setAttribs(x,...)
## S3 method for class 'character'
setAttribs(x,...)
## S3 method for class 'html_elem'
setAttribs(x,...)
## S3 method for class 'html_group'
setAttribs(x,...)

css(...)
as.css(x)
style(x)
style(x) &lt;- value
setStyle(x,...)
## S3 method for class 'character'
setStyle(x,...)
## S3 method for class 'html_elem'
setStyle(x,...)
## S3 method for class 'html_group'
setStyle(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_+3A_tag">tag</code></td>
<td>
<p>a character string that determines the opening and closing
tags of the HTML element. (The closing tag is relevant only if
the element has a content.)</p>
</td></tr>
<tr><td><code id="html_+3A_...">...</code></td>
<td>
<p>optional further arguments, named or not.
</p>
<p>For <code>html</code>: named arguments create the attributes of the HTML element,
unnamed arguments define the content of the HTML element, i.e. whatever 
appears between opening and closing tags (e.g. <code>&lt;p&gt;</code> and <code>&lt;/p&gt;</code>).
Character strings, <code>"html_elem"</code>, or <code>"html_group"</code> objects can appear
as content of a HTML element.
</p>
<p>For <code>setAttribs</code>: named arguments create the attributes of the HTML element,
unnamed arguments are ignored.
</p>
<p>For <code>setStyle</code>: named arguments create the styling of the HTML element,
unnamed arguments are ignored.
</p>
<p>For <code>html_group</code>: several objects of class <code>"html_elem"</code>
or <code>"html_group"</code>.
</p>
<p>For <code>css</code>: named arguments (character strings!) 
become components of a styling in CSS format.
</p>
</td></tr>
<tr><td><code id="html_+3A_.content">.content</code></td>
<td>
<p>an optional character string, <code>"html_elem"</code>, or 
<code>"html_group"</code> object</p>
</td></tr>
<tr><td><code id="html_+3A_linebreak">linebreak</code></td>
<td>
<p>a logical value or vector of length 2, determines
whether linebreaks are inserted after the HTML tags.</p>
</td></tr>
<tr><td><code id="html_+3A_x">x</code></td>
<td>
<p>an object. For <code>as.html_group</code>, this should be a list
of objects of class <code>"html_elem"</code> or <code>"html_group"</code>. 
For <code>content</code>, <code>setContent</code>, <code>attribs</code>, 
<code>setAttribs</code>, <code>style</code>, <code>setStyle</code>,
this should be an object of class <code>"html_elem"</code> or <code>"html_group"</code>.  
</p>
</td></tr>
<tr><td><code id="html_+3A_value">value</code></td>
<td>
<p>an object of appropriate class. 
</p>
<p>For <code>content&lt;-</code>: a character string, <code>"html_elem"</code>, or 
<code>"html_group"</code> object, or a concatenation thereof.
</p>
<p>For <code>attribs&lt;-</code> or <code>style&lt;-</code>: a named character vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects created with <code>html</code> are lists with class attribute
<code>"html_elem"</code> and components
</p>

<dl>
<dt>tag</dt><dd><p>a character string</p>
</dd>
<dt>attributes</dt><dd><p>a named character vector</p>
</dd>
<dt>content</dt><dd><p>a character vector, an <code>"html_elem"</code> or <code>"html_group"</code>
object, or a list of such.
</p>
</dd>
<dt>linebreak</dt><dd><p>a logical value or vector of length 2.</p>
</dd>
</dl>

<p>Objects created with <code>html_group</code> or by concatenation
of <code>"html_elem"</code> or <code>"html_group"</code>
object
are lists of such objects, with class attribute <code>"html_group"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html("img")
html("img",src="test.png")
html("div",class="element",id="first","Sisyphus")
html("div",class="element",id="first",.content="Sisyphus")

div &lt;- html("div",class="element",id="first",linebreak=c(TRUE,TRUE))
content(div) &lt;- "Sisyphus"
div

tag &lt;- html("tag",linebreak=TRUE)
attribs(tag)["class"] &lt;- "something"
attribs(tag)["class"]
tag

style(tag) &lt;- c(color="#342334")
style(tag)
tag

style(tag)["bg"] &lt;- "white"
tag

setStyle(tag,bg="black")
setStyle(tag,c(bg="black"))

c(div,tag,tag)

c(
  c(div,tag),
  c(div,tag,tag)
)

c(
  c(div,tag),
  div,tag,tag
)

c(
  div,tag,
  c(div,tag,tag)
)

content(div) &lt;- c(tag,tag,tag)
div


css("background-color"="black",
                  color="white")

as.css(c("background-color"="black",
                  color="white"))



Hello &lt;- "Hello World!"
Hello &lt;- html("p",Hello,linebreak=c(TRUE,TRUE))
style(Hello) &lt;- c(color="white",
                  "font-size"="40px",
                  "text-align"="center")
     
Link &lt;- html("a","More examples here ...",
             href="http://elff.eu/software/memisc",
             title="More examples here ...",
             style=css(color="white"),
             linebreak=c(TRUE,FALSE))
Link &lt;- html("p"," (",Link,")",linebreak=c(TRUE,TRUE))
style(Link) &lt;- c(color="white",
                 "font-size"="15px",
                 "text-align"="center")

Hello &lt;- html("div",c(Hello,Link),linebreak=c(TRUE,TRUE))
style(Hello) &lt;- c("background-color"="#160666",
                  padding="20px")
Hello

show_html(Hello)

</code></pre>

<hr>
<h2 id='Iconv'>Convert Annotations, and Value Labels between Encodings</h2><span id='topic+Iconv'></span><span id='topic+Iconv.annotation'></span><span id='topic+Iconv.data.set'></span><span id='topic+Iconv.importer'></span><span id='topic+Iconv.item'></span><span id='topic+Iconv.value.labels'></span>

<h3>Description</h3>

<p>This function uses the base package function <code><a href="base.html#topic+iconv">iconv</a></code>
to translate variable descriptions (a.k.a variable labels) and
value labels of <code><a href="#topic+item">item</a></code>, <code><a href="#topic+data.set">data.set</a></code>,
and <code><a href="#topic+importer">importer</a></code> objects into a specified encoding.
</p>
<p>It will be useful in UTF-8 systems when data file come in some ancient
encoding like 'Latin-1' as long used by Windows systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Iconv(x,from="",to="",...) 
## S3 method for class 'annotation'
Iconv(x,from="",to="",...) 
## S3 method for class 'data.set'
Iconv(x,from="",to="",...) 
## S3 method for class 'importer'
Iconv(x,from="",to="",...) 
## S3 method for class 'item'
Iconv(x,from="",to="",...) 
## S3 method for class 'value.labels'
Iconv(x,from="",to="",...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Iconv_+3A_x">x</code></td>
<td>
<p>an object of which attributes are to be re-encoded.</p>
</td></tr>
<tr><td><code id="Iconv_+3A_from">from</code></td>
<td>
<p>a character string desribing the original encoding</p>
</td></tr>
<tr><td><code id="Iconv_+3A_to">to</code></td>
<td>
<p>a character string desribing the target encoding</p>
</td></tr>
<tr><td><code id="Iconv_+3A_...">...</code></td>
<td>
<p>further arguments, passed to <code><a href="base.html#topic+iconv">iconv</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Iconv returns a copy of its first argument with re-encoded 
attributes.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+iconv">iconv</a></code>, <code><a href="base.html#topic+iconv">iconvlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Locate an SPSS 'system' file and get info on variables, their labels etc.
ZA5302 &lt;- spss.system.file("Daten/ZA5302_v6-0-0.sav",to.lower=FALSE)

# Convert labels etc. from 'latin1' to the encoding of the current locale.
ZA5302 &lt;- Iconv(ZA5302,from="latin1")

# Write out the codebook
writeLines(as.character(codebook(ZA5302)),
           con="ZA5302-cdbk.txt")

# Write out the description of the varialbes (their 'variable labels')
writeLines(as.character(description(ZA5302)),
            con="ZA5302-description.txt")

## End(Not run)
</code></pre>

<hr>
<h2 id='importers'>Object Oriented Interface to Foreign Files</h2><span id='topic+importer'></span><span id='topic+importer-class'></span><span id='topic+spss.file'></span><span id='topic+spss.portable.file'></span><span id='topic+spss.portable.importer-class'></span><span id='topic+show+2Cspss.portable.importer-method'></span><span id='topic+spss.system.file'></span><span id='topic+spss.system.importer-class'></span><span id='topic+show+2Cspss.system.importer-method'></span><span id='topic+spss.fixed.file'></span><span id='topic+spss.fixed.importer-class'></span><span id='topic+show+2Cspss.fixed.importer-method'></span><span id='topic+Stata.file'></span><span id='topic+Stata.importer-class'></span><span id='topic+show+2CStata.importer-method'></span><span id='topic+Stata_new.importer-class'></span><span id='topic+show+2CStata_new.importer-method'></span><span id='topic+as.data.set+2Cimporter-method'></span><span id='topic+dim+2Cimporter-method'></span><span id='topic+names+2Cimporter-method'></span><span id='topic++5B+2Cimporter+2Catomic+2Catomic+2CANY-method'></span><span id='topic++5B+2Cimporter+2Catomic+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cimporter+2Cmissing+2Catomic+2CANY-method'></span><span id='topic++5B+2Cimporter+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+5B+2Cimporter-method'></span><span id='topic++24+2Cimporter-method'></span><span id='topic+head+2Cimporter-method'></span><span id='topic+tail+2Cimporter-method'></span><span id='topic+initialize+2Cspss.portable.importer-method'></span><span id='topic+initialize+2Cspss.system.importer-method'></span><span id='topic+initialize+2Cspss.fixed.importer-method'></span><span id='topic+initialize+2CStata.importer-method'></span><span id='topic+initialize+2CStata_new.importer-method'></span><span id='topic+subset.spss.portable.importer'></span><span id='topic+subset.spss.system.importer'></span><span id='topic+subset.spss.fixed.importer'></span><span id='topic+subset.Stata.importer'></span><span id='topic+subset.Stata_new.importer'></span>

<h3>Description</h3>

<p>Importer objects are objects that refer to an external
data file. Currently only Stata files,
SPSS system, portable, and fixed-column files are supported.
</p>
<p>Data are actually imported by &lsquo;translating&rsquo; an
importer file into a <code><a href="#topic+data.set">data.set</a></code> using
<code>as.data.set</code> or <code>subset</code>.
</p>
<p>The <code>importer</code> mechanism is more flexible and extensible
than <code><a href="foreign.html#topic+read.spss">read.spss</a></code> and  <code><a href="foreign.html#topic+read.dta">read.dta</a></code>
of package &quot;foreign&quot;, as most of the parsing of the file headers is done in R.
It is also adapted to efficiently load large data sets.
Most importantly, importer objects support the
<code><a href="#topic+labels">labels</a></code>, <code><a href="#topic+missing.values">missing.values</a></code>,
and <code><a href="#topic+description">description</a></code>s, provided by this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spss.file(file,...)

spss.fixed.file(file,
  columns.file,
  varlab.file=NULL,
  codes.file=NULL,
  missval.file=NULL,
  count.cases=TRUE,
  to.lower=getOption("spss.fixed.to.lower",FALSE),
  iconv=TRUE,
  encoded=getOption("spss.fixed.encoding","cp1252"),
  negative2missing = FALSE)

spss.portable.file(file,
  varlab.file=NULL,
  codes.file=NULL,
  missval.file=NULL,
  count.cases=TRUE,
  to.lower=getOption("spss.por.to.lower",FALSE),
  iconv=TRUE,
  encoded=getOption("spss.por.encoding","cp1252"),
  negative2missing = FALSE)

spss.system.file(file,
  varlab.file=NULL,
  codes.file=NULL,
  missval.file=NULL,
  count.cases=TRUE,
  to.lower=getOption("spss.sav.to.lower",FALSE),
  iconv=TRUE,
  encoded=getOption("spss.sav.encoding","cp1252"),
  ignore.scale.info = FALSE,
  negative2missing = FALSE)

Stata.file(file,
           iconv=TRUE,
           encoded=if(new_format)
                        getOption("Stata.new.encoding","utf-8")
                   else getOption("Stata.old.encoding","cp1252"),
           negative2missing = FALSE)

## The most important methods for "importer" objects are:
## S3 method for class 'spss.system.importer'
subset(x, subset, select, drop = FALSE, ...)
## S3 method for class 'spss.portable.importer'
subset(x, subset, select, drop = FALSE, ...)
## S3 method for class 'spss.fixed.importer'
subset(x, subset, select, drop = FALSE, ...)
## S3 method for class 'Stata.importer'
subset(x, subset, select, drop = FALSE, ...)
## S3 method for class 'Stata_new.importer'
subset(x, subset, select, drop = FALSE, ...)

## S4 method for signature 'importer'
as.data.set(x,row.names=NULL,optional=NULL,
                    compress.storage.modes=FALSE,...)

## S4 method for signature 'importer'
head(x,n=20,...)
## S4 method for signature 'importer'
tail(x,n=20,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importers_+3A_file">file</code></td>
<td>
<p>character string; the path to the file containing
the data</p>
</td></tr>
<tr><td><code id="importers_+3A_...">...</code></td>
<td>
<p>Other arguments. <code>spss.file()</code> passes them on to
<code>spss.portable.file()</code> of  <code>spss.system.file()</code>. Other
function ignore further arguments.</p>
</td></tr>
<tr><td><code id="importers_+3A_columns.file">columns.file</code></td>
<td>
<p>character string; the path to an
SPSS/PSPP syntax file with a <code>DATA LIST FIXED</code> statement</p>
</td></tr>
<tr><td><code id="importers_+3A_varlab.file">varlab.file</code></td>
<td>
<p>character string; the path to an
SPSS/PSPP syntax file with a <code>VARIABLE LABELS</code> statement</p>
</td></tr>
<tr><td><code id="importers_+3A_codes.file">codes.file</code></td>
<td>
<p>character string; the path to an
SPSS/PSPP syntax file with a <code>VALUE LABELS</code> statement</p>
</td></tr>
<tr><td><code id="importers_+3A_missval.file">missval.file</code></td>
<td>
<p>character string; the path to an
SPSS/PSPP syntax file with a <code>MISSING VALUES</code> statement</p>
</td></tr>
<tr><td><code id="importers_+3A_count.cases">count.cases</code></td>
<td>
<p>logical; should cases in file be counted? This
takes effect only if the data file does not already contain information
about the number of cases.</p>
</td></tr>
<tr><td><code id="importers_+3A_to.lower">to.lower</code></td>
<td>
<p>logical; should variable names changed to lower
case?</p>
</td></tr>
<tr><td><code id="importers_+3A_iconv">iconv</code></td>
<td>
<p>logical; should strings (in labels and
variables) changed into encoding of the platform?</p>
</td></tr>
<tr><td><code id="importers_+3A_encoded">encoded</code></td>
<td>
<p>a cacharacter string; the way characters are encoded
in the improrted file. For the available encoding options
see <code>?iconvlist</code>. Using this argument for
<code>spss.system.file</code> this is only a fallback, as the function
uses the encoding information present in the file if it is
present.</p>
</td></tr>
<tr><td><code id="importers_+3A_negative2missing">negative2missing</code></td>
<td>
<p>logical; should negative values be marked
as missing values? This is the convention of some newer data sets that
are available e.g. from the GESIS data archive.</p>
</td></tr>
<tr><td><code id="importers_+3A_ignore.scale.info">ignore.scale.info</code></td>
<td>
<p>logical; should information about measuremnt
scale levels provided in the file be ignored?</p>
</td></tr>
<tr><td><code id="importers_+3A_x">x</code></td>
<td>
<p>an object that inherits from class <code>"importer"</code>.</p>
</td></tr>
<tr><td><code id="importers_+3A_subset">subset</code></td>
<td>
<p>a logical vector or an expression containing variables
from the external data file that evaluates to logical. </p>
</td></tr>
<tr><td><code id="importers_+3A_select">select</code></td>
<td>
<p>a vector of variable names from the external data file.
This may also be a named vector, where the names give
the names into which the variables from the external data
file are renamed.</p>
</td></tr>
<tr><td><code id="importers_+3A_drop">drop</code></td>
<td>
<p>a logical value, that determines what happens if
only one column is selected. If TRUE and only one column
is selected, <code>subset</code> returns only a single <code>item</code>
object and not a <code>data.set</code>.</p>
</td></tr>
<tr><td><code id="importers_+3A_row.names">row.names</code></td>
<td>
<p>ignored, present only for compatibility.</p>
</td></tr>
<tr><td><code id="importers_+3A_optional">optional</code></td>
<td>
<p>ignored, present only for compatibility.</p>
</td></tr>
<tr><td><code id="importers_+3A_compress.storage.modes">compress.storage.modes</code></td>
<td>
<p>logical value; if TRUE floating point values
are converted to integers if possible without loss of information.</p>
</td></tr>
<tr><td><code id="importers_+3A_n">n</code></td>
<td>
<p>integer; the number of rows to be shown by <code>head</code> or <code>tail</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A call to a &lsquo;constructor&rsquo; for an importer object, that is,
<code>spss.fixed.file</code>, <code>spss.portable.file</code>, <code>spss.sysntax.file</code>,
or <code>Stata.file</code>,
causes R to read in the header of the data file and/or
the syntax files that contain information about
the variables, such as the columns that they occupy
(in case of <code>spss.fixed.file</code>), variable labels,
value labels and missing values.
</p>
<p>The information in the file header and/or the accompagnying
files is then processed to prepare the file for importing.
Thus the inner structure of an <code>importer</code> object may
well vary according to what type of file is to imported and
what additional information is given.
</p>
<p>The <code>as.data.set</code> and <code>subset</code> methods
for <code>"importer"</code> objects internally use the
generic functions <code>seekData</code>, <code>readData</code>, <code>readSlice</code>,
and <code>readChunk</code>, which have methods for the
subclasses of <code>"importer"</code>.
These functions are not callable
from outside the package, however.
</p>
<p>The <code>subset</code> method for <code>"importer"</code> objects reads in
the data &lsquo;chunk-wise&rsquo; to create the subset of observations if
the option <code>"subset.chunk.size"</code> is set to a non-<code>NULL</code>
value, e.g. by <code>options(subset.chunk.size=1000)</code>. This may be
useful in case of very large data sets from which only a tiny subset
of observations is needed for analysis.
</p>
<p>Since the functions described here are more or less complete rewrite
based on the description of the file structure provided
by the documenation for PSPP, they are perhaps not as thorougly tested as the 
functions in the <code>foreign</code> package, apart from the frequent use
by the author of this package.
</p>


<h3>Value</h3>

<p><code>spss.fixed.file</code>, <code>spss.portable.file</code>,
<code>spss.system.file</code>, and <code>Stata.file</code>
return, respectively, objects of class
<code>"spss.fixed.importer"</code>, <code>"spss.portable.importer"</code>,
<code>"spss.system.importer"</code>, <code>"Stata.importer"</code>, or <code>"Stata_new.importer"</code>,
which, by inheritance, are also objects of class <code>"importer"</code>.
<code>"Stata.importer"</code> is for files in the format of Stata versions up
to 12, while <code>"Stata_new.importer"</code> is for files in the newer
format of Stata versions from 13.
</p>
<p>Objects of class <code>"importer"</code> have at least the following two slots:
</p>
<table>
<tr><td><code>ptr</code></td>
<td>
<p>an external pointer</p>
</td></tr>
<tr><td><code>variables</code></td>
<td>
<p>a list of objects of class <code>"item.vector"</code> which
provides a &lsquo;prototype&rsquo; for the <code>"data.set"</code> set objects returned
by the <code>as.data.set</code> and <code>subset</code> methods for objects of
class <code>"importer"</code> </p>
</td></tr>
</table>
<p>The <code>as.data.frame</code> for <code>importer</code> objects does
the actual data import and returns a data frame. Note that in contrast
to <code><a href="foreign.html#topic+read.spss">read.spss</a></code>, the variable names of the
resulting data frame will be lower case, unless the importer function
is called with <code>to.lower=FALSE</code>. If long variable names
are defined (in case of a PSPP/SPSS system file), they take
precedence and are <em>not</em> coerced to lower case.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+codebook">codebook</a></code>, <code><a href="#topic+description">description</a></code>,
<code><a href="foreign.html#topic+read.spss">read.spss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract American National Election Study of 1948
nes1948.por &lt;- unzip(system.file("anes/NES1948.ZIP",package="memisc"),
                     "NES1948.POR",exdir=tempfile())

# Get information about the variables contained.
nes1948 &lt;- spss.portable.file(nes1948.por)

# The data are not yet loaded:
show(nes1948)

# ... but one can see what variables are present:
description(nes1948)

# Now a subset of the data is loaded:
vote.socdem.48 &lt;- subset(nes1948,
              select=c(
                  V480018,
                  V480029,
                  V480030,
                  V480045,
                  V480046,
                  V480047,
                  V480048,
                  V480049,
                  V480050
                  ))

# Let's make the names more descriptive:
vote.socdem.48 &lt;- rename(vote.socdem.48,
                  V480018 = "vote",
                  V480029 = "occupation.hh",
                  V480030 = "unionized.hh",
                  V480045 = "gender",
                  V480046 = "race",
                  V480047 = "age",
                  V480048 = "education",
                  V480049 = "total.income",
                  V480050 = "religious.pref"
        )

# It is also possible to do both
# in one step:
# vote.socdem.48 &lt;- subset(nes1948,
#              select=c(
#                  vote           = V480018,
#                  occupation.hh  = V480029,
#                  unionized.hh   = V480030,
#                  gender         = V480045,
#                  race           = V480046,
#                  age            = V480047,
#                  education      = V480048,
#                  total.income   = V480049,
#                  religious.pref = V480050
#                  ))



# We examine the data more closely:
codebook(vote.socdem.48)

# ... and conduct some analyses.
#
t(genTable(percent(vote)~occupation.hh,data=vote.socdem.48))

# We consider only the two main candidates.
vote.socdem.48 &lt;- within(vote.socdem.48,{
  truman.dewey &lt;- vote
  valid.values(truman.dewey) &lt;- 1:2
  truman.dewey &lt;- relabel(truman.dewey,
              "VOTED - FOR TRUMAN" = "Truman",
              "VOTED - FOR DEWEY"  = "Dewey")
  })

summary(truman.relig.glm &lt;- glm((truman.dewey=="Truman")~religious.pref,
    data=vote.socdem.48,
    family="binomial",
))
</code></pre>

<hr>
<h2 id='items'>Survey Items</h2><span id='topic+item'></span><span id='topic+items'></span><span id='topic+item-class'></span><span id='topic+item.vector-class'></span><span id='topic+integer.item-class'></span><span id='topic+double.item-class'></span><span id='topic+numeric.item-class'></span><span id='topic+character.item-class'></span><span id='topic+datetime.item-class'></span><span id='topic+Date.item-class'></span><span id='topic+as.item'></span><span id='topic+as.item+2Cnumeric-method'></span><span id='topic+as.item+2Clogical-method'></span><span id='topic+as.item+2Ccharacter-method'></span><span id='topic+as.item+2Cfactor-method'></span><span id='topic+as.item+2Cordered-method'></span><span id='topic+as.item+2CPOSIXct-method'></span><span id='topic+as.item+2CDate-method'></span><span id='topic+as.item+2Cdouble.item-method'></span><span id='topic+as.item+2Cinteger.item-method'></span><span id='topic+as.item+2Ccharacter.item-method'></span><span id='topic+as.item+2Cdatetime.item-method'></span><span id='topic+as.item+2CDate.item-method'></span><span id='topic++5B+2Citem.vector+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Citem.vector+2Clogical+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cdatetime.item+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cdatetime.item+2Clogical+2Cmissing+2Cmissing-method'></span><span id='topic+str.double.item'></span><span id='topic+str.integer.item'></span><span id='topic+str.character.item'></span><span id='topic+str.datetime.item'></span><span id='topic+unique+2Citem.vector-method'></span><span id='topic+summary+2Citem.vector-method'></span><span id='topic+summary+2Cdatetime.item-method'></span><span id='topic+summary+2CDate.item-method'></span><span id='topic+format+2Citem.vector-method'></span><span id='topic+show+2Citem.vector-method'></span><span id='topic+format+2Cdatetime.item-method'></span><span id='topic+format+2CDate.item-method'></span><span id='topic+show+2Cdatetime.item-method'></span><span id='topic+show+2CDate.item-method'></span><span id='topic+print+2Citem.vector-method'></span><span id='topic+print+2Cdatetime.item-method'></span><span id='topic+print+2CDate.item-method'></span><span id='topic+Compare+2Cnumeric.item+2Ccharacter-method'></span><span id='topic+Compare+2Ccharacter+2Cnumeric.item-method'></span><span id='topic+Arith+2Cnumeric.item+2Cnumeric.item-method'></span><span id='topic+Arith+2Cnumeric.item+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2Cnumeric.item-method'></span><span id='topic+Math+2Cnumeric.item-method'></span><span id='topic+Math2+2Cnumeric.item-method'></span><span id='topic+Summary+2Cnumeric.item-method'></span><span id='topic++25in+25+2Cnumeric.item+2Ccharacter-method'></span><span id='topic+rep+2Citem.vector-method'></span><span id='topic+weighted.mean+2Citem.vector-method'></span>

<h3>Description</h3>

<p>Objects of class <code>item</code> are data vectors with additional information
attached to them like &ldquo;value labels&rdquo; and &ldquo;user-defined missing values&rdquo;
known from software packages like SPSS or Stata.
</p>
<p>The class <code>item</code> is intended to facilitate data management of
survey data. Objects in this class should <em>not</em> directly used
in data analysis. Instead they should changed into &quot;ordinary&quot; vectors
or factors before. For this see the documentation for <code><a href="#topic+as.vector+2Citem-method">as.vector,item-method</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## The constructor for objects of class "item"
## more convenient than new("item",...)
## S4 method for signature 'numeric'
as.item(x,
  labels=NULL,  missing.values=NULL,
  valid.values=NULL,  valid.range=NULL,
  value.filter=NULL,  measurement=NULL,
  annotation=attr(x,"annotation"), ...
  )
## S4 method for signature 'character'
as.item(x,
  labels=NULL,  missing.values=NULL,
  valid.values=NULL,  valid.range=NULL,
  value.filter=NULL,  measurement=NULL,
  annotation=attr(x,"annotation"), ...
  )

## S4 method for signature 'logical'
as.item(x,...)
# x is first coerced to integer,
# arguments in ... are then passed to the "numeric"
# method.

## S4 method for signature 'factor'
as.item(x,...)
## S4 method for signature 'ordered'
as.item(x,...)
## S4 method for signature 'POSIXct'
as.item(x,...)

## S4 method for signature 'double.item'
as.item(x,
  labels=NULL,  missing.values=NULL,
  valid.values=NULL,  valid.range=NULL,
  value.filter=NULL,  measurement=NULL,
  annotation=attr(x,"annotation"), ...
  )

## S4 method for signature 'integer.item'
as.item(x,
  labels=NULL,  missing.values=NULL,
  valid.values=NULL,  valid.range=NULL,
  value.filter=NULL,  measurement=NULL,
  annotation=attr(x,"annotation"), ...
  )

## S4 method for signature 'character.item'
as.item(x,
  labels=NULL,  missing.values=NULL,
  valid.values=NULL,  valid.range=NULL,
  value.filter=NULL,  measurement=NULL,
  annotation=attr(x,"annotation"), ...
  )

## S4 method for signature 'datetime.item'
as.item(x,
  labels=NULL,  missing.values=NULL,
  valid.values=NULL,  valid.range=NULL,
  value.filter=NULL,  measurement=NULL,
  annotation=attr(x,"annotation"), ...
  )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="items_+3A_x">x</code></td>
<td>
<p>for <code>as.item</code> methods,
any atomic vector; 
for the <code>unique</code>, 
<code>summary</code>, <code>str</code>, <code>print</code>, <code>[</code>, and <code>&lt;-</code>
methods, a vector with class <code>labelled</code>.
</p>
</td></tr>
<tr><td><code id="items_+3A_labels">labels</code></td>
<td>
<p>a named vector of the same mode as <code>x</code>.</p>
</td></tr>
<tr><td><code id="items_+3A_missing.values">missing.values</code></td>
<td>
<p>either a vector of the same mode as <code>x</code>,
or a list with components <code>"values"</code>,
vector of the same mode as <code>x</code> (which defines individual missing values)
and <code>"range"</code> a matrix with two rows with
the same mode as <code>x</code> (which defines a range of missing values),
or an object of class <code>"missing.values"</code>.
</p>
</td></tr>
<tr><td><code id="items_+3A_valid.values">valid.values</code></td>
<td>
<p>either a vector of the same mode as <code>x</code>,
defining those values of <code>x</code> that are to be considered as valid,
or an object of class <code>"valid.values"</code>.</p>
</td></tr>
<tr><td><code id="items_+3A_valid.range">valid.range</code></td>
<td>
<p>either a vector of the same mode as <code>x</code> and length 2,
defining a range of valid values of <code>x</code>,
or an object of class <code>"valid.range"</code>.</p>
</td></tr>
<tr><td><code id="items_+3A_value.filter">value.filter</code></td>
<td>
<p>an object of class <code>"value.filter"</code>, that is, of
classes <code>"missing.values"</code>, <code>"valid.values"</code>, or <code>"valid.range"</code>.</p>
</td></tr>
<tr><td><code id="items_+3A_measurement">measurement</code></td>
<td>
<p>level of measurement; one of &quot;nominal&quot;, &quot;ordinal&quot;, &quot;interval&quot;, or &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="items_+3A_annotation">annotation</code></td>
<td>
<p>a named character vector,
or an object of class <code>"annotation"</code> </p>
</td></tr>
<tr><td><code id="items_+3A_...">...</code></td>
<td>
<p>further arguments, ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+annotation">annotation</a></code>
<code><a href="#topic+labels">labels</a></code>
<code><a href="#topic+value.filter">value.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.item(rep(1:5,4),
      labels=c(
          "First"      = 1,
          "Second"     = 2,
          "Third"      = 3,
          "Fourth"     = 4,
          "Don't know" = 5
        ),
      missing.values=5,
      annotation = c(
        description="test"
      ))
  str(x)
  summary(x)
  as.numeric(x)

  test &lt;- as.item(rep(1:6,2),labels=structure(1:6,
                                      names=letters[1:6]))
  test
  test == 1
  test != 1
  test == "a"
  test != "a"
  test == c("a","z")
  test != c("a","z")
  test 
  test 

  codebook(test)

  Test &lt;- as.item(rep(letters[1:6],2),
                    labels=structure(letters[1:6],
                                     names=LETTERS[1:6]))
  Test
  Test == "a"
  Test != "a"
  Test == "A"
  Test != "A"
  Test == c("a","z")
  Test != c("a","z")
  Test 
  Test 

  as.factor(test)
  as.factor(Test)
  as.numeric(test)
  as.character(test)
  as.character(Test)

  as.data.frame(test)[[1]]
</code></pre>

<hr>
<h2 id='items-to-vectors'>How Survey Items Are Converted into &quot;Ordinary&quot; Data Vectors</h2><span id='topic+as.data.frame.character.item'></span><span id='topic+as.data.frame.double.item'></span><span id='topic+as.data.frame.integer.item'></span><span id='topic+as.data.frame.datetime.item'></span><span id='topic+as.data.frame.Date.item'></span><span id='topic+as.vector+2Citem-method'></span><span id='topic+as.numeric+2Citem-method'></span><span id='topic+as.integer+2Citem-method'></span><span id='topic+as.factor+2Citem.vector-method'></span><span id='topic+as.ordered+2Citem.vector-method'></span><span id='topic+as.character+2Citem.vector-method'></span><span id='topic+as.character+2Cdatetime.item-method'></span><span id='topic+as.character+2CDate.item-method'></span>

<h3>Description</h3>

<p>Survey item objects in are numeric or character vectors with some extra information
that may helpful for for managing and documenting survey data, but they are not suitable
for statistical data analysis. To run regressions etc. one should convert 
<code><a href="#topic+item">item</a></code> objects into &quot;ordinary&quot; numeric vectors or factors.
This means that codes or values declared as &quot;missing&quot; (if present) are translated into
the generial missing value <code>NA</code>, while value labels (if defined) are translated into
factor levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># The following methods can be used to covert items into
# vectors with a given mode or into factors. 
## S4 method for signature 'item'
as.vector(x, mode = "any")
## S4 method for signature 'item'
as.numeric(x, ...)
## S4 method for signature 'item'
as.integer(x, ...)
## S4 method for signature 'item.vector'
as.factor(x)
## S4 method for signature 'item.vector'
as.ordered(x)
## S4 method for signature 'item.vector'
as.character(x, use.labels = TRUE, include.missings = FALSE, ...)
## S4 method for signature 'datetime.item.vector'
as.character()
## S4 method for signature 'Date.item.vector'
as.character()
# The following methods are unlikely to be useful in practice, other than
# that they are called internally by the 'as.data.frame()' method for "data.set"
# objects.
## S3 method for class 'character.item'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
## S3 method for class 'double.item'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
## S3 method for class 'integer.item'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
## S3 method for class 'Date.item'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
## S3 method for class 'datetime.item'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="items-to-vectors_+3A_x">x</code></td>
<td>
<p>an object in class &quot;item&quot;,&quot;item.vector&quot;, etc., as relevant
for the respective conversion method.</p>
</td></tr>
<tr><td><code id="items-to-vectors_+3A_mode">mode</code></td>
<td>
<p>the mode of the vector to be returned, usually <code>"numeric"</code>,
<code>"integer"</code>, or <code>"charcater"</code></p>
</td></tr>
<tr><td><code id="items-to-vectors_+3A_use.labels">use.labels</code></td>
<td>
<p>logical,should value labels be used for creating
the character vector?</p>
</td></tr>
<tr><td><code id="items-to-vectors_+3A_include.missings">include.missings</code></td>
<td>
<p>logical; if <code>TRUE</code>, declared missing values are
not converted into <code>NA</code>, but into character strings with <code>"*"</code> as the &quot;missingness marker&quot;
added at the beginning.</p>
</td></tr>
<tr><td><code id="items-to-vectors_+3A_row.names">row.names</code></td>
<td>
<p>optional row names, see <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
<tr><td><code id="items-to-vectors_+3A_optional">optional</code></td>
<td>
<p>a logical value, see <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
<tr><td><code id="items-to-vectors_+3A_...">...</code></td>
<td>
<p>other arguments, ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>as.vector()</code> returns a logical, numeric, or character
depending on the <code>mode=</code> argument. If <code>mode="any"</code>, the vector
has the mode that corresponds to the (internal) mode of the item
vector, that is, an item in class &quot;integer.item&quot; will become an integer
vector, an item in class &quot;double.item&quot; will become a double-precision
numeric vector, an item in class &quot;character.item&quot; will become a
character vector; since the internal mode of a &quot;dateitem.item&quot; or a
&quot;Date.item&quot; vector is numeric, a numeric vector will be returned.
</p>
<p>The functions <code>as.integer()</code>, <code>as.numeric()</code>, <code>as.character()</code>, 
<code>as.factor()</code>, and <code>as.ordered()</code> return an integer, numeric,
or character vector, or an ordered or unordered factor, respectively.
</p>
<p>When <code>as.data.frame()</code> is applied to an survey item object, the
result is a single-column data frame, where the single column is a
numeric vector or character vector or factor depending on the
<code><a href="#topic+measurement">measurement</a></code> attribute of the item. In particular, if the
<code><a href="#topic+measurement">measurement</a></code> attribute equals <code>"ratio"</code> or
<code>"interval"</code> this column will be the result of <code>as.vector()</code>,
if the <code><a href="#topic+measurement">measurement</a></code> attribute equals <code>"ordinal"</code> this
column will be an ordered factor (see <code><a href="base.html#topic+ordered">ordered</a></code>), and if
the <code><a href="#topic+measurement">measurement</a></code> attribute equals <code>"nominal"</code> this
column will be an unordered factor (see <code><a href="base.html#topic+factor">factor</a></code>).
</p>
<p>All these functions have in common that values declared as &quot;missing&quot; by
virtue of the <code><a href="#topic+value.filter">value.filter</a></code> attribute will be turned into <code>NA</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+items">items</a></code>
<code><a href="#topic+annotation">annotation</a></code>
<code><a href="#topic+labels">labels</a></code>
<code><a href="#topic+value.filter">value.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.item(rep(1:5,4),
      labels=c(
          "First"      = 1,
          "Second"     = 2,
          "Third"      = 3,
          "Fourth"     = 4,
          "Don't know" = 5
        ),
      missing.values=5,
      annotation = c(
        description="test"
      ))
  str(x)
  summary(x)
  as.numeric(x)

  test &lt;- as.item(rep(1:6,2),labels=structure(1:6,
                                      names=letters[1:6]))

  as.factor(test)
  as.numeric(test)
  as.character(test)
  as.character(test,include.missings=TRUE)

  as.data.frame(test)[[1]]
</code></pre>

<hr>
<h2 id='labels'>Value Labels</h2><span id='topic+labels'></span><span id='topic+labels+2CNULL-method'></span><span id='topic+labels+2Citem-method'></span><span id='topic+labels+3C-'></span><span id='topic+labels+3C-+2Citem+2CANY-method'></span><span id='topic+labels+3C-+2CANY+2CNULL-method'></span><span id='topic+labels+3C-+2Citem+2CNULL-method'></span><span id='topic+labels+3C-+2Cvector+2CANY-method'></span><span id='topic+labels+3C-+2Cvector+2CNULL-method'></span><span id='topic+value.labels-class'></span><span id='topic+initialize+2Cvalue.labels-method'></span><span id='topic+Arith+2Cvalue.labels+2CANY-method'></span><span id='topic++5B+2Cvalue.labels+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cvalue.labels+2Clogical+2Cmissing+2Cmissing-method'></span><span id='topic+coerce+2Cnumeric+2Cvalue.labels-method'></span><span id='topic+coerce+2Ccharacter+2Cvalue.labels-method'></span><span id='topic+coerce+2Cvalue.labels+2Cnumeric-method'></span><span id='topic+coerce+2Cvalue.labels+2Ccharacter-method'></span><span id='topic+as.vector+2Cvalue.labels-method'></span><span id='topic+show+2Cvalue.labels-method'></span>

<h3>Description</h3>

<p>Value labels associate character labels to possible values
of an encoded survey item. Value labels are represented
as objects of class &quot;value.labels&quot;.
</p>
<p>Value labels of an item can be obtained
using <code>labels(x)</code> and
can be associated to items and to vectors
using labels(x) &lt;- value
</p>
<p>Value labels also can be updated using the  <code>+</code>
and <code>-</code> operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels(object,...)
labels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_+3A_object">object</code></td>
<td>
<p>any object.</p>
</td></tr>
<tr><td><code id="labels_+3A_...">...</code></td>
<td>
<p>further arguments for other methods.</p>
</td></tr>
<tr><td><code id="labels_+3A_x">x</code></td>
<td>
<p>a vector or &quot;item&quot; object.</p>
</td></tr>
<tr><td><code id="labels_+3A_value">value</code></td>
<td>
<p>an object of class &quot;value.labels&quot; or
a vector that can be coerced into an &quot;value.labels&quot; object or NULL</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.item(rep(1:5,4),
      labels=c(
          "First"      = 1,
          "Second"     = 2,
          "Third"      = 3,
          "Fourth"     = 4,
          "Don't know" = 5
        ),
      missing.values=5,
      annotation = c(
        description="test"
      ))
  labels(x)
  labels(x) &lt;- labels(x) - c("Second"=2)
  labels(x)
  labels(x) &lt;- labels(x) + c("Second"=2)
  labels(x)

  puvl &lt;- getOption("print.use.value.labels")
  options(print.use.value.labels=FALSE)
  x
  options(print.use.value.labels=TRUE)
  x
  options(print.use.value.labels=puvl)
</code></pre>

<hr>
<h2 id='List'>Create a list and conveniently supply names to its elements</h2><span id='topic+List'></span>

<h3>Description</h3>

<p><code>List</code> creates a list and names its elements after the
arguments given, in a manner analogously to <code><a href="base.html#topic+data.frame">data.frame</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>  List(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="List_+3A_...">...</code></td>
<td>
<p>tagged or untagged arguments from which the list is
formed. If the untagged arguments are variables from the englosing
environment, their names become the names of the list elements.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  num &lt;- 1:3
  strng &lt;- c("a","b","A","B")
  logi &lt;- rep(FALSE,7)
  List(num,strng,logi)
</code></pre>

<hr>
<h2 id='Mean'>Convenience wrappers for common statistical functions</h2><span id='topic+Mean'></span><span id='topic+Median'></span><span id='topic+Min'></span><span id='topic+Max'></span><span id='topic+Weighted.Mean'></span><span id='topic+Var'></span><span id='topic+StdDev'></span><span id='topic+Cov'></span><span id='topic+Cor'></span><span id='topic+Range'></span>

<h3>Description</h3>

<p><code>Mean()</code>, <code>Median()</code>, etc. are mere wrappers of
the functions <code>mean()</code>, <code>median()</code>, etc. with the
<code>na.rm=</code> optional argument set <code>TRUE</code> by default.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mean(x, na.rm=TRUE, ...)
Median(x, na.rm=TRUE, ...)
Min(x, na.rm=TRUE, ...)
Max(x, na.rm=TRUE, ...)
Weighted.Mean(x, w, ..., na.rm = TRUE)
Var(x, na.rm=TRUE, ...)
StdDev(x, na.rm=TRUE, ...)

Cov(x, y = NULL, use = "pairwise.complete.obs", ...)
Cor(x, y = NULL, use = "pairwise.complete.obs", ...)
Range(..., na.rm = TRUE, finite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mean_+3A_x">x</code></td>
<td>
<p>a (numeric) vector.</p>
</td></tr>
<tr><td><code id="Mean_+3A_y">y</code></td>
<td>
<p>a (numeric) vector or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Mean_+3A_w">w</code></td>
<td>
<p>a (numeric) vector of weights.</p>
</td></tr>
<tr><td><code id="Mean_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value, see <code><a href="base.html#topic+mean">mean</a></code>.</p>
</td></tr>
<tr><td><code id="Mean_+3A_use">use</code></td>
<td>
<p>a character string, see <code><a href="stats.html#topic+cor">cor</a></code>.</p>
</td></tr>
<tr><td><code id="Mean_+3A_...">...</code></td>
<td>
<p>other arguments, passed to the wrapped functions.</p>
</td></tr>
<tr><td><code id="Mean_+3A_finite">finite</code></td>
<td>
<p>a logical value, see <code><a href="base.html#topic+range">range</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Means'>Means for groups of observations</h2><span id='topic+Means'></span><span id='topic+Means.data.frame'></span><span id='topic+Means.numeric'></span><span id='topic+Means.formula'></span><span id='topic+as.data.frame.means.table'></span><span id='topic+as.data.frame.xmeans.table'></span>

<h3>Description</h3>

<p>The function <code>Means()</code> creates a table of group
means, optionally with standard errors, confidence intervals, and
numbers of valid observations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Means(data, ...)
## S3 method for class 'data.frame'
Means(data,
    by, weights=NULL, subset=NULL,
    default=NA,
    se=FALSE, ci=FALSE, ci.level=.95,
    counts=FALSE, ...)
## S3 method for class 'formula'
Means(data, subset, weights, ...)
## S3 method for class 'numeric'
Means(data, ...)
## S3 method for class 'means.table'
as.data.frame(x, row.names=NULL, optional=TRUE, drop=TRUE, ...)
## S3 method for class 'xmeans.table'
as.data.frame(x, row.names=NULL, optional=TRUE, drop=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Means_+3A_data">data</code></td>
<td>
<p>an object usually containing data, or a formula.
</p>
<p>If <code>data</code> is a numeric vector or an object that can be coerced
into a data frame, it is changed into a data frame and the data
frame method of <code>Means()</code> is applied to it.
</p>
<p>If <code>data</code> is a formula, then a data frame is constructed from
the variables in the formula and <code>Means</code> is applied to this
data frame, while the formula is passed on as a <code>by=</code> argument.
</p>
</td></tr>
<tr><td><code id="Means_+3A_by">by</code></td>
<td>
<p>a formula, a vector of variable names or a data frame or
list of factors.
</p>
<p>If <code>by</code> is a vector of variable names,
they are extracted from <code>data</code> to define the groups for which
means are computed, while the variables for which the means are
computed are those not named in <code>by</code>.
</p>
<p>If <code>by</code> is a data frame or a list of factors,
these are used to defined the groups for which means are computed,
while the variables for which the means are
computed are those not in <code>by</code>.
</p>
<p>If <code>by</code> is a formula, its left-hand side determines the
variables of which means are computed, while its right-hand side
determines the factors that define the groups.
</p>
</td></tr>
<tr><td><code id="Means_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights, usually a variable in <code>data</code>.</p>
</td></tr>
<tr><td><code id="Means_+3A_subset">subset</code></td>
<td>
<p>an optional logical vector to select observations,
usually the result of an expression in variables from <code>data</code>.</p>
</td></tr>
<tr><td><code id="Means_+3A_default">default</code></td>
<td>
<p>a default value used for empty cells without
observations.</p>
</td></tr>
<tr><td><code id="Means_+3A_se">se</code></td>
<td>
<p>a logical value, indicates whether standard errors should be
computed.</p>
</td></tr>
<tr><td><code id="Means_+3A_ci">ci</code></td>
<td>
<p>a logical value, indicates whether limits of confidence
intervals should be computed.</p>
</td></tr>
<tr><td><code id="Means_+3A_ci.level">ci.level</code></td>
<td>
<p>a number, the confidence level of the confidence interval</p>
</td></tr>
<tr><td><code id="Means_+3A_counts">counts</code></td>
<td>
<p>a logical value, indicates whether numbers of valid
observations should be reported.</p>
</td></tr>
<tr><td><code id="Means_+3A_x">x</code></td>
<td>
<p>for <code>as.data.frame()</code>, a result of <code>Means()</code>.</p>
</td></tr>
<tr><td><code id="Means_+3A_row.names">row.names</code></td>
<td>
<p>an optional character vector. This argmument presently is
inconsequential and only included for reasons of compatiblity
with the standard methods of <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="Means_+3A_optional">optional</code></td>
<td>
<p>an optional logical value. This argmument presently is
inconsequential and only included for reasons of compatiblity
with the standard methods of <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="Means_+3A_drop">drop</code></td>
<td>
<p>a logical value, determines whether &quot;empty cells&quot; should
be dropped from the resulting data frame.</p>
</td></tr>
<tr><td><code id="Means_+3A_...">...</code></td>
<td>
<p>other arguments, either ignored or passed on to other
methods where applicable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array that inherits classes &quot;means.table&quot; and &quot;table&quot;. If
<code>Means</code> was called with <code>se=TRUE</code> or <code>ci=TRUE</code>
then the result additionally inherits class &quot;xmeans.table&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Preparing example data
USstates &lt;- as.data.frame(state.x77)
USstates &lt;- within(USstates,{
    region &lt;- state.region
    name &lt;- state.name
    abb &lt;- state.abb
    division &lt;- state.division
})
USstates$w &lt;- sample(runif(n=6),size=nrow(USstates),replace=TRUE)

# Using the data frame method
Means(USstates[c("Murder","division","region")],by=c("division","region"))
Means(USstates[c("Murder","division","region")],by=USstates[c("division","region")])
Means(USstates[c("Murder")],1)
Means(USstates[c("Murder","region")],by=c("region"))

# Using the formula method
# One 'dependent' variable
Means(Murder~1, data=USstates)
Means(Murder~division, data=USstates)
Means(Murder~division, data=USstates,weights=w)
Means(Murder~division+region, data=USstates)
as.data.frame(Means(Murder~division+region, data=USstates))

# Standard errors and counts
Means(Murder~division, data=USstates, se=TRUE, counts=TRUE)
drop(Means(Murder~division, data=USstates, se=TRUE, counts=TRUE))
as.data.frame(Means(Murder~division, data=USstates, se=TRUE, counts=TRUE))

# Confidence intervals
Means(Murder~division, data=USstates, ci=TRUE)
drop(Means(Murder~division, data=USstates, ci=TRUE))
as.data.frame(Means(Murder~division, data=USstates, ci=TRUE))

# More than one dependent variable
Means(Murder+Illiteracy~division, data=USstates)
as.data.frame(Means(Murder+Illiteracy~division, data=USstates))

# Confidence intervals
Means(Murder+Illiteracy~division, data=USstates, ci=TRUE)
as.data.frame(Means(Murder+Illiteracy~division, data=USstates, ci=TRUE))

# Some 'non-standard' but still valid usages:
with(USstates,
     Means(Murder~division+region,subset=region!="Northeast"))

with(USstates,
     Means(Murder,by=list(division,region)))
</code></pre>

<hr>
<h2 id='measurement'>Levels of Measurement of Survey Items</h2><span id='topic+measurement'></span><span id='topic+measurement+2CANY-method'></span><span id='topic+measurement+2Citem-method'></span><span id='topic+measurement+2Cdata.set-method'></span><span id='topic+measurement+3C-'></span><span id='topic+measurement+3C-+2Citem-method'></span><span id='topic+measurement+3C-+2Cdata.set-method'></span><span id='topic+set_measurement'></span><span id='topic+is.nominal'></span><span id='topic+is.ordinal'></span><span id='topic+is.interval'></span><span id='topic+is.ratio'></span><span id='topic+as.nominal'></span><span id='topic+as.ordinal'></span><span id='topic+as.interval'></span><span id='topic+as.ratio'></span>

<h3>Description</h3>

<p>The measurement level of a <code>"item"</code> object, which is one of &quot;nominal&quot;, &quot;ordinal&quot;, &quot;interval&quot;, &quot;ratio&quot;,
determines what happens to it, if it or the <code><a href="#topic+data.set">data.set</a></code>
containing it is coerced into a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
If the level of measurement level is &quot;nominal&quot;, the it will be
converted into an (unordered) <a href="base.html#topic+factor">factor</a>, if the level of measurement is &quot;ordinal&quot;,
the item will be converted into an <a href="base.html#topic+ordered">ordered</a> vector. If the measurement
is &quot;interval&quot; or &quot;ratio&quot;, the item will be converted into a numerical vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'item'
measurement(x)
## S4 replacement method for signature 'item'
measurement(x) &lt;- value
## S4 method for signature 'data.set'
measurement(x)
## S4 replacement method for signature 'data.set'
measurement(x) &lt;- value
is.nominal(x)
is.ordinal(x)
is.interval(x)
is.ratio(x)
as.nominal(x)
as.ordinal(x)
as.interval(x)
as.ratio(x)
set_measurement(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measurement_+3A_x">x</code></td>
<td>
<p>an object, usually of class <code>"item"</code>.</p>
</td></tr>
<tr><td><code id="measurement_+3A_value">value</code></td>
<td>

<p>for the <code>item</code> method, 
a character string; either &quot;nominal&quot;, &quot;ordinal&quot;, &quot;interval&quot;, or
&quot;ratio&quot;;
for the <code>data.set</code> method,
a list of character vectors with variable names,
where the names of the list corresponds to a measurement level and
and the list elements indicates the variables to which the
measurement levels are assigned.
</p>
</td></tr>
<tr><td><code id="measurement_+3A_...">...</code></td>
<td>
<p>vectors of variable names, either symbols or character
strings, tagged with the intended measurement level.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>item</code> method of <code>measurement(x)</code> returns a character
string, the <code>data.set</code> method returns a named character vector,
where the name of each element is a variable name and each.
</p>
<p><code>as.nominal</code>, <code>as.ordinal</code>, <code>as.interval</code>, <code>as.ratio</code>
return an item with the requested level of measurement setting.
</p>
<p><code>is.nominal</code>, <code>is.ordinal</code>, <code>is.interval</code>, <code>is.ratio</code>
return a logical value.
</p>


<h3>References</h3>

<p>Stevens, Stanley S. 1946. &quot;On the theory of scales of measurement.&quot; <em>Science</em> 103: 677-680.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.set">data.set</a></code>, <code><a href="#topic+item">item</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vote &lt;- sample(c(1,2,3,8,9),size=30,replace=TRUE)
labels(vote) &lt;- c(Conservatives         =  1,
                  Labour                =  2,
                  "Liberal Democrats"   =  3,
                  "Don't know"          =  8,
                  "Answer refused"      =  9
                  )
missing.values(vote) &lt;- c(8,9)
as.data.frame(vote)[[1]]
measurement(vote) &lt;- "interval"
as.data.frame(vote)[[1]]
vote &lt;- as.nominal(vote)
as.data.frame(vote)[[1]]
group &lt;- sample(c(1,2),size=30,replace=TRUE)
labels(group) &lt;- c(A=1,B=2)
DataS &lt;- data.set(group,vote)
measurement(DataS)
measurement(DataS) &lt;- list(interval=c("group","vote"))
head(as.data.frame(DataS))
DataS &lt;- set_measurement(DataS,
                         nominal=c(group,vote))
head(as.data.frame(DataS))
</code></pre>

<hr>
<h2 id='measurement_autolevel'>Automatically Adapt Measurement Levels</h2><span id='topic+measurement_autolevel'></span><span id='topic+measurement_autolevel+2CANY-method'></span><span id='topic+measurement_autolevel+2Citem.vector-method'></span><span id='topic+measurement_autolevel+2Cdata.set-method'></span>

<h3>Description</h3>

<p>The generic function <code>measurement_autolevel</code> changes the measurement
levels of &quot;item&quot; objects to &quot;nominal&quot; or &quot;ordinal&quot;, if
the proportion of its values that have labels is above a certain
threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measurement_autolevel(x, ...)
## S4 method for signature 'ANY'
measurement_autolevel(x, ...) # Returns its argument as is
## S4 method for signature 'item.vector'
measurement_autolevel(x, 
                to=getOption("measurement.adapt.default","nominal"),
                threshold=getOption("measurement.adapt.threshold",.75),
                ...)
## S4 method for signature 'data.set'
measurement_autolevel(x, 
                to=getOption("measurement.adapt.default","nominal"),
                threshold=getOption("measurement.adapt.threshold",.75),
                except=NULL,
                only=NULL,
                ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measurement_autolevel_+3A_x">x</code></td>
<td>
<p>an object from class &quot;item.vector&quot; or &quot;data.set&quot;.</p>
</td></tr>
<tr><td><code id="measurement_autolevel_+3A_to">to</code></td>
<td>
<p>a character vector, the target measurement level</p>
</td></tr>
<tr><td><code id="measurement_autolevel_+3A_threshold">threshold</code></td>
<td>
<p>the proportion of values, if reached the target
measurement level is set</p>
</td></tr>
<tr><td><code id="measurement_autolevel_+3A_except">except</code></td>
<td>
<p>a vector with variable names, either as symbols
(without quotation marks) or character strings (with quotation
markes), the variables in the data set that are not to be
changed by <code>measurement_autolevel()</code>.</p>
</td></tr>
<tr><td><code id="measurement_autolevel_+3A_only">only</code></td>
<td>
<p>a vector with variable names, either as symbols
(without quotation marks) or character strings (with quotation
markes), the variables in the data set that are to be
changed by <code>measurement_autolevel()</code>.</p>
</td></tr>
<tr><td><code id="measurement_autolevel_+3A_...">...</code></td>
<td>
<p>other arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
 exvect &lt;- as.item(rep(1:2,5))
 labels(exvect) &lt;- c(a=1,b=2)
 codebook(exvect)
 codebook(measurement_autolevel(exvect))

 avect &lt;- as.item(sample(1:3,16,replace=TRUE))
 labels(avect) &lt;- c(a=1,b=2,c=3)
 bvect &lt;- as.item(sample(1:4,16,replace=TRUE))
 labels(bvect) &lt;- c(A=1,B=2,C=3,D=4)
 ds &lt;- data.set(a=avect,b=bvect)
 codebook(ds)
 codebook(measurement_autolevel(ds))
 codebook(measurement_autolevel(ds,except=c(a,b)))
 codebook(measurement_autolevel(ds,only=a))
</code></pre>

<hr>
<h2 id='memisc-deprecated'>Deprecated Functions in Package <span class="pkg">memisc</span></h2><span id='topic+memisc-deprecated'></span><span id='topic+fapply'></span><span id='topic+fapply.default'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of
<span class="pkg">memisc</span> only, and may be defunct as soon as the next release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fapply(formula,data,...) # calls UseMethod("fapply",data)
## Default S3 method:
fapply(formula, data, subset=NULL,
      names=NULL, addFreq=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="memisc-deprecated_+3A_formula">formula</code></td>
<td>
<p>a formula. The right hand side includes one or more
grouping variables separated by '+'. These may be factors, numeric,
or character vectors. The left hand side may be empty,
a numerical variable, a factor, or an expression.
See details below.</p>
</td></tr>
<tr><td><code id="memisc-deprecated_+3A_data">data</code></td>
<td>
<p>an environment or data frame or an object coercable into a data frame.</p>
</td></tr>
<tr><td><code id="memisc-deprecated_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="memisc-deprecated_+3A_names">names</code></td>
<td>
<p>an optional character vector giving names to the
result(s) yielded by the expression on the left hand side of <code>formula</code>.
This argument may be redundant if the left hand side results in is a named vector.
(See the example below.)</p>
</td></tr>
<tr><td><code id="memisc-deprecated_+3A_addfreq">addFreq</code></td>
<td>
<p>a logical value. If TRUE and
<code>data</code> is a table or a data frame with a variable
named &quot;Freq&quot;, a call to
<code>table</code>, <code><a href="#topic+Table">Table</a></code>, <code><a href="#topic+percent">percent</a></code>, or <code><a href="#topic+nvalid">nvalid</a></code>
is supplied by an additional argument <code>Freq</code>
and a call to <code>table</code> is translated into
a call to <code>Table</code>.
</p>
</td></tr>
<tr><td><code id="memisc-deprecated_+3A_...">...</code></td>
<td>
<p>further arguments, passed to methods or ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='mtable'>Comparative Table of Model Estimates</h2><span id='topic+mtable'></span><span id='topic+relabel.memisc_mtable'></span><span id='topic+format.memisc_mtable'></span><span id='topic+print.memisc_mtable'></span><span id='topic+write.mtable'></span><span id='topic+toLatex.memisc_mtable'></span><span id='topic+dim.memisc_mtable'></span><span id='topic+dimnames.memisc_mtable'></span><span id='topic++5B.memisc_mtable'></span><span id='topic+c.memisc_mtable'></span>

<h3>Description</h3>

<p><code>mtable</code> produces a table of estimates for several models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtable(...,coef.style=getOption("coef.style"),
    summary.stats=TRUE,
    signif.symbols=getOption("signif.symbols"),
    factor.style=getOption("factor.style"),
    show.baselevel=getOption("show.baselevel"),
    baselevel.sep=getOption("baselevel.sep"),
    getSummary=eval.parent(quote(getSummary)),
    float.style=getOption("float.style"),
    digits=min(3,getOption("digits")),
    sdigits=digits,
    show.eqnames=getOption("mtable.show.eqnames",NA),
    gs.options=NULL,
    controls=NULL,
    collapse.controls=FALSE,
    control.var.indicator=getOption("control.var.indicator",c("Yes","No"))
  )
## S3 method for class 'memisc_mtable'
relabel(x, ..., gsub = FALSE, fixed = !gsub, warn = FALSE)

## S3 method for class 'memisc_mtable'
format(x,target=c("print","LaTeX","HTML","delim"),
    ...
    )

## S3 method for class 'memisc_mtable'
print(x,
    center.at=getOption("OutDec"),
    topsep="=",bottomsep="=",sectionsep="-",...)

write.mtable(object,file="",
             format=c("delim","LaTeX","HTML"),...)

## S3 method for class 'memisc_mtable'
toLatex(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtable_+3A_...">...</code></td>
<td>
<p>as argument to <code>mtable</code>: several model objects, e.g. of class 
<code><a href="stats.html#topic+lm">lm</a></code>; as argument to <code>print.memisc_mtable</code>,
<code>toLatex.memisc_mtable</code>, <code>write.memisc_mtable</code>: further arguments
passed to <code>format.memisc_mtable</code>; as argument to <code>format.memisc_mtable</code>:
further arguments passed to <code>format.default</code>;
as argument to <code>relabel.memisc_mtable</code>: further arguments
passed to <code><a href="#topic+dimrename">dimrename</a></code>.
</p>
</td></tr>
<tr><td><code id="mtable_+3A_coef.style">coef.style</code></td>
<td>
<p>a character string which specifies the style of
coefficient values, whether standard errors, Wald/t-statistics,
or significance levels are reported, etc. See <code><a href="#topic+coef.style">coef.style</a></code>.</p>
</td></tr>
<tr><td><code id="mtable_+3A_summary.stats">summary.stats</code></td>
<td>
<p>if <code>FALSE</code>, no summary statistics
are repored. If <code>TRUE</code> then for each object in <code>...</code>
either all summary statistics are reported, or those specified by
the option <code>"summary.stats.&lt;cls&gt;"</code>, where <code>&lt;cls&gt;</code> is
the class of the respective object.
</p>
<p>This argument may also contain a character vector with
the names of the summary statistics to report, or a list of
character vectors with names of summary statistics for each
object passed as argument in <code>...</code>.
</p>
</td></tr>
<tr><td><code id="mtable_+3A_signif.symbols">signif.symbols</code></td>
<td>
<p>a named numeric vector to specify
the &quot;significance levels&quot; and corresponding symbols. 
The numeric elements define the significance levels,
the attached names define the associated symbols.</p>
</td></tr>
<tr><td><code id="mtable_+3A_factor.style">factor.style</code></td>
<td>
<p>a character string that specifies the style in
which factor contrasts are labled. See <code><a href="#topic+factor.style">factor.style</a></code>.</p>
</td></tr>
<tr><td><code id="mtable_+3A_show.baselevel">show.baselevel</code></td>
<td>
<p>logical; determines whether base levels of factors are indicated
for dummy coefficients</p>
</td></tr>
<tr><td><code id="mtable_+3A_baselevel.sep">baselevel.sep</code></td>
<td>
<p>character that is used to separate the base level from the 
level that a dummy variable represents</p>
</td></tr>
<tr><td><code id="mtable_+3A_getsummary">getSummary</code></td>
<td>
<p>a function that computes model-related statistics that
appear in the table. See <code><a href="#topic+getSummary">getSummary</a></code>.</p>
</td></tr>
<tr><td><code id="mtable_+3A_float.style">float.style</code></td>
<td>
<p>default format for floating point numbers if
no format is specified by <code>coef.style</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="mtable_+3A_digits">digits</code></td>
<td>
<p>number of significant digits if not specified by
the template returned from <code><a href="#topic+getCoefTemplate">getCoefTemplate</a></code>
<code><a href="#topic+getSummaryTemplate">getSummaryTemplate</a></code>
</p>
</td></tr>
<tr><td><code id="mtable_+3A_sdigits">sdigits</code></td>
<td>
<p>integer; number of digits after decimal dot for
summary statistics.</p>
</td></tr>
<tr><td><code id="mtable_+3A_show.eqnames">show.eqnames</code></td>
<td>
<p>logical; if <code>TRUE</code>, left-hand sides
of equations are (always) shown in the table header;
if <code>FALSE</code>, left-hand sides
of equations are not shown;
if <code>NA</code>, left-hand sides
of equations are shown only if left-hand sides differ
among models or one of the models has multiple equations.
</p>
</td></tr>
<tr><td><code id="mtable_+3A_gs.options">gs.options</code></td>
<td>
<p>an optional list of arguments passed on to
<code>getSummary</code></p>
</td></tr>
<tr><td><code id="mtable_+3A_controls">controls</code></td>
<td>
<p>an optional formula or character vector that
designates &quot;control variables&quot; for which no coefficients are
reported, but only whether they are present in the model.
</p>
</td></tr>
<tr><td><code id="mtable_+3A_collapse.controls">collapse.controls</code></td>
<td>
<p>a logical values; should the report about
inclusion of control variables collapsed to a single value? If
yes, models should either contain none or all of the control
variables.
</p>
</td></tr>
<tr><td><code id="mtable_+3A_control.var.indicator">control.var.indicator</code></td>
<td>

<p>a character vector with to elements; the first element being used
to indicate the presence of a control variable or all
control variables (if <code>collapse.controls=TRUE</code>), the second
element being used otherwise. By default these elements are
<code>"Yes"</code> and <code>"No"</code>. 
</p>
</td></tr>
<tr><td><code id="mtable_+3A_x">x</code>, <code id="mtable_+3A_object">object</code></td>
<td>
<p>an object of class <code>mtable</code></p>
</td></tr>
<tr><td><code id="mtable_+3A_gsub">gsub</code>, <code id="mtable_+3A_warn">warn</code>, <code id="mtable_+3A_fixed">fixed</code></td>
<td>
<p>logical values, see <code><a href="#topic+relabel">relabel</a></code></p>
</td></tr>
<tr><td><code id="mtable_+3A_target">target</code></td>
<td>
<p>a character string which indicates the target format.
Currenlty the targets
&quot;print&quot; (see <code><a href="#topic+mtable_format_print">mtable_format_print</a></code>),
&quot;LaTeX&quot; (see <code><a href="#topic+mtable_format_latex">mtable_format_latex</a></code>),
&quot;HTML&quot; (see <code><a href="#topic+mtable_format_html">mtable_format_html</a></code>), and
&quot;delim&quot; (see <code><a href="#topic+mtable_format_delim">mtable_format_delim</a></code>)
are supported.
</p>
</td></tr>
<tr><td><code id="mtable_+3A_center.at">center.at</code></td>
<td>
<p>a character string on which resulting values are centered.
Typically equal to &quot;.&quot;. This is the default when <code>forLaTeX==TRUE</code>.
If <code>NULL</code>, reported values are not centered.</p>
</td></tr>
<tr><td><code id="mtable_+3A_topsep">topsep</code></td>
<td>
<p>a character string that is recycled to a top rule.</p>
</td></tr>
<tr><td><code id="mtable_+3A_bottomsep">bottomsep</code></td>
<td>
<p>a character string that is recycled to a bottom rule.</p>
</td></tr>
<tr><td><code id="mtable_+3A_sectionsep">sectionsep</code></td>
<td>
<p>a character string that is recycled to seperate coefficients
from summary statistics.</p>
</td></tr>
<tr><td><code id="mtable_+3A_file">file</code></td>
<td>
<p>name of the file where to write to; defaults to console output.</p>
</td></tr>
<tr><td><code id="mtable_+3A_format">format</code></td>
<td>
<p>character string that specifies the desired format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mtable</code> constructs a table of estimates for regression-type models.
<code>format.memisc_mtable</code> formats suitable for use with output or conversion functions
such as <code>print.memisc_mtable</code>, <code>toLatex.memisc_mtable</code>, or
<code>write.memisc_mtable</code>.
</p>


<h3>Value</h3>

<p>A call to <code>mtable</code> results in an object of class <code>"mtable"</code>
with the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a list that contains the model coefficients,</p>
</td></tr>
<tr><td><code>summaries</code></td>
<td>
<p>a matrix that contains the model summaries,</p>
</td></tr>
<tr><td><code>calls</code></td>
<td>
<p>a list of calls that created the model estimates
being summarised.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#### Basic workflow

lm0 &lt;- lm(sr ~ pop15 + pop75,              data = LifeCycleSavings)
lm1 &lt;- lm(sr ~                 dpi + ddpi, data = LifeCycleSavings)
lm2 &lt;- lm(sr ~ pop15 + pop75 + dpi + ddpi, data = LifeCycleSavings)

options(summary.stats.lm=c("R-squared","N"))
mtable("Model 1"=lm0,"Model 2"=lm1,"Model 3"=lm2)

options(summary.stats.lm=c("sigma","R-squared","N"))
mtable("Model 1"=lm0,"Model 2"=lm1,"Model 3"=lm2)

options(summary.stats.lm=NULL)

mtable123 &lt;- mtable("Model 1"=lm0,"Model 2"=lm1,"Model 3"=lm2,
    summary.stats=c("sigma","R-squared","F","p","N"))

(mtable123 &lt;- relabel(mtable123,
  "(Intercept)" = "Constant",
          pop15 = "Percentage of population under 15",
          pop75 = "Percentage of population over 75",
            dpi = "Real per-capita disposable income",
           ddpi = "Growth rate of real per-capita disp. income"
  ))

# This produces output in tab-delimited format:
write.mtable(mtable123)

## Not run: 
# This produces output in tab-delimited format:
file123 &lt;- "mtable123.txt"
write.mtable(mtable123,file=file123)
file.show(file123)
# The contents of this file can be pasted into Word
# and converted into a Word table.

## End(Not run)

## Not run: texfile123 &lt;- "mtable123.tex"
write.mtable(mtable123,format="LaTeX",file=texfile123)
file.show(texfile123)
## End(Not run)

#### Examples with UC Berkeley data

berkeley &lt;- Aggregate(Table(Admit,Freq)~.,data=UCBAdmissions)

berk0 &lt;- glm(cbind(Admitted,Rejected)~1,data=berkeley,family="binomial")
berk1 &lt;- glm(cbind(Admitted,Rejected)~Gender,data=berkeley,family="binomial")
berk2 &lt;- glm(cbind(Admitted,Rejected)~Gender+Dept,data=berkeley,family="binomial")

mtable(berk0,summary.stats=c("Deviance","N"))
mtable(berk1,summary.stats=c("Deviance","N"))

mtable(berk0,berk1,berk2,summary.stats=c("Deviance","N"))

mtable(berk0,berk1,berk2,
          coef.style="horizontal",
          summary.stats=c("Deviance","AIC","N"))
mtable(berk0,berk1,berk2,
          coef.style="stat",
          summary.stats=c("Deviance","AIC","N"))
mtable(berk0,berk1,berk2,
          coef.style="ci",
          summary.stats=c("Deviance","AIC","N"))
mtable(berk0,berk1,berk2,
          coef.style="ci.se",
          summary.stats=c("Deviance","AIC","N"))
mtable(berk0,berk1,berk2,
          coef.style="ci.se.horizontal",
          summary.stats=c("Deviance","AIC","N"))
mtable(berk0,berk1,berk2,
          coef.style="ci.p.horizontal",
          summary.stats=c("Deviance","AIC","N"))
mtable(berk0,berk1,berk2,
          coef.style="ci.horizontal",
          summary.stats=c("Deviance","AIC","N"))
mtable(berk0,berk1,berk2,
          coef.style="all",
          summary.stats=c("Deviance","AIC","N"))
mtable(berk0,berk1,berk2,
          coef.style="all.nostar",
          summary.stats=c("Deviance","AIC","N"))

mtable(by(berkeley,berkeley$Dept,
  function(x)glm(cbind(Admitted,Rejected)~Gender,
        data=x,family="binomial")),
      summary.stats=c("Likelihood-ratio","N"))


mtable(By(~Gender,
  glm(cbind(Admitted,Rejected)~Dept,
        family="binomial"),
        data=berkeley),
      summary.stats=c("Likelihood-ratio","N"))

berkfull &lt;- glm(cbind(Admitted,Rejected)~Dept/Gender - 1,
                      data=berkeley,family="binomial")
relabel(mtable(berkfull),Dept="Department",gsub=TRUE)

#### Array-like semantics

mtable123 &lt;- mtable("Model 1"=lm0,"Model 2"=lm1,"Model 3"=lm2,
    summary.stats=c("sigma","R-squared","F","p","N"))

dim(mtable123)
dimnames(mtable123)
mtable123[c("dpi","ddpi"),
          c("Model 2","Model 3")]

#### Concatention
mt01 &lt;- mtable(lm0,lm1,summary.stats=c("R-squared","N"))
mt12 &lt;- mtable(lm1,lm2,summary.stats=c("R-squared","F","N"))
c(mt01,mt12) # not that this makes sense, but ...
c("Group 1"=mt01,
  "Group 2"=mt12)
</code></pre>

<hr>
<h2 id='mtable_format_delim'>Format for 'mtable' Objects for Writing into File</h2><span id='topic+mtable_format_delim'></span>

<h3>Description</h3>

<p><code>mtable_mtable_print</code> formats 'mtable' in a way suitable for output into a file
with <code>write.table</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtable_format_delim(x,
          colsep="\t",
          rowsep="\n",
          interaction.sep = " x ",
          ...
          )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtable_format_delim_+3A_x">x</code></td>
<td>
<p>an object of class <code>mtable</code></p>
</td></tr>
<tr><td><code id="mtable_format_delim_+3A_colsep">colsep</code></td>
<td>
<p>a character string which seperates the columns in the output.</p>
</td></tr>
<tr><td><code id="mtable_format_delim_+3A_rowsep">rowsep</code></td>
<td>
<p>a character string which seperates the rows in the output.</p>
</td></tr>
<tr><td><code id="mtable_format_delim_+3A_interaction.sep">interaction.sep</code></td>
<td>
<p>a character string that separates factors that are involved
in an interaction effect</p>
</td></tr>
<tr><td><code id="mtable_format_delim_+3A_...">...</code></td>
<td>
<p>further arguments, ignored. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>

<hr>
<h2 id='mtable_format_html'>HTML Formatting for 'mtable' Results</h2><span id='topic+mtable_format_html'></span><span id='topic+format_html.memisc_mtable'></span><span id='topic+mtable_format_html'></span><span id='topic+mtable_format_stdstyle'></span>

<h3>Description</h3>

<p>These functions formats 'mtable' objects into HTML format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtable_format_html(x,
                    interaction.sep = NULL,
                    toprule=2,midrule=1,bottomrule=2,
                    split.dec=TRUE,
                    style=mtable_format_stdstyle,
                    margin="2ex auto", 
                    sig.notes.style=c(width="inherit"),
                    ...
  )
## S3 method for class 'memisc_mtable'
format_html(x,
                    interaction.sep = NULL,
                    toprule=2,midrule=1,bottomrule=2,
                    split.dec=TRUE,
                    style=mtable_format_stdstyle,
                    margin="2ex auto", 
                    sig.notes.style=c(width="inherit"),
                    ...
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtable_format_html_+3A_x">x</code></td>
<td>
<p>an object of class <code>mtable</code></p>
</td></tr>
<tr><td><code id="mtable_format_html_+3A_toprule">toprule</code></td>
<td>
<p>integer;
thickness in pixels of rule at the top of the table.</p>
</td></tr>
<tr><td><code id="mtable_format_html_+3A_midrule">midrule</code></td>
<td>
<p>integer;
thickness in pixels of rules within the table.</p>
</td></tr>
<tr><td><code id="mtable_format_html_+3A_bottomrule">bottomrule</code></td>
<td>
<p>integer;
thickness in pixels of rule at the bottom of the table.</p>
</td></tr>
<tr><td><code id="mtable_format_html_+3A_interaction.sep">interaction.sep</code></td>
<td>
<p>a character string that separates factors that are involved
in an interaction effect or NULL. If NULL then a reasonable default is used
(either a unicode character or an ampersand encoded HTML entity).</p>
</td></tr>
<tr><td><code id="mtable_format_html_+3A_split.dec">split.dec</code></td>
<td>
<p>logical; whether numbers should be centered
at the decimal point by splitting the table cells.</p>
</td></tr>
<tr><td><code id="mtable_format_html_+3A_style">style</code></td>
<td>
<p>string containing default the CSS styling.</p>
</td></tr>
<tr><td><code id="mtable_format_html_+3A_margin">margin</code></td>
<td>
<p>character string, determines the margin and thus
the position of the HTML table.</p>
</td></tr>
<tr><td><code id="mtable_format_html_+3A_sig.notes.style">sig.notes.style</code></td>
<td>
<p>a character vector with named elements,
allows extra styling of the p-values notes at the bottom of
the table.</p>
</td></tr>
<tr><td><code id="mtable_format_html_+3A_...">...</code></td>
<td>
<p>further arguments, ignored. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with code suitable for inclusion into a HTML-file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lm0 &lt;- lm(sr ~ pop15 + pop75,              data = LifeCycleSavings)
lm1 &lt;- lm(sr ~                 dpi + ddpi, data = LifeCycleSavings)
lm2 &lt;- lm(sr ~ pop15 + pop75 + dpi + ddpi, data = LifeCycleSavings)

mtable123 &lt;- mtable("Model 1"=lm0,"Model 2"=lm1,"Model 3"=lm2,
                    summary.stats=c("sigma","R-squared","F","p","N"))

(mtable123 &lt;- relabel(mtable123,
                      "(Intercept)" = "Constant",
                      pop15 = "Percentage of population under 15",
                      pop75 = "Percentage of population over 75",
                      dpi = "Real per-capita disposable income",
                      ddpi = "Growth rate of real per-capita disp. income"
))

# Use HTML entity '&amp;minus;' for minus sign
options(html.use.ampersand=TRUE)
show_html(mtable123)
show_html(mtable123[1:2],
          sig.notes.style=c(width="30ex"))

# Use unicode for minus sign (default)
options(html.use.ampersand=FALSE)
show_html(mtable123)
</code></pre>

<hr>
<h2 id='mtable_format_latex'>Format 'mtable' Results for LaTeX</h2><span id='topic+mtable_format_latex'></span>

<h3>Description</h3>

<p>This function formats objects created by <code><a href="#topic+mtable">mtable</a></code> for inclusion
into LaTeX files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mtable_format_latex(x,
            useDcolumn=getOption("useDcolumn",TRUE),
            colspec=if(useDcolumn) 
                      paste("D{.}{",LaTeXdec,"}{",ddigits,"}",sep="") 
                    else "l",
            LaTeXdec=".",
            ddigits=min(3,getOption("digits")),
            useBooktabs=getOption("useBooktabs",TRUE),
            toprule=if(useBooktabs) "\\toprule" else "\\hline\\hline",
            midrule=if(useBooktabs) "\\midrule" else "\\hline",
            cmidrule=if(useBooktabs) "\\cmidrule" else "\\cline",
            bottomrule=if(useBooktabs) "\\bottomrule" else "\\hline\\hline",
            interaction.sep = " $\\times$ ",
            sdigits=min(1,ddigits),
            compact=FALSE,
            sumry.multicol=FALSE,
            escape.tex=getOption("toLatex.escape.tex",FALSE),
            signif.notes.type=getOption("toLatex.signif.notes.type","include"),
            signif.notes.spec=getOption("toLatex.signif.notes.spec","p{.5\\linewidth}"),
            ...
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtable_format_latex_+3A_x">x</code></td>
<td>
<p>an object of class <code>mtable</code></p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_usedcolumn">useDcolumn</code></td>
<td>
<p>should the <code>dcolumn</code> LaTeX package be used?
If true, you will have to include <code>\usepackage{dcolumn}</code> into
the preamble of your LaTeX document.</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_colspec">colspec</code></td>
<td>
<p>LaTeX table column format specifyer(s).</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_latexdec">LaTeXdec</code></td>
<td>
<p>the decimal point in the final LaTeX output.</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_ddigits">ddigits</code></td>
<td>
<p>alignment specification or digits after the decimal point.</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_usebooktabs">useBooktabs</code></td>
<td>
<p>should the <code>booktabs</code> LaTeX package be used?
If true, you will have to include <code>\usepackage{booktabs}</code> into
the preamble of your LaTeX document.</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_toprule">toprule</code></td>
<td>
<p>appearance of the top border of the LaTeX <code>tabular</code> environment.</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_midrule">midrule</code></td>
<td>
<p>how are coefficients and summary statistics
separated in the LaTeX <code>tabular</code> environment.</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_cmidrule">cmidrule</code></td>
<td>
<p>appearance of rules under section headings.</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_bottomrule">bottomrule</code></td>
<td>
<p>appearance of the bottom border of the LaTeX <code>tabular</code> environment.</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_interaction.sep">interaction.sep</code></td>
<td>
<p>a character string that separates factors that are involved
in an interaction effect</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_sdigits">sdigits</code></td>
<td>
<p>integer; number of digits after decimal dot for summary statistics.</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_compact">compact</code></td>
<td>
<p>logical; should the table be compact, without extra columns
between multi-equation models?</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_sumry.multicol">sumry.multicol</code></td>
<td>
<p>logical, should summaries enclosed into
<code>\multicol</code> commands?</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_escape.tex">escape.tex</code></td>
<td>
<p>logical, should symbols <code>$</code>, <code>_</code>, and <code>^</code> be
escaped with backslashes?</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_signif.notes.type">signif.notes.type</code></td>
<td>
<p>character string; should be either
<code>"include"</code>,<code>"append"</code>, <code>"drop"</code>,  or <code>"tnotes"</code>. If
<code>"append"</code>, (very simple) LaTeX code is appended that contains
notes that relate significance symbols to p-values. If
<code>"include"</code>, the LaTeX table will include a (multi-column)
cell with these notes. If <code>"drop"</code>, notes will not be added.
If <code>"tnotes"</code>, the exported LaTeX
table is wrapped in a <code>threeparttable</code> environment and the
p-value notes are wrapped in a <code>tablenotes</code> environment. This
requires the LaTeX package <code>threeparttable</code> in order to work.
</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_signif.notes.spec">signif.notes.spec</code></td>
<td>
<p>character string; specifies format
of cells that include notes about p-values; relevant only if
<code>signif.notes.type="include"</code>
</p>
</td></tr>
<tr><td><code id="mtable_format_latex_+3A_...">...</code></td>
<td>
<p>further arguments, ignored. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with code suitable for inclusion into a LaTeX-file.
</p>

<hr>
<h2 id='mtable_format_print'>Print Format for 'mtable' Objects</h2><span id='topic+mtable_format_print'></span>

<h3>Description</h3>

<p><code>mtable_format_print</code> formats 'mtable' in a way suitable for screen output
with 'print'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtable_format_print(x,
  topsep="=",
  bottomsep="=",
  sectionsep="-",
  interaction.sep = " x ",
  center.at=getOption("OutDec"),
  align.integers=c("dot","right","left"),
  padding = "  ",
  ...
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtable_format_print_+3A_x">x</code></td>
<td>
<p>an object of class <code>mtable</code></p>
</td></tr>
<tr><td><code id="mtable_format_print_+3A_topsep">topsep</code></td>
<td>
<p>a character string that is recycled to a top rule.</p>
</td></tr>
<tr><td><code id="mtable_format_print_+3A_bottomsep">bottomsep</code></td>
<td>
<p>a character string that is recycled to a bottom rule.</p>
</td></tr>
<tr><td><code id="mtable_format_print_+3A_sectionsep">sectionsep</code></td>
<td>
<p>a character string that is recycled to seperate coefficients
from summary statistics.</p>
</td></tr>
<tr><td><code id="mtable_format_print_+3A_interaction.sep">interaction.sep</code></td>
<td>
<p>a character string that separates factors that are involved
in an interaction effect</p>
</td></tr>
<tr><td><code id="mtable_format_print_+3A_center.at">center.at</code></td>
<td>
<p>a character string on which resulting values are centered.
Typically equal to &quot;.&quot;. This is the default when <code>forLaTeX==TRUE</code>.
If <code>NULL</code>, reported values are not centered.</p>
</td></tr>
<tr><td><code id="mtable_format_print_+3A_align.integers">align.integers</code></td>
<td>
<p>how to align integer values.</p>
</td></tr>
<tr><td><code id="mtable_format_print_+3A_padding">padding</code></td>
<td>
<p>a character string, usually whitespace, used to insert left- and right-padding of 
table contents.</p>
</td></tr>
<tr><td><code id="mtable_format_print_+3A_...">...</code></td>
<td>
<p>further arguments, ignored. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>

<hr>
<h2 id='neg2mis'>Mark Negative Values as Missing</h2><span id='topic+neg2mis'></span>

<h3>Description</h3>

<p>In many newer survey data sets available from social
science data archives non-valid responses (such as &quot;don't know&quot; or
&quot;answer refused&quot;) are given negative codes. The function
<code>neg2miss</code> allows to mark them as missing values.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg2mis(x,all=FALSE,exclude=NULL,select=NULL,zero=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neg2mis_+3A_x">x</code></td>
<td>
<p>an object that inherits from class &quot;item.list&quot;, e.g. a
&quot;data.set&quot; or an &quot;importer&quot; object.</p>
</td></tr>
<tr><td><code id="neg2mis_+3A_all">all</code></td>
<td>
<p>logical; should the marking of negative values as missing
applied to all variables?</p>
</td></tr>
<tr><td><code id="neg2mis_+3A_exclude">exclude</code></td>
<td>
<p>an optional vector of variable naems to which
the marking of negative values as missing should <em>not</em> be
applied.</p>
</td></tr>
<tr><td><code id="neg2mis_+3A_select">select</code></td>
<td>
<p>an optional vector of variable names to which
the marking of negative values as missing should be applied.</p>
</td></tr>
<tr><td><code id="neg2mis_+3A_zero">zero</code></td>
<td>
<p>logical; should zeroes also be marked as missing?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.set(
          var1 = c(0,1,-1,2,3),
          var2 = c(-1,-1,1,1,1),
          var3 = c(1,2,3,4,5)
          )
neg2mis(ds,all=TRUE)
neg2mis(ds,all=TRUE,zero=TRUE)
neg2mis(ds,exclude=var1)
neg2mis(ds,select=var1)
</code></pre>

<hr>
<h2 id='negative+20match'>Negative Match</h2><span id='topic++25nin+25'></span>

<h3>Description</h3>

<p><code>%nin%</code>
is a convenience operator:
<code>x %nin% table</code>
is equivalent to
<code>!(x %in% table).</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  x %nin% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negative+2B20match_+3A_x">x</code></td>
<td>
<p>the values to be matched</p>
</td></tr>
<tr><td><code id="negative+2B20match_+3A_table">table</code></td>
<td>
<p>a values to be match against</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:6,12,replace=TRUE)
x %in% 1:3
x %nin% 1:3
</code></pre>

<hr>
<h2 id='percent'>Table of Percentages with Percentage Base</h2><span id='topic+percent'></span><span id='topic+percent.default'></span><span id='topic+percent.logical'></span>

<h3>Description</h3>

<p><code>percent</code> returns a table of percentages along with
the percentage base. It will be useful
in conjunction with <code><a href="#topic+Aggregate">Aggregate</a></code> or <code><a href="#topic+genTable">genTable</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  percent(x,...)
  ## Default S3 method:
percent(x,weights=NULL,total=!(se || ci),
      se=FALSE,ci=FALSE,ci.level=.95,
      total.name="N",perc.label="Percentage",...)
  ## S3 method for class 'logical'
percent(x,weights=NULL,total=!(se || ci),
      se=FALSE,ci=FALSE,ci.level=.95,
      total.name="N",perc.label="Percentage",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percent_+3A_x">x</code></td>
<td>
<p>a numeric vector or factor.</p>
</td></tr>
<tr><td><code id="percent_+3A_weights">weights</code></td>
<td>
<p>a optional numeric vector of weights of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="percent_+3A_total">total</code></td>
<td>
<p>logical; should the total sum of counts from which the percentages are
computed be included into the output?</p>
</td></tr>
<tr><td><code id="percent_+3A_se">se</code></td>
<td>
<p>logical; should standard errors of the percentages be included?</p>
</td></tr>
<tr><td><code id="percent_+3A_ci">ci</code></td>
<td>
<p>logical; should confidence intervals of the percentages be included?</p>
</td></tr>
<tr><td><code id="percent_+3A_ci.level">ci.level</code></td>
<td>
<p>numeric; nominal coverage of confidence intervals</p>
</td></tr>
<tr><td><code id="percent_+3A_total.name">total.name</code></td>
<td>
<p>character; name given for the total sum of counts</p>
</td></tr>
<tr><td><code id="percent_+3A_perc.label">perc.label</code></td>
<td>
<p>character; label given for the percentages if the
table has more than one dimensions, e.g. if <code>se</code> or <code>ci</code> is TRUE.</p>
</td></tr>
<tr><td><code id="percent_+3A_...">...</code></td>
<td>
<p>for <code>percent.mresp</code>: one or several 1-0 vectors or matrices
otherwise, further arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of percentages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100)
y &lt;- rnorm(100)
z &lt;- rnorm(100)
f &lt;- sample(1:3,100,replace=TRUE)
f &lt;- factor(f,labels=c("a","b","c"))


percent(x&gt;0)
percent(f)

genTable(
  cbind(percent(x&gt;0),
        percent(y&gt;0),
        percent(z&gt;0)) ~ f
  )

gt &lt;- genTable(
  cbind("x &gt; 0" = percent(x&gt;0,ci=TRUE),
        "y &gt; 0" = percent(y&gt;0,ci=TRUE),
        "z &gt; 0" = percent(z&gt;0,ci=TRUE)) ~ f
  )

ftable(gt,row.vars=3:2,col.vars=1)

ex.data &lt;- expand.grid(mean=c(0,25,50),sd=c(1,10,100))[rep(1:9,rep(250,9)),]
ex.data &lt;- within(ex.data,x &lt;- rnorm(n=nrow(ex.data),mean=ex.data$mean,sd=ex.data$sd))
ex.data &lt;- within(ex.data,x.grp &lt;- cases( x &lt; 0,
                                            x &gt;= 0 &amp; x &lt; 50,
                                            x &gt;= 50 &amp; x &lt; 100,
                                            x &gt;= 100
                                          ))
genTable(percent(x.grp)~mean+sd,data=ex.data)

Aggregate(percent(Admit,weight=Freq)~Gender+Dept,data=UCBAdmissions)
</code></pre>

<hr>
<h2 id='percentages'>
Easy Creation of Tables of Percentages
</h2><span id='topic+percentages'></span><span id='topic+percentages.table'></span><span id='topic+percentages.formula'></span><span id='topic+percentages.default'></span><span id='topic+percentages.data.frame'></span><span id='topic+percentages.list'></span><span id='topic+as.data.frame.percentage.table'></span><span id='topic+as.data.frame.xpercentage.table'></span>

<h3>Description</h3>

<p>The generic function <code>percentages</code> and its methods
create one- or multidimensional tables of percentages. As such,
the function <code>percentages</code> can be viewed as a convenience
interface to <code><a href="base.html#topic+prop.table">prop.table</a></code>. However, it also
allows to obtain standard errors and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentages(obj, ...)
## S3 method for class 'table'
percentages(obj,
      by=NULL, which=NULL, se=FALSE, ci=FALSE, ci.level=.95, ...)
## S3 method for class 'formula'
percentages(obj,
      data=parent.frame(), weights=NULL, ...)
## Default S3 method:
percentages(obj,
      weights=NULL, ...)
## S3 method for class 'data.frame'
percentages(obj,
      weights=NULL, ...)
## S3 method for class 'list'
percentages(obj,
      weights=NULL, ...)
## S3 method for class 'percentage.table'
as.data.frame(x, ...)
## S3 method for class 'xpercentage.table'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percentages_+3A_obj">obj</code></td>
<td>
<p>an object; a contingency table or a formula. If
it is a formula, its left-hand side determines the factor 
or combination of factors for which percentages are 
computed while its right-hand side determines the 
factor or combination of factors that define the 
groups within which percentages are computed.</p>
</td></tr>
<tr><td><code id="percentages_+3A_by">by</code></td>
<td>
<p>a character vector with the names of the
factor variables that define the groups within which percentages
are computed. Percentages sum to 100 within combination
of levels of these factors.</p>
</td></tr>
<tr><td><code id="percentages_+3A_which">which</code></td>
<td>
<p>a character vector with the names of the
factor variables for which percentages 
are computed.</p>
</td></tr>
<tr><td><code id="percentages_+3A_se">se</code></td>
<td>
<p>a logical value; determines whether standard
errors are computed.</p>
</td></tr>
<tr><td><code id="percentages_+3A_ci">ci</code></td>
<td>
<p>a logical value; determines whether confidence
intervals are computed. Note that the confidence intervals
are for infinite (or very large) populations.</p>
</td></tr>
<tr><td><code id="percentages_+3A_ci.level">ci.level</code></td>
<td>
<p>a numerical value, the required confidence level of
the confidence intervals.</p>
</td></tr>
<tr><td><code id="percentages_+3A_data">data</code></td>
<td>
<p>a contingency table (an object that inherits from &quot;table&quot;)
or a data frame or an object coercable into a data frame.</p>
</td></tr>
<tr><td><code id="percentages_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights. Should be NULL or a
numeric vector.</p>
</td></tr>
<tr><td><code id="percentages_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to the
&quot;table&quot; method of <code>percentages</code> or ignored in case of
a call to <code>as.data.frame</code>.</p>
</td></tr>
<tr><td><code id="percentages_+3A_x">x</code></td>
<td>
<p>an object coerced into a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array that inherits classes &quot;percentage.table&quot; and &quot;table&quot;. If
<code>percentages</code> was called with <code>se=TRUE</code> or <code>ci=TRUE</code>
then the result additionally inherits class &quot;xpercentage.table&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>percentages(UCBAdmissions)

# Three equivalent ways to create the same table of conditional
# percentages
percentages(Admit~Gender+Dept,data=UCBAdmissions)
percentages(UCBAdmissions,by=c("Gender","Dept"))
percentages(UCBAdmissions,which="Admit")
# Percentage table as data frame
as.data.frame(percentages(Admit~Gender+Dept,data=UCBAdmissions))

# Standard errors and confidence intervals
percentages(Admit~Dept,data=UCBAdmissions,se=TRUE)
percentages(Admit~Dept,data=UCBAdmissions,ci=TRUE)
(p&lt;- percentages(Admit~Dept,data=UCBAdmissions,ci=TRUE,se=TRUE))

# An extended table of percentages as data frame
as.data.frame(p)

# A table of percentages of a factor
percentages(iris$Species)

UCBA &lt;- as.data.frame(UCBAdmissions)
percentages(UCBA$Admit,weights=UCBA$Freq)

percentages(UCBA,weights=UCBA$Freq)

</code></pre>

<hr>
<h2 id='query'>Query an Object for Information</h2><span id='topic+query'></span><span id='topic+query+2Cdata.set-method'></span><span id='topic+query+2Cimporter-method'></span><span id='topic+query+2Citem-method'></span>

<h3>Description</h3>

<p>The function <code>query</code> can be used to search an object
for a keyword.
</p>
<p>The <code><a href="#topic+data.set">data.set</a></code> and <code><a href="#topic+importer">importer</a></code> methods perform such a search
through the annotations and value labels of
the items in the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query(x,pattern,...)
## S4 method for signature 'data.set'
query(x,pattern,...)
## S4 method for signature 'importer'
query(x,pattern,...)

## S4 method for signature 'item'
query(x,pattern,...)
# (Called by the methods above.)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="query_+3A_pattern">pattern</code></td>
<td>
<p>a character string that gives the pattern to be searched
for</p>
</td></tr>
<tr><td><code id="query_+3A_...">...</code></td>
<td>
<p>optional arguments such as
</p>

<dl>
<dt><code>fuzzy</code></dt><dd><p>logical, TRUE by default; use fuzzy search via <code><a href="base.html#topic+agrep">agrep</a></code> or regexp search
via <code><a href="base.html#topic+grep">grep</a></code> </p>
</dd>
<dt><code>extended</code></dt><dd><p>logical, defaults to FALSE; passed to <code><a href="base.html#topic+grep">grep</a></code> </p>
</dd>
<dt><code>perl</code></dt><dd><p>logical, defaults to TRUE; passed to <code><a href="base.html#topic+grep">grep</a></code> </p>
</dd>
<dt><code>fixed</code></dt><dd><p>logical, defaults to TRUE; passed to <code><a href="base.html#topic+grep">grep</a></code> </p>
</dd>
<dt><code>ignore.case</code></dt><dd><p>logical, defaults to TRUE; passed to <code><a href="base.html#topic+grep">grep</a></code> or <code><a href="base.html#topic+agrep">agrep</a></code></p>
</dd>
<dt><code>insertions</code></dt><dd><p>numerical value, defaults
to 0.999999999; passed to <code><a href="base.html#topic+agrep">agrep</a></code> </p>
</dd>
<dt><code>deletions</code></dt><dd><p>numerical value, defaults to 0; passed to <code><a href="base.html#topic+agrep">agrep</a></code> </p>
</dd>
<dt><code>substitutions</code></dt><dd><p>numerical value, defaults to 0; passed to <code><a href="base.html#topic+agrep">agrep</a></code> </p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>If both the annotation and the value labels of an item match the pattern
the <code>query</code> method for 'item' objects returns a list containing the annotation
and the value labels, otherwise if only the annotation or the value labels
match the pattern, either the annotation or the value labels are returned,
otherwise if neither matches the pattern, <code>query</code> returns <code>NULL</code>.
</p>
<p>The methods of <code>query</code> for 'data.set' and 'importer' objects return
a list of all non-<code>NULL</code> query results of all items contained by these
objects, or <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nes1948.por &lt;- unzip(system.file("anes/NES1948.ZIP",package="memisc"),
                     "NES1948.POR",exdir=tempfile())
nes1948 &lt;- spss.portable.file(nes1948.por)
query(nes1948,"TRUMAN")
</code></pre>

<hr>
<h2 id='recode'>Recode Items, Factors and Numeric Vectors</h2><span id='topic+recode'></span><span id='topic+recode+2Cvector-method'></span><span id='topic+recode+2Citem-method'></span><span id='topic+recode+2Cfactor-method'></span>

<h3>Description</h3>

<p><code>recode</code> substitutes old values of a factor or a numeric
vector by new ones, just like the recoding facilities in some
commercial statistical packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(x,...,
       copy=getOption("recode_copy",identical(otherwise,"copy")),
       otherwise=NA)
## S4 method for signature 'vector'
recode(x,...,
    copy=getOption("recode_copy",identical(otherwise,"copy")),
    otherwise=NA)
## S4 method for signature 'factor'
recode(x,...,
    copy=getOption("recode_copy",identical(otherwise,"copy")),
    otherwise=NA)
## S4 method for signature 'item'
recode(x,...,
    copy=getOption("recode_copy",identical(otherwise,"copy")),
    otherwise=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="recode_+3A_...">...</code></td>
<td>
<p>One or more assignment expressions, each 
of the form <code>new.value &lt;- old.values</code>.
<code>new.value</code> should be a scalar numeric value
or character string. If one of the <code>new.value</code>s
is a character string, the return value
of <code>recode</code> will be a factor and each <code>new.value</code>
will be coerced to a character string that labels a level of the factor.
</p>
<p>Each <code>old.value</code> in an assignment expression may be a
(numeric or character) vector. If <code>x</code> is numeric such an
assignment expression may have the form <code>new.value &lt;- range(lower,upper)</code>
In that case, values between <code>lower</code> and <code>upper</code> are exchanged by
<code>new.value</code>. If one of the arguments to <code>range</code> is <code>min</code>,
it is substituted by the minimum of <code>x</code>.
If one of the arguments to <code>range</code> is <code>max</code>,
it is substituted by the maximum of <code>x</code>.
</p>
<p>In case of the method for <code>labelled</code> vectors, the <em>tags</em> of
arguments of the form <code>tag = new.value &lt;- old.values</code>
will define the labels of the new codes.
</p>
<p>If the <code>old.values</code> of different assignment expressions overlap,
an error will be raised because the recoding is ambigous.
</p>
</td></tr>
<tr><td><code id="recode_+3A_copy">copy</code></td>
<td>
<p>logical; should those values of <code>x</code> not given an
explicit new code copied into the resulting vector?</p>
</td></tr>
<tr><td><code id="recode_+3A_otherwise">otherwise</code></td>
<td>
<p>a character string or some other value
that the result may obtain. If equal to <code>NA</code> or <code>"NA"</code>,
original codes not given an explicit new code are recoded into
<code>NA</code>. If equal to <code>"copy"</code>,
original codes not given an explicit new code are copied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>recode</code> relies on the lazy evaluation mechanism of <em>R</em>:
Arguments are not evaluated until required by the function they are given to.
<code>recode</code> does not cause arguments that appear in <code>...</code> to be evaluated.
Instead, <code>recode</code> parses the <code>...</code> arguments. Therefore, although
expressions like <code>1 &lt;- 1:4</code> would cause an error action, if evaluated
at any place elsewhere in <em>R</em>, they will not cause an error action,
if given to <code>recode</code> as an argument. However, a call of the
form <code>recode(x,1=1:4)</code>, would be a syntax error.
</p>
<p>If John Fox' package &quot;car&quot; is installed, <code>recode</code> will also be callable
with the syntax of the <code>recode</code> function of that package.
</p>


<h3>Value</h3>

<p>A numerical vector, factor or an <code>item</code> object.
</p>


<h3>See Also</h3>

<p><code>recode</code> of package &quot;car&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.item(sample(1:6,20,replace=TRUE),
        labels=c( a=1,
                  b=2,
                  c=3,
                  d=4,
                  e=5,
                  f=6))
print(x)


codebook(
    recode(x,
           a = 1 &lt;- 1:2,
           b = 2 &lt;- 4:6))


codebook(
    recode(x,
           a = 1 &lt;- 1:2,
           b = 2 &lt;- 4:6,
           copy = TRUE))

# Note the handling of labels if the recoding rules are bijective
codebook(
    recode(x,
           1 &lt;- 2,
           2 &lt;- 1,
           copy=TRUE))

codebook(
    recode(x,
           a = 1 &lt;- 2,
           b = 2 &lt;- 1,
           copy=TRUE))


# A recoded version of x is returned
# containing the values 1, 2, 3, which are
# labelled as "A", "B", "C".
recode(x,
  A = 1 &lt;- range(min,2),
  B = 2 &lt;- 3:4,
  C = 3 &lt;- range(5,max), # this last comma is ignored
  )

# This causes an error action: the sets
# of original values overlap.
try(recode(x,
  A = 1 &lt;- range(min,2),
  B = 2 &lt;- 2:4,
  C = 3 &lt;- range(5,max)
  ))

recode(x,
  A = 1 &lt;- range(min,2),
  B = 2 &lt;- 3:4,
  C = 3 &lt;- range(5,6),
  D = 4 &lt;- 7
  )
  
# This results in an all-missing vector:
recode(x,
  D = 4 &lt;- 7,
  E = 5 &lt;- 8
  )

f &lt;- as.factor(x)
x &lt;- as.integer(x)

recode(x,
  1 &lt;- range(min,2),
  2 &lt;- 3:4,
  3 &lt;- range(5,max)
  )

# This causes another error action:
# the third argument is an invalid
# expression for a recoding.
try(recode(x,
  1 &lt;- range(min,2),
  3:4,
  3 &lt;- range(5,max)
  ))

# The new values are character strings,
# therefore a factor is returned.
recode(x,
  "a" &lt;- range(min,2),
  "b" &lt;- 3:4,
  "c" &lt;- range(5,6)
  )
  
recode(x,
  1 &lt;- 1:3,
  2 &lt;- 4:6
  )
  
recode(x,
  4 &lt;- 7,
  5 &lt;- 8,
  otherwise = "copy"
  )

recode(f,
  "A" &lt;- c("a","b"),
  "B" &lt;- c("c","d"),
  otherwise="copy"
  )

recode(f,
  "A" &lt;- c("a","b"),
  "B" &lt;- c("c","d"),
  otherwise="C"
  )
 
recode(f,
  "A" &lt;- c("a","b"),
  "B" &lt;- c("c","d")
  )

DS &lt;- data.set(x=as.item(sample(1:6,20,replace=TRUE),
        labels=c( a=1,
                  b=2,
                  c=3,
                  d=4,
                  e=5,
                  f=6)))
print(DS)

DS &lt;- within(DS,{
    xf &lt;- recode(x,
                 "a" &lt;- range(min,2),
                 "b" &lt;- 3:4,
                 "c" &lt;- range(5,6)
                 )
    xn &lt;- x@.Data
    xc &lt;- recode(xn,
                 "a" &lt;- range(min,2),
                 "b" &lt;- 3:4,
                 "c" &lt;- range(5,6)
                 )
    xc &lt;- as.character(x)
    xcc &lt;- recode(xc,
                  1 &lt;- letters[1:2],
                  2 &lt;- letters[3:4],
                  3 &lt;- letters[5:6]
                  )
})

DS

DS &lt;- within(DS,{
    xf &lt;- recode(x,
                 "a" &lt;- range(min,2),
                 "b" &lt;- 3:4,
                 "c" &lt;- range(5,6)
                 )
    x1 &lt;- recode(x,
                 1 &lt;- range(1,2),
                 2 &lt;- range(3,4),
                 copy=TRUE
                 )
    xf1 &lt;- recode(x,
                 "A" &lt;- range(1,2),
                 "B" &lt;- range(3,4),
                 copy=TRUE
                 )
})
DS
codebook(DS)

DF &lt;- data.frame(x=rep(1:6,4,replace=TRUE))
DF &lt;- within(DF,{
    xf &lt;- recode(x,
                 "a" &lt;- range(min,2),
                 "b" &lt;- 3:4,
                 "c" &lt;- range(5,6)
                 )
    x1 &lt;- recode(x,
                 1 &lt;- range(1,2),
                 2 &lt;- range(3,4),
                 copy=TRUE
                 )
    xf1 &lt;- recode(x,
                 "A" &lt;- range(1,2),
                 "B" &lt;- range(3,4),
                 copy=TRUE
                 )
    xf2 &lt;- recode(x,
                 "B" &lt;- range(3,4),
                 "A" &lt;- range(1,2),
                 copy=TRUE
                 )
})
DF
codebook(DF)

</code></pre>

<hr>
<h2 id='relabel'>Change labels of factors or labelled objects</h2><span id='topic+relabel'></span><span id='topic+relabel.default'></span><span id='topic+relabel.factor'></span><span id='topic+relabel4'></span><span id='topic+relabel4+2Citem-method'></span>

<h3>Description</h3>

<p>Function <code>relabel</code> changes the labels of a factor or any object
that has a <code>names</code>, <code>labels</code>, <code>value.labels</code>, or <code>variable.labels</code> attribute.
Function <code>relabel4</code> is an (internal) generic which is called by <code>relabel</code>
to handle S4 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
relabel(x, ..., gsub = FALSE, fixed = TRUE, warn = TRUE)
## S3 method for class 'factor'
relabel(x, ..., gsub = FALSE, fixed = TRUE, warn = TRUE)


## S4 method for signature 'item'
relabel4(x, ...)
# This is an internal method, see details.
# Use relabel(x, \dots) for 'item' objects
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relabel_+3A_x">x</code></td>
<td>
<p>An object with a <code>names</code>, <code>labels</code>, <code>value.labels</code>, or <code>variable.labels</code> attribute</p>
</td></tr>
<tr><td><code id="relabel_+3A_...">...</code></td>
<td>
<p>A sequence of named arguments, all of type character</p>
</td></tr>
<tr><td><code id="relabel_+3A_gsub">gsub</code></td>
<td>
<p>a logical value; if TRUE, <code><a href="base.html#topic+gsub">gsub</a></code> is used to change the
labels of the object. That is, instead of substituting whole labels, substrings of the
labels of the object can changed.</p>
</td></tr>
<tr><td><code id="relabel_+3A_fixed">fixed</code></td>
<td>
<p>a logical value, passed to <code><a href="base.html#topic+gsub">gsub</a></code>. If TRUE,
substitutions are by fixed strings and not by regular expressions.</p>
</td></tr>
<tr><td><code id="relabel_+3A_warn">warn</code></td>
<td>
<p>a logical value; if TRUE, a warning is issues if a
a change of labels was unsuccessful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes the names or labels of <code>x</code> according to the
remaining arguments.
If <code>gsub</code> is FALSE, argument tags are the <em>old</em>
labels, the values are the new labels.
If <code>gsub</code> is TRUE, arguments are substrings of the labels
that are substituted by the argument values.
</p>
<p>Function <code>relabel</code> is S3 generic. If its first argument is an S4 object,
it calls the (internal) <code>relabel4</code> generic function.
</p>


<h3>Value</h3>

<p>The object <code>x</code> with new labels defined by the ... arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f &lt;- as.factor(rep(letters[1:4],5))
  levels(f)
  F &lt;- relabel(f,
    a="A",
    b="B",
    c="C",
    d="D"
    )
  levels(F)
  
  f &lt;- as.item(f)
  labels(f)
  F &lt;- relabel(f,
    a="A",
    b="B",
    c="C",
    d="D"
    )
  labels(F)

  # Since version 0.99.22 - the following also works:

  f &lt;- as.factor(rep(letters[1:4],5))
  levels(f)
  F &lt;- relabel(f,
    a=A,
    b=B,
    c=C,
    d=D
    )
  levels(F)
  
  f &lt;- as.item(f)
  labels(f)
  F &lt;- relabel(f,
    a=A,
    b=B,
    c=C,
    d=D
    )
  labels(F)
  
</code></pre>

<hr>
<h2 id='rename'>Change Names of a Named Object</h2><span id='topic+rename'></span>

<h3>Description</h3>

<p><code>rename</code> changes the names of a named object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename(x, ..., gsub = FALSE, fixed = TRUE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_+3A_x">x</code></td>
<td>
<p>Any named object</p>
</td></tr>
<tr><td><code id="rename_+3A_...">...</code></td>
<td>
<p>A sequence of named arguments, all of type character</p>
</td></tr>
<tr><td><code id="rename_+3A_gsub">gsub</code></td>
<td>
<p>a logical value; if TRUE, <code><a href="base.html#topic+gsub">gsub</a></code> is used to change the
row and column labels of the resulting table.
That is, instead of substituting whole names, substrings of the
names of the object can changed.
</p>
</td></tr>
<tr><td><code id="rename_+3A_fixed">fixed</code></td>
<td>
<p>a logical value, passed to <code><a href="base.html#topic+gsub">gsub</a></code>. If TRUE,
substitutions are by fixed strings and not by regular expressions.</p>
</td></tr>
<tr><td><code id="rename_+3A_warn">warn</code></td>
<td>
<p>a logical value; should a warning be issued if
those names to change are not found?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes the names of <code>x</code> according to the
remaining arguments.
If <code>gsub</code> is FALSE, argument tags are the <em>old</em>
names, the values are the new names.
If <code>gsub</code> is TRUE, arguments are substrings of the names
that are substituted by the argument values.
</p>


<h3>Value</h3>

<p>The object <code>x</code> with new names defined by the ... arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- c(a=1, b=2)
  rename(x,a="A",b="B")
  # Since version 0.99.22 - the following also works:
  rename(x,a=A,b=B)
  
  str(rename(iris,
                  Sepal.Length="Sepal_Length",
                  Sepal.Width ="Sepal_Width",
                  Petal.Length="Petal_Length",
                  Petal.Width ="Petal_Width"
                  ))
  str(rename(iris,
                  .="_"
                  ,gsub=TRUE))

  # Since version 0.99.22 - the following also works:
  str(rename(iris,
                  Sepal.Length=Sepal_Length,
                  Sepal.Width =Sepal_Width,
                  Petal.Length=Petal_Length,
                  Petal.Width =Petal_Width
                  ))
</code></pre>

<hr>
<h2 id='reorder.array'>Reorder an Array or Matrix</h2><span id='topic+reorder'></span><span id='topic+reorder.array'></span><span id='topic+reorder.matrix'></span>

<h3>Description</h3>

<p><code>reorder.array</code> reorders an array along a specified
dimension according given names, indices or results of
a function applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
reorder(x,dim=1,names=NULL,indices=NULL,FUN=mean,...)
## S3 method for class 'matrix'
reorder(x,dim=1,names=NULL,indices=NULL,FUN=mean,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder.array_+3A_x">x</code></td>
<td>
<p>An array</p>
</td></tr>
<tr><td><code id="reorder.array_+3A_dim">dim</code></td>
<td>
<p>An integer specifying the dimension along which <code>x</code> should be ordered.</p>
</td></tr>
<tr><td><code id="reorder.array_+3A_names">names</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="reorder.array_+3A_indices">indices</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="reorder.array_+3A_fun">FUN</code></td>
<td>
<p>A function that can be used in <code>apply(x,dim,FUN)</code> </p>
</td></tr>
<tr><td><code id="reorder.array_+3A_...">...</code></td>
<td>
<p>further arguments, ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
  reorder(x,dim,names)
  reorder(x,dim,indices)
  reorder(x,dim,FUN)
  </pre>
<p>The result of <code>rename(x,dim,names)</code> is <code>x</code>
reordered such that <code>dimnames(x)[[dim]]</code> is equal to
the concatenation of those elements of <code>names</code>
that are in <code>dimnames(x)[[dim]]</code> and the remaining elements
of <code>dimnames(x)[[dim]]</code>.
</p>
<p>The result of <code>rename(x,dim,indices)</code> is <code>x</code>
reordered along <code>dim</code> according to <code>indices</code>.
</p>
<p>The result of <code>rename(x,dim,FUN)</code> is <code>x</code>
reordered along <code>dim</code> according to <code>order(apply(x,dim,FUN))</code>.
</p>


<h3>Value</h3>

<p>The reordered object <code>x</code>.
</p>


<h3>See Also</h3>

<p>The default method of <code><a href="stats.html#topic+reorder.factor">reorder</a></code> in package <code>stats</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  (M &lt;- matrix(rnorm(n=25),5,5,dimnames=list(LETTERS[1:5],letters[1:5])))
  reorder(M,dim=1,names=c("E","A"))
  reorder(M,dim=2,indices=3:1)
  reorder(M,dim=1)
  reorder(M,dim=2)
</code></pre>

<hr>
<h2 id='Reshape'>Reshape data frames or data sets</h2><span id='topic+Reshape'></span>

<h3>Description</h3>

<p><code>Reshape</code> is a convenience
wrapper around <code><a href="stats.html#topic+reshape">reshape</a></code> with a somewhat simpler
syntax.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Reshape(data,...,id,within_id,drop,keep,direction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reshape_+3A_data">data</code></td>
<td>
<p>a data frame or data set to be reshaped.</p>
</td></tr>
<tr><td><code id="Reshape_+3A_...">...</code></td>
<td>

<p>Further arguments that specify the variables in
long and in wide format as well as the time variable.
The name tags of the arguments given here specify 
variable names in long format,
the arguments themselves specify the variables in wide format
(or observations in long vormat)
and the variable of the &quot;time&quot; variable.
The time variable is usually the last of these arguments.
An &quot;automatic&quot; time variable can be specified if only
a single argument in <code>...</code> is given.
</p>
</td></tr>
<tr><td><code id="Reshape_+3A_id">id</code></td>
<td>
<p>a variable name or a concatenation of variable names
(either as character strings or as unquoted symbols), that identify
individual units. Defaults to <code>"id"</code> or the id variable
specified in the <code>"reshapeLong"</code> attribute of the <code>data</code>
argument. Needed only if the data are reshaped from long to wide
format.
</p>
</td></tr>
<tr><td><code id="Reshape_+3A_within_id">within_id</code></td>
<td>
<p>an optional variable name 
(either as character string or as unquoted symbol), that identifies
individual observations on units.
Relevant only if the data are reshaped from long to wide
format.</p>
</td></tr>
<tr><td><code id="Reshape_+3A_drop">drop</code></td>
<td>
<p>a variable name or a concatenation of variable names
(either as character strings or as unquoted symbols), thast specifies
the variables to be dropped before reshaping.
</p>
</td></tr>
<tr><td><code id="Reshape_+3A_keep">keep</code></td>
<td>
<p>a variable name or a concatenation of variable names
(either as character strings or as unquoted symbols), thast specifies
the variables to be kept after reshaping (including the ones
used to define the reshaping).
</p>
</td></tr>
<tr><td><code id="Reshape_+3A_direction">direction</code></td>
<td>
<p>a character string, should be either equal &quot;long&quot;
or &quot;wide&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>example.data.wide &lt;- data.frame(
    v  = c(35,42),
    x1 = c(1.1,2.1),
    x2 = c(1.2,2.2),
    x3 = c(1.3,2.3),
    x4 = c(1.4,2.4),
    y1 = c(2.5,3.5),
    y2 = c(2.7,3.7),
    y3 = c(2.9,3.9))
example.data.wide

# The following two calls are equivalent:
example.data.long &lt;- Reshape(data=example.data.wide,
                             x=c(x1,x2,x3,x4),
                             # N.B. it is possible to
                             # specify 'empty' i.e. missing
                             # measurements
                             y=c(y1,y2,y3,),
                             t=1:4,
                             direction="long")

example.data.long &lt;- Reshape(data=example.data.wide,
                             list(
                                 x=c(x1,x2,x3,x4),
                                 # N.B. it is possible to
                                 # specify 'empty' i.e. missing
                                 # measurements
                                 y=c(y1,y2,y3,)
                             ),
                             t=1:4,
                             direction="long")

example.data.long

# Since the data frame contains an "reshapeLong" attribute
# an id variable is already specified and part of the data
# frame.
example.data.wide &lt;- Reshape(data=example.data.long,
                             x=c(x1,x2,x3,x4),
                             y=c(y1,y2,y3,),
                             t=1:4,
                             direction="wide")
example.data.wide

# Here we examine the case where no "reshapeLong" attribute
# is present:
example.data.wide &lt;- Reshape(data=example.data.long,
                             x=c(x1,x2,x3,x4),
                             y=c(y1,y2,y3,),
                             t=1:4,
                             id=v,
                             direction="wide")
example.data.wide


# Here, an "automatic" time variable is created. This works
# only if there is a single argument other than the data=
# and direction= arguments
example.data.long &lt;- Reshape(data=example.data.wide,
                             list(
                                 x=c(x1,x2,x3,x4),
                                 y=c(y1,y2,y3,)
                             ),
                             direction="long")

example.data.long

example.data.wide &lt;- Reshape(data=example.data.long,
                             list(
                                 x=c(x1,x2,x3,x4),
                                 y=c(y1,y2,y3,)
                             ),
                             direction="wide")
example.data.wide
</code></pre>

<hr>
<h2 id='retain'>Retain Objects in an Environment</h2><span id='topic+retain'></span>

<h3>Description</h3>

<p><code>retain</code> removes all objects from the environment
except those mentioned as argument.</p>


<h3>Usage</h3>

<pre><code class='language-R'>retain(..., list = character(0), envir = parent.frame(),force=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retain_+3A_...">...</code></td>
<td>
<p>names of objects to be retained, as names (unquoted)
or character strings(quoted).</p>
</td></tr>
<tr><td><code id="retain_+3A_list">list</code></td>
<td>
<p>a character vector naming the objects to be retained.</p>
</td></tr>
<tr><td><code id="retain_+3A_envir">envir</code></td>
<td>
<p>the environment from which the objects are removed
that are not to be retained.</p>
</td></tr>
<tr><td><code id="retain_+3A_force">force</code></td>
<td>
<p>logical value. As a measure of caution, this
function removes objects only from local environments,
unless <code>force</code> equals TRUE. In that case, <code>retain</code> can
also be used to clear the global environment, the user's workspace.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>local({
  foreach(x=c(a,b,c,d,e,f,g,h),x&lt;-1)
  cat("Objects before call to 'retain':\n")
  print(ls())
  retain(a)
  cat("Objects after call to 'retain':\n")
  print(ls())
})
x &lt;- 1
y &lt;- 2
retain(x)
</code></pre>

<hr>
<h2 id='reversed'>Reverse the codes of a survey item or the levels of a factor</h2><span id='topic+reversed'></span><span id='topic+reversed+2Citem.vector-method'></span><span id='topic+reversed+2Cfactor-method'></span>

<h3>Description</h3>

<p>The function <code>reversed()</code> returns a copy of its argument with codes
or levels in reverse order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reversed(x)
## S4 method for signature 'item.vector'
reversed(x)
## S4 method for signature 'factor'
reversed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reversed_+3A_x">x</code></td>
<td>
<p>An object &ndash; an &quot;item&quot; object or a &quot;data.set&quot; object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the argument of the function <code>reversed()</code> than either the
unique valid values or the labelled valid values recoded into the
reverse order.
</p>
<p>If th argument is a factor than the function returns the factor with
levels in reverse order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.set(
    x = as.item(sample(c(1:3,9),100,replace=TRUE),
                labels=c("One"=1,
                         "Two"=2,
                         "Three"=3,
                         "Missing"=9)))
df &lt;- as.data.frame(ds)
ds &lt;- within(ds,{
    xr &lt;- reversed(x)
})
codebook(ds)
df &lt;- within(df,{
    xr &lt;- reversed(x)
})
codebook(df)
</code></pre>

<hr>
<h2 id='sample-methods'>Take a Sample from a Data Frame-like Object</h2><span id='topic+sample+2Cdata.frame-method'></span><span id='topic+sample+2Cdata.set-method'></span><span id='topic+sample+2Cimporter-method'></span>

<h3>Description</h3>

<p>The methods below are convenience short-cuts to
take samples from data frames and data sets.
They result in a data frame or data set, respectively,
the rows of which are a sample of the complete
data frame/data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
sample(x, size, replace = FALSE, prob = NULL)
## S4 method for signature 'data.set'
sample(x, size, replace = FALSE, prob = NULL)
## S4 method for signature 'importer'
sample(x, size, replace = FALSE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample-methods_+3A_x">x</code></td>
<td>
<p>a data frame or data set.</p>
</td></tr>
<tr><td><code id="sample-methods_+3A_size">size</code></td>
<td>
<p>an (optional) numerical value, the sample size,
defaults to the total number of rows of <code>x</code>.</p>
</td></tr>
<tr><td><code id="sample-methods_+3A_replace">replace</code></td>
<td>
<p>a logical value, determines whether
sampling takes place with or without replacement.</p>
</td></tr>
<tr><td><code id="sample-methods_+3A_prob">prob</code></td>
<td>
<p>a vector of sampling probabities or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or data set.</p>


<h3>Examples</h3>

<pre><code class='language-R'>for(.i in 1:4)
  print(sample(iris,5))
</code></pre>

<hr>
<h2 id='Sapply'>A Dimension Preserving Variant of &quot;sapply&quot; and &quot;lapply&quot;</h2><span id='topic+Lapply'></span><span id='topic+Sapply'></span>

<h3>Description</h3>

<p><code>Sapply</code> is equivalent to <code><a href="base.html#topic+sapply">sapply</a></code>, except
that it preserves the dimension and dimension names of the
argument <code>X</code>. It also preserves the dimension of
results of the function <code>FUN</code>.
It is intended for application to results e.g.
of a call to <code><a href="base.html#topic+by">by</a></code>. <code>Lapply</code> is an analog
to <code>lapply</code> insofar as it does not try to simplify
the resulting <code>list</code> of results of <code>FUN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
Lapply(X, FUN, ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sapply_+3A_x">X</code></td>
<td>
<p>a vector or list appropriate to a call to <code>sapply</code>.</p>
</td></tr>
<tr><td><code id="Sapply_+3A_fun">FUN</code></td>
<td>
<p>a function.</p>
</td></tr>
<tr><td><code id="Sapply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="Sapply_+3A_simplify">simplify</code></td>
<td>
<p>a logical value; should the result be simplified to a vector or matrix if possible?</p>
</td></tr>
<tr><td><code id="Sapply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>logical; if <code>TRUE</code> and if <code>X</code> is character, use <code>X</code> as names for the result unless it had names already.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>FUN</code> returns a scalar, then the result has the same dimension
as <code>X</code>, otherwise the dimension of the result is enhanced relative
to <code>X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>berkeley &lt;- Aggregate(Table(Admit,Freq)~.,data=UCBAdmissions)
berktest1 &lt;- By(~Dept+Gender,
                glm(cbind(Admitted,Rejected)~1,family="binomial"),
                data=berkeley)
berktest2 &lt;- By(~Dept,
                glm(cbind(Admitted,Rejected)~Gender,family="binomial"),
                data=berkeley)

sapply(berktest1,coef)
Sapply(berktest1,coef)

sapply(berktest1,function(x)drop(coef(summary(x))))
Sapply(berktest1,function(x)drop(coef(summary(x))))

sapply(berktest2,coef)
Sapply(berktest2,coef)
sapply(berktest2,function(x)coef(summary(x)))
Sapply(berktest2,function(x)coef(summary(x)))
</code></pre>

<hr>
<h2 id='sort-methods'>Convenience Methods to Sort Data Frames and Data Sets</h2><span id='topic+sort.data.frame'></span><span id='topic+sort.data.set'></span>

<h3>Description</h3>

<p>The methods below return a sorted version of
the data frame or data set, given as first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
sort(x,decreasing=FALSE,by=NULL,na.last=NA,...)
## S3 method for class 'data.set'
sort(x,decreasing=FALSE,by=NULL,na.last=NA,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort-methods_+3A_x">x</code></td>
<td>
<p>a data frame or data set.</p>
</td></tr>
<tr><td><code id="sort-methods_+3A_decreasing">decreasing</code></td>
<td>
<p>a logical value, should sorting
be in increasing or decreasing order?</p>
</td></tr>
<tr><td><code id="sort-methods_+3A_by">by</code></td>
<td>

<p>a character name of variable names, by which to sort;
a formula giving the variables, by which to sort;
NULL, in which case, the data frame / data set
is sorted by all of its variables.
</p>
</td></tr>
<tr><td><code id="sort-methods_+3A_na.last">na.last</code></td>
<td>
<p>for controlling the treatment of 'NA's. If 'TRUE', missing
values in the data are put last; if 'FALSE', they are put
first; if 'NA', they are removed</p>
</td></tr>
<tr><td><code id="sort-methods_+3A_...">...</code></td>
<td>
<p>other arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted copy of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DF &lt;- data.frame(
        a = sample(1:2,size=20,replace=TRUE),
        b = sample(1:4,size=20,replace=TRUE))
sort(DF)
sort(DF,by=~a+b)
sort(DF,by=~b+a)
sort(DF,by=c("b","a"))
sort(DF,by=c("a","b"))
</code></pre>

<hr>
<h2 id='styles'>Formatting Styles for Coefficients, Factor Contrasts, and Summary Statistics</h2><span id='topic+coef.style'></span><span id='topic+factor.style'></span><span id='topic+setCoefTemplate'></span><span id='topic+getCoefTemplate'></span><span id='topic+getSummaryTemplate'></span><span id='topic+setSummaryTemplate'></span><span id='topic+summaryTemplate'></span>

<h3>Description</h3>

<p>Methods for setting and getting templates for formatting
model coefficients and summaries for use in <code><a href="#topic+mtable">mtable</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCoefTemplate(...)
getCoefTemplate(style)
getSummaryTemplate(x)
setSummaryTemplate(...)
summaryTemplate(x)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="styles_+3A_...">...</code></td>
<td>
<p>sevaral tagged arguments; in case of <code>setCoefTemplate</code> the
tags specify the <code>coef.style</code>s, in case of <code>setSummaryTemplate</code>
they specify model classes.
The associated values are <a href="#topic+template">template</a>s.</p>
</td></tr>
<tr><td><code id="styles_+3A_style">style</code></td>
<td>
<p>a character string with the name of a coefficient style,
if left empty, all coefficient templates are returned.  </p>
</td></tr>
<tr><td><code id="styles_+3A_x">x</code></td>
<td>
<p>a model or a name of a model class, for example <code>"lm"</code> or <code>"glm"</code>;
if left empty, all summary templates are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The style in which model coefficients are formatted by <code><a href="#topic+mtable">mtable</a></code>
is by default selected from the <code>coef.style</code> setting of <code><a href="base.html#topic+options">options</a></code>,
&quot;factory-fresh&quot; setting being <code>options(coef.style="default")</code>.
</p>
<p>The appearance of factor levels in an <code><a href="#topic+mtable">mtable</a></code>
can be influenced by the <code>factor.style</code> setting of <code><a href="base.html#topic+options">options</a></code>.
The &quot;factory-fresh&quot; setting is <code>options(factor.style="($f): ($l)")</code>,
where <code>($f)</code> stands for the factor name and <code>($l)</code> stands
for the factor level. In case of treatment contrasts, the baseline level
will also appear in an <code><a href="#topic+mtable">mtable</a></code> separated from the current
factor level by the <code>baselevel.sep</code> setting of <code><a href="base.html#topic+options">options</a></code>.
The &quot;factory-fresh&quot; setting is <code>options(baselevel.sep="-")</code>,
</p>
<p>Users may specify additional coefficient styles by a call to <code>setCoefTemplate</code>.
</p>
<p>In order to adapt the display of summary statistics of other model classes, users need to
set a template for model summaries via a call to <code>setSummaryTemplate</code>
or to define a method of the generic function <code>summaryTemplate</code>.
</p>

<hr>
<h2 id='Substitute'>Substitutions in Language Objects</h2><span id='topic+Substitute'></span>

<h3>Description</h3>

<p><code>Substitute</code> differs from <code><a href="base.html#topic+substitute">substitute</a></code>
in so far as its first argument can be a variable that
contains an object of mode &quot;language&quot;. In that case,
substitutions take place inside this object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Substitute(lang,with)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Substitute_+3A_lang">lang</code></td>
<td>
<p>any object, unevaluated expression, or
unevaluated language construct, such as a sequence
of calls inside braces
</p>
</td></tr>
<tr><td><code id="Substitute_+3A_with">with</code></td>
<td>

<p>a named list, environment, data frame or data set.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function body is just
<code>do.call("substitute",list(lang,with))</code>.
</p>


<h3>Value</h3>

<p>An object of storage mode &quot;language&quot; or &quot;symbol&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lang &lt;- quote(sin(x)+z)
substitute(lang,list(x=1,z=2))
Substitute(lang,list(x=1,z=2))
</code></pre>

<hr>
<h2 id='Table'>One-Dimensional Table of Frequences and/or Percentages</h2><span id='topic+Table'></span><span id='topic+Table+2Catomic-method'></span><span id='topic+Table+2Cfactor-method'></span><span id='topic+Table+2Citem.vector-method'></span>

<h3>Description</h3>

<p><code>Table</code> is a generic function that
produces a table of counts or weighted counts
and/or the corresponding percentages of an atomic vector,
factor or <code>"item.vector"</code> object.
This function is intended for use with
<code><a href="#topic+Aggregate">Aggregate</a></code> or <code><a href="#topic+genTable">genTable</a></code>.
The <code>"item.vector"</code> method is the workhorse
of <code><a href="#topic+codebook">codebook</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'atomic'
Table(x,weights=NULL,counts=TRUE,percentage=FALSE,...)
## S4 method for signature 'factor'
Table(x,weights=NULL,counts=TRUE,percentage=FALSE,...)
## S4 method for signature 'item.vector'
Table(x,weights=NULL,counts=TRUE,percentage=(style=="codebook"),
              style=c("table","codebook","nolabels"),
              include.missings=(style=="codebook"),
              missing.marker=if(style=="codebook") "M" else "*",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Table_+3A_x">x</code></td>
<td>
<p>an atomic vector, factor or <code>"item.vector"</code> object</p>
</td></tr>
<tr><td><code id="Table_+3A_counts">counts</code></td>
<td>
<p>logical value, should the table contain counts?</p>
</td></tr>
<tr><td><code id="Table_+3A_percentage">percentage</code></td>
<td>
<p>logical value, should the table contain percentages?
Either the <code>counts</code> or the <code>percentage</code> arguments or both
should be <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="Table_+3A_style">style</code></td>
<td>
<p>character string, the style of the names or rownames of the table.</p>
</td></tr>
<tr><td><code id="Table_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="Table_+3A_include.missings">include.missings</code></td>
<td>
<p>a logical value; should missing values included into the table?</p>
</td></tr>
<tr><td><code id="Table_+3A_missing.marker">missing.marker</code></td>
<td>
<p>a character string, used to mark missing values
in the table (row)names.</p>
</td></tr>
<tr><td><code id="Table_+3A_...">...</code></td>
<td>
<p>other, currently ignored arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The atomic vector and factor methods return either a vector
of counts or vector of percentages or a matrix of counts and percentages.
The same applies to the <code>"item.vector"</code> vector method unless
<code>include.missing=TRUE</code> and <code>percentage=TRUE</code>,
in which case total percentages and percentages of valid values
are given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  with(as.data.frame(UCBAdmissions),Table(Admit,Freq))
  Aggregate(Table(Admit,Freq)~.,data=UCBAdmissions)

  A &lt;- sample(c(1:5,9),size=100,replace=TRUE)
  labels(A) &lt;- c(a=1,b=2,c=3,d=4,e=5,dk=9)
  missing.values(A) &lt;- 9
  Table(A,percentage=TRUE)
</code></pre>

<hr>
<h2 id='tibbles'>Interface to Packages 'tibble' and 'haven'</h2><span id='topic+as_tibble.data.set'></span><span id='topic+as.item+2Clabelled-method'></span><span id='topic+as.item+2Chaven_labelled-method'></span><span id='topic+as.item+2Chaven_labelled_spss-method'></span><span id='topic+as_haven'></span><span id='topic+as_haven+2Cdata.set-method'></span><span id='topic+as_haven+2Citem.vector-method'></span><span id='topic+as.data.set+2Ctbl_df-method'></span>

<h3>Description</h3>

<p>A <code>as_tibble</code> method (<code>as_table.data.set</code>) allows to transform <code>"data.set"</code> objects
into objects of class <code>"tbl_df"</code> as defined by the package
&quot;tibble&quot;.
</p>
<p><code>as.item</code> methods for objects of classes <code>"haven_labelled"</code>
and <code>"have_labelled_spss"</code> allow to transform a &quot;tibble&quot; imported
using <code>read_dta</code>, <code>read_spss</code>, etc. from the package &quot;haven&quot;
into an object of class <code>"data.set"</code>.
</p>
<p><code>as_haven</code> can be used to transform <code>"data.set"</code> objects
into objects of class <code>"tbl_df"</code> with that additional information
that objects imported using the &quot;haven&quot; package usually have, i.e.
variable labels and value labels (as the <code>"label"</code> and
<code>"labels"</code> attributes of the columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tibble.data.set(x,...)
## S4 method for signature 'haven_labelled'
as.item(x,...)
## S4 method for signature 'haven_labelled_spss'
as.item(x,...)
as_haven(x,...)
## S4 method for signature 'data.set'
as_haven(x,user_na=FALSE,...)
## S4 method for signature 'item.vector'
as_haven(x,user_na=FALSE,...)
## S4 method for signature 'tbl_df'
as.data.set(x,row.names=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tibbles_+3A_x">x</code></td>
<td>
<p>for <code>as_tibble.data.set</code> and <code>as_haven</code>, an object
of class <code>"data.set"</code>; for <code>as.item</code>, an object of class
<code>"haven_labelled"</code> or <code>"haven_labelled_spss"</code>;
an object of class <code>"tbl_df"</code> for <code>as.data.set</code>.
</p>
</td></tr>
<tr><td><code id="tibbles_+3A_user_na">user_na</code></td>
<td>
<p>logical; if <code>TRUE</code> then the resulting vectors
have an <code>"na_values"</code> and/or <code>"na_range"</code> attribute.</p>
</td></tr>
<tr><td><code id="tibbles_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or an optional character vector of row names.</p>
</td></tr>
<tr><td><code id="tibbles_+3A_...">...</code></td>
<td>
<p>further arguments, passed through to other the the
<code>as_tibble</code> method for lists, or ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as_tibble.data.set</code> and the <code>"data.set"</code>-method of
<code>as_haven</code> return a &quot;tibble&quot;. The <code>"item.vector"</code>-method
(which is for internal use only) returns a vector with S3 class either
<code>"haven_labelled"</code> or <code>"haven_labelled_spss"</code>. 
</p>

<hr>
<h2 id='to.data.frame'>Convert an Array into a Data Frame</h2><span id='topic+to.data.frame'></span>

<h3>Description</h3>

<p><code>to.data.frame</code> converts an array into a data frame, in such a way
that a chosen dimensional extent forms variables in the data frame.
The elements of the array must be either atomic, data frames
with matching variables, or coercable into such data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.data.frame(X,as.vars=1,name="Freq")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to.data.frame_+3A_x">X</code></td>
<td>
<p>an array.</p>
</td></tr>
<tr><td><code id="to.data.frame_+3A_as.vars">as.vars</code></td>
<td>
<p>a numeric value or a character string.
If it is a numeric value then it indicates the dimensional extend
which defines the variables. If it is a character string then it is
matched against the names of the dimenstional extents. This is
applicable e.g. if <code>X</code> is a contingency table and the
dimensional extents are named after the cross-classified factors.
Takes effect only if <code>X</code> is 
an atomic array. If <code>as.vars</code> equals zero, a new variable
is created that contains the values of the array, that is,
<code>to.data.frame</code> acts on the array <code>X</code>
like <code>as.data.frame(as.table(X))</code>
</p>
</td></tr>
<tr><td><code id="to.data.frame_+3A_name">name</code></td>
<td>
<p>a character string; the name of the variable
created if <code>X</code> is an atomic array and <code>as.vars</code> equals zero.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>berkeley &lt;- Aggregate(Table(Admit,Freq)~.,data=UCBAdmissions)
berktest1 &lt;- By(~Dept+Gender,
                glm(cbind(Admitted,Rejected)~1,family="binomial"),
                data=berkeley)
berktest2 &lt;- By(~Dept,
                glm(cbind(Admitted,Rejected)~Gender,family="binomial"),
                data=berkeley)
Stest1 &lt;- Lapply(berktest2,function(x)predict(x,,se.fit=TRUE)[c("fit","se.fit")])
Stest2 &lt;- Sapply(berktest2,function(x)coef(summary(x)))
Stest2.1 &lt;- Lapply(berktest1,function(x)predict(x,,se.fit=TRUE)[c("fit","se.fit")])
to.data.frame(Stest1)
to.data.frame(Stest2,as.vars=2)
to.data.frame(Stest2.1)
# Recasting a contingency table
to.data.frame(UCBAdmissions,as.vars="Admit")
</code></pre>

<hr>
<h2 id='toLatex'>Additional Methods for LaTeX Representations for R objects</h2><span id='topic+toLatex.default'></span><span id='topic+toLatex.ftable'></span><span id='topic+toLatex.matrix'></span><span id='topic+toLatex.data.frame'></span><span id='topic+toLatex.ftable_matrix'></span>

<h3>Description</h3>

<p>Methods for the generic function <code><a href="utils.html#topic+toLatex">toLatex</a></code> of package &ldquo;<a href="utils.html#topic+utils">utils</a>&rdquo;
are provided for generating LaTeX representations
of matrices and flat contingency tables (see <code><a href="stats.html#topic+ftable">ftable</a></code>). Also a default method is defined
that coerces its first argument into a matrix and applies
the matrix method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
toLatex(object,...)

## S3 method for class 'matrix'
toLatex(object,
    show.titles=TRUE,
    show.vars=FALSE,
    show.xvar=show.vars,
    show.yvar=show.vars,
    digits=if(is.table(object)) 0 else getOption("digits"),
    format="f",
    useDcolumn=getOption("useDcolumn",TRUE),
    colspec=if(useDcolumn)
                paste("D{.}{",LaTeXdec,"}{",ddigits,"}",sep="")
             else "r",
    LaTeXdec=".",
    ddigits=digits,
    useBooktabs=getOption("useBooktabs",TRUE),
    toprule=if(useBooktabs) "\\toprule" else "\\hline\\hline",
    midrule=if(useBooktabs) "\\midrule" else "\\hline",
    cmidrule=if(useBooktabs) "\\cmidrule" else "\\cline",
    bottomrule=if(useBooktabs) "\\bottomrule" else "\\hline\\hline",
    toLatex.escape.tex=getOption("toLatex.escape.tex",FALSE),
    ...)


## S3 method for class 'data.frame'
toLatex(object,
    digits=getOption("digits"),
    format="f",
    useDcolumn=getOption("useDcolumn",TRUE),
    numeric.colspec=if(useDcolumn)
                       paste("D{.}{",LaTeXdec,"}{",ddigits,"}",sep="")
                    else "r",
    factor.colspec="l",
    LaTeXdec=".",
    ddigits=digits,
    useBooktabs=getOption("useBooktabs",TRUE),
    toprule=if(useBooktabs) "\\toprule" else "\\hline\\hline",
    midrule=if(useBooktabs) "\\midrule" else "\\hline",
    cmidrule=if(useBooktabs) "\\cmidrule" else "\\cline",
    bottomrule=if(useBooktabs) "\\bottomrule" else "\\hline\\hline",
    row.names=is.character(attr(object,"row.names")),
    NAas="",
    toLatex.escape.tex=getOption("toLatex.escape.tex",FALSE),
    ...)

## S3 method for class 'ftable'
toLatex(object,
    show.titles=TRUE,
    digits=if(is.integer(object)) 0 else getOption("digits"),
    format=if(is.integer(object)) "d" else "f",
    useDcolumn=getOption("useDcolumn",TRUE),
    colspec=if(useDcolumn)
                paste("D{.}{",LaTeXdec,"}{",ddigits,"}",sep="")
             else "r",
    LaTeXdec=".",
    ddigits=digits,
    useBooktabs=getOption("useBooktabs",TRUE),
    toprule=if(useBooktabs) "\\toprule" else "\\hline\\hline",
    midrule=if(useBooktabs) "\\midrule" else "\\hline\n",
    cmidrule=if(useBooktabs) "\\cmidrule" else "\\cline",
    bottomrule=if(useBooktabs) "\\bottomrule" else "\\hline\\hline",
    extrarowsep = NULL,
    toLatex.escape.tex=getOption("toLatex.escape.tex",FALSE),
    fold.leaders=FALSE,
    ...)

## S3 method for class 'ftable_matrix'
toLatex(object,
    show.titles=TRUE,
    digits=getOption("digits"),
    format="f",
    useDcolumn=getOption("useDcolumn",TRUE),
    colspec=if(useDcolumn)
                paste("D{.}{",LaTeXdec,"}{",ddigits,"}",sep="")
             else "r",
    LaTeXdec=".",
    ddigits=digits,
    useBooktabs=getOption("useBooktabs",TRUE),
    toprule=if(useBooktabs) "\\toprule" else "\\hline\\hline",
    midrule=if(useBooktabs) "\\midrule" else "\\hline",
    cmidrule=if(useBooktabs) "\\cmidrule" else "\\cline",
    bottomrule=if(useBooktabs) "\\bottomrule" else "\\hline\\hline",
    compact=FALSE,
    varontop,varinfront,
    groupsep="3pt",
    grouprule=midrule,
    toLatex.escape.tex=getOption("toLatex.escape.tex",FALSE),
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toLatex_+3A_object">object</code></td>
<td>
<p>an <code><a href="stats.html#topic+ftable">ftable</a></code>, a matrix or an object coercable into 
a matrix.  </p>
</td></tr>
<tr><td><code id="toLatex_+3A_show.titles">show.titles</code></td>
<td>
<p>logical, should variable names (in case of the 
<code>ftable</code> and <code>table</code> methods)
or row and column names (in case of the <code>matrix</code> method) be appear
in the <code>LaTeX</code> code? </p>
</td></tr>
<tr><td><code id="toLatex_+3A_show.vars">show.vars</code>, <code id="toLatex_+3A_show.xvar">show.xvar</code>, <code id="toLatex_+3A_show.yvar">show.yvar</code></td>
<td>
<p>logical, should the names of the dimnames of <code>object</code>
be shown in the margins of the LaTeX tabular? Such names usually represent the
row and/or column variables of a two-dimensional <code><a href="base.html#topic+table">table</a></code>.
</p>
</td></tr>
<tr><td><code id="toLatex_+3A_digits">digits</code></td>
<td>
<p>number of significant digits.
</p>
</td></tr>
<tr><td><code id="toLatex_+3A_format">format</code></td>
<td>
<p>character containing a format specifier, see <code><a href="base.html#topic+format">format</a></code>. </p>
</td></tr>
<tr><td><code id="toLatex_+3A_usedcolumn">useDcolumn</code></td>
<td>
<p>logical, should the facilities of the <code>dcolumn</code> LaTeX package be used?
Note that, if TRUE, you will need to include <code>\usepackage{dcolumn}</code>
in the preamble of your LaTeX document.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_colspec">colspec</code></td>
<td>
<p>character, LaTeX table column format specifyer(s).</p>
</td></tr>
<tr><td><code id="toLatex_+3A_numeric.colspec">numeric.colspec</code></td>
<td>
<p>character, LaTeX table column format
specifyer(s) for numeric vectors in the data frame.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_factor.colspec">factor.colspec</code></td>
<td>
<p>character, LaTeX table column format
specifyer(s) for factors in the data frame.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_latexdec">LaTeXdec</code></td>
<td>
<p>character, the decimal point in the final LaTeX output.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_ddigits">ddigits</code></td>
<td>
<p>integer, digits after the decimal point.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_usebooktabs">useBooktabs</code></td>
<td>
<p>logical, should the facilities of the <code>booktabs</code> LaTeX package be used?
Note that, if TRUE, you will need to include <code>\usepackage{booktabs}</code>
in the preamble of your LaTeX document.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_toprule">toprule</code></td>
<td>
<p>character string, TeX code that determines the appearance of the top border of the LaTeX <code>tabular</code> environment.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_midrule">midrule</code></td>
<td>
<p>character string, TeX code that determines how  coefficients and summary statistics are
separated in the LaTeX <code>tabular</code> environment.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_cmidrule">cmidrule</code></td>
<td>
<p>character string, TeX code that determines the appearance of rules under section headings.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_bottomrule">bottomrule</code></td>
<td>
<p>character string, TeX code that determines the appearance of the bottom border of the LaTeX <code>tabular</code> environment.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_extrarowsep">extrarowsep</code></td>
<td>
<p>character string, extra code to be inserted between the column titles and the
table body produced by <code>toLatex</code>. </p>
</td></tr>
<tr><td><code id="toLatex_+3A_compact">compact</code></td>
<td>
<p>logical, if <code>TRUE</code>, extra column space between sub-tables 
is suppressed. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="toLatex_+3A_varontop">varontop</code></td>
<td>
<p>logical, whether names of column variables should appear on top of factor levels</p>
</td></tr>
<tr><td><code id="toLatex_+3A_varinfront">varinfront</code></td>
<td>
<p>logical, whether names of row variables should appear in front of factor levels</p>
</td></tr>
<tr><td><code id="toLatex_+3A_groupsep">groupsep</code></td>
<td>
<p>character string, containing a TeX length; extra 
vertical space inserted between sub-tables, unless <code>compact</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_grouprule">grouprule</code></td>
<td>
<p>character string, TeX code that determines how
sub-table headings are embellished.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_row.names">row.names</code></td>
<td>
<p>logical, whether row names should be included in
exported LaTeX code.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_naas">NAas</code></td>
<td>
<p>character string, how missing values should be represented.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_tolatex.escape.tex">toLatex.escape.tex</code></td>
<td>
<p>logical, should symbols &quot;$&quot;, &quot;_&quot;, and &quot;^&quot; be
escaped with backslashes?</p>
</td></tr>
<tr><td><code id="toLatex_+3A_fold.leaders">fold.leaders</code></td>
<td>
<p>logical, if <code>TRUE</code>, factor levels of row
variables are not distributed into different columns, but
'folded' into a single column.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_...">...</code></td>
<td>
<p>further argument, currently ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>toLatex(diag(5))

toLatex(ftable(UCBAdmissions))

toLatex(rbind(
  ftable(margin.table(UCBAdmissions,c(2,1))),
  ftable(margin.table(UCBAdmissions,c(3,1)))
))
</code></pre>

<hr>
<h2 id='trim_labels'>Trim Codes from the Labels of an Item</h2><span id='topic+trim_labels'></span><span id='topic+trim_labels+2Citem.vector-method'></span><span id='topic+trim_labels+2Cdata.set-method'></span>

<h3>Description</h3>

<p>Occasionally, labels of codes in a survey data sets (e.g. from the
2016 American National Election Study) include a
character representation of the codes being labelled. While there may
be technical reasons for this, it is often inconvenient (e.g. if one
wants to reorder the labelled codes). The function <code>trim_labels</code>
trims the code representations (if they are present.) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_labels(x,...)
## S4 method for signature 'item.vector'
trim_labels(x,...)
## S4 method for signature 'data.set'
trim_labels(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_labels_+3A_x">x</code></td>
<td>
<p>An object &ndash; an &quot;item&quot; object or a &quot;data.set&quot; object</p>
</td></tr>
<tr><td><code id="trim_labels_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;data.set&quot; method applies the &quot;item.vector&quot; method to all the
labelled items in the data set.
</p>
<p>The &quot;item.vector&quot; returns a copy of its argument with modified labels,
where a label such as &quot;1. First alternative&quot; is changed into &quot;First alternative&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.item(sample(1:3,10,replace=TRUE),
             labels=c("1. One"=1,
                      "2. Two"=2,
                      "2. Three"=3))
y &lt;- as.item(sample(1:2,10,replace=TRUE),
             labels=c("1. First category"=1,
                      "2. Second category"=2))
ds &lt;- data.set(x,y)
x &lt;- trim_labels(x)
codebook(x)
ds &lt;- trim_labels(ds)
codebook(ds)
</code></pre>

<hr>
<h2 id='Utility+20classes'>Named Lists, Lists of Items, and Atomic Vectors</h2><span id='topic+named.list'></span><span id='topic+item.list'></span><span id='topic+named.list-class'></span><span id='topic+item.list-class'></span><span id='topic+initialize+2Citem.list-method'></span><span id='topic+initialize+2Cnamed.list-method'></span><span id='topic+coerce+2Cdata.set+2Cnamed.list-method'></span><span id='topic+show+2Cnamed.list-method'></span><span id='topic+atomic-class'></span><span id='topic+double-class'></span>

<h3>Description</h3>

<p>The classes &quot;named.list&quot; and &quot;item.list&quot; are merely some
'helper classes' for the construction of the classes &quot;data.set&quot;
and &quot;importer&quot;.
</p>
<p>Class &quot;named.list&quot; extends the basic class &quot;list&quot; by an additional
slot &quot;names&quot;. Its <code>initialize</code> method assures that the names
of the list are unique.
</p>
<p>Class &quot;item.list&quot; extends the class &quot;named.list&quot;, but does not
add any slots. From &quot;named.list&quot; it differs only by the 
<code>initialize</code> method, which calls that for &quot;named.list&quot;
and makes sure that all elements of the list belong to 
class &quot;<a href="#topic+item">item</a>&quot;.
</p>
<p>Classes &quot;atomic&quot; and &quot;double&quot; are merely used for
method selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new("named.list",a=1,b=2)

# This should generate an error, since the names
# are not unique.
try(new("named.list",a=1,a=2))

# Another error, one name is missing.
try(new("named.list",a=1,2))

# Also an error, the resulting list would be unnamed.
try(new("named.list",1,2))


new("item.list",a=1,b=2)

# Also an error: "item.list"s are "named.lists",
# and here the names would be non-unique.
try(new("item.list",a=1,a=2))
</code></pre>

<hr>
<h2 id='value.filter'>Value Filters</h2><span id='topic+value.filter'></span><span id='topic+value.filter-class'></span><span id='topic+value.filter+2CNULL-method'></span><span id='topic+value.filter+2Citem-method'></span><span id='topic+missing.values-class'></span><span id='topic+valid.values-class'></span><span id='topic+valid.range-class'></span><span id='topic+missing.values'></span><span id='topic+missing.values+2CNULL-method'></span><span id='topic+missing.values+2Citem.vector-method'></span><span id='topic+missing.values+3C-'></span><span id='topic+missing.values+3C-+2CANY+2CNULL-method'></span><span id='topic+missing.values+3C-+2CANY+2Catomic-method'></span><span id='topic+missing.values+3C-+2CANY+2Clist-method'></span><span id='topic+missing.values+3C-+2Citem+2CNULL-method'></span><span id='topic+missing.values+3C-+2Citem+2CANY-method'></span><span id='topic+missing.values+3C-+2Citem+2Cmissing.values-method'></span><span id='topic+missing.values+3C-+2Catomic+2Cmissing.values-method'></span><span id='topic+valid.values'></span><span id='topic+valid.values+2CNULL-method'></span><span id='topic+valid.values+2Citem.vector-method'></span><span id='topic+valid.values+3C-'></span><span id='topic+valid.values+3C-+2CANY+2CNULL-method'></span><span id='topic+valid.values+3C-+2CANY+2Catomic-method'></span><span id='topic+valid.values+3C-+2Citem+2Cvalid.values-method'></span><span id='topic+valid.values+3C-+2Catomic+2Cvalid.values-method'></span><span id='topic+valid.range'></span><span id='topic+valid.range+2CNULL-method'></span><span id='topic+valid.range+2Citem.vector-method'></span><span id='topic+valid.range+3C-'></span><span id='topic+valid.range+3C-+2CANY+2CNULL-method'></span><span id='topic+valid.range+3C-+2CANY+2Catomic-method'></span><span id='topic+valid.range+3C-+2Citem+2Cvalid.range-method'></span><span id='topic+valid.range+3C-+2Catomic+2Cvalid.range-method'></span><span id='topic+format+2Cvalid.values-method'></span><span id='topic+format+2Cvalid.range-method'></span><span id='topic+format+2Cmissing.values-method'></span><span id='topic+show+2Cvalue.filter-method'></span><span id='topic+coerce+2Catomic+2Cvalid.values-method'></span><span id='topic+coerce+2Catomic+2Cvalid.range-method'></span><span id='topic+coerce+2Catomic+2Cmissing.values-method'></span><span id='topic+coerce+2Clist+2Cmissing.values-method'></span><span id='topic+Arith+2Cvalid.values+2Cvalid.values-method'></span><span id='topic+Arith+2Cmissing.values+2Cmissing.values-method'></span><span id='topic+Arith+2Cvalid.range+2Cvalid.range-method'></span><span id='topic+Arith+2Cvalue.filter+2Cvector-method'></span><span id='topic+is.valid'></span><span id='topic+is.missing'></span><span id='topic+is.missing+2Citem.vector-method'></span><span id='topic+is.missing+2CNULL-method'></span><span id='topic+is.missing+2Catomic-method'></span><span id='topic+is.missing+2Cfactor-method'></span><span id='topic+include.missings'></span><span id='topic+include.missings+2Citem-method'></span><span id='topic+nvalid'></span>

<h3>Description</h3>

<p>Value filters, that is objects that inherit from class &quot;value.filter&quot;,
are a mechanism to distinguish between valid codes of a survey
item and codes that are considered to be missing, such as
the codes for answers like &quot;don't know&quot; or &quot;answer refused&quot;.
</p>
<p>Value filters are optional slot values of &quot;item&quot; objects.
They determine which codes of &quot;item&quot; objects are
replaced by <code>NA</code> when they are coerced into
a vector or a factor.
</p>
<p>There are three (sub)classes of value filters:
&quot;missing.values&quot;, which specify individual
missing values and/or a range of missing values;
&quot;valid.values&quot;, which specify individual
valid values (that is, all other values of the
item are considered as missing);
&quot;valid.range&quot;, which specify a range of
valid values (that is, all values outside the range
are considered as missing).
Value filters of class &quot;missing.values&quot; correspond
to missing-values declarations in SPSS files,
imported by <code><a href="#topic+spss.fixed.file">spss.fixed.file</a></code>,
<code><a href="#topic+spss.portable.file">spss.portable.file</a></code>, or
<code><a href="#topic+spss.system.file">spss.system.file</a></code>.
</p>
<p>Value filters also can be updated using the  <code>+</code>
and <code>-</code> operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value.filter(x)

missing.values(x)
missing.values(x)&lt;-value

valid.values(x)
valid.values(x)&lt;-value

valid.range(x)
valid.range(x)&lt;-value

is.valid(x)
nvalid(x)
is.missing(x)
include.missings(x,mark="*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value.filter_+3A_x">x</code>, <code id="value.filter_+3A_value">value</code></td>
<td>
<p>objects of the appropriate class.</p>
</td></tr>
<tr><td><code id="value.filter_+3A_mark">mark</code></td>
<td>
<p>a character string, used to pasted
to value labels of <code>x</code> (if present).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>value.filter(x)</code>, <code>missing.values(x)</code>, <code>valid.values(x)</code>, and <code>valid.range(x)</code>,
return the value filter associated with <code>x</code>, an
object of class &quot;value.filter&quot;, that is, of class
&quot;missing.values&quot;, &quot;valid.values&quot;, or &quot;valid.range&quot;, respectively.
</p>
<p><code>is.missing(x)</code> returns a logical vector indicating for
each element of <code>x</code> whether it is a missing value or not.
<code>is.valid(x)</code> returns a logical vector indicating for
each element of <code>x</code> whether it is a valid value or not.
<code>nvalid(x)</code> returns the number of elements of <code>x</code>
that are valid.
</p>
<p>For convenience, <code>is.missing(x)</code> and <code>is.valid(x)</code> also work
for atomic vectors and factors, where they are equivalent to
<code>is.na(x)</code> and <code>!is.na(x)</code>. For atomic vectors and factors,
<code>nvalid(x)</code> returns the number of elements of <code>x</code> for
which <code>!is.na(x)</code> is TRUE.
</p>
<p><code>include.missings(x,...)</code> returns a copy of <code>x</code>
that has all values declared as valid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep(c(1:4,8,9),2,length=60)
labels(x) &lt;- c(
    a=1,
    b=2,
    c=3,
    d=4,
    dk=8,
    refused=9
    )
missing.values(x) &lt;- 9
missing.values(x)
missing.values(x) &lt;- missing.values(x) + 8
missing.values(x)
missing.values(x) &lt;- NULL
missing.values(x)
missing.values(x) &lt;- list(range=c(8,Inf))
missing.values(x)
valid.values(x)
print(x)
is.missing(x)
is.valid(x)
as.factor(x)
as.factor(include.missings(x))
as.integer(x)
as.integer(include.missings(x))
</code></pre>

<hr>
<h2 id='view'>A Generic Viewing Function</h2><span id='topic+view'></span><span id='topic+viewPrep'></span><span id='topic+viewPrep.default'></span><span id='topic+viewPrep.data.set'></span><span id='topic+viewPrep.data.frame'></span><span id='topic+viewPrep.descriptions'></span><span id='topic+viewPrep.codeplan'></span><span id='topic+viewPrep.importer'></span>

<h3>Description</h3>

<p>The function <code>view</code> provides generic interface to the non-generic
function <code>View</code>.
</p>
<p>In contrast to the implementation of <code>View</code> provided by either
basic <em>R</em> or <em>RStudio</em>, this function can be extended to
handle new kinds of objects by defining <code>viewPrep</code> methods for
them. Further, <code>view</code> can be adapted to other GUIs by specifying
the <code>"vfunc"</code> option or the <code>vfunc=</code> optional argument.
</p>
<p>Internally, <code>view</code> usues the generic function <code>viewPrep</code>
to prepare data so it can be passed on to the (non-generic) function
<code>View</code> or (optionally) a different graphical user interface
function that can be used to display matrix- or data frame-like
objects.  
</p>
<p>The <code>vfunc</code> argument determines how the result of <code>viewPrep</code>
is displayed. Its default is the function <code>View</code>, but an
alternative is <code><a href="#topic+view_html">view_html</a></code> which creates and displays an HTML grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view(x,
     title=deparse(substitute(x)),
     vfunc=getOption("vfunc","View"),
     ...)

# The internal generic, not intended to be used by the end-user.
viewPrep(x,title,...)
## S3 method for class 'data.set'
viewPrep(x,title,...)
## S3 method for class 'data.frame'
viewPrep(x,title,...)
## S3 method for class 'descriptions'
viewPrep(x,title,...)
## S3 method for class 'codeplan'
viewPrep(x,title,compact=FALSE,...)
## S3 method for class 'importer'
viewPrep(x,title,compact=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_+3A_x">x</code></td>
<td>
<p>an object, e.g. a data frame, data.set, or importer.
</p>
</td></tr>
<tr><td><code id="view_+3A_title">title</code></td>
<td>
<p>an optional character string; shown as the title of the
display.</p>
</td></tr>
<tr><td><code id="view_+3A_vfunc">vfunc</code></td>
<td>
<p>a character string; a name of a GUI function to call
with the results of <code>viewPrep()</code></p>
</td></tr>
<tr><td><code id="view_+3A_compact">compact</code></td>
<td>
<p>a logical value; should the codeplan be shown in a
compact form - one line per variable - or in a more expanive form -
one line per labelled value?</p>
</td></tr>
<tr><td><code id="view_+3A_...">...</code></td>
<td>
<p>further arguments; <code>view()</code> passes them on to
<code>viewPrep</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    example(data.set)
    view(Data)
    view(description(Data))
    view(codeplan(Data))
    # Note that this file is *not* included in the package
    # and has to be obtained from GESIS in order to run the 
    # following
    ZA7500sav &lt;- spss.file("ZA7500_v2-0-0.sav")
    view(ZA7500sav)

## End(Not run)
</code></pre>

<hr>
<h2 id='view_html'>HTML Output for 'view.</h2><span id='topic+view_html'></span>

<h3>Description</h3>

<p>An alternative to 'View' for use with 'view'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_html(x,title=deparse(substitute(x)),output,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_html_+3A_x">x</code></td>
<td>
<p>the result of <code>viewPrep</code>, a matrix of character strings.
</p>
</td></tr>
<tr><td><code id="view_html_+3A_title">title</code></td>
<td>
<p>an optional character string; shown as the title of the
display.</p>
</td></tr>
<tr><td><code id="view_html_+3A_output">output</code></td>
<td>
<p>a function or the name of a function. It determines how
where the HTML code is directed to.
</p>
<p>If the working environment is RStudio, the default value is
<code>"file.show"</code>. In other interactive environments it is
<code>"browser"</code>. In non-interactive sessions it is 
<code>"stdout"</code>.
</p>
<p>If <code>output</code> equals <code>"browser"</code> the generated HTML code
is shown using <code><a href="utils.html#topic+browseURL">browseURL</a></code>. If <code>output</code>
equals <code>"stdout"</code> the HTML code is written to the console
output window. If <code>output</code> equals <code>"file.show"</code>, the
function <code>file.show</code> is used.
</p>
<p>If <code>view_html</code> is called within a <em>Jupyter</em> session,
the HTML code created is envelopped in a pair of <code>&lt;div&gt;</code> tags
and included into the Jupyter output.</p>
</td></tr>
<tr><td><code id="view_html_+3A_...">...</code></td>
<td>
<p>other arguments; ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    example(data.set)
    view(Data,vfunc=view_html)

## End(Not run)
</code></pre>

<hr>
<h2 id='wild.codes'>
Table of frequencies for unlabelled codes
</h2><span id='topic+wild.codes'></span><span id='topic+wild.codes+2Citem-method'></span>

<h3>Description</h3>

<p>The function <code>wild.codes</code> creates a table of frequencies of those codes
of an item that do not have labelled attached to them. This way, it helps to identify
coding errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wild.codes(x)
## S4 method for signature 'item'
wild.codes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wild.codes_+3A_x">x</code></td>
<td>
<p>an object of class &quot;item&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of frequencies (i.e. an array of class &quot;table&quot;)
</p>

<hr>
<h2 id='within-operators'>Operators to abbreviate use of &quot;with&quot; and &quot;within&quot;</h2><span id='topic+Within'></span><span id='topic+Within.data.frame'></span><span id='topic++25+24+25'></span><span id='topic++25+24+24+25'></span>

<h3>Description</h3>

<p>The operators <code>%$%</code> and <code>%$$%</code> provide
abbrevitions for calls to <code>with()</code> and <code>within()</code>
respectively.
The function <code>Within()</code> is a variant of <code>with()</code> were
the resulting data frame contains any newly created variables in the
order in which they are created (and not in the reverse order).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data %$% expr
data %$$% expr
Within(data,expr,...)
## S3 method for class 'data.frame'
Within(data,expr,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="within-operators_+3A_data">data</code></td>
<td>
<p>a data frame or similar object, see <code><a href="base.html#topic+with">with</a></code> and <code><a href="base.html#topic+within">within</a></code></p>
</td></tr>
<tr><td><code id="within-operators_+3A_expr">expr</code></td>
<td>
<p>a single or compound expression (i.e. several expressions
enclosed in curly braces), see <code><a href="base.html#topic+with">with</a></code> and
<code><a href="base.html#topic+within">within</a></code></p>
</td></tr>
<tr><td><code id="within-operators_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+with">with</a></code> and <code><a href="base.html#topic+within">within</a></code> in package &quot;base&quot;.</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(a = 1:7,
                 b = 7:1)

df

df &lt;- within(df,{
  ab &lt;- a + b
  a2b2 &lt;- a^2 + b^2
})
df

df &lt;- data.frame(a = 1:7,
                 b = 7:1)
df &lt;- Within(df,{
  ab &lt;- a + b
  a2b2 &lt;- a^2 + b^2
})
df


df &lt;- data.frame(a = 1:7,
                 b = 7:1)
df

ds &lt;- as.data.set(df)
ds

df %$$% {
  ab &lt;- a + b
  a2b2 &lt;- a^2 + b^2
}
df

ds %$$% {
  ab &lt;- a + b
  a2b2 &lt;- a^2 + b^2
}
ds

df %$% c(a.ssq = sum(a^2),
         b.ssq = sum(b^2))
</code></pre>

<hr>
<h2 id='withSE'>Add Alternative Variance Estimates to Models Estimates</h2><span id='topic+withSE'></span><span id='topic+withVCov'></span><span id='topic+withVCov.lm'></span><span id='topic+vcov.withVCov'></span><span id='topic+summary.withVCov'></span><span id='topic+summary.withVCov.lm'></span>

<h3>Description</h3>

<p>A simple object-orientation infrastructure to add alternative standard
errors, e.g. sandwich estimates or New-West standard errors to 
fitted regression-type models, such as fitted by <code>lm()</code> or <code>glm()</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
withSE(object, vcov, ...) 

withVCov(object, vcov, ...)

## S3 method for class 'lm'
withVCov(object, vcov, ...)

## S3 method for class 'withVCov'
summary(object, ...)
## S3 method for class 'withVCov.lm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="withSE_+3A_object">object</code></td>
<td>
<p>a fitted model object</p>
</td></tr>
<tr><td><code id="withSE_+3A_vcov">vcov</code></td>
<td>
<p>a function that returns a variance matrix estimate, a
given matrix that is such an estimate, or a character string that
identifies a function that returns a variance matrix estimate
(e.g. <code>"HAC"</code> for <code>vcovHAC</code>).
</p>
</td></tr>
<tr><td><code id="withSE_+3A_...">...</code></td>
<td>
<p>further arguments, passed to <code>vcov()</code> or, respectively,
to the parent method of <code>summary()</code>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>withVCov()</code> an alternative variance-covariance matrix is
attributed to a fitted model object. Such a matrix may be produced by
any of the variance estimators provided by the &quot;sandwich&quot; package or
any package that extends it.
</p>
<p><code>withVCov()</code> has no consequences on how a fitted model itself is
printed or represented, but it does have consequences what standard
errors are reported, when the function <code>summary()</code> or the function
<code>mtable()</code> is applied.
</p>
<p><code>withSE()</code> is a convenience front-end to <code>withVCov()</code>. It can
be called in the same way as <code>withVCov</code>, but also allows to specify
the type of variance estimate by a character string that identifies
the function that gives the covariance matrix (e.g. <code>"OPG"</code> for
<code>vcovOPG</code>).
</p>


<h3>Value</h3>

<p><code>withVCov</code> returns a slightly modified model object: It adds an
attribute named &quot;.VCov&quot; that contains the alternate covaraince matrix
and modifies the class attribute. If e.g. the original model object has class
&quot;lm&quot; then the model object modified by <code>withVCov</code> has the class
attribute <code>c("withVCov.lm", "withVCov", "lm")</code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate poisson regression relationship
x &lt;- sin(1:100)
y &lt;- rpois(100, exp(1 + x))
## compute usual covariance matrix of coefficient estimates
fm &lt;- glm(y ~ x, family = poisson)

library(sandwich)
fmo &lt;- withVCov(fm,vcovOPG)
vcov(fm)
vcov(fmo)

summary(fm)
summary(fmo)

mtable(Default=fm,
       OPG=withSE(fm,"OPG"),
       summary.stats=c("Deviance","N")
       )

vo &lt;- vcovOPG(fm)

mtable(Default=fm,
       OPG=withSE(fm,vo),
       summary.stats=c("Deviance","N")
       )
</code></pre>

<hr>
<h2 id='Write'>Write Codebooks and Variable Descriptions into a Text File</h2><span id='topic+Write'></span><span id='topic+Write.codebook'></span><span id='topic+Write.descriptions'></span>

<h3>Description</h3>

<p>This is a convenience function to facilitate the creation of data set documents
in text files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Write(x,...)
## S3 method for class 'codebook'
Write(x,file=stdout(),...)
## S3 method for class 'descriptions'
Write(x,file=stdout(),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Write_+3A_x">x</code></td>
<td>
<p>a &quot;codebook&quot; or &quot;descriptions&quot; object.</p>
</td></tr>
<tr><td><code id="Write_+3A_file">file</code></td>
<td>
<p> a connection, see <a href="base.html#topic+connections">connections</a>.</p>
</td></tr>
<tr><td><code id="Write_+3A_...">...</code></td>
<td>
<p> further arguments, ignored or passed on to particular methods.</p>
</td></tr>
</table>

<hr>
<h2 id='xapply'>Apply a function to ranges of variables</h2><span id='topic+xapply'></span>

<h3>Description</h3>

<p><code>xapply</code> evaluates an expression given as second argument by substituting
in variables. The results are collected in a list or array in a
similar way as done by <code>Sapply</code> or <code>lapply</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  xapply(...,.sorted,simplify=TRUE,USE.NAMES=TRUE,.outer=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xapply_+3A_...">...</code></td>
<td>
<p>tagged and untagged arguments.
The tagged arguments define the 'variables' that are looped over,
the first untagged argument defines the expression wich is
evaluated.
</p>
</td></tr>
<tr><td><code id="xapply_+3A_.sorted">.sorted</code></td>
<td>
<p>an optional logical value; relevant only
when a range of variable is specified using the column operator
&quot;<code>:</code>&quot;. Decises whether variable names should be sorted
alphabetically before the range of variables are created.
</p>
<p>If this argument missing, its default value is TRUE, if <code>xapply()</code> is called
in the global environment, otherwise it is FALSE.
</p>
</td></tr>
<tr><td><code id="xapply_+3A_simplify">simplify</code></td>
<td>
<p>a logical value; should the result be simplifies in
<code>Sapply</code>?</p>
</td></tr>
<tr><td><code id="xapply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>a logical value or a positive integer. If
an integer, determines which variable is used to name
the highest dimension of the result (its columns, in case is it a matrix).
If TRUE, the first variable is used.
</p>
</td></tr>
<tr><td><code id="xapply_+3A_.outer">.outer</code></td>
<td>
<p>an optional logical value; if TRUE, each combination of
the variables is used to evaluate the expression,
if FALSE (the default) then the variables all need to have
the same length and the corresponding values of the
variables are used in the evaluation of the expression.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
y &lt;- -(1:3)
z &lt;- c("Uri","Schwyz","Unterwalden")
print(x)
print(y)
print(z)
foreach(var=c(x,y,z),          # assigns names
  names(var) &lt;- letters[1:3]   # to the elements of x, y, and z
  )
print(x)
print(y)
print(z)

ds &lt;- data.set(
        a = c(1,2,3,2,3,8,9),
        b = c(2,8,3,2,1,8,9),
        c = c(1,3,2,1,2,8,8)
      )
print(ds)
ds &lt;- within(ds,{ 
      description(a) &lt;- "First item in questionnaire"
      description(b) &lt;- "Second item in questionnaire"
      description(c) &lt;- "Third item in questionnaire"
      
      wording(a) &lt;- "What number do you like first?"
      wording(b) &lt;- "What number do you like second?"
      wording(c) &lt;- "What number do you like third?"

      foreach(x=a:c,{ # Lazy data documentation:
        labels(x) &lt;- c(    # a,b,c get value labels in one statement
                         one = 1,
                         two = 2,
                       three = 3,
                "don't know" = 8,
         "refused to answer" = 9)
        missing.values(x) &lt;- c(8,9)
        })
      })
      
codebook(ds)

# The colon-operator respects the order of the variables
# in the data set, if .sorted=FALSE
with(ds[c(3,1,2)],
     xapply(x=a:c,
            description(x)
            ))

# Since .sorted=TRUE, the colon operator creates a range 
# of alphabetically sorted variables.
with(ds[c(3,1,2)],
     xapply(x=a:c,
            description(x),
            .sorted=TRUE
            ))

# The variables in reverse order
with(ds,
     xapply(x=c:a,
             description(x)
            ))

# The colon operator can be combined with the 
# concatenation function
with(ds,
     xapply(x=c(a:b,c,c,b:a),
             description(x)
            ))

# Variables can also be selected by regular expressions.
with(ds,
     xapply(x=rx("[a-b]"),
             description(x)
            ))

# Demonstrating the effects of the 'USE.NAMES' argument.
with(ds,
     xapply(x=a:c,mean(x)))

with(ds,
     xapply(x=a:c,mean(x),
     USE.NAMES=FALSE))

t(with(ds,
      xapply(i=1:3,
             x=a:c,
             c(Index=i,
               Mean=mean(x)),
      USE.NAMES=2)))

# Result with 'simplify=FALSE'
with(ds,
     xapply(x=a:c,mean(x),
     simplify=FALSE))

# It is also possible to loop over functions:
xapply(fun=c(exp,log),
       fun(1))

# Two demonstrations for '.outer=TRUE'
with(ds,
      xapply(x=a:c,
             y=a:c,
             cov(x,y),
             .outer=TRUE))

with(ds,
      xapply(x=a:c,
             y=a:c,
             fun=c(cov,cor),
             fun(x,y),
             .outer=TRUE))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
