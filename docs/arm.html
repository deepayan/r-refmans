<!DOCTYPE html><html lang="en"><head><title>Help for package arm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {arm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#balance'><p>Functions to compute the balance statistics</p></a></li>
<li><a href='#bayesglm'><p>Bayesian generalized linear models.</p></a></li>
<li><a href='#bayespolr'><p>Bayesian Ordered Logistic or Probit Regression</p></a></li>
<li><a href='#binnedplot'><p>Binned Residual Plot</p></a></li>
<li><a href='#coefplot'><p>Generic Function for Making Coefficient Plot</p></a></li>
<li><a href='#contrast.bayes'><p>Contrast Matrices</p></a></li>
<li><a href='#corrplot'><p>Correlation Plot</p></a></li>
<li><a href='#discrete.histogram'><p>Histogram for Discrete Distributions</p></a></li>
<li><a href='#display'><p>Functions for Processing lm, glm, mer, polr and svyglm Output</p></a></li>
<li><a href='#extractDIC'>
<p>Extract AIC and DIC from a &lsquo;mer&rsquo; model</p></a></li>
<li><a href='#fround'><p>Formating the Rounding of Numbers</p></a></li>
<li><a href='#GO'><p>Function to Recall Last Source File</p></a></li>
<li><a href='#invlogit'><p>Logistic and Inverse logistic functions</p></a></li>
<li><a href='#lalonde'><p>Lalonde Dataset</p></a></li>
<li><a href='#matching'><p>Single Nearest Neighborhood Matching</p></a></li>
<li><a href='#mcsamp'><p>Generic Function to Run &lsquo;mcmcsamp()&rsquo; in lme4</p></a></li>
<li><a href='#model.matrixBayes'><p>Construct Design Matrices</p></a></li>
<li><a href='#multicomp.plot'><p>Multiple Comparison Plot</p></a></li>
<li><a href='#readColumns'><p>Function to read data by columns</p></a></li>
<li><a href='#rescale'><p>Function for Standardizing by Centering and Dividing by 2 sd's</p></a></li>
<li><a href='#residual.plot'><p>residual plot for the observed values</p></a></li>
<li><a href='#se.coef'><p>Extract Standard Errors of Model Coefficients</p></a></li>
<li><a href='#sigma.hat'><p>Extract Residual Errors</p></a></li>
<li><a href='#sim'><p>Functions to Get Posterior Distributions</p></a></li>
<li><a href='#standardize'><p>Function for Standardizing Regression Predictors by Centering and</p>
Dividing by 2 sd's</a></li>
<li><a href='#traceplot'><p>Trace plot of &lsquo;bugs&rsquo; object</p></a></li>
<li><a href='#triangleplot'><p>Triangle Plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.14-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-4-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Analysis Using Regression and Multilevel/Hierarchical
Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Gelman [aut],
  Yu-Sung Su <a href="https://orcid.org/0000-0001-5021-8209"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Masanao Yajima [ctb],
  Jennifer Hill [ctb],
  Maria Grazia Pittau [ctb],
  Jouni Kerman [ctb],
  Tian Zheng [ctb],
  Vincent Dorie [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yu-Sung Su &lt;suyusung@tsinghua.edu.cn&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/suyusung/arm/issues/">https://github.com/suyusung/arm/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), MASS, Matrix (&ge; 1.0), stats, lme4 (&ge; 1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, coda, graphics, grDevices, methods, nlme, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to accompany A. Gelman and J. Hill, Data Analysis Using Regression and Multilevel/Hierarchical Models, Cambridge University Press, 2007.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&gt; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=arm">https://CRAN.R-project.org/package=arm</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-01 10:51:23 UTC; yusung</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-01 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='balance'>Functions to compute the balance statistics</h2><span id='topic+balance-class'></span><span id='topic+balance'></span><span id='topic+print.balance'></span><span id='topic+plot.balance'></span>

<h3>Description</h3>

<p>This function computes the balance statistics before and after matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance(rawdata, treat, matched, estimand="ATT")

## S3 method for class 'balance'
print(x, ..., combined = FALSE, digits = 2)

## S3 method for class 'balance'
plot(x, longcovnames=NULL, which.covs="mixed",
    v.axis=TRUE, cex.main=1, cex.vars=1, cex.pts=1,
    mar=c(4, 3, 5.1, 2), plot=TRUE, x.max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balance_+3A_rawdata">rawdata</code></td>
<td>
<p>The full covariate dataset</p>
</td></tr>
<tr><td><code id="balance_+3A_treat">treat</code></td>
<td>
<p>the vector of treatment assignments for the full dataset</p>
</td></tr>
<tr><td><code id="balance_+3A_matched">matched</code></td>
<td>
<p>vector of weights to apply to the full dataset to create the
restructured data: for matching without replacement these will all be 0's and 1's; 
for one-to-one matching with replacement these will all be non-negative
integers; for IPTW or more complicated matching methods these could be any non-negative numbers</p>
</td></tr>
<tr><td><code id="balance_+3A_estimand">estimand</code></td>
<td>
<p>can either be <code>ATT</code>, <code>ATC</code>, or <code>ATE</code>, default is <code>ATT</code></p>
</td></tr>
<tr><td><code id="balance_+3A_x">x</code></td>
<td>
<p>an object return by the balance function.</p>
</td></tr>
<tr><td><code id="balance_+3A_combined">combined</code></td>
<td>
<p>default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="balance_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, default is 2.</p>
</td></tr>
<tr><td><code id="balance_+3A_longcovnames">longcovnames</code></td>
<td>
<p>long covariate names.  If not provided, plot will 
use covariate variable name by default</p>
</td></tr>
<tr><td><code id="balance_+3A_which.covs">which.covs</code></td>
<td>
<p><code>mixed</code> then it plots all as std diffs;
<code>binary</code> it only plots binary and as abs unstd diffs;
<code>cont</code> it only plots non-binary and as abs std diffs</p>
</td></tr>
<tr><td><code id="balance_+3A_v.axis">v.axis</code></td>
<td>
<p>default is <code>TRUE</code>, which shows the top axis&ndash;axis(3).</p>
</td></tr>
<tr><td><code id="balance_+3A_cex.main">cex.main</code></td>
<td>
<p>font size of main title</p>
</td></tr>
<tr><td><code id="balance_+3A_cex.vars">cex.vars</code></td>
<td>
<p>font size of variabel names</p>
</td></tr>
<tr><td><code id="balance_+3A_cex.pts">cex.pts</code></td>
<td>
<p>point size of the estimates</p>
</td></tr>
<tr><td><code id="balance_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form <code>c(bottom, left, top, right)</code>
which gives the number of lines of margin to be specified on
the four sides of the plot. The default is <code>c(0,3,5.1,2)</code>.</p>
</td></tr>
<tr><td><code id="balance_+3A_plot">plot</code></td>
<td>
<p>default is <code>TRUE</code>, which will plot the plot.</p>
</td></tr>
<tr><td><code id="balance_+3A_x.max">x.max</code></td>
<td>
<p>set the max of the <code>xlim</code>, default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="balance_+3A_...">...</code></td>
<td>
<p>other plot options may be passed to this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the balance statistics before and after matching.  
The open circle dots represent the unmatched balance statistics.  The 
solid dots represent the matched balance statistics. The closer the value
of the estimates to the zero, the better the treated and control groups are 
balanced after matching.
</p>


<h3>Note</h3>

 
<p>The function does not work with predictors that contain factor(x), log(x) or all
other data transformation. Create new objects for these variables.  Attach
them into the original dataset before doing the matching procedure.
</p>


<h3>Author(s)</h3>

<p>Jennifer Hill <a href="mailto:jennifer.hill@nyu.edu">jennifer.hill@nyu.edu</a>; 
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill. (2006).
<em>Data Analysis Using Regression and Multilevel/Hierarchical Models</em>.
Cambridge University Press. (Chapter 10)</p>


<h3>See Also</h3>

<p><code><a href="#topic+matching">matching</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matching first
old.par &lt;- par(no.readonly = TRUE)
data(lalonde)
attach(lalonde)
fit &lt;- glm(treat ~ re74 + re75 + age + factor(educ) + 
            black + hisp + married + nodegr + u74 + u75, 
            family=binomial(link="logit"))
pscores &lt;- predict(fit, type="link")
matches &lt;- matching(z=lalonde$treat, score=pscores)
matched &lt;- matches$cnts

# balance check
b.stats &lt;- balance(lalonde, treat, matched, estimand = "ATT")
print(b.stats)
plot(b.stats)
par(old.par)
</code></pre>

<hr>
<h2 id='bayesglm'>Bayesian generalized linear models.</h2><span id='topic+bayesglm-class'></span><span id='topic+bayesglm'></span><span id='topic+bayesglm.fit'></span><span id='topic+print+2Cbayesglm-method'></span><span id='topic+show+2Cbayesglm-method'></span><span id='topic+predict.bayesglm'></span>

<h3>Description</h3>

<p>Bayesian functions for generalized linear modeling
with independent normal, t, or Cauchy prior distribution
for the coefficients.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesglm (formula, family = gaussian, data,
    weights, subset, na.action,
    start = NULL, etastart, mustart,
    offset, control = list(...),
    model = TRUE, method = "glm.fit",
    x = FALSE, y = TRUE, contrasts = NULL,
    drop.unused.levels = TRUE,
    prior.mean = 0,
    prior.scale = NULL,
    prior.df = 1,
    prior.mean.for.intercept = 0,
    prior.scale.for.intercept = NULL,
    prior.df.for.intercept = 1,
    min.prior.scale=1e-12,
    scaled = TRUE, keep.order=TRUE,
    drop.baseline=TRUE,
    maxit=100, 
    print.unnormalized.log.posterior=FALSE,
    Warning=TRUE,...)

bayesglm.fit (x, y, weights = rep(1, nobs),
    start = NULL, etastart = NULL,
    mustart = NULL, offset = rep(0, nobs), family = gaussian(),
    control = list(), intercept = TRUE,
    prior.mean = 0,
    prior.scale = NULL,
    prior.df = 1,
    prior.mean.for.intercept = 0,
    prior.scale.for.intercept = NULL,
    prior.df.for.intercept = 1,
    min.prior.scale=1e-12, scaled = TRUE,
    print.unnormalized.log.posterior=FALSE, Warning=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesglm_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit.
The details of model specification are given below.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link
function to be used in the model. This can be a character string
naming a family function, a family function or the result of a call
to a family function.  (See <code><a href="stats.html#topic+family">family</a></code> for details of
family functions.)</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>glm</code> is called.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &ldquo;factory-fresh&rdquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em>
known component to be included in the linear predictor
during fitting.  This should be <code>NULL</code> or a numeric vector of
length either one or equal to the number of cases.
One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the
formula instead or as well, and if both are specified their sum is
used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting
process.  See the documentation for <code><a href="stats.html#topic+glm.control">glm.control</a></code>
for details.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether <em>model frame</em>
should be included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_method">method</code></td>
<td>
<p>the method to be used in fitting the model.
The default method <code>"glm.fit"</code> uses iteratively reweighted
least squares (IWLS).  The only current alternative is
<code>"model.frame"</code> which returns the model frame and does no fitting.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_x">x</code>, <code id="bayesglm_+3A_y">y</code></td>
<td>
<p>For <code>glm</code>:
logical values indicating whether the response vector and model
matrix used in the fitting process should be returned as components
of the returned value.
</p>
<p>For <code>glm.fit</code>: <code>x</code> is a design matrix of dimension <code>n
      * p</code>, and <code>y</code> is a vector of observations of length <code>n</code>.
</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>default TRUE, if FALSE, it interpolates the
intermediate values if the data have integer levels.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_intercept">intercept</code></td>
<td>
<p>logical. Should an intercept be included in the
<em>null</em> model?</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_prior.mean">prior.mean</code></td>
<td>
<p>prior mean for the coefficients: default is 0. Can be a vector
of length equal to the number of predictors
(not counting the intercept, if any). If it is a scalar, it is
expanded to the length of this vector.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_prior.scale">prior.scale</code></td>
<td>
<p>prior scale for the coefficients: default is NULL; if is NULL, for
a logit model, prior.scale is 2.5; for a probit model, prior scale is 2.5*1.6.
Can be a vector of length equal to the number of predictors
(not counting the intercept, if any). If it is a scalar, it is
expanded to the length of this vector.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_prior.df">prior.df</code></td>
<td>
<p>prior degrees of freedom for the coefficients.
For t distribution: default is 1 (Cauchy). Set to Inf to
get normal prior distributions. Can be a vector of length equal to
the number of predictors (not counting the intercept, if any).
If it is a scalar, it is expanded to the length of this vector.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_prior.mean.for.intercept">prior.mean.for.intercept</code></td>
<td>
<p>prior mean for the intercept: default
is 0. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_prior.scale.for.intercept">prior.scale.for.intercept</code></td>
<td>
<p>prior scale for the intercept: default is NULL; for
a logit model, prior scale for intercept is 10;
for probit model, prior scale for intercept is rescaled as 10*1.6.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_prior.df.for.intercept">prior.df.for.intercept</code></td>
<td>
<p>prior degrees of freedom for the intercept: default is 1.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_min.prior.scale">min.prior.scale</code></td>
<td>
<p>Minimum prior scale for the coefficients: default is 1e-12.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_scaled">scaled</code></td>
<td>
<p>scaled=TRUE, the scales for the prior distributions of the coefficients
are determined as follows: For a predictor with only one value,
we just use prior.scale. For a predictor with two values,
we use prior.scale/range(x). For a predictor with more than two values,
we use prior.scale/(2*sd(x)). If the response is Gaussian, prior.scale is also
multiplied by 2 * sd(y). Default is TRUE</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_keep.order">keep.order</code></td>
<td>
<p>a logical value indicating whether the terms should
keep their positions. If <code>FALSE</code> the terms are reordered so
that main effects come first, followed by the interactions,
all second-order, all third-order and so on.  Effects of a given
order are kept in the order specified. Default is TRUE.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_drop.baseline">drop.baseline</code></td>
<td>
<p>Drop the base level of categorical x's, default is TRUE.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_maxit">maxit</code></td>
<td>
<p>integer giving the maximal number of IWLS iterations, default is 100. This can also be controlled by <code>control</code>.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_print.unnormalized.log.posterior">print.unnormalized.log.posterior</code></td>
<td>
<p>display the unnormalized log posterior likelihood for bayesglm, default=FALSE</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_warning">Warning</code></td>
<td>
<p>default is TRUE, which will show the error messages of not convergence and separation.</p>
</td></tr>
<tr><td><code id="bayesglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program is a simple alteration of <code>glm()</code> that uses an approximate EM
algorithm to update the betas at each step using an augmented regression
to represent the prior information.
</p>
<p>We use Student-t prior distributions for the coefficients. The prior
distribution for the constant term is set so it applies to the value
when all predictors are set to their mean values.
</p>
<p>If scaled=TRUE, the scales for the prior distributions of the
coefficients are determined as follows: For a predictor with only one
value, we just use prior.scale. For a predictor with two values, we use
prior.scale/range(x). For a predictor with more than two values, we use
prior.scale/(2*sd(x)).
</p>
<p>We include all the <code>glm()</code> arguments but we haven't tested that all the
options (e.g., <code>offsets</code>, <code>contrasts</code>,
<code>deviance</code> for the null model) all work.
</p>
<p>The new arguments here are: <code>prior.mean</code>, <code>prior.scale</code>,
<code>prior.scale.for.intercept</code>, <code>prior.df</code>, <code>prior.df.for.intercept</code>and
<code>scaled</code>.
</p>


<h3>Value</h3>

<p>See <code><a href="stats.html#topic+glm">glm</a></code> for details.
</p>
<table role = "presentation">
<tr><td><code>prior.mean</code></td>
<td>
<p>prior means for the coefficients and the intercept.</p>
</td></tr>
<tr><td><code>prior.scale</code></td>
<td>
<p>prior scales for the coefficients</p>
</td></tr>
<tr><td><code>prior.df</code></td>
<td>
<p>prior dfs for the coefficients.</p>
</td></tr>
<tr><td><code>prior.scale.for.intercept</code></td>
<td>
<p>prior scale for the intercept</p>
</td></tr>
<tr><td><code>prior.df.for.intercept</code></td>
<td>
<p>prior df for the intercept</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>;
Daniel Lee <a href="mailto:bearlee@alum.mit.edu">bearlee@alum.mit.edu</a>;
Aleks Jakulin <a href="mailto:Jakulin@stat.columbia.edu">Jakulin@stat.columbia.edu</a></p>


<h3>References</h3>

<p>Andrew Gelman, Aleks Jakulin, Maria Grazia Pittau and Yu-Sung Su. (2009).
&ldquo;A Weakly Informative Default Prior Distribution For
Logistic And Other Regression Models.&rdquo;
<em>The Annals of Applied Statistics</em> 2 (4): 1360&ndash;1383.
<a href="http://www.stat.columbia.edu/~gelman/research/published/priors11.pdf">http://www.stat.columbia.edu/~gelman/research/published/priors11.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="#topic+bayespolr">bayespolr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n &lt;- 100
  x1 &lt;- rnorm (n)
  x2 &lt;- rbinom (n, 1, .5)
  b0 &lt;- 1
  b1 &lt;- 1.5
  b2 &lt;- 2
  y &lt;- rbinom (n, 1, invlogit(b0+b1*x1+b2*x2))

  M1 &lt;- glm (y ~ x1 + x2, family=binomial(link="logit"))
  display (M1)

  M2 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"),
    prior.scale=Inf, prior.df=Inf)
  display (M2)  # just a test:  this should be identical to classical logit

  M3 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"))
    # default Cauchy prior with scale 2.5
  display (M3)

  M4 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"),
    prior.scale=2.5, prior.df=1)
    # Same as M3, explicitly specifying Cauchy prior with scale 2.5
  display (M4)

  M5 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"),
    prior.scale=2.5, prior.df=7)   # t_7 prior with scale 2.5
  display (M5)

  M6 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"),
    prior.scale=2.5, prior.df=Inf)  # normal prior with scale 2.5
  display (M6)

# Create separation:  set y=1 whenever x2=1
# Now it should blow up without the prior!

  y &lt;- ifelse (x2==1, 1, y)

  M1 &lt;- glm (y ~ x1 + x2, family=binomial(link="logit"))
  display (M1)

  M2 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"),
    prior.scale=Inf, prior.scale.for.intercept=Inf) # Same as M1
  display (M2)

  M3 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"))
  display (M3)

  M4 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"),
    prior.scale=2.5, prior.scale.for.intercept=10)  # Same as M3
  display (M4)

  M5 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"),
    prior.scale=2.5, prior.df=7)
  display (M5)

  M6 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"),
    prior.scale=2.5, prior.df=Inf)
  display (M6)

  # bayesglm with gaussian family (bayes lm)
  sigma &lt;- 5
  y2 &lt;- rnorm (n, b0+b1*x1+b2*x2, sigma)
  M7 &lt;- bayesglm (y2 ~ x1 + x2, prior.scale=Inf, prior.df=Inf)
  display (M7)


  # bayesglm with categorical variables
  z1 &lt;- trunc(runif(n, 4, 9))
  levels(factor(z1))
  z2 &lt;- trunc(runif(n, 15, 19))
  levels(factor(z2))

  ## drop the base level (R default)
  M8 &lt;- bayesglm (y ~ x1 + factor(z1) + factor(z2),
    family=binomial(link="logit"), prior.scale=2.5, prior.df=Inf)
  display (M8)

  ## keep all levels with the intercept, keep the variable order
  M9 &lt;- bayesglm (y ~ x1 + x1:x2 + factor(z1) + x2 + factor(z2),
    family=binomial(link="logit"),
    prior.mean=rep(0,12),
    prior.scale=rep(2.5,12),
    prior.df=rep(Inf,12),
    prior.mean.for.intercept=0,
    prior.scale.for.intercept=10,
    prior.df.for.intercept=1,
    drop.baseline=FALSE, keep.order=TRUE)
  display (M9)

  ## keep all levels without the intercept
  M10 &lt;- bayesglm (y ~ x1 + factor(z1) + x1:x2 + factor(z2)-1,
    family=binomial(link="logit"),
    prior.mean=rep(0,11),
    prior.scale=rep(2.5,11),
    prior.df=rep(Inf,11),
    drop.baseline=FALSE)
  display (M10)

</code></pre>

<hr>
<h2 id='bayespolr'>Bayesian Ordered Logistic or Probit Regression</h2><span id='topic+bayespolr-class'></span><span id='topic+bayespolr'></span><span id='topic+print+2Cbayespolr-method'></span><span id='topic+show+2Cbayespolr-method'></span>

<h3>Description</h3>

<p>Bayesian functions for ordered logistic or probit modeling
with independent normal, t, or Cauchy prior distribution
for the coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayespolr(formula, data, weights, start,  ...,
    subset, na.action, contrasts = NULL,
    Hess = TRUE, model = TRUE,
    method = c("logistic", "probit", "cloglog", "cauchit"),
    drop.unused.levels=TRUE,
    prior.mean = 0,
    prior.scale = 2.5,
    prior.df = 1,
    prior.counts.for.bins = NULL,
    min.prior.scale=1e-12,
    scaled = TRUE,
    maxit = 100,
    print.unnormalized.log.posterior = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayespolr_+3A_formula">formula</code></td>
<td>
<p>a formula expression as for regression models, of the form
<code>response ~ predictors</code>. The response should be a factor
(preferably an ordered factor), which will be interpreted as
an ordinal response, with levels ordered as in the factor.  A
proportional odds model will be fitted.  The model must have
an intercept: attempts to remove one will lead to a warning
and be ignored. An offset may be used.  See the documentation
of <code>formula</code> for other details.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to interpret the variables
occurring in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_weights">weights</code></td>
<td>
<p>optional case weights in fitting.  Default to 1.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_start">start</code></td>
<td>
<p>initial values for the parameters.  This is in the format
<code>c(coefficients, zeta)</code></p>
</td></tr>
<tr><td><code id="bayespolr_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>optim</code>, most often a
<code>control</code> argument.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_subset">subset</code></td>
<td>
<p>expression saying which subset of the rows of the data should
be used in the fit.  All observations are included by
default.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_contrasts">contrasts</code></td>
<td>
<p>a list of contrasts to be used for some or all of the
factors appearing as variables in the model formula.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_hess">Hess</code></td>
<td>
<p>logical for whether the Hessian (the observed information
matrix) should be returned.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_model">model</code></td>
<td>
<p>logical for whether the model matrix should be returned.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_method">method</code></td>
<td>
<p>logistic or probit or complementary log-log or cauchit
(corresponding to a Cauchy latent variable and only available
in R &gt;= 2.1.0).</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>default <code>TRUE</code>, if <code>FALSE</code>, it interpolates the
intermediate values if the data have integer levels.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_prior.mean">prior.mean</code></td>
<td>
<p>prior mean for the coefficients: default is 0.
Can be a vector of length equal to the number of predictors
(not counting the intercepts). If it is a scalar, it is
expanded to the length of this vector.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_prior.scale">prior.scale</code></td>
<td>
<p>prior scale for the coefficients: default is 2.5.
Can be a vector of length equal to the number of predictors
(not counting the intercepts). If it is a scalar, it is expanded
to the length of this vector.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_prior.df">prior.df</code></td>
<td>
<p>for t distribution: default is 1 (Cauchy).
Set to <code>Inf</code> to get normal prior distributions. Can
be a vector of length equal to the number of predictors (not counting
the intercepts). If it is a scalar, it is expanded to the length of this
vector.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_prior.counts.for.bins">prior.counts.for.bins</code></td>
<td>
<p>default is <code>NULL</code>, which will augment the data by
giving each cut point a <code>1/levels(y)</code>. To use a noninformative prior, assign
prior.counts.for.bins = 0. If it is a scalar, it is expanded to the number
of levels of y.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_min.prior.scale">min.prior.scale</code></td>
<td>
<p>Minimum prior scale for the coefficients: default is 1e-12.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_scaled">scaled</code></td>
<td>
<p>if <code>scaled = TRUE</code>, then the prior distribution is rescaled.
Can be a vector of length equal to the number of cutpoints
(intercepts). If it is a scalar, it is expanded to the length of
this vector.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_maxit">maxit</code></td>
<td>
<p>integer giving the maximal number of IWLS iterations, default is 100. This can also be controlled by <code>control</code>.</p>
</td></tr>
<tr><td><code id="bayespolr_+3A_print.unnormalized.log.posterior">print.unnormalized.log.posterior</code></td>
<td>
<p>display the unnormalized log posterior
likelihood for bayesglm fit, default=<code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program is a simple alteration of <code><a href="MASS.html#topic+polr">polr</a></code> in
<code>VR</code> version 7.2-31 that augments the
loglikelihood with the log of the t prior distributions for the
coefficients.
</p>
<p>We use Student-t prior distributions for the coefficients. The prior
distributions for the intercepts (the cutpoints) are set so they apply
to the value when all predictors are set to their mean values.
</p>
<p>If scaled=TRUE, the scales for the prior distributions of the
coefficients are determined as follows: For a predictor with only one
value, we just use <code>prior.scale</code>. For a predictor with two
values, we use prior.scale/range(x).
For a predictor with more than two values, we use prior.scale/(2*sd(x)).
</p>


<h3>Value</h3>

<p>See <code>polr</code> for details.
</p>
<table role = "presentation">
<tr><td><code>prior.mean</code></td>
<td>
<p>prior means for the cofficients.</p>
</td></tr>
<tr><td><code>prior.scale</code></td>
<td>
<p>prior scales for the cofficients.</p>
</td></tr>
<tr><td><code>prior.df</code></td>
<td>
<p>prior dfs for the cofficients.</p>
</td></tr>
<tr><td><code>prior.counts.for.bins</code></td>
<td>
<p>prior counts for the cutpoints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>;
Maria Grazia Pittau <a href="mailto:grazia@stat.columbia.edu">grazia@stat.columbia.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesglm">bayesglm</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    M1 &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
    display (M1)

    M2 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.scale=Inf, prior.df=Inf) # Same as M1
    display (M2)

    M3 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
    display (M3)

    M4 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.scale=2.5, prior.df=1)  # Same as M3
    display (M4)

    M5 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.scale=2.5, prior.df=7)
    display (M5)

    M6 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.scale=2.5, prior.df=Inf)
    display (M6)

    # Assign priors
    M7 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.mean=rep(0,6), prior.scale=rep(2.5,6), prior.df=c(1,1,1,7,7,7))
    display (M7)


    #### Another example
    y &lt;- factor (rep (1:10,1:10))
    x &lt;- rnorm (length(y))
    x &lt;- x - mean(x)

    M8 &lt;- polr (y ~ x)
    display (M8)

    M9 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=0)
    display (M9) # same as M1

    M10 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=10000)
    display (M10)


    #### Another example

    y &lt;- factor (rep (1:3,1:3))
    x &lt;- rnorm (length(y))
    x &lt;- x - mean(x)

    M11 &lt;- polr (y ~ x)
    display (M11)

    M12 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=0)
    display (M12) # same as M1

    M13 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=1)
    display (M13)

    M14 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=10)
    display (M14)

</code></pre>

<hr>
<h2 id='binnedplot'>Binned Residual Plot</h2><span id='topic+binnedplot'></span><span id='topic+binned.resids'></span>

<h3>Description</h3>

<p>A function that plots averages of y versus averages of x and can be 
useful to plot residuals for logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> binnedplot(x ,y, nclass=NULL, 
    xlab="Expected Values", ylab="Average residual", 
    main="Binned residual plot", 
    cex.pts=0.8, col.pts=1, col.int="gray", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binnedplot_+3A_x">x</code></td>
<td>
<p>The expected values from the logistic regression.</p>
</td></tr>
<tr><td><code id="binnedplot_+3A_y">y</code></td>
<td>
<p>The residuals values from logistic regression (observed values
minus expected values).</p>
</td></tr>
<tr><td><code id="binnedplot_+3A_nclass">nclass</code></td>
<td>
<p>Number of categories (bins) based on their fitted values in which
the data are divided. Default=NULL and will take the value of nclass
according to the $n$ such that if $n &gt;=100$, 
nclass=floor(sqrt(length(x))); if $10&lt;n&lt;100$, nclass=10;
if $n&lt;10$, nclass=floor(n/2).</p>
</td></tr>
<tr><td><code id="binnedplot_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, default is &quot;Expected Values&quot;.</p>
</td></tr>
<tr><td><code id="binnedplot_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, default is &quot;Average residual&quot;.</p>
</td></tr>       
<tr><td><code id="binnedplot_+3A_main">main</code></td>
<td>
<p>a main title for the plot, default is &quot;Binned residual plot&quot;. 
See also <code>title</code>.</p>
</td></tr>
<tr><td><code id="binnedplot_+3A_cex.pts">cex.pts</code></td>
<td>
<p>The size of points, default=0.8.</p>
</td></tr>
<tr><td><code id="binnedplot_+3A_col.pts">col.pts</code></td>
<td>
<p>color of points, default is black</p>
</td></tr>
<tr><td><code id="binnedplot_+3A_col.int">col.int</code></td>
<td>
<p>color of intervals, default is gray</p>
</td></tr>
<tr><td><code id="binnedplot_+3A_...">...</code></td>
<td>
<p>Graphical parameters to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In logistic regression, as with linear regression, the residuals can be defined as 
observed minus expected values. The data are discrete and so are the residuals. 
As a result, plots of raw residuals from logistic regression are generally not useful.
The binned residuals plot instead, after dividing the data into categories (bins) based
on their fitted values, plots the average residual versus the average fitted
value for each bin.
</p>


<h3>Value</h3>

<p>A plot in which the gray lines indicate plus and minus 2 standard-error
bounds, within which one would expect about 95% of the binned residuals to fall,
if the model were actually true. 
</p>


<h3>Note</h3>

<p>There is typically some arbitrariness in choosing the number of bins: 
each bin should contain enough points so that the averaged residuals are not too noisy,
but it helps to have also many bins so as to see more local patterns in the residuals (see 
Gelman and Hill, Data Analysis Using Regression and Multilevel/Hierarchical Models, pag 97).</p>


<h3>Author(s)</h3>

<p>M. Grazia Pittau <a href="mailto:grazia@stat.columbia.edu">grazia@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>References</h3>

<p> Andrew Gelman and Jennifer Hill, 
Data Analysis Using Regression and Multilevel/Hierarchical Models, 
Cambridge University Press, 2006.</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+par">par</a></code>, <code><a href="base.html#topic+plot">plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>old.par &lt;- par(no.readonly = TRUE)
 data(lalonde)
 attach(lalonde)
 fit &lt;- glm(treat ~ re74 + re75 + educ + black + hisp + married 
               + nodegr + u74 + u75, family=binomial(link="logit"))
 x &lt;- predict(fit)
 y &lt;- resid(fit)
 binnedplot(x,y)
par(old.par)
</code></pre>

<hr>
<h2 id='coefplot'>Generic Function for Making Coefficient Plot</h2><span id='topic+coefplot'></span><span id='topic+coefplot.default'></span><span id='topic+coefplot+2Cnumeric-method'></span><span id='topic+coefplot+2Clm-method'></span><span id='topic+coefplot+2Cglm-method'></span><span id='topic+coefplot+2Cbugs-method'></span><span id='topic+coefplot+2Cpolr-method'></span>

<h3>Description</h3>

<p>Functions that plot the coefficients plus and minus 1 and 2 sd 
from a lm, glm, bugs, and polr fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefplot(object,...)

## Default S3 method:
coefplot(coefs, sds, CI=2, 
                lower.conf.bounds, upper.conf.bounds,
                varnames=NULL, vertical=TRUE, 
                v.axis=TRUE, h.axis=TRUE,
                cex.var=0.8, cex.pts=0.9, 
                col.pts=1, pch.pts=20, var.las=2,
                main=NULL, xlab=NULL, ylab=NULL, mar=c(1,3,5.1,2),
                plot=TRUE, add=FALSE, offset=.1, ...)

## S4 method for signature 'bugs'
coefplot(object, var.idx=NULL, varnames=NULL, 
            CI=1, vertical=TRUE,
            v.axis=TRUE, h.axis=TRUE, 
            cex.var=0.8, cex.pts=0.9, 
            col.pts=1, pch.pts=20, var.las=2, 
            main=NULL, xlab=NULL, ylab=NULL, 
            plot=TRUE, add=FALSE, offset=.1,
            mar=c(1,3,5.1,2), ...)

## S4 method for signature 'numeric'
coefplot(object, ...)
## S4 method for signature 'lm'
coefplot(object, varnames=NULL, intercept=FALSE, ...)
## S4 method for signature 'glm'
coefplot(object, varnames=NULL, intercept=FALSE, ...)
## S4 method for signature 'polr'
coefplot(object, varnames=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefplot_+3A_object">object</code></td>
<td>
<p>fitted objects-lm, glm, bugs and polr, or a vector of coefficients.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_coefs">coefs</code></td>
<td>
<p>a vector of coefficients.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_sds">sds</code></td>
<td>
<p>a vector of sds of coefficients.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci">CI</code></td>
<td>
<p>confidence interval, default is 2, which will plot plus and minus 2 sds or
95% CI. If CI=1, plot plus and minus 1 sds or 50% CI instead.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lower.conf.bounds">lower.conf.bounds</code></td>
<td>
<p>lower bounds of confidence intervals.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_upper.conf.bounds">upper.conf.bounds</code></td>
<td>
<p>upper bounds of confidence intervals.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_varnames">varnames</code></td>
<td>
<p>a vector of variable names, default is NULL, which will use
the names of variables; if specified, the length of varnames must be equal to
the length of predictors, including the intercept.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_vertical">vertical</code></td>
<td>
<p>orientation of the plot, default is TRUE which will plot
variable names in the 2nd axis. If FALSE, plot variable names in the first
axis instead.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_v.axis">v.axis</code></td>
<td>
<p>default is TRUE, which shows the bottom axis&ndash;axis(1).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_h.axis">h.axis</code></td>
<td>
<p>default is TRUE, which shows the left axis&ndash;axis(2).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_cex.var">cex.var</code></td>
<td>
<p>The fontsize of the varible names, default=0.8.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_cex.pts">cex.pts</code></td>
<td>
<p>The size of data points, default=0.9.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_col.pts">col.pts</code></td>
<td>
<p>color of points and segments, default is black.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_pch.pts">pch.pts</code></td>
<td>
<p>symbol of points, default is solid dot.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_var.las">var.las</code></td>
<td>
<p>the orientation of variable names against the axis, default is 2. 
see the usage of <code>las</code> in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_main">main</code></td>
<td>
<p>The main title (on top) using font and size (character
expansion) <code>par("font.main")</code> and color <code>par("col.main")</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_xlab">xlab</code></td>
<td>
<p>X axis label using font and character expansion
<code>par("font.lab")</code> and color <code>par("col.lab")</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label, same font attributes as <code>xlab</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form <code>c(bottom, left, top, right)</code>
which gives the number of lines of margin to be specified on
the four sides of the plot. The default is <code>c(1,3,5.1,2)</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_plot">plot</code></td>
<td>
<p>default is TRUE, plot the estimates.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_add">add</code></td>
<td>
<p>if add=TRUE, plot over the existing plot. default is FALSE.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_offset">offset</code></td>
<td>
<p>add extra spaces to separate from the existing dots. default is 0.1.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_var.idx">var.idx</code></td>
<td>
<p>the index of the variables of a bugs object, default
is NULL which will plot all the variables.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_intercept">intercept</code></td>
<td>
<p>If TRUE will plot intercept, default=FALSE to get better presentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots coefficients from bugs, lm, glm and polr
with 1 sd and 2 sd interval bars.
</p>


<h3>Value</h3>

<p>Plot of the coefficients from a bugs, lm or glm fit. You can add the intercept, 
the variable names and the display the result of the fitted model. 
</p>


<h3>Author(s)</h3>

<p>Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill, 
Data Analysis Using Regression and Multilevel/Hierarchical Models, 
Cambridge University Press, 2006.</p>


<h3>See Also</h3>

<p><code><a href="#topic+display">display</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="#topic+bayesglm">bayesglm</a></code>,
<code><a href="graphics.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old.par &lt;- par(no.readonly = TRUE)

 y1 &lt;- rnorm(1000,50,23)
 y2 &lt;- rbinom(1000,1,prob=0.72)
 x1 &lt;- rnorm(1000,50,2) 
 x2 &lt;- rbinom(1000,1,prob=0.63) 
 x3 &lt;- rpois(1000, 2) 
 x4 &lt;- runif(1000,40,100) 
 x5 &lt;- rbeta(1000,2,2) 
 
 longnames &lt;- c("a long name01","a long name02","a long name03",
                "a long name04","a long name05")

 fit1 &lt;- lm(y1 ~ x1 + x2 + x3 + x4 + x5)
 fit2 &lt;- glm(y2 ~ x1 + x2 + x3 + x4 + x5, 
            family=binomial(link="logit"))
 op &lt;- par()
 # plot 1
 par (mfrow=c(2,2))
 coefplot(fit1)
 coefplot(fit2, col.pts="blue")
 
 # plot 2
 longnames &lt;- c("(Intercept)", longnames) 
 coefplot(fit1, longnames, intercept=TRUE, CI=1)
 
 # plot 3
 coefplot(fit2, vertical=FALSE, var.las=1, frame.plot=TRUE)
 
 # plot 4: comparison to show bayesglm works better than glm
 n &lt;- 100
 x1 &lt;- rnorm (n)
 x2 &lt;- rbinom (n, 1, .5)
 b0 &lt;- 1
 b1 &lt;- 1.5
 b2 &lt;- 2
 y &lt;- rbinom (n, 1, invlogit(b0+b1*x1+b2*x2))
 y &lt;- ifelse (x2==1, 1, y)
 x1 &lt;- rescale(x1)
 x2 &lt;- rescale(x2, "center")
 
 M1 &lt;- glm (y ~ x1 + x2, family=binomial(link="logit"))
       display (M1)
 M2 &lt;- bayesglm (y ~ x1 + x2, family=binomial(link="logit"))
       display (M2)

#=================== 
#    stacked plot
#===================
  coefplot(M2, xlim=c(-1,5), intercept=TRUE)
  coefplot(M1, add=TRUE, col.pts="red")
  
#==================== 
# arrayed plot       
#====================
  par(mfrow=c(1,2))
  x.scale &lt;- c(0, 7.5) # fix x.scale for comparison
  coefplot(M1, xlim=x.scale, main="glm", intercept=TRUE)
  coefplot(M2, xlim=x.scale, main="bayesglm", intercept=TRUE)

# plot 5: the ordered logit model from polr
 M3 &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
 coefplot(M3, main="polr")
   
 M4 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
 coefplot(M4, main="bayespolr", add=TRUE, col.pts="red")

## plot 6: plot bugs &amp; lmer
# par &lt;- op
# M5 &lt;- lmer(Reaction ~ Days + (1|Subject), sleepstudy)
# M5.sim &lt;- mcsamp(M5)
# coefplot(M5.sim, var.idx=5:22, CI=1, ylim=c(18,1), main="lmer model")


# plot 7: plot coefficients &amp; sds vectors
 coef.vect &lt;- c(0.2, 1.4, 2.3, 0.5)
 sd.vect &lt;- c(0.12, 0.24, 0.23, 0.15)
 longnames &lt;- c("var1", "var2", "var3", "var4")
 coefplot (coef.vect, sd.vect, varnames=longnames, main="Regression Estimates")
 coefplot (coef.vect, sd.vect, varnames=longnames, vertical=FALSE, 
    var.las=1, main="Regression Estimates")
    
par(old.par)
</code></pre>

<hr>
<h2 id='contrast.bayes'>Contrast Matrices</h2><span id='topic+contr.bayes.ordered'></span><span id='topic+contr.bayes.unordered'></span>

<h3>Description</h3>

<p>Return a matrix of contrasts used in <code><a href="#topic+bayesglm">bayesglm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.bayes.unordered(n, base = 1, contrasts = TRUE)
contr.bayes.ordered (n, scores = 1:n, contrasts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contrast.bayes_+3A_n">n</code></td>
<td>
<p>a vector of levels for a factor, or the number of levels.</p>
</td></tr>
<tr><td><code id="contrast.bayes_+3A_base">base</code></td>
<td>
<p>an integer specifying which group is considered the baseline
group. Ignored if <code>contrasts</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="contrast.bayes_+3A_contrasts">contrasts</code></td>
<td>
<p>a logical indicating whether contrasts should be computed.</p>
</td></tr>
<tr><td><code id="contrast.bayes_+3A_scores">scores</code></td>
<td>
<p>the set of values over which orthogonal polynomials are to be
computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are adapted from <code>contr.treatment</code> and <code>contr.poly</code>
in <code><a href="stats.html#topic+stats">stats</a></code> package.  The purpose for these functions are to keep
the baseline levels of categorical variables and thus to suit the use of 
<code><a href="#topic+bayesglm">bayesglm</a></code>.
</p>
<p><code>contr.bayes.unordered</code> is equivalent to <code>contr.treatment</code> whereas
<code>contr.bayes.ordered</code> is equivalent to <code>contr.poly</code>.
</p>


<h3>Author(s)</h3>

<p>Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+C">C</a></code>,
<code><a href="stats.html#topic+contr.helmert">contr.helmert</a></code>,
<code><a href="stats.html#topic+contr.poly">contr.poly</a></code>,
<code><a href="stats.html#topic+contr.sum">contr.sum</a></code>,
<code><a href="stats.html#topic+contr.treatment">contr.treatment</a></code>;
<code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="stats.html#topic+aov">aov</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="#topic+bayesglm">bayesglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> cat.var &lt;- rep(1:3, 5)
 dim(contr.bayes.unordered(cat.var))
 # 15*15 baseline level kept!
 dim(contr.treatment(cat.var))
 # 15*14
</code></pre>

<hr>
<h2 id='corrplot'>Correlation Plot</h2><span id='topic+corrplot'></span>

<h3>Description</h3>

<p>Function for making a correlation plot starting from a data matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrplot (data, varnames=NULL, cutpts=NULL,
    abs=TRUE, details=TRUE, 
    n.col.legend=5, cex.col=0.7, 
    cex.var=0.9, digits=1, color=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corrplot_+3A_data">data</code></td>
<td>
<p>a data matrix</p>
</td></tr>
<tr><td><code id="corrplot_+3A_varnames">varnames</code></td>
<td>
<p>variable names of the data matrix, if not provided
use default variable names</p>
</td></tr>
<tr><td><code id="corrplot_+3A_abs">abs</code></td>
<td>
<p>if TRUE, transform all correlation values into positive values, 
default=TRUE.</p>
</td></tr>
<tr><td><code id="corrplot_+3A_cutpts">cutpts</code></td>
<td>
<p>a vector of cutting points for color legend, default is NULL. 
The function will decide the cutting points if cutpts is not assigned.</p>
</td></tr>
<tr><td><code id="corrplot_+3A_details">details</code></td>
<td>
<p>show more than one digits correlaton values. Default 
is TRUE.  FALSE is suggested to get readable output.</p>
</td></tr>
<tr><td><code id="corrplot_+3A_n.col.legend">n.col.legend</code></td>
<td>
<p>number of legend for the color thermometer.</p>
</td></tr>
<tr><td><code id="corrplot_+3A_cex.col">cex.col</code></td>
<td>
<p>font size of the color thermometer.</p>
</td></tr>
<tr><td><code id="corrplot_+3A_cex.var">cex.var</code></td>
<td>
<p>font size of the variable names.</p>
</td></tr>
<tr><td><code id="corrplot_+3A_digits">digits</code></td>
<td>
<p>number of digits shown in the text of the color theromoeter.</p>
</td></tr>
<tr><td><code id="corrplot_+3A_color">color</code></td>
<td>
<p>color of the plot, default is FALSE, which uses gray scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function adapts the R function for 
Figure 8 in Tian Zheng, Matthew Salganik, and Andrew Gelman, 2006, 
&quot;How many people do you know in prison?: using overdispersion in count data to estimate social structure in networks&quot;, 
Journal of the American Statistical Association, Vol.101, N0. 474: p.409-23.
</p>


<h3>Value</h3>

<p>A correlation plot. 
</p>


<h3>Author(s)</h3>

<p>Tian Zheng <a href="mailto:tzheng@stat.columbia.edu">tzheng@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>References</h3>

<p> Tian Zheng, Matthew Salganik, and Andrew Gelman, 2006, 
&quot;How many people do you know in prison?: using overdispersion in count data to estimate social structure in networks&quot;, 
Journal of the American Statistical Association, Vol.101, N0. 474: p.409-23</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old.par &lt;- par(no.readonly = TRUE)

 x1 &lt;- rnorm(1000,50,2) 
 x2 &lt;- rbinom(1000,1,prob=0.63) 
 x3 &lt;- rpois(1000, 2) 
 x4 &lt;- runif(1000,40,100) 
 x5 &lt;- rnorm(1000,100,30)
 x6 &lt;- rbeta(1000,2,2) 
 x7 &lt;- rpois(1000,10) 
 x8 &lt;- rbinom(1000,1,prob=0.4) 
 x9 &lt;- rbeta(1000,5,4) 
 x10 &lt;- runif(1000,-10,-1) 

 test.data &lt;- data.matrix(cbind(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10))
 test.names &lt;- c("a short name01","a short name02","a short name03",
                 "a short name04","a short name05","a short name06",
                 "a short name07","a short name08","a short name09",
                 "a short name10")
 
 # example 1
 corrplot(test.data)
 
 # example 2
 corrplot(test.data,test.names, abs=FALSE, n.col.legend=7)
 corrplot(test.data,test.names, abs=TRUE, n.col.legend=7)
 
 # example 3
 data(lalonde)
 corrplot(lalonde, details=FALSE, color=TRUE)
 corrplot(lalonde, cutpts=c(0,0.25,0.5,0.75), color=TRUE, digits=2)
 
par(old.par)
</code></pre>

<hr>
<h2 id='discrete.histogram'>Histogram for Discrete Distributions</h2><span id='topic+discrete.histogram'></span><span id='topic+discrete.hist'></span>

<h3>Description</h3>

<p>Creates a prettier histogram for discrete distributions</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.histogram (x, prob, prob2=NULL, prob3=NULL,
    xlab="x", xaxs.label=NULL, yaxs.label=NULL, bar.width=NULL,
    freq=FALSE, prob.col="blue", prob2.col="red", prob3.col="gray", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrete.histogram_+3A_x">x</code></td>
<td>
<p>The vector of x's</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_prob">prob</code></td>
<td>
<p>The probabilities for the x's</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_prob2">prob2</code></td>
<td>
<p>A second vector of probabilities of the x's</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_prob3">prob3</code></td>
<td>
<p>A third vector of probabilities of the x's</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x axis</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_xaxs.label">xaxs.label</code></td>
<td>
<p>Label for the x's</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_yaxs.label">yaxs.label</code></td>
<td>
<p>Label for the y axis</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_bar.width">bar.width</code></td>
<td>
<p>Width of the bars</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_freq">freq</code></td>
<td>
<p>If TRUE, shows a frequency histogram as opposed to probability.</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_prob.col">prob.col</code></td>
<td>
<p>The color of the first set of histogram bars.</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_prob2.col">prob2.col</code></td>
<td>
<p>The color of the second set of histogram bars.</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_prob3.col">prob3.col</code></td>
<td>
<p>The color of the third set of histogram bars.</p>
</td></tr>
<tr><td><code id="discrete.histogram_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to function <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays a histogram for discrete
probability distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(3,4,0,0,5,1,1,1,1,0)
discrete.histogram (a)

x &lt;- c(0,1,3,4,5)
p &lt;- c(.3,.4,.1,.1,.1)
discrete.histogram (x,p)

x &lt;- c(0,1,3,4,5)
y &lt;- c(3,4,1,1,1)
discrete.histogram (x,y)
</code></pre>

<hr>
<h2 id='display'>Functions for Processing lm, glm, mer, polr and svyglm Output</h2><span id='topic+display'></span><span id='topic+display+2Clm-method'></span><span id='topic+display+2Cbayesglm-method'></span><span id='topic+display+2Cglm-method'></span><span id='topic+display+2CmerMod-method'></span><span id='topic+display+2Cpolr-method'></span><span id='topic+display+2Csvyglm-method'></span>

<h3>Description</h3>

<p>This generic function gives a
clean printout of lm, glm, mer, polr and svyglm objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>display (object, ...)

## S4 method for signature 'lm'
display(object, digits=2, detail=FALSE)
## S4 method for signature 'bayesglm'
display(object, digits=2, detail=FALSE)
## S4 method for signature 'glm'
display(object, digits=2, detail=FALSE)
## S4 method for signature 'merMod'
display(object, digits=2, detail=FALSE)
## S4 method for signature 'polr'
display(object, digits=2, detail=FALSE)
## S4 method for signature 'svyglm'
display(object, digits=2, detail=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="display_+3A_object">object</code></td>
<td>
<p>The output of a call to lm, glm, mer, polr, svyglm or related regressions 
function with n data points and k predictors.</p>
</td></tr>
<tr><td><code id="display_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="display_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to display.</p>
</td></tr>
<tr><td><code id="display_+3A_detail">detail</code></td>
<td>
<p>defaul is <code>FALSE</code>, if <code>TRUE</code>, display p-values or z-values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function gives a
clean printout of lm, glm, mer and polr objects, focusing 
on the most pertinent pieces of information: 
the coefficients and their standard errors, the sample size, 
number of predictors, residual standard deviation, and R-squared.
Note: R-squared is automatically displayed to 2 digits, and deviances are
automatically displayed to 1 digit, no matter what.
</p>


<h3>Value</h3>

<p>Coefficients
and their standard errors, the sample size, number of predictors, 
residual standard
deviation, and R-squared</p>


<h3>Note</h3>

<p>Output are the model, the regression coefficients and standard errors,
and the residual sd and R-squared (for a linear model),
or the null deviance and residual deviance (for a generalized linear model).
</p>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>; 
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>;
Maria Grazia Pittau <a href="mailto:grazia@stat.columbia.edu">grazia@stat.columbia.edu</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill, 
Data Analysis Using Regression and Multilevel/Hierarchical Models, 
Cambridge University Press, 2006.</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="lme4.html#topic+lmer">lmer</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>,
<code><a href="survey.html#topic+svyglm">svyglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>                          
# Here's a simple example of a model of the form, y = a + bx + error, 
# with 10 observations in each of 10 groups, and with both the 
# intercept and the slope varying by group.  First we set up the model and data.
   group &lt;- rep(1:10, rep(10,10))
   group2 &lt;- rep(1:10, 10)
   mu.a &lt;- 0
   sigma.a &lt;- 2
   mu.b &lt;- 3
   sigma.b &lt;- 4
   rho &lt;- 0.56
   Sigma.ab &lt;- array (c(sigma.a^2, rho*sigma.a*sigma.b, 
                    rho*sigma.a*sigma.b, sigma.b^2), c(2,2))
   sigma.y &lt;- 1
   ab &lt;- mvrnorm (10, c(mu.a,mu.b), Sigma.ab)
   a &lt;- ab[,1]
   b &lt;- ab[,2]
   d &lt;- rnorm(10)

   x &lt;- rnorm (100)
   y1 &lt;- rnorm (100, a[group] + b*x, sigma.y)
   y2 &lt;- rbinom(100, 1, prob=invlogit(a[group] + b*x))
   y3 &lt;- rnorm (100, a[group] + b[group]*x + d[group2], sigma.y)
   y4 &lt;- rbinom(100, 1, prob=invlogit(a[group] + b*x + d[group2]))


# display a simple linear model

   M1 &lt;- lm (y1 ~ x)
   display (M1)
   M1.sim &lt;- sim(M1, n.sims=2)  

# display a simple logit model

   M2 &lt;- glm (y2 ~ x, family=binomial(link="logit"))
   display (M2)
   M2.sim &lt;- sim(M2, n.sims=2)  

# Then fit and display a simple varying-intercept model:
 
   M3 &lt;- lmer (y1 ~ x + (1|group))
   display (M3)
   M3.sim &lt;- sim(M3, n.sims=2)  


# Then the full varying-intercept, varying-slope model:
 
   M4 &lt;- lmer (y1 ~ x + (1 + x |group))
   display (M4)
   M4.sim &lt;- sim(M4, n.sims=2)  

 
# Then the full varying-intercept, logit model:
 
   M5 &lt;- glmer (y2 ~ x + (1|group), family=binomial(link="logit"))
   display (M5)
   M5.sim &lt;- sim(M5, n.sims=2)  

 
# Then the full varying-intercept, varying-slope logit model:
 
   M6 &lt;- glmer (y2 ~ x + (1|group) + (0 + x |group), 
        family=binomial(link="logit"))
   display (M6)
   M6.sim &lt;- sim(M6, n.sims=2)  


# Then non-nested varying-intercept, varying-slop model:
   
   M7 &lt;- lmer (y3 ~ x + (1 + x |group) + (1|group2))
   display(M7)
   M7.sim &lt;- sim(M7, n.sims=2)  

 
# Then the ordered logit model from polr

   M8 &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
   display(M8)
   
   M9 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
   display(M9) 
   

</code></pre>

<hr>
<h2 id='extractDIC'>
Extract AIC and DIC from a &lsquo;mer&rsquo; model
</h2><span id='topic+extractDIC'></span><span id='topic+extractDIC.merMod'></span><span id='topic+extractAIC.merMod'></span>

<h3>Description</h3>

<p>Computes the (generalized) Akaike *A*n *I*nformation *C*riterion 
and *D*eviance *I*nformation *C*riterion for a mer model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractDIC(fit,...)
## S3 method for class 'merMod'
extractDIC(fit,...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractDIC_+3A_fit">fit</code></td>
<td>
<p>fitted <code>merMod</code> mode, usually the result of a fiiter like <code>merMod</code>.</p>
</td></tr>
<tr><td><code id="extractDIC_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
extractAIC(fm1)
extractDIC(fm1)
</code></pre>

<hr>
<h2 id='fround'>Formating the Rounding of Numbers</h2><span id='topic+fround'></span><span id='topic+pfround'></span>

<h3>Description</h3>

<p><code>fround</code> rounds the values in its first argument to the specified
number of decimal places with surrounding quotes.
</p>
<p><code>pfround</code> rounds the values in its first argument to the specified
number of decimal places without surrounding quotes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fround(x, digits)
pfround(x, digits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fround_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="fround_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>; 
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+round">round</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    x &lt;- rnorm(1)
    fround(x, digits=2)
    pfround(x, digits=2)
</code></pre>

<hr>
<h2 id='GO'>Function to Recall Last Source File</h2><span id='topic+GO-class'></span><span id='topic+go'></span><span id='topic+G'></span>

<h3>Description</h3>

<p>A function that like <code>source()</code> but recalls the last source file names by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>go(..., add=FALSE, timer=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GO_+3A_...">...</code></td>
<td>
<p>list of filenames as character strings.</p>
</td></tr>
<tr><td><code id="GO_+3A_add">add</code></td>
<td>
<p>add these names to the current list; if replace, then <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="GO_+3A_timer">timer</code></td>
<td>
<p>time the execution time of <code>go()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jouni Kerman <a href="mailto:jouni@kerman.com">jouni@kerman.com</a> <a href="mailto:kerman@stat.columbia.edu">kerman@stat.columbia.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    go('myprog')            # will run source('myprog.r')
    go()                    # will run source('myprog.r') again
    go('somelib',add=TRUE)  # will run source('myprog.r') and source('somelib.r')
    go('myprog','somelib')  # same as above
    go('mytest')            # will run source('mytest') only
    go()                    # runs source('mytest') again
    G                       # short cut to call go()
 </code></pre>

<hr>
<h2 id='invlogit'>Logistic and Inverse logistic functions</h2><span id='topic+invlogit'></span><span id='topic+logit'></span>

<h3>Description</h3>

<p>Inverse-logit function, transforms continuous values to the range (0, 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)
invlogit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invlogit_+3A_x">x</code></td>
<td>
<p>A vector of continuous values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Inverse-logit function defined as: 
<code class="reqn">logit^-1(x) = e^x/(1+e^x)</code> transforms continuous values to the range (0, 1),
which is necessary, since probabilities must be between 0 and 1 and maps 
from the linear predictor to the probabilities 
</p>


<h3>Value</h3>

<p>A vector of estimated probabilities
</p>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>, 
M.Grazia Pittau <a href="mailto:grazia@stat.columbia.edu">grazia@stat.columbia.edu</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill. (2006).
<em>Data Analysis Using Regression and Multilevel/Hierarchical Models</em>.
Cambridge University Press.</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(frisk)
 n &lt;- 100
 x1 &lt;- rnorm (n)
 x2 &lt;- rbinom (n, 1, .5)
 b0 &lt;- 1
 b1 &lt;- 1.5
 b2 &lt;- 2
 Inv.logit &lt;- invlogit(b0+b1*x1+b2*x2)
 plot(b0+b1*x1+b2*x2, Inv.logit)
</code></pre>

<hr>
<h2 id='lalonde'>Lalonde Dataset</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p>Dataset used by Dehejia and Wahba (1999) to evaluate propensity score matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalonde)</code></pre>


<h3>Format</h3>

<p>A data frame with 445 observations on the following 12 variables.
</p>

<dl>
<dt>age</dt><dd><p>age in years.</p>
</dd>
<dt>educ</dt><dd><p>years of schooling.</p>
</dd>
<dt>black</dt><dd><p>indicator variable for blacks.</p>
</dd>
<dt>hisp</dt><dd><p>indicator variable for Hispanics.</p>
</dd>
<dt>married</dt><dd><p>indicator variable for martial status.</p>
</dd>
<dt>nodegr</dt><dd><p>indicator variable for high school diploma.</p>
</dd>
<dt>re74</dt><dd><p>real earnings in 1974.</p>
</dd>
<dt>re75</dt><dd><p>real earnings in 1975.</p>
</dd>
<dt>re78</dt><dd><p>real earnings in 1978.</p>
</dd>
<dt>u74</dt><dd><p>indicator variable for earnings in 1974 being zero.</p>
</dd>
<dt>u75</dt><dd><p>indicator variable for earnings in 1975 being zero.</p>
</dd>
<dt>treat</dt><dd><p>an indicator variable for treatment status.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Two demos are provided which use this dataset.  The first,
<code>DehejiaWahba</code>, replicates one of the models from Dehejia and
Wahba (1999).  The second demo, <code>AbadieImbens</code>, replicates the
models produced by Abadie and Imbens
<a href="https://scholar.harvard.edu/imbens/scholar_software/matching-estimators">https://scholar.harvard.edu/imbens/scholar_software/matching-estimators</a>.
Many of these models are found to produce good balance for the Lalonde
data.
</p>


<h3>Note</h3>

<p>This documentation is adapted from <code>Matching</code> package.</p>


<h3>References</h3>

<p>Dehejia, Rajeev and Sadek Wahba. 1999.&ldquo;Causal Effects in
Non-Experimental Studies: Re-Evaluating the
Evaluation of Training Programs.&rdquo; <em>Journal of the American Statistical
Association</em> 94 (448): 1053-1062.
</p>
<p>LaLonde, Robert. 1986.  &ldquo;Evaluating the Econometric Evaluations of
Training Programs.&rdquo;  <em>American Economic Review</em> 76:604-620.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matching">matching</a></code>,
<code><a href="Matching.html#topic+GenMatch">GenMatch</a></code>
<code><a href="#topic+balance">balance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lalonde)
</code></pre>

<hr>
<h2 id='matching'>Single Nearest Neighborhood Matching</h2><span id='topic+matching'></span>

<h3>Description</h3>

<p>Function for processing matching with propensity score 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matching(z, score, replace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matching_+3A_z">z</code></td>
<td>
<p>vector of indicators for treatment or control.</p>
</td></tr>
<tr><td><code id="matching_+3A_score">score</code></td>
<td>
<p>vector of the propensity scores in the same order as z.</p>
</td></tr>
<tr><td><code id="matching_+3A_replace">replace</code></td>
<td>
<p>whether the control units could be reused for matching, 
default is <code>FALSE</code>.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Function for matching each treatment unit in turn 
the control unit (not previously chosen) with the 
closest propensity score </p>


<h3>Value</h3>

<p>The function returns a vector of indices that the corresponding 
unit is matched to. 0 means matched to nothing.</p>


<h3>Author(s)</h3>

<p>Jeniffer Hill <a href="mailto:jh1030@columbia.edu">jh1030@columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill. (2006).
<em>Data Analysis Using Regression and Multilevel/Hierarchical Models</em>.
Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+balance">balance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matching first
data(lalonde)
attach(lalonde)
fit &lt;- glm(treat ~ re74 + re75 + age + factor(educ) + 
            black + hisp + married + nodegr + u74 + u75, 
            family=binomial(link="logit"))
pscores &lt;- predict(fit, type="response")
matches &lt;- matching(z=lalonde$treat, score=pscores)
matched &lt;- matches$cnts

# balance check!
b.stats &lt;- balance(lalonde, treat, matched)
print(b.stats)
plot(b.stats)
</code></pre>

<hr>
<h2 id='mcsamp'>Generic Function to Run &lsquo;mcmcsamp()&rsquo; in lme4</h2><span id='topic+mcsamp'></span><span id='topic+mcsamp.default'></span><span id='topic+mcsamp+2CmerMod-method'></span>

<h3>Description</h3>

<p>The quick function for MCMC sampling for
lmer and glmer objects and convert to Bugs objects for easy display. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mcsamp(object, n.chains=3, n.iter=1000, n.burnin=floor(n.iter/2), 
    n.thin=max(1, floor(n.chains * (n.iter - n.burnin)/1000)), 
    saveb=TRUE, deviance=TRUE, make.bugs.object=TRUE)
## S4 method for signature 'merMod'
 mcsamp(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcsamp_+3A_object">object</code></td>
<td>
<p><code>mer</code> objects from <code>lme4</code></p>
</td></tr>
<tr><td><code id="mcsamp_+3A_n.chains">n.chains</code></td>
<td>
<p>number of MCMC chains</p>
</td></tr>
<tr><td><code id="mcsamp_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iteration for each MCMC chain</p>
</td></tr>
<tr><td><code id="mcsamp_+3A_n.burnin">n.burnin</code></td>
<td>
<p>number of burnin for each MCMC chain, 
Default is <code>n.iter/2</code>, that is, discarding the
first half of the simulations.</p>
</td></tr>
<tr><td><code id="mcsamp_+3A_n.thin">n.thin</code></td>
<td>
<p>keep every kth draw from each MCMC chain. Must be a positive integer. 
Default is <code>max(1, floor(n.chains * (n.iter-n.burnin) /
          1000))</code> which will only thin if there are at least 2000
simulations.</p>
</td></tr>
<tr><td><code id="mcsamp_+3A_saveb">saveb</code></td>
<td>
<p>if 'TRUE', causes the values
of the random effects in each sample to be saved.</p>
</td></tr>
<tr><td><code id="mcsamp_+3A_deviance">deviance</code></td>
<td>
<p>compute deviance for <code>mer</code> objects. Only works 
for <code><a href="lme4.html#topic+lmer">lmer</a></code> object</p>
</td></tr>
<tr><td><code id="mcsamp_+3A_make.bugs.object">make.bugs.object</code></td>
<td>
<p>tranform the output into bugs object, default is TRUE</p>
</td></tr>
<tr><td><code id="mcsamp_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a sample from the posterior
distribution of the parameters of a fitted model using Markov
Chain Monte Carlo methods. It automatically simulates multiple 
sequences and allows convergence to be monitored. The function relies on
<code>mcmcsamp</code> in <code>lme4</code>.
</p>


<h3>Value</h3>

<p>An object of (S3) class '&quot;bugs&quot;' suitable for use with the
functions in the &quot;R2WinBUGS&quot; package. 
</p>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>; 
Yu-Sung Su <a href="mailto:ys463@columbia.edu">ys463@columbia.edu</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill, 
Data Analysis Using Regression and Multilevel/Hierarchical Models, 
Cambridge University Press, 2006.
</p>
<p>Douglas Bates and Deepayan Sarkar,
lme4: Linear mixed-effects models using S4 classes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+display">display</a></code>,
<code><a href="lme4.html#topic+lmer">lmer</a></code>,
<code><a href="#topic+sim">sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Here's a simple example of a model of the form, y = a + bx + error, 
## with 10 observations in each of 10 groups, and with both the intercept 
## and the slope varying by group.  First we set up the model and data.
##   
#   group &lt;- rep(1:10, rep(10,10))
#   group2 &lt;- rep(1:10, 10)
#   mu.a &lt;- 0
#   sigma.a &lt;- 2
#   mu.b &lt;- 3
#   sigma.b &lt;- 4
#   rho &lt;- 0.56
#   Sigma.ab &lt;- array (c(sigma.a^2, rho*sigma.a*sigma.b, 
#                    rho*sigma.a*sigma.b, sigma.b^2), c(2,2))
#   sigma.y &lt;- 1
#   ab &lt;- mvrnorm (10, c(mu.a,mu.b), Sigma.ab)
#   a &lt;- ab[,1]
#   b &lt;- ab[,2]
#   d &lt;- rnorm(10)
#
#   x &lt;- rnorm (100)
#   y1 &lt;- rnorm (100, a[group] + b*x, sigma.y)
#   y2 &lt;- rbinom(100, 1, prob=invlogit(a[group] + b*x))
#   y3 &lt;- rnorm (100, a[group] + b[group]*x + d[group2], sigma.y)
#   y4 &lt;- rbinom(100, 1, prob=invlogit(a[group] + b*x + d[group2]))
#
## 
## Then fit and display a simple varying-intercept model:
# 
#   M1 &lt;- lmer (y1 ~ x + (1|group))
#   display (M1)
#   M1.sim &lt;- mcsamp (M1)
#   print (M1.sim)
#   plot (M1.sim)
## 
## Then the full varying-intercept, varying-slope model:
## 
#   M2 &lt;- lmer (y1 ~ x + (1 + x |group))
#   display (M2)
#   M2.sim &lt;- mcsamp (M2)
#   print (M2.sim)
#   plot (M2.sim)
## 
## Then the full varying-intercept, logit model:
## 
#   M3 &lt;- lmer (y2 ~ x + (1|group), family=binomial(link="logit"))
#   display (M3)
#   M3.sim &lt;- mcsamp (M3)
#   print (M3.sim)
#   plot (M3.sim)
## 
## Then the full varying-intercept, varying-slope logit model:
## 
#   M4 &lt;- lmer (y2 ~ x + (1|group) + (0+x |group), 
#        family=binomial(link="logit"))
#   display (M4)
#   M4.sim &lt;- mcsamp (M4)
#   print (M4.sim)
#   plot (M4.sim)
#   
##
## Then non-nested varying-intercept, varying-slop model:
##
#   M5 &lt;- lmer (y3 ~ x + (1 + x |group) + (1|group2))
#   display(M5)
#   M5.sim &lt;- mcsamp (M5)
#   print (M5.sim)
#   plot (M5.sim)
      
 </code></pre>

<hr>
<h2 id='model.matrixBayes'>Construct Design Matrices</h2><span id='topic+model.matrixBayes'></span>

<h3>Description</h3>

<p><code>model.matrixBayes</code> creates a design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.matrixBayes(object, data = environment(object),
    contrasts.arg = NULL, xlev = NULL, keep.order = FALSE, drop.baseline=FALSE,...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.matrixBayes_+3A_object">object</code></td>
<td>
<p>an object of an appropriate class.  For the default
method, a model formula or terms object.</p>
</td></tr>
<tr><td><code id="model.matrixBayes_+3A_data">data</code></td>
<td>
<p>a data frame created with <code><a href="stats.html#topic+model.frame">model.frame</a></code>.  If
another sort of object, <code>model.frame</code> is called first.</p>
</td></tr>
<tr><td><code id="model.matrixBayes_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>A list, whose entries are contrasts suitable for
input to the <code><a href="stats.html#topic+contrasts">contrasts</a></code> replacement function and
whose names are the names of columns of <code>data</code> containing
<code><a href="base.html#topic+factor">factor</a></code>s.</p>
</td></tr>
<tr><td><code id="model.matrixBayes_+3A_xlev">xlev</code></td>
<td>
<p>to be used as argument of <code><a href="stats.html#topic+model.frame">model.frame</a></code> if
<code>data</code> has no <code>"terms"</code> attribute.</p>
</td></tr>
<tr><td><code id="model.matrixBayes_+3A_keep.order">keep.order</code></td>
<td>
<p>a logical value indicating whether the terms should
keep their positions. If <code>FALSE</code> the terms are reordered so
that main effects come first, followed by the interactions,
all second-order, all third-order and so on.  Effects of a given
order are kept in the order specified.</p>
</td></tr>
<tr><td><code id="model.matrixBayes_+3A_drop.baseline">drop.baseline</code></td>
<td>
<p>Drop the base level of categorical Xs, default is TRUE.</p>
</td></tr>
<tr><td><code id="model.matrixBayes_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.matrixBayes</code> is adapted from <code>model.matrix</code> in the <code>stats</code>
pacakge and is designed for the use of <code><a href="#topic+bayesglm">bayesglm</a></code>.
It is designed to keep baseline levels of all categorical varaibles and keep the
variable names unodered in the output.  The design matrices created by
<code>model.matrixBayes</code> are unidentifiable using classical regression methods,
though; they can be identified using <code><a href="#topic+bayesglm">bayesglm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a></p>


<h3>References</h3>

<p>Andrew Gelman, Aleks Jakulin, Maria Grazia Pittau and Yu-Sung Su. (2009).
&ldquo;A Weakly Informative Default Prior Distribution For
Logistic And Other Regression Models.&rdquo;
<em>The Annals of Applied Statistics</em> 2 (4): 1360&ndash;1383.
<a href="http://www.stat.columbia.edu/~gelman/research/published/priors11.pdf">http://www.stat.columbia.edu/~gelman/research/published/priors11.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.frame">model.frame</a></code>, <code><a href="stats.html#topic+model.extract">model.extract</a></code>,
<code><a href="stats.html#topic+terms">terms</a></code>, <code><a href="stats.html#topic+terms.formula">terms.formula</a></code>,
<code><a href="#topic+bayesglm">bayesglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- log(Volume) ~ log(Height) + log(Girth)
str(m &lt;- model.frame(ff, trees))
(model.matrix(ff, m))
class(ff) &lt;- c("bayesglm", "terms", "formula")
(model.matrixBayes(ff, m))
</code></pre>

<hr>
<h2 id='multicomp.plot'>Multiple Comparison Plot</h2><span id='topic+multicomp.plot'></span><span id='topic+mcplot'></span>

<h3>Description</h3>

<p>Plots significant difference of simulated array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multicomp.plot(object, alpha = 0.05, main = "Multiple Comparison Plot",
  label = NULL, shortlabel = NULL, show.pvalue = FALSE,
  label.as.shortlabel = FALSE, label.on.which.axis = 3,
  col.low = "lightsteelblue", col.same = "white", col.high = "lightslateblue",
  vertical.line = TRUE, horizontal.line = FALSE,
  vertical.line.lty = 1, horizontal.line.lty = 1, mar=c(3.5,3.5,3.5,3.5))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multicomp.plot_+3A_object">object</code></td>
<td>
<p>Simulated array of coefficients, columns being different variables
and rows being simulated result.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_alpha">alpha</code></td>
<td>
<p>Level of significance to compare.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_main">main</code></td>
<td>
<p>Main label.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_label">label</code></td>
<td>
<p>Labels for simulated parameters.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_shortlabel">shortlabel</code></td>
<td>
<p>Short labels to put into the plot.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_show.pvalue">show.pvalue</code></td>
<td>
<p>Default is FALSE, if set to TRUE replaces short label
with Bayesian p value. </p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_label.as.shortlabel">label.as.shortlabel</code></td>
<td>
<p>Default is FALSE, if set to TRUE takes first 2 character
of label and use it as short label.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_label.on.which.axis">label.on.which.axis</code></td>
<td>
<p>default is the 3rd (top) axis.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_col.low">col.low</code></td>
<td>
<p>Color of significantly low coefficients.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_col.same">col.same</code></td>
<td>
<p>Color of not significant difference.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_col.high">col.high</code></td>
<td>
<p>Color of significantly high coefficients.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_vertical.line">vertical.line</code></td>
<td>
<p>Default is TRUE, if set to FALSE does not draw vertical line.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_horizontal.line">horizontal.line</code></td>
<td>
<p>Default is FALSE, if set to TRUE draws horizontal line.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_vertical.line.lty">vertical.line.lty</code></td>
<td>
<p>Line type of vertical line.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_horizontal.line.lty">horizontal.line.lty</code></td>
<td>
<p>Line type of horizontal line.</p>
</td></tr>
<tr><td><code id="multicomp.plot_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form <code>c(bottom, left, top, right)</code>
which gives the number of lines of margin to be specified on
the four sides of the plot. The default is <code>c(3.5,3.5,3.5,3.5)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pvalue</code></td>
<td>
<p>Array of Bayesian p value.</p>
</td></tr>
<tr><td><code>significant</code></td>
<td>
<p>Array of significance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Masanao Yajima <a href="mailto:yajima@stat.columbia.edu">yajima@stat.columbia.edu</a>,
Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill. (2006).
<em>Data Analysis Using Regression and Multilevel/Hierarchical Models</em>.
Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefplot">coefplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old.par &lt;- par(no.readonly = TRUE)

# example 1
simulation.array &lt;- data.frame(coef1=rnorm(100,10,2), coef2=rnorm(100,5,2),
                      coef3=rnorm(100,0,1), coef4=rnorm(100,-5,3),
                      coef5=rnorm(100,-2,1))
short.lab &lt;- c("c01", "c02", "c03", "c04", "c05")
multicomp.plot(simulation.array[,1:4], label.as.shortlabel=TRUE)

# wraper for multicomp.plot
mcplot(simulation.array, shortlabel = short.lab)

# example 2
data(lalonde)
M1 &lt;- lm(re78 ~ treat + re74 + re75 + age + educ + u74 + u75, data=lalonde)
M1.sim &lt;- sim(M1)
lm.sim &lt;- coef(M1.sim)[,-1]
multicomp.plot(lm.sim, label.as.shortlabel=TRUE, label.on.which.axis=2)

par(old.par)
</code></pre>

<hr>
<h2 id='readColumns'>Function to read data by columns</h2><span id='topic+read.columns'></span>

<h3>Description</h3>

<p>A function read data by columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.columns(filename, columns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readColumns_+3A_filename">filename</code></td>
<td>
<p>user specified file name including path of the file</p>
</td></tr>
<tr><td><code id="readColumns_+3A_columns">columns</code></td>
<td>
<p>which columns of the data to be read</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>
</p>

<hr>
<h2 id='rescale'>Function for Standardizing by Centering and Dividing by 2 sd's</h2><span id='topic+rescale'></span>

<h3>Description</h3>

<p>This function standardizes a variable by centering and dividing by 2 sd's with 
exceptions for binary variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(x, binary.inputs="center")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="rescale_+3A_binary.inputs">binary.inputs</code></td>
<td>
<p>options for standardizing binary variables, default is <code>center</code>; <code>0/1</code> keeps original scale;
<code>-0.5,0.5</code> rescales 0 as -0.5 and 1 as 0.5; <code>center</code> substracts the mean; and 
<code>full</code> substracts the mean and divids by 2 sd.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the standardized vector
</p>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>References</h3>

<p>Andrew Gelman. (2008). 
&ldquo;Scaling regression inputs by dividing by two standard deviations&rdquo;. 
<em>Statistics in Medicine</em> 27: 2865&ndash;2873.
<a href="http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf">http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standardize">standardize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Set up the fake data
  n &lt;- 100
  x &lt;- rnorm (n, 2, 1)
  x1 &lt;- rnorm (n)
  x1 &lt;- (x1-mean(x1))/(2*sd(x1))   # standardization
  x2 &lt;- rbinom (n, 1, .5)
  b0 &lt;- 1
  b1 &lt;- 1.5
  b2 &lt;- 2
  y &lt;- rbinom (n, 1, invlogit(b0+b1*x1+b2*x2))
  rescale(x, "full")
  rescale(y, "center")
</code></pre>

<hr>
<h2 id='residual.plot'>residual plot for the observed values</h2><span id='topic+residual.plot'></span>

<h3>Description</h3>

<p>Plots the residual of observed variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual.plot(Expected, Residuals, sigma, main = deparse(substitute(Expected)), 
  col.pts = "blue", col.ctr = "red", col.sgm = "black", cex = 0.5, 
  gray.scale = FALSE, xlab = "Predicted", ylab = "Residuals", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residual.plot_+3A_expected">Expected</code></td>
<td>
<p> Expected value. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_residuals">Residuals</code></td>
<td>
<p> Residual value. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_sigma">sigma</code></td>
<td>
<p> Standard error. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_main">main</code></td>
<td>
<p> main for the plot.  See <code>plot</code> for detail.</p>
</td></tr>
<tr><td><code id="residual.plot_+3A_col.pts">col.pts</code></td>
<td>
<p> Color of the points. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_col.ctr">col.ctr</code></td>
<td>
<p> Color of the line at zero. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_col.sgm">col.sgm</code></td>
<td>
<p> Color of standard error line. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_cex">cex</code></td>
<td>
<p> A numerical value giving the amount by which plotting text
and symbols should be magnified relative to the default.  See par for detail. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_gray.scale">gray.scale</code></td>
<td>
<p> If <code>TRUE</code>, makes the plot into black and white.  This option overwrites the color specification.  Default is FALSE. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_xlab">xlab</code></td>
<td>
<p> Label for x axis. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_ylab">ylab</code></td>
<td>
<p> Label for y axis. </p>
</td></tr>
<tr><td><code id="residual.plot_+3A_...">...</code></td>
<td>
<p> Additional parameters passed to <code>plot</code> function. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot to visualize pattern of residulal value for the expected value.
</p>


<h3>Author(s)</h3>

<p>Masanao Yajima <a href="mailto:yajima@stat.columbia.edu">yajima@stat.columbia.edu</a>,
M.Grazia Pittau <a href="mailto:grazia@stat.columbia.edu">grazia@stat.columbia.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old.par &lt;- par(no.readonly = TRUE)

x &lt;- rnorm(100)
y &lt;- rnorm(100)
fit &lt;- lm(y~x)
y.hat &lt;- fitted(fit)
u &lt;- resid(fit)
sigma &lt;- sigma.hat(fit)
residual.plot(y.hat, u, sigma)

par(old.par)
</code></pre>

<hr>
<h2 id='se.coef'>Extract Standard Errors of Model Coefficients</h2><span id='topic+se.coef'></span><span id='topic+se.coef+2Clm-method'></span><span id='topic+se.coef+2Cglm-method'></span><span id='topic+se.coef+2CmerMod-method'></span><span id='topic+se.fixef'></span><span id='topic+se.ranef'></span>

<h3>Description</h3>

<p>These functions extract standard errors of model coefficients
from objects returned by modeling functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se.coef (object, ...)
se.fixef (object)
se.ranef (object)

## S4 method for signature 'lm'
se.coef(object)
## S4 method for signature 'glm'
se.coef(object)
## S4 method for signature 'merMod'
se.coef(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="se.coef_+3A_object">object</code></td>
<td>
<p>object of <code>lm</code>, <code>glm</code> and <code>merMod</code> fit</p>
</td></tr>
<tr><td><code id="se.coef_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>se.coef</code> extracts standard errors from objects
returned by modeling functions.
<code>se.fixef</code> extracts standard errors of the fixed effects
from objects returned by lmer and glmer functions.
<code>se.ranef</code> extracts standard errors of the random effects
from objects returned by lmer and glmer functions.
</p>


<h3>Value</h3>

<p><code>se.coef</code> gives lists of standard errors for <code>coef</code>,
<code>se.fixef</code> gives a vector of standard errors for <code>fixef</code> and
<code>se.ranef</code> gives a list of standard errors for <code>ranef</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill. (2006).
<em>Data Analysis Using Regression and Multilevel/Hierarchical Models</em>.
Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+display">display</a></code>,
<code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="#topic+sigma.hat">sigma.hat</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here's a simple example of a model of the form, y = a + bx + error,
# with 10 observations in each of 10 groups, and with both the
# intercept and the slope varying by group.  First we set up the model and data.

   group &lt;- rep(1:10, rep(10,10))
   mu.a &lt;- 0
   sigma.a &lt;- 2
   mu.b &lt;- 3
   sigma.b &lt;- 4
   rho &lt;- 0
   Sigma.ab &lt;- array (c(sigma.a^2, rho*sigma.a*sigma.b,
                    rho*sigma.a*sigma.b, sigma.b^2), c(2,2))
   sigma.y &lt;- 1
   ab &lt;- mvrnorm (10, c(mu.a,mu.b), Sigma.ab)
   a &lt;- ab[,1]
   b &lt;- ab[,2]
#
   x &lt;- rnorm (100)
   y1 &lt;- rnorm (100, a[group] + b[group]*x, sigma.y)
   y2 &lt;- rbinom(100, 1, prob=invlogit(a[group] + b*x))

#  lm fit
   M1 &lt;- lm (y1 ~ x)
   se.coef (M1)

#  glm fit
   M2 &lt;- glm (y2 ~ x)
   se.coef (M2)

#  lmer fit
   M3 &lt;- lmer (y1 ~ x + (1 + x |group))
   se.coef (M3)
   se.fixef (M3)
   se.ranef (M3)

#  glmer fit
   M4 &lt;- glmer (y2 ~ 1 + (0 + x |group), family=binomial(link="logit"))
   se.coef (M4)
   se.fixef (M4)
   se.ranef (M4)
</code></pre>

<hr>
<h2 id='sigma.hat'>Extract Residual Errors</h2><span id='topic+sigma.hat'></span><span id='topic+sigma.hat.lm'></span><span id='topic+sigma.hat.glm'></span><span id='topic+sigma.hat.merMod'></span><span id='topic+sigma.hat.sim'></span><span id='topic+sigma.hat.sim.merMod'></span>

<h3>Description</h3>

<p>This generic function extracts residual errors from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma.hat(object,...)

## S3 method for class 'lm'
sigma.hat(object,...)
## S3 method for class 'glm'
sigma.hat(object,...)
## S3 method for class 'merMod'
sigma.hat(object,...)
## S3 method for class 'sim'
sigma.hat(object,...)
## S3 method for class 'sim.merMod'
sigma.hat(object,...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma.hat_+3A_object">object</code></td>
<td>
<p>any fitted model object of <code>lm</code>, <code>glm</code> and <code>merMod</code> class</p>
</td></tr>
<tr><td><code id="sigma.hat_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+display">display</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="lme4.html#topic+lmer">lmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   group &lt;- rep(1:10, rep(10,10))
   mu.a &lt;- 0
   sigma.a &lt;- 2
   mu.b &lt;- 3
   sigma.b &lt;- 4
   rho &lt;- 0
   Sigma.ab &lt;- array (c(sigma.a^2, rho*sigma.a*sigma.b,
                    rho*sigma.a*sigma.b, sigma.b^2), c(2,2))
   sigma.y &lt;- 1
   ab &lt;- mvrnorm (10, c(mu.a,mu.b), Sigma.ab)
   a &lt;- ab[,1]
   b &lt;- ab[,2]

   x &lt;- rnorm (100)
   y1 &lt;- rnorm (100, a[group] + b[group]*x, sigma.y)
   y2 &lt;- rbinom(100, 1, prob=invlogit(a[group] + b*x))

   M1 &lt;- lm (y1 ~ x)
   sigma.hat(M1)

   M2 &lt;- bayesglm (y1 ~ x, prior.scale=Inf, prior.df=Inf)
   sigma.hat(M2) # should be same to sigma.hat(M1)

   M3 &lt;- glm (y2 ~ x, family=binomial(link="logit"))
   sigma.hat(M3)

   M4 &lt;- lmer (y1 ~ (1+x|group))
   sigma.hat(M4)

   M5 &lt;- glmer (y2 ~ (1+x|group), family=binomial(link="logit"))
   sigma.hat(M5)

</code></pre>

<hr>
<h2 id='sim'>Functions to Get Posterior Distributions</h2><span id='topic+sim'></span><span id='topic+sim-class'></span><span id='topic+sim.merMod-class'></span><span id='topic+sim+2Clm-method'></span><span id='topic+sim+2Cglm-method'></span><span id='topic+sim+2Cpolr-method'></span><span id='topic+sim+2CmerMod-method'></span><span id='topic+coef.sim'></span><span id='topic+coef.sim.polr'></span><span id='topic+coef.sim.merMod'></span><span id='topic+fixef.sim.merMod'></span><span id='topic+ranef.sim.merMod'></span><span id='topic+fitted.sim.merMod'></span>

<h3>Description</h3>

<p>This generic function gets posterior simulations of sigma and beta from a <code>lm</code> object, or
simulations of beta from a <code>glm</code> object, or
simulations of beta from a <code>merMod</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(object, ...)

## S4 method for signature 'lm'
sim(object, n.sims = 100)
## S4 method for signature 'glm'
sim(object, n.sims = 100)
## S4 method for signature 'polr'
sim(object, n.sims = 100)
## S4 method for signature 'merMod'
sim(object, n.sims = 100)

## S3 method for class 'sim'
coef(object,...)
## S3 method for class 'sim.polr'
coef(object, slot=c("ALL", "coef", "zeta"),...)
## S3 method for class 'sim.merMod'
coef(object,...)
## S3 method for class 'sim.merMod'
fixef(object,...)
## S3 method for class 'sim.merMod'
ranef(object,...)
## S3 method for class 'sim.merMod'
fitted(object, regression,...)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_+3A_object">object</code></td>
<td>
<p>the output of a call to <code>lm</code> with n data points and k predictors.</p>
</td></tr>
<tr><td><code id="sim_+3A_slot">slot</code></td>
<td>
<p>return which slot of <code>sim.polr</code>, available options are <code>coef, zeta, ALL</code>.</p>
</td></tr>
<tr><td><code id="sim_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="sim_+3A_n.sims">n.sims</code></td>
<td>
<p>number of independent simulation draws to create.</p>
</td></tr>
<tr><td><code id="sim_+3A_regression">regression</code></td>
<td>
<p>the orginial mer model</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>matrix (dimensions n.sims x k) of n.sims random draws of coefficients.</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>matrix (dimensions n.sims x k) of n.sims random draws of zetas (cut points in polr).</p>
</td></tr>
<tr><td><code>fixef</code></td>
<td>
<p>matrix (dimensions n.sims x k) of n.sims random draws of coefficients     of the fixed effects for the <code>merMod</code> objects. Previously, it is called <code>unmodeled</code>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>vector of n.sims random draws of sigma
(for <code>glm</code>'s, this just returns a vector of 1's or else of the
square root of the overdispersion parameter if that is in the model)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>;
Vincent Dorie <a href="mailto:vjd4@nyu.edu">vjd4@nyu.edu</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill. (2006).
<em>Data Analysis Using Regression and Multilevel/Hierarchical Models</em>.
Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+display">display</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="lme4.html#topic+lmer">lmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Examples of "sim"
 set.seed (1)
 J &lt;- 15
 n &lt;- J*(J+1)/2
 group &lt;- rep (1:J, 1:J)
 mu.a &lt;- 5
 sigma.a &lt;- 2
 a &lt;- rnorm (J, mu.a, sigma.a)
 b &lt;- -3
 x &lt;- rnorm (n, 2, 1)
 sigma.y &lt;- 6
 y &lt;- rnorm (n, a[group] + b*x, sigma.y)
 u &lt;- runif (J, 0, 3)
 y123.dat &lt;- cbind (y, x, group)
# Linear regression
 x1 &lt;- y123.dat[,2]
 y1 &lt;- y123.dat[,1]
 M1 &lt;- lm (y1 ~ x1)
 display(M1)
 M1.sim &lt;- sim(M1)
 coef.M1.sim &lt;- coef(M1.sim)
 sigma.M1.sim &lt;- sigma.hat(M1.sim)
 ## to get the uncertainty for the simulated estimates
 apply(coef(M1.sim), 2, quantile)
 quantile(sigma.hat(M1.sim))

# Logistic regression
 u.data &lt;- cbind (1:J, u)
 dimnames(u.data)[[2]] &lt;- c("group", "u")
 u.dat &lt;- as.data.frame (u.data)
 y &lt;- rbinom (n, 1, invlogit (a[group] + b*x))
 M2 &lt;- glm (y ~ x, family=binomial(link="logit"))
 display(M2)
 M2.sim &lt;- sim (M2)
 coef.M2.sim &lt;- coef(M2.sim)
 sigma.M2.sim &lt;- sigma.hat(M2.sim)

# Ordered Logistic regression
house.plr &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
display(house.plr)
M.plr &lt;- sim(house.plr)
coef.sim &lt;- coef(M.plr, slot="coef")
zeta.sim &lt;- coef(M.plr, slot="zeta")
coefall.sim &lt;- coef(M.plr)

# Using lmer:
# Example 1
 E1 &lt;- lmer (y ~ x + (1 | group))
 display(E1)
 E1.sim &lt;- sim (E1)
 coef.E1.sim &lt;- coef(E1.sim)
 fixef.E1.sim &lt;- fixef(E1.sim)
 ranef.E1.sim &lt;- ranef(E1.sim)
 sigma.E1.sim &lt;- sigma.hat(E1.sim)
 yhat &lt;- fitted(E1.sim, E1)

# Example 2
 u.full &lt;- u[group]
 E2 &lt;- lmer (y ~ x + u.full + (1 | group))
 display(E2)
 E2.sim &lt;- sim (E2)
 coef.E2.sim &lt;- coef(E2.sim)
 fixef.E2.sim &lt;- fixef(E2.sim)
 ranef.E2.sim &lt;- ranef(E2.sim)
 sigma.E2.sim &lt;- sigma.hat(E2.sim)
 yhat &lt;- fitted(E2.sim, E2)

# Example 3
 y &lt;- rbinom (n, 1, invlogit (a[group] + b*x))
 E3 &lt;- glmer (y ~ x + (1 | group), family=binomial(link="logit"))
 display(E3)
 E3.sim &lt;- sim (E3)
 coef.E3.sim &lt;- coef(E3.sim)
 fixef.E3.sim &lt;- fixef(E3.sim)
 ranef.E3.sim &lt;- ranef(E3.sim)
 sigma.E3.sim &lt;- sigma.hat(E3.sim)
 yhat &lt;- fitted(E3.sim, E3)
</code></pre>

<hr>
<h2 id='standardize'>Function for Standardizing Regression Predictors by Centering and 
Dividing by 2 sd's</h2><span id='topic+standardize'></span><span id='topic+standardize+2Clm-method'></span><span id='topic+standardize+2Cglm-method'></span><span id='topic+standardize+2CmerMod-method'></span><span id='topic+standardize+2Cpolr-method'></span>

<h3>Description</h3>

<p>Numeric variables that take on more than two values are each rescaled
to have a mean of 0 and a sd of 0.5;
Binary variables are rescaled to have a mean of 0 and a difference of 1
between their two categories; 
Non-numeric variables that take on more than two values are unchanged;
Variables that take on only one value are unchanged
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lm'
standardize(object, unchanged = NULL, 
    standardize.y = FALSE, binary.inputs = "center")
## S4 method for signature 'glm'
standardize(object, unchanged = NULL, 
    standardize.y = FALSE, binary.inputs = "center")
## S4 method for signature 'merMod'
standardize(object, unchanged = NULL, 
    standardize.y = FALSE, binary.inputs = "center")
## S4 method for signature 'polr'
standardize(object, unchanged = NULL, 
    standardize.y = FALSE, binary.inputs = "center")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_+3A_object">object</code></td>
<td>
<p>an object of class <code>lm</code> or <code>glm</code></p>
</td></tr>
<tr><td><code id="standardize_+3A_unchanged">unchanged</code></td>
<td>
<p>vector of names of parameters to leave unstandardized</p>
</td></tr>
<tr><td><code id="standardize_+3A_standardize.y">standardize.y</code></td>
<td>
<p> if TRUE, the outcome variable is standardized also</p>
</td></tr>
<tr><td><code id="standardize_+3A_binary.inputs">binary.inputs</code></td>
<td>
<p>options for standardizing binary variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;0/1&quot; (rescale so that the lower value is 0 and the upper is 1)
&quot;-0.5/0.5&quot; (rescale so that the lower value is -0.5 and upper is 0.5)
&quot;center&quot; (rescale so that the mean of the data is 0 and the difference
between the two categories is 1)
&quot;full&quot; (rescale by subtracting the mean and dividing by 2 sd's)
&quot;leave.alone&quot; (do nothing)
</p>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>References</h3>

<p>Andrew Gelman. (2008).
&ldquo;Scaling regression inputs by dividing by two standard deviations.&rdquo; 
<em>Statistics in Medicine</em> 27: 2865&ndash;2873.
<a href="http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf">http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rescale">rescale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Set up the fake data
  n &lt;- 100
  x &lt;- rnorm (n, 2, 1)
  x1 &lt;- rnorm (n)
  x1 &lt;- (x1-mean(x1))/(2*sd(x1))   # standardization
  x2 &lt;- rbinom (n, 1, .5)
  b0 &lt;- 1
  b1 &lt;- 1.5
  b2 &lt;- 2
  y &lt;- rbinom (n, 1, invlogit(b0+b1*x1+b2*x2))
  y2 &lt;- sample(1:5, n, replace=TRUE)
  M1 &lt;- glm (y ~ x, family=binomial(link="logit"))
  display(M1)
  M1.1 &lt;- glm (y ~ rescale(x), family=binomial(link="logit"))
  display(M1.1)
  M1.2 &lt;- standardize(M1)
  display(M1.2)
  # M1.1 &amp; M1.2 should be the same
  M2 &lt;- polr(ordered(y2) ~ x)
  display(M2)
  M2.1 &lt;- polr(ordered(y2) ~ rescale(x))
  display(M2.1)
  M2.2 &lt;- standardize(M2.1)
  display(M2.2)
  # M2.1 &amp; M2.2 should be the same
</code></pre>

<hr>
<h2 id='traceplot'>Trace plot of &lsquo;bugs&rsquo; object</h2><span id='topic+traceplot'></span><span id='topic+traceplot.default'></span><span id='topic+traceplot+2Cmcmc.list-method'></span><span id='topic+traceplot+2Cbugs-method'></span>

<h3>Description</h3>

<p>Displays a plot of iterations <em>vs.</em> sampled values for each variable
in the chain, with a separate plot per variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'bugs'
traceplot( x, mfrow = c( 1, 1 ), varname = NULL,
  match.head = TRUE, ask = TRUE,
  col = rainbow( x$n.chains ),
  lty = 1, lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traceplot_+3A_x">x</code></td>
<td>
<p>A bugs object</p>
</td></tr>
<tr><td><code id="traceplot_+3A_mfrow">mfrow</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_varname">varname</code></td>
<td>
<p>vector of variable names to plot</p>
</td></tr>
<tr><td><code id="traceplot_+3A_match.head">match.head</code></td>
<td>
<p> matches the variable names by the beginning of the variable names in bugs object</p>
</td></tr>
<tr><td><code id="traceplot_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is <em>ask</em>ed before each plot, see
<code>par(ask=.)</code>.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_col">col</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_lty">lty</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_lwd">lwd</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_...">...</code></td>
<td>
<p>further graphical parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Masanao Yajima <a href="mailto:yajima@stat.columbia.edu">yajima@stat.columbia.edu</a>.
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+densplot">densplot</a></code>, <code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>,
<code><a href="coda.html#topic+traceplot">traceplot</a></code>
</p>

<hr>
<h2 id='triangleplot'>Triangle Plot</h2><span id='topic+triangleplot'></span>

<h3>Description</h3>

<p>Function for making a triangle plot from a square matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangleplot (x, y=NULL, cutpts=NULL, details=TRUE, 
            n.col.legend=5, cex.col=0.7, 
            cex.var=0.9, digits=1, color=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triangleplot_+3A_x">x</code></td>
<td>
<p>a square matrix.</p>
</td></tr>
<tr><td><code id="triangleplot_+3A_y">y</code></td>
<td>
<p>a vector of names that corresponds to each element of the square matrix x.</p>
</td></tr>
<tr><td><code id="triangleplot_+3A_cutpts">cutpts</code></td>
<td>
<p>a vector of cutting points for color legend, default is <code>NULL</code>. 
The function will decide the cutting points if cutpts is not assigned.</p>
</td></tr>
<tr><td><code id="triangleplot_+3A_details">details</code></td>
<td>
<p>show more than one digits correlaton values. Default 
is <code>TRUE</code>. <code>FALSE</code> is suggested to get readable output.</p>
</td></tr>
<tr><td><code id="triangleplot_+3A_n.col.legend">n.col.legend</code></td>
<td>
<p>number of legend for the color thermometer</p>
</td></tr>
<tr><td><code id="triangleplot_+3A_cex.col">cex.col</code></td>
<td>
<p>font size of the color thermometer.</p>
</td></tr>
<tr><td><code id="triangleplot_+3A_cex.var">cex.var</code></td>
<td>
<p>font size of the variable names.</p>
</td></tr>
<tr><td><code id="triangleplot_+3A_digits">digits</code></td>
<td>
<p>number of digits shown in the text of the color theromoeter.</p>
</td></tr>
<tr><td><code id="triangleplot_+3A_color">color</code></td>
<td>
<p>color of the plot, default is FALSE, which uses gray scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function makes a triangle plot from a square matrix, e.g., the correlation plot, see 
<code><a href="#topic+corrplot">corrplot</a></code>.  If a square matrix contains missing values, the cells of missing values
will be marked <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corrplot">corrplot</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old.par &lt;- par(no.readonly = TRUE)

 # create a square matrix
 x &lt;- matrix(runif(1600, 0, 1), 40, 40)
 
 # fig 1
 triangleplot(x)
 
 # fig 2 assign cutting points
 triangleplot(x, cutpts=c(0,0.25,0.5,0.75,1), digits=2)
 
 # fig 3 if x contains missing value
 x[12,13] &lt;- x[13,12] &lt;- NA
 x[25,27] &lt;- x[27,25] &lt;- NA
 triangleplot(x)
 
par(old.par)

#
#library(RColorBrewer)
#cormat &lt;-  cor(iris[,-5])
#triangleplot2(cormat,color = brewer.pal( 5, "RdBu" ),
# n.col.legend=5, cex.col=0.7, cex.var=0.5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
