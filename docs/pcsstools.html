<!DOCTYPE html><html><head><title>Help for package pcsstools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcsstools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.pcsslm'><p>ANOVA for linear models fit using PCSS</p></a></li>
<li><a href='#approx_and'><p>Approximate a linear model for a series of logical AND statements</p></a></li>
<li><a href='#approx_conditional'><p>Approximate the mean of Y conditional on X</p></a></li>
<li><a href='#approx_mult_prod'><p>Approximate the covariance of a set of predictors and a product of responses</p></a></li>
<li><a href='#approx_or'><p>Approximate a linear model for a series of logical OR statements</p></a></li>
<li><a href='#approx_prod_stats'><p>Approximate summary statistics for a product of phenotypes and a set of</p>
predictors</a></li>
<li><a href='#approx_response_cov_recursive'><p>Approximate the covariance of one response with an arbitrary product of</p>
responses.</a></li>
<li><a href='#calculate_lm'><p>Calculate a linear model using PCSS</p></a></li>
<li><a href='#calculate_lm_combo'><p>Calculate a linear model for a linear combination of responses</p></a></li>
<li><a href='#check_terms'><p>Check that independent and dependent variables are accounted for through PCSS</p></a></li>
<li><a href='#extract_predictors'><p>Extract independent variables from a formula</p></a></li>
<li><a href='#extract_response'><p>Extract dependent variables from a formula as a string</p></a></li>
<li><a href='#get_pcor'><p>Approximate the partial correlation of Y and Z given X</p></a></li>
<li><a href='#guess_response'><p>Guess the function that is applied to a set of responses</p></a></li>
<li><a href='#make_permutations'><p>List all permutations of a sequence of integers</p></a></li>
<li><a href='#model_and'><p>Approximate a linear model for a series of logical AND statements using PCSS</p></a></li>
<li><a href='#model_combo'><p>Model a linear combination of a set of phenotypes using PCSS</p></a></li>
<li><a href='#model_or'><p>Approximate a linear model for a series of logical OR statements using PCSS</p></a></li>
<li><a href='#model_prcomp'><p>Model the principal component score of a set of phenotypes using PCSS</p></a></li>
<li><a href='#model_product'><p>Approximate a linear model for a product using PCSS</p></a></li>
<li><a href='#model_singular'><p>Model an individual phenotype using PCSS</p></a></li>
<li><a href='#new_predictor'><p>Create an object of class &quot;predictor&quot;</p></a></li>
<li><a href='#new_predictor_binary'><p>Shortcut to create a predictor object for a binary variable</p></a></li>
<li><a href='#new_predictor_normal'><p>Shortcut to create a predictor object for a continuous variable</p></a></li>
<li><a href='#new_predictor_snp'><p>Shortcut to create a predictor object for a SNP's minor allele counts</p></a></li>
<li><a href='#pcsslm'><p>Approximate a linear model using PCSS</p></a></li>
<li><a href='#pcsstools_example'><p>Simulated example data</p></a></li>
<li><a href='#print.pcsslm'><p>Print an object of class pcsslm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Regression Using Pre-Computed Summary Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Defines functions to describe regression models using only
    pre-computed summary statistics (i.e. means, variances, and covariances)
    in place of individual participant data.
    Possible models include linear models for linear combinations, products, 
    and logical combinations of phenotypes.
    Implements methods presented in 
    Wolf et al. (2021) &lt;<a href="https://doi.org/10.3389%2Ffgene.2021.745901">doi:10.3389/fgene.2021.745901</a>&gt;
    Wolf et al. (2020) &lt;<a href="https://doi.org/10.1142%2F9789811215636_0063">doi:10.1142/9789811215636_0063</a>&gt; and 
    Gasdaska et al. (2019) &lt;<a href="https://doi.org/10.1142%2F9789813279827_0036">doi:10.1142/9789813279827_0036</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtools, Rdpack, stats</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, spelling</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jackmwolf/pcsstools/">https://github.com/jackmwolf/pcsstools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jackmwolf/pcsstools/issues">https://github.com/jackmwolf/pcsstools/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 00:52:25 UTC; Jack</td>
</tr>
<tr>
<td>Author:</td>
<td>Jack Wolf <a href="https://orcid.org/0000-0002-8919-8740"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  R Core Team and contributors worldwide [cph, aut] (Author and copyright
    holder of modified 'stats' fragments)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jack Wolf &lt;jackwolf910@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 04:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.pcsslm'>ANOVA for linear models fit using PCSS</h2><span id='topic+anova.pcsslm'></span><span id='topic+anova.pcsslmlist'></span>

<h3>Description</h3>

<p>Compute an analysis of variance table for one or more linear model fitted
using PCSS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcsslm'
anova(object, ...)

## S3 method for class 'pcsslmlist'
anova(object, ..., scale = 0, test = "F")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.pcsslm_+3A_object">object</code>, <code id="anova.pcsslm_+3A_...">...</code></td>
<td>
<p>objects of class <code>pcsslm</code>.</p>
</td></tr>
<tr><td><code id="anova.pcsslm_+3A_scale">scale</code></td>
<td>
<p>numeric. An estimate of the noise variance <code class="reqn">\sigma^2</code>. If 
zero this will be estimated from the largest model considered.</p>
</td></tr>
<tr><td><code id="anova.pcsslm_+3A_test">test</code></td>
<td>
<p>a character string specifying the test statistic to be used. Can 
be one of <code>"F"</code>, <code>"Chisq"</code> or <code>"Cp"</code>, with partial matching 
allowed, or <code>NULL</code> for no test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> inheriting from class 
<code>"data.frame"</code>.
</p>


<h3>Author(s)</h3>

<p>R Core Team and contributors worldwide. Modified by Jack Wolf
</p>

<hr>
<h2 id='approx_and'>Approximate a linear model for a series of logical AND statements</h2><span id='topic+approx_and'></span>

<h3>Description</h3>

<p><code>approx_and</code> approximates the linear model for the a conjunction
of m phenotypes as a function of a set of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_and(
  means,
  covs,
  n,
  predictors,
  add_intercept = TRUE,
  verbose = FALSE,
  response_assumption = "binary",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_and_+3A_means">means</code></td>
<td>
<p>vector of predictor and response means with the last <code>m</code>
means being the means of <code>m</code> binary responses to combine in a
logical and statement.</p>
</td></tr>
<tr><td><code id="approx_and_+3A_covs">covs</code></td>
<td>
<p>a matrix of the covariance of all model predictors and the
responses with the order of rows/columns corresponding to the order of
<code>means</code>.</p>
</td></tr>
<tr><td><code id="approx_and_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="approx_and_+3A_predictors">predictors</code></td>
<td>
<p>list of objects of class <code>predictor</code> corresponding
to the order of the predictors in <code>means</code>.</p>
</td></tr>
<tr><td><code id="approx_and_+3A_add_intercept">add_intercept</code></td>
<td>
<p>logical. Should the linear model add an intercept term?</p>
</td></tr>
<tr><td><code id="approx_and_+3A_verbose">verbose</code></td>
<td>
<p>should output be printed to console?</p>
</td></tr>
<tr><td><code id="approx_and_+3A_response_assumption">response_assumption</code></td>
<td>
<p>character. Either <code>"binary"</code> or
<code>"continuous"</code>. If <code>"binary"</code>, specific calculations will be done
to estimate product means and variances.</p>
</td></tr>
<tr><td><code id="approx_and_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Westra J, Tintle N (2021).
&ldquo;Using Summary Statistics to Model Multiplicative Combinations of Initially Analyzed Phenotypes With a Flexible Choice of Covariates.&rdquo;
<em>Frontiers in Genetics</em>, <b>12</b>, 1962.
ISSN 1664-8021, <a href="https://doi.org/10.3389/fgene.2021.745901">doi:10.3389/fgene.2021.745901</a>, <a href="https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full">https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full</a>.
</p>


<hr>
<h2 id='approx_conditional'>Approximate the mean of Y conditional on X</h2><span id='topic+approx_conditional'></span>

<h3>Description</h3>

<p>Approximate the mean of Y conditional on X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_conditional(means, covs, response, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_conditional_+3A_means">means</code></td>
<td>
<p>Vector of the mean of X and the mean of Y</p>
</td></tr>
<tr><td><code id="approx_conditional_+3A_covs">covs</code></td>
<td>
<p>Matrix of covariances for X and Y</p>
</td></tr>
<tr><td><code id="approx_conditional_+3A_response">response</code></td>
<td>
<p>Character. If &quot;binary&quot; truncates means to interval [0, 1].
If &quot;continuous&quot; does not restrict.</p>
</td></tr>
<tr><td><code id="approx_conditional_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2 consisting of 2 functions that give the
estimated conditional mean and conditional variance of Y as a function of X
</p>

<hr>
<h2 id='approx_mult_prod'>Approximate the covariance of a set of predictors and a product of responses</h2><span id='topic+approx_mult_prod'></span>

<h3>Description</h3>

<p><code>approx_mult_prod</code> recursively estimates the covariances and means of a
set of responses. Estimates are approximated using all unique response
orderings and aggregated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_mult_prod(
  means,
  covs,
  n,
  response,
  predictors,
  responses,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_mult_prod_+3A_means">means</code></td>
<td>
<p>a vector of predictor and response means with all response means
at the end of the vector.</p>
</td></tr>
<tr><td><code id="approx_mult_prod_+3A_covs">covs</code></td>
<td>
<p>covariance matrix of all predictors and responses with column
and row order corresponding to the order of <code>means</code>.</p>
</td></tr>
<tr><td><code id="approx_mult_prod_+3A_n">n</code></td>
<td>
<p>sample size (an integer).</p>
</td></tr>
<tr><td><code id="approx_mult_prod_+3A_response">response</code></td>
<td>
<p>a string. Currently supports <code>"binary"</code> or
<code>"continuous"</code>.</p>
</td></tr>
<tr><td><code id="approx_mult_prod_+3A_predictors">predictors</code>, <code id="approx_mult_prod_+3A_responses">responses</code></td>
<td>
<p>lists of objects of class <code>predictor</code> where
each entry corresponds to one predictor/response variable.</p>
</td></tr>
<tr><td><code id="approx_mult_prod_+3A_verbose">verbose</code></td>
<td>
<p>logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>means</code></td>
<td>
<p>a vector of the (approximated) means of all predictors 
and the product of responses</p>
</td></tr>
<tr><td><code>covs</code></td>
<td>
<p>a matrix of (approximated) covariances between all predictors
and the product of responses</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Westra J, Tintle N (2021).
&ldquo;Using Summary Statistics to Model Multiplicative Combinations of Initially Analyzed Phenotypes With a Flexible Choice of Covariates.&rdquo;
<em>Frontiers in Genetics</em>, <b>12</b>, 1962.
ISSN 1664-8021, <a href="https://doi.org/10.3389/fgene.2021.745901">doi:10.3389/fgene.2021.745901</a>, <a href="https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full">https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full</a>.
</p>


<hr>
<h2 id='approx_or'>Approximate a linear model for a series of logical OR statements</h2><span id='topic+approx_or'></span>

<h3>Description</h3>

<p><code>approx_or</code> approximates the linear model for a disjunction of m
phenotypes as a function of a set of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_or(
  means,
  covs,
  n,
  predictors,
  add_intercept = TRUE,
  verbose = FALSE,
  response_assumption = "binary",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_or_+3A_means">means</code></td>
<td>
<p>vector of predictor and response means with the last m
means being the means of m binary responses to combine in a
logical OR statement.</p>
</td></tr>
<tr><td><code id="approx_or_+3A_covs">covs</code></td>
<td>
<p>a matrix of the covariance of all model predictors and the
responses with the order of rows/columns corresponding to the order of
<code>means</code>.</p>
</td></tr>
<tr><td><code id="approx_or_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="approx_or_+3A_predictors">predictors</code></td>
<td>
<p>list of objects of class <code>predictor</code> corresponding
to the order of the predictors in <code>means</code>.</p>
</td></tr>
<tr><td><code id="approx_or_+3A_add_intercept">add_intercept</code></td>
<td>
<p>logical. Should the linear model add an intercept term?</p>
</td></tr>
<tr><td><code id="approx_or_+3A_verbose">verbose</code></td>
<td>
<p>should output be printed to console?</p>
</td></tr>
<tr><td><code id="approx_or_+3A_response_assumption">response_assumption</code></td>
<td>
<p>character. Either <code>"binary"</code> or
<code>"continuous"</code>. If <code>"binary"</code>, specific calculations will be done
to estimate product means and variances.</p>
</td></tr>
<tr><td><code id="approx_or_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Westra J, Tintle N (2021).
&ldquo;Using Summary Statistics to Model Multiplicative Combinations of Initially Analyzed Phenotypes With a Flexible Choice of Covariates.&rdquo;
<em>Frontiers in Genetics</em>, <b>12</b>, 1962.
ISSN 1664-8021, <a href="https://doi.org/10.3389/fgene.2021.745901">doi:10.3389/fgene.2021.745901</a>, <a href="https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full">https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full</a>.
</p>


<hr>
<h2 id='approx_prod_stats'>Approximate summary statistics for a product of phenotypes and a set of
predictors</h2><span id='topic+approx_prod_stats'></span>

<h3>Description</h3>

<p>Approximate summary statistics for a product of phenotypes and a set of
predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_prod_stats(means, covs, n, response, predictors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_prod_stats_+3A_means">means</code></td>
<td>
<p>Vector of means of predictors and the two phenotypes to be
multiplied</p>
</td></tr>
<tr><td><code id="approx_prod_stats_+3A_covs">covs</code></td>
<td>
<p>Covariance matrix of all predictors and the two phenotypes</p>
</td></tr>
<tr><td><code id="approx_prod_stats_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="approx_prod_stats_+3A_response">response</code></td>
<td>
<p>character. Either &quot;binary&quot; or &quot;continuous&quot;.</p>
</td></tr>
<tr><td><code id="approx_prod_stats_+3A_predictors">predictors</code></td>
<td>
<p>a list of elements of class predictor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the predicted covariance matrix of all predictors and
the product and the means of all predictors and the product.
</p>

<hr>
<h2 id='approx_response_cov_recursive'>Approximate the covariance of one response with an arbitrary product of
responses.</h2><span id='topic+approx_response_cov_recursive'></span>

<h3>Description</h3>

<p>Approximate the covariance of one response with an arbitrary product of
responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_response_cov_recursive(
  ids,
  r_covs,
  r_means,
  n,
  responses,
  response,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_response_cov_recursive_+3A_ids">ids</code></td>
<td>
<p>Column ids of responses to use. First is taken alone while 2nd to
last are to be multiplied</p>
</td></tr>
<tr><td><code id="approx_response_cov_recursive_+3A_r_covs">r_covs</code></td>
<td>
<p>Response covariance matrix</p>
</td></tr>
<tr><td><code id="approx_response_cov_recursive_+3A_r_means">r_means</code></td>
<td>
<p>Response means (vector)</p>
</td></tr>
<tr><td><code id="approx_response_cov_recursive_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="approx_response_cov_recursive_+3A_responses">responses</code></td>
<td>
<p>List of lists with elements of class predictor</p>
</td></tr>
<tr><td><code id="approx_response_cov_recursive_+3A_response">response</code></td>
<td>
<p>Character, Either &quot;binary&quot; or &quot;continuous&quot;</p>
</td></tr>
<tr><td><code id="approx_response_cov_recursive_+3A_verbose">verbose</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the approximated covariance, and approximated mean and
variance of the product
</p>

<hr>
<h2 id='calculate_lm'>Calculate a linear model using PCSS</h2><span id='topic+calculate_lm'></span>

<h3>Description</h3>

<p><code>calculate_lm</code> describes the linear model of the last listed variable
in <code>means</code> and <code>covs</code> as a function of all other variables in
<code>means</code> and <code>covs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_lm(
  means,
  covs,
  n,
  add_intercept = FALSE,
  keep_pcss = FALSE,
  terms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_lm_+3A_means">means</code></td>
<td>
<p>a vector of means of all model predictors and the response with
the last element the response mean.</p>
</td></tr>
<tr><td><code id="calculate_lm_+3A_covs">covs</code></td>
<td>
<p>a matrix of the covariance of all model predictors and the
response with the order of rows/columns corresponding to the order of
<code>means</code>.</p>
</td></tr>
<tr><td><code id="calculate_lm_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="calculate_lm_+3A_add_intercept">add_intercept</code></td>
<td>
<p>logical. If <code>TRUE</code> adds an intercept to the model.</p>
</td></tr>
<tr><td><code id="calculate_lm_+3A_keep_pcss">keep_pcss</code></td>
<td>
<p>logical. If <code>TRUE</code>, returns <code>means</code> and 
<code>covs</code>.</p>
</td></tr>
<tr><td><code id="calculate_lm_+3A_terms">terms</code></td>
<td>
<p>terms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Westra J, Tintle N (2021).
&ldquo;Using Summary Statistics to Model Multiplicative Combinations of Initially Analyzed Phenotypes With a Flexible Choice of Covariates.&rdquo;
<em>Frontiers in Genetics</em>, <b>12</b>, 1962.
ISSN 1664-8021, <a href="https://doi.org/10.3389/fgene.2021.745901">doi:10.3389/fgene.2021.745901</a>, <a href="https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full">https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full</a>.
</p>
<p>Wolf JM, Barnard M, Xia X, Ryder N, Westra J, Tintle N (2020).
&ldquo;Computationally efficient, exact, covariate-adjusted genetic principal component analysis by leveraging individual marker summary statistics from large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>25</b>, 719&ndash;730.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789811215636_0063">doi:10.1142/9789811215636_0063</a>, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/</a>.
</p>
<p>Gasdaska A, Friend D, Chen R, Westra J, Zawistowski M, Lindsey W, Tintle N (2019).
&ldquo;Leveraging summary statistics to make inferences about complex phenotypes in large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>24</b>, 391&ndash;402.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789813279827_0036">doi:10.1142/9789813279827_0036</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/30963077/">https://pubmed.ncbi.nlm.nih.gov/30963077/</a>.
</p>


<hr>
<h2 id='calculate_lm_combo'>Calculate a linear model for a linear combination of responses</h2><span id='topic+calculate_lm_combo'></span>

<h3>Description</h3>

<p><code>calculate_lm_combo</code> describes the linear model for a linear combination
of responses as a function of a set of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_lm_combo(means, covs, n, phi, m = length(phi), add_intercept, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_lm_combo_+3A_means">means</code></td>
<td>
<p>a vector of means of all model predictors and the response with
the last <code>m</code> elements the response means (with order corresponding to
the order of weights in <code>phi</code>).</p>
</td></tr>
<tr><td><code id="calculate_lm_combo_+3A_covs">covs</code></td>
<td>
<p>a matrix of the covariance of all model predictors and the
responses with the order of rows/columns corresponding to the order of
<code>means</code>.</p>
</td></tr>
<tr><td><code id="calculate_lm_combo_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="calculate_lm_combo_+3A_phi">phi</code></td>
<td>
<p>vector of linear combination weights with one entry per response
variable.</p>
</td></tr>
<tr><td><code id="calculate_lm_combo_+3A_m">m</code></td>
<td>
<p>number of responses to combine. Defaults to <code>length(weighs)</code>.</p>
</td></tr>
<tr><td><code id="calculate_lm_combo_+3A_add_intercept">add_intercept</code></td>
<td>
<p>logical. If <code>TRUE</code> adds an intercept to the model.</p>
</td></tr>
<tr><td><code id="calculate_lm_combo_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Barnard M, Xia X, Ryder N, Westra J, Tintle N (2020).
&ldquo;Computationally efficient, exact, covariate-adjusted genetic principal component analysis by leveraging individual marker summary statistics from large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>25</b>, 719&ndash;730.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789811215636_0063">doi:10.1142/9789811215636_0063</a>, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/</a>.
</p>
<p>Gasdaska A, Friend D, Chen R, Westra J, Zawistowski M, Lindsey W, Tintle N (2019).
&ldquo;Leveraging summary statistics to make inferences about complex phenotypes in large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>24</b>, 391&ndash;402.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789813279827_0036">doi:10.1142/9789813279827_0036</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/30963077/">https://pubmed.ncbi.nlm.nih.gov/30963077/</a>.
</p>


<hr>
<h2 id='check_terms'>Check that independent and dependent variables are accounted for through PCSS</h2><span id='topic+check_terms'></span>

<h3>Description</h3>

<p>Check that independent and dependent variables are accounted for through PCSS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_terms(xterms, yterms, pcssterms, pcsstype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_terms_+3A_xterms">xterms</code>, <code id="check_terms_+3A_yterms">yterms</code></td>
<td>
<p>character vector of model's independent variables or
variables combined to the dependent variable</p>
</td></tr>
<tr><td><code id="check_terms_+3A_pcssterms">pcssterms</code></td>
<td>
<p>character vector of variables with provided PCSS</p>
</td></tr>
<tr><td><code id="check_terms_+3A_pcsstype">pcsstype</code></td>
<td>
<p>character describing the PCSS being checked. Either
<code>"means"</code>, <code>"covs"</code>, <code>"predictors"</code>, or
<code>"responses"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='extract_predictors'>Extract independent variables from a formula</h2><span id='topic+extract_predictors'></span>

<h3>Description</h3>

<p>Extract independent variables from a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_predictors(formula = formula())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_predictors_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a character vector of all predictors and a logical
value indicating whether the model includes an intercept term.
</p>

<hr>
<h2 id='extract_response'>Extract dependent variables from a formula as a string</h2><span id='topic+extract_response'></span>

<h3>Description</h3>

<p>Extract dependent variables from a formula as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_response(formula = formula())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_response_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of all responses
</p>

<hr>
<h2 id='get_pcor'>Approximate the partial correlation of Y and Z given X</h2><span id='topic+get_pcor'></span>

<h3>Description</h3>

<p>Approximate the partial correlation of Y and Z given X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pcor(covs, cors = cov2cor(covs))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pcor_+3A_covs">covs</code></td>
<td>
<p>Covariance matrix of X, Y, and Z.</p>
</td></tr>
<tr><td><code id="get_pcor_+3A_cors">cors</code></td>
<td>
<p>Correlation matrix of X, Y, and Z.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Approximated partial correlation of the later two terms given the 
first
</p>

<hr>
<h2 id='guess_response'>Guess the function that is applied to a set of responses</h2><span id='topic+guess_response'></span>

<h3>Description</h3>

<p><code>guess_response</code> takes a character vector of the dependent variable
from a <code>formula</code> object and identifies which function separates the
individual variables that make up the response. It then returns the
<code>model_*</code> function to model the appropriate response using PCSS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_response(response = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_response_+3A_response">response</code></td>
<td>
<p>character. Output of <code>extract_response</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character. Either <code>"model_combo"</code>, <code>"model_product"</code>, 
<code>"model_or"</code>, <code>"model_and"</code>, or <code>"model_singular"</code>.
</p>

<hr>
<h2 id='make_permutations'>List all permutations of a sequence of integers</h2><span id='topic+make_permutations'></span>

<h3>Description</h3>

<p>Lists all permutations of 1,2,...,m unique up to the first two elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_permutations(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_permutations_+3A_m">m</code></td>
<td>
<p>number of elements to permute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of permutations of 1,2,...,m.
</p>

<hr>
<h2 id='model_and'>Approximate a linear model for a series of logical AND statements using PCSS</h2><span id='topic+model_and'></span>

<h3>Description</h3>

<p><code>model_and</code> approximates the linear model for the conjunction
of m phenotypes as a function of a set of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_and(formula, n, means, covs, predictors, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_and_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> whose dependent variable is
a combination of variables and logical <code>&amp;</code> operators. All model terms
must be accounted for in <code>means</code> and <code>covs</code>.</p>
</td></tr>
<tr><td><code id="model_and_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="model_and_+3A_means">means</code></td>
<td>
<p>named vector of predictor and response means.</p>
</td></tr>
<tr><td><code id="model_and_+3A_covs">covs</code></td>
<td>
<p>named matrix of the covariance of all model predictors and the
responses.</p>
</td></tr>
<tr><td><code id="model_and_+3A_predictors">predictors</code></td>
<td>
<p>named list of objects of class <code>predictor</code>.</p>
</td></tr>
<tr><td><code id="model_and_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Westra J, Tintle N (2021).
&ldquo;Using Summary Statistics to Model Multiplicative Combinations of Initially Analyzed Phenotypes With a Flexible Choice of Covariates.&rdquo;
<em>Frontiers in Genetics</em>, <b>12</b>, 1962.
ISSN 1664-8021, <a href="https://doi.org/10.3389/fgene.2021.745901">doi:10.3389/fgene.2021.745901</a>, <a href="https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full">https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full</a>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ex_data &lt;- pcsstools_example[c("g1", "x1", "y4", "y5")]
head(ex_data)
means &lt;- colMeans(ex_data)
covs &lt;- cov(ex_data)
n &lt;- nrow(ex_data)
predictors &lt;- list(
  g1 = new_predictor_snp(maf = mean(ex_data$g1) / 2),
  x1 = new_predictor_normal(mean = mean(ex_data$x1), sd = sd(ex_data$x1))
)

model_and(
  y4 &amp; y5 ~ g1 + x1,
  means = means, covs = covs, n = n, predictors = predictors
)
summary(lm(y4 &amp; y5 ~ g1 + x1, data = ex_data))
</code></pre>

<hr>
<h2 id='model_combo'>Model a linear combination of a set of phenotypes using PCSS</h2><span id='topic+model_combo'></span>

<h3>Description</h3>

<p><code>model_combo</code> calculates the linear model for a linear combination of
phenotypes as a function of a set of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_combo(formula, phi, n, means, covs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_combo_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> whose dependent variable is
a series of variables joined by <code>+</code> operators. <code>model_combo</code>
will treat a principal component score of those variables as the actual
dependent variable. All model terms must be accounted for in <code>means</code>
and <code>covs</code>.</p>
</td></tr>
<tr><td><code id="model_combo_+3A_phi">phi</code></td>
<td>
<p>named vector of linear weights for each variable in the
dependent variable in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="model_combo_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="model_combo_+3A_means">means</code></td>
<td>
<p>named vector of predictor and response means.</p>
</td></tr>
<tr><td><code id="model_combo_+3A_covs">covs</code></td>
<td>
<p>named matrix of the covariance of all model predictors and the
responses.</p>
</td></tr>
<tr><td><code id="model_combo_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Barnard M, Xia X, Ryder N, Westra J, Tintle N (2020).
&ldquo;Computationally efficient, exact, covariate-adjusted genetic principal component analysis by leveraging individual marker summary statistics from large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>25</b>, 719&ndash;730.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789811215636_0063">doi:10.1142/9789811215636_0063</a>, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/</a>.
</p>
<p>Gasdaska A, Friend D, Chen R, Westra J, Zawistowski M, Lindsey W, Tintle N (2019).
&ldquo;Leveraging summary statistics to make inferences about complex phenotypes in large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>24</b>, 391&ndash;402.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789813279827_0036">doi:10.1142/9789813279827_0036</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/30963077/">https://pubmed.ncbi.nlm.nih.gov/30963077/</a>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ex_data &lt;- pcsstools_example[c("g1", "x1", "x2", "x3", "y1", "y2", "y3")]
head(ex_data)
means &lt;- colMeans(ex_data)
covs &lt;- cov(ex_data)
n &lt;- nrow(ex_data)
phi &lt;- c("y1" = 1, "y2" = -1, "y3" = 0.5)

model_combo(
  y1 + y2 + y3 ~ g1 + x1 + x2 + x3, 
  phi = phi, n = n, means = means, covs = covs
)

summary(lm(y1 - y2 + 0.5 * y3 ~ g1 + x1 + x2 + x3, data = ex_data))
</code></pre>

<hr>
<h2 id='model_or'>Approximate a linear model for a series of logical OR statements using PCSS</h2><span id='topic+model_or'></span>

<h3>Description</h3>

<p><code>model_or</code> approximates the linear model for the a disjunction
of m phenotypes as a function of a set of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_or(formula, n, means, covs, predictors, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_or_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> whose dependent variable is
a combination of variables and logical <code>|</code> operators. All model terms
must be accounted for in <code>means</code> and <code>covs</code>.</p>
</td></tr>
<tr><td><code id="model_or_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="model_or_+3A_means">means</code></td>
<td>
<p>named vector of predictor and response means.</p>
</td></tr>
<tr><td><code id="model_or_+3A_covs">covs</code></td>
<td>
<p>named matrix of the covariance of all model predictors and the
responses.</p>
</td></tr>
<tr><td><code id="model_or_+3A_predictors">predictors</code></td>
<td>
<p>named list of objects of class <code>predictor</code>.</p>
</td></tr>
<tr><td><code id="model_or_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Westra J, Tintle N (2021).
&ldquo;Using Summary Statistics to Model Multiplicative Combinations of Initially Analyzed Phenotypes With a Flexible Choice of Covariates.&rdquo;
<em>Frontiers in Genetics</em>, <b>12</b>, 1962.
ISSN 1664-8021, <a href="https://doi.org/10.3389/fgene.2021.745901">doi:10.3389/fgene.2021.745901</a>, <a href="https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full">https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full</a>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ex_data &lt;- pcsstools_example[c("g1", "x1", "y4", "y5")]
head(ex_data)
means &lt;- colMeans(ex_data)
covs &lt;- cov(ex_data)
n &lt;- nrow(ex_data)
predictors &lt;- list(
  g1 = new_predictor_snp(maf = mean(ex_data$g1) / 2),
  x1 = new_predictor_normal(mean = mean(ex_data$x1), sd = sd(ex_data$x1))
)

model_or(
  y4 | y5 ~ g1 + x1,
  means = means, covs = covs, n = n, predictors = predictors
)
summary(lm(y4 | y5 ~ g1 + x1, data = ex_data))
</code></pre>

<hr>
<h2 id='model_prcomp'>Model the principal component score of a set of phenotypes using PCSS</h2><span id='topic+model_prcomp'></span>

<h3>Description</h3>

<p><code>model_prcomp</code> calculates the linear model for the mth principal
component score of a set of phenotypes as a function of a set of
predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_prcomp(
  formula,
  comp = 1,
  n,
  means,
  covs,
  center = FALSE,
  standardize = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_prcomp_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> whose dependent variable is
a series of variables joined by <code>+</code> operators. <code>model_prcomp</code>
will treat a principal component score of those variables as the actual
dependent variable. All model terms must be accounted for in <code>means</code>
and <code>covs</code>.</p>
</td></tr>
<tr><td><code id="model_prcomp_+3A_comp">comp</code></td>
<td>
<p>integer indicating which principal component score to analyze.
Must be less than or equal to the total number of phenotypes.</p>
</td></tr>
<tr><td><code id="model_prcomp_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="model_prcomp_+3A_means">means</code></td>
<td>
<p>named vector of predictor and response means.</p>
</td></tr>
<tr><td><code id="model_prcomp_+3A_covs">covs</code></td>
<td>
<p>named matrix of the covariance of all model predictors and the
responses.</p>
</td></tr>
<tr><td><code id="model_prcomp_+3A_center">center</code></td>
<td>
<p>logical. Should the dependent variables be centered before
principal components are calculated?</p>
</td></tr>
<tr><td><code id="model_prcomp_+3A_standardize">standardize</code></td>
<td>
<p>logical. Should the dependent variables be standardized 
before principal components are calculated?</p>
</td></tr>
<tr><td><code id="model_prcomp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Barnard M, Xia X, Ryder N, Westra J, Tintle N (2020).
&ldquo;Computationally efficient, exact, covariate-adjusted genetic principal component analysis by leveraging individual marker summary statistics from large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>25</b>, 719&ndash;730.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789811215636_0063">doi:10.1142/9789811215636_0063</a>, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/</a>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ex_data &lt;- pcsstools_example[c("g1", "x1", "x2", "y1", "y2", "y3")]
head(ex_data)
means &lt;- colMeans(ex_data)
covs &lt;- cov(ex_data)
n &lt;- nrow(ex_data)

model_prcomp(
  y1 + y2 + y3 ~ g1 + x1 + x2,
  comp = 1, n = n, means = means, covs = covs
)
</code></pre>

<hr>
<h2 id='model_product'>Approximate a linear model for a product using PCSS</h2><span id='topic+model_product'></span>

<h3>Description</h3>

<p><code>model_product</code> approximates the linear model for the product
of m phenotypes as a function of a set of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_product(
  formula,
  n,
  means,
  covs,
  predictors,
  responses = NULL,
  response = "continuous",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_product_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> whose dependent variable is
a combination of variables and  <code>*</code> operators. All model terms
must be accounted for in <code>means</code> and <code>covs</code>.</p>
</td></tr>
<tr><td><code id="model_product_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="model_product_+3A_means">means</code></td>
<td>
<p>named vector of predictor and response means.</p>
</td></tr>
<tr><td><code id="model_product_+3A_covs">covs</code></td>
<td>
<p>named matrix of the covariance of all model predictors and the
responses.</p>
</td></tr>
<tr><td><code id="model_product_+3A_predictors">predictors</code></td>
<td>
<p>named list of objects of class <code>predictor</code></p>
</td></tr>
<tr><td><code id="model_product_+3A_responses">responses</code></td>
<td>
<p>named list of objects of class <code>predictor</code>
corresponding to all terms being multiplied in the response. Can be
left <code>NULL</code> if only multiplying two terms</p>
</td></tr>
<tr><td><code id="model_product_+3A_response">response</code></td>
<td>
<p>character. Describe distribution of all product terms.
Either <code>"continuous"</code> or <code>"binary"</code>. If <code>"binary"</code>
different approximations of product means and variances are used.</p>
</td></tr>
<tr><td><code id="model_product_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Westra J, Tintle N (2021).
&ldquo;Using Summary Statistics to Model Multiplicative Combinations of Initially Analyzed Phenotypes With a Flexible Choice of Covariates.&rdquo;
<em>Frontiers in Genetics</em>, <b>12</b>, 1962.
ISSN 1664-8021, <a href="https://doi.org/10.3389/fgene.2021.745901">doi:10.3389/fgene.2021.745901</a>, <a href="https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full">https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full</a>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ex_data &lt;- pcsstools_example[c("g1", "g2", "g3", "x1", "y4", "y5", "y6")]
head(ex_data)
means &lt;- colMeans(ex_data)
covs &lt;- cov(ex_data)
n &lt;- nrow(ex_data)
predictors &lt;- list(
  g1 = new_predictor_snp(maf = mean(ex_data$g1) / 2),
  g2 = new_predictor_snp(maf = mean(ex_data$g2) / 2),
  g3 = new_predictor_snp(maf = mean(ex_data$g3) / 2),
  x1 = new_predictor_normal(mean = mean(ex_data$x1), sd = sd(ex_data$x1))
)
responses &lt;- lapply(means[c("y4", "y5", "y6")], new_predictor_binary)

model_product(
  y4 * y5 * y6 ~ g1 + g2 + g3 + x1,
  means = means, covs = covs, n = n,
  predictors = predictors, responses = responses, response = "binary"
)

summary(lm(y4 * y5 * y6 ~ g1 + g2 + g3 + x1, data = ex_data))
</code></pre>

<hr>
<h2 id='model_singular'>Model an individual phenotype using PCSS</h2><span id='topic+model_singular'></span>

<h3>Description</h3>

<p><code>model_singular</code> calculates the linear model for a singular
phenotype as a function of a set of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_singular(formula, n, means, covs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_singular_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> whose dependent variable is
only variable. All model terms must be accounted for in <code>means</code>
and <code>covs</code>.</p>
</td></tr>
<tr><td><code id="model_singular_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="model_singular_+3A_means">means</code></td>
<td>
<p>named vector of predictor and response means.</p>
</td></tr>
<tr><td><code id="model_singular_+3A_covs">covs</code></td>
<td>
<p>named matrix of the covariance of all model predictors and the
responses.</p>
</td></tr>
<tr><td><code id="model_singular_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Barnard M, Xia X, Ryder N, Westra J, Tintle N (2020).
&ldquo;Computationally efficient, exact, covariate-adjusted genetic principal component analysis by leveraging individual marker summary statistics from large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>25</b>, 719&ndash;730.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789811215636_0063">doi:10.1142/9789811215636_0063</a>, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/</a>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ex_data &lt;- pcsstools_example[c("g1", "x1", "y1")]
means &lt;- colMeans(ex_data)
covs &lt;- cov(ex_data)
n &lt;- nrow(ex_data)

model_singular(
  y1 ~ g1 + x1,
  n = n, means = means, covs = covs
)
summary(lm(y1 ~ g1 + x1, data = ex_data))
</code></pre>

<hr>
<h2 id='new_predictor'>Create an object of class &quot;predictor&quot;</h2><span id='topic+new_predictor'></span>

<h3>Description</h3>

<p>Create an object of class &quot;predictor&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_predictor(
  f = function() {
 },
  predictor_type = character(),
  lb,
  ub,
  support
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_predictor_+3A_f">f</code></td>
<td>
<p>a function that gives the probability mass/distribution function of
a random variable.</p>
</td></tr>
<tr><td><code id="new_predictor_+3A_predictor_type">predictor_type</code></td>
<td>
<p>a character describing the random variable. Either 
&quot;discrete&quot; or &quot;continuous&quot;.</p>
</td></tr>
<tr><td><code id="new_predictor_+3A_lb">lb</code>, <code id="new_predictor_+3A_ub">ub</code></td>
<td>
<p>if <code>predictor_type == "continuous"</code> double giving the
lower/upper bound of the pdf <code>f</code>.</p>
</td></tr>
<tr><td><code id="new_predictor_+3A_support">support</code></td>
<td>
<p>if <code>predictor_type == "discrete"</code> vector of the support 
of the pmf for <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"predictor"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_predictor_normal">new_predictor_normal</a></code>,
<code><a href="#topic+new_predictor_snp">new_predictor_snp</a></code> and <code><a href="#topic+new_predictor_binary">new_predictor_binary</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_predictor(
  f = function(x0) dnorm(x0, mean = 0, sd = 1),
  predictor_type = "continuous", lb = -Inf, ub = Inf
)
</code></pre>

<hr>
<h2 id='new_predictor_binary'>Shortcut to create a predictor object for a binary variable</h2><span id='topic+new_predictor_binary'></span>

<h3>Description</h3>

<p><code>new_predictor_binary</code> calls <code>new_predictor</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_predictor_binary(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_predictor_binary_+3A_p">p</code></td>
<td>
<p>probability of success (predictor mean)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"predictor"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_predictor_binary(p = 0.75)
</code></pre>

<hr>
<h2 id='new_predictor_normal'>Shortcut to create a predictor object for a continuous variable</h2><span id='topic+new_predictor_normal'></span>

<h3>Description</h3>

<p><code>new_predictor_normal</code> calls <code>new_predictor</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_predictor_normal(mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_predictor_normal_+3A_mean">mean</code></td>
<td>
<p>predictor mean (double).</p>
</td></tr>
<tr><td><code id="new_predictor_normal_+3A_sd">sd</code></td>
<td>
<p>predictor standard deviation (double)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"predictor"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_predictor_normal(mean = 10, sd = 1)
</code></pre>

<hr>
<h2 id='new_predictor_snp'>Shortcut to create a predictor object for a SNP's minor allele counts</h2><span id='topic+new_predictor_snp'></span>

<h3>Description</h3>

<p><code>new_predictor_snp</code> calls <code>new_predictor</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_predictor_snp(maf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_predictor_snp_+3A_maf">maf</code></td>
<td>
<p>minor allele frequency</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"predictor"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_predictor_snp(maf = 0.3)
</code></pre>

<hr>
<h2 id='pcsslm'>Approximate a linear model using PCSS</h2><span id='topic+pcsslm'></span>

<h3>Description</h3>

<p><code>pcsslm</code> approximates a linear model of a combination of variables using
precomputed summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcsslm(formula, pcss = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcsslm_+3A_formula">formula</code></td>
<td>
<p>an object of class formula whose dependent variable is a 
combination of variables and logical | operators. 
All model terms must have appropriate PCSS in <code>pcss</code>.</p>
</td></tr>
<tr><td><code id="pcsslm_+3A_pcss">pcss</code></td>
<td>
<p>a list of precomputed summary statistics. In all cases, this
should include <code>n</code>: the sample size, <code>means</code>: a named vector of
predictor and response means, and <code>covs</code>: a named covariance matrix
including all predictors and responses. See Details for more information.</p>
</td></tr>
<tr><td><code id="pcsslm_+3A_...">...</code></td>
<td>
<p>additional arguments. See Details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pcsslm</code> parses the input <code>formula</code>'s dependent variable for 
functions such as sums (<code>+</code>), products (<code>*</code>), or logical 
operators (<code>|</code> and <code>&amp;</code>).
It then identifies models the combination of variables using one of
<code><a href="#topic+model_combo">model_combo</a></code>, <code><a href="#topic+model_product">model_product</a></code>, 
<code><a href="#topic+model_or">model_or</a></code>, <code><a href="#topic+model_and">model_and</a></code>, or 
<code><a href="#topic+model_prcomp">model_prcomp</a></code>.
</p>
<p>Different precomputed summary statistics are needed inside <code>pcss</code>
depending on the function that combines the dependent variable.
</p>

<ul>
<li><p> For linear combinations (and principal component analysis), only
<code>n</code>, <code>means</code>, and <code>covs</code> are required
</p>
</li>
<li><p> For products and logical combinations, the additional items
<code>predictors</code> and <code>responses</code> are required.
These are named lists of objects of class <code>predictor</code>
generated by <code><a href="#topic+new_predictor">new_predictor</a></code>, with a <code>predictor</code>
object for each independent variable in <code>predictors</code> and
each dependent variable in <code>responses</code>.
However, if only modeling the product or logical combination of 
only two variables, <code>responses</code> can be <code>NULL</code> without
consequence.
</p>
</li></ul>

<p>If modeling a principal component score of a set of variables, include 
the argument <code>comp</code> where <code>comp</code> is an integer indicating which 
principal component score to analyze. Optional logical arguments 
<code>center</code> and <code>standardize</code> determine if responses should be
centered and standardized before principal components are calculated. 
</p>
<p>If modeling a linear combination, include the argument <code>phi</code>, a named
vector of linear weights for each variable in the dependent variable in 
formula.
</p>
<p>If modeling a product, include the argument <code>response</code>, a character
equal to either <code>"continuous"</code> or <code>"binary"</code>. If <code>"binary"</code>,
specialized approximations are performed to estimate means and variances.
</p>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wolf JM, Westra J, Tintle N (2021).
&ldquo;Using Summary Statistics to Model Multiplicative Combinations of Initially Analyzed Phenotypes With a Flexible Choice of Covariates.&rdquo;
<em>Frontiers in Genetics</em>, <b>12</b>, 1962.
ISSN 1664-8021, <a href="https://doi.org/10.3389/fgene.2021.745901">doi:10.3389/fgene.2021.745901</a>, <a href="https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full">https://www.frontiersin.org/articles/10.3389/fgene.2021.745901/full</a>.
</p>
<p>Wolf JM, Barnard M, Xia X, Ryder N, Westra J, Tintle N (2020).
&ldquo;Computationally efficient, exact, covariate-adjusted genetic principal component analysis by leveraging individual marker summary statistics from large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>25</b>, 719&ndash;730.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789811215636_0063">doi:10.1142/9789811215636_0063</a>, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6907735/</a>.
</p>
<p>Gasdaska A, Friend D, Chen R, Westra J, Zawistowski M, Lindsey W, Tintle N (2019).
&ldquo;Leveraging summary statistics to make inferences about complex phenotypes in large biobanks.&rdquo;
<em>Pacific Symposium on Biocomputing</em>, <b>24</b>, 391&ndash;402.
ISSN 2335-6928, <a href="https://doi.org/10.1142/9789813279827_0036">doi:10.1142/9789813279827_0036</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/30963077/">https://pubmed.ncbi.nlm.nih.gov/30963077/</a>.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+model_combo">model_combo</a></code>, <code><a href="#topic+model_product">model_product</a></code>, 
<code><a href="#topic+model_or">model_or</a></code>, <code><a href="#topic+model_and">model_and</a></code>, and 
<code><a href="#topic+model_prcomp">model_prcomp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Principal Component Analysis
ex_data &lt;- pcsstools_example[c("g1", "x1", "y1", "y2", "y3")]
pcss &lt;- list(
  means = colMeans(ex_data),
  covs = cov(ex_data),
  n = nrow(ex_data)
)

pcsslm(y1 + y2 + y3 ~ g1 + x1, pcss = pcss, comp = 1)

## Linear combination of variables
ex_data &lt;- pcsstools_example[c("g1", "g2", "y1", "y2")]
pcss &lt;- list(
  means = colMeans(ex_data),
  covs = cov(ex_data),
  n = nrow(ex_data)
)

pcsslm(y1 + y2 ~ g1 + g2, pcss = pcss, phi = c(1, -1))
summary(lm(y1 - y2 ~ g1 + g2, data = ex_data))

## Product of variables
ex_data &lt;- pcsstools_example[c("g1", "x1", "y4", "y5", "y6")]

pcss &lt;- list(
  means = colMeans(ex_data),
  covs = cov(ex_data),
  n = nrow(ex_data),
  predictors = list(
    g1 = new_predictor_snp(maf = mean(ex_data$g1) / 2),
    x1 = new_predictor_normal(mean = mean(ex_data$x1), sd = sd(ex_data$x1))
  ),
  responses = lapply(
    colMeans(ex_data)[3:length(colMeans(ex_data))], 
    new_predictor_binary
  )
)

pcsslm(y4 * y5 * y6 ~ g1 + x1, pcss = pcss, response = "binary")
summary(lm(y4 * y5 * y6 ~ g1 + x1, data = ex_data))

## Disjunct (OR statement) of variables
ex_data &lt;- pcsstools_example[c("g1", "x1", "y4", "y5")]

pcss &lt;- list(
  means = colMeans(ex_data),
  covs = cov(ex_data),
  n = nrow(ex_data),
  predictors = list(
    g1 = new_predictor_snp(maf = mean(ex_data$g1) / 2),
    x1 = new_predictor_normal(mean = mean(ex_data$x1), sd = sd(ex_data$x1))
  )
)
pcsslm(y4 | y5 ~ g1 + x1, pcss = pcss) 
summary(lm(y4 | y5 ~ g1 + x1, data = ex_data))

</code></pre>

<hr>
<h2 id='pcsstools_example'>Simulated example data</h2><span id='topic+pcsstools_example'></span>

<h3>Description</h3>

<p>A dataset containing simulated genetic data with 3 SNPs, 3 continuous 
covariates, and 6 continuous phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcsstools_example
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 12 columns:
</p>

<dl>
<dt>g1,g2,g3</dt><dd><p>Minor allele counts at three sites</p>
</dd>
<dt>x1,x2,x3</dt><dd><p>Continuous covariates</p>
</dd>
<dt>y1,y2,y3</dt><dd><p>Continuous phenotypes</p>
</dd>
<dt>y4,y5,y6</dt><dd><p>Binary phenotypes</p>
</dd>
</dl>


<hr>
<h2 id='print.pcsslm'>Print an object of class pcsslm</h2><span id='topic+print.pcsslm'></span>

<h3>Description</h3>

<p>Prints a linear model fit through pre-computed summary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcsslm'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  symbolic.cor = x$symbolic.cor,
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pcsslm_+3A_x">x</code></td>
<td>
<p>an object of class <code>"pcsslm"</code></p>
</td></tr>
<tr><td><code id="print.pcsslm_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="print.pcsslm_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the correlations in a 
symbolic form (see <a href="stats.html#topic+symnum">symnum</a>) rather than as numbers.</p>
</td></tr>
<tr><td><code id="print.pcsslm_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, 'significance stars' are printed
for each coefficient.</p>
</td></tr>
<tr><td><code id="print.pcsslm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pcsslm"</code>.
</p>
<p>An object of class <code>"pcsslm"</code> is a list containing at least the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p x 4</code> matrix with columns for the 
estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">p, n-p, p*</code>, the
first being the number of non-aliased coefficients, the last being
the total number of coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>a 3-vector with the value of the F-statistic with its
numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the 'fraction of variance explained by the 
model'.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic <em>'adjusted'</em>,
penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p x p</code> matrix of (unscaled) covariances of the
<code class="reqn">coef[j], j=1,...p</code>.</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>a 3-vector with the model's Sum of Squares Regression 
(SSR), Sum of Squares Error (SSE), and Sum of Squares Total (SST).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>R Core Team and contributors worldwide. Modified by Jack Wolf
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
