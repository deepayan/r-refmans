<!DOCTYPE html><html><head><title>Help for package refineR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {refineR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addGrid'><p>Add a grid to an existing plot.</p></a></li>
<li><a href='#as.rgb'><p>Convert color-names or RGB-code to possibly semi-transparent RGB-code.</p></a></li>
<li><a href='#ashDensity'><p>Estimate density of distribution employing the R package &quot;ash&quot; using R-wrapper function.</p></a></li>
<li><a href='#BoxCox'><p>One-parameter Box-Cox transformation.</p></a></li>
<li><a href='#calculateCostHist'><p>Calculate costs for a specific combinations of lambda, muVec and sigmaVec.</p></a></li>
<li><a href='#defineSearchRegions'><p>Helper function to define search regions for mu and sigma and to get the region around the main peak 'ab'</p></a></li>
<li><a href='#estimateAB'><p>Helper function to find region around the main peak of a distribution</p></a></li>
<li><a href='#findMainPeak'><p>Helper function to find the main peak of a distribution</p></a></li>
<li><a href='#findPeaksAndValleys'><p>Find the index of the peaks and valleys of the density estimation.</p></a></li>
<li><a href='#findRI'><p>Function to estimate reference intervals for a single population</p></a></li>
<li><a href='#findRoundingBase'><p>Estimate rounding base of the input data.</p></a></li>
<li><a href='#generateHistData'><p>Generate list with histogram data.</p></a></li>
<li><a href='#getRI'><p>Method to calculate reference intervals (percentiles) for objects of class 'RWDRI'</p></a></li>
<li><a href='#getSumForPArea'><p>Helper function to calculate the amount of observed and estimated data points within specified regions around the peak.</p></a></li>
<li><a href='#invBoxCox'><p>Inverse of the one-parameter Box-Cox transformation.</p></a></li>
<li><a href='#optimizeGrid'><p>Helper function for grid search for mu and sigma.</p></a></li>
<li><a href='#plot.RWDRI'><p>Standard plot method for objects of class 'RWDRI'</p></a></li>
<li><a href='#pnormApprox'><p>Approximate calculation of CDF of normal distribution.</p></a></li>
<li><a href='#print.RWDRI'><p>Standard print method for objects of class 'RWDRI'</p></a></li>
<li><a href='#refineR-package'><p>refineR: Reference Interval Estimation using Real-World Data (RWD)</p></a></li>
<li><a href='#testcase1'><p>Simulated Testcase 1.</p></a></li>
<li><a href='#testcase2'><p>Simulated Testcase 2.</p></a></li>
<li><a href='#testcase3'><p>Simulated Testcase 3.</p></a></li>
<li><a href='#testcase4'><p>Simulated Testcase 4.</p></a></li>
<li><a href='#testcase5'><p>Simulated Testcase 5.</p></a></li>
<li><a href='#testParam'><p>Helper function to find optimal parameters lambda, mu and sigma.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Reference Interval Estimation using Real-World Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Tatjana Ammer [aut, cre],
  Christopher M Rank [aut],
  Andre Schuetzenmeister [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tatjana Ammer &lt;tatjana.ammer@roche.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ash, future, future.apply, parallel, graphics,
grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Indirect method for the estimation of reference intervals using 
	Real-World Data ('RWD'). It takes routine measurements of diagnostic 
	tests, containing pathological and non-pathological samples as input 
	and uses sophisticated statistical methods to derive a model describing 
	the distribution of the non-pathological samples. This distribution can 
	then be used to derive reference intervals. Furthermore, the package 
	offers functions for printing and plotting the results of the algorithm. 
	See ?refineR for a more comprehensive description of the features. 
	Version 1.0 of the algorithm is described in detail in 'Ammer et al. (2021)' 
	&lt;<a href="https://doi.org/10.1038%2Fs41598-021-95301-2">doi:10.1038/s41598-021-95301-2</a>&gt;. Additional guidance on the usage of 
	the algorithm is given in 'Ammer et al. (2023)' &lt;<a href="https://doi.org/10.1093%2Fjalm%2Fjfac101">doi:10.1093/jalm/jfac101</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-13 15:11:04 UTC; rankc</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-14 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addGrid'>Add a grid to an existing plot.</h2><span id='topic+addGrid'></span>

<h3>Description</h3>

<p>It is possible to use automatically determined grid lines (<code>x=NULL, y=NULL</code>) or specifying the number 
of cells <code>x = 3, y = 4</code> as done by <code>grid</code>. Additionally, x- and y-locations of grid-lines can be specified,
e.g. <code>x = 1:10, y = seq(0,10,2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addGrid(x = NULL, y = NULL, col = "lightgray", lwd = 1L, lty = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addGrid_+3A_x">x</code></td>
<td>
<p>(integer, numeric) single integer specifies number of cells, numeric vector specifies vertical grid-lines</p>
</td></tr>
<tr><td><code id="addGrid_+3A_y">y</code></td>
<td>
<p>(integer, numeric) single integer specifies number of cells, numeric vector specifies horizontal grid-lines</p>
</td></tr>
<tr><td><code id="addGrid_+3A_col">col</code></td>
<td>
<p>(character) color of grid-lines</p>
</td></tr>
<tr><td><code id="addGrid_+3A_lwd">lwd</code></td>
<td>
<p>(integer) line width of grid-lines</p>
</td></tr>
<tr><td><code id="addGrid_+3A_lty">lty</code></td>
<td>
<p>(integer) line type of grid-lines</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>

<hr>
<h2 id='as.rgb'>Convert color-names or RGB-code to possibly semi-transparent RGB-code.</h2><span id='topic+as.rgb'></span>

<h3>Description</h3>

<p>Function takes the name of a color and converts it into the rgb space. Parameter &quot;alpha&quot; allows
to specify the transparency within [0,1], 0 meaning completey transparent and 1 meaning completey
opaque. If an RGB-code is provided and alpha != 1, the RGB-code of the transparency adapted color 
will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.rgb(col = "black", alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.rgb_+3A_col">col</code></td>
<td>
<p>(character) name of the color to be converted/transformed into RGB-space (code). Only
those colors can be used which are part of the set returned by function colors(). Defaults
to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="as.rgb_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) value specifying the transparency to be used, 0 = completely transparent, 
1 = opaque.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGB-code
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# convert character string representing a color to RGB-code using alpha-channel of .25 (75\
     as.rgb("red", alpha = .25)

# same thing now using the RGB-code of red (alpha=1, i.e. as.rgb("red"))
     as.rgb("#FF0000FF", alpha = .25)

## End(Not run)
</code></pre>

<hr>
<h2 id='ashDensity'>Estimate density of distribution employing the R package &quot;ash&quot; using R-wrapper function.</h2><span id='topic+ashDensity'></span>

<h3>Description</h3>

<p>Estimate density of distribution employing the R package &quot;ash&quot; using R-wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ashDensity(x, ab, nbin, m, kopt = c(2, 1), normToAB = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ashDensity_+3A_x">x</code></td>
<td>
<p>(numeric) vector of data points</p>
</td></tr>
<tr><td><code id="ashDensity_+3A_ab">ab</code></td>
<td>
<p>(numeric) vector of lower and higher truncation limit of density estimation</p>
</td></tr>
<tr><td><code id="ashDensity_+3A_nbin">nbin</code></td>
<td>
<p>(integer) specifying the number of bins used for density estimation</p>
</td></tr>
<tr><td><code id="ashDensity_+3A_m">m</code></td>
<td>
<p>(integer) specifying the width of the smoothing kernel(s) used for density estimation</p>
</td></tr>
<tr><td><code id="ashDensity_+3A_kopt">kopt</code></td>
<td>
<p>(integer) vector specifying the smoothing kernel</p>
</td></tr>
<tr><td><code id="ashDensity_+3A_normtoab">normToAB</code></td>
<td>
<p>(logical) specifying if the density is normed to the interval ab or to all data points in x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) with density estimation (x values, y values, m and ab).
</p>


<h3>Author(s)</h3>

<p>Christopher Rank <a href="mailto:christopher.rank@roche.com">christopher.rank@roche.com</a>, Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='BoxCox'>One-parameter Box-Cox transformation.</h2><span id='topic+BoxCox'></span>

<h3>Description</h3>

<p>One-parameter Box-Cox transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoxCox(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoxCox_+3A_x">x</code></td>
<td>
<p>(numeric) data to be transformed</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_lambda">lambda</code></td>
<td>
<p>(numeric) Box-Cox transformation parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) vector with Box-Cox transformation of x
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>

<hr>
<h2 id='calculateCostHist'>Calculate costs for a specific combinations of lambda, muVec and sigmaVec.</h2><span id='topic+calculateCostHist'></span>

<h3>Description</h3>

<p>Calculate costs for a specific combinations of lambda, muVec and sigmaVec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateCostHist(
  lambda,
  muVec,
  sigmaVec,
  HistData,
  alpha = 0.01,
  alphaMcb = 0.1,
  pNormLookup
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateCostHist_+3A_lambda">lambda</code></td>
<td>
<p>(numeric) transformation parameter for inverse Box-Cox transformation</p>
</td></tr>
<tr><td><code id="calculateCostHist_+3A_muvec">muVec</code></td>
<td>
<p>(numeric) vector of mean values of non-pathological Gaussian distribution in transformed space</p>
</td></tr>
<tr><td><code id="calculateCostHist_+3A_sigmavec">sigmaVec</code></td>
<td>
<p>(numeric) vector of sd values of non-pathological Gaussian distribution in transformed space</p>
</td></tr>
<tr><td><code id="calculateCostHist_+3A_histdata">HistData</code></td>
<td>
<p>(list) with histogram data generated by function <code><a href="#topic+generateHistData">generateHistData</a></code></p>
</td></tr>
<tr><td><code id="calculateCostHist_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) specifying the confidence region used for selection of histgram bins in cost calculation</p>
</td></tr>
<tr><td><code id="calculateCostHist_+3A_alphamcb">alphaMcb</code></td>
<td>
<p>(numeric) specifying the confidence level defining the maximal allowed counts below asymmetric confidence region</p>
</td></tr>
<tr><td><code id="calculateCostHist_+3A_pnormlookup">pNormLookup</code></td>
<td>
<p>(list) with lookup table for pnormApprox function <code><a href="#topic+pnormApprox">pnormApprox</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) vector with (lambda, mu, sigma, P, cost).
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='defineSearchRegions'>Helper function to define search regions for mu and sigma and to get the region around the main peak 'ab'</h2><span id='topic+defineSearchRegions'></span>

<h3>Description</h3>

<p>The function estimates the start search regions for mu and sigma for each lambda. Further it determines an appropriate 
region around the main peak 'ab' that is used for all lambdas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineSearchRegions(x, lambdaVec, roundingBase, abEst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineSearchRegions_+3A_x">x</code></td>
<td>
<p>(numeric) values specifying data points comprising pathological
and non-pathological values</p>
</td></tr>
<tr><td><code id="defineSearchRegions_+3A_lambdavec">lambdaVec</code></td>
<td>
<p>(numeric) transformation parameter for inverse Box-Cox transformation</p>
</td></tr>
<tr><td><code id="defineSearchRegions_+3A_roundingbase">roundingBase</code></td>
<td>
<p>(numeric) describing the rounding base of the dataset</p>
</td></tr>
<tr><td><code id="defineSearchRegions_+3A_abest">abEst</code></td>
<td>
<p>(numeric) vector with already estimated abSearchReg and abHist for second definition of search regions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) with (abEst, search region for mu and sigma)
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='estimateAB'>Helper function to find region around the main peak of a distribution</h2><span id='topic+estimateAB'></span>

<h3>Description</h3>

<p>Helper function to find region around the main peak of a distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateAB(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateAB_+3A_x">x</code></td>
<td>
<p>(numeric) vector of data points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) with two numeric vectors with lower and upper bound of region around the main peak used for 1) defining the search regions and
2) estimating the histogram with overlapping bins
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='findMainPeak'>Helper function to find the main peak of a distribution</h2><span id='topic+findMainPeak'></span>

<h3>Description</h3>

<p>The function uses a combination of the area under the curve between valleys and the peak height to detect the main peak.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMainPeak(x, ab, mStart, withHeight = FALSE, prevPeak = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findMainPeak_+3A_x">x</code></td>
<td>
<p>(numeric) vector of data points</p>
</td></tr>
<tr><td><code id="findMainPeak_+3A_ab">ab</code></td>
<td>
<p>(numeric) vector specifying the lower and higher truncation limit of density estimation</p>
</td></tr>
<tr><td><code id="findMainPeak_+3A_mstart">mStart</code></td>
<td>
<p>(integer) specifying the width of the smoothing kernel(s) used for density estimation</p>
</td></tr>
<tr><td><code id="findMainPeak_+3A_withheight">withHeight</code></td>
<td>
<p>(logical) specifying if only the area under the curve (FALSE) or a combination of AUC and peak height (TRUE) should be used
to detect the main peak</p>
</td></tr>
<tr><td><code id="findMainPeak_+3A_prevpeak">prevPeak</code></td>
<td>
<p>(numeric) specifying the modEst of the previously estimated peak</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) with the two numeric values peakInd, modEst, and a density list
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='findPeaksAndValleys'>Find the index of the peaks and valleys of the density estimation.</h2><span id='topic+findPeaksAndValleys'></span>

<h3>Description</h3>

<p>Find the index of the peaks and valleys of the density estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPeaksAndValleys(Dens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPeaksAndValleys_+3A_dens">Dens</code></td>
<td>
<p>(list) with density estimation (x values, y values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) specifying the index of the peaks and valleys of the density estimation.
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='findRI'>Function to estimate reference intervals for a single population</h2><span id='topic+findRI'></span>

<h3>Description</h3>

<p>The function estimates the optimal parameters lambda, mu and sigma for a raw data set containing pathological 
and non-pathological values. The optimization is carried out via a multi-level grid search to 
minimize the cost function (negative log-likelihood with regularization) and to find a model that fits the 
distribution of the physiological values and thus separates pathological from non-pathological values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findRI(
  Data = NULL,
  model = c("BoxCox", "modBoxCoxFast", "modBoxCox"),
  NBootstrap = 0,
  seed = 123,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findRI_+3A_data">Data</code></td>
<td>
<p>(numeric) values specifying data points comprising pathological
and non-pathological values</p>
</td></tr>
<tr><td><code id="findRI_+3A_model">model</code></td>
<td>
<p>(character) specifying the applied model (can be either &quot;BoxCox&quot; (default), &quot;modBoxCoxFast&quot; or &quot;modBoxCox&quot;),
option &quot;modBoxCoxFast&quot; and &quot;modBoxCox&quot; first runs the original optimization using the Box-Cox transformation, 
afterwards the modified Box-Cox transformation is utilized and an optimal shift is identified 
('fast': only 1 iteration is carried out to find a shift)</p>
</td></tr>
<tr><td><code id="findRI_+3A_nbootstrap">NBootstrap</code></td>
<td>
<p>(integer) specifying the number of bootstrap repetitions</p>
</td></tr>
<tr><td><code id="findRI_+3A_seed">seed</code></td>
<td>
<p>(integer) specifying the seed used for bootstrapping</p>
</td></tr>
<tr><td><code id="findRI_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(object) of class &quot;RWDRI&quot; with parameters optimized
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# first example

resRI &lt;- findRI(Data = testcase1)
print(resRI)
plot(resRI, showPathol = FALSE)

# second example
resRI &lt;- findRI(Data = testcase2)
print(resRI, RIperc = c(0.025, 0.5, 0.975))
plot(resRI, showPathol = FALSE)

# third example, with bootstrapping 
resRI &lt;- findRI(Data = testcase3, NBootstrap = 30, seed = 123)
print(resRI)
getRI(resRI, RIperc = c(0.025, 0.5, 0.975), CIprop = 0.95, pointEst ="fullDataEst")
getRI(resRI, RIperc = c(0.025, 0.5, 0.975), CIprop = 0.95, pointEst ="medianBS")
plot(resRI)

# forth example, without values and pathological distribution in plot function 
resRI &lt;- findRI(Data = testcase4)
print(resRI)
plot(resRI, showValue = FALSE, showPathol =FALSE) 

# fifth example, with bootstrapping
resRI &lt;- findRI(Data = testcase5, NBootstrap = 30)
plot(resRI,  RIperc = c(0.025, 0.5, 0.975), showPathol = FALSE, showCI = TRUE)

</code></pre>

<hr>
<h2 id='findRoundingBase'>Estimate rounding base of the input data.</h2><span id='topic+findRoundingBase'></span>

<h3>Description</h3>

<p>Estimate rounding base of the input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findRoundingBase(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findRoundingBase_+3A_x">x</code></td>
<td>
<p>(numeric) vector of data points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) with estimated rounding base (e.g. 0.001 when rounded to 3 digits)
</p>


<h3>Author(s)</h3>

<p>Christopher Rank <a href="mailto:christopher.rank@roche.com">christopher.rank@roche.com</a>, Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='generateHistData'>Generate list with histogram data.</h2><span id='topic+generateHistData'></span>

<h3>Description</h3>

<p>Generate list with histogram data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateHistData(x, ab, roundingBase)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateHistData_+3A_x">x</code></td>
<td>
<p>(numeric) vector of data points</p>
</td></tr>
<tr><td><code id="generateHistData_+3A_ab">ab</code></td>
<td>
<p>(numeric) vector of lower and higher limit embedding appropriate region with the main peak</p>
</td></tr>
<tr><td><code id="generateHistData_+3A_roundingbase">roundingBase</code></td>
<td>
<p>(numeric) describing the rounding base of the dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) with histogram data used in the calculation of cost.
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='getRI'>Method to calculate reference intervals (percentiles) for objects of class 'RWDRI'</h2><span id='topic+getRI'></span>

<h3>Description</h3>

<p>Method to calculate reference intervals (percentiles) for objects of class 'RWDRI'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRI(
  x,
  RIperc = c(0.025, 0.975),
  CIprop = 0.95,
  pointEst = c("fullDataEst", "medianBS"),
  Scale = c("original", "transformed", "zScore")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRI_+3A_x">x</code></td>
<td>
<p>(object) of class 'RWDRI'</p>
</td></tr>
<tr><td><code id="getRI_+3A_riperc">RIperc</code></td>
<td>
<p>(numeric) value specifying the percentiles, which define the reference interval</p>
</td></tr>
<tr><td><code id="getRI_+3A_ciprop">CIprop</code></td>
<td>
<p>(numeric) value specifying the central region for estimation of confidence intervals</p>
</td></tr>
<tr><td><code id="getRI_+3A_pointest">pointEst</code></td>
<td>
<p>(character) specifying the point estimate determination: (1) using the full dataset (&quot;fullDataEst&quot;),
(2) calculating the median model from all bootstrap samples (&quot;medianBS&quot;), (2) works only if NBootstrap &gt; 0</p>
</td></tr>
<tr><td><code id="getRI_+3A_scale">Scale</code></td>
<td>
<p>(character) specifying if percentiles are calculated on the original scale (&quot;or&quot;) or the transformed scale (&quot;tr&quot;) or the z-Score scale (&quot;z&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(data.frame) with columns for percentile, point estimate and confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Christopher Rank <a href="mailto:christopher.rank@roche.com">christopher.rank@roche.com</a>, Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='getSumForPArea'>Helper function to calculate the amount of observed and estimated data points within specified regions around the peak.</h2><span id='topic+getSumForPArea'></span>

<h3>Description</h3>

<p>The function helps to define the search region for P (fraction of non-pathological samples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSumForPArea(
  pLimitMin,
  pLimitMax,
  countsPred,
  HistData,
  lambda,
  mu,
  sigma,
  pCorr
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSumForPArea_+3A_plimitmin">pLimitMin</code></td>
<td>
<p>(numeric) vector specifying the lower limits for the regions next to the peak</p>
</td></tr>
<tr><td><code id="getSumForPArea_+3A_plimitmax">pLimitMax</code></td>
<td>
<p>(numeric) vector specifying the upper limits for the regions next to the peak</p>
</td></tr>
<tr><td><code id="getSumForPArea_+3A_countspred">countsPred</code></td>
<td>
<p>(numeric) vector with the predicted counts</p>
</td></tr>
<tr><td><code id="getSumForPArea_+3A_histdata">HistData</code></td>
<td>
<p>(list) with histogram data generated by function <code><a href="#topic+generateHistData">generateHistData</a></code></p>
</td></tr>
<tr><td><code id="getSumForPArea_+3A_lambda">lambda</code></td>
<td>
<p>(numeric) transformation parameter for inverse Box-Cox transformation</p>
</td></tr>
<tr><td><code id="getSumForPArea_+3A_mu">mu</code></td>
<td>
<p>(numeric) parameter of the mean of non-pathological distribution</p>
</td></tr>
<tr><td><code id="getSumForPArea_+3A_sigma">sigma</code></td>
<td>
<p>(numeric) parameter of the standard deviation of non-pathological distribution</p>
</td></tr>
<tr><td><code id="getSumForPArea_+3A_pcorr">pCorr</code></td>
<td>
<p>(numeric) correcting the cumulative probability of the truncated non-pathological distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) with two numeric vectors specifying the amount of observed and estimated data points surrounding the peak
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='invBoxCox'>Inverse of the one-parameter Box-Cox transformation.</h2><span id='topic+invBoxCox'></span>

<h3>Description</h3>

<p>Inverse of the one-parameter Box-Cox transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invBoxCox(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invBoxCox_+3A_x">x</code></td>
<td>
<p>(numeric) data to be transformed</p>
</td></tr>
<tr><td><code id="invBoxCox_+3A_lambda">lambda</code></td>
<td>
<p>(numeric) Box-Cox transformation parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) vector with inverse Box-Cox transformation of x
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>

<hr>
<h2 id='optimizeGrid'>Helper function for grid search for mu and sigma.</h2><span id='topic+optimizeGrid'></span>

<h3>Description</h3>

<p>Helper function for grid search for mu and sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizeGrid(currentBestParam, paramUnique, iter, sigmLimit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeGrid_+3A_currentbestparam">currentBestParam</code></td>
<td>
<p>(numeric) value specifying the current best value for this parameter</p>
</td></tr>
<tr><td><code id="optimizeGrid_+3A_paramunique">paramUnique</code></td>
<td>
<p>(numeric) vector of possible values for this parameter</p>
</td></tr>
<tr><td><code id="optimizeGrid_+3A_iter">iter</code></td>
<td>
<p>(integer) indicating the number of iteration, as in the first iteration the search region
is larger than in the following iterations</p>
</td></tr>
<tr><td><code id="optimizeGrid_+3A_sigmlimit">sigmLimit</code></td>
<td>
<p>(logical) specifiying if parameter is sigma and thus minimum is 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(vector) specifying the new search region fo the parameter to be optimized
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='plot.RWDRI'>Standard plot method for objects of class 'RWDRI'</h2><span id='topic+plot.RWDRI'></span>

<h3>Description</h3>

<p>Standard plot method for objects of class 'RWDRI'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RWDRI'
plot(
  x,
  Scale = c("original", "transformed", "zScore"),
  RIperc = c(0.025, 0.975),
  Nhist = 60,
  showCI = TRUE,
  showPathol = FALSE,
  scalePathol = TRUE,
  showBSModels = FALSE,
  showValue = TRUE,
  CIprop = 0.95,
  pointEst = c("fullDataEst", "medianBS"),
  xlim = NULL,
  ylim = NULL,
  xlab = NULL,
  ylab = NULL,
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.RWDRI_+3A_x">x</code></td>
<td>
<p>(object) of class 'RWDRI'</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_scale">Scale</code></td>
<td>
<p>(character) specifying if percentiles are calculated on the original scale (&quot;or&quot;) or the transformed scale (&quot;tr&quot;) or the z-Score scale (&quot;z&quot;)</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_riperc">RIperc</code></td>
<td>
<p>(numeric) value specifying the percentiles, which define the reference interval (default c(0.025, 0.975))</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_nhist">Nhist</code></td>
<td>
<p>(integer) number of bins in the histogram (derived automatically if not set)</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_showci">showCI</code></td>
<td>
<p>(logical) specifying if the confidence intervals are shown</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_showpathol">showPathol</code></td>
<td>
<p>(logical) specifying if the estimated pathological distribution shall be shown</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_scalepathol">scalePathol</code></td>
<td>
<p>(logical) specifying if the estimated pathological distribution shall be weighted with the ration of pathol/non-pathol</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_showbsmodels">showBSModels</code></td>
<td>
<p>(logical) specifying if the estimated bootstrapping models shall be shown</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_showvalue">showValue</code></td>
<td>
<p>(logical) specifying if the exact value of the estimated reference intervals shall be shown above the plot</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_ciprop">CIprop</code></td>
<td>
<p>(numeric) value specifying the central region for estimation of confidence intervals</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_pointest">pointEst</code></td>
<td>
<p>(character) specifying the point estimate determination: (1) using the full dataset (&quot;fullDataEst&quot;),
(2) calculating the median model from the bootstrap samples (&quot;medianBS&quot;), (2) works only if NBootstrap &gt; 0</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_xlim">xlim</code></td>
<td>
<p>(numeric) vector specifying the limits in x-direction</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_ylim">ylim</code></td>
<td>
<p>(numeric) vector specifying the limits in y-direction</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_xlab">xlab</code></td>
<td>
<p>(character) specifying the x-axis label</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_ylab">ylab</code></td>
<td>
<p>(character) specifying the y-axis label</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_title">title</code></td>
<td>
<p>(character) specifying plot title</p>
</td></tr>
<tr><td><code id="plot.RWDRI_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward to other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The applied plot limits in x-direction (xlim) are returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Rank <a href="mailto:christopher.rank@roche.com">christopher.rank@roche.com</a>, Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

<hr>
<h2 id='pnormApprox'>Approximate calculation of CDF of normal distribution.</h2><span id='topic+pnormApprox'></span>

<h3>Description</h3>

<p>Approximate calculation of CDF of normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnormApprox(q, pNormVal, mean = 0, oneOverSd = 1, oneOverH = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnormApprox_+3A_q">q</code></td>
<td>
<p>(numeric) vector of quantiles of data points</p>
</td></tr>
<tr><td><code id="pnormApprox_+3A_pnormval">pNormVal</code></td>
<td>
<p>(numeric) vector of lookup table for pNorm</p>
</td></tr>
<tr><td><code id="pnormApprox_+3A_mean">mean</code></td>
<td>
<p>(numeric) vector of mean values</p>
</td></tr>
<tr><td><code id="pnormApprox_+3A_oneoversd">oneOverSd</code></td>
<td>
<p>(numeric) reciprocal vector of sd values</p>
</td></tr>
<tr><td><code id="pnormApprox_+3A_oneoverh">oneOverH</code></td>
<td>
<p>(numeric) defining the precision of the approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) vector of approximate CDFs of normal distribution.
</p>


<h3>Author(s)</h3>

<p>Christopher Rank <a href="mailto:christopher.rank@roche.com">christopher.rank@roche.com</a>
</p>

<hr>
<h2 id='print.RWDRI'>Standard print method for objects of class 'RWDRI'</h2><span id='topic+print.RWDRI'></span>

<h3>Description</h3>

<p>Standard print method for objects of class 'RWDRI'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RWDRI'
print(
  x,
  RIperc = c(0.025, 0.975),
  CIprop = 0.95,
  pointEst = c("fullDataEst", "medianBS"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.RWDRI_+3A_x">x</code></td>
<td>
<p>(object) of class 'RWDRI'</p>
</td></tr>
<tr><td><code id="print.RWDRI_+3A_riperc">RIperc</code></td>
<td>
<p>(numeric) value specifying the percentiles, which define the reference interval</p>
</td></tr>
<tr><td><code id="print.RWDRI_+3A_ciprop">CIprop</code></td>
<td>
<p>(numeric) value specifying the central region for estimation of confidence intervals</p>
</td></tr>
<tr><td><code id="print.RWDRI_+3A_pointest">pointEst</code></td>
<td>
<p>(character) specifying the point estimate determination: (1) using the full dataset (&quot;fullDataEst&quot;),
(2) calculating the median model from all bootstrap samples (&quot;medianBS&quot;), (2) works only if NBootstrap &gt; 0</p>
</td></tr>
<tr><td><code id="print.RWDRI_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward to other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Instead, a summary is printed.
</p>


<h3>Author(s)</h3>

<p>Christopher Rank <a href="mailto:christopher.rank@roche.com">christopher.rank@roche.com</a>
</p>

<hr>
<h2 id='refineR-package'>refineR: Reference Interval Estimation using Real-World Data (RWD)</h2><span id='topic+refineR'></span><span id='topic+refineR-package'></span>

<h3>Description</h3>

<p> This package includes the implementation of the refineR algorithm (Ammer et al., 2021) which is an indirect method for the estimation of 
reference intervals using Real-World Data (RWD). It takes routine measurements of diagnostic tests, containing pathological and non-pathological samples 
as input and uses sophisticated statistical methods to derive a model describing the distribution of the non-pathological samples. 
This distribution can then be used to derive reference intervals. Main function of this package is <code><a href="#topic+findRI">findRI</a></code> that takes an input data set 
and tries to find a model that best explains the non-pathological distribution. Furthermore, the package offers functions for printing <code><a href="#topic+print.RWDRI">print.RWDRI</a></code> and plotting
<code><a href="#topic+plot.RWDRI">plot.RWDRI</a></code> the results of the algorithm operating on S3-objects of class 'RWDRI'.
</p>


<h3>Details</h3>

   

<table>
<tr>
 <td style="text-align: left;">     
 Package: </td><td style="text-align: left;"> refineR</td>
</tr>
<tr>
 <td style="text-align: left;">
 Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">     
 Version: </td><td style="text-align: left;"> 1.6.1 </td>
</tr>
<tr>
 <td style="text-align: left;">     
 Date: </td><td style="text-align: left;"> 2023-11-13 </td>
</tr>
<tr>
 <td style="text-align: left;">
 License: </td><td style="text-align: left;"> GPL (&gt;=3) </td>
</tr>
<tr>
 <td style="text-align: left;">     
 LazyLoad: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">   
 </td>
</tr>

</table>
 


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>, 
Christopher M Rank <a href="mailto:christopher.rank@roche.com">christopher.rank@roche.com</a>,
Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Ammer, T., Schuetzenmeister, A., Prokosch, HU., Rauh, M., Rank, C.M., Zierk, J. refineR: A Novel Algorithm for Reference Interval Estimation from Real-World Data. Sci Rep 11, 16023 (2021).
</p>

<hr>
<h2 id='testcase1'>Simulated Testcase 1.</h2><span id='topic+testcase1'></span>

<h3>Description</h3>

<p>This dataset consists of N = 10,000 simulated measurements with 80% non-pathological and 20% pathological samples. 
Ground Truth for reference intervals (2.5% perc., 97.5% perc): [10.2, 29.8]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcase1
</code></pre>


<h3>Format</h3>

<p>Numeric vector with data points.
</p>

<hr>
<h2 id='testcase2'>Simulated Testcase 2.</h2><span id='topic+testcase2'></span>

<h3>Description</h3>

<p>This dataset consists of N = 50,000 simulated measurements with 60% non-pathological and 40% pathological samples. 
Ground Truth for reference intervals (2.5% perc., 97.5% perc): [59.8, 160]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcase2
</code></pre>


<h3>Format</h3>

<p>Numeric vector with data points.
</p>

<hr>
<h2 id='testcase3'>Simulated Testcase 3.</h2><span id='topic+testcase3'></span>

<h3>Description</h3>

<p>This dataset consists of N = 75,000 simulated measurements with 96% non-pathological and 4% pathological samples. 
Ground Truth for reference intervals (2.5% perc., 97.5% perc): [9.04, 13]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcase3
</code></pre>


<h3>Format</h3>

<p>Numeric vector with data points.
</p>

<hr>
<h2 id='testcase4'>Simulated Testcase 4.</h2><span id='topic+testcase4'></span>

<h3>Description</h3>

<p>This dataset consists of N = 100,000 simulated measurements with 90% non-pathological and 10% pathological samples.
Ground Truth for reference intervals (2.5% perc., 97.5% perc): [10, 50]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcase4
</code></pre>


<h3>Format</h3>

<p>Numeric vector with data points.
</p>

<hr>
<h2 id='testcase5'>Simulated Testcase 5.</h2><span id='topic+testcase5'></span>

<h3>Description</h3>

<p>This dataset consists of N = 250,000 simulated measurements with 80% non-pathological and 20% pathological samples. 
Ground Truth for reference intervals (2.5% perc., 97.5% perc): [0.25, 4]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcase5
</code></pre>


<h3>Format</h3>

<p>Numeric vector with data points.
</p>

<hr>
<h2 id='testParam'>Helper function to find optimal parameters lambda, mu and sigma.</h2><span id='topic+testParam'></span>

<h3>Description</h3>

<p>Helper function to find optimal parameters lambda, mu and sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testParam(
  lambdaVec,
  bestParam,
  Data,
  HistData,
  startValues,
  NIter,
  alpha = 0.01,
  alphaMcb = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testParam_+3A_lambdavec">lambdaVec</code></td>
<td>
<p>(numeric) transformation parameter for inverse Box-Cox transformation</p>
</td></tr>
<tr><td><code id="testParam_+3A_bestparam">bestParam</code></td>
<td>
<p>(numeric) vector containing best guess for lambda, mu, sigma, P, cost</p>
</td></tr>
<tr><td><code id="testParam_+3A_data">Data</code></td>
<td>
<p>(numeric) values specifying percentiles or data points comprising pathological
and non-pathological values</p>
</td></tr>
<tr><td><code id="testParam_+3A_histdata">HistData</code></td>
<td>
<p>(list) with histogram data</p>
</td></tr>
<tr><td><code id="testParam_+3A_startvalues">startValues</code></td>
<td>
<p>(list) with start search regions for mu and sigma</p>
</td></tr>
<tr><td><code id="testParam_+3A_niter">NIter</code></td>
<td>
<p>(integer) specifying the number of iterations for optimized grid-search</p>
</td></tr>
<tr><td><code id="testParam_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) specifying the confidence region used for selection of histogram bins in cost calculation</p>
</td></tr>
<tr><td><code id="testParam_+3A_alphamcb">alphaMcb</code></td>
<td>
<p>(numeric) specifying the confidence level defining the maximal allowed counts below the asymmetric confidence region</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) vector with best parameters for lambda, mu, sigma, P, cost.
</p>


<h3>Author(s)</h3>

<p>Tatjana Ammer <a href="mailto:tatjana.ammer@roche.com">tatjana.ammer@roche.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
