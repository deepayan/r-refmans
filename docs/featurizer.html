<!DOCTYPE html><html lang="en"><head><title>Help for package featurizer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {featurizer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#holiday_lst'><p>Fedral Holidays DataFrame</p></a></li>
<li><a href='#infer_gender'><p>Infer gender for list of names fast</p></a></li>
<li><a href='#infer_holiday'><p>Infer if a date is a fedral holiday</p></a></li>
<li><a href='#par_sapply'><p>A friendlier parSapply.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Some Helper Functions that Help Create Features from Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-06-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Chhavi Choudhury [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chhavi Choudhury &lt;chhavi.choudhury@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions that would help one to build features based on external data. Very useful for Data Scientists in data to day work. Many functions create features using parallel computation. Since the nitty gritty of parallel computation is hidden under the hood, the user need not worry about creating clusters and shutting them down.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.1), utils, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-06-11 13:19:20 UTC; chhavi21</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-06-11 23:12:50 UTC</td>
</tr>
</table>
<hr>
<h2 id='holiday_lst'>Fedral Holidays DataFrame</h2><span id='topic+holiday_lst'></span>

<h3>Description</h3>

<p>This is a simple function that returns a data frame of federal holidays and date on which they were observed. It has only 2 columns, Date and Holiday for years 2012-2020.The functions does not take any parameter but returns a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>holiday_lst()
</code></pre>


<h3>Value</h3>

<p>Returns a data frame if fedral holidays and when they were observed from 2012 - 2020
</p>


<h3>Examples</h3>

<pre><code class='language-R'>holiday_lst()
</code></pre>

<hr>
<h2 id='infer_gender'>Infer gender for list of names fast</h2><span id='topic+infer_gender'></span>

<h3>Description</h3>

<p>This function used a database of names and corresponding gender to lookup the gender of a name. It takes in a vector of names and returns a vector indicating gender for the name. The gender is denoted by &quot;m&quot;/&quot;f&quot;/&quot;u&quot; for male/female/unknown respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_gender(x, detect_cores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infer_gender_+3A_x">x</code></td>
<td>
<p>The vector of names to perform paralleized inference on</p>
</td></tr>
<tr><td><code id="infer_gender_+3A_detect_cores">detect_cores</code></td>
<td>
<p>If False (default), 2 cores are used. If True, half the number of cores are used on Mac OS else 2 cores are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The a vector with m/f/u if the name in the original vector was male female or Unknown respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infer_gender(x=c("abby", "Nick", "abc"))
</code></pre>

<hr>
<h2 id='infer_holiday'>Infer if a date is a fedral holiday</h2><span id='topic+infer_holiday'></span>

<h3>Description</h3>

<p>A function that returns the federal holiday observed on a given date. If there was no holiday observed, it returns None. The function takes in a list of dates, where each date is in the format YYYY-MM-DD and checks them against a database of federal holidays (2012-2020). It returns the holiday that was/will be observed on the date. If no holiday is observed on that date, it returns &quot;None&quot; corresponding to that date. This computation happens in parallel and hence is very fast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_holiday(date_lst, detect_cores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infer_holiday_+3A_date_lst">date_lst</code></td>
<td>
<p>a list of dates strings of the format YYYY-MM-DD</p>
</td></tr>
<tr><td><code id="infer_holiday_+3A_detect_cores">detect_cores</code></td>
<td>
<p>If False (default), 2 cores are used. If True, half the number of cores are used on Mac OS else 2 cores are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the kind of fedral holiday that was/will be observed on that date. If there was no holiday observed, it returns None.
It does the lookup in parallel and hence is very fast.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infer_holiday(date_lst = c("2020-12-25", "2020-09-07", "2020-09-08", "2016-01-18",
 "2016-01-19", "2016-01-15"))
</code></pre>

<hr>
<h2 id='par_sapply'>A friendlier parSapply.</h2><span id='topic+par_sapply'></span>

<h3>Description</h3>

<p>A sleek wrapper on the function parSapply. This function does not require user to allocate clusters and then stop them. This function uses parSapply across half the available cores and after the computation is done, it stops the clusters as well. The inputs are same os parSapply from parallel package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_sapply(X, FUNC, detect_cores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="par_sapply_+3A_x">X</code></td>
<td>
<p>The vector of value to perform paralleized sapply on.</p>
</td></tr>
<tr><td><code id="par_sapply_+3A_func">FUNC</code></td>
<td>
<p>Function to be applied to every value of X, similar to sapply</p>
</td></tr>
<tr><td><code id="par_sapply_+3A_detect_cores">detect_cores</code></td>
<td>
<p>If False (default), 2 cores are used. If True, half the number of cores are used on Mac OS else 2 cores are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The a vector just like sapply. It does applies the function on X in parallel and hence is very fast.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par_sapply(1:100, function(x) x*100)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
