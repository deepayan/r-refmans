<!DOCTYPE html><html><head><title>Help for package PeakSegDisk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PeakSegDisk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ChIPreads'>
<p>Reads aligned to hg19 from two ChIP-seq experiments</p></a></li>
<li><a href='#coef.PeakSegFPOP_df'><p>coef PeakSegFPOP df</p></a></li>
<li><a href='#coef.PeakSegFPOP_dir'><p>coef PeakSegFPOP dir</p></a></li>
<li><a href='#col.name.list'><p>col name list</p></a></li>
<li><a href='#fread.first'><p>Quickly read first line</p></a></li>
<li><a href='#fread.last'><p>Quickly read last line</p></a></li>
<li><a href='#Mono27ac'>
<p>A small ChIP-seq data set in which peaks can be found using PeakSegFPOP</p></a></li>
<li><a href='#PeakSegFPOP_df'><p>PeakSeg penalized solver for data.frame</p></a></li>
<li><a href='#PeakSegFPOP_dir'><p>PeakSeg penalized solver with caching</p></a></li>
<li><a href='#PeakSegFPOP_file'><p>PeakSegFPOP using disk storage</p></a></li>
<li><a href='#PeakSegFPOP_vec'><p>PeakSeg penalized solver for integer vector</p></a></li>
<li><a href='#plot.PeakSegFPOP_df'><p>plot PeakSegFPOP df</p></a></li>
<li><a href='#plot.PeakSegFPOP_dir'><p>plot PeakSegFPOP dir</p></a></li>
<li><a href='#sequentialSearch_dir'><p>Compute PeakSeg model with given number of peaks</p></a></li>
<li><a href='#summary.PeakSegFPOP_dir'><p>summary PeakSegFPOP dir</p></a></li>
<li><a href='#wc2int'><p>wc2int</p></a></li>
<li><a href='#writeBedGraph'><p>Write bedGraph file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Disk-Based Constrained Change-Point Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>2023.11.27</td>
</tr>
<tr>
<td>Author:</td>
<td>Toby Dylan Hocking</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Disk-based implementation of
 Functional Pruning Optimal Partitioning with up-down constraints
 &lt;<a href="https://doi.org/10.18637%2Fjss.v101.i10">doi:10.18637/jss.v101.i10</a>&gt; for single-sample peak calling
 (independently for each sample and genomic problem),
 can handle huge data sets (10^7 or more).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.9.8)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, ggplot2, future.apply, future, knitr, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tdhock/PeakSegDisk">https://github.com/tdhock/PeakSegDisk</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tdhock/PeakSegDisk/issues">https://github.com/tdhock/PeakSegDisk/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 21:24:16 UTC; th798</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ChIPreads'>
Reads aligned to hg19 from two ChIP-seq experiments
</h2><span id='topic+ChIPreads'></span>

<h3>Description</h3>

<p>These data are raw aligned reads which have been mapped to the human
genome, hg19. One is sample ID McGill0004, experiment H3K36me3, chr9,
chunk H3K36me3_AM_immune/8. The other is sample ID McGill0002,
experiment H3K4me3, chr2, chunk H3K4me3_PGP_immune/7.
The chunk ID numbers refer to parts of the McGill benchmark data set,
<a href="https://rcdata.nau.edu/genomic-ml/chip-seq-chunk-db/">https://rcdata.nau.edu/genomic-ml/chip-seq-chunk-db/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ChIPreads")</code></pre>


<h3>Format</h3>

<p>A data frame with 40396 observations on the following 4 variables.
</p>

<dl>
<dt><code>experiment</code></dt><dd><p>either H3K36me3 or H3K4me3</p>
</dd>
<dt><code>chrom</code></dt><dd><p>either chr9 or chr2</p>
</dd>
<dt><code>chromStart</code></dt><dd><p>0-based start position of read</p>
</dd>
<dt><code>chromEnd</code></dt><dd><p>1-based end position of read</p>
</dd>
<dt><code>count</code></dt><dd><p>number of times a read occured with the given
chromStart/end in this sample/experiment</p>
</dd>
</dl>



<h3>Details</h3>

<p>Peak detection algorithm are typically run on a sequence of
non-negative integer
count data, one data point for each genomic position.
These data are useful for proving that peak detection methods are
robust to different sequences: (1) spatially correlated,
non-independent aligned read coverage; (2) un-correlated, independent
representations such as first or last read.
</p>

<hr>
<h2 id='coef.PeakSegFPOP_df'>coef PeakSegFPOP df</h2><span id='topic+coef.PeakSegFPOP_df'></span>

<h3>Description</h3>

<p>Create a list of data tables describing PeakSegFPOP model and
data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PeakSegFPOP_df'
coef(object, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.PeakSegFPOP_df_+3A_object">object</code></td>
<td>
<p>object </p>
</td></tr>
<tr><td><code id="coef.PeakSegFPOP_df_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data tables with named elements segments, loss, data,
changes, peaks.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='coef.PeakSegFPOP_dir'>coef PeakSegFPOP dir</h2><span id='topic+coef.PeakSegFPOP_dir'></span>

<h3>Description</h3>

<p>Compute changes and peaks to display/plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PeakSegFPOP_dir'
coef(object, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.PeakSegFPOP_dir_+3A_object">object</code></td>
<td>
<p>object </p>
</td></tr>
<tr><td><code id="coef.PeakSegFPOP_dir_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Value</h3>

<p>model list with additional named elements peaks and changes.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='col.name.list'>col name list</h2><span id='topic+col.name.list'></span>

<h3>Description</h3>

<p>Named list of character vectors (column names of bed/bedGraph/tsv
files), used to read data files, which do not contain a header /
column names. Each name corresponds to a data/file type, and each
value is a character vector of column names expected in that
file. loss is for the coverage.bedGraph_penalty=VALUE_loss.tsv
file generated by <code><a href="#topic+PeakSegFPOP_file">PeakSegFPOP_file</a></code>; segments is for the
coverage.bedGraph_penalty=VALUE_segments.bed generated by
<code><a href="#topic+PeakSegFPOP_file">PeakSegFPOP_file</a></code>; coverage is for the coverage.bedGraph file which
is used as input to <code><a href="#topic+PeakSegFPOP_file">PeakSegFPOP_file</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"col.name.list"</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PeakSegDisk)
r &lt;- function(chrom, chromStart, chromEnd, coverage){
  data.frame(chrom, chromStart, chromEnd, coverage)
}
four &lt;- rbind(
  r("chr1", 0, 10,  2),
  r("chr1", 10, 20, 10),
  r("chr1", 20, 30, 14),
  r("chr1", 30, 40, 13))
write.table(
  four, tmp &lt;- tempfile(),
  sep="\t", row.names=FALSE, col.names=FALSE)
read.table(
  tmp, col.names=col.name.list$coverage)

pstr &lt;- "10.5"
PeakSegFPOP_file(tmp, pstr)
outf &lt;- function(suffix){
  paste0(tmp, "_penalty=", pstr, "_", suffix)
}
fread.first(outf("segments.bed"), col.name.list$segments)
fread.first(outf("loss.tsv"), col.name.list$loss)

</code></pre>

<hr>
<h2 id='fread.first'>Quickly read first line</h2><span id='topic+fread.first'></span>

<h3>Description</h3>

<p>Read the first line of a text file. Useful for quickly checking if
the coverage.bedGraph_penalty=VALUE_segments.bed file is
consistent with the coverage.bedGraph_penalty=VALUE_loss.tsv
file. (used by the <code><a href="#topic+PeakSegFPOP_dir">PeakSegFPOP_dir</a></code> caching mechanism)</p>


<h3>Usage</h3>

<pre><code class='language-R'>fread.first(file.name, 
    col.name.vec)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fread.first_+3A_file.name">file.name</code></td>
<td>
<p>Name of file to read.</p>
</td></tr>
<tr><td><code id="fread.first_+3A_col.name.vec">col.name.vec</code></td>
<td>
<p>Character vector of column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data table with one row.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PeakSegDisk)
r &lt;- function(chrom, chromStart, chromEnd, coverage){
  data.frame(chrom, chromStart, chromEnd, coverage)
}
four &lt;- rbind(
  r("chr1", 0, 10,  2),
  r("chr1", 10, 20, 10),
  r("chr1", 20, 30, 14),
  r("chr1", 30, 40, 13))
write.table(
  four, tmp &lt;- tempfile(),
  sep="\t", row.names=FALSE, col.names=FALSE)
pstr &lt;- "10.5"
PeakSegFPOP_file(tmp, pstr)

outf &lt;- function(suffix){
  paste0(tmp, "_penalty=", pstr, "_", suffix)
}
segments.bed &lt;- outf("segments.bed")
first.seg.line &lt;- fread.first(segments.bed, col.name.list$segments)
last.seg.line &lt;- fread.last(segments.bed, col.name.list$segments)

loss.tsv &lt;- outf("loss.tsv")
loss.row &lt;- fread.first(loss.tsv, col.name.list$loss)

seg.bases &lt;- first.seg.line$chromEnd - last.seg.line$chromStart
loss.row$bases == seg.bases

</code></pre>

<hr>
<h2 id='fread.last'>Quickly read last line</h2><span id='topic+fread.last'></span>

<h3>Description</h3>

<p>Read the last line of a text file. Useful for quickly checking if
the coverage.bedGraph_penalty=VALUE_segments.bed file is
consistent with the coverage.bedGraph_penalty=VALUE_loss.tsv
file. (used by the <code><a href="#topic+PeakSegFPOP_dir">PeakSegFPOP_dir</a></code> caching mechanism)</p>


<h3>Usage</h3>

<pre><code class='language-R'>fread.last(file.name, 
    col.name.vec)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fread.last_+3A_file.name">file.name</code></td>
<td>
<p>Name of file to read.</p>
</td></tr>
<tr><td><code id="fread.last_+3A_col.name.vec">col.name.vec</code></td>
<td>
<p>Character vector of column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data table with one row.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PeakSegDisk)
r &lt;- function(chrom, chromStart, chromEnd, coverage){
  data.frame(chrom, chromStart, chromEnd, coverage)
}
four &lt;- rbind(
  r("chr1", 0, 10,  2),
  r("chr1", 10, 20, 10),
  r("chr1", 20, 30, 14),
  r("chr1", 30, 40, 13))
write.table(
  four, tmp &lt;- tempfile(),
  sep="\t", row.names=FALSE, col.names=FALSE)
pstr &lt;- "10.5"
PeakSegFPOP_file(tmp, pstr)

outf &lt;- function(suffix){
  paste0(tmp, "_penalty=", pstr, "_", suffix)
}
segments.bed &lt;- outf("segments.bed")
first.seg.line &lt;- fread.first(segments.bed, col.name.list$segments)
last.seg.line &lt;- fread.last(segments.bed, col.name.list$segments)

loss.tsv &lt;- outf("loss.tsv")
loss.row &lt;- fread.first(loss.tsv, col.name.list$loss)

seg.bases &lt;- first.seg.line$chromEnd - last.seg.line$chromStart
loss.row$bases == seg.bases

</code></pre>

<hr>
<h2 id='Mono27ac'>
A small ChIP-seq data set in which peaks can be found using PeakSegFPOP
</h2><span id='topic+Mono27ac'></span>

<h3>Description</h3>

<p>The data come from an H3K27ac ChIP-seq experiment which was aligned to
the human reference genome (hg19), aligned read counts were used to
produce the coverage data; looking at these data in a genome browser
was used to produce the labels. ChIP-seq means Chromatin
Immunoprecipitation followed by high-throughput DNA sequencing; it is
an assay used to characterize genome-wide DNA-protein interactions. In
this experiment the protein of interest is histone H3, with the
specific modification K27ac (hence the name H3K27ac). Large counts (peaks)
therefore indicate regions of the reference genome with high
likelihood of interaction between DNA and that specific protein, in
the specific Monocyte sample tested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Mono27ac")</code></pre>


<h3>Format</h3>

<p>A list of 2 data.tables: coverage has 4 columns (chrom, chromStart,
chromEnd, count=number of aligned reads at each position on
chrom:chromStart-chromEnd); labels has 4 columns (chrom, chromStart,
chromEnd, annotation=label at chrom:chromStart-chromEnd).
chrom refers to the chromosome on whcih the data were gathered (chr11),
chromStart is the 0-based position before the first base of the
data/label, chromEnd is the 1-based position which is the last base of
the data/label.
Therefore, each chromEnd on each row should be equal to the chromStart of the next row.
</p>


<h3>Source</h3>

<p>UCI Machine Learning Repository, chipseq data set, problem directory
H3K27ac-H3K4me3_TDHAM_BP/samples/Mono1_H3K27ac/S001YW_NCMLS/problems/chr11:60000-580000
Links: <a href="https://archive.ics.uci.edu/ml/datasets/chipseq">https://archive.ics.uci.edu/ml/datasets/chipseq</a> for the
UCI web page; <a href="https://github.com/tdhock/feature-learning-benchmark">https://github.com/tdhock/feature-learning-benchmark</a> for
a more detailed explanation.
</p>

<hr>
<h2 id='PeakSegFPOP_df'>PeakSeg penalized solver for data.frame</h2><span id='topic+PeakSegFPOP_df'></span>

<h3>Description</h3>

<p>Write data frame to disk then run <code><a href="#topic+PeakSegFPOP_dir">PeakSegFPOP_dir</a></code> solver.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakSegFPOP_df(count.df, 
    pen.num, base.dir = tempdir())</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakSegFPOP_df_+3A_count.df">count.df</code></td>
<td>
<p>data.frame with columns count, chromStart, chromEnd. These data
will be saved via <code><a href="#topic+writeBedGraph">writeBedGraph</a></code>, creating a plain text file with
the following four columns: chrom (character chromosome name),
chromStart (integer start position), chromEnd (integer end
position), count (integer aligned read count on chrom from
chromStart+1 to chromEnd); see also
https://genome.ucsc.edu/goldenPath/help/bedgraph.html</p>
</td></tr>
<tr><td><code id="PeakSegFPOP_df_+3A_pen.num">pen.num</code></td>
<td>
<p>Non-negative numeric scalar.</p>
</td></tr>
<tr><td><code id="PeakSegFPOP_df_+3A_base.dir">base.dir</code></td>
<td>
<p>base.dir/chrXX-start-end/coverage.bedGraph will be written, where
chrXX is the chrom column, start is the first chromStart position,
and end is the last chromEnd position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of solver results, same as <code><a href="#topic+PeakSegFPOP_dir">PeakSegFPOP_dir</a></code>.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate a sequence of Poisson count data.
sim.seg &lt;- function(seg.mean, size.mean=15){
  seg.size &lt;- rpois(1, size.mean)
  rpois(seg.size, seg.mean)
}
set.seed(1)
seg.mean.vec &lt;- c(1.5, 3.5, 0.5, 4.5, 2.5)
z.list &lt;- lapply(seg.mean.vec, sim.seg)
z.rep.vec &lt;- unlist(z.list)

## Plot the simulated data sequence.
if(require(ggplot2)){
  count.df &lt;- data.frame(
    position=seq_along(z.rep.vec),
    count=z.rep.vec)
  gg.count &lt;- ggplot()+
    geom_point(aes(
      position, count),
      shape=1,
      data=count.df)
  gg.count
}

## Plot the true changes.
n.segs &lt;- length(seg.mean.vec)
seg.size.vec &lt;- sapply(z.list, length)
seg.end.vec &lt;- cumsum(seg.size.vec)
change.vec &lt;- seg.end.vec[-n.segs]+0.5
change.df &lt;- data.frame(
  changepoint=change.vec)
gg.change &lt;- gg.count+
  geom_vline(aes(
    xintercept=changepoint),
    data=change.df)
gg.change

## Plot the run-length encoding of the same data.
z.rle.vec &lt;- rle(z.rep.vec)
chromEnd &lt;- cumsum(z.rle.vec$lengths)
coverage.df &lt;- data.frame(
  chrom="chrUnknown",
  chromStart=c(0L, chromEnd[-length(chromEnd)]),
  chromEnd,
  count=z.rle.vec$values)
gg.rle &lt;- gg.change+
  geom_segment(aes(
    chromStart+0.5, count, xend=chromEnd+0.5, yend=count),
    data=coverage.df)
gg.rle

## Fit a peak model and plot the segment means.
fit &lt;- PeakSegDisk::PeakSegFPOP_df(coverage.df, 10.5)
gg.rle+
  geom_segment(aes(
    chromStart+0.5, mean, xend=chromEnd+0.5, yend=mean),
    color="green",
    data=fit$segments)

## Default plot method shows data as geom_step.
(gg &lt;- plot(fit))

## Plot data as points to verify the step representation.
gg+
  geom_point(aes(
    position, count),
    color="grey",
    shape=1,
    data=count.df)

</code></pre>

<hr>
<h2 id='PeakSegFPOP_dir'>PeakSeg penalized solver with caching</h2><span id='topic+PeakSegFPOP_dir'></span><span id='topic+PeakSegDisk'></span>

<h3>Description</h3>

<p>Main function/interface for the PeakSegDisk package.
Run the low-level solver, <code><a href="#topic+PeakSegFPOP_file">PeakSegFPOP_file</a></code>,
on one genomic segmentation problem
directory, and read the result files into R. Actually, this
function will first check if the result files are already present
(and consistent), and if so, it will simply read them into R
(without running <code><a href="#topic+PeakSegFPOP_file">PeakSegFPOP_file</a></code>) &ndash; this is a caching mechanism
that can save a lot of time.
To run the algo on an integer vector, use <code><a href="#topic+PeakSegFPOP_vec">PeakSegFPOP_vec</a></code>;
for a data.frame, use <code><a href="#topic+PeakSegFPOP_df">PeakSegFPOP_df</a></code>.
To compute the optimal model for a given number of peaks,
use <code><a href="#topic+sequentialSearch_dir">sequentialSearch_dir</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakSegFPOP_dir(problem.dir, 
    penalty.param, db.file = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakSegFPOP_dir_+3A_problem.dir">problem.dir</code></td>
<td>
<p>Path to a directory like sampleID/problems/chrXX-start-end which
contains a coverage.bedGraph file with the aligned read counts for
one genomic segmentation problem. This must be a plain text file
with the following four columns: chrom (character chromosome
name), chromStart (integer start position), chromEnd (integer end
position), count (integer aligned read count on chrom from
chromStart+1 to chromEnd); see also
https://genome.ucsc.edu/goldenPath/help/bedgraph.html. Note that
the standard coverage.bedGraph file name is required; for full
flexibility the user can run the algo on an arbitrarily named file
via <code><a href="#topic+PeakSegFPOP_file">PeakSegFPOP_file</a></code> (see that man page for an explanation of how
storage on disk happens).</p>
</td></tr>
<tr><td><code id="PeakSegFPOP_dir_+3A_penalty.param">penalty.param</code></td>
<td>
<p>non-negative numeric penalty parameter (larger values for fewer
peaks), or character scalar which can be interpreted as such. 0
means max peaks, Inf means no peaks.</p>
</td></tr>
<tr><td><code id="PeakSegFPOP_dir_+3A_db.file">db.file</code></td>
<td>
<p>character scalar: file for writing temporary cost function
database &ndash; there will be a lot of disk writing to this
file. Default NULL means to write the same disk where the input
bedGraph file is stored; another option is tempfile() which may
result in speedups if the input bedGraph file is on a slow network
disk and the temporary storage is a fast local disk.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the optimal change-points using the Poisson loss
and the PeakSeg constraint (changes in mean alternate between
non-decreasing and non-increasing). For <code class="reqn">N</code> data points, the
functional pruning algorithm is <code class="reqn">O(\log N)</code> memory. It is
<code class="reqn">O(N \log N)</code> time and disk space. It computes the
exact solution to the optimization problem in
<code>vignette("Examples", package="PeakSegDisk")</code>.</p>


<h3>Value</h3>

<p>Named list of two data.tables:
</p>
<table>
<tr><td><code>segments</code></td>
<td>
<p>has one row for every segment in the optimal model,</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>has one row and contains the following columns:</p>
</td></tr>
</table>

<dl>
<dt>penalty</dt><dd><p>same as input parameter</p>
</dd>
<dt>segments</dt><dd><p>number of segments in optimal model</p>
</dd>
<dt>peaks</dt><dd><p>number of peaks in optimal model</p>
</dd>
<dt>bases</dt><dd><p>number of positions described in bedGraph file</p>
</dd>
<dt>bedGraph.lines</dt><dd><p>number of lines in bedGraph file</p>
</dd>
<dt>total.loss</dt><dd><p>total Poisson loss
= <code class="reqn">\sum_i m_i-z_i*\log(m_i)</code> =
mean.pen.cost*bases-penalty*peaks</p>
</dd>
<dt>mean.pen.cost</dt><dd><p>mean penalized cost = (total.loss+penalty*peaks)/bases</p>
</dd>
<dt>equality.constraints</dt><dd><p>number of adjacent segment means that have
equal values in the optimal solution</p>
</dd>
<dt>mean.intervals</dt><dd><p>mean number of intervals/candidate
changepoints stored in optimal cost functions &ndash; useful for
characterizing the computational complexity of the algorithm</p>
</dd>
<dt>max.intervals</dt><dd><p>maximum number of intervals</p>
</dd>
<dt>megabytes</dt><dd><p>disk usage of *.db file</p>
</dd>
<dt>seconds</dt><dd><p>timing of PeakSegFPOP_file</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Mono27ac, package="PeakSegDisk", envir=environment())
data.dir &lt;- file.path(
  tempfile(),
  "H3K27ac-H3K4me3_TDHAM_BP",
  "samples",
  "Mono1_H3K27ac",
  "S001YW_NCMLS",
  "problems",
  "chr11-60000-580000")
dir.create(data.dir, recursive=TRUE, showWarnings=FALSE)
write.table(
  Mono27ac$coverage, file.path(data.dir, "coverage.bedGraph"),
  col.names=FALSE, row.names=FALSE, quote=FALSE, sep="\t")

## Compute one model with penalty=1952.6
(fit &lt;- PeakSegDisk::PeakSegFPOP_dir(data.dir, 1952.6))
summary(fit)#same as fit$loss

## Visualize that model.
ann.colors &lt;- c(
  noPeaks="#f6f4bf",
  peakStart="#ffafaf",
  peakEnd="#ff4c4c",
  peaks="#a445ee")
if(require(ggplot2)){
  lab.min &lt;- Mono27ac$labels[1, chromStart]
  lab.max &lt;- Mono27ac$labels[.N, chromEnd]
  plist &lt;- coef(fit)
  gg &lt;- ggplot()+
    theme_bw()+
    geom_rect(aes(
      xmin=chromStart/1e3, xmax=chromEnd/1e3,
      ymin=-Inf, ymax=Inf,
      fill=annotation),
      color="grey",
      alpha=0.5,
      data=Mono27ac$labels)+
    scale_fill_manual("label", values=ann.colors)+
    geom_step(aes(
      chromStart/1e3, count),
      color="grey50",
      data=Mono27ac$coverage)+
    geom_segment(aes(
      chromStart/1e3, mean,
      xend=chromEnd/1e3, yend=mean),
      color="green",
      size=1,
      data=plist$segments)+
    geom_vline(aes(
      xintercept=chromEnd/1e3, linetype=constraint),
      color="green",
      data=plist$changes)+
    scale_linetype_manual(
      values=c(
        inequality="dotted",
        equality="solid"))
  print(gg)
  print(gg+coord_cartesian(xlim=c(lab.min, lab.max)/1e3, ylim=c(0, 10)))
  ## Default plotting method only shows model.
  print(gg &lt;- plot(fit))
  ## Data can be added on top of model.
  print(
    gg+
      geom_step(aes(
        chromStart, count),
        color="grey50",
        data=Mono27ac$coverage)
  )
}

</code></pre>

<hr>
<h2 id='PeakSegFPOP_file'>PeakSegFPOP using disk storage</h2><span id='topic+PeakSegFPOP_file'></span>

<h3>Description</h3>

<p>Run the PeakSeg Functional Pruning Optimal Partitioning algorithm,
using a file on disk to store the O(N) function piece lists,
each of size O(log N).
This is a low-level function that just runs the algo
and produces the result files (without reading them into R),
so normal users are recommended to instead use <code><a href="#topic+PeakSegFPOP_dir">PeakSegFPOP_dir</a></code>,
which calls this function then reads the result files into R.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakSegFPOP_file(bedGraph.file, 
    pen.str, db.file = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakSegFPOP_file_+3A_bedgraph.file">bedGraph.file</code></td>
<td>
<p>character scalar: tab-delimited tabular text file with four
columns: chrom, chromStart, chromEnd, coverage. The algorithm
creates a large temporary file in the same directory, so make sure
that there is disk space available on that device.</p>
</td></tr>
<tr><td><code id="PeakSegFPOP_file_+3A_pen.str">pen.str</code></td>
<td>
<p>character scalar that can be converted to a numeric scalar via
as.numeric: non-negative penalty. More penalty means fewer
peaks. &quot;0&quot; and &quot;Inf&quot; are OK. Character is required rather than
numeric, so that the user can reliably find the results in the
output files, which are in the same directory as <code>bedGraph.file</code>,
and named using the penalty value,
e.g. coverage.bedGraph_penalty=136500650856.439_loss.tsv</p>
</td></tr>
<tr><td><code id="PeakSegFPOP_file_+3A_db.file">db.file</code></td>
<td>
<p>character scalar: file for writing temporary cost function
database &ndash; there will be a lot of disk writing to this
file. Default NULL means to write the same disk where the input
bedGraph file is stored; another option is tempfile() which may
result in speedups if the input bedGraph file is on a slow network
disk and the temporary storage is a fast local disk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of input parameters, and the temporary cost function
database file size in megabytes.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- function(chrom, chromStart, chromEnd, coverage){
  data.frame(chrom, chromStart, chromEnd, coverage)
}
four &lt;- rbind(
  r("chr1", 0, 10,  2),
  r("chr1", 10, 20, 10),
  r("chr1", 20, 30, 14),
  r("chr1", 30, 40, 13))
dir.create(prob.dir &lt;- tempfile())
coverage.bedGraph &lt;- file.path(prob.dir, "coverage.bedGraph")
write.table(
  four, coverage.bedGraph,
  sep="\t", row.names=FALSE, col.names=FALSE)
pstr &lt;- "10.5"
result.list &lt;- PeakSegDisk::PeakSegFPOP_file(coverage.bedGraph, pstr)
dir(prob.dir)

## segments file can be read to see optimal segment means.
outf &lt;- function(suffix){
  paste0(coverage.bedGraph, "_penalty=", pstr, suffix)
}
segments.bed &lt;- outf("_segments.bed")
seg.df &lt;- read.table(segments.bed)
names(seg.df) &lt;- col.name.list$segments
seg.df

## loss file can be read to see optimal Poisson loss, etc.
loss.tsv &lt;- outf("_loss.tsv")
loss.df &lt;- read.table(loss.tsv)
names(loss.df) &lt;- col.name.list$loss
loss.df

</code></pre>

<hr>
<h2 id='PeakSegFPOP_vec'>PeakSeg penalized solver for integer vector</h2><span id='topic+PeakSegFPOP_vec'></span>

<h3>Description</h3>

<p>Convert integer data vector to run-length encoding,
then run <code><a href="#topic+PeakSegFPOP_df">PeakSegFPOP_df</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakSegFPOP_vec(count.vec, 
    pen.num)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakSegFPOP_vec_+3A_count.vec">count.vec</code></td>
<td>
<p>integer vector, noisy non-negatve count data to segment.</p>
</td></tr>
<tr><td><code id="PeakSegFPOP_vec_+3A_pen.num">pen.num</code></td>
<td>
<p>Non-negative numeric scalar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of solver results, same as <code><a href="#topic+PeakSegFPOP_dir">PeakSegFPOP_dir</a></code>.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate a sequence of Poisson data.
sim.seg &lt;- function(seg.mean, size.mean=15){
  seg.size &lt;- rpois(1, size.mean)
  rpois(seg.size, seg.mean)
}
set.seed(1)
seg.mean.vec &lt;- c(1.5, 3.5, 0.5, 4.5, 2.5)
z.list &lt;- lapply(seg.mean.vec, sim.seg)
z.rep.vec &lt;- unlist(z.list)

## Plot the simulated data.
if(require(ggplot2)){
  count.df &lt;- data.frame(
    position=seq_along(z.rep.vec),
    count=z.rep.vec)
  gg.count &lt;- ggplot()+
    geom_point(aes(
      position, count),
      shape=1,
      data=count.df)
  print(gg.count)
  ## Plot the true changepoints.
  n.segs &lt;- length(seg.mean.vec)
  seg.size.vec &lt;- sapply(z.list, length)
  seg.end.vec &lt;- cumsum(seg.size.vec)
  change.vec &lt;- seg.end.vec[-n.segs]+0.5
  change.df &lt;- data.frame(
    changepoint=change.vec)
  gg.change &lt;- gg.count+
    geom_vline(aes(
      xintercept=changepoint),
      data=change.df)
  print(gg.change)
  ## Fit a peak model and plot it.
  fit &lt;- PeakSegDisk::PeakSegFPOP_vec(z.rep.vec, 10.5)
  print(
    gg.change+
      geom_segment(aes(
        chromStart+0.5, mean, xend=chromEnd+0.5, yend=mean),
        color="green",
        data=fit$segments)
  )
  ## A pathological data set.
  z.slow.vec &lt;- 1:length(z.rep.vec)
  fit.slow &lt;- PeakSegDisk::PeakSegFPOP_vec(z.slow.vec, 10.5)
  rbind(fit.slow$loss, fit$loss)
}

</code></pre>

<hr>
<h2 id='plot.PeakSegFPOP_df'>plot PeakSegFPOP df</h2><span id='topic+plot.PeakSegFPOP_df'></span>

<h3>Description</h3>

<p>Plot a PeakSeg model with attached data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PeakSegFPOP_df'
plot(x, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PeakSegFPOP_df_+3A_x">x</code></td>
<td>
<p>x </p>
</td></tr>
<tr><td><code id="plot.PeakSegFPOP_df_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='plot.PeakSegFPOP_dir'>plot PeakSegFPOP dir</h2><span id='topic+plot.PeakSegFPOP_dir'></span>

<h3>Description</h3>

<p>Plot a PeakSeg model with attached data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PeakSegFPOP_dir'
plot(x, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PeakSegFPOP_dir_+3A_x">x</code></td>
<td>
<p>x </p>
</td></tr>
<tr><td><code id="plot.PeakSegFPOP_dir_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='sequentialSearch_dir'>Compute PeakSeg model with given number of peaks</h2><span id='topic+sequentialSearch_dir'></span>

<h3>Description</h3>

<p>Compute the most likely peak model with at most the number of
peaks given by <code>peaks.int</code>. This function repeated calls
<code><a href="#topic+PeakSegFPOP_dir">PeakSegFPOP_dir</a></code> with different penalty values, until either
(1) it finds the <code>peaks.int</code> model, or (2) it concludes that there
is no <code>peaks.int</code> model, in which case it returns the next simplest
model (with fewer peaks than <code>peaks.int</code>).
The first pair of penalty values (0, Inf) is run in parallel
via the user-specified future plan,
if the future.apply package is available.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequentialSearch_dir(problem.dir, 
    peaks.int, verbose = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequentialSearch_dir_+3A_problem.dir">problem.dir</code></td>
<td>
<p>problemID directory in which coverage.bedGraph has already been
computed. If there is a labels.bed file then the number of
incorrect labels will be computed in order to find the target
interval of minimal error penalty values.</p>
</td></tr>
<tr><td><code id="sequentialSearch_dir_+3A_peaks.int">peaks.int</code></td>
<td>
<p>int: target number of peaks.</p>
</td></tr>
<tr><td><code id="sequentialSearch_dir_+3A_verbose">verbose</code></td>
<td>
<p>numeric verbosity: if &gt;0 then <code><a href="base.html#topic+cat">cat</a></code> is used to print a message
for each penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same result list from <code><a href="#topic+PeakSegFPOP_dir">PeakSegFPOP_dir</a></code>, with an additional
component &quot;others&quot; describing the other models that were computed
before finding the optimal model with <code>peaks.int</code> (or fewer)
peaks. Additional loss columns are as follows: under=number of
peaks in smaller model during binary search; over=number of peaks
in larger model during binary search; iteration=number of times
PeakSegFPOP has been run.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create simple 6 point data set discussed in supplementary
## materials. GFPOP/GPDPA computes up-down model with 2 peaks, but
## neither CDPA (PeakSegDP::cDPA) nor PDPA (jointseg)
r &lt;- function(chrom, chromStart, chromEnd, coverage){
  data.frame(chrom, chromStart, chromEnd, coverage)
}
supp &lt;- rbind(
  r("chr1", 0, 1,  3),
  r("chr1", 1, 2, 9),
  r("chr1", 2, 3, 18),
  r("chr1", 3, 4, 15),
  r("chr1", 4, 5, 20),
  r("chr1", 5, 6, 2)
)
data.dir &lt;- file.path(tempfile(), "chr1-0-6")
dir.create(data.dir, recursive=TRUE)
write.table(
  supp, file.path(data.dir, "coverage.bedGraph"),
  sep="\t", row.names=FALSE, col.names=FALSE)

## register a parallel future plan to compute the first two
## penalties in parallel during the sequential search.
if(interactive() &amp;&amp; requireNamespace("future"))future::plan("multisession")

## Compute optimal up-down model with 2 peaks via sequential search.
fit &lt;- PeakSegDisk::sequentialSearch_dir(data.dir, 2L)

if(require(ggplot2)){
  ggplot()+
    theme_bw()+
    geom_point(aes(
      chromEnd, coverage),
      data=supp)+
    geom_segment(aes(
      chromStart+0.5, mean,
      xend=chromEnd+0.5, yend=mean),
      data=fit$segments,
      color="green")
}

</code></pre>

<hr>
<h2 id='summary.PeakSegFPOP_dir'>summary PeakSegFPOP dir</h2><span id='topic+summary.PeakSegFPOP_dir'></span>

<h3>Description</h3>

<p>Summary of <code><a href="#topic+PeakSegFPOP_dir">PeakSegFPOP_dir</a></code> <code>object</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PeakSegFPOP_dir'
summary(object, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PeakSegFPOP_dir_+3A_object">object</code></td>
<td>
<p>object </p>
</td></tr>
<tr><td><code id="summary.PeakSegFPOP_dir_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data table with one row and columns describing model summary.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='wc2int'>wc2int</h2><span id='topic+wc2int'></span>

<h3>Description</h3>

<p>Convert wc output to integer number of lines.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wc2int(wc.output)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wc2int_+3A_wc.output">wc.output</code></td>
<td>
<p>Character scalar: output from wc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='writeBedGraph'>Write bedGraph file</h2><span id='topic+writeBedGraph'></span>

<h3>Description</h3>

<p>Write a data.frame in R to a bedGraph file on disk. This must be a
plain text file with the following four columns: chrom (character
chromosome name), chromStart (integer start position), chromEnd
(integer end position), count (integer aligned read count on chrom
from chromStart+1 to chromEnd); see also
https://genome.ucsc.edu/goldenPath/help/bedgraph.html</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeBedGraph(count.df, 
    coverage.bedGraph)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeBedGraph_+3A_count.df">count.df</code></td>
<td>
<p>data.frame with four columns: chrom, chromStart, chromEnd, count.</p>
</td></tr>
<tr><td><code id="writeBedGraph_+3A_coverage.bedgraph">coverage.bedGraph</code></td>
<td>
<p>file path where data will be saved in plain text / bedGraph format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (same as write.table).</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PeakSegDisk)
data(Mono27ac, envir=environment())
coverage.bedGraph &lt;- file.path(
  tempfile(),
  "H3K27ac-H3K4me3_TDHAM_BP",
  "samples",
  "Mono1_H3K27ac",
  "S001YW_NCMLS",
  "problems",
  "chr11-60000-580000",
  "coverage.bedGraph")
dir.create(
  dirname(coverage.bedGraph),
  recursive=TRUE, showWarnings=FALSE)
writeBedGraph(Mono27ac$coverage, coverage.bedGraph)
fread.first(coverage.bedGraph, col.name.list$coverage)
fread.last(coverage.bedGraph, col.name.list$coverage)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
