<!DOCTYPE html><html><head><title>Help for package GENEAread</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GENEAread}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GENEAread-package'><p>A package to process binary accelerometer output files.</p></a></li>
<li><a href='#%bq%'><p>%bq%</p></a></li>
<li><a href='#%bt%'><p>%bt%</p></a></li>
<li><a href='#AccData'><p>Accelerometer Data Object</p></a></li>
<li><a href='#constrain'><p>Constrain</p></a></li>
<li><a href='#conv01'><p>convert vector</p></a></li>
<li><a href='#convert.hexstream'><p>convert.hexstream</p></a></li>
<li><a href='#convert.intstream'><p>convert.instream</p></a></li>
<li><a href='#convert.time'><p>convert.time</p></a></li>
<li><a href='#epoch'><p>Compute epochal summary statistics.</p></a></li>
<li><a href='#expand'><p>expand</p></a></li>
<li><a href='#g.downsample'><p>g.downsample</p></a></li>
<li><a href='#GENEActiv.calibrate'><p>GENEActiv.calibrate</p></a></li>
<li><a href='#get.intervals'><p>Extract an interval of data.</p></a></li>
<li><a href='#getfreqs'><p>getfreqs</p></a></li>
<li><a href='#GRtime'><p>Date time handling for the GENEAread package.</p></a></li>
<li><a href='#hanning.window'><p>Hanning Window</p></a></li>
<li><a href='#header.info'><p>Get header info from GENEA output (.bin) file</p></a></li>
<li><a href='#is.POSIXct'><p>Utility functions to be used within GENEAread</p></a></li>
<li><a href='#parse.time'><p>Parses a character time representation to another format.</p></a></li>
<li><a href='#plot.stft'><p>plot stft</p></a></li>
<li><a href='#print.stft'><p>print.stft</p></a></li>
<li><a href='#pseudolines'><p>pseudoline</p></a></li>
<li><a href='#recalibrate'><p>recalibrate</p></a></li>
<li><a href='#removeZero'><p>removezero</p></a></li>
<li><a href='#seq.log'><p>seq.log</p></a></li>
<li><a href='#shift'><p>shift</p></a></li>
<li><a href='#stft'><p>Computes Short Time Fourier Transforms</p></a></li>
<li><a href='#stftcalc'><p>calculate the fft components</p></a></li>
<li><a href='#subs'><p>subs</p></a></li>
<li><a href='#svm'><p>sum vector magnitude</p></a></li>
<li><a href='#uniform.window'><p>Uniform Window</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Package for Reading Binary Files</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jia Ying Chua &lt;jiayingc@activinsights.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and analytics for GENEA-compatible accelerometer data into R objects. 
             See topic 'GENEAread' for an introduction to the package. 
             See <a href="https://activinsights.com/technology/geneactiv/">https://activinsights.com/technology/geneactiv/</a> for more details on the GENEActiv device.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>bitops, mmap</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 15:32:24 UTC; JiaYingChua</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhou Fang [aut],
  Joss Langford [aut],
  Charles Sweetland [aut],
  Jia Ying Chua [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 17:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='GENEAread-package'>A package to process binary accelerometer output files.</h2><span id='topic+GENEAread-package'></span><span id='topic+read.bin'></span><span id='topic+GENEAread'></span>

<h3>Description</h3>

<p>This is a package to process binary output files from the GENEA accelerometer data.
</p>
<p>The main functions are: </p>

<ul>
<li><p> read.bin
</p>
</li>
<li><p> stft
</p>
</li>
<li><p> epoch
</p>
</li></ul>

<p>A function to process binary accelerometer files and convert the information into R objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.bin(
  binfile,
  outfile = NULL,
  start = NULL,
  end = NULL,
  Use.Timestamps = FALSE,
  verbose = TRUE,
  do.temp = TRUE,
  do.volt = TRUE,
  calibrate = TRUE,
  downsample = NULL,
  blocksize,
  virtual = FALSE,
  mmap.load = (.Machine$sizeof.pointer &gt;= 8),
  pagerefs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GENEAread-package_+3A_binfile">binfile</code></td>
<td>
<p>A filename of a file to process.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_outfile">outfile</code></td>
<td>
<p>An optional filename specifying where to save the processed data object.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_start">start</code></td>
<td>
<p>Either: A representation of when in the file to begin processing, see Details.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_end">end</code></td>
<td>
<p>Either: A representation of when in the file to end processing, see Details.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_use.timestamps">Use.Timestamps</code></td>
<td>
<p>To use timestamps as the start and end time values this has to be set to TRUE. (Default FALSE)</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_verbose">verbose</code></td>
<td>
<p>A boolean variable indicating whether some information should be printed during
processing should be printed.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_do.temp">do.temp</code></td>
<td>
<p>A boolean variable indicating whether the temperature signal should be extracted</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_do.volt">do.volt</code></td>
<td>
<p>A boolean variable indicating whether the voltage signal should be extracted.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_calibrate">calibrate</code></td>
<td>
<p>A boolean variable indicating whether the raw accelerometer values and the light
variable should be calibrated according to the calibration data in the headers.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_downsample">downsample</code></td>
<td>
<p>A variable indicating the type of downsampling to apply to the data as it is loaded.
Can take values:
NULL: (Default) No downsampling
Single numeric: Reads every downsample-th value, starting from the first.
Length two numeric vector: Reads every downsample[1]-th value, starting from
the downsample[2]-th.
Non-integer, or non-divisor of 300 downsampling factors are allowed, but will
lead to imprecise frequency calculations, leap seconds being introduced, and
generally potential problems with other methods. Use with care.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_blocksize">blocksize</code></td>
<td>
<p>Integer value giving maximum number of data pages to read in each pass. Defaults
to 10000 for larger data files. Sufficiently small sizes will split very
large data files to read chunk by chunk, reducing memory requirements for the
read.bin function (without affecting the final object), but conversely possibly
increasing processing time. Can be set to Inf for no splitting.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_virtual">virtual</code></td>
<td>
<p>logical. If set TRUE, do not do any actual data reading. Instead construct a VirtualAccData
object containing header information to allow use with get.intervals</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_mmap.load">mmap.load</code></td>
<td>
<p>Default is (.Machine$sizeof.pointer &gt;= 8). see <code><a href="mmap.html#topic+mmap">mmap</a></code> for more details</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_pagerefs">pagerefs</code></td>
<td>
<p>A variable that can take two forms, and is considered only for <code>mmap.load = TRUE</code>
NULL or FALSE, in which case pagerefs are dynamically calculated for each record. (Default)
A vector giving sorted byte offsets for each record for mmap reading of data files.
TRUE, in which case a full page reference table is computed before any processing occurs.
</p>
<p>Computing pagerefs takes a little time and so is a little slower.
However, it is safer than dynamic computations in the case of missing pages and high temperature variations.
Further, once page references are calculated, future reads are much faster, so long as the previously
computed references are supplied.</p>
</td></tr>
<tr><td><code id="GENEAread-package_+3A_...">...</code></td>
<td>
<p>Any other optional arguments can be supplied that affect manual calibration and data processing.
These are: </p>

<ul>
<li><p> mmap: logical. If TRUE (Default on 64bit R), use the mmap package to process the binfile
</p>
</li>
<li><p> gain: a vector of 3 values for manual gain calibration of the raw (x,y,z) axes. If gain=NULL, the
gain calibration values are taken from within the output file itself.
</p>
</li>
<li><p> offset: a vector of 3 value for manual offset calibration of the raw (x,y,z) axes. If offset=NULL,
the offset calibration values are taken from within the output file itself.
</p>
</li>
<li><p> luxv: a value for manual lux calibration of the light meter. If luxv=NULL, the lux calibration value
is taken from within the output file itself.
</p>
</li>
<li><p> voltv: a value for manual volts calibration of the light meter. If voltv=NULL, the volts calibration
value is taken from within the output file itself.
</p>
</li>
<li><p> warn: if set to true, give a warning if input file is large, and require user confirmation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The main tasks performed by the package are listed below.
The relevant topic contains documentation and examples for each.
</p>

<ul>
<li><p> Extraction of file header material is accomplished by <code><a href="#topic+header.info">header.info</a></code>.
</p>
</li>
<li><p> Input and downsampling of data is accomplished by <code><a href="#topic+read.bin">read.bin</a></code>.
</p>
</li>
<li><p> Selection of time intervals is accomplished via <code><a href="#topic+get.intervals">get.intervals</a></code>.
</p>
</li>
<li><p> Computation of epochal summaries is accomplished by <code><a href="#topic+epoch">epoch</a></code> and other functions documented therein.
</p>
</li>
<li><p> Computation of STFT analyses is accomplished by <code><a href="#topic+stft">stft</a></code>.
</p>
</li></ul>

<p>The package provides definitions and methods for the following S3 classes:
</p>

<ul>
<li><p> GRtime: Provides numeric storage and streamlined plotting for times. <code><a href="#topic+GRtime">GRtime</a></code>
</p>
</li>
<li><p> AccData: Stores GENEA accelerometer data, allowing plotting, subsetting and other computation.<code><a href="#topic+AccData">AccData</a></code>
</p>
</li>
<li><p> VirtAccData: A virtual AccData object, for just-in-time data access via <code><a href="#topic+get.intervals">get.intervals</a></code>.
</p>
</li>
<li><p> stft: Processed STFT outputs, for plotting via <code><a href="#topic+plot.stft">plot.stft</a></code>.
</p>
</li></ul>

<p>The read.bin package reads in binary files compatible with the GeneActiv line of Accelerometers,
for further processing by the other functions in this package. Most of the default options are those
required in the most common cases, though users are advised to consider setting start and end to
smaller intervals and/or choosing some level of downsampling when working with data files of
longer than 24 hours in length.
</p>
<p>The function reads in the desired analysis time window specified by start and end. For convenience,
a variety of time window formats are accepted:
</p>
<p>Large integers are read as page numbers in the dataset. Page numbers larger than that which is
available in the file itself are constrained to what is available. Note that the first page is page 1.
Small values (between 0 and 1) are taken as proportions of the data. For example, ‘start = 0.5‘
would specify that reading should begin at the midpoint of the data.
Strings are interpreted as dates and times using parse.time. In particular, times specified as
&quot;HH:MM&quot; or &quot;HH:MM:SS&quot; are taken as the earliest time interval containing these times in the
file. Strings with an integer prepended, using a space seperator, as interpreted as that time after
the appropriate number of midnights have passed - in other words, the appropriate time of day on
the Nth full day. Days of the week and dates in &quot;day/month&quot;, &quot;day/month/year&quot;, &quot;month-day&quot;,
&quot;year-month-day&quot; are also handled. Note that the time is interpreted in the same time zone as the
data recording itself.
</p>
<p>Actual data reading proceeds by two methods, depending on whether mmap is true or false. With
mmap = FALSE, data is read in line by line using readLine until blocksize is filled, and then
processed. With mmap = TRUE, the mmap package is used to map the entire data file into an address
file, byte locations are calculated (depending on the setting of pagerefs), blocksize chunks of
data are loaded, and then processed as raw vectors.
</p>
<p>There are advantages and disadvantages to both methods: the <code><a href="mmap.html#topic+mmap">mmap</a></code> method is usually much faster,
especially when we are only loading the final parts of the data. <code><a href="base.html#topic+readLines">readLines</a></code> will have to
process the entire file in such a case. On the other hand, mmap requires a large amount of memory address
space, and so can fail in 32 bit systems. Finally, reading of compressed bin files can only be done
with the readLine method. Generally, if mmap reading fails, the function will attempt to catch the
failure, and reprocess the file with the readLine method, giving a warning. Once data is loaded,
calibration is then either performed using values from the binary file, or using
manually inputted values (using the gain, offset,luxv and voltv arguments).
</p>


<h3>Main tasks performed</h3>

<p>NA
</p>


<h3>Classes implemented</h3>

<p>NA
</p>


<h3>WARNING</h3>

<p>Reading in an entire .bin file will take a long time if the file contains a lot of datasets.
Reading in such files without downsampling can use up all available memory. See memory.limit.
This function is specific to header structure in GENEActiv output files.
By design, it should be compatible with all firmware and software versions to date
(as of version of current release).
If order or field names are changed in future .bin files, this function may have to be updated appropriately.
</p>


<h3>Author(s)</h3>

<p>Zhou Fang &lt;zhou@activinsights.co.uk&gt;
</p>
<p>Activinsights Ltd. &lt;joss.langford@activinsights.co.uk&gt;
</p>
<p>Charles Sweetland &lt;charles@sweetland-solutions.co.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("GENEAread")
binfile = system.file("binfile/TESTfile.bin", package = "GENEAread")[1]
#Read in the entire file, calibrated
procfile &lt;- read.bin(binfile)
# print(procfile)
# procfile$data.out[1:5,]
# Uncalibrated, mmap off
procfile2 &lt;- read.bin(binfile, calibrate = FALSE)
# procfile2$data.out[1:5,]
#Read in again, reusing already computed mmap pagerefs
# procfile3 &lt;- read.bin(binfile, pagerefs = procfile2$pagerefs )
#Downsample by a factor of 10
procfilelo&lt;-read.bin(binfile, downsample = 10)
# print(procfilelo)
object.size(procfilelo) / object.size(procfile)
#Read in a 1 minute interval
procfileshort &lt;- read.bin(binfile, start = "16:50", end = "16:51")
# print(procfileshort)
##NOT RUN: Read, and save as a R workspace
#read.bin(binfile, outfile = "tmp.Rdata")
#print(load("tmp.Rdata"))
#print(processedfile)
</code></pre>

<hr>
<h2 id='+25bq+25'>%bq%</h2><span id='topic++25bq+25'></span>

<h3>Description</h3>

<p>quantile version of bt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X %bq% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25bq+2B25_+3A_x">X</code></td>
<td>
<p>First object to pass</p>
</td></tr>
<tr><td><code id="+2B25bq+2B25_+3A_y">y</code></td>
<td>
<p>Second object to pass</p>
</td></tr>
</table>

<hr>
<h2 id='+25bt+25'>%bt%</h2><span id='topic++25bt+25'></span>

<h3>Description</h3>

<p>between' operator for convenience
takes <code>[min, max)</code>, or <code>c("[", min, max, "]")</code> style second terms
default is <code>[min, max]</code> for c(,) terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X %bt% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25bt+2B25_+3A_x">X</code></td>
<td>
<p>First object to pass</p>
</td></tr>
<tr><td><code id="+2B25bt+2B25_+3A_y">y</code></td>
<td>
<p>Second object to pass</p>
</td></tr>
</table>

<hr>
<h2 id='AccData'>Accelerometer Data Object</h2><span id='topic+AccData'></span>

<h3>Description</h3>

<p>Accelerometer Data Output from read.bin function
</p>


<h3>Format</h3>

<p>An AccData object
</p>


<h3>Source</h3>

<p>Output of <code><a href="#topic+read.bin">read.bin</a></code>
</p>


<h3>See Also</h3>

<p><code>read.bin</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace("GENEAread")
binfile  = system.file("binfile/TESTfile.bin", package = "GENEAread")[1]
#Read in the entire file, calibrated
procfile&lt;-read.bin(binfile)
print(procfile)

plot(procfile$temperature,
xlim = c(min(procfile$data.out[,1]),
        max(procfile$data.out[,1])),
ylim = c(10,40))

plot(procfile$data.out[,c(1,7)])
</code></pre>

<hr>
<h2 id='constrain'>Constrain</h2><span id='topic+constrain'></span>

<h3>Description</h3>

<p>constrains a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrain(x, minimum, maximum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constrain_+3A_x">x</code></td>
<td>
<p>dataset that is to be constrained</p>
</td></tr>
<tr><td><code id="constrain_+3A_minimum">minimum</code></td>
<td>
<p>Value of the lowest acceptable number, before being replaced by this lower bound</p>
</td></tr>
<tr><td><code id="constrain_+3A_maximum">maximum</code></td>
<td>
<p>Value of the highest acceptable number, before being replaced by this upper bound</p>
</td></tr>
</table>

<hr>
<h2 id='conv01'>convert vector</h2><span id='topic+conv01'></span>

<h3>Description</h3>

<p>puts a vector into the range 0-1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv01(x)
</code></pre>

<hr>
<h2 id='convert.hexstream'>convert.hexstream</h2><span id='topic+convert.hexstream'></span>

<h3>Description</h3>

<p>internal function for read.bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.hexstream(stream)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.hexstream_+3A_stream">stream</code></td>
<td>
<p>Data from GENEActiv .bin file feed into this stream</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a decrypted raw data
</p>

<hr>
<h2 id='convert.intstream'>convert.instream</h2><span id='topic+convert.intstream'></span>

<h3>Description</h3>

<p>internal function for read.bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.intstream(stream)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.intstream_+3A_stream">stream</code></td>
<td>
<p>Data from GENEActiv .bin file feed into this stream</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a decrypted raw data
</p>

<hr>
<h2 id='convert.time'>convert.time</h2><span id='topic+convert.time'></span>

<h3>Description</h3>

<p>extends time display from package chron to use h:m:s for &gt; 1 day times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.time(x, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.time_+3A_x">x</code></td>
<td>
<p>Object to process. For convert.time, must be numeric.</p>
</td></tr>
<tr><td><code id="convert.time_+3A_format">format</code></td>
<td>
<p>A character string indicating the form of output. See <code><a href="base.html#topic+strptime">strptime</a></code> for details. If
NULL, will be automatically chosen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>convert.time converts numerics to GRtime objects. The format argument allows a format string to be attached
specifying the default format to display in. as.GRtime is a wrapper to convert.time, that when supplied with
character input, coerces the value first to numeric using parse.time.
</p>

<hr>
<h2 id='epoch'>Compute epochal summary statistics.</h2><span id='topic+epoch'></span><span id='topic+apply.epoch'></span><span id='topic+mean.epoch'></span><span id='topic+sd.epoch'></span><span id='topic+median.epoch'></span><span id='topic+mad.epoch'></span><span id='topic+acf.epoch'></span><span id='topic+autocor.epoch'></span><span id='topic+quantile.epoch'></span>

<h3>Description</h3>

<p>Computes epochal summary statistics for an &quot;AccData&quot; object, matrix, or vector, and collates into a matrix or vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.epoch(x, epoch.size = 10, incl.date = FALSE, FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epoch_+3A_x">x</code></td>
<td>
<p>The object to compute statistics for. Can be an &quot;AccData&quot; object, a matrix, or a vector.</p>
</td></tr>
<tr><td><code id="epoch_+3A_epoch.size">epoch.size</code></td>
<td>
<p>Numeric giving intervals to consider and aggregate. For &quot;AccData&quot; x taken as seconds. Otherwise, considered as rows, or as individual readings.</p>
</td></tr>
<tr><td><code id="epoch_+3A_incl.date">incl.date</code></td>
<td>
<p>logical. If TRUE, include a column of times or original indices with the results.</p>
</td></tr>
<tr><td><code id="epoch_+3A_fun">FUN</code></td>
<td>
<p>A function to be applied to each epoch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute epochal summary statistics for &quot;AccData&quot; objects, matrices and vectors.
</p>
<p>apply.epoch is the general function - according to the size of epoch.size, it splits up the x into collections
of consecutive rows, each with the same size. These are then successively supplied to FUN as its first argument.
If the result of FUN is a single value, then the results are concatenated into a vector output.
Otherwise, an array is formed with each row corresponding to a single epochal group. For AccData, the sampling
frequency of the dataset is used to interpret the epoch size in seconds. Otherwise, the raw record indices are used.
If incl.date is set, the original timestamp vector of the data, or the original indices, are downsampled and
included as the first column of the output.
</p>
<p>The remaining functions are wrappers that compute various commonly useful statistics &ndash; in particular, applied to
&quot;AccData&quot; objects and arrays, they by default compute the epochal SVM mean, standard deviation, median, median
absolute deviation, and autocorrelation, and sample quantiles respectively. (Arrays are treated as each column
representing the x, y, and z components respectively.) Applied to vector input, processing will occur without the
SVM calculation. This behaviour may be overridden by the sqrt setting, which will force the function to use the
squared (default for arrays and &quot;AccData&quot;) or original unit (default for vectors) values in the statistical analysis.
</p>


<h3>Value</h3>

<p>A vector or array giving the computed epochal summaries. With incl.date = TRUE,
the result is given as a data.frame suitable for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- read.bin(system.file("binfile/TESTfile.bin", package = "GENEAread")[1]
, calibrate = TRUE)

#look for the epochs that exceed a certain threshold 50% of the time
plot(apply.epoch( dat, epoch.size = 3 ,
                  FUN = function(t) mean(abs(svm(t) -1)&gt;0.2)&gt; 0.5 ), type = "l")

plot(dat[,1], svm(dat), log = "y", pch = ".")
lines(mean.epoch(dat, incl.date = TRUE), lwd = 2)
lines(mean.epoch(dat, epoch.size = 30, incl.date = TRUE), col = 2, lwd = 2)
# This should give all the same results, but by a different way
lines(apply.epoch(dat, epoch.size = 30,
                  FUN = function(A) mean(svm(A, FALSE)), incl.date = TRUE), col = 3)
epsize = 30
lines(apply.epoch(dat, epoch.size = epsize,
                  FUN = function(t) median(t[,1])),
                  apply.epoch(dat, epoch.size = epsize,
                  FUN = function(A) mean(svm(A, FALSE))), col = 4)
#note this is different
lines(apply.epoch(dat, epoch.size = epsize,
                  FUN = function(t) median(t[,1])),
                  apply.epoch(dat, epoch.size = epsize,
                              FUN = function(A) mean(svm(A, sqrt = TRUE)))^2,
                              col = 5)

#plot some statistics
par(mfrow = c(5,1), mar = c(1,4.5,1,1))
plot(sd.epoch(dat), type="l")
plot(median.epoch(dat), type= "l")
plot(mad.epoch(dat), type= "l")
plot(acf.epoch(dat), type = "l")
plot(autocor.epoch(dat), type= "l")
tmp = quantile.epoch(dat, quantiles= c(0.1, 0.25, 0.5, 0.75, 0.9)); matplot(tmp, type = "l")

## End(Not run)
</code></pre>

<hr>
<h2 id='expand'>expand</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>expand an object X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(X, length = (length(X) * 100))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_x">X</code></td>
<td>
<p>object to expand</p>
</td></tr>
<tr><td><code id="expand_+3A_length">length</code></td>
<td>
<p>length to expand object</p>
</td></tr>
</table>

<hr>
<h2 id='g.downsample'>g.downsample</h2><span id='topic+g.downsample'></span>

<h3>Description</h3>

<p>Downsamples a vector of numeric values at three time resolutions:
1 seconds, ws3 seconds, and ws2 second. Function is not intended for direct interaction
by package end user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.downsample(sig, fs, ws3, ws2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.downsample_+3A_sig">sig</code></td>
<td>
<p>Vector of numeric values</p>
</td></tr>
<tr><td><code id="g.downsample_+3A_fs">fs</code></td>
<td>
<p>Sample frequency</p>
</td></tr>
<tr><td><code id="g.downsample_+3A_ws3">ws3</code></td>
<td>
<p>epoch size, e.g 5 seconds</p>
</td></tr>
<tr><td><code id="g.downsample_+3A_ws2">ws2</code></td>
<td>
<p>epoch size, e.g 90 seconds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List with three object: var1, var2, and var3 corresponding to downsample
time series at 1 seconds, ws2 seconds, and ws3 seconds resoluton, respectively
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;vincentvanhees@gmail.com&gt;
</p>

<hr>
<h2 id='GENEActiv.calibrate'>GENEActiv.calibrate</h2><span id='topic+GENEActiv.calibrate'></span>

<h3>Description</h3>

<p>Function starts by identifying ten second windows of non-movement.
Next, the average acceleration per axis per window is used to estimate calibration error
(offset and scaling) per axis. The function provides recommended correction factors to address
the calibration error and a summary of the callibration procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GENEActiv.calibrate(
  binfile,
  use.temp = TRUE,
  spherecrit = 0.3,
  minloadcrit = 72,
  printsummary = TRUE,
  chunksize = c(),
  windowsizes = c(5, 900, 3600)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GENEActiv.calibrate_+3A_binfile">binfile</code></td>
<td>
<p>A filename of a file to process.</p>
</td></tr>
<tr><td><code id="GENEActiv.calibrate_+3A_use.temp">use.temp</code></td>
<td>
<p>use temperature sensor data for calibration</p>
</td></tr>
<tr><td><code id="GENEActiv.calibrate_+3A_spherecrit">spherecrit</code></td>
<td>
<p>The minimum required acceleration value (in g) on both sides of 0 g for each axis.
Used to judge whether the sphere is sufficiently populated</p>
</td></tr>
<tr><td><code id="GENEActiv.calibrate_+3A_minloadcrit">minloadcrit</code></td>
<td>
<p>The minimum number of hours the code needs to read for the autocalibration procedure
to be effective (only sensitive to multitudes of 12 hrs, other values will be ceiled).
After loading these hours only extra data is loaded if calibration error has not been reduced to under 0.01 g</p>
</td></tr>
<tr><td><code id="GENEActiv.calibrate_+3A_printsummary">printsummary</code></td>
<td>
<p>if TRUE will print a summary when done</p>
</td></tr>
<tr><td><code id="GENEActiv.calibrate_+3A_chunksize">chunksize</code></td>
<td>
<p>number between 0.2 and 1 to specificy the size of chunks to be loaded as a fraction
of a 12 hour period, e.g. 0.5 equals 6 hour chunks. The default is 1 (12 hrs).
For machines with less than 4Gb of RAM memory a value below 1 is recommended.</p>
</td></tr>
<tr><td><code id="GENEActiv.calibrate_+3A_windowsizes">windowsizes</code></td>
<td>
<p>Three values to indicate the lengths of the windows as in c(window1,window2,window3):
window1 is the short epoch length in seconds and by default 5 this is the time window over which
acceleration and angle metrics are calculated, window2 is the long epoch length in seconds for which
non-wear and signal clipping are defined, default 900. However, window3 is the window length of data used
for non-wear detection and by default 3600 seconds. So, when window3 is larger than window2 we use
overlapping windows, while if window2 equals window3 non-wear periods are assessed by non-overlapping
windows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outputs from the function are as follows </p>

<ul>
<li><p> scale scaling correction values, e.g. c(1,1,1)
</p>
</li>
<li><p> offset offset correction values, e.g. c(0,0,0)
</p>
</li>
<li><p> tempoffset correction values related to temperature, e.g. c(0,0,0)
</p>
</li>
<li><p> cal.error.start absolute difference between Euclidean norm during all non-movement windows and 1 g before autocalibration
</p>
</li>
<li><p> cal.error.end absolute difference between Euclidean norm during all non-movement windows and 1 g after autocalibration
</p>
</li>
<li><p> spheredata average, standard deviation, Euclidean norm and temperature (if available) for all ten second non-movement windows as used for the autocalibration procedure
</p>
</li>
<li><p> npoints number of 10 second no-movement windows used to populate the sphere
</p>
</li>
<li><p> nhoursused number of hours of measurement data scanned to find the ten second time windows with no movement
</p>
</li>
<li><p> meantempcal mean temperature corresponding to the data as used for autocalibration.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;vincentvanhees@gmail.com&gt;
Zhou Fang
Charles Sweetland &lt;charles@Sweetland-solutions.co.uk&gt;
</p>


<h3>References</h3>

<p>van Hees VT, Fang Z, Langford J, Assah F, Mohammad A, da Silva IC, Trenell MI, White T,
Wareham NJ, Brage S. Auto-calibration of accelerometer data for free-living physical activity assessment
using local gravity and temperature: an evaluation on four continents. J Appl Physiol (1985). 2014 Aug 7
</p>

<hr>
<h2 id='get.intervals'>Extract an interval of data.</h2><span id='topic+get.intervals'></span><span id='topic+print.VirtAccData'></span><span id='topic+VirtAccData'></span>

<h3>Description</h3>

<p>Function for extracting sub intervals of data, and implementation of just-in-time loading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.intervals(x, start=0, end = 1, length = NULL,
time.format = c("auto", "seconds", "days", "proportion", "measurements", "time"),
incl.date = FALSE, simplify = TRUE ,read.from.file=FALSE, size=Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.intervals_+3A_x">x</code></td>
<td>
<p>Object to process. Can be array,</p>
</td></tr>
<tr><td><code id="get.intervals_+3A_start">start</code></td>
<td>
<p>Start of interval.</p>
</td></tr>
<tr><td><code id="get.intervals_+3A_end">end</code></td>
<td>
<p>End of interval.</p>
</td></tr>
<tr><td><code id="get.intervals_+3A_length">length</code></td>
<td>
<p>Length of interval.</p>
</td></tr>
<tr><td><code id="get.intervals_+3A_time.format">time.format</code></td>
<td>
<p>Method with which <code>start</code> and <code>end</code> should be understood.</p>
</td></tr>
<tr><td><code id="get.intervals_+3A_incl.date">incl.date</code></td>
<td>
<p>logical. Include a column denoting time?</p>
</td></tr>
<tr><td><code id="get.intervals_+3A_simplify">simplify</code></td>
<td>
<p>logical. If TRUE, output an array. Otherwise output a AccData object.</p>
</td></tr>
<tr><td><code id="get.intervals_+3A_read.from.file">read.from.file</code></td>
<td>
<p>logical. If TRUE, re-read the relevant time interval from the original bin file.</p>
</td></tr>
<tr><td><code id="get.intervals_+3A_size">size</code></td>
<td>
<p>Desired number of samples in output.</p>
</td></tr>
<tr><td><code id="get.intervals_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+read.bin">read.bin</a></code>, if <code>read.from.file</code> is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts the desired analysis time window specified by <code>start</code> and <code>end</code>.
If length is specified, then the end is set to a point <code>length</code> units after start.
The times are interpreted in terms of <code>time.format</code>. For convenience, a variety of time
window formats are accepted: </p>

<ul>
<li><p> &quot;seconds&quot;: Seconds since start of dataset.
</p>
</li>
<li><p> &quot;days&quot;: Days since start of dataset.
</p>
</li>
<li><p> &quot;proportion&quot;: Proportional point within dataset, given as a numeric between 0 and 1.
</p>
</li>
<li><p> &quot;measurements&quot;: Raw number of samples since start of dataset.
</p>
</li>
<li><p> &quot;time&quot;: Time string, as understood via <code><a href="#topic+parse.time">parse.time</a></code>.
</p>
</li>
<li><p> &quot;auto&quot;: Default - attempt to determine time format from size and type of <code>start</code>.
</p>
</li></ul>

<p>Some capacity for using mixed types of inputs for <code>start</code> and <code>length</code> in particular is present.
</p>
<p>The input object <code>x</code> is typically an &quot;AccData&quot; object, though arrays are also accepted. &quot;VirtAccData&quot;
are dealt with by using the timestamp and call information recorded within them to do a new read of the
original bin file, assuming this is still available. This is useful for 'just in time' reads of data.
&quot;AccData&quot; can be dealt with in this way by setting <code>read.from.file</code>.
</p>
<p>Note that for <code>read.from.file</code>, only &quot;time&quot; and &quot;proportion&quot; <code>time.format</code> are presently supported.
</p>
<p>With <code>simplify = FALSE</code>, an &quot;AccData&quot; S3 object with the desired records.
Otherwise, an array containing either 3 or 4 columns, containing the x, y, z acceleration vectors and optionally a time vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bin">read.bin</a></code>, <code><a href="#topic+AccData">AccData</a></code>, <code><a href="#topic+get.intervals">get.intervals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
binfile  = system.file("binfile/TESTfile.bin", package = "GENEAread")[1]

#Read in a highly downsampled version of the file
procfile&lt;-read.bin(binfile, downsample = 100)
print(procfile)

#Overlay some segments in different colour
lines(get.intervals(procfile, start = 0.4, end = 0.5,
                    time.format = "prop", incl.date = TRUE)[,1:2],
                    col=2)

lines(get.intervals(procfile, start = 0.4, end = 5,
                    time.format = "sec", incl.date = TRUE)[,1:2],
                    col=3)

lines(get.intervals(procfile, start = "16:51", end = "16:52",
                    time.format = "time", incl.date = TRUE)[,1:2],
                    col=4)

# Note that measurements will depend on the downsampling rate,
# not the original sampling rate of the data
lines(get.intervals(procfile, start = 100, length = 10,
                    time.format = "measurement", incl.date = TRUE)[,1:2],
                    col=5)

#This is also understood
lines(get.intervals(procfile, start = "16:52:10", 30,
                    incl.date = TRUE)[,1:2],
                    col=6)

#Now load in virtually
virtfile&lt;-read.bin(binfile, virtual = TRUE)
#Notice that get.intervals with simplify = FALSE gives a genuine AccData object
realfile = get.intervals(virtfile, start = 0.5, end = 1, simplify = FALSE)
virtfile
realfile
#get.intervals calls read.bin automatically
points(get.intervals(virtfile, start = "16:52:10", "16:52:40",
                     incl.date = TRUE)[,1:2], col=4, pch = ".")

#Alternatively, re-read procfile at a different resampling rate.
lines(get.intervals(procfile, start = "16:49:00", "16:49:30",
                    incl.date = TRUE, read.from.file = TRUE, downsample = 300)[,1:2],
                    col=2)

</code></pre>

<hr>
<h2 id='getfreqs'>getfreqs</h2><span id='topic+getfreqs'></span>

<h3>Description</h3>

<p>gets fft components corresponding to frequencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getfreqs(x, frequencies)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getfreqs_+3A_x">x</code></td>
<td>
<p>stft object</p>
</td></tr>
<tr><td><code id="getfreqs_+3A_frequencies">frequencies</code></td>
<td>
<p>frequencies range</p>
</td></tr>
</table>

<hr>
<h2 id='GRtime'>Date time handling for the GENEAread package.</h2><span id='topic+GRtime'></span><span id='topic+as.GRtime'></span><span id='topic+c.GRtime'></span><span id='topic+format.GRtime'></span><span id='topic+Axis.GRtime'></span><span id='topic+axis.GRtime'></span><span id='topic+Ops.GRtime'></span><span id='topic+pretty.GRtime'></span><span id='topic+print.GRtime'></span>

<h3>Description</h3>

<p>Stores date time data as a numeric, with facility for pretty printing and axis commands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.GRtime(x, format = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRtime_+3A_x">x</code></td>
<td>
<p>Object to process. For <code>convert.time</code>, must be numeric. For <code>as.GRtime</code> may be
numeric or character. For <code>format.GRtime</code>, a GRtime object, or a numeric.</p>
</td></tr>
<tr><td><code id="GRtime_+3A_format">format</code></td>
<td>
<p>A character string indicating the form of output. See <code><a href="base.html#topic+strptime">strptime</a></code> for details.
If NULL, will be automatically chosen.</p>
</td></tr>
<tr><td><code id="GRtime_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+parse.time">parse.time</a></code>, <code><a href="base.html#topic+as.numeric">as.numeric</a></code>,
<code><a href="base.html#topic+format.POSIXct">format.POSIXct</a></code>, <code><a href="graphics.html#topic+axis">axis</a></code>, <code><a href="grDevices.html#topic+pretty.POSIXt">pretty.POSIXt</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GRtime class handles dates and times for the GENEAread class. The class treats dates as numerics
denoting seconds since the UNIX epoch, with potentially a string attached specifying the format to print in.
Unlike <code>POSIXct</code>, we avoid some of the processing, especially with respect to time zones, and allow
some more flexibility in time computation and display. A range of operators are defined.
</p>
<p><code>convert.time</code> converts numerics to GRtime objects. The <code>format</code> argument allows a format
string to be attached specifying the default format to display in. <code>as.GRtime</code> is a wrapper to
<code>convert.time</code>, that when supplied with character input, coerces the value first to numeric using
<code>parse.time</code>.
</p>
<p><code>format.GRtime</code> formats GRtime objects for pretty printing. If <code>format</code> is provided as argument,
that is used. Else, if the <code>format</code> attribute is set on <code>x</code>, that is used. Finally, if formats
are not provided, and <code>x</code> is of length greater than one, the range of values of <code>x</code> is used to
decide the units displayed. Numerics are also accepted - they are coerced to GRtime.
</p>
<p><code>axis.GRtime</code> is used to plot GRtime axis, choosing, by default, breakpoints that give 'pretty' sub
intervals. Note that <code><a href="graphics.html#topic+plot.default">plot.default</a></code> uses <code>axis.GRtime</code> by default if supplied with a
GRtime object in one of the directions. However, <code><a href="graphics.html#topic+image.default">image.default</a></code> based functions do not use
the class axis functions, so axes must be plotted manually.
</p>
<p><code>pretty.GRtime</code> computes 'pretty' breakpoints, using the algorithm of <code>pretty.POSIXt</code>.
Attributes are preserved.
</p>

<ul>
<li><p> For <code>convert.time</code>, <code>as.GRtime</code> and <code>pretty.GRtime</code>, a GRtime object.
</p>
</li>
<li><p> For <code>format.GRtime</code> a character string representation.
</p>
</li>
<li><p> For <code>axis.GRtime</code> a list containing positions and labels for axis markers.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+parse.time">parse.time</a></code>, <code><a href="#topic+get.intervals">get.intervals</a></code>, <code><a href="#topic+AccData">AccData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.GRtime("00:01")
#format is automatically set
convert.time(1:10)
convert.time(1:10*1000)
#we add a different default format
convert.time(1:10*1000, "%H:%M:%OS3") -&gt; t
t
str(t)
# we override format with our own
format(t, format = "%a %d/%m/%y %H:%M:%OS3")

# plot calls axis.GRtime automatically. Notice
# that the format attribute is used.
plot(t, 1:10)
#strip out the default format
t2 = convert.time(t, format = NULL)
plot(t2, 1:10)

# image plots are a bit more complex

Z = matrix(rnorm(100), 10)
image(x = t, y = t2, z = Z, axes = FALSE)
Axis(x = t, side = 1) #Axis also works
box() #complete the bounding box

# custom axes
plot(t2, 1:10, xaxt = "n")

</code></pre>

<hr>
<h2 id='hanning.window'>Hanning Window</h2><span id='topic+hanning.window'></span>

<h3>Description</h3>

<p>A hanning window used by the STFT function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hanning.window(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hanning.window_+3A_n">n</code></td>
<td>
<p>number of points inside the window</p>
</td></tr>
</table>

<hr>
<h2 id='header.info'>Get header info from GENEA output (.bin) file</h2><span id='topic+header.info'></span>

<h3>Description</h3>

<p>Function to extract relevant header fields and values from a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>header.info(binfile, more=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="header.info_+3A_binfile">binfile</code></td>
<td>
<p>The file from which to extract the header</p>
</td></tr>
<tr><td><code id="header.info_+3A_more">more</code></td>
<td>
<p>logical. If TRUE, extract additional data from file useful for calibration and data reading.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts useful information from a .bin file, such as information about the GENEA device used to produce the output, and characteristics of the subject who wore the device. The function also accepts data that has been compressed in &lsquo;gzip&rsquo;, &lsquo;bzip2&rsquo; or &lsquo;xz&rsquo; formats. See <code>file</code>.
With <code>more</code> set to TRUE, additional data is extracted, mainly for internal use in <code>read.bin</code>.
</p>
<p>THis function is specific to header structure in GENEActiv output files. By design, it should be compatible with all firmware and software versions to date (as of version of current release). If order or field names are changed in future .bin files, this function may have to be updated appropriately.
The function works by looking for appropriate section headings in the .bin files.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with extracted header information, each row a particular header field with its value.
If <code>more</code> is TRUE, an attribute &quot;calibration&quot; is attached to the object, consisting of a list with measurement offsets, sampling frequency estimates, start times and time zones, data position offsets, and if mmap is detected, byte locations and increments for mmap reading.
</p>


<h3>Warning</h3>

<p>NA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.bin">read.bin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fileheader &lt;- header.info(system.file("binfile/TESTfile.bin",
                                      package = "GENEAread")[1],
                                      more = TRUE)
print(fileheader)
attr(fileheader, "calibration")

</code></pre>

<hr>
<h2 id='is.POSIXct'>Utility functions to be used within GENEAread</h2><span id='topic+is.POSIXct'></span>

<h3>Description</h3>

<p>To check the timestamps are of the correct format when using within read.bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.POSIXct(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.POSIXct_+3A_x">x</code></td>
<td>
<p>Time object passed to check class</p>
</td></tr>
</table>


<h3>Details</h3>

<p>utility function for checking timestamps
</p>

<hr>
<h2 id='parse.time'>Parses a character time representation to another format.</h2><span id='topic+parse.time'></span>

<h3>Description</h3>

<p>Converts a character vector in a variety of forms into either the raw second, second classed as POSIXct, or days since Unix epoch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.time(t="",format=c("seconds", "days", "POSIX"), tzone = 0,
 start = NULL, startmidnight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.time_+3A_t">t</code></td>
<td>
<p>A character string representation of a date-time expression.</p>
</td></tr>
<tr><td><code id="parse.time_+3A_format">format</code></td>
<td>
<p>A character string indicating which representation to output.  Can be either <code>seconds</code>, <code>days</code> or <code>POSIX</code>.</p>
</td></tr>
<tr><td><code id="parse.time_+3A_tzone">tzone</code></td>
<td>
<p>The time zone the time is given in, expressed as an offset from UTC in hours.</p>
</td></tr>
<tr><td><code id="parse.time_+3A_start">start</code></td>
<td>
<p>Earliest allowable time stamp in the data, as seconds since Unix epoch.</p>
</td></tr>
<tr><td><code id="parse.time_+3A_startmidnight">startmidnight</code></td>
<td>
<p>Midnight of day '0' in the data, as seconds since Unix epoch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function processes character vectors of the form &quot;DATE TIME&quot; &ndash; that is to say, a maximum of two terms separated by a space per value.
</p>
<p>&quot;TIME&quot; is given in 24 hour format, seperated by colons, in &quot;hh:mm&quot;, &quot;hh:mm:ss&quot;, &quot;hh:mm:ss:ms&quot; or &quot;hh:mm:ss.ms&quot; format. If ommitted, the time is taken to be 00:00:00.000.
</p>
<p>&quot;DATE&quot; can be a date representation as &quot;YYYY-MM-DD&quot;, &quot;DD/MM/YY&quot; or &quot;DD/MM/YYYY&quot; (noting the use of a colon or backslash seperator to distinguish between the two). Alternatively, with <code>start</code> and/or <code>startmidnight</code> supplied, an integer &quot;NN&quot; or string &quot;DOW&quot; corresponding to a day of the week can be used instead. Then, the function will find the first timestamp matching the correct &quot;TIME&quot;, that falls NN midnights after <code>startmidnight</code> and is after <code>start</code>, or, in the latter case, the first timestamp after the day of <code>start</code> that matches the appropriate day of the week. If a blank &quot;DATE&quot; is supplied, the function will either use the UNIX epoch, or find the first match, corresponding to the case NN = 0.
</p>
<p>Once this is done the time is converted to the required format: <code>POSIX</code> is the usual R POSIXct format; <code>days</code> is the julian days since UNIX epoch 1970-1-1; <code>seconds</code> is the number of seconds (including subseconds) since 1970-1-1. Note that for formats other than POSIX, the output is in the same timezone as <code>tzone</code>. POSIX stores the time internally as the time in UTC, and applies a format that gives this time local to the user.
</p>


<h3>Value</h3>

<p>A converted date-time string in the specified format. In the case of &quot;seconds&quot;, or &quot;days&quot;, a numeric. For POSIX, a <code><a href="base.html#topic+POSIXct">POSIXct</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert.time">convert.time</a></code>, <code><a href="#topic+get.intervals">get.intervals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 = parse.time("2012-06-21 13:04:01"); print(t1)
parse.time("21/06/12 13:04:01") #gives the same result

parse.time(c("19/07/70", "20/07/70"), format = "days")
#results here will depend on your locale
parse.time(c("19/07/70", "20/07/70"), format = "POSIX", tzone = -4)

#one is the same day, one can only find a match the next day
 parse.time("13:05", start = t1) - t1
 parse.time("13:00", start = t1) - t1
 #asking to wait 1 midnight means both times are considered as
 #times on the same, full day of data
 parse.time(c("1 13:05", "1 13:00"), start = t1) - t1
 #2012-06-21 is a Thursday, so this is equivalent
 parse.time(c("Fri 13:05", "Fri 13:00"), start = t1) - t1
 #Longer form days of the week are also understood. Note that
 #the first day does not get matched.
 parse.time(c("Thursday 13:05", "Thursday 13:00"), start = t1) - t1

</code></pre>

<hr>
<h2 id='plot.stft'>plot stft</h2><span id='topic+plot.stft'></span>

<h3>Description</h3>

<p>Processes a dataset, creating an object contained processed time-frequency analyses. These can then be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stft'
plot(
  x,
  mode = c("decibels", "modulus", "pval"),
  log = "",
  showmax = TRUE,
  median = FALSE,
  xaxis = TRUE,
  topthresh,
  reassign = (!(is.null(x$LGD)) &amp;&amp; !("mv" %in% x$type)),
  ylim,
  xlim,
  new = TRUE,
  zlim.raw,
  zlim.quantile,
  cex,
  col = gray(63:0/63),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stft_+3A_x">x</code></td>
<td>
<p>&quot;stft&quot; class object to be processed.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_mode">mode</code></td>
<td>
<p>What should be plotted? </p>

<ul>
<li><p> &quot;decibels&quot;: log10 of FFT modulus
</p>
</li>
<li><p> &quot;modulus&quot;: Raw FFT modulus
</p>
</li>
<li><p> &quot;pvalue&quot;: P-value of each frequence's modulus assuming that window was in fact white noise of equal equal standard deviation
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.stft_+3A_log">log</code></td>
<td>
<p>For <code>log = "y"</code>, use a log scale on the y axis.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_showmax">showmax</code></td>
<td>
<p>Vector or logical. Compute and plot the principle frequency components?</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_median">median</code></td>
<td>
<p>logical. If TRUE, smooth the STFT plot in the time direction with a running median.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_xaxis">xaxis</code></td>
<td>
<p>logical. If TRUE, plot pretty time axes.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_topthresh">topthresh</code></td>
<td>
<p>For finite values, crop plot for frequencies higher than this value, and show a summary plot up top.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_reassign">reassign</code></td>
<td>
<p>logical. Plot reassigned stft, if available?</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_xlim">xlim</code>, <code id="plot.stft_+3A_ylim">ylim</code></td>
<td>
<p>Parameters controlling axes limits of plot.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_new">new</code></td>
<td>
<p>logical. If TRUE, make a new plot. Otherwise overlay on to existing plot.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_zlim.raw">zlim.raw</code></td>
<td>
<p>Raw values at which to threshold values for computation of heatmap colours.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_zlim.quantile">zlim.quantile</code></td>
<td>
<p>Quantile values at which to threshold values for computation of heatmap colours.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_cex">cex</code></td>
<td>
<p>Size of points for reassigned STFT plotting.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_col">col</code></td>
<td>
<p>Vector of colours to be used for plotting.</p>
</td></tr>
<tr><td><code id="plot.stft_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>STFT objects are created by the <code><a href="#topic+stft">stft</a></code> function. These methods print some useful summary statistics about them, and produce plots.
<code>mode</code> determines the type of plot. &quot;decibel&quot; and &quot;modulus&quot; work with the raw values, while &quot;pvalue&quot; conducts some degree of normalisation in each time window and so is perhaps more useful for data showing a large variation in sd across different points in time. If the <code>null.calc</code> was set in the original stft argument, that is used - otherwise, an Exponential distribution is fit to each window, and the pvalues computed from that.
</p>
<p>By default, the function uses some empirical quantile based colour thresholds designed to give somewhat reasonable and informative plots. This can be overridden, however, by setting different <code>zlim.raw</code> or <code>zlim.quantile</code> results. This can be useful for comparing two different datasets.
</p>
<p>Reassigned stft plots are constructed, by default, when they are available, and when the original was not a &quot;mv&quot; stft. Unlike the heatmap used in the usual stft plot, a 2d scatterplot is used instead. This means that if there are few data points, it can be advantageous to set a higher <code>cex</code> value for larger points and better display.
</p>
<p>With Accelerometer data, often the frequencies of interest are concentrated at the lower frequencies. Topthresh crops the frequency display to show only those frequencies. A summary plot is show on the top, to compensate. Choosing a grid of frequencies, this plot draws one line to represent the energies present in the signal at that particular frequency, and higher. Black lines are drawn for frequencies less than 2/3 the <code>topthresh</code>, red lines for 2/3 - 1 times <code>topthresh</code>, and blue lines for frequencies higher than <code>topthresh</code>. Alternative, set <code>log = "y"</code> to put frequencies on a log scale.
</p>


<h3>Value</h3>

<p>These functions are run for their side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stft">stft</a></code>, <code><a href="graphics.html#topic+image.default">image.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: # Real data
 binfile  = system.file("binfile/TESTfile.bin", package = "GENEAread")[1]

#Read in the entire file, calibrated
 procfile&lt;-read.bin(binfile)
 #Create stft object
 obj = stft(procfile, type = "svm", quiet = TRUE)
 #Look at it
 print(obj)

 plot(obj, cex = 5)
 plot(obj, showmax = FALSE, cex = 5) #suppress principals

 #pval plot
 plot(obj, mode = "pval", cex = 5)
 #disable reassigned stft
 plot(obj, mode = "pval", reassign = FALSE)
 #median smoothing
 plot(obj, mode = "pval", reassign = FALSE, median = TRUE)
 #log scale frequency, no top bar
 dev.new(); plot(obj, mode = "pval", reassign = FALSE, topthresh = Inf, log = "y")

## End(Not run)
</code></pre>

<hr>
<h2 id='print.stft'>print.stft</h2><span id='topic+print.stft'></span>

<h3>Description</h3>

<p>print the stft object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stft'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stft_+3A_x">x</code></td>
<td>
<p>stft object</p>
</td></tr>
<tr><td><code id="print.stft_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='pseudolines'>pseudoline</h2><span id='topic+pseudolines'></span>

<h3>Description</h3>

<p>Plot a line graph, with breaks when things change too much
(assume x is sorted)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudolines(x, y = NULL, max.shift, new = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudolines_+3A_x">x</code></td>
<td>
<p>sorted vector</p>
</td></tr>
<tr><td><code id="pseudolines_+3A_y">y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="pseudolines_+3A_max.shift">max.shift</code></td>
<td>
<p>maximum to shift data</p>
</td></tr>
<tr><td><code id="pseudolines_+3A_new">new</code></td>
<td>
<p>Create new plot</p>
</td></tr>
</table>

<hr>
<h2 id='recalibrate'>recalibrate</h2><span id='topic+recalibrate'></span>

<h3>Description</h3>

<p>Taking a GENEActiv binfile and using the recalibration script to create a new calibrated binfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recalibrate(
  datadir,
  outputdir,
  use.temp = TRUE,
  spherecrit = 0.3,
  minloadcrit = 72,
  printsummary = TRUE,
  chunksize = c(0.5),
  windowsizes = c(60, 900, 3600)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recalibrate_+3A_datadir">datadir</code></td>
<td>
<p>The location of the directory/file containing GENEActiv binfile.</p>
</td></tr>
<tr><td><code id="recalibrate_+3A_outputdir">outputdir</code></td>
<td>
<p>The location of the directory/file for the calibrated files to be saved.</p>
</td></tr>
<tr><td><code id="recalibrate_+3A_use.temp">use.temp</code></td>
<td>
<p>Use temperature sensor data if available (Geneactive only)</p>
</td></tr>
<tr><td><code id="recalibrate_+3A_spherecrit">spherecrit</code></td>
<td>
<p>the minimum required acceleration value (in g) on both sides of 0 g for each
axis. Used to judge whether the sphere is sufficiently populated</p>
</td></tr>
<tr><td><code id="recalibrate_+3A_minloadcrit">minloadcrit</code></td>
<td>
<p>the minimum number of hours the code needs to read for the autocalibration
procedure to be effective (only sensitive to multitudes of 12 hrs, other values will be ceiled).
After loading these hours only extra data is loaded if calibration
error has not been reduced to under 0.01 g.</p>
</td></tr>
<tr><td><code id="recalibrate_+3A_printsummary">printsummary</code></td>
<td>
<p>if TRUE will print a summary when done chunksize number between 0.2 and 1
to specificy the size of chunks to be loaded as a fraction of a 12 hour period, e.g. 0.5 equals 6 hour chunks.
The default is 1 (12 hrs). For machines with less than 4Gb of RAM memory a value below 1 is recommended.</p>
</td></tr>
<tr><td><code id="recalibrate_+3A_chunksize">chunksize</code></td>
<td>
<p>number between 0.2 and 1 to specificy the size of chunks to be loaded as a fraction
of a 12 hour period, e.g. 0.5 equals 6 hour chunks. The default is 1 (12 hrs).
For machines with less than 4Gb of RAM memory a value below 1 is recommended.</p>
</td></tr>
<tr><td><code id="recalibrate_+3A_windowsizes">windowsizes</code></td>
<td>
<p>Three values to indicate the lengths of the windows as in c(window1,window2,window3):
window1 is the short epoch length in seconds and by default 5 this is the time window over which
acceleration and angle metrics are calculated, window2 is the long epoch length in seconds for which
non-wear and signal clipping are defined, default 900. However, window3 is the window length of data used
for non-wear detection and by default 3600 seconds. So, when window3 is larger than window2 we use
overlapping windows, while if window2 equals window3 non-wear periods are assessed by non-overlapping
windows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes each binfile found in the data directory, calibrates according to the routine by Vincent T. van Hees
and saves the calibrated file to the specificied output directory
</p>


<h3>Value</h3>

<p>Saves a calibrated binfile to an output folder
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
DataDirectory = "C:/Users/DataDirectory"
ReCalibrate(DataDirectory)

## End(Not run)
</code></pre>

<hr>
<h2 id='removeZero'>removezero</h2><span id='topic+removeZero'></span>

<h3>Description</h3>

<p>removes zero's from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeZero(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeZero_+3A_obj">obj</code></td>
<td>
<p>object to remove zeros from</p>
</td></tr>
</table>

<hr>
<h2 id='seq.log'>seq.log</h2><span id='topic+seq.log'></span>

<h3>Description</h3>

<p>Create a sequence of log values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'log'
seq(..., from = 1, to = 1, length.out = 50, add.zero = FALSE, shifting = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq.log_+3A_from">from</code></td>
<td>
<p>Value to Create the sequence from. default to 1.</p>
</td></tr>
<tr><td><code id="seq.log_+3A_to">to</code></td>
<td>
<p>Value to create the sequence to. default to 1</p>
</td></tr>
<tr><td><code id="seq.log_+3A_length.out">length.out</code></td>
<td>
<p>length of list outputted</p>
</td></tr>
<tr><td><code id="seq.log_+3A_add.zero">add.zero</code></td>
<td>
<p>include 0 at the start</p>
</td></tr>
<tr><td><code id="seq.log_+3A_shifting">shifting</code></td>
<td>
<p>Shifting the sequence by this value</p>
</td></tr>
</table>

<hr>
<h2 id='shift'>shift</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p>shift an object x in a direction/expansion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(x, offset, expand = 0, fill = c("zero", "edge", "loop", "mean"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p>data object to process</p>
</td></tr>
<tr><td><code id="shift_+3A_offset">offset</code></td>
<td>
<p>2 integers to offset a dataset</p>
</td></tr>
<tr><td><code id="shift_+3A_expand">expand</code></td>
<td>
<p>2 integer list to expand the dataset</p>
</td></tr>
<tr><td><code id="shift_+3A_fill">fill</code></td>
<td>
<p>method to run on the shift</p>
</td></tr>
</table>

<hr>
<h2 id='stft'>Computes Short Time Fourier Transforms</h2><span id='topic+stft'></span>

<h3>Description</h3>

<p>Processes a dataset, creating an object contained processed time-frequency analyses. These can then be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stft(X, start=0, end=1, length=NULL,  time.format = c("auto"),
            type = c("mv", "svm", "sum"), mv.indices,
            date.col,  reassign = TRUE, plot.it = FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stft_+3A_x">X</code></td>
<td>
<p>The dataset to be processed.</p>
</td></tr>
<tr><td><code id="stft_+3A_start">start</code>, <code id="stft_+3A_end">end</code>, <code id="stft_+3A_length">length</code>, <code id="stft_+3A_time.format">time.format</code></td>
<td>
<p>A specification for the segment to process, as in get.intervals.</p>
</td></tr>
<tr><td><code id="stft_+3A_type">type</code></td>
<td>
<p>The type of STFT to compute.</p>
</td></tr>
<tr><td><code id="stft_+3A_mv.indices">mv.indices</code></td>
<td>
<p>For type = &quot;mv&quot; or type = &quot;sum&quot;, the indices to process and the order to process them in.</p>
</td></tr>
<tr><td><code id="stft_+3A_date.col">date.col</code></td>
<td>
<p>logical. Whether the first column should be ignored and treated as a timestamp. If unset, is automatically chosen.</p>
</td></tr>
<tr><td><code id="stft_+3A_reassign">reassign</code></td>
<td>
<p>logical. If TRUE, compute the time-reassigned STFT. For type c(&quot;mv&quot;, &quot;sum&quot;), this is done with the first coordinate in mv.indices.</p>
</td></tr>
<tr><td><code id="stft_+3A_plot.it">plot.it</code></td>
<td>
<p>logical. Whether to plot the STFT immediately when processing is complete, using the default plot.stft options.</p>
</td></tr>
<tr><td><code id="stft_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to control the STFT computation. These are:</p>

<ul>
<li><p> win: Window size in seconds for STFT computation. Increased window size mean better frequency resolution, but poorer time resolution. Defaults to 10 seconds.
</p>
</li>
<li><p> inc: Increment between successive time steps for processing. Defaults to win/2.
</p>
</li>
<li><p> coef: Number of fourier frequencies to compute. Small values will remove the higher frequencies from the processed object. Defaults to the maximum, win/2.
</p>
</li>
<li><p> wtype: String giving the name of a window function, providing coefficients for filtering before processing. &quot;hanning.window&quot; is the default, with &quot;uniform.window&quot; also available.
</p>
</li>
<li><p> freq: Sampling frequency of data set. If not given, is taken from X itself, or assumed to be 1 if unavailable.
</p>
</li>
<li><p> centre: If TRUE (Default), centre the data in each window before processing is done. Useful for avoiding excessively large DC offset coefficients in results.
</p>
</li>
<li><p> calc.null: If TRUE (Defaults to FALSE), compute a 'null' STFT by resampling the data completely, then doing a STFT.
</p>
</li>
<li><p> pvalues: If TRUE (Defaults to FALSE) Compute bootstrapped pvalues for each position by resampling within each window and applying a wilcox test.
</p>
</li>
<li><p> time: Allows the user to set an overriding timestamp vector to be used for processing.
</p>
</li>
<li><p> quiet: If TRUE, suppress output.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts input in a variety of forms and computes short time fourier transforms to
extract frequency structure from the data.X may be an array, a vector, or an AccData object.
If date.col is TRUE, the first column of an array X would be used to determine timestamps.
Otherwise indices would be used. If date.col is not set, the function will attempt to determine whether
the first column is timestamp-like. The timestamp column is removed from X (and so not included in
consideration of mv.indices, for instance).
With vectors, the basic method is to compute the STFT by creating windows of size win seconds every
inc seconds, and computing the fourier transform. With multi-dimensional data and AccData,
processing is done on the dimensions that are in mv.indices, or the first three non-date columns
if that is unavailable. Three methods are possible:</p>

<ul>
<li><p> 1. type = &quot;mv&quot;: The one dimensional method is first applied to each of the chosen column indices. These are then collated by choosing, for each time-frequency combination, the maximum such value across each of the indices.
</p>
</li>
<li><p> 2. type = &quot;svm&quot;: The SVM is computed first for each time step by computing the square rooted sum of squares. This is then dealt with using the one dimensional method.
</p>
</li>
<li><p> 3. type = &quot;sum&quot;: As in &quot;mv&quot;, the 1d method is applied. The square of the modulus of the result is then summed and square rooted.
</p>
</li></ul>

<p>If reassign is set, the time reassigned stft is also computed for the first element of mv.indices or the svm as appropriate, by using finite differencing. This gives potentially better resolution results for data with a clear signal component.
</p>


<h3>Value</h3>

<p>A &quot;stft&quot; class object - a list with the following components:</p>

<ul>
<li><p> call: The function call.
</p>
</li>
<li><p> type: Type of STFT computed.
</p>
</li>
<li><p> values: Mod of FFT computed, with each row corresponding to a specific time increment.
</p>
</li>
<li><p> increment,windowsize,centre,sampling.frequency: Various control parameters used in the computation.
</p>
</li>
<li><p> null.logmean,null.logsd: Log of the square rooted mean and standard deviation of the Mod FFT squared for the randomised data, if calc.null = TRUE.
</p>
</li>
<li><p> p.values: Wilcoxian pvalues, if pvalues = TRUE.
</p>
</li>
<li><p> principals: Principal frequencies.
</p>
</li>
<li><p> frequency: Frequencies at which FFT is computed.
</p>
</li>
<li><p> time: Timestamps for FFT windows.
</p>
</li>
<li><p> LGD: Local group delay matrix for reassigned STFT.
</p>
</li>
<li><p> CIF: Channelized instantaneous frequency matrix for reassigned STFT.
</p>
</li></ul>



<h3>References</h3>

<p>Fulop, S.A. &amp; Fitz, K. (2006). Algorithms for computing the time-corrected instantaneous frequency (reassigned) spectrogram, with applications J Acoustical Society of America 119(1), 360&ndash;371.
Nelson. D.J. (2001). Cross-spectral methods for processing speech J Acoustical Society of America 110(1), 2575-2592.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Some artificial data
time = 1:5000
#sum of two sine curves at 0.3 Hz and 0.05 Hz
f1 = 0.3; f2 = 0.05
sin1 = sin(time * f1 * 2*pi)
sin2 = sin(time * f2 * 2*pi)
#add a bit of noise
signal = sin1 + sin2 + 1*rnorm(5000)
#non-reassigned
stft(signal, plot = TRUE, reassign = FALSE, win = 100)
#reassigned
stft(signal, plot = TRUE, reassign = TRUE, win = 100)

#add a third component: varying frequency.
stft(signal + sin(cumsum(seq(f2, f1, length = 5000))*2*pi),
                 plot = TRUE, reassign = TRUE, win = 100)

# Real data
binfile  = system.file("binfile/TESTfile.bin", package = "GENEAread")[1]

# Read in the entire file, calibrated
procfile&lt;-read.bin(binfile)
# Default is mv
stft(procfile, plot.it = TRUE)
# Try sum?
stft(procfile, plot.it = TRUE, type = "sum", reassign = FALSE)

# Just look at the last 50% of the data
stft(procfile, start = 0.5, plot.it = TRUE)

# not reassigned, svm
stft(procfile, type = "svm", reassign = FALSE, plot.it = TRUE)
# a narrower 5 second window means better time resolution
stft(procfile, type = "svm", reassign = FALSE, plot.it = TRUE, win = 5)
# choose increments so as not to overlap
stft(procfile, type = "svm", reassign = FALSE, plot.it = TRUE, win = 5, inc = 5)
# uniform windows
stft(procfile, type = "svm", reassign = FALSE, plot.it = TRUE, wtype = "uniform.window")
# Svm, reassigned, quietly
obj = stft(procfile, type = "svm", quiet = TRUE)
plot(obj, cex = 3, showmax = FALSE, mode = "pval")

#example code
plot(stft(subs(mag, 0.94,0.96), win = 1024, plot = F, coef = 512), zlog = T, log="y")
plot(stft(subs(mag, 0.7,8), win = 1024, plot = F, coef = 512), zlog = T, log="y")
plot(stft(subs(mag, 0.0001,0.005), win = 1024, plot = F, coef = 512), zlog = T)
plot(stft(subs(mag, 0.7,0.8), win = 1024, plot = F), zlog = T, log = "y")

plot(stft(rep(1, 1000) +
      c(sin(1:500/ 10 * 2*pi), rep(0, 500)) +
      c(rep(0, 300),sin(1:500/ 20 * 2*pi), rep(0, 200)),
     freq = 1, plot.it = F), log="x")

stft(sin(1:1000 / (1 +sqrt(1000:1)) * 2 * pi), freq = 1)
stft(rep(1, 1000) + sin(1:1000/ 10 * 2*pi), freq = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='stftcalc'>calculate the fft components</h2><span id='topic+stftcalc'></span>

<h3>Description</h3>

<p>stftcalc calculating the short time fourier transform component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stftcalc(
  X,
  win = 10,
  inc = win/2,
  coef = Inf,
  wtype = "hanning.window",
  freq,
  centre = T,
  calc.null = F,
  pvalues = F,
  time = NULL,
  reassign = T,
  quiet = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stftcalc_+3A_x">X</code></td>
<td>
<p>The dataset to be processed</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_win">win</code></td>
<td>
<p>Window size in number of recordings to use.</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_inc">inc</code></td>
<td>
<p>increment size from one window to the next</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_coef">coef</code></td>
<td>
<p>Number of fourier frequencies to compute. Small values will remove the higher frequencies from the processed object. Defaults to the maximum, win/2.</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_wtype">wtype</code></td>
<td>
<p>Window type for the STFT calculation.</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_freq">freq</code></td>
<td>
<p>frequency of dataset.
If missing and length(time) &gt; 1, freq =(length(time) -1) /( max(time) - min(time) )
If just missing, freq = 1</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_centre">centre</code></td>
<td>
<p>If TRUE (Default), centre the data in each window before processing is done.
Useful for avoiding excessively large DC offset coefficients in results.</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_calc.null">calc.null</code></td>
<td>
<p>If TRUE (Defaults to FALSE), compute a 'null' STFT by resampling the data completely, then doing a STFT.</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_pvalues">pvalues</code></td>
<td>
<p>If TRUE (Defaults to FALSE) Compute bootstrapped pvalues for each position by resampling within each window and applying a wilcox test.</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_time">time</code></td>
<td>
<p>Allows the user to set an overriding timestamp vector to be used for processing.</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_reassign">reassign</code></td>
<td>
<p>logical. If TRUE, compute the time-reassigned STFT. For type %in% c(&quot;mv&quot;, &quot;sum&quot;), this is done with the first coordinate in mv.indices.</p>
</td></tr>
<tr><td><code id="stftcalc_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, suppress output.</p>
</td></tr>
</table>

<hr>
<h2 id='subs'>subs</h2><span id='topic+subs'></span>

<h3>Description</h3>

<p>subsets a proportion of the dataset, or a certain length of the dataset starting at a
specific proportion position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subs(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subs_+3A_x">x</code></td>
<td>
<p>object to subset</p>
</td></tr>
<tr><td><code id="subs_+3A_a">a</code></td>
<td>
<p>Start point to separate the object</p>
</td></tr>
<tr><td><code id="subs_+3A_b">b</code></td>
<td>
<p>End point to separate the object</p>
</td></tr>
</table>

<hr>
<h2 id='svm'>sum vector magnitude</h2><span id='topic+svm'></span>

<h3>Description</h3>

<p>svm acts identically to 'mean.epoch', with the epoch set to the sampling period. In other words, it computes the
instantaneous sum of vector magnitudes of the acceleration at each record point. The function takes &quot;AccData&quot;,
array and vector input. Note that if provided with an array with 4 or more columns, columns 2 to 4 are used &ndash; the
first column is regard as a timestamp and hence ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svm(obj, sqrt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svm_+3A_obj">obj</code></td>
<td>
<p>AccData object</p>
</td></tr>
<tr><td><code id="svm_+3A_sqrt">sqrt</code></td>
<td>
<p>Function to use to calculate SVM</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- read.bin(system.file("binfile/TESTfile.bin", package = "GENEAread")[1], calibrate = TRUE)
svm(dat)

</code></pre>

<hr>
<h2 id='uniform.window'>Uniform Window</h2><span id='topic+uniform.window'></span>

<h3>Description</h3>

<p>A uniform window used by the STFT function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform.window(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniform.window_+3A_n">n</code></td>
<td>
<p>number of points inside the window</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
