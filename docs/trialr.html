<!DOCTYPE html><html><head><title>Help for package trialr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {trialr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#trialr-package'><p>The 'trialr' package.</p></a></li>
<li><a href='#as_tibble.augbin_2t_1a_fit'><p>Cast <code>augbin_2t_1a_fit</code> object to <code>tibble</code>.</p></a></li>
<li><a href='#as_tibble.dose_finding_paths'><p>Cast <code>dose_finding_paths</code> object to <code>tibble</code>.</p></a></li>
<li><a href='#as.data.frame.crm_fit'><p>Convert crm_fit object to <code>data.frame</code>.</p></a></li>
<li><a href='#as.data.frame.efftox_fit'><p>Convert efftox_fit object to <code>data.frame</code>.</p></a></li>
<li><a href='#as.mcmc.list.crm_fit'><p>Convert <code>crm_fit</code> to instance of</p>
<code>mcmc.list</code></a></li>
<li><a href='#as.mcmc.list.efftox_fit'><p>Convert <code>efftox_fit</code> to instance of</p>
<code>mcmc.list</code></a></li>
<li><a href='#augbin_2t_1a_fit'><p>Class used by <span class="pkg">trialr</span> to fit Wason &amp; Seaman's Augmented Binary method in</p>
single arm trials with two post-baseline tumour assessments.</a></li>
<li><a href='#augbin_fit'><p>Class used by <span class="pkg">trialr</span> to fit Wason &amp; Seaman's Augmented Binary method.</p></a></li>
<li><a href='#binary_prob_success'><p>Calculate the binary probability of success.</p></a></li>
<li><a href='#careful_escalation'><p>Dose selection function that practices careful escalation.</p></a></li>
<li><a href='#closest_to_target'><p>Get index of element in vector with value closest to a target</p></a></li>
<li><a href='#crm_codified_dose_logistic'><p>Calculate codified CRM doses.</p></a></li>
<li><a href='#crm_dtps'><p>Calculate dose-transition pathways for a CRM study</p></a></li>
<li><a href='#crm_fit-class'><p>Class of model fit by <span class="pkg">trialr</span> using the CRM dose-finding design.</p></a></li>
<li><a href='#crm_params-class'><p>Container class for parameters to fit the CRM models in trialr.</p></a></li>
<li><a href='#crm_path_analysis'><p>Fit a CRM model to the incrementally observed outcomes on a trial pathway.</p></a></li>
<li><a href='#crm_prior_beliefs'><p>Get the prior beliefs for a CRM trial scenario.</p></a></li>
<li><a href='#crm_process'><p>Process RStan samples from a CRM model.</p></a></li>
<li><a href='#df_parse_outcomes'><p>Parse a string of dose-finding trial outcomes to binary vector notation.</p></a></li>
<li><a href='#dose_finding_fit-class'><p>Class of dose-finding model fit by <span class="pkg">trialr</span> using Stan.</p></a></li>
<li><a href='#dose_finding_path_node-class'><p>Class to hold the elements of a single dose-finding analysis residing in a</p>
pathway of analyses.</a></li>
<li><a href='#eff_at_dose'><p>Get the number of efficacy events seen at the doses under investigation.</p></a></li>
<li><a href='#efftox_analysis_to_df'><p>EffTox analysis to data.frame</p></a></li>
<li><a href='#efftox_contour_plot'><p>Plot EffTox utility contours</p></a></li>
<li><a href='#efftox_dtps'><p>Calculate dose-transition pathways for an EffTox study</p></a></li>
<li><a href='#efftox_dtps_to_dataframe'><p>Calculate dose-transition pathways for an EffTox study</p></a></li>
<li><a href='#efftox_fit-class'><p>Class of model fit by <span class="pkg">trialr</span> using the EffTox dose-finding design.</p></a></li>
<li><a href='#efftox_get_tox'><p>Get the Prob(Tox) for Prob(Eff) and utility pairs</p></a></li>
<li><a href='#efftox_parameters_demo'><p>Get parameters to run the EffTox demo</p></a></li>
<li><a href='#efftox_params-class'><p>Container class for parameters to fit the EffTox model in trialr.</p></a></li>
<li><a href='#efftox_parse_outcomes'><p>Parse a string of EffTox outcomes to binary vector notation.</p></a></li>
<li><a href='#efftox_path_analysis'><p>Fit an EffTox model to the incrementally observed outcomes on a trial pathway.</p></a></li>
<li><a href='#efftox_priors'><p>Simple class to hold prior hyperparameters for the EffTox model.</p></a></li>
<li><a href='#efftox_process'><p>Process RStan samples from an EffTox model</p></a></li>
<li><a href='#efftox_simulate'><p>Run EffTox simulations</p></a></li>
<li><a href='#efftox_solve_p'><p>Calculate the p-index for EffTox utility contours</p></a></li>
<li><a href='#efftox_superiority'><p>Get dose-superiority matrix in EffTox</p></a></li>
<li><a href='#efftox_utility'><p>Get the utility of efficacy &amp; toxicity probability pairs</p></a></li>
<li><a href='#efftox_utility_density_plot'><p>Plot densities of EffTox dose utilities</p></a></li>
<li><a href='#get_efftox_priors'><p>Get normal prior hyperparameters for the EffTox model.</p></a></li>
<li><a href='#n_at_dose'><p>Get the number of patients treated at the doses under investigation.</p></a></li>
<li><a href='#parse_dose_finding_outcomes'><p>Parse a string of dose-finding trial outcomes.</p></a></li>
<li><a href='#parse_eff_tox_dose_finding_outcomes'><p>Parse a string of phase I/II dose-finding trial outcomes.</p></a></li>
<li><a href='#peps2_get_data'><p>Get data to run the PePS2 trial example</p></a></li>
<li><a href='#peps2_process'><p>Process RStan samples from a BEBOP model fit to PePS2 data</p></a></li>
<li><a href='#plot.crm_fit'><p>Plot an crm_fit</p></a></li>
<li><a href='#plot.efftox_fit'><p>Plot an efftox_fit</p></a></li>
<li><a href='#predict.augbin_2t_1a_fit'><p>Predict probability of success for given tumour size measurements.</p></a></li>
<li><a href='#print.augbin_fit'><p>Print augbin_fit object.</p></a></li>
<li><a href='#print.crm_fit'><p>Print crm_fit object.</p></a></li>
<li><a href='#print.efftox_fit'><p>Print efftox_fit object.</p></a></li>
<li><a href='#print.nbg_fit'><p>Print nbg_fit object.</p></a></li>
<li><a href='#prior_predictive_augbin_2t_1a'><p>Sample data from the Augmented Binary model prior predictive distribution.</p></a></li>
<li><a href='#prob_success'><p>Calculate the probability of success.</p></a></li>
<li><a href='#prob_tox_exceeds'><p>Calculate the probability that the rate of toxicity exceeds some threshold</p></a></li>
<li><a href='#ranBin2'><p>Sample pairs of correlated binary events</p></a></li>
<li><a href='#rlkjcorr'><p>Sample LKJ correlation matrices.</p></a></li>
<li><a href='#spread_paths'><p>Spread the information in dose_finding_paths object to a wide data.frame format.</p></a></li>
<li><a href='#stan_augbin'><p>Fit Wason &amp; Seaman's Augmented Binary model for tumour response.</p></a></li>
<li><a href='#stan_augbin_demo'><p>Simple helper function to demonstrate fitting of an Augmented Binary model.</p></a></li>
<li><a href='#stan_crm'><p>Fit a CRM model</p></a></li>
<li><a href='#stan_efftox'><p>Fit an EffTox model</p></a></li>
<li><a href='#stan_efftox_demo'><p>Fit the EffTox model presented in Thall et al. (2014)</p></a></li>
<li><a href='#stan_hierarchical_response_thall'><p>Fit the hierarchical response model described by</p>
Thall <em>et al.</em> (2003).</a></li>
<li><a href='#stan_nbg'><p>Fit a Neuenschwander, Branson &amp; Gsponer logit dose-finding model</p></a></li>
<li><a href='#stan_peps2'><p>Fit the P2TNE model developed for the PePS2 trial to some outcomes.</p></a></li>
<li><a href='#summary.crm_fit'><p>Obtain summary of an crm_fit</p></a></li>
<li><a href='#summary.efftox_fit'><p>Obtain summary of an efftox_fit</p></a></li>
<li><a href='#total_weight_at_dose'><p>Get the total weight of patient outcomes at the doses under investigation.</p></a></li>
<li><a href='#tox_at_dose'><p>Get the number of toxicity events seen at the doses under investigation.</p></a></li>
<li><a href='#trialr_simulate'><p>Run a simulation study.</p></a></li>
<li><a href='#weights_at_dose'><p>Get the weights of patient outcomes at the doses under investigation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-11</td>
</tr>
<tr>
<td>Title:</td>
<td>Clinical Trial Designs in 'rstan'</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of clinical trial designs and methods, implemented in 
    'rstan' and R, including: the Continual Reassessment Method by O'Quigley et 
    al. (1990) &lt;<a href="https://doi.org/10.2307%2F2531628">doi:10.2307/2531628</a>&gt;; EffTox by Thall &amp; Cook (2004) 
    &lt;<a href="https://doi.org/10.1111%2Fj.0006-341X.2004.00218.x">doi:10.1111/j.0006-341X.2004.00218.x</a>&gt;; the two-parameter logistic method of
    Neuenschwander, Branson &amp; Sponer (2008) &lt;<a href="https://doi.org/10.1002%2Fsim.3230">doi:10.1002/sim.3230</a>&gt;; and the 
    Augmented Binary method by Wason &amp; Seaman (2013) &lt;<a href="https://doi.org/10.1002%2Fsim.5867">doi:10.1002/sim.5867</a>&gt;; and
    more. We provide functions to aid model-fitting and analysis. 
    The 'rstan' implementations may also serve as a cookbook to anyone looking 
    to extend or embellish these models. We hope that this package encourages 
    the use of Bayesian methods in clinical trials. There is a preponderance of 
    early phase trial designs because this is where Bayesian methods are used 
    most. If there is a method you would like implemented, please get in touch.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kristian Brock &lt;kristian.brock@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods,Rcpp (&ge; 1.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstan (&ge; 2.18.2), rstantools (&ge; 1.5.1), rlang (&ge; 0.4.5),
dplyr, purrr, magrittr, stringr, ggplot2, gtools, coda,
tidybayes (&ge; 2.0.3), tibble (&ge; 3.0.0), binom, MASS</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>StanHeaders (&ge; 2.18.1), rstan (&ge; 2.18.2), BH (&ge;
1.69.0-1), Rcpp (&ge; 1.0.1), RcppEigen (&ge; 0.3.3.5.0),
RcppParallel (&ge; 5.0.2)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/brockk/trialr">https://github.com/brockk/trialr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/brockk/trialr/issues">https://github.com/brockk/trialr/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, tidyr, ggridges, DiagrammeR</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-11 15:48:13 UTC; k</td>
</tr>
<tr>
<td>Author:</td>
<td>Kristian Brock <a href="https://orcid.org/0000-0002-3921-0166"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Trustees of Columbia University [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-12 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='trialr-package'>The 'trialr' package.</h2><span id='topic+trialr-package'></span><span id='topic+trialr'></span>

<h3>Description</h3>

<p>trialr collects in one place Bayesian clinical trial designs and methods.
Models are implemented in Stan and helper functions are provided in R.
</p>


<h3>References</h3>

<p>Stan Development Team (2018).
RStan: the R interface to Stan. R package version 2.18.2.
https://mc-stan.org/
</p>

<hr>
<h2 id='as_tibble.augbin_2t_1a_fit'>Cast <code>augbin_2t_1a_fit</code> object to <code><a href="tibble.html#topic+tibble">tibble</a></code>.</h2><span id='topic+as_tibble.augbin_2t_1a_fit'></span>

<h3>Description</h3>

<p>Cast <code>augbin_2t_1a_fit</code> object to <code><a href="tibble.html#topic+tibble">tibble</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'augbin_2t_1a_fit'
as_tibble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.augbin_2t_1a_fit_+3A_x">x</code></td>
<td>
<p>Object of class <code>augbin_2t_1a_fit</code>.</p>
</td></tr>
<tr><td><code id="as_tibble.augbin_2t_1a_fit_+3A_...">...</code></td>
<td>
<p>Extra args passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="tibble.html#topic+tibble">tibble</a></code>
</p>

<hr>
<h2 id='as_tibble.dose_finding_paths'>Cast <code>dose_finding_paths</code> object to <code><a href="tibble.html#topic+tibble">tibble</a></code>.</h2><span id='topic+as_tibble.dose_finding_paths'></span>

<h3>Description</h3>

<p>Cast <code>dose_finding_paths</code> object to <code><a href="tibble.html#topic+tibble">tibble</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dose_finding_paths'
as_tibble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.dose_finding_paths_+3A_x">x</code></td>
<td>
<p>Object of class <code>dose_finding_paths</code>.</p>
</td></tr>
<tr><td><code id="as_tibble.dose_finding_paths_+3A_...">...</code></td>
<td>
<p>Extra args passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="tibble.html#topic+tibble">tibble</a></code>
</p>

<hr>
<h2 id='as.data.frame.crm_fit'>Convert crm_fit object to <code>data.frame</code>.</h2><span id='topic+as.data.frame.crm_fit'></span>

<h3>Description</h3>

<p>Convert crm_fit object to <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crm_fit'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.crm_fit_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+crm_fit">crm_fit</a></code> object to convert.</p>
</td></tr>
<tr><td><code id="as.data.frame.crm_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>

<hr>
<h2 id='as.data.frame.efftox_fit'>Convert efftox_fit object to <code>data.frame</code>.</h2><span id='topic+as.data.frame.efftox_fit'></span>

<h3>Description</h3>

<p>Convert efftox_fit object to <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'efftox_fit'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.efftox_fit_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+efftox_fit">efftox_fit</a></code> object to convert.</p>
</td></tr>
<tr><td><code id="as.data.frame.efftox_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>

<hr>
<h2 id='as.mcmc.list.crm_fit'>Convert <code><a href="#topic+crm_fit">crm_fit</a></code> to instance of
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code></h2><span id='topic+as.mcmc.list.crm_fit'></span>

<h3>Description</h3>

<p>This function allows trialr to use tidybayes functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crm_fit'
as.mcmc.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.list.crm_fit_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+crm_fit">crm_fit</a></code></p>
</td></tr>
<tr><td><code id="as.mcmc.list.crm_fit_+3A_...">...</code></td>
<td>
<p>Extra variables that are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
</p>

<hr>
<h2 id='as.mcmc.list.efftox_fit'>Convert <code><a href="#topic+efftox_fit">efftox_fit</a></code> to instance of
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code></h2><span id='topic+as.mcmc.list.efftox_fit'></span>

<h3>Description</h3>

<p>This function allows trialr to use tidybayes functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'efftox_fit'
as.mcmc.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.list.efftox_fit_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+efftox_fit">efftox_fit</a></code></p>
</td></tr>
<tr><td><code id="as.mcmc.list.efftox_fit_+3A_...">...</code></td>
<td>
<p>Extra variables that are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
</p>

<hr>
<h2 id='augbin_2t_1a_fit'>Class used by <span class="pkg">trialr</span> to fit Wason &amp; Seaman's Augmented Binary method in
single arm trials with two post-baseline tumour assessments.</h2><span id='topic+augbin_2t_1a_fit'></span>

<h3>Description</h3>

<p>Class used by <span class="pkg">trialr</span> to fit Wason &amp; Seaman's Augmented Binary method in
single arm trials with two post-baseline tumour assessments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augbin_2t_1a_fit(num_patients, tumour_size, non_shrinkage_failure, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augbin_2t_1a_fit_+3A_num_patients">num_patients</code></td>
<td>
<p>Integer, the number of patients analysed.</p>
</td></tr>
<tr><td><code id="augbin_2t_1a_fit_+3A_tumour_size">tumour_size</code></td>
<td>
<p>matrix-like object containing tumour size measures, with
rows representing patients and columns representing chronological
assessment points. Column one is baseline.</p>
</td></tr>
<tr><td><code id="augbin_2t_1a_fit_+3A_non_shrinkage_failure">non_shrinkage_failure</code></td>
<td>
<p>matrix-like object containing logical indicators
of non-shrinkage failure, with rows representing patients and columns
representing chronological assessment points.</p>
</td></tr>
<tr><td><code id="augbin_2t_1a_fit_+3A_fit">fit</code></td>
<td>
<p>An object of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code>,
containing the posterior samples.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wason JMS, Seaman SR. Using continuous data on tumour measurements to improve
inference in phase II cancer studies.
Statistics in Medicine. 2013;32(26):4639-4650. doi:10.1002/sim.5867
</p>
<p>Eisenhauer EA, Therasse P, Bogaerts J, et al. New response evaluation
criteria in solid tumours: Revised RECIST guideline (version 1.1).
European Journal of Cancer. 2009;45(2):228-247. doi:10.1016/j.ejca.2008.10.026
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augbin_fit">augbin_fit</a></code>
<code><a href="#topic+stan_augbin">stan_augbin</a></code>
</p>

<hr>
<h2 id='augbin_fit'>Class used by <span class="pkg">trialr</span> to fit Wason &amp; Seaman's Augmented Binary method.</h2><span id='topic+augbin_fit'></span>

<h3>Description</h3>

<p>Class used by <span class="pkg">trialr</span> to fit Wason &amp; Seaman's Augmented Binary method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augbin_fit(num_patients, tumour_size, non_shrinkage_failure, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augbin_fit_+3A_num_patients">num_patients</code></td>
<td>
<p>Integer, the number of patients analysed.</p>
</td></tr>
<tr><td><code id="augbin_fit_+3A_tumour_size">tumour_size</code></td>
<td>
<p>matrix-like object containing tumour size measures, with
rows representing patients and columns representing chronological
standardised assessment points. Column one is baseline.</p>
</td></tr>
<tr><td><code id="augbin_fit_+3A_non_shrinkage_failure">non_shrinkage_failure</code></td>
<td>
<p>matrix-like object containing logical indicators
of non-shrinkage failure, with rows representing patients and columns
representing chronological standardised assessment points.</p>
</td></tr>
<tr><td><code id="augbin_fit_+3A_fit">fit</code></td>
<td>
<p>An object of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code>,
containing the posterior samples.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wason JMS, Seaman SR. Using continuous data on tumour measurements to improve
inference in phase II cancer studies.
Statistics in Medicine. 2013;32(26):4639-4650. doi:10.1002/sim.5867
</p>
<p>Eisenhauer EA, Therasse P, Bogaerts J, et al. New response evaluation
criteria in solid tumours: Revised RECIST guideline (version 1.1).
European Journal of Cancer. 2009;45(2):228-247. doi:10.1016/j.ejca.2008.10.026
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_augbin">stan_augbin</a></code>
</p>

<hr>
<h2 id='binary_prob_success'>Calculate the binary probability of success.</h2><span id='topic+binary_prob_success'></span><span id='topic+binary_prob_success.augbin_2t_1a_fit'></span>

<h3>Description</h3>

<p>Calculate the binary probability of success.
</p>
<p>Calculate the binary probability of success from an augbin_2t_1a_fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_prob_success(x, ...)

## S3 method for class 'augbin_2t_1a_fit'
binary_prob_success(
  x,
  y1_lower = -Inf,
  y1_upper = Inf,
  y2_lower = -Inf,
  y2_upper = log(0.7),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_prob_success_+3A_x">x</code></td>
<td>
<p>an R object of class <code>"augbin_fit"</code></p>
</td></tr>
<tr><td><code id="binary_prob_success_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="binary_prob_success_+3A_y1_lower">y1_lower</code></td>
<td>
<p>numeric, minimum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 1 to baseline.
Defaults to negative infinity.</p>
</td></tr>
<tr><td><code id="binary_prob_success_+3A_y1_upper">y1_upper</code></td>
<td>
<p>numeric, maximum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 1 to baseline.
Defaults to positive infinity.</p>
</td></tr>
<tr><td><code id="binary_prob_success_+3A_y2_lower">y2_lower</code></td>
<td>
<p>numeric, minimum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 2 to baseline.</p>
</td></tr>
<tr><td><code id="binary_prob_success_+3A_y2_upper">y2_upper</code></td>
<td>
<p>numeric, maximum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 2 to baseline.
Defaults to log(0.7).</p>
</td></tr>
<tr><td><code id="binary_prob_success_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>-like object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- stan_augbin_demo()
binary_prob_success(fit, y2_upper = log(0.7))

## End(Not run)
</code></pre>

<hr>
<h2 id='careful_escalation'>Dose selection function that practices careful escalation.</h2><span id='topic+careful_escalation'></span>

<h3>Description</h3>

<p>Dose selection function that avoids dose-skipping in escalation and
advocates stopping when there is sufficient evidence that the risk of
toxicity at a reference dose exceeds some threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>careful_escalation(
  dose_finding_fit,
  tox_threshold,
  certainty_threshold,
  reference_dose = 1,
  start_dose = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="careful_escalation_+3A_dose_finding_fit">dose_finding_fit</code></td>
<td>
<p>Instance of <code><a href="#topic+dose_finding_fit">dose_finding_fit</a></code>.</p>
</td></tr>
<tr><td><code id="careful_escalation_+3A_tox_threshold">tox_threshold</code></td>
<td>
<p>numeric, the toxicity threshold.</p>
</td></tr>
<tr><td><code id="careful_escalation_+3A_certainty_threshold">certainty_threshold</code></td>
<td>
<p>numeric, the required confidence that the risk of
toxicity exceeds 'tox_threshold' to advocate stopping.</p>
</td></tr>
<tr><td><code id="careful_escalation_+3A_reference_dose">reference_dose</code></td>
<td>
<p>the integer index of the reference dose. 1 by default,
i.e. the lowest dose-level.</p>
</td></tr>
<tr><td><code id="careful_escalation_+3A_start_dose">start_dose</code></td>
<td>
<p>the integer index of the desired starting dose. 1 by
default. This is required for the function to give the desired answer when
no patients have yet been treated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer dose-level
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CRM example
fit &lt;- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
                target = 0.2, model = 'empiric', beta_sd = 1,
                seed = 123)

## End(Not run)
</code></pre>

<hr>
<h2 id='closest_to_target'>Get index of element in vector with value closest to a target</h2><span id='topic+closest_to_target'></span>

<h3>Description</h3>

<p>Get index of element in vector with value closest to a target
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest_to_target(vector, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closest_to_target_+3A_vector">vector</code></td>
<td>
<p>Identify element in this numeric vector</p>
</td></tr>
<tr><td><code id="closest_to_target_+3A_target">target</code></td>
<td>
<p>numeric target</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indexing <code>vector</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>closest_to_target(c(0.1, 0.2, 0.3), 0.05)  # 1
closest_to_target(c(0.1, 0.2, 0.3), 0.22)  # 2
closest_to_target(c(0.1, 0.2, 0.3), -0.05) # 1
closest_to_target(c(0.1, 0.2, 0.3), 8) # 3
</code></pre>

<hr>
<h2 id='crm_codified_dose_logistic'>Calculate codified CRM doses.</h2><span id='topic+crm_codified_dose_logistic'></span>

<h3>Description</h3>

<p>Calculate the codified CRM doses that map to probability of
toxicity <code>prob_tox</code> in a logistic model with expected values for
intercept and gradient. I.e. find <code class="reqn">x[i]</code> such that
<code class="reqn">logit(p[i]) = \alpha + \beta x[i]</code>, were <code class="reqn">p</code> is
<code>prob_tox</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm_codified_dose_logistic(prob_tox, alpha_mean, beta_mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crm_codified_dose_logistic_+3A_prob_tox">prob_tox</code></td>
<td>
<p>Numeric vector, seek codified doses that yield these
probabilities of toxicity.</p>
</td></tr>
<tr><td><code id="crm_codified_dose_logistic_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>Numeric, expected value of intercept.</p>
</td></tr>
<tr><td><code id="crm_codified_dose_logistic_+3A_beta_mean">beta_mean</code></td>
<td>
<p>Numeric, expected value of gradient with respect to dose.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of codified doses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.2, 0.5)
crm_codified_dose_logistic(skeleton, 1, 0)
crm_codified_dose_logistic(skeleton, 3, 0.5)
</code></pre>

<hr>
<h2 id='crm_dtps'>Calculate dose-transition pathways for a CRM study</h2><span id='topic+crm_dtps'></span>

<h3>Description</h3>

<p>Calculate dose-transition pathways (DTPs, Yap et al, 2017) for a dose-finding
trial using the continual reassessment method (CRM) design. DTPs are a
glimpse into the future for an in-progress trial. They tell us what the model
would advise for all feasible future outcomes. They can be used in the design
stages to detect possible undesirable behaviour. They can be used during the
trial to aid planning and understanding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm_dtps(
  skeleton,
  target,
  model,
  cohort_sizes,
  previous_outcomes = "",
  next_dose = NULL,
  user_dose_func = NULL,
  verbose = FALSE,
  i_am_patient = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crm_dtps_+3A_skeleton">skeleton</code></td>
<td>
<p>a vector of the prior guesses of toxicity at doses.
This should be a monotonically-increasing vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="crm_dtps_+3A_target">target</code></td>
<td>
<p>the target toxicity probability, a number between 0 and 1.
This value would normally be one of the values in <code>skeleton</code>, but that
is not a requirement.</p>
</td></tr>
<tr><td><code id="crm_dtps_+3A_model">model</code></td>
<td>
<p>Character string to denote desired model. One of <code>empiric</code>,
<code>logistic</code>, <code>logistic_gamma</code>, or <code>logistic2</code>.
The choice of model determines which extra parameters are required by
<code>...</code>. See Details.</p>
</td></tr>
<tr><td><code id="crm_dtps_+3A_cohort_sizes">cohort_sizes</code></td>
<td>
<p>vector of future cohort sizes, i.e. positive integers.
E.g. To calculate paths for the the next cohort of two followed by another
cohort of three, use <code>cohort_sizes = c(2, 3)</code>.</p>
</td></tr>
<tr><td><code id="crm_dtps_+3A_previous_outcomes">previous_outcomes</code></td>
<td>
<p>Outcomes observed hitherto in the syntax required
by <code><a href="#topic+df_parse_outcomes">df_parse_outcomes</a></code>.</p>
</td></tr>
<tr><td><code id="crm_dtps_+3A_next_dose">next_dose</code></td>
<td>
<p>optional, integer (1-based) dose-level to be given to the
next cohort. If omitted, the dose suggested by the model is used.</p>
</td></tr>
<tr><td><code id="crm_dtps_+3A_user_dose_func">user_dose_func</code></td>
<td>
<p>optional delegate for deciding dose. A function that
takes a <code><a href="#topic+crm_fit">crm_fit</a></code> as the sole argument and returns the integer
(1-based) dose-level to be given next, or NA to show that no dose should be
chosen and the trial stopped. This function gives the user the opportunity to
build in custom behaviour to tailor the dose selection decision in response
to the insights garnered by the fit model, or recommend that a trial path
be halted immediately. If omitted, the dose ordinarily chosen by the model is
used. An example is given below.</p>
</td></tr>
<tr><td><code id="crm_dtps_+3A_verbose">verbose</code></td>
<td>
<p>logical, TRUE to get log messages.</p>
</td></tr>
<tr><td><code id="crm_dtps_+3A_i_am_patient">i_am_patient</code></td>
<td>
<p>logical. The number of paths to analyse grows faster than
linearly in the number of future cohorts to resolve. Fitting many models by
MCMC can take a long time. This function will not proceed unless you signify
your patience when the number of paths to reolve exceeds 100.</p>
</td></tr>
<tr><td><code id="crm_dtps_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="#topic+stan_crm">stan_crm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different model choices require that different parameters are provided.
See below.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of <code><a href="#topic+dose_finding_path_node">dose_finding_path_node</a></code> objects.
</p>


<h3>Parameter requirements of <code>empiric</code> model</h3>


<ul>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic</code> model</h3>


<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic_gamma</code> model</h3>


<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_shape</code>
</p>
</li>
<li> <p><code>beta_inverse_scale</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic2</code> model</h3>


<ul>
<li> <p><code>alpha_mean</code>
</p>
</li>
<li> <p><code>alpha_sd</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kristian Brock
</p>


<h3>References</h3>

<p>Yap C, Billingham LJ, Cheung YK, Craddock C, Oâ€™Quigley J.
Dose transition pathways: The missing link between complex dose-finding
designs and simple decision-making. Clinical Cancer Research.
2017;23(24):7440-7447. doi:10.1158/1078-0432.CCR-17-0582
</p>


<h3>See Also</h3>

<p><code><a href="#topic+df_parse_outcomes">df_parse_outcomes</a></code>,
<code><a href="#topic+stan_crm">stan_crm</a></code>,
<code><a href="#topic+crm_path_analysis">crm_path_analysis</a></code>,
<code><a href="#topic+dose_finding_path_node">dose_finding_path_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
target &lt;- 0.25
skeleton &lt;- c(0.05, 0.15, 0.25, 0.4, 0.6)

# Run DTPs for the first two cohorts of two for new a trial:
paths &lt;- crm_dtps(skeleton = skeleton, target = target, model = 'empiric',
                  cohort_sizes = c(2, 2), next_dose = 3, beta_sd = 1)
length(paths)  # 13

library(tibble)
df &lt;- as_tibble(paths)
df


# Run DTPs for the next cohort of three in a trial that has already treated
# six patients, seeing some toxicity at dose-level 3:
paths2 &lt;- crm_dtps(skeleton = skeleton, target = target, model = 'empiric',
                   cohort_sizes = c(3), previous_outcomes = '2NNN 3TTN',
                   beta_sd = 1)
length(paths2)  # 5
as_tibble(paths2)
# We see that de-escalation to dose-level 2 should occur now, and that any
# further toxicity will result in advice for further de-escalation to
# dose-level 1.


# An example with a custom dose selection function
paths3 &lt;- crm_dtps(skeleton = skeleton, target = target, model = 'empiric',
                   cohort_sizes = c(3, 3), previous_outcomes = '2NN 3TN',
                   next_dose = 2, beta_sd = 1,
                   user_dose_func = function(x) {
                     careful_escalation(x, tox_threshold = target + 0.1,
                                        certainty_threshold = 0.7)
                   }, seed = 123, refresh = 0)
spread_paths(as_tibble(paths3) %&gt;% select(-fit, -parent_fit, -dose_index))
# Stopping is recommended when the dose selection function returns NA.

## End(Not run)
</code></pre>

<hr>
<h2 id='crm_fit-class'>Class of model fit by <span class="pkg">trialr</span> using the CRM dose-finding design.</h2><span id='topic+crm_fit-class'></span><span id='topic+crm_fit'></span>

<h3>Description</h3>

<p>Class of model fit by <span class="pkg">trialr</span> using the CRM dose-finding design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm_fit(
  dose_indices,
  num_patients,
  doses,
  tox,
  weights,
  prob_tox,
  median_prob_tox,
  prob_mtd,
  recommended_dose,
  dat,
  fit,
  samples = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crm_fit-class_+3A_dose_indices">dose_indices</code></td>
<td>
<p>A vector of integers representing the dose-levels under
consideration.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_num_patients">num_patients</code></td>
<td>
<p>Integer, the number of patients analysed.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_doses">doses</code></td>
<td>
<p>vector of integers representing the dose given to the patients.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_tox">tox</code></td>
<td>
<p>vector of integers representing the toxicity status of the
patients.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_weights">weights</code></td>
<td>
<p>Vector of numeric weights for the observations for patients
1:num_patients, thus facilitating the TITE-CRM design.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_prob_tox">prob_tox</code></td>
<td>
<p>The posterior mean probabilities of toxicity at doses 1:n;
a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_median_prob_tox">median_prob_tox</code></td>
<td>
<p>The posterior median probabilities of toxicity at doses
1:n; a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_prob_mtd">prob_mtd</code></td>
<td>
<p>The posterior probability that each dose is the MTD, by the
chosen model; a vector of numbers between 0 and 1. This probability reflects
the uncertainty remaining in the parameter distributions, whereas
<code>prob_tox</code> and <code>median_prob_tox</code> do not.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_recommended_dose">recommended_dose</code></td>
<td>
<p>An integer representing the dose-level that is
recommended for the next patient or cohort. Contrast to
<code>modal_mtd_candidate</code>.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_dat">dat</code></td>
<td>
<p>Object <code><a href="#topic+crm_params">crm_params</a></code> containing data passed to
<code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_fit">fit</code></td>
<td>
<p>An object of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code>,
containing the posterior samples.</p>
</td></tr>
<tr><td><code id="crm_fit-class_+3A_samples">samples</code></td>
<td>
<p>An optional <code>data.frame</code> like object of samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>methods(class = "crm_fit")</code> for an overview of available
methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_crm">stan_crm</a></code>
</p>

<hr>
<h2 id='crm_params-class'>Container class for parameters to fit the CRM models in trialr.</h2><span id='topic+crm_params-class'></span><span id='topic+crm_params'></span>

<h3>Description</h3>

<p>Container class for parameters to fit the CRM models in trialr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm_params(
  skeleton,
  target,
  a0 = NULL,
  alpha_mean = NULL,
  alpha_sd = NULL,
  beta_mean = NULL,
  beta_sd = NULL,
  beta_shape = NULL,
  beta_inverse_scale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crm_params-class_+3A_skeleton">skeleton</code></td>
<td>
<p>a vector of the prior guesses of toxicity at doses.
This should be a monotonically-increasing vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="crm_params-class_+3A_target">target</code></td>
<td>
<p>the target toxicity probability, a number between 0 and 1.
This value would normally be one of the values in <code>skeleton</code>, but that
is not a requirement.</p>
</td></tr>
<tr><td><code id="crm_params-class_+3A_a0">a0</code></td>
<td>
<p>Value of fixed intercept parameter.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_params-class_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>Prior mean of intercept variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_params-class_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>Prior standard deviation of intercept variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_params-class_+3A_beta_mean">beta_mean</code></td>
<td>
<p>Prior mean of gradient variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_params-class_+3A_beta_sd">beta_sd</code></td>
<td>
<p>Prior standard deviation of slope variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_params-class_+3A_beta_shape">beta_shape</code></td>
<td>
<p>Prior shape parameter of slope variable for gamma prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_params-class_+3A_beta_inverse_scale">beta_inverse_scale</code></td>
<td>
<p>Prior inverse scale parameter of slope variable for
gamma prior. Only required for certain models. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different model parameterisations require that difference parameter values
are specified.
</p>


<h3>Parameter requirements of <code>empiric</code> model</h3>


<ul>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic</code> model</h3>


<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic_gamma</code> model</h3>


<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_shape</code>
</p>
</li>
<li> <p><code>beta_inverse_scale</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic2</code> model</h3>


<ul>
<li> <p><code>alpha_mean</code>
</p>
</li>
<li> <p><code>alpha_sd</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+stan_crm">stan_crm</a></code>
</p>

<hr>
<h2 id='crm_path_analysis'>Fit a CRM model to the incrementally observed outcomes on a trial pathway.</h2><span id='topic+crm_path_analysis'></span>

<h3>Description</h3>

<p>Fit a continuous reassessment method (CRM) model to the outcomes cumulatively
observed at the end of each cohort in a trial pathway. E.g. if the trial
pathway is 1NN 2NN 3NT, we have three cohorts of two patients. This function
will fit the model to the following four states: before any patients have
been evaluated; after 1NN; after 1NN 2NN; and finally after 1NN 2NN 3NT.
This allows us to analyse how the trial model is evolving in its estimation
as trial data is accumulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm_path_analysis(outcome_str, skeleton, target, model, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crm_path_analysis_+3A_outcome_str">outcome_str</code></td>
<td>
<p>A string representing the outcomes observed hitherto.
See <code><a href="#topic+df_parse_outcomes">df_parse_outcomes</a></code> for a description of syntax and
examples. Alternatively, you may provide <code>doses_given</code> and <code>tox</code>
parameters. See Details.</p>
</td></tr>
<tr><td><code id="crm_path_analysis_+3A_skeleton">skeleton</code></td>
<td>
<p>a vector of the prior guesses of toxicity at doses.
This should be a monotonically-increasing vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="crm_path_analysis_+3A_target">target</code></td>
<td>
<p>the target toxicity probability, a number between 0 and 1.
This value would normally be one of the values in <code>skeleton</code>, but that
is not a requirement.</p>
</td></tr>
<tr><td><code id="crm_path_analysis_+3A_model">model</code></td>
<td>
<p>Character string to denote desired model. One of <code>empiric</code>,
<code>logistic</code>, <code>logistic_gamma</code>, or <code>logistic2</code>.
The choice of model determines which extra parameters are required by
<code>...</code>. See Details.</p>
</td></tr>
<tr><td><code id="crm_path_analysis_+3A_verbose">verbose</code></td>
<td>
<p>logical, TRUE to get log messages.</p>
</td></tr>
<tr><td><code id="crm_path_analysis_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="#topic+stan_crm">stan_crm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different model choices require that different parameters are provided.
See below.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of <code><a href="#topic+dose_finding_path_node">dose_finding_path_node</a></code> objects.
</p>


<h3>Parameter requirements of <code>empiric</code> model</h3>


<ul>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic</code> model</h3>


<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic_gamma</code> model</h3>


<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_shape</code>
</p>
</li>
<li> <p><code>beta_inverse_scale</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic2</code> model</h3>


<ul>
<li> <p><code>alpha_mean</code>
</p>
</li>
<li> <p><code>alpha_sd</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kristian Brock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+df_parse_outcomes">df_parse_outcomes</a></code>,
<code><a href="#topic+stan_crm">stan_crm</a></code>,
<code><a href="#topic+dose_finding_path_node">dose_finding_path_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CRM example
target &lt;- 0.25
skeleton &lt;- c(0.05, 0.15, 0.25, 0.4, 0.6)
paths &lt;- crm_path_analysis(
  outcome_str = '1NNN 2NTN 2NNN',
  skeleton = skeleton, target = target, model = 'empiric',
  beta_sd = 1, seed = 123, refresh = 0)
length(paths)  # 4
names(paths)[1]  # ""
names(paths)[2]  # "1NNN"
names(paths)[3]  # "1NNN 2NTN"
names(paths)[4]  # "1NNN 2NTN 2NNN"
# Each node is an analysis fit to the cumulative outcomes
# Converting to a tibble presents some nice tidyverse-related opportunities
library(tibble)
df &lt;- as_tibble(paths)
df

## End(Not run)
</code></pre>

<hr>
<h2 id='crm_prior_beliefs'>Get the prior beliefs for a CRM trial scenario.</h2><span id='topic+crm_prior_beliefs'></span>

<h3>Description</h3>

<p>Infer the prior beliefs consistent with the parameters and model
form for a CRM dose-finding trial. This function could be interpreted as
fitting the model to no data, thus examining the beliefs on dose-toxicity
that are suggested by the parameter priors alone. This function provides the
task analagous to <code><a href="#topic+stan_crm">stan_crm</a></code> before any data has been collected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm_prior_beliefs(
  skeleton,
  target,
  model = c("empiric", "logistic", "logistic_gamma", "logistic2"),
  a0 = NULL,
  alpha_mean = NULL,
  alpha_sd = NULL,
  beta_mean = NULL,
  beta_sd = NULL,
  beta_shape = NULL,
  beta_inverse_scale = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crm_prior_beliefs_+3A_skeleton">skeleton</code></td>
<td>
<p>a vector of the prior guesses of toxicity at doses.
This should be a monotonically-increasing vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_target">target</code></td>
<td>
<p>the target toxicity probability, a number between 0 and 1.
This value would normally be one of the values in <code>skeleton</code>, but that
is not a requirement.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_model">model</code></td>
<td>
<p>Character string to denote desired model. One of <code>empiric</code>,
<code>logistic</code>, <code>logistic_gamma</code>, or <code>logistic2</code>.
The choice of model determines which parameters are required. See Details.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_a0">a0</code></td>
<td>
<p>Value of fixed intercept parameter.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>Prior mean of intercept variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>Prior standard deviation of intercept variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_beta_mean">beta_mean</code></td>
<td>
<p>Prior mean of gradient variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_beta_sd">beta_sd</code></td>
<td>
<p>Prior standard deviation of slope variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_beta_shape">beta_shape</code></td>
<td>
<p>Prior shape parameter of slope variable for gamma prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_beta_inverse_scale">beta_inverse_scale</code></td>
<td>
<p>Prior inverse scale parameter of slope variable for
gamma prior. Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="crm_prior_beliefs_+3A_...">...</code></td>
<td>
<p>extra parameters passed to <code><a href="#topic+stan_crm">stan_crm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different model choices require that different parameters are
provided. See below.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+crm_fit">crm_fit</a></code>
</p>


<h3>Parameter requirements of <code>empiric</code> model</h3>


<ul>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic</code> model</h3>


<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic_gamma</code> model</h3>


<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_shape</code>
</p>
</li>
<li> <p><code>beta_inverse_scale</code>
</p>
</li></ul>



<h3>Parameter requirements of <code>logistic2</code> model</h3>


<ul>
<li> <p><code>alpha_mean</code>
</p>
</li>
<li> <p><code>alpha_sd</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kristian Brock
</p>


<h3>References</h3>

<p>O'Quigley, J., Pepe, M., &amp; Fisher, L. (1990).
Continual reassessment method: a practical design for phase 1 clinical
trials in cancer.
Biometrics, 46(1), 33-48. https://www.jstor.org/stable/2531628
</p>
<p>Cheung, Y.K. (2011).
Dose Finding by the Continual Reassessment Method.
CRC Press. ISBN 9781420091519
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_crm">stan_crm</a></code>
<code><a href="#topic+crm_fit">crm_fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.15, 0.33, 0.5)
target &lt;- 0.33

prior_fit1 &lt;- crm_prior_beliefs(skeleton, target, model = 'empiric',
                                beta_sd = sqrt(1.34))
prior_fit2 &lt;- crm_prior_beliefs(skeleton, target, model = 'logistic_gamma',
                                a0 = 3, beta_shape = 1,
                                beta_inverse_scale = 2)
</code></pre>

<hr>
<h2 id='crm_process'>Process RStan samples from a CRM model.</h2><span id='topic+crm_process'></span>

<h3>Description</h3>

<p>Internal function to process rstan samples from a CRM model to
make inferences about dose-toxicity and which dose should be recommended next.
Typically, this function is not required to be called explicitly by the user
because <code><a href="#topic+stan_crm">stan_crm</a></code> will call it implicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm_process(dat, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crm_process_+3A_dat">dat</code></td>
<td>
<p>An instance of <code><a href="#topic+crm_params">crm_params</a></code>, a list of CRM
parameters.</p>
</td></tr>
<tr><td><code id="crm_process_+3A_fit">fit</code></td>
<td>
<p>An instance of <code>rstan::stanmodel</code>, derived by fitting one of
the trialr CRM models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of <code><a href="#topic+crm_fit">crm_fit</a></code>.
</p>

<hr>
<h2 id='df_parse_outcomes'>Parse a string of dose-finding trial outcomes to binary vector notation.</h2><span id='topic+df_parse_outcomes'></span>

<h3>Description</h3>

<p>Parse a string of dose-finding trial outcomes to the binary
vector notation required by Stan for model invocation. The outcome string
describes the doses given and outcomes observed. The format of the string is
the pure phase I analogue to that described in Brock et al. (2017).
The letters T and N are used to represents patients that experienced
(T)oxicity and (N)o toxicity. These letters are concatenated after numerical
dose-levels to convey the outcomes of cohorts of patients.
For instance, <code>2NNT</code> represents a cohort of three patients that were
treated at dose-level 2, one of whom experienced toxicity, and two that did
not. The results of cohorts are separated by spaces. Thus, <code>2NNT 1NN</code>
extends our previous example, where the next cohort of two were treated at
dose-level 1 and neither experienced toxicity. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_parse_outcomes(outcome_string, as.list = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_parse_outcomes_+3A_outcome_string">outcome_string</code></td>
<td>
<p>character string, conveying doses given and outcomes
observed.</p>
</td></tr>
<tr><td><code id="df_parse_outcomes_+3A_as.list">as.list</code></td>
<td>
<p>TRUE (the default) to return a <code>list</code>;
FALSE to return a <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>as.list == TRUE</code>, a list with elements <code>tox</code>,
<code>doses</code> and <code>num_patients</code>. These elements are congruent with those
of the same name in <code>crm_params</code>, for example.
If <code>as.list == FALSE</code>, a data.frame with columns <code>tox</code> and
<code>doses</code>.
</p>


<h3>References</h3>

<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp; Yap, C.
(2017). Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = df_parse_outcomes('1NNN 2NTN 3TTT')
x$num_patients  # 9
x$doses         # c(1, 1, 1, 2, 2, 2, 3, 3, 3)
x$tox           # c(0, 0, 0, 0, 1, 0, 1, 1, 1)
sum(x$tox)      # 4

</code></pre>

<hr>
<h2 id='dose_finding_fit-class'>Class of dose-finding model fit by <span class="pkg">trialr</span> using Stan.</h2><span id='topic+dose_finding_fit-class'></span><span id='topic+dose_finding_fit'></span>

<h3>Description</h3>

<p>Class of dose-finding model fit by <span class="pkg">trialr</span> using Stan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_finding_fit(
  dose_indices,
  num_patients,
  doses,
  tox,
  prob_tox,
  median_prob_tox,
  recommended_dose,
  dat,
  fit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dose_finding_fit-class_+3A_dose_indices">dose_indices</code></td>
<td>
<p>A vector of integers representing the dose-levels under
consideration.</p>
</td></tr>
<tr><td><code id="dose_finding_fit-class_+3A_num_patients">num_patients</code></td>
<td>
<p>Integer, the number of patients analysed.</p>
</td></tr>
<tr><td><code id="dose_finding_fit-class_+3A_doses">doses</code></td>
<td>
<p>vector of integers representing the dose given to the patients.</p>
</td></tr>
<tr><td><code id="dose_finding_fit-class_+3A_tox">tox</code></td>
<td>
<p>vector of integers representing the toxicity status of the
patients.</p>
</td></tr>
<tr><td><code id="dose_finding_fit-class_+3A_prob_tox">prob_tox</code></td>
<td>
<p>The posterior mean probabilities of toxicity at doses 1:n;
a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="dose_finding_fit-class_+3A_median_prob_tox">median_prob_tox</code></td>
<td>
<p>The posterior median probabilities of toxicity at
doses 1:n; a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="dose_finding_fit-class_+3A_recommended_dose">recommended_dose</code></td>
<td>
<p>An integer representing the dose-level that is
recommended for the next patient or cohort.</p>
</td></tr>
<tr><td><code id="dose_finding_fit-class_+3A_dat">dat</code></td>
<td>
<p>Object <code><a href="#topic+crm_params">crm_params</a></code> containing data passed to
<code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
<tr><td><code id="dose_finding_fit-class_+3A_fit">fit</code></td>
<td>
<p>An object of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code>,
containing the posterior samples.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+crm_fit">crm_fit</a></code>,
<code><a href="#topic+efftox_fit">efftox_fit</a></code>
</p>

<hr>
<h2 id='dose_finding_path_node-class'>Class to hold the elements of a single dose-finding analysis residing in a
pathway of analyses.</h2><span id='topic+dose_finding_path_node-class'></span><span id='topic+dose_finding_path_node'></span>

<h3>Description</h3>

<p>A pathway in a dose-finding trial is a series of successive analyses. For
instance, the model will likely be fit to all of the outcomes observed
at the end of the first cohort, the second cohort, etc. This class holds the
elements reflecting the analysis, and the place of this analysis in the
pathway.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_finding_path_node(
  node_id,
  parent_node_id,
  depth,
  outcomes,
  next_dose,
  fit,
  parent_fit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dose_finding_path_node-class_+3A_node_id">node_id</code></td>
<td>
<p>An integer representing the id of this node in a pathway.</p>
</td></tr>
<tr><td><code id="dose_finding_path_node-class_+3A_parent_node_id">parent_node_id</code></td>
<td>
<p>An integer representing the id of this node's parent in
the pathway.</p>
</td></tr>
<tr><td><code id="dose_finding_path_node-class_+3A_depth">depth</code></td>
<td>
<p>An integer representing the depth of this node in the pathway,
where the root has depth 0.</p>
</td></tr>
<tr><td><code id="dose_finding_path_node-class_+3A_outcomes">outcomes</code></td>
<td>
<p>A string representing the outcomes observed at the time of
analysis. See <code><a href="#topic+df_parse_outcomes">df_parse_outcomes</a></code> for a description of syntax and
examples.</p>
</td></tr>
<tr><td><code id="dose_finding_path_node-class_+3A_next_dose">next_dose</code></td>
<td>
<p>An integer representing the dose recommended by the model
for the next patient or cohort of patients.</p>
</td></tr>
<tr><td><code id="dose_finding_path_node-class_+3A_fit">fit</code></td>
<td>
<p>Object obtained from fitting the dose-finding model to
<code>outcomes</code>.</p>
</td></tr>
<tr><td><code id="dose_finding_path_node-class_+3A_parent_fit">parent_fit</code></td>
<td>
<p>Object obtained from fitting the dose-finding model to
the outcomes of the parent node. Comparing to <code>fit</code> will oten be
valuable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Instance of class <code>dose_finding_path_node</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
parent_outcomes &lt;- '1NNN'
outcomes &lt;- '1NNN 2NNT'
target &lt;- 0.25
skeleton &lt;- c(0.05, 0.15, 0.25, 0.4, 0.6)
parent_fit &lt;- stan_crm(outcome_str = parent_outcomes, skeleton = skeleton,
                       target = target, model = 'empiric', beta_sd = 1)
fit &lt;- stan_crm(outcome_str = outcomes, skeleton = skeleton,
                target = target, model = 'empiric', beta_sd = 1)
dose_finding_path_node(node_id = 2, parent_node_id = 1, depth = 1,
                       outcomes = outcomes, next_dose = fit$recommended_dose,
                       fit = fit, parent_fit = parent_fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='eff_at_dose'>Get the number of efficacy events seen at the doses under investigation.</h2><span id='topic+eff_at_dose'></span><span id='topic+eff_at_dose.efftox_fit'></span>

<h3>Description</h3>

<p>Get the number of efficacy events seen at the doses under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff_at_dose(x, dose, ...)

## S3 method for class 'efftox_fit'
eff_at_dose(x, dose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff_at_dose_+3A_x">x</code></td>
<td>
<p>An R object of class <code>"dose_finding_fit"</code></p>
</td></tr>
<tr><td><code id="eff_at_dose_+3A_dose">dose</code></td>
<td>
<p>Optional integer, at which dose-level? Omit to get data on all doses.</p>
</td></tr>
<tr><td><code id="eff_at_dose_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# EffTox example
x &lt;- stan_efftox_demo(outcome_str = '1N 2E')
eff_at_dose(fit)            # c(0, 1, 0, 0)
eff_at_dose(fit, dose = 2)  # 1
eff_at_dose(fit, dose = 3)  # 0

## End(Not run)
</code></pre>

<hr>
<h2 id='efftox_analysis_to_df'>EffTox analysis to data.frame</h2><span id='topic+efftox_analysis_to_df'></span>

<h3>Description</h3>

<p>Convenient function to turn an <code><a href="#topic+efftox_fit">efftox_fit</a></code>
into a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_analysis_to_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_analysis_to_df_+3A_x">x</code></td>
<td>
<p>An instance of <code><a href="#topic+efftox_fit">efftox_fit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_efftox">stan_efftox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- stan_efftox_demo(outcome_str = '1N 2E 3B')
df &lt;- efftox_analysis_to_df(fit)
df

</code></pre>

<hr>
<h2 id='efftox_contour_plot'>Plot EffTox utility contours</h2><span id='topic+efftox_contour_plot'></span>

<h3>Description</h3>

<p>Plot EffTox utility contours. The probability of efficacy is
on the x-axis and toxicity on the y-axis. The zero-utility curve is plotted
bolder. The three &quot;hinge points&quot; are plotted as blue triangles. Optional
Prob(Efficacy) vs Prob(Toxicity) points can be added; these are shown as
red numerals, enumerated in the order provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_contour_plot(
  fit,
  use_ggplot = FALSE,
  prob_eff = fit$prob_eff,
  prob_tox = fit$prob_tox,
  num_points = 1000,
  util_vals = seq(-3, 3, by = 0.2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_contour_plot_+3A_fit">fit</code></td>
<td>
<p>An instance of <code><a href="#topic+efftox_fit">efftox_fit</a></code>.</p>
</td></tr>
<tr><td><code id="efftox_contour_plot_+3A_use_ggplot">use_ggplot</code></td>
<td>
<p>logical, TRUE to use ggplot2. Defaults to FALSE to use
standard R graphics.</p>
</td></tr>
<tr><td><code id="efftox_contour_plot_+3A_prob_eff">prob_eff</code></td>
<td>
<p>vector of numbers between 0 and 1, containing the
efficacy probabilities of extra points to add to the plot as points,
e.g. the posterior mean efficacy probabilities of the doses under
investigation. Paired with prob_tox, thus they should be the same length.
Defaults to the values fitted by the model. Use NULL to supress.</p>
</td></tr>
<tr><td><code id="efftox_contour_plot_+3A_prob_tox">prob_tox</code></td>
<td>
<p>vector of numbers between 0 and 1, containing the
toxicity probabilities of extra points to add to the plot as points,
e.g. the posterior mean toxicity probabilities of the doses under
investigation. Paired with prob_eff, thus they should be the same length.
Defaults to the values fitted by the model. Use NULL to supress.</p>
</td></tr>
<tr><td><code id="efftox_contour_plot_+3A_num_points">num_points</code></td>
<td>
<p>integer for number of points to calculate on each curve.
The default is 1000 and this should be plenty.</p>
</td></tr>
<tr><td><code id="efftox_contour_plot_+3A_util_vals">util_vals</code></td>
<td>
<p>A contour is plotted for each of these utility values.
The default is contours spaced by 0.2 between from -3 and 3,
i.e. <code>seq(-3, 3, by = 0.2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>use_ggplot = TRUE</code>, an instance of <code>ggplot</code>; else no
object is returned. Omit assignment in either case to just view the plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_efftox">stan_efftox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- stan_efftox_demo(outcome_str = '1N 2E 3B')
efftox_contour_plot(fit)
title('EffTox utility contours')
# The same with ggplot2
efftox_contour_plot(fit, use_ggplot = TRUE) +
                    ggplot2::ggtitle('EffTox utility contours')

</code></pre>

<hr>
<h2 id='efftox_dtps'>Calculate dose-transition pathways for an EffTox study</h2><span id='topic+efftox_dtps'></span>

<h3>Description</h3>

<p>Calculate dose-transition pathways for an EffTox study.
The function <code><a href="#topic+efftox_dtps_to_dataframe">efftox_dtps_to_dataframe</a></code> performs a similar
function, but is much less-flexible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_dtps(
  cohort_sizes,
  previous_outcomes = "",
  next_dose = NULL,
  user_dose_func = NULL,
  verbose = FALSE,
  i_am_patient = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_dtps_+3A_cohort_sizes">cohort_sizes</code></td>
<td>
<p>vector of future cohort sizes, i.e. positive integers.
E.g. To calculate paths for the the next cohort of two followed by another
cohort of three, use <code>cohort_sizes = c(2, 3)</code>.</p>
</td></tr>
<tr><td><code id="efftox_dtps_+3A_previous_outcomes">previous_outcomes</code></td>
<td>
<p>Outcomes observed hitherto in the syntax required
by <code><a href="#topic+efftox_parse_outcomes">efftox_parse_outcomes</a></code>.</p>
</td></tr>
<tr><td><code id="efftox_dtps_+3A_next_dose">next_dose</code></td>
<td>
<p>the dose-level to be given to the immediately next cohort.</p>
</td></tr>
<tr><td><code id="efftox_dtps_+3A_user_dose_func">user_dose_func</code></td>
<td>
<p>optional delegate for deciding dose. A function that
takes a <code><a href="#topic+efftox_fit">efftox_fit</a></code> as the sole argument and returns the integer
(1-based) dose-level to be given next, or NA to show that no dose should be
chosen and the trial stopped. This function gives the user the opportunity to
build in custom behaviour to tailor the dose selection decision in response
to the insights garnered by the fit model, or recommend that a trial path
be halted immediately. If omitted, the dose ordinarily chosen by the model is
used. An example is given below.</p>
</td></tr>
<tr><td><code id="efftox_dtps_+3A_verbose">verbose</code></td>
<td>
<p>logical, TRUE to get progress messages.</p>
</td></tr>
<tr><td><code id="efftox_dtps_+3A_i_am_patient">i_am_patient</code></td>
<td>
<p>logical, TRUE to show your tolerance for waiting for over 100
models to fit. Set to FALSE by default.</p>
</td></tr>
<tr><td><code id="efftox_dtps_+3A_...">...</code></td>
<td>
<p>extra params passed to <code>rstan::sampling</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dose pathways in a <code>data.frame</code>.
</p>


<h3>References</h3>

<p>Yap C, Billingham LJ, Cheung YK, Craddock C, Oâ€™Quigley J.
Dose transition pathways: The missing link between complex dose-finding
designs and simple decision-making. Clinical Cancer Research.
2017;23(24):7440-7447. doi:10.1158/1078-0432.CCR-17-0582
</p>
<p>Brock K, Billingham L, Copland M, Siddique S, Sirovica M, Yap C.
Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology. 2017;17(1):112.
doi:10.1186/s12874-017-0381-x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efftox_parse_outcomes">efftox_parse_outcomes</a></code>,
<code><a href="#topic+stan_efftox">stan_efftox</a></code>,
<code><a href="#topic+efftox_path_analysis">efftox_path_analysis</a></code>,
<code><a href="#topic+dose_finding_path_node">dose_finding_path_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate paths for the first cohort of 3 in Thall et al 2014 example
paths1 &lt;- efftox_dtps(cohort_sizes = c(3), next_dose = 1,
                      real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
                      efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                      p_e = 0.1, p_t = 0.1,
                      eff0 = 0.5, tox1 = 0.65,
                      eff_star = 0.7, tox_star = 0.25,
                      alpha_mean = -7.9593, alpha_sd = 3.5487,
                      beta_mean = 1.5482, beta_sd = 3.5018,
                      gamma_mean = 0.7367, gamma_sd = 2.5423,
                      zeta_mean = 3.4181, zeta_sd = 2.4406,
                      eta_mean = 0, eta_sd = 0.2,
                      psi_mean = 0, psi_sd = 1, seed = 123)



# Calculate paths for the next two cohorts of 2, in an in-progress trial
# Warning: this create 100 paths. It will run for a minute or two.
paths2 &lt;- efftox_dtps(cohort_sizes = c(2, 2),
                      previous_outcomes = '1NN 2EE',
                      next_dose = 1,
                      real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
                      efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                      p_e = 0.1, p_t = 0.1,
                      eff0 = 0.5, tox1 = 0.65,
                      eff_star = 0.7, tox_star = 0.25,
                      alpha_mean = -7.9593, alpha_sd = 3.5487,
                      beta_mean = 1.5482, beta_sd = 3.5018,
                      gamma_mean = 0.7367, gamma_sd = 2.5423,
                      zeta_mean = 3.4181, zeta_sd = 2.4406,
                      eta_mean = 0, eta_sd = 0.2,
                      psi_mean = 0, psi_sd = 1, seed = 123,
                      i_am_patient = TRUE)

# Paths can be converted to a tibble
library(tibble)
library(dplyr)
df &lt;- as_tibble(paths2)
df %&gt;% print(n = 200)

# And shaped in a wide format
spread_paths(df %&gt;% select(-fit, -parent_fit, -dose_index)) %&gt;%
  print(n = 100)
# Incredibly, there are 100 ways these two cohorts of two can end up.



# An example with a custom dose selection function.
# Define a function to select the maximal utility dose, no matter what.
# Note: this diverges from the original authors' intentions; we provide this
# for illustration only!
max_utility_dose &lt;- function(efftox_fit) {
  return(which.max(efftox_fit$utility))
}
# Fit the paths, providing the user_dose_func parameter
# Warning: this create 100 paths. It will run for a minute or two.
paths3 &lt;- efftox_dtps(cohort_sizes = c(2, 2),
                      previous_outcomes = '1NN 2EE',
                      next_dose = 1,
                      real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
                      efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                      p_e = 0.1, p_t = 0.1,
                      eff0 = 0.5, tox1 = 0.65,
                      eff_star = 0.7, tox_star = 0.25,
                      alpha_mean = -7.9593, alpha_sd = 3.5487,
                      beta_mean = 1.5482, beta_sd = 3.5018,
                      gamma_mean = 0.7367, gamma_sd = 2.5423,
                      zeta_mean = 3.4181, zeta_sd = 2.4406,
                      eta_mean = 0, eta_sd = 0.2,
                      psi_mean = 0, psi_sd = 1,
                      user_dose_func = max_utility_dose,
                      seed = 123, i_am_patient = TRUE)

# We can see where the dose-selections differ at the second future cohort
# by joining these paths to those calculated in the previous example:
left_join(
  as_tibble(paths2)%&gt;%
    select(.node, .parent, .depth, outcomes, model_dose = next_dose),
  as_tibble(paths3) %&gt;%
    select(.node, user_dose = next_dose),
  by = '.node'
) %&gt;% spread_paths() %&gt;%
  filter(model_dose2 != user_dose2)
# They differ in many places. The user defined functions sometimes selects
# higher doses; sometimes lower.

## End(Not run)

</code></pre>

<hr>
<h2 id='efftox_dtps_to_dataframe'>Calculate dose-transition pathways for an EffTox study</h2><span id='topic+efftox_dtps_to_dataframe'></span>

<h3>Description</h3>

<p>Calculate dose-transition pathways for an EffTox study.
Note that TODO TODO TODO
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_dtps_to_dataframe(dat, cohort_sizes, next_dose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_dtps_to_dataframe_+3A_dat">dat</code></td>
<td>
<p>An instance of <code><a href="#topic+efftox_params">efftox_params</a></code>, a list of EffTox
parameters. An example is yielded by <code><a href="#topic+efftox_parameters_demo">efftox_parameters_demo</a></code>.</p>
</td></tr>
<tr><td><code id="efftox_dtps_to_dataframe_+3A_cohort_sizes">cohort_sizes</code></td>
<td>
<p>vector of future cohort sizes, i.e. positive integers.
E.g. To calculate paths for the the next cohort of two followed by another
cohort of three, use <code>cohort_sizes = c(2, 3)</code>.</p>
</td></tr>
<tr><td><code id="efftox_dtps_to_dataframe_+3A_next_dose">next_dose</code></td>
<td>
<p>the dose-level to be given to the immediately next cohort.</p>
</td></tr>
<tr><td><code id="efftox_dtps_to_dataframe_+3A_...">...</code></td>
<td>
<p>extra params passed to <code>rstan::sampling</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dose pathways in a <code>data.frame</code>.
</p>


<h3>References</h3>

<p>Brock K, Billingham L, Copland M, Siddique S, Sirovica M, Yap C.
Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology. 2017;17(1):112.
doi:10.1186/s12874-017-0381-x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efftox_dtps">efftox_dtps</a></code>, <code><a href="#topic+efftox_params">efftox_params</a></code>,
<code><a href="#topic+efftox_parameters_demo">efftox_parameters_demo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the paths for the first cohort of 3 in Thall et al 2014 example
dat &lt;- efftox_parameters_demo()
## Not run: 
dtps1 &lt;- efftox_dtps_to_dataframe(dat = dat, cohort_sizes = c(3),
                                  next_dose = 1)

## End(Not run)
# To calculate future paths in a partially-observed trial
dat &lt;- efftox_parameters_demo()
dat$doses = array(c(1,1,1))
dat$eff = array(c(0,0,0))
dat$tox = array(c(1,1,1))
dat$num_patients = 3
## Not run: 
dtps2 &lt;- efftox_dtps_to_dataframe(dat = dat, cohort_sizes = c(3),
                                  next_dose = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='efftox_fit-class'>Class of model fit by <span class="pkg">trialr</span> using the EffTox dose-finding design.</h2><span id='topic+efftox_fit-class'></span><span id='topic+efftox_fit'></span>

<h3>Description</h3>

<p>Phase I/II dose-finding trials, i.e. those that search for a dose my efficacy
and toxicity outcomes search for the optimal biological dose (OBD), rather
than the maximum tolerated dose (MTD) that is typically sought be traditional
toxicity-only dose-finding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_fit(
  dose_indices,
  num_patients,
  doses,
  tox,
  eff,
  prob_tox,
  prob_eff,
  median_prob_tox,
  median_prob_eff,
  prob_acc_tox,
  prob_acc_eff,
  utility,
  post_utility,
  prob_obd,
  acceptable,
  recommended_dose,
  dat,
  fit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_fit-class_+3A_dose_indices">dose_indices</code></td>
<td>
<p>A vector of integers representing the dose-levels under
consideration.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_num_patients">num_patients</code></td>
<td>
<p>Integer, the number of patients analysed.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_doses">doses</code></td>
<td>
<p>vector of integers representing the dose given to the patients.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_tox">tox</code></td>
<td>
<p>vector of integers representing the toxicity status of the
patients.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_eff">eff</code></td>
<td>
<p>vector of integers representing the efficacy status of the
patients.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_prob_tox">prob_tox</code></td>
<td>
<p>The posterior mean probabilities of toxicity at doses 1:n;
a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_prob_eff">prob_eff</code></td>
<td>
<p>The posterior mean probabilities of efficacy at doses 1:n;
a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_median_prob_tox">median_prob_tox</code></td>
<td>
<p>The posterior median probabilities of toxicity at
doses 1:n; a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_median_prob_eff">median_prob_eff</code></td>
<td>
<p>The posterior mean probabilities of efficacy at doses
1:n; a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_prob_acc_tox">prob_acc_tox</code></td>
<td>
<p>The posterior mean probabilities that toxicity at the
doses is acceptable, i.e. that it is less than the maximum toxicity
threshold; a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_prob_acc_eff">prob_acc_eff</code></td>
<td>
<p>The posterior mean probabilities that efficacy at the
doses is acceptable, i.e. that it exceeds the minimum acceptable efficacy
threshold; a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_utility">utility</code></td>
<td>
<p>The utilities of doses 1:n, calculated by plugging the
posterior mean probabilities of efficacy and toxicity into the utility
formula, as advocated by Thall &amp; Cook. Contrast to <code>post_utility</code>;
a vector of numbers.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_post_utility">post_utility</code></td>
<td>
<p>The posterior mean utilities of doses 1:n, calculated
from the posterior distributions of the utilities. This is in contrast to
<code>utility</code>, which uses plug-in posterior means of efficacy and toxicity,
as advocated by Thall &amp; Cook; a vector of numbers.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_prob_obd">prob_obd</code></td>
<td>
<p>The posterior probability that each dose is the optimal
biological dose (OBD); a vector of numbers between 0 and 1. This probability
reflects the uncertainty remaining in the parameter distributions, whereas
<code>prob_tox</code> and <code>prob_eff</code> (etc) do not.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_acceptable">acceptable</code></td>
<td>
<p>A vector of logical values to indicate whether doses 1:n
are acceptable, according to the rules for acceptable efficacy &amp; toxicity,
and rules on not skipping untested doses.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_recommended_dose">recommended_dose</code></td>
<td>
<p>An integer representing the dose-level recommended
for the next patient or cohort; or <code>NA</code> if stopping is recommended.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_dat">dat</code></td>
<td>
<p>Object <code><a href="#topic+efftox_params">efftox_params</a></code> containing data passed to
<code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
<tr><td><code id="efftox_fit-class_+3A_fit">fit</code></td>
<td>
<p>An object of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code>,
containing the posterior samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>methods(class = "efftox_fit")</code> for an overview of available
methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_efftox">stan_efftox</a></code>
<code><a href="#topic+stan_efftox_demo">stan_efftox_demo</a></code>
</p>

<hr>
<h2 id='efftox_get_tox'>Get the Prob(Tox) for Prob(Eff) and utility pairs</h2><span id='topic+efftox_get_tox'></span>

<h3>Description</h3>

<p>Get the probability of toxicity for probability-of-efficacy and
utility pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_get_tox(eff, util, p, eff0, tox1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_get_tox_+3A_eff">eff</code></td>
<td>
<p>Probability of efficacy; number between 0 and 1</p>
</td></tr>
<tr><td><code id="efftox_get_tox_+3A_util">util</code></td>
<td>
<p>Utility score; number</p>
</td></tr>
<tr><td><code id="efftox_get_tox_+3A_p">p</code></td>
<td>
<p>p-index of EffTox utility contours. Use <code>efftox_solve_p</code></p>
</td></tr>
<tr><td><code id="efftox_get_tox_+3A_eff0">eff0</code></td>
<td>
<p>Efficacy probability required when toxicity is impossible;
a number between 0 and 1</p>
</td></tr>
<tr><td><code id="efftox_get_tox_+3A_tox1">tox1</code></td>
<td>
<p>Toxicity probability permitted when efficacy is guaranteed;
a number between 0 and 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability(s) of toxicity
</p>


<h3>Note</h3>

<p>Various ways of vectorising the function are demonstrated in the
examples
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efftox_solve_p">efftox_solve_p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- efftox_solve_p(0.5, 0.65, 0.7, 0.25)

prob_tox &lt;- efftox_get_tox(0.7, 0, p, eff0 = 0.5, tox1 = 0.65)
round(prob_tox, 2) == 0.25

prob_tox &lt;- efftox_get_tox(0.7, seq(-0.5, 0.25, by = 0.25), p, eff0 = 0.5,
                           tox1 = 0.65)
round(prob_tox, 2) == c(0.57, 0.41, 0.25, 0.09)

prob_tox &lt;- efftox_get_tox(c(0.5, 0.7, 0.8), 0.25, p, eff0 = 0.5, tox1 = 0.65)
round(prob_tox, 2) == c(NaN, 0.09, 0.22)

prob_tox &lt;- efftox_get_tox(c(0.5, 0.7, 0.8), c(-1, 0, 1), p, eff0 = 0.5,
                           tox1 = 0.65)
round(prob_tox, 2) == c(0.63, 0.25, NaN)

</code></pre>

<hr>
<h2 id='efftox_parameters_demo'>Get parameters to run the EffTox demo</h2><span id='topic+efftox_parameters_demo'></span>

<h3>Description</h3>

<p>Get parameters to run the EffTox demo. These match those used
to demonstrate EffTox in Thall et al. 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_parameters_demo()
</code></pre>


<h3>Value</h3>

<p>a <code>list</code> of parameters, described in <code>efftox_params</code>
</p>


<h3>References</h3>

<p>Thall, Herrick, Nguyen, Venier &amp; Norris. 2014, Effective sample
size for computing prior hyperparameters in Bayesian phase I-II dose-finding
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efftox_params">efftox_params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- efftox_parameters_demo()
names(dat)
dat$real_doses == c(1, 2, 4, 6.6, 10)

</code></pre>

<hr>
<h2 id='efftox_params-class'>Container class for parameters to fit the EffTox model in trialr.</h2><span id='topic+efftox_params-class'></span><span id='topic+efftox_params'></span>

<h3>Description</h3>

<p>Container class for parameters to fit the EffTox model in trialr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_params(
  real_doses,
  efficacy_hurdle,
  toxicity_hurdle,
  p_e,
  p_t,
  eff0,
  tox1,
  eff_star,
  tox_star,
  priors
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_params-class_+3A_real_doses">real_doses</code></td>
<td>
<p>a vector of numbers.The doses under investigation.
They should be ordered from lowest to highest and be in consistent units.
E.g., to conduct a dose-finding trial of doses 10mg, 20mg and 50mg, use
c(10, 20, 50).</p>
</td></tr>
<tr><td><code id="efftox_params-class_+3A_efficacy_hurdle">efficacy_hurdle</code></td>
<td>
<p>Minimum acceptable efficacy probability.
A number between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_params-class_+3A_toxicity_hurdle">toxicity_hurdle</code></td>
<td>
<p>Maximum acceptable toxicity probability.
A number between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_params-class_+3A_p_e">p_e</code></td>
<td>
<p>Certainty required to infer a dose is acceptable with regards to
being probably efficacious; a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_params-class_+3A_p_t">p_t</code></td>
<td>
<p>Certainty required to infer a dose is acceptable with regards to
being probably tolerable; a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_params-class_+3A_eff0">eff0</code></td>
<td>
<p>Efficacy probability required when toxicity is impossible;
a number between 0 and 1 (see Details).</p>
</td></tr>
<tr><td><code id="efftox_params-class_+3A_tox1">tox1</code></td>
<td>
<p>Toxicity probability permitted when efficacy is guaranteed;
a number between 0 and 1 (see Details).</p>
</td></tr>
<tr><td><code id="efftox_params-class_+3A_eff_star">eff_star</code></td>
<td>
<p>Efficacy probability of an equi-utility third point (see
Details).</p>
</td></tr>
<tr><td><code id="efftox_params-class_+3A_tox_star">tox_star</code></td>
<td>
<p>Toxicity probability of an equi-utility third point (see
Details).</p>
</td></tr>
<tr><td><code id="efftox_params-class_+3A_priors">priors</code></td>
<td>
<p>instance of class <code><a href="#topic+efftox_priors">efftox_priors</a></code>, the
hyperparameters for normal priors on the six model parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+efftox_priors">efftox_priors</a></code>
<code><a href="#topic+get_efftox_priors">get_efftox_priors</a></code>
<code><a href="#topic+stan_efftox">stan_efftox</a></code>
<code><a href="#topic+stan_efftox_demo">stan_efftox_demo</a></code>
</p>

<hr>
<h2 id='efftox_parse_outcomes'>Parse a string of EffTox outcomes to binary vector notation.</h2><span id='topic+efftox_parse_outcomes'></span>

<h3>Description</h3>

<p>Parse a string of EffTox outcomes to the binary vector notation
required by Stan for model invocation. The outcome string describes the doses
given and outcomes observed. The format of the string is described in Brock
et al. (2017). The letters E, T, N and B are used to represents patients that
experienced (E)fficacy only, (T)oxicity only, (B)oth efficacy and toxicity,
and (N)either. These letters are concatenated after numerical dose-levels to
convey the outcomes of cohorts of patients. For instance, <code>2ETB</code>
represents a cohort of three patients that were treated at dose-level 2, and
experienced efficacy, toxicity and both events, respectively. The results of
cohorts are separated by spaces. Thus, <code>2ETB 1NN</code> extends our previous
example, where the next cohort of two were treated at dose-level 1 and both
patients experienced neither efficacy nor toxicity. See examples.
</p>
<p>We present the notation in the EffTox setting but it is applicable in
general seamless phase I/II dose-finding scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_parse_outcomes(outcome_string, as.list = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_parse_outcomes_+3A_outcome_string">outcome_string</code></td>
<td>
<p>character string, conveying doses given and outcomes
observed.</p>
</td></tr>
<tr><td><code id="efftox_parse_outcomes_+3A_as.list">as.list</code></td>
<td>
<p>TRUE (be default) to return a <code>list</code>;
FALSE to return a <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>as.list == TRUE</code>, a list with elements <code>eff</code>, <code>tox</code>,
<code>doses</code> and <code>num_patients</code>. These elements are congruent with those
of the same name in <code>efftox_params</code>.
If <code>as.list == FALSE</code>, a data.frame with columns <code>eff</code>, <code>tox</code>,
and <code>doses</code>.
</p>


<h3>References</h3>

<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp; Yap, C.
(2017). Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = efftox_parse_outcomes('1NNE 2EEN 3TBB')
x$num_patients == 9
x$eff == c(0, 0, 1, 1, 1, 0, 0, 1, 1)
sum(x$tox) == 3

</code></pre>

<hr>
<h2 id='efftox_path_analysis'>Fit an EffTox model to the incrementally observed outcomes on a trial pathway.</h2><span id='topic+efftox_path_analysis'></span>

<h3>Description</h3>

<p>Fit a EffTox model to the outcomes cumulatively observed at the end of each
cohort in a trial pathway. E.g. if the trial pathway is 1EN 2NN 3BT, we have
three cohorts of two patients. This function will fit the model to the
following four states: before any patients have been evaluated; after 1EN;
after 1EN 2NN; and finally after 1EN 2NN 3BT. This allows us to analyse how
the trial model is evolving in its estimation as trial data is accumulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_path_analysis(outcome_str, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_path_analysis_+3A_outcome_str">outcome_str</code></td>
<td>
<p>A string representing the outcomes observed hitherto.
See <code><a href="#topic+efftox_parse_outcomes">efftox_parse_outcomes</a></code> for a description of syntax and
examples. Alternatively, you may provide <code>doses_given</code> and <code>tox</code>
parameters. See Details.</p>
</td></tr>
<tr><td><code id="efftox_path_analysis_+3A_verbose">verbose</code></td>
<td>
<p>logical, TRUE to get log messages.</p>
</td></tr>
<tr><td><code id="efftox_path_analysis_+3A_...">...</code></td>
<td>
<p>All other parameters are passed to <code><a href="#topic+stan_efftox">stan_efftox</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of <code><a href="#topic+dose_finding_path_node">dose_finding_path_node</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Kristian Brock
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efftox_parse_outcomes">efftox_parse_outcomes</a></code>,
<code><a href="#topic+stan_efftox">stan_efftox</a></code>,
<code><a href="#topic+dose_finding_path_node">dose_finding_path_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# EffTox example
paths &lt;- efftox_path_analysis(
  outcome_str = '1NNN 2NEN 3NEB',
  real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
  efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
  p_e = 0.1, p_t = 0.1,
  eff0 = 0.5, tox1 = 0.65,
  eff_star = 0.7, tox_star = 0.25,
  alpha_mean = -7.9593, alpha_sd = 3.5487,
  beta_mean = 1.5482, beta_sd = 3.5018,
  gamma_mean = 0.7367, gamma_sd = 2.5423,
  zeta_mean = 3.4181, zeta_sd = 2.4406,
  eta_mean = 0, eta_sd = 0.2,
  psi_mean = 0, psi_sd = 1, seed = 123, refresh = 0)

length(paths)  # 4
names(paths)[1]  # ""
names(paths)[2]  # "1NNN"
names(paths)[3]  # "1NNN 2NEN"
names(paths)[4]  # "1NNN 2NEN 3NEB"
# Each node is an analysis fit to the cumulative outcomes
# Converting to a tibble presents some nice tidyverse-related opportunities
library(tibble)
df &lt;- as_tibble(paths)
df

## End(Not run)
</code></pre>

<hr>
<h2 id='efftox_priors'>Simple class to hold prior hyperparameters for the EffTox model.</h2><span id='topic+efftox_priors'></span>

<h3>Description</h3>

<p>Simple class to hold prior hyperparameters for the EffTox model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_priors(
  alpha_mean,
  alpha_sd,
  beta_mean,
  beta_sd,
  gamma_mean,
  gamma_sd,
  zeta_mean,
  zeta_sd,
  eta_mean,
  eta_sd,
  psi_mean,
  psi_sd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_priors_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>The prior normal mean of the intercept term in the toxicity
logit model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>The prior normal standard deviation of the intercept term in
the toxicity logit model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_beta_mean">beta_mean</code></td>
<td>
<p>The prior normal mean of the slope term in the toxicity
logit model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_beta_sd">beta_sd</code></td>
<td>
<p>The prior normal standard deviation of the slope term in the
toxicity logit model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_gamma_mean">gamma_mean</code></td>
<td>
<p>The prior normal mean of the intercept term in the efficacy
logit model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_gamma_sd">gamma_sd</code></td>
<td>
<p>The prior normal standard deviation of the intercept term in
the efficacy logit model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_zeta_mean">zeta_mean</code></td>
<td>
<p>The prior normal mean of the slope term in the efficacy logit
model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_zeta_sd">zeta_sd</code></td>
<td>
<p>The prior normal standard deviation of the slope term in the
efficacy logit model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_eta_mean">eta_mean</code></td>
<td>
<p>The prior normal mean of the squared term coefficient in the
efficacy logit model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_eta_sd">eta_sd</code></td>
<td>
<p>The prior normal standard deviation of the squared term
coefficient in the efficacy logit model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_psi_mean">psi_mean</code></td>
<td>
<p>The prior normal mean of the association term in the combined
efficacy-toxicity model. A number.</p>
</td></tr>
<tr><td><code id="efftox_priors_+3A_psi_sd">psi_sd</code></td>
<td>
<p>The prior normal standard deviation of the association term in
the combined efficacy-toxicity model. A number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list-like, instance of class <code>efftox_priors</code>.
</p>


<h3>Author(s)</h3>

<p>Kristian Brock <a href="mailto:kristian.brock@gmail.com">kristian.brock@gmail.com</a>
</p>


<h3>References</h3>

<p>Thall, P., &amp; Cook, J. (2004). Dose-Finding Based on Efficacy-Toxicity
Trade-Offs. Biometrics, 60(3), 684-693.
</p>
<p>Thall, P., Herrick, R., Nguyen, H., Venier, J., &amp; Norris, J. (2014).
Effective sample size for computing prior hyperparameters in Bayesian
phase I-II dose-finding. Clinical Trials, 11(6), 657-666.
https://doi.org/10.1177/1740774514547397
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The priors used in Thall et al. (2014)
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
# The class exists simply to hold these twelve values.
</code></pre>

<hr>
<h2 id='efftox_process'>Process RStan samples from an EffTox model</h2><span id='topic+efftox_process'></span>

<h3>Description</h3>

<p>Internal function to process rstan samples from an EffTox model
to make inferences about dose-acceptability, dose-utility and which dose
should be recommended next.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_process(dat, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_process_+3A_dat">dat</code></td>
<td>
<p>An instance of <code><a href="#topic+efftox_params">efftox_params</a></code>, a list of EffTox
parameters. An example is yielded by <code><a href="#topic+efftox_parameters_demo">efftox_parameters_demo</a></code>.</p>
</td></tr>
<tr><td><code id="efftox_process_+3A_fit">fit</code></td>
<td>
<p>An instance of <code>rstan::stanmodel</code>, derived by fitting the
trialr EffTox model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of <code><a href="#topic+efftox_fit">efftox_fit</a></code>.
</p>

<hr>
<h2 id='efftox_simulate'>Run EffTox simulations</h2><span id='topic+efftox_simulate'></span>

<h3>Description</h3>

<p>Run EffTox simulations for assumed true efficacy and toxicity
curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_simulate(
  dat,
  num_sims,
  first_dose,
  true_eff,
  true_tox,
  cohort_sizes,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_simulate_+3A_dat">dat</code></td>
<td>
<p>An instance of <code><a href="#topic+efftox_params">efftox_params</a></code>, a list of EffTox
parameters. An example is yielded by <code><a href="#topic+efftox_parameters_demo">efftox_parameters_demo</a></code>.</p>
</td></tr>
<tr><td><code id="efftox_simulate_+3A_num_sims">num_sims</code></td>
<td>
<p>integer, number of simulated iterations</p>
</td></tr>
<tr><td><code id="efftox_simulate_+3A_first_dose">first_dose</code></td>
<td>
<p>integer, the dose-level to give to patient 1, e.g. 1 for
the lowest dose.</p>
</td></tr>
<tr><td><code id="efftox_simulate_+3A_true_eff">true_eff</code></td>
<td>
<p>the true probabilities of efficacy at the doses under
investigation; a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_simulate_+3A_true_tox">true_tox</code></td>
<td>
<p>the true probabilities of toxicity at the doses under
investigation; a vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="efftox_simulate_+3A_cohort_sizes">cohort_sizes</code></td>
<td>
<p>a vector of integer cohort sizes. A dose decision is made
when each cohort is completed and the next cohort is treated at the
recommended dose. To conduct a trial using at most 20 patients, where dose is
re-evaluated after every second patient, use <code>rep(2, 10)</code>. To conduct a
trial of 8 patients where dose is re-evaluated after each single patient, use
<code>rep(1, 8)</code>. Cohort size need not be uniform. E.g.
<code>c(rep(1, 5), rep(3, 10))</code> represents a trial where the dose is
re-evaluated after each patient for the first 5 patients, and then after
every third patient for a further 30 patients.</p>
</td></tr>
<tr><td><code id="efftox_simulate_+3A_...">...</code></td>
<td>
<p>Extra parameters provided via the ellipsis are passed to
<code>stan::sampling</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with named elements <code>recommended_dose</code>,
<code>efficacies</code>, <code>toxicities</code>, and <code>doses_given</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- efftox_parameters_demo()
set.seed(123)
# Let's say we want to use only 2 chains. Extra args are passed to stan
## Not run: 
sims &lt;- efftox_simulate(dat, num_sims = 10, first_dose = 1,
                        true_eff = c(0.20, 0.40, 0.60, 0.80, 0.90),
                        true_tox = c(0.05, 0.10, 0.15, 0.20, 0.40),
                        cohort_sizes = rep(3, 13),
                        chains = 2)
table(sims$recommended_dose) / length(sims$recommended_dose)
table(unlist(sims$doses_given)) / length(unlist(sims$doses_given))
table(unlist(sims$doses_given)) / length(sims$recommended_dose)

## End(Not run)
# In real life, we would run thousands of iterations, not 10.
# This is an example.
</code></pre>

<hr>
<h2 id='efftox_solve_p'>Calculate the p-index for EffTox utility contours</h2><span id='topic+efftox_solve_p'></span>

<h3>Description</h3>

<p>Calculate the p-index for EffTox utility contours so that the neutral utility
contour intersects the following points in the
Prob(Efficacy) - Prob(Toxicity) plane:
(<code>eff0</code>, 0), (1, <code>tox1</code>) and (<code>eff_star</code>, <code>tox_star</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_solve_p(eff0, tox1, eff_star, tox_star)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_solve_p_+3A_eff0">eff0</code></td>
<td>
<p>Efficacy probability required when toxicity is impossible;
a number between 0 and 1</p>
</td></tr>
<tr><td><code id="efftox_solve_p_+3A_tox1">tox1</code></td>
<td>
<p>Toxicity probability permitted when efficacy is guaranteed;
a number between 0 and 1</p>
</td></tr>
<tr><td><code id="efftox_solve_p_+3A_eff_star">eff_star</code></td>
<td>
<p>Efficacy probability of an equi-utility third point</p>
</td></tr>
<tr><td><code id="efftox_solve_p_+3A_tox_star">tox_star</code></td>
<td>
<p>Toxicity probability of an equi-utility third point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-index
</p>


<h3>References</h3>

<p>Thall, Herrick, Nguyen, Venier &amp; Norris. 2014, Effective sample
size for computing prior hyperparameters in Bayesian phase I-II dose-finding
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efftox_solve_p(0.5, 0.65, 0.7, 0.25)

</code></pre>

<hr>
<h2 id='efftox_superiority'>Get dose-superiority matrix in EffTox</h2><span id='topic+efftox_superiority'></span>

<h3>Description</h3>

<p>Get a dose-superiority matrix from an EffTox dose analysis.
EffTox seeks to choose the dose with the highest utility, thus superiority
is inferred by posterior utility. The item in row i, col j is the posterior
probability that the utility of dose j exceeds that of dose i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_superiority(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_superiority_+3A_fit">fit</code></td>
<td>
<p>An instance of <code>efftox_fit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n by n matrix, where n is number of doses under investigation.
The item in row i, col j is the posterior probability that the utility of
dose j exceeds that of dose i.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- stan_efftox_demo('1N 2E 3B')
sup_mat &lt;- efftox_superiority(fit)
</code></pre>

<hr>
<h2 id='efftox_utility'>Get the utility of efficacy &amp; toxicity probability pairs</h2><span id='topic+efftox_utility'></span>

<h3>Description</h3>

<p>Get the utility of efficacy &amp; toxicity probability pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_utility(p, eff0, tox1, prob_eff, prob_tox)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_utility_+3A_p">p</code></td>
<td>
<p>p-index of EffTox utility contours. Use <code>efftox_solve_p</code></p>
</td></tr>
<tr><td><code id="efftox_utility_+3A_eff0">eff0</code></td>
<td>
<p>Efficacy probability required when toxicity is impossible;
a number between 0 and 1</p>
</td></tr>
<tr><td><code id="efftox_utility_+3A_tox1">tox1</code></td>
<td>
<p>Toxicity probability permitted when efficacy is guaranteed;
a number between 0 and 1</p>
</td></tr>
<tr><td><code id="efftox_utility_+3A_prob_eff">prob_eff</code></td>
<td>
<p>Probability of efficacy; number between 0 and 1</p>
</td></tr>
<tr><td><code id="efftox_utility_+3A_prob_tox">prob_tox</code></td>
<td>
<p>Probability of toxicity; number between 0 and 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Utility value(s)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efftox_solve_p">efftox_solve_p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- efftox_solve_p(0.5, 0.65, 0.7, 0.25)

u &lt;- efftox_utility(p, 0.5, 0.65, prob_eff = 0.7, prob_tox = 0.25)
round(u, 4) == 0

u &lt;- efftox_utility(p, 0.5, 0.65, prob_eff = c(0.6, 0.7, 0.8),
                    prob_tox = c(0.1, 0.2, 0.3))
round(u, 2) == c(0.04, 0.08, 0.12)

</code></pre>

<hr>
<h2 id='efftox_utility_density_plot'>Plot densities of EffTox dose utilities</h2><span id='topic+efftox_utility_density_plot'></span>

<h3>Description</h3>

<p>Plot densities of EffTox dose utilities. Optionally plot only a
subset of the doses by specifying the <code>doses</code> parameter. This function
requires ggplot2 be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efftox_utility_density_plot(fit, doses = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efftox_utility_density_plot_+3A_fit">fit</code></td>
<td>
<p>An instance of <code>efftox_fit</code>.</p>
</td></tr>
<tr><td><code id="efftox_utility_density_plot_+3A_doses">doses</code></td>
<td>
<p>optional, vector of integer dose-levels to plot. E.g. to plot
only dose-levels 1, 2 &amp; 3 (and suppress the plotting of any other doses), use
<code>doses = 1:3</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of <code>ggplot</code>. Omit assignment to just view the plot.
</p>


<h3>Note</h3>

<p>This function requires that ggplot2 be installed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- stan_efftox_demo('1N 2E 3B')
efftox_utility_density_plot(fit) + ggplot2::ggtitle('My doses')  # Too busy?
# Specify subset of doses to make plot less cluttered
efftox_utility_density_plot(fit, doses = 1:3) + ggplot2::ggtitle('My doses')

</code></pre>

<hr>
<h2 id='get_efftox_priors'>Get normal prior hyperparameters for the EffTox model.</h2><span id='topic+get_efftox_priors'></span>

<h3>Description</h3>

<p>Get normal prior hyperparameters for the EffTox model using the algorithm
presented in Thall et al. (2014) that targets a family of priors with a
pre-specified effective sample size (ESS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_efftox_priors(
  doses = NULL,
  scaled_doses = NULL,
  pi_T,
  ess_T,
  pi_E,
  ess_E,
  num_samples = 10^4,
  seed = 123
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_efftox_priors_+3A_doses">doses</code></td>
<td>
<p>A vector of numbers, the doses under investigation. They
should be ordered from lowest to highest and be in consistent units.
E.g. to conduct a dose-finding trial of doses 10mg, 20mg and 50mg, use
c(10, 20, 50). Specify <code>doses</code> or <code>scaled_doses</code>.</p>
</td></tr>
<tr><td><code id="get_efftox_priors_+3A_scaled_doses">scaled_doses</code></td>
<td>
<p>Optional, vector of numbers, representing the scaled
doses under investigation. Thall et al. advocate
<code>scaled_doses = log(doses) - mean(log(doses))</code>, and that is what we use
here. Specify <code>doses</code> or <code>scaled_doses</code>.</p>
</td></tr>
<tr><td><code id="get_efftox_priors_+3A_pi_t">pi_T</code></td>
<td>
<p>Vector of prior expectations of probabilities of toxicity at the
doses. Should be congruent to <code>doses</code> or <code>scaled_doses</code>.</p>
</td></tr>
<tr><td><code id="get_efftox_priors_+3A_ess_t">ess_T</code></td>
<td>
<p>Numerical, sought total effective sample size for priors on
parameters in the toxicity sub-model. Thall et al. (2014) advocate values in
(0.3, 1.0) but stress that stress-testing with values outside this range may
be necessary.</p>
</td></tr>
<tr><td><code id="get_efftox_priors_+3A_pi_e">pi_E</code></td>
<td>
<p>Vector of prior expectations of probabilities of efficacy at the
doses. Should be congruent to <code>doses</code> or <code>scaled_doses</code>.</p>
</td></tr>
<tr><td><code id="get_efftox_priors_+3A_ess_e">ess_E</code></td>
<td>
<p>Numerical, sought total effective sample size for priors on
parameters in the efficacy sub-model. Thall et al. (2014) advocate values in
(0.3, 1.0) but stress that stress-testing with values outside this range may
be necessary.</p>
</td></tr>
<tr><td><code id="get_efftox_priors_+3A_num_samples">num_samples</code></td>
<td>
<p>Number of samples to draw from priors. The default 10^4
seems to be a nice compromise between accuracy and speed. Orders of magnitude
larger take a long time to run.</p>
</td></tr>
<tr><td><code id="get_efftox_priors_+3A_seed">seed</code></td>
<td>
<p>Optional seed. This process involves randomness so seeds are used
for repeatable results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of class <code><a href="#topic+efftox_priors">efftox_priors</a></code>.
</p>


<h3>References</h3>

<p>Thall, P., Herrick, R., Nguyen, H., Venier, J., &amp; Norris, J. (2014).
Effective sample size for computing prior hyperparameters in Bayesian
phase I-II dose-finding. Clinical Trials, 11(6), 657-666.
https://doi.org/10.1177/1740774514547397
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Reproduce the priors calculated in Thall et al. (2014)
p &lt;- get_efftox_priors(
  doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
  pi_T = c(0.02, 0.04, 0.06, 0.08, 0.10), ess_T = 0.9,
  pi_E = c(0.2, 0.4, 0.6, 0.8, 0.9), ess_E = 0.9
)
p
# These are close to the published example. They do not match exactly because
# the process of deriving them is iterative.

## End(Not run)
</code></pre>

<hr>
<h2 id='n_at_dose'>Get the number of patients treated at the doses under investigation.</h2><span id='topic+n_at_dose'></span><span id='topic+n_at_dose.dose_finding_fit'></span>

<h3>Description</h3>

<p>Get the number of patients treated at the doses under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_at_dose(x, dose, ...)

## S3 method for class 'dose_finding_fit'
n_at_dose(x, dose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_at_dose_+3A_x">x</code></td>
<td>
<p>An R object of class <code>"dose_finding_fit"</code></p>
</td></tr>
<tr><td><code id="n_at_dose_+3A_dose">dose</code></td>
<td>
<p>Optional integer, at which dose-level? Omit to get data on all doses.</p>
</td></tr>
<tr><td><code id="n_at_dose_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CRM example
target &lt;- 0.2
fit &lt;- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
                 target = target, model = 'empiric', beta_sd = sqrt(1.34),
                 seed = 123)
n_at_dose(fit)            # c(1, 1, 1, 0)
n_at_dose(fit, dose = 3)  # 1

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_dose_finding_outcomes'>Parse a string of dose-finding trial outcomes.</h2><span id='topic+parse_dose_finding_outcomes'></span>

<h3>Description</h3>

<p>Parse a string of dose-finding trial outcomes
</p>
<p>Parse a string of dose-finding trial outcomes to a list.
The outcome string describes the doses given, outcomes observed and the
timing of analyses that recommend a dose. The format of the string is
the pure phase I analogue to that described in Brock _et al_. (2017).
The letters T and N are used to represents patients that experienced
(T)oxicity and (N)o toxicity. These letters are concatenated after numerical
dose-levels to convey the outcomes of cohorts of patients.
For instance, <code>2NNT</code> represents a cohort of three patients that were
treated at dose-level 2, one of whom experienced toxicity, and two that did
not. The results of cohorts are separated by spaces and it is assumed that a
dose-finding decision takes place at the end of a cohort. Thus,
<code>2NNT 1NN</code> builds on our previous example, where the next cohort of two
were treated at dose-level 1 and neither of these patients experienced
toxicity. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_dose_finding_outcomes(outcome_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_dose_finding_outcomes_+3A_outcome_string">outcome_string</code></td>
<td>
<p>character representing doses given, outcomes
observed, and timing of analyses. See Description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a slot for each cohort. Each cohort slot is itself a
list, containing elements:
* <code>dose</code>, the integer dose delivered to the cohort;
* <code>outcomes</code>, a character string representing the <code>T</code> or <code>N</code>
outcomes for the patients in this cohort.
</p>


<h3>References</h3>

<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp; Yap, C.
(2017). Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = parse_dose_finding_outcomes('1NNN 2NNT 3TT')
length(x)
x[[1]]$dose
x[[1]]$outcomes
x[[2]]$dose
x[[2]]$outcomes
x[[3]]$dose
x[[3]]$outcomes

</code></pre>

<hr>
<h2 id='parse_eff_tox_dose_finding_outcomes'>Parse a string of phase I/II dose-finding trial outcomes.</h2><span id='topic+parse_eff_tox_dose_finding_outcomes'></span>

<h3>Description</h3>

<p>Parse a string of phase I/II dose-finding trial outcomes.
Phase I/II trials conduct dose-finding by efficacy and toxicity outcomes.
</p>
<p>Parse a string of phase I/II dose-finding outcomes to a list.
The outcome string describes the doses given, efficacy and toxicity outcomes
observed and the timing of analyses that recommend a dose. The format of the
string is described in Brock _et al_. (2017). The letters E, T, N &amp; B are
used to represents patients that experienced (E)fficacy, (T)oxicity,
(N)either and (B)oth. These letters are concatenated after numerical
dose-levels to convey the outcomes of cohorts of patients.
For instance, <code>2NET</code> represents a cohort of three patients that were
treated at dose-level 2, one of whom experienced toxicity only, one that
experienced efficacy only, and one that had neither.
The results of cohorts are separated by spaces and it is assumed that a
dose-finding decision takes place at the end of a cohort. Thus,
<code>2NET 1NN</code> builds on our previous example, where the next cohort of two
were treated at dose-level 1 and neither of these patients experienced
either event. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_eff_tox_dose_finding_outcomes(outcome_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_eff_tox_dose_finding_outcomes_+3A_outcome_string">outcome_string</code></td>
<td>
<p>character representing doses given, outcomes
observed, and timing of analyses. See Description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a slot for each cohort. Each cohort slot is itself a
list, containing elements:
* <code>dose</code>, the integer dose delivered to the cohort;
* <code>outcomes</code>, a character string representing the <code>E</code>, <code>T</code>
<code>N</code> or <code>B</code> outcomes for the patients in this cohort.
</p>


<h3>References</h3>

<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp; Yap, C.
(2017). Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = parse_eff_tox_dose_finding_outcomes('1NEN 2ENT 3TB')
length(x)
x[[1]]$dose
x[[1]]$outcomes
x[[2]]$dose
x[[2]]$outcomes
x[[3]]$dose
x[[3]]$outcomes

</code></pre>

<hr>
<h2 id='peps2_get_data'>Get data to run the PePS2 trial example</h2><span id='topic+peps2_get_data'></span>

<h3>Description</h3>

<p>Get data to run the BEBOP model in the PePS2 trial. The trial
investigates pembrolizumab in non-small-cell lung cancer. Patients may be
previously treated (PT) or treatment naive (TN). Pembro response rates in
lung cancer have been shown to increase with PD-L1 tumour proportion score.
PD-L1 score is measured at baseline. Each patient belongs to one of the Low,
Medium or High categories. These two baseline variables stratify the patient
population and are used as predictive variables to stratify the analysis.
The BEBOP model studies co-primary efficacy and toxicity outcomes in the
presence of predictive data. Thus, PePS2 studies efficacy and toxicity in
6 distinct cohorts:
TN Low, TN Medium, TN High, PT Low, PT Medium, PT High.
The design admits all-comers and does not target specific sample sizes in the
individual cohorts.
Hyperprior parameters have defaults to match those used in PePS2, but all may
be overridden.
The returned object includes randomly-sampled outcomes, as well as parameters
to run the model. These are all combined in the same list object for passing
to RStan, as is the convention.
See the accompanying vignette for a full description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peps2_get_data(
  num_patients,
  cohort_probs = NULL,
  prob_eff,
  prob_tox,
  eff_tox_or,
  cohort_rho = c(15.7, 21.8, 12.4, 20.7, 18, 11.4),
  alpha_mean = -2.2,
  alpha_sd = 2,
  beta_mean = -0.5,
  beta_sd = 2,
  gamma_mean = -0.5,
  gamma_sd = 2,
  zeta_mean = -0.5,
  zeta_sd = 2,
  lambda_mean = -2.2,
  lambda_sd = 2,
  psi_mean = 0,
  psi_sd = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peps2_get_data_+3A_num_patients">num_patients</code></td>
<td>
<p>Total number of patients to use, positive integer.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_cohort_probs">cohort_probs</code></td>
<td>
<p>Probabilities that a patient belongs to each of the 6
cohorts, in the order given above; a vector of numbers between 0 and 1 that
add up to 1. <code>cohort_probs</code> or <code>cohort_rho</code> must be specified.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_prob_eff">prob_eff</code></td>
<td>
<p>Probabilities of efficacy in each of the 6 cohorts, in the
order given above; a vector of numbers between 0 and 1</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_prob_tox">prob_tox</code></td>
<td>
<p>Probabilities of toxicity in each of the 6 cohorts, in the
order given above; a vector of numbers between 0 and 1</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_eff_tox_or">eff_tox_or</code></td>
<td>
<p>Measure of strength of association between efficacy and
toxicity, in each of the 6 cohorts, in the order given above; a vector of
numbers. Use 1 for no association; numbers increasingly greater than 1 for
stronger positive associations, and numbers less than 1 for stronger negative
associations</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_cohort_rho">cohort_rho</code></td>
<td>
<p>Concentration parameters for cohort membership, in the
order given above, using a Dirichlet distribution. This leads to randomly-
sampled cohort sizes distributed Dir(cohort_rho). <code>cohort_probs</code> or
<code>cohort_rho</code> must be specified.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>The prior mean of alpha. Alpha is the efficacy model
intercept.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>The prior standard deviation of alpha. Alpha is the efficacy
model  intercept.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_beta_mean">beta_mean</code></td>
<td>
<p>The prior mean of beta. Beta is the efficacy model term
for being previously treated.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_beta_sd">beta_sd</code></td>
<td>
<p>The prior standard deviation of beta. Beta is the efficacy
model term for being previously treated.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_gamma_mean">gamma_mean</code></td>
<td>
<p>The prior mean of gamma. Gamma is the efficacy model term
for being PD-L1 score = Low.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_gamma_sd">gamma_sd</code></td>
<td>
<p>The prior standard deviation of gamma. Gamma is the efficacy
model term for being PD-L1 score = Low.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_zeta_mean">zeta_mean</code></td>
<td>
<p>The prior mean of zeta. Zeta is the efficacy model term
for being PD-L1 score = Medium.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_zeta_sd">zeta_sd</code></td>
<td>
<p>The prior standard deviation of zeta. Zeta is the efficacy
model term for being PD-L1 score = Medium.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_lambda_mean">lambda_mean</code></td>
<td>
<p>The prior mean of lambda. Lambda is the toxicity model
intercept.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_lambda_sd">lambda_sd</code></td>
<td>
<p>The prior standard deviation of lambda. Lambda is the
toxicity model intercept.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_psi_mean">psi_mean</code></td>
<td>
<p>The prior mean of psi. Psi is the joint model association
parameter.</p>
</td></tr>
<tr><td><code id="peps2_get_data_+3A_psi_sd">psi_sd</code></td>
<td>
<p>The prior standard deviation of psi. Psi is the joint model
association parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
dat &lt;- peps2_get_data(num_patients = 60,
                      prob_eff = c(0.167, 0.192, 0.5, 0.091, 0.156, 0.439),
                      prob_tox = rep(0.1, 6),
                      eff_tox_or = rep(1, 6))
fit &lt;- stan_peps2(
  eff = dat$eff,
  tox = dat$tox,
  cohorts = dat$cohorts
)

## End(Not run)
</code></pre>

<hr>
<h2 id='peps2_process'>Process RStan samples from a BEBOP model fit to PePS2 data</h2><span id='topic+peps2_process'></span>

<h3>Description</h3>

<p>Process RStan samples from a BEBOP model fit to PePS2 data. This
step lets us make inferences about whether the modelled efficacy and toxicity
probabilities suggest the treatment is acceptable in each of the cohorts
under study.
The parameters have default values to match those used in the PePS2 trial.
See the accompanying vignette for a full description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peps2_process(
  fit,
  min_eff = 0.1,
  max_tox = 0.3,
  eff_cert = 0.7,
  tox_cert = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peps2_process_+3A_fit">fit</code></td>
<td>
<p>An instance of <code>rstan::stanmodel</code>, derived by fitting data to
the BEBOP in PePS2 model.
Use <code>stan_peps2</code>.</p>
</td></tr>
<tr><td><code id="peps2_process_+3A_min_eff">min_eff</code></td>
<td>
<p>The lower efficacy probability threshold; a number between 0
and 1.</p>
</td></tr>
<tr><td><code id="peps2_process_+3A_max_tox">max_tox</code></td>
<td>
<p>The upper toxicity probability threshold; a number between 0
and 1.</p>
</td></tr>
<tr><td><code id="peps2_process_+3A_eff_cert">eff_cert</code></td>
<td>
<p>Certainty required to infer the treatment is acceptable with
regards to being probably efficacious; a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="peps2_process_+3A_tox_cert">tox_cert</code></td>
<td>
<p>Certainty required to infer the treatment is acceptable with
regards to being probably tolerable; a number between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following items:
</p>

<ul>
<li> <p><code>ProbEff</code>, the posterior mean probability of efficacy in the 6
cohorts.
</p>
</li>
<li> <p><code>ProbAccEff</code>, the posterior mean probability that the probability
of efficacy exceeds <code>min_eff</code>, in the 6 cohorts.
</p>
</li>
<li> <p><code>ProbTox</code>, the posterior mean probability of toxicity in the 6
cohorts.
</p>
</li>
<li> <p><code>ProbAccTox</code>, the posterior mean probability that the probability
of toxicity is less than <code>max_tox</code>, in the 6 cohorts.
</p>
</li>
<li> <p><code>Accept</code>, a vector of logical values to show whether treatment
should be accepted in the 6 cohorts. Treatment is acceptable when it is
probably efficacious and probably not toxic, with respect to the described
rules.
</p>
</li>
<li> <p><code>alpha</code>, the posterior mean estimate of alpha.
</p>
</li>
<li> <p><code>beta</code>, the posterior mean estimate of beta.
</p>
</li>
<li> <p><code>gamma</code>, the posterior mean estimate of gamma.
</p>
</li>
<li> <p><code>zeta</code>, the posterior mean estimate of zeta.
</p>
</li>
<li> <p><code>lambda</code>, the posterior mean estimate of lambda.
</p>
</li>
<li> <p><code>psi</code>, the posterior mean estimate of psi.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+peps2_get_data">peps2_get_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
fit &lt;- stan_peps2(
  eff = c(0, 1, 0, 1, 0, 0),
  tox = c(0, 0, 1, 1, 0, 0),
  cohorts = c(3, 1, 1, 4, 5, 6)
)
decision &lt;- peps2_process(fit)
decision$Accept
decision$ProbEff
decision$ProbAccEff

</code></pre>

<hr>
<h2 id='plot.crm_fit'>Plot an crm_fit</h2><span id='topic+plot.crm_fit'></span>

<h3>Description</h3>

<p>Plot an crm_fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crm_fit'
plot(x, pars = "prob_tox", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.crm_fit_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+crm_fit">crm_fit</a></code> object to plot.</p>
</td></tr>
<tr><td><code id="plot.crm_fit_+3A_pars">pars</code></td>
<td>
<p>Parameters to plot. Plots utility scores by default.</p>
</td></tr>
<tr><td><code id="plot.crm_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>

<hr>
<h2 id='plot.efftox_fit'>Plot an efftox_fit</h2><span id='topic+plot.efftox_fit'></span>

<h3>Description</h3>

<p>Plot an efftox_fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'efftox_fit'
plot(x, pars = "utility", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.efftox_fit_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+efftox_fit">efftox_fit</a></code> object to plot.</p>
</td></tr>
<tr><td><code id="plot.efftox_fit_+3A_pars">pars</code></td>
<td>
<p>Parameters to plot. Plots utility scores by default.</p>
</td></tr>
<tr><td><code id="plot.efftox_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>

<hr>
<h2 id='predict.augbin_2t_1a_fit'>Predict probability of success for given tumour size measurements.</h2><span id='topic+predict.augbin_2t_1a_fit'></span>

<h3>Description</h3>

<p>This method simply forwards to <code><a href="#topic+prob_success">prob_success</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'augbin_2t_1a_fit'
predict(
  object,
  y1_lower = -Inf,
  y1_upper = Inf,
  y2_lower = -Inf,
  y2_upper = log(0.7),
  probs = c(0.025, 0.975),
  newdata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.augbin_2t_1a_fit_+3A_object">object</code></td>
<td>
<p>Object of class <code>augbin_2t_1a_fit</code>.</p>
</td></tr>
<tr><td><code id="predict.augbin_2t_1a_fit_+3A_y1_lower">y1_lower</code></td>
<td>
<p>numeric, minimum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 1 to baseline.
Defaults to negative infinity.</p>
</td></tr>
<tr><td><code id="predict.augbin_2t_1a_fit_+3A_y1_upper">y1_upper</code></td>
<td>
<p>numeric, maximum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 1 to baseline.
Defaults to positive infinity.</p>
</td></tr>
<tr><td><code id="predict.augbin_2t_1a_fit_+3A_y2_lower">y2_lower</code></td>
<td>
<p>numeric, minimum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 2 to baseline.</p>
</td></tr>
<tr><td><code id="predict.augbin_2t_1a_fit_+3A_y2_upper">y2_upper</code></td>
<td>
<p>numeric, maximum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 2 to baseline.
Defaults to log(0.7).</p>
</td></tr>
<tr><td><code id="predict.augbin_2t_1a_fit_+3A_probs">probs</code></td>
<td>
<p>pair of probabilities to use to calculate the credible interval
for the probability of success.</p>
</td></tr>
<tr><td><code id="predict.augbin_2t_1a_fit_+3A_newdata">newdata</code></td>
<td>
<p>data for which to infer the probability of success.
A dataframe-like object with baseline tumour sizes in first column, and first
and second post-baseline tumour sizes in columns 2 and 3. Omitted by default.
When omitted, newdata is set to be the <code>object$tumour_size</code>.</p>
</td></tr>
<tr><td><code id="predict.augbin_2t_1a_fit_+3A_...">...</code></td>
<td>
<p>Extra args passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="tibble.html#topic+tibble">tibble</a></code>
</p>

<hr>
<h2 id='print.augbin_fit'>Print augbin_fit object.</h2><span id='topic+print.augbin_fit'></span>

<h3>Description</h3>

<p>Print augbin_fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'augbin_fit'
print(
  x,
  pars = c("alpha", "beta", "gamma", "Omega", "sigma", "alphaD1", "gammaD1", "alphaD2",
    "gammaD2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.augbin_fit_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+augbin_fit">augbin_fit</a></code> object to print.</p>
</td></tr>
<tr><td><code id="print.augbin_fit_+3A_pars">pars</code></td>
<td>
<p>parameters in model to summarise.</p>
</td></tr>
<tr><td><code id="print.augbin_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>

<hr>
<h2 id='print.crm_fit'>Print crm_fit object.</h2><span id='topic+print.crm_fit'></span>

<h3>Description</h3>

<p>Print crm_fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crm_fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.crm_fit_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+crm_fit">crm_fit</a></code> object to print.</p>
</td></tr>
<tr><td><code id="print.crm_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>

<hr>
<h2 id='print.efftox_fit'>Print efftox_fit object.</h2><span id='topic+print.efftox_fit'></span>

<h3>Description</h3>

<p>Print efftox_fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'efftox_fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.efftox_fit_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+efftox_fit">efftox_fit</a></code> object to convert.</p>
</td></tr>
<tr><td><code id="print.efftox_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>

<hr>
<h2 id='print.nbg_fit'>Print nbg_fit object.</h2><span id='topic+print.nbg_fit'></span>

<h3>Description</h3>

<p>Print nbg_fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nbg_fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nbg_fit_+3A_x">x</code></td>
<td>
<p><code>nbg_fit</code> object to print.</p>
</td></tr>
<tr><td><code id="print.nbg_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>

<hr>
<h2 id='prior_predictive_augbin_2t_1a'>Sample data from the Augmented Binary model prior predictive distribution.</h2><span id='topic+prior_predictive_augbin_2t_1a'></span>

<h3>Description</h3>

<p>Sample data from the prior predictive distributions of the two-period, single
arm Augmented Binary model, subject to chosen prior parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_predictive_augbin_2t_1a(
  num_samps,
  alpha_mean,
  alpha_sd,
  beta_mean,
  beta_sd,
  gamma_mean,
  gamma_sd,
  sigma_mean,
  sigma_sd,
  omega_lkj_eta,
  alpha_d1_mean,
  alpha_d1_sd,
  gamma_d1_mean,
  gamma_d1_sd,
  alpha_d2_mean,
  alpha_d2_sd,
  gamma_d2_mean,
  gamma_d2_sd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_num_samps">num_samps</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>Prior mean of alpha parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>Prior sd of alpha parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_beta_mean">beta_mean</code></td>
<td>
<p>Prior mean of beta parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_beta_sd">beta_sd</code></td>
<td>
<p>Prior sd of beta parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_gamma_mean">gamma_mean</code></td>
<td>
<p>Prior mean of gamma parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_gamma_sd">gamma_sd</code></td>
<td>
<p>Prior sd of gamma parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_sigma_mean">sigma_mean</code></td>
<td>
<p>Prior mean of sigma parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_sigma_sd">sigma_sd</code></td>
<td>
<p>Prior sd of sigma parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_omega_lkj_eta">omega_lkj_eta</code></td>
<td>
<p>Prior eta parameter for LKJ prior on covariance matrix
of log tumour sizes.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_alpha_d1_mean">alpha_d1_mean</code></td>
<td>
<p>Prior mean of alpha_D1 parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_alpha_d1_sd">alpha_d1_sd</code></td>
<td>
<p>Prior sd of alpha_D1 parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_gamma_d1_mean">gamma_d1_mean</code></td>
<td>
<p>Prior mean of gamma_D1 parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_gamma_d1_sd">gamma_d1_sd</code></td>
<td>
<p>Prior sd of gamma_D1 parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_alpha_d2_mean">alpha_d2_mean</code></td>
<td>
<p>Prior mean of alpha_D2 parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_alpha_d2_sd">alpha_d2_sd</code></td>
<td>
<p>Prior sd of alpha_D2 parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_gamma_d2_mean">gamma_d2_mean</code></td>
<td>
<p>Prior mean of gamma_D2 parameter.</p>
</td></tr>
<tr><td><code id="prior_predictive_augbin_2t_1a_+3A_gamma_d2_sd">gamma_d2_sd</code></td>
<td>
<p>Prior sd of gamma_D2 parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="tibble.html#topic+tibble">tibble</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_augbin">stan_augbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prior_predictive_augbin_2t_1a(num_samps = 1000,
                              alpha_mean = 0, alpha_sd = 1,
                              beta_mean = 0, beta_sd = 1,
                              gamma_mean = 0, gamma_sd = 1,
                              sigma_mean = 0, sigma_sd = 1,
                              omega_lkj_eta = 1,
                              alpha_d1_mean = 0, alpha_d1_sd = 1,
                              gamma_d1_mean = 0, gamma_d1_sd = 1,
                              alpha_d2_mean = 0, alpha_d2_sd = 1,
                              gamma_d2_mean = 0, gamma_d2_sd = 1)
</code></pre>

<hr>
<h2 id='prob_success'>Calculate the probability of success.</h2><span id='topic+prob_success'></span><span id='topic+prob_success.augbin_2t_1a_fit'></span>

<h3>Description</h3>

<p>Calculate the probability of success.
</p>
<p>Calculate the probability of success for an augbin_2t_1a_fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_success(x, ...)

## S3 method for class 'augbin_2t_1a_fit'
prob_success(
  x,
  y1_lower = -Inf,
  y1_upper = Inf,
  y2_lower = -Inf,
  y2_upper = log(0.7),
  probs = c(0.025, 0.975),
  newdata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_success_+3A_x">x</code></td>
<td>
<p>an R object of class <code>"augbin_fit"</code></p>
</td></tr>
<tr><td><code id="prob_success_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="prob_success_+3A_y1_lower">y1_lower</code></td>
<td>
<p>numeric, minimum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 1 to baseline.
Defaults to negative infinity.</p>
</td></tr>
<tr><td><code id="prob_success_+3A_y1_upper">y1_upper</code></td>
<td>
<p>numeric, maximum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 1 to baseline.
Defaults to positive infinity.</p>
</td></tr>
<tr><td><code id="prob_success_+3A_y2_lower">y2_lower</code></td>
<td>
<p>numeric, minimum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 2 to baseline.</p>
</td></tr>
<tr><td><code id="prob_success_+3A_y2_upper">y2_upper</code></td>
<td>
<p>numeric, maximum threshold to constitute success,
scrutinising the log of the tumour size ratio comparing time 2 to baseline.
Defaults to log(0.7).</p>
</td></tr>
<tr><td><code id="prob_success_+3A_probs">probs</code></td>
<td>
<p>pair of probabilities to use to calculate the credible interval
for the probability of success.</p>
</td></tr>
<tr><td><code id="prob_success_+3A_newdata">newdata</code></td>
<td>
<p>data for which to infer the probability of success.
A dataframe-like object with baseline tumour sizes in first column, and first
and second post-baseline tumour sizes in columns 2 and 3. Omitted by default.
When omitted, newdata is set to be the <code>fit$tumour_size</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="tibble.html#topic+tibble">tibble</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- stan_augbin_demo()
prob_success(fit, y2_upper = log(0.7))

## End(Not run)
</code></pre>

<hr>
<h2 id='prob_tox_exceeds'>Calculate the probability that the rate of toxicity exceeds some threshold</h2><span id='topic+prob_tox_exceeds'></span><span id='topic+prob_tox_exceeds.dose_finding_fit'></span>

<h3>Description</h3>

<p>Calculate the probability that the rate of toxicity exceeds some threshold
</p>
<p>Calculate the probability that the rate of toxicity exceeds some threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_tox_exceeds(x, ...)

## S3 method for class 'dose_finding_fit'
prob_tox_exceeds(x, threshold, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_tox_exceeds_+3A_x">x</code></td>
<td>
<p>an R object of class <code>"dose_finding_fit"</code></p>
</td></tr>
<tr><td><code id="prob_tox_exceeds_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="prob_tox_exceeds_+3A_threshold">threshold</code></td>
<td>
<p>numeric, threshold value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector of probabilities
</p>
<p>numerical vector of probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CRM example
target &lt;- 0.2
fit &lt;- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
                 target = target, model = 'empiric', beta_sd = sqrt(1.34),
                 seed = 123)
prob_tox_exceeds(fit, target)

## End(Not run)
</code></pre>

<hr>
<h2 id='ranBin2'>Sample pairs of correlated binary events</h2><span id='topic+ranBin2'></span>

<h3>Description</h3>

<p>This function is reproduced from the <code>binarySimCLF</code> package
on CRAN. The original package appears no longer to be maintained.
View the original source at:
https://github.com/cran/binarySimCLF/blob/master/R/ranBin2.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranBin2(nRep, u, psi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranBin2_+3A_nrep">nRep</code></td>
<td>
<p>Number of simulated event pairs, positive integer.</p>
</td></tr>
<tr><td><code id="ranBin2_+3A_u">u</code></td>
<td>
<p>Mean event probabilities, expressed as a vector of length 2. E.g.
to simulate associated bivariate events with probabilities 80
<code>u = c(0.8, 0.3)</code>.</p>
</td></tr>
<tr><td><code id="ranBin2_+3A_psi">psi</code></td>
<td>
<p>Odds ratio, number. This parameter controls the strength of
association. Use <code>psi = 1</code> for no association. Values greater than 1
correspond to increasingly positive association between the two events,
and vice-versa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of events represented as 0s and 1s, with <code>nRep</code> rows
and 2 columns. The first column is the incidence of event 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probs &lt;- c(0.8, 0.3)
s &lt;- ranBin2(1000, probs, psi=0.2)  # 1000 pairs of outcomes
cor(s)  # Negatively correlated because psi &lt; 1
colMeans(s)  # Event rates as expected
</code></pre>

<hr>
<h2 id='rlkjcorr'>Sample LKJ correlation matrices.</h2><span id='topic+rlkjcorr'></span>

<h3>Description</h3>

<p>This function was copied from Richard McElreath's rethinking package hosted
at https://github.com/rmcelreath/rethinking. In turn, he appears to have
copied it from Ben Bolker's rLKJ function from the emdbook package, although
I cannot find it there (else I would have imported it).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlkjcorr(n, K, eta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlkjcorr_+3A_n">n</code></td>
<td>
<p>Number of matrices to sample.</p>
</td></tr>
<tr><td><code id="rlkjcorr_+3A_k">K</code></td>
<td>
<p>dimenstion of matrix to sample.</p>
</td></tr>
<tr><td><code id="rlkjcorr_+3A_eta">eta</code></td>
<td>
<p>Distribution parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='spread_paths'>Spread the information in dose_finding_paths object to a wide data.frame format.</h2><span id='topic+spread_paths'></span>

<h3>Description</h3>

<p>Spread the information in dose_finding_paths object to a wide data.frame format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread_paths(df = NULL, dose_finding_paths = NULL, max_depth = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_paths_+3A_df">df</code></td>
<td>
<p>Optional <code>data.frame</code> like that returned by
as_tibble(dose_finding_paths). Columns .depth, .node, .parent are required.
All other columns are spread with a suffix reflecting depth.</p>
</td></tr>
<tr><td><code id="spread_paths_+3A_dose_finding_paths">dose_finding_paths</code></td>
<td>
<p>Optional instance of dose_finding_paths. Required
if 'df' is null.</p>
</td></tr>
<tr><td><code id="spread_paths_+3A_max_depth">max_depth</code></td>
<td>
<p>integer, maximum depth of paths to traverse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
target &lt;- 0.25
skeleton &lt;- c(0.05, 0.15, 0.25, 0.4, 0.6)
paths &lt;- crm_dtps(skeleton = skeleton, target = target, model = 'empiric',
                  cohort_sizes = c(1, 1), next_dose = 3, beta_sd = 1)
spread_paths(dose_finding_paths = paths)

df &lt;- as_tibble(paths)
spread_paths(df)
spread_paths(df %&gt;% select(-fit, -parent_fit, -dose_index))

## End(Not run)
</code></pre>

<hr>
<h2 id='stan_augbin'>Fit Wason &amp; Seaman's Augmented Binary model for tumour response.</h2><span id='topic+stan_augbin'></span>

<h3>Description</h3>

<p>Phase II clinical trials in oncology commonly assess response as a key outcome
measure. Patients achieve a RECIST response if their tumour size post-baseline
has changed in size by some threshold amount and they do not experience
non-shrinkage failure. An example of non-shrinkage failure is the appearance
of new lesions. As a dichtotomisation of the underlying continuous tumour size
measurement, RECIST response is inefficient. Wason &amp; Seaman introduced the
Augmented Binary method to incorporate mechanisms for non-shrinkage failure
whilst modelling the probability of response based on the continuous tumour
size measurements. See model-specific sections below, and the references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_augbin(
  tumour_size,
  non_shrinkage_failure,
  arm = NULL,
  model = c("2t-1a"),
  prior_params = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_augbin_+3A_tumour_size">tumour_size</code></td>
<td>
<p>matrix-like object containing tumour size measures, with
rows representing patients and columns representing chronological
standardised assessment points. Column one is baseline.</p>
</td></tr>
<tr><td><code id="stan_augbin_+3A_non_shrinkage_failure">non_shrinkage_failure</code></td>
<td>
<p>matrix-like object containing logical indicators
of non-shrinkage failure, with rows representing patients and columns
representing chronological standardised assessment points.</p>
</td></tr>
<tr><td><code id="stan_augbin_+3A_arm">arm</code></td>
<td>
<p>optional vector of integers representing the allocated treatment
arms for patients, assumed in the same order as <code>tumour_size</code> and
<code>non_shrinkage_failure</code>. NULL to fit the augbin variant for single-arm
trials. NULL is the default.</p>
</td></tr>
<tr><td><code id="stan_augbin_+3A_model">model</code></td>
<td>
<p>Character string to denote the desired model. Currently, only
<code>2t-1a</code> is supported, representing the model variant with two
post-baseline assessments in a single arm trial. Multi-period and multi-arm
versions will be added in future releases. The model choice determines the
prior parameters that must be provided. See sections below.</p>
</td></tr>
<tr><td><code id="stan_augbin_+3A_prior_params">prior_params</code></td>
<td>
<p>list of prior parameters. These are combined with the
data and passed to <code>rstan::sampling</code>. The parameters required depend on
the model form being fit. See sections below.</p>
</td></tr>
<tr><td><code id="stan_augbin_+3A_...">...</code></td>
<td>
<p>Extra parameters are passed to <code>rstan::sampling</code>. Commonly
used options are <code>iter</code>, <code>chains</code>, <code>warmup</code>, <code>cores</code>,
<code>control</code>. See <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance or subclass of type <code><a href="#topic+augbin_fit">augbin_fit</a></code>.
</p>


<h3>Single-arm model with two post-baseline assessments</h3>

<p>The complete model form is:
</p>
<p style="text-align: center;"><code class="reqn">(y_{1i}, y_{2i})^T \sim N( (\mu_{1i}, \mu_{2i})^T, \Sigma) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \mu_{1i} = \alpha + \gamma z_{0i} </code>
</p>

<p style="text-align: center;"><code class="reqn"> \mu_{2i} = \beta + \gamma z_{0i} </code>
</p>

<p style="text-align: center;"><code class="reqn"> logit(Pr(D_{1i} = 1 | Z_{0i})) = \alpha_{D1} + \gamma_{D1} z_{0i} </code>
</p>

<p style="text-align: center;"><code class="reqn"> logit(Pr(D_{2i} = 1 | D_{1i} = 0, Z_{0i}, Z_{1i})) = \alpha_{D2} + \gamma_{D2} z_{1i} </code>
</p>

<p>where <code class="reqn">z_{0i}, z_{1i}, z_{2i}</code> are tumour sizes at baseline, period 1,
and period 2, for patient i; <code class="reqn">y_{1i}, y_{2i}</code> are the log-tumour-size
ratios with respect to baseline; <code class="reqn">D_{1i}, D_{2i}</code> are indicators of
non-shrinkage failure; and <code class="reqn">\Sigma</code> is assumed to be unstructured
covariance matrix, with associated correlation matrix having an LKJ prior.
</p>
<p>The following prior parameters are required:
</p>

<ul>
<li> <p><code>alpha_mean</code> &amp; <code>alpha_sd</code> for normal prior on <code class="reqn">\alpha</code>.
</p>
</li>
<li> <p><code>beta_mean</code> &amp; <code>beta_sd</code> for normal prior on <code class="reqn">\beta</code>.
</p>
</li>
<li> <p><code>gamma_mean</code> &amp; <code>gamma_sd</code> for normal prior on <code class="reqn">\gamma</code>.
</p>
</li>
<li> <p><code>sigma_mean</code> &amp; <code>sigma_sd</code> for normal priors on diagonal elements of <code class="reqn">\Sigma</code>;
</p>
</li>
<li> <p><code>omega_lkj_eta</code> for a LKJ prior on the two-period correlation matrix associated with Sigma. omega_lkj_eta = 1 is uniform, analogous to a Beta(1,1) prior on a binary probability.
</p>
</li>
<li> <p><code>alpha_d1_mean</code> &amp; <code>alpha_d1_sd</code> for normal prior on <code class="reqn">\alpha_{D1}</code>.
</p>
</li>
<li> <p><code>gamma_d1_mean</code> &amp; <code>gamma_d1_sd</code> for normal prior on <code class="reqn">\gamma_{D1}</code>.
</p>
</li>
<li> <p><code>alpha_d2_mean</code> &amp; <code>alpha_d2_sd</code> for normal prior on <code class="reqn">\alpha_{D2}</code>.
</p>
</li>
<li> <p><code>gamma_d2_mean</code> &amp; <code>gamma_d2_sd</code> for normal prior on <code class="reqn">\gamma_{D2}</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kristian Brock
</p>


<h3>References</h3>

<p>Wason JMS, Seaman SR. Using continuous data on tumour measurements to improve
inference in phase II cancer studies.
Statistics in Medicine. 2013;32(26):4639-4650. doi:10.1002/sim.5867
</p>
<p>Eisenhauer EA, Therasse P, Bogaerts J, et al. New response evaluation
criteria in solid tumours: Revised RECIST guideline (version 1.1).
European Journal of Cancer. 2009;45(2):228-247. doi:10.1016/j.ejca.2008.10.026
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augbin_fit">augbin_fit</a></code>
<code><a href="#topic+prior_predictive_augbin_2t_1a">prior_predictive_augbin_2t_1a</a></code>
<code><a href="rstan.html#topic+sampling">sampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>priors &lt;- list(alpha_mean = 0, alpha_sd = 1,
               beta_mean = 0, beta_sd = 1,
               gamma_mean = 0, gamma_sd = 1,
               sigma_mean = 0, sigma_sd = 1,
               omega_lkj_eta = 1,
               alpha_d1_mean = 0, alpha_d1_sd = 1,
               gamma_d1_mean = 0, gamma_d1_sd = 1,
               alpha_d2_mean = 0, alpha_d2_sd = 1,
               gamma_d2_mean = 0, gamma_d2_sd = 1)
# Scenario 1 of Table 1 in Wason &amp; Seaman (2013)
N &lt;- 50
sigma &lt;- 1
delta1 &lt;- -0.356
mu &lt;- c(0.5 * delta1, delta1)
Sigma = matrix(c(0.5 * sigma^2, 0.5 * sigma^2, 0.5 * sigma^2, sigma^2),
               ncol = 2)
alphaD &lt;- -1.5
gammaD &lt;- 0
set.seed(123456)
y &lt;- MASS::mvrnorm(n = N, mu, Sigma)
z0 &lt;- runif(N, min = 5, max = 10)
z1 &lt;- exp(y[, 1]) * z0
z2 &lt;- exp(y[, 2]) * z0
d1 &lt;- rbinom(N, size = 1, prob = gtools::inv.logit(alphaD + gammaD * z0))
d2 &lt;- rbinom(N, size = 1, prob = gtools::inv.logit(alphaD + gammaD * z1))
tumour_size &lt;- data.frame(z0, z1, z2) # Sizes in cm
non_shrinkage_failure &lt;- data.frame(d1, d2)
# Fit
## Not run: 
fit &lt;- stan_augbin(tumour_size, non_shrinkage_failure,
                   prior_params = priors, model = '2t-1a', seed = 123)

## End(Not run)
</code></pre>

<hr>
<h2 id='stan_augbin_demo'>Simple helper function to demonstrate fitting of an Augmented Binary model.</h2><span id='topic+stan_augbin_demo'></span>

<h3>Description</h3>

<p>This function exist mostly to demonstrate things you can do to instances of
<code><a href="#topic+augbin_fit">augbin_fit</a></code> without having to paste into each example the not
inconsiderable blob of code to sample outcomes and fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_augbin_demo()
</code></pre>


<h3>Value</h3>

<p>instance of <code><a href="#topic+augbin_fit">augbin_fit</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_augbin">stan_augbin</a></code>
<code><a href="#topic+augbin_fit">augbin_fit</a></code>
<code><a href="#topic+prior_predictive_augbin_2t_1a">prior_predictive_augbin_2t_1a</a></code>
<code><a href="rstan.html#topic+sampling">sampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- stan_augbin_demo()
# I told you it was simple.

## End(Not run)
</code></pre>

<hr>
<h2 id='stan_crm'>Fit a CRM model</h2><span id='topic+stan_crm'></span>

<h3>Description</h3>

<p>Fit a continual reassessment method (CRM) model for dose-finding using Stan
for full Bayesian inference. There are several likelihood and prior
combinations supported. See model-specific sections below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_crm(
  outcome_str = NULL,
  skeleton,
  target,
  model = c("empiric", "logistic", "logistic_gamma", "logistic2"),
  a0 = NULL,
  alpha_mean = NULL,
  alpha_sd = NULL,
  beta_mean = NULL,
  beta_sd = NULL,
  beta_shape = NULL,
  beta_inverse_scale = NULL,
  doses_given = NULL,
  tox = NULL,
  weights = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_crm_+3A_outcome_str">outcome_str</code></td>
<td>
<p>A string representing the outcomes observed hitherto.
See <code><a href="#topic+df_parse_outcomes">df_parse_outcomes</a></code> for a description of syntax and
examples. Alternatively, you may provide <code>doses_given</code> and <code>tox</code>
parameters. See Details.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_skeleton">skeleton</code></td>
<td>
<p>a vector of the prior guesses of toxicity at doses.
This should be a monotonically-increasing vector of numbers between 0 and 1.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_target">target</code></td>
<td>
<p>the target toxicity probability, a number between 0 and 1.
This value would normally be one of the values in <code>skeleton</code>, but that
is not a requirement.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_model">model</code></td>
<td>
<p>Character string to denote desired model. One of <code>empiric</code>,
<code>logistic</code>, <code>logistic_gamma</code>, or <code>logistic2</code>.
The choice of model determines which parameters are required. See Details.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_a0">a0</code></td>
<td>
<p>Value of fixed intercept parameter.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>Prior mean of intercept variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>Prior standard deviation of intercept variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_beta_mean">beta_mean</code></td>
<td>
<p>Prior mean of gradient variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_beta_sd">beta_sd</code></td>
<td>
<p>Prior standard deviation of slope variable for normal prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_beta_shape">beta_shape</code></td>
<td>
<p>Prior shape parameter of slope variable for gamma prior.
Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_beta_inverse_scale">beta_inverse_scale</code></td>
<td>
<p>Prior inverse scale parameter of slope variable for
gamma prior. Only required for certain models. See Details.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_doses_given">doses_given</code></td>
<td>
<p>A optional vector of dose-levels given to patients
1:num_patients, where 1=lowest dose, 2=second dose, etc. Only required when
<code>outcome_str</code> is not provided.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_tox">tox</code></td>
<td>
<p>An optional vector of toxicity outcomes for patients
1:num_patients, where 1=toxicity and 0=no toxicity. Only required when
<code>outcome_str</code> is not provided.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_weights">weights</code></td>
<td>
<p>An optional vector of numeric weights for the observations
for patients 1:num_patients, thus facilitating the TITE-CRM design.
Can be used with <code>outcome_str</code>, or with <code>doses_given</code> and
<code>tox</code>. It is generally tidier to specify <code>doses_given</code>,
<code>tox</code> and <code>weights</code> when a TITE-CRM analysis is desired.</p>
</td></tr>
<tr><td><code id="stan_crm_+3A_...">...</code></td>
<td>
<p>Extra parameters are passed to <code>rstan::sampling</code>. Commonly
used options are <code>iter</code>, <code>chains</code>, <code>warmup</code>, <code>cores</code>, and
<code>control</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quickest and easiest way to fit a CRM model to some observed outcomes
is to describe the outcomes using <span class="pkg">trialr</span>'s syntax for dose-finding
outcomes. See <code><a href="#topic+df_parse_outcomes">df_parse_outcomes</a></code> for full details and examples.
</p>
<p>Different model choices require that different parameters are
provided. See sections below.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+crm_fit">crm_fit</a></code>
</p>


<h3>The <code>empiric</code> model</h3>

<p>The model form is:
</p>
<p><code class="reqn">F(x_{i}, \beta) = x_{i}^{\exp{\beta}}</code>
</p>
<p>and the required parameters are:
</p>

<ul>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>The <code>logistic</code> model</h3>

<p>The model form is:
</p>
<p><code class="reqn">F(x_{i}, \beta) = 1 / (1 + \exp{(-a_{0} - \exp{(\beta)} x_{i}})) </code>
</p>
<p>and the required parameters are:
</p>

<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>The <code>logistic_gamma</code> model</h3>

<p>The model form is:
</p>
<p><code class="reqn">F(x_{i}, \beta) = 1 / (1 + \exp{(-a_{0} - \exp{(\beta)} x_{i}})) </code>
</p>
<p>and the required parameters are:
</p>

<ul>
<li> <p><code>a0</code>
</p>
</li>
<li> <p><code>beta_shape</code>
</p>
</li>
<li> <p><code>beta_inverse_scale</code>
</p>
</li></ul>



<h3>The <code>logistic2</code> model</h3>

<p>The model form is:
</p>
<p><code class="reqn">F(x_{i}, alpha, \beta) = 1 / (1 + \exp{(-\alpha - \exp{(\beta)} x_i)}) </code>
</p>
<p>and the required parameters are:
</p>

<ul>
<li> <p><code>alpha_mean</code>
</p>
</li>
<li> <p><code>alpha_sd</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kristian Brock
</p>


<h3>References</h3>

<p>O'Quigley, J., Pepe, M., &amp; Fisher, L. (1990).
Continual reassessment method: a practical design for phase 1 clinical
trials in cancer.
Biometrics, 46(1), 33-48. https://www.jstor.org/stable/2531628
</p>
<p>Cheung, Y.K. (2011).
Dose Finding by the Continual Reassessment Method.
CRC Press. ISBN 9781420091519
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm_fit">crm_fit</a></code>
<code><a href="rstan.html#topic+sampling">sampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CRM example
fit1 &lt;- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
                 target = 0.2, model = 'empiric', beta_sd = sqrt(1.34),
                 seed = 123)

fit2 &lt;- stan_crm('1NNN 2NNN 3TTT', skeleton = c(0.1, 0.2, 0.35, 0.6),
                 target = 0.2, model = 'logistic', a0 = 3, beta_mean = 0,
                 beta_sd = sqrt(1.34), seed = 123)

# The seed is passed to the Stan sampler. The usual Stan sampler params like
# cores, iter, chains etc are passed on too via the ellipsis operator.

# TITE-CRM example, p.124 of Dose Finding by the CRM, Cheung (2010)
fit3 &lt;-stan_crm(skeleton = c(0.05, 0.12, 0.25, 0.40, 0.55), target = 0.25,
                doses_given = c(3, 3, 3, 3),
                tox = c(0, 0, 0, 0),
                weights = c(73, 66, 35, 28) / 126,
                model = 'empiric', beta_sd = sqrt(1.34), seed = 123)
fit3$recommended_dose

## End(Not run)
</code></pre>

<hr>
<h2 id='stan_efftox'>Fit an EffTox model</h2><span id='topic+stan_efftox'></span>

<h3>Description</h3>

<p>Fit an EffTox model using Stan for full Bayesian inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_efftox(
  outcome_str = NULL,
  real_doses,
  efficacy_hurdle,
  toxicity_hurdle,
  p_e,
  p_t,
  eff0,
  tox1,
  eff_star,
  tox_star,
  priors = NULL,
  alpha_mean = NULL,
  alpha_sd = NULL,
  beta_mean = NULL,
  beta_sd = NULL,
  gamma_mean = NULL,
  gamma_sd = NULL,
  zeta_mean = NULL,
  zeta_sd = NULL,
  eta_mean = NULL,
  eta_sd = NULL,
  psi_mean = NULL,
  psi_sd = NULL,
  doses_given = NULL,
  eff = NULL,
  tox = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_efftox_+3A_outcome_str">outcome_str</code></td>
<td>
<p>A string representing the outcomes observed hitherto.
See <code><a href="#topic+efftox_parse_outcomes">efftox_parse_outcomes</a></code> for a description of syntax and
examples. Alternatively, you may provide <code>doses_given</code>, <code>eff</code> and
<code>tox</code> parameters. See Details.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_real_doses">real_doses</code></td>
<td>
<p>A vector of numbers, the doses under investigation. They
should be ordered from lowest to highest and be in consistent units.
E.g. to conduct a dose-finding trial of doses 10mg, 20mg and 50mg, use
c(10, 20, 50).</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_efficacy_hurdle">efficacy_hurdle</code></td>
<td>
<p>Minimum acceptable efficacy probability.
A number between 0 and 1.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_toxicity_hurdle">toxicity_hurdle</code></td>
<td>
<p>Maximum acceptable toxicity probability.
A number between 0 and 1.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_p_e">p_e</code></td>
<td>
<p>Certainty required to infer a dose is acceptable with regards to
being probably efficacious; a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_p_t">p_t</code></td>
<td>
<p>Certainty required to infer a dose is acceptable with regards to
being probably tolerable; a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_eff0">eff0</code></td>
<td>
<p>Efficacy probability required when toxicity is impossible;
a number between 0 and 1 (see Details).</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_tox1">tox1</code></td>
<td>
<p>Toxicity probability permitted when efficacy is guaranteed;
a number between 0 and 1 (see Details).</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_eff_star">eff_star</code></td>
<td>
<p>Efficacy probability of an equi-utility third point (see
Details).</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_tox_star">tox_star</code></td>
<td>
<p>Toxicity probability of an equi-utility third point (see
Details).</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_priors">priors</code></td>
<td>
<p>instance of class <code><a href="#topic+efftox_priors">efftox_priors</a></code>, the
hyperparameters for normal priors on the six model parameters.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>Optional, the prior normal mean of the intercept term in
the toxicity logit model. A number. You should prioritise specifying this
value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>Optional, the prior normal standard deviation of the
intercept term in the toxicity logit model. A number.You should prioritise
specifying this value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_beta_mean">beta_mean</code></td>
<td>
<p>Optional, the prior normal mean of the slope term in the
toxicity logit model. A number. You should prioritise specifying this
value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_beta_sd">beta_sd</code></td>
<td>
<p>Optional, the prior normal standard deviation of the slope
term in the toxicity logit model. A number. You should prioritise specifying
this value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_gamma_mean">gamma_mean</code></td>
<td>
<p>Optional, The prior normal mean of the intercept term in
the efficacy logit model. A number. You should prioritise specifying this
value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_gamma_sd">gamma_sd</code></td>
<td>
<p>Optional, the prior normal standard deviation of the
intercept term in the efficacy logit model. A number. You should prioritise
specifying this value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_zeta_mean">zeta_mean</code></td>
<td>
<p>Optional, the prior normal mean of the slope term in the
efficacy logit model. A number. You should prioritise specifying this value
via  <code>priors</code> but this option is provided for backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_zeta_sd">zeta_sd</code></td>
<td>
<p>Optional, the prior normal standard deviation of the slope
term in the efficacy logit model. A number. You should prioritise specifying
this value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_eta_mean">eta_mean</code></td>
<td>
<p>Optional, the prior normal mean of the squared term
coefficient in the efficacy logit model. A number. You should prioritise
specifying this value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_eta_sd">eta_sd</code></td>
<td>
<p>Optional, the prior normal standard deviation of the squared
term coefficient in the efficacy logit model. A number. You should prioritise
specifying this value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_psi_mean">psi_mean</code></td>
<td>
<p>Optional, the prior normal mean of the association term in
the combined efficacy-toxicity model. A number. You should prioritise
specifying this value via <code>priors</code> but this option is provided for
backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_psi_sd">psi_sd</code></td>
<td>
<p>Optional, the prior normal standard deviation of the
association term in the combined efficacy-toxicity model. A number. You
should prioritise specifying this value via <code>priors</code> but this option is
provided for backwards-compatibility.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_doses_given">doses_given</code></td>
<td>
<p>A optional vector of dose-levels given to patients
1:num_patients, where 1=lowest dose, 2=second dose, etc. Only required when
<code>outcome_str</code> is not provided.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_eff">eff</code></td>
<td>
<p>An optional vector of efficacy outcomes for patients
1:num_patients, where 1=efficacy and 0=no efficacy. Only required when
<code>outcome_str</code> is not provided.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_tox">tox</code></td>
<td>
<p>An optional vector of toxicity outcomes for patients
1:num_patients, where 1=toxicity and 0=no toxicity. Only required when
<code>outcome_str</code> is not provided.</p>
</td></tr>
<tr><td><code id="stan_efftox_+3A_...">...</code></td>
<td>
<p>Extra parameters are passed to <code>rstan::sampling</code>. Commonly
used options are <code>iter</code>, <code>chains</code>, <code>warmup</code>, <code>cores</code>,
<code>control</code>. <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quickest and easiest way to fit an EffTox model to some observed outcomes
is to describe the outcomes using <span class="pkg">trialr</span>'s syntax for efficacy-toxicity
dose-finding outcomes. See <code><a href="#topic+efftox_parse_outcomes">efftox_parse_outcomes</a></code> for full
details and examples.
</p>
<p>Utility or attractivess scores are calculated in EffTox using L^p norms.
Imagine the first quadrant of a scatter plot with prob_eff along the x-axis
and prob_tox along the y-axis.
The point (1, 0) (i.e. guaranteed efficacy &amp; no toxicity) is the holy grail.
The neutral contour intersects the points (eff0, 0), (1, tox1) and
(eff_star, tox_star). A unique curve intersects these three points and
identifies a value for p, the exponent in the L^p norm. On this neutral-
utility contour, scores are equal to zero. A family of curves with different
utility scores is defined that are &quot;parallel&quot; to this neutral curve.
Points with probabilities of efficacy and toxicity that are nearer to (1, 0)
will yield greater scores, and vice-versa.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+efftox_fit">efftox_fit</a></code>
</p>


<h3>Author(s)</h3>

<p>Kristian Brock <a href="mailto:kristian.brock@gmail.com">kristian.brock@gmail.com</a>
</p>


<h3>References</h3>

<p>Thall, P., &amp; Cook, J. (2004). Dose-Finding Based on Efficacy-Toxicity
Trade-Offs. Biometrics, 60(3), 684-693.
</p>
<p>Thall, P., Herrick, R., Nguyen, H., Venier, J., &amp; Norris, J. (2014).
Effective sample size for computing prior hyperparameters in Bayesian
phase I-II dose-finding. Clinical Trials, 11(6), 657-666.
https://doi.org/10.1177/1740774514547397
</p>
<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp;
Yap, C. (2017). Implementing the EffTox dose-finding design in the
Matchpoint trial. BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efftox_priors">efftox_priors</a></code>
<code><a href="#topic+get_efftox_priors">get_efftox_priors</a></code>
<code><a href="#topic+efftox_fit">efftox_fit</a></code>
<code><a href="#topic+stan_efftox_demo">stan_efftox_demo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This model is presented in Thall et al. (2014).
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                  beta_mean = 1.5482, beta_sd = 3.5018,
                  gamma_mean = 0.7367, gamma_sd = 2.5423,
                  zeta_mean = 3.4181, zeta_sd = 2.4406,
                  eta_mean = 0, eta_sd = 0.2,
                  psi_mean = 0, psi_sd = 1)
mod1 &lt;- stan_efftox('1N 2E 3B',
                    real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0),
                    efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                    p_e = 0.1, p_t = 0.1,
                    eff0 = 0.5, tox1 = 0.65,
                    eff_star = 0.7, tox_star = 0.25,
                    priors = p,
                    seed = 123)

# The above is a longhad version of:
mod2 &lt;- stan_efftox_demo('1N 2E 3B', seed = 123)

# the seed is passed to the Stan sampler. The usual Stan sampler params like
# cores, iter, chains etc are passed on too via the ellipsis operator.

## End(Not run)
</code></pre>

<hr>
<h2 id='stan_efftox_demo'>Fit the EffTox model presented in Thall et al. (2014)</h2><span id='topic+stan_efftox_demo'></span>

<h3>Description</h3>

<p>Fit the EffTox model presented in Thall et al. (2014) using Stan for full
Bayesian inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_efftox_demo(outcome_str, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_efftox_demo_+3A_outcome_str">outcome_str</code></td>
<td>
<p>A string representing the outcomes observed hitherto.
See <code><a href="#topic+efftox_parse_outcomes">efftox_parse_outcomes</a></code> for a description of syntax and
examples. Alternatively, you may provide <code>doses_given</code>, <code>eff</code> and
<code>tox</code> parameters. See Details.</p>
</td></tr>
<tr><td><code id="stan_efftox_demo_+3A_...">...</code></td>
<td>
<p>Extra parameters are passed to <code>rstan::sampling</code>. Commonly
used options are <code>iter</code>, <code>chains</code>, <code>warmup</code>, <code>cores</code>,
<code>control</code>. <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+efftox_fit">efftox_fit</a></code>
</p>


<h3>Author(s)</h3>

<p>Kristian Brock <a href="mailto:kristian.brock@gmail.com">kristian.brock@gmail.com</a>
</p>


<h3>References</h3>

<p>Thall, P., &amp; Cook, J. (2004). Dose-Finding Based on Efficacy-Toxicity
Trade-Offs. Biometrics, 60(3), 684-693.
</p>
<p>Thall, P., Herrick, R., Nguyen, H., Venier, J., &amp; Norris, J. (2014).
Effective sample size for computing prior hyperparameters in Bayesian
phase I-II dose-finding. Clinical Trials, 11(6), 657-666.
https://doi.org/10.1177/1740774514547397
</p>
<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp;
Yap, C. (2017). Implementing the EffTox dose-finding design in the
Matchpoint trial. BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efftox_fit">efftox_fit</a></code>
<code><a href="#topic+stan_efftox">stan_efftox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This model is presented in Thall et al. (2014)
mod2 &lt;- stan_efftox_demo('1N 2E 3B', seed = 123)

# The seed is passed to the Stan sampler. The usual Stan sampler params like
# cores, iter, chains etc are passed on too via the ellipsis operator.

## End(Not run)
</code></pre>

<hr>
<h2 id='stan_hierarchical_response_thall'>Fit the hierarchical response model described by
Thall <em>et al.</em> (2003).</h2><span id='topic+stan_hierarchical_response_thall'></span>

<h3>Description</h3>

<p>Fit the hierarchical response model to exchangeable groups described by
Thall <em>et al.</em> (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_hierarchical_response_thall(
  group_responses,
  group_sizes,
  mu_mean,
  mu_sd,
  tau_alpha,
  tau_beta,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_hierarchical_response_thall_+3A_group_responses">group_responses</code></td>
<td>
<p>vector of integers, number of responses in each group</p>
</td></tr>
<tr><td><code id="stan_hierarchical_response_thall_+3A_group_sizes">group_sizes</code></td>
<td>
<p>vector of integers, number of patients in each group</p>
</td></tr>
<tr><td><code id="stan_hierarchical_response_thall_+3A_mu_mean">mu_mean</code></td>
<td>
<p>mean parameter of normal prior distribution on mu. See details.</p>
</td></tr>
<tr><td><code id="stan_hierarchical_response_thall_+3A_mu_sd">mu_sd</code></td>
<td>
<p>standard deviation parameter of normal prior distribution on mu.
See details.</p>
</td></tr>
<tr><td><code id="stan_hierarchical_response_thall_+3A_tau_alpha">tau_alpha</code></td>
<td>
<p>parameter alpha of inverse gamma prior distribution on tau. See
details.</p>
</td></tr>
<tr><td><code id="stan_hierarchical_response_thall_+3A_tau_beta">tau_beta</code></td>
<td>
<p>beta parameter of inverse gamma prior distribution on tau. See
details.</p>
</td></tr>
<tr><td><code id="stan_hierarchical_response_thall_+3A_...">...</code></td>
<td>
<p>Extra parameters are passed to <code>rstan::sampling</code>. Commonly
used options are <code>iter</code>, <code>chains</code>, <code>warmup</code>, <code>cores</code>, and
<code>control</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Thall <em>et al.</em> (2003) describe hierarchical methods for analysing
treatment effects of a common intervention in several sub-types of a disease.
The treatment effects are assumed to be different but exchangeable and
correlated. Observing efficacy in one cohort, for example, increases one's
expectations of efficacy in others.
They demonstrate the hierarchical approach in a trial with binary response
outcomes and in another with time-to-event outcomes.
This function fits their model for binary response outcomes.
</p>
<p>Let the probability of response in group <code class="reqn">i</code> be <code class="reqn">\pi[i]</code> for
<code class="reqn">i = 1,...,N</code>.
They assume a logistic model so that
<code class="reqn">\theta_{i} = \log{\pi_{i} / (1 - \pi_{i})}</code>
is the log-odds of response in group <code class="reqn">i</code>.
They assume that <code class="reqn">\theta_{i} \sim N(\mu, \sigma^2)</code>.
</p>
<p>The authors implemented their model in BUGS.
As is the convention in BUGS, the authors define normal distributions by a
precision parameter <code class="reqn">\tau</code> as opposed to the standard deviation parameter
<code class="reqn">\sigma</code> used here. We have re-specified their model to comply with the
Stan convention of using standard deviation. The authors use a normal
prior on <code class="reqn">\mu</code>, and a gamma prior on <code class="reqn">\tau</code>, equivalent to
an inverse gamma prior on <code class="reqn">\tau^{-1} = \sigma^2</code>.
</p>
<p>The authors provide WinBUGS code in their publication.
We implement their model here in Stan.
</p>


<h3>Value</h3>

<p>Object of class <code><a href="rstan.html#topic+stanfit">rstan::stanfit</a></code> returned
by <code><a href="rstan.html#topic+sampling">rstan::sampling</a></code>
</p>


<h3>References</h3>

<p>Thall, Wathen, Bekele, Champlin, Baker, and Benjamin. 2003.
â€œHierarchical Bayesian approaches to phase II trials in diseases with
multiple subtypes.â€ Statistics in Medicine 22 (5): 763â€“80.
https://doi.org/10.1002/sim.1399.
</p>


<h3>See Also</h3>

<p><code><a href="rstan.html#topic+stanfit">rstan::stanfit</a></code>,
<code><a href="rstan.html#topic+sampling">rstan::sampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example from p.778 of Thall et al. (2003)
mod0 &lt;- stan_hierarchical_response_thall(
  group_responses = c(0, 0, 1, 3, 5, 0, 1, 2, 0, 0),
  group_sizes = c(0, 2 ,1, 7, 5, 0, 2, 3, 1, 0),
  mu_mean = -1.3863,
  mu_sd = sqrt(1 / 0.1),
  tau_alpha = 2,
  tau_beta = 20)

## End(Not run)

</code></pre>

<hr>
<h2 id='stan_nbg'>Fit a Neuenschwander, Branson &amp; Gsponer logit dose-finding model</h2><span id='topic+stan_nbg'></span>

<h3>Description</h3>

<p>Fit Neuenschwander, Branson &amp; Gsponer logit model for dose-finding using Stan
for full Bayesian inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_nbg(
  outcome_str = NULL,
  real_doses,
  d_star,
  target,
  alpha_mean = NULL,
  alpha_sd = NULL,
  beta_mean = NULL,
  beta_sd = NULL,
  doses_given = NULL,
  tox = NULL,
  weights = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_nbg_+3A_outcome_str">outcome_str</code></td>
<td>
<p>A string representing the outcomes observed hitherto.
See <code><a href="#topic+df_parse_outcomes">df_parse_outcomes</a></code> for a description of syntax and
examples. Alternatively, you may provide <code>doses_given</code> and <code>tox</code>
parameters. See Details.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_real_doses">real_doses</code></td>
<td>
<p>A vector of numbers, the doses under investigation. They
should be ordered from lowest to highest and be in consistent units.
E.g. to conduct a dose-finding trial of doses 10mg, 20mg and 50mg, use
c(10, 20, 50).</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_d_star">d_star</code></td>
<td>
<p>d_star, numeric reference dose-level. The linear covariate
in this logit model is <code>dose / d_star</code>.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_target">target</code></td>
<td>
<p>the target toxicity probability, a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>Prior mean of intercept variable for normal prior.
See Details.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>Prior standard deviation of intercept variable for normal prior.
See Details.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_beta_mean">beta_mean</code></td>
<td>
<p>Prior mean of gradient variable for normal prior.
See Details.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_beta_sd">beta_sd</code></td>
<td>
<p>Prior standard deviation of slope variable for normal prior.
See Details.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_doses_given">doses_given</code></td>
<td>
<p>A optional vector of dose-levels given to patients
1:num_patients, where 1=lowest dose, 2=second dose, etc. Only required when
<code>outcome_str</code> is not provided.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_tox">tox</code></td>
<td>
<p>An optional vector of toxicity outcomes for patients
1:num_patients, where 1=toxicity and 0=no toxicity. Only required when
<code>outcome_str</code> is not provided.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_weights">weights</code></td>
<td>
<p>An optional vector of numeric weights for the observations
for patients 1:num_patients, thus facilitating a time-to-event (TITE) design.
Can be used with <code>outcome_str</code>, or with <code>doses_given</code> and
<code>tox</code>. It is generally tidier to specify <code>doses_given</code>,
<code>tox</code> and <code>weights</code> when a TITE-analysis is desired.</p>
</td></tr>
<tr><td><code id="stan_nbg_+3A_...">...</code></td>
<td>
<p>Extra parameters are passed to <code>rstan::sampling</code>. Commonly
used options are <code>iter</code>, <code>chains</code>, <code>warmup</code>, <code>cores</code>, and
<code>control</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quickest and easiest way to fit this model to some observed outcomes
is to describe the outcomes using <span class="pkg">trialr</span>'s syntax for dose-finding
outcomes. See <code><a href="#topic+df_parse_outcomes">df_parse_outcomes</a></code> for full details and examples.
</p>
<p>The two-parameter model form is:
</p>
<p><code class="reqn">F(x_{i}, \alpha, \beta) = 1 / (1 + \exp{-(\alpha + \exp{(\beta)} log(x_i / d_star))}) </code>
</p>
<p>and the required parameters are:
</p>

<ul>
<li> <p><code>alpha_mean</code>
</p>
</li>
<li> <p><code>alpha_sd</code>
</p>
</li>
<li> <p><code>beta_mean</code>
</p>
</li>
<li> <p><code>beta_sd</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>nbg_fit</code>, which inherits behaviour from
<code><a href="#topic+crm_fit">crm_fit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Kristian Brock <a href="mailto:kristian.brock@gmail.com">kristian.brock@gmail.com</a>
</p>


<h3>References</h3>

<p>Neuenschwander, B., Branson, M., &amp; Gsponer, T. (2008).
Critical aspects of the Bayesian approach to phase I cancer trials.
Statistics in Medicine, 27, 2420â€“2439. https://doi.org/10.1002/sim
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm_fit">crm_fit</a></code>
<code><a href="rstan.html#topic+sampling">sampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Non-TITE example:
fit1 &lt;- stan_nbg('1NNN 2NNN 3TTT', real_doses = c(10, 20, 50, 100, 200),
                 d_star = 200, target = 0.25,
                 alpha_mean = -1, alpha_sd = 2,
                 beta_mean = 0, beta_sd = 1,
                 seed = 123)
fit1$recommended_dose

# The seed is passed to the Stan sampler. The usual Stan sampler params like
# cores, iter, chains etc are passed on too via the ellipsis operator.

# TITE-CRM example
fit2 &lt;-stan_nbg(real_doses = c(10, 20, 50, 100, 200), d_star = 200,
                target = 0.25,
                doses_given = c(3, 3, 3, 3),
                tox = c(0, 0, 0, 0),
                weights = c(73, 66, 35, 28) / 126,
                alpha_mean = -1, alpha_sd = 2,
                beta_mean = 0, beta_sd = 1,
                seed = 123)
fit2$recommended_dose

## End(Not run)
</code></pre>

<hr>
<h2 id='stan_peps2'>Fit the P2TNE model developed for the PePS2 trial to some outcomes.</h2><span id='topic+stan_peps2'></span>

<h3>Description</h3>

<p>The PePS2 trial
investigates pembrolizumab in non-small-cell lung cancer. Patients may be
previously treated (PT) or treatment naive (TN). Response rates in
lung cancer have been shown to increase with PD-L1 tumour proportion score.
PD-L1 score is measured at baseline. Each patient belongs to one of the
categories &lt;1
stratify the patient
population and are used as predictive variables to stratify the analysis.
The BEBOP model studies co-primary efficacy and toxicity outcomes in the
presence of predictive data. Thus, PePS2 studies efficacy and toxicity in
6 distinct cohorts:
TN Low, TN Medium, TN High, PT Low, PT Medium, PT High.
The design admits all-comers and does not target specific sample sizes in the
individual cohorts.
Hyperprior parameters have defaults to match those used in PePS2, but all may
be overridden.
The returned object includes randomly-sampled outcomes, as well as parameters
to run the model. These are all combined in the same list object for passing
to RStan, as is the convention.
See the accompanying vignette for a full description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_peps2(
  eff,
  tox,
  cohorts,
  alpha_mean = -2.2,
  alpha_sd = 2,
  beta_mean = -0.5,
  beta_sd = 2,
  gamma_mean = -0.5,
  gamma_sd = 2,
  zeta_mean = -0.5,
  zeta_sd = 2,
  lambda_mean = -2.2,
  lambda_sd = 2,
  psi_mean = 0,
  psi_sd = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_peps2_+3A_eff">eff</code></td>
<td>
<p>A vector of efficacy outcomes for the patients, where 1=efficacy
and 0=no efficacy.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_tox">tox</code></td>
<td>
<p>A vector of toxicity outcomes for the patients, where 1=toxicity
and 0=no toxicity.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_cohorts">cohorts</code></td>
<td>
<p>A vector of integers from 1 to 6, denoting the cohorts to
which the patients belong.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>The prior mean of alpha. Alpha is the efficacy model
intercept.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>The prior standard deviation of alpha. Alpha is the efficacy
model  intercept.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_beta_mean">beta_mean</code></td>
<td>
<p>The prior mean of beta. Beta is the efficacy model term
for being previously treated.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_beta_sd">beta_sd</code></td>
<td>
<p>The prior standard deviation of beta. Beta is the efficacy
model term for being previously treated.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_gamma_mean">gamma_mean</code></td>
<td>
<p>The prior mean of gamma. Gamma is the efficacy model term
for being PD-L1 score = Low.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_gamma_sd">gamma_sd</code></td>
<td>
<p>The prior standard deviation of gamma. Gamma is the efficacy
model term for being PD-L1 score = Low.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_zeta_mean">zeta_mean</code></td>
<td>
<p>The prior mean of zeta. Zeta is the efficacy model term
for being PD-L1 score = Medium.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_zeta_sd">zeta_sd</code></td>
<td>
<p>The prior standard deviation of zeta. Zeta is the efficacy
model term for being PD-L1 score = Medium.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_lambda_mean">lambda_mean</code></td>
<td>
<p>The prior mean of lambda. Lambda is the toxicity model
intercept.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_lambda_sd">lambda_sd</code></td>
<td>
<p>The prior standard deviation of lambda. Lambda is the
toxicity model intercept.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_psi_mean">psi_mean</code></td>
<td>
<p>The prior mean of psi. Psi is the joint model association
parameter.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_psi_sd">psi_sd</code></td>
<td>
<p>The prior standard deviation of psi. Psi is the joint model
association parameter.</p>
</td></tr>
<tr><td><code id="stan_peps2_+3A_...">...</code></td>
<td>
<p>Extra parameters are passed to <code>rstan::sampling</code>. Commonly
used options are <code>iter</code>, <code>chains</code>, <code>warmup</code>, <code>cores</code>, and
<code>control</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="rstan.html#topic+stanfit">rstan::stanfit</a></code> returned
by <code><a href="rstan.html#topic+sampling">rstan::sampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- stan_peps2(
  eff = c(0, 1, 0, 1, 0, 0),
  tox = c(0, 0, 1, 1, 0, 0),
  cohorts = c(3, 1, 1, 4, 5, 6)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.crm_fit'>Obtain summary of an crm_fit</h2><span id='topic+summary.crm_fit'></span>

<h3>Description</h3>

<p>Obtain summary of an crm_fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crm_fit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.crm_fit_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+crm_fit">crm_fit</a></code> object to summarise.</p>
</td></tr>
<tr><td><code id="summary.crm_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_crm">stan_crm</a></code>
</p>

<hr>
<h2 id='summary.efftox_fit'>Obtain summary of an efftox_fit</h2><span id='topic+summary.efftox_fit'></span>

<h3>Description</h3>

<p>Obtain summary of an efftox_fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'efftox_fit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.efftox_fit_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+efftox_fit">efftox_fit</a></code> object to summarise.</p>
</td></tr>
<tr><td><code id="summary.efftox_fit_+3A_...">...</code></td>
<td>
<p>Extra parameters, passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary object.
</p>

<hr>
<h2 id='total_weight_at_dose'>Get the total weight of patient outcomes at the doses under investigation.</h2><span id='topic+total_weight_at_dose'></span><span id='topic+total_weight_at_dose.default'></span>

<h3>Description</h3>

<p>Get the total weight of patient outcomes at the doses under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_weight_at_dose(x, dose, ...)

## Default S3 method:
total_weight_at_dose(x, dose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="total_weight_at_dose_+3A_x">x</code></td>
<td>
<p>An R object of class <code>"dose_finding_fit"</code></p>
</td></tr>
<tr><td><code id="total_weight_at_dose_+3A_dose">dose</code></td>
<td>
<p>Optional integer, at which dose-level? Omit to get data on all doses.</p>
</td></tr>
<tr><td><code id="total_weight_at_dose_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CRM example
fit &lt;- stan_crm(skeleton = c(0.1, 0.2, 0.35, 0.6), target = 0.2,
                model = 'empiric', beta_sd = sqrt(1.34), seed = 123,
                doses = c(1, 1, 2, 2, 2),
                tox   = c(0, 0, 0, 0, 0),
                weights = c(1, 1, 0.9, 0.1, 0.1))

total_weight_at_dose(fit)            # c(2, 1.1, 0, 0)
total_weight_at_dose(fit, dose = 2)  # 1.1

## End(Not run)
</code></pre>

<hr>
<h2 id='tox_at_dose'>Get the number of toxicity events seen at the doses under investigation.</h2><span id='topic+tox_at_dose'></span><span id='topic+tox_at_dose.dose_finding_fit'></span>

<h3>Description</h3>

<p>Get the number of toxicity events seen at the doses under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tox_at_dose(x, dose, ...)

## S3 method for class 'dose_finding_fit'
tox_at_dose(x, dose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tox_at_dose_+3A_x">x</code></td>
<td>
<p>An R object of class <code>"dose_finding_fit"</code></p>
</td></tr>
<tr><td><code id="tox_at_dose_+3A_dose">dose</code></td>
<td>
<p>Optional integer, at which dose-level? Omit to get data on all doses.</p>
</td></tr>
<tr><td><code id="tox_at_dose_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CRM example
target &lt;- 0.2
fit &lt;- stan_crm('1N 2N 3T', skeleton = c(0.1, 0.2, 0.35, 0.6),
                 target = target, model = 'empiric', beta_sd = sqrt(1.34),
                 seed = 123)
tox_at_dose(fit)            # c(0, 0, 1, 0)
tox_at_dose(fit, dose = 3)  # 1

## End(Not run)
</code></pre>

<hr>
<h2 id='trialr_simulate'>Run a simulation study.</h2><span id='topic+trialr_simulate'></span>

<h3>Description</h3>

<p>This function is a fairly flexible way of running simulation studies in
trialr, and beyond. It essentially uses delegates to perform this pattern:
</p>
<pre>
for i in 1:N:
  data = get_data_func()
  fit = fit_model_func(data)
  if summarise_func is null:
    sims[i] = fit
  else
    sims[i] = summarise_func(data, fit)
  end
loop
return sims
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>trialr_simulate(
  N,
  get_data_func,
  fit_model_func,
  summarise_func = NULL,
  num_logs = 10,
  num_saves = NULL,
  save_func = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trialr_simulate_+3A_n">N</code></td>
<td>
<p>integer, number of simulated iterations to run.</p>
</td></tr>
<tr><td><code id="trialr_simulate_+3A_get_data_func">get_data_func</code></td>
<td>
<p>Function that takes no parameters and returns a sampled
dataset to be analysed. I.e. the call signature is f().</p>
</td></tr>
<tr><td><code id="trialr_simulate_+3A_fit_model_func">fit_model_func</code></td>
<td>
<p>Function that accepts the output of
<code>get_data_func</code> as the sole parameter and fits the model or performs the
analysis, returning an object of arbitrary type.</p>
</td></tr>
<tr><td><code id="trialr_simulate_+3A_summarise_func">summarise_func</code></td>
<td>
<p>Optional. If provided, this function should accept the
ouputs of <code>get_data_func</code> and <code>fit_model_func</code> as parameters 1 &amp; 2
and perform some post-fit processing or simplification. The result of this
call is the output from iteration i. If omitted, the fit object from
<code>fit_model_func</code> is simply used as the output from iteration i.</p>
</td></tr>
<tr><td><code id="trialr_simulate_+3A_num_logs">num_logs</code></td>
<td>
<p>Number of log messages to receive about progress. NULL to
suppress logging. E.g. if N=100 and num_logs=10, you will get log messages
when i=10, 20, 30, etc.</p>
</td></tr>
<tr><td><code id="trialr_simulate_+3A_num_saves">num_saves</code></td>
<td>
<p>Number of interimittent saves to attempt. NULL to
suppress saving E.g. if N=100 and num_saves=10, the save_func delegate will
be called after iteration i=10, 20, 30, etc.</p>
</td></tr>
<tr><td><code id="trialr_simulate_+3A_save_func">save_func</code></td>
<td>
<p>Optional. Function that takes the interim list of simulated
objects as the sole parameter and saves them somehow. This, combined with
<code>num_saves</code>, allows periodic saving of in-progress results to avoid
complete data loss if the simulation study fails for some reason.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> of length <code>N</code>. The items in the list are as returned
by <code>summarise_func</code> or <code>fit_model_func</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_data_func &lt;- function() {
  group_sizes &lt;- rbinom(n = 5, size = 50, prob = c(0.1, 0.3, 0.3, 0.2, 0.1))
  group_responses &lt;- rbinom(n = 5, size = group_sizes,
                            prob = c(0.2, 0.5, 0.2, 0.2, 0.2))
  list(
    group_responses = group_responses, group_sizes = group_sizes,
    mu_mean = gtools::logit(0.1), mu_sd = 1, tau_alpha = 2, tau_beta = 20
  )
}
fit_model_func &lt;- function(data) {
  data &lt;- append(data, list(refresh = 0))
  do.call(stan_hierarchical_response_thall, args = data)
}
summarise_func &lt;- function(data, fit) {
  # Probability that estimate response rate exceeds 30%
  unname(colMeans(as.data.frame(fit, 'prob_response') &gt; 0.3))
}
## Not run: 
sims &lt;- trialr_simulate(N = 20, get_data_func, fit_model_func, summarise_func)
# Posterior probabilities that the response rate in each cohort exceeds 30%:
do.call(rbind, sims)
# Cohorts are in columns; simulated iterations are in rows.

## End(Not run)
</code></pre>

<hr>
<h2 id='weights_at_dose'>Get the weights of patient outcomes at the doses under investigation.</h2><span id='topic+weights_at_dose'></span><span id='topic+weights_at_dose.default'></span><span id='topic+weights_at_dose.crm_fit'></span>

<h3>Description</h3>

<p>Get the weights of patient outcomes at the doses under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_at_dose(x, dose, ...)

## Default S3 method:
weights_at_dose(x, dose = NULL, ...)

## S3 method for class 'crm_fit'
weights_at_dose(x, dose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights_at_dose_+3A_x">x</code></td>
<td>
<p>An R object of class <code>"dose_finding_fit"</code></p>
</td></tr>
<tr><td><code id="weights_at_dose_+3A_dose">dose</code></td>
<td>
<p>Optional integer, at which dose-level? Omit to get data on all doses.</p>
</td></tr>
<tr><td><code id="weights_at_dose_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list if <code>dose</code> omitted, numerical vector if <code>dose</code> provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CRM example
fit &lt;- stan_crm(skeleton = c(0.1, 0.2, 0.35, 0.6), target = 0.2,
                model = 'empiric', beta_sd = sqrt(1.34), seed = 123,
                doses = c(1, 1, 2, 2, 2),
                tox   = c(0, 0, 0, 0, 0),
                weights = c(1, 1, 0.9, 0.1, 0.1))
l &lt;- weights_at_dose(fit)

length(l)  # 4
l[[1]]  # c(1, 1)
l[[2]]  # c(0.9, 0.1, 0.1)
l[[3]]  # c()

weights_at_dose(fit, dose = 2)  # c(0.9, 0.1, 0.1)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
