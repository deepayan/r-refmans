<!DOCTYPE html><html lang="en"><head><title>Help for package TopKSignal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TopKSignal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#elbowPlot'><p>elbowPlot</p></a></li>
<li><a href='#estimatedSignal'><p>Object returned by the estimateTheta() function.</p></a></li>
<li><a href='#estimateTheta'><p>Estimation of the underlying signal.</p></a></li>
<li><a href='#generate.rank.matrix'><p>generate.rank.matrix</p></a></li>
<li><a href='#heatmapPlot'><p>Heatmap noise matrix plot</p></a></li>
<li><a href='#TopKSignal'><p>TopKSignal: A convex optimization tool for signal reconstruction from multiple ranked lists.</p></a></li>
<li><a href='#violinPlot'><p>violinPlot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Convex Optimization Tool for Signal Reconstruction from
Multiple Ranked Lists</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-12</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, doParallel, parallel, nloptr, Matrix, ggplot2,
reshape2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, gurobi</td>
</tr>
<tr>
<td>Description:</td>
<td>A mathematical optimization procedure in combination with statistical bootstrap for the estimation of the latent signals (sometimes called scores) informing the global consensus ranking (often named aggregation ranking). To solve mid/large-scale problems, users should install the 'gurobi' optimiser (available from <a href="https://www.gurobi.com/">https://www.gurobi.com/</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-21 21:28:56 UTC; bastian</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Vitale Developer [aut],
  Bastian Pfeifer Maintainer [aut, cre],
  Michael G. Schimek Supervision [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bastian Pfeifer Maintainer &lt;bastian.pfeifer@medunigraz.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 10:50:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='elbowPlot'>elbowPlot</h2><span id='topic+elbowPlot'></span>

<h3>Description</h3>

<p>The elbow plot permits the identification of subsets of objects, e.g. top-$k$ or bottom-$q$ objects. On the x-axis all objects are ordered according to their rank positions. On the y-axis the corresponding estimated signal values are displayed. The idea of the elbow plot is to scan for 'jumps' in the sequence of ordered objects ? i.e. find signal estimates next to each other that are visually much distant - in an exploratory manner. The elbowPlot function requires the estimation results from the estimateTheta function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elbowPlot(estimation, title = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elbowPlot_+3A_estimation">estimation</code></td>
<td>
<p>Results from the estimateTheta() function</p>
</td></tr>
<tr><td><code id="elbowPlot_+3A_title">title</code></td>
<td>
<p>A title for the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A elbow plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(estimatedSignal)
elbowPlot(estimatedSignal)
</code></pre>

<hr>
<h2 id='estimatedSignal'>Object returned by the estimateTheta() function.</h2><span id='topic+estimatedSignal'></span>

<h3>Description</h3>

<p>Object returned by the estimateTheta() function.
</p>


<h3>Format</h3>

<p>A list of various values returned by the estimateTheta() function.
</p>

<dl>
<dt>estimation</dt><dd><p>A data frame with the signal estimation and the standard error computed by the bootstrap for each object</p>
</dd>
<dt>estimatedMatrixNoise</dt><dd><p>The estimated matrix noise</p>
</dd> 
<dt>allBootstraps</dt><dd><p>The signal estimates from all bootstrap iterations</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(estimatedSignal)
</code></pre>

<hr>
<h2 id='estimateTheta'>Estimation of the underlying signal.</h2><span id='topic+estimateTheta'></span>

<h3>Description</h3>

<p>The main function for the estimation of the signals informing the ranks is called estimateTheta(). The required parameters are: (1) a rank matrix, (2) the number of bootstrap samples (500 is recommended), (3) a constant for the support variables \(b&gt;0\), default is 0.1, (4)  the type of optimization technique: fullLinear, fullQuadratic, restrictedLinear, and restrictedQuadratic (the latter two recommended), (5) the type of  bootstrap sampling scheme: classic.bootstrap and poisson.bootstrap (recommended), and (6) the number of cores for parallel computation. Each bootstrap sample is executed on a dedicated CPU core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateTheta(
  R.input,
  b,
  num.boot,
  solver,
  type,
  bootstrap.type,
  nCore = ((detectCores() - 1))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateTheta_+3A_r.input">R.input</code></td>
<td>
<p>A matrix where the rows represent the objects and
the columns the assessors (rankers).</p>
</td></tr>
<tr><td><code id="estimateTheta_+3A_b">b</code></td>
<td>
<p>The penalization term. The suggested value is 0.1.</p>
</td></tr>
<tr><td><code id="estimateTheta_+3A_num.boot">num.boot</code></td>
<td>
<p>The number of boostrap samples created from the input ranked matrix. A positive number is expected.</p>
</td></tr>
<tr><td><code id="estimateTheta_+3A_solver">solver</code></td>
<td>
<p>A string that indicates which solver to use. Two options are available, 'gurobi' and 'nloptr'.
We recommend to use gurobi for faster computation. Note, a licence is required. Check the corresponding documentation on how to install gurobi.</p>
</td></tr>
<tr><td><code id="estimateTheta_+3A_type">type</code></td>
<td>
<p>A string that indicates which model to use: four approaches are available: 'restrictedQuadratic', 'fullQuadratic', 'restrictedLinear' and 'fullLinear'.</p>
</td></tr>
<tr><td><code id="estimateTheta_+3A_bootstrap.type">bootstrap.type</code></td>
<td>
<p>A string that indicates which bootstrap method to use: 'classic.bootstrap' or 'poisson.bootstrap'.</p>
</td></tr>
<tr><td><code id="estimateTheta_+3A_ncore">nCore</code></td>
<td>
<p>The number of cores used for computation. Each core is used to calculate the signals from a bootstrap sample. Default number is detectCores() - 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the estimation information obtained:
</p>

<ul>
<li><p> estimation - A data frame with the signal estimation and the standard error computed by the bootstrap for each object
</p>
</li>
<li><p> estimatedMatrixNoise - The estimated matrix noise 
</p>
</li>
<li><p> time - The execution time of the procedure
</p>
</li>
<li><p> allBootstraps - The signal estimates from all bootstrap iterations
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(TopKSignal)
set.seed(1421)
p = 8
n = 10
input &lt;- generate.rank.matrix(p, n)
rownames(input$R.input) &lt;- c("a","b","c","d","e","f","g","h")
# For the following code Gurobi needs to be installed
## Not run: 
estimatedSignal &lt;- estimateTheta(R.input = input$R.input, num.boot = 50, b = 0.1, 
solver = "gurobi", type = "restrictedQuadratic", bootstrap.type = "poisson.bootstrap",nCore = 1)   

## End(Not run)
data(estimatedSignal)
estimatedSignal
</code></pre>

<hr>
<h2 id='generate.rank.matrix'>generate.rank.matrix</h2><span id='topic+generate.rank.matrix'></span>

<h3>Description</h3>

<p>The generate.rank.matrix() function requires the user to specify the number of objects (items), called p, and the number of assessors, called n. The function simulates full ranked lists (i.e. no missing assignments) without ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.rank.matrix(p, n, percentageMissing = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate.rank.matrix_+3A_p">p</code></td>
<td>
<p>The number of objects.</p>
</td></tr>
<tr><td><code id="generate.rank.matrix_+3A_n">n</code></td>
<td>
<p>The number of assessors.</p>
</td></tr>
<tr><td><code id="generate.rank.matrix_+3A_percentagemissing">percentageMissing</code></td>
<td>
<p>The percentage of the missing values. Note, missing data should be resolved by the rank() function before calling estimateTheta().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with simulated data
</p>

<ul>
<li><p> R.input - The rank matrix 
</p>
</li>
<li><p> thea.true - The true underlying signals from the assessments 
</p>
</li>
<li><p> sigmas - The standard error of the noise added for each assessor
</p>
</li>
<li><p> matrixNoise - The noise added to the true signals in order to get the final rank matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>p = 8
n = 10
input &lt;- generate.rank.matrix(p, n)
rownames(input$R.input) &lt;- c("a","b","c","d","e","f","g","h")
</code></pre>

<hr>
<h2 id='heatmapPlot'>Heatmap noise matrix plot</h2><span id='topic+heatmapPlot'></span>

<h3>Description</h3>

<p>The heatmap plot allows us to control for specific error patterns associated with the assessors. The heatmap plot displays information about the noises involved in the estimation process. The rows of the noise matrix are ordered by the estimated ranks of the consensus signal values. The columns are ordered by the column error sums. In the plot, the column with the lowest sum is positioned on the left side and the column with the highest sum is positioned on the right side. Hence, assessors positioned on the left show substantial consensus and thus are more reliable than those positioned to the far right. The heatmap plot is also an exploratory tool for the search for a subset of top-ranked objects (notion of top-$k$ objects ? see the package TopKLists on CRAN for details and functions). Please note, beyond exploratory tasks, the noise matrix can serve as input for various inferential purposes such as testing for assessor group differences. The heatmapPlot function requires the estimation results obtained from the estimateTheta function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmapPlot(estimation, type = "full", title = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmapPlot_+3A_estimation">estimation</code></td>
<td>
<p>The bootstrap estimation obtained from the estimateTheta function</p>
</td></tr>
<tr><td><code id="heatmapPlot_+3A_type">type</code></td>
<td>
<p>The type of method used: Two options are available, 'full' or 'reduced'</p>
</td></tr>
<tr><td><code id="heatmapPlot_+3A_title">title</code></td>
<td>
<p>The title of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li><p> plot - A heatmap plot with the noise matrix (ordered values).
</p>
</li>
<li><p> matrixNoiseOrdered - The matrix noise ordered by the columns. The objects are ordered by the estimated value.
</p>
</li>
<li><p> estimateThetaOrdered - The theta vector ordered by their importance (from the highest value to the lowest).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(estimatedSignal)
heatmapPlot(estimatedSignal)
</code></pre>

<hr>
<h2 id='TopKSignal'>TopKSignal: A convex optimization tool for signal reconstruction from multiple ranked lists.</h2><span id='topic+TopKSignal'></span>

<h3>Description</h3>

<p>A mathematical optimization procedure in combination with statistical bootstrap for the estimation of the latent signals (sometimes called scores) informing the global consensus ranking (often named aggregation ranking).
When using TopKSignal in your work please cite:
Schimek, M. G. et al. (2024). Effective signal reconstruction from multiple ranked lists via convex optimization. Data Mining and Knowledge Discovery. DOI: 10.1007/s10618-023-00991-z.
The goal of estimating consensus signals and therefrom consensus ranks (an alternative form of aggregation ranks) across a number of assessors (humans or machines) is achieved via indirect inference. The input rank matrix is fully represented by order constraints. No distance measures or distributional assumptions are involved. The indirect inference procedure is built around a simple signal plus noise model.
TopKSignal implements a set of different functions. They permit to construct artificial ranked lists, to derive sets of constraints from an input rank matrix, to run convex optimization (with a quadratic or a linear objective function), to perform bootstrap estimation (standard or Poisson bootstrap), and to produce numerical and graphical output.
Different mathematical optimization techniques are available: Optimization with the full set of constraints or with a computationally cheaper restricted set of constraints in combination with either a quadratic or a linear objective function.
Different boostrap sample schemes are available: the classical bootstrap and the computationally less demanding Poisson bootstrap.
</p>


<h3>estimateTheta function</h3>

<p>The main function for the estimation of the signals informing the ranks is called estimateTheta(). The required parameters are: (1) a rank matrix, (2) the number of bootstrap samples (500 is recommended), (3) a constant for the support variables \(b&gt;0\), default is 0.1, (4)  the type of optimization technique: fullLinear, fullQuadratic, restrictedLinear, and restrictedQuadratic (the latter two recommended), (5) the type of  bootstrap sampling scheme: classic.bootstrap and poisson.bootstrap (recommended), and (6) the number of cores for parallel computation. Each bootstrap sample is executed on a dedicated CPU core.
</p>


<h3>generate.rank.matrix function</h3>

<p>The generate.rank.matrix() function requires the user to specify the number of objects (items), called p, and the number of assessors, called n. The function simulates full ranked lists (i.e. no missing assignments) without ties.
</p>


<h3>violinPlot function</h3>

<p>The violin plot displays the bootstrap distribution of the estimated signals along with its means. The deviations from the mean values +/-2 standard errors SE and are shown in the plot.  Analyzing the shape of the distribution and the standard error of the signal of each object, it is possible to evaluate its rank stability with respect to all other objects. The violinPlot function requires (1) the result obtained by the estimation procedure and (2) the 'true' (simulated) signals or ground truth (when available).
</p>


<h3>heatmapPlot function</h3>

<p>The heatmap plot allows us to control for specific error patterns associated with the assessors. The heatmap plot displays information about the noises involved in the estimation process. The rows of the noise matrix are ordered by the estimated ranks of the consensus signal values. The columns are ordered by the column error sums. In the plot, the column with the lowest sum is positioned on the left side and the column with the highest sum is positioned on the right side. Hence, assessors positioned on the left show substantial consensus and thus are more reliable than those positioned to the far right. The heatmap plot is also an exploratory tool for the search for a subset of top-ranked objects (notion of top-$k$ objects ? see the package TopKLists on CRAN for details and functions). Please note, beyond exploratory tasks, the noise matrix can serve as input for various inferential purposes such as testing for assessor group differences. The heatmapPlot function requires the estimation results obtained from the estimateTheta function.
</p>


<h3>elbowPlot function</h3>

<p>The elbow plot permits the identification of subsets of objects, e.g. top-$k$ or bottom-$q$ objects. On the x-axis all objects are ordered according to their rank positions. On the y-axis the corresponding estimated signal values are displayed. The idea of the elbow plot is to scan for 'jumps' in the sequence of ordered objects ? i.e. find signal estimates next to each other that are visually much distant - in an exploratory manner. The elbowPlot function requires the estimation results from the estimateTheta function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TopKSignal)
set.seed(1421)
p = 8
n = 10
input &lt;- generate.rank.matrix(p, n)
rownames(input$R.input) &lt;- c("a","b","c","d","e","f","g","h")
# For the following code Gurobi needs to be installed
## Not run: 
estimatedSignal &lt;- estimateTheta(R.input = input$R.input, num.boot = 50, b = 0.1, 
solver = "gurobi", type = "restrictedQuadratic", bootstrap.type = "poisson.bootstrap",nCore = 1)	

## End(Not run)
data(estimatedSignal)
estimatedSignal
</code></pre>

<hr>
<h2 id='violinPlot'>violinPlot</h2><span id='topic+violinPlot'></span>

<h3>Description</h3>

<p>violinPlot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>violinPlot(estimation, trueSignal = NULL, title = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="violinPlot_+3A_estimation">estimation</code></td>
<td>
<p>The estimation list from the 'estimateTheta' function</p>
</td></tr>
<tr><td><code id="violinPlot_+3A_truesignal">trueSignal</code></td>
<td>
<p>The true signal (if available)</p>
</td></tr>
<tr><td><code id="violinPlot_+3A_title">title</code></td>
<td>
<p>The title of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A violint plot with the estimated distribution of each object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(estimatedSignal)
violinPlot(estimatedSignal)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
