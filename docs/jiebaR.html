<!DOCTYPE html><html lang="en"><head><title>Help for package jiebaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jiebaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jiebaR'><p>A package for Chinese text segmentation</p></a></li>
<li><a href='#+26lt+3B+3D.keywords'><p>Keywords symbol</p></a></li>
<li><a href='#+26lt+3B+3D.qseg'><p>Quick mode symbol</p></a></li>
<li><a href='#+26lt+3B+3D.segment'><p>Text segmentation symbol</p></a></li>
<li><a href='#+26lt+3B+3D.simhash'><p>Simhash symbol</p></a></li>
<li><a href='#+26lt+3B+3D.tagger'><p>Tagger symbol</p></a></li>
<li><a href='#apply_list'><p>Apply list input to a worker</p></a></li>
<li><a href='#DICTPATH'><p>The path of dictionary</p></a></li>
<li><a href='#distance'><p>Hamming distance of words</p></a></li>
<li><a href='#edit_dict'><p>Edit default user dictionary</p></a></li>
<li><a href='#file_coding'><p>Files encoding detection</p></a></li>
<li><a href='#filter_segment'><p>Filter segmentation result</p></a></li>
<li><a href='#freq'><p>The frequency of words</p></a></li>
<li><a href='#get_idf'><p>generate IDF dict</p></a></li>
<li><a href='#get_qsegmodel'><p>Set quick mode model</p></a></li>
<li><a href='#get_tuple'><p>get tuple from the segmentation result</p></a></li>
<li><a href='#keywords'><p>Keyword extraction</p></a></li>
<li><a href='#new_user_word'><p>Add user word</p></a></li>
<li><a href='#print.inv'><p>Print worker settings</p></a></li>
<li><a href='#segment'><p>Chinese text segmentation function</p></a></li>
<li><a href='#show_dictpath'><p>Show default path of dictionaries</p></a></li>
<li><a href='#simhash'><p>Simhash computation</p></a></li>
<li><a href='#simhash_dist'><p>Compute Hamming distance of Simhash value</p></a></li>
<li><a href='#tagging'><p>Speech Tagging</p></a></li>
<li><a href='#tobin'><p>simhash value to binary</p></a></li>
<li><a href='#vector_tag'><p>Tag the a character vector</p></a></li>
<li><a href='#worker'><p>Initialize jiebaR worker</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Chinese Text Segmentation</td>
</tr>
<tr>
<td>Description:</td>
<td>Chinese text segmentation, keyword extraction and speech tagging
    For R.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Qin Wenfeng, Wu Yanyi </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qin Wenfeng &lt;mail@qinwenfeng.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3), jiebaRD</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,testthat,devtools,rmarkdown,roxygen2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/qinwf/jiebaR/">https://github.com/qinwf/jiebaR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/qinwf/jiebaR/issues">https://github.com/qinwf/jiebaR/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-13 17:12:13 UTC; qinwf</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-13 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='jiebaR'>A package for Chinese text segmentation</h2><span id='topic+jiebaR'></span><span id='topic+jiebaR-package'></span>

<h3>Description</h3>

<p>This is a package for Chinese text segmentation, keyword extraction 
and speech tagging with Rcpp and cppjieba.
</p>


<h3>Details</h3>

<p>You can use custom 
dictionary. JiebaR can 
also identify new words, but adding new words will ensure higher 
accuracy.
</p>


<h3>Author(s)</h3>

<p>Qin Wenfeng &lt;<a href="http://qinwenfeng.com">http://qinwenfeng.com</a>&gt;
</p>


<h3>References</h3>

<p>CppJieba <a href="https://github.com/aszxqw/cppjieba">https://github.com/aszxqw/cppjieba</a>;
</p>


<h3>See Also</h3>

<p>JiebaR <a href="https://github.com/qinwf/jiebaR">https://github.com/qinwf/jiebaR</a>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Note: Can not display Chinese characters here.
## Not run: 
words = "hello world"
engine1 = worker()
segment(words, engine1)

# "./temp.txt" is a file path

segment("./temp.txt", engine1)

engine2 = worker("hmm")
segment("./temp.txt", engine2)

engine2$write = T
segment("./temp.txt", engine2)

engine3 = worker(type = "mix", dict = "dict_path",symbol = T)
segment("./temp.txt", engine3)
 
## End(Not run)
 
## Not run: 
### Keyword Extraction
engine = worker("keywords", topn = 1)
keywords(words, engine)

### Speech Tagging 
tagger = worker("tag")
tagging(words, tagger)

### Simhash
simhasher = worker("simhash", topn = 1)
simhash(words, simhasher)
distance("hello world" , "hello world!" , simhasher)

show_dictpath()

## End(Not run)

</code></pre>

<hr>
<h2 id='+26lt+3B+3D.keywords'>Keywords symbol</h2><span id='topic++3C+3D.keywords'></span><span id='topic++5B.keywords'></span>

<h3>Description</h3>

<p>Keywords symbol to find keywords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'keywords'
jiebar &lt;= code

## S3 method for class 'keywords'
jiebar[code]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B26lt+2B3B+2B3D.keywords_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR Worker.</p>
</td></tr>
<tr><td><code id="+2B26lt+2B3B+2B3D.keywords_+3A_code">code</code></td>
<td>
<p>A Chinese sentence or the path of a text file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Qin Wenfeng &lt;<a href="http://qinwenfeng.com">http://qinwenfeng.com</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
words = "hello world"
test1 = worker("keywords",topn=1)
test1 &lt;= words
## End(Not run)
</code></pre>

<hr>
<h2 id='+26lt+3B+3D.qseg'>Quick mode symbol</h2><span id='topic++3C+3D.qseg'></span><span id='topic++5B.qseg'></span><span id='topic+qseg'></span>

<h3>Description</h3>

<p>Depreciated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qseg'
qseg &lt;= code

## S3 method for class 'qseg'
qseg[code]

qseg
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B26lt+2B3B+2B3D.qseg_+3A_qseg">qseg</code></td>
<td>
<p>a qseg object</p>
</td></tr>
<tr><td><code id="+2B26lt+2B3B+2B3D.qseg_+3A_code">code</code></td>
<td>
<p>a string</p>
</td></tr>
</table>


<h3>Format</h3>

<p>qseg an environment</p>


<h3>Details</h3>

<p>Quick mode is depreciated, and is scheduled to be remove in v0.11.0. If you want to keep this feature, please submit a issue on GitHub page to let me know.
</p>
<p>Quick mode symbol to do segmentation, keyword extraction 
and speech tagging. This symbol will initialize a <code>quick_worker</code> 
when it is first called, and will do segmentation or other types of work 
immediately.
</p>
<p>You can reset the default model setting by <code>$</code>, and 
it will change the default setting the next time you use quick mode. 
If you only want to change the parameter temporarily, you can reset the 
settings of <code>quick_worker$</code>. <code><a href="#topic+get_qsegmodel">get_qsegmodel</a></code>, 
<code><a href="#topic+set_qsegmodel">set_qsegmodel</a></code>, and <code><a href="#topic+reset_qsegmodel">reset_qsegmodel</a></code>
are also available for setting quick mode settings.
</p>


<h3>Author(s)</h3>

<p>Qin Wenfeng &lt;<a href="http://qinwenfeng.com">http://qinwenfeng.com</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_qsegmodel">set_qsegmodel</a></code> <code><a href="#topic+worker">worker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
qseg &lt;= "This is test"
qseg &lt;= "This is the second test"

## End(Not run)

## Not run: 
qseg &lt;= "This is test"
qseg$detect = T
qseg
get_qsegmodel()

## End(Not run)

</code></pre>

<hr>
<h2 id='+26lt+3B+3D.segment'>Text segmentation symbol</h2><span id='topic++3C+3D.segment'></span><span id='topic++5B.segment'></span>

<h3>Description</h3>

<p>Text segmentation symbol to cut words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segment'
jiebar &lt;= code

## S3 method for class 'segment'
jiebar[code]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B26lt+2B3B+2B3D.segment_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR Worker.</p>
</td></tr>
<tr><td><code id="+2B26lt+2B3B+2B3D.segment_+3A_code">code</code></td>
<td>
<p>A Chinese sentence or the path of a text file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Qin Wenfeng &lt;<a href="http://qinwenfeng.com">http://qinwenfeng.com</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
words = "hello world"
test1 = worker()
test1 &lt;= words
## End(Not run)
</code></pre>

<hr>
<h2 id='+26lt+3B+3D.simhash'>Simhash symbol</h2><span id='topic++3C+3D.simhash'></span><span id='topic++5B.simhash'></span>

<h3>Description</h3>

<p>Simhash symbol to compute simhash.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simhash'
jiebar &lt;= code

## S3 method for class 'simhash'
jiebar[code]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B26lt+2B3B+2B3D.simhash_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR Worker.</p>
</td></tr>
<tr><td><code id="+2B26lt+2B3B+2B3D.simhash_+3A_code">code</code></td>
<td>
<p>A Chinese sentence or the path of a text file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Qin Wenfeng &lt;<a href="http://qinwenfeng.com">http://qinwenfeng.com</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
words = "hello world"
test1 = worker("simhash",topn=1)
test1 &lt;= words
## End(Not run)
</code></pre>

<hr>
<h2 id='+26lt+3B+3D.tagger'>Tagger symbol</h2><span id='topic++3C+3D.tagger'></span><span id='topic++5B.tagger'></span>

<h3>Description</h3>

<p>Tagger symbol to tag words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tagger'
jiebar &lt;= code

## S3 method for class 'tagger'
jiebar[code]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B26lt+2B3B+2B3D.tagger_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR Worker.</p>
</td></tr>
<tr><td><code id="+2B26lt+2B3B+2B3D.tagger_+3A_code">code</code></td>
<td>
<p>A Chinese sentence or the path of a text file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Qin Wenfeng &lt;<a href="http://qinwenfeng.com">http://qinwenfeng.com</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
words = "hello world"
test1 = worker("tag")
test1 &lt;= words
## End(Not run)
</code></pre>

<hr>
<h2 id='apply_list'>Apply list input to a worker</h2><span id='topic+apply_list'></span>

<h3>Description</h3>

<p>Apply list input to a worker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_list(input, worker)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_list_+3A_input">input</code></td>
<td>
<p>a list of characters</p>
</td></tr>
<tr><td><code id="apply_list_+3A_worker">worker</code></td>
<td>
<p>a worker</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cutter = worker()
apply_list(list("this is test", "that is not test"), cutter)
apply_list(list("this is test", list("that is not test","ab c")), cutter)
</code></pre>

<hr>
<h2 id='DICTPATH'>The path of dictionary</h2><span id='topic+DICTPATH'></span><span id='topic+HMMPATH'></span><span id='topic+USERPATH'></span><span id='topic+IDFPATH'></span><span id='topic+STOPPATH'></span>

<h3>Description</h3>

<p>The path of dictionary, and it is used by segmentation and other
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DICTPATH

HMMPATH

USERPATH

IDFPATH

STOPPATH
</code></pre>


<h3>Format</h3>

<p>character</p>

<hr>
<h2 id='distance'>Hamming distance of words</h2><span id='topic+distance'></span><span id='topic+vector_distance'></span>

<h3>Description</h3>

<p>This function uses Simhash worker to do keyword extraction and finds 
the keywords from two inputs, and then computes Hamming distance 
between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(codel, coder, jiebar)

vector_distance(codel, coder, jiebar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_+3A_codel">codel</code></td>
<td>
<p>For <code>distance</code>, a Chinese sentence or the path of a text file, 
For <code>vector_distance</code>, a character vector of segmented words.</p>
</td></tr>
<tr><td><code id="distance_+3A_coder">coder</code></td>
<td>
<p>For <code>distance</code>, a Chinese sentence or the path of a text file, 
For <code>vector_distance</code>, a character vector of segmented words.</p>
</td></tr>
<tr><td><code id="distance_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR worker</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Qin Wenfeng
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Hamming_distance">http://en.wikipedia.org/wiki/Hamming_distance</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+worker">worker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

words = "hello world"
simhasher = worker("simhash", topn = 1)
simhasher &lt;= words
distance("hello world" , "hello world!" , simhasher)

vector_distance(c("hello","world") , c("hello", "world","!") , simhasher)


## End(Not run)
</code></pre>

<hr>
<h2 id='edit_dict'>Edit default user dictionary</h2><span id='topic+edit_dict'></span>

<h3>Description</h3>

<p>Edit the default user dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edit_dict(name = "user")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edit_dict_+3A_name">name</code></td>
<td>
<p>the name of dictionary including <code>user</code>, <code>system</code>,
<code>stop_word</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three column in the system dictionary. Each column is seperated by space. 
The first column is the word, 
and the second column is the frequency of word. The third column is 
speech tag using labels compatible with ictclas.
</p>
<p>There are two column in the user dictionary. The first column is the word, 
and the second column is speech tag using labels compatible with ictclas.
Frequencies of words in the user dictionary is set by user_weight in <code>worker</code> function.
If you want to provide the frequency of a new word,
you can put it in the system dictionary.
</p>
<p>Only one column in the stop words dictionary, and it contains the stop words.
</p>


<h3>References</h3>

<p>The ictclas speech tag : <a href="http://t.cn/RAEj7e1">http://t.cn/RAEj7e1</a>
</p>

<hr>
<h2 id='file_coding'>Files encoding detection</h2><span id='topic+file_coding'></span><span id='topic+filecoding'></span>

<h3>Description</h3>

<p>This function detects the encoding of input files. 
You can also check encoding with checkenc package which is on GitHub.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_coding(file)

filecoding(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_coding_+3A_file">file</code></td>
<td>
<p>A file path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will choose the most likely encoding, and it will be 
more stable for a large input text file.
</p>


<h3>Value</h3>

<p>The encoding of file
</p>


<h3>Author(s)</h3>

<p>Wu Yongwei, Qin wenfeng
</p>


<h3>References</h3>

<p><a href="https://github.com/adah1972/tellenc">https://github.com/adah1972/tellenc</a>
</p>


<h3>See Also</h3>

<p><a href="https://github.com/qinwf/checkenc">https://github.com/qinwf/checkenc</a>
</p>

<hr>
<h2 id='filter_segment'>Filter segmentation result</h2><span id='topic+filter_segment'></span>

<h3>Description</h3>

<p>This function helps remove some words in the segmentation result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_segment(input, filter_words, unit = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_segment_+3A_input">input</code></td>
<td>
<p>a string vector</p>
</td></tr>
<tr><td><code id="filter_segment_+3A_filter_words">filter_words</code></td>
<td>
<p>a string vector of words to be removed.</p>
</td></tr>
<tr><td><code id="filter_segment_+3A_unit">unit</code></td>
<td>
<p>the length of word unit to use in regular expression, 
and the default is 50. Long list of a words forms a big regular expressions,
it may or may not be accepted: the POSIX standard only requires up to 256 
bytes. So we use unit to split the words in units.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>filter_segment(c("abc","def"," ","."), c("abc"))
</code></pre>

<hr>
<h2 id='freq'>The frequency of words</h2><span id='topic+freq'></span>

<h3>Description</h3>

<p>This function returns the frequency of words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freq_+3A_x">x</code></td>
<td>
<p>a vector of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The frequency of words
</p>


<h3>Author(s)</h3>

<p>Qin wenfeng
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freq(c("a","a","c"))
</code></pre>

<hr>
<h2 id='get_idf'>generate IDF dict</h2><span id='topic+get_idf'></span>

<h3>Description</h3>

<p>Generate IDF dict from a list of documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_idf(x, stop_word = STOPPATH, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_idf_+3A_x">x</code></td>
<td>
<p>a list of character</p>
</td></tr>
<tr><td><code id="get_idf_+3A_stop_word">stop_word</code></td>
<td>
<p>stopword path</p>
</td></tr>
<tr><td><code id="get_idf_+3A_path">path</code></td>
<td>
<p>output path</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input list contains multiple character vectors with words, 
and each vector represents a document.
</p>
<p>Stop words will be removed from the result.
</p>
<p>If path is not NULL, it will write the result to the path.
</p>


<h3>Value</h3>

<p>a data.frame or a file
</p>


<h3>See Also</h3>

<p>https://en.wikipedia.org/wiki/Tf-idf#Inverse_document_frequency_2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_idf(list(c("abc","def"),c("abc"," ")))
</code></pre>

<hr>
<h2 id='get_qsegmodel'>Set quick mode model</h2><span id='topic+get_qsegmodel'></span><span id='topic+set_qsegmodel'></span><span id='topic+reset_qsegmodel'></span>

<h3>Description</h3>

<p>Depreciated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_qsegmodel()

set_qsegmodel(qsegmodel)

reset_qsegmodel()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_qsegmodel_+3A_qsegmodel">qsegmodel</code></td>
<td>
<p>a list which has the same structure as the return value of get_qsegmodel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These function can get and modify quick mode model. <code>get_qsegmodel</code> returns
the default model parameters. <code>set_qsegmodel</code> can modify quick mode model 
using a list, which has the same structure as the return value of get_qsegmodel.
<code>reset_qsegmodel</code> can reset the default model to origin <code>jiebaR</code> default
model.
</p>


<h3>Author(s)</h3>

<p>Qin Wenfeng &lt;<a href="http://qinwenfeng.com">http://qinwenfeng.com</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qseg">qseg</a></code> <code><a href="#topic+worker">worker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
qseg &lt;= "This is test"
qseg &lt;= "This is the second test"

## End(Not run)

## Not run: 
qseg &lt;= "This is test"
qseg$detect = T
qseg
get_qsegmodel()
model = get_qsegmodel()
model$detect = F
set_qsegmodel(model)
reset_qsegmodel()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_tuple'>get tuple from the segmentation result</h2><span id='topic+get_tuple'></span>

<h3>Description</h3>

<p>get tuple from the segmentation result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tuple(x, size = 2, dataframe = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_tuple_+3A_x">x</code></td>
<td>
<p>a character vector or list</p>
</td></tr>
<tr><td><code id="get_tuple_+3A_size">size</code></td>
<td>
<p>a integer &gt;= 2</p>
</td></tr>
<tr><td><code id="get_tuple_+3A_dataframe">dataframe</code></td>
<td>
<p>return data.frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>get_tuple(c("sd","sd","sd","rd"),2)
</code></pre>

<hr>
<h2 id='keywords'>Keyword extraction</h2><span id='topic+keywords'></span><span id='topic+vector_keywords'></span>

<h3>Description</h3>

<p>Keyword Extraction worker uses MixSegment model to cut word and uses 
TF-IDF algorithm to find the keywords.  <code>dict</code> , <code>hmm</code>, 
<code>idf</code>, <code>stop_word</code> and <code>topn</code> should be provided when initializing 
jiebaR worker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keywords(code, jiebar)

vector_keywords(code, jiebar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keywords_+3A_code">code</code></td>
<td>
<p>For <code>keywords</code>, a Chinese sentence or the path of a text file. 
For <code>vector_keywords</code>, a character vector of segmented words.</p>
</td></tr>
<tr><td><code id="keywords_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR Worker.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is a symbol <code>&lt;=</code> for this function.
</p>


<h3>Value</h3>

<p>a vector of keywords with weight.
</p>


<h3>Author(s)</h3>

<p>Qin Wenfeng
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Tf-idf">http://en.wikipedia.org/wiki/Tf-idf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic++3C+3D.keywords">&lt;=.keywords</a></code> <code><a href="#topic+worker">worker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Keyword Extraction
keys = worker("keywords", topn = 1)
keys &lt;= "words of fun"
## End(Not run)
</code></pre>

<hr>
<h2 id='new_user_word'>Add user word</h2><span id='topic+new_user_word'></span>

<h3>Description</h3>

<p>Add user word
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_user_word(worker, words, tags = rep("n", length(words)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_user_word_+3A_worker">worker</code></td>
<td>
<p>a jieba worker</p>
</td></tr>
<tr><td><code id="new_user_word_+3A_words">words</code></td>
<td>
<p>the new words</p>
</td></tr>
<tr><td><code id="new_user_word_+3A_tags">tags</code></td>
<td>
<p>the new words tags, default &quot;n&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cc = worker()
new_user_word(cc, "test")
new_user_word(cc, "do", "v")
</code></pre>

<hr>
<h2 id='print.inv'>Print worker settings</h2><span id='topic+print.inv'></span><span id='topic+print.jieba'></span><span id='topic+print.simhash'></span><span id='topic+print.keywords'></span><span id='topic+print.qseg'></span>

<h3>Description</h3>

<p>These functoins print the worker settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inv'
print(x, ...)

## S3 method for class 'jieba'
print(x, ...)

## S3 method for class 'simhash'
print(x, ...)

## S3 method for class 'keywords'
print(x, ...)

## S3 method for class 'qseg'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.inv_+3A_x">x</code></td>
<td>
<p>The jiebaR Worker.</p>
</td></tr>
<tr><td><code id="print.inv_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Qin Wenfeng
</p>

<hr>
<h2 id='segment'>Chinese text segmentation function</h2><span id='topic+segment'></span>

<h3>Description</h3>

<p>The function uses initialized engines for words segmentation. You 
can initialize multiple engines simultaneously using <code>worker()</code>.
Public settings of workers can be got and modified using <code>$</code>, 
such as <code> WorkerName$symbol = T </code>. Some private settings are fixed 
when engine is initialized, and you can get then by 
<code>WorkerName$PrivateVarible</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment(code, jiebar, mod = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment_+3A_code">code</code></td>
<td>
<p>A Chinese sentence or the path of a text file.</p>
</td></tr>
<tr><td><code id="segment_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR Worker.</p>
</td></tr>
<tr><td><code id="segment_+3A_mod">mod</code></td>
<td>
<p>change default result type, value can be &quot;mix&quot;,&quot;hmm&quot;,&quot;query&quot;,&quot;full&quot; or &quot;mp&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are four kinds of models:
</p>
<p>Maximum probability segmentation model uses Trie tree to construct
a directed acyclic graph and uses dynamic programming algorithm. It
is the core segmentation algorithm. <code>dict</code> and <code>user</code>
should be provided when initializing jiebaR worker.
</p>
<p>Hidden Markov Model uses HMM model to determine status set and 
observed set of words. The default HMM model is based on People's Daily 
language library. <code>hmm</code> should be provided when initializing 
jiebaR worker.
</p>
<p>MixSegment model uses both Maximum probability segmentation model 
and Hidden Markov Model to construct segmentation.  <code>dict</code>, 
<code>hmm</code> and <code>user</code> should be provided when initializing 
jiebaR worker.
</p>
<p>QuerySegment model uses MixSegment to construct segmentation and then 
enumerates all the possible long words in the dictionary.  <code>dict</code>, 
<code>hmm</code> and <code>qmax</code> should be provided when initializing 
jiebaR worker.
</p>
<p>There is a symbol <code>&lt;=</code> for this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++3C+3D.segment">&lt;=.segment</a></code> <code><a href="#topic+worker">worker</a></code>
</p>

<hr>
<h2 id='show_dictpath'>Show default path of dictionaries</h2><span id='topic+show_dictpath'></span>

<h3>Description</h3>

<p>Show the default dictionaries' path. <code>HMMPATH</code>, <code>DICTPATH</code>
, <code>IDFPATH</code>, <code>STOPPATH</code> and <code>USERPATH</code> can be changed 
in default environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_dictpath()
</code></pre>


<h3>Author(s)</h3>

<p>Qin Wenfeng
</p>

<hr>
<h2 id='simhash'>Simhash computation</h2><span id='topic+simhash'></span><span id='topic+vector_simhash'></span>

<h3>Description</h3>

<p>Simhash worker uses the keyword extraction worker to find the keywords
and uses simhash algorithm to compute simhash.  <code>dict</code> 
<code>hmm</code>, <code>idf</code> and <code>stop_word</code> should be provided when initializing 
jiebaR worker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simhash(code, jiebar)

vector_simhash(code, jiebar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simhash_+3A_code">code</code></td>
<td>
<p>For <code>simhash</code>, a Chinese sentence or the path of a text file.
For <code>vector_simhash</code>, a character vector of segmented words.</p>
</td></tr>
<tr><td><code id="simhash_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR Worker.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is a symbol <code>&lt;=</code> for this function.
</p>


<h3>Author(s)</h3>

<p>Qin Wenfeng
</p>


<h3>References</h3>

<p>MS Charikar - Similarity Estimation Techniques from Rounding Algorithms
</p>


<h3>See Also</h3>

<p><code><a href="#topic++3C+3D.simhash">&lt;=.simhash</a></code> <code><a href="#topic+worker">worker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Simhash
words = "hello world"
simhasher = worker("simhash",topn=1)
simhasher &lt;= words
distance("hello world" , "hello world!" , simhasher)

## End(Not run)
</code></pre>

<hr>
<h2 id='simhash_dist'>Compute Hamming distance of Simhash value</h2><span id='topic+simhash_dist'></span><span id='topic+simhash_dist_mat'></span>

<h3>Description</h3>

<p>Compute Hamming distance of Simhash value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simhash_dist(x, y)

simhash_dist_mat(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simhash_dist_+3A_x">x</code></td>
<td>
<p>a character vector of simhash value</p>
</td></tr>
<tr><td><code id="simhash_dist_+3A_y">y</code></td>
<td>
<p>a character vector of simhash value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simhash_dist("1","1")
simhash_dist("1","2")
tobin("1")
tobin("2")
simhash_dist_mat(c("1","12","123"),c("2","1"))
</code></pre>

<hr>
<h2 id='tagging'>Speech Tagging</h2><span id='topic+tagging'></span>

<h3>Description</h3>

<p>The function uses Speech Tagging worker to cut word and 
tags each word after segmentation using labels compatible with 
ictclas.  <code>dict</code> 
<code>hmm</code> and <code>user</code> should be provided when initializing 
jiebaR worker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tagging(code, jiebar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tagging_+3A_code">code</code></td>
<td>
<p>a Chinese sentence or the path of a text file</p>
</td></tr>
<tr><td><code id="tagging_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR Worker</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is a symbol <code>&lt;=</code> for this function.
</p>


<h3>Author(s)</h3>

<p>Qin Wenfeng
</p>


<h3>References</h3>

<p>The ictclas speech tag : <a href="http://t.cn/RAEj7e1">http://t.cn/RAEj7e1</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic++3C+3D.tagger">&lt;=.tagger</a></code> <code><a href="#topic+worker">worker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
words = "hello world"

### Speech Tagging 
tagger = worker("tag")
tagger &lt;= words

## End(Not run)
</code></pre>

<hr>
<h2 id='tobin'>simhash value to binary</h2><span id='topic+tobin'></span>

<h3>Description</h3>

<p>simhash value to binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tobin(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tobin_+3A_x">x</code></td>
<td>
<p>simhash value</p>
</td></tr>
</table>

<hr>
<h2 id='vector_tag'>Tag the a character vector</h2><span id='topic+vector_tag'></span>

<h3>Description</h3>

<p>Tag the a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_tag(string, jiebar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector_tag_+3A_string">string</code></td>
<td>
<p>a character vector of segmented words.</p>
</td></tr>
<tr><td><code id="vector_tag_+3A_jiebar">jiebar</code></td>
<td>
<p>jiebaR Worker.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cc = worker()
(res = cc["this is test"])
vector_tag(res, cc)

## End(Not run)

</code></pre>

<hr>
<h2 id='worker'>Initialize jiebaR worker</h2><span id='topic+worker'></span>

<h3>Description</h3>

<p>This function can initialize jiebaR workers. You can initialize different
kinds of workers including <code>mix</code>, <code>mp</code>, <code>hmm</code>,
<code>query</code>, <code>full</code>, <code>tag</code>, <code>simhash</code>, and <code>keywords</code>.
see Detail for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worker(type = "mix", dict = DICTPATH, hmm = HMMPATH,
  user = USERPATH, idf = IDFPATH, stop_word = STOPPATH, write = T,
  qmax = 20, topn = 5, encoding = "UTF-8", detect = T,
  symbol = F, lines = 1e+05, output = NULL, bylines = F,
  user_weight = "max")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="worker_+3A_type">type</code></td>
<td>
<p>The type of jiebaR workers including <code>mix</code>, <code>mp</code>, <code>hmm</code>, <code>full</code>,
<code>query</code>, <code>tag</code>, <code>simhash</code>, and <code>keywords</code>.</p>
</td></tr>
<tr><td><code id="worker_+3A_dict">dict</code></td>
<td>
<p>A path to main dictionary, default value is <code>DICTPATH</code>,
and the value is used for <code>mix</code>, <code>mp</code>, <code>query</code>, <code>full</code>,
<code>tag</code>, <code>simhash</code> and <code>keywords</code> workers.</p>
</td></tr>
<tr><td><code id="worker_+3A_hmm">hmm</code></td>
<td>
<p>A path to Hidden Markov Model, default value is <code>HMMPATH</code>, <code>full</code>,
and the value is used for <code>mix</code>, <code>hmm</code>, <code>query</code>,
<code>tag</code>, <code>simhash</code> and <code>keywords</code> workers.</p>
</td></tr>
<tr><td><code id="worker_+3A_user">user</code></td>
<td>
<p>A path to user dictionary, default value is <code>USERPATH</code>,
and the value is used for <code>mix</code>, <code>full</code>,  <code>tag</code> and <code>mp</code>  workers.</p>
</td></tr>
<tr><td><code id="worker_+3A_idf">idf</code></td>
<td>
<p>A path to inverse document frequency, default value is <code>IDFPATH</code>,
and the value is used for <code>simhash</code> and <code>keywords</code> workers.</p>
</td></tr>
<tr><td><code id="worker_+3A_stop_word">stop_word</code></td>
<td>
<p>A path to stop word dictionary, default value is <code>STOPPATH</code>,
and the value is used for <code>simhash</code>, <code>keywords</code>, <code>tagger</code> and <code>segment</code> workers. Encoding of this file is checked by <code>file_coding</code>, and it should be UTF-8 encoding. For <code>segment</code> workers, the default <code>STOPPATH</code> will not be used, so you should provide another file path.</p>
</td></tr>
<tr><td><code id="worker_+3A_write">write</code></td>
<td>
<p>Whether to write the output to a file, or return
a the result in a object. This value will only be used when
the input is a file path. The default value is TRUE. The value
is used for segment and speech tagging workers.</p>
</td></tr>
<tr><td><code id="worker_+3A_qmax">qmax</code></td>
<td>
<p>Max query length of words, and the value
is used for <code>query</code> workers.</p>
</td></tr>
<tr><td><code id="worker_+3A_topn">topn</code></td>
<td>
<p>The number of keywords, and the value is used for
<code>simhash</code> and <code>keywords</code> workers.</p>
</td></tr>
<tr><td><code id="worker_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the input file. If encoding
detection is enable, the value of <code>encoding</code> will be
ignore.</p>
</td></tr>
<tr><td><code id="worker_+3A_detect">detect</code></td>
<td>
<p>Whether to detect the encoding of input file
using <code>file_coding</code> function. If encoding
detection is enable, the value of <code>encoding</code> will be
ignore.</p>
</td></tr>
<tr><td><code id="worker_+3A_symbol">symbol</code></td>
<td>
<p>Whether to keep symbols in the sentence.</p>
</td></tr>
<tr><td><code id="worker_+3A_lines">lines</code></td>
<td>
<p>The maximal number of lines to read at one
time when input is a file. The value
is used for segmentation and speech tagging  workers.</p>
</td></tr>
<tr><td><code id="worker_+3A_output">output</code></td>
<td>
<p>A path to the output file, and default worker will
generate file name by system time stamp, the value
is used for segmentation and speech tagging  workers.</p>
</td></tr>
<tr><td><code id="worker_+3A_bylines">bylines</code></td>
<td>
<p>return the result by the lines of input files</p>
</td></tr>
<tr><td><code id="worker_+3A_user_weight">user_weight</code></td>
<td>
<p>the weight of the user dict words. &quot;min&quot; &quot;max&quot; or &quot;median&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package uses initialized engines for word segmentation, and you
can initialize multiple engines simultaneously. You can also reset the model
public settings using <code>$</code> such as
<code> WorkerName$symbol = T </code>. Some private settings are fixed
when a engine is initialized, and you can get then by
<code>WorkerName$PrivateVarible</code>.
</p>
<p>Maximum probability segmentation model uses Trie tree to construct
a directed acyclic graph and uses dynamic programming algorithm. It
is the core segmentation algorithm. <code>dict</code> and <code>user</code>
should be provided when initializing jiebaR worker.
</p>
<p>Hidden Markov Model uses HMM model to determine status set and
observed set of words. The default HMM model is based on People's Daily
language library. <code>hmm</code> should be provided when initializing
jiebaR worker.
</p>
<p>MixSegment model uses both Maximum probability segmentation model
and Hidden Markov Model to construct segmentation.  <code>dict</code>
<code>hmm</code> and <code>user</code> should be provided when initializing
jiebaR worker.
</p>
<p>QuerySegment model uses MixSegment to construct segmentation and then
enumerates all the possible long words in the dictionary.  <code>dict</code>,
<code>hmm</code> and <code>qmax</code> should be provided when initializing
jiebaR worker.
</p>
<p>FullSegment model will enumerates all the possible words in the dictionary.
</p>
<p>Speech Tagging worker uses MixSegment model to cut word and
tag each word after segmentation using labels compatible with
ictclas.  <code>dict</code>,
<code>hmm</code> and <code>user</code> should be provided when initializing
jiebaR worker.
</p>
<p>Keyword Extraction worker uses MixSegment model to cut word and use
TF-IDF algorithm to find the keywords.  <code>dict</code> ,<code>hmm</code>,
<code>idf</code>, <code>stop_word</code> and <code>topn</code> should be provided when initializing
jiebaR worker.
</p>
<p>Simhash worker uses the keyword extraction worker to find the keywords
and uses simhash algorithm to compute simhash.  <code>dict</code>
<code>hmm</code>, <code>idf</code> and <code>stop_word</code> should be provided when initializing
jiebaR worker.
</p>


<h3>Value</h3>

<p>This function returns an environment containing segmentation
settings and worker. Public settings can be modified
using <code>$</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Note: Can not display Chinese characters here.
## Not run: 
words = "hello world"
engine1 = worker()
segment(words, engine1)

# "./temp.txt" is a file path

segment("./temp.txt", engine1)

engine2 = worker("hmm")
segment("./temp.txt", engine2)

engine2$write = T
segment("./temp.txt", engine2)

engine3 = worker(type = "mix", dict = "dict_path",symbol = T)
segment("./temp.txt", engine3)
 
## End(Not run)

## Not run: 
### Keyword Extraction
engine = worker("keywords", topn = 1)
keywords(words, engine)

### Speech Tagging
tagger = worker("tag")
tagging(words, tagger)

### Simhash
simhasher = worker("simhash", topn = 1)
simhash(words, simhasher)
distance("hello world" , "hello world!" , simhasher)

show_dictpath()

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
