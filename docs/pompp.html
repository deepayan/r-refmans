<!DOCTYPE html><html lang="en"><head><title>Help for package pompp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pompp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BetaDeltaPrior-class'><p>Generic class for the beta and delta parameters.</p></a></li>
<li><a href='#covariates_importance-class'><p>Class for covariates importance matrices</p></a></li>
<li><a href='#fit_pompp'><p>Fit presence-only data using the Presence-Only for Marked Point Process model</p></a></li>
<li><a href='#GammaPrior'><p>Create a Gamma prior object for model specification.</p></a></li>
<li><a href='#GammaPrior-class'><p>Gamma prior class for the LambdaStar parameter.</p></a></li>
<li><a href='#initial'><p>Initial values constructor for pompp modeling</p></a></li>
<li><a href='#LambdaStarPrior-class'><p>Generic class for the LambdaStar parameters.</p></a></li>
<li><a href='#NormalPrior'><p>Create a Normal prior object for model specification.</p></a></li>
<li><a href='#NormalPrior-class'><p>Normal prior class for Beta and Delta parameters.</p></a></li>
<li><a href='#pompp_fit-class'><p>Class for the result of the MCMC procedure.</p></a></li>
<li><a href='#pompp_initial-class'><p>Class for the initial values for the MCMC for the pompp package</p></a></li>
<li><a href='#pompp_model'><p>Build a model to be used in the <code>pompp</code> fitting function</p></a></li>
<li><a href='#pompp_model-class'><p>Class that defines a model for the pompp package.</p></a></li>
<li><a href='#pompp_prior-class'><p>Joint prior class for the pompp package parameters</p></a></li>
<li><a href='#prior'><p>Build a joint prior for pompp model parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Presence-Only for Marked Point Process</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Inspired by Moreira and Gamerman (2022) &lt;<a href="https://doi.org/10.1214%2F21-AOAS1569">doi:10.1214/21-AOAS1569</a>&gt;,
    this methodology expands the idea by including Marks in the point process.
    Using efficient 'C++' code, the estimation is possible and made faster with
    'OpenMP' <a href="https://www.openmp.org/">https://www.openmp.org/</a> enabled computers. This package was
    developed under the project PTDC/MAT-STA/28243/2017, supported by
    Portuguese funds through the Portuguese Foundation for Science and
    Technology (FCT).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, RcppProgress</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, coda, geoR, parallel, methods, graphics, stats, tools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bayesplot, ggplot2, MASS</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'covariance_importance.R' 'prior-class.R'
'initial-class.R' 'model-class.R' 'fit-class.R'
'pompp-package.R' 'pompp.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-12 17:11:54 UTC; anthorg</td>
</tr>
<tr>
<td>Author:</td>
<td>Guido Alberti Moreira
    <a href="https://orcid.org/0000-0001-7557-0874"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guido Alberti Moreira &lt;guidoalber@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-12 23:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='BetaDeltaPrior-class'>Generic class for the beta and delta parameters.</h2><span id='topic+BetaDeltaPrior-class'></span><span id='topic+show+2CBetaDeltaPrior-method'></span><span id='topic+print+2CBetaDeltaPrior-method'></span><span id='topic+print.BetaDeltaPrior'></span>

<h3>Description</h3>

<p>Generic class for the beta and delta parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BetaDeltaPrior'
show(object)

## S4 method for signature 'BetaDeltaPrior'
print(x, ...)

## S3 method for class 'BetaDeltaPrior'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BetaDeltaPrior-class_+3A_object">object</code></td>
<td>
<p>The BetaDeltaPrior object.</p>
</td></tr>
<tr><td><code id="BetaDeltaPrior-class_+3A_x">x</code></td>
<td>
<p>The BetaDeltaPrior object.</p>
</td></tr>
<tr><td><code id="BetaDeltaPrior-class_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong><code>show</code></strong> and <strong><code>print</code></strong>: The invisible object.
</p>


<h3>Fields</h3>


<dl>
<dt><code>family</code></dt><dd><p>The family of distributions of the prior.</p>
</dd>
</dl>

<hr>
<h2 id='covariates_importance-class'>Class for covariates importance matrices</h2><span id='topic+covariates_importance-class'></span><span id='topic+print.covariates_importance'></span><span id='topic+plot.covariates_importance'></span><span id='topic+barplot.covariates_importance'></span><span id='topic+boxplot.covariates_importance'></span>

<h3>Description</h3>

<p>Objects of this class is the output of the &quot;covariates_importance&quot; object
from the <code><a href="#topic+pompp_fit-class">pompp_fit-class</a></code>. It can be plotted which uses
the <code><a href="graphics.html#topic+graphics">graphics</a></code> package. The <code>print</code> method
gives a point-wise estimation, the same seen in the <code>bacplot</code> method.
Both <code>plot</code> and <code>boxplot</code> methods use the posterior distribution
of the importance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covariates_importance'
print(x, component = "intensity", ...)

## S3 method for class 'covariates_importance'
plot(
  x,
  component = "intensity",
  y = "importance",
  quantiles = c(0.025, 0.5, 0.975),
  ...
)

## S3 method for class 'covariates_importance'
barplot(height, component = "intensity", y, ...)

## S3 method for class 'covariates_importance'
boxplot(x, component = "intensity", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covariates_importance-class_+3A_x">x</code></td>
<td>
<p>The <code>covariates_importance</code> object.</p>
</td></tr>
<tr><td><code id="covariates_importance-class_+3A_component">component</code></td>
<td>
<p>Either <code>"intensity"</code>, <code>"observability"</code> or
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="covariates_importance-class_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
<tr><td><code id="covariates_importance-class_+3A_y">y</code></td>
<td>
<p>Either <code>"interval"</code> or <code>"density"</code>. The formal gives
vertical credible intervals, and the latter gives separate density plots
with the specified quantiles as vertical lines.</p>
</td></tr>
<tr><td><code id="covariates_importance-class_+3A_quantiles">quantiles</code></td>
<td>
<p>A 2- or 3-simensional vector with the desired quantiles
specified. If 3-dimensiona, the middle point is drawn as a dot when the
<code>y</code> parameter is set as <code>"interval"</code>.</p>
</td></tr>
<tr><td><code id="covariates_importance-class_+3A_height">height</code></td>
<td>
<p>The <code>covariates_importance</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of this class have two matrices where the Monte Carlo samples on the
rows and parameters on the columns. One matrix is for the intensity
importance and the other for the observability importance.
</p>


<h3>Value</h3>

<p>The invisible object.
</p>
<p>Nothing is returned. Plot is called and drawn on the configured
device.
</p>
<p>A barplot. See <code>barplot</code> for details. If component is selected
as <code>"both"</code>, only the second barplot is returned.
</p>
<p>A boxplot. See <code>boxplot</code> for details. If component is selected
as <code>"both"</code>, only the second boxplot is returned.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+barplot">barplot</a></code>.
</p>
<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>.
</p>

<hr>
<h2 id='fit_pompp'>Fit presence-only data using the Presence-Only for Marked Point Process model</h2><span id='topic+fit_pompp'></span><span id='topic+fit_pompp+2Cpompp_model+2Cmatrix-method'></span><span id='topic+checkFormatBackground'></span>

<h3>Description</h3>

<p>The model uses a data augmentation scheme to avoid performing approximations
on the likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_pompp(
  object,
  background,
  mcmc_setup = list(iter = 5000),
  verbose = TRUE,
  ...
)

## S4 method for signature 'pompp_model,matrix'
fit_pompp(
  object,
  background,
  neighborhoodSize = 20,
  mcmc_setup,
  verbose = TRUE,
  area = 1,
  cores = parallel::detectCores(),
  ...
)

checkFormatBackground(object, background)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_pompp_+3A_object">object</code></td>
<td>
<p>Either a <code>pompp_model</code> or <code>pompp_fit</code> object. If
a model, then the model is fit according to specifications. If a fit,
then the model used to fit the model is recovered and used to continue
the MCMC calculations where the previous one left off.</p>
</td></tr>
<tr><td><code id="fit_pompp_+3A_background">background</code></td>
<td>
<p>A matrix where the rows are the grid cells for the studied
region and the columns are the covariates. <code>NA</code>s must be removed. If
the function is being used on a <code>pompp_fit</code> object, the background
must be exactly the same as the one used in the original fit.</p>
</td></tr>
<tr><td><code id="fit_pompp_+3A_mcmc_setup">mcmc_setup</code></td>
<td>
<p>A list containing <code>iter</code> to inform the model how
many iterations are to be run. The list may optionally contain the objects.</p>
</td></tr>
<tr><td><code id="fit_pompp_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>FALSE</code> to suppress all messages to console.</p>
</td></tr>
<tr><td><code id="fit_pompp_+3A_...">...</code></td>
<td>
<p>Parameters passed on to specific methods.
<code>burnin</code> and <code>thin</code> to inform these instructions as well.</p>
</td></tr>
<tr><td><code id="fit_pompp_+3A_neighborhoodsize">neighborhoodSize</code></td>
<td>
<p>Number of neighbors to use in the NNGP method.</p>
</td></tr>
<tr><td><code id="fit_pompp_+3A_area">area</code></td>
<td>
<p>A positive number with the studied region's area.</p>
</td></tr>
<tr><td><code id="fit_pompp_+3A_cores">cores</code></td>
<td>
<p>Number of cores to pass to OpenMP.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The background is kept outside of the
</p>


<h3>Value</h3>

<p>An object of class <code>"pompp_fit"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pompp_model">pompp_model</a></code> and <code><a href="#topic+pompp_fit-class">pompp_fit-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
beta &lt;- c(-1, 2) # Intercept = -1. Only one covariate
delta &lt;- c(3, 4) # Intercept = 3. Only one covariate
lambdaStar &lt;- 1000
gamma &lt;- 2
mu &lt;- 5

total_points &lt;- rpois(1, lambdaStar)
random_points &lt;- cbind(runif(total_points), runif(total_points))
grid_size &lt;- 50

# Find covariate values to explain the species occurrence.
# We give them a Gaussian spatial structure.
reg_grid &lt;- as.matrix(expand.grid(seq(0, 1, len = grid_size), seq(0, 1, len = grid_size)))
Z &lt;- MASS::mvrnorm(1, rep(0, total_points + grid_size * grid_size),
  3 * exp(-as.matrix(dist(rbind(random_points, reg_grid))) / 0.2))
Z1 &lt;- Z[1:total_points]; Z2 &lt;- Z[-(1:total_points)]

# Thin the points by comparing the retaining probabilities with uniforms
# in the log scale to find the occurrences
occurrences &lt;- log(runif(total_points)) &lt;= -log1p(exp(-beta[1] - beta[2] * Z1))
n_occurrences &lt;- sum(occurrences)
occurrences_points &lt;- random_points[occurrences,]
occurrences_Z &lt;- Z1[occurrences]

# Find covariate values to explain the observation bias.
# Additionally create a regular grid to plot the covariate later.
W &lt;- MASS::mvrnorm(1, rep(0, n_occurrences + grid_size * grid_size),
  2 * exp(-as.matrix(dist(rbind(occurrences_points, reg_grid))) / 0.3))
W1 &lt;- W[1:n_occurrences]; W2 &lt;- W[-(1:n_occurrences)]
S &lt;- MASS::mvrnorm(1, rep(0, n_occurrences),
  2 * exp(-as.matrix(dist(occurrences_points)) / 0.3))

# Find the presence-only observations.
marks &lt;- exp(mu + S + rnorm(n_occurrences, 0, 0.3))
po_sightings &lt;- log(runif(n_occurrences)) &lt;= -log1p(exp(-delta[1] - delta[2] * W1 - gamma * S))
n_po &lt;- sum(po_sightings)
po_points &lt;- occurrences_points[po_sightings, ]
po_Z &lt;- occurrences_Z[po_sightings]
po_W &lt;- W1[po_sightings]
po_marks &lt;- marks[po_sightings]

jointPrior &lt;- prior(
  NormalPrior(rep(0, 2), 10 * diag(2)), # Beta
NormalPrior(rep(0, 3), 10 * diag(3)), # Delta
GammaPrior(0.00001, 0.00001), # LambdaStar
NormalPrior(0, 100), GammaPrior(0.001, 0.001) # Marks
)

model &lt;- pompp_model(po = cbind(po_Z, po_W, po_points, po_marks),
intensitySelection = 1, observabilitySelection = 2, marksSelection = 5,
                    coordinates = 3:4,
                    intensityLink = "logit", observabilityLink = "logit",
                    initial_values = 2, joint_prior = jointPrior)

bkg &lt;- cbind(Z2, W2, reg_grid) # Create background

# Be prepared to wait a long time for this
fit &lt;- fit_pompp(model, bkg, neighborhoodSize = 20, area = 1,
  mcmc_setup = list(burnin = 1000, iter = 2000), cores = 1)

summary(fit)

# Rhat upper CI values are above 1.1. More iterations are needed...

</code></pre>

<hr>
<h2 id='GammaPrior'>Create a Gamma prior object for model specification.</h2><span id='topic+GammaPrior'></span>

<h3>Description</h3>

<p>Constructor for <code>GammaPrior-class</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GammaPrior(shape, rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GammaPrior_+3A_shape">shape</code></td>
<td>
<p>A positive number.</p>
</td></tr>
<tr><td><code id="GammaPrior_+3A_rate">rate</code></td>
<td>
<p>A positive number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GammaPrior</code> object with adequate slots.
</p>

<hr>
<h2 id='GammaPrior-class'>Gamma prior class for the LambdaStar parameter.</h2><span id='topic+GammaPrior-class'></span><span id='topic+names+2CGammaPrior-method'></span><span id='topic++24+2CGammaPrior-method'></span><span id='topic++24+3C-+2CGammaPrior-method'></span><span id='topic+show+2CGammaPrior-method'></span><span id='topic+print+2CGammaPrior-method'></span><span id='topic+print.GammaPrior'></span>

<h3>Description</h3>

<p>This is used to represent the prior for lambdaStar individually. It
still needs to be joined with the prior for Beta and Delta to be used
in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GammaPrior'
names(x)

## S4 method for signature 'GammaPrior'
x$name

## S4 replacement method for signature 'GammaPrior'
x$name &lt;- value

## S4 method for signature 'GammaPrior'
show(object)

## S4 method for signature 'GammaPrior'
print(x, ...)

## S3 method for class 'GammaPrior'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GammaPrior-class_+3A_x">x</code></td>
<td>
<p>The GammaPrior object.</p>
</td></tr>
<tr><td><code id="GammaPrior-class_+3A_name">name</code></td>
<td>
<p>The requested slot.</p>
</td></tr>
<tr><td><code id="GammaPrior-class_+3A_value">value</code></td>
<td>
<p>New value.</p>
</td></tr>
<tr><td><code id="GammaPrior-class_+3A_object">object</code></td>
<td>
<p>The GammaPrior object.</p>
</td></tr>
<tr><td><code id="GammaPrior-class_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong><code>names</code></strong>: A character vector with the prior parameters.
</p>
<p><strong><code>`$`</code></strong> The requested slot's value.
</p>
<p><strong><code>`$&lt;-`</code></strong>: The new object with the updated slot.
</p>
<p><strong><code>show</code></strong> and <strong><code>print</code></strong>: The invisible object.
</p>


<h3>Fields</h3>


<dl>
<dt><code>shape</code></dt><dd><p>The shape parameter of the Gamma distribution.</p>
</dd>
<dt><code>rate</code></dt><dd><p>The rate parameter of the Gamma distribution.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+prior">prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GammaPrior(0.0001, 0.0001)
</code></pre>

<hr>
<h2 id='initial'>Initial values constructor for pompp modeling</h2><span id='topic+initial'></span>

<h3>Description</h3>

<p>Helper function to create a valid set of initial values to be used with the
fit_pompp function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial(
  beta = numeric(),
  delta = numeric(),
  lambdaStar = numeric(),
  marksMean = numeric(),
  marksPrecision = numeric(),
  random = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initial_+3A_beta">beta</code></td>
<td>
<p>Either a vector or a single integer. The vector is used if the
initial values are provided and the integer is used as the vector size to
be randomly generated.</p>
</td></tr>
<tr><td><code id="initial_+3A_delta">delta</code></td>
<td>
<p>Either a vector or a single integer. The vector is used if the
initial values are provided and the integer is used as the vector size to
be randomly generated.</p>
</td></tr>
<tr><td><code id="initial_+3A_lambdastar">lambdaStar</code></td>
<td>
<p>A positive number.</p>
</td></tr>
<tr><td><code id="initial_+3A_marksmean">marksMean</code></td>
<td>
<p>Any real number. If random, defines the mean of the random
value.</p>
</td></tr>
<tr><td><code id="initial_+3A_marksprecision">marksPrecision</code></td>
<td>
<p>A positive number. If random, defines the mean of the
random value.</p>
</td></tr>
<tr><td><code id="initial_+3A_random">random</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, then the initial values are
generated from standard normal distribution for <code>beta</code> and <code>delta</code>
and from a <code>Beta(lambdaStar, 1)</code> for <code>lambdaStar</code>. The latter is
generated as a low value due to potential explosive values resulting from
background area scaling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>pompp_initial</code> object. It can be used in the
<code>fit_pompp</code> function by itself, but must be in a list if multiple
initial values are supplied. Initial values can be combined by adding them
(with the use of <code>+</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pompp_initial-class">pompp_initial-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let us create initial values for a model with, say, 3 intensity covariates
# and 4 observability covariates. We add an initial values for both these
# cases due to the intercepts.

# This first one is
in1 &lt;- initial(rep(0, 4), c(0, 2, -1, -2, 3), 100, 0, 1)

# Then we initalize some randomly.
in2 &lt;- initial(4, 5, 100, 0, 1, random = TRUE)

# We can even multiply the random one to generate more. Let us join them all
# to include in a model.
initial_values &lt;- in1 + in2 * 3
# 4 chains are initialized.
</code></pre>

<hr>
<h2 id='LambdaStarPrior-class'>Generic class for the LambdaStar parameters.</h2><span id='topic+LambdaStarPrior-class'></span><span id='topic+show+2CLambdaStarPrior-method'></span>

<h3>Description</h3>

<p>Generic class for the LambdaStar parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LambdaStarPrior'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LambdaStarPrior-class_+3A_object">object</code></td>
<td>
<p>The LambdaStarPrior object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong><code>show</code></strong> and <strong><code>print</code></strong>: The invisible object.
</p>


<h3>Fields</h3>


<dl>
<dt><code>family</code></dt><dd><p>The family of distributions of the prior.</p>
</dd>
</dl>

<hr>
<h2 id='NormalPrior'>Create a Normal prior object for model specification.</h2><span id='topic+NormalPrior'></span>

<h3>Description</h3>

<p>Constructor for <code>NormalPrior-class</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalPrior(mu, Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormalPrior_+3A_mu">mu</code></td>
<td>
<p>The mean vector for the Normal distribution.</p>
</td></tr>
<tr><td><code id="NormalPrior_+3A_sigma">Sigma</code></td>
<td>
<p>The covariance matrix for the Normal distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matrix Sigma must be square and positive definite. Its dimensions
must match mu's length.
</p>


<h3>Value</h3>

<p>A <code>NormalPrior</code> object with adequate slots.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prior">prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NormalPrior(rep(0, 10), diag(10) * 10)
</code></pre>

<hr>
<h2 id='NormalPrior-class'>Normal prior class for Beta and Delta parameters.</h2><span id='topic+NormalPrior-class'></span><span id='topic+names+2CNormalPrior-method'></span><span id='topic++24+2CNormalPrior-method'></span><span id='topic++24+3C-+2CNormalPrior-method'></span><span id='topic+show+2CNormalPrior-method'></span><span id='topic+print+2CNormalPrior-method'></span><span id='topic+print.NormalPrior'></span>

<h3>Description</h3>

<p>This is used to represent the prior for Beta and Delta individually. They
still need to be joined to be used in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NormalPrior'
names(x)

## S4 method for signature 'NormalPrior'
x$name

## S4 replacement method for signature 'NormalPrior'
x$name &lt;- value

## S4 method for signature 'NormalPrior'
show(object)

## S4 method for signature 'NormalPrior'
print(x, ...)

## S3 method for class 'NormalPrior'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormalPrior-class_+3A_x">x</code></td>
<td>
<p>The NormalPrior object.</p>
</td></tr>
<tr><td><code id="NormalPrior-class_+3A_name">name</code></td>
<td>
<p>The requested slot.</p>
</td></tr>
<tr><td><code id="NormalPrior-class_+3A_value">value</code></td>
<td>
<p>New value.</p>
</td></tr>
<tr><td><code id="NormalPrior-class_+3A_object">object</code></td>
<td>
<p>The NormalPrior object.</p>
</td></tr>
<tr><td><code id="NormalPrior-class_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong><code>names</code></strong>: A character vector with the prior parameters.
</p>
<p><strong><code>`$`</code></strong>: The requested slot's value.
</p>
<p><strong><code>`$&lt;-`</code></strong>: The new object with the updated slot.
</p>
<p><strong><code>show</code></strong> and <strong><code>print</code></strong>: The invisible object.
</p>


<h3>Fields</h3>


<dl>
<dt><code>mu</code></dt><dd><p>The mean vector for the prior.</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>The covariance matrix for the prior.</p>
</dd>
</dl>

<hr>
<h2 id='pompp_fit-class'>Class for the result of the MCMC procedure.</h2><span id='topic+pompp_fit-class'></span><span id='topic+show+2Cpompp_fit-method'></span><span id='topic+print+2Cpompp_fit-method'></span><span id='topic+print.pompp_fit'></span><span id='topic+summary+2Cpompp_fit-method'></span><span id='topic+summary.pompp_fit'></span><span id='topic+names+2Cpompp_fit-method'></span><span id='topic+names.pompp_fit'></span><span id='topic++5B+5B+2Cpompp_fit+2CANY+2CANY-method'></span><span id='topic++24+2Cpompp_fit-method'></span><span id='topic+as.array+2Cpompp_fit-method'></span><span id='topic+as.array.pompp_fit'></span><span id='topic+as.matrix+2Cpompp_fit-method'></span><span id='topic+as.matrix.pompp_fit'></span><span id='topic+as.data.frame+2Cpompp_fit-method'></span><span id='topic+as.data.frame.pompp_fit'></span><span id='topic++2B+2Cpompp_fit+2Cpompp_fit-method'></span><span id='topic+c+2Cpompp_fit-method'></span>

<h3>Description</h3>

<p>Objects of this class are the main objects of this package. They contain
much information about the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pompp_fit'
show(object)

## S4 method for signature 'pompp_fit'
print(x, ...)

## S3 method for class 'pompp_fit'
print(x, ...)

## S4 method for signature 'pompp_fit'
summary(object, ...)

## S3 method for class 'pompp_fit'
summary(object, ...)

## S4 method for signature 'pompp_fit'
names(x)

## S3 method for class 'pompp_fit'
names(x)

## S4 method for signature 'pompp_fit,ANY,ANY'
x[[i]]

## S4 method for signature 'pompp_fit'
x$name

## S4 method for signature 'pompp_fit'
as.array(x, ...)

## S3 method for class 'pompp_fit'
as.array(x, ...)

## S4 method for signature 'pompp_fit'
as.matrix(x, ...)

## S3 method for class 'pompp_fit'
as.matrix(x, ...)

## S4 method for signature 'pompp_fit'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S3 method for class 'pompp_fit'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S4 method for signature 'pompp_fit,pompp_fit'
e1 + e2

## S4 method for signature 'pompp_fit'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pompp_fit-class_+3A_object">object</code></td>
<td>
<p>A pompp_fit object.</p>
</td></tr>
<tr><td><code id="pompp_fit-class_+3A_x">x</code></td>
<td>
<p>A pompp_fit object.</p>
</td></tr>
<tr><td><code id="pompp_fit-class_+3A_...">...</code></td>
<td>
<p>Ignored in this version.</p>
</td></tr>
<tr><td><code id="pompp_fit-class_+3A_i">i</code></td>
<td>
<p>The requested slot.</p>
</td></tr>
<tr><td><code id="pompp_fit-class_+3A_name">name</code></td>
<td>
<p>The requested slot.</p>
</td></tr>
<tr><td><code id="pompp_fit-class_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving the row names for the
data frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="pompp_fit-class_+3A_optional">optional</code></td>
<td>
<p>logical. If TRUE, setting row names and converting column
names to syntactic names is optional. See help('as.data.frame') for more.
Leaving as <code>FALSE</code> is recommended.</p>
</td></tr>
<tr><td><code id="pompp_fit-class_+3A_e1">e1</code></td>
<td>
<p>A pompp_fit object.</p>
</td></tr>
<tr><td><code id="pompp_fit-class_+3A_e2">e2</code></td>
<td>
<p>A pompp_fit object with the same slots (except for initial
values) as <code>e1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong><code>show</code></strong> and <strong><code>print</code></strong>: The invisible object.
</p>
<p><strong><code>summary</code></strong>: A matrix with the summary statistics of the
fit. It is also printed in the <code>print</code> method. The summary can be
treated as a matrix, such as retrieving rows/columns and creating tables
with the <code>xtable</code> package.
</p>
<p><strong><code>names</code></strong>: A character vector with the available options
for the <code>`$`</code> and <code>`[[`</code> methods.
</p>
<p><strong><code>`$`</code></strong> and <strong><code>`[[`</code></strong>: The requested slot.
Available options are not necessarily the class slots, and can be checked
with the <code>names</code> method.
</p>
<p><strong><code>as.array</code></strong>: An <code>array</code> with dimensions I x C x P,
where I stands for number of iterations, C for number of chains and P for
total number of parameters. P is actually larger than the number of
parameters in the model, as the the generated sizes of the latent processes
and the log-posterior are also included. This is organized so that is ready
for the <code>bayesplot</code> package functions.
</p>
<p><strong><code>as.matrix</code></strong>: The dimension of the output is
I * C x (P + 2), where I stands for number of iterations, C for number of
chains and P for total number of parameters. P is actually larger than the
number of parameters in the model, as the generated sizes of the latent
processes and the log-posterior are also included.
</p>
<p>Two extra columns are included to indicate to which chain and to which
iteration that draw belongs.
</p>
<p><strong><code>as.data.frame</code></strong>: The dimension of the output is
I*C x P + 2, where I stands for number of iterations, C for number of chains
and P for total number of parameters. P is actually larger than the number
of parameters in the model, as the generated sizes of the latent processes
and the log-posterior are also included.
</p>
<p>Two extra columns are included to indicate to which chain and to which
iteration that draw belongs. This is to facilitate the use of plotting
results via the <code>ggplot2</code> package if desired.
</p>
<p>If <code>row.names</code> is left at <code>NULL</code> then row names are created as
CcIi where c is the chain and i is the iteration of that row.
</p>
<p><strong><code>+</code></strong>: A new <code>pompp_fit</code> object where the chains
are combined into a new multi-chain object. This can be used if chains are
run in separate occasions or computers to combine them into a single object
for analysis.
</p>
<p><strong><code>c</code></strong>: A new <code>pompp_fit</code> object where the chains
are combined into a new multi-chain object. The <strong><code>+</code></strong> method is
used for that, with the same arguments restrictions and results.
</p>


<h3>Fields</h3>


<dl>
<dt><code>fit</code></dt><dd><p>The actual fit from the model. It is an object of class
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>, as generated from the <code>coda</code> package.</p>
</dd>
<dt><code>original</code></dt><dd><p>The model used to generate the chains, an object with class
<code>pompp_model</code>.</p>
</dd>
<dt><code>backgroundSummary</code></dt><dd><p>A small summary of the original background
covariates. This is to ensure that continuing the chains will use the
identical background matrix. Only the summary is kept for storage efficiency.</p>
</dd>
<dt><code>area</code></dt><dd><p>A positive number indicating the area measure of the region being
studied.</p>
</dd>
<dt><code>parnames</code></dt><dd><p>The names of the parameters. If the model used selects the
covariates with column names, they are replicated here. If they are the
column indexes, names are generated for identification.</p>
</dd>
<dt><code>mcmc_setup</code></dt><dd><p>The original mcmc setup used.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit_pompp">fit_pompp</a></code>
</p>

<hr>
<h2 id='pompp_initial-class'>Class for the initial values for the MCMC for the pompp package</h2><span id='topic+pompp_initial-class'></span><span id='topic+names+2Cpompp_initial-method'></span><span id='topic++24+2Cpompp_initial-method'></span><span id='topic++2B+2Cpompp_initial+2CANY-method'></span><span id='topic++2B+2Clist+2Cpompp_initial-method'></span><span id='topic++2B+2Cpompp_initial+2Clist-method'></span><span id='topic++2A+2Cpompp_initial+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2Cpompp_initial-method'></span><span id='topic+show+2Cpompp_initial-method'></span><span id='topic+print+2Cpompp_initial-method'></span><span id='topic+print.pompp_initial'></span>

<h3>Description</h3>

<p>Class for the initial values for the MCMC for the pompp package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pompp_initial'
names(x)

## S4 method for signature 'pompp_initial'
x$name

## S4 method for signature 'pompp_initial,ANY'
e1 + e2

## S4 method for signature 'list,pompp_initial'
e1 + e2

## S4 method for signature 'pompp_initial,list'
e1 + e2

## S4 method for signature 'pompp_initial,numeric'
e1 * e2

## S4 method for signature 'numeric,pompp_initial'
e1 * e2

## S4 method for signature 'pompp_initial'
show(object)

## S4 method for signature 'pompp_initial'
print(x, ...)

## S3 method for class 'pompp_initial'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pompp_initial-class_+3A_x">x</code></td>
<td>
<p>The pompp_initial object.</p>
</td></tr>
<tr><td><code id="pompp_initial-class_+3A_name">name</code></td>
<td>
<p>The requested slot.</p>
</td></tr>
<tr><td><code id="pompp_initial-class_+3A_e1">e1</code></td>
<td>
<p>A pompp_initial object.</p>
</td></tr>
<tr><td><code id="pompp_initial-class_+3A_e2">e2</code></td>
<td>
<p>Another pompp_initial object or a list with pompp_initial
objects for <strong>+</strong> and a positive integer for <strong>*</strong>. e1 and e2
can be switched (+ and * are commutative).</p>
</td></tr>
<tr><td><code id="pompp_initial-class_+3A_object">object</code></td>
<td>
<p>A pompp_initial object.</p>
</td></tr>
<tr><td><code id="pompp_initial-class_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong><code>names</code></strong>: A character vector with the initialized
parameter names.
</p>
<p><strong><code>`$`</code></strong>: The requested initial value (in case of
LambdaStar) or values (in case of Beta or Delta).
</p>
<p><strong><code>+</code></strong>: A list with the objects. Useful to start the
<code>fit_pompp</code> function, as it requires a list of initial values.
</p>
<p><strong><code>*</code></strong>: A list with <code>e2</code> random initial values.
</p>
<p><strong><code>show</code></strong> and <strong><code>print</code></strong>: The invisible object.
</p>


<h3>Fields</h3>


<dl>
<dt><code>beta</code></dt><dd><p>Initial values for beta.</p>
</dd>
<dt><code>delta</code></dt><dd><p>Initial values for delta.</p>
</dd>
<dt><code>lambdaStar</code></dt><dd><p>Initial values for lambdaStar.</p>
</dd>
<dt><code>tag</code></dt><dd><p>Indicates the source of the initial values.</p>
</dd>
</dl>

<hr>
<h2 id='pompp_model'>Build a model to be used in the <code>pompp</code> fitting function</h2><span id='topic+pompp_model'></span>

<h3>Description</h3>

<p>Constructor for <code>pompp_model-class</code> objects, built to facilitate
the use of the fitting function. The output of this function has the
necessary signature for the fit_pompp function to start the model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pompp_model(
  po,
  intensitySelection,
  observabilitySelection,
  marksSelection,
  coordinates,
  intensityLink = "logit",
  observabilityLink = "logit",
  initial_values = 1,
  joint_prior = prior(beta = NormalPrior(rep(0, length(intensitySelection) + 1), 10 *
    diag(length(intensitySelection) + 1)), delta = NormalPrior(rep(0,
    length(observabilitySelection) + 1), 10 * diag(length(observabilitySelection) + 1)),
    lambdaStar = GammaPrior(1e-10, 1e-10), marksMean = NormalPrior(1, 100),
    marksPrecision = GammaPrior(0.001, 0.001)),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pompp_model_+3A_po">po</code></td>
<td>
<p>A matrix whose rows represent the presence-only data and the
columns the covariates observed at each position.</p>
</td></tr>
<tr><td><code id="pompp_model_+3A_intensityselection">intensitySelection</code></td>
<td>
<p>Either a numeric or character vector and
represents the selection of covariates used for the intensity set. If
numeric it is the positions of the columns and if character, the names of
the columns.</p>
</td></tr>
<tr><td><code id="pompp_model_+3A_observabilityselection">observabilitySelection</code></td>
<td>
<p>Either a numeric or character vector and
represents the selection of covariates used for the observability set. If
numeric it is the positions of the columns and if character, the names of
the columns.</p>
</td></tr>
<tr><td><code id="pompp_model_+3A_marksselection">marksSelection</code></td>
<td>
<p>Either a numeric or character vector and
represents the selection of column used for the marks. If
numeric it is the position of the column and if character, the name of
the column.</p>
</td></tr>
<tr><td><code id="pompp_model_+3A_coordinates">coordinates</code></td>
<td>
<p>Either a numeric or character vector and
represents the columns to be used for the coordinates. If
numeric it is the positions of the columns and if character, the names of
the columns. They must be in longitude, latitude order.</p>
</td></tr>
<tr><td><code id="pompp_model_+3A_intensitylink">intensityLink</code></td>
<td>
<p>A string to inform what link function the model has
with respect to the intensity covariates. Current version accepts 'logit'.</p>
</td></tr>
<tr><td><code id="pompp_model_+3A_observabilitylink">observabilityLink</code></td>
<td>
<p>A string to inform what link function the model has
with respect to the observabilitycovariates. Current version accepts 'logit'.</p>
</td></tr>
<tr><td><code id="pompp_model_+3A_initial_values">initial_values</code></td>
<td>
<p>Either a single integer, a single
<code>pompp_initial-class</code> or a list containing
<code>pompp_initial-class</code> objects. The length of the list will inform the
model how many independent chains will be run. If an integer, that many
initial values will be randomly generated.</p>
</td></tr>
<tr><td><code id="pompp_model_+3A_joint_prior">joint_prior</code></td>
<td>
<p>A <code>pompp_prior</code> object.</p>
</td></tr>
<tr><td><code id="pompp_model_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>FALSE</code> to suppress all messages to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>pompp_model</code> object with the requested slots. It is ready
to be used in the <code>fit_pompp</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initial">initial</a></code>, <code><a href="#topic+prior">prior</a></code> and
<code><a href="#topic+fit_pompp">fit_pompp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let us simulate some data to showcase the creation of the model.
beta &lt;- c(-1, 2)
delta &lt;- c(3, 4)
lambdaStar &lt;- 1000
gamma &lt;- 2
mu &lt;- 5

total_points &lt;- rpois(1, lambdaStar)
random_points &lt;- cbind(runif(total_points), runif(total_points))

# Find covariate values to explain the species occurrence.
# We give them a Gaussian spatial structure.
Z &lt;- MASS::mvrnorm(1, rep(0, total_points), 3 * exp(-as.matrix(dist(random_points)) / 0.2))

# Thin the points by comparing the retaining probabilities with uniforms
# in the log scale to find the occurrences
occurrences &lt;- log(runif(total_points)) &lt;= -log1p(exp(-beta[1] - beta[2] * Z))
n_occurrences &lt;- sum(occurrences)
occurrences_points &lt;- random_points[occurrences,]
occurrences_Z &lt;- Z[occurrences]

# Find covariate values to explain the observation bias.
# Additionally create a regular grid to plot the covariate later.
W &lt;- MASS::mvrnorm(1, rep(0, n_occurrences), 2 * exp(-as.matrix(dist(occurrences_points)) / 0.3))
S &lt;- MASS::mvrnorm(1, rep(0, n_occurrences), 2 * exp(-as.matrix(dist(occurrences_points)) / 0.3))

# Find the presence-only observations.
marks &lt;- exp(mu + S + rnorm(n_occurrences, 0, 0.3))
po_sightings &lt;- log(runif(n_occurrences)) &lt;= -log1p(exp(-delta[1] - delta[2] * W - gamma * S))
n_po &lt;- sum(po_sightings)
po_points &lt;- occurrences_points[po_sightings, ]
po_Z &lt;- occurrences_Z[po_sightings]
po_W &lt;- W[po_sightings]
po_marks &lt;- marks[po_sightings]

# Now we create the model
model &lt;- pompp_model(po = cbind(po_Z, po_W, po_points, po_marks),
  intensitySelection = 1, observabilitySelection = 2,
  marksSelection = 5, coordinates = 3:4,
  intensityLink = "logit", observabilityLink = "logit",
  initial_values = 2, joint_prior = prior(
    NormalPrior(rep(0, 2), 10 * diag(2)),
    NormalPrior(rep(0, 3), 10 * diag(3)),
    GammaPrior(1e-4, 1e-4),
    NormalPrior(0, 100), GammaPrior(0.001, 0.001)))
# Check how it is.
model
</code></pre>

<hr>
<h2 id='pompp_model-class'>Class that defines a model for the pompp package.</h2><span id='topic+pompp_model-class'></span><span id='topic+names+2Cpompp_model-method'></span><span id='topic++24+2Cpompp_model-method'></span><span id='topic++24+3C-+2Cpompp_model-method'></span><span id='topic+show+2Cpompp_model-method'></span><span id='topic+print+2Cpompp_model-method'></span><span id='topic+print.pompp_model'></span>

<h3>Description</h3>

<p>The model includes the presence-only data, all selected variables, the link
functions for <code class="reqn">q</code> and <code class="reqn">p</code>, the initial values and the prior
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pompp_model'
names(x)

## S4 method for signature 'pompp_model'
x$name

## S4 replacement method for signature 'pompp_model'
x$name &lt;- value

## S4 method for signature 'pompp_model'
show(object)

## S4 method for signature 'pompp_model'
print(x, ...)

## S3 method for class 'pompp_model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pompp_model-class_+3A_x">x</code></td>
<td>
<p>The pompp_model object.</p>
</td></tr>
<tr><td><code id="pompp_model-class_+3A_name">name</code></td>
<td>
<p>The requested slot.</p>
</td></tr>
<tr><td><code id="pompp_model-class_+3A_value">value</code></td>
<td>
<p>New value.</p>
</td></tr>
<tr><td><code id="pompp_model-class_+3A_object">object</code></td>
<td>
<p>The pompp_model object.</p>
</td></tr>
<tr><td><code id="pompp_model-class_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong><code>names</code></strong>: A character vector with possible options
for the <code>`$`</code> and <code>`$&lt;-`</code> methods.
</p>
<p><strong><code>`$`</code></strong>: The requested slot's value.
</p>
<p><strong><code>`$&lt;-`</code></strong>: The new object with the updated slot.
</p>
<p><strong><code>show</code></strong> and <strong><code>print</code></strong>: The invisible object.
</p>


<h3>Fields</h3>


<dl>
<dt><code>po</code></dt><dd><p>The matrix containing the covariates values for the data.</p>
</dd>
<dt><code>intensityLink</code></dt><dd><p>A string informing about the chosen link for the
intensity covariates. Current acceptable choice is only <code>"logit"</code>.</p>
</dd>
<dt><code>intensitySelection</code></dt><dd><p>A vector containing the indexes of the selected
intensity columns in the <code>po</code> matrix.</p>
</dd>
<dt><code>observabilityLink</code></dt><dd><p>A string informing about the chosen link for the
observability covariates. Current acceptable choice is only <code>"logit"</code>.</p>
</dd>
<dt><code>observabilitySelection</code></dt><dd><p>A vector containing the indexes of the selected
observability columns in the <code>po</code> matrix.</p>
</dd>
<dt><code>marksSelection</code></dt><dd><p>A single value containing the index of the selected
marks column in the <code>po</code> matrix.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>A vector of two values containing the column positions
of the longitude and latitude in the <code>po</code> matrix.</p>
</dd>
<dt><code>init</code></dt><dd><p>A list with objects of class <code>pompp_initial</code> indicating
the initial values for each chain. The length of this list tells the program
how many chains are requested to be run.</p>
</dd>
<dt><code>prior</code></dt><dd><p>An object of class <code>pompp_prior</code> which indicates the
joint prior distribution for the model parameters.</p>
</dd>
<dt><code>iSelectedColumns</code></dt><dd><p>If the intensity covariates selection was made with
the name of the columns, they are stored in this slot.</p>
</dd>
<dt><code>oSelectedColumns</code></dt><dd><p>If the observability covariates selection was made
with the name of the columns, they are stored in this slot.</p>
</dd>
<dt><code>mSelectedColumns</code></dt><dd><p>If the marks selection was made
with the name of the column, it is stored in this slot.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+pompp_initial-class">pompp_initial-class</a></code> and
<code><a href="#topic+pompp_prior-class">pompp_prior-class</a></code> and <code><a href="#topic+pompp_model">pompp_model</a></code>
</p>

<hr>
<h2 id='pompp_prior-class'>Joint prior class for the pompp package parameters</h2><span id='topic+pompp_prior-class'></span><span id='topic+names+2Cpompp_prior-method'></span><span id='topic++24+2Cpompp_prior-method'></span><span id='topic+show+2Cpompp_prior-method'></span><span id='topic+print+2Cpompp_prior-method'></span><span id='topic+print.pompp_prior'></span><span id='topic++24+3C-+2Cpompp_prior-method'></span>

<h3>Description</h3>

<p>Objects of this class are the joining of independent priors for Beta, Delta
and LambdaStar. They can be used in the <code>fit_pompp</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pompp_prior'
names(x)

## S4 method for signature 'pompp_prior'
x$name

## S4 method for signature 'pompp_prior'
show(object)

## S4 method for signature 'pompp_prior'
print(x, ...)

## S3 method for class 'pompp_prior'
print(x, ...)

## S4 method for signature 'pompp_prior'
x$name

## S4 replacement method for signature 'pompp_prior'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pompp_prior-class_+3A_x">x</code></td>
<td>
<p>The pompp_prior object.</p>
</td></tr>
<tr><td><code id="pompp_prior-class_+3A_name">name</code></td>
<td>
<p>The requested slot.</p>
</td></tr>
<tr><td><code id="pompp_prior-class_+3A_object">object</code></td>
<td>
<p>The pompp_prior object.</p>
</td></tr>
<tr><td><code id="pompp_prior-class_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="pompp_prior-class_+3A_value">value</code></td>
<td>
<p>New value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong><code>names</code></strong>: A character vector with the model parameters
names.
</p>
<p><strong><code>`$`</code></strong>: The requested slot's value.
</p>
<p><strong><code>`$&lt;-`</code></strong>: The new object with the updated slot.
</p>


<h3>Fields</h3>


<dl>
<dt><code>beta</code></dt><dd><p>An object of a class which inherits the <code>BetaDeltaPrior</code> S4
class with the appropriate Beta prior.</p>
</dd>
<dt><code>delta</code></dt><dd><p>An object of a class which inherits the <code>BetaDeltaPrior</code> S4
class with the appropriate Delta prior.</p>
</dd>
<dt><code>lambdaStar</code></dt><dd><p>An object of a class which inherits the
<code>LambdaStarPrior</code> S4 class with the appropriate LambdaStar prior.</p>
</dd>
<dt><code>marksMean</code></dt><dd><p>An object of S4 class <code>NormalPrior</code> with the chosen
prior for the marks mean</p>
</dd>
<dt><code>marksPrecision</code></dt><dd><p>An object of S4 class <code>GammaPrior</code> with the chosen
prior for the marks precision</p>
</dd>
</dl>

<hr>
<h2 id='prior'>Build a joint prior for pompp model parameters</h2><span id='topic+prior'></span>

<h3>Description</h3>

<p>Constructor for <code>pompp_prior</code> objects, which is used in the
<code>pompp_fit</code> function. The generated prior is so that Beta, Delta
and LambdaStar are indepdendent a priori.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior(beta, delta, lambdaStar, marksMean, marksPrecision)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_+3A_beta">beta</code></td>
<td>
<p>An S4 object whose class inherits from <code>BetaDeltaPrior</code>.</p>
</td></tr>
<tr><td><code id="prior_+3A_delta">delta</code></td>
<td>
<p>An S4 object whose class inherits from <code>BetaDeltaPrior</code>.</p>
</td></tr>
<tr><td><code id="prior_+3A_lambdastar">lambdaStar</code></td>
<td>
<p>An S4 object whose class inherits from <code>LambdaStarPrior</code>.</p>
</td></tr>
<tr><td><code id="prior_+3A_marksmean">marksMean</code></td>
<td>
<p>An S4 object of class <code>NormalPrior</code>.</p>
</td></tr>
<tr><td><code id="prior_+3A_marksprecision">marksPrecision</code></td>
<td>
<p>An S4 object of class <code>GammaPrior</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>pompp_prior</code> object with the adequate slots. It is ready to
be included in a model via the <code>pompp_model</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_pompp">fit_pompp</a></code>, <code><a href="#topic+NormalPrior">NormalPrior</a></code>,
<code><a href="#topic+GammaPrior">GammaPrior</a></code> and <code><a href="#topic+pompp_model">pompp_model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let us say there are 3 intensity covariates and 4 observability covariates.
# One more element is included in both sets due to the intercepts.
new_prior &lt;- prior(
  NormalPrior(rep(0, 4), 10 * diag(4)),
  NormalPrior(rep(0, 5), 10 * diag(5)),
  GammaPrior(0.0001, 0.0001),
  NormalPrior(0, 100), GammaPrior(0.001, 0.001)
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
