<!DOCTYPE html><html lang="en-US"><head><title>Help for package sdtm.oak</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sdtm.oak}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sdtm.oak-package'><p>sdtm.oak: SDTM Data Transformation Engine</p></a></li>
<li><a href='#+25.+26gt+3B+25'><p>Explicit Dot Pipe</p></a></li>
<li><a href='#add_problems'><p>Add ISO 8601 parsing problems</p></a></li>
<li><a href='#any_problems'><p>Detect problems with the parsing of date/times</p></a></li>
<li><a href='#assert_capture_matrix'><p>Assert capture matrix</p></a></li>
<li><a href='#assert_ct_clst'><p>Assert a codelist code</p></a></li>
<li><a href='#assert_ct_spec'><p>Assert a controlled terminology specification</p></a></li>
<li><a href='#assert_dtc_fmt'><p>Assert date time character formats</p></a></li>
<li><a href='#assert_dtc_format'><p>Assert dtc format</p></a></li>
<li><a href='#assign_datetime'><p>Derive an ISO8601 date-time variable</p></a></li>
<li><a href='#assign_no_ct'><p>Derive an SDTM variable</p></a></li>
<li><a href='#coalesce_capture_matrices'><p>Coalesce capture matrices</p></a></li>
<li><a href='#complete_capture_matrix'><p>Complete a capture matrix</p></a></li>
<li><a href='#condition_add'><p>Add filtering tags to a data set</p></a></li>
<li><a href='#contains_oak_id_vars'><p>Does a vector contain the raw dataset key variables?</p></a></li>
<li><a href='#create_iso8601'><p>Convert date or time collected values to ISO 8601</p></a></li>
<li><a href='#ct_map'><p>Recode according to controlled terminology</p></a></li>
<li><a href='#ct_mappings'><p>Controlled terminology mappings</p></a></li>
<li><a href='#ct_spec_example'><p>Find the path to an example controlled terminology file</p></a></li>
<li><a href='#ct_spec_vars'><p>Controlled terminology variables</p></a></li>
<li><a href='#ctl_new_rowid_pillar.cnd_df'><p>Conditioned tibble pillar print method</p></a></li>
<li><a href='#dataset_oak_vignette'><p>Output a Dataset in a Vignette in the sdtm.oak Format</p></a></li>
<li><a href='#derive_blfl'><p>Derive Baseline Flag or Last Observation Before Exposure Flag</p></a></li>
<li><a href='#derive_seq'><p>Derive the sequence number (<code>--SEQ</code>) variable</p></a></li>
<li><a href='#derive_study_day'><p><code>derive_study_day</code> performs study day calculation</p></a></li>
<li><a href='#domain_example'><p>Find the path to an example SDTM domain file</p></a></li>
<li><a href='#dtc_datepart'><p>Extract date part from ISO8601 date/time variable</p></a></li>
<li><a href='#dtc_formats'><p>Date/time collection formats</p></a></li>
<li><a href='#dtc_timepart'><p>Extract time part from ISO 8601 date/time variable</p></a></li>
<li><a href='#dttm_fmt_to_regex'><p>Convert a parsed date/time format to regex</p></a></li>
<li><a href='#eval_conditions'><p>Evaluate conditions</p></a></li>
<li><a href='#find_int_gap'><p>Find gap intervals in integer sequences</p></a></li>
<li><a href='#fmt_cmp'><p>Regexps for date/time format components</p></a></li>
<li><a href='#fmt_rg'><p>Regexps for date/time components</p></a></li>
<li><a href='#format_iso8601'><p>Convert date/time components into ISO8601 format</p></a></li>
<li><a href='#generate_oak_id_vars'><p>A function to generate oak_id_vars</p></a></li>
<li><a href='#get_cnd_df_cnd'><p>Get the conditioning vector from a conditioned data frame</p></a></li>
<li><a href='#get_cnd_df_cnd_sum'><p>Get the summary of the conditioning vector from a conditioned data frame</p></a></li>
<li><a href='#harcode'><p>Derive an SDTM variable with a hardcoded value</p></a></li>
<li><a href='#index_for_recode'><p>Determine Indices for Recoding</p></a></li>
<li><a href='#is_cnd_df'><p>Check if a data frame is a conditioned data frame</p></a></li>
<li><a href='#is_seq_name'><p>Is it a &ndash;SEQ variable name</p></a></li>
<li><a href='#iso8601_mon'><p>Format as a ISO8601 month</p></a></li>
<li><a href='#iso8601_na'><p>Convert NA to <code>"-"</code></p></a></li>
<li><a href='#iso8601_sec'><p>Format as ISO8601 seconds</p></a></li>
<li><a href='#iso8601_truncate'><p>Truncate a partial ISO8601 date-time</p></a></li>
<li><a href='#iso8601_two_digits'><p>Format as a ISO8601 two-digit number</p></a></li>
<li><a href='#iso8601_year'><p>Format as a ISO8601 four-digit year</p></a></li>
<li><a href='#months_abb_regex'><p>Regex for months' abbreviations</p></a></li>
<li><a href='#mutate.cnd_df'><p>Mutate method for conditioned data frames</p></a></li>
<li><a href='#new_cnd_df'><p>Create a data frame with filtering tags</p></a></li>
<li><a href='#oak_id_vars'><p>Raw dataset keys</p></a></li>
<li><a href='#parse_dttm_'><p>Parse a date, time, or date-time</p></a></li>
<li><a href='#parse_dttm_fmt_'><p>Parse a date/time format</p></a></li>
<li><a href='#problems'><p>Retrieve date/time parsing problems</p></a></li>
<li><a href='#pseq'><p>Parallel sequence generation</p></a></li>
<li><a href='#read_ct_spec'><p>Read in a controlled terminology</p></a></li>
<li><a href='#read_ct_spec_example'><p>Read an example controlled terminology specification</p></a></li>
<li><a href='#read_domain_example'><p>Read an example SDTM domain</p></a></li>
<li><a href='#recode'><p>Recode values</p></a></li>
<li><a href='#reg_matches'><p><code>regmatches()</code> with <code>NA</code></p></a></li>
<li><a href='#regex_or'><p>Utility function to assemble a regex of alternative patterns</p></a></li>
<li><a href='#rm_cnd_df'><p>Remove the <code>cnd_df</code> class from a data frame</p></a></li>
<li><a href='#sbj_vars'><p>Subject-level key variables</p></a></li>
<li><a href='#sdtm_assign'><p>Derive an SDTM variable</p></a></li>
<li><a href='#sdtm_hardcode'><p>Derive an SDTM variable with a hardcoded value</p></a></li>
<li><a href='#sdtm_join'><p>SDTM join</p></a></li>
<li><a href='#str_to_anycase'><p>Generate case insensitive regexps</p></a></li>
<li><a href='#tbl_sum.cnd_df'><p>Conditioned tibble header print method</p></a></li>
<li><a href='#yy_to_yyyy'><p>Convert two-digit to four-digit years</p></a></li>
<li><a href='#zero_pad_whole_number'><p>Convert an integer to a zero-padded character vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>SDTM Data Transformation Engine</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rammprasad Ganapathy &lt;ganapathy.rammprasad@gene.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An Electronic Data Capture system (EDC) and Data Standard agnostic 
    solution that enables the pharmaceutical programming community to develop 
    Clinical Data Interchange Standards Consortium (CDISC)
    Study Data Tabulation Model (SDTM) datasets in R. The reusable algorithms 
    concept in 'sdtm.oak' provides a framework for modular programming and can 
    potentially automate the conversion of raw clinical data to SDTM through 
    standardized SDTM specifications. SDTM is one of the required standards for data 
    submission to the Food and Drug Administration (FDA) in the United States and 
    Pharmaceuticals and Medical Devices Agency (PMDA) in Japan. SDTM standards 
    are implemented following the SDTM Implementation Guide as defined by 
    CDISC <a href="https://www.cdisc.org/standards/foundational/sdtmig">https://www.cdisc.org/standards/foundational/sdtmig</a>.</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>F. Hoffmann-La Roche AG, Pattern Institute, Atorus Research
LLC and Transition Technologies Science sp. z o.o.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pharmaverse/sdtm.oak/issues/">https://github.com/pharmaverse/sdtm.oak/issues/</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pharmaverse.github.io/sdtm.oak/">https://pharmaverse.github.io/sdtm.oak/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>admiraldev (&ge; 1.1.0), dplyr (&ge; 1.0.0), purrr (&ge; 1.0.1),
tidyr (&ge; 1.2.0), rlang (&ge; 1.0.2), tibble (&ge; 3.2.0), vctrs
(&ge; 0.5.0), stringr (&ge; 1.4.0), assertthat, pillar, cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, htmltools, lifecycle, magrittr, rmarkdown, spelling,
testthat (&ge; 3.1.7), DT, readr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-12 02:08:56 UTC; ganapar1</td>
</tr>
<tr>
<td>Author:</td>
<td>Rammprasad Ganapathy [aut, cre],
  Adam Forys [aut],
  Edgar Manukyan [aut],
  Rosemary Li [aut],
  Preetesh Parikh [aut],
  Lisa Houterloot [aut],
  Yogesh Gupta [aut],
  Omar Garcia [aut],
  Ramiro Magno <a href="https://orcid.org/0000-0001-5226-3441"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kamil Sijko <a href="https://orcid.org/0000-0002-2203-1065"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Shiyu Chen [aut],
  Pattern Institute [cph, fnd],
  F. Hoffmann-La Roche AG [cph, fnd],
  Pfizer Inc [cph, fnd],
  Transition Technologies Science [cph, fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-12 03:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sdtm.oak-package'>sdtm.oak: SDTM Data Transformation Engine</h2><span id='topic+sdtm.oak'></span><span id='topic+sdtm.oak-package'></span>

<h3>Description</h3>

<p>An Electronic Data Capture system (EDC) and Data Standard agnostic solution that enables the pharmaceutical programming community to develop Clinical Data Interchange Standards Consortium (CDISC) Study Data Tabulation Model (SDTM) datasets in R. The reusable algorithms concept in 'sdtm.oak' provides a framework for modular programming and can potentially automate the conversion of raw clinical data to SDTM through standardized SDTM specifications. SDTM is one of the required standards for data submission to the Food and Drug Administration (FDA) in the United States and Pharmaceuticals and Medical Devices Agency (PMDA) in Japan. SDTM standards are implemented following the SDTM Implementation Guide as defined by CDISC <a href="https://www.cdisc.org/standards/foundational/sdtmig">https://www.cdisc.org/standards/foundational/sdtmig</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Rammprasad Ganapathy <a href="mailto:ganapathy.rammprasad@gene.com">ganapathy.rammprasad@gene.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Adam Forys
</p>
</li>
<li><p> Edgar Manukyan
</p>
</li>
<li><p> Rosemary Li
</p>
</li>
<li><p> Preetesh Parikh
</p>
</li>
<li><p> Lisa Houterloot
</p>
</li>
<li><p> Yogesh Gupta
</p>
</li>
<li><p> Omar Garcia <a href="mailto:ogcalderon@cdisc.org">ogcalderon@cdisc.org</a>
</p>
</li>
<li><p> Ramiro Magno <a href="mailto:rmagno@pattern.institute">rmagno@pattern.institute</a> (<a href="https://orcid.org/0000-0001-5226-3441">ORCID</a>)
</p>
</li>
<li><p> Kamil Sijko <a href="mailto:kamil.sijko@ttsi.com.pl">kamil.sijko@ttsi.com.pl</a> (<a href="https://orcid.org/0000-0002-2203-1065">ORCID</a>)
</p>
</li>
<li><p> Shiyu Chen <a href="mailto:Shiyu.Chen@atorusresearch.com">Shiyu.Chen@atorusresearch.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Pattern Institute [copyright holder, funder]
</p>
</li>
<li><p> F. Hoffmann-La Roche AG [copyright holder, funder]
</p>
</li>
<li><p> Pfizer Inc [copyright holder, funder]
</p>
</li>
<li><p> Transition Technologies Science [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://pharmaverse.github.io/sdtm.oak/">https://pharmaverse.github.io/sdtm.oak/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pharmaverse/sdtm.oak/issues/">https://github.com/pharmaverse/sdtm.oak/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='+25.+26gt+3B+25'>Explicit Dot Pipe</h2><span id='topic++25.+3E+25'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This operator pipes an object forward into a function or call expression
using an explicit placement of the dot (<code>.</code>) placeholder. Unlike magrittr's
<a href="magrittr.html#topic+pipe">%&gt;%</a> operator, <code style="white-space: pre;">&#8288;%.&gt;%&#8288;</code> does not automatically place the
left-hand side (<code>lhs</code>) as the first argument in the right-hand side (<code>rhs</code>)
call. This operator provides a simpler alternative to the use of braces with
magrittr, while achieving similar behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %.&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25.+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value to be piped forward.</p>
</td></tr>
<tr><td><code id="+2B25.+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call that utilizes the dot (<code>.</code>) placeholder to specify
where <code>lhs</code> should be placed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code style="white-space: pre;">&#8288;%.&gt;%&#8288;</code> operator is used to pipe the <code>lhs</code> value into the <code>rhs</code> function
call. Within the <code>rhs</code> expression, the placeholder <code>.</code> represents the
position where <code>lhs</code> will be inserted. This provides more control over where
the <code>lhs</code> value appears in the <code>rhs</code> function call, compared to the magrittr
pipe operator which always places <code>lhs</code> as the first argument of <code>rhs</code>.
</p>
<p>Unlike magrittr's pipe, which may require the use of braces to fully control
the placement of <code>lhs</code> in nested function calls, <code style="white-space: pre;">&#8288;%.&gt;%&#8288;</code> simplifies this by
directly allowing multiple usages of the dot placeholder without requiring
braces. For example, the following expression using magrittr's pipe and
braces:
</p>
<div class="sourceCode r"><pre>library(magrittr)

1:10 %&gt;% { c(min(.), max(.)) }
</pre></div>
<p>can be written as:
</p>
<div class="sourceCode r"><pre>1:10 %.&gt;% c(min(.), max(.))
</pre></div>
<p>without needing additional braces.
</p>


<h4>Downside</h4>

<p>The disadvantage of <code style="white-space: pre;">&#8288;%.&gt;%&#8288;</code> is that you always need to use
the dot placeholder, even when piping to the first argument of the
right-hand side (<code>rhs</code>).
</p>



<h3>Value</h3>

<p>No Return Value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Equivalent to `subset(head(iris), 1:nrow(head(iris)) %% 2 == 0)`
head(iris) %.&gt;% subset(., 1:nrow(.) %% 2 == 0)

# Equivalent to `c(min(1:10), max(1:10))`
1:10 %.&gt;% c(min(.), max(.))

</code></pre>

<hr>
<h2 id='add_problems'>Add ISO 8601 parsing problems</h2><span id='topic+add_problems'></span>

<h3>Description</h3>

<p><code><a href="#topic+add_problems">add_problems()</a></code> annotates the returned value of <code><a href="#topic+create_iso8601">create_iso8601()</a></code> with
possible parsing problems. This annotation consists of a
<a href="tibble.html#topic+tibble-package">tibble</a> of problems, one row for each parsing
failure (see Details section).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_problems(x, is_problem, dtc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_problems_+3A_x">x</code></td>
<td>
<p>A character vector of date-times in ISO 8601 format; typically, the
output of <code><a href="#topic+format_iso8601">format_iso8601()</a></code>.</p>
</td></tr>
<tr><td><code id="add_problems_+3A_is_problem">is_problem</code></td>
<td>
<p>A <code>logical</code> indicating which date/time inputs are
associated with parsing failures.</p>
</td></tr>
<tr><td><code id="add_problems_+3A_dtc">dtc</code></td>
<td>
<p>A list of <code>character</code> vectors of dates, times or date-times'
components. Typically, this parameter takes the value passed in <code>...</code> to
a <code><a href="#topic+create_iso8601">create_iso8601()</a></code> call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function annotates its input <code>x</code>, a vector date-times in ISO 8601
format, by creating an attribute named <code>problems</code>. This attribute's value
is a <a href="tibble.html#topic+tibble-package">tibble</a> of parsing problems. The problematic
date/times are indicated by the <code>logical</code> vector passed as argument to
<code>is_problem</code>.
</p>
<p>The attribute <code>problems</code> in the returned value will contain a first column
named <code>..i</code> that indicates the date/time index of the problematic date/time
in <code>x</code>, and as many extra columns as there were inputs (passed in <code>dtc</code>). If
<code>dtc</code> is named, then those names are used to name the extra columns,
otherwise they get named sequentially like so <code>..var1</code>, <code>..var2</code>, etc..
</p>


<h3>Value</h3>

<p>Either <code>x</code> without any modification, if no parsing problems exist,
or an annotated <code>x</code>, meaning having a <code>problems</code> attribute that holds
parsing issues (see the Details section).
</p>

<hr>
<h2 id='any_problems'>Detect problems with the parsing of date/times</h2><span id='topic+any_problems'></span>

<h3>Description</h3>

<p><code><a href="#topic+any_problems">any_problems()</a></code> takes a list of capture matrices (see <code><a href="#topic+parse_dttm">parse_dttm()</a></code>) and
reports on parsing problems by means of predicate values. A <code>FALSE</code> value
indicates that the parsing was successful and a <code>TRUE</code> value a parsing
failure in at least one of the inputs to <code><a href="#topic+create_iso8601">create_iso8601()</a></code>. Note that this
is an internal function to be used in the context of <code><a href="#topic+create_iso8601">create_iso8601()</a></code>
source code and hence each capture matrix corresponds to one input to
<code><a href="#topic+create_iso8601">create_iso8601()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_problems(cap_matrices, .cutoff_2000 = 68L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="any_problems_+3A_cap_matrices">cap_matrices</code></td>
<td>
<p>A list of capture matrices in the sense of the returned
value by <code><a href="#topic+parse_dttm">parse_dttm()</a></code>.</p>
</td></tr>
<tr><td><code id="any_problems_+3A_.cutoff_2000">.cutoff_2000</code></td>
<td>
<p>An integer value. Two-digit years smaller or equal to
<code>.cutoff_2000</code> are parsed as though starting with <code>20</code>, otherwise parsed as
though starting with <code>19</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> whose length matches the number of underlying date/times
passed as inputs to <code><a href="#topic+create_iso8601">create_iso8601()</a></code>, i.e. whose length matches the
number of rows of the capture matrices in <code>cap_matrices</code>.
</p>

<hr>
<h2 id='assert_capture_matrix'>Assert capture matrix</h2><span id='topic+assert_capture_matrix'></span>

<h3>Description</h3>

<p><code><a href="#topic+assert_capture_matrix">assert_capture_matrix()</a></code> is an internal helper function aiding with the
checking of an internal R object that contains the parsing results as
returned by <code><a href="#topic+parse_dttm">parse_dttm()</a></code>: capture matrix.
</p>
<p>This function checks that the capture matrix is a matrix and that it contains
six columns: <code>year</code>, <code>mon</code>, <code>mday</code>, <code>hour</code>, <code>min</code> and <code>sec</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_capture_matrix(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_capture_matrix_+3A_m">m</code></td>
<td>
<p>A character matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function throws an error if <code>m</code> is not either:
</p>

<ul>
<li><p> A character matrix;
</p>
</li>
<li><p> A matrix whose columns are (at least): <code>year</code>, <code>mon</code>, <code>mday</code>, <code>hour</code>,
<code>min</code> and <code>sec</code>.
</p>
</li></ul>

<p>Otherwise, it returns <code>m</code> invisibly.
</p>

<hr>
<h2 id='assert_ct_clst'>Assert a codelist code</h2><span id='topic+assert_ct_clst'></span>

<h3>Description</h3>

<p><code><a href="#topic+assert_ct_clst">assert_ct_clst()</a></code> asserts the validity of a codelist code in the context of
a controlled terminology specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_ct_clst(ct_spec, ct_clst, optional = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_ct_clst_+3A_ct_spec">ct_spec</code></td>
<td>
<p>Either a data frame encoding a controlled terminology data set, or
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="assert_ct_clst_+3A_ct_clst">ct_clst</code></td>
<td>
<p>A string with a to-be asserted codelist code, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="assert_ct_clst_+3A_optional">optional</code></td>
<td>
<p>A scalar logical, indicating whether <code>ct_clst</code> can be <code>NULL</code> or
not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function throws an error if <code>ct_clst</code> is not a valid codelist code
given the controlled terminology data set; otherwise, <code>ct_clst</code> is returned
invisibly.
</p>

<hr>
<h2 id='assert_ct_spec'>Assert a controlled terminology specification</h2><span id='topic+assert_ct_spec'></span>

<h3>Description</h3>

<p><code><a href="#topic+assert_ct_spec">assert_ct_spec()</a></code> will check whether <code>ct_spec</code> is a data frame and if it contains the
variables: codelist_code, collected_value, term_synonyms, and term_value.
</p>
<p>In addition, it will also check if the data frame is not empty (no rows), and
whether the columns <code>codelist_code</code> and <code>term_value</code> do
not contain any <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_ct_spec(ct_spec, optional = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_ct_spec_+3A_ct_spec">ct_spec</code></td>
<td>
<p>A data frame to be asserted as a valid controlled terminology data
set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function throws an error if <code>ct_spec</code> is not a valid controlled
terminology data set; otherwise, <code>ct_spec</code> is returned invisibly.
</p>

<hr>
<h2 id='assert_dtc_fmt'>Assert date time character formats</h2><span id='topic+assert_dtc_fmt'></span>

<h3>Description</h3>

<p><code><a href="#topic+assert_dtc_fmt">assert_dtc_fmt()</a></code> takes a character vector of date/time formats and checks if
the formats are supported, meaning it checks if they are one of the formats
listed in column <code>fmt</code> of <a href="#topic+dtc_formats">dtc_formats</a>, failing with an error otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_dtc_fmt(fmt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_dtc_fmt_+3A_fmt">fmt</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='assert_dtc_format'>Assert dtc format</h2><span id='topic+assert_dtc_format'></span>

<h3>Description</h3>

<p><code><a href="#topic+assert_dtc_format">assert_dtc_format()</a></code> is an internal helper function aiding with the checking
of the <code>.format</code> parameter of <code><a href="#topic+create_iso8601">create_iso8601()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_dtc_format(.format)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_dtc_format_+3A_.format">.format</code></td>
<td>
<p>The argument of <code><a href="#topic+create_iso8601">create_iso8601()</a></code>'s <code>.format</code> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function throws an error if <code>.format</code> is not either:
</p>

<ul>
<li><p> A character vector of formats permitted by <code><a href="#topic+assert_dtc_fmt">assert_dtc_fmt()</a></code>;
</p>
</li>
<li><p> A list of character vectors of formats permitted by <code><a href="#topic+assert_dtc_fmt">assert_dtc_fmt()</a></code>.
</p>
</li></ul>

<p>Otherwise, it returns <code>.format</code> invisibly.
</p>

<hr>
<h2 id='assign_datetime'>Derive an ISO8601 date-time variable</h2><span id='topic+assign_datetime'></span>

<h3>Description</h3>

<p><code><a href="#topic+assign_datetime">assign_datetime()</a></code> maps one or more variables with date/time components in a
raw dataset to a target SDTM variable following the ISO8601 format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_datetime(
  tgt_dat = NULL,
  tgt_var,
  raw_dat,
  raw_var,
  raw_fmt,
  raw_unk = c("UN", "UNK"),
  id_vars = oak_id_vars(),
  .warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_datetime_+3A_tgt_dat">tgt_dat</code></td>
<td>
<p>Target dataset: a data frame to be merged against <code>raw_dat</code> by
the variables indicated in <code>id_vars</code>. This parameter is optional, see
section Value for how the output changes depending on this argument value.</p>
</td></tr>
<tr><td><code id="assign_datetime_+3A_tgt_var">tgt_var</code></td>
<td>
<p>The target SDTM variable: a single string indicating the name
of variable to be derived.</p>
</td></tr>
<tr><td><code id="assign_datetime_+3A_raw_dat">raw_dat</code></td>
<td>
<p>The raw dataset (dataframe); must include the
variables passed in <code>id_vars</code> and <code>raw_var</code>.</p>
</td></tr>
<tr><td><code id="assign_datetime_+3A_raw_var">raw_var</code></td>
<td>
<p>The raw variable(s): a character vector indicating the name(s)
of the raw variable(s) in <code>raw_dat</code> with date or time components to be
parsed into a ISO8601 format variable in <code>tgt_var</code>.</p>
</td></tr>
<tr><td><code id="assign_datetime_+3A_raw_fmt">raw_fmt</code></td>
<td>
<p>A date/time parsing format. Either a character vector or a
list of character vectors. If a character vector is passed then each
element is taken as parsing format for each variable indicated in
<code>raw_var</code>. If a list is provided, then each element must be a character
vector of formats. The first vector of formats is used for parsing the
first variable in <code>raw_var</code>, and so on.</p>
</td></tr>
<tr><td><code id="assign_datetime_+3A_raw_unk">raw_unk</code></td>
<td>
<p>A character vector of string literals to be regarded as
missing values during parsing.</p>
</td></tr>
<tr><td><code id="assign_datetime_+3A_id_vars">id_vars</code></td>
<td>
<p>Key variables to be used in the join between the raw dataset
(<code>raw_dat</code>) and the target data set (<code>tgt_dat</code>).</p>
</td></tr>
<tr><td><code id="assign_datetime_+3A_.warn">.warn</code></td>
<td>
<p>Whether to warn about parsing failures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned data set depends on the value of <code>tgt_dat</code>:
</p>

<ul>
<li><p> If no target dataset is supplied, meaning that <code>tgt_dat</code> defaults to
<code>NULL</code>, then the returned data set is <code>raw_dat</code>, selected for the variables
indicated in <code>id_vars</code>, and a new extra column: the derived variable, as
indicated in <code>tgt_var</code>.
</p>
</li>
<li><p> If the target dataset is provided, then it is merged with the raw data set
<code>raw_dat</code> by the variables indicated in <code>id_vars</code>, with a new column: the
derived variable, as indicated in <code>tgt_var</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `md1`: an example raw data set.
md1 &lt;-
  tibble::tribble(
    ~oak_id, ~raw_source, ~patient_number, ~MDBDR,        ~MDEDR,        ~MDETM,
    1L,      "MD1",       375,             NA,            NA,            NA,
    2L,      "MD1",       375,             "15-Sep-20",   NA,            NA,
    3L,      "MD1",       376,             "17-Feb-21",   "17-Feb-21",   NA,
    4L,      "MD1",       377,             "4-Oct-20",    NA,            NA,
    5L,      "MD1",       377,             "20-Jan-20",   "20-Jan-20",   "10:00:00",
    6L,      "MD1",       377,             "UN-UNK-2019", "UN-UNK-2019", NA,
    7L,      "MD1",       377,             "20-UNK-2019", "20-UNK-2019", NA,
    8L,      "MD1",       378,             "UN-UNK-2020", "UN-UNK-2020", NA,
    9L,      "MD1",       378,             "26-Jan-20",   "26-Jan-20",   "07:00:00",
    10L,     "MD1",       378,             "28-Jan-20",   "1-Feb-20",    NA,
    11L,     "MD1",       378,             "12-Feb-20",   "18-Feb-20",   NA,
    12L,     "MD1",       379,             "10-UNK-2020", "20-UNK-2020", NA,
    13L,     "MD1",       379,             NA,            NA,            NA,
    14L,     "MD1",       379,             NA,            "17-Feb-20",   NA
  )

# Using the raw data set `md1`, derive the variable CMSTDTC from MDBDR using
# the parsing format (`raw_fmt`) `"d-m-y"` (day-month-year), while allowing
# for the presence of special date component values (e.g. `"UN"` or `"UNK"`),
# indicating that these values are missing/unknown (unk).
cm1 &lt;-
  assign_datetime(
    tgt_var = "CMSTDTC",
    raw_dat = md1,
    raw_var = "MDBDR",
    raw_fmt = "d-m-y",
    raw_unk = c("UN", "UNK")
  )

cm1

# Inspect parsing failures associated with derivation of CMSTDTC.
problems(cm1$CMSTDTC)

# `cm_inter`: an example target data set.
cm_inter &lt;-
  tibble::tibble(
    oak_id = 1L:14L,
    raw_source = "MD1",
    patient_number = c(
      375, 375, 376, 377, 377, 377, 377, 378,
      378, 378, 378, 379, 379, 379
    ),
    CMTRT = c(
      "BABY ASPIRIN",
      "CORTISPORIN",
      "ASPIRIN",
      "DIPHENHYDRAMINE HCL",
      "PARCETEMOL",
      "VOMIKIND",
      "ZENFLOX OZ",
      "AMITRYPTYLINE",
      "BENADRYL",
      "DIPHENHYDRAMINE HYDROCHLORIDE",
      "TETRACYCLINE",
      "BENADRYL",
      "SOMINEX",
      "ZQUILL"
    ),
    CMINDC = c(
      "NA",
      "NAUSEA",
      "ANEMIA",
      "NAUSEA",
      "PYREXIA",
      "VOMITINGS",
      "DIARHHEA",
      "COLD",
      "FEVER",
      "LEG PAIN",
      "FEVER",
      "COLD",
      "COLD",
      "PAIN"
    )
  )

# Same derivation as above but now involving the merging with the target
# data set `cm_inter`.
cm2 &lt;-
  assign_datetime(
    tgt_dat = cm_inter,
    tgt_var = "CMSTDTC",
    raw_dat = md1,
    raw_var = "MDBDR",
    raw_fmt = "d-m-y"
  )

cm2

# Inspect parsing failures associated with derivation of CMSTDTC.
problems(cm2$CMSTDTC)

# Derive CMSTDTC using both MDEDR and MDETM variables.
# Note that the format `"d-m-y"` is used for parsing MDEDR and `"H:M:S"` for
# MDETM (correspondence is by positional matching).
cm3 &lt;-
  assign_datetime(
    tgt_var = "CMSTDTC",
    raw_dat = md1,
    raw_var = c("MDEDR", "MDETM"),
    raw_fmt = c("d-m-y", "H:M:S"),
    raw_unk = c("UN", "UNK")
  )

cm3

# Inspect parsing failures associated with derivation of CMSTDTC.
problems(cm3$CMSTDTC)

</code></pre>

<hr>
<h2 id='assign_no_ct'>Derive an SDTM variable</h2><span id='topic+assign_no_ct'></span><span id='topic+assign_ct'></span><span id='topic+assign'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+assign_no_ct">assign_no_ct()</a></code> maps a variable in a raw dataset to a target SDTM
variable that has no terminology restrictions.
</p>
</li>
<li> <p><code><a href="#topic+assign_ct">assign_ct()</a></code> maps a variable in a raw dataset to a target SDTM variable
following controlled terminology recoding.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>assign_no_ct(
  tgt_dat = NULL,
  tgt_var,
  raw_dat,
  raw_var,
  id_vars = oak_id_vars()
)

assign_ct(
  tgt_dat = NULL,
  tgt_var,
  raw_dat,
  raw_var,
  ct_spec,
  ct_clst,
  id_vars = oak_id_vars()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_no_ct_+3A_tgt_dat">tgt_dat</code></td>
<td>
<p>Target dataset: a data frame to be merged against <code>raw_dat</code> by
the variables indicated in <code>id_vars</code>. This parameter is optional, see
section Value for how the output changes depending on this argument value.</p>
</td></tr>
<tr><td><code id="assign_no_ct_+3A_tgt_var">tgt_var</code></td>
<td>
<p>The target SDTM variable: a single string indicating the name
of variable to be derived.</p>
</td></tr>
<tr><td><code id="assign_no_ct_+3A_raw_dat">raw_dat</code></td>
<td>
<p>The raw dataset (dataframe); must include the
variables passed in <code>id_vars</code> and <code>raw_var</code>.</p>
</td></tr>
<tr><td><code id="assign_no_ct_+3A_raw_var">raw_var</code></td>
<td>
<p>The raw variable: a single string indicating the name of the
raw variable in <code>raw_dat</code>.</p>
</td></tr>
<tr><td><code id="assign_no_ct_+3A_id_vars">id_vars</code></td>
<td>
<p>Key variables to be used in the join between the raw dataset
(<code>raw_dat</code>) and the target data set (<code>raw_dat</code>).</p>
</td></tr>
<tr><td><code id="assign_no_ct_+3A_ct_spec">ct_spec</code></td>
<td>
<p>Study controlled terminology specification: a dataframe with a
minimal set of columns, see <code><a href="#topic+ct_spec_vars">ct_spec_vars()</a></code> for details.</p>
</td></tr>
<tr><td><code id="assign_no_ct_+3A_ct_clst">ct_clst</code></td>
<td>
<p>A codelist code indicating which subset of the controlled
terminology to apply in the derivation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned data set depends on the value of <code>tgt_dat</code>:
</p>

<ul>
<li><p> If no target dataset is supplied, meaning that <code>tgt_dat</code> defaults to
<code>NULL</code>, then the returned data set is <code>raw_dat</code>, selected for the variables
indicated in <code>id_vars</code>, and a new extra column: the derived variable, as
indicated in <code>tgt_var</code>.
</p>
</li>
<li><p> If the target dataset is provided, then it is merged with the raw data set
<code>raw_dat</code> by the variables indicated in <code>id_vars</code>, with a new column: the
derived variable, as indicated in <code>tgt_var</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
md1 &lt;-
  tibble::tibble(
    oak_id = 1:14,
    raw_source = "MD1",
    patient_number = 101:114,
    MDIND = c(
      "NAUSEA", "NAUSEA", "ANEMIA", "NAUSEA", "PYREXIA",
      "VOMITINGS", "DIARHHEA", "COLD",
      "FEVER", "LEG PAIN", "FEVER", "COLD", "COLD", "PAIN"
    )
  )

assign_no_ct(
  tgt_var = "CMINDC",
  raw_dat = md1,
  raw_var = "MDIND"
)

cm_inter &lt;-
  tibble::tibble(
    oak_id = 1:14,
    raw_source = "MD1",
    patient_number = 101:114,
    CMTRT = c(
      "BABY ASPIRIN",
      "CORTISPORIN",
      "ASPIRIN",
      "DIPHENHYDRAMINE HCL",
      "PARCETEMOL",
      "VOMIKIND",
      "ZENFLOX OZ",
      "AMITRYPTYLINE",
      "BENADRYL",
      "DIPHENHYDRAMINE HYDROCHLORIDE",
      "TETRACYCLINE",
      "BENADRYL",
      "SOMINEX",
      "ZQUILL"
    ),
    CMROUTE = c(
      "ORAL",
      "ORAL",
      NA,
      "ORAL",
      "ORAL",
      "ORAL",
      "INTRAMUSCULAR",
      "INTRA-ARTERIAL",
      NA,
      "NON-STANDARD",
      "RANDOM_VALUE",
      "INTRA-ARTICULAR",
      "TRANSDERMAL",
      "OPHTHALMIC"
    )
  )

# Controlled terminology specification
(ct_spec &lt;- read_ct_spec_example("ct-01-cm"))

assign_ct(
  tgt_dat = cm_inter,
  tgt_var = "CMINDC",
  raw_dat = md1,
  raw_var = "MDIND",
  ct_spec = ct_spec,
  ct_clst = "C66729"
)

</code></pre>

<hr>
<h2 id='coalesce_capture_matrices'>Coalesce capture matrices</h2><span id='topic+coalesce_capture_matrices'></span>

<h3>Description</h3>

<p><code><a href="#topic+coalesce_capture_matrices">coalesce_capture_matrices()</a></code> combines several capture matrices into one.
Each argument of <code>...</code> should be a capture matrix in the sense of the output
by <code><a href="#topic+complete_capture_matrix">complete_capture_matrix()</a></code>, meaning a character matrix of six columns
whose names are: <code>year</code>, <code>mon</code>, <code>mday</code>, <code>hour</code>, <code>min</code> or <code>sec</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce_capture_matrices(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coalesce_capture_matrices_+3A_...">...</code></td>
<td>
<p>A sequence of capture matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single capture matrix whose values have been coalesced in the
sense of <a href="dplyr.html#topic+coalesce">coalesce()</a>.
</p>

<hr>
<h2 id='complete_capture_matrix'>Complete a capture matrix</h2><span id='topic+complete_capture_matrix'></span>

<h3>Description</h3>

<p><code><a href="#topic+complete_capture_matrix">complete_capture_matrix()</a></code> completes the missing, if any, columns of the
capture matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_capture_matrix(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complete_capture_matrix_+3A_m">m</code></td>
<td>
<p>A character matrix that might be missing one or more of the
following columns: <code>year</code>, <code>mon</code>, <code>mday</code>, <code>hour</code>, <code>min</code> or <code>sec</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character matrix that contains the columns <code>year</code>, <code>mon</code>, <code>mday</code>,
<code>hour</code>, <code>min</code> and <code>sec</code>. Any other existing columns are dropped.
</p>

<hr>
<h2 id='condition_add'>Add filtering tags to a data set</h2><span id='topic+condition_add'></span>

<h3>Description</h3>

<p><code>condition_add()</code> tags records in a data set, indicating which rows match the
specified conditions, resulting in a conditioned data frame. Learn how to
integrate conditioned data frames in your SDTM domain derivation in
<code>vignette("cnd_df")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition_add(dat, ..., .na = NA, .dat2 = rlang::env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="condition_add_+3A_dat">dat</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="condition_add_+3A_...">...</code></td>
<td>
<p>Conditions to filter the data frame.</p>
</td></tr>
<tr><td><code id="condition_add_+3A_.na">.na</code></td>
<td>
<p>Return value to be used when the conditions evaluate to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="condition_add_+3A_.dat2">.dat2</code></td>
<td>
<p>An optional environment to look for variables involved in
logical expression passed in <code>...</code>. A data frame or a list can also be
passed that will be coerced to an environment internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conditioned data frame, meaning a tibble with an additional class
<code>cnd_df</code> and a logical vector attribute indicating matching rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(df &lt;- tibble::tibble(x = 1L:3L, y = letters[x]))

# Mark rows for which `x` greater than `1`
(cnd_df &lt;- condition_add(dat = df, x &gt; 1L))

</code></pre>

<hr>
<h2 id='contains_oak_id_vars'>Does a vector contain the raw dataset key variables?</h2><span id='topic+contains_oak_id_vars'></span>

<h3>Description</h3>

<p><code><a href="#topic+contains_oak_id_vars">contains_oak_id_vars()</a></code> evaluates whether a character vector <code>x</code> contains
the raw dataset key variable names, i.e. the so called Oak identifier
variables &mdash; these are defined by the return value of <code><a href="#topic+oak_id_vars">oak_id_vars()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contains_oak_id_vars(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contains_oak_id_vars_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar value.
</p>

<hr>
<h2 id='create_iso8601'>Convert date or time collected values to ISO 8601</h2><span id='topic+create_iso8601'></span>

<h3>Description</h3>

<p><code><a href="#topic+create_iso8601">create_iso8601()</a></code> converts vectors of dates, times or date-times to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format. Learn more in
<code>vignette("iso_8601")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_iso8601(
  ...,
  .format,
  .fmt_c = fmt_cmp(),
  .na = NULL,
  .cutoff_2000 = 68L,
  .check_format = FALSE,
  .warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_iso8601_+3A_...">...</code></td>
<td>
<p>Character vectors of dates, times or date-times' components.</p>
</td></tr>
<tr><td><code id="create_iso8601_+3A_.format">.format</code></td>
<td>
<p>Parsing format(s). Either a character vector or a list of
character vectors. If a character vector is passed then each element is
taken as parsing format for each vector passed in <code>...</code>. If a list is
provided, then each element must be a character vector of formats. The
first vector of formats is used for parsing the first vector passed in
<code>...</code>, and so on.</p>
</td></tr>
<tr><td><code id="create_iso8601_+3A_.fmt_c">.fmt_c</code></td>
<td>
<p>A list of regexps to use when parsing <code>.format</code>. Use <code><a href="#topic+fmt_cmp">fmt_cmp()</a></code>
to create such an object to pass as argument to this parameter.</p>
</td></tr>
<tr><td><code id="create_iso8601_+3A_.na">.na</code></td>
<td>
<p>A character vector of string literals to be regarded as missing
values during parsing.</p>
</td></tr>
<tr><td><code id="create_iso8601_+3A_.cutoff_2000">.cutoff_2000</code></td>
<td>
<p>An integer value. Two-digit years smaller or equal to
<code>.cutoff_2000</code> are parsed as though starting with <code>20</code>, otherwise parsed as
though starting with <code>19</code>.</p>
</td></tr>
<tr><td><code id="create_iso8601_+3A_.check_format">.check_format</code></td>
<td>
<p>Whether to check the formats passed in <code>.format</code>,
meaning to check against a selection of validated formats in
<a href="#topic+dtc_formats">dtc_formats</a>; or to have a more permissible
interpretation of the formats.</p>
</td></tr>
<tr><td><code id="create_iso8601_+3A_.warn">.warn</code></td>
<td>
<p>Whether to warn about parsing failures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of dates, times or date-times in <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Converting dates
create_iso8601(c("2020-01-01", "20200102"), .format = "y-m-d")
create_iso8601(c("2020-01-01", "20200102"), .format = "ymd")
create_iso8601(c("2020-01-01", "20200102"), .format = list(c("y-m-d", "ymd")))

# Two-digit years are supported
create_iso8601(c("20-01-01", "200101"), .format = list(c("y-m-d", "ymd")))

# `.cutoff_2000` sets the cutoff for two-digit to four-digit year conversion
# Default is at 68.
create_iso8601(c("67-01-01", "68-01-01", "69-01-01"), .format = "y-m-d")

# Change it to 80.
create_iso8601(c("79-01-01", "80-01-01", "81-01-01"), .format = "y-m-d", .cutoff_2000 = 80)

# Converting times
create_iso8601("15:10", .format = "HH:MM")
create_iso8601("2:10", .format = "HH:MM")
create_iso8601("2:1", .format = "HH:MM")
create_iso8601("02:01:56", .format = "HH:MM:SS")
create_iso8601("020156.5", .format = "HHMMSS")

# Converting date-times
create_iso8601("12 NOV 202015:15", .format = "dd mmm yyyyHH:MM")

# Indicate allowed missing values to make the parsing pass
create_iso8601("U DEC 201914:00", .format = "dd mmm yyyyHH:MM")
create_iso8601("U DEC 201914:00", .format = "dd mmm yyyyHH:MM", .na = "U")

create_iso8601("NOV 2020", .format = "m y")
create_iso8601(c("MAR 2019", "MaR 2020", "mar 2021"), .format = "m y")

create_iso8601("2019-04-041045-", .format = "yyyy-mm-ddHHMM-")

create_iso8601("20200507null", .format = "ymd(HH:MM:SS)")
create_iso8601("20200507null", .format = "ymd((HH:MM:SS)|null)")

# Fractional seconds
create_iso8601("2019-120602:20:13.1230001", .format = "y-mdH:M:S")

# Use different reserved characters in the format specification
# Here we change "H" to "x" and "M" to "w", for hour and minute, respectively.
create_iso8601("14H00M", .format = "HHMM")
create_iso8601("14H00M", .format = "xHwM", .fmt_c = fmt_cmp(hour = "x", min = "w"))

# Alternative formats with unknown values
datetimes &lt;- c("UN UNK 201914:00", "UN JAN 2021")
format &lt;- list(c("dd mmm yyyy", "dd mmm yyyyHH:MM"))
create_iso8601(datetimes, .format = format, .na = c("UN", "UNK"))

# Dates and times may come in many format variations
fmt &lt;- "dd MMM yyyy HH nn ss"
fmt_cmp &lt;- fmt_cmp(mon = "MMM", min = "nn", sec = "ss")
create_iso8601("05 feb 1985 12 55 02", .format = fmt, .fmt_c = fmt_cmp)

</code></pre>

<hr>
<h2 id='ct_map'>Recode according to controlled terminology</h2><span id='topic+ct_map'></span>

<h3>Description</h3>

<p><code><a href="#topic+ct_map">ct_map()</a></code> recodes a vector following a controlled terminology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct_map(
  x,
  ct_spec = NULL,
  ct_clst = NULL,
  from = ct_spec_vars("from"),
  to = ct_spec_vars("to")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ct_map_+3A_x">x</code></td>
<td>
<p>A character vector of terms to be recoded following a controlled
terminology.</p>
</td></tr>
<tr><td><code id="ct_map_+3A_ct_spec">ct_spec</code></td>
<td>
<p>A <a href="tibble.html#topic+tibble-package">tibble</a> providing a controlled
terminology specification.</p>
</td></tr>
<tr><td><code id="ct_map_+3A_ct_clst">ct_clst</code></td>
<td>
<p>A character vector indicating a set of possible controlled
terminology codelists codes to be used for recoding. By default (<code>NULL</code>)
all codelists available in <code>ct_spec</code> are used.</p>
</td></tr>
<tr><td><code id="ct_map_+3A_from">from</code></td>
<td>
<p>A character vector of column names indicating the variables
containing values to be matched against for terminology recoding.</p>
</td></tr>
<tr><td><code id="ct_map_+3A_to">to</code></td>
<td>
<p>A single string indicating the column whose values are to be
recoded into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of terminology recoded values from <code>x</code>. If no
match is found in the controlled terminology spec provided in <code>ct_spec</code>, then
<code>x</code> values are returned in uppercase. If <code>ct_spec</code> is not provided <code>x</code> is
returned unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A few example terms.
terms &lt;-
  c(
    "/day",
    "Yes",
    "Unknown",
    "Prior",
    "Every 2 hours",
    "Percentage",
    "International Unit"
  )

# Load a controlled terminology example
(ct_spec &lt;- read_ct_spec_example("ct-01-cm"))

# Use all possible matching terms in the controlled terminology.
ct_map(x = terms, ct_spec = ct_spec)

# Note that if the controlled terminology mapping is restricted to a codelist
# code, e.g. C71113, then only `"/day"` and `"Every 2 hours"` get mapped to
# `"QD"` and `"Q2H"`, respectively; remaining terms won't match given the
# codelist code restriction, and will be mapped to an uppercase version of
# the original terms.
ct_map(x = terms, ct_spec = ct_spec, ct_clst = "C71113")

</code></pre>

<hr>
<h2 id='ct_mappings'>Controlled terminology mappings</h2><span id='topic+ct_mappings'></span>

<h3>Description</h3>

<p><code><a href="#topic+ct_mappings">ct_mappings()</a></code> takes a controlled terminology specification and returns the
mappings in the form of a <a href="tibble.html#topic+tibble-package">tibble</a> in long format,
i.e. the recoding of values in the <code>from</code> column to the <code>to</code> column values,
one mapping per row.
</p>
<p>The resulting mappings are unique, i.e. if <code>from</code> values are duplicated in
two <code>from</code> columns, the first column indicated in <code>from</code> takes precedence,
and only that mapping is retained in the controlled terminology map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct_mappings(ct_spec, from = ct_spec_vars("from"), to = ct_spec_vars("to"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ct_mappings_+3A_ct_spec">ct_spec</code></td>
<td>
<p>Controlled terminology specification as a
<a href="tibble.html#topic+tibble-package">tibble</a>. Each row is for a mapped controlled term.
Controlled terms are expected in the column indicated by <code>to_col</code>.</p>
</td></tr>
<tr><td><code id="ct_mappings_+3A_from">from</code></td>
<td>
<p>A character vector of column names indicating the variables
containing values to be recoded.</p>
</td></tr>
<tr><td><code id="ct_mappings_+3A_to">to</code></td>
<td>
<p>A single string indicating the column whose values are to be
recoded into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a> with two columns, <code>from</code> and
<code>to</code>, indicating the mapping of values, one per row.
</p>

<hr>
<h2 id='ct_spec_example'>Find the path to an example controlled terminology file</h2><span id='topic+ct_spec_example'></span>

<h3>Description</h3>

<p><code><a href="#topic+ct_spec_example">ct_spec_example()</a></code> resolves the local path to an example controlled
terminology file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct_spec_example(example)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ct_spec_example_+3A_example">example</code></td>
<td>
<p>A string with either the basename, file name, or relative path
to a controlled terminology file bundled with <code>{stdm.oak}</code>, see examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The local path to an example file if <code>example</code> is supplied, or a
character vector of example file names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the local path to controlled terminology example file 01
# Using the basename only:
ct_spec_example("ct-01-cm")

# Using the file name:
ct_spec_example("ct-01-cm.csv")

# Using the relative path:
ct_spec_example("ct/ct-01-cm.csv")

# If no example is provided it returns a vector of possible choices.
ct_spec_example()

</code></pre>

<hr>
<h2 id='ct_spec_vars'>Controlled terminology variables</h2><span id='topic+ct_spec_vars'></span>

<h3>Description</h3>

<p><code><a href="#topic+ct_spec_vars">ct_spec_vars()</a></code> returns the mandatory variables to be present in a data set
representing a controlled terminology. By default, it returns all required
variables.
</p>
<p>If only the subset of variables used for matching terms are needed, then
request this subset of variables by passing the argument value <code>"from"</code>. If
only the mapping-to variable is to be requested, then simply pass <code>"to"</code>. If
only the codelist code variable name is needed then pass <code>"ct_clst"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct_spec_vars(set = c("all", "ct_clst", "from", "to"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ct_spec_vars_+3A_set">set</code></td>
<td>
<p>A scalar character (string), one of: <code>"all"</code> (default), <code>"ct_clst"</code>,
<code>"from"</code> or <code>"to"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='ctl_new_rowid_pillar.cnd_df'>Conditioned tibble pillar print method</h2><span id='topic+ctl_new_rowid_pillar.cnd_df'></span>

<h3>Description</h3>

<p>Conditioned tibble pillar print method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cnd_df'
ctl_new_rowid_pillar(controller, x, width, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctl_new_rowid_pillar.cnd_df_+3A_controller">controller</code></td>
<td>
<p>The object of class <code>"tbl"</code> currently printed.</p>
</td></tr>
<tr><td><code id="ctl_new_rowid_pillar.cnd_df_+3A_x">x</code></td>
<td>
<p>A simple (one-dimensional) vector.</p>
</td></tr>
<tr><td><code id="ctl_new_rowid_pillar.cnd_df_+3A_width">width</code></td>
<td>
<p>The available width, can be a vector for multiple tiers.</p>
</td></tr>
<tr><td><code id="ctl_new_rowid_pillar.cnd_df_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector to print the tibble which is a conditioned dataframe.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tbl_sum.cnd_df">tbl_sum.cnd_df()</a></code>.
</p>

<hr>
<h2 id='dataset_oak_vignette'>Output a Dataset in a Vignette in the sdtm.oak Format</h2><span id='topic+dataset_oak_vignette'></span>

<h3>Description</h3>

<p>Output a dataset in a vignette with the pre-specified sdtm.oak format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_oak_vignette(dataset, display_vars = NULL, filter = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataset_oak_vignette_+3A_dataset">dataset</code></td>
<td>
<p>Dataset to output in the vignette</p>
</td></tr>
<tr><td><code id="dataset_oak_vignette_+3A_display_vars">display_vars</code></td>
<td>
<p>Variables selected to demonstrate the outcome of the mapping
</p>
<p>Permitted Values: list of variables
</p>
<p>Default is NULL
</p>
<p>If <code>display_vars</code> is not NULL, only the selected variables are visible in the vignette while the
other variables are hidden. They can be made visible by clicking the<code style="white-space: pre;">&#8288;Choose the columns to display&#8288;</code> button.</p>
</td></tr>
<tr><td><code id="dataset_oak_vignette_+3A_filter">filter</code></td>
<td>
<p>Filter condition
</p>
<p>The specified condition is applied to the dataset before it is displayed.
</p>
<p>Permitted Values: a condition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A HTML table
</p>

<hr>
<h2 id='derive_blfl'>Derive Baseline Flag or Last Observation Before Exposure Flag</h2><span id='topic+derive_blfl'></span>

<h3>Description</h3>

<p>Derive the baseline flag variable (<code>--BLFL</code>) or the last observation before
exposure flag (<code>--LOBXFL</code>), from the observation date/time (<code>--DTC</code>), and a
DM domain reference date/time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_blfl(
  sdtm_in,
  dm_domain,
  tgt_var,
  ref_var,
  baseline_visits = character(),
  baseline_timepoints = character()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_blfl_+3A_sdtm_in">sdtm_in</code></td>
<td>
<p>Input SDTM domain.</p>
</td></tr>
<tr><td><code id="derive_blfl_+3A_dm_domain">dm_domain</code></td>
<td>
<p>DM domain with the reference variable <code>ref_var</code></p>
</td></tr>
<tr><td><code id="derive_blfl_+3A_tgt_var">tgt_var</code></td>
<td>
<p>Name of variable to be derived (<code>--BLFL</code> or
<code>--LOBXFL</code> where <code style="white-space: pre;">&#8288;--&#8288;</code> is domain).</p>
</td></tr>
<tr><td><code id="derive_blfl_+3A_ref_var">ref_var</code></td>
<td>
<p>vector of a date/time from the
Demographics (DM) dataset, which serves as a point of comparison for other
observations in the study. Common choices for this reference variable
include &quot;RFSTDTC&quot; (the date/time of the first study treatment) or
&quot;RFXSTDTC&quot; (the date/time of the first exposure to the study drug).</p>
</td></tr>
<tr><td><code id="derive_blfl_+3A_baseline_visits">baseline_visits</code></td>
<td>
<p>A character vector specifying the baseline visits within the study.
These visits are identified as critical points for data collection at the start of the study,
before any intervention is applied.  This allows the function to assign the baseline
flag if the &ndash;DTC matches to the reference date.</p>
</td></tr>
<tr><td><code id="derive_blfl_+3A_baseline_timepoints">baseline_timepoints</code></td>
<td>
<p>A character vector of timepoints values in &ndash;TPT that specifies
the specific timepoints during the baseline visits when key assessments or measurements were taken.
This allows the function to assign the baseline flag if the &ndash;DTC matches to the reference date.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The derivation is as follows:
</p>

<ul>
<li><p> Remove records where the result (<code>--ORRES</code>) is missing. Also, exclude records
with results labeled as &quot;ND&quot; (No Data) or &quot;NOT DONE&quot; in the <code>--ORRES</code> column,
which indicate that the measurement or observation was not completed.
</p>
</li>
<li><p> Remove records where the status (<code>--STAT</code>) indicates the observation or test
was not performed, marked as &quot;NOT DONE&quot;.
</p>
</li>
<li><p> Divide the date and time column (<code>--DTC</code>) and the reference date/time
variable (<code>ref_var</code>) into separate date and time components. Ignore
any seconds recorded in the time component, focusing only on hours and
minutes for further calculations.
</p>
</li>
<li><p> Set partial or missing dates to <code>NA</code>.
</p>
</li>
<li><p> Set partial or missing times to <code>NA</code>.
</p>
</li>
<li><p> Filter on rows that have domain and reference dates not equal to
<code>NA</code>. (Ref to as <strong>X</strong>)
</p>
</li>
<li><p> Filter <strong>X</strong> on rows with domain date (&ndash;DTC) prior to (less than)
reference date. (Ref to as <strong>A</strong>)
</p>
</li>
<li><p> Filter <strong>X</strong> on rows with domain date (&ndash;DTC) equal to reference date but
domain and reference times not equal to <code>NA</code> and domain time prior to (less
than) reference time. (Ref to as <strong>B</strong>)
</p>
</li>
<li><p> Filter <strong>X</strong> on rows with domain date (&ndash;DTC) equal to reference date but
domain and/or reference time equal to NA and:
</p>

<ul>
<li><p> VISIT is in baseline visits list (if it exists) and
</p>
</li>
<li><p> xxTPT is in baseline timepoints list (if it exists).
(Ref to as <strong>C</strong>)
</p>
</li></ul>

</li>
<li><p> Combine the rows from <strong>A</strong>, <strong>B</strong>, and <strong>C</strong> to get a
data frame of pre-reference date observations. Sort the rows by <code>USUBJID</code>,
<code>--STAT</code>, and <code>--ORRES</code>.
</p>
</li>
<li><p> Group by <code>USUBJID</code> and <code>--TESTCD</code> and filter on the rows
that have maximum value from <code>--DTC</code>. Keep only the oak id variables and
<code>--TESTCD</code> (because these are the unique values). Remove any duplicate rows.
Assign the baseline flag variable, <code>--BLFL</code>, the last observation before
exposure flag (<code>--LOBXFL</code>) variable to these rows.
</p>
</li>
<li><p> Join the baseline flag onto the input dataset based on oak id vars
</p>
</li></ul>



<h3>Value</h3>

<p>Modified input data frame with baseline flag variable <code>--BLFL</code> or
last observation before exposure flag <code>--LOBXFL</code> added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dm &lt;- tibble::tribble(
  ~USUBJID, ~RFSTDTC, ~RFXSTDTC,
  "test_study-375", "2020-09-28T10:10", "2020-09-28T10:10",
  "test_study-376", "2020-09-21T11:00", "2020-09-21T11:00",
  "test_study-377", NA, NA,
  "test_study-378", "2020-01-20T10:00", "2020-01-20T10:00",
  "test_study-379", NA, NA,
)

dm

sdtm_in &lt;-
  tibble::tribble(
    ~DOMAIN,
    ~oak_id,
    ~raw_source,
    ~patient_number,
    ~USUBJID,
    ~VSDTC,
    ~VSTESTCD,
    ~VSORRES,
    ~VSSTAT,
    ~VISIT,
    "VS",
    1L,
    "VTLS1",
    375L,
    "test_study-375",
    "2020-09-01T13:31",
    "DIABP",
    "90",
    NA,
    "SCREENING",
    "VS",
    2L,
    "VTLS1",
    375L,
    "test_study-375",
    "2020-10-01T11:20",
    "DIABP",
    "90",
    NA,
    "SCREENING",
    "VS",
    1L,
    "VTLS1",
    375L,
    "test_study-375",
    "2020-09-28T10:10",
    "PULSE",
    "ND",
    NA,
    "SCREENING",
    "VS",
    2L,
    "VTLS1",
    375L,
    "test_study-375",
    "2020-10-01T13:31",
    "PULSE",
    "85",
    NA,
    "SCREENING",
    "VS",
    1L,
    "VTLS2",
    375L,
    "test_study-375",
    "2020-09-28T10:10",
    "SYSBP",
    "120",
    NA,
    "SCREENING",
    "VS",
    2L,
    "VTLS2",
    375L,
    "test_study-375",
    "2020-09-28T10:05",
    "SYSBP",
    "120",
    NA,
    "SCREENING",
    "VS",
    1L,
    "VTLS1",
    376L,
    "test_study-376",
    "2020-09-20",
    "DIABP",
    "75",
    NA,
    "SCREENING",
    "VS",
    1L,
    "VTLS1",
    376L,
    "test_study-376",
    "2020-09-20",
    "PULSE",
    NA,
    "NOT DONE",
    "SCREENING",
    "VS",
    2L,
    "VTLS1",
    376L,
    "test_study-376",
    "2020-09-20",
    "PULSE",
    "110",
    NA,
    "SCREENING",
    "VS",
    2L,
    "VTLS1",
    378L,
    "test_study-378",
    "2020-01-20T10:00",
    "PULSE",
    "110",
    NA,
    "SCREENING",
    "VS",
    3L,
    "VTLS1",
    378L,
    "test_study-378",
    "2020-01-21T11:00",
    "PULSE",
    "105",
    NA,
    "SCREENING"
  )

sdtm_in

# Example 1:
observed_output &lt;- derive_blfl(
  sdtm_in = sdtm_in,
  dm_domain = dm,
  tgt_var = "VSLOBXFL",
  ref_var = "RFXSTDTC",
  baseline_visits = c("SCREENING")
)
observed_output

# Example 2:
observed_output2 &lt;- derive_blfl(
  sdtm_in = sdtm_in,
  dm_domain = dm,
  tgt_var = "VSLOBXFL",
  ref_var = "RFXSTDTC",
  baseline_timepoints = c("PRE-DOSE")
)
observed_output2

# Example 3: Output is the same as Example 2
observed_output3 &lt;- derive_blfl(
  sdtm_in = sdtm_in,
  dm_domain = dm,
  tgt_var = "VSLOBXFL",
  ref_var = "RFXSTDTC",
  baseline_visits = c("SCREENING"),
  baseline_timepoints = c("PRE-DOSE")
)
observed_output3

</code></pre>

<hr>
<h2 id='derive_seq'>Derive the sequence number (<code>--SEQ</code>) variable</h2><span id='topic+derive_seq'></span>

<h3>Description</h3>

<p><code><a href="#topic+derive_seq">derive_seq()</a></code> creates a new identifier variable: the sequence number
(<code>--SEQ</code>).
</p>
<p>This function adds a newly derived variable to <code>tgt_dat</code>, namely the sequence
number (<code>--SEQ</code>) whose name is the one provided in <code>tgt_var</code>. An integer
sequence is generated that uniquely identifies each record within the domain.
</p>
<p>Prior to the derivation of <code>tgt_var</code>, the data frame <code>tgt_dat</code> is sorted
according to grouping variables indicated in <code>rec_vars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_seq(
  tgt_dat,
  tgt_var,
  rec_vars,
  sbj_vars = sdtm.oak::sbj_vars(),
  start_at = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_seq_+3A_tgt_dat">tgt_dat</code></td>
<td>
<p>The target dataset, a data frame.</p>
</td></tr>
<tr><td><code id="derive_seq_+3A_tgt_var">tgt_var</code></td>
<td>
<p>The target SDTM variable: a single string indicating the name
of the sequence number (<code>--SEQ</code>) variable, e.g. <code>"DSSEQ"</code>. Note that
supplying a name not ending in <code>"SEQ"</code> will raise a warning.</p>
</td></tr>
<tr><td><code id="derive_seq_+3A_rec_vars">rec_vars</code></td>
<td>
<p>A character vector of record-level identifier variables.</p>
</td></tr>
<tr><td><code id="derive_seq_+3A_sbj_vars">sbj_vars</code></td>
<td>
<p>A character vector of subject-level identifier variables.</p>
</td></tr>
<tr><td><code id="derive_seq_+3A_start_at">start_at</code></td>
<td>
<p>The sequence numbering starts at this value (default is <code>1</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the data frame supplied in <code>tgt_dat</code> with the newly derived
variable, i.e. the sequence number (<code>--SEQ</code>), whose name is that passed in
<code>tgt_var</code>. This variable is of type integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A VS raw data set example
(vs &lt;- read_domain_example("vs"))

# Derivation of VSSEQ
rec_vars &lt;- c("STUDYID", "USUBJID", "VSTESTCD", "VSDTC", "VSTPTNUM")
derive_seq(tgt_dat = vs, tgt_var = "VSSEQ", rec_vars = rec_vars)

# An APSC raw data set example
(apsc &lt;- read_domain_example("apsc"))

# Derivation of APSEQ
derive_seq(
  tgt_dat = apsc,
  tgt_var = "APSEQ",
  rec_vars = c("STUDYID", "RSUBJID", "SCTESTCD"),
  sbj_vars = c("STUDYID", "RSUBJID")
)
</code></pre>

<hr>
<h2 id='derive_study_day'><code>derive_study_day</code> performs study day calculation</h2><span id='topic+derive_study_day'></span>

<h3>Description</h3>

<p>This function takes the an input data frame and a reference data frame (which
is DM domain in most cases), and calculate the study day from reference date
and target date. In case of unexpected conditions like reference date is not
unique for each patient, or reference and input dates are not actual dates,
NA will be returned for those records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_study_day(
  sdtm_in,
  dm_domain,
  tgdt,
  refdt,
  study_day_var,
  merge_key = "USUBJID"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_study_day_+3A_sdtm_in">sdtm_in</code></td>
<td>
<p>Input data frame that contains the target date.</p>
</td></tr>
<tr><td><code id="derive_study_day_+3A_dm_domain">dm_domain</code></td>
<td>
<p>Reference date frame that contains the reference date.</p>
</td></tr>
<tr><td><code id="derive_study_day_+3A_tgdt">tgdt</code></td>
<td>
<p>Target date from <code>sdtm_in</code> that will be used to calculate the study
day.</p>
</td></tr>
<tr><td><code id="derive_study_day_+3A_refdt">refdt</code></td>
<td>
<p>Reference date from <code>dm_domain</code> that will be used as reference to
calculate the study day.</p>
</td></tr>
<tr><td><code id="derive_study_day_+3A_study_day_var">study_day_var</code></td>
<td>
<p>New study day variable name in the output. For
example, AESTDY for AE domain and CMSTDY for CM domain.</p>
</td></tr>
<tr><td><code id="derive_study_day_+3A_merge_key">merge_key</code></td>
<td>
<p>Character to represent the merging key between <code>sdtm_in</code> and
<code>dm_domain</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame that takes all columns from <code>sdtm_in</code> and a new variable
to represent the calculated study day.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ae &lt;- data.frame(
  USUBJID = c("study123-123", "study123-124", "study123-125"),
  AESTDTC = c("2012-01-01", "2012-04-14", "2012-04-14")
)
dm &lt;- data.frame(
  USUBJID = c("study123-123", "study123-124", "study123-125"),
  RFSTDTC = c("2012-02-01", "2012-04-14", NA)
)
ae$AESTDTC &lt;- as.Date(ae$AESTDTC)
dm$RFSTDTC &lt;- as.Date(dm$RFSTDTC)
derive_study_day(ae, dm, "AESTDTC", "RFSTDTC", "AESTDY")

</code></pre>

<hr>
<h2 id='domain_example'>Find the path to an example SDTM domain file</h2><span id='topic+domain_example'></span>

<h3>Description</h3>

<p><code><a href="#topic+domain_example">domain_example()</a></code> resolves the local path to a SDTM domain example file. The
domain examples files were imported from
<a href="https://cran.r-project.org/package=pharmaversesdtm">pharmaversesdtm</a>. See
Details section for available datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_example(example)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="domain_example_+3A_example">example</code></td>
<td>
<p>A string with either the basename, file name, or relative path
to a SDTM domain example file bundled with <code>{stdm.oak}</code>, e.g. <code>"cm"</code>
(Concomitant Medication) or <code>"ae"</code> (Adverse Events).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Datasets were obtained from
<a href="https://cran.r-project.org/package=pharmaversesdtm">pharmaversesdtm</a> but are
originally sourced from the <a href="https://github.com/cdisc-org/sdtm-adam-pilot-project">CDISC pilot project</a> or have been
constructed ad-hoc by the
<a href="https://cran.r-project.org/package=admiral">admiral</a> team. These datasets
are bundled with <code>{sdtm.oak}</code>, thus obviating a dependence on
<code>{pharmaversesdtm}</code>.
</p>


<h4>Example SDTM domains</h4>


<ul>
<li> <p><code>"ae"</code>: Adverse Events (AE) data set.
</p>
</li>
<li> <p><code>"apsc"</code>: Associated Persons Subject Characteristics (APSC) data set.
</p>
</li>
<li> <p><code>"cm"</code>: Concomitant Medications (CM) data set.
</p>
</li>
<li> <p><code>"vs"</code>: Vital Signs (VS) data set.
</p>
</li></ul>




<h3>Value</h3>

<p>The local path to an example file if <code>example</code> is supplied, or a
character vector of example file names.
</p>


<h3>Source</h3>

<p>See <a href="https://cran.r-project.org/package=pharmaversesdtm">https://cran.r-project.org/package=pharmaversesdtm</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_domain_example">read_domain_example()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If no example is provided it returns a vector of possible choices.
domain_example()

# Get the local path to the Concomitant Medication dataset file.
domain_example("cm")

# Local path to the Adverse Events dataset file.
domain_example("ae")

</code></pre>

<hr>
<h2 id='dtc_datepart'>Extract date part from ISO8601 date/time variable</h2><span id='topic+dtc_datepart'></span>

<h3>Description</h3>

<p>The date part is extracted from an ISO8601 date/time variable.
By default, partial or missing dates are set to NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtc_datepart(dtc, partial_as_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtc_datepart_+3A_dtc">dtc</code></td>
<td>
<p>Character vector containing ISO8601 date/times.</p>
</td></tr>
<tr><td><code id="dtc_datepart_+3A_partial_as_na">partial_as_na</code></td>
<td>
<p>Logical <code>TRUE</code> or <code>FALSE</code> indicating whether
partial dates should be set to NA (default is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector containing ISO8601 dates.
</p>

<hr>
<h2 id='dtc_formats'>Date/time collection formats</h2><span id='topic+dtc_formats'></span>

<h3>Description</h3>

<p>Date/time collection formats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtc_formats
</code></pre>


<h3>Format</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a> of 20 formats
with three variables:
</p>

<dl>
<dt><code>fmt</code></dt><dd><p>Format string.</p>
</dd>
<dt><code>type</code></dt><dd><p>Whether a date, time or date-time.</p>
</dd>
<dt><code>description</code></dt><dd><p>Description of which date-time components are parsed.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>dtc_formats

</code></pre>

<hr>
<h2 id='dtc_timepart'>Extract time part from ISO 8601 date/time variable</h2><span id='topic+dtc_timepart'></span>

<h3>Description</h3>

<p>The time part is extracted from an ISO 8601 date/time variable.
By default, partial or missing times are set to NA, and seconds are ignored
and not extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtc_timepart(dtc, partial_as_na = TRUE, ignore_seconds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtc_timepart_+3A_dtc">dtc</code></td>
<td>
<p>Character vector containing ISO 8601 date/times.</p>
</td></tr>
<tr><td><code id="dtc_timepart_+3A_partial_as_na">partial_as_na</code></td>
<td>
<p>Logical <code>TRUE</code> or <code>FALSE</code> indicating whether
partial times should be set to NA (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dtc_timepart_+3A_ignore_seconds">ignore_seconds</code></td>
<td>
<p>Logical <code>TRUE</code> or <code>FALSE</code> indicating whether
seconds should be ignored (default is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector containing ISO 8601 times.
</p>

<hr>
<h2 id='dttm_fmt_to_regex'>Convert a parsed date/time format to regex</h2><span id='topic+dttm_fmt_to_regex'></span>

<h3>Description</h3>

<p><code><a href="#topic+dttm_fmt_to_regex">dttm_fmt_to_regex()</a></code> takes a <a href="tibble.html#topic+tibble-package">tibble</a> of parsed
date/time format components (as returned by <code><a href="#topic+parse_dttm_fmt">parse_dttm_fmt()</a></code>), and a
mapping of date/time component formats to regexps and generates a single
regular expression with groups for matching each of the date/time components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dttm_fmt_to_regex(
  fmt,
  fmt_regex = fmt_rg(),
  fmt_c = fmt_cmp(),
  anchored = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dttm_fmt_to_regex_+3A_fmt">fmt</code></td>
<td>
<p>A format string (scalar) to be parsed by <code>patterns</code>.</p>
</td></tr>
<tr><td><code id="dttm_fmt_to_regex_+3A_fmt_regex">fmt_regex</code></td>
<td>
<p>A named character vector of regexps, one for each date/time
component.</p>
</td></tr>
<tr><td><code id="dttm_fmt_to_regex_+3A_anchored">anchored</code></td>
<td>
<p>Whether the final regex should be anchored, i.e. bounded by
<code>"^"</code> and <code>"$"</code> for a whole match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing a regular expression for matching date/time
components according to a format.
</p>

<hr>
<h2 id='eval_conditions'>Evaluate conditions</h2><span id='topic+eval_conditions'></span>

<h3>Description</h3>

<p><code><a href="#topic+eval_conditions">eval_conditions()</a></code> evaluates a set of conditions in the context of a
data frame and an optional environment.
</p>
<p>The utility of this function is to provide an easy way to generate a logical
vector of matching records from a set of logical conditions involving
variables in a data frame (<code>dat</code>) and optionally in a supplementary
environment (<code>.env</code>). The set of logical conditions are provided as
expressions to be evaluated in the context of <code>dat</code> and <code>.env</code>.
</p>
<p>Variables are looked up in <code>dat</code>, then in <code>.env</code>, then in the calling
function's environment, followed by its parent environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_conditions(dat, ..., .na = NA, .env = rlang::caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_conditions_+3A_dat">dat</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="eval_conditions_+3A_...">...</code></td>
<td>
<p>A set of logical conditions, e.g. <code style="white-space: pre;">&#8288;y &amp; z, x | z&#8288;</code> (<code>x</code>, <code>y</code>, <code>z</code>
would have to exist either as columns in <code>dat</code> or in the environment
<code>.env</code>). If multiple expressions are included, they are combined with the
<code>&amp;</code> operator.</p>
</td></tr>
<tr><td><code id="eval_conditions_+3A_.na">.na</code></td>
<td>
<p>Return value to be used when the conditions evaluate to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="eval_conditions_+3A_.env">.env</code></td>
<td>
<p>An optional environment to look for variables involved in logical
expression passed in <code>...</code>. A data frame or a list can also be passed that
will be coerced to an environment internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector reflecting matching rows in <code>dat</code>.
</p>

<hr>
<h2 id='find_int_gap'>Find gap intervals in integer sequences</h2><span id='topic+find_int_gap'></span>

<h3>Description</h3>

<p><code><a href="#topic+find_int_gap">find_int_gap()</a></code> determines the <code>start</code> and <code>end</code> positions for gap intervals
in a sequence of integers. By default, the interval range to look for gaps is
defined by the minimum and maximum values of <code>x</code>; specify <code>xmin</code> and <code>xmax</code>
to change the range explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_int_gap(x, xmin = min(x), xmax = max(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_int_gap_+3A_x">x</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="find_int_gap_+3A_xmin">xmin</code></td>
<td>
<p>Left endpoint integer value.</p>
</td></tr>
<tr><td><code id="find_int_gap_+3A_xmax">xmax</code></td>
<td>
<p>Right endpoint integer value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a> of gap intervals of two columns:
</p>

<ul>
<li> <p><code>start</code>: left endpoint
</p>
</li>
<li> <p><code>end</code>: right endpoint
If no gap intervals are found then an empty <a href="tibble.html#topic+tibble-package">tibble</a>
is returned.
</p>
</li></ul>


<hr>
<h2 id='fmt_cmp'>Regexps for date/time format components</h2><span id='topic+fmt_cmp'></span>

<h3>Description</h3>

<p><code><a href="#topic+fmt_cmp">fmt_cmp()</a></code> creates a character vector of patterns to match individual
format date/time components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmt_cmp(
  sec = "S+",
  min = "M+",
  hour = "H+",
  mday = "d+",
  mon = "m+",
  year = "y+"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmt_cmp_+3A_sec">sec</code></td>
<td>
<p>A string pattern for matching the second format component.</p>
</td></tr>
<tr><td><code id="fmt_cmp_+3A_min">min</code></td>
<td>
<p>A string pattern for matching the minute format component.</p>
</td></tr>
<tr><td><code id="fmt_cmp_+3A_hour">hour</code></td>
<td>
<p>A string pattern for matching the hour format component.</p>
</td></tr>
<tr><td><code id="fmt_cmp_+3A_mday">mday</code></td>
<td>
<p>A string pattern for matching the month day format component.</p>
</td></tr>
<tr><td><code id="fmt_cmp_+3A_mon">mon</code></td>
<td>
<p>A string pattern for matching the month format component.</p>
</td></tr>
<tr><td><code id="fmt_cmp_+3A_year">year</code></td>
<td>
<p>A string pattern for matching the year format component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector of date/time format patterns. This a vector
of six elements, one for each date/time component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Regexps to parse format components
fmt_cmp()

fmt_cmp(year = "yyyy")

</code></pre>

<hr>
<h2 id='fmt_rg'>Regexps for date/time components</h2><span id='topic+fmt_rg'></span>

<h3>Description</h3>

<p><code><a href="#topic+fmt_rg">fmt_rg()</a></code> creates a character vector of named patterns to match individual
date/time components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmt_rg(
  sec = "(\\b\\d|\\d{2})(\\.\\d*)?",
  min = "(\\b\\d|\\d{2})",
  hour = "\\d?\\d",
  mday = "\\b\\d|\\d{2}",
  mon = stringr::str_glue("\\d\\d|{months_abb_regex()}"),
  year = "(\\d{2})?\\d{2}",
  na = NULL,
  sec_na = na,
  min_na = na,
  hour_na = na,
  mday_na = na,
  mon_na = na,
  year_na = na
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmt_rg_+3A_sec">sec</code></td>
<td>
<p>Regexp for the second component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_min">min</code></td>
<td>
<p>Regexp for the minute component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_hour">hour</code></td>
<td>
<p>Regexp for the hour component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_mday">mday</code></td>
<td>
<p>Regexp for the month day component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_mon">mon</code></td>
<td>
<p>Regexp for the month component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_year">year</code></td>
<td>
<p>Regexp for the year component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_na">na</code></td>
<td>
<p>Regexp of alternatives, useful to match special values coding for
missingness.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_sec_na">sec_na</code></td>
<td>
<p>Same as <code>na</code> but specifically for the second component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_min_na">min_na</code></td>
<td>
<p>Same as <code>na</code> but specifically for the minute component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_hour_na">hour_na</code></td>
<td>
<p>Same as <code>na</code> but specifically for the hour component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_mday_na">mday_na</code></td>
<td>
<p>Same as <code>na</code> but specifically for the month day component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_mon_na">mon_na</code></td>
<td>
<p>Same as <code>na</code> but specifically for the month component.</p>
</td></tr>
<tr><td><code id="fmt_rg_+3A_year_na">year_na</code></td>
<td>
<p>Same as <code>na</code> but specifically for the year component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector of named patterns (regexps) for matching
each date/time component.
</p>

<hr>
<h2 id='format_iso8601'>Convert date/time components into ISO8601 format</h2><span id='topic+format_iso8601'></span>

<h3>Description</h3>

<p><code><a href="#topic+format_iso8601">format_iso8601()</a></code> takes a character matrix of date/time components and
converts each component to ISO8601 format. In practice this entails
converting years to a four digit number, and month, day, hours, minutes and
seconds to two-digit numbers. Not available (<code>NA</code>) components are converted
to <code>"-"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_iso8601(m, .cutoff_2000 = 68L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_iso8601_+3A_m">m</code></td>
<td>
<p>A character matrix of date/time components. It must have six
named columns: <code>year</code>, <code>mon</code>, <code>mday</code>, <code>hour</code>, <code>min</code> and <code>sec</code>.</p>
</td></tr>
<tr><td><code id="format_iso8601_+3A_.cutoff_2000">.cutoff_2000</code></td>
<td>
<p>An integer value. Two-digit years smaller or equal to
<code>.cutoff_2000</code> are parsed as though starting with <code>20</code>, otherwise parsed as
though starting with <code>19</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with date-times following the ISO8601 format.
</p>

<hr>
<h2 id='generate_oak_id_vars'>A function to generate oak_id_vars</h2><span id='topic+generate_oak_id_vars'></span>

<h3>Description</h3>

<p>A function to generate oak_id_vars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_oak_id_vars(raw_dat, pat_var, raw_src)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_oak_id_vars_+3A_raw_dat">raw_dat</code></td>
<td>
<p>The raw dataset (dataframe)</p>
</td></tr>
<tr><td><code id="generate_oak_id_vars_+3A_pat_var">pat_var</code></td>
<td>
<p>Variable that holds the patient number</p>
</td></tr>
<tr><td><code id="generate_oak_id_vars_+3A_raw_src">raw_src</code></td>
<td>
<p>Name of the raw source</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw_dataset &lt;-
  tibble::tribble(
    ~patnum, ~MDRAW,
    101L, "BABY ASPIRIN",
    102L, "CORTISPORIN",
    103L, NA_character_,
    104L, "DIPHENHYDRAMINE HCL"
  )

# Generate oak_id_vars
generate_oak_id_vars(
  raw_dat = raw_dataset,
  pat_var = "patnum",
  raw_src = "Concomitant Medication"
)
</code></pre>

<hr>
<h2 id='get_cnd_df_cnd'>Get the conditioning vector from a conditioned data frame</h2><span id='topic+get_cnd_df_cnd'></span>

<h3>Description</h3>

<p><code><a href="#topic+get_cnd_df_cnd">get_cnd_df_cnd()</a></code> extracts the conditioning vector from a conditioned data
frame, i.e. from an object of class <code>cnd_df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cnd_df_cnd(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cnd_df_cnd_+3A_dat">dat</code></td>
<td>
<p>A conditioned data frame (<code>cnd_df</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The conditioning vector (<code>cnd</code>) if <code>dat</code> is a conditioned data frame
(<code>cnd_df</code>), otherwise <code>NULL</code>, or <code>NULL</code> if <code>dat</code> is not a conditioned data
frame (<code>cnd_df</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_cnd_df">new_cnd_df()</a></code>, <code><a href="#topic+is_cnd_df">is_cnd_df()</a></code>, <code><a href="#topic+get_cnd_df_cnd_sum">get_cnd_df_cnd_sum()</a></code>,
<code><a href="#topic+rm_cnd_df">rm_cnd_df()</a></code>.
</p>

<hr>
<h2 id='get_cnd_df_cnd_sum'>Get the summary of the conditioning vector from a conditioned data frame</h2><span id='topic+get_cnd_df_cnd_sum'></span>

<h3>Description</h3>

<p><code><a href="#topic+get_cnd_df_cnd_sum">get_cnd_df_cnd_sum()</a></code> extracts the tally of the conditioning vector from a
conditioned data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cnd_df_cnd_sum(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cnd_df_cnd_sum_+3A_dat">dat</code></td>
<td>
<p>A conditioned data frame (<code>cnd_df</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of three elements providing the sum of <code>TRUE</code>, <code>FALSE</code>, and
<code>NA</code> values in the conditioning vector (<code>cnd</code>), or <code>NULL</code> if <code>dat</code> is not
a conditioned data frame (<code>cnd_df</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_cnd_df">new_cnd_df()</a></code>, <code><a href="#topic+is_cnd_df">is_cnd_df()</a></code>, <code><a href="#topic+get_cnd_df_cnd">get_cnd_df_cnd()</a></code>, <code><a href="#topic+rm_cnd_df">rm_cnd_df()</a></code>.
</p>

<hr>
<h2 id='harcode'>Derive an SDTM variable with a hardcoded value</h2><span id='topic+harcode'></span><span id='topic+hardcode_no_ct'></span><span id='topic+hardcode_ct'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+hardcode_no_ct">hardcode_no_ct()</a></code> maps a hardcoded value to a target SDTM variable that has
no terminology restrictions.
</p>
</li>
<li> <p><code><a href="#topic+hardcode_ct">hardcode_ct()</a></code> maps a hardcoded value to a target SDTM variable with
controlled terminology recoding.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>hardcode_no_ct(
  tgt_dat = NULL,
  tgt_val,
  raw_dat,
  raw_var,
  tgt_var,
  id_vars = oak_id_vars()
)

hardcode_ct(
  tgt_dat = NULL,
  tgt_val,
  raw_dat,
  raw_var,
  tgt_var,
  ct_spec,
  ct_clst,
  id_vars = oak_id_vars()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="harcode_+3A_tgt_dat">tgt_dat</code></td>
<td>
<p>Target dataset: a data frame to be merged against <code>raw_dat</code> by
the variables indicated in <code>id_vars</code>. This parameter is optional, see
section Value for how the output changes depending on this argument value.</p>
</td></tr>
<tr><td><code id="harcode_+3A_tgt_val">tgt_val</code></td>
<td>
<p>The target SDTM value to be hardcoded into the variable
indicated in <code>tgt_var</code>.</p>
</td></tr>
<tr><td><code id="harcode_+3A_raw_dat">raw_dat</code></td>
<td>
<p>The raw dataset (dataframe); must include the
variables passed in <code>id_vars</code> and <code>raw_var</code>.</p>
</td></tr>
<tr><td><code id="harcode_+3A_raw_var">raw_var</code></td>
<td>
<p>The raw variable: a single string indicating the name of the
raw variable in <code>raw_dat</code>.</p>
</td></tr>
<tr><td><code id="harcode_+3A_tgt_var">tgt_var</code></td>
<td>
<p>The target SDTM variable: a single string indicating the name
of variable to be derived.</p>
</td></tr>
<tr><td><code id="harcode_+3A_id_vars">id_vars</code></td>
<td>
<p>Key variables to be used in the join between the raw dataset
(<code>raw_dat</code>) and the target data set (<code>raw_dat</code>).</p>
</td></tr>
<tr><td><code id="harcode_+3A_ct_spec">ct_spec</code></td>
<td>
<p>Study controlled terminology specification: a dataframe with a
minimal set of columns, see <code><a href="#topic+ct_spec_vars">ct_spec_vars()</a></code> for details. This parameter is
optional, if left as <code>NULL</code> no controlled terminology recoding is applied.</p>
</td></tr>
<tr><td><code id="harcode_+3A_ct_clst">ct_clst</code></td>
<td>
<p>A codelist code indicating which subset of the controlled
terminology to apply in the derivation. This parameter is optional, if left
as <code>NULL</code>, all possible recodings in <code>ct_spec</code> are attempted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned data set depends on the value of <code>tgt_dat</code>:
</p>

<ul>
<li><p> If no target dataset is supplied, meaning that <code>tgt_dat</code> defaults to
<code>NULL</code>, then the returned data set is <code>raw_dat</code>, selected for the variables
indicated in <code>id_vars</code>, and a new extra column: the derived variable, as
indicated in <code>tgt_var</code>.
</p>
</li>
<li><p> If the target dataset is provided, then it is merged with the raw data set
<code>raw_dat</code> by the variables indicated in <code>id_vars</code>, with a new column: the
derived variable, as indicated in <code>tgt_var</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>md1 &lt;-
  tibble::tribble(
    ~oak_id, ~raw_source, ~patient_number, ~MDRAW,
    1L,      "MD1",       101L,            "BABY ASPIRIN",
    2L,      "MD1",       102L,            "CORTISPORIN",
    3L,      "MD1",       103L,            NA_character_,
    4L,      "MD1",       104L,            "DIPHENHYDRAMINE HCL"
  )

# Derive a new variable `CMCAT` by overwriting `MDRAW` with the
# hardcoded value "GENERAL CONCOMITANT MEDICATIONS".
hardcode_no_ct(
  tgt_val = "GENERAL CONCOMITANT MEDICATIONS",
  raw_dat = md1,
  raw_var = "MDRAW",
  tgt_var = "CMCAT"
)

cm_inter &lt;-
  tibble::tribble(
    ~oak_id, ~raw_source, ~patient_number, ~CMTRT,                ~CMINDC,
    1L,      "MD1",       101L,            "BABY ASPIRIN",        NA,
    2L,      "MD1",       102L,            "CORTISPORIN",         "NAUSEA",
    3L,      "MD1",       103L,            "ASPIRIN",             "ANEMIA",
    4L,      "MD1",       104L,            "DIPHENHYDRAMINE HCL", "NAUSEA",
    5L,      "MD1",       105L,            "PARACETAMOL",         "PYREXIA"
  )

# Derive a new variable `CMCAT` by overwriting `MDRAW` with the
# hardcoded value "GENERAL CONCOMITANT MEDICATIONS" with a prior join to
# `target_dataset`.
hardcode_no_ct(
  tgt_dat = cm_inter,
  tgt_val = "GENERAL CONCOMITANT MEDICATIONS",
  raw_dat = md1,
  raw_var = "MDRAW",
  tgt_var = "CMCAT"
)

# Controlled terminology specification
(ct_spec &lt;- read_ct_spec_example("ct-01-cm"))

# Hardcoding of `CMCAT` with the value `"GENERAL CONCOMITANT MEDICATIONS"`
# involving terminology recoding. `NA` values in `MDRAW` are preserved in
# `CMCAT`.
hardcode_ct(
  tgt_dat = cm_inter,
  tgt_var = "CMCAT",
  raw_dat = md1,
  raw_var = "MDRAW",
  tgt_val = "GENERAL CONCOMITANT MEDICATIONS",
  ct_spec = ct_spec,
  ct_clst = "C66729"
)

</code></pre>

<hr>
<h2 id='index_for_recode'>Determine Indices for Recoding</h2><span id='topic+index_for_recode'></span>

<h3>Description</h3>

<p><code><a href="#topic+index_for_recode">index_for_recode()</a></code> identifies the positions of elements in <code>x</code> that match
any of the values specified in the <code>from</code> vector. This function is primarily
used to facilitate the recoding of values by pinpointing which elements in
<code>x</code> correspond to the <code>from</code> values and thus need to be replaced or updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_for_recode(x, from)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index_for_recode_+3A_x">x</code></td>
<td>
<p>A vector of values in which to search for matches.</p>
</td></tr>
<tr><td><code id="index_for_recode_+3A_from">from</code></td>
<td>
<p>A vector of values to match against the elements in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of the same length as <code>x</code>, containing the indices
of the matched values from the <code>from</code> vector. If an element in <code>x</code> does not
match any value in <code>from</code>, the corresponding position in the output will be
<code>NA</code>. This index information is critical for subsequent recoding operations.
</p>

<hr>
<h2 id='is_cnd_df'>Check if a data frame is a conditioned data frame</h2><span id='topic+is_cnd_df'></span>

<h3>Description</h3>

<p><code><a href="#topic+is_cnd_df">is_cnd_df()</a></code> checks whether a data frame is a conditioned data frame, i.e.
of class <code>cnd_df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_cnd_df(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_cnd_df_+3A_dat">dat</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>dat</code> is a conditioned data frame (class <code>cnd_df</code>),
otherwise <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_cnd_df">new_cnd_df()</a></code>, <code><a href="#topic+get_cnd_df_cnd">get_cnd_df_cnd()</a></code>, <code><a href="#topic+get_cnd_df_cnd_sum">get_cnd_df_cnd_sum()</a></code>,
<code><a href="#topic+rm_cnd_df">rm_cnd_df()</a></code>.
</p>

<hr>
<h2 id='is_seq_name'>Is it a &ndash;SEQ variable name</h2><span id='topic+is_seq_name'></span>

<h3>Description</h3>

<p><code><a href="#topic+is_seq_name">is_seq_name()</a></code> returns which variable names end in <code>"SEQ"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_seq_name(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_seq_name_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>

<hr>
<h2 id='iso8601_mon'>Format as a ISO8601 month</h2><span id='topic+iso8601_mon'></span>

<h3>Description</h3>

<p><code><a href="#topic+iso8601_mon">iso8601_mon()</a></code> converts a character vector whose values represent numeric
or abbreviated month names to zero-padded numeric months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso8601_mon(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso8601_mon_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='iso8601_na'>Convert NA to <code>"-"</code></h2><span id='topic+iso8601_na'></span>

<h3>Description</h3>

<p><code><a href="#topic+iso8601_na">iso8601_na()</a></code> takes a character vector and converts <code>NA</code> values to <code>"-"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso8601_na(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso8601_na_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='iso8601_sec'>Format as ISO8601 seconds</h2><span id='topic+iso8601_sec'></span>

<h3>Description</h3>

<p><code><a href="#topic+iso8601_sec">iso8601_sec()</a></code> converts a character vector whose values represent seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso8601_sec(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso8601_sec_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='iso8601_truncate'>Truncate a partial ISO8601 date-time</h2><span id='topic+iso8601_truncate'></span>

<h3>Description</h3>

<p><code><a href="#topic+iso8601_truncate">iso8601_truncate()</a></code> converts a character vector of ISO8601 dates, times or
date-times that might be partial and truncates the format by removing those
missing components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso8601_truncate(x, empty_as_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso8601_truncate_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='iso8601_two_digits'>Format as a ISO8601 two-digit number</h2><span id='topic+iso8601_two_digits'></span>

<h3>Description</h3>

<p><code><a href="#topic+iso8601_two_digits">iso8601_two_digits()</a></code> converts a single digit or two digit number into a
two digit, 0-padded, number. Failing to parse the input as a two digit number
results in <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso8601_two_digits(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso8601_two_digits_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same size as <code>x</code>.
</p>

<hr>
<h2 id='iso8601_year'>Format as a ISO8601 four-digit year</h2><span id='topic+iso8601_year'></span>

<h3>Description</h3>

<p><code><a href="#topic+iso8601_year">iso8601_year()</a></code> converts a character vector whose values represent years to
four-digit years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso8601_year(x, cutoff_2000 = 68L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso8601_year_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="iso8601_year_+3A_cutoff_2000">cutoff_2000</code></td>
<td>
<p>A non-negative integer value. Two-digit years smaller or
equal to <code>cutoff_2000</code> are parsed as though starting with <code>20</code>, otherwise
parsed as though starting with <code>19</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='months_abb_regex'>Regex for months' abbreviations</h2><span id='topic+months_abb_regex'></span>

<h3>Description</h3>

<p><code><a href="#topic+months_abb_regex">months_abb_regex()</a></code> generates a regex that matches month abbreviations. For
finer control, the case can be specified with parameter <code>case</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>months_abb_regex(x = month.abb, case = c("any", "upper", "lower", "title"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="months_abb_regex_+3A_x">x</code></td>
<td>
<p>A character vector of three-letter month abbreviations. Default is
<code>month.abb</code>.</p>
</td></tr>
<tr><td><code id="months_abb_regex_+3A_case">case</code></td>
<td>
<p>A string scalar: <code>"any"</code>, if month abbreviations are to be
matched in any case; <code>"upper"</code>, to match uppercase abbreviations;
<code>"lower"</code>, to match lowercase; and, <code>"title"</code> to match title case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A regex as a string.
</p>

<hr>
<h2 id='mutate.cnd_df'>Mutate method for conditioned data frames</h2><span id='topic+mutate.cnd_df'></span>

<h3>Description</h3>

<p><code><a href="#topic+mutate.cnd_df">mutate.cnd_df()</a></code> is an S3 method to be dispatched by <a href="dplyr.html#topic+mutate">mutate</a>
generic on conditioned data frames. This function implements a conditional
mutate by only changing rows for which the condition stored in the
conditioned data frame is <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cnd_df'
mutate(
  .data,
  ...,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate.cnd_df_+3A_.data">.data</code></td>
<td>
<p>A conditioned data frame.</p>
</td></tr>
<tr><td><code id="mutate.cnd_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate.cnd_df_+3A_.by">.by</code></td>
<td>
<p>Not used when <code>.data</code> is a conditioned data frame.</p>
</td></tr>
<tr><td><code id="mutate.cnd_df_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate.cnd_df_+3A_.before">.before</code></td>
<td>
<p>Not used, use <code>.after</code> instead.</p>
</td></tr>
<tr><td><code id="mutate.cnd_df_+3A_.after">.after</code></td>
<td>
<p>Control where new columns should appear, i.e. after which
columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A conditioned data frame, meaning a tibble with mutated values.
</p>

<hr>
<h2 id='new_cnd_df'>Create a data frame with filtering tags</h2><span id='topic+new_cnd_df'></span>

<h3>Description</h3>

<p><code><a href="#topic+new_cnd_df">new_cnd_df()</a></code> creates a <em>conditioned</em> data frame, classed <code>cnd_df</code>, meaning
that this function extends the data frame passed as argument by storing a
logical vector <code>cnd</code> (as attribute) that marks rows for posterior conditional
transformation by methods that support <em>conditioned</em> data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_cnd_df(dat, cnd, .warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_cnd_df_+3A_dat">dat</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="new_cnd_df_+3A_cnd">cnd</code></td>
<td>
<p>A logical vector. Length must match the number of rows in <code>dat</code>.</p>
</td></tr>
<tr><td><code id="new_cnd_df_+3A_.warn">.warn</code></td>
<td>
<p>Whether to warn about creating a new <em>conditioned</em> data frame
in case that <code>dat</code> already is one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame <code>dat</code> with the additional class <code>"cnd_df"</code> and the
following attributes:
</p>

<ul>
<li> <p><code>cnd</code>: The logical vector passed as argument <code>cnd</code>: <code>TRUE</code> values mark
rows in <code>dat</code> to be used for transformations; rows marked with <code>FALSE</code> are
not transformed; and <code>NA</code> mark rows whose transformations are to be applied
resulting in <code>NA</code>.
</p>
</li>
<li> <p><code>cnd_sum</code>: An integer vector of three elements providing the sum of <code>TRUE</code>,
<code>FALSE</code> and <code>NA</code> values in <code>cnd</code>, respectively.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+is_cnd_df">is_cnd_df()</a></code>, <code><a href="#topic+get_cnd_df_cnd">get_cnd_df_cnd()</a></code>, <code><a href="#topic+get_cnd_df_cnd_sum">get_cnd_df_cnd_sum()</a></code>,
<code><a href="#topic+rm_cnd_df">rm_cnd_df()</a></code>.
</p>

<hr>
<h2 id='oak_id_vars'>Raw dataset keys</h2><span id='topic+oak_id_vars'></span>

<h3>Description</h3>

<p><code><a href="#topic+oak_id_vars">oak_id_vars()</a></code> is a helper function providing the variable (column) names to
be regarded as keys in <a href="tibble.html#topic+tibble-package">tibbles</a> representing raw
datasets. By default, the set of names is
oak_id, raw_source, and patient_number. Extra variable names may be
indicated and passed in <code>extra_vars</code> which are appended to the default names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oak_id_vars(extra_vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oak_id_vars_+3A_extra_vars">extra_vars</code></td>
<td>
<p>A character vector of extra column names to be appended to
the default names: oak_id, raw_source, and patient_number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of column names to be regarded
as keys in raw datasets.
</p>

<hr>
<h2 id='parse_dttm_'>Parse a date, time, or date-time</h2><span id='topic+parse_dttm_'></span><span id='topic+parse_dttm'></span>

<h3>Description</h3>

<p><code><a href="#topic+parse_dttm">parse_dttm()</a></code> extracts date and time components. <code><a href="#topic+parse_dttm">parse_dttm()</a></code> wraps around
<code><a href="#topic+parse_dttm_">parse_dttm_()</a></code>, which is not vectorized over <code>fmt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_dttm_(
  dttm,
  fmt,
  fmt_c = fmt_cmp(),
  na = NULL,
  sec_na = na,
  min_na = na,
  hour_na = na,
  mday_na = na,
  mon_na = na,
  year_na = na
)

parse_dttm(
  dttm,
  fmt,
  fmt_c = fmt_cmp(),
  na = NULL,
  sec_na = na,
  min_na = na,
  hour_na = na,
  mday_na = na,
  mon_na = na,
  year_na = na
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_dttm__+3A_dttm">dttm</code></td>
<td>
<p>A character vector of dates, times or date-times.</p>
</td></tr>
<tr><td><code id="parse_dttm__+3A_fmt">fmt</code></td>
<td>
<p>In the case of <code>parse_dttm()</code>, a character vector of parsing
formats, or a single string format in the case of <code>parse_dttm_()</code>. When a
character vector of formats is passed, each format is attempted in turn
with the first parsing result to be successful taking precedence in the
final result. The formats in <code>fmt</code> can be any strings, however the
following characters (or successive repetitions thereof) are reserved in
the sense that they are treated in a special way:
</p>

<ul>
<li> <p><code>"y"</code>: parsed as year;
</p>
</li>
<li> <p><code>"m"</code>: parsed as month;
</p>
</li>
<li> <p><code>"d"</code>: parsed as day;
</p>
</li>
<li> <p><code>"H"</code>: parsed as hour;
</p>
</li>
<li> <p><code>"M"</code>: parsed as minute;
</p>
</li>
<li> <p><code>"S"</code>: parsed as second.
</p>
</li></ul>
</td></tr>
<tr><td><code id="parse_dttm__+3A_na">na</code>, <code id="parse_dttm__+3A_sec_na">sec_na</code>, <code id="parse_dttm__+3A_min_na">min_na</code>, <code id="parse_dttm__+3A_hour_na">hour_na</code>, <code id="parse_dttm__+3A_mday_na">mday_na</code>, <code id="parse_dttm__+3A_mon_na">mon_na</code>, <code id="parse_dttm__+3A_year_na">year_na</code></td>
<td>
<p>A character vector of
alternative values to allow during matching. This can be used to indicate
different forms of missing values to be found during the parsing date-time
strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character matrix of six columns: <code>"year"</code>, <code>"mon"</code>, <code>"mday"</code>,
<code>"hour"</code>, <code>"min"</code> and <code>"sec"</code>. Each row corresponds to an element in
<code>dttm</code>. Each element of the matrix is the parsed date/time component.
</p>

<hr>
<h2 id='parse_dttm_fmt_'>Parse a date/time format</h2><span id='topic+parse_dttm_fmt_'></span><span id='topic+parse_dttm_fmt'></span>

<h3>Description</h3>

<p><code><a href="#topic+parse_dttm_fmt">parse_dttm_fmt()</a></code> parses a date/time formats, meaning it will try to parse
the components of the format <code>fmt</code> that refer to date/time components.
<code><a href="#topic+parse_dttm_fmt_">parse_dttm_fmt_()</a></code> is similar to <code><a href="#topic+parse_dttm_fmt">parse_dttm_fmt()</a></code> but is not vectorized
over <code>fmt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_dttm_fmt_(fmt, pattern)

parse_dttm_fmt(fmt, patterns = fmt_cmp())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_dttm_fmt__+3A_fmt">fmt</code></td>
<td>
<p>A format string (scalar) to be parsed by <code>patterns</code>.</p>
</td></tr>
<tr><td><code id="parse_dttm_fmt__+3A_pattern">pattern</code>, <code id="parse_dttm_fmt__+3A_patterns">patterns</code></td>
<td>
<p>A string (in the case of <code>pattern</code>), or a character
vector (in the case of <code>patterns</code>) of regexps for each of the individual
date/time components. Default value is that of <code><a href="#topic+fmt_cmp">fmt_cmp()</a></code>. Use this function
if you plan on passing a different set of patterns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a> of seven columns:
</p>

<ul>
<li> <p><code>fmt_c</code>: date/time format component. Values are either <code>"year"</code>, <code>"mon"</code>,
<code>"mday"</code>, <code>"hour"</code>, <code>"min"</code>, <code>"sec"</code>, or <code>NA</code>.
</p>
</li>
<li> <p><code>pat</code>: Regexp used to parse the date/time component.
</p>
</li>
<li> <p><code>cap</code>: The captured substring from the format.
</p>
</li>
<li> <p><code>start</code>: Start position in the format string for this capture.
</p>
</li>
<li> <p><code>end</code>: End position in the format string for this capture.
</p>
</li>
<li> <p><code>len</code>: Length of the capture (number of chars).
</p>
</li>
<li> <p><code>ord</code>: Ordinal of this date/time component in the format string.
</p>
</li></ul>

<p>Each row is for either a date/time format component or a &quot;delimiter&quot; string
or pattern in-between format components.
</p>

<hr>
<h2 id='problems'>Retrieve date/time parsing problems</h2><span id='topic+problems'></span>

<h3>Description</h3>

<p><code><a href="#topic+problems">problems()</a></code> is a companion helper function to <code><a href="#topic+create_iso8601">create_iso8601()</a></code>. It
retrieves ISO 8601 parsing problems from an object of class iso8601, which is
<code><a href="#topic+create_iso8601">create_iso8601()</a></code>'s return value and that might contain a <code>problems</code>
attribute in case of parsing failures. <code><a href="#topic+problems">problems()</a></code> is a helper function that
provides easy access to these parsing problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>problems(x = .Last.value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="problems_+3A_x">x</code></td>
<td>
<p>An object of class iso8601, as typically obtained from a call to
<code><a href="#topic+create_iso8601">create_iso8601()</a></code>. The argument can also be left empty, in that case
<code>problems()</code> will use the last returned value, making it convenient to use
immediately after <code><a href="#topic+create_iso8601">create_iso8601()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If there are no parsing problems in <code>x</code>, then the returned value is
<code>NULL</code>; otherwise, a <a href="tibble.html#topic+tibble-package">tibble</a> of parsing failures
is returned. Each row corresponds to a parsing problem. There will be a
first column named <code>..i</code> indicating the position(s) in the inputs to the
<code><a href="#topic+create_iso8601">create_iso8601()</a></code> call that resulted in failures; remaining columns
correspond to the original input values passed on to <code><a href="#topic+create_iso8601">create_iso8601()</a></code>,
with columns being automatically named <code>..var1</code>, <code>..var2</code>, and so on, if
the inputs to <code><a href="#topic+create_iso8601">create_iso8601()</a></code> were unnamed, otherwise, the original
variable names are used instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;-
  c(
    "2020-01-01",
    "2020-02-11",
    "2020-01-06",
    "2020-0921",
    "2020/10/30",
    "2020-12-05",
    "20231225"
  )

# By inspecting the problematic dates it can be understood that
# the `.format` parameter needs to updated to include other variations.
iso8601_dttm &lt;- create_iso8601(dates, .format = "y-m-d")
problems(iso8601_dttm)

# Including more parsing formats addresses the previous problems
formats &lt;- c("y-m-d", "y-md", "y/m/d", "ymd")
iso8601_dttm2 &lt;- create_iso8601(dates, .format = list(formats))

# So now `problems()` returns `NULL` because there are no more parsing issues.
problems(iso8601_dttm2)

# If you pass named arguments when calling `create_iso8601()` then they will
# be used to create the problems object.
iso8601_dttm3 &lt;- create_iso8601(date = dates, .format = "y-m-d")
problems(iso8601_dttm3)

</code></pre>

<hr>
<h2 id='pseq'>Parallel sequence generation</h2><span id='topic+pseq'></span>

<h3>Description</h3>

<p><code><a href="#topic+pseq">pseq()</a></code> is similar to <code><a href="base.html#topic+seq">seq()</a></code> but conveniently accepts integer vectors as
inputs to <code>from</code> and <code>to</code>, allowing for parallel generation of sequences.
The result is the union of the generated sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseq(from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseq_+3A_from">from</code></td>
<td>
<p>An integer vector. The starting value(s) of the sequence(s).</p>
</td></tr>
<tr><td><code id="pseq_+3A_to">to</code></td>
<td>
<p>An integer vector. The ending value(s) of the sequence(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>

<hr>
<h2 id='read_ct_spec'>Read in a controlled terminology</h2><span id='topic+read_ct_spec'></span>

<h3>Description</h3>

<p><code><a href="#topic+read_ct_spec">read_ct_spec()</a></code> imports a controlled terminology specification data set as a
<a href="tibble.html#topic+tibble-package">tibble</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ct_spec(file = cli::cli_abort("`file` must be specified"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_ct_spec_+3A_file">file</code></td>
<td>
<p>A path to a file containing a controlled terminology
specification data set. The following are expected of this file:
</p>

<ul>
<li><p> The file is expected to be a CSV file;
</p>
</li>
<li><p> The file is expected to contain a first row of column names;
</p>
</li>
<li><p> This minimal set of variables is expected: codelist_code, collected_value, term_synonyms, and term_value.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a> with a controlled terminology
specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the local path to one of the controlled terminology example files.
path &lt;- ct_spec_example("ct-01-cm")

# Import it to R.
read_ct_spec(file = path)

</code></pre>

<hr>
<h2 id='read_ct_spec_example'>Read an example controlled terminology specification</h2><span id='topic+read_ct_spec_example'></span>

<h3>Description</h3>

<p><code><a href="#topic+read_ct_spec_example">read_ct_spec_example()</a></code> imports one of the bundled controlled terminology
specification data sets as a <a href="tibble.html#topic+tibble-package">tibble</a> into R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ct_spec_example(example)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_ct_spec_example_+3A_example">example</code></td>
<td>
<p>The file name of a controlled terminology data set bundled
with <code>{stdm.oak}</code>, run <code>read_ct_spec_example()</code> for available example files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a> with a controlled terminology
specification data set, or a character vector of example file names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Leave the `example` parameter as missing for available example files.
read_ct_spec_example()

# Read an example controlled terminology spec file.
read_ct_spec_example("ct-01-cm.csv")

# You may omit the file extension.
read_ct_spec_example("ct-01-cm")

</code></pre>

<hr>
<h2 id='read_domain_example'>Read an example SDTM domain</h2><span id='topic+read_domain_example'></span>

<h3>Description</h3>

<p><code><a href="#topic+read_domain_example">read_domain_example()</a></code> imports one of the bundled SDTM domain examples
as a <a href="tibble.html#topic+tibble-package">tibble</a> into R. See <code><a href="#topic+domain_example">domain_example()</a></code> for
possible choices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_domain_example(example)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_domain_example_+3A_example">example</code></td>
<td>
<p>The name of SDTM domain example, e.g. <code>"cm"</code> (Concomitant
Medication) or <code>"ae"</code> (Adverse Events). Run <code>read_domain_example()</code> for
available example files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble-package">tibble</a> with an SDTM domain dataset, or a
character vector of example file names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+domain_example">domain_example()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Leave the `example` parameter as missing for available example files.
read_domain_example()

# Read the example Concomitant Medication domain.
read_domain_example("cm")

# Read the example Adverse Events domain.
read_domain_example("ae")

</code></pre>

<hr>
<h2 id='recode'>Recode values</h2><span id='topic+recode'></span>

<h3>Description</h3>

<p><code><a href="#topic+recode">recode()</a></code> recodes values in <code>x</code> by matching elements in <code>from</code> onto values
in <code>to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(x, from = unique(na.omit(x)), to = from, .no_match = x, .na = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recode_+3A_x">x</code></td>
<td>
<p>An atomic vector of values are to be recoded.</p>
</td></tr>
<tr><td><code id="recode_+3A_from">from</code></td>
<td>
<p>A vector of values to be matched in <code>x</code> for recoding.</p>
</td></tr>
<tr><td><code id="recode_+3A_to">to</code></td>
<td>
<p>A vector of values to be used as replacement for values in <code>from</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_.no_match">.no_match</code></td>
<td>
<p>Value to be used as replacement when cases in <code>from</code> are not
matched.</p>
</td></tr>
<tr><td><code id="recode_+3A_.na">.na</code></td>
<td>
<p>Value to be used to recode missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of recoded values.
</p>

<hr>
<h2 id='reg_matches'><code>regmatches()</code> with <code>NA</code></h2><span id='topic+reg_matches'></span>

<h3>Description</h3>

<p><code><a href="#topic+reg_matches">reg_matches()</a></code> is a thin wrapper around <code><a href="base.html#topic+regmatches">regmatches()</a></code> that returns
<code>NA</code> instead of <code>character(0)</code> when matching fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_matches(x, m, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reg_matches_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="reg_matches_+3A_m">m</code></td>
<td>
<p>An object with match data.</p>
</td></tr>
<tr><td><code id="reg_matches_+3A_invert">invert</code></td>
<td>
<p>A logical scalar. If <code>TRUE</code>, extract or replace the non-matched
substrings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors with the matched substrings, or <code>NA</code> if
matching failed.
</p>

<hr>
<h2 id='regex_or'>Utility function to assemble a regex of alternative patterns</h2><span id='topic+regex_or'></span>

<h3>Description</h3>

<p><code><a href="#topic+regex_or">regex_or()</a></code> takes a set of patterns and binds them with the Or (<code>"|"</code>)
pattern for an easy regex of alternative patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regex_or(x, .open = FALSE, .close = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regex_or_+3A_x">x</code></td>
<td>
<p>A character vector of alternative patterns.</p>
</td></tr>
<tr><td><code id="regex_or_+3A_.open">.open</code></td>
<td>
<p>Whether the resulting regex should start with <code>"|"</code>.</p>
</td></tr>
<tr><td><code id="regex_or_+3A_.close">.close</code></td>
<td>
<p>Whether the resulting regex should end with <code>"|"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character scalar of the resulting regex.
</p>

<hr>
<h2 id='rm_cnd_df'>Remove the <code>cnd_df</code> class from a data frame</h2><span id='topic+rm_cnd_df'></span>

<h3>Description</h3>

<p>This function removes the <code>cnd_df</code> class, along with its attributes, if
applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_cnd_df(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm_cnd_df_+3A_dat">dat</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>dat</code> without the <code>cnd_df</code> class and associated attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_cnd_df">new_cnd_df()</a></code>, <code><a href="#topic+is_cnd_df">is_cnd_df()</a></code>, <code><a href="#topic+get_cnd_df_cnd">get_cnd_df_cnd()</a></code>,
<code><a href="#topic+get_cnd_df_cnd_sum">get_cnd_df_cnd_sum()</a></code>.
</p>

<hr>
<h2 id='sbj_vars'>Subject-level key variables</h2><span id='topic+sbj_vars'></span>

<h3>Description</h3>

<p><code><a href="#topic+sbj_vars">sbj_vars()</a></code> returns the set of variable names that uniquely define
a subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbj_vars()
</code></pre>


<h3>Value</h3>

<p>A character vector of variable names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sbj_vars()

</code></pre>

<hr>
<h2 id='sdtm_assign'>Derive an SDTM variable</h2><span id='topic+sdtm_assign'></span>

<h3>Description</h3>

<p><code><a href="#topic+sdtm_assign">sdtm_assign()</a></code> is an internal function packing the same functionality as
<code><a href="#topic+assign_no_ct">assign_no_ct()</a></code> and <code><a href="#topic+assign_ct">assign_ct()</a></code> together but aimed at developers only.
As a user please use either <code><a href="#topic+assign_no_ct">assign_no_ct()</a></code> or <code><a href="#topic+assign_ct">assign_ct()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdtm_assign(
  tgt_dat = NULL,
  tgt_var,
  raw_dat,
  raw_var,
  ct_spec = NULL,
  ct_clst = NULL,
  id_vars = oak_id_vars()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdtm_assign_+3A_tgt_dat">tgt_dat</code></td>
<td>
<p>Target dataset: a data frame to be merged against <code>raw_dat</code> by
the variables indicated in <code>id_vars</code>. This parameter is optional, see
section Value for how the output changes depending on this argument value.</p>
</td></tr>
<tr><td><code id="sdtm_assign_+3A_tgt_var">tgt_var</code></td>
<td>
<p>The target SDTM variable: a single string indicating the name
of variable to be derived.</p>
</td></tr>
<tr><td><code id="sdtm_assign_+3A_raw_dat">raw_dat</code></td>
<td>
<p>The raw dataset (dataframe); must include the
variables passed in <code>id_vars</code> and <code>raw_var</code>.</p>
</td></tr>
<tr><td><code id="sdtm_assign_+3A_raw_var">raw_var</code></td>
<td>
<p>The raw variable: a single string indicating the name of the
raw variable in <code>raw_dat</code>.</p>
</td></tr>
<tr><td><code id="sdtm_assign_+3A_ct_spec">ct_spec</code></td>
<td>
<p>Study controlled terminology specification: a dataframe with a
minimal set of columns, see <code><a href="#topic+ct_spec_vars">ct_spec_vars()</a></code> for details. This parameter is
optional, if left as <code>NULL</code> no controlled terminology recoding is applied.</p>
</td></tr>
<tr><td><code id="sdtm_assign_+3A_ct_clst">ct_clst</code></td>
<td>
<p>A codelist code indicating which subset of the controlled
terminology to apply in the derivation. This parameter is optional, if left
as <code>NULL</code>, all possible recodings in <code>ct_spec</code> are attempted.</p>
</td></tr>
<tr><td><code id="sdtm_assign_+3A_id_vars">id_vars</code></td>
<td>
<p>Key variables to be used in the join between the raw dataset
(<code>raw_dat</code>) and the target data set (<code>tgt_dat</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned data set depends on the value of <code>tgt_dat</code>:
</p>

<ul>
<li><p> If no target dataset is supplied, meaning that <code>tgt_dat</code> defaults to
<code>NULL</code>, then the returned data set is <code>raw_dat</code>, selected for the variables
indicated in <code>id_vars</code>, and a new extra column: the derived variable, as
indicated in <code>tgt_var</code>.
</p>
</li>
<li><p> If the target dataset is provided, then it is merged with the raw data set
<code>raw_dat</code> by the variables indicated in <code>id_vars</code>, with a new column: the
derived variable, as indicated in <code>tgt_var</code>.
</p>
</li></ul>


<hr>
<h2 id='sdtm_hardcode'>Derive an SDTM variable with a hardcoded value</h2><span id='topic+sdtm_hardcode'></span>

<h3>Description</h3>

<p><code><a href="#topic+sdtm_hardcode">sdtm_hardcode()</a></code> is an internal function packing the same functionality as
<code><a href="#topic+hardcode_no_ct">hardcode_no_ct()</a></code> and <code><a href="#topic+hardcode_ct">hardcode_ct()</a></code> together but aimed at developers only.
As a user please use either <code><a href="#topic+hardcode_no_ct">hardcode_no_ct()</a></code> or <code><a href="#topic+hardcode_ct">hardcode_ct()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdtm_hardcode(
  tgt_dat = NULL,
  tgt_var,
  raw_dat,
  raw_var,
  tgt_val,
  ct_spec = NULL,
  ct_clst = NULL,
  id_vars = oak_id_vars()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdtm_hardcode_+3A_tgt_dat">tgt_dat</code></td>
<td>
<p>Target dataset: a data frame to be merged against <code>raw_dat</code> by
the variables indicated in <code>id_vars</code>. This parameter is optional, see
section Value for how the output changes depending on this argument value.</p>
</td></tr>
<tr><td><code id="sdtm_hardcode_+3A_tgt_var">tgt_var</code></td>
<td>
<p>The target SDTM variable: a single string indicating the name
of variable to be derived.</p>
</td></tr>
<tr><td><code id="sdtm_hardcode_+3A_raw_dat">raw_dat</code></td>
<td>
<p>The raw dataset (dataframe); must include the
variables passed in <code>id_vars</code> and <code>raw_var</code>.</p>
</td></tr>
<tr><td><code id="sdtm_hardcode_+3A_raw_var">raw_var</code></td>
<td>
<p>The raw variable: a single string indicating the name of the
raw variable in <code>raw_dat</code>.</p>
</td></tr>
<tr><td><code id="sdtm_hardcode_+3A_tgt_val">tgt_val</code></td>
<td>
<p>The target SDTM value to be hardcoded into the variable
indicated in <code>tgt_var</code>.</p>
</td></tr>
<tr><td><code id="sdtm_hardcode_+3A_ct_spec">ct_spec</code></td>
<td>
<p>Study controlled terminology specification: a dataframe with a
minimal set of columns, see <code><a href="#topic+ct_spec_vars">ct_spec_vars()</a></code> for details. This parameter is
optional, if left as <code>NULL</code> no controlled terminology recoding is applied.</p>
</td></tr>
<tr><td><code id="sdtm_hardcode_+3A_ct_clst">ct_clst</code></td>
<td>
<p>A codelist code indicating which subset of the controlled
terminology to apply in the derivation. This parameter is optional, if left
as <code>NULL</code>, all possible recodings in <code>ct_spec</code> are attempted.</p>
</td></tr>
<tr><td><code id="sdtm_hardcode_+3A_id_vars">id_vars</code></td>
<td>
<p>Key variables to be used in the join between the raw dataset
(<code>raw_dat</code>) and the target data set (<code>tgt_dat</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned data set depends on the value of <code>tgt_dat</code>:
</p>

<ul>
<li><p> If no target dataset is supplied, meaning that <code>tgt_dat</code> defaults to
<code>NULL</code>, then the returned data set is <code>raw_dat</code>, selected for the variables
indicated in <code>id_vars</code>, and a new extra column: the derived variable, as
indicated in <code>tgt_var</code>.
</p>
</li>
<li><p> If the target dataset is provided, then it is merged with the raw data set
<code>raw_dat</code> by the variables indicated in <code>id_vars</code>, with a new column: the
derived variable, as indicated in <code>tgt_var</code>.
</p>
</li></ul>


<hr>
<h2 id='sdtm_join'>SDTM join</h2><span id='topic+sdtm_join'></span>

<h3>Description</h3>

<p><code><a href="#topic+sdtm_join">sdtm_join()</a></code> is a special join between a raw data set and a target data
set. This function supports conditioned data frames.
</p>
<p><code><a href="#topic+sdtm_join">sdtm_join()</a></code> is a special join between a raw data set and a target data
set. This function supports conditioned data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdtm_join(raw_dat, tgt_dat = NULL, id_vars = oak_id_vars())

sdtm_join(raw_dat, tgt_dat = NULL, id_vars = oak_id_vars())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdtm_join_+3A_raw_dat">raw_dat</code></td>
<td>
<p>The raw dataset: a dataframe or a conditioned data frame. Must
include the variables passed in <code>id_vars</code>.</p>
</td></tr>
<tr><td><code id="sdtm_join_+3A_tgt_dat">tgt_dat</code></td>
<td>
<p>Target dataset: a data frame or a conditioned data frame to be
merged against <code>raw_dat</code> by the variables indicated in <code>id_vars</code>.</p>
</td></tr>
<tr><td><code id="sdtm_join_+3A_id_vars">id_vars</code></td>
<td>
<p>Key variables to be used in the join between the raw dataset
(<code>raw_dat</code>) and the target data set (<code>tgt_dat</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, or a conditioned data frame if at least one of the
input data sets is a conditioned data frame.
</p>
<p>A data frame, or a conditioned data frame if, at least, one of the
input data sets is a conditioned data frame.
</p>

<hr>
<h2 id='str_to_anycase'>Generate case insensitive regexps</h2><span id='topic+str_to_anycase'></span>

<h3>Description</h3>

<p><code><a href="#topic+str_to_anycase">str_to_anycase()</a></code> takes a character vector of word strings as input, and
generates regular expressions that express that match in any case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_to_anycase(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_to_anycase_+3A_x">x</code></td>
<td>
<p>A character vector of strings consisting of word characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='tbl_sum.cnd_df'>Conditioned tibble header print method</h2><span id='topic+tbl_sum.cnd_df'></span>

<h3>Description</h3>

<p>Conditioned tibble header print method. This S3 method adds an extra line
in the header of a tibble that indicates the tibble is a conditioned tibble
(<code style="white-space: pre;">&#8288;# Cond. tbl:&#8288;</code>) followed by the tally of the conditioning vector: number
of TRUE, FALSE and NA values: e.g., <code>1/1/1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cnd_df'
tbl_sum(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tbl_sum.cnd_df_+3A_x">x</code></td>
<td>
<p>A conditioned tibble of class <code>cnd_df</code>.</p>
</td></tr>
<tr><td><code id="tbl_sum.cnd_df_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the default print method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with header values of the conditioned data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctl_new_rowid_pillar.cnd_df">ctl_new_rowid_pillar.cnd_df()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c(1L, NA_integer_, 3L))
(cnd_df &lt;- condition_add(dat = df, x &gt;= 2L))
pillar::tbl_sum(cnd_df)

</code></pre>

<hr>
<h2 id='yy_to_yyyy'>Convert two-digit to four-digit years</h2><span id='topic+yy_to_yyyy'></span>

<h3>Description</h3>

<p><code><a href="#topic+yy_to_yyyy">yy_to_yyyy()</a></code> converts two-digit years to four-digit years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yy_to_yyyy(x, cutoff_2000 = 68L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yy_to_yyyy_+3A_x">x</code></td>
<td>
<p>An integer vector of years.</p>
</td></tr>
<tr><td><code id="yy_to_yyyy_+3A_cutoff_2000">cutoff_2000</code></td>
<td>
<p>An integer value. Two-digit years smaller or equal to
<code>cutoff_2000</code> are parsed as though starting with <code>20</code>, otherwise parsed as
though starting with <code>19</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>

<hr>
<h2 id='zero_pad_whole_number'>Convert an integer to a zero-padded character vector</h2><span id='topic+zero_pad_whole_number'></span>

<h3>Description</h3>

<p><code><a href="#topic+zero_pad_whole_number">zero_pad_whole_number()</a></code> takes non-negative integer values and converts
them to character with zero padding. Negative numbers and numbers greater
than the width specified by the number of digits <code>n</code> are converted to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_pad_whole_number(x, n = 2L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zero_pad_whole_number_+3A_x">x</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="zero_pad_whole_number_+3A_n">n</code></td>
<td>
<p>Number of digits in the output, including zero padding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
