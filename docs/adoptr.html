<!DOCTYPE html><html><head><title>Help for package adoptr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adoptr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adoptr'><p>Adaptive Optimal Two-Stage Designs</p></a></li>
<li><a href='#AverageN2-class'><p>Regularization via L1 norm</p></a></li>
<li><a href='#Binomial-class'><p>Binomial data distribution</p></a></li>
<li><a href='#bounds'><p>Get support of a prior or data distribution</p></a></li>
<li><a href='#c2'><p>Query critical values of a design</p></a></li>
<li><a href='#composite'><p>Score Composition</p></a></li>
<li><a href='#condition'><p>Condition a prior on an interval</p></a></li>
<li><a href='#ConditionalPower-class'><p>(Conditional) Power of a Design</p></a></li>
<li><a href='#ConditionalSampleSize-class'><p>(Conditional) Sample Size of a Design</p></a></li>
<li><a href='#Constraints'><p>Formulating Constraints</p></a></li>
<li><a href='#ContinuousPrior-class'><p>Continuous univariate prior distributions</p></a></li>
<li><a href='#cumulative_distribution_function'><p>Cumulative distribution function</p></a></li>
<li><a href='#DataDistribution-class'><p>Data distributions</p></a></li>
<li><a href='#expectation'><p>Expected value of a function</p></a></li>
<li><a href='#get_initial_design'><p>Initial design</p></a></li>
<li><a href='#get_lower_boundary_design'><p>Boundary designs</p></a></li>
<li><a href='#GroupSequentialDesign-class'><p>Group-sequential two-stage designs</p></a></li>
<li><a href='#make_tunable'><p>Fix parameters during optimization</p></a></li>
<li><a href='#MaximumSampleSize-class'><p>Maximum Sample Size of a Design</p></a></li>
<li><a href='#minimize'><p>Find optimal two-stage design by constraint minimization</p></a></li>
<li><a href='#n1'><p>Query sample size of a design</p></a></li>
<li><a href='#N1-class'><p>Regularize n1</p></a></li>
<li><a href='#Normal-class'><p>Normal data distribution</p></a></li>
<li><a href='#OneStageDesign-class'><p>One-stage designs</p></a></li>
<li><a href='#plot+2CTwoStageDesign-method'><p>Plot <code>TwoStageDesign</code> with optional set of conditional scores</p></a></li>
<li><a href='#PointMassPrior-class'><p>Univariate discrete point mass priors</p></a></li>
<li><a href='#posterior'><p>Compute posterior distribution</p></a></li>
<li><a href='#predictive_cdf'><p>Predictive CDF</p></a></li>
<li><a href='#predictive_pdf'><p>Predictive PDF</p></a></li>
<li><a href='#print.adoptrOptimizationResult'><p>Printing an optimization result</p></a></li>
<li><a href='#Prior-class'><p>Univariate prior on model parameter</p></a></li>
<li><a href='#probability_density_function'><p>Probability density function</p></a></li>
<li><a href='#Scores'><p>Scores</p></a></li>
<li><a href='#simulate+2CTwoStageDesign+2Cnumeric-method'><p>Draw samples from a two-stage design</p></a></li>
<li><a href='#Student-class'><p>Student's t data distribution</p></a></li>
<li><a href='#subject_to'><p>Create a collection of constraints</p></a></li>
<li><a href='#tunable_parameters'><p>Switch between numeric and S4 class representation of a design</p></a></li>
<li><a href='#TwoStageDesign-class'><p>Two-stage designs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive Optimal Two-Stage Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimize one or two-arm, two-stage designs for clinical trials with 
    respect to several implemented objective criteria or custom objectives.
    Optimization under uncertainty and conditional (given stage-one outcome) 
    constraints are supported.
    See Pilz et al. (2019) &lt;<a href="https://doi.org/10.1002%2Fsim.8291">doi:10.1002/sim.8291</a>&gt; and 
    Kunzmann et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v098.i09">doi:10.18637/jss.v098.i09</a>&gt; for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr, rpact, vdiffr, pwr, dplyr,
ggplot2, tidyr, gridExtra, bookdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>nloptr, methods, glue</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>adoptr.R util.R DataDistribution.R BinomialDistribution.R
NormalDistribution.R StudentDistribution.R Prior.R
PointMassPrior.R ContinuousPrior.R TwoStageDesign.R
GroupSequentialDesign.R OneStageDesign.R Scores.R constraints.R
minimize.R ConditionalPower.R ConditionalSampleSize.R
regularization.R CompositeScore.R MaximumSampleSize.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/optad/adoptr/issues">https://github.com/optad/adoptr/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/optad/adoptr">https://github.com/optad/adoptr</a>, <a href="https://optad.github.io/adoptr/">https://optad.github.io/adoptr/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-07 09:23:25 UTC; pilz</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Kunzmann <a href="https://orcid.org/0000-0002-1140-7143"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Maximilian Pilz <a href="https://orcid.org/0000-0002-9685-1613"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jan Meis <a href="https://orcid.org/0000-0001-5407-7220"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Nico Bruder [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian Pilz &lt;maximilian.pilz@itwm.fraunhofer.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-07 14:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='adoptr'>Adaptive Optimal Two-Stage Designs</h2><span id='topic+adoptr-package'></span><span id='topic+adoptr'></span>

<h3>Description</h3>

<p>The <span class="pkg">adoptr</span> package provides functionality to explore custom optimal
two-stage designs for one- or two-arm superiority tests.
For more details on the theoretical background see
<a href="doi:10.1002/sim.8291">doi:10.1002/sim.8291</a> and <a href="doi:10.18637/jss.v098.i09">doi:10.18637/jss.v098.i09</a>.
<span class="pkg">adoptr</span> makes heavy use of the S4 class system.
A good place to start learning about it can be found
<a href="http://adv-r.had.co.nz/OO-essentials.html">here</a>.
</p>


<h3>Quickstart</h3>

<p>For a sample workflow and a quick demo of the capabilities, see
<a href="https://optad.github.io/adoptr/articles/adoptr.html">here</a>.
</p>
<p>A more detailed description of the background and the usage of <span class="pkg">adoptr</span>
can be found <a href="https://optad.github.io/adoptr/articles/adoptr_jss.html">here</a>
or here <a href="doi:10.18637/jss.v098.i09">doi:10.18637/jss.v098.i09</a> .
</p>
<p>A variety of examples is presented in the validation report hosted
<a href="https://kkmann.github.io/adoptr-validation-report/">here</a>.
</p>


<h3>Designs</h3>

<p><span class="pkg">adoptr</span> currently supports <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>,
<code><a href="#topic+GroupSequentialDesign">GroupSequentialDesign</a></code>, and <code><a href="#topic+OneStageDesign">OneStageDesign</a></code>.
</p>


<h3>Data distributions</h3>

<p>Currently, the only implemented data distribution is <code><a href="#topic+Normal">Normal</a></code>
(one or two arms).
</p>


<h3>Priors</h3>

<p>Both <code><a href="#topic+ContinuousPrior">ContinuousPrior</a></code> and <code><a href="#topic+PointMassPrior">PointMassPrior</a></code> are
supported for the single parameter of a <code><a href="#topic+DataDistribution">DataDistribution</a></code>.
</p>


<h3>Scores</h3>

<p>See <code><a href="#topic+Scores">Scores</a></code> for information on the basic system of representing
scores.
Available scores are <code><a href="#topic+ConditionalPower">ConditionalPower</a></code>,
<code><a href="#topic+ConditionalSampleSize">ConditionalSampleSize</a></code>, <code><a href="#topic+Power">Power</a></code>, and
<code><a href="#topic+ExpectedSampleSize">ExpectedSampleSize</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Maximilian Pilz <a href="mailto:maximilian.pilz@itwm.fraunhofer.de">maximilian.pilz@itwm.fraunhofer.de</a> (<a href="https://orcid.org/0000-0002-9685-1613">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Kevin Kunzmann <a href="mailto:kevin.kunzmann@boehringer-ingelheim.com">kevin.kunzmann@boehringer-ingelheim.com</a> (<a href="https://orcid.org/0000-0002-1140-7143">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Jan Meis <a href="mailto:meis@imbi.uni-heidelberg.de">meis@imbi.uni-heidelberg.de</a> (<a href="https://orcid.org/0000-0001-5407-7220">ORCID</a>)
</p>
</li>
<li><p> Nico Bruder <a href="mailto:bruder@imbi.uni-heidelberg.de">bruder@imbi.uni-heidelberg.de</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/optad/adoptr">https://github.com/optad/adoptr</a>
</p>
</li>
<li> <p><a href="https://optad.github.io/adoptr/">https://optad.github.io/adoptr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/optad/adoptr/issues">https://github.com/optad/adoptr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AverageN2-class'>Regularization via L1 norm</h2><span id='topic+AverageN2-class'></span><span id='topic+AverageN2'></span><span id='topic+evaluate+2CAverageN2+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>Implements the L1-norm of the design's stage-two sample size function.
The average of the stage-two sample size without weighting with
the data distribution is computed.
This can be interpreted as integration over a unifrom prior on
the continuation region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AverageN2(label = NA_character_)

## S4 method for signature 'AverageN2,TwoStageDesign'
evaluate(s, design, optimization = FALSE, subdivisions = 10000L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AverageN2-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_subdivisions">subdivisions</code></td>
<td>
<p>number of subdivisions to use for adaptive integration
(only affects non-optimization code)</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+AverageN2">AverageN2</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+N1">N1</a></code> for penalizing n1 values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>avn2 &lt;- AverageN2()

evaluate(
   AverageN2(),
   TwoStageDesign(100, 0.5, 1.5, 60.0, 1.96, order = 5L)
) # 60

</code></pre>

<hr>
<h2 id='Binomial-class'>Binomial data distribution</h2><span id='topic+Binomial-class'></span><span id='topic+Binomial'></span><span id='topic+quantile+2CBinomial-method'></span><span id='topic+simulate+2CBinomial+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Implements the normal approximation for a test on rates.
The reponse rate in the control group,
r<sub>C</sub>, has to be specified by
<code>rate_control</code>.
The null hypothesis is:
r<sub>E</sub> &le; r<sub>C</sub>,
where r<sub>E</sub> denotes the response rate
in the invervention group.
It is tested against the alternative
r<sub>E</sub> > r<sub>C</sub>.
The test statistic is given as
X<sub>1</sub> = &radic;n (r<sub>E</sub> - r<sub>C</sub>) / &radic;(2  r<sub>0</sub> (1-r<sub>0</sub>)),
where r<sub>0</sub> denotes the mean between
r<sub>E</sub> and
r<sub>C</sub> in the two-armed case,
and r<sub>E</sub> in the one-armed case.#'
All priors have to be defined for the rate difference
r<sub>E</sub> - r<sub>C</sub>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Binomial(rate_control, two_armed = TRUE)

## S4 method for signature 'Binomial'
quantile(x, probs, n, theta, ...)

## S4 method for signature 'Binomial,numeric'
simulate(object, nsim, n, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Binomial-class_+3A_rate_control">rate_control</code></td>
<td>
<p>assumed response rate in control group</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_two_armed">two_armed</code></td>
<td>
<p>logical indicating if a two-armed trial is regarded</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Binomial</code></p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>simulate</code> for class <code>Binomial</code> simulates the
normal approximation of the test statistic.
</p>


<h3>Slots</h3>


<dl>
<dt><code>rate_control</code></dt><dd><p>cf. parameter 'rate_control'</p>
</dd>
</dl>


<h3>See Also</h3>

<p>see <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadist &lt;- Binomial(rate_control = 0.2, two_armed = FALSE)

</code></pre>

<hr>
<h2 id='bounds'>Get support of a prior or data distribution</h2><span id='topic+bounds'></span><span id='topic+bounds+2CPointMassPrior-method'></span><span id='topic+bounds+2CContinuousPrior-method'></span>

<h3>Description</h3>

<p><code>bounds()</code> returns the range of the support of a prior or data distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds(dist, ...)

## S4 method for signature 'PointMassPrior'
bounds(dist, ...)

## S4 method for signature 'ContinuousPrior'
bounds(dist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounds_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="bounds_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> of length two, <code>c(lower, upper)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bounds(PointMassPrior(c(0, .5), c(.3, .7)))
# &gt; 0.3 0.7

bounds(ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)))
# &gt; 0.2 0.4

</code></pre>

<hr>
<h2 id='c2'>Query critical values of a design</h2><span id='topic+c2'></span><span id='topic+c2+2CTwoStageDesign+2Cnumeric-method'></span><span id='topic+c2+2COneStageDesign+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods to access the stage-two critical values of a
<code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
<code>c2</code> returns the stage-two critical value conditional on the stage-one test
statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2(d, x1, ...)

## S4 method for signature 'TwoStageDesign,numeric'
c2(d, x1, ...)

## S4 method for signature 'OneStageDesign,numeric'
c2(d, x1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c2_+3A_d">d</code></td>
<td>
<p>design</p>
</td></tr>
<tr><td><code id="c2_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="c2_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the critical value function <code>c2</code> of design <code>d</code> at position <code>x1</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>, see <code><a href="#topic+n">n</a></code> for accessing
the sample size of a design
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(
  n1    = 25,
  c1f   = 0,
  c1e   = 2.5,
  n2    = 50,
  c2    = 1.96,
  order = 7L
)

c2(design, 2.2) # 1.96
c2(design, 3.0) # -Inf
c2(design, -1.0) # Inf

design &lt;- TwoStageDesign(
   n1    = 25,
   c1f   = 0,
   c1e   = 2.5,
   n2    = 50,
   c2    = 1.96,
   order = 7L
)

c2(design, 2.2) # 1.96
c2(design, 3.0) # -Inf
c2(design, -1.0) # Inf

</code></pre>

<hr>
<h2 id='composite'>Score Composition</h2><span id='topic+composite'></span><span id='topic+evaluate+2CCompositeScore+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p><code>composite</code> defines new composite scores by point-wise evaluation of
scores in any valid numerical expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>composite(expr, label = NA_character_)

## S4 method for signature 'CompositeScore,TwoStageDesign'
evaluate(s, design, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="composite_+3A_expr">expr</code></td>
<td>
<p>Expression (in curly brackets); must contain at least one score
variable; if multiple scores are used, they must either all be conditional
or unconditional. Currently, no non-score variables are supported</p>
</td></tr>
<tr><td><code id="composite_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="composite_+3A_s">s</code></td>
<td>
<p>object of class <code>CompositeScore</code></p>
</td></tr>
<tr><td><code id="composite_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="composite_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>CompositeConditionalScore</code> or
<code>CompositeUnconditionalScore</code> depending on the class of the scores used
in <code>expr</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+Scores">Scores</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ess   &lt;- ExpectedSampleSize(Normal(), PointMassPrior(.4, 1))
power &lt;- Power(Normal(), PointMassPrior(.4, 1))

# linear combination:
composite({ess - 50*power})

# control flow (e.g. for and while loops)
composite({
  res &lt;- 0
  for (i in 1:3) {
     res &lt;- res + ess
  }
  res
})

# functional composition
composite({log(ess)})
cp &lt;- ConditionalPower(Normal(), PointMassPrior(.4, 1))
composite({3*cp})

</code></pre>

<hr>
<h2 id='condition'>Condition a prior on an interval</h2><span id='topic+condition'></span><span id='topic+condition+2CPointMassPrior+2Cnumeric-method'></span><span id='topic+condition+2CContinuousPrior+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Restrict an object of class <code><a href="#topic+Prior">Prior</a></code> to a sub-interval and
re-normalize the PDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition(dist, interval, ...)

## S4 method for signature 'PointMassPrior,numeric'
condition(dist, interval, ...)

## S4 method for signature 'ContinuousPrior,numeric'
condition(dist, interval, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condition_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="condition_+3A_interval">interval</code></td>
<td>
<p>length-two numeric vector giving the parameter interval to
condition on</p>
</td></tr>
<tr><td><code id="condition_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>conditional <code><a href="#topic+Prior">Prior</a></code> on given interval
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- condition(PointMassPrior(c(0, .5), c(.3, .7)), c(-1, .25))
expectation(tmp, identity) # 0

tmp &lt;- condition(
    ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)),
    c(.3, .5)
)
bounds(tmp) # c(.3, .4)

</code></pre>

<hr>
<h2 id='ConditionalPower-class'>(Conditional) Power of a Design</h2><span id='topic+ConditionalPower-class'></span><span id='topic+ConditionalPower'></span><span id='topic+Power'></span><span id='topic+evaluate+2CConditionalPower+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>This score evaluates P[X<sub>2</sub> > c2(design, X<sub>1</sub>) | X<sub>1</sub> = x<sub>1</sub>].
Note that the distribution of X<sub>2</sub> is the posterior predictive after
observing X<sub>1</sub> = x<sub>1</sub>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConditionalPower(dist, prior, label = "Pr[x2&gt;=c2(x1)|x1]")

Power(dist, prior, label = "Pr[x2&gt;=c2(x1)]")

## S4 method for signature 'ConditionalPower,TwoStageDesign'
evaluate(s, design, x1, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConditionalPower-class_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Scores">Scores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prior &lt;- PointMassPrior(.4, 1)
cp &lt;- ConditionalPower(Normal(), prior)
evaluate(
   cp,
   TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L),
   x1 = 1
)
# these two are equivalent:
expected(cp, Normal(), prior)
Power(Normal(), prior)

</code></pre>

<hr>
<h2 id='ConditionalSampleSize-class'>(Conditional) Sample Size of a Design</h2><span id='topic+ConditionalSampleSize-class'></span><span id='topic+ConditionalSampleSize'></span><span id='topic+ExpectedSampleSize'></span><span id='topic+evaluate+2CConditionalSampleSize+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>This score simply evaluates <code>n(d, x1)</code> for a design <code>d</code> and the
first-stage outcome <code>x1</code>.
The data distribution and prior are only relevant when it is integrated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConditionalSampleSize(label = "n(x1)")

ExpectedSampleSize(dist, prior, label = "E[n(x1)]")

## S4 method for signature 'ConditionalSampleSize,TwoStageDesign'
evaluate(s, design, x1, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConditionalSampleSize-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Scores">Scores</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L)
prior  &lt;- PointMassPrior(.4, 1)

css   &lt;- ConditionalSampleSize()
evaluate(css, design, c(0, .5, 3))

ess   &lt;- ExpectedSampleSize(Normal(), prior)

# those two are equivalent
evaluate(ess, design)
evaluate(expected(css, Normal(), prior), design)

</code></pre>

<hr>
<h2 id='Constraints'>Formulating Constraints</h2><span id='topic+Constraints'></span><span id='topic+evaluate+2CConstraint+2CTwoStageDesign-method'></span><span id='topic++3C+3D+2CConditionalScore+2Cnumeric-method'></span><span id='topic++3E+3D+2CConditionalScore+2Cnumeric-method'></span><span id='topic++3C+3D+2Cnumeric+2CConditionalScore-method'></span><span id='topic++3E+3D+2Cnumeric+2CConditionalScore-method'></span><span id='topic++3C+3D+2CConditionalScore+2CConditionalScore-method'></span><span id='topic++3E+3D+2CConditionalScore+2CConditionalScore-method'></span><span id='topic++3C+3D+2CUnconditionalScore+2Cnumeric-method'></span><span id='topic++3E+3D+2CUnconditionalScore+2Cnumeric-method'></span><span id='topic++3C+3D+2Cnumeric+2CUnconditionalScore-method'></span><span id='topic++3E+3D+2Cnumeric+2CUnconditionalScore-method'></span><span id='topic++3C+3D+2CUnconditionalScore+2CUnconditionalScore-method'></span><span id='topic++3E+3D+2CUnconditionalScore+2CUnconditionalScore-method'></span>

<h3>Description</h3>

<p>Conceptually, constraints work very similar to scores (any score can be put in
a constraint).
Currently,  constraints of the form 'score &lt;=/&gt;= x',
'x &lt;=/&gt;= score' and 'score &lt;=/&gt;= score' are admissible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Constraint,TwoStageDesign'
evaluate(s, design, optimization = FALSE, ...)

## S4 method for signature 'ConditionalScore,numeric'
e1 &lt;= e2

## S4 method for signature 'ConditionalScore,numeric'
e1 &gt;= e2

## S4 method for signature 'numeric,ConditionalScore'
e1 &lt;= e2

## S4 method for signature 'numeric,ConditionalScore'
e1 &gt;= e2

## S4 method for signature 'ConditionalScore,ConditionalScore'
e1 &lt;= e2

## S4 method for signature 'ConditionalScore,ConditionalScore'
e1 &gt;= e2

## S4 method for signature 'UnconditionalScore,numeric'
e1 &lt;= e2

## S4 method for signature 'UnconditionalScore,numeric'
e1 &gt;= e2

## S4 method for signature 'numeric,UnconditionalScore'
e1 &lt;= e2

## S4 method for signature 'numeric,UnconditionalScore'
e1 &gt;= e2

## S4 method for signature 'UnconditionalScore,UnconditionalScore'
e1 &lt;= e2

## S4 method for signature 'UnconditionalScore,UnconditionalScore'
e1 &gt;= e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Constraints_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="Constraints_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="Constraints_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="Constraints_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Constraints_+3A_e1">e1</code></td>
<td>
<p>left hand side (score or numeric)</p>
</td></tr>
<tr><td><code id="Constraints_+3A_e2">e2</code></td>
<td>
<p>right hand side (score or numeric)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>Constraint</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minimize">minimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- OneStageDesign(50, 1.96)

cp     &lt;- ConditionalPower(Normal(), PointMassPrior(0.4, 1))
pow    &lt;- Power(Normal(), PointMassPrior(0.4, 1))

# unconditional power constraint
constraint1 &lt;- pow &gt;= 0.8
evaluate(constraint1, design)

# conditional power constraint
constraint2 &lt;- cp  &gt;= 0.7
evaluate(constraint2, design, .5)
constraint3 &lt;- 0.7 &lt;= cp # same as constraint2
evaluate(constraint3, design, .5)

</code></pre>

<hr>
<h2 id='ContinuousPrior-class'>Continuous univariate prior distributions</h2><span id='topic+ContinuousPrior-class'></span><span id='topic+ContinuousPrior'></span>

<h3>Description</h3>

<p><code>ContinuousPrior</code> is a sub-class of <code><a href="#topic+Prior">Prior</a></code> implementing
a generic representation of continuous prior distributions over a compact
interval on the real line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ContinuousPrior(
  pdf,
  support,
  order = 10,
  label = NA_character_,
  tighten_support = FALSE,
  check_normalization = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ContinuousPrior-class_+3A_pdf">pdf</code></td>
<td>
<p>vectorized univariate PDF function</p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_support">support</code></td>
<td>
<p>numeric vector of length two with the bounds of
the compact interval on which the pdf is positive.</p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_order">order</code></td>
<td>
<p><code>integer</code>, integration order of the employed Gaussian quadrature
integration rule to evaluate scores. Automatically set to <code>length(n2_pivots)</code> if <br />
<code>length(n2_pivots) == length(c2_pivots) &gt; 1</code>, otherwise c2 and n2
are taken to be constant in stage-two and replicated to match the number of
pivots specified by <code>order</code></p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_tighten_support">tighten_support</code></td>
<td>
<p>logical indicating if the support should be tightened</p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_check_normalization">check_normalization</code></td>
<td>
<p>logical indicating if it should be checked
that <code>pdf</code> defines a density.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>pdf</code></dt><dd><p>cf. parameter 'pdf'</p>
</dd>
<dt><code>support</code></dt><dd><p>cf. parameter 'support'</p>
</dd>
<dt><code>pivots</code></dt><dd><p>normalized pivots for integration rule (in [-1, 1])
the actual pivots are scaled to the support of the prior</p>
</dd>
<dt><code>weights</code></dt><dd><p>weights of of integration rule at <code>pivots</code> for
approximating integrals over <code>delta</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p>Discrete priors are supported via <code><a href="#topic+PointMassPrior">PointMassPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ContinuousPrior(function(x) 2*x, c(0, 1))

</code></pre>

<hr>
<h2 id='cumulative_distribution_function'>Cumulative distribution function</h2><span id='topic+cumulative_distribution_function'></span><span id='topic+cumulative_distribution_function+2CBinomial+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+cumulative_distribution_function+2CNormal+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+cumulative_distribution_function+2CStudent+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>cumulative_distribution_function</code> evaluates the cumulative distribution
function of a specific distribution <code>dist</code> at a point <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative_distribution_function(dist, x, n, theta, ...)

## S4 method for signature 'Binomial,numeric,numeric,numeric'
cumulative_distribution_function(dist, x, n, theta, ...)

## S4 method for signature 'Normal,numeric,numeric,numeric'
cumulative_distribution_function(dist, x, n, theta, ...)

## S4 method for signature 'Student,numeric,numeric,numeric'
cumulative_distribution_function(dist, x, n, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulative_distribution_function_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="cumulative_distribution_function_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="cumulative_distribution_function_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="cumulative_distribution_function_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="cumulative_distribution_function_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the distribution is <code><a href="#topic+Binomial">Binomial</a></code>,
theta denotes the rate difference between
intervention and control group.
Then, the mean is assumed to be
&radic; n  theta.
</p>
<p>If the distribution is <code><a href="#topic+Normal">Normal</a></code>, then
the mean is assumed to be
&radic; n  theta.
</p>


<h3>Value</h3>

<p>value of the cumulative distribution function at point <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cumulative_distribution_function(Binomial(.1, TRUE), 1, 50, .3)

cumulative_distribution_function(Normal(), 1, 50, .3)

cumulative_distribution_function(Student(two_armed = FALSE), .75, 50, .9)

</code></pre>

<hr>
<h2 id='DataDistribution-class'>Data distributions</h2><span id='topic+DataDistribution-class'></span><span id='topic+DataDistribution'></span>

<h3>Description</h3>

<p><code>DataDistribution</code> is an abstract class used to represent the distribution
of a sufficient statistic <code>x</code> given a sample size <code>n</code> and a
single parameter value <code>theta</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataDistribution-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="DataDistribution-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="DataDistribution-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="DataDistribution-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This abstraction layer allows the representation of t-distributions
(unknown variance), normal distribution (known variance), and normal
approximation of a binary endpoint.
Currently, the two implemented versions are <code><a href="#topic+Normal-class">Normal-class</a></code> and
<code><a href="#topic+Binomial-class">Binomial-class</a></code>.
</p>
<p>The logical option <code>two_armed</code> allows to decide whether a one-arm or
a two-arm (the default) design should be computed. In the case of a two-arm
design all sample sizes are per group.
</p>


<h3>Slots</h3>


<dl>
<dt><code>two_armed</code></dt><dd><p>Logical that indicates if a two-arm design is assumed.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>normaldist   &lt;- Normal(two_armed = FALSE)
binomialdist &lt;- Binomial(rate_control = .25, two_armed = TRUE)

</code></pre>

<hr>
<h2 id='expectation'>Expected value of a function</h2><span id='topic+expectation'></span><span id='topic+expectation+2CPointMassPrior+2Cfunction-method'></span><span id='topic+expectation+2CContinuousPrior+2Cfunction-method'></span>

<h3>Description</h3>

<p>Computes the expected value of a vectorized, univariate function <code>f</code>
with respect to a distribution <code>dist</code>.
I.e., E[f(X)].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectation(dist, f, ...)

## S4 method for signature 'PointMassPrior,function'
expectation(dist, f, ...)

## S4 method for signature 'ContinuousPrior,function'
expectation(dist, f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectation_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="expectation_+3A_f">f</code></td>
<td>
<p>a univariate function, must be vectorized</p>
</td></tr>
<tr><td><code id="expectation_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>, expected value of <code>f</code> with respect to <code>dist</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expectation(PointMassPrior(c(0, .5), c(.3, .7)), identity)
# &gt; .35

expectation(
    ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)),
    identity
)
# &gt; 0.3

</code></pre>

<hr>
<h2 id='get_initial_design'>Initial design</h2><span id='topic+get_initial_design'></span>

<h3>Description</h3>

<p>The optimization method <code><a href="#topic+minimize">minimize</a></code> requires an initial
design for optimization.
The function <code>get_initial_design</code> provides an initial guess based on a
fixed design that fulfills constraints on type I error rate and power.
Note that a situation-specific initial design may be much more efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_initial_design(
  theta,
  alpha,
  beta,
  type = c("two-stage", "group-sequential", "one-stage"),
  dist = Normal(),
  order = 7L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_initial_design_+3A_theta">theta</code></td>
<td>
<p>the alternative effect size in the normal case, the
rate difference under the alternative in the binomial case</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_alpha">alpha</code></td>
<td>
<p>maximal type I error rate</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_beta">beta</code></td>
<td>
<p>maximale type II error rate</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_type">type</code></td>
<td>
<p>is a two-stage, group-sequential, or one-stage design requried?</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_dist">dist</code></td>
<td>
<p>distribution of the test statistic</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_order">order</code></td>
<td>
<p>desired integration order</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution of the test statistic is specified by <code>dist</code>.
The default assumes a two-armed z-test.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init &lt;- get_initial_design(
   theta = 0.3,
   alpha = 0.025,
   beta  = 0.2,
   type  = "two-stage",
   dist  = Normal(two_armed = FALSE),
   order = 7L
)

</code></pre>

<hr>
<h2 id='get_lower_boundary_design'>Boundary designs</h2><span id='topic+get_lower_boundary_design'></span><span id='topic+get_upper_boundary_design'></span><span id='topic+get_lower_boundary_design+2COneStageDesign-method'></span><span id='topic+get_lower_boundary_design+2CGroupSequentialDesign-method'></span><span id='topic+get_lower_boundary_design+2CTwoStageDesign-method'></span><span id='topic+get_upper_boundary_design+2COneStageDesign-method'></span><span id='topic+get_upper_boundary_design+2CGroupSequentialDesign-method'></span><span id='topic+get_upper_boundary_design+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>The optimization method <code><a href="#topic+minimize">minimize</a></code> is based on the package
<code>nloptr</code>. This requires upper and lower boundaries for optimization.
Such boundaries can be computed via <code>lower_boundary_design</code>
respectively <code>upper_boundary_design</code>.
They are implemented by default in <code><a href="#topic+minimize">minimize</a></code>.
Note that <code><a href="#topic+minimize">minimize</a></code> allows the user to define its own
boundary designs, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lower_boundary_design(initial_design, ...)

get_upper_boundary_design(initial_design, ...)

## S4 method for signature 'OneStageDesign'
get_lower_boundary_design(initial_design, n1 = 1, c1_buffer = 2, ...)

## S4 method for signature 'GroupSequentialDesign'
get_lower_boundary_design(
  initial_design,
  n1 = 1,
  n2_pivots = 1,
  c1_buffer = 2,
  c2_buffer = 2,
  ...
)

## S4 method for signature 'TwoStageDesign'
get_lower_boundary_design(
  initial_design,
  n1 = 1,
  n2_pivots = 1,
  c1_buffer = 2,
  c2_buffer = 2,
  ...
)

## S4 method for signature 'OneStageDesign'
get_upper_boundary_design(
  initial_design,
  n1 = 5 * initial_design@n1,
  c1_buffer = 2,
  ...
)

## S4 method for signature 'GroupSequentialDesign'
get_upper_boundary_design(
  initial_design,
  n1 = 5 * initial_design@n1,
  n2_pivots = 5 * initial_design@n2_pivots,
  c1_buffer = 2,
  c2_buffer = 2,
  ...
)

## S4 method for signature 'TwoStageDesign'
get_upper_boundary_design(
  initial_design,
  n1 = 5 * initial_design@n1,
  n2_pivots = 5 * initial_design@n2_pivots,
  c1_buffer = 2,
  c2_buffer = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lower_boundary_design_+3A_initial_design">initial_design</code></td>
<td>
<p>The initial design</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_...">...</code></td>
<td>
<p>optional arguments
</p>
<p>The values <code>c1f</code> and <code>c1e</code> from the initial design are shifted
to <code>c1f - c1_buffer</code> and <code>c1e - c1_buffer</code> in
<code>get_lower_boundary_design</code>, respectively, to <br />
<code>c1f + c1_buffer</code> and <code>c1e + c1_buffer</code> in
<code>get_upper_boundary_design</code>.
This is handled analogously with <code>c2_pivots</code> and <code>c2_buffer</code>.</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_n1">n1</code></td>
<td>
<p>bound for the first-stage sample size n1</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_c1_buffer">c1_buffer</code></td>
<td>
<p>shift of the early-stopping boundaries from the initial ones</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_n2_pivots">n2_pivots</code></td>
<td>
<p>bound for the second-stage sample size n2</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_c2_buffer">c2_buffer</code></td>
<td>
<p>shift of the final decision boundary from the initial one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initial_design &lt;- TwoStageDesign(
  n1    = 25,
  c1f   = 0,
  c1e   = 2.5,
  n2    = 50,
  c2    = 1.96,
  order = 7L
  )
get_lower_boundary_design(initial_design)

</code></pre>

<hr>
<h2 id='GroupSequentialDesign-class'>Group-sequential two-stage designs</h2><span id='topic+GroupSequentialDesign-class'></span><span id='topic+GroupSequentialDesign'></span><span id='topic+TwoStageDesign+2CGroupSequentialDesign-method'></span>

<h3>Description</h3>

<p>Group-sequential designs are a sub-class of the <code>TwoStageDesign</code>
class with constant stage-two sample size.
See <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code> for slot details.
Any group-sequential design can be converted to a fully flexible
<code>TwoStageDesign</code> (see examples section).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupSequentialDesign(n1, c1f, c1e, n2_pivots, c2_pivots, order = NULL, ...)

## S4 method for signature 'GroupSequentialDesign'
TwoStageDesign(n1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GroupSequentialDesign-class_+3A_n1">n1</code></td>
<td>
<p>stage one sample size or <code>GroupSequentialDesign</code> object to convert
(overloaded from <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>)</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_c1f">c1f</code></td>
<td>
<p>early futility stopping boundary</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_c1e">c1e</code></td>
<td>
<p>early efficacy stopping boundary</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_n2_pivots">n2_pivots</code></td>
<td>
<p>numeric of length one, stage-two sample size</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_c2_pivots">c2_pivots</code></td>
<td>
<p>numeric vector, stage-two critical values on the integration
pivot points</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_order">order</code></td>
<td>
<p>of the Gaussian uadrature rule to use for integration, set to
length(c2_pivots) if NULL, otherwise first value of c2_pivots is repeated
'order'-times.</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code> for superclass and inherited methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- GroupSequentialDesign(25, 0, 2, 25, c(1, 1.5, 2.5))
summary(design)

TwoStageDesign(design)

</code></pre>

<hr>
<h2 id='make_tunable'>Fix parameters during optimization</h2><span id='topic+make_tunable'></span><span id='topic+make_tunable+2CTwoStageDesign-method'></span><span id='topic+make_fixed'></span><span id='topic+make_fixed+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>The methods <code>make_fixed</code> and <code>make_tunable</code> can be used to modify
the 'tunability' status of parameters in a <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
object.
Tunable parameters are optimized over, non-tunable ('fixed') parameters are
considered given and not altered during optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tunable(x, ...)

## S4 method for signature 'TwoStageDesign'
make_tunable(x, ...)

make_fixed(x, ...)

## S4 method for signature 'TwoStageDesign'
make_fixed(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_tunable_+3A_x">x</code></td>
<td>
<p><code>TwoStageDesign</code> object</p>
</td></tr>
<tr><td><code id="make_tunable_+3A_...">...</code></td>
<td>
<p>unquoted names of slots for which the tunability status should be
changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated object of class <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>, <code><a href="#topic+tunable_parameters">tunable_parameters</a></code> for
converting tunable parameters of a design object to a numeric vector (and back),
and <code><a href="#topic+minimize">minimize</a></code> for the actual minimzation procedure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(25, 0, 2, 25, 2, order = 5)
# default: all parameters are tunable (except integration pivots,
# weights and tunability status itself)
design@tunable

# make n1 and the pivots of n2 fixed (not changed during optimization)
design &lt;- make_fixed(design, n1, n2_pivots)
design@tunable

# make them tunable again
design &lt;- make_tunable(design, n1, n2_pivots)
design@tunable

</code></pre>

<hr>
<h2 id='MaximumSampleSize-class'>Maximum Sample Size of a Design</h2><span id='topic+MaximumSampleSize-class'></span><span id='topic+MaximumSampleSize'></span><span id='topic+evaluate+2CMaximumSampleSize+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>This score evaluates <code>max(n(d))</code> for a design <code>d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaximumSampleSize(label = "max(n(x1))")

## S4 method for signature 'MaximumSampleSize,TwoStageDesign'
evaluate(s, design, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaximumSampleSize-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="MaximumSampleSize-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="MaximumSampleSize-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="MaximumSampleSize-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="MaximumSampleSize-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Scores">Scores</a> for general scores and <a href="#topic+ConditionalSampleSize">ConditionalSampleSize</a>
for evaluating the sample size point-wise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L)
mss    &lt;- MaximumSampleSize()
evaluate(mss, design)

</code></pre>

<hr>
<h2 id='minimize'>Find optimal two-stage design by constraint minimization</h2><span id='topic+minimize'></span>

<h3>Description</h3>

<p><code>minimize</code> takes an unconditional score and
a constraint set (or no constraint) and solves the corresponding
minimization problem using
<a href="https://cran.r-project.org/package=nloptr"><code>nloptr</code></a>
(using COBYLA by default).
An initial design has to be defined. It is also possible to define
lower- and upper-boundary designs. If this is not done, the boundaries are
determined automatically heuristically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimize(
  objective,
  subject_to,
  initial_design,
  lower_boundary_design = get_lower_boundary_design(initial_design),
  upper_boundary_design = get_upper_boundary_design(initial_design),
  opts = list(algorithm = "NLOPT_LN_COBYLA", xtol_rel = 1e-05, maxeval = 10000),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimize_+3A_objective">objective</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="minimize_+3A_subject_to">subject_to</code></td>
<td>
<p>constraint collection</p>
</td></tr>
<tr><td><code id="minimize_+3A_initial_design">initial_design</code></td>
<td>
<p>initial guess (x0 for nloptr)</p>
</td></tr>
<tr><td><code id="minimize_+3A_lower_boundary_design">lower_boundary_design</code></td>
<td>
<p>design specifying the lower boundary.</p>
</td></tr>
<tr><td><code id="minimize_+3A_upper_boundary_design">upper_boundary_design</code></td>
<td>
<p>design specifying the upper boundary</p>
</td></tr>
<tr><td><code id="minimize_+3A_opts">opts</code></td>
<td>
<p>options list passed to nloptr</p>
</td></tr>
<tr><td><code id="minimize_+3A_...">...</code></td>
<td>
<p>further optional arguments passed to <code><a href="nloptr.html#topic+nloptr">nloptr</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements:
</p>
<table>
<tr><td><code>design</code></td>
<td>
<p> The resulting optimal design</p>
</td></tr>
<tr><td><code>nloptr_return</code></td>
<td>
<p> Output of the corresponding nloptr call</p>
</td></tr>
<tr><td><code>call_args</code></td>
<td>
<p> The arguments given to the optimization call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Define Type one error rate
toer &lt;- Power(Normal(), PointMassPrior(0.0, 1))

# Define Power at delta = 0.4
pow &lt;- Power(Normal(), PointMassPrior(0.4, 1))

# Define expected sample size at delta = 0.4
ess &lt;- ExpectedSampleSize(Normal(), PointMassPrior(0.4, 1))

# Compute design minimizing ess subject to power and toer constraints

minimize(

   ess,

   subject_to(
      toer &lt;= 0.025,
      pow  &gt;= 0.9
   ),

   initial_design = TwoStageDesign(50, .0, 2.0, 60.0, 2.0, 5L)

)


</code></pre>

<hr>
<h2 id='n1'>Query sample size of a design</h2><span id='topic+n1'></span><span id='topic+n1+2CTwoStageDesign-method'></span><span id='topic+n2'></span><span id='topic+n2+2CTwoStageDesign+2Cnumeric-method'></span><span id='topic+n'></span><span id='topic+n+2CTwoStageDesign+2Cnumeric-method'></span><span id='topic+n2+2CGroupSequentialDesign+2Cnumeric-method'></span><span id='topic+n2+2COneStageDesign+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods to access the stage-one, stage-two, or overall sample size of a
<code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
<code>n1</code> returns the first-stage sample size of a design,
<code>n2</code> the stage-two sample size conditional on the stage-one test
statistic and <code>n</code> the overall sample size <code>n1 + n2</code>.
Internally, objects of the class <code>TwoStageDesign</code> allow non-natural,
real sample sizes to allow smooth optimization (cf. <code><a href="#topic+minimize">minimize</a></code> for
details).
The optional argument <code>round</code> allows to switch between the internal
real representation and a rounded version (rounding to the next positive
integer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n1(d, ...)

## S4 method for signature 'TwoStageDesign'
n1(d, round = TRUE, ...)

n2(d, x1, ...)

## S4 method for signature 'TwoStageDesign,numeric'
n2(d, x1, round = TRUE, ...)

n(d, x1, ...)

## S4 method for signature 'TwoStageDesign,numeric'
n(d, x1, round = TRUE, ...)

## S4 method for signature 'GroupSequentialDesign,numeric'
n2(d, x1, round = TRUE, ...)

## S4 method for signature 'OneStageDesign,numeric'
n2(d, x1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n1_+3A_d">d</code></td>
<td>
<p>design</p>
</td></tr>
<tr><td><code id="n1_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="n1_+3A_round">round</code></td>
<td>
<p><code>logical</code> should sample sizes be rounded to next integer?</p>
</td></tr>
<tr><td><code id="n1_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sample size value of design <code>d</code> at point <code>x1</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>, see <code><a href="#topic+c2">c2</a></code> for accessing
the critical values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(
   n1    = 25,
   c1f   = 0,
   c1e   = 2.5,
   n2    = 50,
   c2    = 1.96,
   order = 7L
)

n1(design) # 25
design@n1 # 25

n(design, x1 = 2.2) # 75


</code></pre>

<hr>
<h2 id='N1-class'>Regularize n1</h2><span id='topic+N1-class'></span><span id='topic+N1'></span><span id='topic+evaluate+2CN1+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p><code>N1</code> is a class that computes the <code>n1</code> value of a design.
This can be used as a score in <code><a href="#topic+minimize">minimize</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N1(label = NA_character_)

## S4 method for signature 'N1,TwoStageDesign'
evaluate(s, design, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="N1-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="N1-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="N1-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="N1-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="N1-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+N1">N1</a></code>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+AverageN2">AverageN2</a></code> for a regularization of
the second-stage sample size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1_score &lt;- N1()

evaluate(
   N1(),
   TwoStageDesign(70, 0, 2, rep(60, 6), rep(1.7, 6))
) # 70

</code></pre>

<hr>
<h2 id='Normal-class'>Normal data distribution</h2><span id='topic+Normal-class'></span><span id='topic+Normal'></span><span id='topic+quantile+2CNormal-method'></span><span id='topic+simulate+2CNormal+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Implements a normal data distribution for z-values given an observed z-value
and stage size.
Standard deviation is 1 and mean &theta; &radic;n where
&theta; is the standardized effect size.
The option <code>two_armed</code> can be set to decide whether a one-arm or a
two-arm design should be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normal(two_armed = TRUE)

## S4 method for signature 'Normal'
quantile(x, probs, n, theta, ...)

## S4 method for signature 'Normal,numeric'
simulate(object, nsim, n, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normal-class_+3A_two_armed">two_armed</code></td>
<td>
<p>logical indicating if a two-armed trial is regarded</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Normal</code></p>
</td></tr>
<tr><td><code id="Normal-class_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+DataDistribution-class">DataDistribution-class</a></code> for more details.
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadist &lt;- Normal(two_armed = TRUE)

</code></pre>

<hr>
<h2 id='OneStageDesign-class'>One-stage designs</h2><span id='topic+OneStageDesign-class'></span><span id='topic+OneStageDesign'></span><span id='topic+TwoStageDesign+2COneStageDesign-method'></span><span id='topic+plot+2COneStageDesign-method'></span>

<h3>Description</h3>

<p><code>OneStageDesign</code> implements a one-stage design as special case of
a two-stage design, i.e. as sub-class of <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
This is possible by defining n<sub>2</sub> = 0,
c = c<sub>1</sub><sup>f</sup> = c<sub>1</sub><sup>e</sup>,
c<sub>2</sub>(x<sub>1</sub>) = ifelse(x<sub>1</sub> < c, Inf, -Inf).
No integration pivots etc are required (set to <code>NaN</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OneStageDesign(n, c)

## S4 method for signature 'OneStageDesign'
TwoStageDesign(n1, order = 5L, eps = 0.01, ...)

## S4 method for signature 'OneStageDesign'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OneStageDesign-class_+3A_n">n</code></td>
<td>
<p>sample size (stage-one sample size)</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_c">c</code></td>
<td>
<p>rejection boundary (c = c<sub>1</sub><sup>f</sup> = c<sub>1</sub><sup>e</sup>)</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_n1">n1</code></td>
<td>
<p><code>OneStageDesign</code> object to convert, overloaded from
<code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code></p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_order">order</code></td>
<td>
<p>integer &gt;= 2, default is 5; order of Gaussian quadrature
integration rule to use for new TwoStageDesign.</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_eps">eps</code></td>
<td>
<p>numeric &gt; 0, default = .01; the single critical value c must be
split in a continuation interval [c1f, c1e]; this is given by c +/- eps.</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_x">x</code></td>
<td>
<p>design to plot</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the default <code><a href="#topic+plot+2CTwoStageDesign-method">plot,TwoStageDesign-method</a></code> method
is not supported for <code>OneStageDesign</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>, <code><a href="#topic+GroupSequentialDesign">GroupSequentialDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- OneStageDesign(30, 1.96)
summary(design)
design &lt;- TwoStageDesign(design)
summary(design)

</code></pre>

<hr>
<h2 id='plot+2CTwoStageDesign-method'>Plot <code>TwoStageDesign</code> with optional set of conditional scores</h2><span id='topic+plot+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>This method allows to plot the stage-two sample size and decision boundary
functions of a chosen design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TwoStageDesign'
plot(x, y = NULL, ..., rounded = TRUE, k = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_x">x</code></td>
<td>
<p>design to plot</p>
</td></tr>
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_...">...</code></td>
<td>
<p>further named <code>ConditinonalScores</code> to plot for the design
and/or further graphic parameters</p>
</td></tr>
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_rounded">rounded</code></td>
<td>
<p>should n-values be rounded?</p>
</td></tr>
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_k">k</code></td>
<td>
<p>number of points to use for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code> and
user-defined elements of the class <code><a href="#topic+Scores">ConditionalScore</a></code>.
</p>


<h3>Value</h3>

<p>a plot of the two-stage design
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(50, 0, 2, 50, 2, 5)
cp     &lt;- ConditionalPower(dist = Normal(), prior = PointMassPrior(.4, 1))
plot(design, "Conditional Power" = cp, cex.axis = 2)

</code></pre>

<hr>
<h2 id='PointMassPrior-class'>Univariate discrete point mass priors</h2><span id='topic+PointMassPrior-class'></span><span id='topic+PointMassPrior'></span>

<h3>Description</h3>

<p><code>PointMassPrior</code> is a sub-class of <code><a href="#topic+Prior-class">Prior</a></code>
representing a univariate prior over a discrete set of points with positive
probability mass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PointMassPrior(theta, mass, label = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PointMassPrior-class_+3A_theta">theta</code></td>
<td>
<p>numeric vector of pivot points with positive prior mass</p>
</td></tr>
<tr><td><code id="PointMassPrior-class_+3A_mass">mass</code></td>
<td>
<p>numeric vector of probability masses at the pivot points
(must sum to 1)</p>
</td></tr>
<tr><td><code id="PointMassPrior-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>PointMassPrior</code>, <code>theta</code> is
automatically sorted in ascending order
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code></dt><dd><p>cf. parameter 'theta'</p>
</dd>
<dt><code>mass</code></dt><dd><p>cf. parameter 'mass'</p>
</dd>
</dl>


<h3>See Also</h3>

<p>To represent continuous prior distributions use <code><a href="#topic+ContinuousPrior">ContinuousPrior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PointMassPrior(c(0, .5), c(.3, .7))

</code></pre>

<hr>
<h2 id='posterior'>Compute posterior distribution</h2><span id='topic+posterior'></span><span id='topic+posterior+2CDataDistribution+2CPointMassPrior+2Cnumeric-method'></span><span id='topic+posterior+2CDataDistribution+2CContinuousPrior+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Return posterior distribution given observing stage-one outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,PointMassPrior,numeric'
posterior(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,ContinuousPrior,numeric'
posterior(dist, prior, x1, n1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="posterior_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="posterior_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="posterior_+3A_n1">n1</code></td>
<td>
<p>stage-one sample size</p>
</td></tr>
<tr><td><code id="posterior_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="#topic+Prior">Prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior(Normal(), PointMassPrior(0, 1), 2, 20)

tmp &lt;- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4))
posterior(Normal(), tmp, 2, 20)

</code></pre>

<hr>
<h2 id='predictive_cdf'>Predictive CDF</h2><span id='topic+predictive_cdf'></span><span id='topic+predictive_cdf+2CDataDistribution+2CPointMassPrior+2Cnumeric-method'></span><span id='topic+predictive_cdf+2CDataDistribution+2CContinuousPrior+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>predictive_cdf()</code> evaluates the predictive CDF of the model specified
by a <code><a href="#topic+DataDistribution">DataDistribution</a></code> <code>dist</code> and
<code><a href="#topic+Prior">Prior</a></code> at the given stage-one outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive_cdf(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,PointMassPrior,numeric'
predictive_cdf(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,ContinuousPrior,numeric'
predictive_cdf(
  dist,
  prior,
  x1,
  n1,
  k = 10 * (prior@support[2] - prior@support[1]) + 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive_cdf_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_n1">n1</code></td>
<td>
<p>stage-one sample size</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_k">k</code></td>
<td>
<p>number of pivots for crude integral approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>, value of the predictive CDF
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predictive_cdf(Normal(), PointMassPrior(.0, 1), 0, 20) # .5

tmp &lt;- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4))
predictive_cdf(Normal(), tmp, 2, 20)

</code></pre>

<hr>
<h2 id='predictive_pdf'>Predictive PDF</h2><span id='topic+predictive_pdf'></span><span id='topic+predictive_pdf+2CDataDistribution+2CPointMassPrior+2Cnumeric-method'></span><span id='topic+predictive_pdf+2CDataDistribution+2CContinuousPrior+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>predictive_pdf()</code> evaluates the predictive PDF of the model specified
by a <code><a href="#topic+DataDistribution">DataDistribution</a></code> <code>dist</code> and
<code><a href="#topic+Prior">Prior</a></code> at the given stage-one outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive_pdf(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,PointMassPrior,numeric'
predictive_pdf(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,ContinuousPrior,numeric'
predictive_pdf(
  dist,
  prior,
  x1,
  n1,
  k = 10 * (prior@support[2] - prior@support[1]) + 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive_pdf_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_n1">n1</code></td>
<td>
<p>stage-one sample size</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_k">k</code></td>
<td>
<p>number of pivots for crude integral approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>, value of the predictive PDF
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predictive_pdf(Normal(), PointMassPrior(.3, 1), 1.5, 20) # ~.343

tmp &lt;- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4))
predictive_pdf(Normal(), tmp, 2, 20)

</code></pre>

<hr>
<h2 id='print.adoptrOptimizationResult'>Printing an optimization result</h2><span id='topic+print.adoptrOptimizationResult'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>Printing an optimization result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.adoptrOptimizationResult_+3A_x">x</code></td>
<td>
<p>object to print</p>
</td></tr>
<tr><td><code id="print.adoptrOptimizationResult_+3A_...">...</code></td>
<td>
<p>further arguments passed form other methods</p>
</td></tr>
</table>

<hr>
<h2 id='Prior-class'>Univariate prior on model parameter</h2><span id='topic+Prior-class'></span><span id='topic+Prior'></span>

<h3>Description</h3>

<p>A <code>Prior</code> object represents a prior distribution on the single model
parameter of a <code><a href="#topic+DataDistribution">DataDistribution</a></code> class
object.
Together a prior and data-distribution specify the class of the joint
distribution of the test statisic, X, and its parameter, theta.
Currently, <span class="pkg">adoptr</span> only allows simple models with a single parameter.
Implementations for <a href="#topic+PointMassPrior">PointMassPrior</a> and <a href="#topic+ContinuousPrior">ContinuousPrior</a> are available.
</p>


<h3>Details</h3>

<p>For an example on working with priors, see
<a href="https://optad.github.io/adoptr/articles/working-with-priors.html">here</a>.
</p>


<h3>See Also</h3>

<p>For the available methods, see <code><a href="#topic+bounds">bounds</a></code>,
<code><a href="#topic+expectation">expectation</a></code>, <code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+predictive_pdf">predictive_pdf</a></code>,
<code><a href="#topic+predictive_cdf">predictive_cdf</a></code>, <code><a href="#topic+posterior">posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc_prior &lt;- PointMassPrior(c(0.1, 0.25), c(0.4, 0.6))

cont_prior &lt;- ContinuousPrior(
  pdf     = function(x) dnorm(x, mean = 0.3, sd = 0.2),
  support = c(-2, 3)
)


</code></pre>

<hr>
<h2 id='probability_density_function'>Probability density function</h2><span id='topic+probability_density_function'></span><span id='topic+probability_density_function+2CBinomial+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+probability_density_function+2CNormal+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+probability_density_function+2CStudent+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>probability_density_function</code> evaluates the probability density
function of a specific distribution <code>dist</code> at a point <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probability_density_function(dist, x, n, theta, ...)

## S4 method for signature 'Binomial,numeric,numeric,numeric'
probability_density_function(dist, x, n, theta, ...)

## S4 method for signature 'Normal,numeric,numeric,numeric'
probability_density_function(dist, x, n, theta, ...)

## S4 method for signature 'Student,numeric,numeric,numeric'
probability_density_function(dist, x, n, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probability_density_function_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="probability_density_function_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="probability_density_function_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="probability_density_function_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="probability_density_function_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the distribution is <code><a href="#topic+Binomial">Binomial</a></code>,
theta denotes the rate difference between
intervention and control group.
Then, the mean is assumed to be
&radic; n  theta.
</p>
<p>If the distribution is <code><a href="#topic+Normal">Normal</a></code>, then
the mean is assumed to be
&radic; n  theta.
</p>


<h3>Value</h3>

<p>value of the probability density function at point <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probability_density_function(Binomial(.2, FALSE), 1, 50, .3)

probability_density_function(Normal(), 1, 50, .3)

probability_density_function(Student(TRUE), 1, 40, 1.1)

</code></pre>

<hr>
<h2 id='Scores'>Scores</h2><span id='topic+Scores'></span><span id='topic+expected'></span><span id='topic+expected+2CConditionalScore-method'></span><span id='topic+evaluate'></span><span id='topic+evaluate+2CIntegralScore+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>In <code>adoptr</code> scores are used to assess the performance of a design.
This can be done either conditionally on the observed stage-one outcome
or unconditionally.
Consequently, score objects are either of class <code>ConditionalScore</code> or
<code>UnconditionalScore</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected(s, data_distribution, prior, ...)

## S4 method for signature 'ConditionalScore'
expected(s, data_distribution, prior, label = NA_character_, ...)

evaluate(s, design, ...)

## S4 method for signature 'IntegralScore,TwoStageDesign'
evaluate(s, design, optimization = FALSE, subdivisions = 10000L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Scores_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="Scores_+3A_data_distribution">data_distribution</code></td>
<td>
<p><code><a href="#topic+DataDistribution">DataDistribution</a></code> object</p>
</td></tr>
<tr><td><code id="Scores_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="Scores_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Scores_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="Scores_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="Scores_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="Scores_+3A_subdivisions">subdivisions</code></td>
<td>
<p>maximal number of subdivisions when evaluating an integral
score using adaptive quadrature (optimization = FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All scores can be evaluated on a design using the <code>evaluate</code> method.
Note that <code>evaluate</code> requires a third argument <code>x1</code> for
conditional scores (observed stage-one outcome).
Any <code>ConditionalScore</code> can be converted to a <code>UnconditionalScore</code>
by forming its expected value using <code>expected</code>.
The returned unconditional score is of class <code>IntegralScore</code>.
</p>


<h3>Value</h3>

<p>No return value. Generic description of class <code>Score</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ConditionalPower">ConditionalPower</a></code>, <code><a href="#topic+ConditionalSampleSize">ConditionalSampleSize</a></code>,
<code><a href="#topic+composite">composite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(
  n1    = 25,
  c1f   = 0,
  c1e   = 2.5,
  n2    = 50,
  c2    = 1.96,
  order = 7L
)
prior &lt;- PointMassPrior(.3, 1)

# conditional
cp &lt;- ConditionalPower(Normal(), prior)
expected(cp, Normal(), prior)
evaluate(cp, design, x1 = .5)

# unconditional
power &lt;- Power(Normal(), prior)
evaluate(power, design)
evaluate(power, design, optimization = TRUE) # use non-adaptive quadrature

</code></pre>

<hr>
<h2 id='simulate+2CTwoStageDesign+2Cnumeric-method'>Draw samples from a two-stage design</h2><span id='topic+simulate+2CTwoStageDesign+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>simulate</code> allows to draw samples from a given
<code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TwoStageDesign,numeric'
simulate(object, nsim, dist, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_object">object</code></td>
<td>
<p><code>TwoStageDesign</code> to draw samples from</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_dist">dist</code></td>
<td>
<p>data distribution</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_theta">theta</code></td>
<td>
<p>location parameter of the data distribution</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simulate()</code> returns a <code>data.frame</code> with <code>nsim</code>
rows and for each row (each simulation run) the following columns
</p>

<ul>
<li><p> theta: The effect size
</p>
</li>
<li><p> n1: First-stage sample size
</p>
</li>
<li><p> c1f: Stopping for futility boundary
</p>
</li>
<li><p> c1e: Stopping for efficacy boundary
</p>
</li>
<li><p> x1: First-stage outcome
</p>
</li>
<li><p> n2: Resulting second-stage sample size after observing x1
</p>
</li>
<li><p> c2: Resulting second-stage decision-boundary after observing x1
</p>
</li>
<li><p> x2: Second-stage outcome
</p>
</li>
<li><p> reject: Decision whether the null hypothesis is rejected or not
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(25, 0, 2, 25, 2, order = 5)
# draw samples assuming two-armed design
simulate(design, 10, Normal(), .3, 42)

</code></pre>

<hr>
<h2 id='Student-class'>Student's t data distribution</h2><span id='topic+Student-class'></span><span id='topic+Student'></span><span id='topic+quantile+2CStudent-method'></span><span id='topic+simulate+2CStudent+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Implements exact t-distributions instead of a normal approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Student(two_armed = TRUE)

## S4 method for signature 'Student'
quantile(x, probs, n, theta, ...)

## S4 method for signature 'Student,numeric'
simulate(object, nsim, n, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Student-class_+3A_two_armed">two_armed</code></td>
<td>
<p>logical indicating if a two-armed trial is regarded</p>
</td></tr>
<tr><td><code id="Student-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="Student-class_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Student-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="Student-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="Student-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Student-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Student</code></p>
</td></tr>
<tr><td><code id="Student-class_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="Student-class_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>see <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadist &lt;- Student(two_armed = TRUE)

</code></pre>

<hr>
<h2 id='subject_to'>Create a collection of constraints</h2><span id='topic+subject_to'></span><span id='topic+ConstraintCollection'></span><span id='topic+evaluate+2CConstraintsCollection+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p><code>subject_to(...)</code> can be used to generate an object of class
<code>ConstraintsCollection</code> from an arbitrary number of (un)conditional
constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject_to(...)

## S4 method for signature 'ConstraintsCollection,TwoStageDesign'
evaluate(s, design, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subject_to_+3A_...">...</code></td>
<td>
<p>either constraint objects (for <code>subject_to</code> or optional arguments passed to <code>evaluate</code>)</p>
</td></tr>
<tr><td><code id="subject_to_+3A_s">s</code></td>
<td>
<p>object of class <code>ConstraintCollection</code></p>
</td></tr>
<tr><td><code id="subject_to_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="subject_to_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>ConstraintsCollection</code>
</p>


<h3>See Also</h3>

<p><code>subject_to</code> is intended to be used for constraint
specification the constraints in <code><a href="#topic+minimize">minimize</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define type one error rate and power
toer  &lt;- Power(Normal(), PointMassPrior(0.0, 1))
power &lt;- Power(Normal(), PointMassPrior(0.4, 1))

# create constrain collection
subject_to(
  toer  &lt;= 0.025,
  power &gt;= 0.9
)

</code></pre>

<hr>
<h2 id='tunable_parameters'>Switch between numeric and S4 class representation of a design</h2><span id='topic+tunable_parameters'></span><span id='topic+tunable_parameters+2CTwoStageDesign-method'></span><span id='topic+update+2CTwoStageDesign-method'></span><span id='topic+update+2COneStageDesign-method'></span>

<h3>Description</h3>

<p>Get tunable parameters of a design as numeric vector via
<code>tunable_parameters</code> or <code>update</code> a design object with a suitable
vector of values for its tunable parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tunable_parameters(object, ...)

## S4 method for signature 'TwoStageDesign'
tunable_parameters(object, ...)

## S4 method for signature 'TwoStageDesign'
update(object, params, ...)

## S4 method for signature 'OneStageDesign'
update(object, params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tunable_parameters_+3A_object">object</code></td>
<td>
<p><code>TwoStageDesign</code> object to update</p>
</td></tr>
<tr><td><code id="tunable_parameters_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="tunable_parameters_+3A_params">params</code></td>
<td>
<p>vector of design parameters, must be in same order as returned
by <br />
<code>tunable_parameters</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tunable</code> slot of a <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code> stores information about
the set of design parameters which are considered fixed (not changed during
optimization) or tunable (changed during optimization).
For details on how to fix certain parameters or how to make them tunable
again, see <code><a href="#topic+make_fixed">make_fixed</a></code> and <code><a href="#topic+make_tunable">make_tunable</a></code>.
</p>


<h3>Value</h3>

<p><code>tunable_parameters</code> returns the numerical values of all
tunable parameters as a vector.
<code>update</code> returns the updated design.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design  &lt;- TwoStageDesign(25, 0, 2, 25, 2, order = 5)
tunable_parameters(design)
design2 &lt;- update(design, tunable_parameters(design) + 1)
tunable_parameters(design2)

</code></pre>

<hr>
<h2 id='TwoStageDesign-class'>Two-stage designs</h2><span id='topic+TwoStageDesign-class'></span><span id='topic+TwoStageDesign'></span><span id='topic+TwoStageDesign+2Cnumeric-method'></span><span id='topic+summary+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p><code>TwoStageDesign</code> is the fundamental design class of the
<span class="pkg"><a href="#topic+adoptr">adoptr</a></span> package.
Formally, we represent a generic two-stage design as a five-tuple
(n<sub>1</sub>, c<sub>1</sub><sup>f</sup>, c<sub>1</sub><sup>e</sup>, n<sub>2</sub>(&middot;), c<sub>2</sub>(&middot;)).
Here, n<sub>1</sub> is the first-stage sample
size (per group), c<sub>1</sub><sup>f</sup>
and c<sub>1</sub><sup>e</sup> are
boundaries for early stopping for futility and efficacy, respectively.
Since the trial design is a two-stage design, the elements
n<sub>2</sub>(&middot;) (stage-two sample
size) and c<sub>2</sub>(&middot;)
(stage-two critical value) are functions of the first-stage outcome
X<sub>1</sub>=x<sub>1</sub>.
X<sub>1</sub> denotes the first-stage test
statistic. A brief description on this definition of two-stage designs can be
read <a href="https://optad.github.io/adoptr/articles/adoptr.html">here</a>.
For available methods, see the 'See Also' section at the end of this page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoStageDesign(n1, ...)

## S4 method for signature 'numeric'
TwoStageDesign(n1, c1f, c1e, n2_pivots, c2_pivots, order = NULL, ...)

## S4 method for signature 'TwoStageDesign'
summary(object, ..., rounded = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwoStageDesign-class_+3A_n1">n1</code></td>
<td>
<p>stage-one sample size</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_c1f">c1f</code></td>
<td>
<p>early futility stopping boundary</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_c1e">c1e</code></td>
<td>
<p>early efficacy stopping boundary</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_n2_pivots">n2_pivots</code></td>
<td>
<p>numeric vector, stage-two sample size on the integration
pivot points</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_c2_pivots">c2_pivots</code></td>
<td>
<p>numeric vector, stage-two critical values on the integration
pivot points</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_order">order</code></td>
<td>
<p><code>integer</code>, integration order of the employed Gaussian quadrature
integration rule to evaluate scores. Automatically set to <code>length(n2_pivots)</code> if <br />
<code>length(n2_pivots) == length(c2_pivots) &gt; 1</code>, otherwise c2 and n2
are taken to be constant in stage-two and replicated to match the number of
pivots specified by <code>order</code></p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_object">object</code></td>
<td>
<p>object to show</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_rounded">rounded</code></td>
<td>
<p>should rounded n-values be used?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary</code> can be used to quickly compute and display basic facts about
a TwoStageDesign.
An arbitrary number of names <code><a href="#topic+Scores">UnconditionalScore</a></code> objects can be
provided via the optional arguments <code>...</code> and are included in the summary displayed using
<code><a href="#topic+print">print</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>n1</code></dt><dd><p>cf. parameter 'n1'</p>
</dd>
<dt><code>c1f</code></dt><dd><p>cf. parameter 'c1f'</p>
</dd>
<dt><code>c1e</code></dt><dd><p>cf. parameter 'c1e'</p>
</dd>
<dt><code>n2_pivots</code></dt><dd><p>vector of length 'order' giving the values of n2 at the
pivot points of the numeric integration rule</p>
</dd>
<dt><code>c2_pivots</code></dt><dd><p>vector of length order giving the values of c2 at the
pivot points of the numeric integration rule</p>
</dd>
<dt><code>x1_norm_pivots</code></dt><dd><p>normalized pivots for integration rule (in [-1, 1])
the actual pivots are scaled to the interval [c1f, c1e] and can be
obtained by the internal method <br />
<code>adoptr:::scaled_integration_pivots(design)</code></p>
</dd>
<dt><code>weights</code></dt><dd><p>weights of of integration rule at <code>x1_norm_pivots</code> for
approximating integrals over <code>x1</code></p>
</dd>
<dt><code>tunable</code></dt><dd><p>named logical vector indicating whether corresponding slot is
considered a tunable parameter (i.e. whether it can be changed during
optimization via <code><a href="#topic+minimize">minimize</a></code> or not; cf. <br />
<code><a href="#topic+make_fixed">make_fixed</a></code>)</p>
</dd>
</dl>


<h3>See Also</h3>

<p>For accessing sample sizes and critical values safely, see methods in
<code><a href="#topic+n">n</a></code> and <code><a href="#topic+c2">c2</a></code>; for modifying behaviour during optimizaton
see <code><a href="#topic+make_tunable">make_tunable</a></code>; to convert between S4 class represenation and
numeric vector, see <code><a href="#topic+tunable_parameters">tunable_parameters</a></code>; for simulating from a given
design, see <code><a href="#topic+simulate+2CTwoStageDesign+2Cnumeric-method">simulate</a></code>;
for plotting see <code><a href="#topic+plot+2CTwoStageDesign-method">plot,TwoStageDesign-method</a></code>.
Both <a href="#topic+GroupSequentialDesign-class">group-sequential</a> and
<a href="#topic+OneStageDesign">one-stage designs</a> (!) are implemented as subclasses of
<code>TwoStageDesign</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(50, 0, 2, 50.0, 2.0, 5)
pow    &lt;- Power(Normal(), PointMassPrior(.4, 1))
summary(design, "Power" = pow)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
