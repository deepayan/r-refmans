<!DOCTYPE html><html lang="en"><head><title>Help for package adoptr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adoptr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adoptr'><p>Adaptive Optimal Two-Stage Designs</p></a></li>
<li><a href='#ANOVA-class'><p>Analysis of Variance</p></a></li>
<li><a href='#AverageN2-class'><p>Regularization via L1 norm</p></a></li>
<li><a href='#Binomial-class'><p>Binomial data distribution</p></a></li>
<li><a href='#bounds'><p>Get support of a prior or data distribution</p></a></li>
<li><a href='#c2'><p>Query critical values of a design</p></a></li>
<li><a href='#ChiSquared-class'><p>Chi-Squared data distribution</p></a></li>
<li><a href='#composite'><p>Score Composition</p></a></li>
<li><a href='#condition'><p>Condition a prior on an interval</p></a></li>
<li><a href='#ConditionalPower-class'><p>(Conditional) Power of a Design</p></a></li>
<li><a href='#ConditionalSampleSize-class'><p>(Conditional) Sample Size of a Design</p></a></li>
<li><a href='#Constraints'><p>Formulating Constraints</p></a></li>
<li><a href='#ContinuousPrior-class'><p>Continuous univariate prior distributions</p></a></li>
<li><a href='#cumulative_distribution_function'><p>Cumulative distribution function</p></a></li>
<li><a href='#DataDistribution-class'><p>Data distributions</p></a></li>
<li><a href='#expectation'><p>Expected value of a function</p></a></li>
<li><a href='#get_initial_design'><p>Initial design</p></a></li>
<li><a href='#get_lower_boundary_design'><p>Boundary designs</p></a></li>
<li><a href='#GroupSequentialDesign-class'><p>Group-sequential two-stage designs</p></a></li>
<li><a href='#GroupSequentialDesignSurvival-class'><p>Group-sequential two-stage designs for time-to-event-endpoints</p></a></li>
<li><a href='#make_tunable'><p>Fix parameters during optimization</p></a></li>
<li><a href='#MaximumSampleSize-class'><p>Maximum Sample Size of a Design</p></a></li>
<li><a href='#minimize'><p>Find optimal two-stage design by constraint minimization</p></a></li>
<li><a href='#n1'><p>Query sample size of a design</p></a></li>
<li><a href='#N1-class'><p>Regularize n1</p></a></li>
<li><a href='#NestedModels-class'><p>F-Distribution</p></a></li>
<li><a href='#Normal-class'><p>Normal data distribution</p></a></li>
<li><a href='#OneStageDesign-class'><p>One-stage designs</p></a></li>
<li><a href='#OneStageDesignSurvival-class'><p>One-stage designs for time-to-event endpoints</p></a></li>
<li><a href='#Pearson2xK-class'><p>Pearson's chi-squared test for contingency tables</p></a></li>
<li><a href='#plot+2CTwoStageDesign-method'><p>Plot <code>TwoStageDesign</code> with optional set of conditional scores</p></a></li>
<li><a href='#PointMassPrior-class'><p>Univariate discrete point mass priors</p></a></li>
<li><a href='#posterior'><p>Compute posterior distribution</p></a></li>
<li><a href='#predictive_cdf'><p>Predictive CDF</p></a></li>
<li><a href='#predictive_pdf'><p>Predictive PDF</p></a></li>
<li><a href='#print.adoptrOptimizationResult'><p>Printing an optimization result</p></a></li>
<li><a href='#Prior-class'><p>Univariate prior on model parameter</p></a></li>
<li><a href='#probability_density_function'><p>Probability density function</p></a></li>
<li><a href='#Scores'><p>Scores</p></a></li>
<li><a href='#simulate+2CTwoStageDesign+2Cnumeric-method'><p>Draw samples from a two-stage design</p></a></li>
<li><a href='#Student-class'><p>Student's t data distribution</p></a></li>
<li><a href='#subject_to'><p>Create a collection of constraints</p></a></li>
<li><a href='#Survival-class'><p>Log-rank test</p></a></li>
<li><a href='#SurvivalDesign'><p>SurvivalDesign</p></a></li>
<li><a href='#tunable_parameters'><p>Switch between numeric and S4 class representation of a design</p></a></li>
<li><a href='#TwoStageDesign-class'><p>Two-stage designs</p></a></li>
<li><a href='#TwoStageDesignSurvival-class'><p>Two-stage design for time-to-event-endpoints</p></a></li>
<li><a href='#ZSquared-class'><p>Distribution class of a squared normal distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive Optimal Two-Stage Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimize one or two-arm, two-stage designs for clinical trials with 
    respect to several implemented objective criteria or custom objectives.
    Optimization under uncertainty and conditional (given stage-one outcome) 
    constraints are supported.
    See Pilz et al. (2019) &lt;<a href="https://doi.org/10.1002%2Fsim.8291">doi:10.1002/sim.8291</a>&gt; and 
    Kunzmann et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v098.i09">doi:10.18637/jss.v098.i09</a>&gt; for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr, rpact, vdiffr, pwr, dplyr,
ggplot2, tidyr, gridExtra, bookdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>nloptr, methods, glue</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'DataDistribution.R' 'BinomialDistribution.R'
'ChiSquaredDistribution.R' 'Prior.R' 'TwoStageDesign.R'
'OneStageDesign.R' 'util.R' 'Scores.R' 'CompositeScore.R'
'ConditionalPower.R' 'ConditionalSampleSize.R'
'ContinuousPrior.R' 'FDistribution.R' 'GroupSequentialDesign.R'
'MaximumSampleSize.R' 'NormalDistribution.R' 'PointMassPrior.R'
'StudentDistribution.R' 'Survival.R' 'adoptr.R' 'constraints.R'
'minimize.R' 'regularization.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/optad/adoptr/issues">https://github.com/optad/adoptr/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/optad/adoptr">https://github.com/optad/adoptr</a>, <a href="https://optad.github.io/adoptr/">https://optad.github.io/adoptr/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-02 18:40:58 UTC; pilz</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Kunzmann <a href="https://orcid.org/0000-0002-1140-7143"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Maximilian Pilz <a href="https://orcid.org/0000-0002-9685-1613"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jan Meis <a href="https://orcid.org/0000-0001-5407-7220"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Nico Bruder <a href="https://orcid.org/0009-0004-9522-2075"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian Pilz &lt;maximilian.pilz@itwm.fraunhofer.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-02 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adoptr'>Adaptive Optimal Two-Stage Designs</h2><span id='topic+adoptr-package'></span><span id='topic+adoptr'></span>

<h3>Description</h3>

<p>The <span class="pkg">adoptr</span> package provides functionality to explore custom optimal
two-stage designs for one- or two-arm superiority tests.
For more details on the theoretical background see
<a href="doi:10.1002/sim.8291">doi:10.1002/sim.8291</a> and <a href="doi:10.18637/jss.v098.i09">doi:10.18637/jss.v098.i09</a>.
<span class="pkg">adoptr</span> makes heavy use of the S4 class system.
A good place to start learning about it can be found
<a href="http://adv-r.had.co.nz/OO-essentials.html">here</a>.
</p>


<h3>Quickstart</h3>

<p>For a sample workflow and a quick demo of the capabilities, see
<a href="https://optad.github.io/adoptr/articles/adoptr.html">here</a>.
</p>
<p>A more detailed description of the background and the usage of <span class="pkg">adoptr</span>
can be found <a href="https://optad.github.io/adoptr/articles/adoptr_jss.html">here</a>
or here <a href="doi:10.18637/jss.v098.i09">doi:10.18637/jss.v098.i09</a> .
</p>
<p>A variety of examples is presented in the validation report hosted
<a href="https://optad.github.io/adoptr-validation-report/">here</a>.
</p>


<h3>Designs</h3>

<p><span class="pkg">adoptr</span> currently supports <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>,
<code><a href="#topic+GroupSequentialDesign">GroupSequentialDesign</a></code>, and <code><a href="#topic+OneStageDesign">OneStageDesign</a></code>.
</p>


<h3>Data distributions</h3>

<p>The implemented data distributions are <code><a href="#topic+Normal">Normal</a></code>, <code><a href="#topic+Binomial">Binomial</a></code>,
<code><a href="#topic+Student">Student</a></code>, <code><a href="#topic+Survival">Survival</a></code>, <code><a href="#topic+ChiSquared">ChiSquared</a></code> (including
<code><a href="#topic+Pearson2xK">Pearson2xK</a></code> and <code><a href="#topic+ZSquared">ZSquared</a></code>) and <code><a href="#topic+ANOVA">ANOVA</a></code>.
</p>


<h3>Priors</h3>

<p>Both <code><a href="#topic+ContinuousPrior">ContinuousPrior</a></code> and <code><a href="#topic+PointMassPrior">PointMassPrior</a></code> are
supported for the single parameter of a <code><a href="#topic+DataDistribution">DataDistribution</a></code>.
</p>


<h3>Scores</h3>

<p>See <code><a href="#topic+Scores">Scores</a></code> for information on the basic system of representing
scores.
Available scores are <code><a href="#topic+ConditionalPower">ConditionalPower</a></code>,
<code><a href="#topic+ConditionalSampleSize">ConditionalSampleSize</a></code>, <code><a href="#topic+Power">Power</a></code>, and
<code><a href="#topic+ExpectedSampleSize">ExpectedSampleSize</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Maximilian Pilz <a href="mailto:maximilian.pilz@itwm.fraunhofer.de">maximilian.pilz@itwm.fraunhofer.de</a> (<a href="https://orcid.org/0000-0002-9685-1613">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Kevin Kunzmann <a href="mailto:kevin.kunzmann@boehringer-ingelheim.com">kevin.kunzmann@boehringer-ingelheim.com</a> (<a href="https://orcid.org/0000-0002-1140-7143">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Jan Meis <a href="mailto:meis@imbi.uni-heidelberg.de">meis@imbi.uni-heidelberg.de</a> (<a href="https://orcid.org/0000-0001-5407-7220">ORCID</a>)
</p>
</li>
<li><p> Nico Bruder <a href="mailto:bruder@imbi.uni-heidelberg.de">bruder@imbi.uni-heidelberg.de</a> (<a href="https://orcid.org/0009-0004-9522-2075">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/optad/adoptr">https://github.com/optad/adoptr</a>
</p>
</li>
<li> <p><a href="https://optad.github.io/adoptr/">https://optad.github.io/adoptr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/optad/adoptr/issues">https://github.com/optad/adoptr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ANOVA-class'>Analysis of Variance</h2><span id='topic+ANOVA-class'></span><span id='topic+ANOVA'></span><span id='topic+get_tau_ANOVA'></span>

<h3>Description</h3>

<p>ANOVA is used to test whether there is a significant difference between the means of groups.
The sample size which <code>adoptr</code> returns is the group wise sample size.
The function <code>get_tau_ANOVA</code> is used to obtain a parameter <code class="reqn">\tau</code>,
which is used in the same way as <code class="reqn">\theta</code> to describe the difference of
means between the groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANOVA(n_groups)

get_tau_ANOVA(means, common_sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ANOVA-class_+3A_n_groups">n_groups</code></td>
<td>
<p>number of groups to be compared</p>
</td></tr>
<tr><td><code id="ANOVA-class_+3A_means">means</code></td>
<td>
<p>vector denoting the mean per group</p>
</td></tr>
<tr><td><code id="ANOVA-class_+3A_common_sd">common_sd</code></td>
<td>
<p>standard deviation of the groups</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>see <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively. Use <code><a href="#topic+NestedModels">NestedModels</a></code> to get insights
in the implementation of <code>ANOVA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- ANOVA(3L)

H1 &lt;- PointMassPrior(get_tau_ANOVA(c(0.4, 0.8, 0.5)), 1)

</code></pre>

<hr>
<h2 id='AverageN2-class'>Regularization via L1 norm</h2><span id='topic+AverageN2-class'></span><span id='topic+AverageN2'></span><span id='topic+evaluate+2CAverageN2+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>Implements the L1-norm of the design's stage-two sample size function.
The average of the stage-two sample size without weighting with
the data distribution is computed.
This can be interpreted as integration over a unifrom prior on
the continuation region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AverageN2(label = NA_character_)

## S4 method for signature 'AverageN2,TwoStageDesign'
evaluate(s, design, optimization = FALSE, subdivisions = 10000L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AverageN2-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_subdivisions">subdivisions</code></td>
<td>
<p>number of subdivisions to use for adaptive integration
(only affects non-optimization code)</p>
</td></tr>
<tr><td><code id="AverageN2-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+AverageN2">AverageN2</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+N1">N1</a></code> for penalizing n1 values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>avn2 &lt;- AverageN2()

evaluate(
   AverageN2(),
   TwoStageDesign(100, 0.5, 1.5, 60.0, 1.96, order = 5L)
) # 60

</code></pre>

<hr>
<h2 id='Binomial-class'>Binomial data distribution</h2><span id='topic+Binomial-class'></span><span id='topic+Binomial'></span><span id='topic+quantile+2CBinomial-method'></span><span id='topic+simulate+2CBinomial+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Implements the normal approximation for a test on rates.
The reponse rate in the control group,
r<sub>C</sub>, has to be specified by
<code>rate_control</code>.
The null hypothesis is:
r<sub>E</sub> &le; r<sub>C</sub>,
where r<sub>E</sub> denotes the response rate
in the invervention group.
It is tested against the alternative
r<sub>E</sub> > r<sub>C</sub>.
The test statistic is given as
X<sub>1</sub> = &radic;n (r<sub>E</sub> - r<sub>C</sub>) / &radic;(2  r<sub>0</sub> (1-r<sub>0</sub>)),
where r<sub>0</sub> denotes the mean between
r<sub>E</sub> and
r<sub>C</sub> in the two-armed case,
and r<sub>E</sub> in the one-armed case.#'
All priors have to be defined for the rate difference
r<sub>E</sub> - r<sub>C</sub>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Binomial(rate_control, two_armed = TRUE)

## S4 method for signature 'Binomial'
quantile(x, probs, n, theta, ...)

## S4 method for signature 'Binomial,numeric'
simulate(object, nsim, n, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Binomial-class_+3A_rate_control">rate_control</code></td>
<td>
<p>assumed response rate in control group</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_two_armed">two_armed</code></td>
<td>
<p>logical indicating if a two-armed trial is regarded</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Binomial</code></p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="Binomial-class_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>simulate</code> for class <code>Binomial</code> simulates the
normal approximation of the test statistic.
</p>


<h3>Slots</h3>


<dl>
<dt><code>rate_control</code></dt><dd><p>cf. parameter 'rate_control'</p>
</dd>
</dl>


<h3>See Also</h3>

<p>see <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadist &lt;- Binomial(rate_control = 0.2, two_armed = FALSE)

</code></pre>

<hr>
<h2 id='bounds'>Get support of a prior or data distribution</h2><span id='topic+bounds'></span><span id='topic+bounds+2CContinuousPrior-method'></span><span id='topic+bounds+2CPointMassPrior-method'></span>

<h3>Description</h3>

<p><code>bounds()</code> returns the range of the support of a prior or data distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds(dist, ...)

## S4 method for signature 'ContinuousPrior'
bounds(dist, ...)

## S4 method for signature 'PointMassPrior'
bounds(dist, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounds_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="bounds_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> of length two, <code>c(lower, upper)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bounds(ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)))
# &gt; 0.2 0.4

bounds(PointMassPrior(c(0, .5), c(.3, .7)))
# &gt; 0.3 0.7

</code></pre>

<hr>
<h2 id='c2'>Query critical values of a design</h2><span id='topic+c2'></span><span id='topic+c2+2CTwoStageDesign+2Cnumeric-method'></span><span id='topic+c2+2COneStageDesign+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods to access the stage-two critical values of a
<code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
<code>c2</code> returns the stage-two critical value conditional on the stage-one test
statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2(d, x1, ...)

## S4 method for signature 'TwoStageDesign,numeric'
c2(d, x1, ...)

## S4 method for signature 'OneStageDesign,numeric'
c2(d, x1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c2_+3A_d">d</code></td>
<td>
<p>design</p>
</td></tr>
<tr><td><code id="c2_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="c2_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the critical value function <code>c2</code> of design <code>d</code> at position <code>x1</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>, see <code><a href="#topic+n">n</a></code> for accessing
the sample size of a design
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(
  n1    = 25,
  c1f   = 0,
  c1e   = 2.5,
  n2    = 50,
  c2    = 1.96,
  order = 7L
)

c2(design, 2.2) # 1.96
c2(design, 3.0) # -Inf
c2(design, -1.0) # Inf

design &lt;- TwoStageDesign(
   n1    = 25,
   c1f   = 0,
   c1e   = 2.5,
   n2    = 50,
   c2    = 1.96,
   order = 7L
)

c2(design, 2.2) # 1.96
c2(design, 3.0) # -Inf
c2(design, -1.0) # Inf

</code></pre>

<hr>
<h2 id='ChiSquared-class'>Chi-Squared data distribution</h2><span id='topic+ChiSquared-class'></span><span id='topic+ChiSquared'></span><span id='topic+quantile+2CChiSquared-method'></span><span id='topic+simulate+2CChiSquared+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Implements a chi-squared distribution. The classes <code>Pearson2xk</code>
and <code>ZSquared</code> are subclasses, used in two different situations.
<code>Pearson2xK</code> is used when testing k groups for homogeneity in
response rates. The null hypothesis is
r<sub>1</sub>=...=r<sub>k</sub>, and the
alternative is that there exists a pair of groups with differing rates.
<code>ZSquared</code> implements the square of a normally distributed random variable
with mean <code class="reqn">\mu</code> and standard deviation <code class="reqn">\sigma^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChiSquared(df)

## S4 method for signature 'ChiSquared'
quantile(x, probs, n, theta, ...)

## S4 method for signature 'ChiSquared,numeric'
simulate(object, nsim, n, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ChiSquared-class_+3A_df">df</code></td>
<td>
<p>number of degrees of freedom</p>
</td></tr>
<tr><td><code id="ChiSquared-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="ChiSquared-class_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="ChiSquared-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="ChiSquared-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="ChiSquared-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="ChiSquared-class_+3A_object">object</code></td>
<td>
<p>object of class <code>ChiSquared</code></p>
</td></tr>
<tr><td><code id="ChiSquared-class_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="ChiSquared-class_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>see <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadist &lt;- ChiSquared(df=4)

</code></pre>

<hr>
<h2 id='composite'>Score Composition</h2><span id='topic+composite'></span><span id='topic+evaluate+2CCompositeScore+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p><code>composite</code> defines new composite scores by point-wise evaluation of
scores in any valid numerical expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>composite(expr, label = NA_character_)

## S4 method for signature 'CompositeScore,TwoStageDesign'
evaluate(s, design, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="composite_+3A_expr">expr</code></td>
<td>
<p>Expression (in curly brackets); must contain at least one score
variable; if multiple scores are used, they must either all be conditional
or unconditional. Currently, no non-score variables are supported</p>
</td></tr>
<tr><td><code id="composite_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="composite_+3A_s">s</code></td>
<td>
<p>object of class <code>CompositeScore</code></p>
</td></tr>
<tr><td><code id="composite_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="composite_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>CompositeConditionalScore</code> or
<code>CompositeUnconditionalScore</code> depending on the class of the scores used
in <code>expr</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+Scores">Scores</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ess   &lt;- ExpectedSampleSize(Normal(), PointMassPrior(.4, 1))
power &lt;- Power(Normal(), PointMassPrior(.4, 1))

# linear combination:
composite({ess - 50*power})

# control flow (e.g. for and while loops)
composite({
  res &lt;- 0
  for (i in 1:3) {
     res &lt;- res + ess
  }
  res
})

# functional composition
composite({log(ess)})
cp &lt;- ConditionalPower(Normal(), PointMassPrior(.4, 1))
composite({3*cp})

</code></pre>

<hr>
<h2 id='condition'>Condition a prior on an interval</h2><span id='topic+condition'></span><span id='topic+condition+2CContinuousPrior+2Cnumeric-method'></span><span id='topic+condition+2CPointMassPrior+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Restrict an object of class <code><a href="#topic+Prior">Prior</a></code> to a sub-interval and
re-normalize the PDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition(dist, interval, ...)

## S4 method for signature 'ContinuousPrior,numeric'
condition(dist, interval, ...)

## S4 method for signature 'PointMassPrior,numeric'
condition(dist, interval, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="condition_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="condition_+3A_interval">interval</code></td>
<td>
<p>length-two numeric vector giving the parameter interval to
condition on</p>
</td></tr>
<tr><td><code id="condition_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>conditional <code><a href="#topic+Prior">Prior</a></code> on given interval
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- condition(
    ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)),
    c(.3, .5)
)
bounds(tmp) # c(.3, .4)

tmp &lt;- condition(PointMassPrior(c(0, .5), c(.3, .7)), c(-1, .25))
expectation(tmp, identity) # 0

</code></pre>

<hr>
<h2 id='ConditionalPower-class'>(Conditional) Power of a Design</h2><span id='topic+ConditionalPower-class'></span><span id='topic+ConditionalPower'></span><span id='topic+Power'></span><span id='topic+evaluate+2CConditionalPower+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>This score evaluates P[X<sub>2</sub> > c2(design, X<sub>1</sub>) | X<sub>1</sub> = x<sub>1</sub>].
Note that the distribution of X<sub>2</sub> is the posterior predictive after
observing X<sub>1</sub> = x<sub>1</sub>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConditionalPower(dist, prior, label = "Pr[x2&gt;=c2(x1)|x1]")

Power(dist, prior, label = "Pr[x2&gt;=c2(x1)]")

## S4 method for signature 'ConditionalPower,TwoStageDesign'
evaluate(s, design, x1, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConditionalPower-class_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="ConditionalPower-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Scores">Scores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prior &lt;- PointMassPrior(.4, 1)
cp &lt;- ConditionalPower(Normal(), prior)
evaluate(
   cp,
   TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L),
   x1 = 1
)
# these two are equivalent:
expected(cp, Normal(), prior)
Power(Normal(), prior)

</code></pre>

<hr>
<h2 id='ConditionalSampleSize-class'>(Conditional) Sample Size of a Design</h2><span id='topic+ConditionalSampleSize-class'></span><span id='topic+ConditionalSampleSize'></span><span id='topic+ExpectedSampleSize'></span><span id='topic+ExpectedNumberOfEvents'></span><span id='topic+evaluate+2CConditionalSampleSize+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>This score simply evaluates <code>n(d, x1)</code> for a design <code>d</code> and the
first-stage outcome <code>x1</code>.
The data distribution and prior are only relevant when it is integrated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConditionalSampleSize(label = "n(x1)")

ExpectedSampleSize(dist, prior, label = "E[n(x1)]")

ExpectedNumberOfEvents(dist, prior, label = "E[n(x1)]")

## S4 method for signature 'ConditionalSampleSize,TwoStageDesign'
evaluate(s, design, x1, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConditionalSampleSize-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="ConditionalSampleSize-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Scores">Scores</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L)
prior  &lt;- PointMassPrior(.4, 1)

css   &lt;- ConditionalSampleSize()
evaluate(css, design, c(0, .5, 3))

ess   &lt;- ExpectedSampleSize(Normal(), prior)
ene &lt;- ExpectedNumberOfEvents(Survival(0.7), PointMassPrior(1.7, 1))

# those two are equivalent
evaluate(ess, design)
evaluate(expected(css, Normal(), prior), design)

</code></pre>

<hr>
<h2 id='Constraints'>Formulating Constraints</h2><span id='topic+Constraints'></span><span id='topic+evaluate+2CConstraint+2CTwoStageDesign-method'></span><span id='topic++3C+3D+2CConditionalScore+2Cnumeric-method'></span><span id='topic++3E+3D+2CConditionalScore+2Cnumeric-method'></span><span id='topic++3C+3D+2Cnumeric+2CConditionalScore-method'></span><span id='topic++3E+3D+2Cnumeric+2CConditionalScore-method'></span><span id='topic++3C+3D+2CConditionalScore+2CConditionalScore-method'></span><span id='topic++3E+3D+2CConditionalScore+2CConditionalScore-method'></span><span id='topic++3C+3D+2CUnconditionalScore+2Cnumeric-method'></span><span id='topic++3E+3D+2CUnconditionalScore+2Cnumeric-method'></span><span id='topic++3C+3D+2Cnumeric+2CUnconditionalScore-method'></span><span id='topic++3E+3D+2Cnumeric+2CUnconditionalScore-method'></span><span id='topic++3C+3D+2CUnconditionalScore+2CUnconditionalScore-method'></span><span id='topic++3E+3D+2CUnconditionalScore+2CUnconditionalScore-method'></span>

<h3>Description</h3>

<p>Conceptually, constraints work very similar to scores (any score can be put in
a constraint).
Currently,  constraints of the form 'score &lt;=/&gt;= x',
'x &lt;=/&gt;= score' and 'score &lt;=/&gt;= score' are admissible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Constraint,TwoStageDesign'
evaluate(s, design, optimization = FALSE, ...)

## S4 method for signature 'ConditionalScore,numeric'
e1 &lt;= e2

## S4 method for signature 'ConditionalScore,numeric'
e1 &gt;= e2

## S4 method for signature 'numeric,ConditionalScore'
e1 &lt;= e2

## S4 method for signature 'numeric,ConditionalScore'
e1 &gt;= e2

## S4 method for signature 'ConditionalScore,ConditionalScore'
e1 &lt;= e2

## S4 method for signature 'ConditionalScore,ConditionalScore'
e1 &gt;= e2

## S4 method for signature 'UnconditionalScore,numeric'
e1 &lt;= e2

## S4 method for signature 'UnconditionalScore,numeric'
e1 &gt;= e2

## S4 method for signature 'numeric,UnconditionalScore'
e1 &lt;= e2

## S4 method for signature 'numeric,UnconditionalScore'
e1 &gt;= e2

## S4 method for signature 'UnconditionalScore,UnconditionalScore'
e1 &lt;= e2

## S4 method for signature 'UnconditionalScore,UnconditionalScore'
e1 &gt;= e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Constraints_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="Constraints_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="Constraints_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="Constraints_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Constraints_+3A_e1">e1</code></td>
<td>
<p>left hand side (score or numeric)</p>
</td></tr>
<tr><td><code id="Constraints_+3A_e2">e2</code></td>
<td>
<p>right hand side (score or numeric)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>Constraint</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minimize">minimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- OneStageDesign(50, 1.96)

cp     &lt;- ConditionalPower(Normal(), PointMassPrior(0.4, 1))
pow    &lt;- Power(Normal(), PointMassPrior(0.4, 1))

# unconditional power constraint
constraint1 &lt;- pow &gt;= 0.8
evaluate(constraint1, design)

# conditional power constraint
constraint2 &lt;- cp  &gt;= 0.7
evaluate(constraint2, design, .5)
constraint3 &lt;- 0.7 &lt;= cp # same as constraint2
evaluate(constraint3, design, .5)

</code></pre>

<hr>
<h2 id='ContinuousPrior-class'>Continuous univariate prior distributions</h2><span id='topic+ContinuousPrior-class'></span><span id='topic+ContinuousPrior'></span>

<h3>Description</h3>

<p><code>ContinuousPrior</code> is a sub-class of <code><a href="#topic+Prior">Prior</a></code> implementing
a generic representation of continuous prior distributions over a compact
interval on the real line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ContinuousPrior(
  pdf,
  support,
  order = 10,
  label = NA_character_,
  tighten_support = FALSE,
  check_normalization = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ContinuousPrior-class_+3A_pdf">pdf</code></td>
<td>
<p>vectorized univariate PDF function</p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_support">support</code></td>
<td>
<p>numeric vector of length two with the bounds of
the compact interval on which the pdf is positive.</p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_order">order</code></td>
<td>
<p><code>integer</code>, integration order of the employed Gaussian quadrature
integration rule to evaluate scores. Automatically set to <code>length(n2_pivots)</code> if <br />
<code>length(n2_pivots) == length(c2_pivots) &gt; 1</code>, otherwise c2 and n2
are taken to be constant in stage-two and replicated to match the number of
pivots specified by <code>order</code></p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_tighten_support">tighten_support</code></td>
<td>
<p>logical indicating if the support should be tightened</p>
</td></tr>
<tr><td><code id="ContinuousPrior-class_+3A_check_normalization">check_normalization</code></td>
<td>
<p>logical indicating if it should be checked
that <code>pdf</code> defines a density.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>pdf</code></dt><dd><p>cf. parameter 'pdf'</p>
</dd>
<dt><code>support</code></dt><dd><p>cf. parameter 'support'</p>
</dd>
<dt><code>pivots</code></dt><dd><p>normalized pivots for integration rule (in [-1, 1])
the actual pivots are scaled to the support of the prior</p>
</dd>
<dt><code>weights</code></dt><dd><p>weights of of integration rule at <code>pivots</code> for
approximating integrals over <code>delta</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p>Discrete priors are supported via <code><a href="#topic+PointMassPrior">PointMassPrior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ContinuousPrior(function(x) 2*x, c(0, 1))

</code></pre>

<hr>
<h2 id='cumulative_distribution_function'>Cumulative distribution function</h2><span id='topic+cumulative_distribution_function'></span><span id='topic+cumulative_distribution_function+2CBinomial+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+cumulative_distribution_function+2CChiSquared+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+cumulative_distribution_function+2CNestedModels+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+cumulative_distribution_function+2CNormal+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+cumulative_distribution_function+2CStudent+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+cumulative_distribution_function+2CSurvival+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>cumulative_distribution_function</code> evaluates the cumulative distribution
function of a specific distribution <code>dist</code> at a point <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative_distribution_function(dist, x, n, theta, ...)

## S4 method for signature 'Binomial,numeric,numeric,numeric'
cumulative_distribution_function(dist, x, n, theta, ...)

## S4 method for signature 'ChiSquared,numeric,numeric,numeric'
cumulative_distribution_function(dist, x, n, theta, ...)

## S4 method for signature 'NestedModels,numeric,numeric,numeric'
cumulative_distribution_function(dist, x, n, theta, ...)

## S4 method for signature 'Normal,numeric,numeric,numeric'
cumulative_distribution_function(dist, x, n, theta, ...)

## S4 method for signature 'Student,numeric,numeric,numeric'
cumulative_distribution_function(dist, x, n, theta, ...)

## S4 method for signature 'Survival,numeric,numeric,numeric'
cumulative_distribution_function(dist, x, n, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumulative_distribution_function_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="cumulative_distribution_function_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="cumulative_distribution_function_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="cumulative_distribution_function_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="cumulative_distribution_function_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the distribution is <code><a href="#topic+Binomial">Binomial</a></code>,
theta denotes the rate difference between
intervention and control group.
Then, the mean is assumed to be
&radic; n  theta.
</p>
<p>If the distribution is <code><a href="#topic+Normal">Normal</a></code>, then
the mean is assumed to be
&radic; n  theta.
</p>


<h3>Value</h3>

<p>value of the cumulative distribution function at point <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cumulative_distribution_function(Binomial(.1, TRUE), 1, 50, .3)

cumulative_distribution_function(Pearson2xK(3), 1, 30, get_tau_Pearson2xK(c(0.3,0.4,0.7,0.2)))
cumulative_distribution_function(ZSquared(TRUE), 1, 35, get_tau_ZSquared(0.4, 1))


cumulative_distribution_function(ANOVA(3), 1, 30, get_tau_ANOVA(c(0.3, 0.4, 0.7, 0.2)))

cumulative_distribution_function(Normal(), 1, 50, .3)

cumulative_distribution_function(Student(two_armed = FALSE), .75, 50, .9)

cumulative_distribution_function(Survival(0.6,TRUE),0.75,50,0.9)

</code></pre>

<hr>
<h2 id='DataDistribution-class'>Data distributions</h2><span id='topic+DataDistribution-class'></span><span id='topic+DataDistribution'></span>

<h3>Description</h3>

<p><code>DataDistribution</code> is an abstract class used to represent the distribution
of a sufficient statistic <code>x</code> given a sample size <code>n</code> and a
single parameter value <code>theta</code>.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DataDistribution-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="DataDistribution-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="DataDistribution-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="DataDistribution-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This abstraction layer allows the representation of t-distributions
(unknown variance), normal distribution (known variance), and normal
approximation of a binary endpoint.
Currently, the two implemented versions are <code><a href="#topic+Normal-class">Normal-class</a></code> and
<code><a href="#topic+Binomial-class">Binomial-class</a></code>.
</p>
<p>The logical option <code>two_armed</code> allows to decide whether a one-arm or
a two-arm (the default) design should be computed. In the case of a two-arm
design all sample sizes are per group.
</p>


<h3>Slots</h3>


<dl>
<dt><code>two_armed</code></dt><dd><p>Logical that indicates if a two-arm design is assumed.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>normaldist   &lt;- Normal(two_armed = FALSE)
binomialdist &lt;- Binomial(rate_control = .25, two_armed = TRUE)

</code></pre>

<hr>
<h2 id='expectation'>Expected value of a function</h2><span id='topic+expectation'></span><span id='topic+expectation+2CContinuousPrior+2Cfunction-method'></span><span id='topic+expectation+2CPointMassPrior+2Cfunction-method'></span>

<h3>Description</h3>

<p>Computes the expected value of a vectorized, univariate function <code>f</code>
with respect to a distribution <code>dist</code>.
I.e., E[f(X)].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectation(dist, f, ...)

## S4 method for signature 'ContinuousPrior,function'
expectation(dist, f, ...)

## S4 method for signature 'PointMassPrior,function'
expectation(dist, f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectation_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="expectation_+3A_f">f</code></td>
<td>
<p>a univariate function, must be vectorized</p>
</td></tr>
<tr><td><code id="expectation_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>, expected value of <code>f</code> with respect to <code>dist</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expectation(
    ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)),
    identity
)
# &gt; 0.3

expectation(PointMassPrior(c(0, .5), c(.3, .7)), identity)
# &gt; .35

</code></pre>

<hr>
<h2 id='get_initial_design'>Initial design</h2><span id='topic+get_initial_design'></span>

<h3>Description</h3>

<p>The optimization method <code><a href="#topic+minimize">minimize</a></code> requires an initial
design for optimization.
This function provides a variety of possibilities to hand-craft designs that
fulfill type I error and type II error constraints which may be used as initial designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_initial_design(
  theta,
  alpha,
  beta,
  type_design = c("two-stage", "group-sequential", "one-stage"),
  type_c2 = c("linear_decreasing", "constant"),
  type_n2 = c("optimal", "constant", "linear_decreasing", "linear_increasing"),
  dist = Normal(),
  cf,
  ce,
  info_ratio = 0.5,
  slope,
  weight = sqrt(info_ratio),
  order = 7L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_initial_design_+3A_theta">theta</code></td>
<td>
<p>the alternative effect size in the normal case, the
rate difference under the alternative in the binomial case</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_alpha">alpha</code></td>
<td>
<p>maximal type I error rate</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_beta">beta</code></td>
<td>
<p>maximal type II error rate</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_type_design">type_design</code></td>
<td>
<p>type of design</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_type_c2">type_c2</code></td>
<td>
<p>either linear-decreasing c2-function according to inverse normal
combination test or constant c2</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_type_n2">type_n2</code></td>
<td>
<p>design of n2-function</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_dist">dist</code></td>
<td>
<p>distribution of the test statistic</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_cf">cf</code></td>
<td>
<p>first-stage futility boundary</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_ce">ce</code></td>
<td>
<p>first-stage efficacy boundary. Note that specifying this boundary
implies that the type I error constraint might not be fulfilled anymore</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_info_ratio">info_ratio</code></td>
<td>
<p>the ratio between first and second stage sample size</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_slope">slope</code></td>
<td>
<p>slope of n2 function</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_weight">weight</code></td>
<td>
<p>weight of first stage test statistics in inverse normal combination test</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_order">order</code></td>
<td>
<p>desired integration order</p>
</td></tr>
<tr><td><code id="get_initial_design_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution of the test statistic is specified by <code>dist</code>.
The default assumes a two-armed z-test.
The first stage efficacy boundary and the <code class="reqn">c2</code> boundary are chosen as Pocock-boundaries, so either <code class="reqn">c_e=c_2</code>
if <code class="reqn">c_2</code> is constant or <code class="reqn">c_e=c</code>, where the null hypothesis is rejected if <code class="reqn">w_1 Z_1+w_2 Z_2&gt;c</code>.
By specifying <code class="reqn">ce</code>, it's clear that the boundaries are not Pocock-boundaries anymore, so the type I error
constraint may not be fulfilled.
IMPORTANT: When using the t-distribution or ANOVA, the design does probably
not keep the type I and type II error, only approximate designs are returned.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init &lt;- get_initial_design(
   theta = 0.3,
   alpha = 0.025,
   beta  = 0.2,
   type_design="two-stage",
   type_c2="linear_decreasing",
   type_n2="linear_increasing",
   dist=Normal(),
   cf=0.7,
   info_ratio=0.5,
   slope=23,
   weight = 1/sqrt(3)
)

</code></pre>

<hr>
<h2 id='get_lower_boundary_design'>Boundary designs</h2><span id='topic+get_lower_boundary_design'></span><span id='topic+get_upper_boundary_design'></span><span id='topic+get_lower_boundary_design+2COneStageDesign-method'></span><span id='topic+get_lower_boundary_design+2CGroupSequentialDesign-method'></span><span id='topic+get_lower_boundary_design+2CTwoStageDesign-method'></span><span id='topic+get_upper_boundary_design+2COneStageDesign-method'></span><span id='topic+get_upper_boundary_design+2CGroupSequentialDesign-method'></span><span id='topic+get_upper_boundary_design+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>The optimization method <code><a href="#topic+minimize">minimize</a></code> is based on the package
<code>nloptr</code>. This requires upper and lower boundaries for optimization.
Such boundaries can be computed via <code>lower_boundary_design</code>
respectively <code>upper_boundary_design</code>.
They are implemented by default in <code><a href="#topic+minimize">minimize</a></code>.
Note that <code><a href="#topic+minimize">minimize</a></code> allows the user to define its own
boundary designs, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lower_boundary_design(initial_design, ...)

get_upper_boundary_design(initial_design, ...)

## S4 method for signature 'OneStageDesign'
get_lower_boundary_design(initial_design, n1 = 1, c1_buffer = 2, ...)

## S4 method for signature 'GroupSequentialDesign'
get_lower_boundary_design(
  initial_design,
  n1 = 1,
  n2_pivots = 1,
  c1_buffer = 2,
  c2_buffer = 2,
  ...
)

## S4 method for signature 'TwoStageDesign'
get_lower_boundary_design(
  initial_design,
  n1 = 1,
  n2_pivots = 1,
  c1_buffer = 2,
  c2_buffer = 2,
  ...
)

## S4 method for signature 'OneStageDesign'
get_upper_boundary_design(
  initial_design,
  n1 = 5 * initial_design@n1,
  c1_buffer = 2,
  ...
)

## S4 method for signature 'GroupSequentialDesign'
get_upper_boundary_design(
  initial_design,
  n1 = 5 * initial_design@n1,
  n2_pivots = 5 * initial_design@n2_pivots,
  c1_buffer = 2,
  c2_buffer = 2,
  ...
)

## S4 method for signature 'TwoStageDesign'
get_upper_boundary_design(
  initial_design,
  n1 = 5 * initial_design@n1,
  n2_pivots = 5 * initial_design@n2_pivots,
  c1_buffer = 2,
  c2_buffer = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_lower_boundary_design_+3A_initial_design">initial_design</code></td>
<td>
<p>The initial design</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_...">...</code></td>
<td>
<p>optional arguments
</p>
<p>The values <code>c1f</code> and <code>c1e</code> from the initial design are shifted
to <code>c1f - c1_buffer</code> and <code>c1e - c1_buffer</code> in
<code>get_lower_boundary_design</code>, respectively, to <br />
<code>c1f + c1_buffer</code> and <code>c1e + c1_buffer</code> in
<code>get_upper_boundary_design</code>.
This is handled analogously with <code>c2_pivots</code> and <code>c2_buffer</code>.</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_n1">n1</code></td>
<td>
<p>bound for the first-stage sample size n1</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_c1_buffer">c1_buffer</code></td>
<td>
<p>shift of the early-stopping boundaries from the initial ones</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_n2_pivots">n2_pivots</code></td>
<td>
<p>bound for the second-stage sample size n2</p>
</td></tr>
<tr><td><code id="get_lower_boundary_design_+3A_c2_buffer">c2_buffer</code></td>
<td>
<p>shift of the final decision boundary from the initial one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initial_design &lt;- TwoStageDesign(
  n1    = 25,
  c1f   = 0,
  c1e   = 2.5,
  n2    = 50,
  c2    = 1.96,
  order = 7L
  )
get_lower_boundary_design(initial_design)

</code></pre>

<hr>
<h2 id='GroupSequentialDesign-class'>Group-sequential two-stage designs</h2><span id='topic+GroupSequentialDesign-class'></span><span id='topic+GroupSequentialDesign'></span><span id='topic+GroupSequentialDesign+2Cnumeric-method'></span><span id='topic+TwoStageDesign+2CGroupSequentialDesign-method'></span><span id='topic+TwoStageDesign+2CGroupSequentialDesignSurvival-method'></span>

<h3>Description</h3>

<p>Group-sequential designs are a sub-class of the <code>TwoStageDesign</code>
class with constant stage-two sample size.
See <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code> for slot details.
Any group-sequential design can be converted to a fully flexible
<code>TwoStageDesign</code> (see examples section).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupSequentialDesign(n1, ...)

## S4 method for signature 'numeric'
GroupSequentialDesign(
  n1,
  c1f,
  c1e,
  n2_pivots,
  c2_pivots,
  order = NULL,
  event_rate,
  ...
)

## S4 method for signature 'GroupSequentialDesign'
TwoStageDesign(n1, event_rate, ...)

## S4 method for signature 'GroupSequentialDesignSurvival'
TwoStageDesign(n1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroupSequentialDesign-class_+3A_n1">n1</code></td>
<td>
<p>stage one sample size or <code>GroupSequentialDesign</code> object to convert
(overloaded from <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>)</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_c1f">c1f</code></td>
<td>
<p>early futility stopping boundary</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_c1e">c1e</code></td>
<td>
<p>early efficacy stopping boundary</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_n2_pivots">n2_pivots</code></td>
<td>
<p>numeric of length one, stage-two sample size</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_c2_pivots">c2_pivots</code></td>
<td>
<p>numeric vector, stage-two critical values on the integration
pivot points</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_order">order</code></td>
<td>
<p>of the Gaussian quadrature rule to use for integration, set to
length(c2_pivots) if NULL, otherwise first value of c2_pivots is repeated
'order'-times.</p>
</td></tr>
<tr><td><code id="GroupSequentialDesign-class_+3A_event_rate">event_rate</code></td>
<td>
<p>probability that a subject in either group will eventually have an event,
only needs to be specified for time-to-event endpoints.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code> for superclass and inherited methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- GroupSequentialDesign(25, 0, 2, 25, c(1, 1.5, 2.5))
summary(design)

design_survival &lt;- GroupSequentialDesign(25, 0, 2, 25, c(1, 1.5, 2.5), event_rate = 0.7)

TwoStageDesign(design)

TwoStageDesign(design_survival)

</code></pre>

<hr>
<h2 id='GroupSequentialDesignSurvival-class'>Group-sequential two-stage designs for time-to-event-endpoints</h2><span id='topic+GroupSequentialDesignSurvival-class'></span>

<h3>Description</h3>

<p>Group-sequential designs for time-to-event-endpoints are a subclass of both
<code>TwoStageDesignSurvival</code> and <code>GroupSequentialDesign</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesignSurvival-class">TwoStageDesignSurvival-class</a></code> and <code><a href="#topic+GroupSequentialDesign-class">GroupSequentialDesign-class</a></code>
for superclasses and inherited methods.
</p>

<hr>
<h2 id='make_tunable'>Fix parameters during optimization</h2><span id='topic+make_tunable'></span><span id='topic+make_tunable+2CTwoStageDesign-method'></span><span id='topic+make_fixed'></span><span id='topic+make_fixed+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>The methods <code>make_fixed</code> and <code>make_tunable</code> can be used to modify
the 'tunability' status of parameters in a <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
object.
Tunable parameters are optimized over, non-tunable ('fixed') parameters are
considered given and not altered during optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tunable(x, ...)

## S4 method for signature 'TwoStageDesign'
make_tunable(x, ...)

make_fixed(x, ...)

## S4 method for signature 'TwoStageDesign'
make_fixed(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_tunable_+3A_x">x</code></td>
<td>
<p><code>TwoStageDesign</code> object</p>
</td></tr>
<tr><td><code id="make_tunable_+3A_...">...</code></td>
<td>
<p>unquoted names of slots for which the tunability status should be
changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated object of class <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>, <code><a href="#topic+tunable_parameters">tunable_parameters</a></code> for
converting tunable parameters of a design object to a numeric vector (and back),
and <code><a href="#topic+minimize">minimize</a></code> for the actual minimzation procedure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(25, 0, 2, 25, 2, order = 5)
# default: all parameters are tunable (except integration pivots,
# weights and tunability status itself)
design@tunable

# make n1 and the pivots of n2 fixed (not changed during optimization)
design &lt;- make_fixed(design, n1, n2_pivots)
design@tunable

# make them tunable again
design &lt;- make_tunable(design, n1, n2_pivots)
design@tunable

</code></pre>

<hr>
<h2 id='MaximumSampleSize-class'>Maximum Sample Size of a Design</h2><span id='topic+MaximumSampleSize-class'></span><span id='topic+MaximumSampleSize'></span><span id='topic+evaluate+2CMaximumSampleSize+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>This score evaluates <code>max(n(d))</code> for a design <code>d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaximumSampleSize(label = "max(n(x1))")

## S4 method for signature 'MaximumSampleSize,TwoStageDesign'
evaluate(s, design, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaximumSampleSize-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="MaximumSampleSize-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="MaximumSampleSize-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="MaximumSampleSize-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="MaximumSampleSize-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Scores">Scores</a> for general scores and <a href="#topic+ConditionalSampleSize">ConditionalSampleSize</a>
for evaluating the sample size point-wise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L)
mss    &lt;- MaximumSampleSize()
evaluate(mss, design)

</code></pre>

<hr>
<h2 id='minimize'>Find optimal two-stage design by constraint minimization</h2><span id='topic+minimize'></span>

<h3>Description</h3>

<p><code>minimize</code> takes an unconditional score and
a constraint set (or no constraint) and solves the corresponding
minimization problem using
<a href="https://cran.r-project.org/package=nloptr"><code>nloptr</code></a>
(using COBYLA by default).
An initial design has to be defined. It is also possible to define
lower- and upper-boundary designs. If this is not done, the boundaries are
determined automatically heuristically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimize(
  objective,
  subject_to,
  initial_design,
  lower_boundary_design = get_lower_boundary_design(initial_design),
  upper_boundary_design = get_upper_boundary_design(initial_design),
  c2_decreasing = FALSE,
  check_constraints = TRUE,
  opts = list(algorithm = "NLOPT_LN_COBYLA", xtol_rel = 1e-05, maxeval = 10000),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minimize_+3A_objective">objective</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="minimize_+3A_subject_to">subject_to</code></td>
<td>
<p>constraint collection</p>
</td></tr>
<tr><td><code id="minimize_+3A_initial_design">initial_design</code></td>
<td>
<p>initial guess (x0 for nloptr)</p>
</td></tr>
<tr><td><code id="minimize_+3A_lower_boundary_design">lower_boundary_design</code></td>
<td>
<p>design specifying the lower boundary.</p>
</td></tr>
<tr><td><code id="minimize_+3A_upper_boundary_design">upper_boundary_design</code></td>
<td>
<p>design specifying the upper boundary</p>
</td></tr>
<tr><td><code id="minimize_+3A_c2_decreasing">c2_decreasing</code></td>
<td>
<p>if TRUE, the c2_pivots are forced to be monotonically decreasing</p>
</td></tr>
<tr><td><code id="minimize_+3A_check_constraints">check_constraints</code></td>
<td>
<p>if TRUE, it is checked if constrains are fulfilled</p>
</td></tr>
<tr><td><code id="minimize_+3A_opts">opts</code></td>
<td>
<p>options list passed to nloptr</p>
</td></tr>
<tr><td><code id="minimize_+3A_...">...</code></td>
<td>
<p>further optional arguments passed to <code><a href="nloptr.html#topic+nloptr">nloptr</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements:
</p>
<table role = "presentation">
<tr><td><code>design</code></td>
<td>
<p> The resulting optimal design</p>
</td></tr>
<tr><td><code>nloptr_return</code></td>
<td>
<p> Output of the corresponding nloptr call</p>
</td></tr>
<tr><td><code>call_args</code></td>
<td>
<p> The arguments given to the optimization call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Define Type one error rate
toer &lt;- Power(Normal(), PointMassPrior(0.0, 1))

# Define Power at delta = 0.4
pow &lt;- Power(Normal(), PointMassPrior(0.4, 1))

# Define expected sample size at delta = 0.4
ess &lt;- ExpectedSampleSize(Normal(), PointMassPrior(0.4, 1))

# Compute design minimizing ess subject to power and toer constraints

minimize(

   ess,

   subject_to(
      toer &lt;= 0.025,
      pow  &gt;= 0.9
   ),

   initial_design = TwoStageDesign(50, .0, 2.0, 60.0, 2.0, 5L)

)


</code></pre>

<hr>
<h2 id='n1'>Query sample size of a design</h2><span id='topic+n1'></span><span id='topic+n1+2CTwoStageDesign-method'></span><span id='topic+n2'></span><span id='topic+n2+2CTwoStageDesign+2Cnumeric-method'></span><span id='topic+n'></span><span id='topic+n+2CTwoStageDesign+2Cnumeric-method'></span><span id='topic+n2+2COneStageDesign+2Cnumeric-method'></span><span id='topic+n2+2CGroupSequentialDesign+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods to access the stage-one, stage-two, or overall sample size of a
<code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
<code>n1</code> returns the first-stage sample size of a design,
<code>n2</code> the stage-two sample size conditional on the stage-one test
statistic and <code>n</code> the overall sample size <code>n1 + n2</code>.
Internally, objects of the class <code>TwoStageDesign</code> allow non-natural,
real sample sizes to allow smooth optimization (cf. <code><a href="#topic+minimize">minimize</a></code> for
details).
The optional argument <code>round</code> allows to switch between the internal
real representation and a rounded version (rounding to the next positive
integer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n1(d, ...)

## S4 method for signature 'TwoStageDesign'
n1(d, round = TRUE, ...)

n2(d, x1, ...)

## S4 method for signature 'TwoStageDesign,numeric'
n2(d, x1, round = TRUE, ...)

n(d, x1, ...)

## S4 method for signature 'TwoStageDesign,numeric'
n(d, x1, round = TRUE, ...)

## S4 method for signature 'OneStageDesign,numeric'
n2(d, x1, ...)

## S4 method for signature 'GroupSequentialDesign,numeric'
n2(d, x1, round = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n1_+3A_d">d</code></td>
<td>
<p>design</p>
</td></tr>
<tr><td><code id="n1_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="n1_+3A_round">round</code></td>
<td>
<p><code>logical</code> should sample sizes be rounded to next integer?</p>
</td></tr>
<tr><td><code id="n1_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sample size value of design <code>d</code> at point <code>x1</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>, see <code><a href="#topic+c2">c2</a></code> for accessing
the critical values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(
   n1    = 25,
   c1f   = 0,
   c1e   = 2.5,
   n2    = 50,
   c2    = 1.96,
   order = 7L
)

n1(design) # 25
design@n1 # 25

n(design, x1 = 2.2) # 75


</code></pre>

<hr>
<h2 id='N1-class'>Regularize n1</h2><span id='topic+N1-class'></span><span id='topic+N1'></span><span id='topic+evaluate+2CN1+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p><code>N1</code> is a class that computes the <code>n1</code> value of a design.
This can be used as a score in <code><a href="#topic+minimize">minimize</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N1(label = NA_character_)

## S4 method for signature 'N1,TwoStageDesign'
evaluate(s, design, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="N1-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="N1-class_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="N1-class_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="N1-class_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="N1-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+N1">N1</a></code>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+AverageN2">AverageN2</a></code> for a regularization of
the second-stage sample size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1_score &lt;- N1()

evaluate(
   N1(),
   TwoStageDesign(70, 0, 2, rep(60, 6), rep(1.7, 6))
) # 70

</code></pre>

<hr>
<h2 id='NestedModels-class'>F-Distribution</h2><span id='topic+NestedModels-class'></span><span id='topic+NestedModels'></span><span id='topic+quantile+2CNestedModels-method'></span><span id='topic+simulate+2CNestedModels+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Implements the F-distribution used for an ANOVA or for the comparison of the fit of two
nested regression models. In both cases, the test statistic follows a F-distribution.
<code>NestedModel</code> is used to compare the fit of two regression models, where one model contains
the independent variables of the smaller model as a subset. Then, one can use ANOVA to determine
whether more variance can be explained by adding more independent variables.
In the class <code>ANOVA</code>, the number of independent variables of the smaller model is set to <code class="reqn">1</code>
in order to match the degrees of freedom and we obtain a one-way ANOVA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NestedModels(p_inner, p_outer)

## S4 method for signature 'NestedModels'
quantile(x, probs, n, theta, ...)

## S4 method for signature 'NestedModels,numeric'
simulate(object, nsim, n, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NestedModels-class_+3A_p_inner">p_inner</code></td>
<td>
<p>number of independent variables in smaller model</p>
</td></tr>
<tr><td><code id="NestedModels-class_+3A_p_outer">p_outer</code></td>
<td>
<p>number of independent variables in bigger model</p>
</td></tr>
<tr><td><code id="NestedModels-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="NestedModels-class_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="NestedModels-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="NestedModels-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="NestedModels-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="NestedModels-class_+3A_object">object</code></td>
<td>
<p>object of class <code>NestedModels</code></p>
</td></tr>
<tr><td><code id="NestedModels-class_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="NestedModels-class_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>p_inner</code></dt><dd><p>number of parameters in smaller model</p>
</dd>
<dt><code>p_outer</code></dt><dd><p>number of parameters in bigger model</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively. Use <code><a href="#topic+ANOVA">ANOVA</a></code> for detailed information
of ANOVA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- NestedModels(2, 4)

</code></pre>

<hr>
<h2 id='Normal-class'>Normal data distribution</h2><span id='topic+Normal-class'></span><span id='topic+Normal'></span><span id='topic+quantile+2CNormal-method'></span><span id='topic+simulate+2CNormal+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Implements a normal data distribution for z-values given an observed z-value
and stage size.
Standard deviation is 1 and mean &theta; &radic;n where
&theta; is the standardized effect size.
The option <code>two_armed</code> can be set to decide whether a one-arm or a
two-arm design should be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normal(two_armed = TRUE)

## S4 method for signature 'Normal'
quantile(x, probs, n, theta, ...)

## S4 method for signature 'Normal,numeric'
simulate(object, nsim, n, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Normal-class_+3A_two_armed">two_armed</code></td>
<td>
<p>logical indicating if a two-armed trial is regarded</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Normal</code></p>
</td></tr>
<tr><td><code id="Normal-class_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="Normal-class_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+DataDistribution-class">DataDistribution-class</a></code> for more details.
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadist &lt;- Normal(two_armed = TRUE)

</code></pre>

<hr>
<h2 id='OneStageDesign-class'>One-stage designs</h2><span id='topic+OneStageDesign-class'></span><span id='topic+OneStageDesign'></span><span id='topic+OneStageDesign+2Cnumeric-method'></span><span id='topic+TwoStageDesign+2COneStageDesign-method'></span><span id='topic+TwoStageDesign+2COneStageDesignSurvival-method'></span><span id='topic+plot+2COneStageDesign-method'></span>

<h3>Description</h3>

<p><code>OneStageDesign</code> implements a one-stage design as special case of
a two-stage design, i.e. as sub-class of <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
This is possible by defining n<sub>2</sub> = 0,
c = c<sub>1</sub><sup>f</sup> = c<sub>1</sub><sup>e</sup>,
c<sub>2</sub>(x<sub>1</sub>) = ifelse(x<sub>1</sub> < c, Inf, -Inf).
No integration pivots etc are required (set to <code>NaN</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OneStageDesign(n, ...)

## S4 method for signature 'numeric'
OneStageDesign(n, c, event_rate)

## S4 method for signature 'OneStageDesign'
TwoStageDesign(n1, event_rate, order = 5L, eps = 0.01, ...)

## S4 method for signature 'OneStageDesignSurvival'
TwoStageDesign(n1, order = 5L, eps = 0.01, ...)

## S4 method for signature 'OneStageDesign'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OneStageDesign-class_+3A_n">n</code></td>
<td>
<p>sample size (stage-one sample size)</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_c">c</code></td>
<td>
<p>rejection boundary (c = c<sub>1</sub><sup>f</sup> = c<sub>1</sub><sup>e</sup>)</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_event_rate">event_rate</code></td>
<td>
<p>probability that a subject in either group will eventually have an event,
only needs to be specified for time-to-event endpoints.</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_n1">n1</code></td>
<td>
<p><code>OneStageDesign</code> object to convert, overloaded from
<code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code></p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_order">order</code></td>
<td>
<p>integer &gt;= 2, default is 5; order of Gaussian quadrature
integration rule to use for new TwoStageDesign.</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_eps">eps</code></td>
<td>
<p>numeric &gt; 0, default = .01; the single critical value c must be
split in a continuation interval [c1f, c1e]; this is given by c +/- eps.</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_x">x</code></td>
<td>
<p>design to plot</p>
</td></tr>
<tr><td><code id="OneStageDesign-class_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the default <code><a href="#topic+plot+2CTwoStageDesign-method">plot,TwoStageDesign-method</a></code> method
is not supported for <code>OneStageDesign</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>, <code><a href="#topic+GroupSequentialDesign-class">GroupSequentialDesign-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- OneStageDesign(30, 1.96)
summary(design)
design_twostage &lt;- TwoStageDesign(design)
summary(design_twostage)
design_survival &lt;- OneStageDesign(30, 1.96, 0.7)

TwoStageDesign(design_survival)
</code></pre>

<hr>
<h2 id='OneStageDesignSurvival-class'>One-stage designs for time-to-event endpoints</h2><span id='topic+OneStageDesignSurvival-class'></span>

<h3>Description</h3>

<p><code>OneStageDesignSurvival</code> is a subclass of both <code>OneStageDesign</code> and
<code>TwoStageDesignSurvival</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesignSurvival-class">TwoStageDesignSurvival-class</a></code> and <code><a href="#topic+OneStageDesign-class">OneStageDesign-class</a></code>
for superclasses and inherited methods.
</p>

<hr>
<h2 id='Pearson2xK-class'>Pearson's chi-squared test for contingency tables</h2><span id='topic+Pearson2xK-class'></span><span id='topic+Pearson2xK'></span><span id='topic+get_tau_Pearson2xK'></span>

<h3>Description</h3>

<p>When we test for homogeneity of rates in a k-armed trial with binary endpoints,
the test statistic is chi-squared distributed with <code class="reqn">k-1</code> degrees of
freedom under the null. Under the alternative, the statistic is chi-squared
distributed with a non-centrality parameter <code class="reqn">\lambda</code>.
The function <code>get_tau_Pearson2xk</code> then computes <code class="reqn">\tau</code>, such that
<code class="reqn">\lambda</code> is given as <code class="reqn">n \cdot \tau</code>, where <code class="reqn">n</code> is the number of
subjects per group. In <code>adoptr</code>, <code class="reqn">\tau</code> is used in the same way as <code class="reqn">\theta</code>
in the case of the normally distributed test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pearson2xK(n_groups)

get_tau_Pearson2xK(p_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pearson2xK-class_+3A_n_groups">n_groups</code></td>
<td>
<p>number of groups considered for testing procedure</p>
</td></tr>
<tr><td><code id="Pearson2xK-class_+3A_p_vector">p_vector</code></td>
<td>
<p>vector denoting the event rates per group</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>pearson &lt;- Pearson2xK(3)


H1 &lt;- PointMassPrior(get_tau_Pearson2xK(c(.3, .25, .4)), 1)

</code></pre>

<hr>
<h2 id='plot+2CTwoStageDesign-method'>Plot <code>TwoStageDesign</code> with optional set of conditional scores</h2><span id='topic+plot+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>This method allows to plot the stage-two sample size and decision boundary
functions of a chosen design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TwoStageDesign'
plot(x, y = NULL, ..., rounded = TRUE, k = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_x">x</code></td>
<td>
<p>design to plot</p>
</td></tr>
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_...">...</code></td>
<td>
<p>further named <code>ConditinonalScores</code> to plot for the design
and/or further graphic parameters</p>
</td></tr>
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_rounded">rounded</code></td>
<td>
<p>should n-values be rounded?</p>
</td></tr>
<tr><td><code id="plot+2B2CTwoStageDesign-method_+3A_k">k</code></td>
<td>
<p>number of points to use for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code> and
user-defined elements of the class <code><a href="#topic+Scores">ConditionalScore</a></code>.
</p>


<h3>Value</h3>

<p>a plot of the two-stage design
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(50, 0, 2, 50, 2, 5)
cp     &lt;- ConditionalPower(dist = Normal(), prior = PointMassPrior(.4, 1))
plot(design, "Conditional Power" = cp, cex.axis = 2)

</code></pre>

<hr>
<h2 id='PointMassPrior-class'>Univariate discrete point mass priors</h2><span id='topic+PointMassPrior-class'></span><span id='topic+PointMassPrior'></span>

<h3>Description</h3>

<p><code>PointMassPrior</code> is a sub-class of <code><a href="#topic+Prior-class">Prior</a></code>
representing a univariate prior over a discrete set of points with positive
probability mass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PointMassPrior(theta, mass, label = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PointMassPrior-class_+3A_theta">theta</code></td>
<td>
<p>numeric vector of pivot points with positive prior mass</p>
</td></tr>
<tr><td><code id="PointMassPrior-class_+3A_mass">mass</code></td>
<td>
<p>numeric vector of probability masses at the pivot points
(must sum to 1)</p>
</td></tr>
<tr><td><code id="PointMassPrior-class_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>PointMassPrior</code>, <code>theta</code> is
automatically sorted in ascending order
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code></dt><dd><p>cf. parameter 'theta'</p>
</dd>
<dt><code>mass</code></dt><dd><p>cf. parameter 'mass'</p>
</dd>
</dl>


<h3>See Also</h3>

<p>To represent continuous prior distributions use <code><a href="#topic+ContinuousPrior">ContinuousPrior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PointMassPrior(c(0, .5), c(.3, .7))

</code></pre>

<hr>
<h2 id='posterior'>Compute posterior distribution</h2><span id='topic+posterior'></span><span id='topic+posterior+2CDataDistribution+2CContinuousPrior+2Cnumeric-method'></span><span id='topic+posterior+2CDataDistribution+2CPointMassPrior+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Return posterior distribution given observing stage-one outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,ContinuousPrior,numeric'
posterior(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,PointMassPrior,numeric'
posterior(dist, prior, x1, n1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="posterior_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="posterior_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="posterior_+3A_n1">n1</code></td>
<td>
<p>stage-one sample size</p>
</td></tr>
<tr><td><code id="posterior_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="#topic+Prior">Prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4))
posterior(Normal(), tmp, 2, 20)

posterior(Normal(), PointMassPrior(0, 1), 2, 20)

</code></pre>

<hr>
<h2 id='predictive_cdf'>Predictive CDF</h2><span id='topic+predictive_cdf'></span><span id='topic+predictive_cdf+2CDataDistribution+2CContinuousPrior+2Cnumeric-method'></span><span id='topic+predictive_cdf+2CDataDistribution+2CPointMassPrior+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>predictive_cdf()</code> evaluates the predictive CDF of the model specified
by a <code><a href="#topic+DataDistribution">DataDistribution</a></code> <code>dist</code> and
<code><a href="#topic+Prior">Prior</a></code> at the given stage-one outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive_cdf(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,ContinuousPrior,numeric'
predictive_cdf(
  dist,
  prior,
  x1,
  n1,
  k = 10 * (prior@support[2] - prior@support[1]) + 1,
  ...
)

## S4 method for signature 'DataDistribution,PointMassPrior,numeric'
predictive_cdf(dist, prior, x1, n1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictive_cdf_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_n1">n1</code></td>
<td>
<p>stage-one sample size</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="predictive_cdf_+3A_k">k</code></td>
<td>
<p>number of pivots for crude integral approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>, value of the predictive CDF
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4))
predictive_cdf(Normal(), tmp, 2, 20)

predictive_cdf(Normal(), PointMassPrior(.0, 1), 0, 20) # .5

</code></pre>

<hr>
<h2 id='predictive_pdf'>Predictive PDF</h2><span id='topic+predictive_pdf'></span><span id='topic+predictive_pdf+2CDataDistribution+2CContinuousPrior+2Cnumeric-method'></span><span id='topic+predictive_pdf+2CDataDistribution+2CPointMassPrior+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>predictive_pdf()</code> evaluates the predictive PDF of the model specified
by a <code><a href="#topic+DataDistribution">DataDistribution</a></code> <code>dist</code> and
<code><a href="#topic+Prior">Prior</a></code> at the given stage-one outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive_pdf(dist, prior, x1, n1, ...)

## S4 method for signature 'DataDistribution,ContinuousPrior,numeric'
predictive_pdf(
  dist,
  prior,
  x1,
  n1,
  k = 10 * (prior@support[2] - prior@support[1]) + 1,
  ...
)

## S4 method for signature 'DataDistribution,PointMassPrior,numeric'
predictive_pdf(dist, prior, x1, n1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictive_pdf_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_x1">x1</code></td>
<td>
<p>stage-one test statistic</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_n1">n1</code></td>
<td>
<p>stage-one sample size</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="predictive_pdf_+3A_k">k</code></td>
<td>
<p>number of pivots for crude integral approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>, value of the predictive PDF
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4))
predictive_pdf(Normal(), tmp, 2, 20)

predictive_pdf(Normal(), PointMassPrior(.3, 1), 1.5, 20) # ~.343

</code></pre>

<hr>
<h2 id='print.adoptrOptimizationResult'>Printing an optimization result</h2><span id='topic+print.adoptrOptimizationResult'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>Printing an optimization result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.adoptrOptimizationResult_+3A_x">x</code></td>
<td>
<p>object to print</p>
</td></tr>
<tr><td><code id="print.adoptrOptimizationResult_+3A_...">...</code></td>
<td>
<p>further arguments passed form other methods</p>
</td></tr>
</table>

<hr>
<h2 id='Prior-class'>Univariate prior on model parameter</h2><span id='topic+Prior-class'></span><span id='topic+Prior'></span>

<h3>Description</h3>

<p>A <code>Prior</code> object represents a prior distribution on the single model
parameter of a <code><a href="#topic+DataDistribution">DataDistribution</a></code> class
object.
Together a prior and data-distribution specify the class of the joint
distribution of the test statisic, X, and its parameter, theta.
Currently, <span class="pkg">adoptr</span> only allows simple models with a single parameter.
Implementations for <a href="#topic+PointMassPrior">PointMassPrior</a> and <a href="#topic+ContinuousPrior">ContinuousPrior</a> are available.
</p>


<h3>Details</h3>

<p>For an example on working with priors, see
<a href="https://optad.github.io/adoptr/articles/working-with-priors.html">here</a>.
</p>


<h3>See Also</h3>

<p>For the available methods, see <code><a href="#topic+bounds">bounds</a></code>,
<code><a href="#topic+expectation">expectation</a></code>, <code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+predictive_pdf">predictive_pdf</a></code>,
<code><a href="#topic+predictive_cdf">predictive_cdf</a></code>, <code><a href="#topic+posterior">posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc_prior &lt;- PointMassPrior(c(0.1, 0.25), c(0.4, 0.6))

cont_prior &lt;- ContinuousPrior(
  pdf     = function(x) dnorm(x, mean = 0.3, sd = 0.2),
  support = c(-2, 3)
)


</code></pre>

<hr>
<h2 id='probability_density_function'>Probability density function</h2><span id='topic+probability_density_function'></span><span id='topic+probability_density_function+2CBinomial+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+probability_density_function+2CChiSquared+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+probability_density_function+2CNestedModels+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+probability_density_function+2CNormal+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+probability_density_function+2CStudent+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+probability_density_function+2CSurvival+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>probability_density_function</code> evaluates the probability density
function of a specific distribution <code>dist</code> at a point <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probability_density_function(dist, x, n, theta, ...)

## S4 method for signature 'Binomial,numeric,numeric,numeric'
probability_density_function(dist, x, n, theta, ...)

## S4 method for signature 'ChiSquared,numeric,numeric,numeric'
probability_density_function(dist, x, n, theta, ...)

## S4 method for signature 'NestedModels,numeric,numeric,numeric'
probability_density_function(dist, x, n, theta, ...)

## S4 method for signature 'Normal,numeric,numeric,numeric'
probability_density_function(dist, x, n, theta, ...)

## S4 method for signature 'Student,numeric,numeric,numeric'
probability_density_function(dist, x, n, theta, ...)

## S4 method for signature 'Survival,numeric,numeric,numeric'
probability_density_function(dist, x, n, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probability_density_function_+3A_dist">dist</code></td>
<td>
<p>a univariate <code><a href="#topic+DataDistribution-class">distribution</a></code> object</p>
</td></tr>
<tr><td><code id="probability_density_function_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="probability_density_function_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="probability_density_function_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="probability_density_function_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the distribution is <code><a href="#topic+Binomial">Binomial</a></code>,
theta denotes the rate difference between
intervention and control group.
Then, the mean is assumed to be
&radic; n  theta.
</p>
<p>If the distribution is <code><a href="#topic+Normal">Normal</a></code>, then
the mean is assumed to be
&radic; n  theta.
</p>


<h3>Value</h3>

<p>value of the probability density function at point <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probability_density_function(Binomial(.2, FALSE), 1, 50, .3)

probability_density_function(Pearson2xK(3), 1, 30, get_tau_Pearson2xK(c(0.3, 0.4, 0.7, 0.2)))
probability_density_function(ZSquared(TRUE), 1, 35, get_tau_ZSquared(0.4, 1))


probability_density_function(ANOVA(3), 1, 30, get_tau_ANOVA(c(0.3, 0.4, 0.7, 0.2)))

probability_density_function(Normal(), 1, 50, .3)

probability_density_function(Student(TRUE), 1, 40, 1.1)

probability_density_function(Survival(0.6,TRUE),0.75,50,0.9)

</code></pre>

<hr>
<h2 id='Scores'>Scores</h2><span id='topic+Scores'></span><span id='topic+expected'></span><span id='topic+expected+2CConditionalScore-method'></span><span id='topic+evaluate'></span><span id='topic+evaluate+2CIntegralScore+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p>In <code>adoptr</code> scores are used to assess the performance of a design.
This can be done either conditionally on the observed stage-one outcome
or unconditionally.
Consequently, score objects are either of class <code>ConditionalScore</code> or
<code>UnconditionalScore</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected(s, data_distribution, prior, ...)

## S4 method for signature 'ConditionalScore'
expected(s, data_distribution, prior, label = NA_character_, ...)

evaluate(s, design, ...)

## S4 method for signature 'IntegralScore,TwoStageDesign'
evaluate(s, design, optimization = FALSE, subdivisions = 10000L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Scores_+3A_s">s</code></td>
<td>
<p><code><a href="#topic+Scores">Score</a></code> object</p>
</td></tr>
<tr><td><code id="Scores_+3A_data_distribution">data_distribution</code></td>
<td>
<p><code><a href="#topic+DataDistribution">DataDistribution</a></code> object</p>
</td></tr>
<tr><td><code id="Scores_+3A_prior">prior</code></td>
<td>
<p>a <code><a href="#topic+Prior">Prior</a></code> object</p>
</td></tr>
<tr><td><code id="Scores_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Scores_+3A_label">label</code></td>
<td>
<p>object label (string)</p>
</td></tr>
<tr><td><code id="Scores_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="Scores_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
<tr><td><code id="Scores_+3A_subdivisions">subdivisions</code></td>
<td>
<p>maximal number of subdivisions when evaluating an integral
score using adaptive quadrature (optimization = FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All scores can be evaluated on a design using the <code>evaluate</code> method.
Note that <code>evaluate</code> requires a third argument <code>x1</code> for
conditional scores (observed stage-one outcome).
Any <code>ConditionalScore</code> can be converted to a <code>UnconditionalScore</code>
by forming its expected value using <code>expected</code>.
The returned unconditional score is of class <code>IntegralScore</code>.
</p>


<h3>Value</h3>

<p>No return value. Generic description of class <code>Score</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ConditionalPower">ConditionalPower</a></code>, <code><a href="#topic+ConditionalSampleSize">ConditionalSampleSize</a></code>,
<code><a href="#topic+composite">composite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(
  n1    = 25,
  c1f   = 0,
  c1e   = 2.5,
  n2    = 50,
  c2    = 1.96,
  order = 7L
)
prior &lt;- PointMassPrior(.3, 1)

# conditional
cp &lt;- ConditionalPower(Normal(), prior)
expected(cp, Normal(), prior)
evaluate(cp, design, x1 = .5)

# unconditional
power &lt;- Power(Normal(), prior)
evaluate(power, design)
evaluate(power, design, optimization = TRUE) # use non-adaptive quadrature


</code></pre>

<hr>
<h2 id='simulate+2CTwoStageDesign+2Cnumeric-method'>Draw samples from a two-stage design</h2><span id='topic+simulate+2CTwoStageDesign+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>simulate</code> allows to draw samples from a given
<code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TwoStageDesign,numeric'
simulate(object, nsim, dist, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_object">object</code></td>
<td>
<p><code>TwoStageDesign</code> to draw samples from</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_dist">dist</code></td>
<td>
<p>data distribution</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_theta">theta</code></td>
<td>
<p>location parameter of the data distribution</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="simulate+2B2CTwoStageDesign+2B2Cnumeric-method_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simulate()</code> returns a <code>data.frame</code> with <code>nsim</code>
rows and for each row (each simulation run) the following columns
</p>

<ul>
<li><p> theta: The effect size
</p>
</li>
<li><p> n1: First-stage sample size
</p>
</li>
<li><p> c1f: Stopping for futility boundary
</p>
</li>
<li><p> c1e: Stopping for efficacy boundary
</p>
</li>
<li><p> x1: First-stage outcome
</p>
</li>
<li><p> n2: Resulting second-stage sample size after observing x1
</p>
</li>
<li><p> c2: Resulting second-stage decision-boundary after observing x1
</p>
</li>
<li><p> x2: Second-stage outcome
</p>
</li>
<li><p> reject: Decision whether the null hypothesis is rejected or not
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(25, 0, 2, 25, 2, order = 5)
# draw samples assuming two-armed design
simulate(design, 10, Normal(), .3, 42)

</code></pre>

<hr>
<h2 id='Student-class'>Student's t data distribution</h2><span id='topic+Student-class'></span><span id='topic+Student'></span><span id='topic+quantile+2CStudent-method'></span><span id='topic+simulate+2CStudent+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Implements exact t-distributions instead of a normal approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Student(two_armed = TRUE)

## S4 method for signature 'Student'
quantile(x, probs, n, theta, ...)

## S4 method for signature 'Student,numeric'
simulate(object, nsim, n, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Student-class_+3A_two_armed">two_armed</code></td>
<td>
<p>logical indicating if a two-armed trial is regarded</p>
</td></tr>
<tr><td><code id="Student-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="Student-class_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Student-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="Student-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="Student-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Student-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Student</code></p>
</td></tr>
<tr><td><code id="Student-class_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="Student-class_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>see <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadist &lt;- Student(two_armed = TRUE)

</code></pre>

<hr>
<h2 id='subject_to'>Create a collection of constraints</h2><span id='topic+subject_to'></span><span id='topic+ConstraintCollection'></span><span id='topic+evaluate+2CConstraintsCollection+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p><code>subject_to(...)</code> can be used to generate an object of class
<code>ConstraintsCollection</code> from an arbitrary number of (un)conditional
constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject_to(...)

## S4 method for signature 'ConstraintsCollection,TwoStageDesign'
evaluate(s, design, optimization = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject_to_+3A_...">...</code></td>
<td>
<p>either constraint objects (for <code>subject_to</code> or optional arguments passed to <code>evaluate</code>)</p>
</td></tr>
<tr><td><code id="subject_to_+3A_s">s</code></td>
<td>
<p>object of class <code>ConstraintCollection</code></p>
</td></tr>
<tr><td><code id="subject_to_+3A_design">design</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="subject_to_+3A_optimization">optimization</code></td>
<td>
<p>logical, if <code>TRUE</code> uses a relaxation to real
parameters of the underlying design; used for smooth optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>ConstraintsCollection</code>
</p>


<h3>See Also</h3>

<p><code>subject_to</code> is intended to be used for constraint
specification the constraints in <code><a href="#topic+minimize">minimize</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define type one error rate and power
toer  &lt;- Power(Normal(), PointMassPrior(0.0, 1))
power &lt;- Power(Normal(), PointMassPrior(0.4, 1))

# create constrain collection
subject_to(
  toer  &lt;= 0.025,
  power &gt;= 0.9
)

</code></pre>

<hr>
<h2 id='Survival-class'>Log-rank test</h2><span id='topic+Survival-class'></span><span id='topic+Survival'></span><span id='topic+quantile+2CSurvival-method'></span><span id='topic+simulate+2CSurvival+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Implements the normal approximation of the log-rank test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Survival(event_rate, two_armed = TRUE)

## S4 method for signature 'Survival'
quantile(x, probs, n, theta, ...)

## S4 method for signature 'Survival,numeric'
simulate(object, nsim, n, theta, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Survival-class_+3A_event_rate">event_rate</code></td>
<td>
<p>probability that a subject will eventually have an event</p>
</td></tr>
<tr><td><code id="Survival-class_+3A_two_armed">two_armed</code></td>
<td>
<p>logical indicating if a two-armed trial is regarded</p>
</td></tr>
<tr><td><code id="Survival-class_+3A_x">x</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="Survival-class_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Survival-class_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="Survival-class_+3A_theta">theta</code></td>
<td>
<p>distribution parameter</p>
</td></tr>
<tr><td><code id="Survival-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="Survival-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Survival</code></p>
</td></tr>
<tr><td><code id="Survival-class_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation runs</p>
</td></tr>
<tr><td><code id="Survival-class_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>event_rate</code></dt><dd><p>cf. parameter 'event_rate'</p>
</dd>
</dl>


<h3>See Also</h3>

<p>see <code><a href="#topic+probability_density_function">probability_density_function</a></code> and
<code><a href="#topic+cumulative_distribution_function">cumulative_distribution_function</a></code> to evaluate the pdf
and the cdf, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadist &lt;- Survival(event_rate=0.6, two_armed=TRUE)

</code></pre>

<hr>
<h2 id='SurvivalDesign'>SurvivalDesign</h2><span id='topic+SurvivalDesign'></span><span id='topic+SurvivalDesign+2CTwoStageDesign-method'></span><span id='topic+TwoStageDesign+2CTwoStageDesign-method'></span><span id='topic+OneStageDesign+2COneStageDesign-method'></span><span id='topic+SurvivalDesign+2COneStageDesign-method'></span><span id='topic+GroupSequentialDesign+2CGroupSequentialDesign-method'></span><span id='topic+SurvivalDesign+2CGroupSequentialDesign-method'></span>

<h3>Description</h3>

<p><code>SurvivalDesign</code> is a function that converts an arbitrary design to a survival design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurvivalDesign(design, event_rate)

## S4 method for signature 'TwoStageDesign'
SurvivalDesign(design, event_rate)

## S4 method for signature 'TwoStageDesign'
TwoStageDesign(n1, event_rate)

## S4 method for signature 'OneStageDesign'
OneStageDesign(n, event_rate)

## S4 method for signature 'OneStageDesign'
SurvivalDesign(design, event_rate)

## S4 method for signature 'GroupSequentialDesign'
GroupSequentialDesign(n1, event_rate)

## S4 method for signature 'GroupSequentialDesign'
SurvivalDesign(design, event_rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SurvivalDesign_+3A_design">design</code></td>
<td>
<p>design that should be converted to a survival design</p>
</td></tr>
<tr><td><code id="SurvivalDesign_+3A_event_rate">event_rate</code></td>
<td>
<p>probability that a subject in either group will eventually have an event</p>
</td></tr>
<tr><td><code id="SurvivalDesign_+3A_n1">n1</code></td>
<td>
<p>design object to convert (overloaded from <code>TwoStageDesign</code>)</p>
</td></tr>
<tr><td><code id="SurvivalDesign_+3A_n">n</code></td>
<td>
<p>design object to convert (overloaded from <code>TwoStageDesign</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Converts any type of design to a survival design
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- get_initial_design(0.4, 0.025, 0.1)
SurvivalDesign(design, 0.8)

design_os &lt;- get_initial_design(0.4, 0.025, 0.1, type_design = "one-stage")
design_gs &lt;- get_initial_design(0.4, 0.025, 0.1, type_design = "group-sequential")

OneStageDesign(design_os, 0.7)

GroupSequentialDesign(design_gs, 0.8)

</code></pre>

<hr>
<h2 id='tunable_parameters'>Switch between numeric and S4 class representation of a design</h2><span id='topic+tunable_parameters'></span><span id='topic+tunable_parameters+2CTwoStageDesign-method'></span><span id='topic+update+2CTwoStageDesign-method'></span><span id='topic+update+2COneStageDesign-method'></span>

<h3>Description</h3>

<p>Get tunable parameters of a design as numeric vector via
<code>tunable_parameters</code> or <code>update</code> a design object with a suitable
vector of values for its tunable parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tunable_parameters(object, ...)

## S4 method for signature 'TwoStageDesign'
tunable_parameters(object, ...)

## S4 method for signature 'TwoStageDesign'
update(object, params, ...)

## S4 method for signature 'OneStageDesign'
update(object, params, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tunable_parameters_+3A_object">object</code></td>
<td>
<p><code>TwoStageDesign</code> object to update</p>
</td></tr>
<tr><td><code id="tunable_parameters_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="tunable_parameters_+3A_params">params</code></td>
<td>
<p>vector of design parameters, must be in same order as returned
by <br />
<code>tunable_parameters</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tunable</code> slot of a <code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code> stores information about
the set of design parameters which are considered fixed (not changed during
optimization) or tunable (changed during optimization).
For details on how to fix certain parameters or how to make them tunable
again, see <code><a href="#topic+make_fixed">make_fixed</a></code> and <code><a href="#topic+make_tunable">make_tunable</a></code>.
</p>


<h3>Value</h3>

<p><code>tunable_parameters</code> returns the numerical values of all
tunable parameters as a vector.
<code>update</code> returns the updated design.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design  &lt;- TwoStageDesign(25, 0, 2, 25, 2, order = 5)
tunable_parameters(design)
design2 &lt;- update(design, tunable_parameters(design) + 1)
tunable_parameters(design2)

</code></pre>

<hr>
<h2 id='TwoStageDesign-class'>Two-stage designs</h2><span id='topic+TwoStageDesign-class'></span><span id='topic+TwoStageDesign'></span><span id='topic+TwoStageDesign+2Cnumeric-method'></span><span id='topic+summary+2CTwoStageDesign-method'></span>

<h3>Description</h3>

<p><code>TwoStageDesign</code> is the fundamental design class of the
<span class="pkg"><a href="#topic+adoptr">adoptr</a></span> package.
Formally, we represent a generic two-stage design as a five-tuple
(n<sub>1</sub>, c<sub>1</sub><sup>f</sup>, c<sub>1</sub><sup>e</sup>, n<sub>2</sub>(&middot;), c<sub>2</sub>(&middot;)).
Here, n<sub>1</sub> is the first-stage sample
size (per group), c<sub>1</sub><sup>f</sup>
and c<sub>1</sub><sup>e</sup> are
boundaries for early stopping for futility and efficacy, respectively.
Since the trial design is a two-stage design, the elements
n<sub>2</sub>(&middot;) (stage-two sample
size) and c<sub>2</sub>(&middot;)
(stage-two critical value) are functions of the first-stage outcome
X<sub>1</sub>=x<sub>1</sub>.
X<sub>1</sub> denotes the first-stage test
statistic. A brief description on this definition of two-stage designs can be
read <a href="https://optad.github.io/adoptr/articles/adoptr.html">here</a>.
For available methods, see the 'See Also' section at the end of this page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoStageDesign(n1, ...)

## S4 method for signature 'numeric'
TwoStageDesign(
  n1,
  c1f,
  c1e,
  n2_pivots,
  c2_pivots,
  order = NULL,
  event_rate,
  ...
)

## S4 method for signature 'TwoStageDesign'
summary(object, ..., rounded = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TwoStageDesign-class_+3A_n1">n1</code></td>
<td>
<p>stage-one sample size</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_c1f">c1f</code></td>
<td>
<p>early futility stopping boundary</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_c1e">c1e</code></td>
<td>
<p>early efficacy stopping boundary</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_n2_pivots">n2_pivots</code></td>
<td>
<p>numeric vector, stage-two sample size on the integration
pivot points</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_c2_pivots">c2_pivots</code></td>
<td>
<p>numeric vector, stage-two critical values on the integration
pivot points</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_order">order</code></td>
<td>
<p><code>integer</code>, integration order of the employed Gaussian quadrature
integration rule to evaluate scores. Automatically set to <code>length(n2_pivots)</code> if <br />
<code>length(n2_pivots) == length(c2_pivots) &gt; 1</code>, otherwise c2 and n2
are taken to be constant in stage-two and replicated to match the number of
pivots specified by <code>order</code></p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_event_rate">event_rate</code></td>
<td>
<p>probability that a subject in either group will eventually have an event,
only needs to be specified for time-to-event endpoints</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_object">object</code></td>
<td>
<p>object to show</p>
</td></tr>
<tr><td><code id="TwoStageDesign-class_+3A_rounded">rounded</code></td>
<td>
<p>should rounded n-values be used?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary</code> can be used to quickly compute and display basic facts about
a TwoStageDesign.
An arbitrary number of names <code><a href="#topic+Scores">UnconditionalScore</a></code> objects can be
provided via the optional arguments <code>...</code> and are included in the summary displayed using
<code><a href="#topic+print">print</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>n1</code></dt><dd><p>cf. parameter 'n1'</p>
</dd>
<dt><code>c1f</code></dt><dd><p>cf. parameter 'c1f'</p>
</dd>
<dt><code>c1e</code></dt><dd><p>cf. parameter 'c1e'</p>
</dd>
<dt><code>n2_pivots</code></dt><dd><p>vector of length 'order' giving the values of n2 at the
pivot points of the numeric integration rule</p>
</dd>
<dt><code>c2_pivots</code></dt><dd><p>vector of length order giving the values of c2 at the
pivot points of the numeric integration rule</p>
</dd>
<dt><code>x1_norm_pivots</code></dt><dd><p>normalized pivots for integration rule (in [-1, 1])
the actual pivots are scaled to the interval [c1f, c1e] and can be
obtained by the internal method <br />
<code>adoptr:::scaled_integration_pivots(design)</code></p>
</dd>
<dt><code>weights</code></dt><dd><p>weights of of integration rule at <code>x1_norm_pivots</code> for
approximating integrals over <code>x1</code></p>
</dd>
<dt><code>tunable</code></dt><dd><p>named logical vector indicating whether corresponding slot is
considered a tunable parameter (i.e. whether it can be changed during
optimization via <code><a href="#topic+minimize">minimize</a></code> or not; cf. <br />
<code><a href="#topic+make_fixed">make_fixed</a></code>)</p>
</dd>
</dl>


<h3>See Also</h3>

<p>For accessing sample sizes and critical values safely, see methods in
<code><a href="#topic+n">n</a></code> and <code><a href="#topic+c2">c2</a></code>; for modifying behaviour during optimizaton
see <code><a href="#topic+make_tunable">make_tunable</a></code>; to convert between S4 class represenation and
numeric vector, see <code><a href="#topic+tunable_parameters">tunable_parameters</a></code>; for simulating from a given
design, see <code><a href="#topic+simulate+2CTwoStageDesign+2Cnumeric-method">simulate</a></code>;
for plotting see <code><a href="#topic+plot+2CTwoStageDesign-method">plot,TwoStageDesign-method</a></code>.
Both <a href="#topic+GroupSequentialDesign-class">group-sequential</a> and
<a href="#topic+OneStageDesign">one-stage designs</a> (!) are implemented as subclasses of
<code>TwoStageDesign</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- TwoStageDesign(50, 0, 2, 50.0, 2.0, 5)
pow    &lt;- Power(Normal(), PointMassPrior(.4, 1))
summary(design, "Power" = pow)

</code></pre>

<hr>
<h2 id='TwoStageDesignSurvival-class'>Two-stage design for time-to-event-endpoints</h2><span id='topic+TwoStageDesignSurvival-class'></span>

<h3>Description</h3>

<p>When conducting a study with time-to-event endpoints, the main interest is not the
sample size, but the number of overall necessary events. Thus, <span class="pkg"><a href="#topic+adoptr">adoptr</a></span> does not use
the sample size for calculating the design. Instead,
it uses the number of events directly.
In the framework of <span class="pkg"><a href="#topic+adoptr">adoptr</a></span>, all the calculations are done group-wise, where both of the groups are equal-sized.
This means, that the number of events <span class="pkg"><a href="#topic+adoptr">adoptr</a></span> has computed is only half of the overall number of necessary events.
In order to facilitate this issue, the look of the
<code>summary</code> and <code>show</code> functions have been changed in the survival analysis setting.
The sample size is implicitly determined
by dividing the number of events by the event rate. Survival objects are only
created, when the argument <code>event_rate</code> is not missing.
</p>


<h3>Slots</h3>


<dl>
<dt><code>event_rate</code></dt><dd><p>probability that a subject in either group will eventually have an event</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+TwoStageDesign">TwoStageDesign</a></code> for superclass and inherited methods
</p>

<hr>
<h2 id='ZSquared-class'>Distribution class of a squared normal distribution</h2><span id='topic+ZSquared-class'></span><span id='topic+ZSquared'></span><span id='topic+get_tau_ZSquared'></span>

<h3>Description</h3>

<p>Implementation of <code class="reqn">Z^2</code>, where <code class="reqn">Z</code> is normally distributed with mean
<code class="reqn">\mu</code> and variance <code class="reqn">\sigma^2</code>. <code class="reqn">Z^2</code> is chi-squared distributed
with <code class="reqn">1</code> degree of freedom and non-centrality parameter <code class="reqn">(\mu/\sigma)^2</code>.
The function <code>get_tau_ZSquared</code> computes the factor <code class="reqn">\tau=(\mu/\sigma)^2</code>,
such that <code class="reqn">\tau</code> is the equivalent of <code class="reqn">\theta</code> in the normally
distributed case. The square of a normal distribution <code class="reqn">Z^2</code> can be used
for two-sided hypothesis testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZSquared(two_armed = TRUE)

get_tau_ZSquared(mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZSquared-class_+3A_two_armed">two_armed</code></td>
<td>
<p>logical indicating if a two-armed trial is regarded</p>
</td></tr>
<tr><td><code id="ZSquared-class_+3A_mu">mu</code></td>
<td>
<p>mean of Z</p>
</td></tr>
<tr><td><code id="ZSquared-class_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of Z</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>zsquared &lt;- ZSquared(FALSE)


H1 &lt;- PointMassPrior(get_tau_ZSquared(0.4, 1), 1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
