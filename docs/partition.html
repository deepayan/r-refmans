<!DOCTYPE html><html lang="en-US"><head><title>Help for package partition</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {partition}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#all_columns_reduced'><p>Check if all variables reduced to a single composite</p></a></li>
<li><a href='#all_done'><p>Mark the partition as complete to stop search</p></a></li>
<li><a href='#append_mappings'><p>Append a new variable to mapping and filter out composite variables</p></a></li>
<li><a href='#as_director'><p>Create a custom director</p></a></li>
<li><a href='#as_measure'><p>Create a custom metric</p></a></li>
<li><a href='#as_partition'><p>Return a partition object</p></a></li>
<li><a href='#as_partition_step'><p>Create a partition object from a data frame</p></a></li>
<li><a href='#as_partitioner'><p>Create a partitioner</p></a></li>
<li><a href='#as_reducer'><p>Create a custom reducer</p></a></li>
<li><a href='#assign_partition'><p>Process a dataset with a partitioner</p></a></li>
<li><a href='#baxter_data'><p>Microbiome data</p></a></li>
<li><a href='#binary_k_search'><p>Search for best <code>k</code> using the binary search method</p></a></li>
<li><a href='#build_next_name'><p>Create new variable name based on prefix and previous reductions</p></a></li>
<li><a href='#calculate_new_variable'><p>Calculate or retrieve stored reduced variable</p></a></li>
<li><a href='#cat_bold'><p>Print to the console in color</p></a></li>
<li><a href='#corr'><p>Efficiently fit correlation coefficient for matrix or two vectors</p></a></li>
<li><a href='#count_clusters'><p>Helper functions to print <code>partition</code> summary</p></a></li>
<li><a href='#direct_distance'><p>Target based on minimum distance matrix</p></a></li>
<li><a href='#direct_k_cluster'><p>Target based on K-means clustering</p></a></li>
<li><a href='#direct_measure_reduce'><p>Apply a partitioner</p></a></li>
<li><a href='#fill_in_missing'><p>Process reduced variables when missing data</p></a></li>
<li><a href='#filter_reduced'><p>Filter the reduced mappings</p></a></li>
<li><a href='#find_algorithm'><p>Which kmeans algorithm to use?</p></a></li>
<li><a href='#find_min_distance_variables'><p>Find the index of the pair with the smallest distance</p></a></li>
<li><a href='#fit_distance_matrix'><p>Fit a distance matrix using correlation coefficients</p></a></li>
<li><a href='#get_indices'><p>Process mapping key to return from <code>partition()</code></p></a></li>
<li><a href='#guess_init_k'><p>Guess initial <code>k</code> based on threshold and <code>p</code></p></a></li>
<li><a href='#icc'><p>Calculate the intraclass correlation coefficient</p></a></li>
<li><a href='#icc_r'><p>Calculate the intraclass correlation coefficient</p></a></li>
<li><a href='#increase_hits'><p>Count and retrieve the number of metrics below threshold</p></a></li>
<li><a href='#is_partition'><p>Is this object a partition?</p></a></li>
<li><a href='#is_partition_step'><p>Is this object a <code>partition_step</code>?</p></a></li>
<li><a href='#is_partitioner'><p>Is this object a partitioner?</p></a></li>
<li><a href='#is_same_function'><p>Are two functions the same?</p></a></li>
<li><a href='#k_exhausted'><p>Have all values of <code>k</code> been checked for metric?</p></a></li>
<li><a href='#k_searching_forward'><p>Assess <code>k</code> search</p></a></li>
<li><a href='#linear_k_search'><p>Search for best <code>k</code> using the linear search method</p></a></li>
<li><a href='#map_partition'><p>Map a partition across a range of minimum information</p></a></li>
<li><a href='#mapping_key'><p>Return partition mapping key</p></a></li>
<li><a href='#matrix_is_exhausted'><p>Have all pairs of variables been checked for metric?</p></a></li>
<li><a href='#measure_icc'><p>Measure the information loss of reduction using intraclass correlation</p>
coefficient</a></li>
<li><a href='#measure_min_icc'><p>Measure the information loss of reduction using the minimum intraclass</p>
correlation coefficient</a></li>
<li><a href='#measure_min_r2'><p>Measure the information loss of reduction using minimum R-squared</p></a></li>
<li><a href='#measure_std_mutualinfo'><p>Measure the information loss of reduction using standardized mutual</p>
information</a></li>
<li><a href='#measure_variance_explained'><p>Measure the information loss of reduction using the variance explained.</p></a></li>
<li><a href='#mutual_information'><p>Calculate the standardized mutual information of a data set</p></a></li>
<li><a href='#part_icc'><p>Partitioner: distance, ICC, scaled means</p></a></li>
<li><a href='#part_kmeans'><p>Partitioner: K-means, ICC, scaled means</p></a></li>
<li><a href='#part_minr2'><p>Partitioner: distance, minimum R-squared, scaled means</p></a></li>
<li><a href='#part_pc1'><p>Partitioner: distance, first principal component, scaled means</p></a></li>
<li><a href='#part_stdmi'><p>Partitioner: distance, mutual information, scaled means</p></a></li>
<li><a href='#partition'><p>Agglomerative partitioning</p></a></li>
<li><a href='#partition_scores'><p>Return the reduced data from a partition</p></a></li>
<li><a href='#paste_director'><p>Lookup partitioner types to print in English</p></a></li>
<li><a href='#permute_df'><p>Permute a data set</p></a></li>
<li><a href='#plot_area_clusters'><p>Plot partitions</p></a></li>
<li><a href='#plot_permutation'><p>Plot permutation tests</p></a></li>
<li><a href='#pull_composite_variables'><p>Access mapping variables</p></a></li>
<li><a href='#reduce_cluster'><p>Reduce a target</p></a></li>
<li><a href='#reduce_first_component'><p>Reduce selected variables to first principal component</p></a></li>
<li><a href='#reduce_kmeans'><p>Reduce selected variables to scaled means</p></a></li>
<li><a href='#reduce_mappings'><p>Create a mapping key out of a list of targets</p></a></li>
<li><a href='#reduce_scaled_mean'><p>Reduce selected variables to scaled means</p></a></li>
<li><a href='#replace_partitioner'><p>Replace the director, metric, or reducer for a partitioner</p></a></li>
<li><a href='#return_if_single'><p>Reduce targets if more than one variable, return otherwise</p></a></li>
<li><a href='#rewind_target'><p>Set target to last value</p></a></li>
<li><a href='#scaled_mean'><p>Average and scale rows in a <code>data.frame</code></p></a></li>
<li><a href='#search_k'><p>Search for the best <code>k</code></p></a></li>
<li><a href='#simplify_names'><p>Simplify reduced variable names</p></a></li>
<li><a href='#simulate_block_data'><p>Simulate correlated blocks of variables</p></a></li>
<li><a href='#summarize_partitions'><p>Summarize and map partitions and permutations</p></a></li>
<li><a href='#super_partition'><p>super_partition</p></a></li>
<li><a href='#test_permutation'><p>Permute partitions</p></a></li>
<li><a href='#under_threshold'><p>Compare metric to threshold</p></a></li>
<li><a href='#update_dist'><p>Only fit the distances for a new variable</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Agglomerative Partitioning Framework for Dimension Reduction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Malcolm Barrett &lt;malcolmbarrett@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A fast and flexible framework for agglomerative partitioning.
    'partition' uses an approach called Direct-Measure-Reduce to create
    new variables that maintain the user-specified minimum level of
    information. Each reduced variable is also interpretable: the original
    variables map to one and only one variable in the reduced data set.
    'partition' is flexible, as well: how variables are selected to
    reduce, how information loss is measured, and the way data is reduced
    can all be customized.  'partition' is based on the Partition
    framework discussed in Millstein et al. (2020) 
    &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtz661">doi:10.1093/bioinformatics/btz661</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://uscbiostats.github.io/partition/">https://uscbiostats.github.io/partition/</a>,
<a href="https://github.com/USCbiostats/partition">https://github.com/USCbiostats/partition</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USCbiostats/partition/issues">https://github.com/USCbiostats/partition/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>crayon, dplyr (&ge; 0.8.0), forcats, ggplot2 (&ge; 3.3.0),
infotheo, magrittr, MASS, pillar, progress, purrr, Rcpp, rlang,
stringr, tibble, tidyr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, genieclust, ggcorrplot, gtools, knitr, rmarkdown,
spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-09 16:21:53 UTC; malcolmbarrett</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Millstein [aut],
  Malcolm Barrett <a href="https://orcid.org/0000-0003-0299-5825"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Katelyn Queen <a href="https://orcid.org/0000-0002-8070-3042"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-09 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='all_columns_reduced'>Check if all variables reduced to a single composite</h2><span id='topic+all_columns_reduced'></span>

<h3>Description</h3>

<p>Check if all variables reduced to a single composite
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_columns_reduced(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_columns_reduced_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, <code>TRUE</code> or <code>FALSE</code>
</p>

<hr>
<h2 id='all_done'>Mark the partition as complete to stop search</h2><span id='topic+all_done'></span>

<h3>Description</h3>

<p>Mark the partition as complete to stop search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_done(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_done_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>

<hr>
<h2 id='append_mappings'>Append a new variable to mapping and filter out composite variables</h2><span id='topic+append_mappings'></span>

<h3>Description</h3>

<p>Append a new variable to mapping and filter out composite variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_mappings(.partition_step, new_x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="append_mappings_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="append_mappings_+3A_new_x">new_x</code></td>
<td>
<p>the name of the reduced variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tibble</code>, the mapping key
</p>

<hr>
<h2 id='as_director'>Create a custom director</h2><span id='topic+as_director'></span>

<h3>Description</h3>

<p>Directors are functions that tell the partition algorithm what
to try to reduce.  <code><a href="#topic+as_director">as_director()</a></code> is a helper function to create new
directors to be used in <code>partitioner</code>s. <code>partitioner</code>s can be created with
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_director(.pairs, .target, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_director_+3A_.pairs">.pairs</code></td>
<td>
<p>a function that returns a matrix of targets (e.g. a distance matrix of variables)</p>
</td></tr>
<tr><td><code id="as_director_+3A_.target">.target</code></td>
<td>
<p>a function that returns a vector of targets (e.g. the minimum pair)</p>
</td></tr>
<tr><td><code id="as_director_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>.f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function to use in <code><a href="#topic+as_partitioner">as_partitioner()</a></code>
</p>


<h3>See Also</h3>

<p>Other directors: 
<code><a href="#topic+direct_distance">direct_distance</a>()</code>,
<code><a href="#topic+direct_k_cluster">direct_k_cluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use euclidean distance to calculate distances
euc_dist &lt;- function(.data) as.matrix(dist(t(.data)))

# find the pair with the minimum distance
min_dist &lt;- function(.x) {
  indices &lt;- arrayInd(which.min(.x), dim(as.matrix(.x)))

  #  get variable names with minimum distance
  c(
    colnames(.x)[indices[1]],
    colnames(.x)[indices[2]]
  )
}

as_director(euc_dist, min_dist)

</code></pre>

<hr>
<h2 id='as_measure'>Create a custom metric</h2><span id='topic+as_measure'></span>

<h3>Description</h3>

<p>Metrics are functions that tell how much information would be
lost for a given reduction in the data. reduce.  <code><a href="#topic+as_measure">as_measure()</a></code> is a
helper function to create new metrics to be used in <code>partitioner</code>s.
<code>partitioner</code>s can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_measure(.f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_measure_+3A_.f">.f</code></td>
<td>
<p>a function that returns either a numeric vector or a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="as_measure_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>.f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function to use in <code><a href="#topic+as_partitioner">as_partitioner()</a></code>
</p>


<h3>See Also</h3>

<p>Other metrics: 
<code><a href="#topic+measure_icc">measure_icc</a>()</code>,
<code><a href="#topic+measure_min_icc">measure_min_icc</a>()</code>,
<code><a href="#topic+measure_min_r2">measure_min_r2</a>()</code>,
<code><a href="#topic+measure_std_mutualinfo">measure_std_mutualinfo</a>()</code>,
<code><a href="#topic+measure_variance_explained">measure_variance_explained</a>()</code>
</p>
<p>Other metrics: 
<code><a href="#topic+measure_icc">measure_icc</a>()</code>,
<code><a href="#topic+measure_min_icc">measure_min_icc</a>()</code>,
<code><a href="#topic+measure_min_r2">measure_min_r2</a>()</code>,
<code><a href="#topic+measure_std_mutualinfo">measure_std_mutualinfo</a>()</code>,
<code><a href="#topic+measure_variance_explained">measure_variance_explained</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
inter_item_reliability &lt;- function(mat) {
  corrs &lt;- corr(mat)
  corrs[lower.tri(corrs, diag = TRUE)] &lt;- NA

  corrs %&gt;%
    colMeans(na.rm = TRUE) %&gt;%
    mean(na.rm = TRUE)
}

measure_iir &lt;- as_measure(inter_item_reliability)
measure_iir

</code></pre>

<hr>
<h2 id='as_partition'>Return a partition object</h2><span id='topic+as_partition'></span>

<h3>Description</h3>

<p><code>as_partition()</code> is called when partitioning is complete. It scrubs a
<code>partition_step</code> object, cleans the reduced variable names, adds mapping
indices, and sorts the composite variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_partition(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_partition_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition</code> object
</p>

<hr>
<h2 id='as_partition_step'>Create a partition object from a data frame</h2><span id='topic+as_partition_step'></span>

<h3>Description</h3>

<p><code>as_partition_step()</code> creates a <code>partition_step</code> object. <code>partition_step</code>s
are used while iterating through the partition algorithm: it stores necessary
information about how to proceed in the partitioning, such as the information
threshold. <code>as_partition_step()</code> is primarily called internally by
<code>partition()</code> but can be helpful while developing <code>partitioners</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_partition_step(
  .x,
  threshold = NA,
  reduced_data = NA,
  target = NA,
  metric = NA,
  tolerance = 0.01,
  var_prefix = NA,
  partitioner = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_partition_step_+3A_.x">.x</code></td>
<td>
<p>a <code>data.frame</code> or <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="as_partition_step_+3A_threshold">threshold</code></td>
<td>
<p>The minimum information loss allowable</p>
</td></tr>
<tr><td><code id="as_partition_step_+3A_reduced_data">reduced_data</code></td>
<td>
<p>A data set with reduced variables</p>
</td></tr>
<tr><td><code id="as_partition_step_+3A_target">target</code></td>
<td>
<p>A character or integer vector: the variables to reduce</p>
</td></tr>
<tr><td><code id="as_partition_step_+3A_metric">metric</code></td>
<td>
<p>A measure of information</p>
</td></tr>
<tr><td><code id="as_partition_step_+3A_tolerance">tolerance</code></td>
<td>
<p>A tolerance around the threshold to accept a reduction</p>
</td></tr>
<tr><td><code id="as_partition_step_+3A_var_prefix">var_prefix</code></td>
<td>
<p>Variable name for reduced variables</p>
</td></tr>
<tr><td><code id="as_partition_step_+3A_partitioner">partitioner</code></td>
<td>
<p>A <code>partitioner</code>, a <code style="white-space: pre;">&#8288;part_*()&#8288;</code> function or one created with
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.</p>
</td></tr>
<tr><td><code id="as_partition_step_+3A_...">...</code></td>
<td>
<p>Other objects to store during the partition step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.df &lt;- data.frame(x = rnorm(100), y = rnorm(100))
as_partition_step(.df, threshold = .6)
</code></pre>

<hr>
<h2 id='as_partitioner'>Create a partitioner</h2><span id='topic+as_partitioner'></span>

<h3>Description</h3>

<p>Partitioners are functions that tell the partition algorithm 1)
what to try to reduce 2) how to measure how much information is lost from
the reduction and 3) how to reduce the data. In partition, functions that
handle 1) are called directors, functions that handle 2) are called
metrics,  and functions that handle 3) are called reducers. partition has a
number of pre-specified partitioners for agglomerative data reduction.
Custom partitioners can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p>Pass <code>partitioner</code> objects to the <code>partitioner</code> argument of <code><a href="#topic+partition">partition()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_partitioner(direct, measure, reduce)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_partitioner_+3A_direct">direct</code></td>
<td>
<p>a function that directs, possibly created by <code><a href="#topic+as_director">as_director()</a></code></p>
</td></tr>
<tr><td><code id="as_partitioner_+3A_measure">measure</code></td>
<td>
<p>a function that measures, possibly created by <code><a href="#topic+as_measure">as_measure()</a></code></p>
</td></tr>
<tr><td><code id="as_partitioner_+3A_reduce">reduce</code></td>
<td>
<p>a function that reduces, possibly created by <code><a href="#topic+as_reducer">as_reducer()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partitioner</code>
</p>


<h3>See Also</h3>

<p>Other partitioners: 
<code><a href="#topic+part_icc">part_icc</a>()</code>,
<code><a href="#topic+part_kmeans">part_kmeans</a>()</code>,
<code><a href="#topic+part_minr2">part_minr2</a>()</code>,
<code><a href="#topic+part_pc1">part_pc1</a>()</code>,
<code><a href="#topic+part_stdmi">part_stdmi</a>()</code>,
<code><a href="#topic+replace_partitioner">replace_partitioner</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
as_partitioner(
  direct = direct_distance_pearson,
  measure = measure_icc,
  reduce = reduce_scaled_mean
)

</code></pre>

<hr>
<h2 id='as_reducer'>Create a custom reducer</h2><span id='topic+as_reducer'></span>

<h3>Description</h3>

<p>Reducers are functions that tell the partition algorithm how
to reduce the data. <code><a href="#topic+as_reducer">as_reducer()</a></code> is a helper function to create new
reducers to be used in <code>partitioner</code>s. <code>partitioner</code>s can be created with
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_reducer(.f, ..., returns_vector = TRUE, first_match = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_reducer_+3A_.f">.f</code></td>
<td>
<p>a function that returns either a numeric vector or a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="as_reducer_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>.f</code>.</p>
</td></tr>
<tr><td><code id="as_reducer_+3A_returns_vector">returns_vector</code></td>
<td>
<p>logical. Does <code>.f</code> return a vector? <code>TRUE</code> by default.
If <code>FALSE</code>, assumes that <code>.f</code> returns a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="as_reducer_+3A_first_match">first_match</code></td>
<td>
<p>logical. Should the partition algorithm stop when it finds
a reduction that is equal to the threshold? Default is <code>TRUE</code> for reducers
that return a <code>data.frame</code> and <code>FALSE</code> for reducers that return a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function to use in <code><a href="#topic+as_partitioner">as_partitioner()</a></code>
</p>


<h3>See Also</h3>

<p>Other reducers: 
<code><a href="#topic+reduce_first_component">reduce_first_component</a>()</code>,
<code><a href="#topic+reduce_kmeans">reduce_kmeans</a>()</code>,
<code><a href="#topic+reduce_scaled_mean">reduce_scaled_mean</a>()</code>
</p>
<p>Other reducers: 
<code><a href="#topic+reduce_first_component">reduce_first_component</a>()</code>,
<code><a href="#topic+reduce_kmeans">reduce_kmeans</a>()</code>,
<code><a href="#topic+reduce_scaled_mean">reduce_scaled_mean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
reduce_row_means &lt;- as_reducer(rowMeans)
reduce_row_means

</code></pre>

<hr>
<h2 id='assign_partition'>Process a dataset with a partitioner</h2><span id='topic+assign_partition'></span>

<h3>Description</h3>

<p><code>assign_partition()</code> is the primary handler for the partition algorithm and
is iterated by <code>reduce_partition_c()</code>. <code>assign_partition()</code> does initial set
up of the <code>partition_step</code> object and then applies the <code>partitioner</code> to each
iteration of the  <code>partition_step</code> via <code>direct_measure_reduce()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_partition(.x, partitioner, .data, threshold, tolerance, var_prefix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_partition_+3A_.x">.x</code></td>
<td>
<p>the data or a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="assign_partition_+3A_partitioner">partitioner</code></td>
<td>
<p>a <code>partitioner</code>. See the <code style="white-space: pre;">&#8288;part_*()&#8288;</code> functions and
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.</p>
</td></tr>
<tr><td><code id="assign_partition_+3A_.data">.data</code></td>
<td>
<p>a data.frame to partition</p>
</td></tr>
<tr><td><code id="assign_partition_+3A_threshold">threshold</code></td>
<td>
<p>the minimum proportion of information explained by a reduced
variable; <code>threshold</code> sets a boundary for information loss because each
reduced variable must explain at least as much as <code>threshold</code> as measured
by the metric.</p>
</td></tr>
<tr><td><code id="assign_partition_+3A_tolerance">tolerance</code></td>
<td>
<p>a small tolerance within the threshold; if a reduction is
within the threshold plus/minus the tolerance, it will reduce.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>

<hr>
<h2 id='baxter_data'>Microbiome data</h2><span id='topic+baxter_data'></span><span id='topic+baxter_clinical'></span><span id='topic+baxter_otu'></span><span id='topic+baxter_family'></span><span id='topic+baxter_genus'></span><span id='topic+baxter_data_dictionary'></span>

<h3>Description</h3>

<p>Clinical and microbiome data derived from &quot;Microbiota-based model improves
the sensitivity of fecal immunochemical test for detecting colonic lesions&quot;
by Baxter et al. (2016). These data represent a subset of 172 health
participants. <code>baxter_clinical</code> contains 8 clinical variables for each of the
participants: <code>sample_name</code>, <code>id</code>, <code>age</code>, <code>bmi</code>, <code>gender</code>, <code>height</code>,
<code>total_reads</code>, and <code>disease_state</code> (all <code>H</code> for healthy). <code>baxter_otu</code> has
1,234 columns, where each columns represent an Operational Taxonomic Unit
(OTU). OTUs are species-like relationships among bacteria determined by
analyzing their RNA. The cells are logged counts for how often the OTU was
detected in a participant's stool sample. Each column name is a shorthand
name, e.g. <code>otu1</code>; you can find the true name of the OTU mapped in
<code>baxter_data_dictionary</code>. <code>baxter_family</code> and <code>baxter_genus</code> are also logged
counts but instead group OTUs at the family and genus level, respectively, a
common approach to reducing microbiome data. Likewise, the column names are
shorthands, which you can find mapped in <code>baxter_data_dictionary</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baxter_clinical

baxter_otu

baxter_family

baxter_genus

baxter_data_dictionary
</code></pre>


<h3>Format</h3>

<p>5 data frames
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 172 rows and 1234 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 172 rows and 35 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 172 rows and 82 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 1351 rows and 3 columns.
</p>


<h3>Source</h3>

<p>Baxter et al. (2016) <a href="https://doi.org/10.1186/s13073-016-0290-3">doi:10.1186/s13073-016-0290-3</a>
</p>

<hr>
<h2 id='binary_k_search'>Search for best <code>k</code> using the binary search method</h2><span id='topic+binary_k_search'></span>

<h3>Description</h3>

<p>Search for best <code>k</code> using the binary search method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_k_search(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binary_k_search_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>

<hr>
<h2 id='build_next_name'>Create new variable name based on prefix and previous reductions</h2><span id='topic+build_next_name'></span>

<h3>Description</h3>

<p>Create new variable name based on prefix and previous reductions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_next_name(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_next_name_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector
</p>

<hr>
<h2 id='calculate_new_variable'>Calculate or retrieve stored reduced variable</h2><span id='topic+calculate_new_variable'></span>

<h3>Description</h3>

<p>Calculate or retrieve stored reduced variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_new_variable(.partition_step, .f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_new_variable_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector, the reduced variable
</p>

<hr>
<h2 id='cat_bold'>Print to the console in color</h2><span id='topic+cat_bold'></span><span id='topic+cat_white'></span><span id='topic+cat_subtle'></span><span id='topic+paste_subtle'></span>

<h3>Description</h3>

<p>Print to the console in color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_bold(...)

cat_white(...)

cat_subtle(...)

paste_subtle(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_bold_+3A_...">...</code></td>
<td>
<p>text to print. Passed to <code>cat()</code> or <code>paste()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='corr'>Efficiently fit correlation coefficient for matrix or two vectors</h2><span id='topic+corr'></span>

<h3>Description</h3>

<p>Efficiently fit correlation coefficient for matrix or two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr(x, y = NULL, spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corr_+3A_x">x</code></td>
<td>
<p>a matrix or vector</p>
</td></tr>
<tr><td><code id="corr_+3A_y">y</code></td>
<td>
<p>a vector. Optional.</p>
</td></tr>
<tr><td><code id="corr_+3A_spearman">spearman</code></td>
<td>
<p>Logical. Use Spearman's correlation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector, the correlation coefficient
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
# fit for entire data set
iris %&gt;%
  select_if(is.numeric) %&gt;%
  corr()

# just fit for two vectors
corr(iris$Sepal.Length, iris$Sepal.Width)

</code></pre>

<hr>
<h2 id='count_clusters'>Helper functions to print <code>partition</code> summary</h2><span id='topic+count_clusters'></span><span id='topic+total_reduced'></span><span id='topic+summarize_mapping'></span><span id='topic+minimum_information'></span>

<h3>Description</h3>

<p>Helper functions to print <code>partition</code> summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_clusters(.partition)

total_reduced(.partition)

summarize_mapping(.partition, n_composite = 5, n_reduced = 10)

minimum_information(.partition, .round = TRUE, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_clusters_+3A_.partition">.partition</code></td>
<td>
<p>a <code>partition</code> object</p>
</td></tr>
<tr><td><code id="count_clusters_+3A_n_composite">n_composite</code></td>
<td>
<p>number of composite variables to print before summarizing</p>
</td></tr>
<tr><td><code id="count_clusters_+3A_n_reduced">n_reduced</code></td>
<td>
<p>number of reduced variables to print before summarizing</p>
</td></tr>
<tr><td><code id="count_clusters_+3A_.round">.round</code></td>
<td>
<p>Should the minimum information be rounded?</p>
</td></tr>
<tr><td><code id="count_clusters_+3A_digits">digits</code></td>
<td>
<p>If <code>.round</code> is <code>TRUE</code>, to what digit should it be rounded?</p>
</td></tr>
</table>

<hr>
<h2 id='direct_distance'>Target based on minimum distance matrix</h2><span id='topic+direct_distance'></span><span id='topic+direct_distance_pearson'></span><span id='topic+direct_distance_spearman'></span>

<h3>Description</h3>

<p>Directors are functions that tell the partition algorithm what
to try to reduce.  <code><a href="#topic+as_director">as_director()</a></code> is a helper function to create new
directors to be used in <code>partitioner</code>s. <code>partitioner</code>s can be created with
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>direct_distance()</code> fits a distance matrix using either Pearson's or
Spearman's correlation and finds the pair with the smallest distance to
target. If the distance matrix already exists, <code>direct_distance()</code> only
fits the distances for any new reduced variables.
<code>direct_distance_pearson()</code> and <code>direct_distance_spearman()</code> are
convenience functions that directly call the type of distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct_distance(.partition_step, spearman = FALSE)

direct_distance_pearson(.partition_step)

direct_distance_spearman(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="direct_distance_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="direct_distance_+3A_spearman">spearman</code></td>
<td>
<p>Logical. Use Spearman's correlation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other directors: 
<code><a href="#topic+as_director">as_director</a>()</code>,
<code><a href="#topic+direct_k_cluster">direct_k_cluster</a>()</code>
</p>

<hr>
<h2 id='direct_k_cluster'>Target based on K-means clustering</h2><span id='topic+direct_k_cluster'></span>

<h3>Description</h3>

<p>Directors are functions that tell the partition algorithm what
to try to reduce.  <code><a href="#topic+as_director">as_director()</a></code> is a helper function to create new
directors to be used in <code>partitioner</code>s. <code>partitioner</code>s can be created with
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>direct_k_cluster()</code> assigns each variable to a cluster using
K-means. As the partition looks for the best reduction,
<code>direct_k_cluster()</code> iterates through values of <code>k</code> to assign clusters.
This search is handled by the binary search method by default and thus
does not necessarily need to fit every value of k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct_k_cluster(
  .partition_step,
  algorithm = c("armadillo", "Hartigan-Wong", "Lloyd", "Forgy", "MacQueen"),
  search = c("binary", "linear"),
  init_k = NULL,
  seed = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="direct_k_cluster_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="direct_k_cluster_+3A_algorithm">algorithm</code></td>
<td>
<p>The K-Means algorithm to use. The default is a fast version
of the LLoyd algorithm written in armadillo. The rest are options in
<code><a href="stats.html#topic+kmeans">kmeans()</a></code>. In general, armadillo is fastest, but the other algorithms can
be faster in high dimensions.</p>
</td></tr>
<tr><td><code id="direct_k_cluster_+3A_search">search</code></td>
<td>
<p>The search method. Binary search is generally more efficient
but linear search can be faster in very low dimensions.</p>
</td></tr>
<tr><td><code id="direct_k_cluster_+3A_init_k">init_k</code></td>
<td>
<p>The initial k to test. If <code>NULL</code>, then the initial k is the
threshold times the number of variables.</p>
</td></tr>
<tr><td><code id="direct_k_cluster_+3A_seed">seed</code></td>
<td>
<p>The seed to set for reproducibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other directors: 
<code><a href="#topic+as_director">as_director</a>()</code>,
<code><a href="#topic+direct_distance">direct_distance</a>()</code>
</p>

<hr>
<h2 id='direct_measure_reduce'>Apply a partitioner</h2><span id='topic+direct_measure_reduce'></span>

<h3>Description</h3>

<p><code>direct_measure_reduce()</code> works through the direct-measure-reduce steps of
the partition algorithm, applying the <code>partitioner</code> to the <code>partition_step</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct_measure_reduce(.partition_step, partitioner)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="direct_measure_reduce_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="direct_measure_reduce_+3A_partitioner">partitioner</code></td>
<td>
<p>a partitioner, as created from <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_partitioner">as_partitioner()</a></code>
</p>

<hr>
<h2 id='fill_in_missing'>Process reduced variables when missing data</h2><span id='topic+fill_in_missing'></span><span id='topic+swap_nans'></span>

<h3>Description</h3>

<p>Process reduced variables when missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_in_missing(x, .na, .fill = NA)

swap_nans(.x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_in_missing_+3A_x">x</code></td>
<td>
<p>a vector, the reduced variable</p>
</td></tr>
<tr><td><code id="fill_in_missing_+3A_.na">.na</code></td>
<td>
<p>a logical vector marking which are missing</p>
</td></tr>
<tr><td><code id="fill_in_missing_+3A_.fill">.fill</code></td>
<td>
<p>what to fill the missing locations with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length nrow(original data)
</p>
<p>a character vector
</p>

<hr>
<h2 id='filter_reduced'>Filter the reduced mappings</h2><span id='topic+filter_reduced'></span><span id='topic+unnest_reduced'></span>

<h3>Description</h3>

<p><code>filter_reduced()</code> and <code>unnest_reduced()</code> are convenience functions to
quickly retrieve the mappings for only the reduced variables.
<code>filter_reduced()</code> returns a nested <code>tibble</code> while <code>unnest_reduced()</code> unnests
it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_reduced(.partition)

unnest_reduced(.partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_reduced_+3A_.partition">.partition</code></td>
<td>
<p>a <code>partition</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tibble</code> with mapping key
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)
# fit partition
prt &lt;- partition(df, threshold = .6)


# A tibble: 3 x 4
filter_reduced(prt)

# A tibble: 9 x 4
unnest_reduced(prt)

</code></pre>

<hr>
<h2 id='find_algorithm'>Which kmeans algorithm to use?</h2><span id='topic+find_algorithm'></span><span id='topic+kmean_assignment_c'></span><span id='topic+kmean_assignment_r'></span>

<h3>Description</h3>

<p><code>find_algorithm()</code> returns a function to assign k-means cluster.
<code>kmean_assignment_r()</code> wraps around <code><a href="stats.html#topic+kmeans">kmeans()</a></code> to pull the correct
assignments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_algorithm(algorithm, seed)

kmean_assignment_c(.data, k, n_iter = 10L, verbose = FALSE, seed = 1L)

kmean_assignment_r(.data, k, algorithm = "Hartigan-Wong", seed = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_algorithm_+3A_algorithm">algorithm</code></td>
<td>
<p>the kmeans algorithm to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a kmeans function
</p>

<hr>
<h2 id='find_min_distance_variables'>Find the index of the pair with the smallest distance</h2><span id='topic+find_min_distance_variables'></span>

<h3>Description</h3>

<p>Find the index of the pair with the smallest distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_min_distance_variables(.x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_min_distance_variables_+3A_.x">.x</code></td>
<td>
<p>a distance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with the names of the minimum pair
</p>

<hr>
<h2 id='fit_distance_matrix'>Fit a distance matrix using correlation coefficients</h2><span id='topic+fit_distance_matrix'></span>

<h3>Description</h3>

<p>Fit a distance matrix using correlation coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_distance_matrix(.partition_step, spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_distance_matrix_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="fit_distance_matrix_+3A_spearman">spearman</code></td>
<td>
<p>Logical. Use Spearman's correlation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code> of size <code>p</code> by <code>p</code>
</p>

<hr>
<h2 id='get_indices'>Process mapping key to return from <code>partition()</code></h2><span id='topic+get_indices'></span><span id='topic+add_indices'></span><span id='topic+sort_mapping'></span>

<h3>Description</h3>

<p><code>add_indices()</code> uses <code>get_indices()</code> to add the variable positions to the
mapping key. <code>sort_mapping()</code> sorts the composite variables of each reduced
variable by their position in the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_indices(.partition_step)

add_indices(.partition_step)

sort_mapping(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_indices_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>

<hr>
<h2 id='guess_init_k'>Guess initial <code>k</code> based on threshold and <code>p</code></h2><span id='topic+guess_init_k'></span>

<h3>Description</h3>

<p>Guess initial <code>k</code> based on threshold and <code>p</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_init_k(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guess_init_k_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>

<hr>
<h2 id='icc'>Calculate the intraclass correlation coefficient</h2><span id='topic+icc'></span>

<h3>Description</h3>

<p><code>icc()</code> efficiently calculates the ICC for a numeric data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icc(.x, method = c("r", "c"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icc_+3A_.x">.x</code></td>
<td>
<p>a data set</p>
</td></tr>
<tr><td><code id="icc_+3A_method">method</code></td>
<td>
<p>The method source: both the pure R and C++ versions are efficient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of length 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
iris %&gt;%
  select_if(is.numeric) %&gt;%
  icc()
</code></pre>

<hr>
<h2 id='icc_r'>Calculate the intraclass correlation coefficient</h2><span id='topic+icc_r'></span>

<h3>Description</h3>

<p><code>icc_r()</code> efficiently calculates the ICC for a numeric data set in pure R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icc_r(.x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icc_r_+3A_.x">.x</code></td>
<td>
<p>a data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of length 1
</p>

<hr>
<h2 id='increase_hits'>Count and retrieve the number of metrics below threshold</h2><span id='topic+increase_hits'></span><span id='topic+get_hits'></span>

<h3>Description</h3>

<p>Count and retrieve the number of metrics below threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increase_hits(.partition_step)

get_hits(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="increase_hits_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='is_partition'>Is this object a partition?</h2><span id='topic+is_partition'></span>

<h3>Description</h3>

<p>Is this object a partition?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_partition(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_partition_+3A_x">x</code></td>
<td>
<p>an object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical: <code>TRUE</code> or <code>FALSE</code>
</p>

<hr>
<h2 id='is_partition_step'>Is this object a <code>partition_step</code>?</h2><span id='topic+is_partition_step'></span>

<h3>Description</h3>

<p>Is this object a <code>partition_step</code>?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_partition_step(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_partition_step_+3A_x">x</code></td>
<td>
<p>an object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical: <code>TRUE</code> or <code>FALSE</code>
</p>

<hr>
<h2 id='is_partitioner'>Is this object a partitioner?</h2><span id='topic+is_partitioner'></span>

<h3>Description</h3>

<p>Is this object a partitioner?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_partitioner(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_partitioner_+3A_x">x</code></td>
<td>
<p>an object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical: <code>TRUE</code> or <code>FALSE</code>
</p>

<hr>
<h2 id='is_same_function'>Are two functions the same?</h2><span id='topic+is_same_function'></span>

<h3>Description</h3>

<p><code>is_same_function()</code> compares functions correctly even if they are partialized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_same_function(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_same_function_+3A_x">x</code>, <code id="is_same_function_+3A_y">y</code></td>
<td>
<p>functions to compare</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical: <code>TRUE</code> or <code>FALSE</code>
</p>

<hr>
<h2 id='k_exhausted'>Have all values of <code>k</code> been checked for metric?</h2><span id='topic+k_exhausted'></span>

<h3>Description</h3>

<p>Have all values of <code>k</code> been checked for metric?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_exhausted(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k_exhausted_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical: <code>TRUE</code> or <code>FALSE</code>
</p>

<hr>
<h2 id='k_searching_forward'>Assess <code>k</code> search</h2><span id='topic+k_searching_forward'></span><span id='topic+k_searching_backward'></span><span id='topic+boundary_found'></span>

<h3>Description</h3>

<p><code>k_searching_forward()</code> and <code>k_searching_backward()</code> check the direction of
the <code>k</code> search metric. <code>boundary_found()</code> checks if the last value of <code>k</code> was
under the threshold while the current value is over
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_searching_forward(.partition_step)

k_searching_backward(.partition_step)

boundary_found(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k_searching_forward_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, <code>TRUE</code> or <code>FALSE</code>
</p>

<hr>
<h2 id='linear_k_search'>Search for best <code>k</code> using the linear search method</h2><span id='topic+linear_k_search'></span>

<h3>Description</h3>

<p>Search for best <code>k</code> using the linear search method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_k_search(.partition_step, n_hits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_k_search_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>

<hr>
<h2 id='map_partition'>Map a partition across a range of minimum information</h2><span id='topic+map_partition'></span>

<h3>Description</h3>

<p><code>map_partition()</code> fits <code>partition()</code> across a range of minimum information
values, specified in the <code>information</code> argument. The output is a tibble with
a row for each value of <code>information</code>, a summary of the partition, and a
<code>list-col</code> containing the <code>partition</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_partition(
  .data,
  partitioner = part_icc(),
  ...,
  information = seq(0.1, 0.5, by = 0.1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_partition_+3A_.data">.data</code></td>
<td>
<p>a data set to partition</p>
</td></tr>
<tr><td><code id="map_partition_+3A_partitioner">partitioner</code></td>
<td>
<p>the partitioner to use. The default is <code><a href="#topic+part_icc">part_icc()</a></code>.</p>
</td></tr>
<tr><td><code id="map_partition_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+partition">partition()</a></code></p>
</td></tr>
<tr><td><code id="map_partition_+3A_information">information</code></td>
<td>
<p>a vector of minimum information to fit in <code><a href="#topic+partition">partition()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)

map_partition(df, partitioner = part_pc1())

</code></pre>

<hr>
<h2 id='mapping_key'>Return partition mapping key</h2><span id='topic+mapping_key'></span><span id='topic+unnest_mappings'></span><span id='topic+mapping_groups'></span>

<h3>Description</h3>

<p><code>mapping_key()</code> returns a data frame with each reduced variable and its
mapping and information loss; the mapping and indices are represented as
<code>list-cols</code> (so there is one row per variable in the reduced data set).
<code>unnest_mappings()</code> unnests the list columns to return a tidy data frame.
<code>mapping_groups()</code> returns a list of mappings (either the variable names or
their column position).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapping_key(.partition)

unnest_mappings(.partition)

mapping_groups(.partition, indices = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapping_key_+3A_.partition">.partition</code></td>
<td>
<p>a <code>partition</code> object</p>
</td></tr>
<tr><td><code id="mapping_key_+3A_indices">indices</code></td>
<td>
<p>logical. Return just the indices instead of the names? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tibble</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)
# fit partition
prt &lt;- partition(df, threshold = .6)

# tibble: 6 x 4
mapping_key(prt)

# tibble: 12 x 4
unnest_mappings(prt)

# list: length 6
mapping_groups(prt)

</code></pre>

<hr>
<h2 id='matrix_is_exhausted'>Have all pairs of variables been checked for metric?</h2><span id='topic+matrix_is_exhausted'></span>

<h3>Description</h3>

<p>Have all pairs of variables been checked for metric?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_is_exhausted(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix_is_exhausted_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical: <code>TRUE</code> or <code>FALSE</code>
</p>

<hr>
<h2 id='measure_icc'>Measure the information loss of reduction using intraclass correlation
coefficient</h2><span id='topic+measure_icc'></span>

<h3>Description</h3>

<p>Metrics are functions that tell how much information would be
lost for a given reduction in the data. reduce.  <code><a href="#topic+as_measure">as_measure()</a></code> is a
helper function to create new metrics to be used in <code>partitioner</code>s.
<code>partitioner</code>s can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>measure_icc()</code> assesses information loss by calculating the
intraclass correlation coefficient for the target variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_icc(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_icc_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other metrics: 
<code><a href="#topic+as_measure">as_measure</a>()</code>,
<code><a href="#topic+measure_min_icc">measure_min_icc</a>()</code>,
<code><a href="#topic+measure_min_r2">measure_min_r2</a>()</code>,
<code><a href="#topic+measure_std_mutualinfo">measure_std_mutualinfo</a>()</code>,
<code><a href="#topic+measure_variance_explained">measure_variance_explained</a>()</code>
</p>

<hr>
<h2 id='measure_min_icc'>Measure the information loss of reduction using the minimum intraclass
correlation coefficient</h2><span id='topic+measure_min_icc'></span>

<h3>Description</h3>

<p>Metrics are functions that tell how much information would be
lost for a given reduction in the data. reduce.  <code><a href="#topic+as_measure">as_measure()</a></code> is a
helper function to create new metrics to be used in <code>partitioner</code>s.
<code>partitioner</code>s can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>measure_min_icc()</code> assesses information loss by calculating the
intraclass correlation coefficient for each set of the target variables and
finding their minimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_min_icc(.partition_step, search_method = c("binary", "linear"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_min_icc_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="measure_min_icc_+3A_search_method">search_method</code></td>
<td>
<p>The search method. Binary search is generally more efficient
but linear search can be faster in very low dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other metrics: 
<code><a href="#topic+as_measure">as_measure</a>()</code>,
<code><a href="#topic+measure_icc">measure_icc</a>()</code>,
<code><a href="#topic+measure_min_r2">measure_min_r2</a>()</code>,
<code><a href="#topic+measure_std_mutualinfo">measure_std_mutualinfo</a>()</code>,
<code><a href="#topic+measure_variance_explained">measure_variance_explained</a>()</code>
</p>

<hr>
<h2 id='measure_min_r2'>Measure the information loss of reduction using minimum R-squared</h2><span id='topic+measure_min_r2'></span>

<h3>Description</h3>

<p>Metrics are functions that tell how much information would be
lost for a given reduction in the data. reduce.  <code><a href="#topic+as_measure">as_measure()</a></code> is a
helper function to create new metrics to be used in <code>partitioner</code>s.
<code>partitioner</code>s can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>measure_min_r2()</code> assesses information loss by
calculating the minimum R-squared for the target variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_min_r2(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_min_r2_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other metrics: 
<code><a href="#topic+as_measure">as_measure</a>()</code>,
<code><a href="#topic+measure_icc">measure_icc</a>()</code>,
<code><a href="#topic+measure_min_icc">measure_min_icc</a>()</code>,
<code><a href="#topic+measure_std_mutualinfo">measure_std_mutualinfo</a>()</code>,
<code><a href="#topic+measure_variance_explained">measure_variance_explained</a>()</code>
</p>

<hr>
<h2 id='measure_std_mutualinfo'>Measure the information loss of reduction using standardized mutual
information</h2><span id='topic+measure_std_mutualinfo'></span>

<h3>Description</h3>

<p>Metrics are functions that tell how much information would be
lost for a given reduction in the data. reduce.  <code><a href="#topic+as_measure">as_measure()</a></code> is a
helper function to create new metrics to be used in <code>partitioner</code>s.
<code>partitioner</code>s can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>measure_std_mutualinfo()</code> assesses information loss by
calculating the standardized mutual information for the target variables.
See <code><a href="#topic+mutual_information">mutual_information()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_std_mutualinfo(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_std_mutualinfo_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other metrics: 
<code><a href="#topic+as_measure">as_measure</a>()</code>,
<code><a href="#topic+measure_icc">measure_icc</a>()</code>,
<code><a href="#topic+measure_min_icc">measure_min_icc</a>()</code>,
<code><a href="#topic+measure_min_r2">measure_min_r2</a>()</code>,
<code><a href="#topic+measure_variance_explained">measure_variance_explained</a>()</code>
</p>

<hr>
<h2 id='measure_variance_explained'>Measure the information loss of reduction using the variance explained.</h2><span id='topic+measure_variance_explained'></span>

<h3>Description</h3>

<p>Metrics are functions that tell how much information would be
lost for a given reduction in the data. reduce.  <code><a href="#topic+as_measure">as_measure()</a></code> is a
helper function to create new metrics to be used in <code>partitioner</code>s.
<code>partitioner</code>s can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>measure_variance_explained()</code> assesses information loss by
calculating the variance explained by the first component of a principal
components analysis. Because the PCA calculates the components and the
variance explained at the same time, if the reducer is
<code>reduce_first_component()</code>, then <code>measure_variance_explained()</code> will store
the first component for later use to avoid recalculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_variance_explained(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_variance_explained_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other metrics: 
<code><a href="#topic+as_measure">as_measure</a>()</code>,
<code><a href="#topic+measure_icc">measure_icc</a>()</code>,
<code><a href="#topic+measure_min_icc">measure_min_icc</a>()</code>,
<code><a href="#topic+measure_min_r2">measure_min_r2</a>()</code>,
<code><a href="#topic+measure_std_mutualinfo">measure_std_mutualinfo</a>()</code>
</p>

<hr>
<h2 id='mutual_information'>Calculate the standardized mutual information of a data set</h2><span id='topic+mutual_information'></span>

<h3>Description</h3>

<p><code>mutual_information</code> calculate the standardized mutual information of a data
set using the <code>infotheo</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual_information(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutual_information_+3A_.data">.data</code></td>
<td>
<p>a dataframe of numeric values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the standardized MI and the scaled row means
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
iris %&gt;%
  select_if(is.numeric) %&gt;%
  mutual_information()

</code></pre>

<hr>
<h2 id='part_icc'>Partitioner: distance, ICC, scaled means</h2><span id='topic+part_icc'></span>

<h3>Description</h3>

<p>Partitioners are functions that tell the partition algorithm 1)
what to try to reduce 2) how to measure how much information is lost from
the reduction and 3) how to reduce the data. In partition, functions that
handle 1) are called directors, functions that handle 2) are called
metrics,  and functions that handle 3) are called reducers. partition has a
number of pre-specified partitioners for agglomerative data reduction.
Custom partitioners can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p>Pass <code>partitioner</code> objects to the <code>partitioner</code> argument of <code><a href="#topic+partition">partition()</a></code>.
</p>
<p><code>part_icc()</code> uses the following direct-measure-reduce approach:
</p>

<ul>
<li> <p><strong>direct</strong>: <code>direct_distance()</code>, Minimum Distance
</p>
</li>
<li> <p><strong>measure</strong>: <code>measure_icc()</code>, Intraclass Correlation
</p>
</li>
<li> <p><strong>reduce</strong>: <code>reduce_scaled_mean()</code>, Scaled Row Means
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>part_icc(spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_icc_+3A_spearman">spearman</code></td>
<td>
<p>logical. Use Spearman's correlation for distance matrix?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partitioner</code>
</p>


<h3>See Also</h3>

<p>Other partitioners: 
<code><a href="#topic+as_partitioner">as_partitioner</a>()</code>,
<code><a href="#topic+part_kmeans">part_kmeans</a>()</code>,
<code><a href="#topic+part_minr2">part_minr2</a>()</code>,
<code><a href="#topic+part_pc1">part_pc1</a>()</code>,
<code><a href="#topic+part_stdmi">part_stdmi</a>()</code>,
<code><a href="#topic+replace_partitioner">replace_partitioner</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)

# fit partition using part_icc()
partition(df, threshold = .6, partitioner = part_icc())

</code></pre>

<hr>
<h2 id='part_kmeans'>Partitioner: K-means, ICC, scaled means</h2><span id='topic+part_kmeans'></span>

<h3>Description</h3>

<p>Partitioners are functions that tell the partition algorithm 1)
what to try to reduce 2) how to measure how much information is lost from
the reduction and 3) how to reduce the data. In partition, functions that
handle 1) are called directors, functions that handle 2) are called
metrics,  and functions that handle 3) are called reducers. partition has a
number of pre-specified partitioners for agglomerative data reduction.
Custom partitioners can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p>Pass <code>partitioner</code> objects to the <code>partitioner</code> argument of <code><a href="#topic+partition">partition()</a></code>.
</p>
<p><code>part_kmeans()</code> uses the following direct-measure-reduce approach:
</p>

<ul>
<li> <p><strong>direct</strong>: <code>direct_k_cluster()</code>, K-Means Clusters
</p>
</li>
<li> <p><strong>measure</strong>: <code>measure_min_icc()</code>, Minimum Intraclass Correlation
</p>
</li>
<li> <p><strong>reduce</strong>: <code>reduce_kmeans()</code>, Scaled Row Means
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>part_kmeans(
  algorithm = c("armadillo", "Hartigan-Wong", "Lloyd", "Forgy", "MacQueen"),
  search = c("binary", "linear"),
  init_k = NULL,
  n_hits = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_kmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>The K-Means algorithm to use. The default is a fast version
of the LLoyd algorithm written in armadillo. The rest are options in
<code><a href="stats.html#topic+kmeans">kmeans()</a></code>. In general, armadillo is fastest, but the other algorithms can
be faster in high dimensions.</p>
</td></tr>
<tr><td><code id="part_kmeans_+3A_search">search</code></td>
<td>
<p>The search method. Binary search is generally more efficient
but linear search can be faster in very low dimensions.</p>
</td></tr>
<tr><td><code id="part_kmeans_+3A_init_k">init_k</code></td>
<td>
<p>The initial k to test. If <code>NULL</code>, then the initial k is the
threshold times the number of variables.</p>
</td></tr>
<tr><td><code id="part_kmeans_+3A_n_hits">n_hits</code></td>
<td>
<p>In linear search method, the number of iterations that should
be under the threshold before reducing; useful for preventing false
positives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partitioner</code>
</p>


<h3>See Also</h3>

<p>Other partitioners: 
<code><a href="#topic+as_partitioner">as_partitioner</a>()</code>,
<code><a href="#topic+part_icc">part_icc</a>()</code>,
<code><a href="#topic+part_minr2">part_minr2</a>()</code>,
<code><a href="#topic+part_pc1">part_pc1</a>()</code>,
<code><a href="#topic+part_stdmi">part_stdmi</a>()</code>,
<code><a href="#topic+replace_partitioner">replace_partitioner</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)

# fit partition using part_kmeans()
partition(df, threshold = .6, partitioner = part_kmeans())

</code></pre>

<hr>
<h2 id='part_minr2'>Partitioner: distance, minimum R-squared, scaled means</h2><span id='topic+part_minr2'></span>

<h3>Description</h3>

<p>Partitioners are functions that tell the partition algorithm 1)
what to try to reduce 2) how to measure how much information is lost from
the reduction and 3) how to reduce the data. In partition, functions that
handle 1) are called directors, functions that handle 2) are called
metrics,  and functions that handle 3) are called reducers. partition has a
number of pre-specified partitioners for agglomerative data reduction.
Custom partitioners can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p>Pass <code>partitioner</code> objects to the <code>partitioner</code> argument of <code><a href="#topic+partition">partition()</a></code>.
</p>
<p><code>part_minr2()</code> uses the following direct-measure-reduce approach:
</p>

<ul>
<li> <p><strong>direct</strong>: <code>direct_distance()</code>, Minimum Distance
</p>
</li>
<li> <p><strong>measure</strong>: <code>measure_min_r2()</code>, Minimum R-Squared
</p>
</li>
<li> <p><strong>reduce</strong>: <code>reduce_scaled_mean()</code>, Scaled Row Means
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>part_minr2(spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_minr2_+3A_spearman">spearman</code></td>
<td>
<p>logical. Use Spearman's correlation for distance matrix?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partitioner</code>
</p>


<h3>See Also</h3>

<p>Other partitioners: 
<code><a href="#topic+as_partitioner">as_partitioner</a>()</code>,
<code><a href="#topic+part_icc">part_icc</a>()</code>,
<code><a href="#topic+part_kmeans">part_kmeans</a>()</code>,
<code><a href="#topic+part_pc1">part_pc1</a>()</code>,
<code><a href="#topic+part_stdmi">part_stdmi</a>()</code>,
<code><a href="#topic+replace_partitioner">replace_partitioner</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)

# fit partition using part_minr2()
partition(df, threshold = .6, partitioner = part_minr2())

</code></pre>

<hr>
<h2 id='part_pc1'>Partitioner: distance, first principal component, scaled means</h2><span id='topic+part_pc1'></span>

<h3>Description</h3>

<p>Partitioners are functions that tell the partition algorithm 1)
what to try to reduce 2) how to measure how much information is lost from
the reduction and 3) how to reduce the data. In partition, functions that
handle 1) are called directors, functions that handle 2) are called
metrics,  and functions that handle 3) are called reducers. partition has a
number of pre-specified partitioners for agglomerative data reduction.
Custom partitioners can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p>Pass <code>partitioner</code> objects to the <code>partitioner</code> argument of <code><a href="#topic+partition">partition()</a></code>.
</p>
<p><code>part_pc1()</code> uses the following direct-measure-reduce approach:
</p>

<ul>
<li> <p><strong>direct</strong>: <code>direct_distance()</code>, Minimum Distance
</p>
</li>
<li> <p><strong>measure</strong>: <code>measure_variance_explained()</code>, Variance Explained (PCA)
</p>
</li>
<li> <p><strong>reduce</strong>: <code>reduce_first_component()</code>, First Principal Component
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>part_pc1(spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_pc1_+3A_spearman">spearman</code></td>
<td>
<p>logical. Use Spearman's correlation for distance matrix?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partitioner</code>
</p>


<h3>See Also</h3>

<p>Other partitioners: 
<code><a href="#topic+as_partitioner">as_partitioner</a>()</code>,
<code><a href="#topic+part_icc">part_icc</a>()</code>,
<code><a href="#topic+part_kmeans">part_kmeans</a>()</code>,
<code><a href="#topic+part_minr2">part_minr2</a>()</code>,
<code><a href="#topic+part_stdmi">part_stdmi</a>()</code>,
<code><a href="#topic+replace_partitioner">replace_partitioner</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)

# fit partition using part_pc1()
partition(df, threshold = .6, partitioner = part_pc1())

</code></pre>

<hr>
<h2 id='part_stdmi'>Partitioner: distance, mutual information, scaled means</h2><span id='topic+part_stdmi'></span>

<h3>Description</h3>

<p>Partitioners are functions that tell the partition algorithm 1)
what to try to reduce 2) how to measure how much information is lost from
the reduction and 3) how to reduce the data. In partition, functions that
handle 1) are called directors, functions that handle 2) are called
metrics,  and functions that handle 3) are called reducers. partition has a
number of pre-specified partitioners for agglomerative data reduction.
Custom partitioners can be created with <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p>Pass <code>partitioner</code> objects to the <code>partitioner</code> argument of <code><a href="#topic+partition">partition()</a></code>.
</p>
<p><code>part_stdmi()</code> uses the following direct-measure-reduce approach:
</p>

<ul>
<li> <p><strong>direct</strong>: <code>direct_distance()</code>, Minimum Distance
</p>
</li>
<li> <p><strong>measure</strong>: <code>measure_std_mutualinfo()</code>, Standardized Mutual Information
</p>
</li>
<li> <p><strong>reduce</strong>: <code>reduce_scaled_mean()</code>, Scaled Row Means
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>part_stdmi(spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_stdmi_+3A_spearman">spearman</code></td>
<td>
<p>logical. Use Spearman's correlation for distance matrix?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partitioner</code>
</p>


<h3>See Also</h3>

<p>Other partitioners: 
<code><a href="#topic+as_partitioner">as_partitioner</a>()</code>,
<code><a href="#topic+part_icc">part_icc</a>()</code>,
<code><a href="#topic+part_kmeans">part_kmeans</a>()</code>,
<code><a href="#topic+part_minr2">part_minr2</a>()</code>,
<code><a href="#topic+part_pc1">part_pc1</a>()</code>,
<code><a href="#topic+replace_partitioner">replace_partitioner</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)

# fit partition using part_stdmi()
partition(df, threshold = .6, partitioner = part_stdmi())

</code></pre>

<hr>
<h2 id='partition'>Agglomerative partitioning</h2><span id='topic+partition'></span>

<h3>Description</h3>

<p><code>partition()</code> reduces data while minimizing information loss
using an agglomerative partitioning algorithm. The partition algorithm is
fast and flexible: at every iteration, <code>partition()</code> uses an approach
called Direct-Measure-Reduce (see Details) to create new variables that
maintain the user-specified minimum level of information. Each reduced
variable is also interpretable: the original variables map to one and only
one variable in the reduced data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(
  .data,
  threshold,
  partitioner = part_icc(),
  tolerance = 1e-04,
  niter = NULL,
  x = "reduced_var",
  .sep = "_"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partition_+3A_.data">.data</code></td>
<td>
<p>a data.frame to partition</p>
</td></tr>
<tr><td><code id="partition_+3A_threshold">threshold</code></td>
<td>
<p>the minimum proportion of information explained by a reduced
variable; <code>threshold</code> sets a boundary for information loss because each
reduced variable must explain at least as much as <code>threshold</code> as measured
by the metric.</p>
</td></tr>
<tr><td><code id="partition_+3A_partitioner">partitioner</code></td>
<td>
<p>a <code>partitioner</code>. See the <code style="white-space: pre;">&#8288;part_*()&#8288;</code> functions and
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.</p>
</td></tr>
<tr><td><code id="partition_+3A_tolerance">tolerance</code></td>
<td>
<p>a small tolerance within the threshold; if a reduction is
within the threshold plus/minus the tolerance, it will reduce.</p>
</td></tr>
<tr><td><code id="partition_+3A_niter">niter</code></td>
<td>
<p>the number of iterations. By default, it is calculated as 20% of
the number of variables or 10, whichever is larger.</p>
</td></tr>
<tr><td><code id="partition_+3A_x">x</code></td>
<td>
<p>the prefix of the new variable names</p>
</td></tr>
<tr><td><code id="partition_+3A_.sep">.sep</code></td>
<td>
<p>a character vector that separates <code>x</code> from the number (e.g.
&quot;reduced_var_1&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>partition()</code> uses an approach called Direct-Measure-Reduce.
Directors tell the partition algorithm what to reduce, metrics tell it
whether or not there will be enough information left after the reduction,
and reducers tell it how to reduce the data. Together these are called a
partitioner. The default partitioner for <code>partition()</code> is <code><a href="#topic+part_icc">part_icc()</a></code>:
it finds pairs of variables to reduce by finding the pair with the minimum
distance between them, it measures information loss through ICC, and it
reduces data using scaled row means. There are several other partitioners
available (<code style="white-space: pre;">&#8288;part_*()&#8288;</code> functions), and you can create custom partitioners
with <code><a href="#topic+as_partitioner">as_partitioner()</a></code> and <code><a href="#topic+replace_partitioner">replace_partitioner()</a></code>.
</p>


<h3>Value</h3>

<p>a <code>partition</code> object
</p>


<h3>References</h3>

<p>Millstein, Joshua, Francesca Battaglin, Malcolm Barrett, Shu Cao,
Wu Zhang, Sebastian Stintzing, Volker Heinemann, and Heinz-Josef Lenz.
2020. Partition: A Surjective Mapping Approach for Dimensionality
Reduction. <em>Bioinformatics</em> 36 (3):
https://doi.org/67681.10.1093/bioinformatics/btz661.
</p>
<p>Barrett, Malcolm and Joshua Millstein (2020). partition: A fast
and flexible framework for data reduction in R. Journal of Open Source
Software, 5(47), 1991, https://doi.org/10.21105/joss.01991
</p>


<h3>See Also</h3>

<p><code><a href="#topic+part_icc">part_icc()</a></code>, <code><a href="#topic+part_kmeans">part_kmeans()</a></code>, <code><a href="#topic+part_minr2">part_minr2()</a></code>, <code><a href="#topic+part_pc1">part_pc1()</a></code>,
<code><a href="#topic+part_stdmi">part_stdmi()</a></code>, <code><a href="#topic+as_partitioner">as_partitioner()</a></code>, <code><a href="#topic+replace_partitioner">replace_partitioner()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)

#  don't accept reductions where information &lt; .6
prt &lt;- partition(df, threshold = .6)
prt

# return reduced data
partition_scores(prt)

# access mapping keys
mapping_key(prt)
unnest_mappings(prt)

# use a lower threshold of information loss
partition(df, threshold = .5, partitioner = part_kmeans())

# use a custom partitioner
part_icc_rowmeans &lt;- replace_partitioner(part_icc, reduce = as_reducer(rowMeans))
partition(df, threshold = .6, partitioner = part_icc_rowmeans)

</code></pre>

<hr>
<h2 id='partition_scores'>Return the reduced data from a partition</h2><span id='topic+partition_scores'></span><span id='topic+fitted.partition'></span>

<h3>Description</h3>

<p>The reduced data is stored as <code>reduced_data</code> in the partition object and can
thus be returned by subsetting <code>object$reduced_data</code>. Alternatively, the
functions <code>partition_score()</code> and <code>fitted()</code> also return the reduced data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_scores(object, ...)

## S3 method for class 'partition'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partition_scores_+3A_object">object</code></td>
<td>
<p>a <code>partition</code> object</p>
</td></tr>
<tr><td><code id="partition_scores_+3A_...">...</code></td>
<td>
<p>not currently used (for S3 consistency with <code>fitted()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble containing the reduced data for the partition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)
# fit partition
prt &lt;- partition(df, threshold = .6)


# three ways to retrieve reduced data
partition_scores(prt)
fitted(prt)
prt$reduced_data

</code></pre>

<hr>
<h2 id='paste_director'>Lookup partitioner types to print in English</h2><span id='topic+paste_director'></span><span id='topic+paste_metric'></span><span id='topic+paste_reducer'></span>

<h3>Description</h3>

<p>Lookup partitioner types to print in English
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_director(x)

paste_metric(x)

paste_reducer(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paste_director_+3A_x">x</code></td>
<td>
<p>the function for which to find a description</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a description of the parts of the partitioner
</p>

<hr>
<h2 id='permute_df'>Permute a data set</h2><span id='topic+permute_df'></span>

<h3>Description</h3>

<p><code>permute_df()</code> permutes a data set: it randomizes the order within each
variable, which breaks any association between them. Permutation is useful
for testing against null statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_df(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permute_df_+3A_.data">.data</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a permuted <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>permute_df(iris)
</code></pre>

<hr>
<h2 id='plot_area_clusters'>Plot partitions</h2><span id='topic+plot_area_clusters'></span><span id='topic+plot_stacked_area_clusters'></span><span id='topic+plot_ncluster'></span><span id='topic+plot_information'></span>

<h3>Description</h3>

<p><code>plot_stacked_area_clusters()</code> and <code>plot_area_clusters()</code> plot the partition
against a permuted partition. <code>plot_ncluster()</code> plots the number of
variables per cluster. If <code>.partition</code> is the result of <code><a href="#topic+map_partition">map_partition()</a></code> or
<code><a href="#topic+test_permutation">test_permutation()</a></code>, <code>plot_ncluster()</code> facets the plot by each <code>partition</code>.
<code>plot_information()</code> plots a histogram or density plot of the information of
each variable in the <code>partition</code>. If <code>.partition</code> is the result of
<code><a href="#topic+map_partition">map_partition()</a></code> or <code><a href="#topic+test_permutation">test_permutation()</a></code>, <code>plot_information()</code> plots a
scatterplot of the targeted vs. observed information with a 45 degree line
indicating perfect alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_area_clusters(
  .data,
  partitioner = part_icc(),
  information = seq(0.1, 0.5, length.out = 25),
  ...,
  obs_color = "#E69F00",
  perm_color = "#56B4E9"
)

plot_stacked_area_clusters(
  .data,
  partitioner = part_icc(),
  information = seq(0.1, 0.5, length.out = 25),
  ...,
  stack_colors = c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00")
)

plot_ncluster(
  .partition,
  show_n = 100,
  fill = "#0172B1",
  color = NA,
  labeller = "target information:"
)

plot_information(
  .partition,
  fill = "#0172B1",
  color = NA,
  geom = ggplot2::geom_density
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_area_clusters_+3A_.data">.data</code></td>
<td>
<p>a data.frame to partition</p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_partitioner">partitioner</code></td>
<td>
<p>a <code>partitioner</code>. See the <code style="white-space: pre;">&#8288;part_*()&#8288;</code> functions and
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_information">information</code></td>
<td>
<p>a vector of minimum information to fit in <code><a href="#topic+partition">partition()</a></code></p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+partition">partition()</a></code></p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_obs_color">obs_color</code></td>
<td>
<p>the color of the observed partition</p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_perm_color">perm_color</code></td>
<td>
<p>the color of the permuted partition</p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_stack_colors">stack_colors</code></td>
<td>
<p>the colors of the cluster sizes</p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_.partition">.partition</code></td>
<td>
<p>either a <code>partition</code> or a <code>tibble</code>, the result of
<code><a href="#topic+map_partition">map_partition()</a></code> or <code><a href="#topic+test_permutation">test_permutation()</a></code></p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_show_n">show_n</code></td>
<td>
<p>the number of reduced variables to plot</p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_fill">fill</code></td>
<td>
<p>the color of the fill for <code>geom</code></p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_color">color</code></td>
<td>
<p>the color of the <code>geom</code></p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_labeller">labeller</code></td>
<td>
<p>the facet label</p>
</td></tr>
<tr><td><code id="plot_area_clusters_+3A_geom">geom</code></td>
<td>
<p>the <code>geom</code> to use. The default is <code>geom_density</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
df &lt;- simulate_block_data(c(3, 4, 5), lower_corr = .4, upper_corr = .6, n = 100)

df %&gt;%
  partition(.6, partitioner = part_pc1()) %&gt;%
  plot_ncluster()

</code></pre>

<hr>
<h2 id='plot_permutation'>Plot permutation tests</h2><span id='topic+plot_permutation'></span>

<h3>Description</h3>

<p><code>plot_permutation()</code> takes the results of <code><a href="#topic+test_permutation">test_permutation()</a></code> and plots the
distribution of permuted partitions compared to the observed partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_permutation(
  permutations,
  .plot = c("information", "nclusters", "nreduced"),
  labeller = "target information:",
  perm_color = "#56B4EA",
  obs_color = "#CC78A8",
  geom = ggplot2::geom_density
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_permutation_+3A_permutations">permutations</code></td>
<td>
<p>a <code>tibble</code>, the result of <code><a href="#topic+test_permutation">test_permutation()</a></code></p>
</td></tr>
<tr><td><code id="plot_permutation_+3A_.plot">.plot</code></td>
<td>
<p>the variable to plot: observed information, the number of
clusters created, or the number of observed variables reduced</p>
</td></tr>
<tr><td><code id="plot_permutation_+3A_labeller">labeller</code></td>
<td>
<p>the facet label</p>
</td></tr>
<tr><td><code id="plot_permutation_+3A_perm_color">perm_color</code></td>
<td>
<p>the color of the permutation fill</p>
</td></tr>
<tr><td><code id="plot_permutation_+3A_obs_color">obs_color</code></td>
<td>
<p>the color of the observed statistic line</p>
</td></tr>
<tr><td><code id="plot_permutation_+3A_geom">geom</code></td>
<td>
<p>the <code>geom</code> to use. The default is <code>geom_density</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot
</p>

<hr>
<h2 id='pull_composite_variables'>Access mapping variables</h2><span id='topic+pull_composite_variables'></span><span id='topic+expand_mappings'></span><span id='topic+get_names'></span>

<h3>Description</h3>

<p><code>pull_composite_variables()</code> takes a target and finds all the composite
variables (e.g. if a reduced variable is a target, it finds all the variables
the reduced variable is created from). <code>expand_mappings()</code> extracts the
composite variables of a given variable. <code>get_names()</code> finds the variable
names for a list of column positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_composite_variables(.partition_step)

expand_mappings(x, .mapping_key)

get_names(.partition_step, target_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull_composite_variables_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="pull_composite_variables_+3A_.mapping_key">.mapping_key</code></td>
<td>
<p>a mapping key</p>
</td></tr>
<tr><td><code id="pull_composite_variables_+3A_target_list">target_list</code></td>
<td>
<p>a list of composite variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing mappings
</p>

<hr>
<h2 id='reduce_cluster'>Reduce a target</h2><span id='topic+reduce_cluster'></span><span id='topic+map_cluster'></span>

<h3>Description</h3>

<p><code>reduce_cluster()</code> and <code>map_cluster()</code> apply the data reduction to the targets
found in the director step. They only do so if the metric is above the
threshold, however. <code>reduce_cluster()</code> is for functions that return vectors
while <code>map_cluster()</code> is for functions that return <code>data.frames</code>. If you're
using <code><a href="#topic+as_reducer">as_reducer()</a></code>, there's no need to call these functions directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_cluster(.partition_step, .f, first_match = FALSE)

map_cluster(.partition_step, .f, rewind = FALSE, first_match = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_cluster_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="reduce_cluster_+3A_.f">.f</code></td>
<td>
<p>a function to reduce the data to either a vector or a data.frame</p>
</td></tr>
<tr><td><code id="reduce_cluster_+3A_first_match">first_match</code></td>
<td>
<p>logical. Should the partition algorithm stop when it finds
a reduction that is equal to the threshold? Default is <code>TRUE</code> for reducers
that return a <code>data.frame</code> and <code>FALSE</code> for reducers that return a vector</p>
</td></tr>
<tr><td><code id="reduce_cluster_+3A_rewind">rewind</code></td>
<td>
<p>logical. Should the last target be used instead of the
current target?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
reduce_row_means &lt;- function(.partition_step, .data) {
  reduce_cluster(.partition_step, rowMeans)
}

replace_partitioner(
  part_icc,
  reduce = reduce_row_means
)

</code></pre>

<hr>
<h2 id='reduce_first_component'>Reduce selected variables to first principal component</h2><span id='topic+reduce_first_component'></span>

<h3>Description</h3>

<p>Reducers are functions that tell the partition algorithm how
to reduce the data. <code><a href="#topic+as_reducer">as_reducer()</a></code> is a helper function to create new
reducers to be used in <code>partitioner</code>s. <code>partitioner</code>s can be created with
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>reduce_first_component()</code> returns the first component from the
principal components analysis of the target variables. Because the PCA
calculates the components and the variance explained at the same time, if
the metric is <code>measure_variance_explained()</code>, that function will store the
first component for use in <code>reduce_first_component()</code> to avoid
recalculation. If the partitioner uses a different metric, the first
component will be calculated by <code>reduce_first_component()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_first_component(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_first_component_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other reducers: 
<code><a href="#topic+as_reducer">as_reducer</a>()</code>,
<code><a href="#topic+reduce_kmeans">reduce_kmeans</a>()</code>,
<code><a href="#topic+reduce_scaled_mean">reduce_scaled_mean</a>()</code>
</p>

<hr>
<h2 id='reduce_kmeans'>Reduce selected variables to scaled means</h2><span id='topic+reduce_kmeans'></span>

<h3>Description</h3>

<p>Reducers are functions that tell the partition algorithm how
to reduce the data. <code><a href="#topic+as_reducer">as_reducer()</a></code> is a helper function to create new
reducers to be used in <code>partitioner</code>s. <code>partitioner</code>s can be created with
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>reduce_kmeans()</code> is efficient in that it doesn't reduce until
the closest <code>k</code> to the information threshold is found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_kmeans(.partition_step, search = c("binary", "linear"), n_hits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_kmeans_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="reduce_kmeans_+3A_search">search</code></td>
<td>
<p>The search method. Binary search is generally more efficient
but linear search can be faster in very low dimensions.</p>
</td></tr>
<tr><td><code id="reduce_kmeans_+3A_n_hits">n_hits</code></td>
<td>
<p>In linear search method, the number of iterations that should
be under the threshold before reducing; useful for preventing false
positives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other reducers: 
<code><a href="#topic+as_reducer">as_reducer</a>()</code>,
<code><a href="#topic+reduce_first_component">reduce_first_component</a>()</code>,
<code><a href="#topic+reduce_scaled_mean">reduce_scaled_mean</a>()</code>
</p>

<hr>
<h2 id='reduce_mappings'>Create a mapping key out of a list of targets</h2><span id='topic+reduce_mappings'></span>

<h3>Description</h3>

<p>Create a mapping key out of a list of targets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_mappings(.partition_step, target_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_mappings_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="reduce_mappings_+3A_target_list">target_list</code></td>
<td>
<p>a list of composite variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tibble</code>, the mapping key
</p>

<hr>
<h2 id='reduce_scaled_mean'>Reduce selected variables to scaled means</h2><span id='topic+reduce_scaled_mean'></span>

<h3>Description</h3>

<p>Reducers are functions that tell the partition algorithm how
to reduce the data. <code><a href="#topic+as_reducer">as_reducer()</a></code> is a helper function to create new
reducers to be used in <code>partitioner</code>s. <code>partitioner</code>s can be created with
<code><a href="#topic+as_partitioner">as_partitioner()</a></code>.
</p>
<p><code>reduce_scaled_mean()</code> returns the scaled row means of the
target variables to reduce.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_scaled_mean(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_scaled_mean_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>


<h3>See Also</h3>

<p>Other reducers: 
<code><a href="#topic+as_reducer">as_reducer</a>()</code>,
<code><a href="#topic+reduce_first_component">reduce_first_component</a>()</code>,
<code><a href="#topic+reduce_kmeans">reduce_kmeans</a>()</code>
</p>

<hr>
<h2 id='replace_partitioner'>Replace the director, metric, or reducer for a partitioner</h2><span id='topic+replace_partitioner'></span>

<h3>Description</h3>

<p>Replace the director, metric, or reducer for a partitioner
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_partitioner(partitioner, direct = NULL, measure = NULL, reduce = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_partitioner_+3A_partitioner">partitioner</code></td>
<td>
<p>a <code>partitioner</code></p>
</td></tr>
<tr><td><code id="replace_partitioner_+3A_direct">direct</code></td>
<td>
<p>a function that directs, possibly created by <code><a href="#topic+as_director">as_director()</a></code></p>
</td></tr>
<tr><td><code id="replace_partitioner_+3A_measure">measure</code></td>
<td>
<p>a function that measures, possibly created by <code><a href="#topic+as_measure">as_measure()</a></code></p>
</td></tr>
<tr><td><code id="replace_partitioner_+3A_reduce">reduce</code></td>
<td>
<p>a function that reduces, possibly created by <code><a href="#topic+as_reducer">as_reducer()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partitioner</code>
</p>


<h3>See Also</h3>

<p>Other partitioners: 
<code><a href="#topic+as_partitioner">as_partitioner</a>()</code>,
<code><a href="#topic+part_icc">part_icc</a>()</code>,
<code><a href="#topic+part_kmeans">part_kmeans</a>()</code>,
<code><a href="#topic+part_minr2">part_minr2</a>()</code>,
<code><a href="#topic+part_pc1">part_pc1</a>()</code>,
<code><a href="#topic+part_stdmi">part_stdmi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
replace_partitioner(
  part_icc,
  reduce = as_reducer(rowMeans)
)

</code></pre>

<hr>
<h2 id='return_if_single'>Reduce targets if more than one variable, return otherwise</h2><span id='topic+return_if_single'></span>

<h3>Description</h3>

<p>Reduce targets if more than one variable, return otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_if_single(.x, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="return_if_single_+3A_.x">.x</code></td>
<td>
<p>a <code>data.frame</code> containing the targets to reduce</p>
</td></tr>
<tr><td><code id="return_if_single_+3A_.f">.f</code></td>
<td>
<p>a reduction function to apply</p>
</td></tr>
<tr><td><code id="return_if_single_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>.f</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector, the reduced or original variable
</p>

<hr>
<h2 id='rewind_target'>Set target to last value</h2><span id='topic+rewind_target'></span>

<h3>Description</h3>

<p>Set target to last value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewind_target(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewind_target_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>

<hr>
<h2 id='scaled_mean'>Average and scale rows in a <code>data.frame</code></h2><span id='topic+scaled_mean'></span>

<h3>Description</h3>

<p><code>scaled_mean()</code> calculates scaled row means for a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaled_mean(.x, method = c("r", "c"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaled_mean_+3A_.x">.x</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="scaled_mean_+3A_method">method</code></td>
<td>
<p>The method source: both the pure R and C++ versions are efficient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
iris %&gt;%
  select_if(is.numeric) %&gt;%
  scaled_mean()

</code></pre>

<hr>
<h2 id='search_k'>Search for the best <code>k</code></h2><span id='topic+search_k'></span>

<h3>Description</h3>

<p>Search for the best <code>k</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_k(.partition_step, search_method = c("binary", "linear"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_k_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="search_k_+3A_search_method">search_method</code></td>
<td>
<p>The search method. Binary search is generally more efficient
but linear search can be faster in very low dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>

<hr>
<h2 id='simplify_names'>Simplify reduced variable names</h2><span id='topic+simplify_names'></span>

<h3>Description</h3>

<p>Simplify reduced variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_names(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simplify_names_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>partition_step</code> object
</p>

<hr>
<h2 id='simulate_block_data'>Simulate correlated blocks of variables</h2><span id='topic+simulate_block_data'></span>

<h3>Description</h3>

<p><code>simulate_block_data()</code> creates a dataset of blocks of data where variables
within each block are correlated. The correlation for each pair of variables
is sampled uniformly from <code>lower_corr</code> to <code>upper_corr</code>, and the values of
each are sampled using <code><a href="MASS.html#topic+mvrnorm">MASS::mvrnorm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_block_data(
  block_sizes,
  lower_corr,
  upper_corr,
  n,
  block_name = "block",
  sep = "_",
  var_name = "x"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_block_data_+3A_block_sizes">block_sizes</code></td>
<td>
<p>a vector of block sizes. The size of each block is the
number of variables within it.</p>
</td></tr>
<tr><td><code id="simulate_block_data_+3A_lower_corr">lower_corr</code></td>
<td>
<p>the lower bound of the correlation within each block</p>
</td></tr>
<tr><td><code id="simulate_block_data_+3A_upper_corr">upper_corr</code></td>
<td>
<p>the upper bound of the correlation within each block</p>
</td></tr>
<tr><td><code id="simulate_block_data_+3A_n">n</code></td>
<td>
<p>the number of observations or rows</p>
</td></tr>
<tr><td><code id="simulate_block_data_+3A_block_name">block_name</code></td>
<td>
<p>description prepended to the variable to indicate the block it belongs to</p>
</td></tr>
<tr><td><code id="simulate_block_data_+3A_sep">sep</code></td>
<td>
<p>a character, what to separate the variable names with</p>
</td></tr>
<tr><td><code id="simulate_block_data_+3A_var_name">var_name</code></td>
<td>
<p>the name of the variable within the block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tibble</code> with <code>sum(block_sizes)</code> columns and <code>n</code> rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a 100 x 15 data set with 3 blocks
simulate_block_data(
  block_sizes = rep(5, 3),
  lower_corr = .4,
  upper_corr = .6,
  n = 100
)
</code></pre>

<hr>
<h2 id='summarize_partitions'>Summarize and map partitions and permutations</h2><span id='topic+summarize_partitions'></span><span id='topic+map_permutations'></span>

<h3>Description</h3>

<p><code>summarize_partitions()</code> summarizes a <code>partition</code> and attaches it in a
<code>list-col</code>. <code>map_permutations()</code> processes <code><a href="#topic+map_partition">map_partition()</a></code> for a set of
permuted data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_partitions(.partition, .information)

map_permutations(
  .data,
  partitioner = part_icc(),
  ...,
  information = seq(0.1, 0.5, by = 0.1),
  nperm = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_partitions_+3A_.data">.data</code></td>
<td>
<p>a data set to partition</p>
</td></tr>
<tr><td><code id="summarize_partitions_+3A_partitioner">partitioner</code></td>
<td>
<p>the partitioner to use. The default is <code><a href="#topic+part_icc">part_icc()</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_partitions_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+partition">partition()</a></code></p>
</td></tr>
<tr><td><code id="summarize_partitions_+3A_information">information</code>, <code id="summarize_partitions_+3A_.information">.information</code></td>
<td>
<p>a vector of minimum information to fit in <code><a href="#topic+partition">partition()</a></code></p>
</td></tr>
<tr><td><code id="summarize_partitions_+3A_nperm">nperm</code></td>
<td>
<p>Number of permuted data sets to test. Default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>

<hr>
<h2 id='super_partition'>super_partition</h2><span id='topic+super_partition'></span>

<h3>Description</h3>

<p><code>super_partition</code> implements the agglomerative, data reduction method Partition for datasets with large numbers of features by first 'super-partitioning' the data into smaller clusters to Partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>super_partition(
  full_data,
  threshold = 0.5,
  cluster_size = 4000,
  partitioner = part_icc(),
  tolerance = 1e-04,
  niter = NULL,
  x = "reduced_var",
  .sep = "_",
  verbose = TRUE,
  progress_bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="super_partition_+3A_full_data">full_data</code></td>
<td>
<p>sample by feature data frame or matrix</p>
</td></tr>
<tr><td><code id="super_partition_+3A_threshold">threshold</code></td>
<td>
<p>the minimum proportion of information explained by a reduced variable; <code>threshold</code> sets a boundary for information loss because each reduced variable must explain at least as much as <code>threshold</code> as measured by the metric.</p>
</td></tr>
<tr><td><code id="super_partition_+3A_cluster_size">cluster_size</code></td>
<td>
<p>maximum size of any single cluster; default is 4000</p>
</td></tr>
<tr><td><code id="super_partition_+3A_partitioner">partitioner</code></td>
<td>
<p>a <code>partitioner</code>. See the <code style="white-space: pre;">&#8288;part_*()&#8288;</code> functions and <code><a href="#topic+as_partitioner">as_partitioner()</a></code>.</p>
</td></tr>
<tr><td><code id="super_partition_+3A_tolerance">tolerance</code></td>
<td>
<p>a small tolerance within the threshold; if a reduction is within the threshold plus/minus the tolerance, it will reduce.</p>
</td></tr>
<tr><td><code id="super_partition_+3A_niter">niter</code></td>
<td>
<p>the number of iterations. By default, it is calculated as 20% of the number of variables or 10, whichever is larger.</p>
</td></tr>
<tr><td><code id="super_partition_+3A_x">x</code></td>
<td>
<p>the prefix of the new variable names; must not be contained in any existing data names</p>
</td></tr>
<tr><td><code id="super_partition_+3A_.sep">.sep</code></td>
<td>
<p>a character vector that separates <code>x</code> from the number (e.g. &quot;reduced_var_1&quot;).</p>
</td></tr>
<tr><td><code id="super_partition_+3A_verbose">verbose</code></td>
<td>
<p>logical for whether or not to display information about super partition step; default is TRUE</p>
</td></tr>
<tr><td><code id="super_partition_+3A_progress_bar">progress_bar</code></td>
<td>
<p>logical for whether or not to show progress bar; default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>super_partition</code> scales up partition with an approximation, using Genie, a fast, hierarchical clustering algorithm with similar qualities of those to Partition, to first super-partition the data into ceiling(N/c) clusters, where N is the number of features in the full dataset and c is the user-defined maximum cluster size (default value = 4,000). Then, if any cluster from the super-partition has a size greater than c, use Genie again on that cluster until all cluster sizes are less than c. Finally, apply the Partition algorithm to each of the super-partitions.
</p>
<p>It may be the case that large super-partitions cannot be easily broken with Genie due to high similarity between features. In this case, we use k-means to break the cluster.
</p>


<h3>Value</h3>

<p>Partition object
</p>


<h3>Author(s)</h3>

<p>Katelyn Queen, <a href="mailto:kjqueen@usc.edu">kjqueen@usc.edu</a>
</p>


<h3>References</h3>

<p>Barrett, Malcolm and Joshua Millstein (2020). partition: A fast and flexible framework for data reduction in R. Journal of Open Source Software, 5(47), 1991, https://doi.org/10.21105/joss.01991Millstein J, Battaglin F, Barrett M, Cao S, Zhang W, Stintzing S, et al. Partition: a surjective mapping approach for dimensionality reduction. <em>Bioinformatics</em> <strong>36</strong> (2019) 676681. doi:10.1093/bioinformatics/btz661.
</p>
<p>Gagolewski, Marek, Maciej Bartoszuk, and Anna Cena. &quot;Genie: A new, fast, and outlier-resistant hierarchical clustering algorithm.&quot; Information Sciences 363 (2016): 8-23.
</p>
<p>Millstein, Joshua, Francesca Battaglin, Malcolm Barrett, Shu Cao, Wu Zhang, Sebastian Stintzing, Volker Heinemann, and Heinz-Josef Lenz. 2020. Partition: A Surjective Mapping Approach for Dimensionality Reduction. <em>Bioinformatics</em> 36 (3): https://doi.org/67681.10.1093/bioinformatics/btz661.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition">partition()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
df &lt;- simulate_block_data(c(15, 20, 10), lower_corr = .4, upper_corr = .6, n = 100)

#  don't accept reductions where information &lt; .6
prt &lt;- super_partition(df, threshold = .6, cluster_size = 30)
prt

</code></pre>

<hr>
<h2 id='test_permutation'>Permute partitions</h2><span id='topic+test_permutation'></span>

<h3>Description</h3>

<p><code>test_permutation()</code> permutes data and partitions the results to generate a
distribution of null statistics for observed information, number of clusters,
and number of observed variables reduced to clusters. The result is a
<code>tibble</code> with a summary of the observed data results and the averages of the
permuted results. The partitions and and permutations are also available in
<code>list-cols</code>. <code>test_permutation()</code> tests across a range of target information
values, as specified in the <code>information</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_permutation(
  .data,
  information = seq(0.1, 0.6, by = 0.1),
  partitioner = part_icc(),
  ...,
  nperm = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_permutation_+3A_.data">.data</code></td>
<td>
<p>a data set to partition</p>
</td></tr>
<tr><td><code id="test_permutation_+3A_information">information</code></td>
<td>
<p>a vector of minimum information to fit in <code><a href="#topic+partition">partition()</a></code></p>
</td></tr>
<tr><td><code id="test_permutation_+3A_partitioner">partitioner</code></td>
<td>
<p>the partitioner to use. The default is <code><a href="#topic+part_icc">part_icc()</a></code>.</p>
</td></tr>
<tr><td><code id="test_permutation_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+partition">partition()</a></code></p>
</td></tr>
<tr><td><code id="test_permutation_+3A_nperm">nperm</code></td>
<td>
<p>Number of permuted data sets to test. Default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with summaries on observed and permuted data (the means of
the permuted summaries), as well as list-cols containing them
</p>

<hr>
<h2 id='under_threshold'>Compare metric to threshold</h2><span id='topic+under_threshold'></span><span id='topic+above_threshold'></span><span id='topic+is_within'></span><span id='topic+metric_within_tolerance'></span>

<h3>Description</h3>

<p><code>under_threshold()</code> and <code>above_threshold()</code> check relative location of the
metric. <code>metric_within_tolerance()</code> uses <code>is_within()</code> to check if the metric
is within in the range of the threshold plus/minus the tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>under_threshold(.partition_step)

above_threshold(.partition_step)

is_within(.x, .y, .e)

metric_within_tolerance(.partition_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="under_threshold_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, <code>TRUE</code> or <code>FALSE</code>
</p>

<hr>
<h2 id='update_dist'>Only fit the distances for a new variable</h2><span id='topic+update_dist'></span>

<h3>Description</h3>

<p>Only fit the distances for a new variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_dist(.partition_step, spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_dist_+3A_.partition_step">.partition_step</code></td>
<td>
<p>a <code>partition_step</code> object</p>
</td></tr>
<tr><td><code id="update_dist_+3A_spearman">spearman</code></td>
<td>
<p>Logical. Use Spearman's correlation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
