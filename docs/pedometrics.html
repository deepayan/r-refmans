<!DOCTYPE html><html><head><title>Help for package pedometrics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pedometrics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pedometrics-package'><p>Pedometric Tools and Techniques</p></a></li>
<li><a href='#adjR2'><p>Adjusted coefficient of determination</p></a></li>
<li><a href='#bbox2sp'><p>Create a Spatial* object from a bounding box</p></a></li>
<li><a href='#buildModelSeries'><p>Build a series of linear models using automated variable selection</p></a></li>
<li><a href='#checkGMU'><p>Evaluation of geostatistical models of uncertainty</p></a></li>
<li><a href='#cont2cat'><p>Categorize/stratify numerical variable(s)</p></a></li>
<li><a href='#coordenadas'><p>Defunct functions</p></a></li>
<li><a href='#cramer'><p>Association between categorical variables</p></a></li>
<li><a href='#gcpVector'><p>Calculate module and azimuth</p></a></li>
<li><a href='#isNumint'><p>Tests for data types</p></a></li>
<li><a href='#plotCor'><p>Correlation plot</p></a></li>
<li><a href='#plotESDA'><p>Plots for exploratory spatial data analysis (ESDA)</p></a></li>
<li><a href='#plotHist'><p>Histogram and density plot</p></a></li>
<li><a href='#plotModelSeries'><p>Model series plot</p></a></li>
<li><a href='#rowMinCpp'><p>Return the minimum value in each row of a numeric matrix</p></a></li>
<li><a href='#skewness'><p>Moment coefficient of skewness</p></a></li>
<li><a href='#statsModelSeries'><p>Obtain performance statistics of a series of linear models</p></a></li>
<li><a href='#stepVIF'><p>Variable selection using the (generalized) variance-inflation factor (VIF)</p></a></li>
<li><a href='#variogramBins'><p>Variogram binning</p></a></li>
<li><a href='#variogramGuess'><p>Guess the parameters of a spatial covariance function</p></a></li>
<li><a href='#vgmSCV'><p>Spatially correlated variance (SCV)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.12.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Pedometric Tools</td>
</tr>
<tr>
<td>Description:</td>
<td>An R implementation of methods employed in the field of pedometrics, soil science
    discipline dedicated to studying the spatial, temporal, and spatio-temporal variation of soil
    using statistical and computational methods. The methods found here include the calibration of
    linear regression models using covariate selection strategies, computation of summary validation
    statistics for predictions, generation of summary plots, evaluation of the local quality of a
    geostatistical model of uncertainty, and so on. Other functions simply extend the
    functionalities of or facilitate the usage of functions from other packages that are commonly
    used for the analysis of soil data. Formerly available versions of suggested packages no longer
    available from CRAN can be obtained from the CRAN archive
    <a href="https://cran.r-project.org/src/contrib/Archive/">https://cran.r-project.org/src/contrib/Archive/</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Laboratorio-de-Pedometria/pedometrics-package">https://github.com/Laboratorio-de-Pedometria/pedometrics-package</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Laboratorio-de-Pedometria/pedometrics-package/issues">https://github.com/Laboratorio-de-Pedometria/pedometrics-package/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, latticeExtra, Rcpp (&ge; 0.12.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>car, fields, georob, grDevices, grid, gstat, knitr, MASS,
methods, sp, SpatialTools</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pandoc</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-18 22:15:48 UTC; alessandrorosa</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessandro Samuel-Rosa
    <a href="https://orcid.org/0000-0003-0877-1320"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Lucia Helena Cunha dos Anjos
    <a href="https://orcid.org/0000-0003-0063-3521"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ths],
  Gustavo Vasques <a href="https://orcid.org/0000-0001-9463-1898"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths],
  Gerard B M Heuvelink
    <a href="https://orcid.org/0000-0003-0959-9358"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ths],
  Juan Carlos Ruiz Cuetos [ctb],
  Maria Eugenia Polo Garcia [ctb],
  Pablo Garcia Rodriguez [ctb],
  Joshua French [ctb],
  Ken Kleinman [ctb],
  Dick Brus <a href="https://orcid.org/0000-0003-2194-4783"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Frank Harrell Jr [ctb],
  Ruo Xu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessandro Samuel-Rosa &lt;alessandrosamuelrosa@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-19 06:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pedometrics-package'>Pedometric Tools and Techniques</h2><span id='topic+pedometrics-package'></span><span id='topic+pedometrics'></span>

<h3>Description</h3>

<p>This package contains many tools and techniques used in the field of pedometrics (see
https://en.wikipedia.org/wiki/Pedometric_mapping for a definition of <em>pedometrics</em>). These tools
and techniques were developed to fulfill the demands created by the PhD research project
(2012-2016) entitled &ldquo;Contribution to the Construction of Models for Predicting Soil
Properties&rdquo;, developed by Alessandro Samuel-Rosa under the supervision of Dr Lúcia HC Anjos
(Universidade Federal Rural do Rio de Janeiro, Brazil), Dr Gustavo M Vasques (Embrapa Solos,
Brazil), and Dr Gerard B M Heuvelink (ISRIC - World Soil Information, the Netherlands). The
project is/was funded by the CNPq Foundation (Process 140720/2012-0), Ministry of Science
and Technology of Brazil, Brasília, DF, 70040-020, Brazil, phone +55 (61) 2022 6002, and the
CAPES Foundation (Process ID BEX 11677/13-9), Ministry of Education of Brazil, Brasília, DF,
70040-020, Brazil, phone: +55 (61) 2022 6210.
</p>


<h3>Details</h3>

<p>Several functions simply extend the functionalities of other functions commonly used for the
analysis of pedometric data. It should be noted that changes are likely to occur quite often and
the use of this package as a dependency for other packages is strongly discouraged.
</p>


<h3>Author(s)</h3>

<p>Author and Maintainer: Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>.
</p>

<hr>
<h2 id='adjR2'>Adjusted coefficient of determination</h2><span id='topic+adjR2'></span>

<h3>Description</h3>

<p>Calculates the adjusted coefficient of determination of a multiple linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjR2(r2, n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjR2_+3A_r2">r2</code></td>
<td>
<p>Numeric vector with the coefficient of determination to be adjusted.</p>
</td></tr>
<tr><td><code id="adjR2_+3A_n">n</code></td>
<td>
<p>Numeric vector providing the number of observations used to fit the multiple linear
regression model.</p>
</td></tr>
<tr><td><code id="adjR2_+3A_p">p</code></td>
<td>
<p>Numeric vector providing the number of parameters included in the multiple linear
regression model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the adjusted coefficient of determination.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Coefficient of determination. Wikipedia, The Free Encyclopedia. Available at
<a href="https://en.wikipedia.org/wiki/Coefficient_of_determination">https://en.wikipedia.org/wiki/Coefficient_of_determination</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- adjR2(r2 = 0.95, n = 100, p = 80)
</code></pre>

<hr>
<h2 id='bbox2sp'>Create a Spatial* object from a bounding box</h2><span id='topic+bbox2sp'></span>

<h3>Description</h3>

<p>Take the bounding box of a Spatial* object and create a SpatialPoints* or SpatialPolygons* object
from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox2sp(obj, sp = "SpatialPolygons", keep.crs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox2sp_+3A_obj">obj</code></td>
<td>
<p>Object of class Spatial*.</p>
</td></tr>
<tr><td><code id="bbox2sp_+3A_sp">sp</code></td>
<td>
<p>Class of the resulting object with options <code>"SpatialPolygons"</code> (default),
<code>"SpatialPoints"</code>, <code>"SpatialPointsDataFrame"</code>, and <code>"SpatialPolygonsDataFrame"</code>.</p>
</td></tr>
<tr><td><code id="bbox2sp_+3A_keep.crs">keep.crs</code></td>
<td>
<p>Logical for assigning the same coordinate reference system to the resulting
Spatial* object. Defaults to <code>keep.crs = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SpatialPoints* or SpatialPolygons*.
</p>


<h3>Dependencies</h3>

<p>The <strong>sp</strong> package, provider of classes and methods for spatial data in R, is required for
<code><a href="#topic+bbox2sp">bbox2sp()</a></code> to work. The development version of the <strong>sp</strong> package is available on
<a href="https://github.com/edzer/sp/">https://github.com/edzer/sp/</a> while its old versions are available on the CRAN archive at
<a href="https://cran.r-project.org/src/contrib/Archive/sp/">https://cran.r-project.org/src/contrib/Archive/sp/</a>.
</p>


<h3>Note</h3>

<p>Some of the solutions used to build this function were found in the source code of the
R-package <strong>intamapInteractive</strong>. As such, the authors of that package, Edzer Pebesma
<a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> and Jon Skoien <a href="mailto:jon.skoien@gmail.com">jon.skoien@gmail.com</a>, are entitled
&lsquo;contributors&rsquo; to the R-package <strong>pedometrics</strong>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Edzer Pebesma, Jon Skoien with contributions from Olivier Baume, A. Chorti, D.T. Hristopulos,
S.J. Melles and G. Spiliopoulos (2013). <em>intamapInteractive: procedures for automated
interpolation - methods only to be used interactively, not included in intamap package.</em> R
package version 1.1-10. <a href="https://CRAN.R-project.org/package=intamapInteractive">https://CRAN.R-project.org/package=intamapInteractive</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(sp)) {
  data(meuse, package = "sp")
  sp::coordinates(meuse) &lt;- ~ x + y
  bb &lt;- bbox2sp(obj = meuse, keep.crs = FALSE)
}
</code></pre>

<hr>
<h2 id='buildModelSeries'>Build a series of linear models using automated variable selection</h2><span id='topic+buildModelSeries'></span><span id='topic+buildMS'></span>

<h3>Description</h3>

<p>Build a series of linear models with <code><a href="stats.html#topic+lm">stats::lm()</a></code> using one or more automated variable
selection methods implemented in the functions <code><a href="#topic+stepVIF">stepVIF()</a></code> and <code><a href="MASS.html#topic+stepAIC">MASS::stepAIC()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildModelSeries(
  formula,
  data,
  vif = FALSE,
  vif.threshold = 10,
  vif.verbose = FALSE,
  aic = FALSE,
  aic.direction = "both",
  aic.trace = FALSE,
  aic.steps = 5000,
  ...
)

buildMS(
  formula,
  data,
  vif = FALSE,
  vif.threshold = 10,
  vif.verbose = FALSE,
  aic = FALSE,
  aic.direction = "both",
  aic.trace = FALSE,
  aic.steps = 5000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildModelSeries_+3A_formula">formula</code></td>
<td>
<p>A list containing one or several model formulas (a symbolic description of the
model to be fitted).</p>
</td></tr>
<tr><td><code id="buildModelSeries_+3A_data">data</code></td>
<td>
<p>Data frame containing the variables in the model formulas.</p>
</td></tr>
<tr><td><code id="buildModelSeries_+3A_vif">vif</code></td>
<td>
<p>Logical for performing backward variable selection using the Variance-Inflation Factor
(VIF). Defaults to <code>vif = FALSE</code>.</p>
</td></tr>
<tr><td><code id="buildModelSeries_+3A_vif.threshold">vif.threshold</code></td>
<td>
<p>Numeric value setting the maximum acceptable VIF value. Defaults to
<code>vif.threshold = 10</code>.</p>
</td></tr>
<tr><td><code id="buildModelSeries_+3A_vif.verbose">vif.verbose</code></td>
<td>
<p>Logical for printing iteration results of backward variable selection using
the VIF. Defaults to <code>vif.verbose = FALSE</code>.</p>
</td></tr>
<tr><td><code id="buildModelSeries_+3A_aic">aic</code></td>
<td>
<p>Logical for performing variable selection using Akaike's Information Criterion (AIC).
Defaults to <code>aic = FALSE</code>.</p>
</td></tr>
<tr><td><code id="buildModelSeries_+3A_aic.direction">aic.direction</code></td>
<td>
<p>Character string setting the direction of variable selection when using AIC,
with options <code>"both"</code> (default), <code>"forward"</code>, and <code>"backward"</code>.</p>
</td></tr>
<tr><td><code id="buildModelSeries_+3A_aic.trace">aic.trace</code></td>
<td>
<p>Logical for printing iteration results of variable selection using the AIC.
Defaults to <code>aic.trace = FALSE</code>.</p>
</td></tr>
<tr><td><code id="buildModelSeries_+3A_aic.steps">aic.steps</code></td>
<td>
<p>Integer value setting the maximum number of steps to be considered for variable
selection using the AIC. Defaults to <code>aic.steps = 5000</code>.</p>
</td></tr>
<tr><td><code id="buildModelSeries_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="MASS.html#topic+stepAIC">MASS::stepAIC()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+buildModelSeries">buildModelSeries()</a></code> was devised to deal with a list of linear model formulas. The
main objective is to bring together several functions commonly used when building linear models,
such as automated variable selection. In the current implementation, variable selection can be
done using <code><a href="#topic+stepVIF">stepVIF()</a></code> or <code><a href="MASS.html#topic+stepAIC">MASS::stepAIC()</a></code> or both.
<code><a href="#topic+stepVIF">stepVIF()</a></code> is a backward variable selection procedure, while <code><a href="MASS.html#topic+stepAIC">MASS::stepAIC()</a></code>
supports backward, forward, and bidirectional variable selection. For more information about
these functions, please visit their respective help pages.
</p>
<p>An important feature of <code><a href="#topic+buildModelSeries">buildModelSeries()</a></code> is that it records the initial number
of candidate predictor variables and observations offered to the model, and adds this information
as an attribute to the final selected model. Such feature was included because variable selection
procedures result biased linear models (too optimistic), and the effective number of degrees of
freedom is close to the number of candidate predictor variables initially offered to the model
(Harrell, 2001). With the initial number of candidate predictor variables and observations
offered to the model, one can calculate penalized or adjusted measures of model performance. For
models built using <code><a href="#topic+buildModelSeries">buildModelSeries()</a></code>, this can be done using
<code><a href="#topic+statsModelSeries">statsModelSeries()</a></code>.
</p>
<p>Some important details should be clear when using <code><a href="#topic+buildModelSeries">buildModelSeries()</a></code>:
</p>

<ul>
<li><p> this function was originally devised to deal with a list of formulas, but can also be used with
a single formula;
</p>
</li>
<li><p> in the current implementation, <code><a href="#topic+stepVIF">stepVIF()</a></code> runs before <code><a href="MASS.html#topic+stepAIC">MASS::stepAIC()</a></code>;
</p>
</li>
<li><p> function arguments imported from <code><a href="MASS.html#topic+stepAIC">MASS::stepAIC()</a></code> and <code><a href="#topic+stepVIF">stepVIF()</a></code> were named as
in the original functions, and received a prefix (<code>aic</code> or <code>vif</code>) to help the user identifying
which function is affected by a given argument without having to go check the documentation.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the fitted linear models.
</p>


<h3>TODO</h3>

<p>Add option to set the order in which <code><a href="MASS.html#topic+stepAIC">MASS::stepAIC()</a></code> and <code><a href="#topic+stepVIF">stepVIF()</a></code> are run.
</p>


<h3>Dependencies</h3>

<p>The <strong>MASS</strong> package, provider of support functions and datasets for Venables and Ripley's Modern
Applied Statistics with S, is required for <code><a href="#topic+buildModelSeries">buildModelSeries()</a></code> to work. The
development version of the <strong>MASS</strong> package is available on
<a href="https://www.stats.ox.ac.uk/pub/MASS4/">https://www.stats.ox.ac.uk/pub/MASS4/</a> while its old versions are available on the CRAN archive
at <a href="https://cran.r-project.org/src/contrib/Archive/MASS/">https://cran.r-project.org/src/contrib/Archive/MASS/</a>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Harrell, F. E. (2001) <em>Regression modelling strategies: with applications to linear models,
logistic regression, and survival analysis.</em> First edition. New York: Springer.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern applied statistics with S.</em> Fourth edition.
New York: Springer.
</p>
<p>A. Samuel-Rosa, G. B. M. Heuvelink, G. de Mattos Vasques, and L. H. C. dos Anjos, Do more
detailed environmental covariates deliver more accurate soil maps?, <em>Geoderma</em>, vol. 243–244,
pp. 214–227, May 2015, doi: 10.1016/j.geoderma.2014.12.017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepVIF">stepVIF()</a></code>, <code><a href="#topic+statsMS">statsMS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  # based on the second example of MASS::stepAIC()
  library("MASS")
  cpus1 &lt;- cpus
  for(v in names(cpus)[2:7])
    cpus1[[v]] &lt;- cut(cpus[[v]], unique(stats::quantile(cpus[[v]])),
                      include.lowest = TRUE)
  cpus0 &lt;- cpus1[, 2:8]  # excludes names, authors' predictions
  cpus.samp &lt;- sample(1:209, 100)
  cpus.form &lt;- list(formula(log10(perf) ~ syct + mmin + mmax + cach + chmin +
                    chmax + perf),
                    formula(log10(perf) ~ syct + mmin + cach + chmin + chmax),
                    formula(log10(perf) ~ mmax + cach + chmin + chmax + perf))
  data &lt;- cpus1[cpus.samp,2:8]
  cpus.ms &lt;- buildModelSeries(cpus.form, data, vif = TRUE, aic = TRUE)
}
</code></pre>

<hr>
<h2 id='checkGMU'>Evaluation of geostatistical models of uncertainty</h2><span id='topic+checkGMU'></span>

<h3>Description</h3>

<p>Evaluate the local quality of a geostatistical model of uncertainty (GMU) using summary measures
and graphical displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkGMU(
  observed,
  simulated,
  pi = seq(0.01, 0.99, 0.01),
  symmetric = TRUE,
  plotit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkGMU_+3A_observed">observed</code></td>
<td>
<p>Vector of observed values at the validation points. See &lsquo;Details&rsquo; for more
information.</p>
</td></tr>
<tr><td><code id="checkGMU_+3A_simulated">simulated</code></td>
<td>
<p>Data frame or matrix with simulated values (columns) for each validation point
(rows). See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="checkGMU_+3A_pi">pi</code></td>
<td>
<p>Vector defining the width of the series of probability intervals. Defaults to
<code>pi = seq(0.01, 0.99, 0.01)</code>. See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="checkGMU_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical for choosing the type of probability interval. Defaults to
<code>symmetric = TRUE</code>. See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="checkGMU_+3A_plotit">plotit</code></td>
<td>
<p>Logical for plotting the results. Defaults to <code>plotit = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no standard way of evaluating the local quality of a GMU. The collection of summary
measures and graphical displays presented here is far from being comprehensive. A few definitions
are given bellow.
</p>


<h4>Error statistics</h4>

<p>Error statistics measure how well the GMU predicts the measured values at the validation points.
Four error statistics are presented:
</p>

<dl>
<dt>Mean error (ME)</dt><dd>
<p>Measures the bias of the predictions of the GMU, being defined as the mean of the differences
between the average of the simulated values and the observed values, i.e. the average of all
simulations is taken as the predicted value.
</p>
</dd>
<dt>Mean squared error (MSE)</dt><dd>
<p>Measures the accuracy of the predictions of the GMU, being defined as the mean of the squared
differences between the average of the simulated values and the observed values.
</p>
</dd>
<dt>Scaled root mean squared error (SRMSE)</dt><dd>
<p>Measures how well the GMU estimate of the prediction error variance (PEV) approximates the
observed prediction error variance, where the first is given by the variance of the simulated
values, while the second is given by the squared differences between the average of the simulated
values, i.e. the squared error (SE). The SRMSE is computed as the average of SE / PEV, where
SRMSE &gt; 1 indicates underestimation, while SRMSE &lt; 1 indicates overestimation.
</p>
</dd>
<dt>Pearson correlation coefficient</dt><dd>
<p>Measures how close the GMU predictions are to the observed values. A scatter plot of the observed
values versus the average of the simulated values can be used to check for possible unwanted
outliers and non-linearities. The square of the Pearson correlation coefficient measures the
fraction of the overall spread of observed values that is explained by the GMU, that is, the
amount of variance explained (AVE), also known as coefficient of determination or ratio of
scatter.
</p>
</dd>
</dl>




<h4>Coverage probabilities</h4>

<p>The coverage probability of an interval is given by the number of times that that interval
contains its parameter over several replications of an experiment. For example, consider the
interquartile range <code class="reqn">IQR = Q3 - Q1</code> of a Gaussian distributed variable with mean equal to
zero and variance equal to one. The nominal coverage probability of the IQR is 0.5, i.e. two
quarters of the data fall within the IQR. Suppose we generate a Gaussian distributed
<em>random</em> variable with the same mean and variance and count the number of values that fall within
the IQR defined above: about 0.5 of its values will fall within the IQR. If we continue
generating Gaussian distributed <em>random</em> variables with the same mean and variance, on average,
0.5 of the values will fall in that interval.
</p>
<p>Coverage probabilities are very useful to evaluate the local quality of a GMU: the closer the
observed coverage probabilities of a sequence of probability intervals (PI) are to the nominal
coverage probabilities of those PIs, the better the modeling of the local uncertainty.
</p>
<p>Two types of PIs can be used here: symmetric, median-centered PIs, and left-bounded PIs. Papritz
&amp; Dubois (1999) recommend using left-bounded PIs because they are better at evidencing deviations
for both large and small PIs. The authors also point that the coverage probabilities of the
symmetric, median-centered PIs can be read from the coverage probability plots produced using
left-bounded PIs.
</p>
<p>In both cases, the PIs are computed at each validation location using the quantiles of the
conditional cumulative distribution function (ccdf) defined by the set of realizations at that
validation location. For a sequence of PIs of increasing width, we check which of them contains
the observed value at all validation locations. We then average the results over all validation
locations to compute the proportion of PIs (with the same width) that contains the observed
value: this gives the coverage probability of the PIs.
</p>
<p>Deutsch (1997) proposed three summary measures of the coverage probabilities to assess the local
<em>goodness</em> of a GMU: accuracy ($A$), precision ($P$), and goodness ($G$). According to Deutsch
(1997), a GMU can be considered &ldquo;good&rdquo; if it is both accurate and precise. Although easy
to compute, these measures seem not to have been explored by many geostatisticians, except for
the studies developed by Pierre Goovaerts and his later software implementation (Goovaerts,
2009). Richmond (2001) suggests that they should not be used as the only measures of the local
quality of a GMU.
</p>

<dl>
<dt>Accuracy</dt><dd>
<p>An accurate GMU is that for which the proportion <code class="reqn">p^*</code> of true values falling within the $p$
PI is equal to or larger than the nominal probability $p$, that is, when <code class="reqn">p^* \geq p</code>. In the
coverage probability plot, a GMU will be more accurate when all points are on or above the 1:1
line. The range of $A$ goes from 0 (lest accurate) to 1 (most accurate).
</p>
</dd>
<dt>Precision</dt><dd>
<p>The <em>precision</em>, $P$, is defined only for an accurate GMU, and measures how close <code class="reqn">p^*</code> is to
$p$. The range of $P$ goes from 0 (lest precise) to 1 (most precise). Thus, a GMU will be more
accurate when all points in the PI-width plot are on or above the 1:1 line.
</p>
</dd>
<dt>Goodness</dt><dd>
<p>The <em>goodness</em>, $G$, is a measure of the departure of the points from the 1:1 line in the
coverage probability plot. $G$ ranges from 0 (minimum goodness) to 1 (maximum goodness), the
maximum $G$ being achieved when <code class="reqn">p^* = p</code>, that is, all points in both coverage probability
and interval width plots are exactly on the 1:1 line.
</p>
</dd>
</dl>

<p>It is worth noting that the coverage probability and PI-width plots are relevant mainly to GMU
created using <em>conditional simulations</em>, that is, simulations that are locally conditioned to the
data observed at the validation locations. Conditioning the simulations locally serves the
purposes of honoring the available data and reducing the variance of the output realizations.
This is why one would like to find the points falling above the 1:1 line in both coverage
probability and PI-width plots. For <em>unconditional simulations</em>, that is, simulations that are
only globally conditioned to the histogram (and variogram) of the data observed at the validation
locations, one would expect to find that, over a large number of simulations, the whole set of
possible values (i.e. the global histogram) can be generated at any node of the simulation grid.
In other words, it is expected to find all points on the 1:1 line in both coverage probability
and PI-width plots. Deviations from the 1:1 line could then be used as evidence of problems in
the simulation.
</p>



<h3>Value</h3>

<p>A <code>list</code> of summary measures and plots of the coverage probability and width of probability
intervals.
</p>


<h3>Note</h3>

<p>Comments by Pierre Goovaerts <a href="mailto:pierre.goovaerts@biomedware.com">pierre.goovaerts@biomedware.com</a> were important to
describe how to use the coverage probability and PI-width plots when a GMU is created using
unconditional simulations.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Deutsch, C. Direct assessment of local accuracy and precision. Baafi, E. Y. &amp; Schofield, N. A.
(Eds.) <em>Geostatistics Wollongong '96</em>. Dordrecht: Kinwer Academic Publishers, v. I, p. 115-125,
1997.
</p>
<p>Papritz, A. &amp; Dubois, J. R. Mapping heavy metals in soil by (non-)linear kriging: an empirical
validation. Gómez-Hernández, J.; Soares, A. &amp; Froidevaux, R. (Eds.) <em>geoENV II &ndash; Geostatistics
for Environmental Applications</em>. Springer, p. 429-440, 1999.
</p>
<p>Goovaerts, P. Geostatistical modelling of uncertainty in soil science. <em>Geoderma</em>. v. 103, p.
3 - 26, 2001.
</p>
<p>Goovaerts, P. AUTO-IK: a 2D indicator kriging program for the automated non-parametric modeling
of local uncertainty in earth sciences. <em>Computers &amp; Geosciences</em>. v. 35, p. 1255-1270, 2009.
</p>
<p>Richmond, A. J. Maximum profitability with minimum risk and effort. Xie, H.; Wang, Y. &amp; Jiang, Y.
(Eds.) <em>Proceedings 29th APCOM</em>. Lisse: A. A. Balkema, p. 45-50, 2001.
</p>
<p>Ripley, B. D. <em>Stochastic simulation</em>. New York: John Wiley &amp; Sons, p. 237, 1987.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  set.seed(2001)
  observed &lt;- round(rnorm(100), 3)
  simulated &lt;- t(
    sapply(1:length(observed), function (i) round(rnorm(100), 3)))
  resa &lt;- checkGMU(observed, simulated, symmetric = T)
  resb &lt;- checkGMU(observed, simulated, symmetric = F)
  resa$error; resb$error
  resa$goodness; resb$goodness
}
</code></pre>

<hr>
<h2 id='cont2cat'>Categorize/stratify numerical variable(s)</h2><span id='topic+cont2cat'></span><span id='topic+breakPoints'></span><span id='topic+stratify'></span>

<h3>Description</h3>

<p>Create break points, compute strata proportions, and stratify numerical variable(s) to create
categorical variable(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cont2cat(x, breaks, integer = FALSE)

breakPoints(x, n, type = "area", prop = FALSE)

stratify(x, n, type = "area", integer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cont2cat_+3A_x">x</code></td>
<td>
<p>Vector, data frame or matrix with data on the numerical variable(s) to be
categorized/stratified.</p>
</td></tr>
<tr><td><code id="cont2cat_+3A_breaks">breaks</code></td>
<td>
<p>Vector or list containing the lower and upper limits that should be used to break
the numerical variable(s) into categories. See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="cont2cat_+3A_integer">integer</code></td>
<td>
<p>Logical value indicating if the categorical variable(s) should be returned as
<code>integer</code>s. Defaults to <code>integer = FALSE</code>, i.e. the variable(s) will be returned as <code>factor</code>s.</p>
</td></tr>
<tr><td><code id="cont2cat_+3A_n">n</code></td>
<td>
<p>Integer value indicating the number of categories/strata that should be created.</p>
</td></tr>
<tr><td><code id="cont2cat_+3A_type">type</code></td>
<td>
<p>Character value indicating the type of categories/strata that should be used, with
options <code>"area"</code> (default), for equal-area, and <code>"range"</code>, for equal-range strata.</p>
</td></tr>
<tr><td><code id="cont2cat_+3A_prop">prop</code></td>
<td>
<p>Logical value indicating if the strata proportions should be returned? Defaults to
<code>prop = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>breaks</code> must be a vector if <code>x</code> is a vector, but a list if <code>x</code> is a data frame or
matrix. Using a list allows breaking each column of <code>x</code> into different number of categories.
</p>


<h3>Value</h3>

<p>A vector, data frame, or matrix, depending on the class of <code>x</code>.
</p>


<h3>Dependencies</h3>

<p>The <strong>SpatialTools</strong> package, provider of tools for spatial data analysis in R, is required for
<code><a href="#topic+breakPoints">breakPoints()</a></code> and <code><a href="#topic+stratify">stratify()</a></code> to work. The development version of
the <strong>SpatialTools</strong> package is available on <a href="https://github.com/jfrench/SpatialTools">https://github.com/jfrench/SpatialTools</a> while its
old versions are available on the CRAN archive at
<a href="https://cran.r-project.org/src/contrib/Archive/SpatialTools/">https://cran.r-project.org/src/contrib/Archive/SpatialTools/</a>.
</p>


<h3>Reverse dependencies</h3>

<p>The <strong>spsann</strong> package, provider of methods for the optimization of sample configurations using
spatial simulated annealing in R, requires <code><a href="#topic+breakPoints">breakPoints()</a></code>,
<code><a href="#topic+cont2cat">cont2cat()</a></code> and <code><a href="#topic+stratify">stratify()</a></code> for some of its functions to work. The
development version of the <strong>spsann</strong> package is available on
<a href="https://github.com/Laboratorio-de-Pedometria/spsann-package">https://github.com/Laboratorio-de-Pedometria/spsann-package</a>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>B. Minasny and A. B. McBratney. A conditioned Latin hypercube method for sampling in the presence
of ancillary information. <em>Computers &amp; Geosciences</em>, vol. 32, no. 9, pp. 1378–1388, Nov. 2006,
doi: 10.1016/j.cageo.2005.12.009.
</p>
<p>T. Hengl, D. G. Rossiter, and A. Stein. Soil sampling strategies for spatial prediction by
correlation with auxiliary maps. <em>Australian Journal of Soil Research</em>, vol. 41, no. 8, pp.
1403–1422, 2003, doi: 10.1071/SR03005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(SpatialTools)) {
  ## Compute the break points of marginal strata
  x &lt;- data.frame(x = round(rnorm(10), 1), y = round(rlnorm(10), 1))
  x &lt;- breakPoints(x = x, n = 4, type = "area", prop = TRUE)

  ## Convert numerical data into categorical data
  # Matrix
  x &lt;- y &lt;- c(1:10)
  x &lt;- cbind(x, y)
  breaks &lt;- list(c(1, 2, 4, 8, 10), c(1, 5, 10))
  y &lt;- cont2cat(x, breaks)

  # Data frame
  x &lt;- y &lt;- c(1:10)
  x &lt;- data.frame(x, y)
  breaks &lt;- list(c(1, 2, 4, 8, 10), c(1, 5, 10))
  y &lt;- cont2cat(x, breaks, integer = TRUE)

  # Vector
  x &lt;- c(1:10)
  breaks &lt;- c(1, 2, 4, 8, 10)
  y &lt;- cont2cat(x, breaks, integer = TRUE)

  ## Stratification
  x &lt;- data.frame(x = round(rlnorm(10), 1), y = round(rnorm(10), 1))
  x &lt;- stratify(x = x, n = 4, type = "area", integer = TRUE)
  x
}
</code></pre>

<hr>
<h2 id='coordenadas'>Defunct functions</h2><span id='topic+coordenadas'></span><span id='topic+cdfPlot'></span><span id='topic+cdfStats'></span><span id='topic+cdfTable'></span><span id='topic+gcpDiff'></span><span id='topic+trend.terms'></span><span id='topic+trend.matrix'></span>

<h3>Description</h3>

<p>The functions listed here are no longer part of the <strong>pedometrics</strong> package. If you need to use
any of these functions, you can still find them at <a href="https://github.com/samuel-rosa/ASRtools">https://github.com/samuel-rosa/ASRtools</a> or
<a href="https://cran.r-project.org/src/contrib/Archive/pedometrics/">https://cran.r-project.org/src/contrib/Archive/pedometrics/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordenadas(...)

cdfPlot(...)

cdfStats(...)

cdfTable(...)

gcpDiff(...)

trend.terms(...)

trend.matrix(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordenadas_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a><br />
Tony Olsen <a href="mailto:Olsen.Tony@epa.gov">Olsen.Tony@epa.gov</a><br />
Tom Kincaid <a href="mailto:Kincaid.Tom@epa.gov">Kincaid.Tom@epa.gov</a>
</p>

<hr>
<h2 id='cramer'>Association between categorical variables</h2><span id='topic+cramer'></span>

<h3>Description</h3>

<p>Compute the Cramer's V, a descriptive statistic that measures the association between categorical
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cramer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cramer_+3A_x">x</code></td>
<td>
<p>Data frame or matrix with a set of categorical variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any integer variable is internally converted to a factor.
</p>


<h3>Value</h3>

<p>A matrix with the Cramer's V between the categorical variables.
</p>


<h3>Reverse dependencies</h3>

<p>The <strong>spsann</strong> package, provider of methods for the optimization of sample configurations using
spatial simulated annealing in R, requires <code><a href="#topic+cramer">cramer()</a></code> for some of its functions to
work. The development version of the <strong>spsann</strong> package is available on
<a href="https://github.com/Laboratorio-de-Pedometria/spsann-package">https://github.com/Laboratorio-de-Pedometria/spsann-package</a>.
</p>


<h3>Note</h3>

<p>The original code is available at <a href="https://sas-and-r.blogspot.com/">https://sas-and-r.blogspot.com/</a>, Example 8.39:
calculating Cramer's V, posted by Ken Kleinman on Friday, June 3, 2011. As such, Ken Kleinman
<a href="mailto:Ken_Kleinman@hms.harvard.edu">Ken_Kleinman@hms.harvard.edu</a> is entitled a &lsquo;contributor&rsquo; to the R-package
<strong>pedometrics</strong>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Cramér, H. <em>Mathematical methods of statistics</em>. Princeton: Princeton University Press, p. 575,
1946.
</p>
<p>Everitt, B. S. <em>The Cambridge dictionary of statistics</em>. Cambridge: Cambridge University Press,
p. 432, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  data(meuse, package = "sp")
  str(meuse)
  test &lt;- cramer(meuse[, c("ffreq", "soil", "lime", "landuse")])
}
</code></pre>

<hr>
<h2 id='gcpVector'>Calculate module and azimuth</h2><span id='topic+gcpVector'></span>

<h3>Description</h3>

<p>Calculate the module and azimuth of the difference on x and y coordinates between two sets of
ground control points (GCP). It is suited to perform calculations for topographical
coordinates only. The origin is set in the y coordinate, and rotation performed clockwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcpVector(dx, dy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcpVector_+3A_dx">dx</code></td>
<td>
<p>Numeric vector containing the difference on the &lsquo;x&rsquo; coordinate between two sets
of GCP.</p>
</td></tr>
<tr><td><code id="gcpVector_+3A_dy">dy</code></td>
<td>
<p>Numeric vector containing the difference on the &lsquo;y&rsquo; coordinate between two sets
of GCP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the module, its square and azimuth. These three columns are named
&lsquo;module&rsquo;, &lsquo;sq.module&rsquo; and &lsquo;azimuth&rsquo;.
</p>


<h3>Note</h3>

<p>This function was adapted from package's <strong>VecStatGraphs2D</strong> function <code>LoadData()</code>.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Ruiz Cuetos <a href="mailto:bilba_t@hotmail.com">bilba_t@hotmail.com</a><br /> Maria Eugenia Polo Garcia
<a href="mailto:mepolo@unex.es">mepolo@unex.es</a><br /> Pablo Garcia Rodriguez <a href="mailto:pablogr@unex.es">pablogr@unex.es</a><br /> Alessandro
Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Ruiz-Cuetos J.C., Polo M.E. and Rodriguez P.G. (2012). <em>VecStatGraphs2D: Vector analysis using
graphical and analytical methods in 2D</em>. R package version 1.6.
<a href="https://CRAN.R-project.org/package=VecStatGraphs2D">https://CRAN.R-project.org/package=VecStatGraphs2D</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- gcpVector(dx = rnorm(3, 5, 10), dy = rnorm(3, 5, 10))

</code></pre>

<hr>
<h2 id='isNumint'>Tests for data types</h2><span id='topic+isNumint'></span><span id='topic+allNumint'></span><span id='topic+anyNumint'></span><span id='topic+allInteger'></span><span id='topic+anyInteger'></span><span id='topic+allFactor'></span><span id='topic+anyFactor'></span><span id='topic+allNumeric'></span><span id='topic+anyNumeric'></span><span id='topic+uniqueClass'></span><span id='topic+whichNumint'></span><span id='topic+whichInteger'></span><span id='topic+whichFactor'></span><span id='topic+whichNumeric'></span>

<h3>Description</h3>

<p>Evaluate the data type contained in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNumint(x)

allNumint(x)

anyNumint(x)

whichNumint(x)

allInteger(x)

anyInteger(x)

whichInteger(x)

allFactor(x)

anyFactor(x)

whichFactor(x)

allNumeric(x)

anyNumeric(x)

whichNumeric(x)

uniqueClass(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNumint_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code> depending on whether <code>x</code> contains a given data type.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+numeric">base::is.numeric()</a></code>, <code><a href="base.html#topic+integer">base::is.integer()</a></code>, <code><a href="base.html#topic+factor">base::is.factor()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vector of integers
x &lt;- 1:10
isNumint(x) # FALSE

# Vector of numeric integers
x &lt;- as.numeric(x)
isNumint(x) # TRUE

# Vector of numeric values
x &lt;- c(1.1, 1, 1, 1, 2)
isNumint(x) # FALSE
allNumint(x) # FALSE
anyNumint(x) # TRUE
whichNumint(x)

# Single numeric integer
isNumint(1) # TRUE

# Single numeric value
isNumint(1.1) # FALSE

</code></pre>

<hr>
<h2 id='plotCor'>Correlation plot</h2><span id='topic+plotCor'></span>

<h3>Description</h3>

<p>Plotting correlation matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCor(r, r2, col, breaks, col.names, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCor_+3A_r">r</code></td>
<td>
<p>A square matrix with correlation values.</p>
</td></tr>
<tr><td><code id="plotCor_+3A_r2">r2</code></td>
<td>
<p>(optional) A second square matrix with correlation values.</p>
</td></tr>
<tr><td><code id="plotCor_+3A_col">col</code></td>
<td>
<p>(optional) Color table to use for <code>image</code> &ndash; see <code><a href="graphics.html#topic+image">graphics::image()</a></code> for details. The
default is a colorblind-friendly palette created using the <strong>RColorBrewer</strong> palette <code>"RdBu"</code>.</p>
</td></tr>
<tr><td><code id="plotCor_+3A_breaks">breaks</code></td>
<td>
<p>(optional) Break points in sorted order to indicate the intervals for assigning the
colors. See <code><a href="fields.html#topic+image.plot">fields::image.plot()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="plotCor_+3A_col.names">col.names</code></td>
<td>
<p>(optional) Character vector with short (up to 5 characters) column names.</p>
</td></tr>
<tr><td><code id="plotCor_+3A_...">...</code></td>
<td>
<p>(optional) Additional parameters passed to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A correlation plot in an alternative way of showing the strength of the empirical correlations
between variables. This is done by using a diverging color palette, where the darker the color,
the stronger the absolute correlation value.
</p>
<p><code><a href="#topic+plotCor">plotCor()</a></code> can also be used to compare correlations between the same variables at
different points in time or space or for different observations. This is done by passing two
square correlation matrices using arguments <code>r</code> and <code>r2</code>. The lower triangle of the resulting
correlation plot will contain correlations from <code>r</code>, correlations from <code>r2</code> will be in the upper
triangle, and the diagonal will be empty.
</p>


<h3>Value</h3>

<p>A correlation plot.
</p>


<h3>Dependencies</h3>

<p>The <strong>fields</strong> package, provider of tools for spatial data in R, is required for
<code><a href="#topic+plotCor">plotCor()</a></code> to work. The development version of the <strong>fields</strong> package is
available on <a href="https://github.com/dnychka/fieldsRPackage">https://github.com/dnychka/fieldsRPackage</a> while its old versions are available on
the CRAN archive at <a href="https://cran.r-project.org/src/contrib/Archive/fields/">https://cran.r-project.org/src/contrib/Archive/fields/</a>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Neuwirth E (2022). <em>RColorBrewer: ColorBrewer Palettes</em>. R package version 1.1-3,
<a href="https://CRAN.R-project.org/package=RColorBrewer">https://CRAN.R-project.org/package=RColorBrewer</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (all(c(require(sp), require(fields)))) {
  data(meuse, package = "sp")
  cols &lt;- c("cadmium", "copper", "lead", "zinc", "elev", "dist", "om")

  # A single correlation matrix
  r &lt;- cor(meuse[1:20, cols], use = "complete")
  r &lt;- round(r, 2)
  plotCor(r)

  # Two correlation matrices: r2 goes in the upper triangle
  r2 &lt;- cor(meuse[21:40, cols], use = "complete")
  r2 &lt;- round(r2, 2)
  plotCor(r, r2)
}
</code></pre>

<hr>
<h2 id='plotESDA'>Plots for exploratory spatial data analysis (ESDA)</h2><span id='topic+plotESDA'></span>

<h3>Description</h3>

<p>Create four plots for exploratory spatial data analysis (ESDA): histogram + density plot,
bubble plot, variogram plot, and variogram map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotESDA(
  z,
  lat,
  lon,
  lags = NULL,
  cutoff = NULL,
  width = c(cutoff/20),
  leg.pos = "right"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotESDA_+3A_z">z</code></td>
<td>
<p>Vector of numeric values of the variable for with ESDA plots should be created.</p>
</td></tr>
<tr><td><code id="plotESDA_+3A_lat">lat</code></td>
<td>
<p>Vector of numeric values containing the y coordinate (latitude) of the point locations
where the <code>z</code> variable was observed.</p>
</td></tr>
<tr><td><code id="plotESDA_+3A_lon">lon</code></td>
<td>
<p>Vector of numeric values containing the x coordinate (longitude) of the point
locations where the <code>z</code> variable was observed.</p>
</td></tr>
<tr><td><code id="plotESDA_+3A_lags">lags</code></td>
<td>
<p>(optional) Numerical vector; upper boundaries of lag-distance classes. See argument
<code>boundaries</code> of <code><a href="gstat.html#topic+variogram">gstat::variogram()</a></code> for more info.</p>
</td></tr>
<tr><td><code id="plotESDA_+3A_cutoff">cutoff</code></td>
<td>
<p>(optional) Integer value defining the spatial separation distance up to which point
pairs are included in semi-variance estimates. Defaults to the length of the diagonal of the box
spanning the data divided by three.</p>
</td></tr>
<tr><td><code id="plotESDA_+3A_width">width</code></td>
<td>
<p>Integer value specifying the width of subsequent distance intervals into which data
point pairs are grouped for semi-variance estimates. Defaults to <code>width = cutoff / 20</code>.</p>
</td></tr>
<tr><td><code id="plotESDA_+3A_leg.pos">leg.pos</code></td>
<td>
<p>(optional) Character value indication the location of the legend of the bubble
plot. Defaults to <code>leg.pos = "right"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user should visit the help pages of <code><a href="gstat.html#topic+variogram">gstat::variogram()</a></code>, <code><a href="#topic+plotHD">plotHD()</a></code>,
<code><a href="sp.html#topic+bubble">sp::bubble()</a></code> and <code><a href="sp.html#topic+spplot">sp::spplot()</a></code> to obtain more details about the main functions used to built
<code><a href="#topic+plotESDA">plotESDA()</a></code>.
</p>


<h3>Value</h3>

<p>Four plots: histogram and density plot, bubble plot, empirical variogram, and variogram map.
</p>


<h3>Dependencies</h3>

<p>The <strong>sp</strong> package, provider of classes and methods for spatial data in R, is required for
<code><a href="#topic+plotESDA">plotESDA()</a></code> to work. The development version of the <strong>sp</strong> package is available on
<a href="https://github.com/edzer/sp/">https://github.com/edzer/sp/</a> while its old versions are available on the CRAN archive at
<a href="https://cran.r-project.org/src/contrib/Archive/sp/">https://cran.r-project.org/src/contrib/Archive/sp/</a>.
</p>
<p>The <strong>gstat</strong> package, provider of methods for spatial and spatio-temporal geostatistical
modelling, prediction and simulation in R, is required for <code><a href="#topic+plotESDA">plotESDA()</a></code> to work. The
development version of the <strong>sp</strong> package is available on <a href="https://github.com/r-spatial/gstat">https://github.com/r-spatial/gstat</a>
while its old versions are available on the CRAN archive at
<a href="https://cran.r-project.org/src/contrib/Archive/gstat/">https://cran.r-project.org/src/contrib/Archive/gstat/</a>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993) <em>Statistics for Spatial Data</em>. New York: John Wiley and Sons, p.900, 1993.
</p>
<p>Pebesma, E.J. (2004) Multivariable geostatistics in S: the gstat package. <em>Computers and
Geosciences</em>, 30:683-691, 2004.
</p>
<p>Webster, R., Oliver, M.A. <em>Geostatistics for environmental scientists</em>. Chichester: John Wiley
and Sons, p.315, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHD">plotHD()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (all(require(sp), require(gstat))) {
  data(meuse, package = "sp")
  p &lt;- plotESDA(z = meuse$zinc, lat = meuse$y, lon = meuse$x)
}
</code></pre>

<hr>
<h2 id='plotHist'>Histogram and density plot</h2><span id='topic+plotHist'></span><span id='topic+plotHD'></span>

<h3>Description</h3>

<p>Plot a histogram and a density plot of a single variable using the R-package <strong>lattice</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHist(
  x,
  HD = "over",
  nint = 20,
  digits = 2,
  stats = TRUE,
  BoxCox = FALSE,
  col = c("lightgray", "black"),
  lwd = c(1, 1),
  lty = "dashed",
  xlim,
  ylim,
  ...
)

plotHD(
  x,
  HD = "over",
  nint = 20,
  digits = 2,
  stats = TRUE,
  BoxCox = FALSE,
  col = c("lightgray", "black"),
  lwd = c(1, 1),
  lty = "dashed",
  xlim,
  ylim,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHist_+3A_x">x</code></td>
<td>
<p>Vector of numeric values of the variable for which the histogram and density plot
should be created.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_hd">HD</code></td>
<td>
<p>Character value indicating the type of plot to be created. Available options are
<code>"over"</code>, to create a histogram superimposed by the theoretical density plot of a normally
distributed variable, and <code>"stack"</code>, to create a histogram and an empirical density plot in
separated panels. Defaults to <code>HD = "over"</code>.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_nint">nint</code></td>
<td>
<p>Integer specifying the number of histogram bins. Defaults to <code>nint = 20</code>.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used
when printing the statistics of the variable <code>x</code>. Defaults to <code>digits = 2</code>.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_stats">stats</code></td>
<td>
<p>Logical to indicate if descriptive statistics of the variable <code>x</code> should be added
to the plot. Available only when <code>HD = "over"</code>. The function tries to automatically find the
best location to put the descriptive statistics given the shape of the histogram. Defaults to
<code>stats = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_boxcox">BoxCox</code></td>
<td>
<p>Logical to indicate if the variable <code>x</code> should be transformed using the Box-Cox
family of power transformations. The estimated lambda value of the Box-Cox transform is printed
in the console. It is set to zero when negative. Defaults to <code>BoxCox = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_col">col</code></td>
<td>
<p>Vector of two elements, the first indicating the color of the histogram, the second
indicating the color of the density plot. Defaults to <code>col = c("lightgray", "black")</code>.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_lwd">lwd</code></td>
<td>
<p>Vector of two elements, the first indicating the line width of the histogram, the
second indicating the line width of the density plot. Defaults to <code>lwd = c(1, 1)</code>.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_lty">lty</code></td>
<td>
<p>Character value indicating the line type for the density plot. Defaults to
<code>lty = "dashed"</code>.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_xlim">xlim</code></td>
<td>
<p>Vector of two elements defining the limits of the x axis. The function automatically
optimizes <code>xlim</code> based on the density plot.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_ylim">ylim</code></td>
<td>
<p>Vector of two elements defining the limits of the y axis. The function automatically
optimizes <code>ylim</code> based both histogram and density plot.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <strong>lattice</strong> functions. There is no guarantee
that they will work.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user should visit the help pages of <code><a href="lattice.html#topic+histogram">lattice::histogram()</a></code>, <code><a href="lattice.html#topic+histogram">lattice::densityplot()</a></code>,
<code><a href="lattice.html#topic+panel.functions">lattice::panel.mathdensity()</a></code>, <code><a href="car.html#topic+powerTransform">car::powerTransform()</a></code>, and <code><a href="car.html#topic+bcPower">car::bcPower()</a></code> to obtain more
details about the main functions used to built <code><a href="#topic+plotHD">plotHD()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The <code><a href="lattice.html#topic+update.trellis">lattice::update.trellis()</a></code> method can be used to update
components of the object and the <code><a href="lattice.html#topic+print.trellis">lattice::print.trellis()</a></code> print method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Dependencies</h3>

<p>The <strong>car</strong> package, provider of functions to accompany Fox and Weisberg's An R Companion to
Applied Regression, is required for <code><a href="#topic+plotHist">plotHist()</a></code> to work. The development version of
the <strong>car</strong> package is available on <a href="https://r-forge.r-project.org/projects/car/">https://r-forge.r-project.org/projects/car/</a> while its old
versions are available on the CRAN archive at
<a href="https://cran.r-project.org/src/contrib/Archive/car/">https://cran.r-project.org/src/contrib/Archive/car/</a>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data Visualization with R</em>, Springer.
<a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+histogram">lattice::histogram()</a></code>, <code><a href="lattice.html#topic+histogram">lattice::densityplot()</a></code>, <code><a href="lattice.html#topic+panel.functions">lattice::panel.mathdensity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (all(c(require(car), require(lattice), require(latticeExtra)))) {
  x &lt;- rnorm(100, 10, 2)
  p1 &lt;- plotHist(x, HD = "stack")
  p2 &lt;- plotHist(x, HD = "over")
}
</code></pre>

<hr>
<h2 id='plotModelSeries'>Model series plot</h2><span id='topic+plotModelSeries'></span><span id='topic+plotMS'></span>

<h3>Description</h3>

<p>Produce a graphical output to examine the effect of using different model specifications (design)
on the predictive performance of these models (a model series). Devised to access the results of
<code><a href="#topic+buildModelSeries">buildModelSeries()</a></code> and <code><a href="#topic+statsMS">statsMS()</a></code>, but can be easily adapted to
work with any model structure and performance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModelSeries(
  obj,
  grid,
  line,
  ind,
  type = c("b", "g"),
  pch = c(20, 2),
  size = 0.5,
  arrange = "desc",
  color = NULL,
  xlim = NULL,
  ylab = NULL,
  xlab = NULL,
  at = NULL,
  ...
)

plotMS(
  obj,
  grid,
  line,
  ind,
  type = c("b", "g"),
  pch = c(20, 2),
  size = 0.5,
  arrange = "desc",
  color = NULL,
  xlim = NULL,
  ylab = NULL,
  xlab = NULL,
  at = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotModelSeries_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>data.frame</code>, generally returned by <code><a href="#topic+statsMS">statsMS()</a></code>,
containing:
</p>

<ol>
<li><p> a series of performance statistics of several models, and
</p>
</li>
<li><p> the design information of each model.
</p>
</li></ol>

<p>See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_grid">grid</code></td>
<td>
<p>Vector of integer values or character strings indicating the columns of the
<code>data.frame</code> containing the design data which will be gridded using the function
<code><a href="lattice.html#topic+levelplot">lattice::levelplot()</a></code>. See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_line">line</code></td>
<td>
<p>Character string or integer value indicating which of the performance statistics
(usually calculated by <code><a href="#topic+statsMS">statsMS()</a></code>) should be plotted using the function
<code><a href="lattice.html#topic+xyplot">lattice::xyplot()</a></code>. See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_ind">ind</code></td>
<td>
<p>Integer value indicating for which group of models the mean rank is to be calculated.
See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_type">type</code></td>
<td>
<p>Vector of character strings indicating some of the effects to be used when plotting
the performance statistics using <code><a href="lattice.html#topic+xyplot">lattice::xyplot()</a></code>. Defaults to <code>type = c("b", "g")</code>. See
<code><a href="lattice.html#topic+panel.xyplot">lattice::panel.xyplot()</a></code> for more information on how to set this argument.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_pch">pch</code></td>
<td>
<p>Vector with two integer values specifying the symbols to be used to plot points. The
first sets the symbol used to plot the performance statistic, while the second sets the symbol
used to plot the mean rank of the indicator set using argument <code>ind</code>. Defaults to
<code>pch = c(20, 2)</code>. See <code><a href="graphics.html#topic+points">graphics::points()</a></code> for possible values and their interpretation.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_size">size</code></td>
<td>
<p>Numeric value specifying the size of the symbols used for plotting the mean rank of
the indicator set using argument <code>ind</code>. Defaults to <code>size = 0.5</code>. See <code><a href="grid.html#topic+grid.points">grid::grid.points()</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_arrange">arrange</code></td>
<td>
<p>Character string indicating how the model series should be arranged, which can be
in ascending (<code>"asc"</code>) or descending (<code>"desc"</code>, default) order.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_color">color</code></td>
<td>
<p>Vector defining the colors to be used in the grid produced by function
<code><a href="lattice.html#topic+levelplot">lattice::levelplot()</a></code>. If <code>color = NULL</code>, defaults to <code>color = cm.colors(n)</code>, where <code>n</code> is the
number of unique values in the columns defined by argument <code>grid</code>. See <code><a href="grDevices.html#topic+palettes">grDevices::cm.colors()</a></code>
to see how to use other color palettes.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length 2, giving the x coordinates range. If <code>xlim = NULL</code> (which
is the recommended value), defaults to <code>xlim = c(0.5, dim(obj)[1] + 0.5)</code>. This is, so far, the
optimum range for adequate plotting.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_ylab">ylab</code></td>
<td>
<p>Character vector of length 2, giving the y-axis labels. When <code>obj</code> is a <code>data.frame</code>
returned by <code><a href="#topic+statsMS">statsMS()</a></code>, and the performance statistic passed to argument
<code>line</code> is one of those calculated by <code><a href="#topic+statsMS">statsMS()</a></code> (<code>"candidates"</code>, <code>"df"</code>, <code>"aic"</code>,
<code>"rmse"</code>, <code>"nrmse"</code>, <code>"r2"</code>, <code>"adj_r2"</code>, or <code>"ADJ_r2"</code>), the function tries to automatically
identify the correct <code>ylab</code>.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_xlab">xlab</code></td>
<td>
<p>Character vector of unit length, the x-axis label. Defaults <code>xlab = "Model ranking"</code>.</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_at">at</code></td>
<td>
<p>Numeric vector indicating the location of tick marks along the x axis (in native
coordinates).</p>
</td></tr>
<tr><td><code id="plotModelSeries_+3A_...">...</code></td>
<td>
<p>Other arguments for plotting, although most of these have no been tested. Argument
<code>asp</code>, for example, is not effective since the function automatically identifies the best aspect
for plotting based on the dimensions of the design data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This section gives more details about arguments <code>obj</code>, <code>grid</code>, <code>line</code>, <code>arrange</code>, and <code>ind</code>.
</p>


<h4>obj</h4>

<p>The argument <code>obj</code> usually constitutes a <code>data.frame</code> returned by <code><a href="#topic+statsMS">statsMS()</a></code>.
However, the user can use any <code>data.frame</code> object as far as it contains the two basic units of
information needed:
</p>

<ol>
<li><p> design data passed with argument <code>grid</code>
</p>
</li>
<li><p> performance statistic passed with argument <code>line</code>
</p>
</li></ol>




<h4>grid</h4>

<p>The argument <code>grid</code> indicates the <em>design</em> data which is used to produce the grid output in the
top of the model series plot. By <em>design</em> we mean the data that specify the structure of each
model and how they differ from each other. Suppose that eight linear models were fit using three
types of predictor variables (<code>a</code>, <code>b</code>, and <code>c</code>). Each of these predictor variables is available
in two versions that differ by their accuracy, where <code>0</code> means a less accurate predictor
variable, while <code>1</code> means a more accurate predictor variable. This yields 2^3 = 8 total possible
combinations. The <em>design</em> data would be of the following form:
</p>
<p><code style="white-space: pre;">&#8288;
&gt; design
  a b c
1 0 0 0
2 0 0 1
3 0 1 0
4 1 0 0
5 0 1 1
6 1 0 1
7 1 1 0
8 1 1 1
&#8288;</code>
</p>



<h4>line</h4>

<p>The argument <code>line</code> corresponds to the performance statistic that is used to arrange the models
in ascending or descending order, and to produce the line output in the bottom of the model
series plot. For example, it can be a series of values of adjusted coefficient of determination,
one for each model:
</p>
<p><code style="white-space: pre;">&#8288;
adj_r2 &lt;- c(0.87, 0.74, 0.81, 0.85, 0.54, 0.86, 0.90, 0.89)
&#8288;</code>
</p>



<h4>arrange</h4>

<p>The argument <code>arrange</code> automatically arranges the model series according to the performance
statistics selected with argument <code>line</code>. If <code>obj</code> is a <code>data.frame</code> returned by
<code><a href="#topic+statsMS">statsMS()</a></code>, then the function uses standard arranging approaches. For most
performance statistics, the models are arranged in descending order. The exception is when
<code>"r2"</code>, <code>"adj_r2"</code>, or <code>"ADJ_r2"</code> are used, in which case the models are arranged in ascending
order. This means that the model with lowest value appears in the leftmost side of the model
series plot, while the models with the highest value appears in the rightmost side of the plot.
</p>
<p><code style="white-space: pre;">&#8288;
&gt; arrange(obj, adj_r2)
  id a b c adj_r2
1  5 1 0 1   0.54
2  2 0 0 1   0.74
3  3 1 0 0   0.81
4  4 0 1 0   0.85
5  6 0 1 1   0.86
6  1 0 0 0   0.87
7  8 1 1 1   0.89
8  7 1 1 0   0.90
&#8288;</code>
</p>
<p>This results suggest that the best performing model is that of <code>id = 7</code>, while the model of
<code>id = 5</code> is the poorest one.
</p>



<h4>ind</h4>

<p>The model series plot allows to see how the design influences model performance. This is achieved
mainly through the use of different colors in the grid output, where each unique value in the
<em>design</em> data is represented by a different color. For the example given above, one could try to
see if the models built with the more accurate versions of the predictor variables have a better
performance by identifying their relative distribution in the model series plot. The models
placed at the rightmost side of the plot are those with the best performance.
</p>
<p>The argument <code>ind</code> provides another tool to help identifying how the design, more specifically
how each variable in the <em>design</em> data, influences model performance. This is done by simply
calculating the mean ranking of the models that were built using the updated version of each
predictor variable. This very same mean ranking is also used to rank the predictor variables and
thus identify which of them is the most important.
</p>
<p>After arranging the <code>design</code> data described above using the adjusted coefficient of
determination, the following mean rank is obtained for each predictor variable:
</p>
<p><code style="white-space: pre;">&#8288;
&gt; rank_center
     a    b    c
1 5.75 6.25 5.25
&#8288;</code>
</p>
<p>This result suggests that the best model performance is obtained when using the updated version
of the predictor variable <code>b</code>. In the model series plot, the predictor variable <code>b</code> appears in
the top row, while the predictor variable <code>c</code> appears in the bottom row.
</p>



<h3>Value</h3>

<p>An object of class <code>"trellis"</code> consisting of a model series plot.
</p>


<h3>Dependencies</h3>

<p>The <strong>grDevices</strong> package, provider of graphics devices and support for colours and fonts in R,
is required for <code><a href="#topic+plotModelSeries">plotModelSeries()</a></code> to work.
</p>
<p>The <strong>grid</strong> package, a rewrite of the graphics layout capabilities in R, is required for
<code><a href="#topic+plotModelSeries">plotModelSeries()</a></code> to work.
</p>


<h3>Warning</h3>

<p>Use the original functions <code><a href="lattice.html#topic+xyplot">lattice::xyplot()</a></code> and <code><a href="lattice.html#topic+levelplot">lattice::levelplot()</a></code> for higher
customization.
</p>


<h3>Note</h3>

<p>Some of the solutions used to build this function were found in the source code of the R-package
<strong>mvtsplot</strong>. As such, the author of that package, Roger D. Peng <a href="mailto:rpeng@jhsph.edu">rpeng@jhsph.edu</a>, is
entitled &lsquo;contributors&rsquo; to the R-package <strong>pedometrics</strong>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Deepayan Sarkar (2008). <em>Lattice: Multivariate Data Visualization with R.</em> Springer, New York.
ISBN 978-0-387-75968-5.
</p>
<p>Roger D. Peng (2008). <em>A method for visualizing multivariate time series data.</em> Journal of
Statistical Software. v. 25 (Code Snippet), p. 1-17.
</p>
<p>Roger D. Peng (2012). <em>mvtsplot: Multivariate Time Series Plot.</em> R package version 1.0-1.
<a href="https://CRAN.R-project.org/package=mvtsplot">https://CRAN.R-project.org/package=mvtsplot</a>.
</p>
<p>A. Samuel-Rosa, G. B. M. Heuvelink, G. de Mattos Vasques, and L. H. C. dos Anjos, Do more
detailed environmental covariates deliver more accurate soil maps?, <em>Geoderma</em>, vol. 243–244,
pp. 214–227, May 2015, doi: 10.1016/j.geoderma.2014.12.017.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">lattice::xyplot()</a></code> <code><a href="lattice.html#topic+levelplot">lattice::levelplot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (all(require(grDevices), require(grid))) {
  # This example follows the discussion in section "Details"
  # Note that the data.frame is created manually
  id &lt;- c(1:8)
  design &lt;- data.frame(a = c(0, 0, 1, 0, 1, 0, 1, 1),
                       b = c(0, 0, 0, 1, 0, 1, 1, 1),
                       c = c(0, 1, 0, 0, 1, 1, 0, 1))
  adj_r2 &lt;- c(0.87, 0.74, 0.81, 0.85, 0.54, 0.86, 0.90, 0.89)
  obj &lt;- cbind(id, design, adj_r2)
  p &lt;- plotModelSeries(obj, grid = c(2:4), line = "adj_r2", ind = 1, 
              color = c("lightyellow", "palegreen"),
              main = "Model Series Plot")
}
</code></pre>

<hr>
<h2 id='rowMinCpp'>Return the minimum value in each row of a numeric matrix</h2><span id='topic+rowMinCpp'></span>

<h3>Description</h3>

<p>This function returns the minimum value in each row of a numeric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMinCpp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMinCpp_+3A_x">x</code></td>
<td>
<p>Numeric matrix with two or more rows and/or columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is implemented in C++ to speed-up the computation time for
large matrices.
</p>


<h3>Value</h3>

<p>A numeric vector with the minimum value of each row if the matrix.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>rowMins()</code> in <a href="https://cran.r-project.org/package=matrixStats">https://cran.r-project.org/package=matrixStats</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(20), nrow = 5)
rowMinCpp(x)
</code></pre>

<hr>
<h2 id='skewness'>Moment coefficient of skewness</h2><span id='topic+skewness'></span>

<h3>Description</h3>

<p>Compute the moment coefficient of skewness of a continuous, possibly non-normal variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewness_+3A_x">x</code></td>
<td>
<p>Numeric vector, the values of the variable of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value: the moment coefficient of skewness of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>B. S. Everitt, <em>The Cambridge Dictionary of Statistics</em>, 3rd ed. Cambridge: Cambridge University
Press, 2006, p. 432.
</p>
<p>D. N. Joanes and C. A. Gill, Comparing measures of sample skewness and kurtosis, <em>J Royal
Statistical Soc D</em>, vol. 47, no. 1, pp. 183–189, Mar. 1998, doi: 10.1111/1467-9884.00122.
</p>
<p>H. Cramér, <em>Mathematical Methods of Statistics</em>. Princeton: Princeton University Press, 1946,
p. 575.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rlnorm(10)
skw &lt;- skewness(x)
</code></pre>

<hr>
<h2 id='statsModelSeries'>Obtain performance statistics of a series of linear models</h2><span id='topic+statsModelSeries'></span><span id='topic+statsMS'></span>

<h3>Description</h3>

<p>Compute several statistics measuring the performance of a series of linear models built using
<code><a href="#topic+buildModelSeries">buildModelSeries()</a></code>, with an option to rank the models based on one of the returned
performance statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statsModelSeries(model, design.info, arrange.by, digits)

statsMS(model, design.info, arrange.by, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statsModelSeries_+3A_model">model</code></td>
<td>
<p>A list of linear models returned by <code><a href="#topic+buildModelSeries">buildModelSeries()</a></code>.</p>
</td></tr>
<tr><td><code id="statsModelSeries_+3A_design.info">design.info</code></td>
<td>
<p>Extra information about the linear models in the series.</p>
</td></tr>
<tr><td><code id="statsModelSeries_+3A_arrange.by">arrange.by</code></td>
<td>
<p>Character string defining if the table with the performance statistics of the
linear models should be arranged, and which column should be used. Available options are
<code>"candidates"</code>, <code>"df"</code>, <code>"aic"</code>, <code>"rmse"</code>, <code>"nrmse"</code>, <code>"r2"</code>, <code>"adj_r2"</code>, and <code>"ADJ_r2"</code>.
Descending order is used by default and cannot be changed in the current implementation. See
&lsquo;Value&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="statsModelSeries_+3A_digits">digits</code></td>
<td>
<p>Integer or vector with six integers indicating the number of decimal places to be
used to round the performance statistics. If a vector is passed to the function, the number of
decimal places should be in the following order:
</p>
<p><code>c("aic", "rmse", "nrmse", "r2", "adj_r2", "ADJ_r2")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was devised to deal with a list of linear models generated by the function
<code><a href="#topic+buildModelSeries">buildModelSeries()</a></code>. The main objective is to compare several linear models using
several performance statistics. Such statistics can then be used to rank the linear models and
identify, for example, the best performing model, given the selected performance statistics.
</p>
<p>An important feature of <code><a href="#topic+buildModelSeries">buildModelSeries()</a></code> is that it uses the information about
the initial number of candidate predictor variables offered to the build the model to calculate
penalized or adjusted measures of model performance. Such information is recorded as an attribute
of the final model selected by <code><a href="#topic+buildModelSeries">buildModelSeries()</a></code>. This feature was included in
<code><a href="#topic+statsModelSeries">statsModelSeries()</a></code> because data-driven variable selection results biased linear
models (too optimistic), and the effective number of degrees of freedom is close to the number of
candidate predictor variables initially offered to the model (Harrell, 2001).
</p>


<h3>Value</h3>

<p>A data frame with several performance statistics:
</p>

<dl>
<dt>id</dt><dd><p>Identification of the model.</p>
</dd>
<dt>candidates</dt><dd><p>Number of candidate predictor variables initially
offered to the model.</p>
</dd>
<dt>df</dt><dd><p>Number of degrees of freedom of the final selected model.</p>
</dd>
<dt>aic</dt><dd><p>Akaike's Information Criterion (AIC). Obtained using
<code>extractAIC</code>.</p>
</dd>
<dt>rmse</dt><dd><p>Root-mean squared error, calculated based on the number of
candidate predictor variables initially offered to the model.</p>
</dd>
<dt>nrmse</dt><dd><p>Normalized Root-mean squared error, calculated as the ratio
between the RMSE and the standard deviation of the observed values of the
dependent variable.</p>
</dd>
<dt>r2</dt><dd><p>Multiple coefficient of determination.</p>
</dd>
<dt>adj_r2</dt><dd><p>Adjusted multiple coefficient of determination.</p>
</dd>
<dt>ADJ_r2</dt><dd><p>Adjusted multiple coefficient of determination. Calculations
are done based on the number of candidate predictor variables initially
offered to the model.</p>
</dd>
</dl>



<h3>TODO</h3>


<ul>
<li><p> Include other performance statistics such as: PRESS, BIC, Mallow's Cp, max(VIF);
</p>
</li>
<li><p> Add option to select which performance statistics should be returned.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Harrell, F. E. (2001) <em>Regression modelling strategies: with applications to linear models,
logistic regression, and survival analysis.</em> First edition. New York: Springer.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern applied statistics with S.</em> Fourth edition. New
York: Springer.
</p>
<p>A. Samuel-Rosa, G. B. M. Heuvelink, G. de Mattos Vasques, and L. H. C. dos Anjos, Do more
detailed environmental covariates deliver more accurate soil maps?, <em>Geoderma</em>, vol. 243–244,
pp. 214–227, May 2015, doi: 10.1016/j.geoderma.2014.12.017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildModelSeries">buildModelSeries()</a></code>, <code><a href="#topic+plotModelSeries">plotModelSeries()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  # based on the second example of function MASS:stepAIC()
  require(MASS)
  cpus1 &lt;- cpus
  for(v in names(cpus)[2:7])
    cpus1[[v]] &lt;- cut(cpus[[v]], unique(quantile(cpus[[v]])), 
                      include.lowest = TRUE)
  cpus0 &lt;- cpus1[, 2:8]  # excludes names, authors' predictions
  cpus.samp &lt;- sample(1:209, 100)
  cpus.form &lt;- list(formula(log10(perf) ~ syct + mmin + mmax + cach + chmin +
                    chmax + perf),
                    formula(log10(perf) ~ syct + mmin + cach + chmin + chmax),
                    formula(log10(perf) ~ mmax + cach + chmin + chmax + perf))
  data &lt;- cpus1[cpus.samp,2:8]
  cpus.ms &lt;- buildModelSeries(cpus.form, data, vif = TRUE, aic = TRUE)
  cpus.des &lt;- data.frame(a = c(0, 1, 0), b = c(1, 0, 1), c = c(1, 1, 0))
  stats &lt;- statsModelSeries(cpus.ms, design.info = cpus.des, arrange.by = "aic")
}
</code></pre>

<hr>
<h2 id='stepVIF'>Variable selection using the (generalized) variance-inflation factor (VIF)</h2><span id='topic+stepVIF'></span>

<h3>Description</h3>

<p>This function takes a linear model and selects the subset of predictor variables that meet a
user-specific collinearity threshold measured by the (generalized) variance-inflation factor
(VIF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepVIF(model, threshold = 10, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepVIF_+3A_model">model</code></td>
<td>
<p>Linear model (object of class 'lm') containing collinear predictor variables.</p>
</td></tr>
<tr><td><code id="stepVIF_+3A_threshold">threshold</code></td>
<td>
<p>Positive number defining the maximum allowed VIF. Defaults to <code>threshold = 10</code>.</p>
</td></tr>
<tr><td><code id="stepVIF_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if iteration results should be printed. Defaults to
<code>verbose = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stepVIF</code> starts computing the VIF of all predictor variables in the linear model. If the linear
model contains categorical predictor variables, generalized variance-inflation factors (GVIF)
(Fox and Monette, 1992), are calculated instead using <code><a href="car.html#topic+vif">car::vif()</a></code>. GVIF is interpretable as the
inflation in size of the confidence ellipse or ellipsoid for the coefficients of the predictor
variable in comparison with what would be obtained for orthogonal, uncorrelated data. Since
categorical predictors have more than one degree of freedom, <em>df</em>, the confidence ellipsoid will
have <em>df</em> dimensions, and GVIF will need to be adjusted so that it can be comparable across
predictor variables. The adjustment is made using the following equation:
</p>
<p><code class="reqn">GVIF^{1/(2\times df)}</code>
</p>
<p>The next step consists of evaluating if any of the predictor variables has a (G)VIF larger than
the specified threshold, the function default being <code>threshold = 10</code>. For, GVIF^(1/(2*df)), the
threshold will be <code>sqrt(threshold)</code>.
</p>
<p>If there is only one predictor variable that does not meet the VIF threshold, it is automatically
removed from the model and no further processing occurs. When there are two or more predictor
variables that do not meet the (G)VIF threshold, <code><a href="#topic+stepVIF">stepVIF()</a></code> fits a linear model
between each of them and the dependent variable. The predictor variable with the lowest adjusted
coefficient of determination is dropped from the model and new coefficients are calculated,
resulting in a new linear model.
</p>
<p>This process lasts until all predictor variables included in the new model meet the (G)VIF
threshold.
</p>
<p>Nothing is done if all predictor variables have a (G)VIF value lower that the threshold, and
<code><a href="#topic+stepVIF">stepVIF()</a></code> returns the original linear model.
</p>


<h3>Value</h3>

<p>A linear model (object of class 'lm') with low collinearity.
</p>


<h3>Dependencies</h3>

<p>The <strong>car</strong> package, provider of functions to accompany Fox and Weisberg's An R Companion to
Applied Regression, is required for <code><a href="#topic+plotHist">plotHist()</a></code> to work. The development version of
the <strong>car</strong> package is available on <a href="https://r-forge.r-project.org/projects/car/">https://r-forge.r-project.org/projects/car/</a> while its old
versions are available on the CRAN archive at
<a href="https://cran.r-project.org/src/contrib/Archive/car/">https://cran.r-project.org/src/contrib/Archive/car/</a>.
</p>


<h3>Note</h3>

<p>More on the use of GVIF to measure the collinearity in linear models containing categorical
predictor variables can be found on
<a href="https://stats.stackexchange.com/questions/70679/">StackExchange</a>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Fox, J. and Monette, G. (1992) Generalized collinearity diagnostics. <em>JASA</em>, 87, 178&ndash;183.
</p>
<p>Fox, J. (2008) <em>Applied Regression Analysis and Generalized Linear Models</em>, Second Edition. Sage.
</p>
<p>Fox, J. and Weisberg, S. (2011) <em>An R Companion to Applied Regression</em>, Second Edition. Thousand
Oaks: Sage.
</p>
<p>Hair, J. F., Black, B., Babin, B. and Anderson, R. E. (2010) <em>Multivariate data analysis</em>. New
Jersey: Pearson Prentice Hall.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics with S</em>. Fourth edition.
Springer.
</p>
<p>A. Samuel-Rosa, G. B. M. Heuvelink, G. de Mattos Vasques, and L. H. C. dos Anjos, Do more
detailed environmental covariates deliver more accurate soil maps?, <em>Geoderma</em>, vol. 243–244,
pp. 214–227, May 2015, doi: 10.1016/j.geoderma.2014.12.017.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+stepAIC">MASS::stepAIC()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(car)) {
  fit &lt;- lm(prestige ~ income + education + type, data = Duncan)
  fit &lt;- stepVIF(fit, threshold = 10, verbose = TRUE)
}
</code></pre>

<hr>
<h2 id='variogramBins'>Variogram binning</h2><span id='topic+variogramBins'></span><span id='topic+vgmLags'></span>

<h3>Description</h3>

<p>Computation of bins for sample (experimental) variograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogramBins(
  coords,
  n.lags = 7,
  type = "exp",
  cutoff = 0.5,
  base = 2,
  zero = 0.001,
  count = "pairs"
)

vgmLags(
  coords,
  n.lags = 7,
  type = "exp",
  cutoff = 0.5,
  base = 2,
  zero = 0.001,
  count = "pairs"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogramBins_+3A_coords">coords</code></td>
<td>
<p>Data frame or matrix with the projected x- and y-coordinates.</p>
</td></tr>
<tr><td><code id="variogramBins_+3A_n.lags">n.lags</code></td>
<td>
<p>Integer value defining the number of variogram bins (distance classes) that should
be computed. Defaults to <code>n = 7</code>.</p>
</td></tr>
<tr><td><code id="variogramBins_+3A_type">type</code></td>
<td>
<p>Character value defining the type of variogram bins that should be computed,
with options <code>"equi"</code> (equidistant, equal-width) and <code>"exp"</code> (exponential, exponentially
growing). Defaults to <code>type = "exp"</code>.</p>
</td></tr>
<tr><td><code id="variogramBins_+3A_cutoff">cutoff</code></td>
<td>
<p>Numeric value defining the fraction of the diagonal of the rectangle that spans the
data (bounding box) that should be used to set the maximum distance up to which variogram bins
should be computed. Defaults to <code>cutoff = 0.5</code>, i.e. half the diagonal of the bounding box.</p>
</td></tr>
<tr><td><code id="variogramBins_+3A_base">base</code></td>
<td>
<p>Numeric value defining the base of the exponential expression used to create
exponentially growing variogram bins. Used only when <code>type = "exp"</code>. Defaults to <code>base = 2</code>,
i.e. the width of the rightmost bin is equal to half the diagonal of <code>cutoff</code>, and so on.</p>
</td></tr>
<tr><td><code id="variogramBins_+3A_zero">zero</code></td>
<td>
<p>Numeric value setting the minimum pair-wise separation distance that should be used
to compute the variogram bins. Defaults to <code>zero = 0.0001</code>.</p>
</td></tr>
<tr><td><code id="variogramBins_+3A_count">count</code></td>
<td>
<p>Should the number of points (<code>"points"</code>) or point-pairs (<code>"pairs"</code>) per variogram
bin be computed? Defaults to <code>count = "pairs"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of numeric values with the lower and upper boundaries of the variogram bins. The
number of points or point-pairs per variogram bin is returned as an attribute.
</p>


<h3>Dependencies</h3>

<p>The <strong>SpatialTools</strong> package, provider of tools for spatial data analysis in R, is required for
<code><a href="#topic+variogramBins">variogramBins()</a></code> to work. The development version of the <strong>SpatialTools</strong> package
is available on <a href="https://github.com/jfrench/SpatialTools">https://github.com/jfrench/SpatialTools</a> while its old versions are available
on the CRAN archive at <a href="https://cran.r-project.org/src/contrib/Archive/SpatialTools/">https://cran.r-project.org/src/contrib/Archive/SpatialTools/</a>.
</p>


<h3>Reverse dependencies</h3>

<p>The <strong>spsann</strong> package, provider of methods for the optimization of sample configurations using
spatial simulated annealing in R, requires <code><a href="#topic+variogramBins">variogramBins()</a></code> for some of its
functions to work. The development version of the <strong>spsann</strong> package is available on
<a href="https://github.com/Laboratorio-de-Pedometria/spsann-package">https://github.com/Laboratorio-de-Pedometria/spsann-package</a>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Truong, P. N.; Heuvelink, G. B. M.; Gosling, J. P. Web-based tool for expert elicitation of the
variogram. <em>Computers and Geosciences</em>. v. 51, p. 390-399, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (all(c(require(SpatialTools), require(sp)))) {
  data(meuse, package = "sp")
  lags_points &lt;- variogramBins(coords = meuse[, 1:2], count = "points")
  lags_pairs &lt;- variogramBins(coords = meuse[, 1:2], count = "pairs")
}
</code></pre>

<hr>
<h2 id='variogramGuess'>Guess the parameters of a spatial covariance function</h2><span id='topic+variogramGuess'></span><span id='topic+vgmICP'></span>

<h3>Description</h3>

<p>Guess the parameters of the spatial covariance function of a random, regionalized variable. A
guess of such parameters is required to start the fitting functions of many geostatistical
packages such as <strong>gstat</strong>, <strong>geoR</strong>, and <strong>georob</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogramGuess(
  z,
  coords,
  lags,
  cutoff = 0.5,
  method = "a",
  min.npairs = 30,
  model = "matern",
  nu = 0.5,
  estimator = "qn",
  plotit = FALSE
)

vgmICP(
  z,
  coords,
  lags,
  cutoff = 0.5,
  method = "a",
  min.npairs = 30,
  model = "matern",
  nu = 0.5,
  estimator = "qn",
  plotit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogramGuess_+3A_z">z</code></td>
<td>
<p>Numeric vector with the values of the regionalized variable for which the values for the
spatial covariance parameters should be guessed.</p>
</td></tr>
<tr><td><code id="variogramGuess_+3A_coords">coords</code></td>
<td>
<p>Data frame or matrix with the projected x- and y-coordinates.</p>
</td></tr>
<tr><td><code id="variogramGuess_+3A_lags">lags</code></td>
<td>
<p>Numeric scalar defining the width of the variogram bins or a numeric vector with the
lower and upper bounds of the variogram bins. If missing, the variogram bins are computed using
<code><a href="#topic+variogramBins">variogramBins()</a></code>. See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="variogramGuess_+3A_cutoff">cutoff</code></td>
<td>
<p>Numeric value defining the fraction of the diagonal of the rectangle that spans the
data (bounding box) that should be used to set the maximum distance up to which variogram bins
should be computed. Defaults to <code>cutoff = 0.5</code>, i.e. half the diagonal of the bounding box.</p>
</td></tr>
<tr><td><code id="variogramGuess_+3A_method">method</code></td>
<td>
<p>Character keyword defining the method used for guessing the spatial covariance
parameters of the regionalized variable. Defaults to <code>method = "a"</code>. See &lsquo;Details&rsquo; for
more information.</p>
</td></tr>
<tr><td><code id="variogramGuess_+3A_min.npairs">min.npairs</code></td>
<td>
<p>Positive integer defining the minimum number of point-pairs required so that a
variogram bin is used to guessing the spatial covariance parameters of the  of the regionalized
variable. Defaults to <code>min.npairs = 30</code>.</p>
</td></tr>
<tr><td><code id="variogramGuess_+3A_model">model</code></td>
<td>
<p>Character keyword defining the spatial covariance function that will be fitted to
the data of the regionalized variable. Currently, most of the basic spatial covariance function
are accepted. See <code>geoR::cov.spatial()</code> for more information. Defaults to <code>model = "matern"</code>.</p>
</td></tr>
<tr><td><code id="variogramGuess_+3A_nu">nu</code></td>
<td>
<p>Numerical value for the additional smoothness parameter <code class="reqn">\nu</code> of the spatial
covariance function of the regionalized variable. See <code>RandomFields::RMmodel()</code> and argument
<code>kappa</code> of <code>geoR::cov.spatial()</code> for more information.</p>
</td></tr>
<tr><td><code id="variogramGuess_+3A_estimator">estimator</code></td>
<td>
<p>Character keyword defining the estimator for computing the sample (experimental)
variogram of the regionalized variable, with options <code>"qn"</code> (default), <code>"mad"</code>, <code>"matheron"</code>, and
<code>"ch"</code>. See <code>georob::sample.variogram()</code> for more details.</p>
</td></tr>
<tr><td><code id="variogramGuess_+3A_plotit">plotit</code></td>
<td>
<p>Should the guessed spatial covariance parameters be plotted along with the sample
(experimental) variogram of the regionalized variable? Defaults to <code>plotit = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are five methods two guess the covariance parameters. Two of them, <code>"a"</code> and <code>"c"</code>, rely on
a sample variogram with exponentially growing variogram bins, while the other three, <code>"b"</code>,
<code>"d"</code>, and <code>"e"</code>, use equal-width variogram bins (see <code><a href="#topic+variogramBins">variogramBins()</a></code>). All of
them are <a href="https://en.wikipedia.org/wiki/Heuristic">heuristic</a>.
</p>
<p>Method <code>"a"</code> was developed in-house and is the most elaborated of them, specially for guessing
the nugget variance.
</p>
<p>Method <code>"b"</code> was proposed by <a href="https://doi.org/10.1016/0098-3004%2895%2900095-X">doi:10.1016/0098-3004(95)00095-X</a>Jian et al. (1996) and
is implemented in <a href="https://support.sas.com/documentation/cdl/en/statug/63347/HTML/default/viewer.htm#statug_variogram_a0000000593.htm">SAS/STAT(R) 9.22</a>.
</p>
<p>Method <code>"c"</code> is implemented in the <strong>automap</strong>-package and was developed by
<a href="https://doi.org/10.1016/j.cageo.2008.10.011">doi:10.1016/j.cageo.2008.10.011</a>Hiemstra et al. (2009).
</p>
<p>Method <code>"d"</code> was developed by <a href="https://doi.org/10.1007/s11004-012-9434-1">doi:10.1007/s11004-012-9434-1</a>Desassis &amp; Renard (2012).
</p>
<p>Method <code>"e"</code> was proposed by Larrondo et al. (2003)
<a href="http://www.ccgalberta.com/ccgresources/report05/2003-122-varfit.pdf">http://www.ccgalberta.com/ccgresources/report05/2003-122-varfit.pdf</a> and is implemented in the
VARFIT module of GSLIB <a href="http://www.gslib.com/">http://www.gslib.com/</a>.
</p>


<h3>Value</h3>

<p>A vector of numerical values, the guesses for the spatial covariance parameters of the
regionalized variable:
</p>

<ul>
<li><p> nugget
</p>
</li>
<li><p> partial sill
</p>
</li>
<li><p> range
</p>
</li></ul>



<h3>Dependencies</h3>

<p>The <strong>georob</strong> package, provider of functions for the robust geostatistical analysis of spatial
data in R, is required for <code><a href="#topic+variogramGuess">variogramGuess()</a></code> to work. The old versions of the
<strong>georob</strong> package are available on the CRAN archive at
<a href="https://cran.r-project.org/src/contrib/Archive/georob/">https://cran.r-project.org/src/contrib/Archive/georob/</a>.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>References</h3>

<p>Desassis, N. &amp; Renard, D. Automatic variogram modelling by iterative least squares: univariate
and multivariate cases. <em>Mathematical Geosciences</em>. Springer Science + Business Media, v. 45, p.
453-470, 2012.
</p>
<p>Hiemstra, P. H.; Pebesma, E. J.; Twenhöfel, C. J. &amp; Heuvelink, G. B. Real-time automatic
interpolation of ambient gamma dose rates from the Dutch radioactivity monitoring network.
<em>Computers &amp; Geosciences</em>. Elsevier BV, v. 35, p. 1711-1721, 2009.
</p>
<p>Jian, X.; Olea, R. A. &amp; Yu, Y.-S. Semivariogram modelling by weighted least squares. <em>Computers &amp;
Geosciences</em>. Elsevier BV, v. 22, p. 387-397, 1996.
</p>
<p>Larrondo, P. F.; Neufeld, C. T. &amp; Deutsch, C. V. <em>VARFIT: a program for semi-automatic variogram
modelling</em>. Edmonton: Department of Civil and Environmental Engineering, University of Alberta,
p. 17, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variogramBins">variogramBins()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (all(c(require(sp), require(georob)))) {
  data(meuse, package = "sp")
  icp &lt;- variogramGuess(z = log(meuse$copper), coords = meuse[, 1:2])
}
</code></pre>

<hr>
<h2 id='vgmSCV'>Spatially correlated variance (SCV)</h2><span id='topic+vgmSCV'></span><span id='topic+vgmSCV.variomodel'></span><span id='topic+vgmSCV.variogramModel'></span><span id='topic+vgmSCV.georob'></span>

<h3>Description</h3>

<p>Compute the proportion of the variance that is spatially correlated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgmSCV(obj, digits = 4)

## S3 method for class 'variomodel'
vgmSCV(obj, digits = 4)

## S3 method for class 'variogramModel'
vgmSCV(obj, digits = 4)

## S3 method for class 'georob'
vgmSCV(obj, digits = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgmSCV_+3A_obj">obj</code></td>
<td>
<p>Variogram model fitted with available function in geostatistical packages such as
<strong>gstat</strong>, <strong>geoR</strong>, and <strong>georob</strong>.</p>
</td></tr>
<tr><td><code id="vgmSCV_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value indicating the proportion of the variance that is spatially correlated.
</p>


<h3>Author(s)</h3>

<p>Alessandro Samuel-Rosa <a href="mailto:alessandrosamuelrosa@gmail.com">alessandrosamuelrosa@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variogramBins">variogramBins()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (all(c(require(gstat), require(sp)))) {
  library(gstat)
  library(sp)
  data(meuse)
  sp::coordinates(meuse) &lt;- ~ x + y
  vgm1 &lt;- gstat::variogram(log(zinc) ~ 1, meuse)
  fit &lt;- gstat::fit.variogram(vgm1, gstat::vgm(1, "Sph", 300, 1))
  res &lt;- vgmSCV(fit)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
