<!DOCTYPE html><html lang="en"><head><title>Help for package cmstatrExt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cmstatrExt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cmstatrExt-package'><p>cmstatrExt: More Statistical Methods for Composite Material Data</p></a></li>
<li><a href='#augment.average_curve_lm'><p>Augment a <code>data.frame</code> with the results from <code>average_curve_lm</code></p></a></li>
<li><a href='#augment.average_curve_optim'><p>Augment a <code>data.frame</code> with the results from <code>average_curve_optim</code></p></a></li>
<li><a href='#average_curve_lm'><p>Generate an average curve using <code>lm</code></p></a></li>
<li><a href='#average_curve_optim'><p>Generate an average curve using <code>optim</code></p></a></li>
<li><a href='#fff_shear'><p>Example shear stress-shear strain data</p></a></li>
<li><a href='#iso_equiv_two_sample'><p>Calculate t1 and t2 pairs that have the same p-Value</p></a></li>
<li><a href='#k_equiv_two_sample'><p>Calculate the factors for a two-sample acceptance test</p></a></li>
<li><a href='#p_equiv'><p>p-Value for one-sample equivalency</p></a></li>
<li><a href='#p_equiv_two_sample'><p>p-Value for two-sample equivalency</p></a></li>
<li><a href='#pa12_tension'><p>Example stress-strain data</p></a></li>
<li><a href='#power_sim_dual'><p>Rejection rate for dual acceptance criteria based via simulation</p></a></li>
<li><a href='#print.average_curve_lm'><p>Print an <code>average_curve_lm</code> object</p></a></li>
<li><a href='#print.average_curve_optim'><p>Print an <code>average_curve_optim</code> object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#summary.average_curve_lm'><p>Summarize an <code>average_curve_lm</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>More Statistical Methods for Composite Material Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-05</td>
</tr>
<tr>
<td>Description:</td>
<td>A companion package to
  'cmstatr' <a href="https://cran.r-project.org/package=cmstatr">https://cran.r-project.org/package=cmstatr</a>. 'cmstatr' contains
  statistical methods that are published in the Composite Materials Handbook,
  Volume 1 (2012, ISBN: 978-0-7680-7811-4), while 'cmstatrExt' contains
  statistical methods that are not included in that handbook.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cmstatr/cmstatrExt">https://github.com/cmstatr/cmstatrExt</a>,
<a href="https://cmstatrExt.cmstatr.net">https://cmstatrExt.cmstatr.net</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cmstatr/cmstatrExt/issues">https://github.com/cmstatr/cmstatrExt/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, generics, Rcpp, rlang (&ge; 0.4.0), stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, testthat</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cmstatr, testthat (&ge; 3.0.0), tidyverse, lintr, xml2,
rmarkdown, knitr</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-07 02:59:10 UTC; stefan</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Kloppenborg [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Kloppenborg &lt;stefan@kloppenborg.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-07 14:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cmstatrExt-package'>cmstatrExt: More Statistical Methods for Composite Material Data</h2><span id='topic+cmstatrExt'></span><span id='topic+cmstatrExt-package'></span>

<h3>Description</h3>

<p><code>cmstatrExt</code> is a package that contains statistical methods that can be
used for composite material data, but that are not contained within
CMH-17.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stefan Kloppenborg <a href="mailto:stefan@kloppenborg.ca">stefan@kloppenborg.ca</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cmstatr/cmstatrExt">https://github.com/cmstatr/cmstatrExt</a>
</p>
</li>
<li> <p><a href="https://cmstatrExt.cmstatr.net">https://cmstatrExt.cmstatr.net</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cmstatr/cmstatrExt/issues">https://github.com/cmstatr/cmstatrExt/issues</a>
</p>
</li></ul>


<hr>
<h2 id='augment.average_curve_lm'>Augment a <code>data.frame</code> with the results from <code>average_curve_lm</code></h2><span id='topic+augment.average_curve_lm'></span>

<h3>Description</h3>

<p>Augment a <code>data.frame</code> with the results from <code>average_curve_lm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'average_curve_lm'
augment(x, newdata = NULL, extrapolate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment.average_curve_lm_+3A_x">x</code></td>
<td>
<p>an <code>average_curve_lm</code> object</p>
</td></tr>
<tr><td><code id="augment.average_curve_lm_+3A_newdata">newdata</code></td>
<td>
<p>(optional) a new <code>data.frame</code> to which to augment the object</p>
</td></tr>
<tr><td><code id="augment.average_curve_lm_+3A_extrapolate">extrapolate</code></td>
<td>
<p>whether to show the curve fit on all data or only
the data within the original fitted range. Default: FALSE</p>
</td></tr>
<tr><td><code id="augment.average_curve_lm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with new columns <code>.fit</code>, <code>.extrapolate</code> and
<code>.residual</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+average_curve_lm">average_curve_lm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve_fit &lt;- average_curve_lm(
  pa12_tension,
  Coupon,
  Stress ~ I(Strain) + I(Strain^2) + I(Strain^3) + 0,
  n_bins = 100
)
augment(curve_fit)
## # A tibble: 3,105 × 6
##    Coupon     Strain  Stress  .fit .extrapolate .residual
##    &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;            &lt;dbl&gt;
##  1 Coupon 4 0        -0.353  0     FALSE          -0.353
##  2 Coupon 4 0.000200 -0.0604 0.235 FALSE          -0.295
##  3 Coupon 4 0.000400  0.283  0.469 FALSE          -0.185
##  4 Coupon 4 0.000601  0.475  0.702 FALSE          -0.228
##  5 Coupon 4 0.000801  0.737  0.935 FALSE          -0.198
##  6 Coupon 4 0.00100   0.803  1.17  FALSE          -0.364
##  7 Coupon 4 0.00120   1.25   1.40  FALSE          -0.151
##  8 Coupon 4 0.00140   1.32   1.63  FALSE          -0.305
##  9 Coupon 4 0.00160   1.53   1.86  FALSE          -0.325
## 10 Coupon 4 0.00180   2.01   2.09  FALSE          -0.0735
## # i 3,095 more row
## # i Use `print(n = ...)` to see more rows

</code></pre>

<hr>
<h2 id='augment.average_curve_optim'>Augment a <code>data.frame</code> with the results from <code>average_curve_optim</code></h2><span id='topic+augment.average_curve_optim'></span>

<h3>Description</h3>

<p>Augment a <code>data.frame</code> with the results from <code>average_curve_optim</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'average_curve_optim'
augment(x, newdata = NULL, extrapolate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment.average_curve_optim_+3A_x">x</code></td>
<td>
<p>an <code>average_curve_optim</code> object</p>
</td></tr>
<tr><td><code id="augment.average_curve_optim_+3A_newdata">newdata</code></td>
<td>
<p>(optional) a new <code>data.frame</code> to which to augment the object</p>
</td></tr>
<tr><td><code id="augment.average_curve_optim_+3A_extrapolate">extrapolate</code></td>
<td>
<p>whether to show the curve fit on all data or only
the data within the original fitted range. Default: FALSE</p>
</td></tr>
<tr><td><code id="augment.average_curve_optim_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with new columns <code>.fit</code>, <code>.extrapolate</code> and
<code>.residual</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+average_curve_lm">average_curve_lm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve_fit &lt;- average_curve_optim(
  pa12_tension,
  Coupon,
  Strain,
  Stress,
  function(strain, par) {
    sum(par * c(strain, strain^2, strain^3))
  },
  c(c1 = 1, c2 = 1, c3 = 1),
  n_bins = 100
)
augment(curve_fit)
## # A tibble: 3,105 × 6
## Coupon     Strain  Stress  .fit .extrapolate .residual
##    &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;            &lt;dbl&gt;
##  1 Coupon 4 0        -0.353  0     FALSE          -0.353
##  2 Coupon 4 0.000200 -0.0604 0.235 FALSE          -0.295
##  3 Coupon 4 0.000400  0.283  0.469 FALSE          -0.185
##  4 Coupon 4 0.000601  0.475  0.702 FALSE          -0.228
##  5 Coupon 4 0.000801  0.737  0.935 FALSE          -0.198
##  6 Coupon 4 0.00100   0.803  1.17  FALSE          -0.364
##  7 Coupon 4 0.00120   1.25   1.40  FALSE          -0.151
##  8 Coupon 4 0.00140   1.32   1.63  FALSE          -0.305
##  9 Coupon 4 0.00160   1.53   1.86  FALSE          -0.325
## 10 Coupon 4 0.00180   2.01   2.09  FALSE          -0.0735
## # i 3,095 more rows
## # i Use `print(n = ...)` to see more rows

</code></pre>

<hr>
<h2 id='average_curve_lm'>Generate an average curve using <code>lm</code></h2><span id='topic+average_curve_lm'></span>

<h3>Description</h3>

<p>The user must decide on a single dependent variable (<code>Y</code>) and a
single independent variable (<code>X</code>). The user will specify a <code>formula</code> with
the relationship between the dependent and independent variables.
For a <code>data.frame</code> containing stress-strain (or load-deflection) data for
more than one coupon, the maximum value of <code>X</code> for each coupon is found and
the smallest maximum value determines the range over which the curve
fit is performed: the range is from zero to this value. Only positive
values of <code>X</code> are considered. For each coupon individually, the data is
divided into a user-specified number of bins and averaged within each bin.
The resulting binned/averaged data is then passed to <code><a href="stats.html#topic+lm">stats::lm()</a></code> to perform
the curve fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_curve_lm(data, coupon_var, model, n_bins = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="average_curve_lm_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="average_curve_lm_+3A_coupon_var">coupon_var</code></td>
<td>
<p>the variable for coupon identification</p>
</td></tr>
<tr><td><code id="average_curve_lm_+3A_model">model</code></td>
<td>
<p>a <code>formula</code> for the curve to fit</p>
</td></tr>
<tr><td><code id="average_curve_lm_+3A_n_bins">n_bins</code></td>
<td>
<p>the number of bins to average the data inside into before
fitting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When specifying the formula (argument <code>model</code>), there are two things to
keep in mind. First, based on physical behavior, it is normally desirable
to set the intercept to zero (e.g. so that there is 0 stress at 0 strain).
To do this, include a term <code>+0</code> in the formula. Second, when specifying
a term for a power of the <code>X</code> variable (for example, $X^2$), this needs
to be wrapped inside the &quot;as-is&quot; operator <code>I()</code>, otherwise, <code>R</code> will
treat it as an interaction term, rather than an exponent. In other words,
if you want to include a quadratic term, you need to write <code>I(X^2)</code>
(replacing <code>X</code> with the appropriate variable from your <code>data.frame</code>).
</p>


<h3>Value</h3>

<p>an object of class <code>average_curve_lm</code> with the following content:
</p>

<ul>
<li> <p><code>data</code> the original data provided to the function
</p>
</li>
<li> <p><code>binned_data</code> the data after the binning/averaging operation
</p>
</li>
<li> <p><code>fit_lm</code> the results of the call to <code>lm</code>
</p>
</li>
<li> <p><code>n_bins</code> the number of bins specified by the user
</p>
</li>
<li> <p><code>max_x</code> the upper end of the range used for fitting
</p>
</li>
<li> <p><code>y_var</code> the independent (<code>Y</code>) variable
</p>
</li>
<li> <p><code>x_var</code> the dependent (<code>X</code>) variable
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+tilde">~</a></code>, <code><a href="base.html#topic+AsIs">I()</a></code>, <code><a href="stats.html#topic+lm">lm()</a></code>,
<code><a href="#topic+average_curve_optim">average_curve_optim()</a></code>, <code><a href="#topic+print.average_curve_lm">print.average_curve_lm()</a></code>,
<code><a href="#topic+summary.average_curve_lm">summary.average_curve_lm()</a></code>, <code><a href="#topic+augment.average_curve_lm">augment.average_curve_lm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using the `pa12_tension` dataset and fitting a cubic polynomial with
# zero intercept:
curve_fit &lt;- average_curve_lm(
  pa12_tension,
  Coupon,
  Stress ~ I(Strain) + I(Strain^2) + I(Strain^3) + 0,
  n_bins = 100
)
print(curve_fit)
## Range: ` Strain ` in  [ 0,  0.1409409 ]
##
## Call:
##   average_curve_lm(data = pa12_tension, coupon_var = Coupon,
##                    model = Stress ~ I(Strain) + I(Strain^2) + I(Strain^3)
##                    + 0, n_bins = 100)
##
## Coefficients:
##    I(Strain)   I(Strain^2)   I(Strain^3)
##        1174         -8783         20586

</code></pre>

<hr>
<h2 id='average_curve_optim'>Generate an average curve using <code>optim</code></h2><span id='topic+average_curve_optim'></span>

<h3>Description</h3>

<p>The user must decide on a single dependent variable (<code>Y</code>) and a
single independent variable (<code>X</code>). The user will specify a function defining
the relationship between the dependent and independent variables.
For a <code>data.frame</code> containing stress-strain (or load-deflection) data for
more than one coupon, the maximum value of <code>X</code> for each coupon is found and
the smallest maximum value determines the range over which the curve
fit is performed: the range is from zero to this value. Only positive
values of <code>X</code> are considered. For each coupon individually, the data is
divided into a user-specified number of bins and averaged within each bin.
The resulting binned/averaged data is then used for curve fitting.
The mean squared error between the observed value of <code>Y</code> and the result of
the user-specified function evaluated at each <code>X</code> is minimized by varying
the parameters <code>par</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_curve_optim(
  data,
  coupon_var,
  x_var,
  y_var,
  fn,
  par,
  n_bins = 100,
  method = "L-BFGS-B",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="average_curve_optim_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="average_curve_optim_+3A_coupon_var">coupon_var</code></td>
<td>
<p>the variable for coupon identification</p>
</td></tr>
<tr><td><code id="average_curve_optim_+3A_x_var">x_var</code></td>
<td>
<p>the independent variable</p>
</td></tr>
<tr><td><code id="average_curve_optim_+3A_y_var">y_var</code></td>
<td>
<p>the dependent variable</p>
</td></tr>
<tr><td><code id="average_curve_optim_+3A_fn">fn</code></td>
<td>
<p>a function defining the relationship between <code>Y</code> and <code>X</code>.
See Details for more information.</p>
</td></tr>
<tr><td><code id="average_curve_optim_+3A_par">par</code></td>
<td>
<p>the initial guess for the parameters</p>
</td></tr>
<tr><td><code id="average_curve_optim_+3A_n_bins">n_bins</code></td>
<td>
<p>the number of bins to average the data inside into before
fitting</p>
</td></tr>
<tr><td><code id="average_curve_optim_+3A_method">method</code></td>
<td>
<p>The method to be used by <code>optim()</code>. Defaults to &quot;L-BFGS-B&quot;</p>
</td></tr>
<tr><td><code id="average_curve_optim_+3A_...">...</code></td>
<td>
<p>extra parameters to be passed to <code>optim()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fn</code> must have two arguments. The first argument must be the
value of the independent variable (<code>X</code>): this must be a numeric value
(of length one). The second argument must be a vector of the parameters of
the model, which are to be varied in order to obtain the best fit. See below
for an example.
</p>


<h3>Value</h3>

<p>an object of class <code>average_curve_optim</code> with the following content:
</p>

<ul>
<li> <p><code>data</code> the original data provided to the function
</p>
</li>
<li> <p><code>binned_data</code> the data after the binning/averaging operation
</p>
</li>
<li> <p><code>fn</code> the function supplied
</p>
</li>
<li> <p><code>fit_optim</code> the results of the call to <code>optim</code>
</p>
</li>
<li> <p><code>call</code> the call
</p>
</li>
<li> <p><code>n_bins</code> the number of bins specified by the user
</p>
</li>
<li> <p><code>max_x</code> the upper end of the range used for fitting
</p>
</li>
<li> <p><code>y_var</code> the independent (<code>Y</code>) variable
</p>
</li>
<li> <p><code>x_var</code> the dependent (<code>X</code>) variable
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim()</a></code>, <code><a href="#topic+average_curve_lm">average_curve_lm()</a></code>,
<code><a href="#topic+print.average_curve_optim">print.average_curve_optim()</a></code>, <code><a href="#topic+augment.average_curve_optim">augment.average_curve_optim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using the `pa12_tension` dataset and fitting a cubic polynomial with
# zero intercept:
curve_fit &lt;- average_curve_optim(
  pa12_tension,
  Coupon,
  Strain,
  Stress,
  function(strain, par) {
    sum(par * c(strain, strain^2, strain^3))
  },
  c(c1 = 1, c2 = 1, c3 = 1),
  n_bins = 100
)
## Range: ` Strain ` in  [ 0,  0.1409409 ]
##
## Call:
## average_curve_optim(data = pa12_tension, coupon_var = Coupon,
##                     x_var = Strain, y_var = Stress,
##                     fn = function(strain, par) {
##                       sum(par * c(strain, strain^2, strain^3))
##                     }, par = c(c1 = 1, c2 = 1, c3 = 1), n_bins = 100)
##
## Parameters:
##       c1        c2        c3
## 1174.372 -8783.106 20585.898

</code></pre>

<hr>
<h2 id='fff_shear'>Example shear stress-shear strain data</h2><span id='topic+fff_shear'></span>

<h3>Description</h3>

<p>Example shear stress-strain data. This data was collected using a novel
shear test method. Coupons were made using a thermoset via
Fused Filament Fabrication (FFF).
This data requires some clean-up, including removal of the &quot;toe&quot;, offsetting
the strain, and removal of the post-failure data points. These procedures
are demonstrated in the <code>stress-strain</code> vignette. See:
<code>vignette("stress-strain", package = "cmstatrExt")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fff_shear
</code></pre>


<h3>Format</h3>



<h4><code>fff_shear</code></h4>

<p>A data frame with 2,316 rows and 3 columns:
</p>

<dl>
<dt>Coupon</dt><dd><p>the coupon ID</p>
</dd>
<dt>Stress</dt><dd><p>the shear stress measurement <code style="white-space: pre;">&#8288;[psi]&#8288;</code></p>
</dd>
<dt>Strain</dt><dd><p>the shear strain measurement <code style="white-space: pre;">&#8288;[in/in]&#8288;</code></p>
</dd>
</dl>



<hr>
<h2 id='iso_equiv_two_sample'>Calculate t1 and t2 pairs that have the same p-Value</h2><span id='topic+iso_equiv_two_sample'></span>

<h3>Description</h3>

<p>Calculates pairs of t1 and t2 values, which have the same p-value for the
two-sample equivalency test. See <code><a href="#topic+p_equiv_two_sample">p_equiv_two_sample()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso_equiv_two_sample(n, m, alpha, t1max, t2max, n_points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso_equiv_two_sample_+3A_n">n</code></td>
<td>
<p>the size of the qualification sample</p>
</td></tr>
<tr><td><code id="iso_equiv_two_sample_+3A_m">m</code></td>
<td>
<p>the size of the equivalency sample</p>
</td></tr>
<tr><td><code id="iso_equiv_two_sample_+3A_alpha">alpha</code></td>
<td>
<p>the desired p-value</p>
</td></tr>
<tr><td><code id="iso_equiv_two_sample_+3A_t1max">t1max</code></td>
<td>
<p>the maximum value of t1 (only approximate)</p>
</td></tr>
<tr><td><code id="iso_equiv_two_sample_+3A_t2max">t2max</code></td>
<td>
<p>the maximum value of t2 (only approximate)</p>
</td></tr>
<tr><td><code id="iso_equiv_two_sample_+3A_n_points">n_points</code></td>
<td>
<p>the number of returned points is twice n_points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values t1 and t2 are based on the transformation:
</p>
<p>t1 = (X_mean - Y_min) / S
</p>
<p>t2 = (X_mean - Y_mean) / S
</p>
<p>Where:
</p>

<ul>
<li><p> X_mean is the mean of the qualification sample
</p>
</li>
<li><p> S is the standard deviation of the qualification sample
</p>
</li>
<li><p> Y_min is the minimum from the acceptance sample
</p>
</li>
<li><p> Y_mean is the mean of the acceptance sample
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> with values of t1 and t2
</p>


<h3>References</h3>

<p>Kloppenborg, S. (2023). Lot acceptance testing using sample mean and
extremum with finite qualification samples. Journal of Quality Technology,
https://doi.org/10.1080/00224065.2022.2147884
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p_equiv_two_sample">p_equiv_two_sample()</a></code>, <code><a href="#topic+k_equiv_two_sample">k_equiv_two_sample()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("tidyverse")){
  library(cmstatrExt)
  library(tidyverse)
  curve &lt;- iso_equiv_two_sample(24, 8, 0.05, 4, 1.5, 10)
  curve

  curve %&gt;%
    ggplot(aes(x = t1, y = t2)) +
      geom_path() +
      ggtitle("Acceptance criteria for alpha=0.05")
}


</code></pre>

<hr>
<h2 id='k_equiv_two_sample'>Calculate the factors for a two-sample acceptance test</h2><span id='topic+k_equiv_two_sample'></span>

<h3>Description</h3>

<p>Calculates the factors k1 and k2, which are used for setting acceptance
values for lot acceptance. These factors consider both the
size of the qualification sample (<code>n</code>)
and the size of acceptance sample (<code>m</code>).
This test is detailed in a forthcoming paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_equiv_two_sample(alpha, n, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k_equiv_two_sample_+3A_alpha">alpha</code></td>
<td>
<p>the desired probability of Type 1 error</p>
</td></tr>
<tr><td><code id="k_equiv_two_sample_+3A_n">n</code></td>
<td>
<p>the size of the qualification sample</p>
</td></tr>
<tr><td><code id="k_equiv_two_sample_+3A_m">m</code></td>
<td>
<p>the size of the acceptance sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2 with the contents <code>c(k1, k2)</code>
</p>


<h3>References</h3>

<p>Kloppenborg, S. (2023). Lot acceptance testing using sample mean and
extremum with finite qualification samples. Journal of Quality Technology,
https://doi.org/10.1080/00224065.2022.2147884
</p>

<hr>
<h2 id='p_equiv'>p-Value for one-sample equivalency</h2><span id='topic+p_equiv'></span>

<h3>Description</h3>

<p>Calculates the p-Value for a one-sample acceptance test
based on Vangel (2002).
This test considers the sample size of the acceptance sample (<code>m</code>).
</p>
<p>Two test statistics are required:
</p>
<p>t1 = (mu - Y_min) / sigma
</p>
<p>t2 = (mu - Y_mean) / sigma
</p>
<p>Where:
</p>

<ul>
<li><p> mu is the mean of the population
</p>
</li>
<li><p> sigma is the standard deviation of the population
</p>
</li>
<li><p> Y_min is the minimum from the acceptance sample
</p>
</li>
<li><p> Y_mean is the mean of the acceptance sample
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>p_equiv(m, t1, t2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_equiv_+3A_m">m</code></td>
<td>
<p>the size of the acceptance sample</p>
</td></tr>
<tr><td><code id="p_equiv_+3A_t1">t1</code></td>
<td>
<p>the test statistic described above. May be a vector.</p>
</td></tr>
<tr><td><code id="p_equiv_+3A_t2">t2</code></td>
<td>
<p>the test statistic described above. May be a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of p-Values of the same length as t1 and t2
</p>

<hr>
<h2 id='p_equiv_two_sample'>p-Value for two-sample equivalency</h2><span id='topic+p_equiv_two_sample'></span>

<h3>Description</h3>

<p>Calculates the p-Value for a two-sample acceptance test.
This test considers the sample size of the qualification
sample (<code>n</code>) and the acceptance sample (<code>m</code>).
</p>
<p>Two test statistics are required:
</p>
<p>t1 = (X_mean - Y_min) / S
</p>
<p>t2 = (X_mean - Y_mean) / S
</p>
<p>Where:
</p>

<ul>
<li><p> X_mean is the mean of the qualification sample
</p>
</li>
<li><p> S is the standard deviation of the qualification sample
</p>
</li>
<li><p> Y_min is the minimum from the acceptance sample
</p>
</li>
<li><p> Y_mean is the mean of the acceptance sample
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>p_equiv_two_sample(n, m, t1, t2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_equiv_two_sample_+3A_n">n</code></td>
<td>
<p>the size of the qualification sample</p>
</td></tr>
<tr><td><code id="p_equiv_two_sample_+3A_m">m</code></td>
<td>
<p>the size of the acceptance sample</p>
</td></tr>
<tr><td><code id="p_equiv_two_sample_+3A_t1">t1</code></td>
<td>
<p>the test statistic described above. May be a vector.</p>
</td></tr>
<tr><td><code id="p_equiv_two_sample_+3A_t2">t2</code></td>
<td>
<p>the test statistic described above. May be a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of p-Values of the same length as t1 and t2
</p>

<hr>
<h2 id='pa12_tension'>Example stress-strain data</h2><span id='topic+pa12_tension'></span>

<h3>Description</h3>

<p>Example tension stress-strain data. This data was generated by tracing the
stress-strain graph for PA12 from the manuscript referenced below. The
non-linearity seen at low strain in the original data set was removed, then
the data was re-sampling to produce more tightly spaced strain values.
Normally-distributed error was added to the stress.
The code used to generate the data set can be found at
<a href="https://github.com/cmstatr/cmstatrExt/blob/master/data-raw/pa12-tension.R">https://github.com/cmstatr/cmstatrExt/blob/master/data-raw/pa12-tension.R</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pa12_tension
</code></pre>


<h3>Format</h3>



<h4><code>pa12_tension</code></h4>

<p>A data frame with 3,212 rows and 3 columns:
</p>

<dl>
<dt>Coupon</dt><dd><p>the coupon ID</p>
</dd>
<dt>Strain</dt><dd><p>the strain measurement <code style="white-space: pre;">&#8288;[mm/mm]&#8288;</code></p>
</dd>
<dt>Stress</dt><dd><p>the stress measurement <code style="white-space: pre;">&#8288;[MPa]&#8288;</code></p>
</dd>
</dl>




<h3>Source</h3>

<p>Alomarah, Amer &amp; Ruan, Dong &amp; Masood, S. &amp; Gao, Zhanyuan. (2019).
Compressive properties of a novel additively manufactured 3D auxetic
structure. Smart Materials and Structures. 28.
10.1088/1361-665X/ab0dd6.
</p>

<hr>
<h2 id='power_sim_dual'>Rejection rate for dual acceptance criteria based via simulation</h2><span id='topic+power_sim_dual'></span>

<h3>Description</h3>

<p>Performs Monte Carlo simulation to determine the rejection rate of a
dual acceptance criteria (based on sample minimum and mean). By specifying
several sets of parameters for the &quot;equivalency&quot; distribution, a power
curve for the acceptance test can be determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_sim_dual(
  n_qual,
  m_equiv,
  replicates,
  distribution = "rnorm",
  param_qual,
  param_equiv,
  k1,
  k2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_sim_dual_+3A_n_qual">n_qual</code></td>
<td>
<p>the sample size of the qualification sample</p>
</td></tr>
<tr><td><code id="power_sim_dual_+3A_m_equiv">m_equiv</code></td>
<td>
<p>the sample size of the equivalency/acceptance sample</p>
</td></tr>
<tr><td><code id="power_sim_dual_+3A_replicates">replicates</code></td>
<td>
<p>the number of simulated qualification samples and
equivalency samples. If a single value is given, the
same numbers used for both, if a vector of length two
is given, the first element is the number of qualification
replicates and the second element is the number of
equivalency replicates.</p>
</td></tr>
<tr><td><code id="power_sim_dual_+3A_distribution">distribution</code></td>
<td>
<p>a function name for generating a random sample
(defaults to &quot;rnorm&quot;)</p>
</td></tr>
<tr><td><code id="power_sim_dual_+3A_param_qual">param_qual</code></td>
<td>
<p>a data.frame (must be single row) with columns matching the
arguments of the distribution function</p>
</td></tr>
<tr><td><code id="power_sim_dual_+3A_param_equiv">param_equiv</code></td>
<td>
<p>a data.frame with columns matching the arguments of the
distribution function. The simulation is repeated with
the parameters specified in each row of the data.frame.</p>
</td></tr>
<tr><td><code id="power_sim_dual_+3A_k1">k1</code></td>
<td>
<p>a factor for determining the acceptance criterion for sample
minimum, which is calculated as <code>mean_qual - k1 * sd_qual</code></p>
</td></tr>
<tr><td><code id="power_sim_dual_+3A_k2">k2</code></td>
<td>
<p>a factor for determining the acceptance criterion for sample
average, which is calculated as <code>mean_qual - k2 * sd_qual</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs simulation to estimate the performance of the
dual acceptance criteria commonly used for composite materials in
aerospace applications. These criteria are based on setting lower limits
on the minimum individual (lower extremum) and the mean of an &quot;acceptance&quot;
sample. These limits are computed based on the sample mean and sample
standard deviation of an initial &quot;qualification&quot; sample. The criteria
are intended to be a test of non-inferiority to determine if the material
lots from which the &quot;acceptance&quot; samples are drawn should be accepted for
production. Another common use of these criteria are to determine if a
process change, equipment change, or second manufacturing site is
acceptable for production.
</p>
<p>For each set of distribution parameters given by the rows of <code>param_equiv</code>,
a number of samples of size <code>m_equiv</code> are generated using the function
<code>distribution</code>. Next, a number of qualification samples of size <code>n_qual</code>
are generated
using the <code>distribution</code> function and the parameters given in <code>param_qual</code>.
Limits for minimum and average are determined for each qualification
sample. Each equivalency sample is compared with the limits determined
from each qualification sample. The number of replicate in this simulation
is given by <code>replicates</code>: if this is a vector of length two, the first
element is the number of qualification samples and the second is the number
of equivalency samples; if <code>replicates</code> is a single value, the same number
is used for the number of qualification samples and acceptance samples.
Therefore, for each row of <code>param_equiv</code> a total of
<code>replicates[1] * replicates[2]</code> criteria are evaluated.
</p>
<p>The argument <code>distribution</code> must correspond with a function that generates
(pseudo) random numbers. This function must have an argument <code>n</code> that
specifies the sample size to be generated. When the argument <code>distribution</code>
matches certain common distribution functions (such as <code>rnorm</code>), the C++
implementation of the random number generation function is used instead of
calling R code, which results in a significant speedup.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>. The first column(s) are duplicate of the <code>data.frame</code>
passed in the argument <code>param_equiv</code>. The last column is named
<code style="white-space: pre;">&#8288;Rejection Rate&#8288;</code> and has a value equal to the number of samples rejected
for each simulation run.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+k_equiv_two_sample">k_equiv_two_sample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute a power curve for a dual acceptance criteria for a qualification
# sample size of 18 and an equivalency sample size of 6, using 2000
# replicates. A standard normal distribution is used and the power to
# detect a decrease in mean is determined.
set.seed(12345) # make it reproducible
power_sim_dual(
  18, 6,
  2000,
  "rnorm",
  data.frame(mean = 0, sd = 1),
  data.frame(mean = c(-2, -1.5, -1, 0.5, 0), sd = 1),
  2.959, 0.954
)
##   mean sd Rejection Rate
## 1 -2.0  1     0.98349975
## 2 -1.5  1     0.88186900
## 3 -1.0  1     0.56382425
## 4  0.5  1     0.00864025
## 5  0.0  1     0.04826250

</code></pre>

<hr>
<h2 id='print.average_curve_lm'>Print an <code>average_curve_lm</code> object</h2><span id='topic+print.average_curve_lm'></span>

<h3>Description</h3>

<p>Print an <code>average_curve_lm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'average_curve_lm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.average_curve_lm_+3A_x">x</code></td>
<td>
<p>an <code>average_curve_lm</code> object</p>
</td></tr>
<tr><td><code id="print.average_curve_lm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>print.lm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object passed to this method is invisibly returned
(via <code>invisible(x)</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+average_curve_lm">average_curve_lm()</a></code>
</p>

<hr>
<h2 id='print.average_curve_optim'>Print an <code>average_curve_optim</code> object</h2><span id='topic+print.average_curve_optim'></span>

<h3>Description</h3>

<p>Print an <code>average_curve_optim</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'average_curve_optim'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.average_curve_optim_+3A_x">x</code></td>
<td>
<p>an <code>average_curve_optim</code> object</p>
</td></tr>
<tr><td><code id="print.average_curve_optim_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object passed to this method is invisibly returned
(via <code>invisible(x)</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+average_curve_optim">average_curve_optim()</a></code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="generics.html#topic+augment">generics::augment()</a></code>
</p>

<hr>
<h2 id='summary.average_curve_lm'>Summarize an <code>average_curve_lm</code> object</h2><span id='topic+summary.average_curve_lm'></span>

<h3>Description</h3>

<p>Summarize an <code>average_curve_lm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'average_curve_lm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.average_curve_lm_+3A_object">object</code></td>
<td>
<p>an <code>average_curve_lm</code> object</p>
</td></tr>
<tr><td><code id="summary.average_curve_lm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>summary.lm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This method only produces printed output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+average_curve_lm">average_curve_lm()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
