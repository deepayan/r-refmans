<!DOCTYPE html><html><head><title>Help for package furrr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {furrr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#furrr_options'><p>Options to fine tune furrr</p></a></li>
<li><a href='#furrr-package'><p>furrr: Apply Mapping Functions in Parallel using Futures</p></a></li>
<li><a href='#future_imap'><p>Apply a function to each element of a vector, and its index via futures</p></a></li>
<li><a href='#future_invoke_map'><p>Invoke functions via futures</p></a></li>
<li><a href='#future_map'><p>Apply a function to each element of a vector via futures</p></a></li>
<li><a href='#future_map_if'><p>Apply a function to each element of a vector conditionally via futures</p></a></li>
<li><a href='#future_map2'><p>Map over multiple inputs simultaneously via futures</p></a></li>
<li><a href='#future_modify'><p>Modify elements selectively via futures</p></a></li>
<li><a href='#future_options'><p>Deprecated furrr options</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Apply Mapping Functions in Parallel using Futures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of the family of map() functions from 'purrr'
    that can be resolved using any 'future'-supported backend, e.g.
    parallel on the local machine or distributed on a compute cluster.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DavisVaughan/furrr">https://github.com/DavisVaughan/furrr</a>,
<a href="https://furrr.futureverse.org/">https://furrr.futureverse.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DavisVaughan/furrr/issues">https://github.com/DavisVaughan/furrr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>future (&ge; 1.25.0), R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>globals (&ge; 0.14.0), lifecycle (&ge; 1.0.1), purrr (&ge; 0.3.4),
rlang (&ge; 1.0.2), vctrs (&ge; 0.4.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>carrier, covr, dplyr (&ge; 0.7.4), knitr, listenv (&ge; 0.6.0),
magrittr, rmarkdown, testthat (&ge; 3.0.0), tidyselect, withr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>progressr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-15 19:00:06 UTC; davis</td>
</tr>
<tr>
<td>Author:</td>
<td>Davis Vaughan [aut, cre],
  Matt Dancho [aut],
  RStudio [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Davis Vaughan &lt;davis@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-15 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='furrr_options'>Options to fine tune furrr</h2><span id='topic+furrr_options'></span>

<h3>Description</h3>

<p>These options fine tune furrr functions, such as <code><a href="#topic+future_map">future_map()</a></code>. They
are either used by furrr directly, or are passed on to <code><a href="future.html#topic+future">future::future()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>furrr_options(
  ...,
  stdout = TRUE,
  conditions = "condition",
  globals = TRUE,
  packages = NULL,
  seed = FALSE,
  scheduling = 1,
  chunk_size = NULL,
  prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="furrr_options_+3A_...">...</code></td>
<td>
<p>These dots are reserved for future extensibility and must
be empty.</p>
</td></tr>
<tr><td><code id="furrr_options_+3A_stdout">stdout</code></td>
<td>
<p>A logical.
</p>

<ul>
<li><p> If <code>TRUE</code>, standard output of the underlying futures is relayed as soon
as possible.
</p>
</li>
<li><p> If <code>FALSE</code>, output is silenced by sinking it to the null device.
</p>
</li></ul>
</td></tr>
<tr><td><code id="furrr_options_+3A_conditions">conditions</code></td>
<td>
<p>A character string of conditions classes to be relayed.
The default is to relay all conditions, including messages and warnings.
Errors are always relayed. To not relay any conditions (besides errors),
use <code>conditions = character()</code>. To selectively ignore specific classes,
use <code>conditions = structure("condition", exclude = "message")</code>.</p>
</td></tr>
<tr><td><code id="furrr_options_+3A_globals">globals</code></td>
<td>
<p>A logical, a character vector, a named list, or <code>NULL</code> for
controlling how globals are handled. For details, see the
<code style="white-space: pre;">&#8288;Global variables&#8288;</code> section below.</p>
</td></tr>
<tr><td><code id="furrr_options_+3A_packages">packages</code></td>
<td>
<p>A character vector, or <code>NULL</code>. If supplied, this specifies
packages that are guaranteed to be attached in the R environment where the
future is evaluated.</p>
</td></tr>
<tr><td><code id="furrr_options_+3A_seed">seed</code></td>
<td>
<p>A logical, an integer of length <code>1</code> or <code>7</code>, a list of
<code>length(.x)</code> with pre-generated random seeds, or <code>NULL</code>. For details, see
the <code style="white-space: pre;">&#8288;Reproducible random number generation (RNG)&#8288;</code> section below.</p>
</td></tr>
<tr><td><code id="furrr_options_+3A_scheduling">scheduling</code></td>
<td>
<p>A single integer, logical, or <code>Inf</code>. This argument
controls the average number of futures (&quot;chunks&quot;) per worker.
</p>

<ul>
<li><p> If <code>0</code>, then a single future is used to process all elements of <code>.x</code>.
</p>
</li>
<li><p> If <code>1</code> or <code>TRUE</code>, then one future per worker is used.
</p>
</li>
<li><p> If <code>2</code>, then each worker will process two futures (provided there
are enough elements in <code>.x</code>).
</p>
</li>
<li><p> If <code>Inf</code> or <code>FALSE</code>, then one future per element of <code>.x</code> is used.
</p>
</li></ul>

<p>This argument is only used if <code>chunk_size</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="furrr_options_+3A_chunk_size">chunk_size</code></td>
<td>
<p>A single integer, <code>Inf</code>, or <code>NULL</code>. This argument
controls the average number of elements per future (<code>"chunk"</code>). If <code>Inf</code>,
then all elements are processed in a single future. If <code>NULL</code>, then
<code>scheduling</code> is used instead to determine how <code>.x</code> is chunked.</p>
</td></tr>
<tr><td><code id="furrr_options_+3A_prefix">prefix</code></td>
<td>
<p>A single character string, or <code>NULL</code>. If a character string,
then each future is assigned a label as <code>{prefix}-{chunk-id}</code>. If <code>NULL</code>,
no labels are used.</p>
</td></tr>
</table>


<h3>Global variables</h3>

<p><code>globals</code> controls how globals are identified, similar to the <code>globals</code>
argument of <code><a href="future.html#topic+future">future::future()</a></code>. Since all function calls use the same set of
globals, furrr gathers globals upfront (once), which is more efficient than
if it was done for each future independently.
</p>

<ul>
<li><p> If <code>TRUE</code> or <code>NULL</code>, then globals are automatically identified and
gathered.
</p>
</li>
<li><p> If a character vector of names is specified, then those globals are
gathered.
</p>
</li>
<li><p> If a named list, then those globals are used as is.
</p>
</li>
<li><p> In all cases, <code>.f</code> and any <code>...</code> arguments are automatically passed as
globals to each future created, as they are always needed.
</p>
</li></ul>



<h3>Reproducible random number generation (RNG)</h3>

<p>Unless <code>seed = FALSE</code>, furrr functions are guaranteed to generate
the exact same sequence of random numbers <em>given the same initial
seed / RNG state</em> regardless of the type of futures and scheduling
(&quot;chunking&quot;) strategy.
</p>
<p>Setting <code>seed = NULL</code> is equivalent to <code>seed = FALSE</code>, except that the
<code>future.rng.onMisuse</code> option is not consulted to potentially monitor the
future for faulty random number usage. See the <code>seed</code> argument of
<code><a href="future.html#topic+future">future::future()</a></code> for more details.
</p>
<p>RNG reproducibility is achieved by pre-generating the random seeds for all
iterations (over <code>.x</code>) by using L'Ecuyer-CMRG RNG streams. In each
iteration, these seeds are set before calling <code>.f(.x[[i]], ...)</code>.
<em>Note, for large <code>length(.x)</code> this may introduce a large overhead.</em>
</p>
<p>A fixed <code>seed</code> may be given as an integer vector, either as a full
L'Ecuyer-CMRG RNG seed of length <code>7</code>, or as a seed of length <code>1</code> that
will be used to generate a full L'Ecuyer-CMRG seed.
</p>
<p>If <code>seed = TRUE</code>, then <code>.Random.seed</code> is returned if it holds a
L'Ecuyer-CMRG RNG seed, otherwise one is created randomly.
</p>
<p>If <code>seed = NA</code>, a L'Ecuyer-CMRG RNG seed is randomly created.
</p>
<p>If none of the function calls <code>.f(.x[[i]], ...)</code> use random number
generation, then <code>seed = FALSE</code> may be used.
</p>
<p>In addition to the above, it is possible to specify a pre-generated
sequence of RNG seeds as a list such that <code>length(seed) == length(.x)</code> and
where each element is an integer seed that can be assigned to <code>.Random.seed</code>.
Use this alternative with caution. <em>Note that <code>as.list(seq_along(.x))</code> is
not a valid set of such <code>.Random.seed</code> values.</em>
</p>
<p>In all cases but <code>seed = FALSE</code>, after a furrr function returns, the RNG
state of the calling R process is guaranteed to be &quot;forwarded one step&quot; from
the RNG state before the call. This is true regardless of the future
strategy / scheduling used. This is done in order to guarantee that an R
script calling <code>future_map()</code> multiple times should be numerically
reproducible given the same initial seed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>furrr_options()
</code></pre>

<hr>
<h2 id='furrr-package'>furrr: Apply Mapping Functions in Parallel using Futures</h2><span id='topic+furrr'></span><span id='topic+furrr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Implementations of the family of map() functions from 'purrr' that can be resolved using any 'future'-supported backend, e.g. parallel on the local machine or distributed on a compute cluster.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Davis Vaughan <a href="mailto:davis@rstudio.com">davis@rstudio.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Matt Dancho <a href="mailto:mdancho@business-science.io">mdancho@business-science.io</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> RStudio [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DavisVaughan/furrr">https://github.com/DavisVaughan/furrr</a>
</p>
</li>
<li> <p><a href="https://furrr.futureverse.org/">https://furrr.futureverse.org/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DavisVaughan/furrr/issues">https://github.com/DavisVaughan/furrr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='future_imap'>Apply a function to each element of a vector, and its index via futures</h2><span id='topic+future_imap'></span><span id='topic+future_imap_chr'></span><span id='topic+future_imap_dbl'></span><span id='topic+future_imap_int'></span><span id='topic+future_imap_lgl'></span><span id='topic+future_imap_raw'></span><span id='topic+future_imap_dfr'></span><span id='topic+future_imap_dfc'></span><span id='topic+future_iwalk'></span>

<h3>Description</h3>

<p>These functions work exactly the same as <code><a href="purrr.html#topic+imap">purrr::imap()</a></code> functions,
but allow you to map in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_imap(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_imap_chr(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_imap_dbl(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_imap_int(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_imap_lgl(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_imap_raw(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_imap_dfr(
  .x,
  .f,
  ...,
  .id = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_imap_dfc(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_iwalk(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_imap_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="future_imap_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="future_imap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="future_imap_+3A_.options">.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code><a href="#topic+furrr_options">furrr_options()</a></code>.</p>
</td></tr>
<tr><td><code id="future_imap_+3A_.env_globals">.env_globals</code></td>
<td>
<p>The environment to look for globals required by <code>.x</code> and
<code>...</code>. Globals required by <code>.f</code> are looked up in the function environment
of <code>.f</code>.</p>
</td></tr>
<tr><td><code id="future_imap_+3A_.progress">.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td></tr>
<tr><td><code id="future_imap_+3A_.id">.id</code></td>
<td>
<p>Either a string or <code>NULL</code>. If a string, the output will contain
a variable with that name, storing either the name (if <code>.x</code> is named) or
the index (if <code>.x</code> is unnamed) of the input. If <code>NULL</code>, the default, no
variable will be created.
</p>
<p>Only applies to <code style="white-space: pre;">&#8288;_dfr&#8288;</code> variant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as .x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plan(multisession, workers = 2)

future_imap_chr(sample(10), ~ paste0(.y, ": ", .x))


</code></pre>

<hr>
<h2 id='future_invoke_map'>Invoke functions via futures</h2><span id='topic+future_invoke_map'></span><span id='topic+future_invoke_map_chr'></span><span id='topic+future_invoke_map_dbl'></span><span id='topic+future_invoke_map_int'></span><span id='topic+future_invoke_map_lgl'></span><span id='topic+future_invoke_map_raw'></span><span id='topic+future_invoke_map_dfr'></span><span id='topic+future_invoke_map_dfc'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions work exactly the same as <code><a href="purrr.html#topic+invoke">purrr::invoke_map()</a></code> functions, but
allow you to invoke in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_invoke_map(
  .f,
  .x = list(NULL),
  ...,
  .env = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_invoke_map_chr(
  .f,
  .x = list(NULL),
  ...,
  .env = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_invoke_map_dbl(
  .f,
  .x = list(NULL),
  ...,
  .env = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_invoke_map_int(
  .f,
  .x = list(NULL),
  ...,
  .env = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_invoke_map_lgl(
  .f,
  .x = list(NULL),
  ...,
  .env = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_invoke_map_raw(
  .f,
  .x = list(NULL),
  ...,
  .env = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_invoke_map_dfr(
  .f,
  .x = list(NULL),
  ...,
  .env = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_invoke_map_dfc(
  .f,
  .x = list(NULL),
  ...,
  .env = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_invoke_map_+3A_.f">.f</code></td>
<td>
<p>A list of functions.</p>
</td></tr>
<tr><td><code id="future_invoke_map_+3A_.x">.x</code></td>
<td>
<p>A list of argument-lists the same length as <code>.f</code> (or length 1). The
default argument, <code>list(NULL)</code>, will be recycled to the same length as
<code>.f</code>, and will call each function with no arguments (apart from any
supplied in <code>...</code>).</p>
</td></tr>
<tr><td><code id="future_invoke_map_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to each function.</p>
</td></tr>
<tr><td><code id="future_invoke_map_+3A_.env">.env</code></td>
<td>
<p>Environment in which <code><a href="base.html#topic+do.call">do.call()</a></code> should
evaluate a constructed expression. This only matters if you pass
as <code>.f</code> the name of a function rather than its value, or as
<code>.x</code> symbols of objects rather than their values.</p>
</td></tr>
<tr><td><code id="future_invoke_map_+3A_.options">.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code><a href="#topic+furrr_options">furrr_options()</a></code>.</p>
</td></tr>
<tr><td><code id="future_invoke_map_+3A_.env_globals">.env_globals</code></td>
<td>
<p>The environment to look for globals required by <code>.x</code> and
<code>...</code>. Globals required by <code>.f</code> are looked up in the function environment
of <code>.f</code>.</p>
</td></tr>
<tr><td><code id="future_invoke_map_+3A_.progress">.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plan(multisession, workers = 2)

df &lt;- dplyr::tibble(
  f = c("runif", "rpois", "rnorm"),
  params = list(
    list(n = 10),
    list(n = 5, lambda = 10),
    list(n = 10, mean = -3, sd = 10)
  )
)

future_invoke_map(df$f, df$params, .options = furrr_options(seed = 123))


</code></pre>

<hr>
<h2 id='future_map'>Apply a function to each element of a vector via futures</h2><span id='topic+future_map'></span><span id='topic+future_map_chr'></span><span id='topic+future_map_dbl'></span><span id='topic+future_map_int'></span><span id='topic+future_map_lgl'></span><span id='topic+future_map_raw'></span><span id='topic+future_map_dfr'></span><span id='topic+future_map_dfc'></span><span id='topic+future_walk'></span>

<h3>Description</h3>

<p>These functions work exactly the same as <code><a href="purrr.html#topic+map">purrr::map()</a></code> and its variants, but
allow you to map in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_map(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_chr(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_dbl(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_int(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_lgl(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_raw(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_dfr(
  .x,
  .f,
  ...,
  .id = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_dfc(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_walk(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_map_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="future_map_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="future_map_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="future_map_+3A_.options">.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code><a href="#topic+furrr_options">furrr_options()</a></code>.</p>
</td></tr>
<tr><td><code id="future_map_+3A_.env_globals">.env_globals</code></td>
<td>
<p>The environment to look for globals required by <code>.x</code> and
<code>...</code>. Globals required by <code>.f</code> are looked up in the function environment
of <code>.f</code>.</p>
</td></tr>
<tr><td><code id="future_map_+3A_.progress">.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td></tr>
<tr><td><code id="future_map_+3A_.id">.id</code></td>
<td>
<p>Either a string or <code>NULL</code>. If a string, the output will contain
a variable with that name, storing either the name (if <code>.x</code> is named) or
the index (if <code>.x</code> is unnamed) of the input. If <code>NULL</code>, the default, no
variable will be created.
</p>
<p>Only applies to <code style="white-space: pre;">&#8288;_dfr&#8288;</code> variant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions return a vector the same length as <code>.x</code>.
</p>

<ul>
<li> <p><code><a href="#topic+future_map">future_map()</a></code> returns a list
</p>
</li>
<li> <p><code><a href="#topic+future_map_lgl">future_map_lgl()</a></code> a logical vector
</p>
</li>
<li> <p><code><a href="#topic+future_map_int">future_map_int()</a></code> an integer vector
</p>
</li>
<li> <p><code><a href="#topic+future_map_dbl">future_map_dbl()</a></code> a double vector
</p>
</li>
<li> <p><code><a href="#topic+future_map_chr">future_map_chr()</a></code> a character vector
</p>
</li></ul>

<p>The output of <code>.f</code> will be automatically typed upwards, e.g. logical -&gt;
integer -&gt; double -&gt; character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
plan(multisession, workers = 2)

1:10 %&gt;%
  future_map(rnorm, n = 10, .options = furrr_options(seed = 123)) %&gt;%
  future_map_dbl(mean)

# If each element of the output is a data frame, use
# `future_map_dfr()` to row-bind them together:
mtcars %&gt;%
  split(.$cyl) %&gt;%
  future_map(~ lm(mpg ~ wt, data = .x)) %&gt;%
  future_map_dfr(~ as.data.frame(t(as.matrix(coef(.)))))


# You can be explicit about what gets exported to the workers.
# To see this, use multisession (not multicore as the forked workers
# still have access to this environment)
plan(multisession)
x &lt;- 1
y &lt;- 2

# This will fail, y is not exported (no black magic occurs)
try(future_map(1, ~y, .options = furrr_options(globals = "x")))

# y is exported
future_map(1, ~y, .options = furrr_options(globals = "y"))


</code></pre>

<hr>
<h2 id='future_map_if'>Apply a function to each element of a vector conditionally via futures</h2><span id='topic+future_map_if'></span><span id='topic+future_map_at'></span>

<h3>Description</h3>

<p>These functions work exactly the same as <code><a href="purrr.html#topic+map_if">purrr::map_if()</a></code> and
<code><a href="purrr.html#topic+map_if">purrr::map_at()</a></code>, but allow you to run them in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_map_if(
  .x,
  .p,
  .f,
  ...,
  .else = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_at(
  .x,
  .at,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_map_if_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="future_map_if_+3A_.p">.p</code></td>
<td>
<p>A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as <code>.x</code>.
Alternatively, if the elements of <code>.x</code> are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where <code>.p</code> evaluates to
<code>TRUE</code> will be modified.</p>
</td></tr>
<tr><td><code id="future_map_if_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="future_map_if_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="future_map_if_+3A_.else">.else</code></td>
<td>
<p>A function applied to elements of <code>.x</code> for which <code>.p</code>
returns <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="future_map_if_+3A_.options">.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code><a href="#topic+furrr_options">furrr_options()</a></code>.</p>
</td></tr>
<tr><td><code id="future_map_if_+3A_.env_globals">.env_globals</code></td>
<td>
<p>The environment to look for globals required by <code>.x</code> and
<code>...</code>. Globals required by <code>.f</code> are looked up in the function environment
of <code>.f</code>.</p>
</td></tr>
<tr><td><code id="future_map_if_+3A_.progress">.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td></tr>
<tr><td><code id="future_map_if_+3A_.at">.at</code></td>
<td>
<p>A character vector of names, positive numeric vector of
positions to include, or a negative numeric vector of positions to
exlude. Only those elements corresponding to <code>.at</code> will be modified.
If the <code>tidyselect</code> package is installed, you can use <code>vars()</code> and
the <code>tidyselect</code> helpers to select elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return a list the same length as <code>.x</code> with the
elements conditionally transformed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plan(multisession, workers = 2)

# Modify the even elements
future_map_if(1:5, ~.x %% 2 == 0L, ~ -1)

future_map_at(1:5, c(1, 5), ~ -1)

</code></pre>

<hr>
<h2 id='future_map2'>Map over multiple inputs simultaneously via futures</h2><span id='topic+future_map2'></span><span id='topic+future_map2_chr'></span><span id='topic+future_map2_dbl'></span><span id='topic+future_map2_int'></span><span id='topic+future_map2_lgl'></span><span id='topic+future_map2_raw'></span><span id='topic+future_map2_dfr'></span><span id='topic+future_map2_dfc'></span><span id='topic+future_pmap'></span><span id='topic+future_pmap_chr'></span><span id='topic+future_pmap_dbl'></span><span id='topic+future_pmap_int'></span><span id='topic+future_pmap_lgl'></span><span id='topic+future_pmap_raw'></span><span id='topic+future_pmap_dfr'></span><span id='topic+future_pmap_dfc'></span><span id='topic+future_walk2'></span><span id='topic+future_pwalk'></span>

<h3>Description</h3>

<p>These functions work exactly the same as <code><a href="purrr.html#topic+map2">purrr::map2()</a></code> and its variants,
but allow you to map in parallel. Note that &quot;parallel&quot; as described in purrr
is just saying that you are working with multiple inputs, and parallel in
this case means that you can work on multiple inputs and process them all in
parallel as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_map2(
  .x,
  .y,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map2_chr(
  .x,
  .y,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map2_dbl(
  .x,
  .y,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map2_int(
  .x,
  .y,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map2_lgl(
  .x,
  .y,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map2_raw(
  .x,
  .y,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map2_dfr(
  .x,
  .y,
  .f,
  ...,
  .id = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map2_dfc(
  .x,
  .y,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_pmap(
  .l,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_pmap_chr(
  .l,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_pmap_dbl(
  .l,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_pmap_int(
  .l,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_pmap_lgl(
  .l,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_pmap_raw(
  .l,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_pmap_dfr(
  .l,
  .f,
  ...,
  .id = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_pmap_dfc(
  .l,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_walk2(
  .x,
  .y,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_pwalk(
  .l,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_map2_+3A_.x">.x</code>, <code id="future_map2_+3A_.y">.y</code></td>
<td>
<p>Vectors of the same length. A vector of length 1 will
be recycled.</p>
</td></tr>
<tr><td><code id="future_map2_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="future_map2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="future_map2_+3A_.options">.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code><a href="#topic+furrr_options">furrr_options()</a></code>.</p>
</td></tr>
<tr><td><code id="future_map2_+3A_.env_globals">.env_globals</code></td>
<td>
<p>The environment to look for globals required by <code>.x</code> and
<code>...</code>. Globals required by <code>.f</code> are looked up in the function environment
of <code>.f</code>.</p>
</td></tr>
<tr><td><code id="future_map2_+3A_.progress">.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td></tr>
<tr><td><code id="future_map2_+3A_.id">.id</code></td>
<td>
<p>Either a string or <code>NULL</code>. If a string, the output will contain
a variable with that name, storing either the name (if <code>.x</code> is named) or
the index (if <code>.x</code> is unnamed) of the input. If <code>NULL</code>, the default, no
variable will be created.
</p>
<p>Only applies to <code style="white-space: pre;">&#8288;_dfr&#8288;</code> variant.</p>
</td></tr>
<tr><td><code id="future_map2_+3A_.l">.l</code></td>
<td>
<p>A list of vectors, such as a data frame. The length of <code>.l</code>
determines the number of arguments that <code>.f</code> will be called with. List
names will be used if present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An atomic vector, list, or data frame, depending on the suffix.
Atomic vectors and lists will be named if <code>.x</code> or the first element of <code>.l</code>
is named.
</p>
<p>If all input is length 0, the output will be length 0. If any input is
length 1, it will be recycled to the length of the longest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plan(multisession, workers = 2)

x &lt;- list(1, 10, 100)
y &lt;- list(1, 2, 3)
z &lt;- list(5, 50, 500)

future_map2(x, y, ~ .x + .y)

# Split into pieces, fit model to each piece, then predict
by_cyl &lt;- split(mtcars, mtcars$cyl)
mods &lt;- future_map(by_cyl, ~ lm(mpg ~ wt, data = .))
future_map2(mods, by_cyl, predict)

future_pmap(list(x, y, z), sum)

# Matching arguments by position
future_pmap(list(x, y, z), function(a, b ,c) a / (b + c))

# Vectorizing a function over multiple arguments
df &lt;- data.frame(
  x = c("apple", "banana", "cherry"),
  pattern = c("p", "n", "h"),
  replacement = c("x", "f", "q"),
  stringsAsFactors = FALSE
)

future_pmap(df, gsub)
future_pmap_chr(df, gsub)


</code></pre>

<hr>
<h2 id='future_modify'>Modify elements selectively via futures</h2><span id='topic+future_modify'></span><span id='topic+future_modify_at'></span><span id='topic+future_modify_if'></span>

<h3>Description</h3>

<p>These functions work exactly the same as <code><a href="purrr.html#topic+modify">purrr::modify()</a></code> functions, but
allow you to modify in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_modify(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_modify_at(
  .x,
  .at,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_modify_if(
  .x,
  .p,
  .f,
  ...,
  .else = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_modify_+3A_.x">.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td></tr>
<tr><td><code id="future_modify_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="future_modify_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="future_modify_+3A_.options">.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code><a href="#topic+furrr_options">furrr_options()</a></code>.</p>
</td></tr>
<tr><td><code id="future_modify_+3A_.env_globals">.env_globals</code></td>
<td>
<p>The environment to look for globals required by <code>.x</code> and
<code>...</code>. Globals required by <code>.f</code> are looked up in the function environment
of <code>.f</code>.</p>
</td></tr>
<tr><td><code id="future_modify_+3A_.progress">.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td></tr>
<tr><td><code id="future_modify_+3A_.at">.at</code></td>
<td>
<p>A character vector of names, positive numeric vector of
positions to include, or a negative numeric vector of positions to
exlude. Only those elements corresponding to <code>.at</code> will be modified.
If the <code>tidyselect</code> package is installed, you can use <code>vars()</code> and
the <code>tidyselect</code> helpers to select elements.</p>
</td></tr>
<tr><td><code id="future_modify_+3A_.p">.p</code></td>
<td>
<p>A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as <code>.x</code>.
Alternatively, if the elements of <code>.x</code> are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where <code>.p</code> evaluates to
<code>TRUE</code> will be modified.</p>
</td></tr>
<tr><td><code id="future_modify_+3A_.else">.else</code></td>
<td>
<p>A function applied to elements of <code>.x</code> for which <code>.p</code>
returns <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From purrr:
</p>
<p>Since the transformation can alter the structure of the input;
it's your responsibility to ensure that the transformation produces a valid
output. For example, if you're modifying a data frame, <code>.f</code> must preserve the
length of the input.
</p>


<h3>Value</h3>

<p>An object the same class as <code>.x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
plan(multisession, workers = 2)

# Convert each col to character, in parallel
future_modify(mtcars, as.character)

iris %&gt;%
 future_modify_if(is.factor, as.character) %&gt;%
 str()

mtcars %&gt;%
  future_modify_at(c(1, 4, 5), as.character) %&gt;%
  str()


</code></pre>

<hr>
<h2 id='future_options'>Deprecated furrr options</h2><span id='topic+future_options'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#defunct"><img src="../help/figures/lifecycle-defunct.svg" alt='[Defunct]' /></a>
</p>
<p>As of furrr 0.3.0, <code>future_options()</code> is defunct in favor of
<code><a href="#topic+furrr_options">furrr_options()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_options(globals = TRUE, packages = NULL, seed = FALSE, scheduling = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_options_+3A_globals">globals</code></td>
<td>
<p>A logical, a character vector, a named list, or <code>NULL</code> for
controlling how globals are handled. For details, see the
<code style="white-space: pre;">&#8288;Global variables&#8288;</code> section below.</p>
</td></tr>
<tr><td><code id="future_options_+3A_packages">packages</code></td>
<td>
<p>A character vector, or <code>NULL</code>. If supplied, this specifies
packages that are guaranteed to be attached in the R environment where the
future is evaluated.</p>
</td></tr>
<tr><td><code id="future_options_+3A_seed">seed</code></td>
<td>
<p>A logical, an integer of length <code>1</code> or <code>7</code>, a list of
<code>length(.x)</code> with pre-generated random seeds, or <code>NULL</code>. For details, see
the <code style="white-space: pre;">&#8288;Reproducible random number generation (RNG)&#8288;</code> section below.</p>
</td></tr>
<tr><td><code id="future_options_+3A_scheduling">scheduling</code></td>
<td>
<p>A single integer, logical, or <code>Inf</code>. This argument
controls the average number of futures (&quot;chunks&quot;) per worker.
</p>

<ul>
<li><p> If <code>0</code>, then a single future is used to process all elements of <code>.x</code>.
</p>
</li>
<li><p> If <code>1</code> or <code>TRUE</code>, then one future per worker is used.
</p>
</li>
<li><p> If <code>2</code>, then each worker will process two futures (provided there
are enough elements in <code>.x</code>).
</p>
</li>
<li><p> If <code>Inf</code> or <code>FALSE</code>, then one future per element of <code>.x</code> is used.
</p>
</li></ul>

<p>This argument is only used if <code>chunk_size</code> is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>try(future_options())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
