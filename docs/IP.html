<!DOCTYPE html><html><head><title>Help for package IP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Arithmetic'><p> Methods for IP arithmetic</p></a></li>
<li><a href='#Bitwise-methods'><p> Bitwise operations</p></a></li>
<li><a href='#Comparison'><p> Methods for IP Comparison</p></a></li>
<li><a href='#Conversion-methods'><p> Methods for converting IP objects to other representations</p></a></li>
<li><a href='#Hostinfo'><p> host-info</p></a></li>
<li><a href='#IP classes'><p>IPv4, IPv6 and IP classes</p></a></li>
<li><a href='#IP range classes'><p>IPv4, IPv6 and IP ranges classes</p></a></li>
<li><a href='#IP-package'><p>Classes and methods for IP addresses</p></a></li>
<li><a href='#Varia'><p>Miscellaneous methods and functions for IP classes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Classes and Methods for 'IP' Addresses</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Soubiran [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Soubiran &lt;thomas.soubiran@univ-lille.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides S4 classes for Internet Protocol (IP) versions 4 and 6 addresses and efficient methods for 'IP' addresses comparison, arithmetic, bit manipulation and lookup. Both 'IPv4' and 'IPv6' arbitrary ranges are also supported as well as internationalized (IDN) domain lookup with and 'whois' query.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libidn: libidn11-dev (deb)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringi</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-02 20:36:54 UTC; dilleo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Arithmetic'> Methods for IP arithmetic </h2><span id='topic+Arith-methods'></span><span id='topic++2B'></span><span id='topic++2B-method'></span><span id='topic+-'></span><span id='topic+--method'></span><span id='topic++2B+2CIPv4+2CIPv4-method'></span><span id='topic++2B+2CIPv4+2Cinteger-method'></span><span id='topic++2B+2CIPv4+2Clogical-method'></span><span id='topic++2B+2CIPv4+2Cnumeric-method'></span><span id='topic+-+2CIPv4+2Cmissing-method'></span><span id='topic+-+2CIPv4+2CIPv4-method'></span><span id='topic+-+2CIPv4+2Cinteger-method'></span><span id='topic+-+2CIPv4+2Cnumeric-method'></span><span id='topic++2B+2CIPv6+2CIPv6-method'></span><span id='topic++2B+2CIPv6+2Cinteger-method'></span><span id='topic++2B+2CIPv6+2Cnumeric-method'></span><span id='topic++2B+2CIPv6+2Clogical-method'></span><span id='topic+-+2CIPv6+2Cmissing-method'></span><span id='topic+-+2CIPv6+2CIPv6-method'></span><span id='topic+-+2CIPv6+2Cinteger-method'></span><span id='topic+-+2CIPv6+2Cnumeric-method'></span><span id='topic+Arith+2CIP+2Cmissing-method'></span><span id='topic+Arith+2CIP+2CIP-method'></span><span id='topic+Arith+2CIP+2C.__intFP__.-method'></span><span id='topic++2B+2CIPv4r+2Cinteger-method'></span>

<h3>Description</h3>

<p>Methods for unary and binary IP arithmetic 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  -e1
  e1 + e2
  e1 - e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arithmetic_+3A_e1">e1</code></td>
<td>
<p>an object of either an 'IPv4', 'IPv6' or 'IP' class</p>
</td></tr>
<tr><td><code id="Arithmetic_+3A_e2">e2</code></td>
<td>
<p>either a corresponding object of class 'IPv4', 'IPv6', 'IP' or an integer or a numerical vector </p>
</td></tr>
</table>


<h3>Details</h3>


<p>Both IPv4 and v6 sets are represented as unsigned integers and are closed under addition and subtraction. An operation resulting in a negative number (or an overflow) is marked as NA. 


Operations are currently not always commutative. IP*-IP* are but those involving integers or floats are not. 
Thus, adding (or subtracting) an integer or a float to an IP* object will work but the reverse (adding (or subtracting) an IP* to an integer or a float) will raise an error (see example below and the caveat section in the package description). 
In addition multiplication and division are not implemented and will raise an error. 


Arithmetic operations involving IP* are better done using methods provided.
Both IPv4 and IPv6 addresses are represented as unsigned integers but <span class="rlang"><b>R</b></span> only works with 32 bits signed integers.
In addition, double precision numbers cannot represent all integers in the 0-(2^128-1) range. Therefore, converting an IPv6 object to numeric may cause a loss of precision and the same applies to arithmetic operations on IPv6 represented as floating point numbers.
</p>



<h3>Value</h3>

<p>an object of either an 'IPv4', 'IPv6' or 'IP' class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
ipv4("192.0.0.1") + 1
ipv6("fd00::1") + 1
ip(c("192.0.0.1", "fd00::1")) + 1

##
## Prohibited Arith operations
##
## this raises an error 
tryCatch(1L - ipv4("192.0.0.1"), error=function(e) e )
## and so will 
tryCatch(1 + ipv6("fd00::1"), error=function(e) e )
## as well as
tryCatch(ipv4("192.0.0.1") * 2, error=function(e) e )

##
## Loss of precision in arithmetical operations
##
(2^52 +1)- 2^52
(2^53 +1)- 2^53
##
identical((2^64 +1)- 2^64  , 0 )
## ...and so on
( (2^64 + 2^11 ) - (2^64))
## next representable number with IEEE 754 double precision floats; mind the gap
( (2^64 + 2^12 ) - (2^64))


## OTH,
((ipv6('::1') %&lt;&lt;% 53L) + ipv6('::1')) - (ipv6('::1') %&lt;&lt;% 53L)
##
(x &lt;- ( ( ipv6('::1') %&lt;&lt;% 64L ) + ( ipv6('::1') %&lt;&lt;% 11L ) ) - ( ipv6('::1') %&lt;&lt;% 64L ) )
log2(as.numeric(x))
</code></pre>

<hr>
<h2 id='Bitwise-methods'> Bitwise operations </h2><span id='topic+Logic-methods'></span><span id='topic+Logic+2CIP+2CIP-method'></span><span id='topic++21'></span><span id='topic++21-method'></span><span id='topic++21+2CIPv4-method'></span><span id='topic++21+2CIPv6-method'></span><span id='topic++26'></span><span id='topic++26-method'></span><span id='topic++26+2CIPv4+2CIPv4-method'></span><span id='topic++26+2CIPv6+2CIPv6-method'></span><span id='topic++26+2CIP+2CIP-method'></span><span id='topic++7C'></span><span id='topic++7C-method'></span><span id='topic++7C+2CIPv4+2CIPv4-method'></span><span id='topic++7C+2CIPv6+2CIPv6-method'></span><span id='topic++7C+2CIP+2CIP-method'></span><span id='topic++5E'></span><span id='topic++5E-methods'></span><span id='topic++5E+2CIPv4+2CIPv4-method'></span><span id='topic++5E+2CIPv6+2CIPv6-method'></span><span id='topic++5E+2CIP+2CIP-method'></span><span id='topic+ip.xor'></span><span id='topic+ip.xor-methods'></span><span id='topic+ip.xor+2CIPv4+2CIPv4-method'></span><span id='topic+ip.xor+2CIPv6+2CIPv6-method'></span><span id='topic+ip.xor+2CIP+2CIP-method'></span><span id='topic++25+3E+3E+25'></span><span id='topic++25+3E+3E+25-method'></span><span id='topic++25+3C+3C+25'></span><span id='topic++25+3C+3C+25-method'></span><span id='topic++25+3E+3E+25+2CIPv4+2Cinteger-method'></span><span id='topic++25+3C+3C+25+2CIPv4+2Cinteger-method'></span><span id='topic++25+3E+3E+25+2CIPv6+2Cinteger-method'></span><span id='topic++25+3C+3C+25+2CIPv6+2Cinteger-method'></span><span id='topic+ipv4.netmask'></span><span id='topic+ipv6.netmask'></span><span id='topic+ipv4.hostmask'></span><span id='topic+ipv6.hostmask'></span>

<h3>Description</h3>

<p>Methods for IP bitwise operations


<code>!e1</code> 

<code>e1 &amp; e2</code> 

<code>e1 | e2</code>

<code>e1 %&gt;&gt;% e2</code>

<code>e1 %&lt;&lt;% e2</code>

<code>e1 ^ e2 </code>

<code>ip.xor(e1 , e2 )</code>

<code>ipv4.netmask(n)</code>

<code>ipv6.netmask(n)</code>

<code>ipv4.hostmask(n)</code>

<code>ipv6.hostmask(n)</code>

</p>


<h3>Arguments</h3>


<table>
<tr><td><code id="Bitwise-methods_+3A_e1">e1</code></td>
<td>

<p>an object of either an 'IPv4', 'IPv6' or 'IP' class  
</p>
</td></tr>

<tr><td><code id="Bitwise-methods_+3A_e2">e2</code></td>
<td>

<p>an object of either an 'IPv4', 'IPv6' or 'IP' class except for shifts where e2 is like 'n' 
</p>
</td></tr>

<tr><td><code id="Bitwise-methods_+3A_n">n</code></td>
<td>

<p>an integer in the range (0,32) for IPv4 or in the (0,128) for IPv6 for masking methods
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The <code>&amp;</code>, <code>|</code> and <code>!</code> operators behave differently from their base R counterparts in that they perform bitwise operation much like in the C language.

</p>


<ul>
<li> <p><code>&amp;</code> : bitwise AND

</p>
</li>
<li> <p><code>|</code> : bitwise non exclusive OR

</p>
</li>
<li> <p><code>!</code> : bitwise NOT
</p>
</li></ul>


<p><code>ip.xor()</code> provides a faster alternative to base <code>xor()</code>.
</p>

<p><code>%&gt;&gt;%</code> and <code>%&lt;&lt;%</code> perform left (binary division) and right shift (binary multiplication) respectively.
</p>

<p>The <code>*.netmask()</code> and <code>*.hostmask()</code> functions return the net and host mask of specified length <code>n</code>.
</p>


<h3>Value</h3>

<p>an object of either an 'IPv4', 'IPv6' or 'IP' class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
private.network &lt;- ipv4r("192.0.0.0/16")
##
(mask.len &lt;- ceiling(log2(ip.range(private.network))))
##
ip &lt;- ipv4("192.168.1.1") 
##
(netmask &lt;- ipv4.netmask(mask.len))
##
ip &amp; netmask
##
(hostmask &lt;- ipv4.hostmask(mask.len))
##
ip &amp; hostmask
##
((ip &amp; netmask) | (ip &amp; hostmask) )==ip
## 2 complement
((!ip) + 1L)==-ip
##
ipv4('0.0.0.2') %&gt;&gt;% 1L
##
ipv4('0.0.0.2') %&lt;&lt;% 1L
##
## branchless swap
##
ipv4.ifelse &lt;- function(test, yes, no){
  ## 
  if( ( class(yes)!='IPv4' ) | ( class(no)!='IPv4' ) ){
    stop('both arguments should be of class IPv4')
  }
  ##
  ip.xor(
    no
    , ip.xor(
      no, yes
    ) &amp; -(ipv4(test)) ## mask
  )
}
##
x &lt;- ipv4('192.168.0.0') + 1:5
## recycling without warning (yet)
y &lt;- x + c(1,-1)
##
test &lt;- x &lt; y
##
data.frame(
  x, y, test, res= ipv4.ifelse(test , x,y)
)
##
##
##
ip6 &lt;- ipv6("2606:2800:220:1:248:1893:25c8:1946")
## Unicast addresses global routing prefix
ip6 &amp; ipv6.netmask(48)
## Subnet ID
ip6 &amp; (ipv6.hostmask(128-16) %&lt;&lt;% 64L)
## Interface ID 
ip6 &amp; ipv6.hostmask(64)
</code></pre>

<hr>
<h2 id='Comparison'> Methods for IP Comparison </h2><span id='topic+Compare-methods'></span><span id='topic+Compare+2CIP+2CIP-method'></span><span id='topic+Compare+2CIPr+2CIPr-method'></span><span id='topic++3D+3D'></span><span id='topic++3D+3D-method'></span><span id='topic++3D+3D+2CIPv4+2CIPv4-method'></span><span id='topic++3D+3D+2CIPv4r+2CIPv4r-method'></span><span id='topic++3D+3D+2CIPv6+2CIPv6-method'></span><span id='topic++3D+3D+2CIPv6r+2CIPv6r-method'></span><span id='topic++21+3D'></span><span id='topic++21+3D-method'></span><span id='topic++21+3D+2CIPv4+2CIPv4-method'></span><span id='topic++21+3D+2CIPv4r+2CIPv4r-method'></span><span id='topic++21+3D+2CIPv6+2CIPv6-method'></span><span id='topic++21+3D+2CIPv6r+2CIPv6r-method'></span><span id='topic++3C'></span><span id='topic++3C-method'></span><span id='topic++3C+2CIPv4+2CIPv4-method'></span><span id='topic++3C+2CIPv6+2CIPv6-method'></span><span id='topic++3E'></span><span id='topic++3E-method'></span><span id='topic++3E+2CIPv4+2CIPv4-method'></span><span id='topic++3E+2CIPv6+2CIPv6-method'></span><span id='topic++3C+3D'></span><span id='topic++3C+3D-method'></span><span id='topic++3C+3D+2CIPv4+2CIPv4-method'></span><span id='topic++3C+3D+2CIPv6+2CIPv6-method'></span><span id='topic++3E+3D'></span><span id='topic++3E+3D-method'></span><span id='topic++3E+3D+2CIPv4+2CIPv4-method'></span><span id='topic++3E+3D+2CIPv6+2CIPv6-method'></span>

<h3>Description</h3>

<p>Methods for IP binary comparison 
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Comparison_+3A_e1">e1</code>, <code id="Comparison_+3A_e2">e2</code></td>
<td>
<p>objects of either class 'IPv4', 'IPv6'or 'IP'</p>
</td></tr>

</table>


<h3>Details</h3>


<p>Only the <code>==</code> operator is supported for ranges
</p>


<h3>Value</h3>

<p>a logical vector
</p>


<h3>Methods</h3>


<dl>
<dt>x == y </dt><dd> </dd>
<dt>x != y </dt><dd> </dd>
<dt>x &gt; y </dt><dd> </dd>
<dt>x &lt; y </dt><dd> </dd>
<dt>x &gt;= y </dt><dd> </dd>
<dt>x &lt;= y </dt><dd> </dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  ##
  ip1 &lt;- ip(c("192.0.0.1", "fd00::1")) + rep(c(0:2),each=2)
  ##
  ip2 &lt;- ip1 + rep(c(1,-1,0), each=2)
  ##
  data.frame(
    ip1, ip2
    , lt = ip1&lt;ip2
    , le = ip1&lt;=ip2
    , eq = ip1==ip2
    , ge = ip1&gt;=ip2
    , gt = ip1&gt;ip2
  )
</code></pre>

<hr>
<h2 id='Conversion-methods'> Methods for converting IP objects to other representations </h2><span id='topic+coerce'></span><span id='topic+coerce-methods'></span><span id='topic+coerce+2CIPv4+2Ccharacter-method'></span><span id='topic+coerce+2CIPv6+2Ccharacter-method'></span><span id='topic+as.character'></span><span id='topic+as.character-methods'></span><span id='topic+as.character+2CIPv4-method'></span><span id='topic+as.character+2CIPv4r-method'></span><span id='topic+as.character+2CIPv6-method'></span><span id='topic+as.character+2CIPv6r-method'></span><span id='topic+as.character+2CIP-method'></span><span id='topic+as.character+2CIPr-method'></span><span id='topic+as.character+2Chost-method'></span><span id='topic+format'></span><span id='topic+format.IPv4'></span><span id='topic+format.IPv6'></span><span id='topic+format.IP'></span><span id='topic+format.IPv4r'></span><span id='topic+format.IPv6r'></span><span id='topic+format.IPr'></span><span id='topic+format.host'></span><span id='topic+toString'></span><span id='topic+toString.IPv4'></span><span id='topic+toString.IPv6'></span><span id='topic+toString.IP'></span><span id='topic+toString.IPv4r'></span><span id='topic+toString.IPv6r'></span><span id='topic+toString.IPr'></span><span id='topic+toString.host'></span><span id='topic+as.vector'></span><span id='topic+as.vector-methods'></span><span id='topic+as.vector+2C.__IPvr__.-method'></span><span id='topic+as.numeric'></span><span id='topic+as.numeric-methods'></span><span id='topic+as.numeric+2CIPv4-method'></span><span id='topic+as.numeric+2CIPv4r-method'></span><span id='topic+as.numeric+2CIPv6-method'></span><span id='topic+as.numeric+2CIPv6r-method'></span><span id='topic+as.numeric+2CIP-method'></span><span id='topic+as.integer'></span><span id='topic+as.integer-methods'></span><span id='topic+as.integer+2CIPv4-method'></span><span id='topic+as.integer+2CIPv4r-method'></span><span id='topic+as.integer+2CIPv6-method'></span><span id='topic+as.integer+2CIPv6r-method'></span>

<h3>Description</h3>

<p>Methods for converting IP objects to other representations





</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Conversion-methods_+3A_x">x</code></td>
<td>
<p> an object of class 'IPv4', 'IPv4r', 'IPv6', 'IP' or 'IPr'</p>
</td></tr>
<tr><td><code id="Conversion-methods_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='Hostinfo'> host-info </h2><span id='topic+host-class'></span><span id='topic+host'></span><span id='topic+host-methods'></span><span id='topic+host+2Ccharacter-method'></span><span id='topic+host+2CIPv4-method'></span><span id='topic+host+2CIPv6-method'></span><span id='topic+host+2CIP-method'></span><span id='topic+show+2Chost-method'></span><span id='topic+names.host'></span><span id='topic+host.info'></span><span id='topic+host.info-methods'></span><span id='topic+host.info+2CIPv4-method'></span><span id='topic+host.info+2CIPv6-method'></span><span id='topic+host.info+2CIP-method'></span><span id='topic+host.info+2Chost-method'></span><span id='topic+ipv4+2Chost-method'></span><span id='topic+ipv6+2Chost-method'></span><span id='topic+localhost.ip'></span><span id='topic+toIdna'></span><span id='topic+fromIdna'></span><span id='topic+fqdn'></span><span id='topic+is.fqdn'></span><span id='topic+rir.names'></span><span id='topic+ipv4.rir'></span><span id='topic+ipv6.rir'></span><span id='topic+ipv4.addr.space'></span><span id='topic+ipv6.addr.space'></span><span id='topic+ipv4.reserved'></span><span id='topic+ipv6.reserved'></span><span id='topic+ipv4.recovered'></span><span id='topic+ipv6.unicast'></span><span id='topic+whois'></span>

<h3>Description</h3>

<p>Methods for querying information about hosts (DNS) or IP (address spaces)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  host(host,...)
  
  host(host,...)
  
  host.info(host,...)
  
  localhost.ip(...)
  
  toIdna(domain, flags)
  
  fromIdna(domain, flags)
  
  fqdn(hostname) 
  
  is.fqdn(hostname)
  
  whois(domain, refer , output, verbose)
  
  rir.names() 
  
  ipv4.rir() 
  
  ipv6.rir() 
  
  ipv4.addr.space()  
  
  ipv6.addr.space()
  
  ipv4.reserved()
  
  ipv6.reserved()
  
  ipv4.recovered()
  
  ipv6.unicast()
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="Hostinfo_+3A_host">host</code></td>
<td>

<p>a vector of either or IPv4, IPv6, IP addresses
</p>
</td></tr>







<tr><td><code id="Hostinfo_+3A_...">...</code></td>
<td>

<p>further arguments. Only host.info (default:FALSE) for host() at the moment
</p>
</td></tr>

<tr><td><code id="Hostinfo_+3A_hostname">hostname</code></td>
<td>

<p>A character vector of host names
</p>
</td></tr>

<tr><td><code id="Hostinfo_+3A_domain">domain</code></td>
<td>

<p>A character vector of domain names
</p>
</td></tr>  

<tr><td><code id="Hostinfo_+3A_flags">flags</code></td>
<td>

<p>Flags for IDNA conversion. &quot;IDNA_DEFAULT&quot;: default behavior, &quot;IDNA_ALLOW_UNASSIGNED&quot;: allow processing of unassigned Unicode code points, &quot;IDNA_USE_STD3_ASCII_RULES&quot;: check output to make sure it is a STD3 conforming host name.
</p>
</td></tr>  

<tr><td><code id="Hostinfo_+3A_refer">refer</code></td>
<td>

<p>An optional referrer to be queried
</p>
</td></tr> 

<tr><td><code id="Hostinfo_+3A_output">output</code></td>
<td>

<p>An integer specifying whether to return the raw response from the referrer (0) or parse the response and return a key-value named vector (1). The latter is still experimental due to the heterogeneity of responses.
</p>
</td></tr> 

<tr><td><code id="Hostinfo_+3A_verbose">verbose</code></td>
<td>

<p>An integer specifying the level of verbosity
</p>
</td></tr>
</table>


<h3>Details</h3>




<h4>Methods and functions for querying informations about hosts</h4>




<ul>
<li> <p><code>host()</code> takes a character vector of domain names as arguments for DNS lookup. Addresses can be extracted with the corresponding methods (ipv4(), ipv6(), ip()). 
Also takes either IPv4, IPv6 or IP objects for reverse DNS lookup and returns the corresponding domain name (or NA if not found).

</p>
</li>
<li> <p><code>host.info()</code> (depreciated) takes either IPv4, IPv6 or IP objects for reverse DNS lookup and returns the corresponding domain name (or NA if not found)

</p>
</li>
<li> <p><code>localhost.ip()</code> retrieves the host's interfaces IP adresses

</p>
</li>
<li> <p><code>fqdn()</code> extracts the fully qualified name of a domain name, -eg to query <code>whois</code> databases

</p>
</li>
<li> <p><code>is.fqdn()</code> tests whether strings in a character vector qualify as fully qualified names

</p>
</li>
<li> <p><code>whois()</code> queries <code>whois</code> databases for a vector of fully qualified domain names. 
</p>
</li></ul>


<p>Since <code>localhost.ip()</code> needs OS specific system call &mdash;as well as <code>host()</code> and <code>host.info()</code>&mdash;, this function is only available for <b>POSIX compliant OS</b> at the moment. 
Support of Internationalized Domain Names (IDN) also depends on the system's libraries. For instance, glibc supports IDN starting with version 2.3.4. Use the <code>toIdna()</code> function to ensure proper domain names encoding. Note that result may differ depdending on the flag argument.

In addition, the <code>host()</code> and <code>host.info()</code> methods are still <b>very experimental</b> and might change in the future.
</p>

<p><code>whois</code> databases typically contain information such as registrars' names ... 
Note that responses are not standardized at all and may require an ad hoc parser. 
This is why the <code>whois()</code> function returns either a (still buggy at the moment) named vector of key-value pairs or the raw responses from the referrers.

The relevant referrer <code>url</code> can be determined automatically (default) or passed as an argument.
</p>






<h4>Functions returning IP addresses assignments from IANA registries</h4>




<ul>
<li> <p><code>ipv4.addr.space()</code> and <code>ipv6.addr.space()</code> : return the corresponding IP address space

</p>
</li>
<li> <p><code>ipv4.reserved()</code> and <code>ipv6.reserved()</code> : return the corresponding IP reserved address space 

</p>
</li>
<li> <p><code>ipv6.unicast()</code> : IPv6 unicast addresses

</p>
</li>
<li> <p><code>ipv4.recovered()</code> : pool of IPv4 addresses recovered by IANA from RIRs


</p>
</li>
<li> <p><code>ipv4.rir()</code> and <code>ipv6.rir()</code> : returns the RIRs IP address spaces

</p>
</li>
<li> <p><code>rir.names()</code> : Regional Internet Registry names
</p>
</li></ul>


<p>The IP address spaces is divided into many ranges with specific purposes. For instance, IP addresses can be assigned to organizations. Some addresses are otherwise reserved for special purposes such as loopback, subnetting, local communications within a private network, multicasting, broadcasting,...

The IP address space is managed globally by the Internet Assigned Numbers Authority (IANA), and locally by five regional Internet registries (RIRs) :  

</p>


<ul>
<li><p> The African Network Information Center (AFRINIC) serves Africa

</p>
</li>
<li><p>  The American Registry for Internet Numbers (ARIN) serves Antarctica, Canada, parts of the Caribbean, and the United States

</p>
</li>
<li><p> The Asia-Pacific Network Information Centre (APNIC) serves East Asia, Oceania, South Asia, and Southeast Asia

</p>
</li>
<li><p> The Latin America and Caribbean Network Information Centre (LACNIC) serves most of the Caribbean and all of Latin America

</p>
</li>
<li><p> The Réseaux IP Européens Network Coordination Centre (RIPE NCC) serves Europe, Central Asia, Russia, and West Asia
</p>
</li></ul>

<p>RIRs are responsible in their designated territories for assignment to end users and local Internet registries, such as Internet service providers. 
</p>

<p>Note differences in ouptut between <code>ipv4.addr.space()</code> and <code>ipv6.addr.space()</code>. 
RIRs IPv4 and Ipv6 assignments are stored by IANA in tables with different naming scheme (corresponding to <code>ipv4.addr.space()</code> and <code>ipv6.unicast()</code>). 
In the early days of IPv4 deployment, addresses were assigned directly to end user organizations. Therefore, <code>ipv4.addr.space()</code> also mixes RIR and end user organizations assignments. 
To find the corresponding RIR, use <code>ipv4.rir()</code> and <code>ipv6.rir()</code> instead.

Also note that some lookups may be misleading because some IPv4 ranges have been transferred from one RIR to an another (see example). For instance, some address ranges were assigned by ARIN in the 80's to European organizations such as universities before RIPE-NCC began its operations in 1992. Those ranges were later transferred to the RIPE NCC but still belong to the ARIN address space.

Likewise, some IPv4 addresses have been recovered by IANA from RIRs in order to delay IPv4 pool exhaustion and were later reassigned to other RIRs (see <code><a href="#topic+ipv4.recovered">ipv4.recovered</a></code>).
</p>



<h3>Value</h3>


<table>
<tr><td><code>host</code></td>
<td>
<p>an host object or a character vector</p>
</td></tr>

<tr><td><code>host.info</code></td>
<td>
<p>a character vector</p>
</td></tr>

<tr><td><code>localhost.ip</code></td>
<td>
<p>an IP</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##

host(
  ipv4(
    c("127.0.0.1")
  )
)
##
h &lt;- host(c(
  "icann.org", "iana.org"
))
##
host(ipv4(h))
##
## Domain names internationalization
##
##
## results may vary according to the (POSIX) platform
host(c("bucher.de", "Bücher.de"))

##
if( ip.capabilities()["IDN"] ){
  ## 
  dn &lt;- c( 
    enc2utf8("bücher.de") ## ensure UTF-8
    ## cannot input emoji with Latex 
    , "\U1f4a9" # or alternatively: rawToChar(as.raw(c(0xf0, 0x9f, 0x92, 0xa9, 0x2e, 0x6c, 0x61)))
  )
  ##
  Encoding(dn) &lt;- "UTF-8"
  ##
  dn
  ## enforce internationalization with different options
  flags &lt;-rep( c( "IDNA_DEFAULT" , "IDNA_ALLOW_UNASSIGNED"), each = length(dn))
  ##
  dni &lt;- toIdna( dn, flags)
  ## convert back
  fromIdna(dni, flags)

  ##
  host(dni)

}
##

##
## French country-code top-level domains (ccTLD)
##
tld &lt;- whois(
  c(
    "fr", "re", "tf", "wf", "pm", "yt"
    , "nc", "mq"##, "gp", "gf"
    , "pf"
  )
  , verbose = 1 ## be a little verbose
  , output = 1 ## output key-value pairs
)
##
sapply(tld, function(x) x[names(x)=="whois"])
##
## R related info
##
rhost     &lt;- host('r-project.org')
## hostname       : "cran.wu-wien.ac.at"
rhost.hnm &lt;- host.info(ipv4(rhost))
## primary domain : "ac.at"
fqdn(rhost.hnm)
## ARIN 
ipv4.rir()[ip.match(ipv4(rhost), ipv4.rir())]
##
ip.match(ipv4(rhost), ipv4.recovered())
## domain name info 
rdom.wh   &lt;- whois('r-project.org', output=1)
## "AT"
rdom.wh[['r-project.org']]['Registrant Country']
## host
rhost.wh0 &lt;- whois(ipv4(rhost),verbose = 2, output=1)

</code></pre>

<hr>
<h2 id='IP+20classes'>IPv4, IPv6 and IP classes</h2><span id='topic+IPv4-class'></span><span id='topic+IPv6-class'></span><span id='topic+IP-class'></span><span id='topic+ipv4'></span><span id='topic+ipv4-method'></span><span id='topic+ipv4+2Cmissing-method'></span><span id='topic+ipv4+2Ccharacter-method'></span><span id='topic+ipv4+2Cinteger-method'></span><span id='topic+ipv4+2Clogical-method'></span><span id='topic+ipv4+2CIP-method'></span><span id='topic+ipv6'></span><span id='topic+ipv6-method'></span><span id='topic+ipv6+2Cmissing-method'></span><span id='topic+ipv6+2Ccharacter-method'></span><span id='topic+ipv6+2Cinteger-method'></span><span id='topic+ipv6+2Clogical-method'></span><span id='topic+ipv6+2CIP-method'></span><span id='topic+ip'></span><span id='topic+ip-method'></span><span id='topic+ip+2Ccharacter-method'></span><span id='topic+ip+2Clist-method'></span><span id='topic+ip+2Cmissing+2Cmissing-method'></span><span id='topic+ip+2CIPv4+2CIPv6-method'></span><span id='topic+ip+2CIPv4+2Cmissing-method'></span><span id='topic+ip+2CIPv6+2Cmissing-method'></span><span id='topic+ip+2Ccharacter+2Cmissing-method'></span><span id='topic+ip+2Cinteger+2Cmissing-method'></span><span id='topic+ip+2Clist+2Cmissing-method'></span><span id='topic+ip+2Clogical+2Cmissing-method'></span><span id='topic+ip+2CIPr+2Cmissing-method'></span><span id='topic+ip+2Chost+2Cmissing-method'></span><span id='topic+ip.version'></span><span id='topic+ip.version-methods'></span><span id='topic+ip.version+2CIPv4-method'></span><span id='topic+ip.version+2CIP-method'></span><span id='topic++5B-method'></span><span id='topic++5B+2CIPv4+2C.__subscript__.-method'></span><span id='topic++5B+2CIPv6+2C.__subscript__.-method'></span><span id='topic++5B+2CIP+2C.__subscript__.-method'></span><span id='topic++5B+3C--method'></span><span id='topic++5B+3C-+2CIPv4+2C.__subscript__.-method'></span><span id='topic++5B+3C-+2CIPv6+2C.__subscript__.-method'></span><span id='topic++5B+3C-+2CIP+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CIP+2C.__subscript__.-method'></span><span id='topic++5B+3C-+2CIP+2C.__subscript__.+2CANY+2CIPv4-method'></span><span id='topic++5B+3C-+2CIP+2C.__subscript__.+2CANY+2CIPv6-method'></span><span id='topic++5B+3C-+2CIP+2C.__subscript__.+2CANY+2Clogical-method'></span><span id='topic+print-methods'></span><span id='topic+print+2CIP-method'></span><span id='topic+print+2CIPv4-method'></span><span id='topic+print+2CIPv6-method'></span><span id='topic+show-methods'></span><span id='topic+show+2CIPv4-method'></span><span id='topic+show+2CIPv6-method'></span><span id='topic+show+2CIP-method'></span><span id='topic++5B+2CIPv4+2C.__subscript__.-method'></span><span id='topic++5B+3C-+2CIP+2C.__subscript__.+2CANY+2CIPv4-method'></span><span id='topic++5B+3C-+2CIPv4+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CIPv6+2C.__subscript__.-method'></span><span id='topic++5B+3C-+2CIPv6+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CIP+2C.__subscript__.+2CANY+2CIP-method'></span><span id='topic++5B+3C-+2CIP+2C.__subscript__.+2CANY+2CANY-method'></span><span id='topic++5B+5B-method'></span><span id='topic++5B+5B+2C.__IPvr__.+2C.__subscript__.-method'></span><span id='topic+names.IPv4'></span><span id='topic+names.IPv6'></span><span id='topic+names.IP'></span><span id='topic+names+3C-.IPv4'></span><span id='topic+names+3C-.IPv6'></span><span id='topic+names+3C-.IP'></span><span id='topic+as.data.frame-method'></span><span id='topic+as.data.frame.IPv4'></span><span id='topic+as.data.frame.IPv6'></span><span id='topic+as.data.frame.IP'></span><span id='topic+c.IPv4'></span><span id='topic+c.IPv6'></span><span id='topic+c.IP'></span><span id='topic+rbind2-method'></span><span id='topic+rbind2+2CIPv4+2CIPv4-method'></span><span id='topic+rbind2+2CIPv6+2CIPv6-method'></span><span id='topic+rbind2+2CIP+2CIP-method'></span><span id='topic+rep.IPv4'></span><span id='topic+rep.IPv6'></span><span id='topic+rep.IP'></span><span id='topic+is.numeric-method'></span><span id='topic+is.numeric+2CIPv4-method'></span><span id='topic+is.numeric+2CIPv6-method'></span><span id='topic+is.numeric+2CIP-method'></span>

<h3>Description</h3>

<p>classes for IPv4 and IPv6 addresses</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ipv4(object,...)
  ipv6(object,...)
  ip(e1,e2,...)
  
  
  
  
  
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="IP+2B20classes_+3A_object">object</code></td>
<td>
<p>a vector of IPv4 or IPv6 strings. If missing, returns an empty IPv4 or IPv6 object</p>
</td></tr>

<tr><td><code id="IP+2B20classes_+3A_e1">e1</code>, <code id="IP+2B20classes_+3A_e2">e2</code></td>
<td>
<p>either e1= a vector of IPv4 or IPv6 strings (and e2 missing) or objects of class e1 = an object of class IPv4' and e2 = an object of class 'IPv6</p>
</td></tr>



<tr><td><code id="IP+2B20classes_+3A_...">...</code></td>
<td>
<p>for <code>c</code>, zero or more objects objects of either class 'IPv4' or 'IPv6'or 'IP' exclusively</p>
</td></tr>
</table>


<h3>Details</h3>


<p>IPv4 and IPv6 objects are created either from either character strings or integer vectors through <code>ipv4()</code> and <code>ipv6()</code> calls.
</p>

<p>IP objects store both IPv4 and IPv6 addresses. IP are created either from a character string or from IPv4 and IPv6 objects through <code>ip()</code> calls. 

Since the IPv4 and IPv6 protocols use a different address representation, IP objects store both IPv4 and IPv6 addresses but do not mix them. The i-th element of an IP object can only an IPv4 or an IPv6 address but not both. So, if the i-th IPv4 is set, the corresponding i-th IPv6 must be NA and vice-versa.
</p>

<p>in addition to object creation, he <code>ipv4()</code> and <code>ipv6()</code> methods also extract the IPv4 and IPv6 addresses from an IP object and return an object with the same length. Use the drop argument to remove all NA values.
</p>

<p>Like atomic base R vectors, IPv4, IPv6 and IP objects elements can be subsetted (<code>[</code>) and replaced (<code>[&lt;-</code>) and named (<code>name&lt;-</code>). Objects can also be concatenated (<code>c()</code> or <code>rbind2()</code>) or stored in a <code>data.frame</code>.
</p>

<p>Note that in order to avoid undesirable side-effects, <code>is.numeric()</code> returns <code>FALSE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
ipv4("0.0.0.0")==ipv4(0L)
##
ipv6("::")==ipv6(0L)
## create an empty object
ip0    &lt;- ip()
## grow it
ip0[3] &lt;- ipv4(3L)
ip0[5] &lt;- ipv6(5L)
ip0
## same thing with NA
ip0    &lt;- ip()
ip0[2] &lt;- NA
ip0
## private networks
ip.strings &lt;- c(v4 = "192.0.0.1", v6 = "fd00::1" )
##
(ip4 &lt;- ipv4(ip.strings))
##
(ip6 &lt;- ipv6(ip.strings))
##
(ip &lt;- ip(ip.strings))
##
all(ip==ip(ip4, ip6))
##
pnet0 &lt;- data.frame(
  ip 
  , v = ip.version(ip)
)
##
pnet1 &lt;- rbind(
  pnet0
  , within(pnet0, ip &lt;- ip+1L)
)
##
pnet0==pnet1[1:2,] 
## fails (why?): 
identical(pnet0,pnet1[1:2,])
##
ip(ip4[1],ip6[2],append=TRUE)
##
## IPv6 transition mechanism
##
## IPv4-mapped Address
(ip6 &lt;- ipv6("::ffff:c000:0280"))==ipv6("::ffff:192.0.2.128")
##
ipv6.reserved()[ip.index(ipv6.reserved())(ip6)]
## NAT64 IPv4-IPv6 translation
(ip6 &lt;- ipv6("64:ff9b::c000:201") ) &amp; ipv6.hostmask(96)
##
ipv6.reserved()[ip.index(ipv6.reserved())(ip6)]
</code></pre>

<hr>
<h2 id='IP+20range+20classes'>IPv4, IPv6 and IP ranges classes</h2><span id='topic+IPv4r-class'></span><span id='topic+IPv6r-class'></span><span id='topic+IPr-class'></span><span id='topic+ipv4r'></span><span id='topic+ipv4r-method'></span><span id='topic+ipv4r+2Cmissing+2Cmissing-method'></span><span id='topic+ipv4r+2Ccharacter+2Cmissing-method'></span><span id='topic+ipv4r+2Ccharacter+2Ccharacter-method'></span><span id='topic+ipv4r+2Ccharacter+2C.__intFP__.-method'></span><span id='topic+ipv4r+2CIPv4+2CIPv4-method'></span><span id='topic+ipv4r+2CIPv4+2C.__intFP__.-method'></span><span id='topic+ipv4r+2Clist+2Cmissing-method'></span><span id='topic+ipv4r+2Clogical+2Cmissing-method'></span><span id='topic+ipv4r+2CIPr+2Cmissing-method'></span><span id='topic+ipv6r'></span><span id='topic+ipv6r-method'></span><span id='topic+ipv6r+2Cmissing+2Cmissing-method'></span><span id='topic+ipv6r+2Ccharacter+2Cmissing-method'></span><span id='topic+ipv6r+2Ccharacter+2Ccharacter-method'></span><span id='topic+ipv6r+2Ccharacter+2C.__intFP__.-method'></span><span id='topic+ipv6r+2CIPv6+2CIPv6-method'></span><span id='topic+ipv6r+2CIPv6+2C.__intFP__.-method'></span><span id='topic+ipv6r+2Clist+2Cmissing-method'></span><span id='topic+ipv6r+2Clogical+2Cmissing-method'></span><span id='topic+ipv6r+2CIPr+2Cmissing-method'></span><span id='topic+ipr'></span><span id='topic+ipr-method'></span><span id='topic+ipr+2Cmissing+2Cmissing-method'></span><span id='topic+ip+2CIPr-method'></span><span id='topic+ipr+2Ccharacter+2Cmissing-method'></span><span id='topic+ipr+2Ccharacter+2Ccharacter-method'></span><span id='topic+ipr+2Ccharacter+2C.__intFP__.-method'></span><span id='topic+ipr+2CIP+2CIP-method'></span><span id='topic+ipr+2CIP+2C.__intFP__.-method'></span><span id='topic+ipr+2CIPv4r+2CIPv6r-method'></span><span id='topic+ipr+2CIPv4r+2Cmissing-method'></span><span id='topic+ipr+2CIPv6r+2Cmissing-method'></span><span id='topic+ipr+2Clogical+2Cmissing-method'></span><span id='topic+ipr+2Clist+2Cmissing-method'></span><span id='topic+ip.version+2CIPr-method'></span><span id='topic+print+2CIPv4r-method'></span><span id='topic+print+2CIPv6r-method'></span><span id='topic+print+2CIPr-method'></span><span id='topic+show+2CIPv4r-method'></span><span id='topic+show+2CIPv6r-method'></span><span id='topic+show+2CIPr-method'></span><span id='topic++5B+2CIPv4r+2CANY-method'></span><span id='topic++5B+2CIPv4r+2C.__subscript__.-method'></span><span id='topic++5B+2CIPv6r+2C.__subscript__.-method'></span><span id='topic++5B+2CIPr+2C.__subscript__.-method'></span><span id='topic++5B+2C.__IPvr__.+2Ccharacter-method'></span><span id='topic++5B+2C.__IPvr__.+2Cmissing-method'></span><span id='topic++5B+3C-+2CIPv4r+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CIPv4r+2C.__subscript__.-method'></span><span id='topic++5B+3C-+2CIPv6r+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CIPv6r+2C.__subscript__.-method'></span><span id='topic++5B+3C-+2CIPr+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CIPr+2C.__subscript__.+2CANY+2CIPr-method'></span><span id='topic++5B+3C-+2CIPr+2C.__subscript__.+2CANY+2CIPv4r-method'></span><span id='topic++5B+3C-+2CIPr+2C.__subscript__.+2CANY+2CIPv6r-method'></span><span id='topic++5B+3C-+2CIPr+2C.__subscript__.+2CANY+2Clogical-method'></span><span id='topic+lo'></span><span id='topic+lo+2CIPv4r-method'></span><span id='topic+lo+2CIPv6r-method'></span><span id='topic+lo+2CIPr-method'></span><span id='topic+hi'></span><span id='topic+hi+2CIPv4r-method'></span><span id='topic+hi+2CIPv6r-method'></span><span id='topic+hi+2CIPr-method'></span><span id='topic+ipv4+2CIPv4r-method'></span><span id='topic+ipv6+2CIPv6r-method'></span><span id='topic+ip.range'></span><span id='topic+ip.range-methods'></span><span id='topic+ip.range+2CIPv4r-method'></span><span id='topic+ip.range+2CIPv6r-method'></span><span id='topic+names-method'></span><span id='topic+names.IPv4r'></span><span id='topic+names.IPv6r'></span><span id='topic+names.IPr'></span><span id='topic+names+3C--method'></span><span id='topic+names+3C-.IPv4r'></span><span id='topic+names+3C-.IPv6r'></span><span id='topic+names+3C-.IPr'></span><span id='topic+as.data.frame.IPv4r'></span><span id='topic+as.data.frame.IPv6r'></span><span id='topic+as.data.frame.IPr'></span><span id='topic+c.IPv4r'></span><span id='topic+c.IPv6r'></span><span id='topic+c.IPr'></span><span id='topic+rbind2+2CIPv4r+2CIPv4r-method'></span><span id='topic+rbind2+2CIPv6r+2CIPv6r-method'></span><span id='topic+rbind2+2CIPr+2CIPr-method'></span><span id='topic+rep.IPv4r'></span><span id='topic+rep.IPv6r'></span><span id='topic+rep.IPr'></span><span id='topic+seq.IPv4r'></span><span id='topic+seq.IPv6r'></span><span id='topic+is.numeric+2CIPv4r-method'></span><span id='topic+is.numeric+2CIPv6r-method'></span><span id='topic+is.numeric+2CIPr-method'></span>

<h3>Description</h3>

<p>classes for IPv4 and IPv6 ranges addresses</p>


<h3>Details</h3>


<p>IPv4 and IPv6 ranges may be created from character vector using either range or Classless Inter-Domain Routing (CIDR) notation. 
Range notation represents ranges by using first and last address separated by a dash (<code>"&lt;ipr-start/&gt;-&lt;ipr-end/&gt;"</code>). 
CIDR notation uses a network prefix and a network identifier separated by a slash (<code>"&lt;net-prefix/&gt;/&lt;identifier/&gt;"</code>). 
The network identifier is a decimal number which counts the number of leading 1 bits in the subnet mask (see <code>hostmask()</code>).
</p>

<p>the lo() and hi() methods extract the low and high ends of ip ranges. When extracting IPv4r or IPv6r parts from IPr objects, use the drop argument to remove all NA values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Range notation
##
ipv4r("192.0.0.0-192.0.0.10")
##
## CIDR notation
##
## The entire IPv4 address space
ipv4(ipv4r('0.0.0.0/0'))
## Is there life on Mars ? (Martian packets)
ipv4r("100.64.0.0/10")
##
ip4 &lt;- ipv4("192.0.0.0")
## power of 2 
ipv4r( print(sprintf("%s-%s", ip4,  ip4 + ( 2^8-1) ) ))
## not a power of 2
ipv4r( print(sprintf("%s-%s", ip4,  ip4 + 10 ) ))
##
## Network classes
##
ip.class &lt;- data.frame(
  name = paste('class', LETTERS[1:5])
  , class = ipv4r(
  c(
        '0.0.0.0/8'                 ## Class A
      , '128.0.0.0/16'              ## Class B
      , '192.0.0.0/24'              ## Class C
      , '224.0.0.0-239.255.255.255' ## Class D
      , '240.0.0.0-255.255.255.255' ## Class E
    )
  )
)
##
## extract IP range start and end
##
(class.ip &lt;- ipv4(ip.class$class))
##
lo(ip.class$class)==class.ip$lo
##
hi(ip.class$class)==class.ip$hi
##
## # of hosts on this network
##
ip.range(ip.class$class)
## this is ok for IP v4 but may cause loss of precision for IPv6
## (please refer to the Arithmetic section)
ip.range(ip.class$class)==as.numeric(class.ip$hi - class.ip$lo)
##
##
##
ipr0 &lt;- ipr()
##
ipr0[3] &lt;- ipv4r(
  "0.0.0.0", "0.0.0.1"

)
ipr0[5] &lt;- ipv6r(
  "::" , 0L
)
ipr0
##
ipr0    &lt;- ipr()
ipr0[2] &lt;- NA
ipr0
##
## sequences
##
seq(ipv4r('0.0.0.0/24'), by=5)
seq(ipv4r('0.0.0.0/24'), length.out=3)
##
seq(ipv6r('::/120'), b=5)
seq(ipv6r('::/120'), length.out=3)
##
## throws an error : seq(ipv6r('::/96'),by=1)
## because this would yield a 2^32 vector
</code></pre>

<hr>
<h2 id='IP-package'>Classes and methods for IP addresses</h2><span id='topic+IP-package'></span><span id='topic+IP'></span>

<h3>Description</h3>

<p>Classes and methods for IP addresses
</p>


<h3>Details</h3>


<p>The IP package provides vector-like classes and methods for Internet Protocol (IP) addresses. 
It is based on the ip4r PostgreSQL extension available at <a href="https://github.com/RhodiumToad/ip4r">https://github.com/RhodiumToad/ip4r</a>.
</p>
<p>An IP address is a numerical label assigned to each device connected to a computer network that uses the Internet Protocol for communication. 
The Internet Protocol uses those labels to identify nodes such as host or network interface for relaying datagrams between them across network boundaries.
</p>
<p>Internet Protocol version 4 (IPv4) defines an IP address as an unsigned 32-bit number. However, because of the growth of the Internet and the depletion of available IPv4 addresses, a new version of IP (IPv6) using 128 bits for the IP address was developed from 1995 on. IPv6 deployment has been ongoing since the mid-2000s. Note that there is no IPv5 address. In addition, IPv4 and IPv6 protocols differ in many respects besides IP addresses representation.
</p>
<p>IP addresses are usually written and displayed in human-readable notations, such as &quot;192.168.0.1&quot; in IPv4, and &quot;fe80::3b13:cff7:1013:d2e7&quot; in IPv6. 
Ranges can be represented using two IP addresses separated by a dash or using the Classless Inter-Domain Routing (CIDR) notation. CIDR suffixes an address with he size of the routing prefix of the address which is the number of significant bits. For instance, &quot;192.168.0.0/16&quot; is a private network with subnet mask &quot;255.255.0.0&quot; and is equivalent to &quot;192.168.0.0-192.168.255.255&quot;. 

Currently, the IP package supports the following object types implemented using S4 classes :

</p>


<ul>
<li><p> the <code>IPv4</code> class stores IP version 4 addresses

</p>
</li>
<li><p> the <code>IPv4r</code> class stores IP version 4 addresses ranges

</p>
</li>
<li><p> the <code>IPv6</code> class stores IP version 6 addresses

</p>
</li>
<li><p> the <code>IPv6r</code> class stores IP version 6 addresses ranges

</p>
</li>
<li><p> the <code>IP</code> class stores both IPv4 and IPv6 addresses

</p>
</li>
<li><p> the <code>IPr</code> class stores both IPv4r and IPv6r addresses

</p>
</li>
<li><p> the (still experimental) <code>host</code> class holds the result of DNS lookup
</p>
</li></ul>

<p>The IP package also provides methods for arithmetic, comparison and bitwise unary and binary operations in addition to sorting and lookup and querying information about IP addresses and domain names. 
All operators are not available for all classes mostly by design but a few are still missing because they have not been implemented yet. IP objects can also be subseted or stored in a <code>data.frame</code> and serialized. 
</p>
<p>The IP and IPr classes are only convenience containers for instances when addresses must be created from vectors mixing both protocols. 
The IPv4 and IPv6 protocols and their corresponding IP representation are indeed very different in many respects so only a subset of methods are available for them. In addition, methods for those containers tend to run slower because, at the moment, they need to make two passes (one for IPv4* and one for IPv6* objects). 
Use the <code>ipv4(IP)</code> (resp. <code>ipv4r(IPr)</code>) and <code>ipv6(IP)</code> (resp. <code>ipv6r(IP)</code>) getters to work with v4 and v6 objects separately.
</p>



<h4>Design considerations</h4>


<p>IP objects were designed to behave as much as possible like base R atomic vectors. 
Therefore many R base functions such as <code>table()</code> or <code>factor()</code> or merging two <code>data.frame</code> using IP objects as keys work.
</p>
<p>But there are a few caveats when using functions or methods not provided by the IP package in which case you <b>may have to convert to the character representation of the addresses</b>.
</p>
<p>IP objects are S4 objects that all inherit from the integer class 
and because of this there are instances where function calls will operate on the inherited integer <code>.Data</code> part of the object only. 
As of writing, this is for example the case for the <code>nchar</code> function which returns the number of characters of the .Data vector only. But <code>grep</code> works because the x argument to the function is explicitly coerced to character before further processing.
</p>
<p>The .Data slot does not hold the addresses but an index to the addresses. 
When calling a non-IP method, <span class="rlang"><b>R</b></span> will first look for a method for this particular object. If none is found, it will try to find one for the class this object inherits from. Hence, the call will operate on the index, and not on the object as a hole. 
This is why some operations are explicitly blacklisted such as multiplication. Since there are no <code>`*`</code> for IP objects, multiplying an IP with a number would otherwise fall back to multiplying the index by this number, thus badly damaging the object.
</p>

<p>Reasons for using an index are twofold. First, each IP address space use the entire 32 (resp. 128) bits integer range. Thus, no value can be used for NA. 
For instance, R defines <code>NA_integer_</code> as <code class="reqn">2^{31}</code> which a perfectly valid IP v4 address (&quot;128.0.0.0&quot;). 
Second reason is IP words size. An IPv4 address uses 32 bits and thus can be stored using an integer vector (and IPv4 address ranges uses 64 bits and could be stored using a numeric vector). But an IP v6 address uses 128 bits and an IP v6 address range uses 256 bits and currently no <span class="rlang"><b>R</b></span> built-in atomic vectors are wide enough to hold them. IP addresses other than IPv4 have to be stored in a separate matrix and the index is used to retrieve their value.
</p>
<p>Therefore, each IP* object has an index which either points to the IP location in a table or mark the value as NA. 
This way <span class="rlang"><b>R</b></span> believes it is dealing with a regular vector but at the cost of increased memory consumption. 
The memory footprint is a function of the number of NA.
</p>
<p>On the other end, this design makes it easy to know if there are any NA and, if none, skip NA checking which makes things faster.
</p>




<h4>SIMD support</h4>

<p>The IP package provide an experimental support for AVX2 vectorized operations for IP comparison and arithmetic. 
To enable AVX2 support, please pass the <code>"--enable-avx2"</code> <code>configure.args</code> argument to the <code>install.packages()</code> function. 
</p>




<h4>Data protection</h4>

<p>One last caveat. In certain countries such as EU member countries, IP addresses are considered personal data (see Article 29 Working Party Opinion 4/2007 and ECJ ruling dated 19 October 2016 &ndash;ref.: C582/14). IP processing must therefore be done in accordance to the applicable laws and regulations.
</p>


<hr>
<h2 id='Varia'>Miscellaneous methods and functions for IP classes</h2><span id='topic+ip.capabilities'></span><span id='topic+length'></span><span id='topic+length+2CIPv4-method'></span><span id='topic+length+2CIPv4r-method'></span><span id='topic+length+2CIPv6-method'></span><span id='topic+length+2CIPv6r-method'></span><span id='topic+is.na'></span><span id='topic+is.na+2CIPv4-method'></span><span id='topic+is.na+2CIPv4r-method'></span><span id='topic+is.na+2CIPv6-method'></span><span id='topic+is.na+2CIPv6r-method'></span><span id='topic+anyNA'></span><span id='topic+anyNA+2C.__ipvr__.-method'></span><span id='topic+anyNA+2CIPv4-method'></span><span id='topic+anyNA+2CIPv4r-method'></span><span id='topic+anyNA+2CIPv6-method'></span><span id='topic+anyNA+2CIPv6r-method'></span><span id='topic+unique'></span><span id='topic+unique.IPv4'></span><span id='topic+unique.IPv6'></span><span id='topic+unique.IPv4r'></span><span id='topic+unique.IPv6r'></span><span id='topic+unique.IP'></span><span id='topic+xtfrm'></span><span id='topic+xtfrm-methods'></span><span id='topic+xtfrm+2CIPv4-method'></span><span id='topic+xtfrm+2CIPv4r-method'></span><span id='topic+xtfrm+2CIPv6r-method'></span><span id='topic+xtfrm+2CIPv6-method'></span><span id='topic+ip.order'></span><span id='topic+ip.order-method'></span><span id='topic+ip.order+2CIPv4-method'></span><span id='topic+ip.order+2CIPv6-method'></span><span id='topic+ip.order+2CIPv4r-method'></span><span id='topic+ip.order+2CIPv6r-method'></span><span id='topic+match'></span><span id='topic+match-methods'></span><span id='topic+match+2CIPv4+2CIPv4-method'></span><span id='topic+match+2CIPv4+2CIPv4r-method'></span><span id='topic+match+2CIPv4r+2CIPv4r-method'></span><span id='topic+match+2CIPv6+2CIPv6-method'></span><span id='topic+match+2CIPv6+2CIPv6r-method'></span><span id='topic+match+2CIPv6r+2CIPv6r-method'></span><span id='topic+ip.match'></span><span id='topic+ip.match-method'></span><span id='topic+ip.match+2CIPv4+2CIPv4-method'></span><span id='topic+ip.match+2CIPv4+2CIPv4r-method'></span><span id='topic+ip.match+2CIPv4r+2CIPv4r-method'></span><span id='topic+ip.match+2CIPv6+2CIPv6-method'></span><span id='topic+ip.match+2CIPv6+2CIPv6r-method'></span><span id='topic+ip.match+2CIPv6r+2CIPv6r-method'></span><span id='topic+getIdx'></span><span id='topic+ip.index'></span><span id='topic+ip.index-method'></span><span id='topic+ip.index+2CIPv4r-method'></span><span id='topic+ip.index+2CIPv6r-method'></span><span id='topic+ip.setequal'></span><span id='topic+ip.setequal-method'></span><span id='topic+ip.setequal+2C.__IPvr__.+2C.__IPvr__.-method'></span><span id='topic+ip.union'></span><span id='topic+ip.union-method'></span><span id='topic+ip.union+2C.__IPvr__.+2C.__IPvr__.-method'></span><span id='topic+ip.intersect'></span><span id='topic+ip.intersect-method'></span><span id='topic+ip.intersect+2C.__IPvr__.+2C.__IPvr__.-method'></span><span id='topic+ip.setdiff'></span><span id='topic+ip.setdiff-method'></span><span id='topic+ip.setdiff+2C.__IPvr__.+2C.__IPvr__.-method'></span><span id='topic+ip.symdiff'></span><span id='topic+ip.symdiff-method'></span><span id='topic+ip.symdiff+2C.__IPvr__.+2C.__IPvr__.-method'></span>

<h3>Description</h3>


<p>Mostly IP counterparts of base <span class="rlang"><b>R</b></span> methods and functions for atomic vectors. Namely,

</p>


<ul>
<li><p> length(), is.na(), anyNA()

</p>
</li>
<li><p> unique()

</p>
</li>
<li><p> sorting : xtfrm() 

</p>
</li>
<li><p> matching : match(), ip.match(), ip.index()

</p>
</li>
<li><p> set operations : ip.setequal(), ip.union(), ip.intersect(), ip.setdiff(), ip.symdiff()
</p>
</li></ul>



<h3>Details</h3>

  



<h4>Sorting</h4>

<p>IP object may be efficiently sorted through call to <span class="rlang"><b>R</b></span> generic functions <code>order()</code> and <code>sort()</code> thanks to the <code><a href="#topic+xtfrm">xtfrm</a></code> generic function. The IP package also provides the <code>ip.order()</code> which falls back to the default order method at the moment. 
</p>




<h4>Lookup</h4>

<p>This part is still <b>experimental</b> and might be subject to change in the future.
</p>
<p><code>match()</code> and <code>ip.match()</code> do IP lookup like base <code>match()</code> while <code>ip.index()</code> can be used for range queries. The IP package make <code>match()</code> generic to avoid unwanted effects of method dispatch in code using the package. But note that, unfortunately, this won't change the behaviour of <code>match()</code> in other packages (see caveat section in the package description).
</p>
<p><code>match()</code> and <code>ip.match()</code> behave differently according to their signature. When table is of class IPv4 or IPv6, <code>ip.match()</code> does a table lookup like base <code>match()</code>. But when table is an IP range and the x argument is not, both look for the range x lies into. If you want to test whether an IP range lies within another range, use the function returned by the <code>ip.index()</code> method (see example). 
</p>
<p>When arguments are of the same class, <code>match()</code> simply call base <code>match()</code> on the character representation while <code>ip.match()</code> uses hash tables. Range search uses a binary search tree. Beware that binary search can only handle non overlapping IP* ranges by default. Use <code>ip.index()</code> with <code>overlap=TRUE</code> to allow for overlap. Note that this also allows for multiple matches. As a consequence, result vector might be longer that input vector and therefore needs specialized data structures and access methods inspired by the compressed column storage of sparse matrices. See the example section for testing for overlap and lookup.
</p>
<p><code>ip.index()</code> returns a function. Calling this function with the value argument set to TRUE returns the matched value and the indices of the matches otherwise. 
When both overlap and value are TRUE, the function returns a two&ndash;columns <code>data.frame</code>with x and the matching values in the table.
</p>

<p>Also, the incomparable argument for <code>match()</code> or <code>unique()</code> is not implemented yet.
</p>







<h3>Examples</h3>

<pre><code class='language-R'>## 
x  &lt;- ipv4(0L) + sample.int(10)
x[order(x)]
sort(x)

##
## matching the address space of a wifi interface on a GNU/Linux box 
## that uses Predictable Network Interface Names
## notes: the name of the interface might change depending on the distribution 
##       you're using among other things and the localhost.ip() function 
##       only works for POSIX platforms at the moment
## 

  ipv4.reserved()[match(ipv4(localhost.ip())['wlp2s0'], ipv4.reserved() )]
  ## alternatively, if tables has to be looked up several time
  m &lt;- ip.index(ipv4.reserved())
  m(ipv4(localhost.ip())['wlp2s0'])


##
## ip.match() and ip.index() comparison
##
##
## index the table
bidx &lt;- ip.index(ipv4.reserved())
## "169.254.0.0/16"
x &lt;- ipv4.reserved()['Link Local']
## match
ip.match(x, ipv4.reserved() )
## match
ipv4.reserved()[bidx(x)]
## a range that lies within "169.254.0.0/16"
x &lt;- ipv4r("169.254.0.0/24")
## no match ("169.254.0.0/24"!="169.254.0.0/16")
ip.match(x, ipv4.reserved() )
## match ("169.254.0.0/24" \in "169.254.0.0/16")
ipv4.reserved()[bidx(x)]

##
## overlap
## 
## this demonstrates that ranges in ipv4.reserved() overlap
##
## range match
m &lt;- (
  ip.index(ipv4.reserved())
)(value=TRUE)
## FALSE because there are overlapping ranges and, in this case,
## the query returns the first matching range
all(m==ipv4.reserved())
## OTH match works as expected
all(ipv4.reserved()[ip.match(ipv4.reserved(),ipv4.reserved())]==ipv4.reserved())
##
## Find overlapping IPv4 ranges (pure R)
##
ipr.overlaps &lt;- function(x, y, rm.diag  = FALSE){
  overlaps &lt;- function(x,y) ( lo(x) &lt;= hi(y) ) &amp; ( hi(x) &gt;= lo( y))
  x &lt;- x[!is.na(x)]
  y &lt;- if( missing(y) ) x else y[!is.na(y)]
  rv &lt;- outer( x , y, overlaps)
  if( rm.diag) diag(rv) &lt;- 0
  ij &lt;- which(rv&gt;0,arr.ind = TRUE)
  data.frame(nm=names(x)[ij[,1]], x=x[ij[,1]], y=y[ij[,2]])
}
##
ipr.overlaps(ipv4.reserved(),rm.diag=TRUE)
##
## Find overlapping IPv4 ranges (IP package)
##
bsearch &lt;- ip.index(ipv4.reserved(), overlap=TRUE)
##
m &lt;- bsearch()
## get the indices
idx &lt;- getIdx(m)
## matches indices
midx &lt;- idx$midx
## start indices for each address in the midx vector
## (diff(ptr) gives the number of matches per address)
ptr &lt;- idx$ptr
##
subset(
  data.frame(
       nm  = names(ipv4.reserved()[midx])
     , x   = rep(m, diff(ptr))
     , tbl = ipv4.reserved()[midx]
     , n   = rep(diff(ptr), diff(ptr))
  )
  , n&gt;1 &amp; x!=tbl
)
##
## Same thing for IPv6r
##
ip.index(ipv6.reserved(), overlap=TRUE)(value=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
