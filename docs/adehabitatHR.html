<!DOCTYPE html><html lang="en"><head><title>Help for package adehabitatHR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adehabitatHR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BRB'>
<p>Utilization Distribution of an Animal Based on Biased Random Bridges</p></a></li>
<li><a href='#CharHull'>
<p>Estimation of the Home Range by Delaunay Triangulation method</p></a></li>
<li><a href='#clusthr'><p>Estimation of the Home Range by Single-Linkage Cluster Analysis</p></a></li>
<li><a href='#estUD-class'><p>Class &quot;estUD&quot;: Storing Utilization Distributions in R</p></a></li>
<li><a href='#findmax'><p>Find Local Maxima on a Map of Class 'SpatialPixelsDataFrame'</p></a></li>
<li><a href='#getverticeshr'>
<p>Extract the home-range contour of one or several animals</p></a></li>
<li><a href='#kernelbb'><p>Estimation of Kernel Brownian Bridge Home-Range</p></a></li>
<li><a href='#kernelkc'><p>Kernel Smoothing in Space and Time of the Animals' Use of Space</p></a></li>
<li><a href='#kerneloverlap'><p>Spatial Interaction between Animals Monitored Using Radio-Tracking</p></a></li>
<li><a href='#kernelUD'><p>Estimation of Kernel Home-Range</p></a></li>
<li><a href='#kver2spol'><p>Conversion of old classes from adehabitat to classes from adehabitatHR</p></a></li>
<li><a href='#LoCoH'><p>Estimating LoCoH home ranges</p></a></li>
<li><a href='#MCHu'><p>The Class &quot;MCHu&quot;: Managing Home Ranges Built by Multiple Convex</p>
Hulls</a></li>
<li><a href='#mcp'><p>Estimation of the Home Range Using the Minimum Convex Polygon</p>
Estimator</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.4.22</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-06</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1), sp, methods, ade4, adehabitatMA, adehabitatLT</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tkrplot, MASS, sf, deldir</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats</td>
</tr>
<tr>
<td>Title:</td>
<td>Home Range Estimation</td>
</tr>
<tr>
<td>Author:</td>
<td>Clement Calenge [aut, cre],
  Scott Fortmann-Roe [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Clement Calenge &lt;clement.calenge@ofb.gouv.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools for the estimation of animals home range.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-06 10:45:01 UTC; calenge</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-06 16:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='BRB'>
Utilization Distribution of an Animal Based on Biased Random Bridges
</h2><span id='topic+BRB'></span><span id='topic+BRB.D'></span><span id='topic+BRB.likD'></span>

<h3>Description</h3>

<p>This function estimates the utilization distribution of one/several
animals using a biased random bridge approach (Benhamou and Cornelis
2010, Benhamou 2011).  This function also allows the decomposition of
the utilization distribution into (i) an intensity distribution
reflecting the average time spent by the animal in the habitat
patches, and (ii) a recursion distribution reflecting the number of
visits of the animal in the habitat patches (Benhamou and
Riotte-Lambert, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRB(ltr, D, Tmax, Lmin, hmin, type=c("UD","ID", "RD"), radius = NULL,
    maxt = NULL, filtershort = TRUE, habitat = NULL, activity = NULL,
    grid = 200, b=FALSE, same4all=FALSE, extent=0.5, tau = NULL,
    boundary=NULL) 

BRB.D(ltr, Tmax = NULL, Lmin = NULL, habitat = NULL, activity = NULL)

BRB.likD(ltr, Dr=c(0.1,100),
         Tmax = NULL, Lmin = NULL,
         habitat = NULL, activity = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BRB_+3A_ltr">ltr</code></td>
<td>

<p>an object of class <code>ltraj</code>.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_d">D</code></td>
<td>

<p>a number corresponding to the diffusion parameter (in squared
&quot;units&quot; per second, where &quot;units&quot; denote the units of the relocation
coordinates) used for the estimation.  Alternatively this parameter
may be an object of class <code>DBRB</code> returned by the function
<code>BRB.D</code>.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_dr">Dr</code></td>
<td>

<p>a vector of length two giving the lower and upper limits of the
diffusion coefficient, within which the maximum likelihood could be
found.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_tmax">Tmax</code></td>
<td>

<p>the maximum duration (in seconds) allowed for a step built by successive
relocations.  All steps characterized by a duration dt greater than
<code>Tmax</code> are not taken into account in the calculations.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_lmin">Lmin</code></td>
<td>

<p>the minimum distance (in units of the coordinates) between successive 
relocations, defining intensive use or resting (See details).  The
distance should be specified in units of the relocation coordinates
(i.e. in metres if they are specified in metres).
</p>
</td></tr>
<tr><td><code id="BRB_+3A_hmin">hmin</code></td>
<td>

<p>The minimum smoothing parameter (in units of the relocations
coordinates), applied to all recorded relocations. See details for a
description of this parameter.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_type">type</code></td>
<td>

<p>The type of distribution expected by the user: <code>"UD"</code> returns
the utilization distribution using the approach described by
Benhamou and Cornelis (2010).  <code>"ID"</code> returns the intensity
distribution described in Benhamou and Riotte-Lambert (2012), i.e. a
distribution reflecting the average time spent in habitat patches.
<code>"RD"</code> returns the recursion distribution described in Benhamou
and Riotte-Lambert (2012), i.e. a distribution reflecting the number
of visits in habitat patches.  
</p>
</td></tr>
<tr><td><code id="BRB_+3A_radius">radius</code></td>
<td>

<p>If <code>type = "ID"</code> or <code>"RD"</code>, the radius of the patches (in
units of the relocation coordinates) used in the calculation of the
residence time or the number of visits.  If <code>NULL</code>, the radius
is set to <code>3*hmin</code>.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_maxt">maxt</code></td>
<td>

<p>If <code>type = "ID"</code> or <code>"RD"</code>, maximum time threshold (in
seconds) that the animal is allowed to spend outside the patch
before that we consider that the animal actually left the patch (see
<code>?residenceTime</code>).
</p>
</td></tr>
<tr><td><code id="BRB_+3A_filtershort">filtershort</code></td>
<td>

<p>logical indicating the behaviour of the function
when the length of a step is lower than <code>Lmin</code> (see details).
It must be set to TRUE if track segments shorter than
Lmin are assumed to correspond to resting periods, which thereby
will be filtered out systematically, or to FALSE to take these short
track segments into account when not associated to resting (animals
active without moving more than Lmin). They then will be given a
null diffusion coefficient.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_habitat">habitat</code></td>
<td>

<p>optionally, an object of class <code>SpatialPixelsDataFrame</code> with
one column describing the habitat type on the area.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_activity">activity</code></td>
<td>

<p>optionally, a character indicating the name of the variable in the
infolocs component of <code>ltr</code> indicating the proportion of time
between relocation i and relocation i+1 during which the animal was
active (Users of adehabitatLT prior to version 0.3 should read the
section Warning below).
</p>
</td></tr>
<tr><td><code id="BRB_+3A_grid">grid</code></td>
<td>

<p>a number giving the size of the grid on which the UD should
be estimated.  Alternatively, this parameter may be an object
of class <code>SpatialPixels</code>, or a list of objects of class
<code>SpatialPixels</code> with as many elements as there are bursts in
<code>ltr</code>.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_b">b</code></td>
<td>

<p>logical specifying how relocation and movement variances are
combined.  If <code>TRUE</code>, the relocation variance progressively
merges with the movement component; if <code>FALSE</code>, the relocation
variance has a constant weight (see Benhamou, 2011).
</p>
</td></tr>
<tr><td><code id="BRB_+3A_same4all">same4all</code></td>
<td>

<p>logical.  if <code>TRUE</code>, the same grid is used for the estimation
of all bursts.  If <code>FALSE</code>, one grid is used per burst.
</p>
</td></tr>
<tr><td><code id="BRB_+3A_extent">extent</code></td>
<td>

<p>a value indicating the extent of the grid used for the
estimation (the extent of the grid on the abscissa is equal
to <code>(min(xy[,1]) + extent * diff(range(xy[,1])))</code>).
</p>
</td></tr>
<tr><td><code id="BRB_+3A_tau">tau</code></td>
<td>

<p>interpolation time (tau, in seconds).  Defaults to <code>tmin/10</code>,
where <code>tmin</code> is the minimum duration of a step in <code>ltr</code>. 
</p>
</td></tr>
<tr><td><code id="BRB_+3A_boundary">boundary</code></td>
<td>

<p>If, not <code>NULL</code>, an object inheriting the class
<code>SpatialLines</code> defining a barrier that cannot be crossed by the
animals. There are constraints on the shape of the barrier that
depend on the smoothing parameter (***see details***)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>BRB</code> uses the biased random bridge approach 
to estimate the Utilization Distribution of an animal with serial
autocorrelation of the relocations.  This approach is similar to the
Brownian bridge approach (see <code>?kernelbb</code>), with several
noticeable improvements.  Actually, the Brownian bridge approach
supposes that the animal movement is random and purely diffusive
between two successive relocations: it is supposed that the animal
moves in a purely random fashion from the starting relocation and
reaches the next relocation randomly. The BRB approach goes further by
adding an advection component (i.e., a &quot;drift&quot;) to the purely
diffusive movement: is is supposed that the animal movement is
governed by a drift component (a general tendency to move in the
direction of the next relocation) and a diffusion component (tendency
to move in other directions than the direction of the drift).
</p>
<p>The BRB approach is based on the biased random walk model.  This model
is the following: at a given time t, the speed of the animal is drawn
from a probability density function (pdf) and the angle between the
step and the east direction is drawn from a circular pdf with given
mean angle and concentration parameters.  A biased random walk occurs
when this angular distribution is not uniform (i.e. there is a
preferred direction of movement).  Now, consider two successive
relocations r1 = (x1, y1) and r2 = (x2, y2) collected respectively at times t1
and t2.  The aim of the Biased Random Bridges approach is to estimate
the pdf that the animal is located at a given place r = (x,y) at time
ti (with t1 &lt; ti &lt; t2), given that it is located at r1,r2 at times
t1,t2, and given that the animal moves according a biased random walk
with an advection component determined by r1 and r2.
</p>
<p>Benhamou (2011) proposed an approximation for this pdf, noting
that it can be approximated by a circular bivariate normal
distribution with mean location corresponding to  (x1 + pi*(x2-x1), y1
+ pi*(y2-y1)), where pi = (ti-t1)/(t2-t1).  The variance-covariance
matrix of this distribution is diagonal, with both diagonal elements
corresponding to the diffusion coefficient D.  This coefficient D can
be estimated using the plug-in method, using the function
<code>BRB.D</code> (for details, see Benhamou, 2011).  Note that the
diffusion parameter <code>D</code> can be estimated for each habitat type is
a habitat map is available.  Note that the function <code>BRB.likD</code>
can be used alternatively to estimate the diffusion coefficient using
the maximum likelihood method.
</p>
<p>An important aspect of the BRB approach is that the drift component is
allowed to change in direction and strength from one step to the
other, but should remain constant during each of them.  For this
reason, it is required to set an upper time threshold <code>Tmax</code>.
Steps characterized by a longer duration are not taken into account
into the estimation of the pdf. This upper threshold should be based
on biological grounds.
</p>
<p>As for the Brownian bridge approach, this conditional pdf based on
biased random walks takes an infinite value at times ti = t1 and ti =
t2 (because, at these times, the relocation of the animal is known
exactly).  Benhamou proposed to circumvent this drawback by
considering that the true relocation of the animal at times t1 and t2
is not known exactly.  He noted: &quot;a GPS fix should be
considered a punctual sample of the possible locations at which the
animal may be observed at that time, given its current motivational
state and history. Even if the recording noise is low, the relocation
variance should therefore be large enough to encompass potential
locations occurring in the same habitat patch as the recorded
location&quot;. He proposed two ways to include this &quot;relocation
uncertainty&quot; component in the pdf: (i) either the relocation variance
progressively merges with the movement component, (ii) or the
relocation variance has a constant weight. This is controlled by the
parameter <code>b</code> of the function. In both cases, the minimum
uncertainty over the relocation of an animal is observed for ti = t1
or t2.  This minimum standard deviation corresponds to the parameter
<code>hmin</code>. According to Benhamou and Cornelis, &quot;<code>hmin</code> must be
at least equal to the standard deviation of the localization errors
and also must integrate uncertainty of the habitat map when UDs are
computed for habitat preference analyses. Beyond these technical
constraints, <code>hmin</code> also should incorporate a random component
inherent to animal behavior because any recorded location, even if
accurately recorded and plotted on a reliable map, is just a punctual
sample of possible locations at which the animal may be found at that
time, given its current motivational state and history. Consequently,
hmin should be large enough to encompass potential locations occurring
in the same habitat patch as the recorded location&quot;.
</p>
<p>Practically, the BRB approach can be carried out with the help of the
movement-based kernel density estimation (MKDE) developed by Benhamou
and Cornelis (2010).  This method consists in dividing each step i
into Ti/tau intervals, where Ti is the duration of the step (in
seconds) and <code>tau</code> is the interpolation time (in seconds).  A
kernel density estimation is then used to estimate the required pdf,
with a smoothing parameter varying with each interpolated location ri
and corresponding to: hi^2 = hmin^2 + 4pi(1-pi)(hmax^2 -
hmin^2)Ti/Tmax.  In this equation, <code>hmax^2</code> corresponds to
<code>hmin^2+ D*Tmax/2</code> if <code>b</code> is FALSE and to <code>D*Tmax/2</code>
otherwise.  Note that this smoothing parameter may be a 
function of the habitat type where the interpolated relocation occurs
if the diffusion parameters are available for each habitat types.
</p>
<p>The special case where a given step covers a distance lower than
<code>Lmin</code> merits further details.  When the parameter
<code>filtershort = TRUE</code>, it is always assumed that the animal was
resting at this time, and this step is filtered out before the
estimation.  When the parameter <code>filtershort = FALSE</code>, this
assumption is not made.  In this case, the behaviour of the function
depends on the availability of a variable measuring the activity of
the animal (when the name of the variable containing the ai in the
<code>infolocs</code> component is passed as the parameter <code>activity</code>;
see <code>?infolocs</code> for additionnal information on this component).
If the animal was active during the step, the smoothing parameter hi
is set to <code>hmin</code> for this step. This procedure allows to give
more weight to the immediate surroundings of this relocation
(indicating an intensive use of these immediate surroundings).  If the
animal was inactive, then the animal was resting and the step is
filtered out before the estimation.  Note however that activity value
may sometimes be relatively high while the animal is resting, e.g. if
disturbed by flies, possibly requiring manual correction of activity
values based on the distance moved between relocations).
</p>
<p>If no activity variable is available and <code>filtershort = FALSE</code>,
it is always suppose that the animal was active between the two
relocations, the step is not filtered out and the
smoothing parameter hi is set to <code>hmin</code> for this step.
</p>
<p>The parameter <code>boundary</code> allows to define a barrier that cannot
be crossed by the animals.  When this parameter is
set, the method described by Benhamou and Cornelis (2010) for
correcting boundary biases is used.  The boundary can possibly be
defined by several nonconnected lines, each one being built by several
connected segments. Note that there are constraints on these segments
(not all kinds of boundary can be defined): (i) each segment length
should at least be equal to <code>3*h</code> (the size of &quot;internal lane&quot;
according to the terminology of Benhamou and Cornelis), (ii) the angle
between two line segments should be greater that <code>pi/2</code> or lower
that <code>-pi/2</code>.  The UD of all the pixels located within a
band defined by the boundary and with a width equal to <code>6*h</code>
(&quot;external lane&quot;) is set to zero.
</p>
<p>Benhamou and Riotte-Lambert (2012) showed that the space use at any
given location, as estimated by this approach, can be seen as the
product between the mean residence time per visit times the number of
visits of the location.  They proposed an approach allowing the
decomposition of the UD into two components: (i) the intensity
distribution reflecting this average residence time and (ii) a
recursion distribution reflecting the number of visits.  This function
allows to estimate these two components, by setting the argument
<code>type</code> to <code>"ID"</code> and <code>"RD"</code> respectively.  
</p>
<p>Note that all the methods available to deal with objects of class
<code>estUDm</code> are available to deal with the results of the function
<code>BRB</code> (see <code>?kernelUD</code>).
</p>


<h3>Value</h3>

<p><code>BRB</code> returns an object of class <code>estUDm</code> when the UD is
estimated for several animals, and <code>estUD</code> when only one animal
is studied.
</p>
<p><code>BRB.D</code> and <code>BRB.likD</code> returns a list of class <code>DBRB</code>,
with one component per burst containing a data frame with the
diffusion parameters.
</p>


<h3>Warning</h3>

<p>Users of the version 0.2 of adehabitatHR should be careful that there
was a slight inconsistency in the package design: whereas all the
parameters characterizing the steps in an object of class
<code>"ltraj"</code> (e.g. <code>dist, dx, dy</code>) describe the step between
relocations i and i+1, it was expected for <code>BRB</code> that the
activity described the proportion of activity time between relocation
i-1 and i.  This inconsistency has now been corrected since version
0.3.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a>, based on a C
translation of the Pascal source code of the program provided by Simon
Benhamou.
</p>


<h3>References</h3>

<p>Benhamou, S. (2011) Dynamic approach to space and habitat use
based on biased random bridges <em>PLOS One</em>, <b>6</b>, 1&ndash;8.
</p>
<p>Benhamou, S. and Cornelis, D. (2010) Incorporating Movement Behavior
and Barriers to Improve Biological Relevance of Kernel Home Range
Space Use Estimates. <em>Journal of Wildlife Management</em>, <b>74</b>,
1353&ndash;1360.
</p>
<p>Benhamou, S. and Riotte-Lambert, L. (2012) Beyond the Utilization
Distribution: Identifying home range areas that are intensively
exploited or repeatedly visited. <em>Ecological Modelling</em>,
<b>227</b>,  112&ndash;116.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernelbb">kernelbb</a></code> for the Brownian bridge kernel estimation,
<code><a href="#topic+kernelUD">kernelUD</a></code> and <code><a href="#topic+estUD-class">estUD-class</a></code> for additional
information about objects of class <code>estUDm</code> and <code>estUD</code>,
<code><a href="adehabitatLT.html#topic+infolocs">infolocs</a></code> for additional information about the
<code>infolocs</code> component, <code><a href="adehabitatLT.html#topic+as.ltraj">as.ltraj</a></code> for additional
information about the class <code>ltraj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example dataset used by Benhamou (2011)
data(buffalo)

## The trajectory:
buffalo$traj

## The habitat map:
buffalo$habitat

## Show the dataset
plot(buffalo$traj, spixdf = buffalo$habitat)

## Estimate the diffusion component for each habitat type
## Using the plug-in method
vv &lt;- BRB.D(buffalo$traj, Tmax = 180*60, Lmin = 50,
            habitat = buffalo$habitat, activ = "act")

vv

## Note that the values are given here as m^2/s, whereas
## they are given as m^2/min in Benhamou (2011). The
## values in m^2 per min are:
vv[[1]][,2]*60

## Approximately the same values, with slight differences due to
## differences in the way the program of Benhamou (2011) and the present
## one deal with the relocations occurring on the boundary between two
## different habitat types
## Note that an alternative estimation of the Diffusion coefficient
## could be found using maximum likelihood
vv2 &lt;- BRB.likD(buffalo$traj, Tmax = 180*60, Lmin = 50,
                habitat = buffalo$habitat, activ = "act")
vv2
vv[[1]][,2]*60


## Estimation of the UD with the same parameters as those chosen by
## Benhamou (2011)
ud &lt;- BRB(buffalo$traj, D = vv, Tmax = 180*60, tau = 300, Lmin = 50, hmin=100,
          habitat = buffalo$habitat, activity = "act", grid = 50, b=0,
          same4all=FALSE, extent=0.5)
ud

## Show the UD.
image(ud)

## Not run: 
## Example of the decomposition of the UD into a recursion distribution
## and a intensity distribution (Benhamou and Riotte-Lambert 2012).
##
## 1. Intensity Distribution using the same parameters as Benhamou and
## Riotte-Lambert (2012)

id &lt;- BRB(buffalo$traj, D = 440/60, Tmax = 3*3600, Lmin = 50, type = "ID",
          hmin=100, radius = 300, maxt = 2*3600, activity="act", filtershort=FALSE,
          grid = 200, extent=0.1)

rd &lt;- BRB(buffalo$traj, D = 440/60, Tmax = 3*3600, Lmin = 50, type = "RD",
          hmin=100, radius = 300, maxt = 2*3600, activity="act", filtershort=FALSE,
          grid = 200, extent=0.1)

ud &lt;- BRB(buffalo$traj, D = 440/60, Tmax = 3*3600, Lmin = 50, 
          hmin=100, radius = 300, maxt = 2*3600, activity="act", filtershort=FALSE,
          grid = 200, extent=0.1)

par(mfrow = c(2,2), mar=c(0,0,2,0))
image(getvolumeUD(id))
title("ID")
image(getvolumeUD(rd))
title("RD")
image(getvolumeUD(ud))
title("UD")

## End(Not run)




</code></pre>

<hr>
<h2 id='CharHull'>
Estimation of the Home Range by Delaunay Triangulation method
</h2><span id='topic+CharHull'></span>

<h3>Description</h3>

<p>The function <code>CharHull</code> implements the method developed by Downs
and Horner (2009) for the home range estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CharHull(xy, unin = c("m", "km"),
         unout = c("ha", "m2", "km2"),
         duplicates = c("random", "remove"), amount = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CharHull_+3A_xy">xy</code></td>
<td>
<p>an object inheriting the class <code>SpatialPoints</code>
containing the x and y coordinates of the relocations of the animal.
If <code>xy</code> inherits the class <code>SpatialPointsDataFrame</code>, it
should contain only one column (factor) corresponding to the
identity of the animals for each relocation.</p>
</td></tr>
<tr><td><code id="CharHull_+3A_unin">unin</code></td>
<td>
<p>the units of the relocations coordinates.  Either &quot;m&quot;
(default) for meters or &quot;km&quot; for kilometers</p>
</td></tr>
<tr><td><code id="CharHull_+3A_unout">unout</code></td>
<td>
<p>the units of the output areas.  Either &quot;m2&quot; for square
meters, &quot;km2&quot; for square kilometers or &quot;ha&quot; for hectares
(default)</p>
</td></tr>
<tr><td><code id="CharHull_+3A_duplicates">duplicates</code></td>
<td>
<p>a setting to determine how duplicated points are handled.
If &quot;random&quot; the duplicated points are slightly moved
randomly. If &quot;remove&quot; the duplicated points are removed.</p>
</td></tr>
<tr><td><code id="CharHull_+3A_amount">amount</code></td>
<td>
<p>if <code>duplicates == random</code>, this parameter controls
the amount of noise added to the data (see the help page of
<code>jitter</code> for additional information on this parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method consists in the computation of the Delaunay triangulation
of the set of relocations.  Then, the triangles are ordered from the
smallest to the largest. It is possible to select a given percentage
of the smallest triangles (measured by their area) as the home-range
estimation.  The contour can be extracted with the function
<code>getverticeshr</code>
</p>


<h3>Value</h3>

<p>an object of the class <code>MCHu</code>
</p>


<h3>Note</h3>

<p>This function relies on the package <code>deldir</code>.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a>
</p>


<h3>References</h3>

<p>Downs J.A. and Horner, M.W. (2009) A Characteristic-Hull Based Method
for  Home Range Estimation. <em>Transactions in GIS</em>, <b>13</b>,
527&ndash;537. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCHu">MCHu</a></code> for further information on the class
<code>MCHu</code>, and <code><a href="sp.html#topic+SpatialPolygonsDataFrame-class">SpatialPolygonsDataFrame-class</a></code> for
additional information on this class. See <code><a href="#topic+getverticeshr">getverticeshr</a></code>
to extract a given home range contour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(puechabonsp)
lo&lt;-puechabonsp$relocs[,1]
     
## Home Range Estimation
res &lt;- CharHull(lo)

## Displays the home range
plot(res)
 
## Computes the home range size
MCHu2hrsize(res)

## Computes the 95 percent home range
ver &lt;- getverticeshr(res)
ver
plot(ver)

## End(Not run)

</code></pre>

<hr>
<h2 id='clusthr'>Estimation of the Home Range by Single-Linkage Cluster Analysis</h2><span id='topic+clusthr'></span>

<h3>Description</h3>

<p><code>clusthr</code> allows the estimation of the home range by
single-linkage cluster analysis (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusthr(xy, unin = c("m", "km"),
        unout = c("ha", "m2", "km2"),
        duplicates=c("random","remove"), amount = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusthr_+3A_xy">xy</code></td>
<td>
<p>an object inheriting the class <code>SpatialPoints</code>
containing the x and y relocations of the animal.  If <code>xy</code>
inherits the class <code>SpatialPointsDataFrame</code>, it should contain
only one column (factor) corresponding to the identity of the
animals for each relocation.</p>
</td></tr>
<tr><td><code id="clusthr_+3A_unin">unin</code></td>
<td>
<p>the units of the relocations coordinates.  Either
<code>"m"</code> (default) for
meters or <code>"km"</code> for kilometers</p>
</td></tr>
<tr><td><code id="clusthr_+3A_unout">unout</code></td>
<td>
<p>the units of the output areas.  Either <code>"m2"</code> for
square meters, <code>"km2"</code> for square kilometers or <code>"ha"</code> for
hectares (default)</p>
</td></tr>
<tr><td><code id="clusthr_+3A_duplicates">duplicates</code></td>
<td>
<p>a setting to determine how duplicated points are
handled.  If &quot;<code>random</code>&quot; the duplicated points are slightly moved
randomly. If &quot;<code>remove</code>&quot; the duplicated points are removed.</p>
</td></tr>
<tr><td><code id="clusthr_+3A_amount">amount</code></td>
<td>
<p>if <code>duplicates == random</code>, this parameter controls the
amount of noise added to the data (see the help page of <code>jitter</code>
for additional information on this parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method estimates home range using the single-linkage cluster
analysis modified by Kenward et
al. (2001). The clustering process is described hereafter: the three
locations with the minimum mean of nearest-neighbour joining distances
(NNJD) form the first cluster. At each step, two distances are
computed: (i) the minimum mean NNJD between three locations (which
corresponds to the next potential cluster) and (ii) the minimum of the
NNJD between a cluster &quot;c&quot; and the closest location.  If (i) is smaller
that (ii), another cluster is defined with these three locations.
If (ii) is smaller than (i), the cluster &quot;c&quot; gains a new location.  If
this new location belong to another cluster, the two cluster
fuses. The process stop when all relocations are assigned to the same
cluster.
</p>
<p>At each step of the clustering process, the proportion of all
relocations which are assigned to a cluster is computed (so that the
home range can be defined to enclose a given proportion of the
relocations at hand, i.e. to an uncomplete process).
At a given step, the home range is defined as
the set of minimum convex polygon enclosing the relocations in the
clusters.
</p>
<p>Note that a given home-range contour can be extracted using the
function <code>getverticeshr</code>.
</p>


<h3>Value</h3>

<p>The function <code>clusthr</code> returns either objects of class
<code>SpatialPolygonsDataFrame</code> (if the relocations of only one
animals are passed as the <code>xy</code> argument) or a list of
<code>SpatialPolygonsDataFrame</code> of class <code>MCHu</code> &ndash; Multiple
Convex Hull (if the relocations of several animals are passed as the
<code>xy</code> argument).
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>References</h3>

<p>Kenwward R.E., Clarke R.T., Hodder K.H. and Walls S.S. (2001) Density
and linkage estimators of homre range: nearest neighbor clustering
defines multinuclear cores. <em>Ecology</em>, <b>82</b>, 1905&ndash;1920.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCHu">MCHu</a></code> for further information on the class
<code>MCHu</code>, and <code><a href="sp.html#topic+SpatialPolygonsDataFrame-class">SpatialPolygonsDataFrame-class</a></code> for
additional information on this class. See <code><a href="#topic+getverticeshr">getverticeshr</a></code>
to extract a given home range contour.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(puechabonsp)
lo&lt;-puechabonsp$relocs[,1]

## Home Range Estimation
res &lt;- clusthr(lo)

## Displays the home range
plot(res)

## Computes the home range size
MCHu2hrsize(res)

## get the 95 percent home range:
plot(getverticeshr(res, percent=95))


</code></pre>

<hr>
<h2 id='estUD-class'>Class &quot;estUD&quot;: Storing Utilization Distributions in R</h2><span id='topic+estUD-class'></span><span id='topic+coerce+2CestUD+2Cdata.frame-method'></span><span id='topic+show+2CestUD-method'></span>

<h3>Description</h3>

<p>This class is an extension of the class
<code>SpatialPixelsDataFrame</code> of the package sp, and is designed to
store the utilization distribution of an animal</p>


<h3>Objects from the Class</h3>

<p>Objects of class &quot;<code>estUD</code>&quot; can be created using the functions
<code>kernelUD</code> and <code>getvolumeUD</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>h</code>:</dt><dd><p>Object of class <code>"list"</code> containing all
information concerning the smoothing parameters used in the
estimation process</p>
</dd>
<dt><code>vol</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the mapped values coorespond to the UD
or to the volume under the UD (see <code>?kernelUD</code>)</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code>
containing the values of the UD</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="sp.html#topic+SpatialPixelsDataFrame-class">SpatialPixelsDataFrame-class</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "estUD", to = "data.frame")</code>:
converts the object into a data frame</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "estUD")</code>: printing method of
the object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

 <p><code><a href="sp.html#topic+SpatialPixelsDataFrame-class">SpatialPixelsDataFrame-class</a></code> for additional
information about this class, and <code><a href="#topic+kernelUD">kernelUD</a></code> for
additional information about the methods generating such objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load the data
data(puechabonsp)

## estimate one UD for each animal
jj &lt;- kernelUD(puechabonsp$relocs[,1])
image(jj)
jj


## Consider the first animal
jj[[1]]
class(jj[[1]])
image(jj[[1]])


</code></pre>

<hr>
<h2 id='findmax'>Find Local Maxima on a Map of Class 'SpatialPixelsDataFrame'</h2><span id='topic+findmax'></span>

<h3>Description</h3>

<p><code>findmax</code> finds the local maxima on a map of class
<code>SpatialPixelsDataFrame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  findmax(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findmax_+3A_x">x</code></td>
<td>
<p>a map of class <code>SpatialPixelsDataFrame</code> with one column</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be useful, among other things, to identify the local
modes of the utilization distribution of an animal estimated
using <code>kernelUD</code>. 
</p>


<h3>Value</h3>

<p>an object of class <code>SpatialPoints</code> containing the x and y
coordinates of the local maxima.
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>See Also</h3>

 <p><code><a href="sp.html#topic+SpatialPixelsDataFrame-class">SpatialPixelsDataFrame-class</a></code> for additionnal
information on objects of class <code>SpatialPixelsDataFrame</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(puechabonsp)

## estimates the UD
kud &lt;- kernelUD(puechabonsp$relocs[,1])

## displays the maximum
image(kud[[1]])
points(findmax(kud[[1]]))

</code></pre>

<hr>
<h2 id='getverticeshr'>
Extract the home-range contour of one or several animals
</h2><span id='topic+getverticeshr'></span><span id='topic+getverticeshr.estUD'></span><span id='topic+getverticeshr.estUDm'></span><span id='topic+getverticeshr.MCHu'></span><span id='topic+getverticeshr.default'></span>

<h3>Description</h3>

<p>These functions allow the extraction of the home-range contours
computed using various methods (kernel home range, cluster home range,
etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getverticeshr(x, percent = 95, ...)
## S3 method for class 'estUD'
getverticeshr(x, percent = 95, ida = NULL, unin = c("m", "km"),
                              unout = c("ha", "km2", "m2"),
                              standardize = FALSE, ...)
## S3 method for class 'estUDm'
getverticeshr(x, percent = 95, whi = names(x),
                               unin = c("m", "km"),
                               unout = c("ha", "km2", "m2"),
                               standardize = FALSE, ...)
## S3 method for class 'MCHu'
getverticeshr(x, percent = 95, whi = names(x), ...)
## Default S3 method:
getverticeshr(x, percent = 95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getverticeshr_+3A_x">x</code></td>
<td>
<p>For <code>getverticeshr.estUD</code>, an object of class
<code>estUD</code>.  For <code>getverticeshr.estUDm</code>, an object of class
<code>estUDm</code>.  For <code>getverticeshr.MCHu</code>, an object of class
<code>MCHu</code>.</p>
</td></tr>
<tr><td><code id="getverticeshr_+3A_percent">percent</code></td>
<td>
<p>a single value giving the percentage level for
home-range estimation</p>
</td></tr>
<tr><td><code id="getverticeshr_+3A_ida">ida</code></td>
<td>
<p>a character string indicating the id of the polygons
corresponding to the home range in the resulting
<code>SpatialPolygonsDataFrame</code> (see the help page of
<code>SpatialPolygonsDataFrame</code>).  By default it is set to
<code>"homerange"</code></p>
</td></tr>
<tr><td><code id="getverticeshr_+3A_unin">unin</code></td>
<td>
<p>the units of the relocations coordinates.  Either &quot;m&quot; for
meters (default) or &quot;km&quot; for kilometers</p>
</td></tr>
<tr><td><code id="getverticeshr_+3A_unout">unout</code></td>
<td>
<p>the units of the output areas.  Either &quot;m2&quot; for square
meters, &quot;km2&quot; for square kilometers or &quot;ha&quot; for hectares
(default)</p>
</td></tr>
<tr><td><code id="getverticeshr_+3A_whi">whi</code></td>
<td>
<p>a vector of character strings indicating which animals
should be returned.</p>
</td></tr>
<tr><td><code id="getverticeshr_+3A_standardize">standardize</code></td>
<td>
<p>a logical value indicating whether the UD should be
standardized over the area of interest, so that the volume
under the UD and *over the area* is equal to 1..</p>
</td></tr>
<tr><td><code id="getverticeshr_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to and from other methods
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SpatialPolygonsDataFrame</code> containing the
selected home range contours of the animals.
</p>


<h3>Note</h3>

<p>The function <code>getverticeshr.default</code> is present for compatibility
purposes.  Its use generates an error.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernelUD">kernelUD</a></code>, <code><a href="#topic+kernelbb">kernelbb</a></code> or
<code><a href="#topic+kernelkc">kernelkc</a></code> for methods generating objects of classes
<code>estUD</code> and <code>estUDm</code>, 
<code><a href="#topic+clusthr">clusthr</a></code>, <code><a href="#topic+LoCoH.a">LoCoH.a</a></code> and
<code><a href="#topic+CharHull">CharHull</a></code> for methods generating objects of class
<code><a href="#topic+MCHu">MCHu</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example with a kernel home range
data(puechabonsp)
loc &lt;- puechabonsp$relocs
     
## have a look at the data
head(as.data.frame(loc))
## the first column of this data frame is the ID
     
## Estimation of UD for the four animals
(ud &lt;- kernelUD(loc[,1]))

## Calculates the home range contour

ver &lt;- getverticeshr(ud, percent=95)
ver
plot(ver)

## Example with a cluster home range
clu &lt;- clusthr(loc[,1])
ver2 &lt;- getverticeshr(clu, percent=95)
ver2
plot(ver2)

</code></pre>

<hr>
<h2 id='kernelbb'>Estimation of Kernel Brownian Bridge Home-Range</h2><span id='topic+kernelbb'></span><span id='topic+print.liker'></span><span id='topic+liker'></span>

<h3>Description</h3>

<p><code>kernelbb</code> is used to estimate the utilization distribution of an
animal using the brownian bridge approach of the kernel method (for
autocorrelated relocations; Bullard 1991, Horne et al. 2007). 
</p>
<p><code>liker</code> can be used to find the maximum likelihood
estimation of the parameter sig1, using the approach defined in Horne
et al. 2007 (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelbb(ltr, sig1, sig2, grid = 40, same4all = FALSE, byburst = FALSE,
         extent = 0.5, nalpha = 25)

liker(tr, rangesig1, sig2, le = 1000,
      byburst = FALSE, plotit = TRUE)

## S3 method for class 'liker'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernelbb_+3A_ltr">ltr</code>, <code id="kernelbb_+3A_tr">tr</code></td>
<td>
<p>an object of class <code>ltraj</code> of type II (time recorded),
regular or not (see <code>help(as.ltraj)</code>).</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_sig1">sig1</code></td>
<td>
<p>first smoothing parameter for the brownian bridge method
(related to the speed of the animals; it can be estimated by the
function <code>liker</code>).</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_sig2">sig2</code></td>
<td>
<p>second smoothing parameter for the brownian bridge method
(related to the imprecision of the relocations, supposed known).</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_grid">grid</code></td>
<td>
<p>a number giving the size of the grid on
which the UD should be estimated.  Alternatively, this parameter may
be an object of class <code>SpatialPixels</code>, or a list of objects of
class <code>SpatialPixels</code>, with named elements corresponding to each
level of the factor id</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_same4all">same4all</code></td>
<td>
<p>logical. If <code>TRUE</code>, the same grid
is used for all animals.  If <code>FALSE</code>, one grid per
animal is used</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_byburst">byburst</code></td>
<td>
<p>logical. Whether the brownian bridge estimation should
be done by burst.</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_extent">extent</code></td>
<td>
<p>a value indicating the extent of the grid used for the
estimation (the extent of the grid on the abscissa is equal to
<code>(min(xy[,1]) + extent * diff(range(xy[,1])))</code>).</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_nalpha">nalpha</code></td>
<td>
<p>a parameter used internally to compute the integral
of the Brownian bridge.  The integral is computed by cutting each
step built by two relocations into <code>nalpha</code> sub-intervals. </p>
</td></tr>
<tr><td><code id="kernelbb_+3A_rangesig1">rangesig1</code></td>
<td>
<p>the range of possible values of sig1 within which
the likelihood should be maximized.</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_le">le</code></td>
<td>
<p>The number of values of sig1 tested within the specified
range.</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_plotit">plotit</code></td>
<td>
<p>logical. Whether the results of the function should be
plotted.</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_x">x</code></td>
<td>
<p>an object of class <code>khr</code> returned by <code>kernelbb</code>.</p>
</td></tr>
<tr><td><code id="kernelbb_+3A_...">...</code></td>
<td>
<p>additionnal parameters to be passed to the generic
functions <code>print</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>kernelbb</code> uses the brownian bridge approach to
estimate the Utilization Distribution of an animal with serial
autocorrelation of the relocations (Bullard 1991, Horne et al. 2007).
Instead of simply smoothing the relocation pattern (which is the case
for the function <code>kernelUD</code>), it takes into account the fact that
between two successive relocations r1 and r2, the animal has moved
through a continuous path, which is not necessarily linear.  A
brownian bridge estimates the density of probability that this path
passed through any point of the study area, given that the animal was
located at the point r1 at time t1 and at the point r2 at time t2,
with a certain amount of inaccuracy (controled by the parameter sig2,
see Examples).  Brownian bridges are placed over the different
sections of the trajectory, and these functions are then summed over the
area.  The brownian bridge approach therefore smoothes a trajectory.
</p>
<p>The brownian bridge estimation relies on two smoothing parameters,
<code>sig1</code> and <code>sig2</code>.  The parameter <code>sig1</code> is related to
the speed of the animal, and describes how far from the line joining
two successive relocations the animal can go during one time unit
(here the time is measured in second). The function <code>liker</code> can
be used to estimate this value using the maximum likelihood approach
described in Horne et al. (2007). The larger this parameter is,
and the more wiggly the trajectory is likely to be.
The parameter <code>sig2</code> is equivalent to the parameter 
<code>h</code> of the classical kernel method: it is related to the
inaccuracy of the relocations, and is supposed known (See examples for
an illustration of the smoothing parameters).
</p>
<p>The functions <code>getvolumeUD</code> and <code>getverticeshr</code> can then be
used to conpute the home ranges (see <code>kernelbb</code>).  More
generally, more details on the generic parameters of <code>kernelbb</code>
can be found on the help page of <code>kernelUD</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>estUDm</code>
</p>
<p><code>liker</code> returns an object of class <code>liker</code>, with one
component per animal (or per burst, depending on the value of
the parameter <code>perburst</code>), containing the value of (i) optimized
sig1, (ii) sig2, and (iii) a data frame named &quot;cv&quot; with the tested
values of sig1 and the corresponding log-likelihood.
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>References</h3>

<p>Bullard, F. (1991) <em>Estimating the home range of an animal: a Brownian
bridge approach</em>. Master of Science, University of North Carolina,
Chapel Hill.
</p>
<p>Horne, J.S., Garton, E.O., Krone, S.M. and Lewis, J.S. (2007)
Analyzing animal movements using brownian bridge. <em>Ecology</em>,
<b>in press</b>.
</p>


<h3>See Also</h3>

<p><code><a href="adehabitatLT.html#topic+as.ltraj">as.ltraj</a></code> for further information concerning
objects of class <code>ltraj</code>. <code><a href="#topic+kernelUD">kernelUD</a></code> for the
classical kernel estimation. ,  <code><a href="#topic+mcp">mcp</a></code> for
estimation of home ranges using the minimum convex polygon, and for
help on the function <code>plot.hrsize</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

#########################################################
#########################################################
#########################################################
###
###        Example of a typical case study
###       with the brownian bridge approach
###

## Load the data
data(puechcirc)
x &lt;- puechcirc[1]

## Field studies have shown that the mean standard deviation (relocations
## as a sample of the actual position of the animal) is equal to 58
## meters on these data (Maillard, 1996, p. 63). Therefore
sig2 &lt;- 58

## Find the maximum likelihood estimation of the parameter sig1
## First, try to find it between 10 and 100.
liker(x, sig2 = 58, rangesig1 = c(10, 100))

## Wow! we expected a too large standard deviation! Try again between
## 1 and 10:
liker(x, sig2 = 58, rangesig1 = c(1, 10))

## So that sig1 = 6.23

## Now, estimate the brownian bridge
tata &lt;- kernelbb(x, sig1 = 6.23, sig2 = 58, grid = 100)
image(tata)


## OK, now look at the home range
image(tata)
plot(getverticeshr(tata, 95), add=TRUE, lwd=2)





#########################################################
#########################################################
#########################################################
###
###      Comparison of the brownian bridge approach
###            with the classical approach
###


## Take an illustrative example: we simulate a trajectory
suppressWarnings(RNGversion("3.5.0"))
set.seed(2098)
pts1 &lt;- data.frame(x = rnorm(25, mean = 4.5, sd = 0.05),
                   y = rnorm(25, mean = 4.5, sd = 0.05))
pts1b &lt;- data.frame(x = rnorm(25, mean = 4.5, sd = 0.05),
                    y = rnorm(25, mean = 4.5, sd = 0.05))
pts2 &lt;- data.frame(x = rnorm(25, mean = 4, sd = 0.05),
                   y = rnorm(25, mean = 4, sd = 0.05))
pts3 &lt;- data.frame(x = rnorm(25, mean = 5, sd = 0.05),
                   y = rnorm(25, mean = 4, sd = 0.05))
pts3b &lt;- data.frame(x = rnorm(25, mean = 5, sd = 0.05),
                    y = rnorm(25, mean = 4, sd = 0.05))
pts2b &lt;- data.frame(x = rnorm(25, mean = 4, sd = 0.05),
                    y = rnorm(25, mean = 4, sd = 0.05))
pts &lt;- do.call("rbind", lapply(1:25, function(i) {
          rbind(pts1[i,], pts1b[i,], pts2[i,], pts3[i,],
                pts3b[i,], pts2b[i,])
}))
dat &lt;- 1:150
class(dat) &lt;- c("POSIXct","POSIXt")
x &lt;- as.ltraj(pts, date=dat, id = rep("A", 150))

## See the trajectory:
plot(x)


## Now, we suppose that there is a precision of 0.05
## on the relocations
sig2 &lt;- 0.05
## and that sig1=0.1
sig1 &lt;- 0.1

## Now fits the brownian bridge home range
(kbb &lt;- kernelbb(x, sig1 = sig1,
                 sig2 = sig2))


## Now fits the classical kernel home range
coordinates(pts) &lt;- c("x","y")
(kud &lt;- kernelUD(pts))


###### The results

opar &lt;- par(mfrow=c(2,2), mar=c(0.1,0.1,2,0.1))
plot(pts, pch=16)
title(main="The relocation pattern")
box()
plot(x, axes=FALSE, main="The trajectory")
box()
image(kud)
title(main="Classical kernel home range")
plot(getverticeshr(kud, 95), add=TRUE)
box()
image(kbb)
title(main="Brownian bridge kernel home range")
plot(getverticeshr(kbb, 95), add=TRUE)
box()
par(opar)



###############################################
###############################################
###############################################
###
###         Image of a brownian bridge.
###          Fit with two relocations
###               


xx &lt;- c(0,1)
yy &lt;- c(0,1)
date &lt;- c(0,1)
class(date) &lt;- c("POSIXt", "POSIXct")
tr &lt;- as.ltraj(data.frame(x = xx,y = yy), date, id="a")

## Use of different smoothing parameters
sig1 &lt;- c(0.05, 0.1, 0.2, 0.4, 0.6)
sig2 &lt;- c(0.05, 0.1, 0.2, 0.5, 0.7)

y &lt;- list()
for (i in 1:5) {
  for (j in 1:5) {
     k &lt;- paste("s1=", sig1[i], ", s2=", sig2[j], sep = "")
     y[[k]]&lt;-kernelbb(tr, sig1[i], sig2[j])
   }
 }

## Displays the results
opar &lt;- par(mar = c(0,0,2,0), mfrow = c(5,5))
foo &lt;- function(x)
   {
     image(y[[x]])
     title(main = names(y)[x])
     points(tr[[1]][,c("x","y")], pch = 16)
   }
lapply(1:length(y), foo)

par(opar)



## End(Not run)
</code></pre>

<hr>
<h2 id='kernelkc'>Kernel Smoothing in Space and Time of the Animals' Use of Space</h2><span id='topic+kernelkc'></span><span id='topic+kernelkcbase'></span><span id='topic+getvolumeUDk'></span><span id='topic+getvolumeUDs'></span><span id='topic+getverticeshrk'></span><span id='topic+getverticeshrs'></span><span id='topic+exwc'></span>

<h3>Description</h3>

<p>These functions estimate the utilization distribution (UD) in space
and time of animals monitored using radio-telemetry, using the product
kernel estimator advocated by Keating and Cherry (2009).
</p>
<p>Note that this approach has also been useful for the analysis of
recoveries in programs involving ringed birds (Calenge et al. 2010,
see section examples below).
</p>
<p><code>kernelkc</code> estimate the UD of several animals from an object of
class <code>ltraj</code>.
</p>
<p><code>kernelkcbase</code> estimate one UD from a data frame with three
columns indicating the spatial coordinates and associated timing.
</p>
<p><code>exwc</code> allows to search for the best value of the
time smoothing parameter in the case where the time is considered as a
circular variable (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelkc(tr, h, tcalc, t0, grid = 40, circular = FALSE,
         cycle = 24 * 3600, same4all = FALSE,
         byburst = FALSE, extent = 0.5)

kernelkcbase(xyt, h, tcalc, t0, grid=40, circular=FALSE,
             cycle=24*3600, extent=0.5)

exwc(hv)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernelkc_+3A_tr">tr</code></td>
<td>
<p>an object of class <code>ltraj</code></p>
</td></tr>
<tr><td><code id="kernelkc_+3A_xyt">xyt</code></td>
<td>
<p>a data frame with three columns indicating the x and y
coordinates, as well as the timing of the relocations. </p>
</td></tr>
<tr><td><code id="kernelkc_+3A_h">h</code></td>
<td>
<p>a numeric vector with three elements indicating the value of
the smoothing parameters: the first and second elements are
the smoothing parameters of the X and Y coordinates respectively,
the third element is the smoothing parameter for the time
dimension.  If <code>circular=TRUE</code> it should be a smoothing
parameter in the interval 0-1 (see details).  If
<code>circular=FALSE</code> this smoothing parameter should be given in
seconds.</p>
</td></tr>
<tr><td><code id="kernelkc_+3A_tcalc">tcalc</code></td>
<td>
<p>the time at which the UD is to be estimated</p>
</td></tr>
<tr><td><code id="kernelkc_+3A_t0">t0</code></td>
<td>
<p>if <code>circular=TRUE</code>, this parameter indicates the time
at which the time cycle begins (see examples).</p>
</td></tr>
<tr><td><code id="kernelkc_+3A_grid">grid</code></td>
<td>
<p>a number giving the size of the grid on which the UD should
be estimated.  Alternatively, this parameter may be an object
of class <code>SpatialPixels</code>.  In addition, for the function
<code>kernelkc</code> this parameter can be a list of objects of class
<code>SpatialPixels</code>, with named elements corresponding to each
level of the burst/id</p>
</td></tr>
<tr><td><code id="kernelkc_+3A_circular">circular</code></td>
<td>
<p>logical.  Indicates whether the time should be
considered as a circular variable (e.g., the 31th december 2007 is
considered to be one day before the 1st january 2007) or not (e.g.,
the 31th december 2007 is considered to be one year after the 1st
january 2007).</p>
</td></tr>
<tr><td><code id="kernelkc_+3A_cycle">cycle</code></td>
<td>
<p>if <code>circular=TRUE</code>, the duration of the time cycle.
for <code>kernelkc</code>, it should be given in seconds, and for
<code>kernelkcbase</code>, in the units of the data (the units of the
third column of <code>xyt</code>).</p>
</td></tr>
<tr><td><code id="kernelkc_+3A_same4all">same4all</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the same grid is used for all
levels of id/burst.  If <code>FALSE</code>, one grid per id/burst is used.</p>
</td></tr>
<tr><td><code id="kernelkc_+3A_byburst">byburst</code></td>
<td>
<p>logical.  Indicates whether one UD should be estimated
by burst of <code>tr</code>, or whether the data should be pooled across
all bursts of each value of id in <code>tr</code></p>
</td></tr>
<tr><td><code id="kernelkc_+3A_extent">extent</code></td>
<td>
<p>a value indicating the extent of the grid used for the
estimation (the extent of the grid on the abscissa is equal
to <code>(min(xy[,1]) + extent * diff(range(xy[,1])))</code>). </p>
</td></tr>
<tr><td><code id="kernelkc_+3A_hv">hv</code></td>
<td>
<p>a value of smoothing parameter for the time dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Keating and Cherry (2009) advocated the estimation of the UD in
time and space using the product kernel estimator.  These functions
implement exactly this methodology.\
</p>
<p>For the spatial coordinates, the implemented kernel function is the
biweight kernel.
</p>
<p>Two possible
approaches are possible to manage the time in the estimation process:
(i) the time may be considered as a linear variable (e.g., the 31th
december 2007 is considered to be one day before the 1st january
2007), or (ii) the time may be considered as a circular variable
(e.g., the 31th december 2007 is considered to be one year after the
1st january 2007).
</p>
<p>If the time is considered as a linear variable, the kernel function
used in the estimation process is the biweight kernel.  If the time is
considered as a circular variable, the implemented kernel is the
wrapped Cauchy distribution (as in the article of Keating and Cherry).
In this latter case, the smoothing parameter should be chosen in the
interval 0-1, with a value of 1 corresponding to a stronger
smoothing.
</p>
<p>These functions can only be used on objects of class &quot;ltraj&quot;, but
the estimation of the UD in time and space is also possible with other
types of data (see the help page of <code>kernelkcbase</code>).  Note that
both <code>kernelkc</code> and <code>kernelkcbase</code> return conditional
probability density function (pdf), i.e. the pdf to relocate an animal
at a place, given that it has been relocated at time <code>tcalc</code>
(i.e. the volume under the UD estimated at time <code>tcalc</code> is equal
to 1 whatever <code>tcalc</code>).
</p>
<p>The function <code>exwc</code> draws a graph of the wrapped
Cauchy distribution for the chosen <code>h</code> parameter (for circular
time), so that it is possible to make one's mind concerning the weight
that can be given to the neighbouring points of a given time point.
Note that although Keating and Cherry (2009) advocated the use of
an automatic algorithm to select &quot;optimal&quot; values for the smoothing
parameter, it is not implemented in adehabitatHR.  Indeed, different
smoothing parameters may allow to identify patterns at different
scales, and we encourage the user to try several values before
subjectively choosing the value which allows to more clearly identify
the patterns of the UD.
</p>


<h3>Value</h3>

<p><code>kernelkc</code> returns a list of class &quot;<code>estUDm</code>&quot; containing
objects of class <code>estUD</code>, mapping one estimate of the UD per burst
or id (depending on the value of the parameter <code>byburst</code>).
</p>
<p><code>kernelkcbase</code> returns an object of class &quot;<code>estUD</code>&quot; mapping
the  estimated UD.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>References</h3>

<p>Keating, K. and Cherry, S. (2009) Modeling utilization
distributions in space and time. <em>Ecology</em>, <b>90</b>:
1971&ndash;1980.
</p>
<p>Calenge, C., Guillemain, M., Gauthier-Clerc, M. and Simon, G. 2010.  A
new exploratory approach to the study of the spatio-temporal
distribution of ring recoveries - the example of Teal (Anas crecca)
ringed in Camargue, Southern France. <em>Journal of Ornithology</em>,
<b>151</b>, 945&ndash;950.
</p>


<h3>See Also</h3>

<p><code><a href="adehabitatLT.html#topic+as.ltraj">as.ltraj</a></code> for additional information on objects of
class <code>ltraj</code>, <code><a href="#topic+kernelUD">kernelUD</a></code> for the &quot;classical&quot; kernel
home range estimates. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


################################################
##
## Illustrates the analysis of recoveries of
## ringed data

data(teal)
head(teal)

## compute the sequence of dates at which the
## probability density function (pdf) of recoveries is to be estimated

vv &lt;- seq(min(teal$date), max(teal$date), length=50)
head(vv)

## The package "maps" should be installed for the example below
library(maps)


re &lt;- lapply(1:length(vv), function(i) {

             ## Estimate the pdf. We choose a smoothing parameter of
             ## 2 degrees of lat-long for X and Y coordinates,
             ## and of 2 months for the time
             uu &lt;- kernelkcbase(teal, c(2.5,2.5,2*30*24*3600), tcalc =
                                vv[i], grid=100, extent=0.1)

             ## now, we show the result
             ## potentially, we could type
             ##
             ## jpeg(paste("prdefu", i, ".jpg", sep=""))
             ##
             ## to store the figures in a file, and then to build a
             ## movie with the resulting files:
             ##

             image(uu, col=grey(seq(1,0, length=8)))
             title(main=vv[i])

             ## highlight the area on which there is a probability
             ## equal to 0.95 to recover a bird
             ## ****warning! The argument standardize=TRUE should
             ## be passed, because the UD is defined in space and
             ## time, and because we estimate the UD just in space
             plot(getverticeshr(uu, 95, standardize=TRUE), add=TRUE,
                  border="red", lwd=2)

             ## The map:
             map(xlim=c(-20,70), ylim=c(30,80), add=TRUE)

             ## and if we had typed jpeg(...) before, we have to type
             ## dev.off()
             ## to close the device. When we have finished this loop
             ## We could combine the resulting files with imagemagick
             ## (windows) or mencoder (linux)
             })




################################################
##
## Illustrates how to explore the UD in time and
## space with the bear data

data(bear)

## compute the sequence of dates at which the UD is to be
## estimated
vv &lt;- seq(min(bear[[1]]$date), max(bear[[1]]$date), length=50)
head(vv)

## estimates the UD at each time point
re &lt;- lapply(1:length(vv), function(i) {

             ## estimate the UD. We choose a smoothing parameter of
             ## 1000 meters for X and Y coordinates, and of 72 hours
             ## for the time (after a visual exploration)
             uu &lt;- kernelkc(bear, h = c(1000,1000,72*3600),
                            tcalc= vv[i], grid=100)

             ## now, we show the result
             ## potentially, we could type
             ##
             ## jpeg(paste("UD", i, ".jpg", sep=""))
             ##
             ## to store the figures in a file, and then to build a
             ## movie with the resulting files:
             ##
             image(uu, col=grey(seq(1,0,length=10)))
             title(main=vv[i])

             ## highlight the 95 percent home range
             ## we set standardize = TRUE because we want to estimate
             ## the home range in space from a UD estimated in space and
             ## time
             plot(getverticeshr(uu, 95, standardize=TRUE), lwd=2,
                  border="red", add=TRUE)

             ## and if we had typed jpeg(...) before, we have to type
             ## dev.off()
             ## to close the device. When we have finished this loop
             ## We could combine the resulting files with imagemagick
             ## (windows) or mencoder (linux)
             })


## Or, just show the home range:
re &lt;- lapply(1:length(vv), function(i) {

             uu &lt;- kernelkc(bear, h = c(1000,1000,72*3600),
                            tcalc= vv[i])

             pc &lt;- getverticeshr(uu, 95, standardize=TRUE)
             plot(pc, xlim=c(510000, 530000),
                  ylim=c(6810000, 6825000))
             title(main=vv[i])
             })








##################################################
##
## Example with several wild boars (linear time)

## load wild boar data
data(puechcirc)


## keep only the first two circuits:
puechc &lt;- puechcirc[1:2]


## Now load the map of the elevation
data(puechabonsp)


## compute the time point at which the UD is to be estimated
vv &lt;- seq(min(puechcirc[[2]]$date), max(puechcirc[[2]]$date),
          length=50)


## The estimate the UD
re &lt;- lapply(1:length(vv),
             function(i) {

                 ## We choose a smoothing parameter of 300 meters for
                 ## the x and y coordinates and of one hour for the time
                 ## (but try to play with these smoothing parameters)

                 uu &lt;- kernelkc(puechcirc, h=c(300,300,3600),
                                tcalc = vv[i], same4all=TRUE,
                                extent=0.1)

                 ## show the elevation
                 image(puechabonsp$map, 
                       xlim=c(698000,704000),
                       ylim=c(3156000,3160000))
                 title(main=vv[i])

                 ## and the UD, with contour lines
                 colo &lt;- c("green","blue")
                 lapply(1:length(uu), function(i) {
                        contour(as(uu[[i]],"SpatialPixelsDataFrame"),
                                add=TRUE, col=colo[i])
                 })

                 ## the blue contour lines show the UD of the mother and
                 ## the red ones correspond to her son. Adult wild boars
                 ## are known to be more "shy" that the youger ones.
                 ## Here, the low elevation corresponds to crop area
                 ## (vineyards). The young boar is the first and the
                 ## last in the crops
             })








##################################################
##
## Example with the bear, to illustrate (circular time)

data(bear)

## We consider a time cycle of 24 hours.
## the following vector contains the time points on the
## time circle at which the UD is to be estimated (note that
## the time is given in seconds)
vv &lt;- seq(0, 24*3600-1, length=40)


## for each time point:
re &lt;- lapply(1:length(vv),
             function(i) {

                 ## Estimation of the UD for the bear. We choose
                 ## a smoothing parameter of 1000 meters for the spatial
                 ## coordinates and a smoothing parameter equal to 0.2
                 ## for the time. We set the beginning of the time
                 ## cycle at midnight (no particular reason, just to
                 ## illustrate the function). So we pass, as t0, any
                 ## object of class POSIXct corresponding t a date at
                 ## this hour, for example the 12/25/2012 at 00H00
                 t0 &lt;- as.POSIXct("2012-12-25 00:00")
                 uu &lt;- kernelkc(bear, h=c(1000,1000,0.2), cycle=24*3600,
                                 tcalc=vv[i], t0=t0, circular=TRUE)

                 ## shows the results
                 ## first compute the hour for the title
                 hour &lt;- paste(floor(vv[i]/3600), "hours",
                               floor((vv[i]%%3600)/60), "min")

                 ## compute the 95% home range
                 pc &lt;- getverticeshr(uu, 95, standardize=TRUE)
                 plot(pc, xlim=c(510000, 530000),
                      ylim=c(6810000, 6825000))
                 title(main=hour)

                 ## compute the 50% home range
                 pc &lt;- getverticeshr(uu, 50, standardize=TRUE)
                 plot(pc, add=TRUE, col="blue")
                 
             })
 ## Now, each home range computed at a given time point corresponds to
 ## the area used by the animal at this time period.  We may for example
 ## try to identify the main difference in habitat composition of the
 ## home-range between different time, to identify differences in
 ## habitat use between different time of the day. We do not do it here
 ## (lack of example data)










##################################################
##
## Example of the use of the function kernelkcbase and
## related functions


## load the data
data(puechabonsp)
locs &lt;- puechabonsp$relocs

## keeps only the wild boar Jean
locs &lt;- locs[slot(locs, "data")[,1]=="Jean",]

## compute the number of days since the beginning
## of the monitoring
dd &lt;- cumsum(c(0, diff(strptime(slot(locs, "data")[,4], "%y%m%d"))))
dd

## compute xyt. Note that t is here the number of
## days since the beginning of the monitoring (it
## is not an object of class POSIXt, but it may be)
xyt &lt;- data.frame(as.data.frame(coordinates(locs)), dd)

## Now compute the time points at which the UD is to be estimated:
vv &lt;- 1:61

## and finally, show the UD changed with time:
re &lt;- lapply(1:length(vv),
             function(i) {
                 ud &lt;- kernelkcbase(xyt, h=c(300,300,20), 
                                    tcalc=vv[i], grid=100)
                 image(ud, main=vv[i])
                 plot(getverticeshr(ud, 95, standardize=TRUE),
                       border="red", lwd=2, add=TRUE)

                 ## Just to slow down the process
                 Sys.sleep(0.2)
                 })




## End(Not run)



</code></pre>

<hr>
<h2 id='kerneloverlap'>Spatial Interaction between Animals Monitored Using Radio-Tracking</h2><span id='topic+kerneloverlap'></span><span id='topic+kerneloverlaphr'></span>

<h3>Description</h3>

<p>These functions implements all the indices of kernel home-range overlap
reviewed by Fieberg and Kochanny (2005).  <code>kerneloverlap</code>
computes these indices from a set of relocations, whereas
<code>kerneloverlaphr</code> computes these indices from an object
containing the utilization distributions of the animals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kerneloverlap(xy, method = c("HR", "PHR", "VI", "BA", "UDOI",
              "HD"), percent = 95, conditional = FALSE, ...)

kerneloverlaphr(x, method = c("HR", "PHR", "VI", "BA", "UDOI", "HD"),
                percent = 95, conditional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kerneloverlap_+3A_xy">xy</code></td>
<td>
<p>an object of class <code>SpatialPointsDataFrame</code> containing
only one column (which is a factor indicating the identity
associated to the relocations))</p>
</td></tr>
<tr><td><code id="kerneloverlap_+3A_x">x</code></td>
<td>
<p>an object of class <code>estUDm</code> containing several
home-ranges for which the overlap is to be calculated</p>
</td></tr>
<tr><td><code id="kerneloverlap_+3A_method">method</code></td>
<td>
<p>the desired method for the estimation of overlap (see
details)</p>
</td></tr>
<tr><td><code id="kerneloverlap_+3A_percent">percent</code></td>
<td>
<p>the percentage level of the home range estimation</p>
</td></tr>
<tr><td><code id="kerneloverlap_+3A_conditional">conditional</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the function sets to 0
the pixels of the grid over which the UD is estimated,
outside the home range of the animal estimated at a level of
probability equal to <code>percent</code>.  Note that this argument has no
effect when <code>meth="HR"</code>.</p>
</td></tr>
<tr><td><code id="kerneloverlap_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function
<code>kernelUD</code> for the kernel estimation of the utilization
distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fieberg and Kochanny (2005) made an extensive review of the indices of
overlap between utilization distributions (UD) of two animals.  The
function <code>kerneloverlap</code> implements these indices.  The argument
<code>method</code> allows to choose an index.
</p>
<p>The choice <code>method="HR"</code> computes the proportion of the home
range of one animal covered by the home range of another one, i.e.:
</p>
<p style="text-align: center;"><code class="reqn">HR_{i,j} = A_{i,j} / A_i</code>
</p>
<p>,
where <code class="reqn">A_{i,j}</code> is the area of the intersection between
the two home ranges and <code class="reqn">A_i</code> is the area of the home range
of the animal i.
</p>
<p>The choice <code>method="PHR"</code> computes the volume under the UD of the
animal j that is inside the home range of the animal i (i.e., the
probability to find the animal j in the home range of i). That is:
</p>
<p style="text-align: center;"><code class="reqn">PHR_{i,j} = \int \int_{A_i} UD_j(x,y) dxdy</code>
</p>
<p> where
<code class="reqn">UD_j(x,y)</code> is the value of the utilization
distribution of the animal j at the point x,y.
</p>
<p>The choice <code>method="VI"</code> computes the volume of the intersection
between the two UD, i.e.:
</p>
<p style="text-align: center;"><code class="reqn">VI = \int_x \int_y min(UD_i(x,y),UD_j(x,y)) dxdy</code>
</p>

<p>Other choices rely on the computation of the joint distribution of the
two animals under the hypothesis of independence UD[i](x,y) *
UD[j](x,y). 
</p>
<p>The choice <code>method="BA"</code> computes the Bhattacharyya's affinity
</p>
<p style="text-align: center;"><code class="reqn">BA = \int_x \int_y \sqrt{UD_i(x,y)} \times \sqrt{UD_j(x,y)}</code>
</p>
<p><br />
</p>
<p>The choice <code>method="UDOI"</code> computes a measure similar to the
Hurlbert index of niche overlap:
</p>
<p style="text-align: center;"><code class="reqn">UDOI = A_{i,j} \int_x \int_y UD_i(x,y) \times
  UD_j(x,y)</code>
</p>

<p>The choice <code>method="HD"</code> computes the Hellinger's distance:
</p>
<p style="text-align: center;"><code class="reqn">HD = \int_x \int_y ((\sqrt UD_i(x,y) - \sqrt UD_j(x,y))^2
  dxdy)^{1/2}</code>
</p>



<h3>Value</h3>

<p>A matrix giving the value of indices of overlap for all pairs of
animals.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a>,
based on a work of John Fieberg</p>


<h3>References</h3>

<p>Fieberg, J. and Kochanny, C.O. (2005) Quantifying home-range overlap: the
importance of the utilization distribution. <em>Journal of Wildlife
Management</em>, <b>69</b>, 1346&ndash;1359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernelUD">kernelUD</a></code> for additional information on kernel
estimation of home ranges</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(puechabonsp)

kerneloverlap(puechabonsp$relocs[,1],
              grid=200, meth="VI", conditional=TRUE)

## Identical to
kud &lt;- kernelUD(puechabonsp$relocs[,1],
                grid=200, same4all=TRUE)
kerneloverlaphr(kud, meth="VI", conditional=TRUE)

## other indices
kerneloverlap(puechabonsp$relocs[,1],
              grid=200, meth="HR")

kerneloverlap(puechabonsp$relocs[,1],
              grid=200, meth="PHR")

kerneloverlap(puechabonsp$relocs[,1],
              grid=200, meth="BA")

kerneloverlap(puechabonsp$relocs[,1],
              grid=200, meth="UDOI")

kerneloverlap(puechabonsp$relocs[,1],
              grid=200, meth="HD")

## End(Not run)
</code></pre>

<hr>
<h2 id='kernelUD'>Estimation of Kernel Home-Range</h2><span id='topic+kernelUD'></span><span id='topic+print.estUDm'></span><span id='topic+image.estUD'></span><span id='topic+image.estUDm'></span><span id='topic+plotLSCV'></span><span id='topic+getvolumeUD'></span><span id='topic+kernel.area'></span><span id='topic+estUDm2spixdf'></span><span id='topic+as.data.frame.estUD'></span>

<h3>Description</h3>

<p>The function <code>kernelUD</code> estimates the UD of one or several
animals.
</p>
<p><code>plotLSCV</code> allows to explore the results of the least-square
cross-validation algorithm used to find the best smoothing value.
</p>
<p><code>image</code> allows a graphical display of the estimates.
</p>
<p><code>getvolumeUD</code> and <code>kernel.area</code> provide utilities
for home range and home-range size estimation.
</p>
<p><code>getverticeshr</code> stores the home range contour as an object of
class <code>SpatialPolygonsDataFrame</code> (package sp), with one row per
animal.
</p>
<p><code>estUDm2spixdf</code> can be used to convert the result into an object
of class <code>SpatialPixelsDataFrame</code>
</p>
<p><code>as.data.frame.estUD</code> can be used to convert an object of class
<code>estUD</code> as a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
kernelUD(xy, h = "href", grid = 60,
         same4all = FALSE, hlim = c(0.1, 1.5),
         kern = c("bivnorm", "epa"), extent = 1,
         boundary = NULL)

## S3 method for class 'estUDm'
print(x, ...)

## S3 method for class 'estUD'
image(x, ...)

## S3 method for class 'estUDm'
image(x, ...)

## S3 method for class 'estUD'
as.data.frame(x, row.names, optional, ...)

plotLSCV(x)

getvolumeUD(x, standardize = FALSE)

kernel.area(x, percent = seq(20, 95, by = 5),
            unin = c("m", "km"),
            unout = c("ha", "km2", "m2"), standardize = FALSE)

estUDm2spixdf(x)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernelUD_+3A_xy">xy</code></td>
<td>
<p>An object inheriting the class <code>SpatialPoints</code>
containing the x and y relocations of the animal.  If <code>xy</code>
inherits the class <code>SpatialPointsDataFrame</code>, it should contain
only one column (factor) corresponding to the identity of the
animals for each relocation.</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_h">h</code></td>
<td>
<p>a character string or a number.  If <code>h</code> is set to
<code>"href"</code>, the ad hoc method is used for the smoothing parameter
(see details).  If <code>h</code> is set to 
<code>"LSCV"</code>, the least-square cross validation method is
used. Note that <code>"LSCV"</code> is not available if <code>kern = "epa"</code>. 
Alternatively, <code>h</code> may be set to any given numeric value</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_grid">grid</code></td>
<td>
<p>a number giving the size of the grid on
which the UD should be estimated.  Alternatively, this parameter may
be an object inheriting the class <code>SpatialPixels</code>, that will be
used for all animals.  For the function <code>kernelUD</code>, it may in
addition be a list of objects of class <code>SpatialPixels</code>, with
named elements corresponding to each level of the factor id.</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_hlim">hlim</code></td>
<td>
<p>a numeric vector of length two.  If <code>h = "LSCV"</code>,
the function minimizes the cross-validation criterion for values of
h ranging from <code>hlim[1]*href</code> to <code>hlim[2]*href</code>, where
<code>href</code> is the smoothing parameter computed with the ad hoc
method (see below)</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_kern">kern</code></td>
<td>
<p>a character string.  If <code>"bivnorm"</code>, a bivariate
normal kernel is used.  If <code>"epa"</code>, an Epanechnikov kernel is
used.</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_extent">extent</code></td>
<td>
<p>a value controlling the extent of the grid used for the
estimation (the extent of the grid on the abscissa is equal to
<code>(min(abscissa.relocations) + extent *
      diff(range(abscissa.relocations)))</code>, and similarly for the ordinate).</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_same4all">same4all</code></td>
<td>
<p>logical. If <code>TRUE</code>, the same grid
is used for all animals.  If <code>FALSE</code>, one grid per
animal is used.  Note that when <code>same4all = TRUE</code>, the grid
used for the estimation is calculated by the function (so that the
parameter <code>grid</code> cannot be a <code>SpatialPixels</code> object).</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_boundary">boundary</code></td>
<td>
<p>If, not <code>NULL</code>, an object inheriting the class
<code>SpatialLines</code> defining a barrier that cannot be crossed by the
animals.  There are constraints on the shape of the barrier that
depend on the smoothing parameter <code>h</code> (***see details***)</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_x">x</code></td>
<td>
<p>an object of class <code>estUD</code> (UD for one animal) or
<code>estUDm</code> (UD for several animals).  For the 
function <code>estUDm2spixdf</code>, an object of class <code>estUDm</code>
only.  For the function <code>as.data.frame.estUD</code>, an object of
class <code>estUD</code> only.</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_percent">percent</code></td>
<td>
<p>for <code>kernel.area</code>, a vector of percentage levels
for home-range size estimation.  For <code>getverticeshr</code>, a single
value giving the percentage level for home-range estimation.</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_standardize">standardize</code></td>
<td>
<p>a logical value indicating whether the UD should be
standardized over the area of interest, so that the volume under the
UD and *over the area* is equal to 1.</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_unin">unin</code></td>
<td>
<p>the units of the relocations coordinates.  Either <code>"m"</code> for
meters (default) or <code>"km"</code> for kilometers</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_unout">unout</code></td>
<td>
<p>the units of the output areas.  Either <code>"m2"</code> for
square meters, <code>"km2"</code> for square kilometers or <code>"ha"</code> for
hectares (default)</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_row.names">row.names</code></td>
<td>
<p>unused argument here</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_optional">optional</code></td>
<td>
<p>unused argument here</p>
</td></tr>
<tr><td><code id="kernelUD_+3A_...">...</code></td>
<td>
<p>additionnal parameters to be passed to the generic
functions <code>print</code> and <code>image</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Utilization Distribution (UD) is the bivariate function giving the
probability density that an animal is found at a point according to
its geographical coordinates.  Using this model, one can define 
the home range as the minimum area in which an animal has some
specified probability of being located. The
functions used here correspond to the approach described in Worton
(1995).
</p>
<p>The kernel method has been recommended by many authors for the
estimation of the utilization distribution (e.g. Worton, 1989, 1995).
The default method for the estimation of the
smoothing parameter is the <em>ad hoc</em> method, i.e. for a bivariate
normal kernel
</p>
<p style="text-align: center;"><code class="reqn">h = \sigma n^{- \frac{1}{6}}</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">\sigma^2 = 0.5 (var(x)+var(y))</code>
</p>
<p> which supposes that the UD is
bivariate normal.  If an Epanechnikov kernel is used, this value is
multiplied by 1.77 (Silverman, 1986, p. 86).
Alternatively, the smoothing parameter h may be
computed by Least Square Cross Validation (LSCV).  The estimated value
then minimizes the Mean Integrated Square Error (MISE), i.e. the
difference in volume between the true UD and the estimated UD.  Note
that the cross-validation criterion cannot be minimized in some
cases.  According to Seaman and Powell (1998) <em>&quot;This is a
difficult problem that has not been worked out by statistical
theoreticians, so no definitive response is available at this
time&quot;</em> (see Seaman and Powell, 1998 for further details and tricky
solutions).  <code>plotLSCV</code> allows to have a diagnostic of the
success of minimization of the cross validation criterion (i.e. to
know whether the minimum of the CV criterion occurs within the scanned
range).  Finally, the UD is then estimated over a grid.
</p>
<p>The default kernel is the bivariate normal kernel, but the
Epanechnikov kernel, which requires less computer time is also
available for the estimation of the UD.
</p>
<p>The function <code>getvolumeUD</code> modifies the UD component of the
object passed as argument: that the pixel values of the resulting
object are equal to the percentage of the smallest home range
containing this pixel.  This function is used in the function
<code>kernel.area</code>, to compute the home-range size.  Note, that the
function <code>plot.hrsize</code> (see the help page of this  function) can
be used to display the home-range size estimated at various levels.
</p>
<p>The parameter <code>boundary</code> allows to define a barrier that cannot
be crossed by the animals.  When this parameter is
set, the method described by Benhamou and Cornelis (2010) for
correcting boundary biases is used.  The boundary can possibly be
defined by several nonconnected lines, each one being built by several
connected segments. Note that there are constraints on these segments
(not all kinds of boundary can be defined): (i) each segment length
should at least be equal to <code>3*h</code> (the size of &quot;internal lane&quot;
according to the terminology of Benhamou and Cornelis), (ii) the angle
between two line segments should be greater that <code>pi/2</code> or lower
that <code>-pi/2</code>.  The UD of all the pixels located within a
band defined by the boundary and with a width equal to <code>6*h</code>
(&quot;external lane&quot;) is set to zero.
</p>


<h3>Value</h3>

<p>The function <code>kernelUD</code> returns either: (i) an object belonging
to the S4 class <code>estUD</code> (see <code>?estUD-class</code>) when the object
<code>xy</code> passed as argument contains the relocations of only one
animal (i.e., belong to the class <code>SpatialPoints</code>), or (ii) a
list of elements of class <code>estUD</code> when the object
<code>xy</code> passed as argument contains the relocations of several
animals (i.e., belong to the class <code>SpatialPointsDataFrame</code>).
</p>
<p>The function <code>getvolumeUD</code> returns an object of the same class as
the object passed as argument (<code>estUD</code> or <code>estUDm</code>). 
</p>
<p><code>kernel.area</code> returns a data frame of subclass <code>hrsize</code>,
with one column per animal and one row per level of
estimation of the home range.
</p>
<p><code>getverticeshr</code> returns an object of class
<code>SpatialPolygonsDataFrame</code>.
</p>
<p><code>estUDm2spixdf</code> returns an object of class
<code>SpatialPixelsDataFrame</code>.
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>References</h3>

<p>Silverman, B.W. (1986)
<em>Density estimation for statistics and data
analysis</em>. London: Chapman and Hall.
</p>
<p>Worton, B.J. (1989) Kernel methods for estimating the utilization
distribution in home-range studies. <em>Ecology</em>, <b>70</b>, 164&ndash;168.
</p>
<p>Worton, B.J. (1995) Using Monte Carlo simulation to evaluate
kernel-based home range estimators. <em>Journal of Wildlife Management</em>,
<b>59</b>,794&ndash;800.
</p>
<p>Seaman, D.E. and Powell, R.A. (1998) <em>Kernel home range estimation
program (kernelhr)</em>. Documentation of the
program.
</p>
<p>Benhamou, S. and Cornelis, D. (2010) Incorporating Movement Behavior
and Barriers to Improve Biological Relevance of Kernel Home Range
Space Use Estimates. <em>Journal of Wildlife Management</em>, <b>74</b>,
1353&ndash;1360.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcp">mcp</a></code> for help on the function <code>plot.hrsize</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load the data
data(puechabonsp)
loc &lt;- puechabonsp$relocs

## have a look at the data
head(as.data.frame(loc))
## the first column of this data frame is the ID


## Estimation of UD for the four animals
(ud &lt;- kernelUD(loc[,1]))

## The UD of the four animals
image(ud)

## Calculation of the 95 percent home range
ver &lt;- getverticeshr(ud, 95)

## and display on an elevation map:
elev &lt;- puechabonsp$map
image(elev, 1)
plot(ver, add=TRUE, col=rainbow(4))
legend(699000, 3165000, legend = names(ud), fill = rainbow(4))

## Example of estimation using LSCV
udbis &lt;- kernelUD(loc[,1], h = "LSCV")
image(udbis)


## Compare the estimation with ad hoc and LSCV method
## for the smoothing parameter
(cuicui1 &lt;- kernel.area(ud)) ## ad hoc
plot(cuicui1)
(cuicui2 &lt;- kernel.area(udbis)) ## LSCV
plot(cuicui2)

## Diagnostic of the cross-validation
plotLSCV(udbis)



## Use of the same4all argument: the same grid
## is used for all animals
## BTW, we indicate a grid with a fine resolution:
udbis &lt;- kernelUD(loc[,1], same4all = TRUE, grid = 100)
image(udbis)


## Estimation of the UD on a map
## (e.g. for subsequent analyses on habitat selection)
## Measures the UD in each pixel of the map
udbis &lt;- kernelUD(loc[,1], grid = elev)
image(udbis)


##########################################
##
## Estimating the UD with the presence of a barrier
## The boars are located on the plateau of Puechabon (near
## Montpellier, France), and their movements are limited by the
## Herault river.

## We first map the elevation:
image(elev)

## Then, we used the function locator() to identify the limits of the
## segments of this barrier. BEWARE! The boundary should satisfy the two
## constraints: (i) segment length &gt; 3*h, (ii) no angle lower than pi/2
## between successive segments. We choose a smoothing parameter of 100
## m, so that no segment length should be less than 300 m.
## Because the resolution of the map is 100 m, this means that no
## segment should cover less than 3 pixels. We have used the function
## locator() to digitize this barrier and then the function dput to
## have the following limits:

bound &lt;- structure(list(x = c(701751.385381925, 701019.24105475,
                        700739.303517889,
                        700071.760160759, 699522.651915378,
                        698887.40904327, 698510.570051342,
                        698262.932999504, 697843.026694212,
                        698058.363261028),
                        y = c(3161824.03387414,
                        3161824.03387414, 3161446.96718494,
                        3161770.16720425, 3161479.28718687,
                        3161231.50050539, 3161037.5804938,
                        3160294.22044937, 3159389.26039528,
                        3157482.3802813)), .Names = c("x", "y"))

lines(bound, lwd=3)

## We convert bound to SpatialLines:
bound &lt;- do.call("cbind",bound)
Slo1 &lt;- Line(bound)
Sli1 &lt;- Lines(list(Slo1), ID="frontier1")
barrier &lt;- SpatialLines(list(Sli1))

## estimation of the UD
kud &lt;- kernelUD(loc[,1], h=100, grid=100, boundary=barrier)

## Result:
image(kud)

## Have a closer look to Calou:
kud2 &lt;- kud[[2]]
image(kud2, col=grey(seq(1,0,length=15)))
title(main="Home range of Calou")
points(loc[slot(loc,"data")[,1]=="Calou",], pch=3, col="blue")
plot(getverticeshr(kud2, 95), add=TRUE, lwd=2)
lines(barrier, col="red", lwd=3)



</code></pre>

<hr>
<h2 id='kver2spol'>Conversion of old classes from adehabitat to classes from adehabitatHR</h2><span id='topic+kver2spol'></span><span id='topic+khr2estUDm'></span>

<h3>Description</h3>

<p>These functions convert home ranges available in adehabitat toward
classes available in the package <code>adehabitatHR</code>.
</p>
<p><code>kver2spol</code> converts an object of class <code>kver</code> into an
object of class <code>SpatialPolygons</code>.
</p>
<p><code>khr2estUDm</code> converts an object of class <code>khr</code> (kernel UD)
into an object of class <code>estUDm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kver2spol(kv)
khr2estUDm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kver2spol_+3A_kv">kv</code></td>
<td>
<p>an object of class <code>kver</code>.</p>
</td></tr>
<tr><td><code id="kver2spol_+3A_x">x</code></td>
<td>
<p>an object of class <code>khr</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>

<hr>
<h2 id='LoCoH'>Estimating LoCoH home ranges</h2><span id='topic+LoCoH'></span><span id='topic+LoCoH.k'></span><span id='topic+LoCoH.r'></span><span id='topic+LoCoH.a'></span><span id='topic+LoCoH.k.area'></span><span id='topic+LoCoH.r.area'></span><span id='topic+LoCoH.a.area'></span>

<h3>Description</h3>

<p>The functions computes the home range of one or several animals using
the LoCoH family of methods.
</p>
<p>The functions <code>LoCoH.k</code>, <code>LoCoH.r</code>, and <code>LoCoH.a</code>
implement the k-LoCoH, r-LoCoH, and a-LoCoH respectively (Getz et
al. 2007).
</p>
<p>The functions <code>LoCoH.k.area</code>, <code>LoCoH.r.area</code>, and
<code>LoCoH.a.area</code> compute the curve showing the relationships
between the home-range size (computed to a specified percent) and the
k, r or a parameters respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoCoH.k(xy, k=5, unin = c("m", "km"),
        unout = c("ha", "m2", "km2"),
        duplicates=c("random","remove"), amount = NULL)

LoCoH.r(xy, r, unin = c("m", "km"),
        unout = c("ha", "m2", "km2"),
        duplicates=c("random","remove"), amount = NULL)

LoCoH.a(xy, a, unin = c("m", "km"),
        unout = c("ha", "m2", "km2"),
        duplicates=c("random","remove"), amount = NULL)



LoCoH.k.area(xy, krange, percent=100, unin = c("m", "km"),
             unout = c("ha", "m2", "km2"),
             duplicates=c("random","remove"), amount = NULL)

LoCoH.r.area(xy, rrange, percent=100, unin = c("m", "km"),
             unout = c("ha", "m2", "km2"),
             duplicates=c("random","remove"), amount = NULL)

LoCoH.a.area(xy, arange, percent=100, unin = c("m", "km"),
             unout = c("ha", "m2", "km2"),
             duplicates=c("random","remove"), amount = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LoCoH_+3A_xy">xy</code></td>
<td>
<p>An object inheriting the class <code>SpatialPoints</code>
containing the x and y relocations of the animal.  If <code>xy</code>
inherits the class <code>SpatialPointsDataFrame</code>, it should contain
only one column (a factor) corresponding to the identity of the
animals for each relocation.</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_k">k</code></td>
<td>
<p>numeric.  The number of nearest neighbors minus one out of
which to create convex hulls</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_r">r</code></td>
<td>
<p>numeric.  The convex hulls are created out of all points
within r distance from the root points</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_a">a</code></td>
<td>
<p>numeric. Create convex hulls from the maximum number of
nearest neighbors such that the sum of their distances is less than
or equal to this parameter</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_unin">unin</code></td>
<td>
<p>the units of the relocations coordinates.  Either
<code>"m"</code> for meters or <code>"km"</code> for kilometers</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_unout">unout</code></td>
<td>
<p>the units of the output areas.  Either <code>"m2"</code> for
square meters, <code>"km2"</code> for square kilometers or <code>"ha"</code> for
hectares</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_duplicates">duplicates</code></td>
<td>
<p>a setting to determine how duplicated points are
handled.  If &quot;<code>random</code>&quot; the duplicated points are slightly moved
randomly. If &quot;<code>remove</code>&quot; the duplicated points are removed.</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_amount">amount</code></td>
<td>
<p>if <code>duplicates == random</code>, this parameter controls the
amount of noise added to the data (see the help page of <code>jitter</code>
for additional information on this parameter).</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_krange">krange</code></td>
<td>
<p>a vector containing the values of k for which the home
range size is to be estimated.</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_arange">arange</code></td>
<td>
<p>a vector containing the values of k for which the home
range size is to be estimated.</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_rrange">rrange</code></td>
<td>
<p>a vector containing the values of k for which the home
range size is to be estimated.</p>
</td></tr>
<tr><td><code id="LoCoH_+3A_percent">percent</code></td>
<td>
<p>the percentage level of the home range.  For the
function <code>plot.LoCoH</code>, this value could also be the character
string <code>"all"</code>, indicating that all the polygons are to be
displayed.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The functions <code>LoCoH.*</code> return either objects of class
<code>SpatialPolygonsDataFrame</code> (if the relocations of only one
animals are passed as the <code>xy</code> argument) or a list of
<code>SpatialPolygonsDataFrame</code> (if the relocations of several
animals are passed as the <code>xy</code> argument).
</p>
<p>The functions <code>LoCoH.*.area</code> return invisibly either a vector (if
the  relocations of only one animals are passed as the <code>xy</code>
argument) or a data frame containing the home-range sizes for various
values of k, r (rows) for the different animals (columns).
</p>


<h3>Note</h3>

<p>These functions rely on the package sf.
</p>
<p>The LoCoH family of methods for locating Utilization Distributions
consists of three algorithms: Fixed k LoCoH, Fixed r LoCoH, and
Adaptive LoCoH.  All the algorithms work by constructing a small convex
hull for each relocation, and then incrementally merging the hulls
together from smallest to largest into isopleths.  The 10% isopleth
contains 10% of the points and represents a higher utilization than the
100% isopleth that contains all the points.
</p>
<p><b>Fixed k LoCoH:</b> Also known as k-NNCH, Fixed k LoCoH is described
in Getz and Willmers (2004).  The convex hull for each point is
constructed from the (k-1) nearest neighbors to that point.  Hulls are
merged together from smallest to largest based on the area of the
hull.
</p>
<p><b>Fixed r LoCoH:</b> In this case, hulls are created from all points
within <code>r</code> distance of the root point.  When merging hulls, the
hulls are primarily sorted by the value of k generated for each hull
(the number of points contained in the hull), and secondly by the area
of the hull.
</p>
<p><b>Adaptive LoCoH:</b>  Here, hulls are created out of the maximum
nearest neighbors such that the sum of the distances from the nearest
neighbors is less than or equal to d.  Use the same hull sorting as
Fixed r LoCoH.
</p>
<p>Fixed r LoCoH and Adaptive LoCoH are discussed in Getz et al (2007).
</p>
<p>All of these algorithms can take a significant amount of time.  Time
taken increases exponentially with the size of the data set.
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a><br />
with contributions from Scott Fortmann-Roe <a href="mailto:scottfr@gmail.com">scottfr@gmail.com</a></p>


<h3>References</h3>

<p>Getz, W.M. &amp; Wilmers, C.C. (2004). A local nearest-neighbor convex-hull
construction of home ranges and utilization
distributions. <em>Ecography</em>, <b>27</b>, 489&ndash;505.
</p>
<p>Getz, W.M., Fortmann-Roe, S.B, Lyons, A., Ryan, S., Cross,
P. (2007). LoCoH methods for the construction of home ranges and
utilization distributions. <em>PLoS ONE</em>, <b>2</b>: 1&ndash;11. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCHu">MCHu</a></code>, <code><a href="#topic+getverticeshr">getverticeshr</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Load the data
data(puechabonsp)

## The relocations:
locs &lt;- puechabonsp$relocs
locsdf &lt;- as.data.frame(locs)
head(locsdf)

## Shows the relocations
plot(locs, col=as.numeric(locsdf[,1]))


## Examinates the changes in home-range size for various values of k
## Be patient! the algorithm can be very long
ar &lt;- LoCoH.k.area(locs[,1], k=c(8:13))

## 12 points seems to be a good choice (rough asymptote for all animals)
## the k-LoCoH method:
nn &lt;- LoCoH.k(locs[,1], k=12)

## Graphical display of the results
plot(nn, border=NA)

## the object nn is a list of objects of class
## SpatialPolygonsDataFrame
length(nn)
names(nn)
class(nn[[1]])

## shows the content of the object for the first animal
as.data.frame(nn[[1]])

## The 95% home range is the smallest area for which the
## proportion of relocations included is larger or equal
## to 95% In this case, it is the 22th row of the
## SpatialPolygonsDataFrame.
## The area covered by the home range is for this first animal
## equal to 22.87 ha.

## shows this area:
plot(nn[[1]][11,])


## rasterization of the home ranges:
## use the map of the area:
image(puechabonsp$map)
ras &lt;- MCHu.rast(nn, puechabonsp$map, percent=100)  
opar &lt;- par(mfrow=c(2,2))
lapply(1:4, function(i) { image(ras,i); box()})
par(opar)


## r-LoCoH and a-LoCoH can be applied similarly


## End(Not run)

</code></pre>

<hr>
<h2 id='MCHu'>The Class &quot;MCHu&quot;: Managing Home Ranges Built by Multiple Convex
Hulls</h2><span id='topic+MCHu'></span><span id='topic+print.MCHu'></span><span id='topic+plot.MCHu'></span><span id='topic+MCHu.rast'></span><span id='topic+MCHu2hrsize'></span><span id='topic+spoldf2MCHu'></span>

<h3>Description</h3>

<p>The class <code>"MCHu"</code> is designed to store home ranges built by
multiple convex hulls, for example built using the single-linkage
cluster algorithm (function <code>clusterhr</code>) or the LoCoH
(e.g. function <code>LoCoH.k</code>).
</p>
<p>The function <code>plot.MCHu</code> allows to graphically display the
home-ranges.
</p>
<p><code>MCHu.rast</code> allows to compute a raster map of the home ranges.<br />
<code>MCHu2hrsize</code> allows to compute the home range size for specified
percentage levels for the home range (see
<code>help(plot.hrsize)</code>).
</p>
<p><code>spoldf2MCHu</code> allows to convert a SpatialPolygonsDataFrame
storing home ranges built by multiple convex hulls into an object of
class <code>"MCHu"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCHu'
print(x, ...)

## S3 method for class 'MCHu'
plot(x, percent="all", points=NULL, ...)

MCHu.rast(x, spdf, percent=100)

MCHu2hrsize(x, percent=seq(20,100, by=10), plotit=TRUE)

spoldf2MCHu(spdf, nam="a")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCHu_+3A_x">x</code></td>
<td>
<p>an object of class <code>MCHu</code>.</p>
</td></tr>
<tr><td><code id="MCHu_+3A_spdf">spdf</code></td>
<td>
<p>an object of class <code>SpatialPixelsDataFrame</code>.</p>
</td></tr>
<tr><td><code id="MCHu_+3A_points">points</code></td>
<td>
<p>an object of class <code>SpatialPoints</code> or
<code>SpatialPointsDataFrame</code> with one column (a factor storing the
identity of the animal for each relocation), containing the
relocations of the animal(s).</p>
</td></tr>
<tr><td><code id="MCHu_+3A_percent">percent</code></td>
<td>
<p>the percentage level of the home range.  For the
function <code>plot.MCHu</code>, this value could also be the character
string <code>"all"</code>, indicating that all the polygons are to be
displayed.</p>
</td></tr> 
<tr><td><code id="MCHu_+3A_plotit">plotit</code></td>
<td>
<p>a logical value indicating whether the results should be
plotted.</p>
</td></tr>
<tr><td><code id="MCHu_+3A_nam">nam</code></td>
<td>
<p>the name of the animal to be used in the object of class
<code>"MCHu"</code>.</p>
</td></tr>
<tr><td><code id="MCHu_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the functions
<code>print</code> and <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"MCHu"</code> is basically a list of objects of class
<code>SpatialPolygonsDataFrame</code>, with one data frame per animal. 
</p>


<h3>Value</h3>

<p>The function <code>MCHu.rast</code> returns an object of class
<code>SpatialPixelsDataFrame</code>.
</p>
<p>The function <code>MCHu2hrsize</code> returns an object of class
<code>hrsize</code> (see <code>?mcp.area</code>).
</p>


<h3>Author(s)</h3>

<p>Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+clusthr">clusthr</a></code> and <code><a href="#topic+LoCoH">LoCoH</a></code> for home range
estimation methods returning this class of objects.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(puechabonsp)

## The relocations:
locs &lt;- puechabonsp$relocs
locsdf &lt;- as.data.frame(locs)
head(locsdf)

## Shows the relocations
plot(locs, col=as.numeric(locsdf[,1]))


## 12 points seems to be a good choice (rough asymptote for all animals)
## the k-LoCoH method:
nn &lt;- LoCoH.k(locs[,1], k=12)

## Graphical display of the results
plot(nn, border=NA)

## Rasterize the home range on the elevation map:
image(puechabonsp$map)
(oo &lt;- MCHu.rast(nn, puechabonsp$map))
image(oo)


## End(Not run)
</code></pre>

<hr>
<h2 id='mcp'>Estimation of the Home Range Using the Minimum Convex Polygon
Estimator</h2><span id='topic+mcp'></span><span id='topic+hr.rast'></span><span id='topic+plot.hrsize'></span><span id='topic+mcp.area'></span>

<h3>Description</h3>

<p><code>mcp</code> computes the home range of several
animals using the Minimum Convex Polygon estimator.<br />
<code>mcp.area</code> is used for home-range size estimation.<br />
<code>hr.rast</code> is used to rasterize a minimum convex polygon.<br />
<code>plot.hrsize</code> is used to display the home-range size estimated at
various levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcp(xy, percent=95, unin = c("m", "km"),
    unout = c("ha", "km2", "m2"))

mcp.area(xy, percent = seq(20,100, by = 5),
         unin = c("m", "km"),
         unout = c("ha", "km2", "m2"), plotit = TRUE)

hr.rast(mcp, w)

## S3 method for class 'hrsize'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcp_+3A_xy">xy</code></td>
<td>
<p>An object inheriting the class <code>SpatialPoints</code>
containing the x and y relocations of the animal.  If <code>xy</code>
inherits the class <code>SpatialPointsDataFrame</code>, it should contain
only one column (a factor) corresponding to the identity of the
animals for each relocation.</p>
</td></tr>
<tr><td><code id="mcp_+3A_percent">percent</code></td>
<td>
<p>A single number for the function <code>mcp</code> and a
vector for the function <code>mcp.area</code>:  100 minus the proportion
of outliers to be excluded from the computation.</p>
</td></tr>
<tr><td><code id="mcp_+3A_unin">unin</code></td>
<td>
<p>the units of the relocations coordinates.  Either
<code>"m"</code> (default) for meters or <code>"km"</code> for kilometers</p>
</td></tr>
<tr><td><code id="mcp_+3A_unout">unout</code></td>
<td>
<p>the units of the output areas.  Either <code>"m2"</code> for
square meters, <code>"km2"</code> for square kilometers or <code>"ha"</code> for
hectares (default)</p>
</td></tr>
<tr><td><code id="mcp_+3A_plotit">plotit</code></td>
<td>
<p>logical.  Whether the plot should be drawn.</p>
</td></tr>
<tr><td><code id="mcp_+3A_x">x</code></td>
<td>
<p>an objet of class <code>hrsize</code> returned by the function
<code>mcp.area</code>, or <code>kernel.area</code> (see <code>kernelUD()</code>)</p>
</td></tr>
<tr><td><code id="mcp_+3A_mcp">mcp</code></td>
<td>
<p>an objet of class <code>SpatialPolygons</code> returned by the
function <code>mcp</code>.</p>
</td></tr>
<tr><td><code id="mcp_+3A_w">w</code></td>
<td>
<p>an objet of class <code>SpatialPixelsDataFrame</code> used as a
reference for the rasterization.</p>
</td></tr>
<tr><td><code id="mcp_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function
<code>plot</code>.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function computes the Minimum Convex Polygon estimation after the
removal of <code>(100 minus percent)</code> percent of the relocations the
farthest away from the centroid of the home range (computed by the
arithmetic mean of the coordinates of the relocations for each
animal).
</p>


<h3>Value</h3>

<p><code>mcp</code> returns an object of class <code>SpatialPolygonsDataFrame</code>,
in which the first column contains the ID of the animals, and the
second contains the home range size.
</p>
<p><code>mcp.area</code> returns a data frame of class <code>hrsize</code>, 
with one column per animal and one row per level of
estimation of the home range.
</p>
<p><code>hr.rast</code> returns an object of class
<code>SpatialPixelsDataFrame</code>.
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>References</h3>

<p>Mohr, C.O. (1947) Table of equivalent populations of north
american small mammals. <em>The American Midland Naturalist</em>,
<b>37</b>, 223-249.</p>


<h3>See Also</h3>

 <p><code><a href="grDevices.html#topic+chull">chull</a></code>,
<code><a href="sp.html#topic+SpatialPolygonsDataFrame-class">SpatialPolygonsDataFrame-class</a></code> for additionnal
information on the class <code>SpatialPolygonsDataFrame</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(puechabonsp)
rel &lt;-  puechabonsp$relocs


## estimates the MCP
cp &lt;- mcp(rel[,1])

## The home-range size
as.data.frame(cp)

## Plot the home ranges
plot(cp)

## ... And the relocations
plot(rel, col=as.data.frame(rel)[,1], add=TRUE)


## Computation of the home-range size:
cuicui1 &lt;- mcp.area(rel[,1])

## Rasterization
ii &lt;- hr.rast(cp, puechabonsp$map)

opar &lt;- par(mfrow=c(2,2))
lapply(1:4, function(i) {image(ii, i); box()})
par(opar)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
