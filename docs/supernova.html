<!DOCTYPE html><html><head><title>Help for package supernova</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {supernova}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova_tbl'><p>ANOVA table with nicer column names.</p></a></li>
<li><a href='#autoplot.pairwise'><p>Plotting method for pairwise objects.</p></a></li>
<li><a href='#cat_line'><p>Paste, Concatenate, add End-Of-Line and Print</p></a></li>
<li><a href='#check_pairwise_args'><p>Check that the arguments are compatible with the rest of the pairwise code.</p></a></li>
<li><a href='#drop_term'><p>Drop a term from the given model</p></a></li>
<li><a href='#equation'><p>Print the output of <code>lm()</code> with the fitted equation.</p></a></li>
<li><a href='#find_categorical_vars'><p>Find the categorical variables in a model</p></a></li>
<li><a href='#formula_string'><p>We have to insert spaces where terms were removed from the part model.</p></a></li>
<li><a href='#frm_build'><p>Build a formula from terms</p></a></li>
<li><a href='#frm_expand'><p>Expand a formula</p></a></li>
<li><a href='#frm_outcome'><p>Extracting from formulae</p></a></li>
<li><a href='#frm_remove_term'><p>Remove a term or variable from the right-hand side of a formula</p></a></li>
<li><a href='#frm_string'><p>Get the string representation of the formula.</p></a></li>
<li><a href='#generate_models'><p>Generate a List of Models for Computing Different Types of Sums of Squares</p></a></li>
<li><a href='#insert_row'><p>Insert a row of data into a table.</p></a></li>
<li><a href='#insert_rule'><p>Insert a horizontal rule in a table for pretty printing</p></a></li>
<li><a href='#level_pairs'><p>Get all pairs for a given vector</p></a></li>
<li><a href='#listwise_delete'><p>Remove cases with missing values.</p></a></li>
<li><a href='#lower_tri'><p>Find and return the lower triangle of a matrix</p></a></li>
<li><a href='#means_and_counts'><p>Get the means and counts for each categorical term in the model</p></a></li>
<li><a href='#new_pairwise_tbl'><p>Constructor for pairwise comparison tables</p></a></li>
<li><a href='#number'><p><code>number</code> vector</p></a></li>
<li><a href='#pad'><p>Pad x to length of y</p></a></li>
<li><a href='#pad_len'><p>Pad x to a given output length</p></a></li>
<li><a href='#pairwise'><p>Compute all pairwise comparisons between category levels</p></a></li>
<li><a href='#paste_line'><p>Paste together lines of text.</p></a></li>
<li><a href='#refit_categorical'><p>Refit a model, dropping any non-categorical terms.</p></a></li>
<li><a href='#rename'><p>Rename a column in a data frame</p></a></li>
<li><a href='#resolve_type'><p>Convert SS type parameter to the corresponding numeric value</p></a></li>
<li><a href='#row_blank'><p>A template for a row in an ANOVA table.</p></a></li>
<li><a href='#row_error'><p>Compute and construct an ANOVA table row for an error term</p></a></li>
<li><a href='#row_term'><p>Compute and construct an ANOVA table row for a term.</p></a></li>
<li><a href='#select_terms'><p>Select terms based on the user's <code>term</code> specification</p></a></li>
<li><a href='#supernova'><p>supernova</p></a></li>
<li><a href='#update_in_env'><p>Update a model in the environment the model was created in</p></a></li>
<li><a href='#variables'><p>Extract the variables from a model formula</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Judd, McClelland, &amp; Ryan Formatting for ANOVA Output</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Produces ANOVA tables in the format used by Judd, McClelland,
    and Ryan (2017, ISBN: 978-1138819832) in their introductory textbook,
    Data Analysis. This includes proportional reduction in error and
    formatting to improve ease the transition between the book and R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/UCLATALL/supernova">https://github.com/UCLATALL/supernova</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/UCLATALL/supernova/issues">https://github.com/UCLATALL/supernova/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, methods, pillar (&ge; 1.5.0), purrr, rlang, stringr,
tibble, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>car, covr, dplyr (&ge; 1.0.0), ggplot2, lintr, lme4, magrittr,
readr, remotes, testthat (&ge; 2.1.0), tidyr, vdiffr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 02:13:20 UTC; adamblake</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Blake <a href="https://orcid.org/0000-0001-7881-8652"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  Jeff Chrabaszcz [aut],
  Ji Son <a href="https://orcid.org/0000-0002-4258-4791"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jim Stigler <a href="https://orcid.org/0000-0001-6107-7827"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Blake &lt;adam@coursekata.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-07 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova_tbl'>ANOVA table with nicer column names.</h2><span id='topic+anova_tbl'></span>

<h3>Description</h3>

<p>ANOVA table with nicer column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anova_tbl(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova_tbl_+3A_model">model</code></td>
<td>
<p>A model fitted by <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ANOVA table with standard column names.
</p>

<hr>
<h2 id='autoplot.pairwise'>Plotting method for pairwise objects.</h2><span id='topic+autoplot.pairwise'></span><span id='topic+plot.pairwise'></span>

<h3>Description</h3>

<p>Plotting method for pairwise objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot.pairwise(object, ...)

## S3 method for class 'pairwise'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.pairwise_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+pairwise">pairwise</a></code> object.</p>
</td></tr>
<tr><td><code id="autoplot.pairwise_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plotting geom.</p>
</td></tr>
<tr><td><code id="autoplot.pairwise_+3A_x">x</code></td>
<td>
<p>A <code>pairwise</code> object.</p>
</td></tr>
<tr><td><code id="autoplot.pairwise_+3A_y">y</code></td>
<td>
<p>Ignored, required for compatibility with the <code>plot()</code> generic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires an optional dependency: <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2</a></code>.
When this package is installed, calling <code>autoplot()</code> or <code>plot</code> on a <code>pairwise</code> object will
generate a plot of the pairwise comparisons. The plot will show the differences between the
groups, with error bars representing the confidence intervals. The x-axis will be labeled with
the type of confidence interval used and the values of the differences, and the y-axis will be
labeled with the groups being compared. A dashed line at 0 is included to help visualize the
differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(ggplot2)) {
  # generate the plot immediately
  pairwise(lm(mpg ~ factor(am) + disp, data = mtcars), plot = TRUE)

  # or save the object and plot it later
  p &lt;- pairwise(lm(mpg ~ factor(am) + disp, data = mtcars))
  plot(p)
}
</code></pre>

<hr>
<h2 id='cat_line'>Paste, Concatenate, add End-Of-Line and Print</h2><span id='topic+cat_line'></span>

<h3>Description</h3>

<p>Paste, Concatenate, add End-Of-Line and Print
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_line(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat_line_+3A_...">...</code></td>
<td>
<p>Character vectors to paste together.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (invisible <code>NULL</code>).
</p>

<hr>
<h2 id='check_pairwise_args'>Check that the arguments are compatible with the rest of the pairwise code.</h2><span id='topic+check_pairwise_args'></span><span id='topic+check_aov_compat'></span><span id='topic+check_not_empty'></span>

<h3>Description</h3>

<p>Check that the arguments are compatible with the rest of the pairwise code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pairwise_args(fit, alpha)

check_aov_compat(fit)

check_not_empty(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pairwise_args_+3A_fit">fit</code></td>
<td>
<p>A model fit by <code><a href="stats.html#topic+lm">lm()</a></code> or <code><a href="stats.html#topic+aov">aov()</a></code> (or similar).</p>
</td></tr>
<tr><td><code id="check_pairwise_args_+3A_alpha">alpha</code></td>
<td>
<p>A single double value indicating the alpha to use for the tests.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>check_aov_compat()</code>: Ensure the model can be converted by <code><a href="stats.html#topic+aov">aov()</a></code>
</p>
</li>
<li> <p><code>check_not_empty()</code>: Check that the model is not the empty model
</p>
</li></ul>

<hr>
<h2 id='drop_term'>Drop a term from the given model</h2><span id='topic+drop_term'></span>

<h3>Description</h3>

<p>This function is needed to re-fit the models for Type III SS. If you have a model with an
interactive term (e.g. <code>y ~ a + b + a:b</code>), when you try to refit without one of the lower-order
terms (e.g. <code>y ~ a +    a:b</code>) <code><a href="stats.html#topic+lm">lm()</a></code> will add it back in. This function uses a fitting function
that operates underneath <code>lm()</code> to circumvent this behavior. (It is very similar to <code><a href="stats.html#topic+drop1">drop1()</a></code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_term(fit, term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_term_+3A_fit">fit</code></td>
<td>
<p>The model to update.</p>
</td></tr>
<tr><td><code id="drop_term_+3A_term">term</code></td>
<td>
<p>The term to drop from the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>lm</code>.
</p>

<hr>
<h2 id='equation'>Print the output of <code>lm()</code> with the fitted equation.</h2><span id='topic+equation'></span>

<h3>Description</h3>

<p>Print the output of <code>lm()</code> with the fitted equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equation(x, digits = max(3L, getOption("digits") - 3L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equation_+3A_x">x</code></td>
<td>
<p>The fitted linear model to print.</p>
</td></tr>
<tr><td><code id="equation_+3A_digits">digits</code></td>
<td>
<p>The minimal number of significant digits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly return the fitted linear model.
</p>

<hr>
<h2 id='find_categorical_vars'>Find the categorical variables in a model</h2><span id='topic+find_categorical_vars'></span>

<h3>Description</h3>

<p>Find the categorical variables in a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_categorical_vars(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_categorical_vars_+3A_fit">fit</code></td>
<td>
<p>A model fit by <code><a href="stats.html#topic+lm">lm()</a></code> or <code><a href="stats.html#topic+aov">aov()</a></code> (or similar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the categorical variables in the model. Note these are not terms,
they are variables, e.g. interactions are not included here, only the variables they are
comprised of.
</p>

<hr>
<h2 id='formula_string'>We have to insert spaces where terms were removed from the part model.</h2><span id='topic+formula_string'></span>

<h3>Description</h3>

<p>We have to insert spaces where terms were removed from the part model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_string(obj, part, term)
</code></pre>

<hr>
<h2 id='frm_build'>Build a formula from terms</h2><span id='topic+frm_build'></span>

<h3>Description</h3>

<p>Build a formula from terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frm_build(lhs, rhs, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frm_build_+3A_lhs">lhs</code></td>
<td>
<p>The outcome term for the left-hand side.</p>
</td></tr>
<tr><td><code id="frm_build_+3A_rhs">rhs</code></td>
<td>
<p>The terms for the right-hand side.</p>
</td></tr>
<tr><td><code id="frm_build_+3A_env">env</code></td>
<td>
<p>The environment to assign to the formula (defaults to calling environment).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The right-hand side terms are joined with <code>+</code>. Then, the right-hand side is joined
to the left and returned as a <a href="stats.html#topic+formula">formula</a>.
</p>


<h3>See Also</h3>

<p>formula_extraction formula_expansion
</p>

<hr>
<h2 id='frm_expand'>Expand a formula</h2><span id='topic+frm_expand'></span>

<h3>Description</h3>

<p>Expand a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frm_expand(frm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frm_expand_+3A_frm">frm</code></td>
<td>
<p>A formula that may have compact terms like <code>a * b</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expanded formula where terms like <code>a * b</code> are expanded to <code>a + b + a:b</code>.
</p>


<h3>See Also</h3>

<p>formula_building formula_extraction
</p>

<hr>
<h2 id='frm_outcome'>Extracting from formulae</h2><span id='topic+frm_outcome'></span><span id='topic+frm_terms'></span><span id='topic+frm_interaction_terms'></span><span id='topic+frm_fixed_terms'></span><span id='topic+frm_random_terms'></span><span id='topic+frm_vars'></span><span id='topic+frm_random_vars'></span><span id='topic+frm_fixed_vars'></span>

<h3>Description</h3>

<p>These tools extracting parts from formulae. The only function that extracts from the left-hand
side is <code>frm_outcome</code>. The rest only extract from the right-hand side. The word <code>term</code> is used to
denote functions that extract full terms from the formula, whereas <code>var</code> denotes functions that
extract the variables the formula uses. For example, the formula <code>y ~ a * b + (1 | group)</code> has
terms <code>a</code>, <code>b</code>, <code>a:b</code>, and <code>1 | group</code>. The same formula has variables <code>a</code>, <code>b</code>, and <code>group</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frm_outcome(frm)

frm_terms(frm)

frm_interaction_terms(frm)

frm_fixed_terms(frm)

frm_random_terms(frm)

frm_vars(frm)

frm_random_vars(frm)

frm_fixed_vars(frm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frm_outcome_+3A_frm">frm</code></td>
<td>
<p>The formula to extract values from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These tools are ONLY tested against models and formulae that are explicitly supported. See the
README and test cases for more information.
</p>


<h3>Value</h3>

<p>The function name and parameters should be descriptive enough (see Description above).
The extracted parts are always strings.
</p>


<h3>See Also</h3>

<p>formula_building formula_expansion
</p>

<hr>
<h2 id='frm_remove_term'>Remove a term or variable from the right-hand side of a formula</h2><span id='topic+frm_remove_term'></span><span id='topic+frm_remove_var'></span>

<h3>Description</h3>

<p>Remove a term or variable from the right-hand side of a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frm_remove_term(frm, term)

frm_remove_var(frm, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frm_remove_term_+3A_frm">frm</code></td>
<td>
<p>The formula to modify.</p>
</td></tr>
<tr><td><code id="frm_remove_term_+3A_term">term</code>, <code id="frm_remove_term_+3A_var">var</code></td>
<td>
<p>The term or variable to drop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The formula with the term removed.
</p>


<h3>See Also</h3>

<p>formula_building formula_expansion formula_extraction
</p>

<hr>
<h2 id='frm_string'>Get the string representation of the formula.</h2><span id='topic+frm_string'></span>

<h3>Description</h3>

<p>Get the string representation of the formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frm_string(frm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frm_string_+3A_frm">frm</code></td>
<td>
<p>The formula (or something that can be coerced to a formula).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of the formula.
</p>

<hr>
<h2 id='generate_models'>Generate a List of Models for Computing Different Types of Sums of Squares</h2><span id='topic+generate_models'></span><span id='topic+generate_models.formula'></span><span id='topic+generate_models.lm'></span>

<h3>Description</h3>

<p>This function will return a list of lists where the top-level keys (names) of the items indicate
the component of the full model (i.e. the term) that the generated models can be used to test. At
each of these keys is a list with both the <code>complex</code> and <code style="white-space: pre;">&#8288;simple models&#8288;</code> that can be compared to
test the component. The <code>complex</code> models always include the target term, and the <code>simple</code> models
are identical to the <code>complex</code> except the target term is removed. Thus, when the models are
compared (e.g. using <code><a href="stats.html#topic+anova">anova</a></code>, except for Type III; see details below), the resulting values
will show the effect of adding the target term to the model. There are three generally used
approaches to determining what the appropriate comparison models should be, called Type I, II,
and III. See the sections below for more information on these types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_models(model, type = 3)

## S3 method for class 'formula'
generate_models(model, type = 3)

## S3 method for class 'lm'
generate_models(model, type = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_models_+3A_model">model</code></td>
<td>
<p>The model to generate the models from, of the type <code><a href="stats.html#topic+lm">lm()</a></code>, <code><a href="stats.html#topic+aov">aov()</a></code>, or
<code><a href="stats.html#topic+formula">formula()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_models_+3A_type">type</code></td>
<td>
<p>The type of sums of squares to calculate: - Use <code>1</code>, <code>I</code>, and <code>sequential</code> for Type
I. - Use <code>2</code>, <code>II</code>, and <code>hierarchical</code> for Type II. - Use <code>3</code>, <code>III</code>, and <code>orthogonal</code> for Type
III.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the augmented models for each term, where the associated term is the key for
each model in the list.
</p>


<h3>Type I</h3>

<p>For Type I SS, or sequential SS, each term is considered in order after the preceding terms are
considered. Consider the example model
</p>
<p><code>Y ~ A + B + A:B</code>
</p>
<p>, where &quot;:&quot; indicates an interaction. To determine the Type I effect of <code>A</code>, we would compare the
model <code>Y ~ A</code> to the same model without the term: <code>Y ~ NULL</code>. For <code>B</code>, we compare <code>Y ~ A + B</code> to
<code>Y ~ A</code>; and for <code>A:B</code>, we compare <code>Y ~ A + B + A:B</code> to <code>Y ~ A + B</code>. Incidentally, the <code><a href="stats.html#topic+anova">anova()</a></code>
function that ships with the base installation of R computes Type I statistics.
</p>


<h3>Type II</h3>

<p>For Type II SS, or hierarchical SS, each term is considered in the presence of all of the terms
that do not include it. For example, consider an example three-way factorial model
</p>
<p><code>Y ~ A + B + C + A:B + A:C + B:C + A:B:C</code>
</p>
<p>, where &quot;:&quot; indicates an interaction. The effect of <code>A</code> is found by comparing <code>Y ~ B + C + B:C + A</code> to <code>Y ~ B + C + B:C</code> (the only terms included are those that do not include <code>A</code>). For <code>B</code>, the
comparison models would be <code>Y ~ A + C + A:C + B</code> and <code>Y ~ A + C + A:C</code>; for <code>A:B</code>, the models
would be <code>Y ~ A + B + C + A:C + B:C + A:B</code> and <code>Y ~ A + B + C + A:C + B:C</code>; and so on.
</p>


<h3>Type III</h3>

<p>For Type III SS, or orthogonal SS, each term is considered in the presence of all of the other
terms. For example, consider an example two-way factorial model
</p>
<p><code>Y ~ A + B + A:B</code>
</p>
<p>, where <code>:</code> indicates an interaction between the terms. The effect of <code>A</code>, is found by comparing
<code>Y ~ B + A:B + A</code> to <code>Y ~ B + A:B</code>; for <code>B</code>, the comparison models would be <code>Y ~ A + A:B + B</code> and
<code>Y ~ A + A:B</code>; and for <code>A:B</code>, the models would be <code>Y ~ A + B + A:B</code> and <code>Y ~ A + B</code>.
</p>
<p>Unfortunately, <code><a href="stats.html#topic+anova">anova()</a></code> cannot be used to compare Type III models. <code>anova()</code> does not allow for
violation of the principle of marginality, which is the rule that interactions should only be
tested in the context of their lower order terms. When an interaction term is present in a model,
<code>anova()</code> will automatically add in the lower-order terms, making a model like <code>Y ~ A + A:B</code>
unable to be compared: it will add the lower-order term <code>B</code>,and thus use the model <code>Y ~ A + B + A:B</code> instead. To get the appropriate statistics for Type III comparisons, use <code><a href="stats.html#topic+drop1">drop1()</a></code> with the
full scope, i.e. <code>drop1(model_fit, scope = . ~ .)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create all type 2 comparison models
models &lt;- generate_models(
  lm(mpg ~ hp * factor(am), data = mtcars),
  type = 2
)

# compute the SS for the hp term
anova_hp &lt;- anova(models$hp$simple, models$hp$complex)
anova_hp[["Sum of Sq"]][[2]]
</code></pre>

<hr>
<h2 id='insert_row'>Insert a row of data into a table.</h2><span id='topic+insert_row'></span>

<h3>Description</h3>

<p>Insert a row of data into a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_row(df, insert_at, contents)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_row_+3A_df">df</code></td>
<td>
<p>The original data.frame.</p>
</td></tr>
<tr><td><code id="insert_row_+3A_insert_at">insert_at</code></td>
<td>
<p>The row in which to insert the data.</p>
</td></tr>
<tr><td><code id="insert_row_+3A_contents">contents</code></td>
<td>
<p>The row of contents to insert (should be a vector of length
<code>ncol(df)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data.frame with the row of data inserted.
</p>

<hr>
<h2 id='insert_rule'>Insert a horizontal rule in a table for pretty printing</h2><span id='topic+insert_rule'></span>

<h3>Description</h3>

<p>Insert a horizontal rule in a table for pretty printing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_rule(df, insert_at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_rule_+3A_df">df</code></td>
<td>
<p>The original data.frame</p>
</td></tr>
<tr><td><code id="insert_rule_+3A_insert_at">insert_at</code></td>
<td>
<p>The row in which to insert the dashes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data.frame with the horizontal rule inserted.
</p>

<hr>
<h2 id='level_pairs'>Get all pairs for a given vector</h2><span id='topic+level_pairs'></span>

<h3>Description</h3>

<p>The output of this function should match the pairs you get when you run <code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>level_pairs(levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="level_pairs_+3A_levels">levels</code></td>
<td>
<p>The vector to get pairs for. It is called levels because it was written for the
purpose of comparing levels of a factor to one another with multiple comparisons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with two columns, group 1 and group 2, where each row is a unique pair.
</p>

<hr>
<h2 id='listwise_delete'>Remove cases with missing values.</h2><span id='topic+listwise_delete'></span><span id='topic+listwise_delete.data.frame'></span><span id='topic+listwise_delete.lm'></span>

<h3>Description</h3>

<p>Remove cases with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listwise_delete(obj, vars)

## S3 method for class 'data.frame'
listwise_delete(obj, vars = names(obj))

## S3 method for class 'lm'
listwise_delete(obj, vars = all.vars(formula(obj)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listwise_delete_+3A_obj">obj</code></td>
<td>
<p>The <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="stats.html#topic+lm">lm</a></code> object to process.</p>
</td></tr>
<tr><td><code id="listwise_delete_+3A_vars">vars</code></td>
<td>
<p>The variables to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>data.frame</code>s, the <code>vars</code> are checked for missing values. If one is found on any of
the variables, the entire row is removed (list-wise deletion). For linear models, the model is
refit after the underlying data have been processed.
</p>

<hr>
<h2 id='lower_tri'>Find and return the lower triangle of a matrix</h2><span id='topic+lower_tri'></span>

<h3>Description</h3>

<p>Same as <code><a href="base.html#topic+lower.tri">lower.tri()</a></code> except it returns the values from the matrix (rather than a positional
matrix that lets you look up the values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower_tri(x, diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lower_tri_+3A_x">x</code></td>
<td>
<p>a matrix or other <span class="rlang"><b>R</b></span> object with <code>length(dim(x)) == 2</code>.
For back compatibility reasons, when the above is not fulfilled,
<code><a href="base.html#topic+as.matrix">as.matrix</a>(x)</code> is called first.</p>
</td></tr>
<tr><td><code id="lower_tri_+3A_diag">diag</code></td>
<td>
<p>logical.  Should the diagonal be included?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The values in the lower triangular part of the matrix.
</p>

<hr>
<h2 id='means_and_counts'>Get the means and counts for each categorical term in the model</h2><span id='topic+means_and_counts'></span>

<h3>Description</h3>

<p>Get the means and counts for each categorical term in the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>means_and_counts(fit, term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="means_and_counts_+3A_fit">fit</code></td>
<td>
<p>A model fit by <code><a href="stats.html#topic+lm">lm()</a></code> or <code><a href="stats.html#topic+aov">aov()</a></code> (or similar).</p>
</td></tr>
<tr><td><code id="means_and_counts_+3A_term">term</code></td>
<td>
<p>If <code>NULL</code>, use each categorical term in the model. Otherwise, only use the given
term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the means and counts for each level of each term.
</p>

<hr>
<h2 id='new_pairwise_tbl'>Constructor for pairwise comparison tables</h2><span id='topic+new_pairwise_tbl'></span>

<h3>Description</h3>

<p>Constructor for pairwise comparison tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_pairwise_tbl(tbl, term, fit, fwer, alpha, correction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_pairwise_tbl_+3A_tbl">tbl</code></td>
<td>
<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code>-like object.</p>
</td></tr>
<tr><td><code id="new_pairwise_tbl_+3A_term">term</code></td>
<td>
<p>The term the table describes.</p>
</td></tr>
<tr><td><code id="new_pairwise_tbl_+3A_fit">fit</code></td>
<td>
<p>The linear model the term comes from.</p>
</td></tr>
<tr><td><code id="new_pairwise_tbl_+3A_fwer">fwer</code></td>
<td>
<p>The family-wise error-rate for the group of tests in the table.</p>
</td></tr>
<tr><td><code id="new_pairwise_tbl_+3A_alpha">alpha</code></td>
<td>
<p>The alpha to use when computing the family-wise error-rate.</p>
</td></tr>
<tr><td><code id="new_pairwise_tbl_+3A_correction">correction</code></td>
<td>
<p>The type of alpha correction the tests in the table use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> sub-classed as <code>pairwise_comparison_tbl</code>. These have custom printers and
retain their attributes when subsetted.
</p>

<hr>
<h2 id='number'><code>number</code> vector</h2><span id='topic+number'></span><span id='topic+is_number'></span><span id='topic+as_number'></span>

<h3>Description</h3>

<p>This creates a formatted double vector. You can specify the number of digits you want the value
to display after the decimal, and the underlying value will not change. Additionally you can
explicitly set whether scientific notation should be used and if numbers less than 0 should
contain a leading 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number(x = numeric(), digits = 3L, scientific = FALSE, leading_zero = TRUE)

is_number(x)

as_number(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_+3A_x">x</code></td>
<td>

<ul>
<li><p> For <code>number()</code>: A numeric vector
</p>

<ul>
<li><p> For <code>is_number()</code>: An object to test
</p>
</li>
<li><p> For <code>as_number()</code>: An object to coerce to a <code>number</code>
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="number_+3A_digits">digits</code></td>
<td>
<p>The number of digits to display after the decimal point.</p>
</td></tr>
<tr><td><code id="number_+3A_scientific">scientific</code></td>
<td>
<p>Whether the number should be represented with scientific notation (e.g. 1e2)</p>
</td></tr>
<tr><td><code id="number_+3A_leading_zero">leading_zero</code></td>
<td>
<p>Whether a leading zero should be used on numbers less than 0 (e.g. .001)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 vector of class <code>supernova_number</code>. It should behave like a double, but be
formatted consistently.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>number(1:5, digits = 3)
</code></pre>

<hr>
<h2 id='pad'>Pad x to length of y</h2><span id='topic+pad'></span>

<h3>Description</h3>

<p>Pad x to length of y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(x, y, after = length(x), pad = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_+3A_x">x</code></td>
<td>
<p>The vector to pad.</p>
</td></tr>
<tr><td><code id="pad_+3A_y">y</code></td>
<td>
<p>The vector with target length.</p>
</td></tr>
<tr><td><code id="pad_+3A_after">after</code></td>
<td>
<p>A subscript, after which the padding is to be appended.</p>
</td></tr>
<tr><td><code id="pad_+3A_pad">pad</code></td>
<td>
<p>The value to pad the vector with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The padded vector.
</p>

<hr>
<h2 id='pad_len'>Pad x to a given output length</h2><span id='topic+pad_len'></span>

<h3>Description</h3>

<p>Pad x to a given output length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_len(x, output_length, after = length(x), pad = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_len_+3A_x">x</code></td>
<td>
<p>The vector to pad.</p>
</td></tr>
<tr><td><code id="pad_len_+3A_output_length">output_length</code></td>
<td>
<p>The length to pad the vector to.</p>
</td></tr>
<tr><td><code id="pad_len_+3A_after">after</code></td>
<td>
<p>A subscript, after which the padding is to be appended.</p>
</td></tr>
<tr><td><code id="pad_len_+3A_pad">pad</code></td>
<td>
<p>The value to pad the vector with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The padded vector.
</p>

<hr>
<h2 id='pairwise'>Compute all pairwise comparisons between category levels</h2><span id='topic+pairwise'></span><span id='topic+pairwise_t'></span><span id='topic+pairwise_bonferroni'></span><span id='topic+pairwise_tukey'></span>

<h3>Description</h3>

<p>This function is useful for generating and testing all pairwise comparisons of categorical terms
in a linear model. This can be done in base R using functions like <code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code> and
<code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a></code>, but these functions are inconsistent both in their output format and their general
approach to pairwise comparisons. <code>pairwise()</code> will return a consistent table format, and will
make consistent decisions about how to calculate error terms and confidence intervals. See the
<strong>Details</strong> section low for more on how the models are tested (and why your output might not
match other functions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise(
  fit,
  correction = "Tukey",
  term = NULL,
  alpha = 0.05,
  var_equal = TRUE,
  plot = FALSE
)

pairwise_t(fit, term = NULL, alpha = 0.05, correction = "none")

pairwise_bonferroni(fit, term = NULL, alpha = 0.05)

pairwise_tukey(fit, term = NULL, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_+3A_fit">fit</code></td>
<td>
<p>A model fit by <code><a href="stats.html#topic+lm">lm()</a></code> or <code><a href="stats.html#topic+aov">aov()</a></code> (or similar).</p>
</td></tr>
<tr><td><code id="pairwise_+3A_correction">correction</code></td>
<td>
<p>The type of correction (if any) to perform to maintain the family-wise
error-rate specified by <code>alpha</code>:
- <strong>Tukey</strong>: computes Tukey's Honestly Significant Differences (see <code><a href="stats.html#topic+TukeyHSD">TukeyHSD()</a></code>)
- <strong>Bonferroni</strong>: computes pairwise <em>t</em>-tests and then apply a Bonferroni correction
- <strong>none</strong>: computes pairwise <em>t</em>-tests and reports the uncorrected statistics</p>
</td></tr>
<tr><td><code id="pairwise_+3A_term">term</code></td>
<td>
<p>If <code>NULL</code>, use each categorical term in the model. Otherwise, only use the given
term.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_alpha">alpha</code></td>
<td>
<p>The family-wise error-rate to restrict the tests to. If &quot;none&quot; is given for
<code>correction</code>, this value is the value for each test (and is used to calculate the family-wise
error-rate for the group of tests).</p>
</td></tr>
<tr><td><code id="pairwise_+3A_var_equal">var_equal</code></td>
<td>
<p>If <code>TRUE</code> (default), treat the variances between each group as being equal,
otherwise the Welch or Satterthwaite method is used to appropriately weight the variances.
<strong>Note:</strong>, currently only <code>TRUE</code> is supported. Alternative methods forthcoming.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_plot">plot</code></td>
<td>
<p>Setting plot to TRUE will automatically call <code><a href="base.html#topic+plot">plot</a></code> on the returned object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simple one-way models where a single categorical variable predicts and outcome, you will get
output similar to other methods of computing pairwise comparisons. Essentially, the differences
on the outcome between each of the groups defined by the categorical variable are compared with
the requested test, and their confidence intervals and p-values are adjusted by the requested
<code>correction</code>.
</p>
<p>However, when more than two variables are entered into the model, the outcome will diverge
somewhat from other methods of computing pairwise comparisons. For traditional pairwise tests you
need to estimate an error term, usually by pooling the standard deviation of the groups being
compared. This means that when you have other predictors in the model, their presence is ignored
when running these tests. For the functions in this package, we instead compute the pooled
standard error by using the mean squared error (MSE) from the full model fit.
</p>
<p>Let's take a concrete example to explain that. If we are predicting a car's miles-per-gallon
(<code>mpg</code>) based on whether it has an automatic or manual transmission (<code>am</code>), we can create that
linear model and get the pairwise comparisons like this:
</p>
<p><code>pairwise(lm(mpg ~ factor(am), data = mtcars))</code>
</p>
<p>The output of this code will have one table showing the comparison of manual and automatic
transmissions with regard to miles-per-gallon. The pooled standard error is the same as the
square root of the MSE from the full model.
</p>
<p>In these data the <code>am</code> variable did not have any other values than <em>automatic</em> and <em>manual</em>, but
we can imagine situations where the predictor has more than two levels. In these cases, the
pooled SD would be calculated by taking the MSE of the full model (not of each group) and then
weighting it based on the size of the groups in question (divide by <em>n</em>).
</p>
<p>To improve our model, we might add the car's displacement (<code>disp</code>) as a quantitative predictor:
</p>
<p><code>pairwise(lm(mpg ~ factor(am) + disp, data = mtcars))</code>
</p>
<p>Note that the output still only has a table for <code>am</code>. This is because we can't do a pairwise
comparison using <code>disp</code> because there are no groups to compare. Most functions will drop or not
let you use this variable during pairwise comparisons. Instead, <code>pairwise()</code> uses the same
approach as in the 3+ groups situation: we use the MSE for the full model and then weight it by
the size of the groups being compared. Because we are using the MSE for the full model, the
effect of <code>disp</code> is accounted for in the error term even though we are not explicitly comparing
different displacements. <strong>Importantly</strong>, the interpretation of the outcome is different than in
other traditional t-tests. Instead of saying, &quot;there is a difference in miles-per-gallon based
on the type of transmission,&quot; we must add that this difference is found &quot;after accounting for
displacement.&quot;
</p>


<h3>Value</h3>

<p>A list of tables organized by the terms in the model. For each term (categorical terms
only, as splitting on a continuous variable is generally uninformative), the table describes
all of the pairwise-comparisons possible.
</p>

<hr>
<h2 id='paste_line'>Paste together lines of text.</h2><span id='topic+paste_line'></span>

<h3>Description</h3>

<p>The lines are joined together with a newline (<code style="white-space: pre;">&#8288;\n&#8288;</code>) character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_line(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_line_+3A_...">...</code></td>
<td>
<p>Vectors of lines of text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Check out the <a href="base.html#topic+paste">paste</a> function for more information.
</p>

<hr>
<h2 id='refit_categorical'>Refit a model, dropping any non-categorical terms.</h2><span id='topic+refit_categorical'></span>

<h3>Description</h3>

<p>Refit a model, dropping any non-categorical terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit_categorical(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit_categorical_+3A_fit">fit</code></td>
<td>
<p>A model fit by <code><a href="stats.html#topic+lm">lm()</a></code> or <code><a href="stats.html#topic+aov">aov()</a></code> (or similar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A linear model that only has categorical predictors.
</p>

<hr>
<h2 id='rename'>Rename a column in a data frame</h2><span id='topic+rename'></span>

<h3>Description</h3>

<p>Rename a column in a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename(data, col_name, replacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_+3A_data">data</code></td>
<td>
<p>A data frame to modify.</p>
</td></tr>
<tr><td><code id="rename_+3A_col_name">col_name</code></td>
<td>
<p>A character vector of columns to rename.</p>
</td></tr>
<tr><td><code id="rename_+3A_replacement">replacement</code></td>
<td>
<p>A character vector of replacement column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the renamed data frame.
</p>

<hr>
<h2 id='resolve_type'>Convert SS type parameter to the corresponding numeric value</h2><span id='topic+resolve_type'></span>

<h3>Description</h3>

<p>Convert SS type parameter to the corresponding numeric value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_type(type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_type_+3A_type">type</code></td>
<td>
<p>The value to convert, either string or numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric value corresponding to the input.
</p>

<hr>
<h2 id='row_blank'>A template for a row in an ANOVA table.</h2><span id='topic+row_blank'></span>

<h3>Description</h3>

<p>A template for a row in an ANOVA table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_blank(
  term = NA_character_,
  description = NA_character_,
  ss = NA_real_,
  df = NA_integer_,
  ms = ss/df,
  f = NA_real_,
  pre = NA_real_,
  p = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_blank_+3A_term">term</code></td>
<td>
<p>The name of the term the row describes.</p>
</td></tr>
<tr><td><code id="row_blank_+3A_description">description</code></td>
<td>
<p>An optional, short description of the term (pedagogical).</p>
</td></tr>
<tr><td><code id="row_blank_+3A_ss">ss</code></td>
<td>
<p>The sum of squares for the term (defaults to blank)</p>
</td></tr>
<tr><td><code id="row_blank_+3A_df">df</code></td>
<td>
<p>The degrees of freedom the term uses (defaults to blank).</p>
</td></tr>
<tr><td><code id="row_blank_+3A_ms">ms</code></td>
<td>
<p>The mean square for the term (defaults to <code>ss / df</code>)</p>
</td></tr>
<tr><td><code id="row_blank_+3A_f">f</code></td>
<td>
<p>Fisher's F statistic for the term in the model (defaults to blank).</p>
</td></tr>
<tr><td><code id="row_blank_+3A_pre">pre</code></td>
<td>
<p>The proportional reduction of error the term provides (defaults to blank).</p>
</td></tr>
<tr><td><code id="row_blank_+3A_p">p</code></td>
<td>
<p>The p-value of the F (and PRE) for the term in the model (defaults to blank).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble_row">tibble_row</a></code> of length 1 with all of the variables initialized.
</p>

<hr>
<h2 id='row_error'>Compute and construct an ANOVA table row for an error term</h2><span id='topic+row_error'></span>

<h3>Description</h3>

<p>Compute and construct an ANOVA table row for an error term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_error(term, description, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_error_+3A_term">term</code></td>
<td>
<p>The name of the term the row describes (e.g. Error or Total).</p>
</td></tr>
<tr><td><code id="row_error_+3A_description">description</code></td>
<td>
<p>An optional, short description of the term (pedagogical).</p>
</td></tr>
<tr><td><code id="row_error_+3A_fit">fit</code></td>
<td>
<p>The model we are describing error from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble_row">tibble_row</a></code> with the properties initialized. The code has been written to be as
simple and understandable as possible. Please take a look at the source and offer any
suggestions for improvement!
</p>

<hr>
<h2 id='row_term'>Compute and construct an ANOVA table row for a term.</h2><span id='topic+row_term'></span>

<h3>Description</h3>

<p>&quot;Term&quot; is loosely defined here and is probably better understood as &quot;everything in the table that
is not an error row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_term(name, description, models, term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_term_+3A_description">description</code></td>
<td>
<p>An optional, short description of the term (pedagogical).</p>
</td></tr>
<tr><td><code id="row_term_+3A_models">models</code></td>
<td>
<p>The models created by <code><a href="#topic+generate_models">generate_models()</a></code> for comparison.</p>
</td></tr>
<tr><td><code id="row_term_+3A_term">term</code></td>
<td>
<p>The term to compute the row for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble_row">tibble_row</a></code> with the properties initialized. The code has been written to be as
simple and understanding as possible. Please take a look at the source and offer any
suggestions for improvement!
</p>

<hr>
<h2 id='select_terms'>Select terms based on the user's <code>term</code> specification</h2><span id='topic+select_terms'></span>

<h3>Description</h3>

<p>Before returning the selection, ensure that the term we are subsetting on exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_terms(fit, term = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_terms_+3A_fit">fit</code></td>
<td>
<p>A model fit by <code><a href="stats.html#topic+lm">lm()</a></code> or <code><a href="stats.html#topic+aov">aov()</a></code> (or similar).</p>
</td></tr>
<tr><td><code id="select_terms_+3A_term">term</code></td>
<td>
<p>If <code>NULL</code>, use each categorical term in the model. Otherwise, only use the given
term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of terms to run analyses on.
</p>

<hr>
<h2 id='supernova'>supernova</h2><span id='topic+supernova'></span><span id='topic+supernova.lm'></span><span id='topic+supernova.lmerMod'></span>

<h3>Description</h3>

<p>An alternative set of summary statistics for ANOVA. Sums of squares, degrees
of freedom, mean squares, and F value are all computed with Type III sums of
squares, but for fully-between subjects designs you can set the type to I or
II. This function adds to the output table the proportional reduction in
error, an explicit summary of the whole model, separate formatting of p
values, and is intended to match the output used in Judd, McClelland, and
Ryan (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supernova(fit, type = 3, verbose = TRUE)

## S3 method for class 'lm'
supernova(fit, type = 3, verbose = TRUE)

## S3 method for class 'lmerMod'
supernova(fit, type = 3, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supernova_+3A_fit">fit</code></td>
<td>
<p>A model fit by <code><a href="stats.html#topic+lm">lm()</a></code> or <code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code></p>
</td></tr>
<tr><td><code id="supernova_+3A_type">type</code></td>
<td>
<p>The type of sums of squares to calculate (see <code><a href="#topic+generate_models">generate_models()</a></code>). Defaults to the
widely used Type <code>III</code> SS.</p>
</td></tr>
<tr><td><code id="supernova_+3A_verbose">verbose</code></td>
<td>
<p>If <code>FALSE</code>, the <code>description</code> column is suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>supernova</code>, which has a clean print method for displaying the
ANOVA table in the console as well as a named list:
</p>
<table>
<tr><td><code>tbl</code></td>
<td>
<p>The ANOVA table as a <code><a href="base.html#topic+data.frame">data.frame</a></code></p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The original <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="lme4.html#topic+lmer">lmer</a></code>
object being tested</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>Models created by <code><a href="#topic+generate_models">generate_models</a></code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Judd, C. M., McClelland, G. H., &amp; Ryan, C. S. (2017). <em>Data
Analysis: A Model Comparison Approach to Regression, ANOVA, and Beyond</em>
(3rd ed.). New York: Routledge. ISBN:879-1138819832
</p>


<h3>Examples</h3>

<pre><code class='language-R'>supernova(lm(mpg ~ disp, data = mtcars))

change_p_decimals &lt;- supernova(lm(mpg ~ disp, data = mtcars))
print(change_p_decimals, pcut = 8)
</code></pre>

<hr>
<h2 id='update_in_env'>Update a model in the environment the model was created in</h2><span id='topic+update_in_env'></span>

<h3>Description</h3>

<p><code><a href="stats.html#topic+update">stats::update()</a></code> will perform the update in <code><a href="base.html#topic+parent.frame">parent.frame()</a></code> by default, but this can cause
problems when the update is called by another function (so the parent frame is no longer the
environment the user is in).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_in_env(object, formula., ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_in_env_+3A_object">object</code></td>
<td>
<p>An existing fit from a model function such as <code><a href="stats.html#topic+lm">lm()</a></code>, <code><a href="stats.html#topic+glm">glm()</a></code> and many others.</p>
</td></tr>
<tr><td><code id="update_in_env_+3A_formula.">formula.</code></td>
<td>
<p>Changes to the formula &ndash; see <code>update.formula</code> for
details.</p>
</td></tr>
<tr><td><code id="update_in_env_+3A_...">...</code></td>
<td>
<p>Additional arguments to the call, or arguments with
changed values. Use <code>name = NULL</code> to remove the argument <code>name</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated model is returned.
</p>

<hr>
<h2 id='variables'>Extract the variables from a model formula</h2><span id='topic+variables'></span><span id='topic+variables.supernova'></span><span id='topic+variables.formula'></span><span id='topic+variables.lm'></span><span id='topic+variables.lmerMod'></span>

<h3>Description</h3>

<p>Extract the variables from a model formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variables(object)

## S3 method for class 'supernova'
variables(object)

## S3 method for class 'formula'
variables(object)

## S3 method for class 'lm'
variables(object)

## S3 method for class 'lmerMod'
variables(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variables_+3A_object">object</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="#topic+supernova">supernova</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the <code>outcome</code> and <code>predictor</code> variables in the model.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
