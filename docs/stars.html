<!DOCTYPE html><html><head><title>Help for package stars</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stars}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%in%,stars-method'><p>evaluate whether cube values are in a given set</p></a></li>
<li><a href='#aggregate.stars'><p>spatially or temporally aggregate stars object</p></a></li>
<li><a href='#as'><p>Coerce stars object into a Raster raster or brick</p></a></li>
<li><a href='#bcsd_obs'><p>Monthly Gridded Meteorological Observations</p></a></li>
<li><a href='#c.stars'><p>combine multiple stars objects, or combine multiple attributes in a single stars object into a single array</p></a></li>
<li><a href='#contour.stars'><p>plot contours of a stars object</p></a></li>
<li><a href='#cut_stars'><p>cut methods for stars objects</p></a></li>
<li><a href='#dplyr'><p>dplyr verbs for stars objects</p></a></li>
<li><a href='#geom_stars'><p>ggplot geom for stars objects</p></a></li>
<li><a href='#L7_ETMs'><p>Landsat-7 bands for a selected region around Olinda, BR</p></a></li>
<li><a href='#make_intervals'><p>create an intervals object</p></a></li>
<li><a href='#mdim'><p>Read or write data using GDAL's multidimensional array API</p></a></li>
<li><a href='#merge'><p>merge or split stars object</p></a></li>
<li><a href='#ops_stars'><p>S3 Ops Group Generic Functions for stars objects</p></a></li>
<li><a href='#plot'><p>plot stars object, with subplots for each level of first non-spatial dimension</p></a></li>
<li><a href='#predict.stars'><p>Predict values, given a model object, for a stars or stars_proxy object</p></a></li>
<li><a href='#print_stars'><p>print stars or dimensions object</p></a></li>
<li><a href='#read_ncdf'><p>Read NetCDF into stars object</p></a></li>
<li><a href='#read_stars'><p>read raster/array dataset from file or connection</p></a></li>
<li><a href='#redimension'><p>redimension array, or collapse attributes into a new dimension</p></a></li>
<li><a href='#st_apply'><p>st_apply apply a function to one or more array dimensions</p></a></li>
<li><a href='#st_as_sf'><p>Convert stars object into an sf object</p></a></li>
<li><a href='#st_as_stars'><p>convert objects into a stars object</p></a></li>
<li><a href='#st_cells'><p>return the cell index corresponding to the location of a set of points</p></a></li>
<li><a href='#st_contour'><p>Compute or plot contour lines or sets</p></a></li>
<li><a href='#st_coordinates'><p>retrieve coordinates for raster or vector cube cells</p></a></li>
<li><a href='#st_crop'><p>crop a stars object</p></a></li>
<li><a href='#st_dim_to_attr'><p>create an array with dimension values</p></a></li>
<li><a href='#st_dimensions'><p>get dimensions from stars object</p></a></li>
<li><a href='#st_downsample'><p>downsample stars or stars_proxy objects</p></a></li>
<li><a href='#st_extract'><p>Extract cell values at point locations</p></a></li>
<li><a href='#st_intersects.stars'><p>spatial intersect predicate for stars and sfc object</p></a></li>
<li><a href='#st_join.stars'><p>Spatially join a stars and an 'sf' object</p></a></li>
<li><a href='#st_mosaic'><p>build mosaic (composite) of several spatially disjoint stars objects</p></a></li>
<li><a href='#st_raster_type'><p>get the raster type (if any) of a stars object</p></a></li>
<li><a href='#st_rasterize'><p>rasterize simple feature geometries</p></a></li>
<li><a href='#st_res'><p>obtain (spatial) resolution of a stars object</p></a></li>
<li><a href='#st_rgb'><p>reduce dimension to rgb (alpha) hex values</p></a></li>
<li><a href='#st_set_bbox'><p>set bounding box parameters of regular grid</p></a></li>
<li><a href='#st_sfc2xy'><p>replace POINT simple feature geometry list with an x y raster</p></a></li>
<li><a href='#st_tile'><p>Specify parameters to load raster in blocks</p></a></li>
<li><a href='#st_transform'><p>transform geometries in stars objects to a new coordinate reference system, without warping</p></a></li>
<li><a href='#st_warp'><p>Warp (resample) grids in stars objects to a new grid, possibly in an new coordinate reference system</p></a></li>
<li><a href='#st_xy2sfc'><p>replace x y raster dimensions with simple feature geometry list (points, or polygons = rasterize)</p></a></li>
<li><a href='#stars_sentinel2'><p>Sentinel-2 sample tile</p></a></li>
<li><a href='#stars_subset'><p>subset stars objects</p></a></li>
<li><a href='#write_stars'><p>write stars object to gdal dataset (typically: to file)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatiotemporal Arrays, Raster and Vector Data Cubes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-4</td>
</tr>
<tr>
<td>Description:</td>
<td>Reading, manipulating, writing and plotting
    spatiotemporal arrays (raster and vector data cubes) in 'R', using 'GDAL'
    bindings provided by 'sf', and 'NetCDF' bindings by 'ncmeta' and 'RNetCDF'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/LICENSE-1.1">Apache License version 1.1</a> | <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License version 2.0</a> [expanded from: Apache License]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-spatial.github.io/stars/">https://r-spatial.github.io/stars/</a>,
<a href="https://github.com/r-spatial/stars/">https://github.com/r-spatial/stars/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatial/stars/issues/">https://github.com/r-spatial/stars/issues/</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://cran.uni-muenster.de/pebesma/">https://cran.uni-muenster.de/pebesma/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), abind, sf (&ge; 1.0-10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, classInt (&ge; 0.4-1), rlang, units</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Cairo, OpenStreetMap, PCICt, RNetCDF (&ge; 1.8-2), clue, covr,
cubble (&ge; 0.3.0), cubelyr, digest, dplyr (&ge; 0.7-0),
exactextractr, FNN, future.apply, ggforce, ggplot2, ggthemes,
gstat, httr, jsonlite, knitr, lwgeom, maps, mapdata, ncdfgeom,
ncmeta (&ge; 0.0.3), pbapply, plm, randomForest, raster,
rmarkdown, sp, spacetime, spatstat (&ge; 2.0-1), spatstat.geom,
starsdata, terra (&ge; 1.4-22), testthat, tibble, tidyr, tsibble,
viridis, xts, zoo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'init.R' 'stars.R' 'read.R' 'sf.R' 'dimensions.R' 'values.R'
'plot.R' 'tidyverse.R' 'transform.R' 'ops.R' 'write.R'
'raster.R' 'sp.R' 'spacetime.R' 'ncdf.R' 'ncproxy.R' 'proxy.R'
'factors.R' 'rasterize.R' 'subset.R' 'warp.R' 'aggregate.R'
'xts.R' 'intervals.R' 'geom.R' 'mosaic.R' 'spatstat.R'
'OpenStreetMap.R' 'sample.R' 'extract.R' 'datasets.R' 'tile.R'
'mdim.R' 'cubble.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-10 20:29:30 UTC; edzer</td>
</tr>
<tr>
<td>Author:</td>
<td>Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Michael Sumner <a href="https://orcid.org/0000-0002-2471-7511"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Etienne Racine [ctb],
  Adriano Fantini [ctb],
  David Blodgett [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edzer Pebesma &lt;edzer.pebesma@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-11 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25in+25+2Cstars-method'>evaluate whether cube values are in a given set</h2><span id='topic++25in+25+2Cstars-method'></span>

<h3>Description</h3>

<p>evaluate whether cube values are in a given set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'stars'
x %in% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25in+2B25+2B2Cstars-method_+3A_x">x</code></td>
<td>
<p>data cube value</p>
</td></tr>
<tr><td><code id="+2B25in+2B25+2B2Cstars-method_+3A_table">table</code></td>
<td>
<p>values of the set</p>
</td></tr>
</table>

<hr>
<h2 id='aggregate.stars'>spatially or temporally aggregate stars object</h2><span id='topic+aggregate.stars'></span><span id='topic+aggregate'></span>

<h3>Description</h3>

<p>spatially or temporally aggregate stars object, returning a data cube with lower spatial or temporal resolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
aggregate(
  x,
  by,
  FUN,
  ...,
  drop = FALSE,
  join = st_intersects,
  as_points = any(st_dimension(by) == 2, na.rm = TRUE),
  rightmost.closed = FALSE,
  left.open = FALSE,
  exact = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.stars_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code> with information to be aggregated</p>
</td></tr>
<tr><td><code id="aggregate.stars_+3A_by">by</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code> for spatial aggregation, for temporal aggregation a vector with time values (<code>Date</code>, <code>POSIXct</code>, or <code>PCICt</code>) that is interpreted as a sequence of left-closed, right-open time intervals or a string like &quot;months&quot;, &quot;5 days&quot; or the like (see <a href="base.html#topic+cut.POSIXt">cut.POSIXt</a>), or a function that cuts time into intervals; if by is an object of class <code>stars</code>, it is converted to sfc by <code>st_as_sfc(by, as_points = FALSE)</code> thus ignoring its time component. Note: each pixel is assigned to only a single group (in the order the groups occur) so non-overlapping spatial features and temporal windows are recommended.</p>
</td></tr>
<tr><td><code id="aggregate.stars_+3A_fun">FUN</code></td>
<td>
<p>aggregation function, such as <code>mean</code></p>
</td></tr>
<tr><td><code id="aggregate.stars_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>FUN</code>, such as <code>na.rm=TRUE</code></p>
</td></tr>
<tr><td><code id="aggregate.stars_+3A_drop">drop</code></td>
<td>
<p>logical; ignored</p>
</td></tr>
<tr><td><code id="aggregate.stars_+3A_join">join</code></td>
<td>
<p>function; function used to find matches of <code>x</code> to <code>by</code></p>
</td></tr>
<tr><td><code id="aggregate.stars_+3A_as_points">as_points</code></td>
<td>
<p>see <a href="#topic+st_as_sf">st_as_sf</a>: shall raster pixels be taken as points, or small square polygons?</p>
</td></tr>
<tr><td><code id="aggregate.stars_+3A_rightmost.closed">rightmost.closed</code></td>
<td>
<p>see <a href="base.html#topic+findInterval">findInterval</a></p>
</td></tr>
<tr><td><code id="aggregate.stars_+3A_left.open">left.open</code></td>
<td>
<p>logical; used for time intervals, see <a href="base.html#topic+findInterval">findInterval</a> and <a href="base.html#topic+cut.POSIXt">cut.POSIXt</a></p>
</td></tr>
<tr><td><code id="aggregate.stars_+3A_exact">exact</code></td>
<td>
<p>logical; if <code>TRUE</code>, use <a href="exactextractr.html#topic+coverage_fraction">coverage_fraction</a> to compute exact overlap fractions of polygons with raster cells</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="sf.html#topic+aggregate">aggregate</a>, <a href="sf.html#topic+st_interpolate_aw">st_interpolate_aw</a>, <a href="#topic+st_extract">st_extract</a>, https://github.com/r-spatial/stars/issues/317
</p>


<h3>Examples</h3>

<pre><code class='language-R'># aggregate time dimension in format Date
tif = system.file("tif/L7_ETMs.tif", package = "stars")
t1 = as.Date("2018-07-31")
x = read_stars(c(tif, tif, tif, tif), along = list(time = c(t1, t1+1, t1+2, t1+3)))[,1:30,1:30]
st_get_dimension_values(x, "time")
x_agg_time = aggregate(x, by = t1 + c(0, 2, 4), FUN = max) 

# aggregate time dimension in format Date - interval
by_t = "2 days"
x_agg_time2 = aggregate(x, by = by_t, FUN = max) 
st_get_dimension_values(x_agg_time2, "time")
#TBD:
#x_agg_time - x_agg_time2

# aggregate time dimension in format POSIXct
x = st_set_dimensions(x, 4, values = as.POSIXct(c("2018-07-31", 
                                                  "2018-08-01", 
                                                  "2018-08-02", 
                                                  "2018-08-03")), 
                      names = "time")
by_t = as.POSIXct(c("2018-07-31", "2018-08-02"))
x_agg_posix = aggregate(x, by = by_t, FUN = max)
st_get_dimension_values(x_agg_posix, "time")
#TBD:
# x_agg_time - x_agg_posix
aggregate(x, "2 days", mean)
if (require(ncmeta, quietly = TRUE)) {
 # Spatial aggregation, see https://github.com/r-spatial/stars/issues/299
 prec_file = system.file("nc/test_stageiv_xyt.nc", package = "stars")
 prec = read_ncdf(prec_file, curvilinear = c("lon", "lat"))
 prec_slice = dplyr::slice(prec, index = 17, along = "time")
 nc = sf::read_sf(system.file("gpkg/nc.gpkg", package = "sf"), "nc.gpkg")
 nc = st_transform(nc, st_crs(prec_slice))
 agg = aggregate(prec_slice, st_geometry(nc), mean)
 plot(agg)
}

# example of using a function for "by": aggregate by month-of-year
d = c(10, 10, 150)
a = array(rnorm(prod(d)), d) # pure noise
times = Sys.Date() + seq(1, 2000, length.out = d[3])
m = as.numeric(format(times, "%m"))
signal = rep(sin(m / 12 * pi), each = prod(d[1:2])) # yearly period
s = (st_as_stars(a) + signal) %&gt;%
      st_set_dimensions(3, values = times)
f = function(x, format = "%B") {
	  months = format(as.Date(paste0("01-", 1:12, "-1970")), format)
	  factor(format(x, format), levels = months)
}
agg = aggregate(s, f, mean)
plot(agg)
</code></pre>

<hr>
<h2 id='as'>Coerce stars object into a Raster raster or brick</h2><span id='topic+as'></span><span id='topic+coerce+2Cstars+2CRaster-method'></span><span id='topic+coerce+2Cstars_proxy+2CRaster-method'></span><span id='topic+coerce+2Cstars+2CTerra-method'></span><span id='topic+coerce+2Cstars_proxy+2CTerra-method'></span>

<h3>Description</h3>

<p>Coerce stars object into a Raster raster or brick
</p>
<p>Coerce stars object into a terra SpatRaster
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_+3A_from">from</code></td>
<td>
<p>object to coerce</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the stars object has more than three dimensions, all dimensions higher than the third will be collapsed into the third dimensions. If the stars object has only an x/y raster but multiple attributes, these are merged first, then put in a raster brick.
</p>
<p>If the stars object has more than three dimensions, all dimensions higher than the third will be collapsed into the third dimensions. If the stars object has only an x/y raster but multiple attributes, these are merged first, then put in a SpatRaster.
</p>


<h3>Value</h3>

<p>RasterLayer or RasterBrick
</p>
<p>SpatRaster
</p>

<hr>
<h2 id='bcsd_obs'>Monthly Gridded Meteorological Observations</h2><span id='topic+bcsd_obs'></span>

<h3>Description</h3>

<p>These are the monthly observational data used for BCSD downscaling. See: http://gdo-dcp.ucllnl.org/downscaled_cmip_projections/dcpInterface.html#About for more information.&quot; ;
&quot;Atmospheric Temperature, Air Temperature Atmosphere, Precipitation, Rain, Maximum Daily Temperature, Minimum  Daily Temperature&quot; ;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcsd_obs
</code></pre>


<h3>Format</h3>

<p>An object of class <code>stars_proxy</code> (inherits from <code>stars</code>) of dimension 81 x 33 x 12.
</p>

<hr>
<h2 id='c.stars'>combine multiple stars objects, or combine multiple attributes in a single stars object into a single array</h2><span id='topic+c.stars'></span><span id='topic+c.stars_proxy'></span>

<h3>Description</h3>

<p>combine multiple stars objects, or combine multiple attributes in a single stars object into a single array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
c(
  ...,
  along = NA_integer_,
  try_hard = FALSE,
  nms = names(list(...)),
  tolerance = sqrt(.Machine$double.eps)
)

## S3 method for class 'stars_proxy'
c(
  ...,
  along = NA_integer_,
  along_crs = FALSE,
  try_hard = FALSE,
  nms = names(list(...)),
  tolerance = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.stars_+3A_...">...</code></td>
<td>
<p>object(s) of class <code>star</code>: in case of multiple arguments, these are combined into a single stars object, in case of a single argument, its attributes are combined into a single attribute. In case of multiple objects, all objects should have the same dimensionality.</p>
</td></tr>
<tr><td><code id="c.stars_+3A_along">along</code></td>
<td>
<p>integer; see <a href="#topic+read_stars">read_stars</a></p>
</td></tr>
<tr><td><code id="c.stars_+3A_try_hard">try_hard</code></td>
<td>
<p>logical; if <code>TRUE</code> and some arrays have different dimensions, combine those that dimensions matching to the first array</p>
</td></tr>
<tr><td><code id="c.stars_+3A_nms">nms</code></td>
<td>
<p>character; vector with array names</p>
</td></tr>
<tr><td><code id="c.stars_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric; values used in <a href="Matrix.html#topic+all.equal">all.equal</a> to compare dimension values
combine those that dimensions matching to the first array</p>
</td></tr>
<tr><td><code id="c.stars_+3A_along_crs">along_crs</code></td>
<td>
<p>logical; if <code>TRUE</code>, combine arrays along a CRS dimension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An error is raised when attempting to combine arrays with different
measurement units into a single array. If this was intentded, <code>drop_units</code> 
can be used to remove units of a <code>stars</code> object before merging.
</p>


<h3>Value</h3>

<p>a single <code>stars</code> object with merged (binded) arrays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
(new = c(x, x))
c(new) # collapses two arrays into one with an additional dimension
c(x, x, along = 3)
</code></pre>

<hr>
<h2 id='contour.stars'>plot contours of a stars object</h2><span id='topic+contour.stars'></span>

<h3>Description</h3>

<p>plot contours of a stars object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
contour(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour.stars_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="contour.stars_+3A_...">...</code></td>
<td>
<p>other parameters passed on to <a href="graphics.html#topic+contour">contour</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>this uses the R internal contour algorithm, which (by default) plots contours; <a href="#topic+st_contour">st_contour</a> uses the GDAL contour algorithm that returns contours as simple features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d = st_dimensions(x = 1:ncol(volcano), y = 1:nrow(volcano))
r = st_as_stars(t(volcano))
r = st_set_dimensions(r, 1, offset = 0, delta = 1)
r = st_set_dimensions(r, 2, offset = 0, delta = -1)
plot(r, reset = FALSE)
contour(r, add = TRUE)
</code></pre>

<hr>
<h2 id='cut_stars'>cut methods for stars objects</h2><span id='topic+cut_stars'></span><span id='topic+cut.array'></span><span id='topic+cut.matrix'></span><span id='topic+cut.stars'></span>

<h3>Description</h3>

<p>cut methods for stars objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
cut(x, breaks, ...)

## S3 method for class 'matrix'
cut(x, breaks, ...)

## S3 method for class 'stars'
cut(x, breaks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_stars_+3A_x">x</code></td>
<td>
<p>see <a href="base.html#topic+cut">cut</a></p>
</td></tr>
<tr><td><code id="cut_stars_+3A_breaks">breaks</code></td>
<td>
<p>see <a href="base.html#topic+cut">cut</a></p>
</td></tr>
<tr><td><code id="cut_stars_+3A_...">...</code></td>
<td>
<p>see <a href="base.html#topic+cut">cut</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>R's <code>factor</code> only works for vectors, not for arrays or matrices. This is a work-around (or hack?) to keep the factor levels generated by <code>cut</code> and use them in plots.
</p>


<h3>Value</h3>

<p>an array or matrix with a <code>levels</code> attribute; see details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
cut(x, c(0, 50, 100, 255))
cut(x[,,,1], c(0, 50, 100, 255))
plot(cut(x[,,,1], c(0, 50, 100, 255)))
tif = system.file("tif/L7_ETMs.tif", package = "stars")
x1 = read_stars(tif)
(x1_cut = cut(x1, breaks = c(0, 50, 100, Inf)))  # shows factor in summary
plot(x1_cut[,,,c(3,6)]) # propagates through [ and plot
</code></pre>

<hr>
<h2 id='dplyr'>dplyr verbs for stars objects</h2><span id='topic+dplyr'></span><span id='topic+filter.stars'></span><span id='topic+filter.stars_proxy'></span><span id='topic+mutate.stars'></span><span id='topic+mutate.stars_proxy'></span><span id='topic+transmute.stars'></span><span id='topic+transmute.stars_proxy'></span><span id='topic+select.stars'></span><span id='topic+select.stars_proxy'></span><span id='topic+rename.stars'></span><span id='topic+rename.stars_proxy'></span><span id='topic+pull.stars'></span><span id='topic+pull.stars_proxy'></span><span id='topic+as.tbl_cube.stars'></span><span id='topic+slice.stars'></span><span id='topic+slice.stars_proxy'></span><span id='topic+replace_na.stars'></span><span id='topic+replace_na.stars_proxy'></span>

<h3>Description</h3>

<p>dplyr verbs for stars objects; package dplyr needs to be loaded before these methods can be used for stars objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.stars(.data, ...)

filter.stars_proxy(.data, ...)

mutate.stars(.data, ...)

mutate.stars_proxy(.data, ...)

transmute.stars(.data, ...)

transmute.stars_proxy(.data, ...)

select.stars(.data, ...)

select.stars_proxy(.data, ...)

rename.stars(.data, ...)

rename.stars_proxy(.data, ...)

pull.stars(.data, var = -1)

pull.stars_proxy(.data, ...)

as.tbl_cube.stars(x, ...)

slice.stars(.data, along, index, ..., drop = length(index) == 1)

slice.stars_proxy(.data, along, index, ...)

replace_na.stars(data, replace, ...)

replace_na.stars_proxy(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr_+3A_.data">.data</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="dplyr_+3A_...">...</code></td>
<td>
<p>see <a href="dplyr.html#topic+filter">filter</a></p>
</td></tr>
<tr><td><code id="dplyr_+3A_var">var</code></td>
<td>
<p>see <a href="dplyr.html#topic+pull">pull</a></p>
</td></tr>
<tr><td><code id="dplyr_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="dplyr_+3A_along">along</code></td>
<td>
<p>name or index of dimension to which the slice should be applied</p>
</td></tr>
<tr><td><code id="dplyr_+3A_index">index</code></td>
<td>
<p>integer value(s) for this index</p>
</td></tr>
<tr><td><code id="dplyr_+3A_drop">drop</code></td>
<td>
<p>logical; drop dimensions that only have a single index?</p>
</td></tr>
<tr><td><code id="dplyr_+3A_data">data</code></td>
<td>
<p>data set to work on</p>
</td></tr>
<tr><td><code id="dplyr_+3A_replace">replace</code></td>
<td>
<p>see <a href="tidyr.html#topic+replace_na">replace_na</a>: list with variable=value pairs, where value is the replacement value for NA's</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x1 = read_stars(tif)
if (require(dplyr, quietly = TRUE)) {
 x1 %&gt;% slice("band", 2:3)
 x1 %&gt;% slice("x", 50:100)
}
</code></pre>

<hr>
<h2 id='geom_stars'>ggplot geom for stars objects</h2><span id='topic+geom_stars'></span><span id='topic+theme_stars'></span>

<h3>Description</h3>

<p>ggplot geom for stars objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_stars(
  mapping = NULL,
  data = NULL,
  ...,
  downsample = 0,
  sf = FALSE,
  na.action = na.pass
)

theme_stars(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_stars_+3A_mapping">mapping</code></td>
<td>
<p>see <a href="ggplot2.html#topic+geom_tile">geom_raster</a></p>
</td></tr>
<tr><td><code id="geom_stars_+3A_data">data</code></td>
<td>
<p>see <a href="ggplot2.html#topic+geom_tile">geom_raster</a></p>
</td></tr>
<tr><td><code id="geom_stars_+3A_...">...</code></td>
<td>
<p>see <a href="ggplot2.html#topic+geom_tile">geom_raster</a></p>
</td></tr>
<tr><td><code id="geom_stars_+3A_downsample">downsample</code></td>
<td>
<p>downsampling rate: e.g. 3 keeps rows and cols 1, 4, 7, 10 etc.; a value of 0 does not downsample; can be specified for each dimension, e.g. <code>c(5,5,0)</code> to downsample the first two dimensions but not the third.</p>
</td></tr>
<tr><td><code id="geom_stars_+3A_sf">sf</code></td>
<td>
<p>logical; if <code>TRUE</code> rasters will be converted to polygons and plotted using <a href="ggplot2.html#topic+ggsf">geom_sf</a>.</p>
</td></tr>
<tr><td><code id="geom_stars_+3A_na.action">na.action</code></td>
<td>
<p>function; if <code>NA</code> values need to be removed before plotting use the value <code>na.omit</code> here (only applies to objects with raster dimensions)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geom_stars</code> returns (a call to) either <a href="ggplot2.html#topic+geom_tile">geom_raster</a>, <a href="ggplot2.html#topic+geom_tile">geom_tile</a>, or <a href="ggplot2.html#topic+ggsf">geom_sf</a>, depending on the raster or vector geometry; for the first to, an <a href="ggplot2.html#topic+aes">aes</a> call is constructed with the raster dimension names and the first array as fill variable. Further calls to <a href="ggplot2.html#topic+coord_fixed">coord_equal</a> and <a href="ggplot2.html#topic+facet_wrap">facet_wrap</a> are needed to control aspect ratio and the layers to be plotted; see examples. If a <code>stars</code> array contains hex color values, and no <code>fill</code> parameter is given, the color values are used as fill color; see the example below.
</p>
<p>If visual artefacts occur (Moiré-Effekt), then see the details section of <a href="#topic+plot.stars">plot.stars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("tif/L7_ETMs.tif", package = "stars") %&gt;% read_stars() -&gt; x
if (require(ggplot2, quietly = TRUE)) {
  ggplot() + geom_stars(data = x) +
    coord_equal() +
    facet_wrap(~band) +
    theme_void() +
    scale_x_discrete(expand=c(0,0))+
    scale_y_discrete(expand=c(0,0))
  # plot rgb composite:
  st_as_stars(L7_ETMs)[,,,1:3] |&gt; st_rgb() -&gt; x # x contains colors as pixel values
  ggplot() + geom_stars(data = x)
}
</code></pre>

<hr>
<h2 id='L7_ETMs'>Landsat-7 bands for a selected region around Olinda, BR</h2><span id='topic+L7_ETMs'></span>

<h3>Description</h3>

<p>Probably containing the six 30 m bands:
</p>

<ul>
<li><p> Band 1 Visible (0.45 - 0.52 µm) 30 m
</p>
</li>
<li><p> Band 2 Visible (0.52 - 0.60 µm) 30 m
</p>
</li>
<li><p> Band 3 Visible (0.63 - 0.69 µm) 30 m
</p>
</li>
<li><p> Band 4 Near-Infrared (0.77 - 0.90 µm) 30 m
</p>
</li>
<li><p> Band 5 Short-wave Infrared (1.55 - 1.75 µm) 30 m
</p>
</li>
<li><p> Band 7 Mid-Infrared (2.08 - 2.35 µm) 30 m
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>L7_ETMs
</code></pre>


<h3>Format</h3>

<p>An object of class <code>stars_proxy</code> (inherits from <code>stars</code>) of dimension 349 x 352 x 6.
</p>

<hr>
<h2 id='make_intervals'>create an intervals object</h2><span id='topic+make_intervals'></span>

<h3>Description</h3>

<p>create an intervals object, assuming left-closed and right-open intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_intervals(start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_intervals_+3A_start">start</code></td>
<td>
<p>vector with start values, or 2-column matrix with start and end values in column 1 and 2, respectively</p>
</td></tr>
<tr><td><code id="make_intervals_+3A_end">end</code></td>
<td>
<p>vector with end values</p>
</td></tr>
</table>

<hr>
<h2 id='mdim'>Read or write data using GDAL's multidimensional array API</h2><span id='topic+mdim'></span><span id='topic+read_mdim'></span><span id='topic+write_mdim'></span>

<h3>Description</h3>

<p>Read or write data using GDAL's multidimensional array API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_mdim(
  filename,
  variable = character(0),
  ...,
  options = character(0),
  raster = NULL,
  offset = integer(0),
  count = integer(0),
  step = integer(0),
  proxy = FALSE,
  debug = FALSE,
  bounds = TRUE,
  curvilinear = NA
)

write_mdim(
  x,
  filename,
  driver = detect.driver(filename),
  ...,
  root_group_options = character(0),
  options = character(0),
  as_float = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdim_+3A_filename">filename</code></td>
<td>
<p>name of the source or destination file or data source</p>
</td></tr>
<tr><td><code id="mdim_+3A_variable">variable</code></td>
<td>
<p>name of the array to be read</p>
</td></tr>
<tr><td><code id="mdim_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="mdim_+3A_options">options</code></td>
<td>
<p>character; driver specific options regarding the opening (read_mdim) or creation (write_mdim) of the dataset</p>
</td></tr>
<tr><td><code id="mdim_+3A_raster">raster</code></td>
<td>
<p>names of the raster variables (default: first two dimensions)</p>
</td></tr>
<tr><td><code id="mdim_+3A_offset">offset</code></td>
<td>
<p>integer; offset for each dimension (pixels) of sub-array to read, defaults to 0 for each dimension(requires sf &gt;= 1.0-9)</p>
</td></tr>
<tr><td><code id="mdim_+3A_count">count</code></td>
<td>
<p>integer; size for each dimension (pixels) of sub-array to read (default: read all); a value of NA will read the corresponding dimension entirely; counts are relative to the step size (requires sf &gt;= 1.0-9)</p>
</td></tr>
<tr><td><code id="mdim_+3A_step">step</code></td>
<td>
<p>integer; step size for each dimension (pixels) of sub-aray to read; defaults to 1 for each dimension (requires sf &gt;= 1.0-9)</p>
</td></tr>
<tr><td><code id="mdim_+3A_proxy">proxy</code></td>
<td>
<p>logical; return proxy object? (not functional yet)</p>
</td></tr>
<tr><td><code id="mdim_+3A_debug">debug</code></td>
<td>
<p>logical; print debug info?</p>
</td></tr>
<tr><td><code id="mdim_+3A_bounds">bounds</code></td>
<td>
<p>logical or character: if <code>TRUE</code> tries to infer from &quot;bounds&quot; attribute; if character, 
named vector of the form <code>c(longitude="lon_bnds", latitude="lat_bnds")</code> with names dimension names</p>
</td></tr>
<tr><td><code id="mdim_+3A_curvilinear">curvilinear</code></td>
<td>
<p>control reading curvilinear (geolocation) coordinate arrays; if <code>NA</code> try reading the x/y dimension names; if character, defines the arrays to read; if <code>FALSE</code> do not try; see also <a href="#topic+read_stars">read_stars</a></p>
</td></tr>
<tr><td><code id="mdim_+3A_x">x</code></td>
<td>
<p>stars object</p>
</td></tr>
<tr><td><code id="mdim_+3A_driver">driver</code></td>
<td>
<p>character; driver name</p>
</td></tr>
<tr><td><code id="mdim_+3A_root_group_options">root_group_options</code></td>
<td>
<p>character; driver specific options regarding the creation of the root group</p>
</td></tr>
<tr><td><code id="mdim_+3A_as_float">as_float</code></td>
<td>
<p>logical; if <code>TRUE</code> write 4-byte floating point numbers, if <code>FALSE</code> write 8-byte doubles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>it is assumed that the first two dimensions are easting and northing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(135)
m = matrix(runif(10), 2, 5)
names(dim(m)) = c("stations", "time")
times = as.Date("2022-05-01") + 1:5
pts = st_as_sfc(c("POINT(0 1)", "POINT(3 5)"))
s = st_as_stars(list(Precipitation = m)) |&gt;
 st_set_dimensions(1, values = pts) |&gt;
 st_set_dimensions(2, values = times)
nc = tempfile(fileext=".nc")
if (compareVersion(sf_extSoftVersion()["GDAL"], "3.4.0") &gt; -1) {
  write_mdim(s, nc)
  # try ncdump on the generated file
  print(read_mdim(nc))
}
</code></pre>

<hr>
<h2 id='merge'>merge or split stars object</h2><span id='topic+merge'></span><span id='topic+split.stars'></span><span id='topic+split'></span><span id='topic+merge.stars'></span>

<h3>Description</h3>

<p>merge attributes into a dimension, or split a dimension over attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
split(x, f = length(dim(x)), drop = TRUE, ...)

## S3 method for class 'stars'
merge(x, y, ..., name = "attributes")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="merge_+3A_f">f</code></td>
<td>
<p>the name or index of the dimension to split; by default the last dimension</p>
</td></tr>
<tr><td><code id="merge_+3A_drop">drop</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="merge_+3A_...">...</code></td>
<td>
<p>if defined, the first unnamed argument is used for dimension values, if not defined, attribute names are used for dimension values</p>
</td></tr>
<tr><td><code id="merge_+3A_y">y</code></td>
<td>
<p>needs to be missing</p>
</td></tr>
<tr><td><code id="merge_+3A_name">name</code></td>
<td>
<p>name for the new dimension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>split.stars works on the first attribute, and will give an error when more than one attribute is present
</p>


<h3>Value</h3>

<p>merge merges attributes of a stars object into a new dimension; split splits a dimension over attributes
</p>

<hr>
<h2 id='ops_stars'>S3 Ops Group Generic Functions for stars objects</h2><span id='topic+ops_stars'></span><span id='topic+Ops.stars'></span><span id='topic+Math.stars'></span><span id='topic+Ops.stars_proxy'></span><span id='topic+Math.stars_proxy'></span>

<h3>Description</h3>

<p>Ops functions for stars objects, including comparison, product and divide, add, subtract
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
Ops(e1, e2)

## S3 method for class 'stars'
Math(x, ...)

## S3 method for class 'stars_proxy'
Ops(e1, e2)

## S3 method for class 'stars_proxy'
Math(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ops_stars_+3A_e1">e1</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="ops_stars_+3A_e2">e2</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="ops_stars_+3A_x">x</code></td>
<td>
<p>object of class stars</p>
</td></tr>
<tr><td><code id="ops_stars_+3A_...">...</code></td>
<td>
<p>parameters passed on to the Math functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>e1</code> or <code>e2</code> is is a numeric vector, or <code>e2</code>
has less or smaller dimensions than <code>e1</code>, then <code>e2</code> is recycled
such that it fits <code>e1</code>, using usual R array recycling rules. The user
needs to make sure this is sensible; it may be needed to use <code>aperm</code>
to permutate dimensions first.
</p>


<h3>Value</h3>

<p>object of class <code>stars</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
x * x
x / x
x + x
x + 10
all.equal(x * 10, 10 * x)
tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
a = sqrt(x)
b = log(x, base = 10)
</code></pre>

<hr>
<h2 id='plot'>plot stars object, with subplots for each level of first non-spatial dimension</h2><span id='topic+plot'></span><span id='topic+plot.stars'></span><span id='topic+image.stars'></span><span id='topic+plot.nc_proxy'></span><span id='topic+plot.stars_proxy'></span>

<h3>Description</h3>

<p>plot stars object, with subplots for each level of first non-spatial dimension, and customization of legend key
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
plot(
  x,
  y,
  ...,
  join_zlim = TRUE,
  main = make_label(x, 1),
  axes = FALSE,
  downsample = TRUE,
  nbreaks = 11,
  breaks = "quantile",
  col = grey(1:(nbreaks - 1)/nbreaks),
  key.pos = get_key_pos(x, ...),
  key.width = kw_dflt(x, key.pos),
  key.length = 0.618,
  key.lab = main,
  reset = TRUE,
  box_col = grey(0.8),
  center_time = FALSE,
  hook = NULL,
  mfrow = NULL,
  fill = FALSE
)

## S3 method for class 'stars'
image(
  x,
  ...,
  band = 1,
  attr = 1,
  asp = NULL,
  rgb = NULL,
  maxColorValue = ifelse(inherits(rgb, "data.frame"), 255, max(x[[attr]], na.rm = TRUE)),
  xlab = if (!axes) "" else names(d)[1],
  ylab = if (!axes) "" else names(d)[2],
  xlim = st_bbox(extent)$xlim,
  ylim = st_bbox(extent)$ylim,
  text_values = FALSE,
  text_color = "black",
  axes = FALSE,
  interpolate = FALSE,
  as_points = FALSE,
  key.pos = NULL,
  logz = FALSE,
  key.width = kw_dflt(x, key.pos),
  key.length = 0.618,
  add.geom = NULL,
  border = NA,
  useRaster = isTRUE(dev.capabilities()$rasterImage == "yes"),
  extent = x
)

## S3 method for class 'nc_proxy'
plot(x, y, ..., downsample = get_downsample(dim(x)), max_times = 16)

## S3 method for class 'stars_proxy'
plot(x, y, ..., downsample = get_downsample(dim(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>further arguments: for <code>plot</code>, passed on to <code>image.stars</code>; for <code>image</code>, passed on to <code>image.default</code> or <code>rasterImage</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_join_zlim">join_zlim</code></td>
<td>
<p>logical; if <code>TRUE</code>, compute a single, joint zlim (color scale) for all subplots from <code>x</code></p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>character; subplot title prefix; use <code>""</code> to get only time, use <code>NULL</code> to suppress subplot titles</p>
</td></tr>
<tr><td><code id="plot_+3A_axes">axes</code></td>
<td>
<p>logical; should axes and box be added to the plot?</p>
</td></tr>
<tr><td><code id="plot_+3A_downsample">downsample</code></td>
<td>
<p>logical or numeric; if <code>TRUE</code> will try to plot not many more pixels than actually are visible, if <code>FALSE</code>, no downsampling takes place, if numeric, the number of pixels/lines/bands etc that will be skipped; see Details.</p>
</td></tr>
<tr><td><code id="plot_+3A_nbreaks">nbreaks</code></td>
<td>
<p>number of color breaks; should be one more than number of colors. If missing and <code>col</code> is specified, it is derived from that.</p>
</td></tr>
<tr><td><code id="plot_+3A_breaks">breaks</code></td>
<td>
<p>actual color breaks, or a method name used for <a href="classInt.html#topic+classIntervals">classIntervals</a>.</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>colors to use for grid cells, or color palette function</p>
</td></tr>
<tr><td><code id="plot_+3A_key.pos">key.pos</code></td>
<td>
<p>numeric; side to plot a color key: 1 bottom, 2 left, 3 top, 4 right; set to <code>NULL</code> to omit key. Ignored if multiple columns are plotted in a single function call. Default depends on plot size, map aspect, and, if set, parameter <code>asp</code>. If it has lenght 2, the second value, ranging from 0 to 1, determines where the key is placed in the available space (default: 0.5, center).</p>
</td></tr>
<tr><td><code id="plot_+3A_key.width">key.width</code></td>
<td>
<p>amount of space reserved for width of the key (labels); relative or absolute (using lcm)</p>
</td></tr>
<tr><td><code id="plot_+3A_key.length">key.length</code></td>
<td>
<p>amount of space reserved for length of the key (labels); relative or absolute (using lcm)</p>
</td></tr>
<tr><td><code id="plot_+3A_key.lab">key.lab</code></td>
<td>
<p>character; label for color key in case of multiple subplots, use <code>""</code> to suppress</p>
</td></tr>
<tr><td><code id="plot_+3A_reset">reset</code></td>
<td>
<p>logical; if <code>FALSE</code>, keep the plot in a mode that allows adding further map elements; if <code>TRUE</code> restore original mode after plotting</p>
</td></tr>
<tr><td><code id="plot_+3A_box_col">box_col</code></td>
<td>
<p>color for box around sub-plots; use <code>0</code> to suppress plotting of boxes around sub-plots.</p>
</td></tr>
<tr><td><code id="plot_+3A_center_time">center_time</code></td>
<td>
<p>logical; if <code>TRUE</code>, sub-plot titles will show the center of time intervals, otherwise their start</p>
</td></tr>
<tr><td><code id="plot_+3A_hook">hook</code></td>
<td>
<p>NULL or function; hook function that will be called on every sub-plot; see examples.</p>
</td></tr>
<tr><td><code id="plot_+3A_mfrow">mfrow</code></td>
<td>
<p>length-2 integer vector with nrows, ncolumns of a composite plot, to override the default layout</p>
</td></tr>
<tr><td><code id="plot_+3A_fill">fill</code></td>
<td>
<p>logical; fill the plotting area at the lower or right-hand margin?</p>
</td></tr>
<tr><td><code id="plot_+3A_band">band</code></td>
<td>
<p>integer; which band (dimension) to plot</p>
</td></tr>
<tr><td><code id="plot_+3A_attr">attr</code></td>
<td>
<p>integer; which attribute to plot</p>
</td></tr>
<tr><td><code id="plot_+3A_asp">asp</code></td>
<td>
<p>numeric; aspect ratio of image</p>
</td></tr>
<tr><td><code id="plot_+3A_rgb">rgb</code></td>
<td>
<p>integer; specify three bands to form an rgb composite. Experimental: rgb color table; see Details.</p>
</td></tr>
<tr><td><code id="plot_+3A_maxcolorvalue">maxColorValue</code></td>
<td>
<p>numeric; passed on to <a href="grDevices.html#topic+rgb">rgb</a></p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code></td>
<td>
<p>character; x axis label</p>
</td></tr>
<tr><td><code id="plot_+3A_ylab">ylab</code></td>
<td>
<p>character; y axis label</p>
</td></tr>
<tr><td><code id="plot_+3A_xlim">xlim</code></td>
<td>
<p>x axis limits</p>
</td></tr>
<tr><td><code id="plot_+3A_ylim">ylim</code></td>
<td>
<p>y axis limits</p>
</td></tr>
<tr><td><code id="plot_+3A_text_values">text_values</code></td>
<td>
<p>logical; print values as text on image?</p>
</td></tr>
<tr><td><code id="plot_+3A_text_color">text_color</code></td>
<td>
<p>character; color for printed text values</p>
</td></tr>
<tr><td><code id="plot_+3A_interpolate">interpolate</code></td>
<td>
<p>logical; when using <a href="graphics.html#topic+rasterImage">rasterImage</a> (rgb), should pixels be interpolated?</p>
</td></tr>
<tr><td><code id="plot_+3A_as_points">as_points</code></td>
<td>
<p>logical; for curvilinear or sheared grids: parameter passed on to <a href="#topic+st_as_sf">st_as_sf</a>, determining whether raster cells will be plotted as symbols (fast, approximate) or small polygons (slow, exact)</p>
</td></tr>
<tr><td><code id="plot_+3A_logz">logz</code></td>
<td>
<p>logical; if <code>TRUE</code>, use log10-scale for the attribute variable. In that case, <code>breaks</code> and <code>at</code> need to be given as log10-values; see examples.</p>
</td></tr>
<tr><td><code id="plot_+3A_add.geom">add.geom</code></td>
<td>
<p>object of class <code>sfc</code>, or list with arguments to <code>plot</code>, that will be added to an image or sub-image</p>
</td></tr>
<tr><td><code id="plot_+3A_border">border</code></td>
<td>
<p>color used for cell borders (only in case <code>x</code> is a curvilinear or rotated/sheared grid)</p>
</td></tr>
<tr><td><code id="plot_+3A_useraster">useRaster</code></td>
<td>
<p>logical; use the rasterImage capabilities of the graphics device?</p>
</td></tr>
<tr><td><code id="plot_+3A_extent">extent</code></td>
<td>
<p>object which has a <code>st_bbox</code> method; sets the plotting extent</p>
</td></tr>
<tr><td><code id="plot_+3A_max_times">max_times</code></td>
<td>
<p>integer; maximum number of time steps to attempt to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Downsampling: a value for <code>downsample</code> of 0: no downsampling, 1: after every dimension value (pixel/line/band), one value is skipped (half of the original resolution), 2: after every dimension value, 2 values are skipped (one third of the original resolution), etc. If <code>downsample</code> is <code>TRUE</code> or a length 1 numeric vector, downsampling is only applied to the raster [x] and [y] dimensions.
</p>
<p>To remove unused classes in a categorical raster, use the <a href="base.html#topic+droplevels">droplevels</a> function.
</p>
<p>When bitmaps show visual artefacts (Moiré effects), make sure that device <a href="grDevices.html#topic+png">png</a> is used rather than <code>ragg::agg_png</code> as the latter uses antialiasing for filled polygons which causes this; see also https://github.com/r-spatial/stars/issues/573 .
</p>
<p>use of an rgb color table is experimental; see https://github.com/r-spatial/mapview/issues/208
</p>
<p>when plotting a subsetted <code>stars_proxy</code> object, the default value for argument <code>downsample</code> will not be computed correctly, and has to be set manually.
</p>
<p>when plotting a subsetted <code>stars_proxy</code> object, the default value for argument <code>downsample</code> will not be computed correctly, and has to be set manually.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_bbox(L7_ETMs) |&gt; st_as_sfc() |&gt; st_centroid() |&gt; st_coordinates() -&gt; pt
hook1 = function() {
    text(pt[,"X"], pt[,"Y"], "foo", col = 'orange', cex = 2)
}
plot(L7_ETMs, hook = hook1)
x = st_set_dimensions(L7_ETMs, 3, paste0("B_", 1:6))
hook2 = function(..., row, col, nr, nrow, ncol, value, bbox) {
   str = paste0("row ", row, "/", nrow, ", col ", col, "/", ncol, "\nnr: ", nr, " value: ", value)
   bbox |&gt; st_as_sfc() |&gt; st_centroid() |&gt; st_coordinates() -&gt; pt
   text(pt[,"X"], pt[,"Y"], str, col = 'red', cex = 2)
}
plot(x, hook = hook2, col = grey(c(.2,.25,.3,.35)))
if (isTRUE(dev.capabilities()$rasterImage == "yes")) {
  lc = read_stars(system.file("tif/lc.tif", package = "stars"))
  levels(lc[[1]]) = abbreviate(levels(lc[[1]]), 6) # so it's not only legend
  plot(lc, key.pos=4)
}
tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
image(x, col = grey((3:9)/10))
if (isTRUE(dev.capabilities()$rasterImage == "yes")) {
  image(x, rgb = c(1,3,5)) # false color composite
}
</code></pre>

<hr>
<h2 id='predict.stars'>Predict values, given a model object, for a stars or stars_proxy object</h2><span id='topic+predict.stars'></span><span id='topic+predict.stars_proxy'></span>

<h3>Description</h3>

<p>Predict values, given a model object, for a stars or stars_proxy object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
predict(object, model, ..., drop_dimensions = FALSE)

## S3 method for class 'stars_proxy'
predict(object, model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.stars_+3A_object">object</code></td>
<td>
<p>object of class 'stars'</p>
</td></tr>
<tr><td><code id="predict.stars_+3A_model">model</code></td>
<td>
<p>model object of a class that has a predict method; check with 'methods(class = class(object))'</p>
</td></tr>
<tr><td><code id="predict.stars_+3A_...">...</code></td>
<td>
<p>arguments passed on to this predict method</p>
</td></tr>
<tr><td><code id="predict.stars_+3A_drop_dimensions">drop_dimensions</code></td>
<td>
<p>logical; if 'TRUE', remove dimensions (coordinates etc) from 'data.frame' with predictors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>separate predictors in object need to be separate attributes in object; 
in case they are e.g. in a band dimension, use 'split(object)'
</p>

<hr>
<h2 id='print_stars'>print stars or dimensions object</h2><span id='topic+print_stars'></span><span id='topic+print.stars'></span><span id='topic+as.data.frame.dimensions'></span><span id='topic+print.dimensions'></span>

<h3>Description</h3>

<p>print stars or dimensions object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
print(x, ..., n = 1e+05, abbrev = 30)

## S3 method for class 'dimensions'
as.data.frame(
  x,
  ...,
  digits = max(3, getOption("digits") - 3),
  usetz = TRUE,
  stars_crs = getOption("stars.crs") %||% 28,
  all = FALSE
)

## S3 method for class 'dimensions'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_stars_+3A_x">x</code></td>
<td>
<p>object of class stars or of class dimensions</p>
</td></tr>
<tr><td><code id="print_stars_+3A_...">...</code></td>
<td>
<p>passed on to <code>as.data.frame.dimensions</code></p>
</td></tr>
<tr><td><code id="print_stars_+3A_n">n</code></td>
<td>
<p>when prod(dim(x)) &gt; 10 * n, the first n cells are used for attribute summary statistics</p>
</td></tr>
<tr><td><code id="print_stars_+3A_abbrev">abbrev</code></td>
<td>
<p>number of characters to abbreviate attribute names to</p>
</td></tr>
<tr><td><code id="print_stars_+3A_digits">digits</code></td>
<td>
<p>number of digits to print numbers</p>
</td></tr>
<tr><td><code id="print_stars_+3A_usetz">usetz</code></td>
<td>
<p>logical; used to format <code>PCICt</code> or <code>POSIXct</code> values</p>
</td></tr>
<tr><td><code id="print_stars_+3A_stars_crs">stars_crs</code></td>
<td>
<p>maximum width of string for CRS objects</p>
</td></tr>
<tr><td><code id="print_stars_+3A_all">all</code></td>
<td>
<p>logical; if <code>TRUE</code> print also fields entirely filled with <code>NA</code> or <code>NULL</code></p>
</td></tr>
</table>

<hr>
<h2 id='read_ncdf'>Read NetCDF into stars object</h2><span id='topic+read_ncdf'></span>

<h3>Description</h3>

<p>Read data from a file (or source) using the NetCDF library directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ncdf(
  .x,
  ...,
  var = NULL,
  ncsub = NULL,
  curvilinear = character(0),
  eps = sqrt(.Machine$double.eps),
  ignore_bounds = FALSE,
  make_time = TRUE,
  make_units = TRUE,
  proxy = NULL,
  downsample = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ncdf_+3A_.x">.x</code></td>
<td>
<p>NetCDF file or source as a character vector or an nc_proxy object.</p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_var">var</code></td>
<td>
<p>variable name or names (they must be on matching grids)</p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_ncsub">ncsub</code></td>
<td>
<p>matrix of start, count columns (see Details)</p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_curvilinear">curvilinear</code></td>
<td>
<p>length two character named vector with names of variables holding
longitude and latitude values for all raster cells. 'stars' attempts to figure out appropriate
curvilinear coordinates if they are not supplied.</p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_eps">eps</code></td>
<td>
<p>numeric; dimension value increases are considered identical when they differ less than <code>eps</code></p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_ignore_bounds">ignore_bounds</code></td>
<td>
<p>logical; should bounds values for dimensions, if present, be ignored?</p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_make_time">make_time</code></td>
<td>
<p>if <code>TRUE</code> (the default), an atttempt is made to provide a date-time class from the &quot;time&quot; variable</p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_make_units">make_units</code></td>
<td>
<p>if <code>TRUE</code> (the default), an attempt is made to set the units property of each variable</p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_proxy">proxy</code></td>
<td>
<p>logical; if <code>TRUE</code>, an object of class <code>stars_proxy</code> is read which contains array
metadata only; if <code>FALSE</code> the full array data is read in memory. If not set, defaults to <code>TRUE</code>
when the number of cells to be read is larger than <code>options(stars.n_proxy)</code>, or to 1e8 if that option was not set.</p>
</td></tr>
<tr><td><code id="read_ncdf_+3A_downsample">downsample</code></td>
<td>
<p>integer; number of cells to omit between samples along each dimension. 
e.g. <code>c(1,1,2)</code> would return every other cell in x and y and every third cell
in the third dimension (z or t). If 0, no downsampling is applied. Note that this transformation
is applied AFTER NetCDF data are read using st_downsample. As such, if proxy=TRUE, this 
option is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following logic is applied to coordinates. If any coordinate axes have
regularly spaced coordinate variables they are reduced to the
offset/delta form with 'affine = c(0, 0)', otherwise the values of the coordinates
are stored and used to define a rectilinear grid.
</p>
<p>If the data has two or more dimensions and the first two are regular
they are nominated as the 'raster' for plotting.
</p>
<p>If the <code>curvilinear</code> argument is used it specifies the 2D arrays
containing coordinate values for the first two dimensions of the data read. It is currently
assumed that the coordinates are 2D and that they relate to the first two dimensions in
that order.
</p>
<p>If <code>var</code> is not set the first set of variables on a shared grid is used.
</p>
<p><code>start</code> and <code>count</code> columns of ncsub must correspond to the variable dimemsion (nrows)
and be valid index using <code><a href="RNetCDF.html#topic+var.get.nc">var.get.nc</a></code> convention (start is 1-based). If the count value
is <code>NA</code> then all steps are included. Axis order must match that of the variable/s being read.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("nc/reduced.nc", package = "stars")
if (require(ncmeta, quietly = TRUE)) {
 read_ncdf(f)
 read_ncdf(f, var = c("anom"))
 read_ncdf(f, ncsub = cbind(start = c(1, 1, 1, 1), count = c(10, 12, 1, 1)))
}

if (require(ncmeta, quietly = TRUE)) {
 #' precipitation data in a curvilinear NetCDF
 prec_file = system.file("nc/test_stageiv_xyt.nc", package = "stars")
 prec = read_ncdf(prec_file, curvilinear = c("lon", "lat"), ignore_bounds = TRUE)
}

##plot(prec) ## gives error about unique breaks
## remove NAs, zeros, and give a large number
## of breaks (used for validating in detail)
qu_0_omit = function(x, ..., n = 22) {
  x = units::drop_units(na.omit(x))
  c(0, quantile(x[x &gt; 0], seq(0, 1, length.out = n)))
}
if (require(dplyr, quietly = TRUE)) {
  prec_slice = slice(prec, index = 17, along = "time")
  plot(prec_slice, border = NA, breaks = qu_0_omit(prec_slice[[1]]), reset = FALSE)
  nc = sf::read_sf(system.file("gpkg/nc.gpkg", package = "sf"), "nc.gpkg")
  plot(st_geometry(nc), add = TRUE, reset = FALSE, col = NA)
}
</code></pre>

<hr>
<h2 id='read_stars'>read raster/array dataset from file or connection</h2><span id='topic+read_stars'></span>

<h3>Description</h3>

<p>read raster/array dataset from file or connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_stars(
  .x,
  sub = TRUE,
  ...,
  options = character(0),
  driver = character(0),
  quiet = FALSE,
  NA_value = NA_real_,
  along = NA_integer_,
  RasterIO = list(),
  proxy = getOption("stars.n_proxy") %||% 1e+08,
  curvilinear = character(0),
  normalize_path = TRUE,
  RAT = character(0),
  tolerance = 1e-10,
  exclude = "",
  shorten = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_stars_+3A_.x">.x</code></td>
<td>
<p>character vector with name(s) of file(s) or data source(s) to be read, or a function that returns such a vector</p>
</td></tr>
<tr><td><code id="read_stars_+3A_sub">sub</code></td>
<td>
<p>character, integer or logical; name, index or indicator of sub-dataset(s) to be read</p>
</td></tr>
<tr><td><code id="read_stars_+3A_...">...</code></td>
<td>
<p>passed on to <a href="#topic+st_as_stars">st_as_stars</a> if <code>curvilinear</code> was set</p>
</td></tr>
<tr><td><code id="read_stars_+3A_options">options</code></td>
<td>
<p>character; opening options</p>
</td></tr>
<tr><td><code id="read_stars_+3A_driver">driver</code></td>
<td>
<p>character; driver to use for opening file. To override fixing for subdatasets and autodetect them as well, use <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="read_stars_+3A_quiet">quiet</code></td>
<td>
<p>logical; print progress output?</p>
</td></tr>
<tr><td><code id="read_stars_+3A_na_value">NA_value</code></td>
<td>
<p>numeric value to be used for conversion into NA values; by default this is read from the input file</p>
</td></tr>
<tr><td><code id="read_stars_+3A_along">along</code></td>
<td>
<p>length-one character or integer, or list; determines how several arrays are combined, see Details.</p>
</td></tr>
<tr><td><code id="read_stars_+3A_rasterio">RasterIO</code></td>
<td>
<p>list with named parameters for GDAL's RasterIO, to further control the extent, resolution and bands to be read from the data source; see details.</p>
</td></tr>
<tr><td><code id="read_stars_+3A_proxy">proxy</code></td>
<td>
<p>logical; if <code>TRUE</code>, an object of class <code>stars_proxy</code> is read which contains array
metadata only; if <code>FALSE</code> the full array data is read in memory. Always <code>FALSE</code> for curvilinear girds.
If set to a number, defaults to <code>TRUE</code> when the number of cells to be read is larger than that number.</p>
</td></tr>
<tr><td><code id="read_stars_+3A_curvilinear">curvilinear</code></td>
<td>
<p>length two character vector with names of subdatasets holding longitude and latitude values for all raster cells, or named length 2 list holding longitude and latitude matrices; the names of this list should correspond to raster dimensions referred to</p>
</td></tr>
<tr><td><code id="read_stars_+3A_normalize_path">normalize_path</code></td>
<td>
<p>logical; if <code>FALSE</code>, suppress a call to <a href="base.html#topic+normalizePath">normalizePath</a> on <code>.x</code></p>
</td></tr>
<tr><td><code id="read_stars_+3A_rat">RAT</code></td>
<td>
<p>character; raster attribute table column name to use as factor levels</p>
</td></tr>
<tr><td><code id="read_stars_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric; passed on to <a href="Matrix.html#topic+all.equal">all.equal</a> for comparing dimension parameters.</p>
</td></tr>
<tr><td><code id="read_stars_+3A_exclude">exclude</code></td>
<td>
<p>character; vector with category value(s) to exclude</p>
</td></tr>
<tr><td><code id="read_stars_+3A_shorten">shorten</code></td>
<td>
<p>logical or character; if <code>TRUE</code> and <code>length(.x) &gt; 1</code>, remove common start and end parts of array names; if character a new prefix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case <code>.x</code> contains multiple files, they will all be read and combined with <a href="#topic+c.stars">c.stars</a>. Along which dimension, or how should objects be merged? If <code>along</code> is set to <code>NA</code> it will merge arrays as new attributes if all objects have identical dimensions, or else try to merge along time if a dimension called <code>time</code> indicates different time stamps. A single name (or positive value) for <code>along</code> will merge along that dimension, or create a new one if it does not already exist. If the arrays should be arranged along one of more dimensions with values (e.g. time stamps), a named list can passed to <code>along</code> to specify them; see example.
</p>
<p><code>RasterIO</code> is a list with zero or more of the following named arguments:
<code>nXOff</code>, <code>nYOff</code> (both 1-based: the first row/col has offset value 1),
<code>nXSize</code>, <code>nYSize</code>, <code>nBufXSize</code>, <code>nBufYSize</code>, <code>bands</code>, <code>resample</code>.
See <a href="https://gdal.org/doxygen/classGDALDataset.html">https://gdal.org/doxygen/classGDALDataset.html</a> for their meaning;
<code>bands</code> is an integer vector containing the band numbers to be read (1-based: first band is 1).
Note that if <code>nBufXSize</code> or <code>nBufYSize</code> are specified for downsampling an image,
resulting in an adjusted geotransform. <code>resample</code> reflects the resampling method and
has to be one of: &quot;nearest_neighbour&quot; (the default),
&quot;bilinear&quot;, &quot;cubic&quot;, &quot;cubic_spline&quot;, &quot;lanczos&quot;, &quot;average&quot;, &quot;mode&quot;, or &quot;Gauss&quot;.
</p>
<p>Data that are read into memory (<code>proxy=FALSE</code>) are read into a numeric (double) array, except for categorical variables which are read into an numeric (integer) array of class <code>factor</code>.
</p>


<h3>Value</h3>

<p>object of class <code>stars</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
(x1 = read_stars(tif))
(x2 = read_stars(c(tif, tif)))
(x3 = read_stars(c(tif, tif), along = "band"))
(x4 = read_stars(c(tif, tif), along = "new_dimensions")) # create 4-dimensional array
x1o = read_stars(tif, options = "OVERVIEW_LEVEL=1")
t1 = as.Date("2018-07-31")
# along is a named list indicating two dimensions:
read_stars(c(tif, tif, tif, tif), along = list(foo = c("bar1", "bar2"), time = c(t1, t1+2)))

m = matrix(1:120, nrow = 12, ncol = 10)
dim(m) = c(x = 10, y = 12) # named dim
st = st_as_stars(m)
attr(st, "dimensions")$y$delta = -1
attr(st, "dimensions")$y$offset = 12
st
tmp = tempfile(fileext = ".tif")
write_stars(st, tmp)
(red &lt;- read_stars(tmp))
read_stars(tmp, RasterIO = list(nXOff = 1, nYOff = 1, nXSize = 10, nYSize = 12,
   nBufXSize = 2, nBufYSize = 2))[[1]]
(red &lt;- read_stars(tmp, RasterIO = list(nXOff = 1, nYOff = 1, nXSize = 10, nYSize = 12,
   nBufXSize = 2, nBufYSize = 2)))
red[[1]] # cell values of subsample grid:
## Not run: 
  plot(st, reset = FALSE, axes = TRUE, ylim = c(-.1,12.1), xlim = c(-.1,10.1),
    main = "nBufXSize &amp; nBufYSize demo", text_values = TRUE)
  plot(st_as_sfc(red, as_points = TRUE), add = TRUE, col = 'red', pch = 16)
  plot(st_as_sfc(st_as_stars(st), as_points = FALSE), add = TRUE, border = 'grey')
  plot(st_as_sfc(red, as_points = FALSE), add = TRUE, border = 'green', lwd = 2)

## End(Not run)
file.remove(tmp)
</code></pre>

<hr>
<h2 id='redimension'>redimension array, or collapse attributes into a new dimension</h2><span id='topic+redimension'></span><span id='topic+st_redimension'></span><span id='topic+st_redimension.stars'></span><span id='topic+st_redimension.stars_proxy'></span>

<h3>Description</h3>

<p>redimension array, or collapse attributes into a new dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_redimension(x, new_dims, along, ...)

## S3 method for class 'stars'
st_redimension(
  x,
  new_dims = st_dimensions(x),
  along = setNames(list(names(x)), name),
  ...,
  name = "new_dim"
)

## S3 method for class 'stars_proxy'
st_redimension(
  x,
  new_dims = st_dimensions(x),
  along = list(new_dim = names(x)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redimension_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="redimension_+3A_new_dims">new_dims</code></td>
<td>
<p>target dimensions: either a &lsquo;dimensions' object or an integer vector with the dimensions&rsquo; sizes</p>
</td></tr>
<tr><td><code id="redimension_+3A_along">along</code></td>
<td>
<p>named list with new dimension name and values</p>
</td></tr>
<tr><td><code id="redimension_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="redimension_+3A_name">name</code></td>
<td>
<p>character name of the new dimension</p>
</td></tr>
</table>

<hr>
<h2 id='st_apply'>st_apply apply a function to one or more array dimensions</h2><span id='topic+st_apply'></span><span id='topic+st_apply.stars'></span>

<h3>Description</h3>

<p>st_apply apply a function to array dimensions: aggregate over space, time, or something else
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
st_apply(
  X,
  MARGIN,
  FUN,
  ...,
  CLUSTER = NULL,
  PROGRESS = FALSE,
  FUTURE = FALSE,
  rename = TRUE,
  .fname,
  single_arg = has_single_arg(FUN, list(...)) || can_single_arg(FUN),
  keep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_apply_+3A_x">X</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_apply_+3A_margin">MARGIN</code></td>
<td>
<p>see <a href="base.html#topic+apply">apply</a>; index number(s) or name(s) of the dimensions over which <code>FUN</code> will be applied</p>
</td></tr>
<tr><td><code id="st_apply_+3A_fun">FUN</code></td>
<td>
<p>see <a href="base.html#topic+apply">apply</a> and see Details.</p>
</td></tr>
<tr><td><code id="st_apply_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>FUN</code></p>
</td></tr>
<tr><td><code id="st_apply_+3A_cluster">CLUSTER</code></td>
<td>
<p>cluster to use for parallel apply; see <a href="parallel.html#topic+makeCluster">makeCluster</a></p>
</td></tr>
<tr><td><code id="st_apply_+3A_progress">PROGRESS</code></td>
<td>
<p>logical; if <code>TRUE</code>, use <code>pbapply::pbapply</code> to show progress bar</p>
</td></tr>
<tr><td><code id="st_apply_+3A_future">FUTURE</code></td>
<td>
<p>logical;if <code>TRUE</code>, use <code>future.apply::future_apply</code></p>
</td></tr>
<tr><td><code id="st_apply_+3A_rename">rename</code></td>
<td>
<p>logical; if <code>TRUE</code> and <code>X</code> has only one attribute and 
<code>FUN</code> is a simple function name, rename the attribute of the returned object 
to the function name</p>
</td></tr>
<tr><td><code id="st_apply_+3A_.fname">.fname</code></td>
<td>
<p>function name for the new attribute name (if one or more 
dimensions are reduced) or the new dimension (if a new dimension is created); 
if missing, the name of <code>FUN</code> is used</p>
</td></tr>
<tr><td><code id="st_apply_+3A_single_arg">single_arg</code></td>
<td>
<p>logical; if <code>TRUE</code>, FUN takes a single argument (like <code>fn_ndvi1</code> below), 
if <code>FALSE</code> FUN takes multiple arguments (like <code>fn_ndvi2</code> below).</p>
</td></tr>
<tr><td><code id="st_apply_+3A_keep">keep</code></td>
<td>
<p>logical; if <code>TRUE</code>, preserve dimension metadata (e.g. time stamps)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FUN is a function which either operates on a single object, which will 
be the data of each iteration step over dimensions MARGIN, or a function that 
has as many arguments as there are elements in such an object. See the NDVI 
examples below. The second form can be VERY much faster e.g. when a trivial 
function is not being called for every pixel, but only once (example).
</p>
<p>The heuristics for the default of <code>single_arg</code> work often, but not always; try
setting this to the right value when <code>st_apply</code> gives an error.
</p>


<h3>Value</h3>

<p>object of class <code>stars</code> with accordingly reduced number of dimensions; 
in case <code>FUN</code> returns more than one value, a new dimension is created carrying 
the name of the function used; see the examples. Following the logic of 
<a href="base.html#topic+apply">apply</a>, This new dimension is put before the
other dimensions; use <a href="base.html#topic+aperm">aperm</a> to rearrange this, see last example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
st_apply(x, 1:2, mean) # mean band value for each pixel
st_apply(x, c("x", "y"), mean) # equivalent to the above
st_apply(x, 3, mean)   # mean of all pixels for each band
## Not run: 
 st_apply(x, "band", mean) # equivalent to the above
 st_apply(x, 1:2, range) # min and max band value for each pixel
 fn_ndvi1 = function(x) (x[4]-x[3])/(x[4]+x[3]) # ONE argument: will be called for each pixel
 fn_ndvi2 = function(red,nir) (nir-red)/(nir+red) # n arguments: will be called only once
 ndvi1 = st_apply(x, 1:2, fn_ndvi1)
   # note that we can select bands 3 and 4 in the first argument:
 ndvi2 = st_apply(x[,,,3:4], 1:2, fn_ndvi2) 
 all.equal(ndvi1, ndvi2)
 # compute the (spatial) variance of each band; https://github.com/r-spatial/stars/issues/430
 st_apply(x, 3, function(x) var(as.vector(x))) # as.vector is required!
 # to get a progress bar also in non-interactive mode, specify:
 if (require(pbapply)) { # install it, if FALSE
   pboptions(type = "timer")
 }
 st_apply(x, 1:2, range) # dimension "range" is first; rearrange by:
 st_apply(x, 1:2, range) %&gt;% aperm(c(2,3,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='st_as_sf'>Convert stars object into an sf object</h2><span id='topic+st_as_sf'></span><span id='topic+st_as_sfc.stars'></span><span id='topic+st_as_sf.stars'></span><span id='topic+st_as_sf.stars_proxy'></span>

<h3>Description</h3>

<p>Convert stars object into an sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
st_as_sfc(x, ..., as_points, which = seq_len(prod(dim(x)[1:2])))

## S3 method for class 'stars'
st_as_sf(
  x,
  ...,
  as_points = FALSE,
  merge = FALSE,
  na.rm = TRUE,
  use_integer = is.logical(x[[1]]) || is.integer(x[[1]]),
  long = FALSE,
  connect8 = FALSE
)

## S3 method for class 'stars_proxy'
st_as_sf(x, ..., downsample = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_sf_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_as_points">as_points</code></td>
<td>
<p>logical; should cells be converted to points or to polygons? See details.</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_which">which</code></td>
<td>
<p>linear index of cells to keep (this argument is not recommended to be used)</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_merge">merge</code></td>
<td>
<p>logical; if <code>TRUE</code>, cells with identical values are merged (using <code>GDAL_Polygonize</code> or <code>GDAL_FPolygonize</code>); if <code>FALSE</code>, a polygon for each raster cell is returned; see details</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; should missing valued cells be removed, or also be converted to features?</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_use_integer">use_integer</code></td>
<td>
<p>(relevant only if <code>merge</code> is <code>TRUE</code>): if <code>TRUE</code>, before polygonizing values are rounded to 32-bits signed integer values (GDALPolygonize), otherwise they are converted to 32-bit floating point values (GDALFPolygonize).</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_long">long</code></td>
<td>
<p>logical; if <code>TRUE</code>, return a long table form <code>sf</code>, with geometries and other dimensions recycled</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_connect8">connect8</code></td>
<td>
<p>logical; if <code>TRUE</code>, use 8 connectedness. Otherwise the 4 connectedness algorithm will be applied.</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_downsample">downsample</code></td>
<td>
<p>see <a href="#topic+st_as_stars">st_as_stars</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>merge</code> is <code>TRUE</code>, only the first attribute is converted into an <code>sf</code> object. If <code>na.rm</code> is <code>FALSE</code>, areas with <code>NA</code> values are also written out as polygons. Note that the resulting polygons are typically invalid, and use <a href="sf.html#topic+valid">st_make_valid</a> to create valid polygons out of them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
x = x[,1:100,1:100,6] # subset of a band with lower values in it
x[[1]][x[[1]] &lt; 30] = NA # set lower values to NA
x[[1]] = x[[1]] &lt; 100 # make the rest binary
x
(p = st_as_sf(x)) # removes NA areas
(p = st_as_sf(x[,,,1], merge = TRUE)) # glues polygons together
all(st_is_valid(p)) # not all valid, see details
plot(p, axes = TRUE)
(p = st_as_sf(x, na.rm = FALSE, merge = TRUE)) # includes polygons with NA values
plot(p, axes = TRUE)
</code></pre>

<hr>
<h2 id='st_as_stars'>convert objects into a stars object</h2><span id='topic+st_as_stars'></span><span id='topic+st_as_stars.list'></span><span id='topic+st_as_stars.default'></span><span id='topic+st_as_stars.stars'></span><span id='topic+st_as_stars.bbox'></span><span id='topic+st_as_stars.sf'></span><span id='topic+st_as_stars.Raster'></span><span id='topic+st_as_stars.SpatRaster'></span><span id='topic+st_as_stars.ncdfgeom'></span><span id='topic+st_as_stars.stars_proxy'></span><span id='topic+st_as_stars.data.frame'></span><span id='topic+st_as_stars.xts'></span><span id='topic+st_as_stars.OpenStreetMap'></span><span id='topic+st_as_stars.cubble_df'></span>

<h3>Description</h3>

<p>convert objects into a stars object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_as_stars(.x, ...)

## S3 method for class 'list'
st_as_stars(.x, ..., dimensions = NULL)

## Default S3 method:
st_as_stars(.x = NULL, ..., raster = NULL)

## S3 method for class 'stars'
st_as_stars(.x, ..., curvilinear = NULL, crs = st_crs("OGC:CRS84"))

## S3 method for class 'bbox'
st_as_stars(
  .x,
  ...,
  nx,
  ny,
  dx = dy,
  dy = dx,
  xlim = .x[c("xmin", "xmax")],
  ylim = .x[c("ymin", "ymax")],
  values = 0,
  n = 64800,
  pretty = FALSE,
  inside = FALSE,
  nz,
  proxy = FALSE
)

## S3 method for class 'sf'
st_as_stars(.x, ..., name = attr(.x, "sf_column"))

## S3 method for class 'Raster'
st_as_stars(.x, ..., att = 1, ignore_file = FALSE)

## S3 method for class 'SpatRaster'
st_as_stars(
  .x,
  ...,
  ignore_file = FALSE,
  as_attributes = all(terra::is.factor(.x))
)

## S3 method for class 'ncdfgeom'
st_as_stars(.x, ..., sf_geometry = NA)

## S3 method for class 'stars_proxy'
st_as_stars(
  .x,
  ...,
  downsample = 0,
  url = attr(.x, "url"),
  envir = parent.frame()
)

## S3 method for class 'data.frame'
st_as_stars(
  .x,
  ...,
  dims = coords,
  xy = dims[1:2],
  y_decreasing = TRUE,
  coords = 1:2
)

## S3 method for class 'xts'
st_as_stars(.x, ..., dimensions, name = "attr")

## S3 method for class 'OpenStreetMap'
st_as_stars(.x, ..., as_col = FALSE)

## S3 method for class 'cubble_df'
st_as_stars(.x, ..., check_times = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_stars_+3A_.x">.x</code></td>
<td>
<p>object to convert</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_...">...</code></td>
<td>
<p>in case <code>.x</code> is of class <code>bbox</code>, arguments passed on to 
<a href="base.html#topic+pretty">pretty</a>. In case <code>.x</code> is of class <code>nc_proxy</code>, arguments
passed on to <code><a href="#topic+read_ncdf">read_ncdf</a></code>.</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_dimensions">dimensions</code></td>
<td>
<p>object of class dimensions</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_raster">raster</code></td>
<td>
<p>character; the names of the dimensions that denote raster dimensions</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_curvilinear">curvilinear</code></td>
<td>
<p>only for creating curvilinear grids: named length 2 list holding longitude and latitude matrices or stars arrays, or the names of the corresponding attributes in <code>.x</code>; the names of this vector should correspond to raster dimensions the matrices are associated with; see Details.</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_crs">crs</code></td>
<td>
<p>object of class <code>crs</code> with the coordinate reference system of the values in <code>curvilinear</code>; see details</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_nx">nx</code></td>
<td>
<p>integer; number of cells in x direction; see details</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_ny">ny</code></td>
<td>
<p>integer; number of cells in y direction; see details</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_dx">dx</code></td>
<td>
<p>numeric or object of class units; cell size in x direction; see details</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_dy">dy</code></td>
<td>
<p>numeric or object of class units; cell size in y direction; see details</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_xlim">xlim</code></td>
<td>
<p>length 2 numeric vector with extent (min, max) in x direction</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_ylim">ylim</code></td>
<td>
<p>length 2 numeric vector with extent (min, max) in y direction</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_values">values</code></td>
<td>
<p>value(s) to populate the raster values with</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_n">n</code></td>
<td>
<p>the (approximate) target number of grid cells</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_pretty">pretty</code></td>
<td>
<p>logical; should cell coordinates have <a href="base.html#topic+pretty">pretty</a> values?</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_inside">inside</code></td>
<td>
<p>logical; should all cells entirely fall inside the bbox, potentially not covering it completely (<code>TRUE</code>), or allways cover the bbox (<code>FALSE</code>), or find a good approximation (<code>NA</code>, default)?</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_nz">nz</code></td>
<td>
<p>integer; number of cells in z direction; if missing no z-dimension is created.</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_proxy">proxy</code></td>
<td>
<p>logical; should a <code>stars_proxy</code> object be created? (requires gdal_create binary when sf &lt; 1.0-6)</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_name">name</code></td>
<td>
<p>character; attribute name for array from an <code>xts</code> object</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_att">att</code></td>
<td>
<p>see <a href="raster.html#topic+factor">factorValues</a>; column in the RasterLayer's attribute table</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_ignore_file">ignore_file</code></td>
<td>
<p>logical; if <code>TRUE</code>, ignore the SpatRaster object file name</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_as_attributes">as_attributes</code></td>
<td>
<p>logical; if <code>TRUE</code> and <code>.x</code> has more than one layer, load these as separate attributes rather than as a band or time dimension (only implemented for the case where <code>ignore_file</code> is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_sf_geometry">sf_geometry</code></td>
<td>
<p>sf data.frame with geometry and attributes to be added to stars object.
Must have same number of rows as timeseries instances.</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_downsample">downsample</code></td>
<td>
<p>integer: if larger than 0, downsample with this rate (number of pixels to skip in every row/column); if length 2, specifies downsampling rate in x and y.</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_url">url</code></td>
<td>
<p>character; URL of the stars endpoint where the data reside</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_envir">envir</code></td>
<td>
<p>environment to resolve objects in</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_dims">dims</code></td>
<td>
<p>the column names or indices that form the cube dimensions</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_xy">xy</code></td>
<td>
<p>the x and y raster dimension names or indices; only takes effect after dims has been specified</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_y_decreasing">y_decreasing</code></td>
<td>
<p>logical; if TRUE, (numeric) y values get a negative delta (decrease with increasing index)</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_coords">coords</code></td>
<td>
<p>same as dims, for symmetry with <a href="sf.html#topic+st_as_sf">st_as_sf</a></p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_as_col">as_col</code></td>
<td>
<p>logical; return rgb numbers (FALSE) or (character) color values (TRUE)?</p>
</td></tr>
<tr><td><code id="st_as_stars_+3A_check_times">check_times</code></td>
<td>
<p>logical; should we check that the time stamps of all time series are identical?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>curvilinear</code> is a list with <code>stars</code> objects with longitude and latitude values, its coordinate reference system is typically not that of the latitude and longitude values. If <code>curvilinear</code> contains the names of two arrays in <code>.x</code>, then these are removed from the returned object.
</p>
<p>For the <code>bbox</code> method: if <code>pretty</code> is <code>TRUE</code>, raster cells may extend the coordinate range of <code>.x</code> on all sides. If in addition to <code>nx</code> and <code>ny</code>, <code>dx</code> and <code>dy</code> are also missing, these are set to a single value computed as <code>sqrt(diff(xlim)*diff(ylim)/n)</code>. 
</p>
<p>If <code>nx</code> and <code>ny</code> are missing and <code>values</code> is a matrix, the number of columns and rows of the matrix are taken.
</p>
<p>Otherwise, if <code>nx</code> and <code>ny</code> are missing, they are computed as the (ceiling, floor, or rounded to integer value) of the ratio of the (x or y) range divided by (dx or dy), depending on the value of <code>inside</code>. Positive <code>dy</code> will be made negative. Further named arguments (<code>...</code>) are passed on to <code>pretty</code>. If <code>dx</code> or <code>dy</code> are <code>units</code> objects, their value is converted to the units of <code>st_crs(.x)</code> (only when sf &gt;= 1.0-7).
</p>
<p>For the <code>ncdfgeom</code> method: objects are point-timeseries with optional line or polygon geometry for each timeseries specified with the <code>sf_geometry</code> parameter. See <span class="pkg">ncdfgeom</span> for more about this NetCDF-based format for geometry and timeseries.
</p>
<p>for the <code>xts</code> methods, if <code>dimensions</code> are provided, time has to be the first dimension.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(plm, quietly = TRUE)) {
  data(Produc, package = "plm")
  st_as_stars(Produc, y_decreasing = FALSE)
 data(Produc, package = "plm")
 st_as_stars(Produc, y_decreasing = FALSE)
}
</code></pre>

<hr>
<h2 id='st_cells'>return the cell index corresponding to the location of a set of points</h2><span id='topic+st_cells'></span>

<h3>Description</h3>

<p>return the cell index corresponding to the location of a set of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_cells(x, sf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_cells_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_cells_+3A_sf">sf</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1345)
st_bbox(L7_ETMs) |&gt; 
  st_as_sfc() |&gt; 
  st_sample(10) -&gt; pts 
(x &lt;- st_cells(L7_ETMs, pts))
# get the pixel values (first band only):
st_as_stars(L7_ETMs)[[1]][x]
# get pixel values for all bands:
st_as_stars(L7_ETMs) |&gt; split() |&gt; sapply(`[`, x)
# compare with st_extract():
st_as_stars(L7_ETMs) |&gt; split() |&gt; st_extract(pts)
</code></pre>

<hr>
<h2 id='st_contour'>Compute or plot contour lines or sets</h2><span id='topic+st_contour'></span>

<h3>Description</h3>

<p>Compute contour lines or sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_contour(
  x,
  na.rm = TRUE,
  contour_lines = FALSE,
  breaks = classInt::classIntervals(na.omit(as.vector(x[[1]])))$brks
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_contour_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_contour_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; should missing valued cells be removed, or also be converted to features?</p>
</td></tr>
<tr><td><code id="st_contour_+3A_contour_lines">contour_lines</code></td>
<td>
<p>logical; if <code>FALSE</code>, polygons are returned (contour sets), otherwise contour lines</p>
</td></tr>
<tr><td><code id="st_contour_+3A_breaks">breaks</code></td>
<td>
<p>numerical; values at which to &quot;draw&quot; contour levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function requires GDAL &gt;= 2.4.0
</p>


<h3>See Also</h3>

<p>for polygonizing rasters following grid boundaries, see <a href="#topic+st_as_sf">st_as_sf</a> with arguments <code>as_points=FALSE</code> and <code>merge=TRUE</code>; <a href="graphics.html#topic+contour">contour</a> plots contour lines using R's native algorithm (which also plots contour levels)
</p>

<hr>
<h2 id='st_coordinates'>retrieve coordinates for raster or vector cube cells</h2><span id='topic+st_coordinates'></span><span id='topic+st_coordinates.stars'></span><span id='topic+as.data.frame.stars'></span><span id='topic+as_tibble.stars'></span>

<h3>Description</h3>

<p>retrieve coordinates for raster or vector cube cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
st_coordinates(x, ..., add_max = FALSE, center = TRUE)

## S3 method for class 'stars'
as.data.frame(x, ..., add_max = FALSE, center = NA)

as_tibble.stars(.x, ..., add_max = FALSE, center = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_coordinates_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_coordinates_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_coordinates_+3A_add_max">add_max</code></td>
<td>
<p>logical; if <code>TRUE</code>, dimensions are given with a min (x) and max (x_max) value</p>
</td></tr>
<tr><td><code id="st_coordinates_+3A_center">center</code></td>
<td>
<p>logical; (only if <code>add_max</code> is FALSE): should grid cell center coordinates be returned (TRUE) or offset values (FALSE)? <code>center</code> can be a named logical vector or list to specify values for each dimension.</p>
</td></tr>
<tr><td><code id="st_coordinates_+3A_.x">.x</code></td>
<td>
<p>object to be converted to a tibble</p>
</td></tr>
</table>

<hr>
<h2 id='st_crop'>crop a stars object</h2><span id='topic+st_crop'></span><span id='topic+st_crop.stars_proxy'></span><span id='topic+st_crop.stars'></span>

<h3>Description</h3>

<p>crop a stars object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars_proxy'
st_crop(
  x,
  y,
  ...,
  crop = TRUE,
  epsilon = sqrt(.Machine$double.eps),
  collect = TRUE
)

## S3 method for class 'stars'
st_crop(
  x,
  y,
  ...,
  crop = TRUE,
  epsilon = sqrt(.Machine$double.eps),
  as_points = all(st_dimension(y) == 2, na.rm = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_crop_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_crop_+3A_y">y</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>bbox</code>; see Details below.</p>
</td></tr>
<tr><td><code id="st_crop_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_crop_+3A_crop">crop</code></td>
<td>
<p>logical; if <code>TRUE</code>, the spatial extent of the returned object is cropped to still cover <code>obj</code>, if <code>FALSE</code>, the extent remains the same but cells outside <code>y</code> are given <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="st_crop_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric; factor to shrink the bounding box of <code>y</code> towards its center before cropping.</p>
</td></tr>
<tr><td><code id="st_crop_+3A_collect">collect</code></td>
<td>
<p>logical; if <code>TRUE</code>, repeat cropping on <code>stars</code> object, i.e. after data has been read</p>
</td></tr>
<tr><td><code id="st_crop_+3A_as_points">as_points</code></td>
<td>
<p>logical; only relevant if <code>y</code> is of class <code>sf</code> or <code>sfc</code>: if <code>FALSE</code>, treat <code>x</code> as a set of points, else as a set of small polygons. Default: <code>TRUE</code> if <code>y</code> is two-dimensional, else <code>FALSE</code>; see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for raster <code>x</code>, <code>st_crop</code> selects cells that intersect with <code>y</code>. 
For intersection, are raster cells interpreted as points or as small polygons? 
If <code>y</code> is of class <code>stars</code>, <code>x</code> raster cells are interpreted as points; if <code>y</code> is of class <code>bbox</code>, <code>x</code> cells are interpreted as cells (small polygons). Otherwise, if <code>as_points</code> is not given, cells are interpreted as points if <code>y</code> has a two-dimensional geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l7 = read_stars(system.file("tif/L7_ETMs.tif", package = "stars"))
d = st_dimensions(l7)

# area around cells 3:10 (x) and 4:11 (y):
offset = c(d[["x"]]$offset, d[["y"]]$offset)
res = c(d[["x"]]$delta, d[["y"]]$delta)
bb = st_bbox(c(xmin = offset[1] + 2 * res[1],
	ymin = offset[2] + 11 * res[2],
	xmax = offset[1] + 10 * res[1],
	ymax = offset[2] +  3 * res[2]), crs = st_crs(l7))
l7[bb]
# equivalent:
st_crop(l7, bb)

plot(l7[,1:13,1:13,1], reset = FALSE)
image(l7[bb,,,1], add = TRUE, col = sf.colors())
plot(st_as_sfc(bb), add = TRUE, border = 'green', lwd = 2)

# slightly smaller bbox:
bb = st_bbox(c(xmin = offset[1] + 2.1 * res[1],
	ymin = offset[2] + 10.9 * res[2],
	xmax = offset[1] +  9.9 * res[1],
	ymax = offset[2] +  3.1 * res[2]), crs = st_crs(l7))
l7[bb]

plot(l7[,1:13,1:13,1], reset = FALSE)
image(l7[bb,,,1], add = TRUE, col = sf.colors())
plot(st_as_sfc(bb), add = TRUE, border = 'green', lwd = 2)

# slightly larger bbox:
bb = st_bbox(c(xmin = offset[1] + 1.9 * res[1],
	ymin = offset[2] + 11.1 * res[2],
	xmax = offset[1] + 10.1 * res[1],
	ymax = offset[2] +  2.9 * res[2]), crs = st_crs(l7))
l7[bb]

plot(l7[,1:13,1:13,1], reset = FALSE)
image(l7[bb,,,1], add = TRUE, col = sf.colors())
plot(st_as_sfc(bb), add = TRUE, border = 'green', lwd = 2)

# half a cell size larger bbox:
bb = st_bbox(c(xmin = offset[1] + 1.49 * res[1],
	ymin = offset[2] + 11.51 * res[2],
	xmax = offset[1] + 10.51 * res[1],
	ymax = offset[2] +  2.49 * res[2]), crs = st_crs(l7))
l7[bb]

plot(l7[,1:13,1:13,1], reset = FALSE)
image(l7[bb,,,1], add = TRUE, col = sf.colors())
plot(st_as_sfc(bb), add = TRUE, border = 'green', lwd = 2)
</code></pre>

<hr>
<h2 id='st_dim_to_attr'>create an array with dimension values</h2><span id='topic+st_dim_to_attr'></span>

<h3>Description</h3>

<p>create an array with dimension values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_dim_to_attr(x, which = seq_along(dim(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_dim_to_attr_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_dim_to_attr_+3A_which">which</code></td>
<td>
<p>integer; indices of the dimensions to address (default: all)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>stars</code> object with dimension values as attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x1 = read_stars(tif)
(x = st_dim_to_attr(x1))
plot(x)
(x = st_dim_to_attr(x1, 2:3))
plot(x)
(x= st_dim_to_attr(x1, 3))
plot(x)
</code></pre>

<hr>
<h2 id='st_dimensions'>get dimensions from stars object</h2><span id='topic+st_dimensions'></span><span id='topic+st_dimensions.stars'></span><span id='topic+st_dimensions+3C-'></span><span id='topic+st_dimensions+3C-.stars'></span><span id='topic+st_dimensions+3C-.stars_proxy'></span><span id='topic+st_dimensions+3C-.list'></span><span id='topic+st_dimensions.array'></span><span id='topic+st_dimensions.default'></span><span id='topic+st_set_dimensions'></span><span id='topic+st_get_dimension_values'></span>

<h3>Description</h3>

<p>get dimensions from stars object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_dimensions(.x, ...)

## S3 method for class 'stars'
st_dimensions(.x, ...)

st_dimensions(x) &lt;- value

## S3 replacement method for class 'stars'
st_dimensions(x) &lt;- value

## S3 replacement method for class 'stars_proxy'
st_dimensions(x) &lt;- value

## S3 replacement method for class 'list'
st_dimensions(x) &lt;- value

## S3 method for class 'array'
st_dimensions(.x, ...)

## Default S3 method:
st_dimensions(
  .x,
  ...,
  .raster,
  affine = c(0, 0),
  cell_midpoints = FALSE,
  point = FALSE
)

st_set_dimensions(
  .x,
  which,
  values = NULL,
  point = NULL,
  names = NULL,
  xy,
  ...
)

st_get_dimension_values(.x, which, ..., where = NA, max = FALSE, center = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_dimensions_+3A_.x">.x</code></td>
<td>
<p>object to retrieve dimensions information from</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_x">x</code></td>
<td>
<p>object of class <code>dimensions</code></p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_value">value</code></td>
<td>
<p>new object of class <code>dimensions</code>, with matching dimensions</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_.raster">.raster</code></td>
<td>
<p>length 2 character array with names (if any) of the raster dimensions</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_affine">affine</code></td>
<td>
<p>numeric; specify parameters of the affine transformation</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_cell_midpoints">cell_midpoints</code></td>
<td>
<p>logical; if <code>TRUE</code> AND the dimension values are strictly regular, the values are interpreted as the cell midpoint values rather than the cell offset values when calculating offset (i.e., the half-cell-size correction is applied); can have a value for each dimension, or else is recycled</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_point">point</code></td>
<td>
<p>logical; does the pixel value (measure) refer to a point (location) value or to an pixel (area) summary value?</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_which">which</code></td>
<td>
<p>integer or character; index or name of the dimension to be changed</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_values">values</code></td>
<td>
<p>values for this dimension (e.g. <code>sfc</code> list-column), or length-1 <code>dimensions</code> object; setting special value <code>NULL</code> removes dimension values, for instance to remove curvilinear raster coordinates</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_names">names</code></td>
<td>
<p>character; vector with new names for all dimensions, or with the single new name for the dimension indicated by <code>which</code></p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_xy">xy</code></td>
<td>
<p>length-2 character vector; (new) names for the <code>x</code> and <code>y</code> raster dimensions</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_where">where</code></td>
<td>
<p>character, one of 'start', 'center' or 'end'. Set to NA (default) to ignore and use <code>max</code> and <code>center</code> explictly.  This argument provides a convenient alternative to setting <code>max</code> and <code>center</code>.</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_max">max</code></td>
<td>
<p>logical; if <code>TRUE</code> return the end, rather than the beginning of an interval</p>
</td></tr>
<tr><td><code id="st_dimensions_+3A_center">center</code></td>
<td>
<p>logical; if <code>TRUE</code> return the center of an interval; if <code>NA</code> return the center for raster dimensions, and the start of intervals in other cases</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dimensions can be specified in two ways. The simplest is to pass a vector with numeric values for a numeric dimension, or character values for a categorical dimension. Parameter <code>cell_midpoints</code> is used to specify whether numeric values refer to the offset (start) of a dimension interval (default), or to the center; the center case is only available for regular dimensions. For rectilinear numeric dimensions, one can specify either a vector with cell borders (start values), or a data.frame with two columns named &quot;start&quot; and &quot;end&quot;, with the respective interval start and end values. In the first case, the end values are computed from the start values by assuming the last two intervals have equal width.
</p>


<h3>Value</h3>

<p>the <code>dimensions</code> attribute of <code>x</code>, of class <code>dimensions</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = read_stars(system.file("tif/L7_ETMs.tif", package = "stars"))
# Landsat 7 ETM+ band semantics: https://landsat.gsfc.nasa.gov/the-enhanced-thematic-mapper-plus/
# set bands to values 1,2,3,4,5,7:
(x1 = st_set_dimensions(x, "band", values = c(1,2,3,4,5,7), names = "band_number", point = TRUE))
# set band values as bandwidth
rbind(c(0.45,0.515), c(0.525,0.605), c(0.63,0.69), c(0.775,0.90), c(1.55,1.75), c(2.08,2.35)) %&gt;%
  units::set_units("um") -&gt; bw # or: units::set_units(µm) -&gt; bw
# set bandwidth midpoint:
(x2 = st_set_dimensions(x, "band", values = 0.5 * (bw[,1]+bw[,2]), 
   names = "bandwidth_midpoint", point = TRUE))
# set bandwidth intervals:
(x3 = st_set_dimensions(x, "band", values = make_intervals(bw), names = "bandwidth"))
m = matrix(1:20, nrow = 5, ncol = 4)
dim(m) = c(x = 5, y = 4) # named dim
(s = st_as_stars(m))
st_get_dimension_values(s, 'x', where = "start")
st_get_dimension_values(s, 'x', center = FALSE)
st_get_dimension_values(s, 'x', where = "center")
st_get_dimension_values(s, 'x', center = TRUE)
st_get_dimension_values(s, 'x', where = "end")
st_get_dimension_values(s, 'x', max = TRUE)
</code></pre>

<hr>
<h2 id='st_downsample'>downsample stars or stars_proxy objects</h2><span id='topic+st_downsample'></span><span id='topic+st_downsample.stars'></span><span id='topic+st_downsample.stars_proxy'></span>

<h3>Description</h3>

<p>downsample a stars or stars_proxy object either by skipping rows, columns and bands,
or by computing a single value (e.g. the mean) from the sub-tiles involved
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_downsample(x, n, ...)

## S3 method for class 'stars'
st_downsample(x, n, ..., offset = 0, FUN)

## S3 method for class 'stars_proxy'
st_downsample(x, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_downsample_+3A_x">x</code></td>
<td>
<p>object of class stars or stars_proxy</p>
</td></tr>
<tr><td><code id="st_downsample_+3A_n">n</code></td>
<td>
<p>integer; for each dimension the number of pixels/lines/bands etc that will be skipped; see Details.</p>
</td></tr>
<tr><td><code id="st_downsample_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>FUN</code> (e.g., <code>na.rm = TRUE</code> to ignore missing values if FUN is <code>mean</code>)</p>
</td></tr>
<tr><td><code id="st_downsample_+3A_offset">offset</code></td>
<td>
<p>integer; offset(s) for downsampling, in pixels, starting at the offset of 
each dimension; should be smaller or equal to <code>n</code></p>
</td></tr>
<tr><td><code id="st_downsample_+3A_fun">FUN</code></td>
<td>
<p>function; if given, downsampling will apply FUN to each of the the subtiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If all n == 0, no downsampling takes place; if it is 1, every second row/column/band
is skipped, if it is 2, every second+third row/column/band are skipped, etc.
</p>
<p>Downsampling a <code>stars_proxy</code> object returns a <code>stars</code> object, is
equivalent to calling <code>st_as_stars(x, downsample = 2)</code>, and only downsamples
the first two (x and y) dimensions.
</p>
<p>Downsampled regular rasters keep their dimension offsets, have a cell size (delta) that
is n[i]+1 times larger, and may result in a (slightly) different extent.
</p>
<p>Note that terra's <a href="terra.html#topic+aggregate">aggregate</a> with <code>fact=2</code> corresponds to
<code>st_downsample(x, n = 1, FUN = mean)</code>: <code>fact</code> is one larger than <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m = matrix(1:121, 11, 11))
(s = st_as_stars(m))
st_downsample(s, 1)
st_downsample(s, 1)[[1]]
st_downsample(s, 1, offset = 1)
st_downsample(s, 1, offset = 1)[[1]]
st_downsample(s, 1, offset = c(0,1))
st_downsample(s, 1, offset = c(0,1))[[1]]
st_downsample(s, 1, FUN = mean)
st_downsample(s, 1, FUN = mean)[[1]]
st_downsample(s, 1, offset = 1, FUN = mean)
st_downsample(s, 1, offset = c(0,1), FUN = mean)[[1]]
</code></pre>

<hr>
<h2 id='st_extract'>Extract cell values at point locations</h2><span id='topic+st_extract'></span><span id='topic+st_extract.stars'></span>

<h3>Description</h3>

<p>Extract cell values at point locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_extract(x, ...)

## S3 method for class 'stars'
st_extract(
  x,
  at,
  ...,
  bilinear = FALSE,
  time_column = attr(at, "time_column") %||% attr(at, "time_col"),
  interpolate_time = bilinear,
  FUN = mean
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_extract_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code> or <code>stars_proxy</code></p>
</td></tr>
<tr><td><code id="st_extract_+3A_...">...</code></td>
<td>
<p>passed on to <a href="#topic+aggregate.stars">aggregate.stars</a> when geometries are not exclusively POINT geometries</p>
</td></tr>
<tr><td><code id="st_extract_+3A_at">at</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code> with geometries, or two-column matrix with coordinate points in rows, indicating where to extract values of <code>x</code></p>
</td></tr>
<tr><td><code id="st_extract_+3A_bilinear">bilinear</code></td>
<td>
<p>logical; use bilinear interpolation rather than nearest neighbour?</p>
</td></tr>
<tr><td><code id="st_extract_+3A_time_column">time_column</code></td>
<td>
<p>character or integer; name or index of a column with time or date values that will be matched to values of the dimension &quot;time&quot; in <code>x</code>, after which this dimension is reduced. This is useful to extract data cube values along a trajectory; see https://github.com/r-spatial/stars/issues/352 .</p>
</td></tr>
<tr><td><code id="st_extract_+3A_interpolate_time">interpolate_time</code></td>
<td>
<p>logical; should time be interpolated? if FALSE, time instances are matched using the coinciding or the last preceding time in the data cube.</p>
</td></tr>
<tr><td><code id="st_extract_+3A_fun">FUN</code></td>
<td>
<p>function used to aggregate pixel values when geometries of <code>at</code> intersect with more than one pixel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>points outside the raster are returned as <code>NA</code> values. For
large sets of points for which extraction is needed, passing a matrix as
to <code>at</code> may be much faster than passing an <code>sf</code> or <code>sfc</code> object.
</p>


<h3>Value</h3>

<p>if <code>at</code> is of class <code>matrix</code>, a matrix with extracted values is returned; 
otherwise: if <code>x</code> has more dimensions than only x and y (raster), an 
object of class <code>stars</code> with POINT geometries replacing x and y raster
dimensions, if this is not the case, an object of <code>sf</code> with extracted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
r = read_stars(tif)
pnt = st_sample(st_as_sfc(st_bbox(r)), 10)
st_extract(r, pnt)
st_extract(r, pnt) %&gt;% st_as_sf()
st_extract(r[,,,1], pnt)
st_extract(r, st_coordinates(pnt)) # "at" is a matrix: return a matrix
</code></pre>

<hr>
<h2 id='st_intersects.stars'>spatial intersect predicate for stars and sfc object</h2><span id='topic+st_intersects.stars'></span>

<h3>Description</h3>

<p>spatial intersect predicate for stars and sfc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
st_intersects(x, y, sparse = TRUE, ..., as_points = NA, transpose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_intersects.stars_+3A_x">x</code></td>
<td>
<p>object of class stars</p>
</td></tr>
<tr><td><code id="st_intersects.stars_+3A_y">y</code></td>
<td>
<p>object that has an 'st_geometry' method: of class 'sf' or 'sfc', or 'stars' object with an 'sfc' dimension</p>
</td></tr>
<tr><td><code id="st_intersects.stars_+3A_sparse">sparse</code></td>
<td>
<p>logical; if TRUE, return the a sparse logical matrix (object of class 'sgbp'), if FALSE, return a logical matrix</p>
</td></tr>
<tr><td><code id="st_intersects.stars_+3A_...">...</code></td>
<td>
<p>ignored, or passed on to 'st_intersects.sf' for curvilinear grids</p>
</td></tr>
<tr><td><code id="st_intersects.stars_+3A_as_points">as_points</code></td>
<td>
<p>logical, should grid cells be considered as points (TRUE) or polygons (FALSE)? Default: FALSE and warning emitted</p>
</td></tr>
<tr><td><code id="st_intersects.stars_+3A_transpose">transpose</code></td>
<td>
<p>logical; should the transpose of the 'sgbp' object be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>curvilinear grids are always converted to polygons, so points on grid boundaries may intersect with two cells touched; for other grids each cell boundary or corner belongs only to one cell.
</p>


<h3>Value</h3>

<p>'sgbp' object if sparse = TRUE, logical matrix otherwise
</p>

<hr>
<h2 id='st_join.stars'>Spatially join a stars and an 'sf' object</h2><span id='topic+st_join.stars'></span>

<h3>Description</h3>

<p>Spatially join a stars and an 'sf' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
st_join(
  x,
  y,
  join = st_intersects,
  ...,
  what = "left1",
  as_points = NA,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_join.stars_+3A_x">x</code></td>
<td>
<p>object of class stars</p>
</td></tr>
<tr><td><code id="st_join.stars_+3A_y">y</code></td>
<td>
<p>object of class sf, or one that can be coerced into that by <a href="#topic+st_as_sf">st_as_sf</a></p>
</td></tr>
<tr><td><code id="st_join.stars_+3A_join">join</code></td>
<td>
<p>the join function, which should return an sgbp object; see details</p>
</td></tr>
<tr><td><code id="st_join.stars_+3A_...">...</code></td>
<td>
<p>arguments that will be passed on to the join function</p>
</td></tr>
<tr><td><code id="st_join.stars_+3A_what">what</code></td>
<td>
<p>&quot;left1&quot;, &quot;right&quot; or &quot;inner&quot;; see details</p>
</td></tr>
<tr><td><code id="st_join.stars_+3A_as_points">as_points</code></td>
<td>
<p>logical; controls whether grid cells in <code>x</code> will be treated as points, or as cell areas; the <a href="#topic+st_intersects.stars">st_intersects.stars</a> method by default will derive this from <code>x</code>'s metadata, or else assume areas.</p>
</td></tr>
<tr><td><code id="st_join.stars_+3A_warn">warn</code></td>
<td>
<p>logical; if TRUE, warn on 1-to-many matches when <code>what</code> is <code>"left1"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When there is more than one match to a single x value, the first matching record from y is taken (and if <code>warn</code> is TRUE a warning is raised). If what is &quot;inner&quot;, an object of class <code>sf</code> with all matching records of x and y.
</p>


<h3>Value</h3>

<p>If what is &quot;left1&quot;, an object of class stars with the (first) value of y at spatial instances of x
</p>

<hr>
<h2 id='st_mosaic'>build mosaic (composite) of several spatially disjoint stars objects</h2><span id='topic+st_mosaic'></span><span id='topic+st_mosaic.stars'></span><span id='topic+st_mosaic.character'></span><span id='topic+st_mosaic.stars_proxy'></span>

<h3>Description</h3>

<p>build mosaic (composite) of several spatially disjoint stars objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_mosaic(.x, ...)

## S3 method for class 'stars'
st_mosaic(
  .x,
  ...,
  dst = tempfile(fileext = file_ext),
  options = c("-vrtnodata", "-9999", "-srcnodata", "nan"),
  file_ext = ".tif"
)

## S3 method for class 'character'
st_mosaic(
  .x,
  ...,
  dst = tempfile(fileext = file_ext),
  options = c("-vrtnodata", "-9999"),
  file_ext = ".tif"
)

## S3 method for class 'stars_proxy'
st_mosaic(
  .x,
  ...,
  dst = tempfile(fileext = file_ext),
  options = c("-vrtnodata", "-9999"),
  file_ext = ".tif"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_mosaic_+3A_.x">.x</code></td>
<td>
<p>object of class stars, or character vector with input dataset names</p>
</td></tr>
<tr><td><code id="st_mosaic_+3A_...">...</code></td>
<td>
<p>further input stars objects</p>
</td></tr>
<tr><td><code id="st_mosaic_+3A_dst">dst</code></td>
<td>
<p>character; destination file name</p>
</td></tr>
<tr><td><code id="st_mosaic_+3A_options">options</code></td>
<td>
<p>character; options to the gdalbuildvrt command</p>
</td></tr>
<tr><td><code id="st_mosaic_+3A_file_ext">file_ext</code></td>
<td>
<p>character; file extension, determining the format used to write to (&quot;.tif&quot; implies GeoTIFF)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the gdal function buildvrt builds a mosaic of input images; these imput images can be multi-band, but not higher-dimensional data cubes or stars objects with multiple attributes
</p>
<p>uses <a href="sf.html#topic+gdal_utils">gdal_utils</a> to internally call <code>buildvrt</code>; no executables external to R are called.
</p>


<h3>Value</h3>

<p>the stars method returns a stars object with the composite of the input; the <code>character</code> method returns the file name of the file with the mosaic; see also the GDAL documentation of <code>gdalbuildvrt</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = read_stars(system.file("tif/L7_ETMs.tif", package = "stars"))
x1 = x[,100:200,100:200,]
x2 = x[,150:300,150:300,]
plot(st_mosaic(x1, x2))
</code></pre>

<hr>
<h2 id='st_raster_type'>get the raster type (if any) of a stars object</h2><span id='topic+st_raster_type'></span>

<h3>Description</h3>

<p>get the raster type (if any) of a stars object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_raster_type(x, dimension = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_raster_type_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_raster_type_+3A_dimension">dimension</code></td>
<td>
<p>optional: numbers or names of dimension(s) to get per-dimension type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>categories <code>"curvilinear"</code> and <code>"affine"</code> only refer to
the relationship between a pair of spatial (raster) dimensions.
</p>


<h3>Value</h3>

<p>if <code>dimension</code> is not specified, return the spatial raster type: 
one of <code>NA</code> (if the object does not have raster dimensions), 
<code>"curvilinear"</code>, <code>"rectilinear"</code>, <code>"affine"</code>, or <code>"regular"</code>.
In case dimension(s) are specified, return one of <code>"regular"</code>, <code>"rectilinear"</code>
(irregular but numeric), or <code>"discrete"</code> (anything else).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
st_raster_type(x)
st_raster_type(x, 1:3)
</code></pre>

<hr>
<h2 id='st_rasterize'>rasterize simple feature geometries</h2><span id='topic+st_rasterize'></span>

<h3>Description</h3>

<p>rasterize simple feature geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_rasterize(
  sf,
  template = guess_raster(sf, ...) %||% st_as_stars(st_bbox(sf), values = NA_real_,
    ...),
  file = tempfile(),
  driver = "GTiff",
  options = character(0),
  align = FALSE,
  proxy = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_rasterize_+3A_sf">sf</code></td>
<td>
<p>object of class <code>sf</code></p>
</td></tr>
<tr><td><code id="st_rasterize_+3A_template">template</code></td>
<td>
<p>stars object with desired target geometry, or target geometry alignment if <code>align=TRUE</code></p>
</td></tr>
<tr><td><code id="st_rasterize_+3A_file">file</code></td>
<td>
<p>temporary file name</p>
</td></tr>
<tr><td><code id="st_rasterize_+3A_driver">driver</code></td>
<td>
<p>driver for temporary file</p>
</td></tr>
<tr><td><code id="st_rasterize_+3A_options">options</code></td>
<td>
<p>character; options vector for <code>GDALRasterize</code></p>
</td></tr>
<tr><td><code id="st_rasterize_+3A_align">align</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>template</code> contain the geometry alignment, 
informing target resolution and offset only.</p>
</td></tr>
<tr><td><code id="st_rasterize_+3A_proxy">proxy</code></td>
<td>
<p>logical; should a proxy object be returned?</p>
</td></tr>
<tr><td><code id="st_rasterize_+3A_...">...</code></td>
<td>
<p>arguments passed on to <a href="#topic+st_as_stars">st_as_stars</a></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>demo(nc, echo = FALSE, ask = FALSE)
(x = st_rasterize(nc)) # default grid:
plot(x, axes = TRUE)
# a bit more customized grid:
(x = st_rasterize(nc, st_as_stars(st_bbox(nc), nx = 100, ny = 50, values = NA_real_)))
plot(x, axes = TRUE)
(ls = st_sf(a = 1:2, st_sfc(st_linestring(rbind(c(0.1, 0), c(1.1, 1))),
   st_linestring(rbind(c(0, 0.05), c(1, 0.05))))))
(grd = st_as_stars(st_bbox(ls), nx = 10, ny = 10, xlim = c(0, 1.0), ylim = c(0, 1),
   values = NA_real_))
# Only the left-top corner is part of the grid cell:
sf_extSoftVersion()["GDAL"]
plot(st_rasterize(ls, grd), axes = TRUE, reset = FALSE) # ALL_TOUCHED=FALSE; 
plot(ls, add = TRUE, col = "red")
plot(st_rasterize(ls, grd, options = "ALL_TOUCHED=TRUE"), axes = TRUE, reset = FALSE)
plot(ls, add = TRUE, col = "red")
# add lines to existing 0 values, summing values in case of multiple lines:
(grd = st_as_stars(st_bbox(ls), nx = 10, ny = 10, xlim = c(0, 1.0), ylim = c(0, 1), values = 0))
r = st_rasterize(ls, grd, options = c("MERGE_ALG=ADD", "ALL_TOUCHED=TRUE"))
plot(r, axes = TRUE, reset = FALSE)
plot(ls, add = TRUE, col = "red")
</code></pre>

<hr>
<h2 id='st_res'>obtain (spatial) resolution of a stars object</h2><span id='topic+st_res'></span>

<h3>Description</h3>

<p>obtain resolution(s) of a stars object: by default only the (absolute) x/y raster dimensions, optionally all <code>delta</code> dimension parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_res(x, all = FALSE, absolute = !all)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_res_+3A_x">x</code></td>
<td>
<p>an object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_res_+3A_all">all</code></td>
<td>
<p>logical; if FALSE return a vector with the x/y raster resolution</p>
</td></tr>
<tr><td><code id="st_res_+3A_absolute">absolute</code></td>
<td>
<p>logical; only works when <code>all = FALSE</code>; if TRUE return absolute resolution values, if FALSE return <code>delta</code> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>all = FALSE</code> a vector with x/y raster resolutions, otherwise a list with delta values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_res(L7_ETMs)
st_res(L7_ETMs, absolute = FALSE)
st_res(L7_ETMs, all = TRUE)
if (require(starsdata)) {
  paste0("netcdf/", c("avhrr-only-v2.19810901.nc", 
    "avhrr-only-v2.19810902.nc",
    "avhrr-only-v2.19810903.nc",
    "avhrr-only-v2.19810904.nc")) |&gt;
  system.file(package = "starsdata") |&gt;
  read_stars(quiet = TRUE) -&gt; x
  st_res(x) |&gt; print()
  st_res(x, all = TRUE) |&gt; print()
}
</code></pre>

<hr>
<h2 id='st_rgb'>reduce dimension to rgb (alpha) hex values</h2><span id='topic+st_rgb'></span>

<h3>Description</h3>

<p>reduce dimension to rgb (alpha) hex values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_rgb(
  x,
  dimension = 3,
  use_alpha = dim(x)[dimension] == 4,
  maxColorValue = 255L,
  probs = c(0, 1),
  stretch = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_rgb_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_rgb_+3A_dimension">dimension</code></td>
<td>
<p>dimension name or number to reduce</p>
</td></tr>
<tr><td><code id="st_rgb_+3A_use_alpha">use_alpha</code></td>
<td>
<p>logical; if TRUE, the fourth band will be used as alpha values</p>
</td></tr>
<tr><td><code id="st_rgb_+3A_maxcolorvalue">maxColorValue</code></td>
<td>
<p>integer; maximum value for colors</p>
</td></tr>
<tr><td><code id="st_rgb_+3A_probs">probs</code></td>
<td>
<p>probability values for quantiles used for stretching by &quot;percent&quot;.</p>
</td></tr>
<tr><td><code id="st_rgb_+3A_stretch">stretch</code></td>
<td>
<p>logical or character; if <code>TRUE</code> or <code>"percent"</code>,
each band is stretched to 0 ... maxColorValue by &quot;percent clip&quot; method using
probs values. If <code>"histogram"</code>, a &quot;histogram equalization&quot; is performed
(<code>probs</code> values are ignored). If stretch is <code>NULL</code> or <code>FALSE</code>, no stretching
is performed. Other character values are interpreted as &quot;percent&quot; and a message
will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the dimension's bands are mapped to red, green, blue, alpha; if a different
ordering is wanted, use <a href="#topic++5B.stars">[.stars</a> to reorder a dimension, see examples.
Alternatively, you can use <a href="#topic+plot.stars">plot.stars</a> with the <code>rgb</code> argument to create a three-band composition.
</p>


<h3>See Also</h3>

<p><a href="#topic+st_apply">st_apply</a>, <a href="grDevices.html#topic+rgb">rgb</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
st_rgb(x[,,,3:1])
r = st_rgb(x[,,,c(6,5,4,3)], 3, use_alpha=TRUE) # now R=6,G=5,B=4,alpha=3
if (require(ggplot2)) {
 ggplot() + geom_stars(data = r) + scale_fill_identity()
}
r = st_rgb(x[,,,3:1],
		   probs = c(0.01, 0.99),
		   stretch = "percent")
plot(r)
r = st_rgb(x[,,,3:1],
		   probs = c(0.01, 0.99),
		   stretch = "histogram")
plot(r)
</code></pre>

<hr>
<h2 id='st_set_bbox'>set bounding box parameters of regular grid</h2><span id='topic+st_set_bbox'></span>

<h3>Description</h3>

<p>set bounding box parameters of regular grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_set_bbox(x, value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_set_bbox_+3A_x">x</code></td>
<td>
<p>object of class dimensions, stars or stars_proxy</p>
</td></tr>
<tr><td><code id="st_set_bbox_+3A_value">value</code></td>
<td>
<p>object of class bbox</p>
</td></tr>
<tr><td><code id="st_set_bbox_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='st_sfc2xy'>replace POINT simple feature geometry list with an x y raster</h2><span id='topic+st_sfc2xy'></span>

<h3>Description</h3>

<p>replace POINT simple feature geometry list with an x y raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_sfc2xy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_sfc2xy_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code>, or of class <code>sf</code></p>
</td></tr>
<tr><td><code id="st_sfc2xy_+3A_...">...</code></td>
<td>
<p>passed on to <a href="#topic+as.data.frame.stars">as.data.frame.stars</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>stars</code> with a POINT list replaced by x and y raster dimensions. This only works when the points are distributed over a regular or rectilinear grid.
</p>

<hr>
<h2 id='st_tile'>Specify parameters to load raster in blocks</h2><span id='topic+st_tile'></span>

<h3>Description</h3>

<p>Helper function for specifying the block parameters (<code>nXOff</code>,
<code>nYOff</code>, <code>nXsize</code>, and <code>nYSize</code>) required by <code>RasterIO</code>
argument in <a href="#topic+read_stars">read_stars</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_tile(img_rows, img_cols, x_window, y_window, overlap = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_tile_+3A_img_rows">img_rows</code></td>
<td>
<p>number of input raster rows (integer)</p>
</td></tr>
<tr><td><code id="st_tile_+3A_img_cols">img_cols</code></td>
<td>
<p>number of input raster columns (integer)</p>
</td></tr>
<tr><td><code id="st_tile_+3A_x_window">x_window</code></td>
<td>
<p>number of rows in block (integer)</p>
</td></tr>
<tr><td><code id="st_tile_+3A_y_window">y_window</code></td>
<td>
<p>number of columns in block (integer)</p>
</td></tr>
<tr><td><code id="st_tile_+3A_overlap">overlap</code></td>
<td>
<p>number of overlapping pixels (integer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with specified <code>nXOff</code>, <code>nYOff</code>, <code>nXsize</code>,
and <code>nYSize</code> parameters for every block
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tif = system.file("tif/L7_ETMs.tif", package = "stars")
r = read_stars(tif, proxy = TRUE)
tiles = st_tile(nrow(r), ncol(r), 256, 256)
for (i in seq_len(nrow(tiles))) {
  tile = read_stars(tif, proxy = FALSE, RasterIO = tiles[i, ])
  # write tiles to separate files
  write_stars(tile, dsn = paste0(i, ".tif"))
}

## End(Not run)

</code></pre>

<hr>
<h2 id='st_transform'>transform geometries in stars objects to a new coordinate reference system, without warping</h2><span id='topic+st_transform'></span><span id='topic+st_transform.stars'></span><span id='topic+st_transform_proj.stars'></span>

<h3>Description</h3>

<p>transform geometries in stars objects to a new coordinate reference system, without warping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stars'
st_transform(x, crs, ...)

st_transform_proj.stars(x, crs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_transform_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code>, with either raster or simple feature geometries</p>
</td></tr>
<tr><td><code id="st_transform_+3A_crs">crs</code></td>
<td>
<p>object of class <code>crs</code> with target crs</p>
</td></tr>
<tr><td><code id="st_transform_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simple feature dimensions, <a href="sf.html#topic+st_transform">st_transform</a> is called, leading to lossless transformation. For gridded spatial data, a curvilinear grid with transformed grid cell (centers) is returned, which is also lossless. To convert this to a regular grid in the new <code>CRS</code>, use <a href="#topic+st_warp">st_warp</a> (which is in general lossy).
</p>


<h3>See Also</h3>

<p><a href="#topic+st_warp">st_warp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geomatrix = system.file("tif/geomatrix.tif", package = "stars")
(x = read_stars(geomatrix))
new = st_crs('OGC:CRS84')
y = st_transform(x, new)
plot(st_transform(st_as_sfc(st_bbox(x)), new), col = NA, border = 'red')
plot(st_as_sfc(y, as_points=FALSE), col = NA, border = 'green', axes = TRUE, add = TRUE)
image(y, col = heat.colors(12), add = TRUE)
plot(st_as_sfc(y, as_points=TRUE), pch=3, cex=.5, col = 'blue', add = TRUE)
plot(st_transform(st_as_sfc(x, as_points=FALSE), new), add = TRUE)
</code></pre>

<hr>
<h2 id='st_warp'>Warp (resample) grids in stars objects to a new grid, possibly in an new coordinate reference system</h2><span id='topic+st_warp'></span>

<h3>Description</h3>

<p>Warp (resample) grids in stars objects to a new grid, possibly in an new coordinate reference system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_warp(
  src,
  dest,
  ...,
  crs = NA_crs_,
  cellsize = NA_real_,
  segments = 100,
  use_gdal = FALSE,
  options = character(0),
  no_data_value = NA_real_,
  debug = FALSE,
  method = "near",
  threshold = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_warp_+3A_src">src</code></td>
<td>
<p>object of class <code>stars</code> with source raster</p>
</td></tr>
<tr><td><code id="st_warp_+3A_dest">dest</code></td>
<td>
<p>object of class <code>stars</code> with target raster geometry</p>
</td></tr>
<tr><td><code id="st_warp_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_warp_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system for destination grid, only used when <code>dest</code> is missing</p>
</td></tr>
<tr><td><code id="st_warp_+3A_cellsize">cellsize</code></td>
<td>
<p>length 1 or 2 numeric; cellsize in target coordinate reference system units</p>
</td></tr>
<tr><td><code id="st_warp_+3A_segments">segments</code></td>
<td>
<p>(total) number of segments for segmentizing the bounding box before transforming to the new crs</p>
</td></tr>
<tr><td><code id="st_warp_+3A_use_gdal">use_gdal</code></td>
<td>
<p>logical; if <code>TRUE</code>, use gdal's warp or warper, through <a href="sf.html#topic+gdal_utils">gdal_utils</a></p>
</td></tr>
<tr><td><code id="st_warp_+3A_options">options</code></td>
<td>
<p>character vector with options, passed on to gdalwarp</p>
</td></tr>
<tr><td><code id="st_warp_+3A_no_data_value">no_data_value</code></td>
<td>
<p>value used by gdalwarp for no_data (NA) when writing to temporary file; 
not setting this when <code>use_gdal</code> is <code>TRUE</code> leads to a warning</p>
</td></tr>
<tr><td><code id="st_warp_+3A_debug">debug</code></td>
<td>
<p>logical; if <code>TRUE</code>, do not remove the temporary gdalwarp destination file, and print its name</p>
</td></tr>
<tr><td><code id="st_warp_+3A_method">method</code></td>
<td>
<p>character; see details for options; methods other than <code>near</code> only work when <code>use_gdal=TRUE</code></p>
</td></tr>
<tr><td><code id="st_warp_+3A_threshold">threshold</code></td>
<td>
<p>numeric; distance threshold for warping curvilinear grids: new cells at distances larger than threshold are assigned NA values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method</code> should be one of <code>near</code>, <code>bilinear</code>, <code>cubic</code>, <code>cubicspline</code>, <code>lanczos</code>, <code>average</code>, <code>mode</code>, <code>max</code>, <code>min</code>, <code>med</code>, <code>q1</code> or <code>q3</code>; see https://github.com/r-spatial/stars/issues/109
</p>
<p>For gridded spatial data (dimensions <code>x</code> and <code>y</code>), see figure; the existing grid is transformed into a regular grid defined by <code>dest</code>, possibly in a new coordinate reference system. If <code>dest</code> is not specified, but <code>crs</code> is, the procedure used to choose a target grid is similar to that of <a href="raster.html#topic+projectRaster">projectRaster</a>. This entails: (i) the envelope (bounding box polygon) is transformed into the new crs, possibly after segmentation (red box); (ii) a grid is formed in this new crs, touching the transformed envelope on its East and North side, with (if cellsize is not given) a cellsize similar to the cell size of <code>src</code>, with an extent that at least covers <code>x</code>; (iii) for each cell center of this new grid, the matching grid cell of <code>x</code> is used; if there is no match, an <code>NA</code> value is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geomatrix = system.file("tif/geomatrix.tif", package = "stars")
(x = read_stars(geomatrix))
new_crs = st_crs('OGC:CRS84')
y = st_warp(x, crs = new_crs)
plot(st_transform(st_as_sfc(st_bbox(x)), new_crs), col = NA, border = 'red')
plot(st_as_sfc(y, as_points=FALSE), col = NA, border = 'green', axes = TRUE, add = TRUE)
image(y, add = TRUE, nbreaks = 6)
plot(st_as_sfc(y, as_points=TRUE), pch=3, cex=.5, col = 'blue', add = TRUE)
plot(st_transform(st_as_sfc(x, as_points=FALSE), new_crs), add = TRUE)
# warp 0-360 raster to -180-180 raster:
r = read_stars(system.file("nc/reduced.nc", package = "stars"))
r %&gt;% st_set_crs('OGC:CRS84') %&gt;% st_warp(st_as_stars(st_bbox(), dx = 2)) -&gt; s
plot(r, axes = TRUE) # no CRS set, so no degree symbols in labels
plot(s, axes = TRUE)
# downsample raster (90 to 270 m)
r = read_stars(system.file("tif/olinda_dem_utm25s.tif", package = "stars"))
r270 = st_as_stars(st_bbox(r), dx = 270)
r270 = st_warp(r, r270)
</code></pre>

<hr>
<h2 id='st_xy2sfc'>replace x y raster dimensions with simple feature geometry list (points, or polygons = rasterize)</h2><span id='topic+st_xy2sfc'></span>

<h3>Description</h3>

<p>replace x y raster dimensions with simple feature geometry list (points, or polygons = rasterize)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_xy2sfc(x, as_points, ..., na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_xy2sfc_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="st_xy2sfc_+3A_as_points">as_points</code></td>
<td>
<p>logical; if <code>TRUE</code>, generate points at cell centers, else generate polygons</p>
</td></tr>
<tr><td><code id="st_xy2sfc_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>st_as_sfc</code></p>
</td></tr>
<tr><td><code id="st_xy2sfc_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; omit (remove) cells which are entirely missing valued (across other dimensions)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>stars</code> with x and y raster dimensions replaced by a single sfc geometry list column containing either points, or polygons. Adjacent cells with identical values are not merged; see <code>st_rasterize</code> for this.
</p>

<hr>
<h2 id='stars_sentinel2'>Sentinel-2 sample tile</h2><span id='topic+stars_sentinel2'></span>

<h3>Description</h3>

<p>Sentinel-2 sample tile, downloaded from https://scihub.copernicus.eu/
reads the four 10-m bands: B2 (490 nm), B3 (560 nm), B4 (665 nm) and B8 (842 nm)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stars_sentinel2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>stars_proxy</code> (inherits from <code>stars</code>) of dimension 10980 x 10980 x 4.
</p>

<hr>
<h2 id='stars_subset'>subset stars objects</h2><span id='topic+stars_subset'></span><span id='topic++5B+3C-.stars_proxy'></span><span id='topic++5B.stars'></span><span id='topic++5B+3C-.stars'></span><span id='topic+st_flip'></span>

<h3>Description</h3>

<p>subset stars objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'stars_proxy'
x[i, downsample = 0] &lt;- value

## S3 method for class 'stars'
x[i = TRUE, ..., drop = FALSE, crop = !is_curvilinear(x)]

## S3 replacement method for class 'stars'
x[i] &lt;- value

st_flip(x, which = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stars_subset_+3A_x">x</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="stars_subset_+3A_i">i</code></td>
<td>
<p>first selector: integer, logical or character vector indicating attributes to select, or object of class <code>sf</code>, <code>sfc</code>, <code>bbox</code>, or <code>stars</code> used as spatial selector; see details</p>
</td></tr>
<tr><td><code id="stars_subset_+3A_downsample">downsample</code></td>
<td>
<p>downsampling rate used in case <code>i</code> is a <code>stars_proxy</code> object</p>
</td></tr>
<tr><td><code id="stars_subset_+3A_value">value</code></td>
<td>
<p>array of dimensions equal to those in <code>x</code>, or a vector or value that will be recycled to such an array</p>
</td></tr>
<tr><td><code id="stars_subset_+3A_...">...</code></td>
<td>
<p>further (logical or integer vector) selectors, matched by order, to select on individual dimensions</p>
</td></tr>
<tr><td><code id="stars_subset_+3A_drop">drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, degenerate dimensions (with only one value) are dropped</p>
</td></tr>
<tr><td><code id="stars_subset_+3A_crop">crop</code></td>
<td>
<p>logical; if <code>TRUE</code> and parameter <code>i</code> is a spatial geometry (<code>sf</code> or <code>sfc</code>) object, the extent (bounding box) of the result is cropped to match the extent of <code>i</code> using <a href="#topic+st_crop">st_crop</a>. Cropping curvilinear grids is not supported.</p>
</td></tr>
<tr><td><code id="stars_subset_+3A_which">which</code></td>
<td>
<p>character or integer; dimension(s) to be flipped</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>i</code> is an object of class <code>sf</code>, <code>sfc</code> or <code>bbox</code>, the spatial subset covering this geometry is selected, possibly followed by cropping the extent. Array values for which the cell centre is not inside the geometry are assigned <code>NA</code>. If <code>i</code> is of class <code>stars</code>, and attributes of <code>i</code> are <code>logical</code>, cells in <code>x</code> corresponding to <code>NA</code> or <code>FALSE</code> cells in <code>i</code> are assigned an <code>NA</code>. Dimension ranges containing negative values or <code>NA</code> may be partially supported.
</p>
<p>in an assignment (or replacement form, <code>[&lt;-</code>), argument <code>i</code> needs to be either (i) a <code>stars</code> object with logical attribute(s) that has dimensions matching (possibly after recycling) those of <code>x</code>, in which case the <code>TRUE</code> cells will be replaced and <code>i</code> and/or <code>value</code> will be recycled to the dimensions of the arrays in <code>x</code>, or (ii) a length-one integer or character vector indicating which array to replace, in which case <code>value</code> may be stars object or a vector or array (that will be recycled).
</p>


<h3>Value</h3>

<p><code>st_flip</code> flips (reverts) the array values along the chosen dimension 
without(s) changing the dimension properties
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
x[,,,1:3] # select bands
x[,1:100,100:200,] # select x and y by range
x["L7_ETMs.tif"] # select attribute
xy = structure(list(x = c(293253.999046018, 296400.196497684), y = c(9113801.64775462,
9111328.49619133)), .Names = c("x", "y"))
pts = st_as_sf(data.frame(do.call(cbind, xy)), coords = c("x", "y"), crs = st_crs(x))
image(x, axes = TRUE)
plot(st_as_sfc(st_bbox(pts)), col = NA, add = TRUE)
bb = st_bbox(pts)
(xx = x[bb])
image(xx)
plot(st_as_sfc(bb), add = TRUE, col = NA)
image(x)
pt = st_point(c(x = 290462.103109179, y = 9114202.32594085))
buf = st_buffer(st_sfc(pt, crs = st_crs(x)), 1500)
plot(buf, add = TRUE)

buf = st_sfc(st_polygon(list(st_buffer(pt, 1500)[[1]], st_buffer(pt, 1000)[[1]])),
   crs = st_crs(x))
image(x[buf])
plot(buf, add = TRUE, col = NA)
image(x[buf, crop=FALSE])
plot(buf, add = TRUE, col = NA)
# with i of class stars:
x[x &gt; 75] # generates lots of NA's; pattern for each band
x[x[,,,1] &gt; 75] # recycles a single band template for all bands
x = read_stars(tif)
# replace, using a logical stars selector: cuts all values above 90 to 90
x[x &gt; 90] = 90
# replace a single attribute when there are more than one:
s = split(x)
names(s) = paste0("band", 1:6)
# rescale only band 1:
s[1] = s[1] * 0.75 
# rescale only attribute named "band2":
s["band2"] = s["band2"] * 0.85 
# create a new attribute from a numeric vector:
s["rnorm"] = rnorm(prod(dim(s))) 
s
lc = read_stars(system.file("tif/lc.tif", package = "stars"))
x = c(orig = lc, 
      flip_x = st_flip(lc, "x"), 
      flip_y = st_flip(lc, "y"), 
      flip_xy = st_flip(lc, c("x", "y")), 
      along = 3)
plot(x)
</code></pre>

<hr>
<h2 id='write_stars'>write stars object to gdal dataset (typically: to file)</h2><span id='topic+write_stars'></span><span id='topic+write_stars.stars'></span><span id='topic+write_stars.stars_proxy'></span><span id='topic+detect.driver'></span>

<h3>Description</h3>

<p>write stars object to gdal dataset (typically: to file)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_stars(obj, dsn, layer, ...)

## S3 method for class 'stars'
write_stars(
  obj,
  dsn,
  layer = 1,
  ...,
  driver = detect.driver(dsn),
  options = character(0),
  type = if (is.factor(obj[[1]]) &amp;&amp; length(levels(obj[[1]])) &lt; 256) "Byte" else "Float32",
  NA_value = NA_real_,
  update = FALSE,
  normalize_path = TRUE,
  scale_offset = c(1, 0)
)

## S3 method for class 'stars_proxy'
write_stars(
  obj,
  dsn,
  layer = 1,
  ...,
  driver = detect.driver(dsn),
  options = character(0),
  scale_offset = c(1, 0),
  type = "Float32",
  NA_value = NA_real_,
  chunk_size = c(dim(obj)[1], floor(2.5e+07/dim(obj)[1])),
  progress = TRUE
)

detect.driver(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_stars_+3A_obj">obj</code></td>
<td>
<p>object of class <code>stars</code></p>
</td></tr>
<tr><td><code id="write_stars_+3A_dsn">dsn</code></td>
<td>
<p>gdal dataset (file) name</p>
</td></tr>
<tr><td><code id="write_stars_+3A_layer">layer</code></td>
<td>
<p>attribute name; if missing, the first attribute is written</p>
</td></tr>
<tr><td><code id="write_stars_+3A_...">...</code></td>
<td>
<p>passed on to <a href="sf.html#topic+gdal">gdal_write</a></p>
</td></tr>
<tr><td><code id="write_stars_+3A_driver">driver</code></td>
<td>
<p>driver driver name; see <a href="sf.html#topic+st_drivers">st_drivers</a></p>
</td></tr>
<tr><td><code id="write_stars_+3A_options">options</code></td>
<td>
<p>character vector with dataset creation options, passed on to GDAL</p>
</td></tr>
<tr><td><code id="write_stars_+3A_type">type</code></td>
<td>
<p>character; output binary type, one of: <code>Byte</code> for eight bit unsigned integer, <code>UInt16</code> for sixteen bit unsigned integer, <code>Int16</code> for sixteen bit signed integer, <code>UInt32</code> for thirty two bit unsigned integer, <code>Int32</code> for thirty two bit signed integer, <code>Float32</code> for thirty two bit floating point, <code>Float64</code> for sixty four bit floating point.</p>
</td></tr>
<tr><td><code id="write_stars_+3A_na_value">NA_value</code></td>
<td>
<p>non-NA value that should represent R's <code>NA</code> value in the target raster file; if set to <code>NA</code>, it will be ignored.</p>
</td></tr>
<tr><td><code id="write_stars_+3A_update">update</code></td>
<td>
<p>logical; if <code>TRUE</code>, an existing file is being updated</p>
</td></tr>
<tr><td><code id="write_stars_+3A_normalize_path">normalize_path</code></td>
<td>
<p>logical; see <a href="#topic+read_stars">read_stars</a></p>
</td></tr>
<tr><td><code id="write_stars_+3A_scale_offset">scale_offset</code></td>
<td>
<p>length 2 numeric vector with scale, offset values: raw values computed by raw = (value - offset) / scale are written to dsn; scale and offset values are written to dsn or else a warning is raised</p>
</td></tr>
<tr><td><code id="write_stars_+3A_chunk_size">chunk_size</code></td>
<td>
<p>length two integer vector with the number of pixels (x, y) used in the read/write loop; see details.</p>
</td></tr>
<tr><td><code id="write_stars_+3A_progress">progress</code></td>
<td>
<p>logical; if <code>TRUE</code>, a progress bar is shown</p>
</td></tr>
<tr><td><code id="write_stars_+3A_filename">filename</code></td>
<td>
<p>character; used for guessing driver short name based on file 
extension; see examples</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>write_stars</code> first creates the target file, then updates it sequentially by writing blocks of <code>chunk_size</code>.
</p>
<p>in case <code>obj</code> is a multi-file <code>stars_proxy</code> object, all files are written as layers into the output file <code>dsn</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>detect.driver("L7_ETMs.tif")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
