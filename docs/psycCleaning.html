<!DOCTYPE html><html><head><title>Help for package psycCleaning</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {psycCleaning}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#center_grand_mean'><p>Center with respect to grand mean</p></a></li>
<li><a href='#center_group_mean'><p>Center with respect to group mean</p></a></li>
<li><a href='#center_mlm'><p>Centering for multilevel analyses</p></a></li>
<li><a href='#composite_score'><p>Composite column</p></a></li>
<li><a href='#dummy_coding'><p>Dummy Coding</p></a></li>
<li><a href='#effect_coding'><p>Effect Coding</p></a></li>
<li><a href='#listwise_deletion'><p>Listwise deletion</p></a></li>
<li><a href='#mlbook_data'><p>mlbook_data</p></a></li>
<li><a href='#recode_item'><p>Recode values of a data frame</p></a></li>
<li><a href='#summarize_missing_values'><p>Count the number of missing values</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#z_scored_grand_mean'><p>Grand mean z-score</p></a></li>
<li><a href='#z_scored_group_mean'><p>Z scored with with respect to the group mean</p></a></li>
<li><a href='#z_scored_mlm'><p>Z-scored for multilevel analyses</p></a></li>
<li><a href='#z_scored_mlm_categorical'><p>Z-scored for multilevel analyses</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Cleaning for Psychological Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Useful for preparing and cleaning data. It includes functions to center data, reverse coding, dummy code and effect code data, and more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, tidyr, tibble, data.table, rlang (&ge; 0.1.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxygen2, covr, misty, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jasonmoy28.github.io/psycCleaning/">https://jasonmoy28.github.io/psycCleaning/</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-04 20:21:58 UTC; Jasonmoy</td>
</tr>
<tr>
<td>Author:</td>
<td>Jason Moy <a href="https://orcid.org/0000-0001-8795-3311"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jason Moy &lt;jason.moyhj@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-05 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>no return value
</p>

<hr>
<h2 id='center_grand_mean'>Center with respect to grand mean</h2><span id='topic+center_grand_mean'></span>

<h3>Description</h3>

<p>This function will compute grand-mean-centered scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_grand_mean(data, cols, keep_original = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_grand_mean_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="center_grand_mean_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be centered. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="center_grand_mean_+3A_keep_original">keep_original</code></td>
<td>
<p>default is 'FALSE'. Set to 'TRUE' to keep original columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:  
1. Columns from .data will be preserved  
2. Columns with scores that are grand-mean-centered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>center_grand_mean(iris,where(is.numeric))

</code></pre>

<hr>
<h2 id='center_group_mean'>Center with respect to group mean</h2><span id='topic+center_group_mean'></span>

<h3>Description</h3>

<p>This function will compute group-mean-centered scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_group_mean(data, cols, group, keep_original = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_group_mean_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="center_group_mean_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be centered. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="center_group_mean_+3A_group">group</code></td>
<td>
<p>character. grouping variable</p>
</td></tr>
<tr><td><code id="center_group_mean_+3A_keep_original">keep_original</code></td>
<td>
<p>default is 'TRUE'. Set to 'FALSE' to remove original columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:  
1. Columns from .data will be preserved
2. Columns with scores that are group-mean centered
</p>


<h3>Examples</h3>

<pre><code class='language-R'>center_group_mean(iris,where(is.numeric), group = Species)

</code></pre>

<hr>
<h2 id='center_mlm'>Centering for multilevel analyses</h2><span id='topic+center_mlm'></span>

<h3>Description</h3>

<p>This function will group mean centered the scores at the level 1 and create a mean score for each group at L2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_mlm(data, cols, group, keep_original = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_mlm_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="center_mlm_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be centered. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="center_mlm_+3A_group">group</code></td>
<td>
<p>the grouping variable. Must be character.</p>
</td></tr>
<tr><td><code id="center_mlm_+3A_keep_original">keep_original</code></td>
<td>
<p>default is 'TRUE'. Set to 'FALSE' to remove original columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:  
1. Columns from .data will be preserved  
2. Columns with L1 scores that are group-mean centered.  
3. Columns with L2 aggregated means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>center_mlm(iris,dplyr::ends_with('Length'),group = 'Species')

</code></pre>

<hr>
<h2 id='composite_score'>Composite column</h2><span id='topic+composite_score'></span>

<h3>Description</h3>

<p>The function will perform a row-wise aggregation which then divided by the total number of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>composite_score(
  data,
  cols = dplyr::everything(),
  na.rm = FALSE,
  composite_col_name = "composited_column"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="composite_score_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="composite_score_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be composited See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="composite_score_+3A_na.rm">na.rm</code></td>
<td>
<p>Ignore NA. The default is 'FALSE'. If set to 'TRUE', the composite score will be 'NA' if there is one or more 'NA' in any of the columns.</p>
</td></tr>
<tr><td><code id="composite_score_+3A_composite_col_name">composite_col_name</code></td>
<td>
<p>Name for the new composited columns. Default is 'composite_column'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:
1. Columns from .data will be preserved.
2. Columns with composited scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_df = data.frame(col1 = c(1,2,3,4),col2 = c(1,2,3,4), col3 = c(1,2,NA,4))
composite_df = composite_score(data = test_df)


</code></pre>

<hr>
<h2 id='dummy_coding'>Dummy Coding</h2><span id='topic+dummy_coding'></span>

<h3>Description</h3>

<p>Create dummy-coded columns, supporting tidyselect syntax to process multiple columns simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_coding(data, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_coding_+3A_data">data</code></td>
<td>
<p>data.frame object</p>
</td></tr>
<tr><td><code id="dummy_coding_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be dummy-coded See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:
1. Columns from .data will be preserved.
2. Columns that are dummy-coded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dummy_coding(iris,Species)

</code></pre>

<hr>
<h2 id='effect_coding'>Effect Coding</h2><span id='topic+effect_coding'></span>

<h3>Description</h3>

<p>Create effect-coded columns, supporting tidyselect syntax to process multiple columns simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect_coding(data, cols, factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effect_coding_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="effect_coding_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be effect-coded. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="effect_coding_+3A_factor">factor</code></td>
<td>
<p>The default is 'FALSE'. If factor is set to 'TRUE', this function returns a tibble with effect-coded factors. If factor is set to 'FALSE', this function returns a tibble with effect-coded columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:
1. Columns from .data will be preserved.
2. Columns that are effect-coded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>effect_coding(iris,Species)

</code></pre>

<hr>
<h2 id='listwise_deletion'>Listwise deletion</h2><span id='topic+listwise_deletion'></span>

<h3>Description</h3>

<p>Perform listwise deletion (the entire rows is disregarded if the row has one 'NA' value)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listwise_deletion(data, cols = dplyr::everything())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listwise_deletion_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="listwise_deletion_+3A_cols">cols</code></td>
<td>
<p>Columns that need to use listwise deletion. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data with rows revmoed if the row has one 'NA' value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_df = data.frame(col1 = c(1,2,3),col2 = c(1,NA,3),col3 = c(1,2,NA))
listwise_deletion(test_df,col1:col2) # you can see that the row with NA in col3 is not deleted

</code></pre>

<hr>
<h2 id='mlbook_data'>mlbook_data</h2><span id='topic+mlbook_data'></span>

<h3>Description</h3>

<p>Classic data-set from Snijders, Tom A.B., and Bosker, Roel J. Multilevel Analysis: An Introduction to Basic and Advanced Multilevel Modeling, second edition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlbook_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 3758 rows and 34 variables:
</p>

<dl>
<dt>schoolnr</dt><dd><p>School ID</p>
</dd>
<dt>pupilNR_new</dt><dd><p>Student Identifier (Level 1 units)</p>
</dd>
<dt>langPOST</dt><dd><p>Student language score</p>
</dd>
<dt>ses</dt><dd><p>Student socioeconomic score, grand-mean centered (in points, M = 0))</p>
</dd>
<dt>IQ_verb</dt><dd><p>Student verbal IQ, grand-mean centered (in points, M = 0)</p>
</dd>
<dt>sex</dt><dd><p>Student binary gender, 1 = female, 0 = not female</p>
</dd>
<dt>Minority</dt><dd><p>Student minority status, 1 = minoritized, 0 = not minoritized</p>
</dd>
<dt>denomina</dt><dd><p>School-level religious denominations, 5 categories</p>
</dd>
<dt>female_dum</dt><dd><p>Dummy coded sex</p>
</dd>
<dt>female_eff</dt><dd><p>Effect-coded sex</p>
</dd>
<dt>female_CMC</dt><dd><p>Group-mean-centered of female_eff</p>
</dd>
<dt>fempct_agg</dt><dd><p>Aggregated mean female_dum for each school</p>
</dd>
<dt>Zfempct_agg</dt><dd><p>Z-scored aggregated mean female_dum for each school</p>
</dd>
<dt>ses_CMC</dt><dd><p>Group-mean-centered SES</p>
</dd>
<dt>Zses_CMC</dt><dd><p>Z-scored group-mean-centered SES</p>
</dd>
<dt>ses_agg</dt><dd><p>Aggregated mean SES for each school</p>
</dd>
<dt>Zses_agg</dt><dd><p>Z-scored aggregated mean SES for each school</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/mlbook.htm">https://www.stats.ox.ac.uk/~snijders/mlbook.htm</a>
</p>

<hr>
<h2 id='recode_item'>Recode values of a data frame</h2><span id='topic+recode_item'></span>

<h3>Description</h3>

<p>Recode values of a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_item(data, cols, code_from = NULL, code_to = NULL, retain_code = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_item_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="recode_item_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be recoded. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="recode_item_+3A_code_from">code_from</code></td>
<td>
<p>vector. the order must match with vector for 'code_to'</p>
</td></tr>
<tr><td><code id="recode_item_+3A_code_to">code_to</code></td>
<td>
<p>vector. the order must match with vector for 'code_from'</p>
</td></tr>
<tr><td><code id="recode_item_+3A_retain_code">retain_code</code></td>
<td>
<p>vector. Specify the values to be retain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:
1. Columns except the recoded columns from .data will be preserved
2. Recoded columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pre_recoded_df = tibble::tibble(x1 = 1:5, x2 = 5:1)
recoded_df = recode_item(pre_recoded_df, cols = dplyr::contains('x'),
                        code_from = 1:5,
                        code_to = 5:1)

</code></pre>

<hr>
<h2 id='summarize_missing_values'>Count the number of missing values</h2><span id='topic+summarize_missing_values'></span>

<h3>Description</h3>

<p>It counts the number of missing (i.e.,'NA') values in each column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_missing_values(
  data,
  cols = dplyr::everything(),
  group = NULL,
  verbose = TRUE,
  return_result = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_missing_values_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="summarize_missing_values_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be checked for missing values. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="summarize_missing_values_+3A_group">group</code></td>
<td>
<p>character. count missing values by group.</p>
</td></tr>
<tr><td><code id="summarize_missing_values_+3A_verbose">verbose</code></td>
<td>
<p>default is 'TRUE'. Print the missing value data frame</p>
</td></tr>
<tr><td><code id="summarize_missing_values_+3A_return_result">return_result</code></td>
<td>
<p>default is 'FALSE'. Return 'data_frame' if set to yes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. that specified the number of NA values of the columns (only when 'return_result = TRUE')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 = data.frame(col1 = c(1,2,3),col2 = c(1,NA,3),col3 = c(1,2,NA))
summarize_missing_values(df1,everything())

</code></pre>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+expr'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+.data'></span><span id='topic++3A+3D'></span><span id='topic+as_name'></span><span id='topic+as_label'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="rlang.html#topic+sym">sym</a>()</code> creates a symbol from a string and
<code><a href="rlang.html#topic+sym">syms</a>()</code> creates a list of symbols from a
character vector.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">enquo</a>()</code> and
<code><a href="rlang.html#topic+nse-defuse">enquos</a>()</code> delay the execution of one or
several function arguments. <code>enquo()</code> returns a single quoted
expression, which is like a blueprint for the delayed computation.
<code>enquos()</code> returns a list of such quoted expressions.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">expr</a>()</code> quotes a new expression <em>locally</em>. It
is mostly useful to build new expressions around arguments
captured with <code><a href="#topic+enquo">enquo()</a></code> or <code><a href="#topic+enquos">enquos()</a></code>:
<code>expr(mean(!!enquo(arg), na.rm = TRUE))</code>.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+as_name">as_name</a>()</code> transforms a quoted variable name
into a string. Supplying something else than a quoted variable
name is an error.
</p>
<p>That's unlike <code><a href="rlang.html#topic+as_label">as_label</a>()</code> which also returns
a single string but supports any kind of R object as input,
including quoted function calls and vectors. Its purpose is to
summarise that object into a single label. That label is often
suitable as a default name.
</p>
<p>If you don't know what a quoted expression contains (for instance
expressions captured with <code>enquo()</code> could be a variable
name, a call to a function, or an unquoted constant), then use
<code>as_label()</code>. If you know you have quoted a simple variable
name, or would like to enforce this, use <code>as_name()</code>.
</p>
</li></ul>

<p>To learn more about tidy eval and how to use these tools, visit
<a href="https://www.tidyverse.org">https://www.tidyverse.org</a> and the
<a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming
section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a>.
</p>


<h3>Value</h3>

<p>no return value
</p>

<hr>
<h2 id='z_scored_grand_mean'>Grand mean z-score</h2><span id='topic+z_scored_grand_mean'></span>

<h3>Description</h3>

<p>This function will compute z-scores with respect to the grand mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_scored_grand_mean(data, cols, keep_original = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z_scored_grand_mean_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="z_scored_grand_mean_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be centered. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="z_scored_grand_mean_+3A_keep_original">keep_original</code></td>
<td>
<p>default is 'FALSE'. Set to 'TRUE' to keep original columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:
1. Columns from .data will be preserved
2. Columns with scores that are z-scored
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z_scored_grand_mean(iris,where(is.numeric))

</code></pre>

<hr>
<h2 id='z_scored_group_mean'>Z scored with with respect to the group mean</h2><span id='topic+z_scored_group_mean'></span>

<h3>Description</h3>

<p>This function will compute group-mean-centered scores, and then z-scored the group-mean-centered scores with respect to the grand mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_scored_group_mean(data, cols, group, keep_original = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z_scored_group_mean_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="z_scored_group_mean_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be centered. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="z_scored_group_mean_+3A_group">group</code></td>
<td>
<p>the grouping variable. If you need to pass multiple group variables, try to use quos(). Passing multiple group variables is not tested.</p>
</td></tr>
<tr><td><code id="z_scored_group_mean_+3A_keep_original">keep_original</code></td>
<td>
<p>default is 'FALSE'. Set to 'TRUE' to keep original columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a dataframe with the columns z-scored (replace existing columns)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z_scored_group_mean(iris, dplyr::ends_with("Petal.Width"), "Species")
</code></pre>

<hr>
<h2 id='z_scored_mlm'>Z-scored for multilevel analyses</h2><span id='topic+z_scored_mlm'></span>

<h3>Description</h3>

<p>This function will group mean centered the scores at the level 1 and create an aggregated mean score for each group at L2. 
After that, the group-mean-centered L1 scores and mean L2 scores will be z-scored with respect to the grand mean. 
Please see 'center_mlm' if you want to use the version without the z-scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_scored_mlm(data, cols, group, keep_original = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z_scored_mlm_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="z_scored_mlm_+3A_cols">cols</code></td>
<td>
<p>Columns that need to be centered. See 'dplyr::dplyr_tidy_select' for available options.</p>
</td></tr>
<tr><td><code id="z_scored_mlm_+3A_group">group</code></td>
<td>
<p>The grouping/cluster variable.</p>
</td></tr>
<tr><td><code id="z_scored_mlm_+3A_keep_original">keep_original</code></td>
<td>
<p>default is 'TRUE'. Set to 'FALSE' to remove original columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:
1. Columns from .data will be preserved  
2. Columns with L1 scores that are group-mean centered then grand-mean z-scored.
3. Columns with L2 aggregated means that are z-scored
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z_scored_mlm(iris,dplyr::ends_with('Length'),group = 'Species')

</code></pre>

<hr>
<h2 id='z_scored_mlm_categorical'>Z-scored for multilevel analyses</h2><span id='topic+z_scored_mlm_categorical'></span>

<h3>Description</h3>

<p>This is a specialized function for mean centering categorical variables. There are two cases where this function should be used instead of the generic 'center_mlm'. 
1. This function should be used when you need group mean centering for non-dummy-coded variables at L1. Variables at L2 are always dummy-coded as they represent the percentage of subjects in that group.
2. This function should be used whenever you want to z-score the aggregated L2 means
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_scored_mlm_categorical(
  data,
  cols,
  dummy_coded = NA,
  group,
  keep_original = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z_scored_mlm_categorical_+3A_data">data</code></td>
<td>
<p>A data.frame or a data.frame extension (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="z_scored_mlm_categorical_+3A_cols">cols</code></td>
<td>
<p>Dummy-coded or effect-coded columns for group-mean centering. Support 'dplyr::dplyr_tidy_select' options.</p>
</td></tr>
<tr><td><code id="z_scored_mlm_categorical_+3A_dummy_coded">dummy_coded</code></td>
<td>
<p>Dummy-coded variables (cannot be effect-coded) for L2 aggregated means. Support 'dplyr::dplyr_tidy_select' options.</p>
</td></tr>
<tr><td><code id="z_scored_mlm_categorical_+3A_group">group</code></td>
<td>
<p>the grouping variable. Must be character</p>
</td></tr>
<tr><td><code id="z_scored_mlm_categorical_+3A_keep_original">keep_original</code></td>
<td>
<p>default is 'FALSE'. Set to 'TRUE' to keep original columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as .data. The output has the following properties:
1. Columns from .data will be preserved
2. Columns with L1 scores that are group-mean centered 
3. Columns with L2 aggregated means (i.e., percentage) that are z-scored
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z_scored_mlm_categorical(mlbook_data,cols='female_eff',dummy_coded='female_dum','schoolnr')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
