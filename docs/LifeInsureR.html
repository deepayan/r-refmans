<!DOCTYPE html><html><head><title>Help for package LifeInsureR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LifeInsureR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#age.exactRounded'><p>Calculate the age of the insured based on exact age at contract closing, rounded</p>
to the nearest birthday.</a></li>
<li><a href='#age.yearDifference'><p>Calculate the age of the insured based on the difference of the bith year and</p>
contract closing year.</a></li>
<li><a href='#applyHook'><p>If <code>hook</code> is a function, apply it to <code>val</code>, otherwise return <code>val</code> unchanged</p></a></li>
<li><a href='#CalculationSingleEnum-class'><p>Enum to define how much of a contract needs to be calculated automatically.</p></a></li>
<li><a href='#contractGrid'><p>Create a grid of InsuranceContract objects or premiums with each axis representing one varying parameter</p></a></li>
<li><a href='#costs.baseAlpha'><p>Helper function to define base costs with base alpha, but otherwise unchanged costs</p></a></li>
<li><a href='#costs.scaleAlpha'><p>Helper function to modify alpha costs of an insurance contract individually</p></a></li>
<li><a href='#costsDisplayTable'><p>Helper function to display all cost definitions in a concise table</p></a></li>
<li><a href='#costValuesAsDF'><p>Convert the multi-dimensional costs array to a data.frame for output to a file</p></a></li>
<li><a href='#deathBenefit.annuityDecreasing'><p>Describes the death benefit of a decreasing whole life insurance (after a possible deferall period)</p></a></li>
<li><a href='#deathBenefit.linearDecreasing'><p>Describes the death benefit of a linearly decreasing whole life insurance (after a possible deferall period)</p></a></li>
<li><a href='#exportInsuranceContract.xlsx'><p>Export an insurance contract (object of class InsuranceContract) to an 'Excel' file</p></a></li>
<li><a href='#exportInsuranceContractExample'><p>Export the example calculations of an insurance contract</p></a></li>
<li><a href='#fallbackFields'><p>Replace missing values in ields by default fallback values</p></a></li>
<li><a href='#fillFields'><p>Overwrite all existing fields with default values given</p></a></li>
<li><a href='#fillNAgaps'><p>Replace all <code>NA</code> entries of a vector with the previous non-NA value</p></a></li>
<li><a href='#filterProfitRates'><p>Filter the whole data.frame of profit rates for the given profit classes</p></a></li>
<li><a href='#freqCharge'><p>Defines a frequency charge (surcharge for monthly/quarterly/semiannual) premium payments</p></a></li>
<li><a href='#head0'><p>Set all entries of the given vector to 0 up until index 'start'</p></a></li>
<li><a href='#initializeCosts'><p>Initialize or modify a data structure for the definition of InsuranceTarif costs</p></a></li>
<li><a href='#InsuranceContract'><p>Base Class for Insurance Contracts</p></a></li>
<li><a href='#InsuranceContract.ParameterDefaults'><p>Default parameters for the InsuranceContract class.</p></a></li>
<li><a href='#InsuranceContract.ParametersFallback'><p>Use fallback values for missing contract parameters</p></a></li>
<li><a href='#InsuranceContract.ParametersFill'><p>Initialize the insurance contract parameters from passed arguments</p></a></li>
<li><a href='#InsuranceContract.ParameterStructure'><p>Full insurance contract parameter structure.</p></a></li>
<li><a href='#InsuranceContract.Values'><p>Data structure (filled only with NULL) for insurance contract class member values.</p></a></li>
<li><a href='#InsuranceTarif'><p>Base class for traditional Insurance Tarifs (with fixed guarantee, profit</p>
sharing and no unit-linked component)</a></li>
<li><a href='#isRegularPremiumContract'><p>Determine whether a contract (given all parameters) is a contract with regular premiums</p></a></li>
<li><a href='#isSinglePremiumContract'><p>Determine whether a contract (given all parameters) is a single-premium contract or with regular premiums</p></a></li>
<li><a href='#makeContractGridDimname'><p>Create human-readable labels for the dimensions in a <code>contractGrid()</code></p></a></li>
<li><a href='#pad0'><p>Pad a vector with 0 to a desired length</p></a></li>
<li><a href='#padLast'><p>Pad the vector <code>v</code> to length <code>l</code> by repeating the last entry of the</p>
vector.</a></li>
<li><a href='#PaymentTimeSingleEnum-class'><p>Enum to describe when a benefit or premium payment is due (in advance or in arrears)</p></a></li>
<li><a href='#premiumRefundPeriod.default'><p>Default premium refund period: for deferred contracts the deferral period, otherwise the whole contract</p></a></li>
<li><a href='#ProfitComponentsMultipleEnum-class'><p>Enum to define the different components of profit participation.</p></a></li>
<li><a href='#ProfitParticipation'><p>Base Class for Profit Participation Schemes</p></a></li>
<li><a href='#ProfitParticipationFunctions'><p>Helper functions for profit participation</p></a></li>
<li><a href='#PVfactory'><p>PVfactory (R6Class for present values with arbitrary dimensions)</p></a></li>
<li><a href='#rollingmean'><p>Calculate the rolling mean of length 2</p></a></li>
<li><a href='#setCost'><p>Update one component of an InsuranceTarif's cost structure</p></a></li>
<li><a href='#SexSingleEnum-class'><p>Enum to describe possible sexes in an insurance contract or tariff.</p></a></li>
<li><a href='#showVmGlgExamples'><p>Display insurance contract calculation example</p></a></li>
<li><a href='#TariffTypeSingleEnum-class'><p>An enum specifying the main characteristics of the tarif.</p></a></li>
<li><a href='#testVmGlgExample'><p>Perform unit tests of given standard values of the insurance contract example</p></a></li>
<li><a href='#valueOrFunction'><p>If <code>val</code> is a function, evaluate it, otherwise return <code>val</code></p></a></li>
<li><a href='#vmGlgExample.generateTest'><p>Generate testthat output for unit-testing a tarif implementation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Modelling Traditional Life Insurance Contracts</td>
</tr>
<tr>
<td>Description:</td>
<td>R6 classes to model traditional life insurance
    contracts like annuities, whole life insurances or endowments. Such life
    insurance contracts provide a guaranteed interest and are not directly linked
    to the performance of a particular investment vehicle, but they typically
    provide (discretionary) profit participation. This package provides a framework
    to model such contracts in a very generic (cash-flow-based) way and includes
    modelling profit participation schemes, dynamic increases or more general
    contract layers, as well as contract changes (like sum increases or premium
    waivers). All relevant quantities like premium decomposition, reserves and 
    benefits over the whole contract period are calculated and potentially 
    exported to 'Excel'. Mortality rates are given using the 'MortalityTables' package.</td>
</tr>
<tr>
<td>Author:</td>
<td>Reinhold Kainhofer [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Reinhold Kainhofer &lt;reinhold@kainhofer.com&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, MortalityTables, objectProperties, lubridate, openxlsx,
dplyr, scales, abind, stringr, methods, rlang, rmarkdown,
kableExtra, pander, tidyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'HelperFunctions.R' 'InsuranceParameters.R'
'ProfitParticipation_Functions.R' 'ProfitParticipation.R'
'InsuranceTarif.R' 'InsuranceContract.R' 'contractGrid.R'
'create_LIR_project.R' 'exportInsuranceContract_xlsx.R'
'showVmGlgExamples.R' 'exportInsuranceContractExample.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, magrittr, tibble, testthat, fs</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.open-tools.net/R/LifeInsureR">https://gitlab.open-tools.net/R/LifeInsureR</a>,
<a href="https://github.com/kainhofer/LifeInsureR">https://github.com/kainhofer/LifeInsureR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.open-tools.net/R/LifeInsureR/-/issues">https://gitlab.open-tools.net/R/LifeInsureR/-/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-27 15:52:02 UTC; 036134</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-06 18:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='age.exactRounded'>Calculate the age of the insured based on exact age at contract closing, rounded
to the nearest birthday.</h2><span id='topic+age.exactRounded'></span>

<h3>Description</h3>

<p>Calculate the age of the insured based on exact age at contract closing, rounded
to the nearest birthday.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age.exactRounded(params, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age.exactRounded_+3A_params">params</code></td>
<td>
<p>The parameters of the contract.</p>
</td></tr>
<tr><td><code id="age.exactRounded_+3A_values">values</code></td>
<td>
<p>Unused by default (already calculated values of the contract)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting age
</p>

<hr>
<h2 id='age.yearDifference'>Calculate the age of the insured based on the difference of the bith year and
contract closing year.</h2><span id='topic+age.yearDifference'></span>

<h3>Description</h3>

<p>Calculate the age of the insured based on the difference of the bith year and
contract closing year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age.yearDifference(params, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age.yearDifference_+3A_params">params</code></td>
<td>
<p>The parameters of the contract.</p>
</td></tr>
<tr><td><code id="age.yearDifference_+3A_values">values</code></td>
<td>
<p>Unused by default (already calculated values of the contract)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting age
</p>

<hr>
<h2 id='applyHook'>If <code>hook</code> is a function, apply it to <code>val</code>, otherwise return <code>val</code> unchanged</h2><span id='topic+applyHook'></span>

<h3>Description</h3>

<p>If <code>hook</code> is a function, apply it to <code>val</code>, otherwise return <code>val</code> unchanged
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyHook(hook, val, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyHook_+3A_hook">hook</code></td>
<td>
<p>(optional) function to apply to <code>val</code> and the other parameters</p>
</td></tr>
<tr><td><code id="applyHook_+3A_val">val</code></td>
<td>
<p>The value to which the hook is applied (ifgiven)</p>
</td></tr>
<tr><td><code id="applyHook_+3A_...">...</code></td>
<td>
<p>optional parameters passed to the hook function (if it is a function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value with the hook function applied (if a function) or unchanged otherwiese
</p>


<h3>Examples</h3>

<pre><code class='language-R'>applyHook(NULL, 3) # returns 3 unchanged
applyHook(function(x) 2*x, 3) # applies the function, returns 6
applyHook(`+`, 3, 1) # returns 4
</code></pre>

<hr>
<h2 id='CalculationSingleEnum-class'>Enum to define how much of a contract needs to be calculated automatically.</h2><span id='topic+CalculationSingleEnum-class'></span><span id='topic+CalculationEnum'></span>

<h3>Description</h3>

<p>Enum to define how much of a contract needs to be calculated automatically.
</p>


<h3>Details</h3>

<p>When an <a href="#topic+InsuranceContract">InsuranceContract</a> object is created, all time series are immediately
calculated. However, sometimes, one only needs part of the values, so it
would be a waste of resources to calculate e.g. all future reserves and
profit participation, if only premiums are of interest.
</p>
<p>Possible values are:
</p>

<ul>
<li><p> &quot;all&quot;
</p>
</li>
<li><p> &quot;probabilities&quot;
</p>
</li>
<li><p> &quot;cashflows&quot;
</p>
</li>
<li><p> &quot;presentvalues&quot;
</p>
</li>
<li><p> &quot;premiums&quot;
</p>
</li>
<li><p> &quot;absvalues&quot;
</p>
</li>
<li><p> &quot;reserves&quot;
</p>
</li>
<li><p> &quot;premiumcomposition&quot;
</p>
</li>
<li><p> &quot;profitparticipation&quot;
</p>
</li>
<li><p> &quot;history&quot;
</p>
</li></ul>


<hr>
<h2 id='contractGrid'>Create a grid of InsuranceContract objects or premiums with each axis representing one varying parameter</h2><span id='topic+contractGrid'></span><span id='topic+contractGridPremium'></span>

<h3>Description</h3>

<p>The function <code>contractGrid</code> creates a (two- or multi-dimensional) grid
of InsuranceContract objects, where each axis represents one of the insurance
parameters varying as given in the <code>axes</code> argument (as a named list).
</p>
<p>The function <code>contractGridPremium</code> returns a grid of premiums as requested in
the <code>premium</code> parameter rather than the full InsuranceContract objects.
It is a convenience wrapper around <code>contractGrid</code> and is recommended if
one is only interested in a grid of one particular value (typically some
kind of premium).
The function <code>contractGridPremium</code> can also be used on an existing
<code>contractGrid</code>-generated grid of contracts to extract grid of numerical
values of the specified premiums. If no contract grid is passed to
<code>contractGridPremium</code>, <code>contractGrid</code> will be called to create it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contractGrid(
  axes = list(age = seq(20, 60, 10), policyPeriod = seq(5, 35, 5)),
  YOB = NULL,
  observationYear = NULL,
  ...
)

contractGridPremium(
  contractGrid = NULL,
  premium = "written",
  .fun = function(cntr) {
     cntr$Values$premiums[[premium]]
 },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contractGrid_+3A_axes">axes</code></td>
<td>
<p>List of paramters spanning the dimensions of the grid.</p>
</td></tr>
<tr><td><code id="contractGrid_+3A_yob">YOB</code></td>
<td>
<p>optional year of bith. If missing, the <code>observationYear</code> and the contract's age</p>
</td></tr>
<tr><td><code id="contractGrid_+3A_observationyear">observationYear</code></td>
<td>
<p>The observation year, for which the grid shall be calculated. If given, the YOB is calculated from it, otherwise the contract's YOB is used</p>
</td></tr>
<tr><td><code id="contractGrid_+3A_...">...</code></td>
<td>
<p>In <code>contractGrid</code>: Additional parameters to be passed to <a href="../../LifeInsureR/html/InsuranceContract.html#method-new"><code>InsuranceContract$new()</code></a>; In <code>contractGridPremium</code>: Additional parameters to be passed to <code>contractGrid</code>.</p>
</td></tr>
<tr><td><code id="contractGrid_+3A_contractgrid">contractGrid</code></td>
<td>
<p>(optional) existing contract grid from which to derive
premiums. If not given, <a href="#topic+contractGrid">contractGrid</a> is called with all parameters, so
<code>...</code> should contain an <code>axes</code> argument in that case.</p>
</td></tr>
<tr><td><code id="contractGrid_+3A_premium">premium</code></td>
<td>
<p>The type of premium to derive (key of the <code>contract$Values$premiums</code> list.</p>
</td></tr>
<tr><td><code id="contractGrid_+3A_.fun">.fun</code></td>
<td>
<p>The function to extract the desired premium from a contract
object. By default it accesses the premium vector and extracts the
type of premium given in the <code>premium</code> parameter. One can,
however pass any other extractor function to access e.g. reserves,
cash flows etc. at any desired time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>contractGrid</code> will return the full <a href="#topic+InsuranceContract">InsuranceContract</a>
objects, so apply can later be used to extract premiums, reserves and other
values to display in a grid. For this feature, one can also use the convenience
function <code>contractGridPremium</code>.
</p>
<p>The <code>axes</code> list describing the parameters changing along the axes of the
resulting grid is internally expanded with <code><a href="base.html#topic+expand.grid">expand.grid()</a></code>. The resulting flat
list of parameter (together with the fixed parameters passed as <code>...</code>)
is then passed to the <a href="../../LifeInsureR/html/InsuranceContract.html#method-new"><code>InsuranceContract$new()</code></a> call to create the corresponding
contract object.
</p>
<p>To create the human-readable row-/columnnames of the resulting array,
the function <code><a href="#topic+makeContractGridDimname">makeContractGridDimname()</a></code> for each value of the axes, allowing
human-readable representations e.g. of a tariff or a mortality table as
the dimension label.
</p>


<h3>Value</h3>

<p>multi-dimensional array of insurance contracts (dimensions defined by the axes argument)
</p>
<p>a array of premiums (or other contract-specific value) for the grid defined by the <code>axes</code> argument to <code>contractGrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MortalityTables")
mortalityTables.load("Austria_Annuities_AVOe2005R")
# A trivial deferred annuity tariff with no costs, premiums during whole 
# deferral period, 30 years annuity payments:
tariff = InsuranceTarif$new(name="Test Annuity", type="annuity", tarif = "Annuity 1A",
    mortalityTable = AVOe2005R.unisex, i=0.01, 
    deferralPeriod = function(params, ...) { params$ContractData$premiumPeriod }, 
    policyPeriod = function(params, ...) { params$ContractData$premiumPeriod + 30 }
)
contractGrid(
    axes = list(
        age = seq(20, 60, 10),
        premiumPeriod = seq(5,30, 5)
    ),
    tarif = tariff,
    sumInsured = 1000,
    contractClosing = as.Date("2023-11-01")
)

</code></pre>

<hr>
<h2 id='costs.baseAlpha'>Helper function to define base costs with base alpha, but otherwise unchanged costs</h2><span id='topic+costs.baseAlpha'></span>

<h3>Description</h3>

<p>Returns a function that sets base alpha (and Zillmer) costs to the given value,
but otherwise uses the full costs defined by the Costs parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costs.baseAlpha(alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costs.baseAlpha_+3A_alpha">alpha</code></td>
<td>
<p>The minimum alpha / Zillmer cost that cannot be waived</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be set as minCosts parameter for a tariff and makes sure
that only alpha costs are modified / waived, but no other costs.
</p>

<hr>
<h2 id='costs.scaleAlpha'>Helper function to modify alpha costs of an insurance contract individually</h2><span id='topic+costs.scaleAlpha'></span>

<h3>Description</h3>

<p>Returns a function that modifies alpha (and Zillmer) costs by the given scale,
but otherwise uses the full costs defined by the Costs parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costs.scaleAlpha(scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costs.scaleAlpha_+3A_scale">scale</code></td>
<td>
<p>The scale for  alpha / Zillmer cost</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be set as adjustCosts or adjustMinCosts hook parameters
for a tariff or contract and can be used to apply cost adjustments on a
per-contract basis.
</p>

<hr>
<h2 id='costsDisplayTable'>Helper function to display all cost definitions in a concise table</h2><span id='topic+costsDisplayTable'></span>

<h3>Description</h3>

<p>Returns a data.frame with columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costsDisplayTable(costs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costsDisplayTable_+3A_costs">costs</code></td>
<td>
<p>The cost structure to be displayed in a concise table style.</p>
</td></tr>
</table>

<hr>
<h2 id='costValuesAsDF'>Convert the multi-dimensional costs array to a data.frame for output to a file</h2><span id='topic+costValuesAsDF'></span>

<h3>Description</h3>

<p>Convert the cost values array to a tx15 matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costValuesAsDF(costValues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costValuesAsDF_+3A_costvalues">costValues</code></td>
<td>
<p>Cost definition data structure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
Convert the array containing cost values like cashflows, present
values, etc. (objects of dimension tx5x3) to a matrix with dimensions (tx15)
</p>

<hr>
<h2 id='deathBenefit.annuityDecreasing'>Describes the death benefit of a decreasing whole life insurance (after a possible deferall period)</h2><span id='topic+deathBenefit.annuityDecreasing'></span>

<h3>Description</h3>

<p>The death benefit will be the full sumInsured for the first year after the
deferral period and then decrease like an annuity to 0 at the end of the policyPeriod.
This can be used with the <code>deathBenefit</code> parameter for insurance
contracts, but should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deathBenefit.annuityDecreasing(interest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deathBenefit.annuityDecreasing_+3A_interest">interest</code></td>
<td>
<p>The interest rate of the loan, which is underlying the insurance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a mere generator function, which takes the interest rate and
generates a function that describes a decreasing annuity.
</p>
<p>The generated function has the following parameters:
</p>

<dl>
<dt>len</dt><dd><p>The desired length of the Cash flow vector (can be shorter than
the policyPeriod, if q_x=1 before the end of the contract, e.g.
for life-long insurances)</p>
</dd>
<dt>params</dt><dd><p>The full parameter set of the insurance contract (including
all inherited values from the tariff and the profit participation)</p>
</dd>
<dt>values</dt><dd><p>The values calculated from the insurance contract so far</p>
</dd>
</dl>



<h3>Value</h3>

<p>vector of decreasing death benefits
</p>

<hr>
<h2 id='deathBenefit.linearDecreasing'>Describes the death benefit of a linearly decreasing whole life insurance (after a possible deferall period)</h2><span id='topic+deathBenefit.linearDecreasing'></span>

<h3>Description</h3>

<p>The death benefit will be the full sumInsured for the first year after the
deferral period and then decrease linearly to 0 at the end of the policyPeriod.
This can be used with the <code>deathBenefit</code> parameter for insurance
contracts, but should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deathBenefit.linearDecreasing(len, params, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deathBenefit.linearDecreasing_+3A_len">len</code></td>
<td>
<p>The desired length of the Cash flow vector (can be shorter than
the policyPeriod, if q_x=1 before the end of the contract, e.g.
for life-long insurances)</p>
</td></tr>
<tr><td><code id="deathBenefit.linearDecreasing_+3A_params">params</code></td>
<td>
<p>The full parameter set of the insurance contract (including
all inherited values from the tariff and the profit participation)</p>
</td></tr>
<tr><td><code id="deathBenefit.linearDecreasing_+3A_values">values</code></td>
<td>
<p>The values calculated from the insurance contract so far</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of linearly decreasing benefits over the whole insurance coverage period
</p>

<hr>
<h2 id='exportInsuranceContract.xlsx'>Export an insurance contract (object of class <a href="#topic+InsuranceContract">InsuranceContract</a>) to an 'Excel' file</h2><span id='topic+exportInsuranceContract.xlsx'></span>

<h3>Description</h3>

<p>Export an insurance contract (object of class <a href="#topic+InsuranceContract">InsuranceContract</a>) to an 'Excel' file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportInsuranceContract.xlsx(contract, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportInsuranceContract.xlsx_+3A_contract">contract</code></td>
<td>
<p>The insurance contract to export</p>
</td></tr>
<tr><td><code id="exportInsuranceContract.xlsx_+3A_filename">filename</code></td>
<td>
<p>Target 'Excel' file name for export</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>exportInsuranceContract.xlsx</code> exports an object
of class <a href="#topic+InsuranceContract">InsuranceContract</a> to an 'Excel' file. All basic data, as well as
the time series of (absolute and unit) cash flows, reserves, premiums, premium
composition and all profit participation scenarios are exported to the file
in nicely looking tables.
</p>
<p>No new calculations are done in this function. It only prints out the values
stored in <code>contract$Values</code>.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MortalityTables")
mortalityTables.load("Austria_Annuities_AVOe2005R")
# A trivial deferred annuity tariff with no costs:
tariff = InsuranceTarif$new(name = "Test Annuity", type = "annuity", tarif = "Annuity 1A",
    mortalityTable = AVOe2005R.unisex, i=0.01)
contract = InsuranceContract$new(
    tariff,
    age = 35, YOB = 1981,
    policyPeriod = 30, premiumPeriod = 15, deferralPeriod = 15,
    sumInsured = 1000,
    contractClosing = as.Date("2016-10-01")
);
exportInsuranceContract.xlsx(contract, tempfile("Example_annuity_contract", fileext = ".xlsx"))
</code></pre>

<hr>
<h2 id='exportInsuranceContractExample'>Export the example calculations of an insurance contract</h2><span id='topic+exportInsuranceContractExample'></span>

<h3>Description</h3>

<p>Export the given contract to 'Excel' (full history/timeseries of all cash
flows, reserves, premiums, etc.) and to a text file (sample calculation
required by the Austrian regulation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportInsuranceContractExample(
  contract,
  prf = 10,
  outdir = ".",
  basename = NULL,
  extraname = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportInsuranceContractExample_+3A_contract">contract</code></td>
<td>
<p>The <code><a href="#topic+InsuranceContract">InsuranceContract</a></code> object to be exported</p>
</td></tr>
<tr><td><code id="exportInsuranceContractExample_+3A_prf">prf</code></td>
<td>
<p>The time of the premium waiver</p>
</td></tr>
<tr><td><code id="exportInsuranceContractExample_+3A_outdir">outdir</code></td>
<td>
<p>The output directory (the file names are not configurable)</p>
</td></tr>
<tr><td><code id="exportInsuranceContractExample_+3A_basename">basename</code></td>
<td>
<p>The base output filename (sans .xlsx). If missing, a name of
the form 2020-08-01_TARIFNAME_EXTRANAME_RZ0.01_x35_YoB1977_LZ45_PrZ20_VS100000
is used. If given, the main contract without modification will be
exported to basename.xlsx, while the example with premium waiver will be
exported to basename_PremiumWaiver_t10.xlsx and the text file containing
the examples required by the LV-VMGV is exported to basename_VmGlg.txt.</p>
</td></tr>
<tr><td><code id="exportInsuranceContractExample_+3A_extraname">extraname</code></td>
<td>
<p>If basename is not given, this allows a suffix to distinguish
multiple exports.</p>
</td></tr>
<tr><td><code id="exportInsuranceContractExample_+3A_...">...</code></td>
<td>
<p>Further parameters (passed on to <code><a href="#topic+showVmGlgExamples">showVmGlgExamples</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three output files are generated:
</p>

<ul>
<li><p> {DATE}_{TARIFF}_Example.xlsx: Full history/timeseries
</p>
</li>
<li><p> {DATE}_{TARIFF}_Example_PremiumWaiver_t10.xlsx: Full history/timeseries
after a premium waiver at the given time <code>prf</code>
</p>
</li>
<li><p> {DATE}_{TARIFF}_Examples_VmGlg.txt: Example calculation required for the
Austrian regulation (LV-VMGLV)
</p>
</li></ul>



<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MortalityTables")
mortalityTables.load("Austria_Annuities_AVOe2005R")
# A trivial deferred annuity tariff with no costs:
tariff = InsuranceTarif$new(name="Test Annuity", type="annuity", tarif = "Annuity 1A",
    mortalityTable = AVOe2005R.unisex, i=0.01)
contract = InsuranceContract$new(
    tariff,
    age = 35, YOB = 1981,
    policyPeriod = 30, premiumPeriod = 15, deferralPeriod = 15,
    sumInsured = 1000,
    contractClosing = as.Date("2016-10-01")
);
exportInsuranceContractExample(contract, prf = 10, outdir = tempdir())

</code></pre>

<hr>
<h2 id='fallbackFields'>Replace missing values in ields by default fallback values</h2><span id='topic+fallbackFields'></span>

<h3>Description</h3>

<p>Replace all missing values in fields (either missing or NA) with
their corresponding values from fallback. Members in fallback that are missing
in fields are inserted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fallbackFields(fields, valuelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fallbackFields_+3A_fields">fields</code></td>
<td>
<p>existing list</p>
</td></tr>
<tr><td><code id="fallbackFields_+3A_valuelist">valuelist</code></td>
<td>
<p>list of fields to replace in <code>fields</code>. Only keys that are missing in <code>fields</code> are added, no existing fields in <code>fields</code> are overwritten</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fields with missing values filled from the fallback data
</p>

<hr>
<h2 id='fillFields'>Overwrite all existing fields with default values given</h2><span id='topic+fillFields'></span>

<h3>Description</h3>

<p>Overwrite all existing fields in the first argument with
values given in valuelist. Members of valuelist that are not yet in
fields are ignored. This allows a huge valuelist to be used to fill
fields in multiple lists with given structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillFields(fields, valuelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillFields_+3A_fields">fields</code></td>
<td>
<p>existing list</p>
</td></tr>
<tr><td><code id="fillFields_+3A_valuelist">valuelist</code></td>
<td>
<p>list of fields to replace in <code>fields</code>. Only keys that exist in <code>fields</code> are overwritten, no new fields are added to <code>fields</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated fields list
</p>

<hr>
<h2 id='fillNAgaps'>Replace all <code>NA</code> entries of a vector with the previous non-NA value</h2><span id='topic+fillNAgaps'></span>

<h3>Description</h3>

<p>Sometimes one has a vector with some gaps (<code>NA</code>) values, which cause
problems for several numeric functions. This function <code>fillNAgaps</code> fills
these missing values by inserting the last preceeding non-NA-value. Leading
NA values (at the start of the vector will not be modified). If the
argument <code>firstBack = TRUE</code>, leading <code>NA</code>-values are replaced by
the first non-NA value.
Trailing NAs are always replaced by the last previous NA-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillNAgaps(x, firstBack = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillNAgaps_+3A_x">x</code></td>
<td>
<p>The vector where NA-values should be filled by repeating the last preceeding non-NA value</p>
</td></tr>
<tr><td><code id="fillNAgaps_+3A_firstback">firstBack</code></td>
<td>
<p>if <code>TRUE</code>, leading NAs are replaced by the first non-NA
value in the vector, otherwise leading NAs are left untouched.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code was taken from the R Cookbook:
http://www.cookbook-r.com/Manipulating_data/Filling_in_NAs_with_last_non-NA_value/
LICENSE (from that page): The R code is freely available for use without any restrictions.
In other words: you may reuse the R code for any purpose (and under any license).
</p>


<h3>Value</h3>

<p>vector with NAs properly replaced
</p>

<hr>
<h2 id='filterProfitRates'>Filter the whole data.frame of profit rates for the given profit classes</h2><span id='topic+filterProfitRates'></span>

<h3>Description</h3>

<p>This is a rather trivial helper function, which just calls <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterProfitRates(rates, classes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterProfitRates_+3A_rates">rates</code></td>
<td>
<p>data.frame containing all profit rates for multiple profit classes</p>
</td></tr>
<tr><td><code id="filterProfitRates_+3A_classes">classes</code></td>
<td>
<p>the profit classes, for which rates should be extracted</p>
</td></tr>
</table>

<hr>
<h2 id='freqCharge'>Defines a frequency charge (surcharge for monthly/quarterly/semiannual) premium payments</h2><span id='topic+freqCharge'></span>

<h3>Description</h3>

<p>Tariffs are typically calculated with yearly premium installments. When
premiums are paid more often then one a year (in advance), the insurance
receives part of the premium later (or not at all in case of death), so a
surcharge for premium payment frequencies higher than yearly is applied to
the  premium, typically in the form of a percentage of the premium.
</p>
<p>This function generates the internal data structure to define surcharges for
monthly, quarterly and semiannual premium payments. The given surcharges can
be either given as percentage points (e.g. 1.5 means 1.5% = 0.015) or as
fractions of 1 (i.e. 0.015 also means 1.5% surcharge). The heuristics applied
to distinguish percentage points and fractions is that all values larger than 0.1
are understood as percentage points and values 0.1 and lower are understood
as fractions of 1.
As a consequence, a frequency charge of 10% or more MUST be given as percentage points.
</p>
<p>Currently, the frequency charges are internally represented as a named list,
<code>list("1" = 0, "2" = 0.01, "4" = 0.02, "12" = 0.03)</code>, but that might
change in the future, so it is advised to use this function rather than
explicitly using the named list in your code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqCharge(monthly = 0, quarterly = 0, semiannually = 0, yearly = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqCharge_+3A_monthly">monthly</code></td>
<td>
<p>Surcharge for monthly premium payments</p>
</td></tr>
<tr><td><code id="freqCharge_+3A_quarterly">quarterly</code></td>
<td>
<p>Surcharge for quarterly premium payments</p>
</td></tr>
<tr><td><code id="freqCharge_+3A_semiannually">semiannually</code></td>
<td>
<p>Surcharge for semi-annual premium payments</p>
</td></tr>
<tr><td><code id="freqCharge_+3A_yearly">yearly</code></td>
<td>
<p>Surcharge for yearly premium payments (optiona, default is no surcharge)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of surcharges for names 1 (yearly), 2 (semiannually), 4 (quarterly) and 12 (monthly) payments
</p>

<hr>
<h2 id='head0'>Set all entries of the given vector to 0 up until index 'start'</h2><span id='topic+head0'></span>

<h3>Description</h3>

<p>Set all entries of the given vector to 0 up until index 'start'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head0(v, start = 0, value.start = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head0_+3A_v">v</code></td>
<td>
<p>the vector to modify</p>
</td></tr>
<tr><td><code id="head0_+3A_start">start</code></td>
<td>
<p>how many leading elements to zero out</p>
</td></tr>
<tr><td><code id="head0_+3A_value.start">value.start</code></td>
<td>
<p>the value to insert before the start index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector <code>v</code> with the first <code>start</code> elements replaced by 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head0(1:10, 3)
</code></pre>

<hr>
<h2 id='initializeCosts'>Initialize or modify a data structure for the definition of <a href="#topic+InsuranceTarif">InsuranceTarif</a> costs</h2><span id='topic+initializeCosts'></span>

<h3>Description</h3>

<p>Initialize a cost matrix with dimensions: {CostType, Basis, Period}, where:
</p>

<dl>
<dt>CostType:</dt><dd><p>alpha, Zillmer, beta, gamma, gamma_nopremiums, unitcosts</p>
</dd>
<dt>Basis:</dt><dd><p>SumInsured, SumPremiums, GrossPremium, NetPremium, Benefits, Constant</p>
</dd>
<dt>Period:</dt><dd><p>once, PremiumPeriod, PremiumFree, PolicyPeriod, CommissionPeriod</p>
</dd>
</dl>

<p>This cost structure can then be modified for non-standard costs using the <code><a href="#topic+setCost">setCost()</a></code> function.
The main purpose of this structure is to be passed to <a href="#topic+InsuranceContract">InsuranceContract</a> or
<a href="#topic+InsuranceTarif">InsuranceTarif</a> definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initializeCosts(
  costs,
  alpha,
  Zillmer,
  alpha.commission,
  beta,
  gamma,
  gamma.paidUp,
  gamma.premiumfree,
  gamma.contract,
  gamma.afterdeath,
  gamma.fullcontract,
  unitcosts,
  unitcosts.PolicyPeriod
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initializeCosts_+3A_costs">costs</code></td>
<td>
<p>(optional) existing cost structure to duplicate / use as a starting point</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_alpha">alpha</code></td>
<td>
<p>Alpha costs (charged once, relative to sum of premiums)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_zillmer">Zillmer</code></td>
<td>
<p>Zillmer costs (charged once, relative to sum of premiums)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_alpha.commission">alpha.commission</code></td>
<td>
<p>Alpha costs (charged during the commission period,
relative to sum of premiums; Use the <code>commissionPeriod</code>
and <code>alphaCostsCommission</code> contract parameters
to set the length of the commission period and whether
the <code>alpha.commission</code> valÂ´ue is understood as yearly
cost or the sum or present value of the commission
charges over the whole commission period)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_beta">beta</code></td>
<td>
<p>Collection costs (charged on each gross premium, relative to gross premium)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_gamma">gamma</code></td>
<td>
<p>Administration costs while premiums are paid (relative to sum insured)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_gamma.paidup">gamma.paidUp</code></td>
<td>
<p>Administration costs for paid-up contracts (relative to sum insured)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_gamma.premiumfree">gamma.premiumfree</code></td>
<td>
<p>Administration costs for planned premium-free period (reltaive to sum insured)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_gamma.contract">gamma.contract</code></td>
<td>
<p>Administration costs for the whole contract period (relative to sum insured)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_gamma.afterdeath">gamma.afterdeath</code></td>
<td>
<p>Administration costs after the insured person has dies (for term-fix insurances)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_gamma.fullcontract">gamma.fullcontract</code></td>
<td>
<p>Administration costs for the full contract period,
even if the insured has already dies (for term-fix insurances)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_unitcosts">unitcosts</code></td>
<td>
<p>Unit costs (absolute monetary amount, during premium period)</p>
</td></tr>
<tr><td><code id="initializeCosts_+3A_unitcosts.policyperiod">unitcosts.PolicyPeriod</code></td>
<td>
<p>Unit costs (absolute monetary amount, during full contract period)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an insurance cost structure (multi-dimensional matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># empty cost structure (only 0 costs)
initializeCosts()

# the most common cost types can be given in initializeCosts()
initializeCosts(alpha = 0.04, Zillmer = 0.025, beta = 0.05, gamma.contract = 0.001)

# The same cost structure manually
costs.Bsp = initializeCosts();
costs.Bsp[["alpha", "SumPremiums", "once"]] = 0.04;
costs.Bsp[["Zillmer", "SumPremiums", "once"]] = 0.025;
costs.Bsp[["beta", "GrossPremium", "PremiumPeriod"]] = 0.05;
costs.Bsp[["gamma", "SumInsured", "PolicyPeriod"]] = 0.001;

# The same structure using the setCost() function:
library(magrittr)
costs.Bsp = initializeCosts() %&gt;%
  setCost("alpha", "SumPremiums", "once", 0.04) %&gt;%
  setCost("Zillmer", "SumPremiums", "once", 0.025) %&gt;%
  setCost("beta", "GrossPremium", "PremiumPeriod", 0.05) %&gt;%
  setCost("gamma", "SumInsured", "PolicyPeriod", 0.001)




</code></pre>

<hr>
<h2 id='InsuranceContract'>Base Class for Insurance Contracts</h2><span id='topic+InsuranceContract'></span>

<h3>Description</h3>

<p>Base Class for Insurance Contracts
</p>
<p>Base Class for Insurance Contracts
</p>


<h3>Details</h3>

<p>R6 class that models a complete, general insurance contract.
The corresponding tariff and the profit participation scheme, as well as
all other relevant contract parameters (if not defined by the tariff or
explicitly overridden by the contract) can be given in the constructor.
</p>


<h3>Usage</h3>

<p>The typical usage of this class is to simply call
<a href="#method-new"><code>InsuranceContract$new()</code></a>.
</p>
<p>All parameters from the <a href="#topic+InsuranceContract.ParameterDefaults">InsuranceContract.ParameterDefaults</a> can be passed
to the constructor of the class (i.e. the <a href="#method-new"><code>InsuranceContract$new()</code></a>-call).
Parameters not explicitly given, will be taken from the tariff or as a fall-back
mechanism from the <a href="#topic+InsuranceContract.ParameterDefaults">InsuranceContract.ParameterDefaults</a> defaults.
</p>
<p>Immediately upon construction, all premiums, reserves and cash flows for the
whole contract period are calculated and can be accessed via the <code>Values</code>
field of the object.
</p>


<h3>Calculation approach: Valuation</h3>

<p>The calculation of all contract values is controlled by the function
<a href="#method-calculateContract"><code>InsuranceContract$calculateContract()</code></a> (using methods of the <a href="#topic+InsuranceTarif">InsuranceTarif</a>
object) and follows the following logic:
</p>

<ol>
<li><p> First the <strong>contingent (unit) cash flows</strong> and the <strong>transition probbilities</strong>
are determined.
</p>
</li>
<li><p> The <strong>actuarial equivalence principle</strong> states that at time of inception, the
(net and gross) premium must be determined in a way that the present value
of the future benefits and costs minus the present value of the future premiums
must be equal, i.e. in expectation the future premiums ove the whole lifetime
of the contract will exactly cover the benefits and costs. Similarly, at all
later time steps, the difference between these two present values needs to be
reserved (i.e. has already been paid by the customer by previous premiums).
</p>
</li>
<li><p> This allows the premiums to be calculated by first calculating the <strong>present
values</strong> for all of the <strong>benefit and costs cash flow</strong> vectors.
</p>
</li>
<li><p> The formulas
to calculate the gross, Zillmer and net <strong>premiums</strong> involve simple linear
combinations of these present values, so the <strong>coefficients of these formulas</strong>
are determined next.
</p>
</li>
<li><p> With the coefficients of the premium formulas calculated, all <strong>premiums
can be calculated</strong> (first the gross premium, because due to potential gross
premium refunds in case of death, the formula for the net premium requires
the gross premium, which the formula for the gross premium involves no other
type of premuim).
</p>
</li>
<li><p> With premiums determined, all unit cash flows and unit present values can
now be expressed in monetary terms / as <strong>absolute cash flows</strong> (i.e. the actual Euro-amount that flows
rather than a percentage).
</p>
</li>
<li><p> As described above, the difference between the present values of premiums
and present values of benefits and costs is defined as the required amount
of reserves, so the <strong>reserves (net, gross, administration cost, balance sheet)</strong>
and all values derived from them (i.e. surrender value, sum insured in case of
premium waiver, etc.) are calculated.
</p>
</li>
<li><p> The <strong>decomposition of the premium</strong> into parts dedicated to specific purposes
(tax, rebates, net premium, gross premium, Zillmer premium, cost components,
risk premium, savings premium, etc.) can be done once the reserves are
ready (since e.g. the savings premium is defined as the difference of
discounted reserves at times $t$ and $t+1$).
</p>
</li>
<li><p> If the contract has <strong>(discretionary or obligatory) profit sharing</strong>B mechanisms
included, the corresponding <a href="#topic+ProfitParticipation">ProfitParticipation</a> object can calculate that
profit sharing amounts, once all guaranteed values are calculated. This can
also be triggered manually (with custom profit sharing rates) by calling
the methods <a href="#method-profitScenario"><code>InsuranceContract$profitScenario()</code></a>]
or <a href="#method-addProfitScenario"><code>InsuranceContract$addProfitScenario()</code></a>.
</p>
</li></ol>



<h3>Calculation approach: Cash Flows</h3>

<p>An insurance contract is basically defined by the (unit) cash flows it produces:
</p>

<ul>
<li> <p><strong>Premium payments</strong> (in advance or in arrears) at each timestep
</p>
</li>
<li> <p><strong>Survival payments</strong> at each timestep
</p>
</li>
<li> <p><strong>Guaranteed payments</strong> at each timestep
</p>
</li>
<li> <p><strong>Death benefits</strong> at each timestep
</p>
</li>
<li> <p><strong>Disease benefits</strong> at each timestep
</p>
</li></ul>

<p>Together with the transition probabilities (mortalityTable parameter)
the present values can be calculated, from which the premiums follow and
finally the reserves and a potential profit sharing.
</p>
<p>For example, a <em><strong>term life insurance with regular premiums</strong></em> would have the following
cash flows:
</p>

<ul>
<li><p> premium cash flows: 1, 1, 1, 1, 1, ...
</p>
</li>
<li><p> survival cash flows: 0, 0, 0, 0, 0, ...
</p>
</li>
<li><p> guaranteed cash flows: 0, 0, 0, 0, 0, ...
</p>
</li>
<li><p> death benefit cash flows: 1, 1, 1, 1, 1, ...
</p>
</li></ul>

<p>A <em><strong>single-premium term life insurance</strong></em> would look similar, except for the premiums:
</p>

<ul>
<li><p> premium cash flows: 1, 0, 0, 0, 0, ...
</p>
</li></ul>

<p>A <em><strong>pure endowment</strong></em> has no death benefits, but a survival benefit of 1 at the
maturity of the contract:
</p>

<ul>
<li><p> premium cash flows: 1, 1, 1, 1, 1, ...
</p>
</li>
<li><p> survival cash flows: 0, 0, ..., 0, 1
</p>
</li>
<li><p> guaranteed cash flows: 0, 0, 0, 0, 0, ...
</p>
</li>
<li><p> death benefit cash flows: 0, 0, 0, 0, 0, ...
</p>
</li></ul>

<p>An <em><strong>endowment</strong></em> has also death benefits during the contract duration:
</p>

<ul>
<li><p> premium cash flows: 1, 1, 1, 1, 1, ...
</p>
</li>
<li><p> survival cash flows: 0, 0, ..., 0, 1
</p>
</li>
<li><p> guaranteed cash flows: 0, 0, 0, 0, 0, ...
</p>
</li>
<li><p> death benefit cash flows: 1, 1, 1, 1, 1, ...
</p>
</li></ul>

<p>A <em><strong>(deferred) annuity</strong>B</em> has premium cash flows only during the deferral peroid
and only survival cash flows during the annuity payment phase. Often, in case
of death during the deferral period, all premiums paid are refunded as a death
benefit.:
</p>

<ul>
<li><p> premium cash flows: 1, 1, ...,  1, 0, 0, 0, ...
</p>
</li>
<li><p> survival cash flows: 0, 0, ..., 0, 1, 1, 1,...
</p>
</li>
<li><p> guaranteed cash flows: 0, 0, 0, 0, 0, ...
</p>
</li>
<li><p> death benefit cash flows: 1, 2, 3, 4, 5, ..., 0, 0, ...
</p>
</li></ul>

<p>A <em><strong>terme-fix insurance</strong></em> has a guaranteed payment at maturity, even if the insured
has already died. The premiums, however, are only paid until death (which is
not reflected in the contingent cash flows, but rather in the transition
probabilities):
</p>

<ul>
<li><p> premium cash flows: 1, 1, 1, 1, ...,  1
</p>
</li>
<li><p> survival cash flows: 0, 0, 0, 0, ..., 0
</p>
</li>
<li><p> guaranteed cash flows: 0, 0, 0, ..., 0, 1
</p>
</li>
<li><p> death benefit cash flows: 0, 0, 0, 0, ..., 0
</p>
</li></ul>

<p>The <code>InsuranceContract$new()</code> function creates a new
insurance contract for the given tariff, using the parameters passed
to the function (and the defaults specified in the tariff).
</p>
<p>As soon as this function is called, the contract object calculates
all time series (cash flows, premiums, reserves, profit participation)
for the whole contract duration.
</p>
<p>The most important parameters that are typically passed to the
constructor are:
</p>

<ul>
<li> <p><code>age</code> ... Age of the insured person (used to derive mortalities / transition probabilities)
</p>
</li>
<li> <p><code>policyPeriod</code> ... Maturity of the policy (in years)
</p>
</li>
<li> <p><code>premiumPeriod</code> ... How long premiums are paid (<code>premiumPeriod = 1</code>
for single-premium contracts, <code>premiumPeriod</code> equals
<code>policyPeriod</code> for regular premium payments for the whole
contract period, while other premium payment durations indicate
premium payments only for shorter periods than the whole contract
duration. Contract extensions without any premium payments are
indicated by <code>premiumPeriod</code>=0). Default is equal to
<code>policyPeriod</code>
</p>
</li>
<li> <p><code>sumInsured</code> ... The sum insured (i.e. survival benefit for
endowments, death benefit for whole/term life insurances,
annuity payments for annuities)
</p>
</li>
<li> <p><code>contractClosing</code> ... Date of the contract beginning (typically
created using something like <code>as.Date("2020-08-01")</code>)
</p>
</li>
<li> <p><code>YOB</code> ... Year of birth of the insured (for cohort mortality
tables). If not given, YOB is derived from <code>age</code> and
<code>contractClosing</code>.
</p>
</li>
<li> <p><code>deferralPeriod</code> ... Deferral period for deferred annuities
(i.e. when annuity payments start at a future point in time).
Default is 0.
</p>
</li>
<li> <p><code>premiumFrequency</code> ... How many premium payments per year are
made (e.g. 1 for yearly premiums, 4 for quarterly premiumd,
12 for monthly premium payments). Default is 1 (yearly premiums).
</p>
</li></ul>

<p>While these are the most common and most important parameters, all
parameters can be overwritten on a per-contract basis, even those
that are defined by the tariff. For a full list and explanation of all
parameters, see <a href="#topic+InsuranceContract.ParameterDefaults">InsuranceContract.ParameterDefaults</a>.
</p>
<p>The <code>InsuranceContract$addHistorySnapshot()</code> function
adds the current (or the explicitly given) state of the contract
(parameters, calculated values, tarif, list of all contract blocks)
to the history list (available in the <code>history</code> field of the
contract, i.e. <code>InsuranceContract$history</code>).
</p>
<p>Contracts with multiple contract blocks (typically either
contracts with dynamic increases, sum increases or protection riders)
are constructed by instantiating the child block (e.g. a single
dynamic increase or the rider) independently with its own (shorter)
duration and then inserting it into the parent contract with this
function at the given time.
</p>
<p>If no <a href="#topic+InsuranceContract">InsuranceContract</a> object is passed as <code>block</code>, a copy
of the parent is created with overriding parameters given in <code>...</code>.
</p>
<p>This method adds a new contract block describing a dynamic
or sum increase (increasing the sum insured at a later time
$t$ than contract inception). This increase is modelled by a
separate <a href="#topic+InsuranceContract">InsuranceContract</a> object with the sum difference
as its own <code>sumInsured</code>.
</p>
<div class="sourceCode"><pre>     By default, all parameters are taken from the main contract,
     with the maturity adjusted to match the original contract's
     maturity.

     The main contract holds all child blocks, controls their
     valueation and aggregates all children's values to the
     total values of the overall contract.
</pre></div>
<p>When a contract expires, this function adds a follow-up contract
(with either the same or a different tariff), using the existing
reserve as <code>additionalCapital</code> at inception.
Technically, a child block using the new contract data of the extension
is added to the original contract. The over-all contract values are then
the sum of the original contract (providing values until expiration)
and the extension (providing values after the extension).
</p>
<p>This method calculates all contract values (potentially
starting from and preserving all values before a later time
<code>valuesFrom</code>). This function is not meant to be called
directly, but internally, whenever a contract is created or
modified.
</p>
<div class="sourceCode"><pre>     There is, however, a legitimate case to call this function
     when a contract was initially created with a value of
     \code{calculate} other than "all", so not all values of the
     contract were calculated. When one later needs more values
     than were initially calculated, this function can be called.
     However, any contract changes might need to be rolled back
     and reapplied again afterwards. So even in this case it is
     probably easier to create the contract object from scratch
     again.
</pre></div>
<p>This function is an internal function for contracts with
multiple child blocks (dynamic increases, sum increases, riders).
It takes the values from all child blocks and calculates the
overall values from all child blocks aggregated.
</p>
<div class="sourceCode"><pre>   This function should not be called manually.
</pre></div>
<p>This function modifies the contract at time $t$ so that
no further premiums are paid (i.e. a paid-up contract) and the
<code>sumInsured</code> is adjusted according to the existing reserves.
</p>
<p>This function calculates one profit scenario with the
provided profit participation parameters (all parameters
not given in the call are taken from their values of the
contract, profit participation scheme or tariff).
</p>
<p>This function calculates one profit scenario with the
provided profit participation parameters (all parameters
not given in the call are taken from their values of the
contract, profit participation scheme or tariff). The results
are stored in a list of profit scenarios inside the contract.
</p>
<div class="sourceCode"><pre>    This function can be chained to calculate and add multiple
    profit scenarios.
</pre></div>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>tarif</code></dt><dd><p>The <a href="#topic+InsuranceTarif">InsuranceTarif</a> underlying this contract. The tarif is the abstract
product description (i.e. defining the type of insurance, fixing tpyes
of benefits, specifying costs, guaranteed interest rate, mortality tables,
potential profit sharing mechanisms, etc.), while the contract holds
the individual parts like age, sum insured, contract duration, premium
payment frequency, etc.</p>
</dd>
<dt><code>parent</code></dt><dd><p>A pointer to the parent contract. Some contracts consist of multiple
parts (e.g. a main savings contract with a dread-disease rider, or
a contract with multiple dynamic increases). These are internally
represented by one <a href="#topic+InsuranceContract">InsuranceContract</a> object per contract part, plus
one contract object combining them and deriving combined premiums,
reserves and profit participation. The child contracts (i.e. the
objects representing the individual parts) have a pointer to their
parent, while the overall contract holds a list of all its child contract parts.</p>
</dd>
<dt><code>ContractParameters</code></dt><dd><p>Insurance contract parameters explicitly specified in the contract
(i.e. parameters that are NOT taken from the tariff of the defaults).</p>
</dd>
<dt><code>Parameters</code></dt><dd><p>Full set of insurance contract parameters applying to this contract.
The set of parameters is a combination of explicitly given (contract-specific)
values, parameters determined by the tariff and default values.</p>
</dd>
<dt><code>Values</code></dt><dd><p>List of all contract values (cash flows, present values, premiums,
reserves, premium decomposition, profit participation, etc.). These
values will be calculated and filled when the contract is created
and updated whenever the contract is changed.</p>
</dd>
<dt><code>blocks</code></dt><dd><p>For contracts with multiple contract parts: List of all tariff blocks
(independently calculated <a href="#topic+InsuranceContract">InsuranceContract</a> objects, that are combined
to one contract, e.g. dynamic/sum increases). If this field is empty,
this object describes a contract block (calculated as a stand-alone
tariff), otherwise it will simply be the sum of its blocks (adjusted
to span the same time periods)</p>
</dd>
<dt><code>history</code></dt><dd><p>A list keeping track of all contract changes (including the whole
contract state and its values before the change).</p>
</dd>
<dt><code>dummy.public</code></dt><dd><p>dummy field to allow a trailing comma after the previous field/method</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-InsuranceContract-new"><code>InsuranceContract$new()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-addHistorySnapshot"><code>InsuranceContract$addHistorySnapshot()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-addBlock"><code>InsuranceContract$addBlock()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-addDynamics"><code>InsuranceContract$addDynamics()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-addExtension"><code>InsuranceContract$addExtension()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-calculateContract"><code>InsuranceContract$calculateContract()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-consolidateBlocks"><code>InsuranceContract$consolidateBlocks()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-premiumWaiver"><code>InsuranceContract$premiumWaiver()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-profitScenario"><code>InsuranceContract$profitScenario()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-addProfitScenario"><code>InsuranceContract$addProfitScenario()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceContract-clone"><code>InsuranceContract$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-InsuranceContract-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new insurance contract (for the given tariff/product) and calculate all time series
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$new(
  tarif,
  parent = NULL,
  calculate = "all",
  profitid = "default",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tarif</code></dt><dd><p>The <a href="#topic+InsuranceTarif">InsuranceTarif</a> object describing the Tariff/Product
and providing defaults for the parameters.</p>
</dd>
<dt><code>parent</code></dt><dd><p>For contracts with multiple contract blocks (dynamic
increases, sum increases, riders), each child is created with
a pointer to its parent. NULL for single-block contracts or
for the overall-contract of a multi-block contract. This
parameter is used internally, but should not be used in
user-written code.</p>
</dd>
<dt><code>calculate</code></dt><dd><p>how much of the contract's time series need to be
calculated. See <a href="#topic+CalculationEnum">CalculationEnum</a> for all possible values. This
is usefull to prevent calculation of e.g. reserves and profit
participation, when one only wants to create a grid of premiums.</p>
</dd>
<dt><code>profitid</code></dt><dd><p>The ID of the default profit participation scenario.
The default profit participation scenario uses the default
values passed, while further scenarios can be added by
<a href="#method-addProfitScenario"><code>InsuranceContract$addProfitScenario()</code></a>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Further parameters (age, sum insured, contract closing /
begin, premium payment details, etc.) of the contract, which
can also override parameters defined at the tariff-level.
Possible values are all sub-fields of the
<a href="#topic+InsuranceContract.ParameterDefaults">InsuranceContract.ParameterDefaults</a> data structure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InsuranceContract-addHistorySnapshot"></a>



<h4>Method <code>addHistorySnapshot()</code></h4>

<p>Add the current state of the contract to the history list
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$addHistorySnapshot(
  time = 0,
  comment = "Initial contract values",
  type = "Contract",
  params = self$Parameters,
  values = self$Values,
  tarif = self$tarif,
  blocks = self$blocks
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>time</code></dt><dd><p>the time described by the snapshot</p>
</dd>
<dt><code>comment</code></dt><dd><p>a comment to store together with the contract state</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of action that caused a history snapshot to
be stored. Typical values are &quot;Contract&quot; to describe the initial
contract, &quot;Premium Waiver&quot; or &quot;Dynamic Increase&quot;.</p>
</dd>
<dt><code>params</code></dt><dd><p>The set of params to be stored in the history snapshot
(default is <code>self$Parameters</code>, if not explicitly given)</p>
</dd>
<dt><code>values</code></dt><dd><p>The calculated time series of all contract values
calculated so far. Default is <code>self$Values</code>, if not
explicitly given</p>
</dd>
<dt><code>tarif</code></dt><dd><p>The underlying <a href="#topic+InsuranceTarif">InsuranceTarif</a> object describing the
Product/Tariff. Default is <code>self$tarif</code>, if not explicitly given.</p>
</dd>
<dt><code>blocks</code></dt><dd><p>The list of all contract children for contracts with
multiple insurance blocks (e.g. dynamic increases, riders, etc.)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># TODO
</pre>
</div>


<hr>
<a id="method-InsuranceContract-addBlock"></a>



<h4>Method <code>addBlock()</code></h4>

<p>Add a child contract block (e.g. a dynamic increase or a rider) to an insurance contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$addBlock(
  id = NULL,
  block = NULL,
  t = block$Values$int$blockStart,
  comment = paste0("Additional block at time t=", t),
  blockType = "Dynamics",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The identifier of the child block to be inserted</p>
</dd>
<dt><code>block</code></dt><dd><p>The <a href="#topic+InsuranceContract">InsuranceContract</a> object describing the child block.
If NULL (or not given at all), a copy of the parent will be
created.</p>
</dd>
<dt><code>t</code></dt><dd><p>Then the child block starts, relative to the parent block.
The child block is calculated independently (with time 0
describing its own start), so when aggregating all values from
the individual blocks to overall values for the whole contract,
the child's values need to be translated to the parent contracts's
time frame using this parameter</p>
</dd>
<dt><code>comment</code></dt><dd><p>The comment to use in the history snapshot.</p>
</dd>
<dt><code>blockType</code></dt><dd><p>The type of block to be added (e.g. Dynamics, Extension,
etc.). Can be any (short) string.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters to be passed to <a href="#method-new"><code>InsuranceContract$new()</code></a> when
<code>block</code> is not given and a copy of the parent should be
created with overrides.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># TODO
</pre>
</div>


<hr>
<a id="method-InsuranceContract-addDynamics"></a>



<h4>Method <code>addDynamics()</code></h4>

<p>Add a dynamic increase with the same parameters as the main contract part
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$addDynamics(t, NewSumInsured, SumInsuredDelta, id, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>The time within the main contract when the sum increase happens.
The <a href="#topic+InsuranceContract">InsuranceContract</a> object describing the dynamic increase
will still internally start at its own time 0, but the
aggregation by the main contract will correctly offset to
the time $t$ within the main contract.</p>
</dd>
<dt><code>NewSumInsured</code></dt><dd><p>The over-all new sum insured (sum of original
contract and all dynamica increaeses). The <code>sumInsured</code>
of the new dynamic increase block will be determined as the
difference of the old and new overall sum insured. Alternatively,
it can directly be given as the <code>SumInsuredDelta</code>
argument instead.</p>
</dd>
<dt><code>SumInsuredDelta</code></dt><dd><p>The sum insured of only the dynamic increase,
i.e. the sumInsured of the dynamic contract block only. The
overall sum insured will increase by this amount. Only one of
<code>NewSumInsured</code> and <code>SumInsuredDelta</code> is needed,
the other one will be calculated accordingly. If both are
given, the <code>SumInsuredDelta</code> will take precedence.</p>
</dd>
<dt><code>id</code></dt><dd><p>The identifier of the contract block describing the dynamic
increase. This is a free-form string that should be unique
within the list of child blocks. It will be displayed in the
'Excel' export feature and in the history snapshot list.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters to override in the dynamic block. By default,
all parameters of the main contract block will be used, but
they can be overridden per dynamic increase block.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># TODO
</pre>
</div>


<hr>
<a id="method-InsuranceContract-addExtension"></a>



<h4>Method <code>addExtension()</code></h4>

<p>Add a contract extension after the contract has ended
(existing reserve is used as initial capital of the follow-up contract).
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$addExtension(
  id = NULL,
  t = NULL,
  comment = paste0("Contract extension at time t=", t),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The identifier of the child block to be inserted</p>
</dd>
<dt><code>t</code></dt><dd><p>The time of the extension (relative to the parent block),
by default contract expiration of the parent block.
The extension is calculated independently (with time 0
describing its own start), but using the existing reserve as
initialCapital and the parent's parameters as fall-back values.</p>
</dd>
<dt><code>comment</code></dt><dd><p>The comment to use in the history snapshot.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters to be passed to
<a href="#method-new"><code>InsuranceContract$new</code></a> to create the contract
extension object.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># TODO
</pre>
</div>


<hr>
<a id="method-InsuranceContract-calculateContract"></a>



<h4>Method <code>calculateContract()</code></h4>

<p>Calculate all time series of the contract from the parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$calculateContract(
  calculate = "all",
  valuesFrom = 0,
  premiumCalculationTime = 0,
  preservePastPV = TRUE,
  additionalCapital = 0,
  recalculatePremiums = TRUE,
  recalculatePremiumSum = TRUE,
  history_comment = NULL,
  history_type = "Contract"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>calculate</code></dt><dd><p>Which values to calculate. See <a href="#topic+CalculationEnum">CalculationEnum</a></p>
</dd>
<dt><code>valuesFrom</code></dt><dd><p>Calculate only values starting from this time step
on (all values before that time will be preserved). This is
required when a contract is changed significantly (potentially
even switching to a new tariff), so that the calculation bases
for previous periods are no longer available.</p>
</dd>
<dt><code>premiumCalculationTime</code></dt><dd><p>The time point when the premium should
be re-calculated (including existing reserves) based on the
actuarial equivalence principle. All reserves will be based on
these new premiums.</p>
</dd>
<dt><code>preservePastPV</code></dt><dd><p>Whether present value before the recalculation
time <code>valuesFrom</code> should be preserved or recalculated.
When they are recalculated, the present values are consistent
to the new cash flows over the whole contract period, but
they no longer represent the actual contract state at these
times. If values are not recalculated, the reserves at each
time step represent the proper state at that point in time.</p>
</dd>
<dt><code>additionalCapital</code></dt><dd><p>The capital that is added to the contract
(e.g. capital carried over from a previous contract) at the
premium calculation time.</p>
</dd>
<dt><code>recalculatePremiums</code></dt><dd><p>Whether the premiums should be recalculated
at time <code>premiumCalculationTime</code> at all.</p>
</dd>
<dt><code>recalculatePremiumSum</code></dt><dd><p>Whether to recalculate the overall premium
sum when the premium is recalculated.</p>
</dd>
<dt><code>history_comment</code></dt><dd><p>The comment for the history snapshot entry</p>
</dd>
<dt><code>history_type</code></dt><dd><p>The type (free-form string) to record in the history snapshot</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InsuranceContract-consolidateBlocks"></a>



<h4>Method <code>consolidateBlocks()</code></h4>

<p>Aggregate values from all child contract blocks (if any)
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$consolidateBlocks(valuesFrom = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>valuesFrom</code></dt><dd><p>The time from when to aggragate values. Values before
that time will be left unchanged.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InsuranceContract-premiumWaiver"></a>



<h4>Method <code>premiumWaiver()</code></h4>

<p>Stop premium payments and re-calculate sumInsured of the paid-up contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$premiumWaiver(t, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>Time of the premium waiver.</p>
</dd>
<dt><code>...</code></dt><dd><p>Further parameters (currently unused)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># TODO
</pre>
</div>


<hr>
<a id="method-InsuranceContract-profitScenario"></a>



<h4>Method <code>profitScenario()</code></h4>

<p>Calculate one profit scenario and return all values
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$profitScenario(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Scenario-specific profit sharing parameters, overriding
the default values. Typically, adjusted profit rates are required
in a profitScenario.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a data.frame holding all profit participation values (rates,
bases for the different profit types, profit allocations,
terminal bonus funds, profit in case of death/surrender/premium waiver)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># TODO
</pre>
</div>


<hr>
<a id="method-InsuranceContract-addProfitScenario"></a>



<h4>Method <code>addProfitScenario()</code></h4>

<p>Calculate one profit scenario and store it in the contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$addProfitScenario(id, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>The unique ID of the profit scenario. Will be used as key
in the list of profit scenarios and printed out in the 'Excel'
export.</p>
</dd>
<dt><code>...</code></dt><dd><p>Scenario-specific profit sharing parameters, overriding
the default values. Typically, adjusted profit rates are required
in a profitScenario.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># TODO
</pre>
</div>


<hr>
<a id="method-InsuranceContract-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceContract$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># TODO


## ------------------------------------------------
## Method `InsuranceContract$addHistorySnapshot`
## ------------------------------------------------

# TODO

## ------------------------------------------------
## Method `InsuranceContract$addBlock`
## ------------------------------------------------

# TODO

## ------------------------------------------------
## Method `InsuranceContract$addDynamics`
## ------------------------------------------------

# TODO

## ------------------------------------------------
## Method `InsuranceContract$addExtension`
## ------------------------------------------------

# TODO

## ------------------------------------------------
## Method `InsuranceContract$premiumWaiver`
## ------------------------------------------------

# TODO

## ------------------------------------------------
## Method `InsuranceContract$profitScenario`
## ------------------------------------------------

# TODO

## ------------------------------------------------
## Method `InsuranceContract$addProfitScenario`
## ------------------------------------------------

# TODO
</code></pre>

<hr>
<h2 id='InsuranceContract.ParameterDefaults'>Default parameters for the InsuranceContract class.</h2><span id='topic+InsuranceContract.ParameterDefaults'></span>

<h3>Description</h3>

<p>A new contract will be
pre-filled with these values, and values passed in the constructor (or with
other setter functions) will override these values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InsuranceContract.ParameterDefaults
</code></pre>


<h3>Format</h3>

<p>The parameter list is a list of lists with the following structure:
</p>
<p>Sublists:
</p>

<ul>
<li> <p><code>$ContractData</code> ... Contract-specific data (policy period,
closing, age, sum insured, premium payments, etc.)
</p>
</li>
<li> <p><code>$ContractState</code> ... Current contract state (paid-up, surrender
penalty already applied, alpha costs already (partially) refunded)
</p>
</li>
<li> <p><code>$ActuarialBases</code> ... Actuarial bases for the contract
calculation (mortality/invalidity table, guaranteed interest,
surrender penalty, etc.)
</p>
</li>
<li> <p><code>$Costs</code>, <code>$minCosts</code> ... Expenses charged to the contract (see <code><a href="#topic+initializeCosts">initializeCosts()</a></code>)
</p>
</li>
<li> <p><code>$Loadings</code> ... Loadings, rebates and other charges of the
tariff / contract (tax, unit costs, surcharge for no medial exam, premium/benefit frequency loading)
</p>
</li>
<li> <p><code>$Features</code> ... Peculiarities of the tariff (to enable
non-standard formulas for certain company-specific historical
&quot;glitches&quot; in the tariff definitions.)
</p>
</li>
<li> <p><code>$ProfitParticipation</code> ... Profit scheme and profit participation
rates (default values, can be overwritten per profit scenario)
</p>
</li>
<li> <p><code>$Hooks</code> ... Hook functions to allow modification of various
calculation aspects (e.g. modify the default cash flows after
their setup)
</p>
</li></ul>



<h4>Elements of sublist <code>InsuranceContract.ParameterDefault$ContractData</code></h4>

<p>These values are typically set per contract and not by the tariff. Notable
exceptions are the contract duration in some instances and the premiumPeriod=1
for single-premium contracts.
</p>

<dl>
<dt><code>$id</code></dt><dd><p>ID of the contract (to distinguish individual parts in
contracts with multiple parts, e.g. dynamic increases),
default = &quot;Hauptvertrag&quot;</p>
</dd>
<dt><code>$sumInsured</code></dt><dd><p>Sum insured, default = 100,000</p>
</dd>
<dt><code>$premium</code></dt><dd><p>Premium, given to determine the sumInsured (default: NULL)</p>
</dd>
<dt><code>$initialCapital</code></dt><dd><p>Reserve/Capital that is already available
at contract inception, e.g. from a previous contract. No tax
or acquisition costs are applied to this capital.</p>
</dd>
<dt><code>$YOB (deprecated)</code></dt><dd><p>Year of birth of the insured, used to determine the
age for the application of the mortality table</p>
</dd>
<dt><code>$birthDate</code></dt><dd><p>Date  of birth of the insured, used to determine the
age for the application of the mortality table. Alternatively,
the year alone can be passed as <code>YOB</code>.</p>
</dd>
<dt><code>$age</code></dt><dd><p>Age of the insured</p>
</dd>
<dt><code>$technicalAge</code></dt><dd><p>Technical age of the insured (when the age
for the application of the mortality table does not coincide
with the real age)</p>
</dd>
<dt><code>$ageDifferences</code></dt><dd><p>Vector of age differences to the first
insured for contracts with multiple insured (i.e. joint-lives)</p>
</dd>
<dt><code>$sex</code></dt><dd><p>Sex of the insured, to allow gender-specific prixing
(e.g. different mortalities or age modification), default=&quot;unisex&quot;,
Type is <a href="#topic+SexEnum">SexEnum</a></p>
</dd>
<dt><code>$policyPeriod</code></dt><dd><p>Policy Duration (in years)</p>
</dd>
<dt><code>$premiumPeriod</code></dt><dd><p>Premium payment period (in year), for
single-premium contracts, <code>premiumPeriod = 1</code>. Default is
<code>policyPeriod</code>, i.e. regular premiums during the whole
contract period</p>
</dd>
<dt><code>$deferralPeriod</code></dt><dd><p>deferral period for annuities, i.e. the
period survival payments start only after this period, typically
the retirement age.  This applies mostly to tariffs of type
annuity, although deferral periods are possible (but not common)
for all other types of insurance, too.</p>
</dd>
<dt><code>$guaranteedPeriod</code></dt><dd><p>guaranteed annuity payment period. The
annuity pays out for this period, even if the insured dies.
This applies only to tariffs of type annuity.</p>
</dd>
<dt><code>$contractClosing</code></dt><dd><p>The date (variable of type <a href="base.html#topic+Date">Date</a>) when
the coverage of the contract starts (not neccessarily equal to
the date when the contract was signed). Typically generated by
a call to <code><a href="base.html#topic+as.Date">as.Date()</a></code>. The year is relevant to derive the age
of the insured, while month and day are relevant for the
interpolation of the balance sheet reserves</p>
</dd>
<dt><code>$blockStart</code></dt><dd><p>For contracts with multiple blocks (e.g.
multiple dynamic increases, where each increase is modelled
like a separate contract), this variable holds the offset of
the current contract block relative to the main contract block.
The main block starts a 0, dynamic increases start later! This
value is only used by the parent block (i.e. $t=0$ of the child
is aligned with $t=blockStart$ of the parent block.</p>
</dd>
<dt><code>$premiumPayments</code></dt><dd><p>Whether premiums are paid in advance
(default) or arrears. Value is of type <a href="#topic+PaymentTimeEnum">PaymentTimeEnum</a>
with possible values &quot;in advance&quot; and &quot;in arrears&quot;</p>
</dd>
<dt><code>$benefitPayments</code></dt><dd><p>Whether recurring benefits (e.g. annuities)
are paid in advance (default) or arrears. Value is of type
<a href="#topic+PaymentTimeEnum">PaymentTimeEnum</a> with possible values &quot;in advance&quot; and
&quot;in arrears&quot;</p>
</dd>
<dt><code>$premiumFrequency</code></dt><dd><p>Number of premium payments per year, default is 1.</p>
</dd>
<dt><code>$benefitFrequency</code></dt><dd><p>Number of benefit payments per year, default is 1.</p>
</dd>
<dt><code>$premiumRefund</code></dt><dd><p>Proportion of (gross) premiums refunded on
death (including additional risk, e.g. 1.10 = 110% of paid premiums)</p>
</dd>
<dt><code>$premiumRefundPeriod</code></dt><dd><p>The period, during which the premium
refund on death applies. By default, deferred contracts will
refund premiums only during the deferral period, all other
contracts during the whole contract. Default is
<code>premiumRefundPeriod.default</code></p>
</dd>
<dt><code>$premiumIncrease</code></dt><dd><p>The yearly growth factor of the premium,
i.e. 1.05 means +5% increase each year; a vector describes the
premiums for all years</p>
</dd>
<dt><code>$annuityIncrease</code></dt><dd><p>The yearly growth factor of the annuity
payments, i.e. 1.05 means +5% increase each year; a vector
describes the annuity unit payments for all years</p>
</dd>
<dt><code>$deathBenefit</code></dt><dd><p>The yearly relative death benefit (relative
to the initial sum insured); Can be set to a <code>function(len,
              params, values)</code>, e.g. <code>deathBenefit = deathBenefit.linearDecreasing</code></p>
</dd>
<dt><code>$benefitParameter</code></dt><dd><p>(optional) Tariff-specific parameter to
indicate special benefit conditions (e.g. for non-constant benefits
the initial starting value, or a minimum benefit, etc.). This
parameter is not used automatically, but needs to be processed
by a custom <code>$deathBenefit</code> function.</p>
</dd>
<dt><code>$costWaiver</code></dt><dd><p>The fraction of the costs that are waived (only
those cost components that are defined to be waivable, i.e. by
defining a corresponding <code>$minCosts</code>). Linearly interpolates
between <code>$Costs</code> and <code>$minCosts</code>, if the latter is set.
Otherwise is has no effect.</p>
</dd>
<dt><code>$attributes</code></dt><dd><p>Additional custom attributes (as a named list),
which can be used for particular behaviour of different contracts
or contract slices.</p>
</dd>
</dl>




<h4>Elements of sublist <code>InsuranceContract.ParameterDefault$ContractState</code></h4>

<p>Contract-specific status variables holding the status of the contract.
</p>

<dl>
<dt><code>$premiumWaiver</code></dt><dd><p>Whether the contract is paid-up.</p>
</dd>
<dt><code>$surrenderPenalty</code></dt><dd><p>Whether a surrender penalty still applies
(e.g. because it has already been applied during a contract change,
or because due to legal reasons it can no longer be applied)</p>
</dd>
<dt><code>$alphaRefunded</code></dt><dd><p>Whether alpha costs have (at least partially)
been refunded (e.g. when a contract is changed or paid-up). Default
is not yet refunded.</p>
</dd>
</dl>




<h4>Elements of sublist <code>InsuranceContract.ParameterDefault$ActuarialBases</code></h4>

<p>Tarif-specific actuarial calculation parameters of the contract. Typically,
these values are set by the tariff, but can be overridden by contract (e.g.
while prototyping a new product or a product change).
</p>

<dl>
<dt><code>$mortalityTable</code></dt><dd><p>The <a href="MortalityTables.html#topic+mortalityTable">mortalityTable</a> object describing the
mortality of the insured</p>
</dd>
<dt><code>$invalidityTable</code></dt><dd><p>For contracts with invalidity benefits,
the <a href="MortalityTables.html#topic+mortalityTable">mortalityTable</a> object describing the probabilities of
invalidity</p>
</dd>
<dt><code>$invalidityEndsContract</code></dt><dd><p>For contracts with invalidity
benefits, whether a payment of an invalidity benefit ends the
contract.</p>
</dd>
<dt><code>$i</code></dt><dd><p>Guaranteed yearly interest rate, default is 0.00, i.e. 0%</p>
</dd>
<dt><code>$balanceSheetDate</code></dt><dd><p>The day/month when balance sheet reserves
are calculated. Value of type <a href="base.html#topic+Date">Date</a>, typically generated with
<code><a href="base.html#topic+as.Date">as.Date()</a></code>. The year is actually irrelevant, only the day and
month are relevant.</p>
</dd>
<dt><code>$balanceSheetMethod</code></dt><dd><p>How to interpolate the balance sheet
reserves (at the balandeSheetDate) from the yearly contractual
reserves. Either a string &quot;30/360&quot;, &quot;act/act&quot;, &quot;act/360&quot;, &quot;act/365&quot;
or a function with signature <code>balanceSheetMethod(params, contractDates, balanceDates)</code>
that returns a vector of coefficients for each year to
interpolate the reserves available at the given <code>contractDates</code>
for the desired <code>balanceDates</code></p>
</dd>
<dt><code>$unearnedPremiumsMethod</code></dt><dd><p>How to calculate the unearned
premiums (considering the balance sheet date and the premium
frequency). A function with signature <code>unearnedPremiumsMethod(params, dates)</code></p>
</dd>
<dt><code>$surrenderValueCalculation</code></dt><dd><p>A function describing the surrender
value calculation. If NULL, the full reserve will be used as
surrender value. If given, it must be a function with signature
<code>function(SurrenderReserve, params, values)</code>.</p>
</dd>
<dt><code>$premiumWaiverValueCalculation</code></dt><dd><p>A function describing the
reserve used to derive the premium-free sum insured. If NULL,
the surrender value will be used. If given, it must be a function
with signature <code>function(SurrenderReserve, params, values)</code></p>
</dd>
<dt><code>$premiumFrequencyOrder</code></dt><dd><p>Order of the approximation for
payments within the year (unless an extra frequency loading is
used =&gt; then leave this at 0)</p>
</dd>
<dt><code>$benefitFrequencyOrder</code></dt><dd><p>Order of the approximation for
payments within the year (unless an extra frequency loading is
used =&gt; then leave this at 0)</p>
</dd>
</dl>




<h4>Elements of sublist <code>InsuranceContract.ParameterDefault$Costs</code></h4>

<p>Definition of contractual costs charged to the contract. See <code><a href="#topic+initializeCosts">initializeCosts()</a></code>.
</p>

<dl>
<dt><code>$Costs</code></dt><dd><p>The full cost defined for the contract / tariff,
usually set with <code><a href="#topic+initializeCosts">initializeCosts()</a></code> and <code><a href="#topic+setCost">setCost()</a></code></p>
</dd>
<dt><code>$minCosts</code></dt><dd><p>The minimum costs defined for the contract / tariff
that cannot be waived. Either an explicit cost definition structure
generated by <code><a href="#topic+initializeCosts">initializeCosts()</a></code> and <code><a href="#topic+setCost">setCost()</a></code>, or a
<code style="white-space: pre;">&#8288;function(params, values, costs)&#8288;</code>, where the full costs are passed
as third parameter, so the function can modify only those cost parts
that can be waived at all. </p>
</dd>
</dl>




<h4>Elements of sublist <code>InsuranceContract.ParameterDefault$Loadings</code></h4>


<dl>
<dt><code>$ongoingAlphaGrossPremium</code></dt><dd><p>Acquisition cost that increase the gross premium</p>
</dd>
<dt><code>$tax</code></dt><dd><p>insurance tax, factor on each premium paid, default is 4%, i.e. <code>i=0.04</code></p>
</dd>
<dt><code>$unitcosts</code></dt><dd><p>Annual unit cost for each policy, absolute value (can be a function)</p>
</dd>
<dt><code>$security</code></dt><dd><p>Additional security loading on all benefit payments, factor on all benefits</p>
</dd>
<dt><code>$noMedicalExam</code></dt><dd><p>Loading when no medicial exam is done, % of SumInsured</p>
</dd>
<dt><code>$noMedicalExamRelative</code></dt><dd><p>Loading when no medicial exam is done, % of gross premium</p>
</dd>
<dt><code>$sumRebate</code></dt><dd><p>gross premium reduction for large premiums, % of SumInsured</p>
</dd>
<dt><code>$extraRebate</code></dt><dd><p>gross premium reduction for any reason, % of SumInsured</p>
</dd>
<dt><code>$premiumRebate</code></dt><dd><p>gross premium reduction for large premiums, % of gross premium</p>
</dd>
<dt><code>$partnerRebate</code></dt><dd><p>Rebate on premium with all surcharges and
rebates when more than one contract is written with identical
parameters. Sums with advanceBonusInclUnitCost and premiumRebate.</p>
</dd>
<dt><code>$extraChargeGrossPremium</code></dt><dd><p>extra charges on gross premium
(smoker, leisure activities, BMI too high, etc.)</p>
</dd>
<dt><code>$benefitFrequencyLoading</code></dt><dd><p>Loading on the benefit for premium
payment frequencies of more than once a year. Format is
<code>list("1" = 0.0, "2" = 0.0, "4" = 0.0, "12" = 0.0)</code></p>
</dd>
<dt><code>$premiumFrequencyLoading</code></dt><dd><p>Loading on the premium for premium
payment frequencies of more than once a year. Format is
<code>list("1" = 0.0, "2" = 0.0, "4" = 0.0, "12" = 0.0)</code></p>
</dd>
<dt><code>$alphaRefundPeriod</code></dt><dd><p>How long the acquisition costs should be
(partially) refunded in case of surrender or premium waiver.</p>
</dd>
<dt><code>$commissionPeriod</code></dt><dd><p>Period, over which the acquisition costs
are charged to the contract (if not fully up-front or over the
whole contract period). This has only an effect for cost definitions
with duration &quot;CommissionPeriod&quot;. Default is 5 years.</p>
</dd>
</dl>




<h4>Elements of sublist <code>InsuranceContract.ParameterDefault$Features</code></h4>


<dl>
<dt><code>$zillmering</code></dt><dd><p>Whether the contract uses Zillmering (and bases
reserves on the Zillmer reserve as opposed to the adequate
reserve) (default: TRUE)</p>
</dd>
<dt><code>$betaGammaInZillmer</code></dt><dd><p>Whether beta and gamma-costs should be
included in the Zillmer premium calculation</p>
</dd>
<dt><code>$alphaRefundLinear</code></dt><dd><p>Whether the refund of alpha-costs on
surrender is linear in t or follows the NPV of an annuity</p>
</dd>
<dt><code>$useUnearnedPremiums</code></dt><dd><p>Whether unearned premiums should be
reported in the balance sheet reserves. Otherwise, a premium
paid at the beginning of the period is added to the reserve at
that time for balance-sheet purposes.
For regular premiums, the default is TRUE, i.e. the balance-sheet
reserve at time $t$ does not include the premium paid at time
$t$, but unearned premiums are included in the balance sheet
reserves. For single-premium contracts, there are no &quot;unearned&quot;
premiums, but the initial single premium is added to the reserve
immediately for balance-sheet purposes. In particular, the
balance sheet reserve at time $t=0$ is not 0, but the
premium paid. In turn, no unearned premiums are applied.</p>
</dd>
<dt><code>$surrenderIncludesCostsReserves</code></dt><dd><p>Whether (administration)
cost reserves are paid out on surrender (i.e. included in the
surrender value before surrender penalties are applied)</p>
</dd>
<dt><code>$unitcostsInGross</code></dt><dd><p>Whether unit costs are included in the
gross premium calculation or added after gross premiums. (default: FALSE)</p>
</dd>
<dt><code>$absPremiumRefund</code></dt><dd><p>Constant death benefit (typically premium
refund of a previous contract), relative to the sum insured.</p>
</dd>
<dt><code>$alphaCostsCommission</code></dt><dd><p>Whether alpha costs over the commision
period are given as their actual yearly value (&quot;actual&quot;), or
whether the given value is the sum (&quot;sum&quot;) or the present value
(&quot;presentvalue&quot;) over the whole commission period.</p>
</dd>
</dl>




<h4>Elements of sublist <code>InsuranceContract.ParameterDefault$ProfitParticipation</code></h4>

<p>Parameters describing the profit participation (instance of <a href="#topic+ProfitParticipation">ProfitParticipation</a>)
Most element descrive some kind of profit rate (which can vary in time),
while the bases, on which they are applied is defined in the profit scheme.
</p>

<dl>
<dt><code>$advanceProfitParticipation</code></dt><dd><p>Advance profit participation
rate (percentage rebate of the gross premium)</p>
</dd>
<dt><code>$advanceProfitParticipationInclUnitCost</code></dt><dd><p>Advance profit
participation rate (percentage rebate on the gross premium after all surcharges and unit costs.</p>
</dd>
<dt><code>$waitingPeriod</code></dt><dd><p>Waiting period of the profit sharing (e.g.
no profit in the first two years of a contract, or similar)</p>
</dd>
<dt><code>$guaranteedInterest</code></dt><dd><p>Individual contract-specific overrides
of the guaranteed interest rate (i.e. not keyed by year)</p>
</dd>
<dt><code>$interestProfitRate</code></dt><dd><p>Interest profit rate (guaranteed interest
rate + interest profit rate = total credited rate)</p>
</dd>
<dt><code>$totalInterest</code></dt><dd><p>Total credited rate (guarantee + interest profit)</p>
</dd>
<dt><code>$mortalityProfitRate</code></dt><dd><p>Mortality Profit rate</p>
</dd>
<dt><code>$expenseProfitRate</code></dt><dd><p>Expense profit rate</p>
</dd>
<dt><code>$sumProfitRate</code></dt><dd><p>Sum profit rate (for high sumInsured)</p>
</dd>
<dt><code>$terminalBonusRate</code></dt><dd><p>Terminal bonus rate (non-terminal-bonus
fund, but &quot;old&quot; Austrian terminal bonus)</p>
</dd>
<dt><code>$terminalBonusFundRate</code></dt><dd><p>Terminal bonus fund rate</p>
</dd>
<dt><code>$profitParticipationScheme</code></dt><dd><p>Profit participation scheme (object of class <a href="#topic+ProfitParticipation">ProfitParticipation</a>)</p>
</dd>
<dt><code>$profitComponents</code></dt><dd><p>Profit components of the profit scheme. List containing one or more of <code>c("interest", "risk", "expense", "sum", "terminal")</code></p>
</dd>
<dt><code>$profitClass</code></dt><dd><p>String describing the profit class the tariff
is assigned to. Profit classes are used to bundle similar
contracts (e.g. following similar risks) together. Profit
participation rates are defined at the level of profit classes.</p>
</dd>
<dt><code>$profitRates</code></dt><dd><p>General, company-wide profit rates, key columns are year and profitClass</p>
</dd>
<dt><code>$scenarios</code></dt><dd><p>profit participation scenarios (list of overridden parameters for each scenario)</p>
</dd>
</dl>




<h4>Elements of sublist <code>InsuranceContract.ParameterDefault$Hooks</code></h4>


<dl>
<dt><code>$adjustCashFlows</code></dt><dd><p>Function with signature <code>function(x, params, values, ...)</code> to adjust the benefit/premium cash flows after their setup.</p>
</dd>
<dt><code>$adjustCashFlowsCosts</code></dt><dd><p>Function with signature <code>function(x, params, values, ...)</code> to adjust the costs cash flows after their setup.</p>
</dd>
<dt><code>$adjustCosts</code></dt><dd><p>Function with signature <code>function(costs, params, values, ...)</code> to adjust the tariff costs after their setup (e.g. contract-specific conditions/waivers, etc.).</p>
</dd>
<dt><code>$adjustMinCosts</code></dt><dd><p>Function with signature <code>function(minCosts, costs, params, values, ...)</code> to adjust the tariff minimum (unwaivable) costs after their setup (e.g. contract-specific conditions/waivers, etc.).</p>
</dd>
<dt><code>$adjustPresentValues</code></dt><dd><p>Adjust the present value vectors that are later used to derive premiums and reserves. <code>function(presentValues, params, values)</code></p>
</dd>
<dt><code>$adjustPresentValuesCosts</code></dt><dd><p>Adjust the present value cost vectors used to derive premiums and reserves. <code>function(presentValuesCosts, params, values)</code></p>
</dd>
<dt><code>$adjustPremiumCoefficients</code></dt><dd><p>Function with signature <code>function(coeff, type, premiums, params, values, premiumCalculationTime)</code> to adjust the coefficients for premium calculation after their default setup. Use cases are e.g. term-fix tariffs where the Zillmer premium term contains the administration cost over the whole contract, but not other gamma- or beta-costs.</p>
</dd>
<dt><code>$adjustPremiums</code></dt><dd><p>Adjust the resulting premiums. <code>function(premiums = list(premiums, coefficients, sumInsured), params, values)</code></p>
</dd>
<dt><code>$adjustPVForReserves</code></dt><dd><p>Adjust the absolute present value vectors used to derive reserves (e.g. when a sum rebate is subtracted from the gamma-cost reserves without influencing the premium calculation). <code>function(absPV, params, values)</code></p>
</dd>
<dt><code>$premiumRebateCalculation</code></dt><dd><p>Calculate the actual premium rebate from the rebate rate (e.g. when the premium rate is given as a yearly cost reduction applied to a single-premium contract). <code>function(premiumRebateRate, params = params, values = values)</code></p>
</dd>
</dl>




<h3>Examples</h3>

<pre><code class='language-R'>InsuranceContract.ParameterDefaults
</code></pre>

<hr>
<h2 id='InsuranceContract.ParametersFallback'>Use fallback values for missing contract parameters</h2><span id='topic+InsuranceContract.ParametersFallback'></span>

<h3>Description</h3>

<p>Provide default values for the insurance contract parameters if any of the
parameters is not explicitly set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InsuranceContract.ParametersFallback(params, fallback, ppParameters = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InsuranceContract.ParametersFallback_+3A_params">params</code></td>
<td>
<p>Current, explicitly set contract parameters. All NULL values
will be filled with the corresponding entry from <code>fallback</code>.</p>
</td></tr>
<tr><td><code id="InsuranceContract.ParametersFallback_+3A_fallback">fallback</code></td>
<td>
<p>Fallback values that will be used when the corresponding
entry in <code>params</code> is NULL.</p>
</td></tr>
<tr><td><code id="InsuranceContract.ParametersFallback_+3A_ppparameters">ppParameters</code></td>
<td>
<p>Whether profit participation parameters should also be
filled (default is TRUE)</p>
</td></tr>
</table>

<hr>
<h2 id='InsuranceContract.ParametersFill'>Initialize the insurance contract parameters from passed arguments</h2><span id='topic+InsuranceContract.ParametersFill'></span>

<h3>Description</h3>

<p>Initialize the insurance contract parameters from the passed
arguments. Arguments not given are left unchanged. If no existing parameter
structure is given, an empty (i.e. all NULL entries) structure is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InsuranceContract.ParametersFill(
  params = InsuranceContract.ParameterStructure,
  costs = NULL,
  minCosts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InsuranceContract.ParametersFill_+3A_params">params</code></td>
<td>
<p>Initial values of the insurance contract parameters. (default: empty parameter structure)</p>
</td></tr>
<tr><td><code id="InsuranceContract.ParametersFill_+3A_costs">costs</code>, <code id="InsuranceContract.ParametersFill_+3A_mincosts">minCosts</code>, <code id="InsuranceContract.ParametersFill_+3A_...">...</code></td>
<td>
<p>Values for any of the entries in the insurance contract
parameter structure. These values take precedence over the
initial parameters provided in <code>params</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='InsuranceContract.ParameterStructure'>Full insurance contract parameter structure.</h2><span id='topic+InsuranceContract.ParameterStructure'></span>

<h3>Description</h3>

<p>All values are filled with NULL,
so the functions <code><a href="#topic+InsuranceContract.ParametersFill">InsuranceContract.ParametersFill</a></code> and
<code><a href="#topic+InsuranceContract.ParametersFallback">InsuranceContract.ParametersFallback</a></code> can be used to override
existing parameters or to provide default values for unset (NULL) entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InsuranceContract.ParameterStructure
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 9.
</p>

<hr>
<h2 id='InsuranceContract.Values'>Data structure (filled only with NULL) for insurance contract class member values.</h2><span id='topic+InsuranceContract.Values'></span>

<h3>Description</h3>

<p>Data structure (filled only with NULL) for insurance contract class member values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InsuranceContract.Values
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 16.
</p>

<hr>
<h2 id='InsuranceTarif'>Base class for traditional Insurance Tarifs (with fixed guarantee, profit
sharing and no unit-linked component)</h2><span id='topic+InsuranceTarif'></span>

<h3>Description</h3>

<p>The class <code>InsuranceTarif</code> provides the code and general
framework to implement contract-independent functionality of a life insurance
product.
</p>


<h3>Details</h3>

<p>This is a base class for holding contract-independent values and
providing methods to calculate cash flows, premiums, etc. Objects of this
class do NOT contain contract-specific values like age, death probabilities,
premiums, reserves, etc. Rather, they are the calculation kernels that will
be called by the <code><a href="#topic+InsuranceContract">InsuranceContract</a></code> objects to make the actual,
tariff-specific calculations.
</p>
<p>Most methods of this class are not meant to be called manually, but are supposed
to be called by the InsuranceContract object with contract-specific information.
The only methods that are typically used for defining an insurance tariff are
the constructor <a href="#method-new"><code>InsuranceTarif$new()</code></a> and the cloning method
<a href="#method-createModification"><code>InsuranceTarif$createModification()</code></a>.
All other methods should never be called manually.
</p>
<p>However, as overriding private methods is not possible in an R6 class, all the
methods need to be public to allow overriding them in derived classes.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>The tariff's unique name. Will also be used as the key for exported data.</p>
</dd>
<dt><code>tarif</code></dt><dd><p>The tariff's public name (typically a product name), not necessarily unique.</p>
</dd>
<dt><code>desc</code></dt><dd><p>A short human-readable description of the tariff and its main features.</p>
</dd>
<dt><code>tariffType</code></dt><dd><p>An enum specifying the main characteristics of the tarif.
Possible values are:
</p>

<dl>
<dt>annuity</dt><dd><p>Whole life or term annuity (periodic survival benefits)
with flexible payouts (constand, increasing, decreasing, arbitrary,
etc.)</p>
</dd>
<dt>wholelife</dt><dd><p>A whole or term life insurance with only death benefits.
The benefit can be constant, increasing, decreasing, described by
a function, etc.</p>
</dd>
<dt>endowment</dt><dd><p>An  endowment with death and survival benefits,
potentially with different benefits.</p>
</dd>
<dt>pureendowment</dt><dd><p>A pure endowment with only a survival benefit at
the end of the contract. Optionally, in case of death, all or part
of the premiums paid may be refunded.</p>
</dd>
<dt>terme-fix</dt><dd><p>A terme-fix insurance with a fixed payout at the end
of the contract, even if the insured dies before that time.
Premiums are paid until death of the insured.</p>
</dd>
<dt>dread-disease</dt><dd><p>A dread-disease insurance, which pays in case of
a severe illness (typically heart attacks, cancer, strokes, etc.),
but not in case of death.</p>
</dd>
<dt>endowment + dread-disease</dt><dd><p>A combination of an endowment and a
temporary dread-disease insurance. Benefits occur either on death,
severe illness or survival, whichever comes first.</p>
</dd>
</dl>
</dd>
<dt><code>Parameters</code></dt><dd><p>A data structure (nested list) containing all relevant
parameters describing a contract, its underlying tariff, the profit
participation scheme etc. See <a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a> for
all fields.</p>
</dd>
<dt><code>dummy</code></dt><dd><p>Dummy field to allow commas after the previous method</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-InsuranceTarif-new"><code>InsuranceTarif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-createModification"><code>InsuranceTarif$createModification()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getParameters"><code>InsuranceTarif$getParameters()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getInternalValues"><code>InsuranceTarif$getInternalValues()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getAges"><code>InsuranceTarif$getAges()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getTransitionProbabilities"><code>InsuranceTarif$getTransitionProbabilities()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getCostValues"><code>InsuranceTarif$getCostValues()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getPremiumCF"><code>InsuranceTarif$getPremiumCF()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getAnnuityCF"><code>InsuranceTarif$getAnnuityCF()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getDeathCF"><code>InsuranceTarif$getDeathCF()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getBasicCashFlows"><code>InsuranceTarif$getBasicCashFlows()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getCashFlows"><code>InsuranceTarif$getCashFlows()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getCashFlowsCosts"><code>InsuranceTarif$getCashFlowsCosts()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-presentValueCashFlows"><code>InsuranceTarif$presentValueCashFlows()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-presentValueCashFlowsCosts"><code>InsuranceTarif$presentValueCashFlowsCosts()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getAbsCashFlows"><code>InsuranceTarif$getAbsCashFlows()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getAbsPresentValues"><code>InsuranceTarif$getAbsPresentValues()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-presentValueBenefits"><code>InsuranceTarif$presentValueBenefits()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getPremiumCoefficients"><code>InsuranceTarif$getPremiumCoefficients()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-sumInsuredCalculation"><code>InsuranceTarif$sumInsuredCalculation()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-premiumCalculation"><code>InsuranceTarif$premiumCalculation()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-reserveCalculation"><code>InsuranceTarif$reserveCalculation()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getBalanceSheetReserveFactor"><code>InsuranceTarif$getBalanceSheetReserveFactor()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-reserveCalculationBalanceSheet"><code>InsuranceTarif$reserveCalculationBalanceSheet()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-calculateProfitParticipation"><code>InsuranceTarif$calculateProfitParticipation()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-reservesAfterProfit"><code>InsuranceTarif$reservesAfterProfit()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-getBasicDataTimeseries"><code>InsuranceTarif$getBasicDataTimeseries()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-premiumDecomposition"><code>InsuranceTarif$premiumDecomposition()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-calculateFutureSums"><code>InsuranceTarif$calculateFutureSums()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-calculatePresentValues"><code>InsuranceTarif$calculatePresentValues()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-evaluateFrequencyLoading"><code>InsuranceTarif$evaluateFrequencyLoading()</code></a>
</p>
</li>
<li> <p><a href="#method-InsuranceTarif-clone"><code>InsuranceTarif$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-InsuranceTarif-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a new tariff object
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$new(
  name = NULL,
  type = "wholelife",
  tarif = "Generic Tarif",
  desc = "Description of tarif",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The unique name / ID of the tariff</p>
</dd>
<dt><code>type</code></dt><dd><p>An enum specifying the main characteristics of the tarif. See <a href="#topic+TariffTypeEnum">TariffTypeEnum</a></p>
</dd>
<dt><code>tarif</code></dt><dd><p>The tariff's public name to be stored in the <code>tarif</code> field.</p>
</dd>
<dt><code>desc</code></dt><dd><p>A short human-readable description to be stored in the <code>desc</code> field.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters for the <a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a>,
defining the characteristics of the tariff.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The constructor function defines a tariff and generates the
corresponding data structure, which can then be used with the <a href="#topic+InsuranceContract">InsuranceContract</a>
class to define an actual contract using the tariff.
</p>
<p>The arguments passed to this function will be stored inside the
<code>Parameters</code> field of the class, inside one of the lists sublists.
The parameters are stacked from different layers (higher levels override
default values from lower layers):
</p>

<ul>
<li><p> InsuranceContract object (parameters passed directly to the individual
contract)
</p>
</li>
<li><p> ProfitParticipation object (parameters for profit participation, passed
to the definition of the profit plan, which is used for the tarif
definition or the contract)
</p>
</li>
<li><p> InsuranceTarif object (parameters passed to the definition of the tariff
that was used for the contract)
</p>
</li>
<li><p> Defaults taken from <a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a>
</p>
</li></ul>

<p>The general implementation of this parameter layering means that (a) a tariff
can already provide default values for contracts (e.g. a default maturity,
default sum insured, etc) and (b) individual contracts can override all
parameters defined with the underlying tariff. In particular the latter
feature has many use-cases in prototyping: E.g. when you have a tariff
with a guaranteed interest rate of 1\
one can immediately instantiate a contract with an updated interest rate
or mortality table for comparison. There is no need to re-implement a
tariff for such comparisons, as long as only parameters are changed.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>MortalityTables::mortalityTables.load("Austria_Annuities_AVOe2005R")
tarif.male = InsuranceTarif$new(name = "Annuity Males", type = "annuity",
    i = 0.01, mortalityTable = AVOe2005R.male)
</pre>
</div>


<hr>
<a id="method-InsuranceTarif-createModification"></a>



<h4>Method <code>createModification()</code></h4>

<p>create a copy of a tariff with certain parameters changed
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$createModification(
  name = NULL,
  tarif = NULL,
  desc = NULL,
  tariffType = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The unique name / ID of the tariff</p>
</dd>
<dt><code>tarif</code></dt><dd><p>The tariff's public name to be stored in the <code>tarif</code> field.</p>
</dd>
<dt><code>desc</code></dt><dd><p>A short human-readable description to be stored in the <code>desc</code> field.</p>
</dd>
<dt><code>tariffType</code></dt><dd><p>An enum specifying the main characteristics of the tarif.
See <a href="#topic+TariffTypeEnum">TariffTypeEnum</a></p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters for the <a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a>,
defining the characteristics of the tariff.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method <code>createModification</code> returns a copy of the tariff
with all given arguments changed in the tariff's <code>InsuranceTarif$Parameters</code>
parameter list.
</p>
<p>As InsuranceTarif is a R6 class with reference logic, simply assigning
the object to a new variable does not create a copy, but references the
original tariff object. To create an actual copy, one needs to call this
method, which first clones the whole object and then adjusts all parameters
to the values passed to this method.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>MortalityTables::mortalityTables.load("Austria_Annuities_AVOe2005R")
tarif.male = InsuranceTarif$new(name = "Annuity Males", type = "annuity",
    i = 0.01, mortalityTable = AVOe2005R.male)
tarif.unisex = tarif.male$createModification(name = "Annuity unisex",
    mortalityTable = AVOe2005R.unisex)
</pre>
</div>


<hr>
<a id="method-InsuranceTarif-getParameters"></a>



<h4>Method <code>getParameters()</code></h4>

<p>Retrieve the parameters for this tariff (can be overridden
for each contract)
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getParameters()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>tarif.male = InsuranceTarif$new(name = "Annuity Males", type = "annuity",
    i = 0.01, mortalityTable = AVOe2005R.male)
tarif.male$getParameters()
</pre>
</div>


<hr>
<a id="method-InsuranceTarif-getInternalValues"></a>



<h4>Method <code>getInternalValues()</code></h4>

<p>Get some internal parameters cached (length of data.frames,
policy periods cut at max.age, etc.)
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getInternalValues(params, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>...</code></dt><dd><p>currently unused</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This methos is not meant to be called explicitly, but rather used
by the InsuranceContract class. It returns a list of maturities and ages
relevant for the contract-specific calculations
</p>


<hr>
<a id="method-InsuranceTarif-getAges"></a>



<h4>Method <code>getAges()</code></h4>

<p>Calculate the contract-relevant age(s) given a certain
parameter data structure (contract-specific values)
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getAges(params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method is not meant to be called explicitly, but rather used
by the InsuranceContract class. It returns the relevant ages during the
whole contract period
</p>


<hr>
<a id="method-InsuranceTarif-getTransitionProbabilities"></a>



<h4>Method <code>getTransitionProbabilities()</code></h4>

<p>Calculate the transition probabilities from the contract-specific
parameters passed as <code>params</code> and the already-calculated contract
values <code>values</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getTransitionProbabilities(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getCostValues"></a>



<h4>Method <code>getCostValues()</code></h4>

<p>Obtain the cost structure from the cost parameter and the
given paremeter set
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getCostValues(params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>The parameters of the contract / tariff</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
The cost parameter can be either an array of costs (generated by <code><a href="#topic+initializeCosts">initializeCosts()</a></code>)
or a function with parameters <code>param</code> and <code>values</code>(=NULL) returning
an array of the required dimensions. This function makes sures that the
latter function is actually evaluated.
</p>


<hr>
<a id="method-InsuranceTarif-getPremiumCF"></a>



<h4>Method <code>getPremiumCF()</code></h4>

<p>Returns the unit premium cash flow for the whole contract period.
</p>

<ul>
<li><p> For constant premiums it will be rep(1, premiumPeriod),
</p>
</li>
<li><p> for single premiums it will be c(1, 0, 0, ...),
</p>
</li>
<li><p> for increasing premiums it will be (1+increase)^(0:(premiumPeriod-1))
and 0 after the premium period
</p>
</li></ul>



<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getPremiumCF(len, params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>len</code></dt><dd><p>The desired length of the returned data frame (the number of contract periods desire)</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getAnnuityCF"></a>



<h4>Method <code>getAnnuityCF()</code></h4>

<p>Returns the unit annuity cash flow (guaranteed and contingent) for
the whole annuity payment period (after potential deferral period)
</p>

<ul>
<li><p> For constant annuity it will be rep(1, annuityPeriod),
</p>
</li>
<li><p> for increasing annuities it will be (1+increase)^(0:(premiumPeriod-1))
and 0 after the premium period
</p>
</li></ul>



<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getAnnuityCF(len, params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>len</code></dt><dd><p>The desired length of the returned data frame (the number of contract periods desire)</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getDeathCF"></a>



<h4>Method <code>getDeathCF()</code></h4>

<p>Returns the unit death cash flow for the whole protection
period (after potential deferral period!)
</p>

<ul>
<li><p> For constant death benefit it will be rep(1, policyPeriod),
</p>
</li>
<li><p> for linearly decreasing sum insured it will be (policyPeriod:0)/policyPeriod
</p>
</li></ul>



<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getDeathCF(len, params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>len</code></dt><dd><p>The desired length of the returned data frame (the number of contract periods desire)</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getBasicCashFlows"></a>



<h4>Method <code>getBasicCashFlows()</code></h4>

<p>Returns the basic (unit) cash flows associated with the type
of insurance given in the InsuranceTarif's <code>tariffType</code> field
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getBasicCashFlows(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getCashFlows"></a>



<h4>Method <code>getCashFlows()</code></h4>

<p>Returns the cash flows for the contract given the parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getCashFlows(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getCashFlowsCosts"></a>



<h4>Method <code>getCashFlowsCosts()</code></h4>

<p>Returns the cost cash flows of the contract given the contract
and tariff parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getCashFlowsCosts(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-presentValueCashFlows"></a>



<h4>Method <code>presentValueCashFlows()</code></h4>

<p>Returns the present values of the cash flows of the contract
(cash flows already calculated and stored in the <code>cashFlows</code> data.frame)
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$presentValueCashFlows(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
<dt><code>cashFlows</code></dt><dd><p>data.frame of cash flows calculated by a call to <a href="#method-getCashFlows"><code>InsuranceTarif$getCashFlows()</code></a></p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-presentValueCashFlowsCosts"></a>



<h4>Method <code>presentValueCashFlowsCosts()</code></h4>

<p>Calculates the present values of the cost cash flows of the
contract (cost cash flows alreay calculated by <a href="#method-getCashFlowsCosts"><code>InsuranceTarif$getCashFlowsCosts()</code></a>
and stored in the <code>values</code> list
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$presentValueCashFlowsCosts(params, values, presentValues)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
<dt><code>presentValues</code></dt><dd><p>The present values of the insurance claims (without costs)</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getAbsCashFlows"></a>



<h4>Method <code>getAbsCashFlows()</code></h4>

<p>Calculate the cash flows in monetary terms of the insurance contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getAbsCashFlows(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Once the premiums of the insurance contracts are calculated, all
cash flows can also be expressed in absolute terms. This function
calculates these time series in monetary terms, once the premiums
are calculated by the previous functions of this class.
</p>
<p>This method is NOT to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getAbsPresentValues"></a>



<h4>Method <code>getAbsPresentValues()</code></h4>

<p>Calculate the absolute present value time series of the insurance contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getAbsPresentValues(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Once the premiums of the insurance contracts are calculated, all
present values can also be expressed in absolute terms. This function
calculates these time series in monetary terms, once the premiums and the
unit-benefit present values are calculated by the previous functions of
this classe.
</p>
<p>This method is NOT to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-presentValueBenefits"></a>



<h4>Method <code>presentValueBenefits()</code></h4>

<p>Calculate the absolute present value time series of the
benefits of the insurance contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$presentValueBenefits(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Once the premiums of the insurance contracts are calculated, all
present values can also be expressed in absolute terms. This function
calculates these time series of the benefits present values in monetary
terms, once the premiums and the unit-benefit present values are calculated
by the previous functions of this classe.
</p>
<p>This method is NOT to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getPremiumCoefficients"></a>



<h4>Method <code>getPremiumCoefficients()</code></h4>

<p>Calculate the linear coefficients of the premium calculation formula for the insurance contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getPremiumCoefficients(
  type = "gross",
  coeffBenefits,
  coeffCosts,
  premiums,
  params,
  values,
  premiumCalculationTime = values$int$premiumCalculationTime
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>The premium that is supposed to be calculated (&quot;gross&quot;, &quot;Zillmer&quot;, &quot;net&quot;)</p>
</dd>
<dt><code>coeffBenefits</code></dt><dd><p>(empty) data structure of the benefit coefficients.
The actual values have no meaning, this parameter is only used to
derive the required dimensions</p>
</dd>
<dt><code>coeffCosts</code></dt><dd><p>(empty) data structure of the cost coefficients. The
actual values have no meaning, this parameter is only used to
derive the required dimensions</p>
</dd>
<dt><code>premiums</code></dt><dd><p>The premium components that have already been calculated
(e.g. for net and Zillmer, the gross premium has already been
calculated to allow modelling the premium refund)</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
<dt><code>premiumCalculationTime</code></dt><dd><p>The time when the premiums should be
(re-)calculated according to the equivalence principle. A time 0
means the initial premium calculation at contract closing, later
premium calculation times can be used to re-calculate the new
premium after a contract change (possibly including an existing reserve)</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
When <code>getPremiumCoefficients</code> is called, the <code>values$premiums</code>
array has NOT yet been filled! Instead, all premiums already calculated
(and required for the premium coefficients) are passed in the <code>premiums</code>
argument.
</p>


<hr>
<a id="method-InsuranceTarif-sumInsuredCalculation"></a>



<h4>Method <code>sumInsuredCalculation()</code></h4>

<p>Calculate the sumInsured of the InsuranceContract given the
parameters and premiums given and teh , present values already calculated and
stored in the <code>params</code> and <code>values</code> lists.
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$sumInsuredCalculation(
  params,
  values,
  calculationTime = values$int$premiumCalculationTime
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
<dt><code>calculationTime</code></dt><dd><p>the time when the sumInsured should be recalculated from the given premium</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-premiumCalculation"></a>



<h4>Method <code>premiumCalculation()</code></h4>

<p>Calculate the premiums of the InsuranceContract given the
parameters, present values and premium cofficients already calculated and
stored in the <code>params</code> and <code>values</code> lists.
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$premiumCalculation(
  params,
  values,
  premiumCalculationTime = values$int$premiumCalculationTime
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
<dt><code>premiumCalculationTime</code></dt><dd><p>The time when the premiums should be
(re-)calculated according to the equivalence principle. A time 0
means the initial premium calculation at contract closing, later
premium calculation times can be used to re-calculate the new
premium after a contract change (possibly including an existing reserve)</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-reserveCalculation"></a>



<h4>Method <code>reserveCalculation()</code></h4>

<p>Calculate the reserves of the InsuranceContract given the
parameters, present values and premiums already calculated and stored in
the <code>params</code> and <code>values</code> lists.
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$reserveCalculation(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getBalanceSheetReserveFactor"></a>



<h4>Method <code>getBalanceSheetReserveFactor()</code></h4>

<p>Calculate the (linear) interpolation factors for the balance
sheet reserve (Dec. 31) between the yearly contract closing dates
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getBalanceSheetReserveFactor(method, params, years = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>The method for the balance sheet interpolation (30/360, act/act, act/360, act/365 or a function)</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>years</code></dt><dd><p>how many years to calculate (for some usances, the factor
is different in leap years!)</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-reserveCalculationBalanceSheet"></a>



<h4>Method <code>reserveCalculationBalanceSheet()</code></h4>

<p>Calculate the reserves for the balance sheets at Dec. 31 of each
year by interpolation from the contract values calculated for
the yearly reference date of the contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$reserveCalculationBalanceSheet(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-calculateProfitParticipation"></a>



<h4>Method <code>calculateProfitParticipation()</code></h4>

<p>Calculate the profit participation given the contract
parameters and the already calculated reserves of the contract.
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$calculateProfitParticipation(params, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters for the profit participation calculation, passed
through to the profit participation scheme's <a href="../../LifeInsureR/html/ProfitParticipation.html#method-getProfitParticipation"><code>ProfitParticipation$getProfitParticipation()</code></a></p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-reservesAfterProfit"></a>



<h4>Method <code>reservesAfterProfit()</code></h4>

<p>Calculate the reserves after profit participation for the given profit scenario
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$reservesAfterProfit(profitScenario, params, values, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>profitScenario</code></dt><dd><p>The ID of the profit scenario for which to calculate the reserves</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
<dt><code>...</code></dt><dd><p>TODO</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-getBasicDataTimeseries"></a>



<h4>Method <code>getBasicDataTimeseries()</code></h4>

<p>Return the time series of the basic contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$getBasicDataTimeseries(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
</p>


<hr>
<a id="method-InsuranceTarif-premiumDecomposition"></a>



<h4>Method <code>premiumDecomposition()</code></h4>

<p>Calculate the time series of the premium decomposition of the contract
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$premiumDecomposition(params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Not to be called directly, but implicitly by the <a href="#topic+InsuranceContract">InsuranceContract</a> object.
All premiums, reserves and present values have already been calculated.
</p>


<hr>
<a id="method-InsuranceTarif-calculateFutureSums"></a>



<h4>Method <code>calculateFutureSums()</code></h4>

<p>Generic function to calculate future sums of the values
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$calculateFutureSums(cf, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cf</code></dt><dd><p>The time series, for which future sums at all times are desired</p>
</dd>
<dt><code>...</code></dt><dd><p>currently unused</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InsuranceTarif-calculatePresentValues"></a>



<h4>Method <code>calculatePresentValues()</code></h4>

<p>Calculate all present values for a given time series. The
mortalities are taken from the contract's parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$calculatePresentValues(cf, params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cf</code></dt><dd><p>The time series, for which future present values at all
times are desired</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
<dt><code>...</code></dt><dd><p>currently unused</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InsuranceTarif-evaluateFrequencyLoading"></a>



<h4>Method <code>evaluateFrequencyLoading()</code></h4>

<p>Calculate the premium frequency loading, i.e. the surcharge
on the premium for those cases where the premium is not paid yearly.
Return values can be either a numeric value or a named list with all
possible premium frequencies as keys.
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$evaluateFrequencyLoading(loading, frequency, params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>loading</code></dt><dd><p>The premiumFrequencyLoading parameter of the Contract or Tariff to be evaluated</p>
</dd>
<dt><code>frequency</code></dt><dd><p>The premiumFrequency parameter of the contract</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (in the <code>contract$Values</code>
list) then this method is called by the contract object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InsuranceTarif-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>InsuranceTarif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Define an insurance tariff for 10-year endowments, using a guaranteed interest
# rate of 1% and the Austrian population mortality table of the census 2011.
# Premiums are paid monthly in advance during the whole contract period.
MortalityTables::mortalityTables.load("Austria_Census")
# Cost structure:
#   - 4% up-front acquisition costs (of premium sum)
#   - 1% collection cost of each premium paid
#   - 1%o yearly administration cost (of the sum insured) as long as premiums are paid
#   - 2%o yearly administration cost for paid-up contracts
#   - 10 Euro yearly unit costs (as long as premiums are paid)
costs.endw = initializeCosts(alpha = 0.04, beta = 0.01, gamma = 0.001,
    gamma.paidUp = 0.002, gamma.premiumfree = 0.002, unitcosts = 10)

endowment.AT1 = InsuranceTarif$new(
    name = "Endow AT 1%", type = "endowment", tarif = "Austrian Endowment",
    desc = "An endowment for Austrian insured with 1% interest and no profit participation",
    ContractPeriod = 10,
    i = 0.01, mortalityTable = mort.AT.census.2011.unisex,
    costs = costs.endw, premiumFrequency = 12)

# The instantiation of the actual contract will provide the contract specific
# information and immediately calculate all further values:
ctr.end.AT1 = InsuranceContract$new(tarif = endowment.AT1,
    contractClosing = as.Date("2020-07-01"), age = 42)

# All values for the contract are already calculated during construction and
# stored in the ctr.end.AT1$Values list:
ctr.end.AT1$Values$basicData
ctr.end.AT1$Values$transitionProbabilities
ctr.end.AT1$Values$cashFlowsCosts
ctr.end.AT1$Values$presentValues
ctr.end.AT1$Values$premiums
ctr.end.AT1$Values$reserves
ctr.end.AT1$Values$premiumComposition
# etc.

## ------------------------------------------------
## Method `InsuranceTarif$new`
## ------------------------------------------------

MortalityTables::mortalityTables.load("Austria_Annuities_AVOe2005R")
tarif.male = InsuranceTarif$new(name = "Annuity Males", type = "annuity",
    i = 0.01, mortalityTable = AVOe2005R.male)

## ------------------------------------------------
## Method `InsuranceTarif$createModification`
## ------------------------------------------------

MortalityTables::mortalityTables.load("Austria_Annuities_AVOe2005R")
tarif.male = InsuranceTarif$new(name = "Annuity Males", type = "annuity",
    i = 0.01, mortalityTable = AVOe2005R.male)
tarif.unisex = tarif.male$createModification(name = "Annuity unisex",
    mortalityTable = AVOe2005R.unisex)

## ------------------------------------------------
## Method `InsuranceTarif$getParameters`
## ------------------------------------------------

tarif.male = InsuranceTarif$new(name = "Annuity Males", type = "annuity",
    i = 0.01, mortalityTable = AVOe2005R.male)
tarif.male$getParameters()
</code></pre>

<hr>
<h2 id='isRegularPremiumContract'>Determine whether a contract (given all parameters) is a contract with regular premiums</h2><span id='topic+isRegularPremiumContract'></span>

<h3>Description</h3>

<p>Regular premium contracts are identified by the parameter <code>premiumPeriod &gt; 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isRegularPremiumContract(params, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isRegularPremiumContract_+3A_params">params</code></td>
<td>
<p>The parameters of the contract.</p>
</td></tr>
<tr><td><code id="isRegularPremiumContract_+3A_values">values</code></td>
<td>
<p>Unused by default (already calculated values of the contract)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE, indicating a contract with regular premiums
</p>

<hr>
<h2 id='isSinglePremiumContract'>Determine whether a contract (given all parameters) is a single-premium contract or with regular premiums</h2><span id='topic+isSinglePremiumContract'></span>

<h3>Description</h3>

<p>Single premium contracts are identified by the parameter <code>premiumPeriod = 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSinglePremiumContract(params, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSinglePremiumContract_+3A_params">params</code></td>
<td>
<p>The parameters of the contract.</p>
</td></tr>
<tr><td><code id="isSinglePremiumContract_+3A_values">values</code></td>
<td>
<p>Unused by default (already calculated values of the contract)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE, indicating a single-premium contract or not
</p>

<hr>
<h2 id='makeContractGridDimname'>Create human-readable labels for the dimensions in a <code><a href="#topic+contractGrid">contractGrid()</a></code></h2><span id='topic+makeContractGridDimname'></span><span id='topic+makeContractGridDimnames'></span>

<h3>Description</h3>

<p>The function <code>makeContractGridDimname</code> generates a short, human-readable
dimension label for the entries along the axes of a <code><a href="#topic+contractGrid">contractGrid()</a></code>.
The default is to use the <code>value</code> unchanged as the row-/columnname, but
for some parameter values (like a <a href="#topic+InsuranceTarif">InsuranceTarif</a> or <a href="MortalityTables.html#topic+mortalityTable">mortalityTable</a>)
a custom method of this function is needed to create the (short) human-readable
representation for the axes in the grid.
</p>
<p>The function <code>makeContractGridDimnames</code> generate proper
dimnames for all entries of the axes of a <code><a href="#topic+contractGrid">contractGrid()</a></code> by calling
<code>makeContractGridDimname</code> on each of the axes' values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeContractGridDimname(value)

makeContractGridDimnames(axes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeContractGridDimname_+3A_value">value</code></td>
<td>
<p>the value along the axis, for which a name should be generated</p>
</td></tr>
<tr><td><code id="makeContractGridDimname_+3A_axes">axes</code></td>
<td>
<p>the axes with all names, for which a name should be generated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the entry in the dimnames of <code><a href="#topic+contractGrid">contractGrid()</a></code>
</p>
<p>an array of dimnames derived from the axes definitions of <code><a href="#topic+contractGrid">contractGrid()</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>makeContractGridDimname()</code>: Create a short, human-readable dimensional name for an object (default S3 method)
</p>
</li>
<li> <p><code>makeContractGridDimnames()</code>: Generate proper dimnames for all entries of the axes of a <code><a href="#topic+contractGrid">contractGrid()</a></code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(MortalityTables)
mortalityTables.load("Austria_Census")

makeContractGridDimname(mort.AT.census.2011.unisex)

makeContractGridDimnames(axes = list(
    age = seq(30,60,10),
    mortalityTable = c(mort.AT.census.2011.unisex, mort.AT.census.2011.male,
                       mort.AT.census.2011.female))
)
</code></pre>

<hr>
<h2 id='pad0'>Pad a vector with 0 to a desired length</h2><span id='topic+pad0'></span>

<h3>Description</h3>

<p>Pad a vector with 0 to a desired length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad0(v, l, value = 0, start = 0, value.start = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad0_+3A_v">v</code></td>
<td>
<p>the vector to pad with 0</p>
</td></tr>
<tr><td><code id="pad0_+3A_l">l</code></td>
<td>
<p>the desired (resulting) length of the vector</p>
</td></tr>
<tr><td><code id="pad0_+3A_value">value</code></td>
<td>
<p>the value to pad with (if padding is needed). Default to 0, but
can be overridden to pad with any other value.</p>
</td></tr>
<tr><td><code id="pad0_+3A_start">start</code></td>
<td>
<p>the first <code>start</code> values are always set to 0 (default is 0,
can be changed using the <code>value.start</code> argument),
the vector <code>v</code> starts only after these leading zeroes. The number of
leading zeroes counts towards the desired length</p>
</td></tr>
<tr><td><code id="pad0_+3A_value.start">value.start</code></td>
<td>
<p>the value to insert before the start index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the vector <code>v</code> padded to length <code>l</code> with value <code>value</code> (default 0).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pad0(1:5, 7)   # Pad to length 7 with zeroes
pad0(1:5, 3)   # no padding, but cut at length 3

# 3 leading zeroes, then the vector start (10 elements of vector, no additional padding needed):
pad0(1:10, 13, start = 3)

# padding with value other than zero:
pad0(1:5, 7, value = "pad")
</code></pre>

<hr>
<h2 id='padLast'>Pad the vector <code>v</code> to length <code>l</code> by repeating the last entry of the
vector.</h2><span id='topic+padLast'></span>

<h3>Description</h3>

<p>This function is just a trivial wrapper around <code>pad0</code> and only calls <code><a href="#topic+pad0">pad0()</a></code>
with the last element of the vector as padding value instead of the default 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padLast(v, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="padLast_+3A_v">v</code></td>
<td>
<p>the vector to pad by repeating the last element</p>
</td></tr>
<tr><td><code id="padLast_+3A_...">...</code></td>
<td>
<p>arguments passed through to <code>pad0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector padded to the correct length
</p>


<h3>Examples</h3>

<pre><code class='language-R'>padLast(1:5, 7) # 5 is repeated twice
padLast(1:5, 3) # no padding needed

</code></pre>

<hr>
<h2 id='PaymentTimeSingleEnum-class'>Enum to describe when a benefit or premium payment is due (in advance or in arrears)</h2><span id='topic+PaymentTimeSingleEnum-class'></span><span id='topic+PaymentTimeEnum'></span>

<h3>Description</h3>

<p>Enum to describe when a benefit or premium payment is due (in advance or in arrears)
</p>


<h3>Details</h3>

<p>Currently, only two values are allowed;
</p>

<ul>
<li><p> &quot;in advance&quot;
</p>
</li>
<li><p> &quot;in arrears&quot;
</p>
</li></ul>


<hr>
<h2 id='premiumRefundPeriod.default'>Default premium refund period: for deferred contracts the deferral period, otherwise the whole contract</h2><span id='topic+premiumRefundPeriod.default'></span>

<h3>Description</h3>

<p>If a premium refund is set for the tariff, the default is the full contract
period, except for deferred contracts (typically deferred life annuities),
for which the deferral period is the refund period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>premiumRefundPeriod.default(params, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="premiumRefundPeriod.default_+3A_params">params</code></td>
<td>
<p>The full parameter set of the insurance contract (including
all inherited values from the tariff and the profit participation)</p>
</td></tr>
<tr><td><code id="premiumRefundPeriod.default_+3A_values">values</code></td>
<td>
<p>The values calculated from the insurance contract so far</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length of the premium refund period (deferral period for deferred contracts, contract period otherwise)
</p>

<hr>
<h2 id='ProfitComponentsMultipleEnum-class'>Enum to define the different components of profit participation.</h2><span id='topic+ProfitComponentsMultipleEnum-class'></span><span id='topic+ProfitComponentsEnum'></span>

<h3>Description</h3>

<p>Enum to define the different components of profit participation.
</p>


<h3>Details</h3>

<p>Profit participation schemes typically consist of different components,
which are calculated independently. Typical components are interest profit
to distribute investment gains to the customer, risk profit and expense profit
to return security margins in the biometric risk and the expenses to the customer
and sum profit, which aplies to contracts with higher sums insured, where
charged expenses are calculated from the sum insured, while the actual
expenses are more or less constant. Thus, high contracts are charged more,
which causes profits that are returned as sum profit.
</p>
<p>As a special case, part of the profits can be stored in a terminal bonus
reserve and only distributed on maturity (or potentially on death), but
not on surrender. Some (older) profit participation schemes add an independently
calculated bonus on maturity (e.g. twice the total profit assignment of the
last year) at maturity to give customers an additional incentive not to
surrender a contract.
</p>
<p>Possible values are (multiple can be given):
</p>

<ul>
<li><p> &quot;interest&quot;
</p>
</li>
<li><p> &quot;risk&quot;
</p>
</li>
<li><p> &quot;expense&quot;
</p>
</li>
<li><p> &quot;sum&quot;
</p>
</li>
<li><p> &quot;terminal&quot;
</p>
</li>
<li><p> &quot;TBF&quot;
</p>
</li></ul>


<hr>
<h2 id='ProfitParticipation'>Base Class for Profit Participation Schemes</h2><span id='topic+ProfitParticipation'></span>

<h3>Description</h3>

<p>Base Class for Profit Participation Schemes
</p>
<p>Base Class for Profit Participation Schemes
</p>


<h3>Details</h3>

<p>Base class for Profit Participation schemes  (holding contract-independent values and
providing methods to calculate the profit participation values from the given
reserves).
</p>
<p>The profit participation object is typically not used directly, but rather
defined once and then passed on to an <a href="#topic+InsuranceTarif">InsuranceTarif</a> or <a href="#topic+InsuranceContract">InsuranceContract</a>
object, where it will be used internally when profit participation is
calculated.
</p>
<p>This class provides the technical implementation of a profit plan for traditional
life insurance contracts with a guaranteed component (calculated before the
profit scheme comes into play) and a discretionary profit on top.
</p>
<p>This function is called when a new profit participation scheme
is created with a call to <code>ProfitParticipation$new(...)</code>. Possible
parameters to the <code>new</code>-Call are all parameters from the <code>ProfitParticipation</code> sublist of the
<a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a> parameter
structure (which are understood as template values that can be overridden
per contract or even per profit participation scenario) and the components
of the <code>Functions</code> field defining the functions to calculate the individual
components of the profit participation (rates, calculation bases, calculation, benefits)
</p>
<p>This method <code>createModification</code> returns a copy of the profit scheme
with all given arguments changed in the schmes's <code>Parameters</code>
parameter list.
</p>
<p>As ProfitParticipation is a R6 class with reference logic, simply assigning
the object to a new variable does not create a copy, but references the
original profit scheme object. To create an actual copy, one needs to call this
method, which first clones the whole object and then adjusts all parameters
to the values passed to this method.
</p>
<p>The <a href="#topic+InsuranceContract">InsuranceContract</a>'s param structure <a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a>
contains the field <code>params$ProfitParticipation$advanceProfitParticipation</code>,
which can either be numeric rate for advance profit participation, or
a function with signature <code>function(params, values, ...)</code> that
returns the advance profit participation rate when called with the
contract's parameters and the values calculated so far (cash flows and premiums)
</p>
<p>The <a href="#topic+InsuranceContract">InsuranceContract</a>'s param structure <a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a>
contains the field <code>params$ProfitParticipation$advanceProfitParticipationInclUnitCost</code>,
which can either be numeric rate for advance profit participation, or
a function with signature <code>function(params, values, ...)</code> that
returns the advance profit participation rate when called with the
contract's parameters and the values calculated so far (cash flows and premiums)
</p>
<p>This function provides an easy way to modify the whole set of
profit rates after their initial setup. Possible applications are waiting
periods, which can be implemented once for all rates rather than inside
each individual calculation period.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>The human-readable name of the profit plan.</p>
</dd>
<dt><code>Parameters</code></dt><dd><p>Parameter template for profit-participation-specific
parameters, i.e. the <code>ProfitParticipation</code> element of the
<a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a> data structure.
</p>
<p>All elements defined in the profit scheme can be overriden per contract
in the call to <code>[InsuranceContract]$new</code> or even in the explicit
call to <a href="../../LifeInsureR/html/InsuranceContract.html#method-profitScenario"><code>InsuranceContract$profitScenario()</code></a>
or <a href="../../LifeInsureR/html/InsuranceContract.html#method-addProfitScenario"><code>InsuranceContract$addProfitScenario()</code></a>.</p>
</dd>
<dt><code>Functions</code></dt><dd><p>list of functions defined to calculate the individual
components. For each of the profit components
</p>

<ul>
<li><p> interest profit
</p>
</li>
<li><p> risk profit
</p>
</li>
<li><p> expense profit
</p>
</li>
<li><p> sum profit
</p>
</li>
<li><p> terminal bonus
</p>
</li>
<li><p> terminal bonus fund
</p>
</li></ul>

<p>a rate,  a profit base and a calculation function can be defined, by assigning one of the pre-defined
<a href="#topic+ProfitParticipationFunctions">ProfitParticipationFunctions</a> or proving your own function with signature
<code>function(rates, params, values, ...)</code>. Additionally, for each of the
benefit types (survival, death, surrender, premium waiver) a function can
be provided to calculate the benefit stemming from profit participation.</p>
</dd>
<dt><code>dummy</code></dt><dd><p>Dummy to allow commas in the previous method</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ProfitParticipation-new"><code>ProfitParticipation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-setParameters"><code>ProfitParticipation$setParameters()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-setFunctions"><code>ProfitParticipation$setFunctions()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-setFallbackParameters"><code>ProfitParticipation$setFallbackParameters()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-createModification"><code>ProfitParticipation$createModification()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-getAdvanceProfitParticipation"><code>ProfitParticipation$getAdvanceProfitParticipation()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-getAdvanceProfitParticipationAfterUnitCosts"><code>ProfitParticipation$getAdvanceProfitParticipationAfterUnitCosts()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-setupRates"><code>ProfitParticipation$setupRates()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-adjustRates"><code>ProfitParticipation$adjustRates()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-getProfitParticipation"><code>ProfitParticipation$getProfitParticipation()</code></a>
</p>
</li>
<li> <p><a href="#method-ProfitParticipation-clone"><code>ProfitParticipation$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ProfitParticipation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new profit participation scheme
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$new(name = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the profit scheme (typicall the name of the profit plan and its version)</p>
</dd>
<dt><code>...</code></dt><dd><p>profit participation parameters to be stored in the
<code style="white-space: pre;">&#8288;Parameters field or calculation functions to be stored in the &#8288;</code>Functions'
field</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProfitParticipation-setParameters"></a>



<h4>Method <code>setParameters()</code></h4>

<p>Store all passed parameters in the <code>Parameters</code> field
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$setParameters(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>any of the named fields defined in the <code>ProfitParticipation</code> sublist of the
<a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a>. All other arguments will be ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProfitParticipation-setFunctions"></a>



<h4>Method <code>setFunctions()</code></h4>

<p>Store all passed functions in the <code>Functions</code> field
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$setFunctions(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>any of the functions defined in the <code>Functions</code> field. All other
arguments will be ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProfitParticipation-setFallbackParameters"></a>



<h4>Method <code>setFallbackParameters()</code></h4>

<p>Fill all missing parameters with the default fall-back values
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$setFallbackParameters()</pre></div>


<hr>
<a id="method-ProfitParticipation-createModification"></a>



<h4>Method <code>createModification()</code></h4>

<p>create a copy of a profit scheme with certain parameters changed
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$createModification(name = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The new name for the cloned <a href="#topic+ProfitParticipation">ProfitParticipation</a> object</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters for the <a href="#topic+InsuranceContract.ParameterStructure">InsuranceContract.ParameterStructure</a>,
defining the characteristics of the tariff.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProfitParticipation-getAdvanceProfitParticipation"></a>



<h4>Method <code>getAdvanceProfitParticipation()</code></h4>

<p>Calculate and return the advance profit participation (to be
applied on the actuarial gross premium)
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$getAdvanceProfitParticipation(params, values, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (guaranteed component of the
insurance contract, including cash flows, premiums, reserves etc.).</p>
</dd>
<dt><code>...</code></dt><dd><p>optional parameters, to be passed to the advanceProfitParticipation
field of the parameter structure (if that is a function)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Return either one numerical value (constant for the whole premium payment period)
of a vector of numerical values for the whole contract period
</p>


<hr>
<a id="method-ProfitParticipation-getAdvanceProfitParticipationAfterUnitCosts"></a>



<h4>Method <code>getAdvanceProfitParticipationAfterUnitCosts()</code></h4>

<p>Calculate and return the advance profit participation (to be
applied after unit costs are added to the gross premium)
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$getAdvanceProfitParticipationAfterUnitCosts(
  params,
  values,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (guaranteed component of the
insurance contract, including cash flows, premiums, reserves etc.).</p>
</dd>
<dt><code>...</code></dt><dd><p>optional parameters, to be passed to the advanceProfitParticipationInclUnitCost
field of the parameter structure (if that is a function)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Return either one numerical value (constant for the whole premium payment period)
of a vector of numerical values for the whole contract period
</p>


<hr>
<a id="method-ProfitParticipation-setupRates"></a>



<h4>Method <code>setupRates()</code></h4>

<p>Set up the data.frame containing the profit participation rates
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$setupRates(params, values, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (guaranteed component of the
insurance contract, including cash flows, premiums, reserves etc.).</p>
</dd>
<dt><code>...</code></dt><dd><p>additional parameters passed to the profit calculation functions
stored in the <code>Functions</code> field.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProfitParticipation-adjustRates"></a>



<h4>Method <code>adjustRates()</code></h4>

<p>Adjust the data.frame of profit participation rates after their setup
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$adjustRates(rates, params, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rates</code></dt><dd><p>data.frame of profit paticipation rates</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (guaranteed component of the
insurance contract, including cash flows, premiums, reserves etc.).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProfitParticipation-getProfitParticipation"></a>



<h4>Method <code>getProfitParticipation()</code></h4>

<p>Calculation the full time series of profit participation for
the given contract values
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$getProfitParticipation(
  calculateFrom = 0,
  profitScenario = NULL,
  params,
  values,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>calculateFrom</code></dt><dd><p>The time from which to start calculating the profit
participation. When a contract is changed at some time t (possibly even
changing the profit scheme), all future profit participation needs to be
re-calculated from that time on, without changing past profit participation.
All values before <code>calculateFrom</code> will not be calculated.</p>
</dd>
<dt><code>profitScenario</code></dt><dd><p>profit participation values from a previous calculation
(NULL if profit calculation is to be calculated from the contract inception).
Values before <code>calculateFrom</code> will be used from this data.frame.</p>
</dd>
<dt><code>params</code></dt><dd><p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</dd>
<dt><code>values</code></dt><dd><p>Contract values calculated so far (guaranteed component of the
insurance contract, including cash flows, premiums, reserves etc.).</p>
</dd>
<dt><code>...</code></dt><dd><p>additional parameters to be passed to <a href="../../LifeInsureR/html/ProfitParticipation.html#method-setupRates"><code>ProfitParticipation$setupRates()</code></a></p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProfitParticipation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProfitParticipation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ProfitParticipationFunctions'>Helper functions for profit participation</h2><span id='topic+ProfitParticipationFunctions'></span><span id='topic+PP.base.NULL'></span><span id='topic+PP.base.PreviousZillmerReserve'></span><span id='topic+PP.base.ZillmerReserveT2'></span><span id='topic+PP.base.contractualReserve'></span><span id='topic+PP.base.previousContractualReserve'></span><span id='topic+PP.base.meanContractualReserve'></span><span id='topic+PP.base.ZillmerRiskPremium'></span><span id='topic+PP.base.sumInsured'></span><span id='topic+PP.base.totalProfitAssignment'></span><span id='topic+PP.rate.interestProfit'></span><span id='topic+PP.rate.riskProfit'></span><span id='topic+PP.rate.expenseProfit'></span><span id='topic+PP.rate.sumProfit'></span><span id='topic+PP.rate.terminalBonus'></span><span id='topic+PP.rate.terminalBonusFund'></span><span id='topic+PP.rate.interestProfitPlusGuarantee'></span><span id='topic+PP.rate.interestProfit2PlusGuarantee'></span><span id='topic+PP.rate.totalInterest'></span><span id='topic+PP.rate.totalInterest2'></span><span id='topic+PP.rate.interestProfit2'></span><span id='topic+getTerminalBonusReserve'></span><span id='topic+PP.calculate.RateOnBase'></span><span id='topic+PP.calculate.RateOnBaseMin0'></span><span id='topic+PP.calculate.RatePlusGuaranteeOnBase'></span><span id='topic+PP.calculate.RateOnBaseSGFFactor'></span><span id='topic+sumProfits'></span><span id='topic+PP.benefit.ProfitPlusTerminalBonusReserve'></span><span id='topic+PP.benefit.Profit'></span><span id='topic+PP.benefit.ProfitPlusGuaranteedInterest'></span><span id='topic+PP.benefit.ProfitPlusTotalInterest'></span><span id='topic+PP.benefit.ProfitPlusHalfTotalInterest'></span><span id='topic+PP.benefit.ProfitPlusHalfGuaranteedInterest'></span><span id='topic+PP.benefit.ProfitPlusInterestMinGuaranteeTotal'></span><span id='topic+PP.benefit.ProfitPlusHalfInterestMinGuaranteeTotal'></span><span id='topic+PP.benefit.ProfitGuaranteeSupporting'></span><span id='topic+PP.benefit.TerminalBonus5YearsProRata'></span><span id='topic+PP.benefit.TerminalBonus5Years'></span><span id='topic+PP.benefit.TerminalBonus'></span><span id='topic+PP.benefit.None'></span>

<h3>Description</h3>

<p>Various helper functions for the <code>ProfitParticipation</code> class that
provide the building blocks for the individual components of profit participation,
the rates and how the assigned profit is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PP.base.NULL(rates, params, values, ...)

PP.base.PreviousZillmerReserve(rates, params, values, ...)

PP.base.ZillmerReserveT2(rates, params, values, ...)

PP.base.contractualReserve(rates, params, values, ...)

PP.base.previousContractualReserve(rates, params, values, ...)

PP.base.meanContractualReserve(rates, params, values, ...)

PP.base.ZillmerRiskPremium(rates, params, values, ...)

PP.base.sumInsured(rates, params, values, ...)

PP.base.totalProfitAssignment(res, ...)

PP.rate.interestProfit(rates, ...)

PP.rate.riskProfit(rates, ...)

PP.rate.expenseProfit(rates, ...)

PP.rate.sumProfit(rates, ...)

PP.rate.terminalBonus(rates, ...)

PP.rate.terminalBonusFund(rates, ...)

PP.rate.interestProfitPlusGuarantee(rates, ...)

PP.rate.interestProfit2PlusGuarantee(rates, ...)

PP.rate.totalInterest(rates, ...)

PP.rate.totalInterest2(rates, ...)

PP.rate.interestProfit2(rates, ...)

getTerminalBonusReserve(
  profits,
  rates,
  terminalBonus,
  terminalBonusAccount,
  params,
  values,
  ...
)

PP.calculate.RateOnBase(base, rate, waiting, rates, params, values, ...)

PP.calculate.RateOnBaseMin0(base, rate, waiting, rates, params, values, ...)

PP.calculate.RatePlusGuaranteeOnBase(
  base,
  rate,
  waiting,
  rates,
  params,
  values,
  ...
)

PP.calculate.RateOnBaseSGFFactor(
  base,
  rate,
  waiting,
  rates,
  params,
  values,
  ...
)

sumProfits(profits, cols)

PP.benefit.ProfitPlusTerminalBonusReserve(profits, ...)

PP.benefit.Profit(profits, ...)

PP.benefit.ProfitPlusGuaranteedInterest(profits, rates, ...)

PP.benefit.ProfitPlusTotalInterest(profits, rates, params, values)

PP.benefit.ProfitPlusHalfTotalInterest(profits, ...)

PP.benefit.ProfitPlusHalfGuaranteedInterest(profits, rates, ...)

PP.benefit.ProfitPlusInterestMinGuaranteeTotal(profits, rates, ...)

PP.benefit.ProfitPlusHalfInterestMinGuaranteeTotal(profits, rates, ...)

PP.benefit.ProfitGuaranteeSupporting(profits, rates, params, values, ...)

PP.benefit.TerminalBonus5YearsProRata(profits, params, ...)

PP.benefit.TerminalBonus5Years(profits, params, ...)

PP.benefit.TerminalBonus(profits, params, ...)

PP.benefit.None(profits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProfitParticipationFunctions_+3A_rates">rates</code></td>
<td>
<p>data.frame of profit rates</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_params">params</code></td>
<td>
<p>Contract-specific, full set of parameters of the contract
(merged parameters of the defaults, the tariff, the profit participation
scheme and the contract)</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_values">values</code></td>
<td>
<p>Contract values calculated so far (guaranteed component of the
insurance contract, including cash flows, premiums, reserves etc.).</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_...">...</code></td>
<td>
<p>Other values that might be used for the calculation (currently unused)</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_res">res</code></td>
<td>
<p>the data.frame of reserves.</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_profits">profits</code></td>
<td>
<p>The array of profit participation component values</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_terminalbonus">terminalBonus</code></td>
<td>
<p>The terminal bonus calculated</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_terminalbonusaccount">terminalBonusAccount</code></td>
<td>
<p>The terminal bonus account (like a bank account,
where terminal bonuses are accrued, potentiall discounted from the maturity)</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_base">base</code></td>
<td>
<p>The profit calculation base, on which the rate is to be applied</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_rate">rate</code></td>
<td>
<p>The profit participation rate</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_waiting">waiting</code></td>
<td>
<p>A possible waiting period</p>
</td></tr>
<tr><td><code id="ProfitParticipationFunctions_+3A_cols">cols</code></td>
<td>
<p>The columns of the profit values array to be summed (columns given that do not exist in the profits array are ignired)</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>PP.base.NULL()</code>: Basis for profit: NONE (i.e. always returns 0)
</p>
</li>
<li> <p><code>PP.base.PreviousZillmerReserve()</code>: Basis for profit: Previous Zillmer reserve (no administration cost reserve)
</p>
</li>
<li> <p><code>PP.base.ZillmerReserveT2()</code>: Basis for profit: Zillmer reserve (no administration cost reserve) at time t-2
</p>
</li>
<li> <p><code>PP.base.contractualReserve()</code>: Basis for profit: Contractual reserve (including administration costs) at time t
</p>
</li>
<li> <p><code>PP.base.previousContractualReserve()</code>: Basis for profit: Contractual reserve (including administration costs) at time t-1
</p>
</li>
<li> <p><code>PP.base.meanContractualReserve()</code>: Basis for profit: Contractual reserve (including administration costs) averaged over t and t-1
</p>
</li>
<li> <p><code>PP.base.ZillmerRiskPremium()</code>: Basis for risk/mortality profit: Zillmer Risk Premium of the past year
</p>
</li>
<li> <p><code>PP.base.sumInsured()</code>: Basis for expense/sum profit: sum insured
</p>
</li>
<li> <p><code>PP.base.totalProfitAssignment()</code>: Basis for Terminal Bonus Fund Assignment: total profit assignment of the year
</p>
</li>
<li> <p><code>PP.rate.interestProfit()</code>: Returns the array of interest profit rates (keyed by year)
</p>
</li>
<li> <p><code>PP.rate.riskProfit()</code>: Returns the array of risk profit rates (keyed by year)
</p>
</li>
<li> <p><code>PP.rate.expenseProfit()</code>: Returns the array of expense profit rates (keyed by year)
</p>
</li>
<li> <p><code>PP.rate.sumProfit()</code>: Returns the array of sum profit rates (keyed by year)
</p>
</li>
<li> <p><code>PP.rate.terminalBonus()</code>: Returns the array of terminal bonus rates (keyed by year)
</p>
</li>
<li> <p><code>PP.rate.terminalBonusFund()</code>: Returns the array of terminal bonus rates (keyed by year) as the terminal bonus fund ratio
</p>
</li>
<li> <p><code>PP.rate.interestProfitPlusGuarantee()</code>: Rate for interest on past profits: total credited rate, but at least the guarantee
</p>
</li>
<li> <p><code>PP.rate.interestProfit2PlusGuarantee()</code>: Rate for interest on past profits: total creditedrate2, but at least the guarantee
</p>
</li>
<li> <p><code>PP.rate.totalInterest()</code>: Rate for interest on past profits: total interest rate
</p>
</li>
<li> <p><code>PP.rate.totalInterest2()</code>: Rate for interest on past profits: second total interest rate
</p>
</li>
<li> <p><code>PP.rate.interestProfit2()</code>: Rate for interest on past profits: second interest profit rate (not including guaranteed interest), keyed by year
</p>
</li>
<li> <p><code>getTerminalBonusReserve()</code>: Calculate the terminal bonus reserve.
</p>
</li>
<li> <p><code>PP.calculate.RateOnBase()</code>: Calculate profit by a simple rate applied on the basis (with an optional waiting vector of values 0 or 1)
</p>
</li>
<li> <p><code>PP.calculate.RateOnBaseMin0()</code>: Calculate profit by a simple rate applied on the basis (with an optional waiting vector of values 0 or 1), bound below by 0
</p>
</li>
<li> <p><code>PP.calculate.RatePlusGuaranteeOnBase()</code>: Calculate profit by a rate + guaranteed interest applied on the basis (with an optional waiting vector of values 0 or 1)
</p>
</li>
<li> <p><code>PP.calculate.RateOnBaseSGFFactor()</code>: Calculate profit by a simple rate applied on the basis (with only (1-SGFFactor) put into profit participation, and an optional waiting vector of values 0 or 1)
</p>
</li>
<li> <p><code>sumProfits()</code>: Extract the given columns of the profit participation array of values and sum
them up. Columns that do not exist, because the profit scheme does not
provide the corresponding profit component will be silently ignored.
This allows generic benefit calculation functions to be written that do
not need to distinguish e.g. whether an old-style terminal bonus or a terminal
bonus fund is provided.
</p>
<p>This function is not meant to be called directly, but within a profit benefit
calculation function.
</p>
</li>
<li> <p><code>PP.benefit.ProfitPlusTerminalBonusReserve()</code>: Calculate survival benefit as total profit amount plus the terminal bonus reserve
</p>
</li>
<li> <p><code>PP.benefit.Profit()</code>: Calculate benefit as total profit accrued so far
</p>
</li>
<li> <p><code>PP.benefit.ProfitPlusGuaranteedInterest()</code>: Calculate accrued death benefit as total profit with (guaranteed) interest for one year
</p>
</li>
<li> <p><code>PP.benefit.ProfitPlusTotalInterest()</code>: Calculate accrued death benefit as total profit with total interest (interest on profit rate) for one year
</p>
</li>
<li> <p><code>PP.benefit.ProfitPlusHalfTotalInterest()</code>: Calculate accrued benefit as total profit with total interest (interest on profit rate) for half a year
</p>
</li>
<li> <p><code>PP.benefit.ProfitPlusHalfGuaranteedInterest()</code>: Calculate death benefit as total profit with (guaranteed) interest for one year
</p>
</li>
<li> <p><code>PP.benefit.ProfitPlusInterestMinGuaranteeTotal()</code>: Calculate accrued benefit as total profit with interest for one year (max of guarantee and total interest)
</p>
</li>
<li> <p><code>PP.benefit.ProfitPlusHalfInterestMinGuaranteeTotal()</code>: Calculate accrued benefit as total profit with interest for half a year (max of guarantee and total interest)
</p>
</li>
<li> <p><code>PP.benefit.ProfitGuaranteeSupporting()</code>: Calculate accrued benefit as regular profit, but used to cover initial Zillmerization
</p>
</li>
<li> <p><code>PP.benefit.TerminalBonus5YearsProRata()</code>: Calculate benefit from terminal bonus as 1/n parts of the terminal bonus reserve during the last 5 years
</p>
</li>
<li> <p><code>PP.benefit.TerminalBonus5Years()</code>: Terminal bonus is only paid out during the last 5 years of the contract (but never during the first 10 years)
</p>
</li>
<li> <p><code>PP.benefit.TerminalBonus()</code>: Calculate benefit from terminal bonus (full bonus), either old-style terminal bonus reserve or Terminal Bonus Fund (TBF)
</p>
</li>
<li> <p><code>PP.benefit.None()</code>: No benefit paid out
</p>
</li></ul>

<hr>
<h2 id='PVfactory'>PVfactory (R6Class for present values with arbitrary dimensions)</h2><span id='topic+PVfactory'></span>

<h3>Description</h3>

<p>PVfactory (R6Class for present values with arbitrary dimensions)
</p>
<p>PVfactory (R6Class for present values with arbitrary dimensions)
</p>


<h3>Details</h3>

<p>provides functions to calculate present values for survival, death, dread
disease, invalidity and guaranteed benefits in various dimensions
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PVfactory-new"><code>PVfactory$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PVfactory-guaranteed"><code>PVfactory$guaranteed()</code></a>
</p>
</li>
<li> <p><a href="#method-PVfactory-survival"><code>PVfactory$survival()</code></a>
</p>
</li>
<li> <p><a href="#method-PVfactory-death"><code>PVfactory$death()</code></a>
</p>
</li>
<li> <p><a href="#method-PVfactory-disease"><code>PVfactory$disease()</code></a>
</p>
</li>
<li> <p><a href="#method-PVfactory-afterDeath"><code>PVfactory$afterDeath()</code></a>
</p>
</li>
<li> <p><a href="#method-PVfactory-clone"><code>PVfactory$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PVfactory-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the present value factory with defaults for qx, interest and multiple payments per year
</p>


<h5>Usage</h5>

<div class="r"><pre>PVfactory$new(qx, m = 1, mCorrection = list(alpha = 1, beta = 0), v = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>qx</code></dt><dd><p>the vector of mortality / death probabilities</p>
</dd>
<dt><code>m</code></dt><dd><p>the number of yearly payments</p>
</dd>
<dt><code>mCorrection</code></dt><dd><p>the list of alpha/beta to correct present values for multiple payments per year</p>
</dd>
<dt><code>v</code></dt><dd><p>the discount factor (1 / (1+i))</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PVfactory-guaranteed"></a>



<h4>Method <code>guaranteed()</code></h4>

<p>Present values of guaranteed benefits (paid in advance or arrears, possible multiple times per year)
</p>


<h5>Usage</h5>

<div class="r"><pre>PVfactory$guaranteed(
  advance = NULL,
  arrears = NULL,
  start = 0,
  ...,
  m = private$m,
  mCorrection = private$mCorrection,
  v = private$v
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>advance</code></dt><dd><p>the payment cashflows in advance</p>
</dd>
<dt><code>arrears</code></dt><dd><p>the payment cashflows in arrears</p>
</dd>
<dt><code>start</code></dt><dd><p>the time index, where the PV calculation should be based</p>
</dd>
<dt><code>...</code></dt><dd><p>other parameters (currently not used, for future use)</p>
</dd>
<dt><code>m</code></dt><dd><p>the number of yearly payments</p>
</dd>
<dt><code>mCorrection</code></dt><dd><p>the list of alpha/beta to correct present values for multiple payments per year</p>
</dd>
<dt><code>v</code></dt><dd><p>the discount factor (1 / (1+i))</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PVfactory-survival"></a>



<h4>Method <code>survival()</code></h4>

<p>Present values of survival benefits (paid in advance or arrears, possible multiple times per year)
</p>


<h5>Usage</h5>

<div class="r"><pre>PVfactory$survival(
  advance = NULL,
  arrears = NULL,
  start = 0,
  ...,
  m = private$m,
  mCorrection = private$mCorrection,
  v = private$v
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>advance</code></dt><dd><p>the payment cashflows in advance</p>
</dd>
<dt><code>arrears</code></dt><dd><p>the payment cashflows in arrears</p>
</dd>
<dt><code>start</code></dt><dd><p>the time index, where the PV calculation should be based</p>
</dd>
<dt><code>...</code></dt><dd><p>other parameters (currently not used, for future use)</p>
</dd>
<dt><code>m</code></dt><dd><p>the number of yearly payments</p>
</dd>
<dt><code>mCorrection</code></dt><dd><p>the list of alpha/beta to correct present values for multiple payments per year</p>
</dd>
<dt><code>v</code></dt><dd><p>the discount factor (1 / (1+i))</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PVfactory-death"></a>



<h4>Method <code>death()</code></h4>

<p>Present values of death benefits
</p>


<h5>Usage</h5>

<div class="r"><pre>PVfactory$death(benefits, start = 0, ..., v = private$v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>benefits</code></dt><dd><p>the vector of death / invalidity / disease benefits</p>
</dd>
<dt><code>start</code></dt><dd><p>the time index, where the PV calculation should be based</p>
</dd>
<dt><code>...</code></dt><dd><p>other parameters (currently not used, for future use)</p>
</dd>
<dt><code>v</code></dt><dd><p>the discount factor (1 / (1+i))</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PVfactory-disease"></a>



<h4>Method <code>disease()</code></h4>

<p>Present values of disease benefits
</p>


<h5>Usage</h5>

<div class="r"><pre>PVfactory$disease(benefits, start = 0, ..., v = private$v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>benefits</code></dt><dd><p>the vector of death / invalidity / disease benefits</p>
</dd>
<dt><code>start</code></dt><dd><p>the time index, where the PV calculation should be based</p>
</dd>
<dt><code>...</code></dt><dd><p>other parameters (currently not used, for future use)</p>
</dd>
<dt><code>v</code></dt><dd><p>the discount factor (1 / (1+i))</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PVfactory-afterDeath"></a>



<h4>Method <code>afterDeath()</code></h4>

<p>Present values of guaranteed benefits after death (paid in advance or arrears, possible multiple times per year)
</p>


<h5>Usage</h5>

<div class="r"><pre>PVfactory$afterDeath(
  advance = NULL,
  arrears = NULL,
  start = 0,
  ...,
  m = private$m,
  mCorrection = private$mCorrection,
  v = private$v
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>advance</code></dt><dd><p>the payment cashflows in advance</p>
</dd>
<dt><code>arrears</code></dt><dd><p>the payment cashflows in arrears</p>
</dd>
<dt><code>start</code></dt><dd><p>the time index, where the PV calculation should be based</p>
</dd>
<dt><code>...</code></dt><dd><p>other parameters (currently not used, for future use)</p>
</dd>
<dt><code>m</code></dt><dd><p>the number of yearly payments</p>
</dd>
<dt><code>mCorrection</code></dt><dd><p>the list of alpha/beta to correct present values for multiple payments per year</p>
</dd>
<dt><code>v</code></dt><dd><p>the discount factor (1 / (1+i))</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PVfactory-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PVfactory$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='rollingmean'>Calculate the rolling mean of length 2</h2><span id='topic+rollingmean'></span>

<h3>Description</h3>

<p>Calculate the rolling mean of length 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollingmean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollingmean_+3A_x">x</code></td>
<td>
<p>vector of values, for which the rolling mean is calculated</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rollingmean(1:10)
</code></pre>

<hr>
<h2 id='setCost'>Update one component of an <a href="#topic+InsuranceTarif">InsuranceTarif</a>'s cost structure</h2><span id='topic+setCost'></span>

<h3>Description</h3>

<p>Insurance tariff costs are defined by a cost matrix with dimensions: {CostType, Basis, Period}, where:
</p>

<dl>
<dt>CostType:</dt><dd><p>alpha, Zillmer, beta, gamma, gamma_nopremiums, unitcosts</p>
</dd>
<dt>Basis:</dt><dd><p>SumInsured, SumPremiums, GrossPremium, NetPremium, Constant</p>
</dd>
<dt>Period:</dt><dd><p>once, PremiumPeriod, PremiumFree, PolicyPeriod, AfterDeath, FullContract</p>
</dd>
</dl>

<p>After creation (using the function <code><a href="#topic+initializeCosts">initializeCosts()</a></code>), the funciton <code>setCost</code>
can be used to modify a single entry. While <code><a href="#topic+initializeCosts">initializeCosts()</a></code> provides arguments
to set the most common types of cost parameters in one call, the <code>setCost</code>
function allows to modify any cost parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCost(costs, type, basis = "SumInsured", frequency = "PolicyPeriod", value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setCost_+3A_costs">costs</code></td>
<td>
<p>The cost definition matrix (usually created by <code><a href="#topic+initializeCosts">initializeCosts()</a></code>)</p>
</td></tr>
<tr><td><code id="setCost_+3A_type">type</code></td>
<td>
<p>The cost type (alpha, Zillmer, beta, gamma, gamma_nopremiums, unitcosts)</p>
</td></tr>
<tr><td><code id="setCost_+3A_basis">basis</code></td>
<td>
<p>The basis fo which the cost rate is applied (default is SumInsured)</p>
</td></tr>
<tr><td><code id="setCost_+3A_frequency">frequency</code></td>
<td>
<p>How often / during which period the cost is charged (once, PremiumPeriod, PremiumFree, PolicyPeriod, FullContract)</p>
</td></tr>
<tr><td><code id="setCost_+3A_value">value</code></td>
<td>
<p>The new cost value to set for the given type, basis and frequency</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function modifies a copy of the cost structure and returns it, so this
function can be chained as often as desired and final return value will contain
all cost modifications.
</p>


<h3>Value</h3>

<p>The modified cost structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>costs = initializeCosts()
setCost(costs, "alpha", "SumPremiums", "once", 0.05)

</code></pre>

<hr>
<h2 id='SexSingleEnum-class'>Enum to describe possible sexes in an insurance contract or tariff.</h2><span id='topic+SexSingleEnum-class'></span><span id='topic+SexEnum'></span>

<h3>Description</h3>

<p>Enum to describe possible sexes in an insurance contract or tariff.
</p>


<h3>Details</h3>

<p>Currently, the only possible values are:
</p>

<ul>
<li><p> &quot;unisex&quot;
</p>
</li>
<li><p> &quot;male&quot;
</p>
</li>
<li><p> &quot;female&quot;
</p>
</li></ul>


<hr>
<h2 id='showVmGlgExamples'>Display insurance contract calculation example</h2><span id='topic+showVmGlgExamples'></span>

<h3>Description</h3>

<p>Display the values of the example calculation of the given insurance contract
as required by the Austrian regulation (LV-VMGLV, &quot;LV
Versicherungsmathematische Grundlagen Verordnung&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showVmGlgExamples(contract, prf = 10, t = 10, t_prf = 12, file = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showVmGlgExamples_+3A_contract">contract</code></td>
<td>
<p>The insurance contract to calculate and show</p>
</td></tr>
<tr><td><code id="showVmGlgExamples_+3A_prf">prf</code></td>
<td>
<p>Time of premium waiver (premium-free)</p>
</td></tr>
<tr><td><code id="showVmGlgExamples_+3A_t">t</code></td>
<td>
<p>Time for which to show all values (except premium-free values)</p>
</td></tr>
<tr><td><code id="showVmGlgExamples_+3A_t_prf">t_prf</code></td>
<td>
<p>Time for which to show all values after the premium waiver</p>
</td></tr>
<tr><td><code id="showVmGlgExamples_+3A_file">file</code></td>
<td>
<p>If given, outputs all information to the file rather than the console</p>
</td></tr>
<tr><td><code id="showVmGlgExamples_+3A_...">...</code></td>
<td>
<p>Further parameters for generating the contract for a tariff object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Name of the output file (invisible) or empty if printed to console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MortalityTables)
mortalityTables.load("Austria_Annuities_AVOe2005R")
# A trivial deferred annuity tariff with no costs:
tariff = InsuranceTarif$new(name="Test Annuity", type="annuity",
    mortalityTable = AVOe2005R.unisex, i=0.01)
contract = InsuranceContract$new(
    tariff,
    age = 35, YOB = 1981,
    policyPeriod = 30, premiumPeriod = 15, deferralPeriod = 15,
    sumInsured = 1000,
    contractClosing = as.Date("2016-10-01")
);
showVmGlgExamples(contract)

# Optionally output to a file rather than the console:

showVmGlgExamples(contract, file =  tempfile("annuity-example", fileext = ".txt"))

</code></pre>

<hr>
<h2 id='TariffTypeSingleEnum-class'>An enum specifying the main characteristics of the tarif.</h2><span id='topic+TariffTypeSingleEnum-class'></span><span id='topic+TariffTypeEnum'></span>

<h3>Description</h3>

<p>Possible values are:
</p>

<dl>
<dt>annuity</dt><dd><p>Whole life or term annuity (periodic survival benefits)
with flexible payouts (constand, increasing, decreasing, arbitrary,
etc.)</p>
</dd>
<dt>wholelife</dt><dd><p>A whole or term life insurance with only death benefits.
The benefit can be constant, increasing, decreasing, described by
a function, etc.</p>
</dd>
<dt>endowment</dt><dd><p>An  endowment with death and survival benefits,
potentially with different benefits.</p>
</dd>
<dt>pureendowment</dt><dd><p>A pure endowment with only a survival benefit at
the end of the contract. Optionally, in case of death, all or part
of the premiums paid may be refunded.</p>
</dd>
<dt>terme-fix</dt><dd><p>A terme-fix insurance with a fixed payout at the end
of the contract, even if the insured dies before that time.
Premiums are paid until death of the insured.</p>
</dd>
<dt>dread-disease</dt><dd><p>A dread-disease insurance, which pays in case of
a severe illness (typically heart attacks, cancer, strokes, etc.),
but not in case of death.</p>
</dd>
<dt>endowment + dread-disease</dt><dd><p>A combination of an endowment and a
temporary dread-disease insurance. Benefits occur either on death,
severe illness or survival, whichever comes first.</p>
</dd>
</dl>


<hr>
<h2 id='testVmGlgExample'>Perform unit tests of given standard values of the insurance contract example</h2><span id='topic+testVmGlgExample'></span>

<h3>Description</h3>

<p>Check the values of the example calculation of the given insurance contract
as required by the Austrian regulation (LV-VMGLV, &quot;LV
Versicherungsmathematische Grundlagen Verordnung&quot;).
Missing params not passed to the function call will be silently ignored and
not cause unit test failures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testVmGlgExample(
  contract,
  prf = 10,
  t = 10,
  t_prf = 12,
  net,
  Zillmer,
  gross,
  written,
  savings,
  risk,
  ZillmerRes,
  ZillmerRes.prf,
  VwKostenRes,
  VwKostenRes.prf,
  Bilanzreserve,
  Praemienuebertrag,
  Rueckkaufsreserve,
  Rueckkaufswert,
  Abschlusskostenruecktrag,
  Rueckkaufswert.prf,
  VS.prf,
  absTolerance = 0.015,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testVmGlgExample_+3A_contract">contract</code></td>
<td>
<p>The insurance contract to calculate and check</p>
</td></tr>
<tr><td><code id="testVmGlgExample_+3A_prf">prf</code></td>
<td>
<p>Time of premium waiver (premium-free)</p>
</td></tr>
<tr><td><code id="testVmGlgExample_+3A_t">t</code></td>
<td>
<p>Time for which to check all values (except premium-free values)</p>
</td></tr>
<tr><td><code id="testVmGlgExample_+3A_t_prf">t_prf</code></td>
<td>
<p>Time for which to check all values after the premium waiver</p>
</td></tr>
<tr><td><code id="testVmGlgExample_+3A_net">net</code>, <code id="testVmGlgExample_+3A_zillmer">Zillmer</code>, <code id="testVmGlgExample_+3A_gross">gross</code>, <code id="testVmGlgExample_+3A_written">written</code>, <code id="testVmGlgExample_+3A_savings">savings</code>, <code id="testVmGlgExample_+3A_risk">risk</code>, <code id="testVmGlgExample_+3A_zillmerres">ZillmerRes</code>, <code id="testVmGlgExample_+3A_zillmerres.prf">ZillmerRes.prf</code>, <code id="testVmGlgExample_+3A_vwkostenres">VwKostenRes</code>, <code id="testVmGlgExample_+3A_vwkostenres.prf">VwKostenRes.prf</code>, <code id="testVmGlgExample_+3A_bilanzreserve">Bilanzreserve</code>, <code id="testVmGlgExample_+3A_praemienuebertrag">Praemienuebertrag</code>, <code id="testVmGlgExample_+3A_rueckkaufsreserve">Rueckkaufsreserve</code>, <code id="testVmGlgExample_+3A_rueckkaufswert">Rueckkaufswert</code>, <code id="testVmGlgExample_+3A_abschlusskostenruecktrag">Abschlusskostenruecktrag</code>, <code id="testVmGlgExample_+3A_rueckkaufswert.prf">Rueckkaufswert.prf</code>, <code id="testVmGlgExample_+3A_vs.prf">VS.prf</code></td>
<td>
<p>Values as printed out by showVmGlgExamples</p>
</td></tr>
<tr><td><code id="testVmGlgExample_+3A_abstolerance">absTolerance</code></td>
<td>
<p>If non-NULL, will ignore small floating point differences. It uses same algorithm as all.equal()</p>
</td></tr>
<tr><td><code id="testVmGlgExample_+3A_...">...</code></td>
<td>
<p>Further parameters for generating the contract for a tariff object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The easiest way to write unit-tests is using the function <code>vmGlgExample.generateTest</code>
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MortalityTables)
library(testthat)
mortalityTables.load("Austria_Annuities_AVOe2005R")

test_that("Testtarif", {
    # A trivial deferred annuity tariff with no costs:
    library(MortalityTables)
    mortalityTables.load("Austria_Annuities")
    tariff = InsuranceTarif$new(name="Test Annuity", type="annuity",
        mortalityTable = AVOe2005R.unisex, i = 0.01)
    contract = InsuranceContract$new(
        tariff,
        age = 35, YOB = 1981,
        policyPeriod = 30, premiumPeriod = 15, deferralPeriod = 15,
        sumInsured = 1000,
        contractClosing = as.Date("2016-10-01")
    );

    testVmGlgExample(
        contract, t = 10,
        net = 850.09, # NOT_CHECKED: Zillmer = 950.09,
        gross = 850.09,
        written = 884.09,
        savings = 857.09, risk = -7.00,
        ZillmerRes = 9011.40,
        ZillmerRes.prf = 9205.96,
        VwKostenRes = 0.00,
        VwKostenRes.prf = 0.00,
        Bilanzreserve = 9250.35,
        Praemienuebertrag = 637.567,
        Rueckkaufsreserve = 9011.40,
        Rueckkaufswert = 9011.40,
        Abschlusskostenruecktrag = 0.00,
        Rueckkaufswert.prf = 9205.96,
        VS.prf = 684.117
    )
})

</code></pre>

<hr>
<h2 id='valueOrFunction'>If <code>val</code> is a function, evaluate it, otherwise return <code>val</code></h2><span id='topic+valueOrFunction'></span>

<h3>Description</h3>

<p>If <code>val</code> is a function, evaluate it, otherwise return <code>val</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valueOrFunction(val, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valueOrFunction_+3A_val">val</code></td>
<td>
<p>Function or value</p>
</td></tr>
<tr><td><code id="valueOrFunction_+3A_...">...</code></td>
<td>
<p>Argument passed to <code>val</code> if it is a function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value, potentially with the given function applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'>valueOrFunction(3) # returns 3
valueOrFunction(`+`, 1, 2) # also returns 3
A = `+`
valueOrFunction(A, 1, 2)
</code></pre>

<hr>
<h2 id='vmGlgExample.generateTest'>Generate testthat output for unit-testing a tarif implementation</h2><span id='topic+vmGlgExample.generateTest'></span>

<h3>Description</h3>

<p>This function calculates the required reference values for the given
insurance contract as required by the Austrian regulation (LV-VMGLV, &quot;LV
Versicherungsmathematische Grundlagen Verordnung&quot;) and generates the
code for unit-testing the contract with these values. The code printed
can be directly copied into a unit test file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmGlgExample.generateTest(contract, prf = 10, t = 10, t_prf = 12, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmGlgExample.generateTest_+3A_contract">contract</code></td>
<td>
<p>The insurance contract to calculate and generate unit-testing code.
If an InsuranceTarif object is given, a new contract with default
values is generated.</p>
</td></tr>
<tr><td><code id="vmGlgExample.generateTest_+3A_prf">prf</code></td>
<td>
<p>Time of premium waiver (premium-free)</p>
</td></tr>
<tr><td><code id="vmGlgExample.generateTest_+3A_t">t</code></td>
<td>
<p>Time for which to calculate all values (except premium-free values)</p>
</td></tr>
<tr><td><code id="vmGlgExample.generateTest_+3A_t_prf">t_prf</code></td>
<td>
<p>Time for which to calculated all values after the premium waiver</p>
</td></tr>
<tr><td><code id="vmGlgExample.generateTest_+3A_...">...</code></td>
<td>
<p>Further parameters for generating the contract for a tariff object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (code is printed to the console, but no value returned)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MortalityTables)
mortalityTables.load("Austria_Annuities_AVOe2005R")
# A trivial deferred annuity tariff with no costs:
tariff = InsuranceTarif$new(name="Test Annuity", type="annuity",
    mortalityTable = AVOe2005R.unisex, i=0.01)
vmGlgExample.generateTest(tariff,
    age = 35, YOB = 1981,
    policyPeriod = 30, premiumPeriod = 15, deferralPeriod = 15,
    sumInsured = 1000,
    contractClosing = as.Date("2016-10-01")
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
