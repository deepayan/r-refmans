<!DOCTYPE html><html><head><title>Help for package mhtboot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mhtboot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#datgen'><p>datgen</p></a></li>
<li><a href='#elbow'><p>Finding corner of a vector of ordered transformed p values</p></a></li>
<li><a href='#hitplots'><p>Plot area under p value cdf below a cutoff.</p></a></li>
<li><a href='#mht.1sample'><p>Multiple hypothesis testing based on p value distribution for one sample test</p></a></li>
<li><a href='#mhtboot'><p>mhtboot: A package for multiple hypothesis testing using bootstrap distribution of p values.</p></a></li>
<li><a href='#pboot.1sample'><p>Generate Bootstrap Distribution of p values for one sample tests.</p></a></li>
<li><a href='#pboot.1sample.s'><p>Generate p value distributions and estimate of sample correlation matrix using bootstrap.</p></a></li>
<li><a href='#pboot.2sample'><p>Generate bootstrap distribution of p values based on user given two sample tests.</p></a></li>
<li><a href='#plotchange'><p>plotchange</p></a></li>
<li><a href='#plotpboot'><p>Quantile plots for p value distributions.</p></a></li>
<li><a href='#ptrans'><p>Transformation of order statistics of the p value distributions</p></a></li>
<li><a href='#qelbow'><p>Finding corner of a quantile of ordered transformed p values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multiple Hypothesis Test Based on Distribution of p Values</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Abhirup Mallik [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Abhirup Mallik &lt;malli066@umn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for multiple hypothesis testing based on distribution
    of p values. It is well known that the p values come from different
    distribution for null and alternatives, in this package we provide
    functions to detect that change. We provide a method for using the change
    in distribution of p values as a way to detect the true signals in the
    data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), ggplot2, reshape2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-10-30 18:52:19 UTC; datageek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-10-30 22:14:24</td>
</tr>
</table>
<hr>
<h2 id='datgen'>datgen</h2><span id='topic+datgen'></span>

<h3>Description</h3>

<p>Function to generate data from multivariate normal with different mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datgen(n, m, m0, sigeff, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datgen_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="datgen_+3A_m">m</code></td>
<td>
<p>number of cords</p>
</td></tr>
<tr><td><code id="datgen_+3A_m0">m0</code></td>
<td>
<p>number of non sparse elements</p>
</td></tr>
<tr><td><code id="datgen_+3A_sigeff">sigeff</code></td>
<td>
<p>magnitude of signal</p>
</td></tr>
<tr><td><code id="datgen_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates data from multivariate normal distribution with given covariance matrix. The mean values are either zero or constant sigeff, randomly permuted among the coordinates.
</p>


<h3>Value</h3>

<p>X data matrix of size nxm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n = 50;m = 250;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)

## End(Not run)
</code></pre>

<hr>
<h2 id='elbow'>Finding corner of a vector of ordered transformed p values</h2><span id='topic+elbow'></span>

<h3>Description</h3>

<p>Finds corner of a vector of ordered transformed p values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elbow(zvec, rbuff = 25, h = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elbow_+3A_zvec">zvec</code></td>
<td>
<p>vector of ordered transformed p values</p>
</td></tr>
<tr><td><code id="elbow_+3A_rbuff">rbuff</code></td>
<td>
<p>scaler, by default 25. Controls the right buffer.</p>
</td></tr>
<tr><td><code id="elbow_+3A_h">h</code></td>
<td>
<p>scaler, default 30. Controls the window size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The corner point of ordered p values indicate the point where the change from the alternative to null happens. So, by detecting that point we get an estimate of the number of true alternatives. 
</p>
<p>This function uses two methods for corner detection. One method is by transforming the vectors by taking their first difference and centering them around a theoretical mean for null case. The other method is by detecting the maximum change in gradient at each point. These methods will be denoted by dav and dlm respectively.
</p>


<h3>Value</h3>

<p>vector with two elements, containing estimates of the index of corner 
</p>
<p>$dav: by average method.
$dlm: by maximum gradient method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:          
n = 50;m = 250;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
porder &lt;- pboot.1sample(X=X,B=500,ncpus = 1)
out &lt;- elbow(zvec = porder[1,])
out

## End(Not run)
</code></pre>

<hr>
<h2 id='hitplots'>Plot area under p value cdf below a cutoff.</h2><span id='topic+hitplots'></span>

<h3>Description</h3>

<p>Function to plot the area under the cdf below a certain cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hitplots(porder, alpha = 0.005)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hitplots_+3A_porder">porder</code></td>
<td>
<p>the feed from porder.1sample or porder.2sample. matrix of size Bxm. of ordered transformed p values.</p>
</td></tr>
<tr><td><code id="hitplots_+3A_alpha">alpha</code></td>
<td>
<p>the cutoff of ecd, by default 0.005.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alpha parameter specifies the cutoff, the plot is the ecdf under alpha. So the right tail of the ecdf would have probability alpha.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n = 50;m = 250;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
porder &lt;- pboot.1sample(X, B = 100, ncpus = 1)
hitplots(porder)

## End(Not run)
</code></pre>

<hr>
<h2 id='mht.1sample'>Multiple hypothesis testing based on p value distribution for one sample test</h2><span id='topic+mht.1sample'></span>

<h3>Description</h3>

<p>Implements multiple hypothesis testing based on bootstrap distribution of p values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mht.1sample(X, B = 100, test = t.test, nbx = NROW(X), ncpus = 8,
  rbuff = 25, h = 30, qi = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mht.1sample_+3A_x">X</code></td>
<td>
<p>matrix of data</p>
</td></tr>
<tr><td><code id="mht.1sample_+3A_b">B</code></td>
<td>
<p>bootstrap sample size, default is 100</p>
</td></tr>
<tr><td><code id="mht.1sample_+3A_test">test</code></td>
<td>
<p>one sample test. by default t.test(), user can provide own function, must return p values in $p.value</p>
</td></tr>
<tr><td><code id="mht.1sample_+3A_nbx">nbx</code></td>
<td>
<p>size of the bootstrap sample</p>
</td></tr>
<tr><td><code id="mht.1sample_+3A_ncpus">ncpus</code></td>
<td>
<p>number of cpu to use</p>
</td></tr>
<tr><td><code id="mht.1sample_+3A_rbuff">rbuff</code></td>
<td>
<p>right buffer for change detection</p>
</td></tr>
<tr><td><code id="mht.1sample_+3A_h">h</code></td>
<td>
<p>window size for change detection</p>
</td></tr>
<tr><td><code id="mht.1sample_+3A_qi">qi</code></td>
<td>
<p>the quantile to use for change detection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the dataset and produces the bootstrap distribtution of the transformed and ordered p values using the user given parameters. Then detects the change in the bootstrap distribution using the corner detection method. This method requires the user to specify the quantile to use for change detection. The change point is an estimate of the location of change from alternative to null and used to get the coordinates of the true signals.
</p>


<h3>Value</h3>

<p>list with two elements. cutoff: the location of corner, signal: the index of the detected coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 50;m = 100;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
out1 &lt;- mht.1sample(X,B=100,ncpus = 1)
out1$cutoff
out1$signal
</code></pre>

<hr>
<h2 id='mhtboot'>mhtboot: A package for multiple hypothesis testing using bootstrap distribution of p values.</h2><span id='topic+mhtboot'></span><span id='topic+mhtboot-package'></span>

<h3>Description</h3>

<p>The mhtboot package provides three categories of important functions:
pboot, elbow and mht.
</p>


<h3>pboot functions</h3>

<p>pboot functions provide bootstrap distribution of p values. The pvalues are ordered and transformed. Currently the default transformation is fn(p) = -log(1-p) and in future some more transformations would be provided. There are support for two type of tests. One sample and two sample tests. The corresponding two functions are pboot.1sample and pboot.2sample. The test function by default is taken to be t.test(), while the user can provide their own test function. Both of these functions are parallelized using multicore for better performance.
</p>


<h3>elbow functions</h3>

<p>The purpose of elbow functions is to detect the change in distribution of the ordered transfromed p values. The basic function for detecting this change is elbow(), which takes in a particular p value curve and estimates the change point. We also provide a function to process the bootstrap distribution of p values and generate the estimate of the change point corresponding to a quantile of the empirical distribution.
</p>


<h3>mht</h3>

<p>The general function implementing the proceedure for multiple hypothesis testing based on bootstrap distribution of the p values. All the controls associated with pboot functions and elbow functions are transferred in mht functions too. There are two functions corresponding to one sample and two sample tests. These functions are mht.1sample and mht.2sample.
</p>

<hr>
<h2 id='pboot.1sample'>Generate Bootstrap Distribution of p values for one sample tests.</h2><span id='topic+pboot.1sample'></span>

<h3>Description</h3>

<p>Performs bootstrap to generate empirical distribution of order statistics of p values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pboot.1sample(X, B = 100, test = t.test, nbx = NROW(X), ncpus = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pboot.1sample_+3A_x">X</code></td>
<td>
<p>matrix of data, each row is an independent observation nxm</p>
</td></tr>
<tr><td><code id="pboot.1sample_+3A_b">B</code></td>
<td>
<p>bootstrap sample size</p>
</td></tr>
<tr><td><code id="pboot.1sample_+3A_test">test</code></td>
<td>
<p>function for testing. default is t.test(). Must return a data frame with p value in $p.value.</p>
</td></tr>
<tr><td><code id="pboot.1sample_+3A_nbx">nbx</code></td>
<td>
<p>Sample size for the bootstrap samples. Default is NROW(X), which is same as the original data sample size.</p>
</td></tr>
<tr><td><code id="pboot.1sample_+3A_ncpus">ncpus</code></td>
<td>
<p>Number of cpus to use for bootstrap. We use parallel:multicore() to parallelize the bootstrap. For windows, use ncpus = 1, for any other machine, you can use the maximum permissible number for your system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We generate the bootstrap distribution of the order statistics of the p values. We are performing one sample test on each coordinate of the original dataset. The bootstrap used here is standard version with default bootstrap sample size being equal to data sample size. The default one sample test is t.test(), however the user can provide their own test functions. The only requirement is that it must return p values in $p.value column of the output.
The bootstrap is parallelized using multicore from the library parallel. Windows machines at this point does not support using multiple cores, so the ncpus option should be equal to 1 for windows. For other systems, it can be higher to speed up the process.
We also use a transofrmation of the p values, by default the transformation is -log(1-p). But the user can provide their own transformation function. They should be monotonically increasing functions.
</p>


<h3>Value</h3>

<p>matrix of dimension Bxm. (Where m coordinates), each row indicates transformed p values for that bootstrap sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n = 50;m = 250;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
porder &lt;- pboot.1sample(X=X,B=100,ncpus = 1)
plotpboot(porder)

## End(Not run)
</code></pre>

<hr>
<h2 id='pboot.1sample.s'>Generate p value distributions and estimate of sample correlation matrix using bootstrap.</h2><span id='topic+pboot.1sample.s'></span>

<h3>Description</h3>

<p>If the user chooses to keep sout as TRUE, then this function generates bootstrap distribution of p values and returns the mean of the correlation matrices of all the bootstrap samples generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pboot.1sample.s(X, B = 100, test = t.test, nbx = NROW(X), ncpus = 8,
  sout = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pboot.1sample.s_+3A_x">X</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="pboot.1sample.s_+3A_b">B</code></td>
<td>
<p>Bootstrap size</p>
</td></tr>
<tr><td><code id="pboot.1sample.s_+3A_test">test</code></td>
<td>
<p>test to perform</p>
</td></tr>
<tr><td><code id="pboot.1sample.s_+3A_nbx">nbx</code></td>
<td>
<p>bootstrap sample size, by default same as the data sample size</p>
</td></tr>
<tr><td><code id="pboot.1sample.s_+3A_ncpus">ncpus</code></td>
<td>
<p>number of cpus to use</p>
</td></tr>
<tr><td><code id="pboot.1sample.s_+3A_sout">sout</code></td>
<td>
<p>if correlation matrix is needed or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a matrix containing the p value distributions, and another matrix of correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n = 50;m = 250;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
porder &lt;- pboot.1sample.s(X=X,B=100,sout = TRUE,ncpus = 1)
plotpboot(porder)

## End(Not run) 
</code></pre>

<hr>
<h2 id='pboot.2sample'>Generate bootstrap distribution of p values based on user given two sample tests.</h2><span id='topic+pboot.2sample'></span>

<h3>Description</h3>

<p>Performs bootstrap to generate empirical distribution of order statistics of p values from two sample tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pboot.2sample(X, Y, B = 100, test = t.test, nbx = NROW(X),
  nby = NROW(Y), ncpus = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pboot.2sample_+3A_x">X</code></td>
<td>
<p>matrix of data, each row is an independent observation nxm</p>
</td></tr>
<tr><td><code id="pboot.2sample_+3A_y">Y</code></td>
<td>
<p>matrix of data, sample 2. each row is an independent observation nxm.</p>
</td></tr>
<tr><td><code id="pboot.2sample_+3A_b">B</code></td>
<td>
<p>bootstrap sample size</p>
</td></tr>
<tr><td><code id="pboot.2sample_+3A_test">test</code></td>
<td>
<p>function for testing. default is t.test(). Must return a data frame with p value in $p.value.</p>
</td></tr>
<tr><td><code id="pboot.2sample_+3A_nbx">nbx</code></td>
<td>
<p>Sample size for the bootstrap samples. Default is NROW(X), which is same as the original data sample size.</p>
</td></tr>
<tr><td><code id="pboot.2sample_+3A_nby">nby</code></td>
<td>
<p>Sample size for the bootstrap samples for second dataset. Default is NROW(X), which is same as the original data sample size.</p>
</td></tr>
<tr><td><code id="pboot.2sample_+3A_ncpus">ncpus</code></td>
<td>
<p>Number of cpus to use for bootstrap. We use parallel:multicore() to parallelize the bootstrap. For windows, use ncpus = 1, for any other machine, you can use the maximum permissible number for your system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We generate the bootstrap distribution of the order statistics of the p values. We are performing one sample test on each coordinate of the original dataset. The bootstrap used here is standard version with default bootstrap sample size being equal to data sample size. The default one sample test is t.test(), however the user can provide their own test functions. The only requirement is that it must return p values in $p.value column of the output.
The bootstrap is parallelized using multicore from the library parallel. Windows machines at this point does not support using multiple cores, so the ncpus option should be equal to 1 for windows. For other systems, it can be higher to speed up the process.
We also use a transofrmation of the p values, by default the transformation is -log(1-p). But the user can provide their own transformation function. They should be monotonically increasing functions.
</p>


<h3>Value</h3>

<p>matrix of dimension Bxm. (Where m coordinates), each row indicates transformed p values for that bootstrap sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n = 50;m = 250;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
porder &lt;- pboot.1sample(X=X,B=100,ncpus = 1)
plotpboot(porder) 

## End(Not run)
</code></pre>

<hr>
<h2 id='plotchange'>plotchange</h2><span id='topic+plotchange'></span>

<h3>Description</h3>

<p>Plot the change function that is maximized to find the change point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotchange(zvec, rbuff = 25, h = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotchange_+3A_zvec">zvec</code></td>
<td>
<p>vector of transformed order statistic of p values</p>
</td></tr>
<tr><td><code id="plotchange_+3A_rbuff">rbuff</code></td>
<td>
<p>right buffer</p>
</td></tr>
<tr><td><code id="plotchange_+3A_h">h</code></td>
<td>
<p>window size</p>
</td></tr>
<tr><td><code id="plotchange_+3A_...">...</code></td>
<td>
<p>any graphical parameters passed to the plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently there are two types of change functions supported. The difference between first difference series and the difference in gradients at each point. Both of these functions should have a theoretical maximum at the change point. We plot these two series side by side along with indicating the change point.
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
## Not run:       
n = 50;m = 250;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
porder &lt;- pboot.1sample(X=X,B=100,ncpus = 1)
plotchange(porder[1,])

## End(Not run)
</code></pre>

<hr>
<h2 id='plotpboot'>Quantile plots for p value distributions.</h2><span id='topic+plotpboot'></span>

<h3>Description</h3>

<p>Produces density plots of quantiles of transformed order statistics of p values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotpboot(porder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotpboot_+3A_porder">porder</code></td>
<td>
<p>Matrix feeds from pboot. This is a matrix of p values from the bootstrap sampls. Of size Bxm, each row for one bootstrap. The columns indicate the coordinates for testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot function for pboot
</p>
<p>This function plots the order statistics of the quantiles of the transformed p values. As the distribution of the statistic changes as the number of coordinates increase, it should show a change in the curve. 
</p>
<p>This function uses ggplot2 and reshape library to manipulate data. The final object returned is a ggplot2 image that can be fed into ggsave or any other supported functions.
</p>


<h3>Value</h3>

<p>ggplot2 object contatining the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n = 50;m = 250;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
Y &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
porder &lt;- pboot.2sample(X=X,Y = Y, B=100,ncpus = 1)
plotpboot(porder)

## End(Not run)
</code></pre>

<hr>
<h2 id='ptrans'>Transformation of order statistics of the p value distributions</h2><span id='topic+ptrans'></span>

<h3>Description</h3>

<p>This function applys transformation on the bootstrap distribution of order statistics of p values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptrans(porder, trans = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptrans_+3A_porder">porder</code></td>
<td>
<p>matrix of p value order statistics, rows indicate replicates</p>
</td></tr>
<tr><td><code id="ptrans_+3A_trans">trans</code></td>
<td>
<p>one of (&quot;default&quot;,&quot;normal&quot;,&quot;none&quot;) indicating trnasformation of -log(1-p), which is by default. Or inverse normal cdf transformation or no transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformation of p values must be monotonically increasing. The user can use their own transofrmation, however, this function supports only the commonly used transformations. These are -log(1-p) transformation, inverse normal cdf and identiy transformation.
</p>


<h3>Value</h3>

<p>matrix with transformed distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
X &lt;- datgen(n=100,m=80,m0=20,sigeff=1,Sigma = 0.25*diag(80))
porder &lt;- pboot.1sample(X=X,B=100,ncpus = 1)
porder.tr &lt;- ptrans(porder,trans="normal")
plotpboot(porder.tr)

## End(Not run)
</code></pre>

<hr>
<h2 id='qelbow'>Finding corner of a quantile of ordered transformed p values</h2><span id='topic+qelbow'></span>

<h3>Description</h3>

<p>Given a matrix of empirical distribution of ordered transformed p values, this function finds the corner point for a particular quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qelbow(porder, rbuff = 25, h = 30, qi = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qelbow_+3A_porder">porder</code></td>
<td>
<p>matrix, usually feed from pboot functions. Bxm matrix of ordered p values, where B is the replication size and m is dimension.</p>
</td></tr>
<tr><td><code id="qelbow_+3A_rbuff">rbuff</code></td>
<td>
<p>right buffer, scaler, control for elbow()</p>
</td></tr>
<tr><td><code id="qelbow_+3A_h">h</code></td>
<td>
<p>window size, default 30.</p>
</td></tr>
<tr><td><code id="qelbow_+3A_qi">qi</code></td>
<td>
<p>number between 0 and 1, quantile of the distribution. default 0.9.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the distribution of the transformed ordered p values, we choose a particular quantile given by the user. We estimate the change point, which will be an estimate of the number of true alternatives corresponding to that quantile of the p values. As the values of the quantile increases, the estimates can only increasing, because we are dealing with ordered p values.
</p>


<h3>Value</h3>

<p>vector with two elements. estimates of the corner point by two methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
## Not run:     
n = 50;m = 250;m0 = 20;
sigeff = 1;
Sigma &lt;- 0.25*diag(m)
X &lt;- datgen(n,m,m0,sigeff,Sigma = Sigma)
porder &lt;- pboot.1sample(X=X,B=100,ncpus = 1)
out &lt;- qelbow(porder = porder)
out

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
