<!DOCTYPE html><html><head><title>Help for package unmconf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {unmconf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#helpers'><p>Convert to Greek expressions</p></a></li>
<li><a href='#runm'><p>Generate synthetic data</p></a></li>
<li><a href='#unm_glm'><p>Fitting Multi-Staged Bayesian Regression Model with Unmeasured Confounders</p></a></li>
<li><a href='#unm_summary'><p>Generate synthetic data</p></a></li>
<li><a href='#unmconf'><p>unmconf: Modeling with Unmeasured Confounding</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling with Unmeasured Confounding</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Kahle &lt;david@kahle.io&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit and assess Bayesian multi-staged regression models that account 
    for unmeasured confounders using JAGS.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS &gt;= 4.3.0 (http://mcmc-jags.sourceforge.net)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), rjags</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, glue, janitor</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bayesplot, posterior, ggplot2, dplyr, tidyr, tibble, knitr,
rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 21:41:39 UTC; david_kahle</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Hebdon [aut],
  James Stamey <a href="https://orcid.org/0000-0002-3787-6490"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  David Kahle <a href="https://orcid.org/0000-0002-9999-1558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Xiang Zhang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 20:50:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='helpers'>Convert to Greek expressions</h2><span id='topic+helpers'></span><span id='topic+expand_labels'></span><span id='topic+greek_expander'></span><span id='topic+make_greek_coefs'></span><span id='topic+drop_nulls'></span>

<h3>Description</h3>

<p>Convert to Greek expressions for plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_labels(labs)

greek_expander(s)

make_greek_coefs(mod)

drop_nulls(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helpers_+3A_labs">labs</code></td>
<td>
<p>A character vector of greek symbols of the form <code>ga_x</code> and <code>be_1</code>.</p>
</td></tr>
<tr><td><code id="helpers_+3A_s">s</code></td>
<td>
<p>A character vector of Greek short hand codes, e.g. <code>"si"</code>.</p>
</td></tr>
<tr><td><code id="helpers_+3A_mod">mod</code></td>
<td>
<p>Output from <code><a href="#topic+unm_glm">unm_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="helpers_+3A_x">x</code></td>
<td>
<p>Character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
labs &lt;- c("ga_1", "ga_treatment", "ga_x", "be_1",
  "be_treatment", "be_x", "la_u", "al_y", "si")
expand_labels(labs)


</code></pre>

<hr>
<h2 id='runm'>Generate synthetic data</h2><span id='topic+runm'></span>

<h3>Description</h3>

<p><code><a href="#topic+runm">runm()</a></code> generates synthetic data for use of modeling with unmeasured
confounders. Defaults to the case of one unmeasured confounder present and
fixed parameter values. Can be customized. Currently set up to have at most
two unmeasured confounders to pair with <code><a href="#topic+unm_glm">unm_glm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runm(
  n,
  type = "int",
  missing_prop = 0.8,
  response = "bin",
  response_param = NULL,
  response_model_coefs = c(int = -1, z1 = 0.5, z2 = 0.5, z3 = 0.5, u1 = 0.5, x = 0.5),
  treatment_model_coefs = c(int = -1, z1 = 0.5, z2 = 0.5, z3 = 0.5, u1 = 0.5),
  covariate_fam_list = list("norm", "bin", "norm"),
  covariate_param_list = list(c(mean = 0, sd = 1), prob = 0.3, c(0, 2)),
  unmeasured_fam_list = list("norm"),
  unmeasured_param_list = list(c(mean = 0, sd = 1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runm_+3A_n">n</code></td>
<td>
<p>Number of observations. When <code>type = "int"</code>, <code>n</code> is a vector of
length 1. When <code>type = "ext"</code>, <code>n</code> can either be a vector of length 1 or 2.
For the case when <code>n</code> is of length 2, <code style="white-space: pre;">&#8288;n = (n_main, n_external)&#8288;</code>, where
<code>n_main</code> corresponds to the main study sample size and <code>n_external</code>
corresponds to the external validation sample size. For the case when <code>n</code>
is of length 1, <code>n</code> will be split evenly between main study and external
validation observations, with the main study getting the additional
observation when <code>n</code> is odd.</p>
</td></tr>
<tr><td><code id="runm_+3A_type">type</code></td>
<td>
<p>Type of validation source. Can be <code>"int"</code> for internal validation
or <code>"ext"</code> for external validation. Defaults to <code>"int"</code>.</p>
</td></tr>
<tr><td><code id="runm_+3A_missing_prop">missing_prop</code></td>
<td>
<p>Proportion of missing values for internal validation
scenario (i.e., when <code>type = "int"</code>).</p>
</td></tr>
<tr><td><code id="runm_+3A_response">response</code></td>
<td>
<p><code>"norm"</code>, <code>"bin"</code>, <code>"pois"</code>, or <code>"gam"</code>. Defaults to <code>"bin"</code>.</p>
</td></tr>
<tr><td><code id="runm_+3A_response_param">response_param</code></td>
<td>
<p>Nuisance parameters for response type. For <code>"norm"</code>,
the default standard deviation is 1. For <code>"gam"</code>, the default shape
parameter is 2. For <code>"pois"</code>, an offset variable is added to the dataset
that is uniformly distributed from 1 to 10.</p>
</td></tr>
<tr><td><code id="runm_+3A_response_model_coefs">response_model_coefs</code></td>
<td>
<p>A named vector of coefficients to generate data
from the response model. This must include an intercept (<code style="white-space: pre;">&#8288;"int" = &#8288;</code>), a
coefficient for each covariate specified, a coefficient for each unmeasured
confounder, and a treatment coefficient (<code style="white-space: pre;">&#8288;"x" = &#8288;</code>). The coefficients for
the covariates and treatment will be denoted with <code>"beta[.]"</code> and the
unmeasured confounders with <code>"lambda[.]"</code>.</p>
</td></tr>
<tr><td><code id="runm_+3A_treatment_model_coefs">treatment_model_coefs</code></td>
<td>
<p>A named vector of coefficients to generate data
from the treatment model. This must include an intercept (<code style="white-space: pre;">&#8288;"int" = &#8288;</code>), a
coefficient for each covariate specified, and a coefficient for each
unmeasured confounder. The coefficients for the covariates and unmeasured
confounders will be denoted with <code>"eta[.]"</code>.</p>
</td></tr>
<tr><td><code id="runm_+3A_covariate_fam_list">covariate_fam_list</code></td>
<td>
<p>A list of either <code>"norm"</code> or <code>"bin"</code>, where the
length of the list matches the number of covariates in the model.</p>
</td></tr>
<tr><td><code id="runm_+3A_covariate_param_list">covariate_param_list</code></td>
<td>
<p>A list of parameters for the respective
distributions in <code>covariate_fam_list</code>, where the length of the list matches
the length of <code>covariate_fam_list</code>.</p>
</td></tr>
<tr><td><code id="runm_+3A_unmeasured_fam_list">unmeasured_fam_list</code></td>
<td>
<p>A list of either <code>"norm"</code> or <code>"bin"</code>, where the
length of the list matches the number of unmeasured confounders in the
model. This can be at most a length of 2 to pair with <code><a href="#topic+unm_glm">unm_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="runm_+3A_unmeasured_param_list">unmeasured_param_list</code></td>
<td>
<p>A list of parameters for the respective
distributions in <code>unmeasured_fam_list</code>, where the length of the list
matches the length of <code>unmeasured_fam_list</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
runm(100)
runm(n = 100, type = "int", missing_prop = .75)
runm(n = 100, type = "int", missing_prop = .75) |&gt; attr("params")
runm(100, type = "int", response = "norm")
runm(100, type = "int", response = "norm") |&gt; attr("params")
runm(100, type = "int", response = "norm", response_param = 3) |&gt; attr("params")
runm(100, type = "int", response = "gam")
runm(100, type = "int", response = "gam", response_param = 5) |&gt; attr("params")
runm(100, type = "int", missing_prop = .5, response = "pois")

runm(n = 100, type = "ext")
runm(n = 100, type = "ext") |&gt; attr("params")
runm(n = c(10, 10), type = "ext")
runm(100, type = "ext", response = "norm")
runm(100, type = "int", response = "norm", response_param = 3) |&gt; attr("params")
runm(100, type = "ext", response = "gam")
runm(100, type = "ext", response = "pois")

runm(
  n = 100,
  type = "int",
  missing_prop = .80,
  response = "norm",
  response_param = c("si_y" = 2),
  response_model_coefs = c("int" = -1, "z" = .4,
                           "u1" = .75, "u2" = .75, "x" = .75),
  treatment_model_coefs = c("int" = -1, "z" = .4,
                            "u1" = .75, "u2" = .75),
  covariate_fam_list = list("norm"),
  covariate_param_list = list(c(mean = 0, sd = 1)),
  unmeasured_fam_list = list("norm", "bin"),
  unmeasured_param_list = list(c(mean = 0, sd = 1), c(.3))
)

runm(
  n = c(20, 30),
  type = "ext",
  response = "norm",
  response_param = c("si_y" = 2),
  response_model_coefs = c("int" = -1, "z1" = .4, "z2" = .5, "z3" = .4,
                           "u1" = .75, "u2" = .75, "x" = .75),
  treatment_model_coefs = c("int" = -1, "z1" = .4, "z2" = .5, "z3" = .4,
                            "u1" = .75, "u2" = .75),
  covariate_fam_list = list("norm", "bin", "norm"),
  covariate_param_list = list(c(mean = 0, sd = 1), c(.3), c(0, 2)),
  unmeasured_fam_list = list("norm", "bin"),
  unmeasured_param_list = list(c(mean = 0, sd = 1), c(.3))
)
</code></pre>

<hr>
<h2 id='unm_glm'>Fitting Multi-Staged Bayesian Regression Model with Unmeasured Confounders</h2><span id='topic+unm_glm'></span><span id='topic+jags_code'></span><span id='topic+print.unm_int'></span><span id='topic+coef.unm_int'></span>

<h3>Description</h3>

<p><code><a href="#topic+unm_glm">unm_glm()</a></code> fits a multi-staged Bayesian regression model that accounts for
unmeasured confounders. Users can input model information into <code><a href="#topic+unm_glm">unm_glm()</a></code> in
a similar manner as they would for the standard <code><a href="stats.html#topic+glm">stats::glm()</a></code> function,
providing arguments like <code>formula</code>, <code>family</code>, and <code>data</code>. Results are stored
as MCMC iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unm_glm(
  form1,
  form2 = NULL,
  form3 = NULL,
  family1 = binomial(),
  family2 = NULL,
  family3 = NULL,
  data,
  n.iter = 2000,
  n.adapt = 1000,
  thin = 1,
  n.chains = 4,
  filename = tempfile(fileext = ".jags"),
  quiet = getOption("unm_quiet"),
  progress.bar = getOption("unm_progress.bar"),
  code_only = FALSE,
  priors,
  response_nuisance_priors,
  response_params_to_track,
  confounder1_nuisance_priors,
  confounder1_params_to_track,
  confounder2_nuisance_priors,
  confounder2_params_to_track,
  ...
)

jags_code(mod)

## S3 method for class 'unm_int'
print(x, digits = 3, ..., print_call = getOption("unm_print_call"))

## S3 method for class 'unm_int'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unm_glm_+3A_form1">form1</code></td>
<td>
<p>The formula specification for the response model (stage I)</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_form2">form2</code></td>
<td>
<p>The formula specification for the first unmeasured confounder
model (stage II)</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_form3">form3</code></td>
<td>
<p>The formula specification for the second unmeasured confounder
model (stage III)</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_family1">family1</code>, <code id="unm_glm_+3A_family2">family2</code>, <code id="unm_glm_+3A_family3">family3</code></td>
<td>
<p>The family object, communicating the types of
models to be used for response (<code>form1</code>) and unmeasured confounder (<code style="white-space: pre;">&#8288;form2, form3&#8288;</code>) models. See <code><a href="stats.html#topic+family">stats::family()</a></code> for details</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_data">data</code></td>
<td>
<p>The dataset containing all variables (this function currently
only supports a single dataset containing internally validated data)</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_n.iter">n.iter</code></td>
<td>
<p><code>n.iter</code> argument of <code><a href="rjags.html#topic+coda.samples">rjags::coda.samples()</a></code></p>
</td></tr>
<tr><td><code id="unm_glm_+3A_n.adapt">n.adapt</code></td>
<td>
<p><code>n.adapt</code> argument of <code><a href="rjags.html#topic+jags.model">rjags::jags.model()</a></code></p>
</td></tr>
<tr><td><code id="unm_glm_+3A_thin">thin</code></td>
<td>
<p><code>thin</code> argument of <code><a href="rjags.html#topic+coda.samples">rjags::coda.samples()</a></code></p>
</td></tr>
<tr><td><code id="unm_glm_+3A_n.chains">n.chains</code></td>
<td>
<p><code>n.chains</code> argument of <code><a href="rjags.html#topic+jags.model">rjags::jags.model()</a></code></p>
</td></tr>
<tr><td><code id="unm_glm_+3A_filename">filename</code></td>
<td>
<p>File name where to store jags code</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_quiet">quiet</code></td>
<td>
<p>The <code>quiet</code> parameter of <code><a href="rjags.html#topic+jags.model">rjags::jags.model()</a></code>. Defaults to
<code>TRUE</code>, but you can change it on a per-session basis with
<code>options(unm_quiet = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_progress.bar">progress.bar</code></td>
<td>
<p>The <code>progress.bar</code> parameter of <code><a href="rjags.html#topic+update">rjags::update.jags()</a></code>.
Defaults to <code>"none"</code>, but you can change it on a per-session basis with
<code>options(unm_progress.bar = "text")</code>.</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_code_only">code_only</code></td>
<td>
<p>Should only the code be created?</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_priors">priors</code></td>
<td>
<p>Custom priors to use on regression coefficients, see examples.</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_response_nuisance_priors">response_nuisance_priors</code>, <code id="unm_glm_+3A_confounder1_nuisance_priors">confounder1_nuisance_priors</code>, <code id="unm_glm_+3A_confounder2_nuisance_priors">confounder2_nuisance_priors</code></td>
<td>
<p>JAGS code for the nuisance priors on parameters in a JAGS model (see
examples)</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_response_params_to_track">response_params_to_track</code>, <code id="unm_glm_+3A_confounder1_params_to_track">confounder1_params_to_track</code>, <code id="unm_glm_+3A_confounder2_params_to_track">confounder2_params_to_track</code></td>
<td>
<p>Additional parameters to track when nuisance parameter priors are used (see
examples)</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass into <code><a href="rjags.html#topic+jags.model">rjags::jags.model()</a></code>, such as
<code>inits</code></p>
</td></tr>
<tr><td><code id="unm_glm_+3A_mod">mod</code></td>
<td>
<p>The output of <code><a href="#topic+unm_glm">unm_glm()</a></code></p>
</td></tr>
<tr><td><code id="unm_glm_+3A_x">x</code></td>
<td>
<p>Object to be printed</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to; defaults to 3</p>
</td></tr>
<tr><td><code id="unm_glm_+3A_print_call">print_call</code></td>
<td>
<p>Should the call be printed? Defaults to <code>TRUE</code>, but can be
turned off with <code>options("unm_print_call" = FALSE)</code></p>
</td></tr>
<tr><td><code id="unm_glm_+3A_object">object</code></td>
<td>
<p>Model object for which the coefficients are desired</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(Invisibly) The output of <code><a href="rjags.html#topic+coda.samples">rjags::coda.samples()</a></code>, an object of class
<code>mcmc.list</code>, along with attributes <code>code</code> containing the jags code used and
<code>file</code> containing the filename of the jags code.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runm">runm()</a></code>, <code><a href="rjags.html#topic+dic.samples">rjags::dic.samples()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# ~~ One Unmeasured Confounder Examples (II-Stage Model) ~~


# normal response, normal confounder model with internally validated data
(df &lt;- runm(20, response = "norm"))

(unm_mod &lt;- unm_glm(
  y ~ x + z1 + z2 + z3 + u1,  family1 = gaussian(),
  u1 ~ x + z1 + z2 + z3,      family2 = gaussian(),
  data = df
))

(unm_mod &lt;- unm_glm(
  y ~ .,      family1 = gaussian(),
  u1 ~ . - y, family2 = gaussian(),
  data = df
))
glm(y ~ x + z1 + z2 + z3, data = df)
coef(unm_mod)

jags_code(unm_mod)
unm_glm(
  y ~ .,
  u1 ~ . - y,
  family1 = gaussian(),
  family2 = gaussian(),
  data = df, code_only = TRUE
)





</code></pre>

<hr>
<h2 id='unm_summary'>Generate synthetic data</h2><span id='topic+unm_summary'></span><span id='topic+unm_backfill'></span><span id='topic+unm_dic'></span>

<h3>Description</h3>

<p><code><a href="#topic+unm_summary">unm_summary()</a></code> produces result summaries of the results from the model fitting
function, <code><a href="#topic+unm_glm">unm_glm()</a></code>. The table of results are summarized from the MCMC draws of
the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unm_summary(mod, data, quantiles = c(0.025, 0.975))

unm_backfill(data, mod)

unm_dic(mod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unm_summary_+3A_mod">mod</code></td>
<td>
<p>Output from <code><a href="#topic+unm_glm">unm_glm()</a></code>.</p>
</td></tr>
<tr><td><code id="unm_summary_+3A_data">data</code></td>
<td>
<p>The data <code>mod</code> was generated with.</p>
</td></tr>
<tr><td><code id="unm_summary_+3A_quantiles">quantiles</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# ~~ One Unmeasured Confounder Examples (II-Stage Model) ~~

# normal response, normal confounder model with internally validated data
(df &lt;- runm(20, response = "norm"))

(unm_mod &lt;- unm_glm(
  y ~ x + z1 + z2 + z3 + u1, family1 = gaussian(),
  u1 ~ x + z1 + z2 + z3,     family2 = gaussian(),
  data = df
))

glm(y ~ x + z1 + z2 + z3, data = df)

coef(unm_mod)
jags_code(unm_mod)
unm_summary(unm_mod)
unm_summary(unm_mod, df) # true values known df

# impute missing values with model
unm_backfill(df, unm_mod)



</code></pre>

<hr>
<h2 id='unmconf'>unmconf: Modeling with Unmeasured Confounding</h2><span id='topic+unmconf'></span><span id='topic+unmconf-package'></span>

<h3>Description</h3>

<p>Tools for fitting and assessing Bayesian multi-staged regression models that
account for unmeasured confounders.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
