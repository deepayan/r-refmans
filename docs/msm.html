<!DOCTYPE html><html><head><title>Help for package msm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {msm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#msm-package'><p>Multi-State Markov and Hidden Markov Models in Continuous Time</p></a></li>
<li><a href='#aneur'><p>Aortic aneurysm progression data</p></a></li>
<li><a href='#boot.msm'><p>Bootstrap resampling for multi-state models</p></a></li>
<li><a href='#bos'><p>Bronchiolitis obliterans syndrome after lung transplants</p></a></li>
<li><a href='#cav'><p>Heart transplant monitoring data</p></a></li>
<li><a href='#cmodel.object'><p>Developer documentation: censoring model object</p></a></li>
<li><a href='#coef.msm'><p>Extract model coefficients</p></a></li>
<li><a href='#crudeinits.msm'><p>Calculate crude initial values for transition intensities</p></a></li>
<li><a href='#deltamethod'><p>The delta method</p></a></li>
<li><a href='#draic.msm'><p>Criteria for comparing two multi-state models with nested state spaces</p></a></li>
<li><a href='#ecmodel.object'><p>Developer documentation: model for covariates on misclassification</p>
probabilities</a></li>
<li><a href='#efpt.msm'><p>Expected first passage time</p></a></li>
<li><a href='#ematrix.msm'><p>Misclassification probability matrix</p></a></li>
<li><a href='#emodel.object'><p>Developer documentation: misclassification model structure object</p></a></li>
<li><a href='#fev'><p>FEV1 measurements from lung transplant recipients</p></a></li>
<li><a href='#hazard.msm'><p>Calculate tables of hazard ratios for covariates on transition intensities</p></a></li>
<li><a href='#hmm-dists'><p>Hidden Markov model constructors</p></a></li>
<li><a href='#hmmMV'><p>Multivariate hidden Markov models</p></a></li>
<li><a href='#hmodel.object'><p>Developer documentation: hidden Markov model structure object</p></a></li>
<li><a href='#logLik.msm'><p>Extract model log-likelihood</p></a></li>
<li><a href='#lrtest.msm'><p>Likelihood ratio test</p></a></li>
<li><a href='#MatrixExp'><p>Matrix exponential</p></a></li>
<li><a href='#medists'><p>Measurement error distributions</p></a></li>
<li><a href='#model.frame.msm'><p>Extract original data from <code>msm</code> objects.</p></a></li>
<li><a href='#msm'><p>Multi-state Markov and hidden Markov models in continuous time</p></a></li>
<li><a href='#msm.form.qoutput'><p>Extract msm model parameter estimates in compact format</p></a></li>
<li><a href='#msm.object'><p>Fitted msm model objects</p></a></li>
<li><a href='#msm2Surv'><p>Convert data for &lsquo;msm&rsquo; to data for &lsquo;survival&rsquo;, &lsquo;mstate&rsquo; or &lsquo;flexsurv&rsquo;</p>
analysis</a></li>
<li><a href='#odds.msm'><p>Calculate tables of odds ratios for covariates on misclassification</p>
probabilities</a></li>
<li><a href='#paramdata.object'><p>Developer documentation: internal msm parameters object</p></a></li>
<li><a href='#pearson.msm'><p>Pearson-type goodness-of-fit test</p></a></li>
<li><a href='#pexp'><p>Exponential distribution with piecewise-constant rate</p></a></li>
<li><a href='#phasemeans.msm'><p>Parameters of phase-type models in mixture form</p></a></li>
<li><a href='#plot.msm'><p>Plots of multi-state models</p></a></li>
<li><a href='#plot.prevalence.msm'><p>Plot of observed and expected prevalences</p></a></li>
<li><a href='#plot.survfit.msm'><p>Plot empirical and fitted survival curves</p></a></li>
<li><a href='#plotprog.msm'><p>Kaplan Meier estimates of incidence</p></a></li>
<li><a href='#pmatrix.msm'><p>Transition probability matrix</p></a></li>
<li><a href='#pmatrix.piecewise.msm'><p>Transition probability matrix for processes with piecewise-constant</p>
intensities</a></li>
<li><a href='#pnext.msm'><p>Probability of each state being next</p></a></li>
<li><a href='#ppass.msm'><p>Passage probabilities</p></a></li>
<li><a href='#prevalence.msm'><p>Tables of observed and expected prevalences</p></a></li>
<li><a href='#print.msm'><p>Print a fitted msm model object</p></a></li>
<li><a href='#printold.msm'><p>Print a fitted msm model object</p></a></li>
<li><a href='#psor'><p>Psoriatic arthritis data</p></a></li>
<li><a href='#qcmodel.object'><p>Developer documentation: model for covariates on transition intensities</p></a></li>
<li><a href='#qgeneric'><p>Generic function to find quantiles of a distribution</p></a></li>
<li><a href='#qmatrix.msm'><p>Transition intensity matrix</p></a></li>
<li><a href='#qmodel.object'><p>Developer documentation: transition model structure object</p></a></li>
<li><a href='#qratio.msm'><p>Estimated ratio of transition intensities</p></a></li>
<li><a href='#recreate.olddata'><p>Convert data stored in msm object to old format</p></a></li>
<li><a href='#scoreresid.msm'><p>Score residuals</p></a></li>
<li><a href='#sim.msm'><p>Simulate one individual trajectory from a continuous-time Markov model</p></a></li>
<li><a href='#simfitted.msm'><p>Simulate from a Markov model fitted using msm</p></a></li>
<li><a href='#simmulti.msm'><p>Simulate multiple trajectories from a multi-state Markov model with</p>
arbitrary observation times</a></li>
<li><a href='#sojourn.msm'><p>Mean sojourn times from a multi-state model</p></a></li>
<li><a href='#statetable.msm'><p>Table of transitions</p></a></li>
<li><a href='#summary.msm'><p>Summarise a fitted multi-state model</p></a></li>
<li><a href='#surface.msm'><p>Explore the likelihood surface</p></a></li>
<li><a href='#tnorm'><p>Truncated Normal distribution</p></a></li>
<li><a href='#totlos.msm'><p>Total length of stay, or expected number of visits</p></a></li>
<li><a href='#transient.msm'><p>Transient and absorbing states</p></a></li>
<li><a href='#twophase'><p>Coxian phase-type distribution with two phases</p></a></li>
<li><a href='#updatepars.msm'><p>Update the maximum likelihood estimates in a fitted model object.</p></a></li>
<li><a href='#viterbi.msm'><p>Calculate the probabilities of underlying states and the most likely path</p>
through them</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.7.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-State Markov and Hidden Markov Models in Continuous Time</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for fitting continuous-time Markov and hidden
    Markov multi-state models to longitudinal data.  Designed for
    processes observed at arbitrary times in continuous time (panel data)
    but some other observation schemes are supported. Both Markov
    transition rates and the hidden Markov output process can be modelled
    in terms of covariates, which may be constant or piecewise-constant
    in time.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>survival,mvtnorm,expm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mstate, minqa, doParallel, foreach, numDeriv, testthat,
flexsurv, covr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/chjackson/msm">https://github.com/chjackson/msm</a>, <a href="https://chjackson.github.io/msm/">https://chjackson.github.io/msm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chjackson/msm/issues">https://github.com/chjackson/msm/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-23 20:12:56 UTC; Chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Jackson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-23 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='msm-package'>Multi-State Markov and Hidden Markov Models in Continuous Time</h2><span id='topic+msm-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>msm: Functions for fitting continuous-time Markov and hidden Markov
multi-state models to longitudinal data.  Designed for processes
observed at arbitrary times in continuous time (intermittently
observed or panel data) but some other observation schemes are
supported. Both Markov transition rates and the hidden Markov
output process can be modelled in terms of covariates, which may be
constant or piecewise-constant in time.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Christopher Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/chjackson/msm">https://github.com/chjackson/msm</a>
</p>
</li>
<li> <p><a href="https://chjackson.github.io/msm/">https://chjackson.github.io/msm/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/chjackson/msm/issues">https://github.com/chjackson/msm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aneur'>Aortic aneurysm progression data</h2><span id='topic+aneur'></span>

<h3>Description</h3>

<p>This dataset contains longitudinal measurements of grades of aortic
aneurysms, measured by ultrasound examination of the diameter of the aorta.
</p>


<h3>Format</h3>

<p>A data frame containing 4337 rows, with each row corresponding to an
ultrasound scan from one of 838 men over 65 years of age.
</p>

<table>
<tr>
 <td style="text-align: right;"> <code>ptnum</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Patient identification
number </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>age</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Recipient age at examination
(years) </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>diam</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Aortic diameter</td>
</tr>
<tr>
 <td style="text-align: right;"> <code>state</code>
</td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> State of aneurysm. </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>

<p>The states represent successive degrees of aneurysm severity, as indicated
by the aortic diameter.
</p>

<table>
<tr>
 <td style="text-align: right;"> State 1 </td><td style="text-align: left;"> Aneurysm-free </td><td style="text-align: left;"> &lt; 30 cm </td>
</tr>
<tr>
 <td style="text-align: right;"> State 2 </td><td style="text-align: left;"> Mild
aneurysm </td><td style="text-align: left;"> 30-44 cm </td>
</tr>
<tr>
 <td style="text-align: right;"> State 3 </td><td style="text-align: left;"> Moderate aneurysm </td><td style="text-align: left;"> 45-54 cm </td>
</tr>
<tr>
 <td style="text-align: right;">
State 4 </td><td style="text-align: left;"> Severe aneurysm </td><td style="text-align: left;"> &gt; 55 cm </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>

<p>683 of these men were aneurysm-free at age 65 and were re-screened every two
years.  The remaining men were aneurysmal at entry and had successive
screens with frequency depending on the state of the aneurysm.  Severe
aneurysms are repaired by surgery.
</p>


<h3>Source</h3>

<p>The Chichester, U.K. randomised controlled trial of screening for
abdominal aortic aneurysms by ultrasonography.
</p>


<h3>References</h3>

<p>Jackson, C.H., Sharples, L.D., Thompson, S.G. and Duffy, S.W.
and Couto, E.  Multi-state Markov models for disease progression with
classification error. <em>The Statistician</em>, 52(2): 193&ndash;209 (2003)
</p>
<p>Couto, E. and Duffy, S. W. and Ashton, H. A. and Walker, N. M.  and Myles,
J. P. and Scott, R. A. P. and Thompson, S. G. (2002) <em>Probabilities of
progression of aortic aneurysms: estimates and implications for screening
policy</em> Journal of Medical Screening 9(1):40&ndash;42
</p>

<hr>
<h2 id='boot.msm'>Bootstrap resampling for multi-state models</h2><span id='topic+boot.msm'></span>

<h3>Description</h3>

<p>Draw a number of bootstrap resamples, refit a <code><a href="#topic+msm">msm</a></code> model to the
resamples, and calculate statistics on the refitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.msm(
  x,
  stat = pmatrix.msm,
  B = 1000,
  file = NULL,
  cores = NULL,
  remove.errors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.msm_+3A_x">x</code></td>
<td>
<p>A fitted msm model, as output by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="boot.msm_+3A_stat">stat</code></td>
<td>
<p>A function to call on each refitted msm model. By default this
is <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>, returning the transition probability matrix in
one time unit. If <code>NULL</code> then no function is computed.</p>
</td></tr>
<tr><td><code id="boot.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap resamples.</p>
</td></tr>
<tr><td><code id="boot.msm_+3A_file">file</code></td>
<td>
<p>Name of a file in which to save partial results after each
replicate. This is saved using <code><a href="base.html#topic+save">save</a></code> and can be restored using
<code><a href="base.html#topic+load">load</a></code>, producing an object called <code>boot.list</code> containing
the partial results.  Not supported when using parallel processing.</p>
</td></tr>
<tr><td><code id="boot.msm_+3A_cores">cores</code></td>
<td>
<p>Number of processor cores to use for parallel processing.
Requires the <span class="pkg">doParallel</span> package to be installed.  If not specified,
parallel processing is not used. If <code>cores</code> is set to the string
<code>"default"</code>, the default methods of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>
(on Windows) or <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> (on Unix-like)
are used.</p>
</td></tr>
<tr><td><code id="boot.msm_+3A_remove.errors">remove.errors</code></td>
<td>
<p>If <code>TRUE</code> then bootstrap refits which resulted in an
error are removed from the returned list, and a message is returned which states the
proportion of failed fits and the first error message.  If <code>FALSE</code>, then 
the error message for failed refits is placed in the
corresponding component of the returned list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bootstrap datasets are computed by resampling independent pairs of
observations at successive times (for non-hidden models without censoring),
or independent individual series (for hidden models or models with
censoring).  Therefore this approach doesn't work if, for example, the data
for a HMM consist of a series of observations from just one individual, and
is inaccurate for small numbers of independent transitions or individuals.
</p>
<p>Confidence intervals or standard errors for the corresponding statistic can
be calculated by summarising the returned list of <code>B</code> replicated
outputs.  This is currently implemented for most the output functions
<code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>, <code><a href="#topic+ematrix.msm">ematrix.msm</a></code>,
<code><a href="#topic+qratio.msm">qratio.msm</a></code>, <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>,
<code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code>, <code><a href="#topic+totlos.msm">totlos.msm</a></code> and
<code><a href="#topic+prevalence.msm">prevalence.msm</a></code>.  For other outputs, users will have to write
their own code to summarise the output of <code><a href="#topic+boot.msm">boot.msm</a></code>.
</p>
<p>Most of <span class="pkg">msm</span>'s output functions present confidence intervals based on
asymptotic standard errors calculated from the Hessian. These are expected
to be underestimates of the true standard errors (Cramer-Rao lower bound).
Some of these functions use a further approximation, the delta method (see
<code><a href="#topic+deltamethod">deltamethod</a></code>) to obtain standard errors of transformed
parameters. Bootstrapping should give a more accurate estimate of the
uncertainty.
</p>
<p>An alternative method which is less accurate though faster than
bootstrapping, but more accurate than the delta method, is to draw a sample
from the asymptotic multivariate normal distribution implied by the maximum
likelihood estimates (and covariance matrix), and summarise the transformed
estimates.  See <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>.
</p>
<p>All objects used in the original call to <code><a href="#topic+msm">msm</a></code> which produced
<code>x</code>, such as the <code>qmatrix</code>, should be in the working environment,
or else <code>boot.msm</code> will produce an &ldquo;object not found&rdquo; error.
This enables <code>boot.msm</code> to refit the original model to the replicate
datasets.  However there is currently a limitation.  In the original call to
<code>msm</code>, the <code>"formula"</code> argument should be specified directly, as,
for example,
</p>
<p><code>msm(state ~ time, data = ...)</code>
</p>
<p>and not, for example,
</p>
<p><code>form = data$state ~ data$time</code>
</p>
<p><code>msm(formula=form, data = ...)</code>
</p>
<p>otherwise <code>boot.msm</code> will be unable to draw the replicate datasets.
</p>
<p><code>boot.msm</code> will also fail with an incomprehensible error if the
original call to msm used a used-defined object whose name is the same as a
built-in R object, or an object in any other loaded package.  For example,
if you have called a Q matrix <code>q</code>, when <code>q()</code> is the built-in
function for quitting R.
</p>
<p>If <code>stat</code> is <code>NULL</code>, then <code>B</code> different <code>msm</code> model
objects will be stored in memory. This is unadvisable, as <code>msm</code> objects
tend to be large, since they contain the original data used for the
<code>msm</code> fit, so this will be wasteful of memory.
</p>
<p>To specify more than one statistic, write a function consisting of a list of
different function calls, for example,
</p>
<p><code>stat = function(x) list (pmatrix.msm(x, t=1), pmatrix.msm(x, t=2))</code>
</p>


<h3>Value</h3>

<p>A list with <code>B</code> components, containing the result of calling
function <code>stat</code> on each of the refitted models.  If <code>stat</code> is
<code>NULL</code>, then each component just contains the refitted model.  If one
of the <code>B</code> model fits was unsuccessful and resulted in an error, then
the corresponding list component will contain the error message.
</p>


<h3>Author(s)</h3>

<p>C.H.Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Efron, B. and Tibshirani, R.J. (1993) <em>An Introduction to
the Bootstrap</em>, Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>, <code><a href="#topic+qratio.msm">qratio.msm</a></code>,
<code><a href="#topic+sojourn.msm">sojourn.msm</a></code>, <code><a href="#topic+ematrix.msm">ematrix.msm</a></code>,
<code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>, <code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code>,
<code><a href="#topic+totlos.msm">totlos.msm</a></code>, <code><a href="#topic+prevalence.msm">prevalence.msm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  ## Psoriatic arthritis example
  data(psor)
  psor.q &lt;- rbind(c(0,0.1,0,0),c(0,0,0.1,0),c(0,0,0,0.1),c(0,0,0,0))
  psor.msm &lt;- msm(state ~ months, subject=ptnum, data=psor, qmatrix =
    psor.q, covariates = ~ollwsdrt+hieffusn,
    constraint = list(hieffusn=c(1,1,1),ollwsdrt=c(1,1,2)),
    control = list(REPORT=1,trace=2), method="BFGS")
  ## Bootstrap the baseline transition intensity matrix.  This will take a long time.
  q.list &lt;- boot.msm(psor.msm, function(x)x$Qmatrices$baseline)
  ## Manipulate the resulting list of matrices to calculate bootstrap standard errors.
  apply(array(unlist(q.list), dim=c(4,4,5)), c(1,2), sd)
  ## Similarly calculate a bootstrap 95% confidence interval
  apply(array(unlist(q.list), dim=c(4,4,5)), c(1,2),
        function(x)quantile(x, c(0.025, 0.975)))
  ## Bootstrap standard errors are larger than the asymptotic standard
  ## errors calculated from the Hessian
  psor.msm$QmatricesSE$baseline

## End(Not run)

</code></pre>

<hr>
<h2 id='bos'>Bronchiolitis obliterans syndrome after lung transplants</h2><span id='topic+bos'></span><span id='topic+bos3'></span><span id='topic+bos4'></span>

<h3>Description</h3>

<p>A dataset containing histories of bronchiolitis obliterans syndrome (BOS)
from lung transplant recipients. BOS is a chronic decline in lung function,
often observed after lung transplantation.  The condition is classified into
four stages of severity: none, mild, moderate and severe.
</p>


<h3>Format</h3>

<p>A data frame containing 638 rows, grouped by patient, including
histories of 204 patients.  The first observation for each patient is
defined to be stage 1, no BOS, at six months after transplant.  Subsequent
observations denote the entry times into stages 2, 3, 4, representing mild,
moderate and severe BOS respectively, and stage 5, representing death.
</p>

<table>
<tr>
 <td style="text-align: right;"> <code>ptnum</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Patient identification
number </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>time</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Months after transplant </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>state</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> BOS state entered at this time </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>



<h3>Details</h3>

<p>The entry time of each patient into each stage of BOS was estimated by
clinicians, based on their history of lung function measurements and acute
rejection and infection episodes.  BOS is only assumed to occur beyond six
months after transplant.  In the first six months the function of each
patient's new lung stabilises.  Subsequently BOS is diagnosed by comparing
the lung function against the &quot;baseline&quot; value.
</p>
<p>The objects <code>bos3</code> and <code>bos4</code> contain the same data, but with
mild/moderate/severe combined, and moderate/severe combined, to give 3 and
4-state representations respectively.
</p>


<h3>Source</h3>

<p>Papworth Hospital, U.K.
</p>


<h3>References</h3>

<p>Heng. D. et al. (1998).  Bronchiolitis Obliterans Syndrome:
Incidence, Natural History, Prognosis, and Risk Factors.  Journal of Heart
and Lung Transplantation 17(12)1255&ndash;1263.
</p>

<hr>
<h2 id='cav'>Heart transplant monitoring data</h2><span id='topic+cav'></span>

<h3>Description</h3>

<p>A series of approximately yearly angiographic examinations of heart
transplant recipients.  The state at each time is a grade of cardiac
allograft vasculopathy (CAV), a deterioration of the arterial walls.
</p>


<h3>Format</h3>

<p>A data frame containing 2846 rows.  There are 622 patients, the rows
are grouped by patient number and ordered by years after transplant, with
each row representing an examination and containing additional covariates.
</p>

<table>
<tr>
 <td style="text-align: right;"> <code>PTNUM</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Patient identification
number </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>age</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Recipient age at examination
(years) </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>years</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Examination time (years after
transplant)</td>
</tr>
<tr>
 <td style="text-align: right;"> <code>dage</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Age of heart donor (years)
</td>
</tr>
<tr>
 <td style="text-align: right;"> <code>sex</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> sex (0=male, 1=female) </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>pdiag</code>
</td><td style="text-align: left;"> (factor) </td><td style="text-align: left;"> Primary diagnosis (reason for transplant) </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> </td><td style="text-align: left;">
IHD=ischaemic heart disease, IDC=idiopathic dilated cardiomyopathy. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>cumrej</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Cumulative number of acute rejection
episodes </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>state</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> State at the examination. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> State 1 represents no CAV, state 2 is mild/moderate CAV </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;">
</td><td style="text-align: left;"> and state 3 is severe CAV.  State 4 indicates death.  </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>firstobs</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> 0 = record represents an angiogram or
date of death.</td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> 1 = record represents transplant (patient's
first observation) </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>statemax</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Maximum observed
state so far for this patient (added in version 1.5.1) </td>
</tr>

</table>



<h3>Source</h3>

<p>Papworth Hospital, U.K.
</p>


<h3>References</h3>

<p>Sharples, L.D. and Jackson, C.H. and Parameshwar, J. and
Wallwork, J. and Large, S.R. (2003). Diagnostic accuracy of coronary
angiopathy and risk factors for post-heart-transplant cardiac allograft
vasculopathy. Transplantation 76(4):679-82
</p>

<hr>
<h2 id='cmodel.object'>Developer documentation: censoring model object</h2><span id='topic+cmodel.object'></span>

<h3>Description</h3>

<p>A list giving information about censored states, their labels in the data
and what true states they represent.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ncens</code></td>
<td>
<p>The number of distinct values used for censored
observations in the <code>state</code> data supplied to <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code>censor</code></td>
<td>
<p>A vector of length <code>ncens</code>, giving the labels used for
censored states in the data.</p>
</td></tr> <tr><td><code>states</code></td>
<td>
<p>A vector obtained by
<code>unlist()</code>ing a list with <code>ncens</code> elements, each giving the set of
true states that an observation with this label could be.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>Index into <code>states</code> for the first state corresponding to
each <code>censor</code>, plus an extra <code>length(states)+1</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+msm.object">msm.object</a></code>.
</p>

<hr>
<h2 id='coef.msm'>Extract model coefficients</h2><span id='topic+coef.msm'></span>

<h3>Description</h3>

<p>Extract the estimated log transition intensities and the corresponding
linear effects of each covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.msm_+3A_object">object</code></td>
<td>
<p>A fitted multi-state model object, as returned by
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="coef.msm_+3A_...">...</code></td>
<td>
<p>(unused) further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If there is no misclassification, <code>coef.msm</code> returns a list of
matrices.  The first component, labelled <code>logbaseline</code>, is a matrix
containing the estimated transition intensities on the log scale with any
covariates fixed at their means in the data. Each remaining component is a
matrix giving the linear effects of the labelled covariate on the matrix of
log intensities. <br />
</p>
<p>For misclassification models, <code>coef.msm</code> returns a list of lists. The
first component, <code>Qmatrices</code>, is a list of matrices as described in the
previous paragraph.  The additional component <code>Ematrices</code> is a list of
similar format containing the logit-misclassification probabilities and any
estimated covariate effects.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>
</p>

<hr>
<h2 id='crudeinits.msm'>Calculate crude initial values for transition intensities</h2><span id='topic+crudeinits.msm'></span>

<h3>Description</h3>

<p>Calculates crude initial values for transition intensities by assuming that
the data represent the exact transition times of the Markov process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crudeinits.msm(
  formula,
  subject,
  qmatrix,
  data = NULL,
  censor = NULL,
  censor.states = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crudeinits.msm_+3A_formula">formula</code></td>
<td>
<p>A formula giving the vectors containing the observed states
and the corresponding observation times. For example,
</p>
<p><code>state ~ time</code>
</p>
<p>Observed states should be in the set <code>1, ...{}, n</code>, where <code>n</code> is
the number of states.  Note hidden Markov models are not supported by this
function.</p>
</td></tr>
<tr><td><code id="crudeinits.msm_+3A_subject">subject</code></td>
<td>
<p>Vector of subject identification numbers for the data
specified by <code>formula</code>. If missing, then all observations are assumed
to be on the same subject. These must be sorted so that all observations on
the same subject are adjacent.</p>
</td></tr>
<tr><td><code id="crudeinits.msm_+3A_qmatrix">qmatrix</code></td>
<td>
<p>Matrix of indicators for the allowed transitions.  An initial
value will be estimated for each value of qmatrix that is greater than zero.
Transitions are taken as disallowed for each entry of <code>qmatrix</code> that is
0.</p>
</td></tr>
<tr><td><code id="crudeinits.msm_+3A_data">data</code></td>
<td>
<p>An optional data frame in which the variables represented by
<code>subject</code> and <code>state</code> can be found.</p>
</td></tr>
<tr><td><code id="crudeinits.msm_+3A_censor">censor</code></td>
<td>
<p>A state, or vector of states, which indicates censoring.  See
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="crudeinits.msm_+3A_censor.states">censor.states</code></td>
<td>
<p>Specifies the underlying states which censored
observations can represent.  See <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose we want a crude estimate of the transition intensity
<code class="reqn">q_{rs}</code> from state <code class="reqn">r</code> to state <code class="reqn">s</code>.  If we observe
<code class="reqn">n_{rs}</code> transitions from state <code class="reqn">r</code> to state <code class="reqn">s</code>, and a
total of <code class="reqn">n_r</code> transitions from state <code class="reqn">r</code>, then <code class="reqn">q_{rs} / </code><code class="reqn"> q_{rr}</code> can be estimated by <code class="reqn">n_{rs} /
n_r</code>. Then, given a total of <code class="reqn">T_r</code> years spent in state
<code class="reqn">r</code>, the mean sojourn time <code class="reqn">1 / q_{rr}</code> can be estimated
as <code class="reqn">T_r / n_r</code>.  Thus, <code class="reqn">n_{rs} / T_r</code> is a crude
estimate of <code class="reqn">q_{rs}</code>.
</p>
<p>If the data do represent the exact transition times of the Markov process,
then these are the exact maximum likelihood estimates.
</p>
<p>Observed transitions which are incompatible with the given <code>qmatrix</code>
are ignored.  Censored states are ignored.
</p>


<h3>Value</h3>

<p>The estimated transition intensity matrix.  This can be used as the
<code>qmatrix</code> argument to <code><a href="#topic+msm">msm</a></code>.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+statetable.msm">statetable.msm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cav)
twoway4.q &lt;- rbind(c(-0.5, 0.25, 0, 0.25), c(0.166, -0.498, 0.166, 0.166),
c(0, 0.25, -0.5, 0.25), c(0, 0, 0, 0))
statetable.msm(state, PTNUM, data=cav)
crudeinits.msm(state ~ years, PTNUM, data=cav, qmatrix=twoway4.q)

</code></pre>

<hr>
<h2 id='deltamethod'>The delta method</h2><span id='topic+deltamethod'></span>

<h3>Description</h3>

<p>Delta method for approximating the standard error of a transformation
<code class="reqn">g(X)</code> of a random variable <code class="reqn">X = (x_1, x_2, \ldots)</code>, given estimates of the mean and covariance matrix of <code class="reqn">X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltamethod(g, mean, cov, ses = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deltamethod_+3A_g">g</code></td>
<td>
<p>A formula representing the transformation. The variables must be
labelled <code>x1, x2,...{}</code> For example,
</p>
<p><code>~ 1 / (x1 + x2)</code>
</p>
<p>If the transformation returns a vector, then a list of formulae representing
(<code class="reqn">g_1, g_2, \ldots</code>) can be provided, for example
</p>
<p><code>list( ~ x1 + x2, ~ x1 / (x1 + x2) )</code></p>
</td></tr>
<tr><td><code id="deltamethod_+3A_mean">mean</code></td>
<td>
<p>The estimated mean of <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="deltamethod_+3A_cov">cov</code></td>
<td>
<p>The estimated covariance matrix of <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="deltamethod_+3A_ses">ses</code></td>
<td>
<p>If <code>TRUE</code>, then the standard errors of <code class="reqn">g_1(X),
g_2(X),\ldots</code> are returned. Otherwise the covariance
matrix of <code class="reqn">g(X)</code> is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delta method expands a differentiable function of a random variable
about its mean, usually with a first-order Taylor approximation, and then
takes the variance. For example, an approximation to the covariance matrix
of <code class="reqn">g(X)</code> is given by
</p>
<p style="text-align: center;"><code class="reqn"> Cov(g(X)) = g'(\mu) Cov(X) [g'(\mu)]^T </code>
</p>

<p>where <code class="reqn">\mu</code> is an estimate of the mean of <code class="reqn">X</code>.  This function
uses symbolic differentiation via <code><a href="stats.html#topic+deriv">deriv</a></code>.
</p>
<p>A limitation of this function is that variables created by the user are not
visible within the formula <code>g</code>.  To work around this, it is necessary
to build the formula as a string, using functions such as <code>sprintf</code>,
then to convert the string to a formula using <code>as.formula</code>.  See the
example below.
</p>
<p>If you can spare the computational time, bootstrapping is a more accurate
method of calculating confidence intervals or standard errors for
transformations of parameters. See <code><a href="#topic+boot.msm">boot.msm</a></code>.  Simulation from
the asymptotic distribution of the MLEs (see e.g. Mandel 2013) is also a
convenient alternative.
</p>


<h3>Value</h3>

<p>A vector containing the standard errors of <code class="reqn">g_1(X), g_2(X),
\ldots</code> or a matrix containing the covariance of
<code class="reqn">g(X)</code>.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Oehlert, G. W. (1992) <em>A note on the delta method</em>.
American Statistician 46(1).
</p>
<p>Mandel, M. (2013) <em>Simulation based confidence intervals for functions
with complicated derivatives.</em> The American Statistician 67(2):76-81.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Simple linear regression, E(y) = alpha + beta x 
x &lt;- 1:100
y &lt;- rnorm(100, 4*x, 5)
toy.lm &lt;- lm(y ~ x)
estmean &lt;- coef(toy.lm)
estvar &lt;- summary(toy.lm)$cov.unscaled * summary(toy.lm)$sigma^2

## Estimate of (1 / (alphahat + betahat))
1 / (estmean[1] + estmean[2])
## Approximate standard error
deltamethod (~ 1 / (x1 + x2), estmean, estvar) 

## We have a variable z we would like to use within the formula.
z &lt;- 1
## deltamethod (~ z / (x1 + x2), estmean, estvar) will not work.
## Instead, build up the formula as a string, and convert to a formula.
form &lt;- sprintf("~ %f / (x1 + x2)", z)
form
deltamethod(as.formula(form), estmean, estvar)


</code></pre>

<hr>
<h2 id='draic.msm'>Criteria for comparing two multi-state models with nested state spaces</h2><span id='topic+draic.msm'></span><span id='topic+drlcv.msm'></span>

<h3>Description</h3>

<p>A modification of Akaike's information criterion, and a leave-one-out
likelihood cross-validation criterion, for comparing the predictive ability
of two Markov multi-state models with nested state spaces.  This is
evaluated based on the restricted or aggregated data which the models have
in common.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draic.msm(
  msm.full,
  msm.coarse,
  likelihood.only = FALSE,
  information = c("expected", "observed"),
  tl = 0.95
)

drlcv.msm(
  msm.full,
  msm.coarse,
  tl = 0.95,
  cores = NULL,
  verbose = TRUE,
  outfile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draic.msm_+3A_msm.full">msm.full</code></td>
<td>
<p>Model on the bigger state space.</p>
</td></tr>
<tr><td><code id="draic.msm_+3A_msm.coarse">msm.coarse</code></td>
<td>
<p>Model on the smaller state space.
</p>
<p>The two models must both be non-hidden Markov models without censored
states.
</p>
<p>The two models must be fitted to the same datasets, except that the state
space of the coarse model must be an aggregated version of the state space
of the full model.  That is, every state in the full dataset must correspond
to a unique state in the coarse dataset.  For example, for the full state
variable <code>c(1,1,2,2,3,4)</code>, the corresponding coarse states could be
<code>c(1,1,2,2,2,3)</code>, but not <code>c(1,2,3,4,4,4)</code>.
</p>
<p>The structure of allowed transitions in the coarse model must also be a
collapsed version of the big model structure, but no check is currently made
for this in the code.
</p>
<p>To use these functions, all objects which were used in the calls to fit
<code>msm.full</code> and <code>msm.coarse</code> must be in the working environment,
for example, datasets and definitions of transition matrices.</p>
</td></tr>
<tr><td><code id="draic.msm_+3A_likelihood.only">likelihood.only</code></td>
<td>
<p>Don't calculate Hessians and trace term (DRAIC).</p>
</td></tr>
<tr><td><code id="draic.msm_+3A_information">information</code></td>
<td>
<p>Use observed or expected information in the DRAIC trace
term.  Expected is the default, and much faster, though is only available
for models fitted to pure panel data (all <code>obstype=1</code> in the call to
<code><a href="#topic+msm">msm</a></code>, thus not exact transition times or exact death times)</p>
</td></tr>
<tr><td><code id="draic.msm_+3A_tl">tl</code></td>
<td>
<p>Width of symmetric tracking interval, by default 0.95 for a 95%
interval.</p>
</td></tr>
<tr><td><code id="draic.msm_+3A_cores">cores</code></td>
<td>
<p>Number of processor cores to use in <code>drlcv</code> for
cross-validation by parallel processing.  Requires the <span class="pkg">doParallel</span>
package to be installed.  If not specified, parallel processing is not used.
If <code>cores</code> is set to the string <code>"default"</code>, the default methods
of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> (on Windows) or
<code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> (on Unix-like) are used.</p>
</td></tr>
<tr><td><code id="draic.msm_+3A_verbose">verbose</code></td>
<td>
<p>Print intermediate results of each iteration of
cross-validation to the console while running. May not work with parallel
processing.</p>
</td></tr>
<tr><td><code id="draic.msm_+3A_outfile">outfile</code></td>
<td>
<p>Output file to print intermediate results of
cross-validation.  Useful to track execution speed when using parallel
processing, where output to the console may not work.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that standard AIC can be computed for one or more fitted <code>msm</code>
models <code>x,y,...</code> using <code><a href="stats.html#topic+AIC">AIC</a>(x,y,...)</code>, and this can be used
to compare models fitted to the same data. <code>draic.msm</code> and
<code>drlcv.msm</code> are designed for models fitted to data with
differently-aggregated state spaces.
</p>
<p>The difference in restricted AIC (Liquet and Commenges, 2011), as computed
by this function, is defined as
</p>
<p style="text-align: center;"><code class="reqn">D_{RAIC} = l(\gamma_n |\mathbf{x}'' ) - l(\theta_n |\mathbf{x}'' ) +
trace ( J(\theta_n |\mathbf{x}'')J(\theta_n |\mathbf{x})^{-1} - J(\gamma_n
|\mathbf{x}'' )J(\gamma_n |\mathbf{x}' )^{-1})</code>
</p>

<p>where <code class="reqn">\gamma</code> and <code class="reqn">\theta</code> are the maximum likelihood
estimates of the smaller and bigger models, fitted to the smaller and bigger
data, respectively.
</p>
<p><code class="reqn">l(\gamma_n |x'')</code> represents the likelihood of the
simpler model evaluated on the restricted data.
</p>
<p><code class="reqn">l(\theta_n |x'')</code> represents the likelihood of the
complex model evaluated on the restricted data.  This is a hidden Markov
model, with a misclassification matrix and initial state occupancy
probabilities as described by Thom et al (2014).
</p>
<p><code class="reqn">J()</code> are the corresponding (expected or observed, as specified by the
user) information matrices.
</p>
<p><code class="reqn">\mathbf{x}</code> is the expanded data, to which the bigger model was
originally fitted, and <code class="reqn">\mathbf{x}'</code> is the data to which the
smaller model was originally fitted.  <code class="reqn">\mathbf{x}''</code> is the
restricted data which the two models have in common.  <code class="reqn">\mathbf{x}'' =
\mathbf{x}'</code> in this implementation, so the models are nested.
</p>
<p>The difference in likelihood cross-validatory criteria (Liquet and
Commenges, 2011) is defined as
</p>
<p style="text-align: center;"><code class="reqn">D_{RLCV} = 1/n \sum_{i=1}^n \log( h_{X''}(x_i'' | \gamma_{-i}) /
g_{X''}(x_i''| \theta_{-i}))</code>
</p>

<p>where <code class="reqn">\gamma_{-i}</code> and <code class="reqn">\theta_{-i}</code> are the maximum likelihood
estimates from the smaller and bigger models fitted to datasets with subject
<code class="reqn">i</code> left out, <code class="reqn">g()</code> and <code class="reqn">h()</code> are the densities of the
corresponding models, and <code class="reqn">x_i''</code> is the restricted data from subject
<code class="reqn">i</code>.
</p>
<p>Tracking intervals are analogous to confidence intervals, but not strictly
the same, since the quantity which D_RAIC aims to estimate, the difference
in expected Kullback-Leibler discrepancy for predicting a replicate dataset,
depends on the sample size.  See the references.
</p>
<p>Positive values for these criteria indicate the coarse model is preferred,
while negative values indicate the full model is preferred.
</p>


<h3>Value</h3>

<p>A list containing <code class="reqn">D_{RAIC}</code> (<code>draic.msm</code>) or
<code class="reqn">D_{RLCV}</code> (<code>drlcv.msm</code>), its component terms, and tracking
intervals.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>, H. H. Z.
Thom <a href="mailto:howard.thom@bristol.ac.uk">howard.thom@bristol.ac.uk</a>
</p>


<h3>References</h3>

<p>Thom, H. and Jackson, C. and Commenges, D. and Sharples, L.
(2015) State selection in multistate models with application to quality of
life in psoriatic arthritis.  Statistics In Medicine 34(16) 2381 - 2480.
</p>
<p>Liquet, B. and Commenges D. (2011) Choice of estimators based on different
observations: Modified AIC and LCV criteria. Scandinavian Journal of
Statistics; 38:268-287.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logLik.msm">logLik.msm</a></code>
</p>

<hr>
<h2 id='ecmodel.object'>Developer documentation: model for covariates on misclassification
probabilities</h2><span id='topic+ecmodel.object'></span>

<h3>Description</h3>

<p>A list representing the model for covariates on misclassification
probabilities.
</p>


<h3>Value</h3>

<table>
<tr><td><code>npars</code></td>
<td>
<p>Number of covariate effect parameters.  This is defined
as the number of covariates on misclassification (with factors expanded as
contrasts) multiplied by the number of allowed misclassifications in the
model.  </p>
</td></tr> <tr><td><code>ndpars</code></td>
<td>
<p>Number of distinct covariate effect parameters, as
<code>npars</code>, but after any equality constraints have been applied.</p>
</td></tr>
<tr><td><code>ncovs</code></td>
<td>
<p>Number of covariates on misclassification, with factors
expanded as contrasts.</p>
</td></tr> <tr><td><code>constr</code></td>
<td>
<p>List of equality constraints on these
covariate effects, as supplied in the <code>miscconstraint</code> argument to
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>covlabels</code></td>
<td>
<p>Names / labels of these covariates in
the model matrix (see <code><a href="#topic+model.matrix.msm">model.matrix.msm</a></code>).</p>
</td></tr> <tr><td><code>inits</code></td>
<td>
<p>Initial
values for these covariate effects, as a vector formed from the
<code>misccovinits</code> list supplied to <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code>covmeans</code></td>
<td>
<p>Means of these covariates in the data (excluding data not
required to fit the model, such as observations with missing data in other
elements or subjects' last observations).  This includes means of 0/1 factor
contrasts as well as continuous covariates (for historic reasons, which may
not be sensible).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+msm.object">msm.object</a></code>.
</p>

<hr>
<h2 id='efpt.msm'>Expected first passage time</h2><span id='topic+efpt.msm'></span>

<h3>Description</h3>

<p>Expected time until first reaching a particular state or set of states in a
Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efpt.msm(
  x = NULL,
  qmatrix = NULL,
  tostate,
  start = "all",
  covariates = "mean",
  ci = c("none", "normal", "bootstrap"),
  cl = 0.95,
  B = 1000,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efpt.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="efpt.msm_+3A_qmatrix">qmatrix</code></td>
<td>
<p>Instead of <code>x</code>, you can simply supply a transition
intensity matrix in <code>qmatrix</code>.</p>
</td></tr>
<tr><td><code id="efpt.msm_+3A_tostate">tostate</code></td>
<td>
<p>State, or set of states supplied as a vector, for which to
estimate the first passage time into.  Can be integer, or character matched
to the row names of the Q matrix.</p>
</td></tr>
<tr><td><code id="efpt.msm_+3A_start">start</code></td>
<td>
<p>Starting state (integer).  By default (<code>start="all"</code>),
this will return a vector of expected passage times from each state in turn.
</p>
<p>Alternatively, this can be used to obtain the expected first passage time
from a <em>set</em> of states, rather than single states.  To achieve this,
<code>state</code> is set to a vector of weights, with length equal to the number
of states in the model.  These weights should be proportional to the
probability of starting in each of the states in the desired set, so that
weights of zero are supplied for other states.  The function will calculate
the weighted average of the expected passage times from each of the
corresponding states.</p>
</td></tr>
<tr><td><code id="efpt.msm_+3A_covariates">covariates</code></td>
<td>
<p>Covariate values defining the intensity matrix for the
fitted model <code>x</code>, as supplied to <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>.</p>
</td></tr>
<tr><td><code id="efpt.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"normal"</code>, then calculate a confidence interval by
simulating <code>B</code> random vectors from the asymptotic multivariate normal
distribution implied by the maximum likelihood estimates (and covariance
matrix) of the log transition intensities and covariate effects.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.
</p>
<p>If <code>"none"</code> (the default) then no confidence interval is calculated.</p>
</td></tr>
<tr><td><code id="efpt.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval, relative to 1.</p>
</td></tr>
<tr><td><code id="efpt.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="efpt.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="efpt.msm_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+MatrixExp">MatrixExp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected first passage times from each of a set of states
<code class="reqn">\mathbf{i}</code> to to the remaining set of states
<code class="reqn">\overline{\mathbf{i}}</code> in the state space, for a model with
transition intensity matrix <code class="reqn">Q</code>, are
</p>
<p style="text-align: center;"><code class="reqn">-Q_{\mathbf{i},\mathbf{i}}^{-1} \mathbf{1}</code>
</p>

<p>where <code class="reqn">\mathbf{1}</code> is a vector of ones, and
<code class="reqn">Q_{\mathbf{i},\mathbf{i}}</code> is the square subset of <code class="reqn">Q</code>
pertaining to states <code class="reqn">\mathbf{i}</code>.
</p>
<p>It is equal to the sum of mean sojourn times for all states between the
&quot;from&quot; and &quot;to&quot; states in a unidirectional model.  If there is non-zero
chance of reaching an absorbing state before reaching <code>tostate</code>, then
it is infinite.  It is trivially zero if the &quot;from&quot; state equals
<code>tostate</code>.
</p>
<p>This function currently only handles time-homogeneous Markov models.  For
time-inhomogeneous models it will assume that <code class="reqn">Q</code> equals the average
intensity matrix over all times and observed covariates.  Simulation might
be used to handle time dependence.
</p>
<p>Note this is the <em>expectation</em> of first passage time, and the
confidence intervals are CIs for this mean, not predictive intervals for the
first passage time.  The full distribution of the first passage time to a
set of states can be obtained by setting the rows of the intensity matrix
<code class="reqn">Q</code> corresponding to that set of states to zero to make a model where
those states are absorbing.  The corresponding transition probability matrix
<code class="reqn">Exp(Qt)</code> then gives the probabilities of having hit or passed that
state by a time <code class="reqn">t</code> (see the example below). This is implemented in
<code><a href="#topic+ppass.msm">ppass.msm</a></code>.
</p>


<h3>Value</h3>

<p>A vector of expected first passage times, or &quot;hitting times&quot;, from
each state to the desired state.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Norris, J. R. (1997) Markov Chains. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sojourn.msm">sojourn.msm</a></code>, <code><a href="#topic+totlos.msm">totlos.msm</a></code>,
<code><a href="#topic+boot.msm">boot.msm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
twoway4.q &lt;- rbind(c(-0.5, 0.25, 0, 0.25), c(0.166, -0.498, 0.166, 0.166),
             c(0, 0.25, -0.5, 0.25), c(0, 0, 0, 0))
efpt.msm(qmatrix=twoway4.q, tostate=3)
# given in state 1, expected time to reaching state 3 is infinite
# since may die (state 4) before entering state 3

# If we remove the death state from the model, EFPTs become finite
Q &lt;- twoway4.q[1:3,1:3]; diag(Q) &lt;- 0; diag(Q) &lt;- -rowSums(Q)
efpt.msm(qmatrix=Q, tostate=3)

# Suppose we cannot die or regress while in state 2, can only go to state 3
Q &lt;- twoway4.q; Q[2,4] &lt;- Q[2,1] &lt;- 0; diag(Q) &lt;- 0; diag(Q) &lt;- -rowSums(Q)
efpt.msm(qmatrix=Q, tostate=3)
# The expected time from 2 to 3 now equals the mean sojourn time in 2.
-1/Q[2,2]

# Calculate cumulative distribution of the first passage time
# into state 3 for the following three-state model
Q &lt;- twoway4.q[1:3,1:3]; diag(Q) &lt;- 0; diag(Q) &lt;- -rowSums(Q)
# Firstly form a model where the desired hitting state is absorbing
Q[3,] &lt;- 0
MatrixExp(Q, t=10)[,3]
ppass.msm(qmatrix=Q, tot=10)
# Given in state 1 at time 0, P(hit 3 by time 10) = 0.479
MatrixExp(Q, t=50)[,3]  # P(hit 3 by time 50) = 0.98
ppass.msm(qmatrix=Q, tot=50)


</code></pre>

<hr>
<h2 id='ematrix.msm'>Misclassification probability matrix</h2><span id='topic+ematrix.msm'></span>

<h3>Description</h3>

<p>Extract the estimated misclassification probability matrix, and
corresponding confidence intervals, from a fitted multi-state model at a
given set of covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ematrix.msm(
  x,
  covariates = "mean",
  ci = c("delta", "normal", "bootstrap", "none"),
  cl = 0.95,
  B = 1000,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ematrix.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code></p>
</td></tr>
<tr><td><code id="ematrix.msm_+3A_covariates">covariates</code></td>
<td>
<p>The covariate values for which to estimate the misclassification probability
matrix.  This can either be:<br />
</p>
<p>the string <code>"mean"</code>, denoting the means of the covariates in the data
(this is the default),<br />
</p>
<p>the number <code>0</code>, indicating that all the covariates should be set to
zero,<br />
</p>
<p>or a list of values, with optional names. For example
</p>
<p><code>list (60, 1)</code>
</p>
<p>where the order of the list follows the order of the covariates originally
given in the model formula, or a named list,
</p>
<p><code>list (age = 60, sex = 1)</code></p>
</td></tr>
<tr><td><code id="ematrix.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"delta"</code> (the default) then confidence intervals are
calculated by the delta method, or by simple transformation of the Hessian
in the very simplest cases.
</p>
<p>If <code>"normal"</code>, then calculate a confidence interval by simulating
<code>B</code> random vectors from the asymptotic multivariate normal distribution
implied by the maximum likelihood estimates (and covariance matrix) of the
multinomial-logit-transformed misclassification probabilities and covariate
effects, then transforming back.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.</p>
</td></tr>
<tr><td><code id="ematrix.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval to present.  Defaults
to 0.95.</p>
</td></tr>
<tr><td><code id="ematrix.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates, or number of normal simulations
from the distribution of the MLEs</p>
</td></tr>
<tr><td><code id="ematrix.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Misclassification probabilities and covariate effects are estimated on the
multinomial-logit scale by <code><a href="#topic+msm">msm</a></code>. A covariance matrix is
estimated from the Hessian of the maximised log-likelihood.  From these, the
delta method can be used to obtain standard errors of the probabilities on
the natural scale at arbitrary covariate values.  Confidence intervals are
estimated by assuming normality on the multinomial-logit scale.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>Estimated misclassification probability matrix. The rows
correspond to true states, and columns observed states.</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>Corresponding approximate standard errors.</p>
</td></tr> <tr><td><code>L</code></td>
<td>
<p>Lower
confidence limits.</p>
</td></tr> <tr><td><code>U</code></td>
<td>
<p>Upper confidence limits.</p>
</td></tr>
</table>
<p>Or if <code>ci="none"</code>, then <code>ematrix.msm</code> just returns the estimated
misclassification probability matrix.
</p>
<p>The default print method for objects returned by <code><a href="#topic+ematrix.msm">ematrix.msm</a></code>
presents estimates and confidence limits. To present estimates and standard
errors, do something like
</p>
<p><code>ematrix.msm(x)[c("estimates","SE")]</code>
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>
</p>

<hr>
<h2 id='emodel.object'>Developer documentation: misclassification model structure object</h2><span id='topic+emodel.object'></span>

<h3>Description</h3>

<p>A list giving information about the misclassifications assumed in a
multi-state model fitted with the <code>ematrix</code> argument of
<code><a href="#topic+msm">msm</a></code>.  Returned in a fitted <code><a href="#topic+msm">msm</a></code> model object.
This information is converted internally to a <code>hmodel</code> object (see
<code><a href="#topic+hmodel.object">hmodel.object</a></code>) for use in likelihood computations.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nstates</code></td>
<td>
<p>Number of states (same as <code>qmodel$nstates</code>).</p>
</td></tr>
<tr><td><code>npars</code></td>
<td>
<p>Number of allowed misclassifications, equal to
<code>sum(imatrix)</code>.</p>
</td></tr> <tr><td><code>imatrix</code></td>
<td>
<p>Indicator matrix for allowed
misclassifications.  This has <code class="reqn">(r,s)</code> entry 1 if misclassification of
true state <code class="reqn">r</code> as observed state <code class="reqn">s</code> is possible.  diagonal entries
are arbitrarily set to 0.</p>
</td></tr> <tr><td><code>ematrix</code></td>
<td>
<p>Matrix of initial values for the
misclassification probabilities, supplied as the <code>ematrix</code> argument of
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>inits</code></td>
<td>
<p>Vector of these initial values, reading
across rows of <code>qmatrix</code> and excluding the diagonal and disallowed
transitions.</p>
</td></tr> <tr><td><code>constr</code></td>
<td>
<p>Indicators for equality constraints on baseline
misclassification probabilities, taken from the <code>econstraint</code> argument
to <code><a href="#topic+msm">msm</a></code>, and mapped if necessary to the set (1,2,3,...)</p>
</td></tr>
<tr><td><code>ndpars</code></td>
<td>
<p>Number of distinct misclassification probabilities, after
applying equality constraints.</p>
</td></tr> <tr><td><code>nipars</code></td>
<td>
<p>Number of initial state
occupancy probabilities being estimated.  This is zero if
<code>est.initprobs=FALSE</code>, otherwise equal to the number of states.</p>
</td></tr>
<tr><td><code>initprobs</code></td>
<td>
<p>Initial state occupancy probabilities, as supplied to
<code><a href="#topic+msm">msm</a></code> (initial values before estimation, if
<code>est.initprobs=TRUE</code>.)</p>
</td></tr> <tr><td><code>est.initprobs</code></td>
<td>
<p>Are initial state
occupancy probabilities estimated (<code>TRUE</code> or <code>FALSE</code>), as supplied
in the <code>est.initprobs</code> argument of <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+msm.object">msm.object</a></code>,<code><a href="#topic+qmodel.object">qmodel.object</a></code>,
<code><a href="#topic+hmodel.object">hmodel.object</a></code>.
</p>

<hr>
<h2 id='fev'>FEV1 measurements from lung transplant recipients</h2><span id='topic+fev'></span>

<h3>Description</h3>

<p>A series of measurements of the forced expiratory volume in one second
(FEV1) from lung transplant recipients, from six months onwards after their
transplant.
</p>


<h3>Format</h3>

<p>A data frame containing 5896 rows.  There are 204 patients, the rows
are grouped by patient number and ordered by days after transplant.  Each
row represents an examination and containing an additional covariate.
</p>

<table>
<tr>
 <td style="text-align: right;"> <code>ptnum</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Patient identification
number. </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>days</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Examination time (days after
transplant). </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>fev</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Percentage of baseline FEV1.
A code of 999 indicates the patient's date of death. </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>acute</code> </td><td style="text-align: left;">
(numeric) </td><td style="text-align: left;"> 0/1 indicator for whether the patient suffered an acute
infection or rejection </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> within 14 days of the visit.  </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>



<h3>Details</h3>

<p>A baseline &quot;normal&quot; FEV1 for each individual is calculated using
measurements from the first six months after transplant. After six months,
as presented in this dataset, FEV1 is expressed as a percentage of the
baseline value.
</p>
<p>FEV1 is monitored to diagnose bronchiolitis obliterans syndrome (BOS), a
long-term lung function decline, thought to be a form of chronic rejection.
Acute rejections and infections also affect the lung function in the short
term.
</p>


<h3>Source</h3>

<p>Papworth Hospital, U.K.
</p>


<h3>References</h3>

<p>Jackson, C.H. and Sharples, L.D. Hidden Markov models for the
onset and progression of bronchiolitis obliterans syndrome in lung
transplant recipients <em>Statistics in Medicine</em>, 21(1): 113&ndash;128 (2002).
</p>

<hr>
<h2 id='hazard.msm'>Calculate tables of hazard ratios for covariates on transition intensities</h2><span id='topic+hazard.msm'></span>

<h3>Description</h3>

<p>Hazard ratios are computed by exponentiating the estimated covariate effects
on the log-transition intensities.  This function is called by
<code><a href="#topic+summary.msm">summary.msm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazard.msm(x, hazard.scale = 1, cl = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazard.msm_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+msm">msm</a></code> representing a fitted multi-state
model.</p>
</td></tr>
<tr><td><code id="hazard.msm_+3A_hazard.scale">hazard.scale</code></td>
<td>
<p>Vector with same elements as number of covariates on
transition rates. Corresponds to the increase in each covariate used to
calculate its hazard ratio. Defaults to all 1.</p>
</td></tr>
<tr><td><code id="hazard.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval to present.  Defaults
to 0.95.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables containing hazard ratio estimates, one table for each
covariate.  Each table has three columns, containing the hazard ratio, and
an approximate upper and lower confidence limit respectively (assuming
normality on the log scale), for each Markov chain transition intensity.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>, <code><a href="#topic+summary.msm">summary.msm</a></code>,
<code><a href="#topic+odds.msm">odds.msm</a></code>
</p>

<hr>
<h2 id='hmm-dists'>Hidden Markov model constructors</h2><span id='topic+hmm-dists'></span><span id='topic+hmmCat'></span><span id='topic+hmmIdent'></span><span id='topic+hmmUnif'></span><span id='topic+hmmNorm'></span><span id='topic+hmmLNorm'></span><span id='topic+hmmExp'></span><span id='topic+hmmGamma'></span><span id='topic+hmmWeibull'></span><span id='topic+hmmPois'></span><span id='topic+hmmBinom'></span><span id='topic+hmmTNorm'></span><span id='topic+hmmMETNorm'></span><span id='topic+hmmMEUnif'></span><span id='topic+hmmNBinom'></span><span id='topic+hmmBetaBinom'></span><span id='topic+hmmBeta'></span><span id='topic+hmmT'></span>

<h3>Description</h3>

<p>These functions are used to specify the distribution of the response
conditionally on the underlying state in a hidden Markov model.  A list of
these function calls, with one component for each state, should be used for
the <code>hmodel</code> argument to <code>msm</code>. The initial values for the
parameters of the distribution should be given as arguments. Note the
initial values should be supplied as literal values - supplying them as
variables is currently not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmCat(prob, basecat)

hmmIdent(x)

hmmUnif(lower, upper)

hmmNorm(mean, sd)

hmmLNorm(meanlog, sdlog)

hmmExp(rate)

hmmGamma(shape, rate)

hmmWeibull(shape, scale)

hmmPois(rate)

hmmBinom(size, prob)

hmmBetaBinom(size, meanp, sdp)

hmmNBinom(disp, prob)

hmmBeta(shape1, shape2)

hmmTNorm(mean, sd, lower = -Inf, upper = Inf)

hmmMETNorm(mean, sd, lower, upper, sderr, meanerr = 0)

hmmMEUnif(lower, upper, sderr, meanerr = 0)

hmmT(mean, scale, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm-dists_+3A_prob">prob</code></td>
<td>
<p>(<code>hmmCat</code>) Vector of probabilities of observing category
<code>1, 2, ...{}, length(prob)</code> respectively.  Or the probability
governing a binomial or negative binomial distribution.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_basecat">basecat</code></td>
<td>
<p>(<code>hmmCat</code>) Category which is considered to be the
&quot;baseline&quot;, so that during estimation, the probabilities are parameterised
as probabilities relative to this baseline category. By default, the
category with the greatest probability is used as the baseline.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_x">x</code></td>
<td>
<p>(<code>hmmIdent</code>) Code in the data which denotes the
exactly-observed state.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_lower">lower</code></td>
<td>
<p>(<code>hmmUnif,hmmTNorm,hmmMEUnif</code>) Lower limit for an Uniform
or truncated Normal distribution.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_upper">upper</code></td>
<td>
<p>(<code>hmmUnif,hmmTNorm,hmmMEUnif</code>) Upper limit for an Uniform
or truncated Normal distribution.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_mean">mean</code></td>
<td>
<p>(<code>hmmNorm,hmmLNorm,hmmTNorm</code>) Mean defining a Normal, or
truncated Normal distribution.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_sd">sd</code></td>
<td>
<p>(<code>hmmNorm,hmmLNorm,hmmTNorm</code>) Standard deviation defining a
Normal, or truncated Normal distribution.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_meanlog">meanlog</code></td>
<td>
<p>(<code>hmmNorm,hmmLNorm,hmmTNorm</code>) Mean on the log scale, for
a log Normal distribution.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_sdlog">sdlog</code></td>
<td>
<p>(<code>hmmNorm,hmmLNorm,hmmTNorm</code>) Standard deviation on the
log scale, for a log Normal distribution.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_rate">rate</code></td>
<td>
<p>(<code>hmmPois,hmmExp,hmmGamma</code>) Rate of a Poisson, Exponential
or Gamma distribution (see <code><a href="stats.html#topic+dpois">dpois</a></code>, <code><a href="stats.html#topic+dexp">dexp</a></code>,
<code><a href="stats.html#topic+dgamma">dgamma</a></code>).</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_shape">shape</code></td>
<td>
<p>(<code>hmmPois,hmmExp,hmmGamma</code>) Shape parameter of a Gamma or
Weibull distribution (see <code><a href="stats.html#topic+dgamma">dgamma</a></code>, <code><a href="stats.html#topic+dweibull">dweibull</a></code>).</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_scale">scale</code></td>
<td>
<p>(<code>hmmGamma</code>) Scale parameter of a Gamma distribution (see
<code><a href="stats.html#topic+dgamma">dgamma</a></code>), or unstandardised Student t distribution.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_size">size</code></td>
<td>
<p>Order of a Binomial distribution (see <code><a href="stats.html#topic+dbinom">dbinom</a></code>).</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_meanp">meanp</code></td>
<td>
<p>Mean outcome probability in a beta-binomial distribution</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_sdp">sdp</code></td>
<td>
<p>Standard deviation describing the overdispersion of the outcome
probability in a beta-binomial distribution</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_disp">disp</code></td>
<td>
<p>Dispersion parameter of a negative binomial distribution, also
called <code>size</code> or <code>order</code>.  (see <code><a href="stats.html#topic+dnbinom">dnbinom</a></code>).</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_shape1">shape1</code>, <code id="hmm-dists_+3A_shape2">shape2</code></td>
<td>
<p>First and second parameters of a beta distribution (see
<code><a href="stats.html#topic+dbeta">dbeta</a></code>).</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_sderr">sderr</code></td>
<td>
<p>(<code>hmmMETNorm,hmmUnif</code>) Standard deviation of the Normal
measurement error distribution.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_meanerr">meanerr</code></td>
<td>
<p>(<code>hmmMETNorm,hmmUnif</code>) Additional shift in the
measurement error, fixed to 0 by default.  This may be modelled in terms of
covariates.</p>
</td></tr>
<tr><td><code id="hmm-dists_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the Student t distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hmmCat</code> represents a categorical response distribution on the set
<code>1, 2, ...{}, length(prob)</code>.  The Markov model with misclassification
is an example of this type of model. The categories in this case are (some
subset of) the underlying states.
</p>
<p>The <code>hmmIdent</code> distribution is used for underlying states which are
observed exactly without error.  For hidden Markov models with multiple
outcomes, (see <code><a href="#topic+hmmMV">hmmMV</a></code>), the outcome in the data which takes the
special <code>hmmIdent</code> value must be the first of the multiple outcomes.
</p>
<p><code>hmmUnif</code>, <code>hmmNorm</code>, <code>hmmLNorm</code>, <code>hmmExp</code>,
<code>hmmGamma</code>, <code>hmmWeibull</code>, <code>hmmPois</code>, <code>hmmBinom</code>,
<code>hmmTNorm</code>, <code>hmmNBinom</code> and <code>hmmBeta</code> represent Uniform,
Normal, log-Normal, exponential, Gamma, Weibull, Poisson, Binomial,
truncated Normal, negative binomial and beta distributions, respectively,
with parameterisations the same as the default parameterisations in the
corresponding base R distribution functions.
</p>
<p><code>hmmT</code> is the Student t distribution with general mean <code class="reqn">\mu</code>,
scale <code class="reqn">\sigma</code> and degrees of freedom <code>df</code>.  The variance is
<code class="reqn">\sigma^2 df/(df + 2)</code>.  Note the t distribution in
base R <code><a href="stats.html#topic+dt">dt</a></code> is a standardised one with mean 0 and scale 1.
These allow any positive (integer or non-integer) <code>df</code>.  By default,
all three parameters, including <code>df</code>, are estimated when fitting a
hidden Markov model, but in practice, <code>df</code> might need to be fixed for
identifiability - this can be done using the <code>fixedpars</code> argument to
<code><a href="#topic+msm">msm</a></code>.
</p>
<p>The <code>hmmMETNorm</code> and <code>hmmMEUnif</code> distributions are truncated
Normal and Uniform distributions, but with additional Normal measurement
error on the response. These are generalisations of the distributions
proposed by Satten and Longini (1996) for modelling the progression of CD4
cell counts in monitoring HIV disease.  See <code><a href="#topic+medists">medists</a></code> for
density, distribution, quantile and random generation functions for these
distributions.  See also <code><a href="#topic+tnorm">tnorm</a></code> for density, distribution,
quantile and random generation functions for the truncated Normal
distribution.
</p>
<p>See the PDF manual &lsquo;<span class="file">msm-manual.pdf</span>&rsquo; in the &lsquo;<span class="file">doc</span>&rsquo; subdirectory for
algebraic definitions of all these distributions.  New hidden Markov model
response distributions can be added to <span class="pkg">msm</span> by following the
instructions in Section 2.17.1.
</p>
<p>Parameters which can be modelled in terms of covariates, on the scale of a
link function, are as follows.
</p>

<table>
<tr>
 <td style="text-align: left;"> PARAMETER NAME </td><td style="text-align: left;"> LINK FUNCTION </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>mean</code> </td><td style="text-align: left;">
identity </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>meanlog</code> </td><td style="text-align: left;"> identity </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>rate</code> </td><td style="text-align: left;"> log </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>scale</code> </td><td style="text-align: left;"> log </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>meanerr</code> </td><td style="text-align: left;"> identity </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>meanp</code> </td><td style="text-align: left;">
logit </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>prob</code> </td><td style="text-align: left;"> logit or multinomial logit </td>
</tr>

</table>

<p>Parameters <code>basecat, lower, upper, size, meanerr</code> are fixed at their
initial values. All other parameters are estimated while fitting the hidden
Markov model, unless the appropriate <code>fixedpars</code> argument is supplied
to <code>msm</code>.
</p>
<p>For categorical response distributions <code>(hmmCat)</code> the outcome
probabilities initialized to zero are fixed at zero, and the probability
corresponding to <code>basecat</code> is fixed to one minus the sum of the
remaining probabilities.  These remaining probabilities are estimated, and
can be modelled in terms of covariates via multinomial logistic regression
(relative to <code>basecat</code>).
</p>


<h3>Value</h3>

<p>Each function returns an object of class <code>hmodel</code>, which is a
list containing information about the model.  The only component which may
be useful to end users is <code>r</code>, a function of one argument <code>n</code>
which returns a random sample of size <code>n</code> from the given distribution.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Satten, G.A. and Longini, I.M.  Markov chains with measurement
error: estimating the 'true' course of a marker of the progression of human
immunodeficiency virus disease (with discussion) <em>Applied Statistics</em>
45(3): 275-309 (1996).
</p>
<p>Jackson, C.H. and Sharples, L.D. Hidden Markov models for the onset and
progresison of bronchiolitis obliterans syndrome in lung transplant
recipients <em>Statistics in Medicine</em>, 21(1): 113&ndash;128 (2002).
</p>
<p>Jackson, C.H., Sharples, L.D., Thompson, S.G. and Duffy, S.W. and Couto, E.
Multi-state Markov models for disease progression with classification error.
<em>The Statistician</em>, 52(2): 193&ndash;209 (2003).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>
</p>

<hr>
<h2 id='hmmMV'>Multivariate hidden Markov models</h2><span id='topic+hmmMV'></span>

<h3>Description</h3>

<p>Constructor for a a multivariate hidden Markov model (HMM) where each of the
<code>n</code> variables observed at the same time has a (potentially different)
standard univariate distribution conditionally on the underlying state.  The
<code>n</code> outcomes are independent conditionally on the hidden state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmMV(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmmMV_+3A_...">...</code></td>
<td>
<p>The number of arguments supplied should equal the maximum number
of observations made at one time.  Each argument represents the univariate
distribution of that outcome conditionally on the hidden state, and should
be the result of calling a univariate hidden Markov model constructor (see
<code><a href="#topic+hmm-dists">hmm-dists</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a particular state in a HMM has such an outcome distribution, then a call
to <code><a href="#topic+hmmMV">hmmMV</a></code> is supplied as the corresponding element of the
<code>hmodel</code> argument to <code><a href="#topic+msm">msm</a></code>.  See Example 2 below.
</p>
<p>A multivariate HMM where multiple outcomes at the same time are generated
from the <em>same</em> distribution is specified in the same way as the
corresponding univariate model, so that <code><a href="#topic+hmmMV">hmmMV</a></code> is not required.
The outcome data are simply supplied as a matrix instead of a vector.  See
Example 1 below.
</p>
<p>The outcome data for such models are supplied as a matrix, with number of
columns equal to the maximum number of arguments supplied to the
<code><a href="#topic+hmmMV">hmmMV</a></code> calls for each state.  If some but not all of the
variables are missing (<code>NA</code>) at a particular time, then the observed
data at that time still contribute to the likelihood.  The missing data are
assumed to be missing at random.  The Viterbi algorithm may be used to
predict the missing values given the fitted model and the observed data.
</p>
<p>Typically the outcome model for each state will be from the same family or
set of families, but with different parameters.  Theoretically, different
numbers of distributions may be supplied for different states.  If a
particular state has fewer outcomes than the maximum, then the data for that
state are taken from the first columns of the response data matrix.  However
this is not likely to be a useful model, since the number of observations
will probably give information about the underlying state, violating the
missing at random assumption.
</p>
<p>Models with outcomes that are dependent conditionally on the hidden state
(e.g. correlated multivariate normal observations) are not currently
supported.
</p>


<h3>Value</h3>

<p>A list of objects, each of class <code>hmmdist</code> as returned by the
univariate HMM constructors documented in <code><a href="#topic+hmm-dists">hmm-dists</a></code>.  The
whole list has class <code>hmmMVdist</code>, which inherits from <code>hmmdist</code>.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Jackson, C. H., Su, L., Gladman, D. D. and Farewell, V. T.
(2015) On modelling minimal disease activity.  Arthritis Care and Research
(early view).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm-dists">hmm-dists</a></code>,<code><a href="#topic+msm">msm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate data from a Markov model 
nsubj &lt;- 30; nobspt &lt;- 5
sim.df &lt;- data.frame(subject = rep(1:nsubj, each=nobspt),
                     time = seq(0, 20, length=nobspt))
set.seed(1)
two.q &lt;- rbind(c(-0.1, 0.1), c(0, 0))
dat &lt;- simmulti.msm(sim.df[,1:2], qmatrix=two.q, drop.absorb=FALSE)

### EXAMPLE 1
## Generate two observations at each time from the same outcome
## distribution:
## Bin(40, 0.1) for state 1, Bin(40, 0.5) for state 2
dat$obs1[dat$state==1] &lt;- rbinom(sum(dat$state==1), 40, 0.1)
dat$obs2[dat$state==1] &lt;- rbinom(sum(dat$state==1), 40, 0.1)
dat$obs1[dat$state==2] &lt;- rbinom(sum(dat$state==2), 40, 0.5)
dat$obs2[dat$state==2] &lt;- rbinom(sum(dat$state==2), 40, 0.5)
dat$obs &lt;- cbind(obs1 = dat$obs1, obs2 = dat$obs2)

## Fitted model should approximately recover true parameters 
msm(obs ~ time, subject=subject, data=dat, qmatrix=two.q,
    hmodel = list(hmmBinom(size=40, prob=0.2),
                  hmmBinom(size=40, prob=0.2)))

### EXAMPLE 2
## Generate two observations at each time from different
## outcome distributions:
## Bin(40, 0.1) and Bin(40, 0.2) for state 1, 
dat$obs1 &lt;- dat$obs2 &lt;- NA
dat$obs1[dat$state==1] &lt;- rbinom(sum(dat$state==1), 40, 0.1)
dat$obs2[dat$state==1] &lt;- rbinom(sum(dat$state==1), 40, 0.2)

## Bin(40, 0.5) and Bin(40, 0.6) for state 2
dat$obs1[dat$state==2] &lt;- rbinom(sum(dat$state==2), 40, 0.6)
dat$obs2[dat$state==2] &lt;- rbinom(sum(dat$state==2), 40, 0.5)
dat$obs &lt;- cbind(obs1 = dat$obs1, obs2 = dat$obs2)

## Fitted model should approximately recover true parameters 
msm(obs ~ time, subject=subject, data=dat, qmatrix=two.q,   
    hmodel = list(hmmMV(hmmBinom(size=40, prob=0.3),
                        hmmBinom(size=40, prob=0.3)),                 
                 hmmMV(hmmBinom(size=40, prob=0.3),
                       hmmBinom(size=40, prob=0.3))),
    control=list(maxit=10000))

</code></pre>

<hr>
<h2 id='hmodel.object'>Developer documentation: hidden Markov model structure object</h2><span id='topic+hmodel.object'></span>

<h3>Description</h3>

<p>A list giving information about the models for the outcome data
conditionally on the states of a hidden Markov model.  Used in internal
computations, and returned in a fitted <code><a href="#topic+msm">msm</a></code> model object.
</p>


<h3>Value</h3>

<table>
<tr><td><code>hidden</code></td>
<td>
<p><code>TRUE</code> for hidden Markov models, <code>FALSE</code>
otherwise.</p>
</td></tr> <tr><td><code>nstates</code></td>
<td>
<p>Number of states, the same as
<code>qmodel$nstates</code>.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p><code>TRUE</code> if the parameter values in
<code>pars</code> are the maximum likelihood estimates, <code>FALSE</code> if they are
the initial values.</p>
</td></tr> <tr><td><code>models</code></td>
<td>
<p>The outcome distribution for each hidden
state.  A vector of length <code>nstates</code> whose <code class="reqn">r</code>th entry is the index
of the state <code class="reqn">r</code> outcome distributions in the vector of supported
distributions.  The vector of supported distributions is given in full by
<code>msm:::.msm.HMODELS</code>: the first few are 1 for categorical outcome, 2
for identity, 3 for uniform and 4 for normal. </p>
</td></tr> <tr><td><code>labels</code></td>
<td>
<p>String
identifying each distribution in <code>models</code>.</p>
</td></tr> <tr><td><code>npars</code></td>
<td>
<p>Vector of
length <code>nstates</code> giving the number of parameters in each outcome
distribution, excluding covariate effects.</p>
</td></tr> <tr><td><code>nipars</code></td>
<td>
<p>Number of initial
state occupancy probabilities being estimated.  This is zero if
<code>est.initprobs=FALSE</code>, otherwise equal to the number of states.</p>
</td></tr>
<tr><td><code>totpars</code></td>
<td>
<p>Total number of parameters, equal to <code>sum(npars)</code>. </p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>A vector of length <code>totpars</code>, made from concatenating a
list of length <code>nstates</code> whose <code class="reqn">r</code>th component is vector of the
parameters for the state <code class="reqn">r</code> outcome distribution.  </p>
</td></tr> <tr><td><code>plabs</code></td>
<td>
<p>List
with the names of the parameters in <code>pars</code>.</p>
</td></tr> <tr><td><code>parstate</code></td>
<td>
<p>A vector
of length <code>totpars</code>, whose <code class="reqn">i</code>th element is the state corresponding
to the <code class="reqn">i</code>th parameter.</p>
</td></tr> <tr><td><code>firstpar</code></td>
<td>
<p>A vector of length
<code>nstates</code> giving the index in <code>pars</code> of the first parameter for
each state.</p>
</td></tr> <tr><td><code>locpars</code></td>
<td>
<p>Index in <code>pars</code> of parameters which can
have covariates on them. </p>
</td></tr> <tr><td><code>initprobs</code></td>
<td>
<p>Initial state occupancy
probabilities, as supplied to <code><a href="#topic+msm">msm</a></code> (initial values before
estimation, if <code>est.initprobs=TRUE</code>.)</p>
</td></tr> <tr><td><code>est.initprobs</code></td>
<td>
<p>Are initial
state occupancy probabilities estimated (<code>TRUE</code> or <code>FALSE</code>), as
supplied in the <code>est.initprobs</code> argument of <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code>ncovs</code></td>
<td>
<p>Number of covariate effects per parameter in <code>pars</code>, with,
e.g. factor contrasts expanded.</p>
</td></tr> <tr><td><code>coveffect</code></td>
<td>
<p>Vector of covariate
effects, of length <code>sum(ncovs)</code>.</p>
</td></tr> <tr><td><code>covlabels</code></td>
<td>
<p>Labels of these
effects.</p>
</td></tr> <tr><td><code>coveffstate</code></td>
<td>
<p>Vector indicating state corresponding to each
element of <code>coveffect</code>.</p>
</td></tr> <tr><td><code>ncoveffs</code></td>
<td>
<p>Number of covariate effects on
HMM outcomes, equal to <code>sum(ncovs)</code>.</p>
</td></tr> <tr><td><code>nicovs</code></td>
<td>
<p>Vector of length
<code>nstates-1</code> giving the number of covariate effects on each initial
state occupancy probability (log relative to the baseline probability).</p>
</td></tr>
<tr><td><code>icoveffect</code></td>
<td>
<p>Vector of length <code>sum(nicovs)</code> giving covariate
effects on initial state occupancy probabilities.</p>
</td></tr> <tr><td><code>nicoveffs</code></td>
<td>
<p>Number
of covariate effects on initial state occupancy probabilities, equal to
<code>sum(nicovs)</code>.</p>
</td></tr> <tr><td><code>constr</code></td>
<td>
<p>Constraints on (baseline) hidden Markov
model outcome parameters, as supplied in the <code>hconstraint</code> argument of
<code><a href="#topic+msm">msm</a></code>, excluding covariate effects, converted to a vector and
mapped to the set 1,2,3,... if necessary.</p>
</td></tr> <tr><td><code>covconstr</code></td>
<td>
<p>Vector of
constraints on covariate effects in hidden Markov outcome models, as
supplied in the <code>hconstraint</code> argument of <code><a href="#topic+msm">msm</a></code>, excluding
baseline parameters, converted to a vector and mapped to the set
1,2,3,... if necessary.</p>
</td></tr> <tr><td><code>ranges</code></td>
<td>
<p>Matrix of range restrictions for
HMM parameters, including those given to the <code>hranges</code> argument to
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>foundse</code></td>
<td>
<p><code>TRUE</code> if standard errors are
available for the estimates.</p>
</td></tr> <tr><td><code>initpmat</code></td>
<td>
<p>Matrix of initial state
occupancy probabilities with one row for each subject (estimated if
<code>est.initprobs=TRUE</code>).</p>
</td></tr> <tr><td><code>ci</code></td>
<td>
<p>Confidence intervals for baseline HMM
outcome parameters.</p>
</td></tr> <tr><td><code>covci</code></td>
<td>
<p>Confidence intervals for covariate effects
in HMM outcome models.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+msm.object">msm.object</a></code>,<code><a href="#topic+qmodel.object">qmodel.object</a></code>,
<code><a href="#topic+emodel.object">emodel.object</a></code>.
</p>

<hr>
<h2 id='logLik.msm'>Extract model log-likelihood</h2><span id='topic+logLik.msm'></span>

<h3>Description</h3>

<p>Extract the log-likelihood and the number of parameters of a model fitted
with <code><a href="#topic+msm">msm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msm'
logLik(object, by.subject = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.msm_+3A_object">object</code></td>
<td>
<p>A fitted multi-state model object, as returned by
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.msm_+3A_by.subject">by.subject</code></td>
<td>
<p>Return vector of subject-specific log-likelihoods, which
should sum to the total log-likelihood.</p>
</td></tr>
<tr><td><code id="logLik.msm_+3A_...">...</code></td>
<td>
<p>(unused) further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood of the model represented by 'object' evaluated at
the maximum likelihood estimates.
</p>
<p>Akaike's information criterion can also be computed using
<code><a href="stats.html#topic+AIC">AIC</a>(object)</code>.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>,<code><a href="#topic+lrtest.msm">lrtest.msm</a></code>.
</p>

<hr>
<h2 id='lrtest.msm'>Likelihood ratio test</h2><span id='topic+lrtest.msm'></span>

<h3>Description</h3>

<p>Likelihood ratio test between two or more fitted multi-state models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrtest.msm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrtest.msm_+3A_...">...</code></td>
<td>
<p>Two or more fitted multi-state models, as returned by
<code><a href="#topic+msm">msm</a></code>, ordered by increasing numbers of parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with three columns, giving the likelihood ratio statistic,
difference in degrees of freedom and the chi-squared p-value for a
comparison of the first model supplied with each subsequent model.
</p>


<h3>Warning</h3>

<p>The comparison between models will only be valid if they
are fitted to the same dataset. This may be a problem if there are missing
values and R's default of 'na.action = na.omit' is used.
</p>
<p>The likelihood ratio statistic only has the indicated chi-squared
distribution if the models are nested. An alternative for comparing
non-nested models is Akaike's information criterion.  This can be computed
for one or more fitted <code>msm</code> models <code>x,y,...</code> using
<code><a href="stats.html#topic+AIC">AIC</a>(x,y,...)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logLik.msm">logLik.msm</a></code>,<code><a href="#topic+msm">msm</a></code>
</p>

<hr>
<h2 id='MatrixExp'>Matrix exponential</h2><span id='topic+MatrixExp'></span>

<h3>Description</h3>

<p>Calculates the exponential of a square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixExp(mat, t = 1, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatrixExp_+3A_mat">mat</code></td>
<td>
<p>A square matrix</p>
</td></tr>
<tr><td><code id="MatrixExp_+3A_t">t</code></td>
<td>
<p>An optional scaling factor for <code>mat</code>.  If a vector is supplied,
then an array of matrices is returned with different scaling factors.</p>
</td></tr>
<tr><td><code id="MatrixExp_+3A_method">method</code></td>
<td>
<p>Under the default of <code>NULL</code>, this simply wraps the
<code><a href="expm.html#topic+expm">expm</a></code> function from the <span class="pkg">expm</span> package.  This is
recommended.  Options to <code><a href="expm.html#topic+expm">expm</a></code> can be supplied to
<code><a href="#topic+MatrixExp">MatrixExp</a></code>, including <code>method</code>.
</p>
<p>Otherwise, for backwards compatibility, the following options, which use
code in the <span class="pkg">msm</span> package, are available: <code>"pade"</code> for a Pade
approximation method, <code>"series"</code> for the power series approximation, or
<code>"analytic"</code> for the analytic formulae for simpler Markov model
intensity matrices (see below).  These options are only used if <code>mat</code>
has repeated eigenvalues, thus the usual eigen-decomposition method cannot
be used.</p>
</td></tr>
<tr><td><code id="MatrixExp_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="expm.html#topic+expm">expm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="expm.html#topic+expm">expm</a></code> documentation for details of the algorithms
it uses.
</p>
<p>Generally the exponential <code class="reqn">E</code> of a square matrix <code class="reqn">M</code> can often be
calculated as
</p>
<p style="text-align: center;"><code class="reqn">E = U \exp(D) U^{-1}</code>
</p>

<p>where <code class="reqn">D</code> is a diagonal matrix with the eigenvalues of <code class="reqn">M</code> on the
diagonal, <code class="reqn">\exp(D)</code> is a diagonal matrix with the exponentiated
eigenvalues of <code class="reqn">M</code> on the diagonal, and <code class="reqn">U</code> is a matrix whose
columns are the eigenvectors of <code class="reqn">M</code>.
</p>
<p>This method of calculation is used if <code>"pade"</code> or <code>"series"</code> is
supplied but <code class="reqn">M</code> has distinct eigenvalues.  I If <code class="reqn">M</code> has repeated
eigenvalues, then its eigenvector matrix may be non-invertible. In this
case, the matrix exponential is calculated using the Pade approximation
defined by Moler and van Loan (2003), or the less robust power series
approximation,
</p>
<p style="text-align: center;"><code class="reqn">\exp(M) = I + M + M^2/2 + M^3 / 3! + M^4 / 4! + ...</code>
</p>

<p>For a continuous-time homogeneous Markov process with transition intensity
matrix <code class="reqn">Q</code>, the probability of occupying state <code class="reqn">s</code> at time <code class="reqn">u +
t</code> conditional on occupying state <code class="reqn">r</code> at time <code class="reqn">u</code> is given by the
<code class="reqn">(r,s)</code> entry of the matrix <code class="reqn">\exp(tQ)</code>.
</p>
<p>If <code>mat</code> is a valid transition intensity matrix for a continuous-time
Markov model (i.e. diagonal entries non-positive, off-diagonal entries
non-negative, rows sum to zero), then for certain simpler model structures,
there are analytic formulae for the individual entries of the exponential of
<code>mat</code>.  These structures are listed in the PDF manual and the formulae
are coded in the <span class="pkg">msm</span> source file <code>src/analyticp.c</code>.  These
formulae are only used if <code>method="analytic"</code>.  This is more efficient,
but it is not the default in <code>MatrixExp</code> because the code is not robust
to extreme values.  However it is the default when calculating likelihoods
for models fitted by <code><a href="#topic+msm">msm</a></code>.
</p>
<p>The implementation of the Pade approximation used by <code>method="pade"</code>
was taken from JAGS by Martyn Plummer
(<a href="https://mcmc-jags.sourceforge.io">https://mcmc-jags.sourceforge.io</a>).
</p>


<h3>Value</h3>

<p>The exponentiated matrix <code class="reqn">\exp(mat)</code>. Or, if <code>t</code>
is a vector of length 2 or more, an array of exponentiated matrices.
</p>


<h3>References</h3>

<p>Cox, D. R. and Miller, H. D. <em>The theory of stochastic
processes</em>, Chapman and Hall, London (1965)
</p>
<p>Moler, C and van Loan, C (2003).  Nineteen dubious ways to compute the
exponential of a matrix, twenty-five years later.  <em>SIAM Review</em>
<b>45</b>, 3&ndash;49.
</p>

<hr>
<h2 id='medists'>Measurement error distributions</h2><span id='topic+medists'></span><span id='topic+dmenorm'></span><span id='topic+pmenorm'></span><span id='topic+qmenorm'></span><span id='topic+rmenorm'></span><span id='topic+dmeunif'></span><span id='topic+pmeunif'></span><span id='topic+qmeunif'></span><span id='topic+rmeunif'></span>

<h3>Description</h3>

<p>Truncated Normal and Uniform distributions, where the response is also
subject to a Normally distributed measurement error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmenorm(
  x,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  sderr = 0,
  meanerr = 0,
  log = FALSE
)

pmenorm(
  q,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  sderr = 0,
  meanerr = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

qmenorm(
  p,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  sderr = 0,
  meanerr = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

rmenorm(n, mean = 0, sd = 1, lower = -Inf, upper = Inf, sderr = 0, meanerr = 0)

dmeunif(x, lower = 0, upper = 1, sderr = 0, meanerr = 0, log = FALSE)

pmeunif(
  q,
  lower = 0,
  upper = 1,
  sderr = 0,
  meanerr = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

qmeunif(
  p,
  lower = 0,
  upper = 1,
  sderr = 0,
  meanerr = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

rmeunif(n, lower = 0, upper = 1, sderr = 0, meanerr = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medists_+3A_x">x</code>, <code id="medists_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="medists_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="medists_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="medists_+3A_lower">lower</code></td>
<td>
<p>lower truncation point.</p>
</td></tr>
<tr><td><code id="medists_+3A_upper">upper</code></td>
<td>
<p>upper truncation point.</p>
</td></tr>
<tr><td><code id="medists_+3A_sderr">sderr</code></td>
<td>
<p>Standard deviation of measurement error distribution.</p>
</td></tr>
<tr><td><code id="medists_+3A_meanerr">meanerr</code></td>
<td>
<p>Optional shift for the measurement error distribution.</p>
</td></tr>
<tr><td><code id="medists_+3A_log">log</code>, <code id="medists_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as
<code class="reqn">\log(p)</code>, or log density is returned.</p>
</td></tr>
<tr><td><code id="medists_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;=
x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="medists_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="medists_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normal distribution with measurement error has density
</p>
<p style="text-align: center;"><code class="reqn">
\frac{\Phi(u, \mu_2, \sigma_3) - \Phi(l, \mu_2, \sigma_3)}{\Phi(u, \mu_2, \sigma_3) -
\Phi(l, \mu_2, \sigma_3)} \phi(x, \mu_0 + \mu_\epsilon, \sigma_2)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\sigma_2^2 = \sigma_0^2 + \sigma_\epsilon^2,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_3 = \sigma_0 \sigma_\epsilon / \sigma_2,</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_2 = (x - \mu_\epsilon) \sigma_0^2 + \mu_0 \sigma_\epsilon^2,
</code>
</p>

<p><code class="reqn">\mu_0</code> is the mean of the original Normal distribution before
truncation, <br /> <code class="reqn">\sigma_0</code> is the corresponding standard deviation,
<br /> <code class="reqn">u</code> is the upper truncation point, <br /> <code class="reqn">l</code> is the lower
truncation point, <br /> <code class="reqn">\sigma_\epsilon</code> is the standard deviation
of the additional measurement error, <br /> <code class="reqn">\mu_\epsilon</code> is the
mean of the measurement error (usually 0). <br /> <code class="reqn">\phi(x)</code> is the
density of the corresponding normal distribution, and <br />
<code class="reqn">\Phi(x)</code> is the distribution function of the corresponding
normal distribution.
</p>
<p>The uniform distribution with measurement error has density
</p>
<p style="text-align: center;"><code class="reqn">(\Phi(x, \mu_\epsilon+l, \sigma_\epsilon) - \Phi(x, \mu_\epsilon+u,
\sigma_\epsilon)) </code>
</p>
<p style="text-align: center;"><code class="reqn"> / (u - l)</code>
</p>

<p>These are calculated from the original truncated Normal or Uniform density
functions <code class="reqn">f(. | \mu, \sigma, l, u)</code> as
</p>
<p style="text-align: center;"><code class="reqn"> \int f(y | \mu, \sigma, l, u) \phi(x, y + \mu_\epsilon, \sigma_\epsilon) dy </code>
</p>

<p>If <code>sderr</code> and <code>meanerr</code> are not specified they assume the default
values of 0, representing no measurement error variance, and no constant
shift in the measurement error, respectively.
</p>
<p>Therefore, for example with no other arguments, <code>dmenorm(x)</code>, is simply
equivalent to <code>dtnorm(x)</code>, which in turn is equivalent to
<code>dnorm(x)</code>.
</p>
<p>These distributions were used by Satten and Longini (1996) for CD4 cell
counts conditionally on hidden Markov states of HIV infection, and later by
Jackson and Sharples (2002) for FEV1 measurements conditionally on states of
chronic lung transplant rejection.
</p>
<p>These distribution functions are just provided for convenience, and are not
optimised for numerical accuracy or speed.  To fit a hidden Markov model
with these response distributions, use a <code><a href="#topic+hmmMETNorm">hmmMETNorm</a></code> or
<code><a href="#topic+hmmMEUnif">hmmMEUnif</a></code> constructor. See the <code><a href="#topic+hmm-dists">hmm-dists</a></code> help
page for further details.
</p>


<h3>Value</h3>

<p><code>dmenorm</code>, <code>dmeunif</code> give the density, <code>pmenorm</code>,
<code>pmeunif</code> give the distribution function, <code>qmenorm</code>,
<code>qmeunif</code> give the quantile function, and <code>rmenorm</code>,
<code>rmeunif</code> generate random deviates, for the Normal and Uniform versions
respectively.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Satten, G.A. and Longini, I.M.  Markov chains with measurement
error: estimating the 'true' course of a marker of the progression of human
immunodeficiency virus disease (with discussion) <em>Applied Statistics</em>
45(3): 275-309 (1996)
</p>
<p>Jackson, C.H. and Sharples, L.D. Hidden Markov models for the onset and
progression of bronchiolitis obliterans syndrome in lung transplant
recipients <em>Statistics in Medicine</em>, 21(1): 113&ndash;128 (2002).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="stats.html#topic+dunif">dunif</a></code>, <code><a href="#topic+dtnorm">dtnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## what does the distribution look like?
x &lt;- seq(50, 90, by=1)
plot(x, dnorm(x, 70, 10), type="l", ylim=c(0,0.06)) ## standard Normal
lines(x, dtnorm(x, 70, 10, 60, 80), type="l")       ## truncated Normal
## truncated Normal with small measurement error
lines(x, dmenorm(x, 70, 10, 60, 80, sderr=3), type="l")

</code></pre>

<hr>
<h2 id='model.frame.msm'>Extract original data from <code>msm</code> objects.</h2><span id='topic+model.frame.msm'></span><span id='topic+model.matrix.msm'></span>

<h3>Description</h3>

<p>Extract the data from a multi-state model fitted with <code>msm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msm'
model.frame(formula, agg = FALSE, ...)

## S3 method for class 'msm'
model.matrix(object, model = "intens", state = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.msm_+3A_formula">formula</code></td>
<td>
<p>A fitted multi-state model object, as returned by
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.msm_+3A_agg">agg</code></td>
<td>
<p>Return the model frame in the efficient aggregated form used to
calculate the likelihood internally for non-hidden Markov models.  This has
one row for each unique combination of from-state, to-state, time lag,
covariate value and observation type.  The variable named <code>"(nocc)"</code>
counts how many observations of that combination there are in the original
data.</p>
</td></tr>
<tr><td><code id="model.frame.msm_+3A_...">...</code></td>
<td>
<p>Further arguments (not used).</p>
</td></tr>
<tr><td><code id="model.frame.msm_+3A_object">object</code></td>
<td>
<p>A fitted multi-state model object, as returned by
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.msm_+3A_model">model</code></td>
<td>
<p><code>"intens"</code> to return the design matrix for covariates on
intensities, <code>"misc"</code> for misclassification probabilities, <code>"hmm"</code>
for a general hidden Markov model, and <code>"inits"</code> for initial state
probabilities in hidden Markov models.</p>
</td></tr>
<tr><td><code id="model.frame.msm_+3A_state">state</code></td>
<td>
<p>State corresponding to the required covariate design matrix in
a hidden Markov model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>model.frame</code> returns a data frame with all the original
variables used for the model fit, with any missing data removed (see
<code>na.action</code> in <code><a href="#topic+msm">msm</a></code>).  The state, time, subject,
<code>obstype</code> and <code>obstrue</code> variables are named <code>"(state)"</code>,
<code>"(time)"</code>, <code>"(subject)"</code>, <code>"(obstype)"</code> and
<code>"(obstrue)"</code> respectively (note the brackets).  A variable called
<code>"(obs)"</code> is the observation number from the original data before any
missing data were dropped.  The variable <code>"(pcomb)"</code> is used for
computing the likelihood for hidden Markov models, and identifies which
distinct time difference, <code>obstype</code> and covariate values (thus which
distinct interval transition probability matrix) each observation
corresponds to.
</p>
<p>The model frame object has some other useful attributes, including
<code>"usernames"</code> giving the user's original names for these variables
(used for model refitting, e.g. in bootstrapping or cross validation) and
<code>"covnames"</code> identifying which ones are covariates.
</p>
<p><code>model.matrix</code> returns a design matrix for a part of the model that
includes covariates.  The required part is indicated by the <code>"model"</code>
argument.
</p>
<p>For time-inhomogeneous models fitted with <code>"pci"</code>, these datasets will
have imputed observations at each time change point, indicated where the
variable <code>"(pci.imp)"</code> in the model frame is 1.  The model matrix for
intensities will have factor contrasts for the <code>timeperiod</code> covariate.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>

<hr>
<h2 id='msm'>Multi-state Markov and hidden Markov models in continuous time</h2><span id='topic+msm'></span>

<h3>Description</h3>

<p>Fit a continuous-time Markov or hidden Markov multi-state model by maximum
likelihood. Observations of the process can be made at arbitrary times, or
the exact times of transition between states can be known.  Covariates can
be fitted to the Markov chain transition intensities or to the hidden Markov
observation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msm(
  formula,
  subject = NULL,
  data = list(),
  qmatrix,
  gen.inits = FALSE,
  ematrix = NULL,
  hmodel = NULL,
  obstype = NULL,
  obstrue = NULL,
  covariates = NULL,
  covinits = NULL,
  constraint = NULL,
  misccovariates = NULL,
  misccovinits = NULL,
  miscconstraint = NULL,
  hcovariates = NULL,
  hcovinits = NULL,
  hconstraint = NULL,
  hranges = NULL,
  qconstraint = NULL,
  econstraint = NULL,
  initprobs = NULL,
  est.initprobs = FALSE,
  initcovariates = NULL,
  initcovinits = NULL,
  deathexact = NULL,
  death = NULL,
  exacttimes = FALSE,
  censor = NULL,
  censor.states = NULL,
  pci = NULL,
  phase.states = NULL,
  phase.inits = NULL,
  cl = 0.95,
  fixedpars = NULL,
  center = TRUE,
  opt.method = "optim",
  hessian = NULL,
  use.deriv = TRUE,
  use.expm = TRUE,
  analyticp = TRUE,
  na.action = na.omit,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msm_+3A_formula">formula</code></td>
<td>
<p>A formula giving the vectors containing the observed states
and the corresponding observation times. For example,
</p>
<p><code>state ~ time</code>
</p>
<p>Observed states should be numeric variables in the set <code>1, ...{}, n</code>,
where <code>n</code> is the number of states.  Factors are allowed only if their
levels are called <code>"1", ...{}, "n"</code>.
</p>
<p>The times can indicate different types of observation scheme, so be careful
to choose the correct <code>obstype</code>.
</p>
<p>For hidden Markov models, <code>state</code> refers to the outcome variable, which
need not be a discrete state.  It may also be a matrix, giving multiple
observations at each time (see <code><a href="#topic+hmmMV">hmmMV</a></code>).</p>
</td></tr>
<tr><td><code id="msm_+3A_subject">subject</code></td>
<td>
<p>Vector of subject identification numbers for the data
specified by <code>formula</code>. If missing, then all observations are assumed
to be on the same subject. These must be sorted so that all observations on
the same subject are adjacent.</p>
</td></tr>
<tr><td><code id="msm_+3A_data">data</code></td>
<td>
<p>Optional data frame in which to interpret the variables supplied
in <code>formula</code>, <code>subject</code>, <code>covariates</code>, <code>misccovariates</code>,
<code>hcovariates</code>, <code>obstype</code> and <code>obstrue</code>.</p>
</td></tr>
<tr><td><code id="msm_+3A_qmatrix">qmatrix</code></td>
<td>
<p>Matrix which indicates the allowed transitions in the
continuous-time Markov chain, and optionally also the initial values of
those transitions. If an instantaneous transition is not allowed from state
<code class="reqn">r</code> to state <code class="reqn">s</code>, then <code>qmatrix</code> should have <code class="reqn">(r,s)</code> entry
0, otherwise it should be non-zero.
</p>
<p>If supplying initial values yourself, then the non-zero entries should be
those values.  If using <code>gen.inits=TRUE</code> then the non-zero entries can
be anything you like (conventionally 1).  Any diagonal entry of
<code>qmatrix</code> is ignored, as it is constrained to be equal to minus the sum
of the rest of the row.
</p>
<p>For example,<br />
</p>
<p><code> rbind( c( 0, 0.1, 0.01 ), c( 0.1, 0, 0.2 ), c( 0, 0, 0 ) ) </code><br />
</p>
<p>represents a 'health - disease - death' model, with initial transition
intensities 0.1 from health to disease, 0.01 from health to death, 0.1 from
disease to health, and 0.2 from disease to death.
</p>
<p>If the states represent ordered levels of severity of a disease, then this
matrix should usually only allow transitions between adjacent states.  For
example, if someone was observed in state 1 (&quot;mild&quot;) at their first
observation, followed by state 3 (&quot;severe&quot;) at their second observation,
they are assumed to have passed through state 2 (&quot;moderate&quot;) in between, and
the 1,3 entry of <code>qmatrix</code> should be zero.
</p>
<p>The initial intensities given here are with any covariates set to their
means in the data (or set to zero, if <code>center = FALSE</code>). If any
intensities are constrained to be equal using <code>qconstraint</code>, then the
initial value is taken from the first of these (reading across rows).</p>
</td></tr>
<tr><td><code id="msm_+3A_gen.inits">gen.inits</code></td>
<td>
<p>If <code>TRUE</code>, then initial values for the transition
intensities are generated automatically using the method in
<code><a href="#topic+crudeinits.msm">crudeinits.msm</a></code>. The non-zero entries of the supplied
<code>qmatrix</code> are assumed to indicate the allowed transitions of the model.
This is not available for hidden Markov models, including models with
misclassified states.</p>
</td></tr>
<tr><td><code id="msm_+3A_ematrix">ematrix</code></td>
<td>
<p>If misclassification between states is to be modelled, this
should be a matrix of initial values for the misclassification
probabilities.  The rows represent underlying states, and the columns
represent observed states.  If an observation of state <code class="reqn">s</code> is not
possible when the subject occupies underlying state <code class="reqn">r</code>, then
<code>ematrix</code> should have <code class="reqn">(r,s)</code> entry 0.  Otherwise <code>ematrix</code>
should have <code class="reqn">(r,s)</code> entry corresponding to the probability of observing
<code class="reqn">s</code> conditionally on occupying true state <code class="reqn">r</code>. The diagonal of
<code>ematrix</code> is ignored, as rows are constrained to sum to 1.  For
example, <br />
</p>
<p><code> rbind( c( 0, 0.1, 0 ), c( 0.1, 0, 0.1 ), c( 0, 0.1, 0 ) ) </code><br />
</p>
<p>represents a model in which misclassifications are only permitted between
adjacent states.
</p>
<p>If any probabilities are constrained to be equal using <code>econstraint</code>,
then the initial value is taken from the first of these (reading across
rows).
</p>
<p>For an alternative way of specifying misclassification models, see
<code>hmodel</code>.</p>
</td></tr>
<tr><td><code id="msm_+3A_hmodel">hmodel</code></td>
<td>
<p>Specification of the hidden Markov model (HMM).  This should
be a list of return values from HMM constructor functions.  Each element of
the list corresponds to the outcome model conditionally on the corresponding
underlying state.  Univariate constructors are described in
the<code><a href="#topic+hmm-dists">hmm-dists</a></code> help page.  These may also be grouped together to
specify a multivariate HMM with a set of conditionally independent
univariate outcomes at each time, as described in <code><a href="#topic+hmmMV">hmmMV</a></code>.
</p>
<p>For example, consider a three-state hidden Markov model.  Suppose the
observations in underlying state 1 are generated from a Normal distribution
with mean 100 and standard deviation 16, while observations in underlying
state 2 are Normal with mean 54 and standard deviation 18. Observations in
state 3, representing death, are exactly observed, and coded as 999 in the
data.  This model is specified as
</p>
<p><code>hmodel = list(hmmNorm(mean=100, sd=16), hmmNorm(mean=54, sd=18),
hmmIdent(999))</code>
</p>
<p>The mean and standard deviation parameters are estimated starting from these
initial values. If multiple parameters are constrained to be equal using
<code>hconstraint</code>, then the initial value is taken from the value given on
the first occasion that parameter appears in <code>hmodel</code>.
</p>
<p>See the <code><a href="#topic+hmm-dists">hmm-dists</a></code> help page for details of the constructor
functions for each univariate distribution.
</p>
<p>A misclassification model, that is, a hidden Markov model where the outcomes
are misclassified observations of the underlying states, can either be
specified using a list of <code><a href="#topic+hmmCat">hmmCat</a></code> or <code><a href="#topic+hmmIdent">hmmIdent</a></code>
objects, or by using an <code>ematrix</code>.
</p>
<p>For example, <br />
</p>
<p><code> ematrix = rbind( c( 0, 0.1, 0, 0 ), c( 0.1, 0, 0.1, 0 ), c( 0, 0.1,
0, 0), c( 0, 0, 0, 0) ) </code><br />
</p>
<p>is equivalent to <br />
</p>
<p><code>hmodel = list( hmmCat(prob=c(0.9, 0.1, 0, 0)), hmmCat(prob=c(0.1, 0.8,
0.1, 0)), hmmCat(prob=c(0, 0.1, 0.9, 0)), hmmIdent()) </code><br /></p>
</td></tr>
<tr><td><code id="msm_+3A_obstype">obstype</code></td>
<td>
<p>A vector specifying the observation scheme for each row of
the data. This can be included in the data frame <code>data</code> along with the
state, time, subject IDs and covariates.  Its elements should be either 1, 2
or 3, meaning as follows:
</p>
 <dl>
<dt>1</dt><dd><p>An observation of the process at an arbitrary time (a
&quot;snapshot&quot; of the process, or &quot;panel-observed&quot; data). The states are unknown
between observation times.</p>
</dd> <dt>2</dt><dd><p>An exact transition time, with the
state at the previous observation retained until the current observation.
An observation may represent a transition to a different state or a repeated
observation of the same state (e.g. at the end of follow-up).  Note that if
all transition times are known, more flexible models could be fitted with
packages other than <span class="pkg">msm</span> - see the note under <code>exacttimes</code>.
</p>
<p>Note also that if the previous state was censored using <code>censor</code>, for
example known only to be state 1 or state 2, then <code>obstype</code> 2 means
that either state 1 is retained or state 2 is retained until the current
observation - this does not allow for a change of state in the middle of the
observation interval.  </p>
</dd> <dt>3</dt><dd><p>An exact transition time, but the state at
the instant before entering this state is unknown. A common example is death
times in studies of chronic diseases.</p>
</dd> </dl>
<p> If <code>obstype</code> is not specified,
this defaults to all 1. If <code>obstype</code> is a single number, all
observations are assumed to be of this type.  The obstype value for the
first observation from each subject is not used.
</p>
<p>This is a generalisation of the <code>deathexact</code> and <code>exacttimes</code>
arguments to allow different schemes per observation.  <code>obstype</code>
overrides both <code>deathexact</code> and <code>exacttimes</code>.
</p>
<p><code>exacttimes=TRUE</code> specifies that all observations are of obstype 2.
</p>
<p><code>deathexact = death.states</code> specifies that all observations of
<code>death.states</code> are of type 3.  <code>deathexact = TRUE</code> specifies that
all observations in the final absorbing state are of type 3.</p>
</td></tr>
<tr><td><code id="msm_+3A_obstrue">obstrue</code></td>
<td>
<p>In misclassification models specified with <code>ematrix</code>,
<code>obstrue</code> is a vector of logicals (<code>TRUE</code> or <code>FALSE</code>) or
numerics (1 or 0) specifying which observations (<code>TRUE</code>, 1) are
observations of the underlying state without error, and which (<code>FALSE</code>,
0) are realisations of a hidden Markov model.
</p>
<p>In HMMs specified with <code>hmodel</code>, where the hidden state is known at
some times, if <code>obstrue</code> is supplied it is assumed to contain the
actual true state data.  Elements of <code>obstrue</code> at times when the hidden
state is unknown are set to <code>NA</code>.  This allows the information from HMM
outcomes generated conditionally on the known state to be included in the
model, thus improving the estimation of the HMM outcome distributions.
</p>
<p>HMMs where the true state is known to be within a specific set at specific
times can be defined with a combination of <code>censor</code> and <code>obstrue</code>.
In these models, a code is defined for the <code>state</code> outcome (see
<code>censor</code>), and <code>obstrue</code> is set to 1 for observations where the
true state is known to be one of the elements of <code>censor.states</code> at the
corresponding time.</p>
</td></tr>
<tr><td><code id="msm_+3A_covariates">covariates</code></td>
<td>
<p>A formula or a list of formulae representing the
covariates on the transition intensities via a log-linear model. If a single
formula is supplied, like
</p>
<p><code>covariates = ~ age + sex + treatment</code>
</p>
<p>then these covariates are assumed to apply to all intensities.  If a named
list is supplied, then this defines a potentially different model for each
named intensity.  For example,
</p>
<p><code>covariates = list("1-2" = ~ age, "2-3" = ~ age + treatment)</code>
</p>
<p>specifies an age effect on the state 1 - state 2 transition, additive age
and treatment effects on the state 2 - state 3 transition, but no covariates
on any other transitions that are allowed by the <code>qmatrix</code>.
</p>
<p>If covariates are time dependent, they are assumed to be constant in between
the times they are observed, and the transition probability between a pair
of times <code class="reqn">(t1, t2)</code> is assumed to depend on the covariate value at
<code class="reqn">t1</code>.</p>
</td></tr>
<tr><td><code id="msm_+3A_covinits">covinits</code></td>
<td>
<p>Initial values for log-linear effects of covariates on the
transition intensities. This should be a named list with each element
corresponding to a covariate.  A single element contains the initial values
for that covariate on each transition intensity, reading across the rows in
order.  For a pair of effects constrained to be equal, the initial value for
the first of the two effects is used.
</p>
<p>For example, for a model with the above <code>qmatrix</code> and age and sex
covariates, the following initialises all covariate effects to zero apart
from the age effect on the 2-1 transition, and the sex effect on the 1-3
transition.  <code> covinits = list(sex=c(0, 0, 0.1, 0), age=c(0, 0.1, 0,
0))</code>
</p>
<p>For factor covariates, name each level by concatenating the name of the
covariate with the level name, quoting if necessary. For example, for a
covariate <code>agegroup</code> with three levels <code>0-15, 15-60, 60-</code>, use
something like
</p>
<p><code> covinits = list("agegroup15-60"=c(0, 0.1, 0, 0), "agegroup60-"=c(0.1,
0.1, 0, 0))</code>
</p>
<p>If not specified or wrongly specified, initial values are assumed to be
zero.</p>
</td></tr>
<tr><td><code id="msm_+3A_constraint">constraint</code></td>
<td>
<p>A list of one numeric vector for each named covariate. The
vector indicates which covariate effects on intensities are constrained to
be equal. Take, for example, a model with five transition intensities and
two covariates. Specifying<br />
</p>
<p><code>constraint = list (age = c(1,1,1,2,2), treatment = c(1,2,3,4,5))</code><br />
</p>
<p>constrains the effect of age to be equal for the first three intensities,
and equal for the fourth and fifth. The effect of treatment is assumed to be
different for each intensity. Any vector of increasing numbers can be used
as indicators. The intensity parameters are assumed to be ordered by reading
across the rows of the transition matrix, starting at the first row,
ignoring the diagonals.
</p>
<p>Negative elements of the vector can be used to indicate that particular
covariate effects are constrained to be equal to minus some other effects.
For example:
</p>
<p><code>constraint = list (age = c(-1,1,1,2,-2), treatment = c(1,2,3,4,5))
</code><br />
</p>
<p>constrains the second and third age effects to be equal, the first effect to
be minus the second, and the fifth age effect to be minus the fourth.  For
example, it may be realisitic that the effect of a covariate on the
&quot;reverse&quot; transition rate from state 2 to state 1 is minus the effect on the
&quot;forward&quot; transition rate, state 1 to state 2.  Note that it is not possible
to specify exactly which of the covariate effects are constrained to be
positive and which negative.  The maximum likelihood estimation chooses the
combination of signs which has the higher likelihood.
</p>
<p>For categorical covariates, defined as factors, specify constraints as
follows:<br />
</p>
<p><code>list(..., covnameVALUE1 = c(...), covnameVALUE2 = c(...), ...)</code><br />
</p>
<p>where <code>covname</code> is the name of the factor, and <code>VALUE1</code>,
<code>VALUE2</code>, ... are the labels of the factor levels (usually excluding
the baseline, if using the default contrasts).
</p>
<p>Make sure the <code>contrasts</code> option is set appropriately, for example, the
default
</p>
<p><code>options(contrasts=c(contr.treatment, contr.poly))</code>
</p>
<p>sets the first (baseline) level of unordered factors to zero, then the
baseline level is ignored in this specification.
</p>
<p>To assume no covariate effect on a certain transition, use the
<code>fixedpars</code> argument to fix it at its initial value (which is zero by
default) during the optimisation.</p>
</td></tr>
<tr><td><code id="msm_+3A_misccovariates">misccovariates</code></td>
<td>
<p>A formula representing the covariates on the
misclassification probabilities, analogously to <code>covariates</code>, via
multinomial logistic regression. Only used if the model is specified using
<code>ematrix</code>, rather than <code>hmodel</code>.
</p>
<p>This must be a single formula - lists are not supported, unlike
<code>covariates</code>.  If a different model on each probability is required,
include all covariates in this formula, and use <code>fixedpars</code> to fix some
of their effects (for particular probabilities) at their default initial
values of zero.</p>
</td></tr>
<tr><td><code id="msm_+3A_misccovinits">misccovinits</code></td>
<td>
<p>Initial values for the covariates on the
misclassification probabilities, defined in the same way as <code>covinits</code>.
Only used if the model is specified using <code>ematrix</code>.</p>
</td></tr>
<tr><td><code id="msm_+3A_miscconstraint">miscconstraint</code></td>
<td>
<p>A list of one vector for each named covariate on
misclassification probabilities. The vector indicates which covariate
effects on misclassification probabilities are constrained to be equal,
analogously to <code>constraint</code>.  Only used if the model is specified using
<code>ematrix</code>.</p>
</td></tr>
<tr><td><code id="msm_+3A_hcovariates">hcovariates</code></td>
<td>
<p>List of formulae the same length as <code>hmodel</code>,
defining any covariates governing the hidden Markov outcome models.  The
covariates operate on a suitably link-transformed linear scale, for example,
log scale for a Poisson outcome model. If there are no covariates for a
certain hidden state, then insert a NULL in the corresponding place in the
list.  For example, <code>hcovariates = list(~acute + age, ~acute, NULL).</code></p>
</td></tr>
<tr><td><code id="msm_+3A_hcovinits">hcovinits</code></td>
<td>
<p>Initial values for the hidden Markov model covariate
effects. A list of the same length as <code>hcovariates</code>. Each element is a
vector with initial values for the effect of each covariate on that state.
For example, the above <code>hcovariates</code> can be initialised with
<code>hcovariates = list(c(-8, 0), -8, NULL)</code>. Initial values must be given
for all or no covariates, if none are given these are all set to zero.  The
initial value given in the <code>hmodel</code> constructor function for the
corresponding baseline parameter is interpreted as the value of that
parameter with any covariates fixed to their means in the data.  If multiple
effects are constrained to be equal using <code>hconstraint</code>, then the
initial value is taken from the first of the multiple initial values
supplied.</p>
</td></tr>
<tr><td><code id="msm_+3A_hconstraint">hconstraint</code></td>
<td>
<p>A named list. Each element is a vector of constraints on
the named hidden Markov model parameter. The vector has length equal to the
number of times that class of parameter appears in the whole model.
</p>
<p>For example consider the three-state hidden Markov model described above,
with normally-distributed outcomes for states 1 and 2.  To constrain the
outcome variance to be equal for states 1 and 2, and to also constrain the
effect of <code>acute</code> on the outcome mean to be equal for states 1 and 2,
specify
</p>
<p><code>hconstraint = list(sd = c(1,1), acute=c(1,1))</code>
</p>
<p>Note this excludes initial state occupancy probabilities and covariate
effects on those probabilities, which cannot be constrained.</p>
</td></tr>
<tr><td><code id="msm_+3A_hranges">hranges</code></td>
<td>
<p>Range constraints for hidden Markov model parameters.
Supplied as a named list, with each element corresponding to the named
hidden Markov model parameter.  This element is itself a list with two
elements, vectors named &quot;lower&quot; and &quot;upper&quot;.  These vectors each have length
equal to the number of times that class of parameter appears in the whole
model, and give the corresponding mininum amd maximum allowable values for
that parameter.  Maximum likelihood estimation is performed with these
parameters constrained in these ranges (through a log or logit-type
transformation).  Lower bounds of <code>-Inf</code> and upper bounds of <code>Inf</code>
can be given if the parameter is unbounded above or below.
</p>
<p>For example, in the three-state model above, to constrain the mean for state
1 to be between 0 and 6, and the mean of state 2 to be between 7 and 12,
supply
</p>
<p><code>hranges=list(mean=list(lower=c(0, 7), upper=c(6, 12)))</code>
</p>
<p>These default to the natural ranges, e.g. the positive real line for
variance parameters, and [0,1] for probabilities.  Therefore <code>hranges</code>
need not be specified for such parameters unless an even stricter constraint
is desired.  If only one limit is supplied for a parameter, only the first
occurrence of that parameter is constrained.
</p>
<p>Initial values should be strictly within any ranges, and not on the range
boundary, otherwise optimisation will fail with a &quot;non-finite value&quot; error.</p>
</td></tr>
<tr><td><code id="msm_+3A_qconstraint">qconstraint</code></td>
<td>
<p>A vector of indicators specifying which baseline
transition intensities are equal. For example,
</p>
<p><code>qconstraint = c(1,2,3,3)</code>
</p>
<p>constrains the third and fourth intensities to be equal, in a model with
four allowed instantaneous transitions.  When there are covariates on the
intensities and <code>center=TRUE</code> (the default), <code>qconstraint</code> is
applied to the intensities with covariates taking the values of the means in
the data.  When <code>center=FALSE</code>, <code>qconstraint</code> is applied to the
intensities with covariates set to zero.</p>
</td></tr>
<tr><td><code id="msm_+3A_econstraint">econstraint</code></td>
<td>
<p>A similar vector of indicators specifying which baseline
misclassification probabilities are constrained to be equal.  Only used if
the model is specified using <code>ematrix</code>, rather than <code>hmodel</code>.</p>
</td></tr>
<tr><td><code id="msm_+3A_initprobs">initprobs</code></td>
<td>
<p>Only used in hidden Markov models.  Underlying state
occupancy probabilities at each subject's first observation.  Can either be
a vector of <code class="reqn">nstates</code> elements with common probabilities to all
subjects, or a <code class="reqn">nsubjects</code> by <code class="reqn">nstates</code> matrix of subject-specific
probabilities.  This refers to observations after missing data and subjects
with only one observation have been excluded.
</p>
<p>If these are estimated (see <code>est.initprobs</code>), then this represents an
initial value, and defaults to equal probability for each state.  Otherwise
this defaults to <code>c(1, rep(0, nstates-1))</code>, that is, in state 1 with a
probability of 1.  Scaled to sum to 1 if necessary.  The state 1 occupancy
probability should be non-zero.</p>
</td></tr>
<tr><td><code id="msm_+3A_est.initprobs">est.initprobs</code></td>
<td>
<p>Only used in hidden Markov models.  If <code>TRUE</code>,
then the underlying state occupancy probabilities at the first observation
will be estimated, starting from a vector of initial values supplied in the
<code>initprobs</code> argument.  Structural zeroes are allowed: if any of these
initial values are zero they will be fixed at zero during optimisation, even
if <code>est.initprobs=TRUE</code>, and no covariate effects on them are
estimated.  The exception is state 1, which should have non-zero occupancy
probability.
</p>
<p>Note that the free parameters during this estimation exclude the state 1
occupancy probability, which is fixed at one minus the sum of the other
probabilities.</p>
</td></tr>
<tr><td><code id="msm_+3A_initcovariates">initcovariates</code></td>
<td>
<p>Formula representing covariates on the initial state
occupancy probabilities, via multinomial logistic regression.  The linear
effects of these covariates, observed at the individual's first observation
time, operate on the log ratio of the state <code class="reqn">r</code> occupancy probability to
the state 1 occupancy probability, for each <code class="reqn">r = 2</code> to the number of
states.  Thus the state 1 occupancy probability should be non-zero. If
<code>est.initprobs</code> is <code>TRUE</code>, these effects are estimated starting
from their initial values.  If <code>est.initprobs</code> is <code>FALSE</code>, these
effects are fixed at theit initial values.</p>
</td></tr>
<tr><td><code id="msm_+3A_initcovinits">initcovinits</code></td>
<td>
<p>Initial values for the covariate effects
<code>initcovariates</code>.  A named list with each element corresponding to a
covariate, as in <code>covinits</code>. Each element is a vector with (1 - number
of states) elements, containing the initial values for the linear effect of
that covariate on the log odds of that state relative to state 1, from state
2 to the final state.  If <code>initcovinits</code> is not specified, all
covariate effects are initialised to zero.</p>
</td></tr>
<tr><td><code id="msm_+3A_deathexact">deathexact</code></td>
<td>
<p>Vector of indices of absorbing states whose time of entry
is known exactly, but the individual is assumed to be in an unknown
transient state (&quot;alive&quot;) at the previous instant.  This is the usual
situation for times of death in chronic disease monitoring data.  For
example, if you specify <code>deathexact = c(4, 5)</code> then states 4 and 5 are
assumed to be exactly-observed death states.
</p>
<p>See the <code>obstype</code> argument.  States of this kind correspond to
<code>obstype=3</code>. <code>deathexact = TRUE</code> indicates that the final
absorbing state is of this kind, and <code>deathexact = FALSE</code> or
<code>deathexact = NULL</code> (the default) indicates that there is no state of
this kind.
</p>
<p>The <code>deathexact</code> argument is overridden by <code>obstype</code> or
<code>exacttimes</code>.
</p>
<p>Note that you do not always supply a <code>deathexact</code> argument, even if
there are states that correspond to deaths, because they do not necessarily
have <code>obstype=3</code>.  If the state is known between the time of death and
the previous observation, then you should specify <code>obstype=2</code> for the
death times, or <code>exacttimes=TRUE</code> if the state is known at all times,
and the <code>deathexact</code> argument is ignored.</p>
</td></tr>
<tr><td><code id="msm_+3A_death">death</code></td>
<td>
<p>Old name for the <code>deathexact</code> argument.  Overridden by
<code>deathexact</code> if both are supplied. Deprecated.</p>
</td></tr>
<tr><td><code id="msm_+3A_exacttimes">exacttimes</code></td>
<td>
<p>By default, the transitions of the Markov process are
assumed to take place at unknown occasions in between the observation times.
If <code>exacttimes</code> is set to <code>TRUE</code>, then the observation times are
assumed to represent the exact times of transition of the process.  The
subject is assumed to be in the same state between these times.  An
observation may represent a transition to a different state or a repeated
observation of the same state (e.g. at the end of follow-up).  This is
equivalent to every row of the data having <code>obstype = 2</code>.  See the
<code>obstype</code> argument.  If both <code>obstype</code> and <code>exacttimes</code> are
specified then <code>exacttimes</code> is ignored.
</p>
<p>Note that the complete history of the multi-state process is known with this
type of data.  The models which <span class="pkg">msm</span> fits have the strong assumption of
constant (or piecewise-constant) transition rates.  Knowing the exact
transition times allows more realistic models to be fitted with other
packages.  For example parametric models with sojourn distributions more
flexible than the exponential can be fitted with the <span class="pkg">flexsurv</span> package,
or semi-parametric models can be implemented with <span class="pkg">survival</span> in
conjunction with <span class="pkg">mstate</span>.</p>
</td></tr>
<tr><td><code id="msm_+3A_censor">censor</code></td>
<td>
<p>A state, or vector of states, which indicates censoring.
Censoring means that the observed state is known only to be one of a
particular set of states. For example, <code>censor=999</code> indicates that all
observations of <code>999</code> in the vector of observed states are censored
states.  By default, this means that the true state could have been any of
the transient (non-absorbing) states. To specify corresponding true states
explicitly, use a <code>censor.states</code> argument.
</p>
<p>Note that in contrast to the usual terminology of survival analysis, here it
is the <em>state</em> which is considered to be censored, rather than the
<em>event time</em>.  If at the end of a study, an individual has not died,
but their true state is <em>known</em>, then <code>censor</code> is unnecessary,
since the standard multi-state model likelihood is applicable.  Also a
&quot;censored&quot; state here can be at any time, not just at the end.
</p>
<p>For hidden Markov models, censoring may indicate either a set of possible
observed states, or a set of (hidden) true states. The later case is
specified by setting the relevant elements of <code>obstrue</code> to 1 (and
<code>NA</code> otherwise).
</p>
<p>Note in particular that general time-inhomogeneous Markov models with
piecewise constant transition intensities can be constructed using the
<code>censor</code> facility. If the true state is unknown on occasions when a
piecewise constant covariate is known to change, then censored states can be
inserted in the data on those occasions.  The covariate may represent time
itself, in which case the <code>pci</code> option to msm can be used to perform
this trick automatically, or some other time-dependent variable.
</p>
<p>Not supported for multivariate hidden Markov models specified with
<code><a href="#topic+hmmMV">hmmMV</a></code>.</p>
</td></tr>
<tr><td><code id="msm_+3A_censor.states">censor.states</code></td>
<td>
<p>Specifies the underlying states which censored
observations can represent. If <code>censor</code> is a single number (the
default) this can be a vector, or a list with one element.  If <code>censor</code>
is a vector with more than one element, this should be a list, with each
element a vector corresponding to the equivalent element of <code>censor</code>.
For example
</p>
<p><code>censor = c(99, 999), censor.states = list(c(2,3), c(3,4))</code>
</p>
<p>means that observations coded 99 represent either state 2 or state 3, while
observations coded 999 are really either state 3 or state 4.</p>
</td></tr>
<tr><td><code id="msm_+3A_pci">pci</code></td>
<td>
<p>Model for piecewise-constant intensities.  Vector of cut points
defining the times, since the start of the process, at which intensities
change for all subjects.  For example
</p>
<p><code>pci = c(5, 10)</code>
</p>
<p>specifies that the intensity changes at time points 5 and 10.  This will
automatically construct a model with a categorical (factor) covariate called
<code>timeperiod</code>, with levels <code>"[-Inf,5)"</code>, <code>"[5,10)"</code> and
<code>"[10,Inf)"</code>, where the first level is the baseline.  This covariate
defines the time period in which the observation was made.  Initial values
and constraints on covariate effects are specified the same way as for a
model with a covariate of this name, for example,
</p>
<p><code>covinits = list("timeperiod[5,10)"=c(0.1,0.1),
"timeperiod[10,Inf)"=c(0.1,0.1))</code>
</p>
<p>Thus if <code>pci</code> is supplied, you cannot have a previously-existing
variable called <code>timeperiod</code> as a covariate in any part of a <code>msm</code>
model.
</p>
<p>To assume piecewise constant intensities for some transitions but not others
with <code>pci</code>, use the <code>fixedpars</code> argument to fix the appropriate
covariate effects at their default initial values of zero.
</p>
<p>Internally, this works by inserting censored observations in the data at
times when the intensity changes but the state is not observed.
</p>
<p>If the supplied times are outside the range of the time variable in the
data, <code>pci</code> is ignored and a time-homogeneous model is fitted.
</p>
<p>After fitting a time-inhomogeneous model, <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code> can be
used to obtain the fitted intensity matrices for each time period, for
example,
</p>
<p><code>qmatrix.msm(example.msm, covariates=list(timeperiod="[5,Inf)"))</code>
</p>
<p>This facility does not support interactions between time and other
covariates.  Such models need to be specified &quot;by hand&quot;, using a state
variable with censored observations inserted.  Note that the <code>data</code>
component of the <code>msm</code> object returned from a call to <code>msm</code> with
<code>pci</code> supplied contains the states with inserted censored observations
and time period indicators.  These can be used to construct such models.
</p>
<p>Note that you do not need to use <code>pci</code> in order to model the effect of
a time-dependent covariate in the data.  <code>msm</code> will automatically
assume that covariates are piecewise-constant and change at the times when
they are observed.  <code>pci</code> is for when you want all intensities to
change at the same pre-specified times for all subjects.
</p>
<p><code>pci</code> is not supported for multivariate hidden Markov models specified with
<code><a href="#topic+hmmMV">hmmMV</a></code>.   An approximate equivalent can be constructed by
creating a variable in the data to represent the time period, and treating
that as a covariate using the <code>covariates</code> argument to <code>msm</code>.
This will assume that the value of this variable is constant between
observations.</p>
</td></tr>
<tr><td><code id="msm_+3A_phase.states">phase.states</code></td>
<td>
<p>Indices of states which have a two-phase sojourn
distribution.  This defines a semi-Markov model, in which the hazard of an
onward transition depends on the time spent in the state.
</p>
<p>This uses the technique described by Titman and Sharples (2009).  A hidden
Markov model is automatically constructed on an expanded state space, where
the phases correspond to the hidden states.  The &quot;tau&quot; proportionality
constraint described in this paper is currently not supported.
</p>
<p>Covariates, constraints, <code>deathexact</code> and <code>censor</code> are expressed
with respect to the expanded state space.  If not supplied by hand,
<code>initprobs</code> is defined automatically so that subjects are assumed to
begin in the first of the two phases.
</p>
<p>Hidden Markov models can additionally be given phased states.  The user
supplies an outcome distribution for each original state using
<code>hmodel</code>, which is expanded internally so that it is assumed to be the
same within each of the phased states.  <code>initprobs</code> is interpreted on
the expanded state space.  Misclassification models defined using
<code>ematrix</code> are not supported, and these must be defined using
<code>hmmCat</code> or <code>hmmIdent</code> constructors, as described in the
<code>hmodel</code> section of this help page.  Or the HMM on the expanded state
space can be defined by hand.
</p>
<p>Output functions are presented as it were a hidden Markov model on the
expanded state space, for example, transition probabilities between states,
covariate effects on transition rates, or prevalence counts, are not
aggregated over the hidden phases.
</p>
<p>Numerical estimation will be unstable when there is weak evidence for a
two-phase sojourn distribution, that is, if the model is close to Markov.
</p>
<p>See <code><a href="#topic+d2phase">d2phase</a></code> for the definition of the two-phase distribution
and the interpretation of its parameters.
</p>
<p>This is an experimental feature, and some functions are not implemented.
Please report any experiences of using this feature to the author!</p>
</td></tr>
<tr><td><code id="msm_+3A_phase.inits">phase.inits</code></td>
<td>
<p>Initial values for phase-type models.  A list with one
component for each &quot;two-phased&quot; state.  Each component is itself a list of
two elements.  The first of these elements is a scalar defining the
transition intensity from phase 1 to phase 2.  The second element is a
matrix, with one row for each potential destination state from the
two-phased state, and two columns.  The first column is the transition rate
from phase 1 to the destination state, and the second column is the
transition rate from phase 2 to the destination state.  If there is only one
destination state, then this may be supplied as a vector.
</p>
<p>In phase type models, the initial values for transition rates out of
non-phased states are taken from the <code>qmatrix</code> supplied to msm, and
entries of this matrix corresponding to transitions out of phased states are
ignored.</p>
</td></tr>
<tr><td><code id="msm_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals for maximum likelihood
estimates, by default 0.95.</p>
</td></tr>
<tr><td><code id="msm_+3A_fixedpars">fixedpars</code></td>
<td>
<p>Vector of indices of parameters whose values will be fixed
at their initial values during the optimisation. These are given in the
order: transition intensities (reading across rows of the transition
matrix), covariates on intensities (ordered by intensities within
covariates), hidden Markov model parameters, including misclassification
probabilities or parameters of HMM outcome distributions (ordered by
parameters within states), hidden Markov model covariate parameters (ordered
by covariates within parameters within states), initial state occupancy
probabilities (excluding the first probability, which is fixed at one minus
the sum of the others).
</p>
<p>If there are equality constraints on certain parameters, then
<code>fixedpars</code> indexes the set of unique parameters, excluding those which
are constrained to be equal to previous parameters.
</p>
<p>To fix all parameters, specify <code>fixedpars = TRUE</code>.
</p>
<p>This can be useful for profiling likelihoods, and building complex models
stage by stage.</p>
</td></tr>
<tr><td><code id="msm_+3A_center">center</code></td>
<td>
<p>If <code>TRUE</code> (the default, unless <code>fixedpars=TRUE</code>)
then covariates are centered at their means during the maximum likelihood
estimation. This usually improves stability of the numerical optimisation.</p>
</td></tr>
<tr><td><code id="msm_+3A_opt.method">opt.method</code></td>
<td>
<p>If &quot;optim&quot;, &quot;nlm&quot; or &quot;bobyqa&quot;, then the corresponding R
function will be used for maximum likelihood estimation.
<code><a href="stats.html#topic+optim">optim</a></code> is the default.  &quot;bobyqa&quot; requires the package
<span class="pkg">minqa</span> to be installed.  See the help of these functions for further
details.  Advanced users can also add their own optimisation methods, see
the source for <code>optim.R</code> in msm for some examples.
</p>
<p>If &quot;fisher&quot;, then a specialised Fisher scoring method is used (Kalbfleisch
and Lawless, 1985) which can be faster than the generic methods, though less
robust.  This is only available for Markov models with panel data
(<code>obstype=1</code>), that is, not for models with censored states, hidden
Markov models, exact observation or exact death times (<code>obstype=2,3</code>).</p>
</td></tr>
<tr><td><code id="msm_+3A_hessian">hessian</code></td>
<td>
<p>If <code>TRUE</code> then standard errors and confidence intervals
are obtained from a numerical estimate of the Hessian (the observed
information matrix).  This is the default when maximum likelihood estimation
is performed.  If all parameters are fixed at their initial values and no
optimisation is performed, then this defaults to <code>FALSE</code>.  If
requested, the actual Hessian is returned in <code>x$paramdata$opt$hessian</code>,
where <code>x</code> is the fitted model object.
</p>
<p>If <code>hessian</code> is set to <code>FALSE</code>, then standard errors and
confidence intervals are obtained from the Fisher (expected) information
matrix, if this is available.  This may be preferable if the numerical
estimation of the Hessian is computationally intensive, or if the resulting
estimate is non-invertible or not positive definite.</p>
</td></tr>
<tr><td><code id="msm_+3A_use.deriv">use.deriv</code></td>
<td>
<p>If <code>TRUE</code> then analytic first derivatives are used in
the optimisation of the likelihood, where available and an appropriate
quasi-Newton optimisation method, such as BFGS, is being used.  Analytic
derivatives are not available for all models.</p>
</td></tr>
<tr><td><code id="msm_+3A_use.expm">use.expm</code></td>
<td>
<p>If <code>TRUE</code> then any matrix exponentiation needed to
calculate the likelihood is done using the <span class="pkg">expm</span> package.  Otherwise
the original routines used in <span class="pkg">msm</span> 1.2.4 and earlier are used.  Set to
<code>FALSE</code> for backward compatibility, and let the package maintainer know
if this gives any substantive differences.</p>
</td></tr>
<tr><td><code id="msm_+3A_analyticp">analyticp</code></td>
<td>
<p>By default, the likelihood for certain simpler 3, 4 and 5
state models is calculated using an analytic expression for the transition
probability (P) matrix. For all other models, matrix exponentiation is used
to obtain P. To revert to the original method of using the matrix
exponential for all models, specify <code>analyticp=FALSE</code>. See the PDF
manual for a list of the models for which analytic P matrices are
implemented.</p>
</td></tr>
<tr><td><code id="msm_+3A_na.action">na.action</code></td>
<td>
<p>What to do with missing data: either <code>na.omit</code> to drop
it and carry on, or <code>na.fail</code> to stop with an error.  Missing data
includes all NAs in the states, times, <code>subject</code> or <code>obstrue</code>, all
NAs at the first observation for a subject for covariates in
<code>initcovariates</code>, all NAs in other covariates (excluding the last
observation for a subject), all NAs in <code>obstype</code> (excluding the first
observation for a subject), and any subjects with only one observation (thus
no observed transitions).</p>
</td></tr>
<tr><td><code id="msm_+3A_...">...</code></td>
<td>
<p>Optional arguments to the general-purpose optimisation routine,
<code><a href="stats.html#topic+optim">optim</a></code> by default. For example <code>method="Nelder-Mead"</code> to
change the optimisation algorithm from the <code>"BFGS"</code> method that msm
calls by default.
</p>
<p>It is often worthwhile to normalize the optimisation using
<code>control=list(fnscale = a)</code>, where <code>a</code> is the a number of the
order of magnitude of the -2 log likelihood.
</p>
<p>If 'false' convergence is reported and the standard errors cannot be
calculated due to a non-positive-definite Hessian, then consider tightening
the tolerance criteria for convergence. If the optimisation takes a long
time, intermediate steps can be printed using the <code>trace</code> argument of
the control list. See <code><a href="stats.html#topic+optim">optim</a></code> for details.
</p>
<p>For the Fisher scoring method, a <code>control</code> list can be supplied in the
same way, but the only supported options are <code>reltol</code>, <code>trace</code> and
<code>damp</code>.  The first two are used in the same way as for
<code><a href="stats.html#topic+optim">optim</a></code>.  If the algorithm fails with a singular information
matrix, adjust <code>damp</code> from the default of zero (to, e.g. 1).  This adds
a constant identity matrix multiplied by <code>damp</code> to the information
matrix during optimisation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For full details about the methodology behind the <span class="pkg">msm</span> package, refer
to the PDF manual &lsquo;<span class="file">msm-manual.pdf</span>&rsquo; in the &lsquo;<span class="file">doc</span>&rsquo; subdirectory of
the package. This includes a tutorial in the typical use of <span class="pkg">msm</span>.  The
paper by Jackson (2011) in Journal of Statistical Software presents the
material in this manual in a more concise form.
</p>
<p><span class="pkg">msm</span> was designed for fitting <em>continuous-time</em> Markov models,
processes where transitions can occur at any time.  These models are defined
by <em>intensities</em>, which govern both the time spent in the current state
and the probabilities of the next state.  In <em>discrete-time models</em>,
transitions are known in advance to only occur at multiples of some time
unit, and the model is purely governed by the probability distributions of
the state at the next time point, conditionally on the state at the current
time. These can also be fitted in <span class="pkg">msm</span>, assuming that there is a
continuous-time process underlying the data.  Then the fitted transition
probability matrix over one time period, as returned by
<code>pmatrix.msm(...,t=1)</code> is equivalent to the matrix that governs the
discrete-time model. However, these can be fitted more efficiently using
multinomial logistic regression, for example, using <code>multinom</code> from the
R package <span class="pkg">nnet</span> (Venables and Ripley, 2002).
</p>
<p>For simple continuous-time multi-state Markov models, the likelihood is
calculated in terms of the transition intensity matrix <code class="reqn">Q</code>. When the
data consist of observations of the Markov process at arbitrary times, the
exact transition times are not known.  Then the likelihood is calculated
using the transition probability matrix <code class="reqn">P(t) = \exp(tQ)</code>, where <code class="reqn">\exp</code> is the matrix exponential.  If state <code class="reqn">i</code>
is observed at time <code class="reqn">t</code> and state <code class="reqn">j</code> is observed at time <code class="reqn">u</code>,
then the contribution to the likelihood from this pair of observations is
the <code class="reqn">i,j</code> element of <code class="reqn">P(u - t)</code>. See, for example, Kalbfleisch and
Lawless (1985), Kay (1986), or Gentleman <em>et al.</em> (1994).
</p>
<p>For hidden Markov models, the likelihood for an individual with <code class="reqn">k</code>
observations is calculated directly by summing over the unknown state at
each time, producing a product of <code class="reqn">k</code> matrices. The calculation is a
generalisation of the method described by Satten and Longini (1996), and
also by Jackson and Sharples (2002), and Jackson <em>et al.</em> (2003).
</p>
<p>There must be enough information in the data on each state to estimate each
transition rate, otherwise the likelihood will be flat and the maximum will
not be found.  It may be appropriate to reduce the number of states in the
model, the number of allowed transitions, or the number of covariate
effects, to ensure convergence.  Hidden Markov models, and situations where
the value of the process is only known at a series of snapshots, are
particularly susceptible to non-identifiability, especially when combined
with a complex transition matrix.  Choosing an appropriate set of initial
values for the optimisation can also be important.  For flat likelihoods,
'informative' initial values will often be required.  See the PDF manual for
other tips.
</p>


<h3>Value</h3>

<p>To obtain summary information from models fitted by the
<code><a href="#topic+msm">msm</a></code> function, it is recommended to use extractor functions
such as <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>, <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>,
<code><a href="#topic+sojourn.msm">sojourn.msm</a></code>, <code><a href="#topic+msm.form.qoutput">msm.form.qoutput</a></code>.  These provide
estimates and confidence intervals for quantities such as transition
probabilities for given covariate values.
</p>
<p>For advanced use, it may be necessary to directly use information stored in
the object returned by <code><a href="#topic+msm">msm</a></code>.  This is documented in the help
page <code><a href="#topic+msm.object">msm.object</a></code>.
</p>
<p>Printing a <code>msm</code> object by typing the object's name at the command line
implicitly invokes <code><a href="#topic+print.msm">print.msm</a></code>.  This formats and prints the
important information in the model fit, and also returns that information in
an R object.  This includes estimates and confidence intervals for the
transition intensities and (log) hazard ratios for the corresponding
covariates. When there is a hidden Markov model, the chief information in
the <code>hmodel</code> component is also formatted and printed. This includes
estimates and confidence intervals for each parameter.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Jackson, C.H. (2011). Multi-State Models for Panel Data: The msm
Package for R., Journal of Statistical Software, 38(8), 1-29. URL
http://www.jstatsoft.org/v38/i08/.
</p>
<p>Kalbfleisch, J., Lawless, J.F., The analysis of panel data under a Markov
assumption <em>Journal of the Americal Statistical Association</em> (1985)
80(392): 863&ndash;871.
</p>
<p>Kay, R.  A Markov model for analysing cancer markers and disease states in
survival studies.  <em>Biometrics</em> (1986) 42: 855&ndash;865.
</p>
<p>Gentleman, R.C., Lawless, J.F., Lindsey, J.C. and Yan, P.  Multi-state
Markov models for analysing incomplete disease history data with
illustrations for HIV disease.  <em>Statistics in Medicine</em> (1994) 13(3):
805&ndash;821.
</p>
<p>Satten, G.A. and Longini, I.M.  Markov chains with measurement error:
estimating the 'true' course of a marker of the progression of human
immunodeficiency virus disease (with discussion) <em>Applied Statistics</em>
45(3): 275-309 (1996)
</p>
<p>Jackson, C.H. and Sharples, L.D. Hidden Markov models for the onset and
progression of bronchiolitis obliterans syndrome in lung transplant
recipients <em>Statistics in Medicine</em>, 21(1): 113&ndash;128 (2002).
</p>
<p>Jackson, C.H., Sharples, L.D., Thompson, S.G. and Duffy, S.W. and Couto, E.
Multi-state Markov models for disease progression with classification error.
<em>The Statistician</em>, 52(2): 193&ndash;209 (2003)
</p>
<p>Titman, A.C. and Sharples, L.D.  Semi-Markov models with phase-type sojourn
distributions.  <em>Biometrics</em> 66, 742-752 (2009).
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) <em>Modern Applied Statistics with
S</em>, second edition. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simmulti.msm">simmulti.msm</a></code>, <code><a href="#topic+plot.msm">plot.msm</a></code>,
<code><a href="#topic+summary.msm">summary.msm</a></code>, <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>,
<code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>, <code><a href="#topic+sojourn.msm">sojourn.msm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Heart transplant data
### For further details and background to this example, see
### Jackson (2011) or the PDF manual in the doc directory.
print(cav[1:10,])
twoway4.q &lt;- rbind(c(-0.5, 0.25, 0, 0.25), c(0.166, -0.498, 0.166, 0.166),
c(0, 0.25, -0.5, 0.25), c(0, 0, 0, 0))
statetable.msm(state, PTNUM, data=cav)
crudeinits.msm(state ~ years, PTNUM, data=cav, qmatrix=twoway4.q)
cav.msm &lt;- msm( state ~ years, subject=PTNUM, data = cav,
                 qmatrix = twoway4.q, deathexact = 4, 
                 control = list ( trace = 2, REPORT = 1 )  )
cav.msm
qmatrix.msm(cav.msm)
pmatrix.msm(cav.msm, t=10)
sojourn.msm(cav.msm)

</code></pre>

<hr>
<h2 id='msm.form.qoutput'>Extract msm model parameter estimates in compact format</h2><span id='topic+msm.form.qoutput'></span><span id='topic+msm.form.eoutput'></span>

<h3>Description</h3>

<p>Extract estimates and confidence intervals for transition intensities (or
misclassification probabilities), and their covariate effects, in a tidy
matrix format with one row per transition.  This is used by the print method
(<code><a href="#topic+print.msm">print.msm</a></code>) for <code>msm</code> objects.  Covariate effects are
returned as hazard or odds ratios, not on the log scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msm.form.qoutput(x, covariates = "mean", cl = 0.95, digits = 4, ...)

msm.form.eoutput(x, covariates = "mean", cl = 0.95, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msm.form.qoutput_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model object, as returned by
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="msm.form.qoutput_+3A_covariates">covariates</code></td>
<td>
<p>Covariate values defining the &quot;baseline&quot; parameters (see
<code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>).</p>
</td></tr>
<tr><td><code id="msm.form.qoutput_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval to present.  Defaults
to 0.95.</p>
</td></tr>
<tr><td><code id="msm.form.qoutput_+3A_digits">digits</code></td>
<td>
<p>Minimum number of significant digits for the formatted
character matrix returned as an attribute.  This is passed to
<code><a href="base.html#topic+format">format</a></code>. Defaults to 4.</p>
</td></tr>
<tr><td><code id="msm.form.qoutput_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="base.html#topic+format">format</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with one row per transition, and one column for
each estimate or confidence limit.  The <code>"formatted"</code> attribute
contains the same results formatted for pretty printing.
<code>msm.form.qoutput</code> returns the transition intensities and their
covariates, and <code>msm.form.eoutput</code> returns the misclassification
probabilities and their covariates.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.msm">print.msm</a></code>
</p>

<hr>
<h2 id='msm.object'>Fitted msm model objects</h2><span id='topic+msm.object'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+msm">msm</a></code> function returns a list with the following components.
These are intended for developers and confident users.  To extract results
from fitted model objects, functions such as <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code> or
<code><a href="#topic+print.msm">print.msm</a></code> should be used instead.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code><a href="#topic+msm">msm</a></code>, as returned by
<code><a href="base.html#topic+match.call">match.call</a></code>.</p>
</td></tr> <tr><td><code>Qmatrices</code></td>
<td>
<p>A list of matrices. The first
component, labelled <code>logbaseline</code>, is a matrix containing the estimated
transition intensities on the log scale with any covariates fixed at their
means in the data (or at zero, if <code>center=FALSE</code>). The component
labelled <code>baseline</code> is the equivalent on the untransformed scale. Each
remaining component is a matrix giving the linear effects of the labelled
covariate on the matrix of log intensities.  To extract an estimated
intensity matrix on the natural scale, at an arbitrary combination of
covariate values, use the function <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>.  </p>
</td></tr>
<tr><td><code>QmatricesSE</code></td>
<td>
<p>The standard error matrices corresponding to
<code>Qmatrices</code>.  </p>
</td></tr> <tr><td><code>QmatricesL</code>, <code>QmatricesU</code></td>
<td>
<p>Corresponding lower and
upper symmetric confidence limits, of width 0.95 unless specified otherwise
by the <code>cl</code> argument.  </p>
</td></tr> <tr><td><code>Ematrices</code></td>
<td>
<p>A list of matrices. The first
component, labelled <code>logitbaseline</code>, is the estimated misclassification
probability matrix (expressed as as log odds relative to the probability of
the true state) with any covariates fixed at their means in the data (or at
zero, if <code>center=FALSE</code>). The component labelled <code>baseline</code> is the
equivalent on the untransformed scale. Each remaining component is a matrix
giving the linear effects of the labelled covariate on the matrix of logit
misclassification probabilities.  To extract an estimated misclassification
probability matrix on the natural scale, at an arbitrary combination of
covariate values, use the function <code><a href="#topic+ematrix.msm">ematrix.msm</a></code>.</p>
</td></tr>
<tr><td><code>EmatricesSE</code></td>
<td>
<p>The standard error matrices corresponding to
<code>Ematrices</code>.</p>
</td></tr> <tr><td><code>EmatricesL</code>, <code>EmatricesU</code></td>
<td>
<p>Corresponding lower and
upper symmetric confidence limits, of width 0.95 unless specified otherwise
by the <code>cl</code> argument.  </p>
</td></tr>
<tr><td><code>minus2loglik</code></td>
<td>
<p>Minus twice the maximised log-likelihood.</p>
</td></tr>
<tr><td><code>deriv</code></td>
<td>
<p>Derivatives of the minus twice log-likelihood at its maximum.</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>Vector of untransformed maximum likelihood estimates
returned from <code><a href="stats.html#topic+optim">optim</a></code>.  Transition intensities are on the log
scale and misclassification probabilities are given as log odds relative to
the probability of the true state.</p>
</td></tr> <tr><td><code>estimates.t</code></td>
<td>
<p>Vector of transformed
maximum likelihood estimates with intensities and probabilities on their
natural scales.</p>
</td></tr>
<tr><td><code>fixedpars</code></td>
<td>
<p>Indices of <code>estimates</code> which were fixed during the
maximum likelihood estimation.</p>
</td></tr> <tr><td><code>center</code></td>
<td>
<p>Indicator for whether the
estimation was performed with covariates centered on their means in the
data.</p>
</td></tr> <tr><td><code>covmat</code></td>
<td>
<p>Covariance matrix corresponding to <code>estimates</code>.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>Matrix of confidence intervals corresponding to
<code>estimates.t</code></p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>Return value from the optimisation routine (such as
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlm">nlm</a></code>), giving information about the
results of the optimisation.</p>
</td></tr> <tr><td><code>foundse</code></td>
<td>
<p>Logical value indicating
whether the Hessian was positive-definite at the supposed maximum of the
likelihood.  If not, the covariance matrix of the parameters is unavailable.
In these cases the optimisation has probably not converged to a maximum.  </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A list giving the data used for the model fit, for use in
post-processing.  To extract it, use the methods
<code><a href="#topic+model.frame.msm">model.frame.msm</a></code> or <code><a href="#topic+model.matrix.msm">model.matrix.msm</a></code>.
</p>
<p>The format of this element changed in version 1.4 of <span class="pkg">msm</span>, so that it
now contains a <code><a href="stats.html#topic+model.frame">model.frame</a></code> object <code>mf</code> with all the
variables used in the model.  The previous format (an ad-hoc list of vectors
and matrices) can be obtained with the function
<code>recreate.olddata(msmobject)</code>, where <code>msmobject</code> is the object
returned by <code>msm</code>.  </p>
</td></tr> <tr><td><code>qmodel</code></td>
<td>
<p>A list of objects representing the
transition matrix structure and options for likelihood calculation.  See
<code><a href="#topic+qmodel.object">qmodel.object</a></code> for documentation of the components.</p>
</td></tr>
<tr><td><code>emodel</code></td>
<td>
<p>A list of objects representing the misclassification model
structure, for models specified using the <code>ematrix</code> argument to
<code><a href="#topic+msm">msm</a></code>. See <code><a href="#topic+emodel.object">emodel.object</a></code>.</p>
</td></tr> <tr><td><code>qcmodel</code></td>
<td>
<p>A list
of objects representing the model for covariates on transition intensities.
See <code><a href="#topic+qcmodel.object">qcmodel.object</a></code>.</p>
</td></tr> <tr><td><code>ecmodel</code></td>
<td>
<p>A list of objects
representing the model for covariates on transition intensities.  See
<code><a href="#topic+ecmodel.object">ecmodel.object</a></code>.</p>
</td></tr> <tr><td><code>hmodel</code></td>
<td>
<p>A list of objects representing
the hidden Markov model structure. See <code><a href="#topic+hmodel.object">hmodel.object</a></code>.</p>
</td></tr>
<tr><td><code>cmodel</code></td>
<td>
<p>A list giving information about censored states.  See
<code><a href="#topic+cmodel.object">cmodel.object</a></code>. </p>
</td></tr> <tr><td><code>pci</code></td>
<td>
<p>Cut points for time-varying
intensities, as supplied to <code><a href="#topic+msm">msm</a></code>, but excluding any that are
outside the times observed in the data.</p>
</td></tr> <tr><td><code>paramdata</code></td>
<td>
<p>A list giving
information about the parameters of the multi-state model.  See
<code><a href="#topic+paramdata.object">paramdata.object</a></code>.</p>
</td></tr> <tr><td><code>cl</code></td>
<td>
<p>Confidence interval width, as
supplied to <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>covariates</code></td>
<td>
<p>Formula for covariates on
intensities, as supplied to <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code>misccovariates</code></td>
<td>
<p>Formula for covariates on misclassification
probabilities, as supplied to <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>hcovariates</code></td>
<td>
<p>Formula
for covariates on hidden Markov model outcomes, as supplied to
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>initcovariates</code></td>
<td>
<p>Formula for covariates on initial
state occupancy probabilities in hidden Markov models, as supplied to
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>sojourn</code></td>
<td>
<p> A list as returned by
<code><a href="#topic+sojourn.msm">sojourn.msm</a></code>, with components:
</p>
<p><code>mean</code> = estimated mean sojourn times in the transient states, with
covariates fixed at their means (if center=TRUE) or at zero (if
center=FALSE).
</p>
<p><code>se</code> = corresponding standard errors. </p>
</td></tr>
</table>

<hr>
<h2 id='msm2Surv'>Convert data for &lsquo;msm&rsquo; to data for &lsquo;survival&rsquo;, &lsquo;mstate&rsquo; or &lsquo;flexsurv&rsquo;
analysis</h2><span id='topic+msm2Surv'></span>

<h3>Description</h3>

<p>Converts longitudinal data for a <code><a href="#topic+msm">msm</a></code> model fit, where
observations represent the exact transition times of the process, to
counting process data.  This enables, for example, flexible parametric
multi-state models to be fitted with <code><a href="flexsurv.html#topic+flexsurvreg">flexsurvreg</a></code>
from the <span class="pkg">flexsurv</span> package, or semiparametric models to be implemented
with <code><a href="survival.html#topic+coxph">coxph</a></code> and the <span class="pkg">mstate</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msm2Surv(data, subject, time, state, covs = NULL, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msm2Surv_+3A_data">data</code></td>
<td>
<p>Data frame in the format expected by a <code><a href="#topic+msm">msm</a></code> model
fit with <code>exacttimes=TRUE</code> or all <code>obstype=2</code>.  Each row
represents an observation of a state, and the time variable contains the
exact and complete transition times of the underlying process.  This is
explained in more detail in the help page for <code><a href="#topic+msm">msm</a></code>, section
<code>obstype=2</code>.</p>
</td></tr>
<tr><td><code id="msm2Surv_+3A_subject">subject</code></td>
<td>
<p>Name of the subject ID in the data (character format, i.e.
quoted).</p>
</td></tr>
<tr><td><code id="msm2Surv_+3A_time">time</code></td>
<td>
<p>Name of the time variable in the data (character).</p>
</td></tr>
<tr><td><code id="msm2Surv_+3A_state">state</code></td>
<td>
<p>Name of the state variable in the data (character).</p>
</td></tr>
<tr><td><code id="msm2Surv_+3A_covs">covs</code></td>
<td>
<p>Vector of covariate names to carry through (character).  If not
supplied, this is taken to be all remaining variables in the data.</p>
</td></tr>
<tr><td><code id="msm2Surv_+3A_q">Q</code></td>
<td>
<p>Transition intensity matrix.  This should have number of rows and
number of columns both equal to the number of states.  If an instantaneous
transition is not allowed from state <code class="reqn">r</code> to state <code class="reqn">s</code>, then <code>Q</code>
should have <code class="reqn">(r,s)</code> entry 0, otherwise it should be non-zero.  The
diagonal entries are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, if the data supplied to <code><a href="#topic+msm">msm</a></code> look like this:
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>subj</code> </td><td style="text-align: left;"> <code>days</code> </td><td style="text-align: left;"> <code>status</code> </td><td style="text-align: left;">
<code>age</code> </td><td style="text-align: left;"> <code>treat</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 1</td><td style="text-align: left;"> 0</td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 66</td><td style="text-align: left;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;"> 1</td><td style="text-align: left;"> 27</td><td style="text-align: left;">
2 </td><td style="text-align: left;"> 66</td><td style="text-align: left;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;"> 1</td><td style="text-align: left;"> 75</td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> 66</td><td style="text-align: left;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;"> 1</td><td style="text-align: left;"> 97</td><td style="text-align: left;"> 4 </td><td style="text-align: left;">
66</td><td style="text-align: left;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;"> 1</td><td style="text-align: left;"> 1106</td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 69</td><td style="text-align: left;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;"> 2</td><td style="text-align: left;"> 0</td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 49</td><td style="text-align: left;"> 0</td>
</tr>
<tr>
 <td style="text-align: left;">
2</td><td style="text-align: left;"> 90</td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 49</td><td style="text-align: left;"> 0</td>
</tr>
<tr>
 <td style="text-align: left;"> 2</td><td style="text-align: left;"> 1037</td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 51</td><td style="text-align: left;"> 0</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>then the output of <code><a href="#topic+msm2Surv">msm2Surv</a></code> will be a data frame looking like
this:
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>id</code> </td><td style="text-align: left;"> <code>from</code> </td><td style="text-align: left;"> <code>to</code> </td><td style="text-align: left;">
<code>Tstart</code> </td><td style="text-align: left;"> <code>Tstop</code> </td><td style="text-align: left;"> <code>time</code> </td><td style="text-align: left;"> <code>status</code> </td><td style="text-align: left;">
<code>age</code> </td><td style="text-align: left;"> <code>treat</code> </td><td style="text-align: left;"> <code>trans</code></td>
</tr>
<tr>
 <td style="text-align: left;"> 1 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 0
</td><td style="text-align: left;"> 27 </td><td style="text-align: left;"> 27 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 66 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;"> 1 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;">
27 </td><td style="text-align: left;"> 27 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 66 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 2</td>
</tr>
<tr>
 <td style="text-align: left;"> 1 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> 27 </td><td style="text-align: left;"> 75
</td><td style="text-align: left;"> 48 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 66 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 3</td>
</tr>
<tr>
 <td style="text-align: left;"> 1 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 27 </td><td style="text-align: left;"> 75 </td><td style="text-align: left;">
48 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 66 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 4</td>
</tr>
<tr>
 <td style="text-align: left;"> 1 </td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 75 </td><td style="text-align: left;"> 97 </td><td style="text-align: left;"> 22
</td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 69 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 5</td>
</tr>
<tr>
 <td style="text-align: left;"> 2 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 90 </td><td style="text-align: left;"> 90 </td><td style="text-align: left;">
1 </td><td style="text-align: left;"> 49 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;"> 2 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 90 </td><td style="text-align: left;"> 90 </td><td style="text-align: left;"> 0
</td><td style="text-align: left;"> 49 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 2</td>
</tr>
<tr>
 <td style="text-align: left;"> 2 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> 90 </td><td style="text-align: left;"> 1037 </td><td style="text-align: left;"> 947 </td><td style="text-align: left;"> 0
</td><td style="text-align: left;"> 49 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 3</td>
</tr>
<tr>
 <td style="text-align: left;"> 2 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 90 </td><td style="text-align: left;"> 1037 </td><td style="text-align: left;"> 947 </td><td style="text-align: left;">
0</td><td style="text-align: left;"> 49 </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> 4</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>At 27 days, subject 1 is observed to move from state 1 to state 2 (first
row, status 1), which means that their potential transition from state 1 to
state 4 is censored (second row, status 0).
</p>
<p>See the <span class="pkg">mstate</span> package and the references below for more details of
this data format and using it for semi-parametric multi-state modelling.
</p>


<h3>Value</h3>

<p>A data frame of class <code>"msdata"</code>, with rows representing
observed or censored transitions.  There will be one row for each observed
transition in the original data, and additional rows for every potential
transition that could have occurred out of each observed state.
</p>
<p>The data frame will have columns called:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Subject ID</p>
</td></tr> <tr><td><code>from</code></td>
<td>
<p>Starting state of the transition</p>
</td></tr>
<tr><td><code>to</code></td>
<td>
<p>Finishing state of the transition</p>
</td></tr> <tr><td><code>Tstart</code></td>
<td>
<p>The starting time
of the transition</p>
</td></tr> <tr><td><code>Tstop</code></td>
<td>
<p>The finishing time of the transition</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>The time difference = <code>Tstop</code> - <code>Tstart</code></p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>Event or censoring indicator, with 1 indicating an observed
transition, and 0 indicating censoring</p>
</td></tr> <tr><td><code>trans</code></td>
<td>
<p>Transition number</p>
</td></tr>
</table>
<p>and any remaining columns will represent covariates.  Any covariates whose
names clash with the standard variables in the returned data (<code>"id"</code>,
<code>"from"</code>, <code>"to"</code>, <code>"Tstart"</code>, <code>"Tstop"</code>, <code>"time"</code>,
<code>"status"</code> or <code>"trans"</code>) have <code>".2"</code> appended to their names.
</p>
<p>The transition matrix in <span class="pkg">mstate</span> format is stored in the <code>trans</code>
attribute of the returned object.  See the example code below.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Putter H, Fiocco M, Geskus RB (2007). Tutorial in biostatistics:
Competing risks and multi-state models. <em>Statistics in Medicine</em> 26:
2389-2430.
</p>
<p>Liesbeth C. de Wreede, Marta Fiocco, Hein Putter (2011). <span class="pkg">mstate</span>: An R
Package for the Analysis of Competing Risks and Multi-State Models.
<em>Journal of Statistical Software</em>, 38(7), 1-30.
</p>
<p>Jackson, C. H. (2014). flexsurv: Flexible parametric survival and
multi-state models.  R package version 0.5.
</p>


<h3>See Also</h3>

<p><code><a href="mstate.html#topic+msprep">msprep</a></code>, in <span class="pkg">mstate</span>, which produces data
in a similar format, given data in &quot;wide&quot; format with one row per subject.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
msmdat &lt;- data.frame(
 subj = c(1, 1, 1, 1, 1, 2, 2, 2),
 days = c(0, 27, 75, 97, 1106, 0, 90, 1037),
 status = c(1, 2, 3, 4, 4, 1, 2, 2),
 age = c(66, 66, 66, 66, 69, 49, 49, 51),
 treat = c(1, 1, 1, 1, 1, 0, 0, 0)
)
# transitions only allowed to next state up or state 4
Q &lt;- rbind(c(1, 1, 0, 1), 
           c(0, 1, 1, 1),
           c(0, 0, 1, 1),
           c(0, 0, 0, 0))
dat &lt;- msm2Surv(data=msmdat, subject="subj", time="days", state="status", 
         Q=Q)
dat
attr(dat, "trans")

</code></pre>

<hr>
<h2 id='odds.msm'>Calculate tables of odds ratios for covariates on misclassification
probabilities</h2><span id='topic+odds.msm'></span>

<h3>Description</h3>

<p>Odds ratios are computed by exponentiating the estimated covariate effects
on the logit-misclassification probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odds.msm(x, odds.scale = 1, cl = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odds.msm_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+msm">msm</a></code> representing a fitted multi-state
model.</p>
</td></tr>
<tr><td><code id="odds.msm_+3A_odds.scale">odds.scale</code></td>
<td>
<p>Vector with same elements as number of covariates on
misclassification probabilities. Corresponds to the increase in each
covariate used to calculate its odds ratio. Defaults to all 1.</p>
</td></tr>
<tr><td><code id="odds.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval to present.  Defaults
to 0.95.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables containing odds ratio estimates, one table for each
covariate.  Each table has three columns, containing the odds ratio, and an
approximate upper 95% and lower 95% confidence limit respectively
(assuming normality on the log scale), for each misclassification
probability.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>, <code><a href="#topic+hazard.msm">hazard.msm</a></code>
</p>

<hr>
<h2 id='paramdata.object'>Developer documentation: internal msm parameters object</h2><span id='topic+paramdata.object'></span>

<h3>Description</h3>

<p>An object giving information about the parameters of the multi-state model.
Used internally during maximum likelihood estimation and arranging results.
Returned as the <code>paramdata</code> component of a fitted <code><a href="#topic+msm">msm</a></code>
model object.
</p>


<h3>Value</h3>

<table>
<tr><td><code>inits</code></td>
<td>
<p>Vector of initial values for distinct parameters which
are being estimated.  These have been transformed to the real line (e.g. by
log), and exclude parameters being fixed at their initial values, parameters
defined to be always fixed (e.g. binomial denominators) and parameters
constrained to equal previous ones.</p>
</td></tr> <tr><td><code>plabs</code></td>
<td>
<p>Names of parameters in
<code>allinits</code>.</p>
</td></tr> <tr><td><code>allinits</code></td>
<td>
<p>Vector of parameter values before
estimation, including those which are fixed or constrained to equal other
parameters, and transformed to the real line.</p>
</td></tr> <tr><td><code>hmmpars</code></td>
<td>
<p>Indices of
<code>allinits</code> which represent baseline parameters of hidden Markov outcome
models (thus excluding covariate effects in HMMs and initial state occupancy
probabilities). </p>
</td></tr> <tr><td><code>fixed</code></td>
<td>
<p><code>TRUE</code> if all parameters are fixed,
<code>FALSE</code> otherwise.</p>
</td></tr> <tr><td><code>fixedpars</code></td>
<td>
<p>Indices of parameters in
<code>allinits</code> which are fixed, either by definition or as requested by the
user in the <code>fixedpars</code> argument to <code><a href="#topic+msm">msm</a></code>. Excludes
parameters fixed by constraining to equal other parameters.</p>
</td></tr>
<tr><td><code>notfixed</code></td>
<td>
<p>Indices of parameters which are not fixed by the definition
of <code>fixedpars</code>.</p>
</td></tr> <tr><td><code>optpars</code></td>
<td>
<p>Indices of parameters in
<code>allinits</code> being estimated, thus those included in <code>inits</code>.</p>
</td></tr>
<tr><td><code>auxpars</code></td>
<td>
<p>Indices of &quot;auxiliary&quot; parameters which are always fixed, for
example, binomial denominators (<code><a href="#topic+hmmBinom">hmmBinom</a></code>) and the <code>which</code>
parameter in <code><a href="#topic+hmmIdent">hmmIdent</a></code>.</p>
</td></tr> <tr><td><code>constr</code></td>
<td>
<p>Vector of integers, of
length <code>npars</code>, indicating which sets of parameters are constrained to
be equal to each other.  If two of these integers are equal the
corresponding parameters are equal.  A negative element indicates that
parameter is defined to be minus some other parameter (this is used for
covariate effects on transition intensities).</p>
</td></tr> <tr><td><code>npars</code></td>
<td>
<p>Total number of
parameters, equal to <code>length(allinits)</code>.</p>
</td></tr> <tr><td><code>nfix</code></td>
<td>
<p>Number of fixed
parameters, equal to <code>length(fixedpars)</code>. </p>
</td></tr> <tr><td><code>nopt</code></td>
<td>
<p>Number of
parameters being estimated, equal to <code>length(inits)</code> and
<code>length(optpars)</code>.</p>
</td></tr> <tr><td><code>ndup</code></td>
<td>
<p>Number of parameters defined as
duplicates of previous parameters by equality constraints (currently
unused).</p>
</td></tr> <tr><td><code>ranges</code></td>
<td>
<p>Matrix of defined ranges for each parameter on the
natural scale (e.g. 0 to infinity for rate parameters). </p>
</td></tr> <tr><td><code>opt</code></td>
<td>
<p>Object
returned by the optimisation routine (such as <code><a href="stats.html#topic+optim">optim</a></code>).</p>
</td></tr>
<tr><td><code>foundse</code></td>
<td>
<p><code>TRUE</code> if standard errors are available after
optimisation. If <code>FALSE</code> the optimisation probably hasn't converged. </p>
</td></tr>
<tr><td><code>lik</code></td>
<td>
<p>Minus twice the log likelihood at the parameter estimates.</p>
</td></tr>
<tr><td><code>deriv</code></td>
<td>
<p>Derivatives of the minus twice log likelihood at the parameter
estimates, if available. </p>
</td></tr> <tr><td><code>information</code></td>
<td>
<p>Corresponding expected
information matrix at the parameter estimates, if available.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>Vector of parameter values after maximum likelihood
estimation, corresponding to <code>allinits</code>, still on the real-line
transformed scale.</p>
</td></tr> <tr><td><code>covmat</code></td>
<td>
<p>Covariance matrix corresponding to
<code>params</code>.</p>
</td></tr> <tr><td><code>ci</code></td>
<td>
<p>Matrix of confidence intervals corresponding to
<code>params</code>, with nominal coverage (default 0.95) defined by the <code>cl</code>
argument of <code><a href="#topic+msm">msm</a></code>. </p>
</td></tr> <tr><td><code>estimates.t</code></td>
<td>
<p>Vector of parameter
estimates, as <code>params</code> but with parameters on their natural scales.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+msm.object">msm.object</a></code>
</p>

<hr>
<h2 id='pearson.msm'>Pearson-type goodness-of-fit test</h2><span id='topic+pearson.msm'></span>

<h3>Description</h3>

<p>Pearson-type goodness-of-fit test for multi-state models fitted to
panel-observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pearson.msm(
  x,
  transitions = NULL,
  timegroups = 3,
  intervalgroups = 3,
  covgroups = 3,
  groups = NULL,
  boot = FALSE,
  B = 500,
  next.obstime = NULL,
  N = 100,
  indep.cens = TRUE,
  maxtimes = NULL,
  pval = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pearson.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_transitions">transitions</code></td>
<td>
<p>This should be an integer vector indicating which
interval transitions should be grouped together in the contingency table.
Its length should be the number of allowed interval transitions, excluding
transitions from absorbing states to absorbing states.
</p>
<p>The allowed interval transitions are the set of pairs of states <code class="reqn">(a,b)</code>
for which it is possible to observe <code class="reqn">a</code> at one time and <code class="reqn">b</code> at any
later time.  For example, in a &quot;well-disease-death&quot; model with allowed
<em>instantaneous</em> 1-2, 2-3 transitions, there are 5 allowed
<em>interval</em> transitions. In numerical order, these are 1-1, 1-2, 1-3,
2-2 and 2-3, excluding absorbing-absorbing transitions.
</p>
<p>Then, to group transitions 1-1,1-2 together, and transitions 2-2,2-3
together, specify
</p>
<p><code>transitions = c(1,1,2,3,3)</code>.
</p>
<p>Only transitions from the same state may be grouped.  By default, each
interval transition forms a separate group.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_timegroups">timegroups</code></td>
<td>
<p>Number of groups based on quantiles of the time since the
start of the process.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_intervalgroups">intervalgroups</code></td>
<td>
<p>Number of groups based on quantiles of the time
interval between observations, within time groups</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_covgroups">covgroups</code></td>
<td>
<p>Number of groups based on quantiles of <code class="reqn">\sum_r
q_{irr}</code>, where <code class="reqn">q_{irr}</code> are the diagonal entries of the
transition intensity matrix for the <em>i</em>th transition.  These are a
function of the covariate effects and the covariate values at the <em>i</em>th
transition: <code class="reqn">q_{irr}</code> is minus the sum of the off-diagonal entries
<code class="reqn">q_{rs}^{(0)} exp (\beta_{rs}^T z_i)</code> on the <em>r</em>th row.
</p>
<p>Thus <code>covgroups</code> summarises the impact of covariates at each
observation, by calculating the overall rate of progression through states
at that observation.
</p>
<p>For time-inhomogeneous models specified using the <code>pci</code> argument to
<code><a href="#topic+msm">msm</a></code>, if the only covariate is the time period,
<code>covgroups</code> is set to 1, since <code>timegroups</code> ensures that
transitions are grouped by time.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_groups">groups</code></td>
<td>
<p>A vector of arbitrary groups in which to categorise each
transition. This can be an integer vector or a factor.  This can be used to
diagnose specific areas of poor fit.  For example, the contingency table
might be grouped by arbitrary combinations of covariates to detect types of
individual for whom the model fits poorly.
</p>
<p>The length of <code>groups</code> should be <code>x$data$n</code>, the number of
observations used in the model fit, which is the number of observations in
the original dataset with any missing values excluded.  The value of
<code>groups</code> at observation <code class="reqn">i</code> is used to categorise the transition
which <em>ends</em> at observation i. Values of <code>groups</code> at the first
observation for each subject are ignored.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_boot">boot</code></td>
<td>
<p>Estimate an &quot;exact&quot; p-value using a parametric bootstrap.
</p>
<p>All objects used in the original call to <code><a href="#topic+msm">msm</a></code> which produced
<code>x</code>, such as the <code>qmatrix</code>, should be in the working environment,
or else an &ldquo;object not found&rdquo; error will be given.  This enables the
original model to be refitted to the replicate datasets.
</p>
<p>Note that <code>groups</code> cannot be used with bootstrapping, as the simulated
observations will not be in the same categories as the original
observations.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_next.obstime">next.obstime</code></td>
<td>
<p>This is a vector of length <code>x$data$n</code> (the number
of observations used in the model fit) giving the time to the next
<em>scheduled</em> observation following each time point.  This is only used
when times to death are known exactly.
</p>
<p>For individuals who died (entered an absorbing state) before the next
scheduled observation, and the time of death is known exactly,
<code>next.obstime</code> would be <em>greater</em> than the observed death time.
</p>
<p>If the individual did not die, and a scheduled observation did follow that
time point, <code>next.obstime</code> should just be the same as the time to that
observation.
</p>
<p><code>next.obstime</code> is used to determine a grouping of the time interval
between observations, which should be based on scheduled observations. If
exact times to death were used in the grouping, then shorter intervals would
contain excess deaths, and the goodness-of-fit statistic would be biased.
</p>
<p>If <code>next.obstime</code> is unknown, it is multiply-imputed using a
product-limit estimate based on the intervals to observations other than
deaths. The resulting tables of transitions are averaged over these
imputations.  This may be slow.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_n">N</code></td>
<td>
<p>Number of imputations for the estimation of the distribution of the
next scheduled observation time, when there are exact death times.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_indep.cens">indep.cens</code></td>
<td>
<p>If <code>TRUE</code>, then times to censoring are included in
the estimation of the distribution to the next scheduled observation time.
If <code>FALSE</code>, times to censoring are assumed to be systematically
different from other observation times.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_maxtimes">maxtimes</code></td>
<td>
<p>A vector of length <code>x$data$n</code>, or a common scalar,
giving an upper bound for the next scheduled observation time.  Used in the
multiple imputation when times to death are known exactly.  If a value
greater than <code>maxtimes</code> is simulated, then the next scheduled
observation is taken as censored.  This should be supplied, if known.  If
not supplied, this is taken to be the maximum interval occurring in the
data, plus one time unit.  For observations which are not exact death times,
this should be the time since the previous observation.</p>
</td></tr>
<tr><td><code id="pearson.msm_+3A_pval">pval</code></td>
<td>
<p>Calculate a p-value using the improved approximation of Titman
(2009).  This is optional since it is not needed during bootstrapping, and
it is computationally non-trivial.  Only available currently for non-hidden
Markov models for panel data without exact death times.  Also not available
for models with censoring, including time-homogeneous models fitted with the
<code>pci</code> option to <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method (Aguirre-Hernandez and Farewell, 2002) is intended for data
which represent observations of the process at arbitrary times (&quot;snapshots&quot;,
or &quot;panel-observed&quot; data). For data which represent the exact transition
times of the process, <code><a href="#topic+prevalence.msm">prevalence.msm</a></code> can be used to assess
fit, though without a formal test.
</p>
<p>When times of death are known exactly, states are misclassified, or an
individual's final observation is a censored state, the modification by
Titman and Sharples (2008) is used. The only form of censoring supported is
a state at the end of an individual's series which represents an unknown
transient state (i.e. the individual is only known to be alive at this
time). Other types of censoring are omitted from the data before performing
the test.
</p>
<p>See the references for further details of the methods.  The method used for
censored states is a modification of the method in the appendix to Titman
and Sharples (2008), described at
<a href="https://www.mrc-bsu.cam.ac.uk/wp-content/uploads/robustcensoring.pdf">https://www.mrc-bsu.cam.ac.uk/wp-content/uploads/robustcensoring.pdf</a>
(Titman, 2007).
</p>
<p>Groupings of the time since initiation, the time interval and the impact of
covariates are based on equally-spaced quantiles.  The number of groups
should be chosen that there are not many cells with small expected numbers
of transitions, since the deviance statistic will be unstable for sparse
contingency tables.  Ideally, the expected numbers of transitions in each
cell of the table should be no less than about 5.  Conversely, the power of
the test is reduced if there are too few groups. Therefore, some sensitivity
analysis of the test results to the grouping is advisable.
</p>
<p>Saved model objects fitted with previous versions of R (versions less than
1.2) will need to be refitted under the current R for use with
<code>pearson.msm</code>.
</p>


<h3>Value</h3>

<p>A list whose first two elements are contingency tables of observed
transitions <code class="reqn">O</code> and expected transitions <code class="reqn">E</code>, respectively, for each
combination of groups.  The third element is a table of the deviances
<code class="reqn">(O - E)^2 / E</code> multiplied by the sign of <code class="reqn">O - E</code>.  If the expected
number of transitions is zero then the deviance is zero.  Entries in the
third matrix will be bigger in magnitude for groups for which the model fits
poorly.  <br />
</p>
<table>
<tr><td><code>list("\"test\"")</code></td>
<td>
<p>the fourth element of the list, is a data frame with
one row containing the Pearson-type goodness-of-fit test statistic
<code>stat</code>.  The test statistic is the sum of the deviances.  For
panel-observed data without exact death times, misclassification or censored
observations, <code>p</code> is the p-value for the test statistic calculated
using the improved approximation of Titman (2009).
</p>
<p>For these models, for comparison with older versions of the package,
<code>test</code> also presents <code>p.lower</code> and <code>p.upper</code>, which are
theoretical lower and upper limits for the p-value of the test statistic,
based on chi-squared distributions with
<code>df.lower</code> and <code>df.upper</code> degrees of freedom, respectively.
<code>df.upper</code> is the number of independent cells in the contingency table,
and <code>df.lower</code> is <code>df.upper</code> minus the number of estimated
parameters in the model.</p>
</td></tr>
<tr><td><code>list("\"intervalq\"")</code></td>
<td>
<p>(not printed by default) contains the
definition of the grouping of the intervals between observations.  These
groups are defined by quantiles within the groups corresponding to the time
since the start of the process.</p>
</td></tr>
<tr><td><code>list("\"sim\"")</code></td>
<td>
<p>If there are exact death times, this contains
simulations of the contingency tables and test statistics for each
imputation of the next scheduled sampling time.  These are averaged over to
produce the presented tables and test statistic. This element is not printed
by default.
</p>
<p>With exact death times, the null variance of the test statistic (formed by
taking mean of simulated test statistics) is less than twice the mean
(Titman, 2008), and the null distribution is not
chi-squared.  In this case, <code>p.upper</code> is an
upper limit for the true asymptotic p-value, but <code>p.lower</code> is not a
lower limit, and is not presented.</p>
</td></tr>
<tr><td><code>list("\"boot\"")</code></td>
<td>
<p>If the bootstrap has been used, the element will
contain the bootstrap replicates of the test statistics (not printed by
default).</p>
</td></tr>
<tr><td><code>list("\"lambda\"")</code></td>
<td>
<p>If the Titman (2009) p-value has been calculated,
this contains the weights defining the null distribution of the test
statistic as a weighted sum of chi-squared(1)
random variables (not printed by default).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew Titman <a href="mailto:a.titman@lancaster.ac.uk">a.titman@lancaster.ac.uk</a>, Chris Jackson
<a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Aguirre-Hernandez, R. and Farewell, V. (2002) A Pearson-type
goodness-of-fit test for stationary and time-continuous Markov regression
models. <em>Statistics in Medicine</em> 21:1899-1911.
</p>
<p>Titman, A. and Sharples, L. (2008) A general goodness-of-fit test for Markov
and hidden Markov models. <em>Statistics in Medicine</em> 27(12):2177-2195
</p>
<p>Titman, A. (2009) Computation of the asymptotic null distribution of
goodness-of-fit tests for multi-state models. <em>Lifetime Data Analysis</em>
15(4):519-533.
</p>
<p>Titman, A. (2008) Model diagnostics in multi-state models of biological
systems. PhD thesis, University of Cambridge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>, <code><a href="#topic+prevalence.msm">prevalence.msm</a></code>,
<code><a href="#topic+scoreresid.msm">scoreresid.msm</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
psor.q &lt;- rbind(c(0,0.1,0,0),c(0,0,0.1,0),c(0,0,0,0.1),c(0,0,0,0))
psor.msm &lt;- msm(state ~ months, subject=ptnum, data=psor,
                qmatrix = psor.q, covariates = ~ollwsdrt+hieffusn,
                constraint = list(hieffusn=c(1,1,1),ollwsdrt=c(1,1,2)))
pearson.msm(psor.msm, timegroups=2, intervalgroups=2, covgroups=2)
# More 1-2, 1-3 and 1-4 observations than expected in shorter time
# intervals - the model fits poorly.
# A random effects model might accommodate such fast progressors.

</code></pre>

<hr>
<h2 id='pexp'>Exponential distribution with piecewise-constant rate</h2><span id='topic+pexp'></span><span id='topic+dpexp'></span><span id='topic+ppexp'></span><span id='topic+qpexp'></span><span id='topic+rpexp'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for
a generalisation of the exponential distribution, in which the rate changes
at a series of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpexp(x, rate = 1, t = 0, log = FALSE)

ppexp(q, rate = 1, t = 0, lower.tail = TRUE, log.p = FALSE)

qpexp(p, rate = 1, t = 0, lower.tail = TRUE, log.p = FALSE)

rpexp(n = 1, rate = 1, t = 0, start = min(t))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pexp_+3A_x">x</code>, <code id="pexp_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pexp_+3A_rate">rate</code></td>
<td>
<p>vector of rates.</p>
</td></tr>
<tr><td><code id="pexp_+3A_t">t</code></td>
<td>
<p>vector of the same length as <code>rate</code>, giving the times at which
the rate changes. The values of <code>t</code> should be in increasing order.</p>
</td></tr>
<tr><td><code id="pexp_+3A_log">log</code>, <code id="pexp_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p), or
log density is returned.</p>
</td></tr>
<tr><td><code id="pexp_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x],
otherwise, P[X &gt; x].</p>
</td></tr>
<tr><td><code id="pexp_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="pexp_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="pexp_+3A_start">start</code></td>
<td>
<p>numeric scalar; delayed entry time. The random deviates will be
left truncated from this start time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the exponential distribution with rates <code class="reqn">r_1, \ldots,
</code><code class="reqn"> r_n</code> changing at times <code class="reqn">t_1, \ldots,
t_n</code>, with <code class="reqn">t_1 = 0</code>. Suppose <code class="reqn">t_k</code> is
the maximum <code class="reqn">t_i</code> such that <code class="reqn">t_i &lt; x</code>.  The density of
this distribution at <code class="reqn">x &gt; 0</code> is <code class="reqn">f(x)</code> for <code class="reqn">k = 1</code>, and
</p>
<p style="text-align: center;"><code class="reqn">\prod_{i=1}^k (1 - F(t_{i} - t_{i-1}, r_i)) f(x - t_{k},
r_{k})</code>
</p>
<p> for k
&gt; 1.
</p>
<p>where <code class="reqn">F()</code> and <code class="reqn">f()</code> are the distribution and density functions of
the standard exponential distribution.
</p>
<p>If <code>rate</code> is of length 1, this is just the standard exponential
distribution.  Therefore, for example, <code>dpexp(x)</code>, with no other
arguments, is simply equivalent to <code>dexp(x)</code>.
</p>
<p>Only <code>rpexp</code> is used in the <code>msm</code> package, to simulate from Markov
processes with piecewise-constant intensities depending on time-dependent
covariates.  These functions are merely provided for completion, and are not
optimized for numerical stability or speed.
</p>


<h3>Value</h3>

<p><code>dpexp</code> gives the density, <code>ppexp</code> gives the distribution
function, <code>qpexp</code> gives the quantile function, and <code>rpexp</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dexp">dexp</a></code>, <code><a href="#topic+sim.msm">sim.msm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0.1, 50, by=0.1)
rate &lt;- c(0.1, 0.2, 0.05, 0.3)
t &lt;- c(0, 10, 20, 30)
## standard exponential distribution
plot(x, dexp(x, 0.1), type="l")
## distribution with piecewise constant rate
lines(x, dpexp(x, rate, t), type="l", lty=2)
## standard exponential distribution
plot(x, pexp(x, 0.1), type="l")
## distribution with piecewise constant rate
lines(x, ppexp(x, rate, t), type="l", lty=2)

</code></pre>

<hr>
<h2 id='phasemeans.msm'>Parameters of phase-type models in mixture form</h2><span id='topic+phasemeans.msm'></span>

<h3>Description</h3>

<p>Parameters of fitted two-phase models, in mixture model parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phasemeans.msm(
  x,
  covariates = "mean",
  ci = c("none", "normal", "bootstrap"),
  cl = 0.95,
  B = 1000,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phasemeans.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="phasemeans.msm_+3A_covariates">covariates</code></td>
<td>
<p>Covariate values, see <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>.</p>
</td></tr>
<tr><td><code id="phasemeans.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"none"</code> (the default) no confidence intervals are
calculated.  Otherwise <code>"normal"</code>, or <code>"boot"</code> as described by
<code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>.</p>
</td></tr>
<tr><td><code id="phasemeans.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval, relative to 1.</p>
</td></tr>
<tr><td><code id="phasemeans.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates, or number of normal simulations
from the distribution of the MLEs.</p>
</td></tr>
<tr><td><code id="phasemeans.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with one row for each state that has a two-phase
distribution, and three columns: the short-stay mean, long-stay mean and
long-stay probability.  These are functions of the transition intensities of
the expanded hidden Markov model, defined in <code><a href="#topic+d2phase">d2phase</a></code>.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+d2phase">d2phase</a></code>.
</p>

<hr>
<h2 id='plot.msm'>Plots of multi-state models</h2><span id='topic+plot.msm'></span>

<h3>Description</h3>

<p>This produces a plot of the expected probability of survival against time,
from each transient state. Survival is defined as not entering an absorbing
state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msm'
plot(
  x,
  from = NULL,
  to = NULL,
  range = NULL,
  covariates = "mean",
  legend.pos = NULL,
  xlab = "Time",
  ylab = "Fitted survival probability",
  lwd = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.msm_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+msm">msm</a></code>, representing a fitted multi-state
model object.</p>
</td></tr>
<tr><td><code id="plot.msm_+3A_from">from</code></td>
<td>
<p>States from which to consider survival. Defaults to the complete
set of transient states.</p>
</td></tr>
<tr><td><code id="plot.msm_+3A_to">to</code></td>
<td>
<p>Absorbing state to consider. Defaults to the highest-labelled
absorbing state.</p>
</td></tr>
<tr><td><code id="plot.msm_+3A_range">range</code></td>
<td>
<p>Vector of two elements, giving the range of times to plot for.</p>
</td></tr>
<tr><td><code id="plot.msm_+3A_covariates">covariates</code></td>
<td>
<p>Covariate values for which to evaluate the expected
probabilities.  This can either be:<br />
</p>
<p>the string <code>"mean"</code>, denoting the means of the covariates in the data
(this is the default),<br />
</p>
<p>the number <code>0</code>, indicating that all the covariates should be set to
zero,<br />
</p>
<p>or a list of values, with optional names. For example
</p>
<p><code>list (60, 1)</code>
</p>
<p>where the order of the list follows the order of the covariates originally
given in the model formula, or a named list,
</p>
<p><code>list (age = 60, sex = 1)</code></p>
</td></tr>
<tr><td><code id="plot.msm_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Vector of the <code class="reqn">x</code> and <code class="reqn">y</code> position, respectively,
of the legend.</p>
</td></tr>
<tr><td><code id="plot.msm_+3A_xlab">xlab</code></td>
<td>
<p>x axis label.</p>
</td></tr>
<tr><td><code id="plot.msm_+3A_ylab">ylab</code></td>
<td>
<p>y axis label.</p>
</td></tr>
<tr><td><code id="plot.msm_+3A_lwd">lwd</code></td>
<td>
<p>Line width. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.msm_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the generic <code><a href="base.html#topic+plot">plot</a></code>
and <code><a href="graphics.html#topic+lines">lines</a></code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that while this function is only relevant to models with absorbing
states, models in <span class="pkg">msm</span> can have any transition structure and do not
necessarily have to have an absorbing state.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>
</p>

<hr>
<h2 id='plot.prevalence.msm'>Plot of observed and expected prevalences</h2><span id='topic+plot.prevalence.msm'></span>

<h3>Description</h3>

<p>Provides a rough indication of goodness of fit of a multi-state model, by
estimating the observed numbers of individuals occupying a state at a series
of times, and plotting these against forecasts from the fitted model, for
each state.  Observed prevalences are indicated as solid lines, expected
prevalences as dashed lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prevalence.msm'
plot(
  x,
  mintime = NULL,
  maxtime = NULL,
  timezero = NULL,
  initstates = NULL,
  interp = c("start", "midpoint"),
  censtime = Inf,
  subset = NULL,
  covariates = "population",
  misccovariates = "mean",
  piecewise.times = NULL,
  piecewise.covariates = NULL,
  xlab = "Times",
  ylab = "Prevalence (%)",
  lwd.obs = 1,
  lwd.exp = 1,
  lty.obs = 1,
  lty.exp = 2,
  col.obs = "blue",
  col.exp = "red",
  legend.pos = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.prevalence.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model produced by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_mintime">mintime</code></td>
<td>
<p>Minimum time at which to compute the observed and expected
prevalences of states.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_maxtime">maxtime</code></td>
<td>
<p>Maximum time at which to compute the observed and expected
prevalences of states.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_timezero">timezero</code></td>
<td>
<p>Initial time of the Markov process. Expected values are
forecasted from here. Defaults to the minimum of the observation times given
in the data.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_initstates">initstates</code></td>
<td>
<p>Optional vector of the same length as the number of
states. Gives the numbers of individuals occupying each state at the initial
time, to be used for forecasting expected prevalences.  The default is those
observed in the data.  These should add up to the actual number of people in
the study at the start.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_interp">interp</code></td>
<td>
<p>Interpolation method for observed states, see
<code><a href="#topic+prevalence.msm">prevalence.msm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_censtime">censtime</code></td>
<td>
<p>Subject-specific maximum follow-up times, see
<code><a href="#topic+prevalence.msm">prevalence.msm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_subset">subset</code></td>
<td>
<p>Vector of the subject identifiers to calculated observed
prevalences for.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_covariates">covariates</code></td>
<td>
<p>Covariate values for which to forecast expected state
occupancy.  See <code><a href="#topic+prevalence.msm">prevalence.msm</a></code> &mdash; if this function runs too
slowly, as it may if there are continuous covariates, replace
<code>covariates="population"</code> with <code>covariates="mean"</code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_misccovariates">misccovariates</code></td>
<td>
<p>(Misclassification models only) Values of covariates
on the misclassification probability matrix. See
<code><a href="#topic+prevalence.msm">prevalence.msm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_piecewise.times">piecewise.times</code></td>
<td>
<p>Times at which piecewise-constant intensities change.
See <code><a href="#topic+prevalence.msm">prevalence.msm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_piecewise.covariates">piecewise.covariates</code></td>
<td>
<p>Covariates on which the piecewise-constant
intensities depend. See <code><a href="#topic+prevalence.msm">prevalence.msm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_xlab">xlab</code></td>
<td>
<p>x axis label.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_ylab">ylab</code></td>
<td>
<p>y axis label.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_lwd.obs">lwd.obs</code></td>
<td>
<p>Line width for observed prevalences. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_lwd.exp">lwd.exp</code></td>
<td>
<p>Line width for expected prevalences. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_lty.obs">lty.obs</code></td>
<td>
<p>Line type for observed prevalences. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_lty.exp">lty.exp</code></td>
<td>
<p>Line type for expected prevalences. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_col.obs">col.obs</code></td>
<td>
<p>Line colour for observed prevalences. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_col.exp">col.exp</code></td>
<td>
<p>Line colour for expected prevalences. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Vector of the <code class="reqn">x</code> and <code class="reqn">y</code> position, respectively,
of the legend.</p>
</td></tr>
<tr><td><code id="plot.prevalence.msm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the generic <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+prevalence.msm">prevalence.msm</a></code> for details of the assumptions underlying
this method.
</p>
<p>Observed prevalences are plotted with a solid line, and expected prevalences
with a dotted line.
</p>


<h3>References</h3>

<p>Gentleman, R.C., Lawless, J.F., Lindsey, J.C. and Yan, P.
Multi-state Markov models for analysing incomplete disease history data with
illustrations for HIV disease.  <em>Statistics in Medicine</em> (1994) 13(3):
805&ndash;821.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prevalence.msm">prevalence.msm</a></code>
</p>

<hr>
<h2 id='plot.survfit.msm'>Plot empirical and fitted survival curves</h2><span id='topic+plot.survfit.msm'></span>

<h3>Description</h3>

<p>Plot a Kaplan-Meier estimate of the survival probability and compare it with
the fitted survival probability from a <code>msm</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survfit.msm'
plot(
  x,
  from = 1,
  to = NULL,
  range = NULL,
  covariates = "mean",
  interp = c("start", "midpoint"),
  ci = c("none", "normal", "bootstrap"),
  B = 100,
  legend.pos = NULL,
  xlab = "Time",
  ylab = "Survival probability",
  lty = 1,
  lwd = 1,
  col = "red",
  lty.ci = 2,
  lwd.ci = 1,
  col.ci = "red",
  mark.time = TRUE,
  col.surv = "blue",
  lty.surv = 2,
  lwd.surv = 1,
  survdata = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.survfit.msm_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+msm">msm</a></code>, representing a fitted multi-state
model object.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_from">from</code></td>
<td>
<p>Non-absorbing state from which to consider survival.  Defaults
to state 1.  The fitted probabilities will then be calculated as the
transition probabilities from this state to <code>to</code>.  The empirical
survival curve plots survival from the first observation of <code>from</code>
(where this exists) to the first entry time into <code>to</code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_to">to</code></td>
<td>
<p>Absorbing state to consider. Defaults to the highest-labelled
absorbing state.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_range">range</code></td>
<td>
<p>Vector of two elements, giving the range of times to plot for.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_covariates">covariates</code></td>
<td>
<p>Covariate values for which to evaluate the expected
probabilities.  This can either be:<br />
</p>
<p>the string <code>"mean"</code>, denoting the means of the covariates in the data
(this is the default),<br />
</p>
<p>the number <code>0</code>, indicating that all the covariates should be set to
zero,<br />
</p>
<p>or a list of values, with optional names. For example
</p>
<p><code>list (60, 1)</code>
</p>
<p>where the order of the list follows the order of the covariates originally
given in the model formula, or a named list,
</p>
<p><code>list (age = 60, sex = 1)</code>
</p>
<p>but note the empirical curve is plotted for the full population.  To
consider subsets for the empirical curve, set <code>survdata=TRUE</code> to
extract the survival data and build a survival plot by hand using
<code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_interp">interp</code></td>
<td>
<p>If <code>interp="start"</code> (the default) then the entry time
into the absorbing state is assumed to be the time it is first observed in
the data.
</p>
<p>If <code>interp="midpoint"</code> then the entry time into the absorbing state is
assumed to be halfway between the time it is first observed and the previous
observation time. This is generally more reasonable for &quot;progressive&quot; models
with observations at arbitrary times.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"none"</code> (the default) no confidence intervals are
plotted.  If <code>"normal"</code> or <code>"bootstrap"</code>, confidence intervals are
plotted based on the respective method in <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>. This is
very computationally-intensive, since intervals must be computed at a series
of times.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap or normal replicates for the confidence
interval.  The default is 100 rather than the usual 1000, since these plots
are for rough diagnostic purposes.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Vector of the <code class="reqn">x</code> and <code class="reqn">y</code> position, respectively,
of the legend.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_xlab">xlab</code></td>
<td>
<p>x axis label.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_ylab">ylab</code></td>
<td>
<p>y axis label.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_lty">lty</code></td>
<td>
<p>Line type for the fitted curve. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_lwd">lwd</code></td>
<td>
<p>Line width for the fitted curve. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_col">col</code></td>
<td>
<p>Colour for the fitted curve. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_lty.ci">lty.ci</code></td>
<td>
<p>Line type for the fitted curve confidence limits. See
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_lwd.ci">lwd.ci</code></td>
<td>
<p>Line width for the fitted curve confidence limits. See
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_col.ci">col.ci</code></td>
<td>
<p>Colour for the fitted curve confidence limits. See
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_mark.time">mark.time</code></td>
<td>
<p>Mark the empirical survival curve at each censoring point,
see <code><a href="survival.html#topic+lines.survfit">lines.survfit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_col.surv">col.surv</code></td>
<td>
<p>Colour for the empirical survival curve, passed to
<code><a href="survival.html#topic+lines.survfit">lines.survfit</a></code>. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_lty.surv">lty.surv</code></td>
<td>
<p>Line type for the empirical survival curve, passed to
<code><a href="survival.html#topic+lines.survfit">lines.survfit</a></code>. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_lwd.surv">lwd.surv</code></td>
<td>
<p>Line width for the empirical survival curve, passed to
<code><a href="survival.html#topic+lines.survfit">lines.survfit</a></code>. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_survdata">survdata</code></td>
<td>
<p>Set to <code>TRUE</code> to return the survival data frame
constructed when plotting the empirical curve.  This can be used for
constructing survival plots by hand using
<code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.msm_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="base.html#topic+plot">plot</a></code> function
which draws the fitted curve, or the <code><a href="survival.html#topic+lines.survfit">lines.survfit</a></code>
function which draws the empirical curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the data represent observations of the process at arbitrary times, then
the first occurrence of the absorbing state in the data will usually be
greater than the actual first transition time to that state.  Therefore the
Kaplan-Meier estimate of the survival probability will be an overestimate.
</p>
<p>The method of Turnbull (1976) could be used to give a non-parametric
estimate of the time to an interval-censored event, and compared to the
equivalent estimate from a multi-state model.  This is implemented in the
CRAN package <span class="pkg">interval</span> (Fay and Shaw 2010).
</p>
<p>This currently only handles time-homogeneous models.
</p>


<h3>References</h3>

<p>Turnbull, B. W. (1976) The empirical distribution function with
arbitrarily grouped, censored and truncated data. J. R. Statist. Soc. B 38,
290-295.
</p>
<p>Fay, MP and Shaw, PA (2010). Exact and Asymptotic Weighted Logrank Tests for
Interval Censored Data: The interval R package. Journal of Statistical
Software. http://www.jstatsoft.org/v36/ i02/. 36 (2):1-34.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survfit">survfit</a></code>,
<code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>, <code><a href="#topic+plot.prevalence.msm">plot.prevalence.msm</a></code>
</p>

<hr>
<h2 id='plotprog.msm'>Kaplan Meier estimates of incidence</h2><span id='topic+plotprog.msm'></span>

<h3>Description</h3>

<p>Compute and plot Kaplan-Meier estimates of the probability that each
successive state has not occurred yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotprog.msm(
  formula,
  subject,
  data,
  legend.pos = NULL,
  xlab = "Time",
  ylab = "1 - incidence probability",
  lwd = 1,
  xlim = NULL,
  mark.time = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotprog.msm_+3A_formula">formula</code></td>
<td>
<p>A formula giving the vectors containing the observed states
and the corresponding observation times. For example,
</p>
<p><code>state ~ time</code>
</p>
<p>Observed states should be in the set <code>1, ...{}, n</code>, where <code>n</code> is
the number of states.</p>
</td></tr>
<tr><td><code id="plotprog.msm_+3A_subject">subject</code></td>
<td>
<p>Vector of subject identification numbers for the data
specified by <code>formula</code>. If missing, then all observations are assumed
to be on the same subject. These must be sorted so that all observations on
the same subject are adjacent.</p>
</td></tr>
<tr><td><code id="plotprog.msm_+3A_data">data</code></td>
<td>
<p>An optional data frame in which the variables represented by
<code>state</code>, <code>time</code> and <code>subject</code> can be found.</p>
</td></tr>
<tr><td><code id="plotprog.msm_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Vector of the <code class="reqn">x</code> and <code class="reqn">y</code> position, respectively,
of the legend.</p>
</td></tr>
<tr><td><code id="plotprog.msm_+3A_xlab">xlab</code></td>
<td>
<p>x axis label.</p>
</td></tr>
<tr><td><code id="plotprog.msm_+3A_ylab">ylab</code></td>
<td>
<p>y axis label.</p>
</td></tr>
<tr><td><code id="plotprog.msm_+3A_lwd">lwd</code></td>
<td>
<p>Line width. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotprog.msm_+3A_xlim">xlim</code></td>
<td>
<p>x axis limits, e.g. c(0,10) for an axis ranging from 0 to 10.
Default is the range of observation times.</p>
</td></tr>
<tr><td><code id="plotprog.msm_+3A_mark.time">mark.time</code></td>
<td>
<p>Mark the empirical survival curve at each censoring point,
see <code><a href="survival.html#topic+lines.survfit">lines.survfit</a></code>.</p>
</td></tr>
<tr><td><code id="plotprog.msm_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="base.html#topic+plot">plot</a></code> and
<code><a href="survival.html#topic+lines.survfit">lines.survfit</a></code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the data represent observations of the process at arbitrary times, then
the first occurrence of the state in the data will usually be greater than
the actual first transition time to that state.  Therefore the probabilities
plotted by <code><a href="#topic+plotprog.msm">plotprog.msm</a></code> will be overestimates.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survfit">survfit</a></code>,
<code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>
</p>

<hr>
<h2 id='pmatrix.msm'>Transition probability matrix</h2><span id='topic+pmatrix.msm'></span>

<h3>Description</h3>

<p>Extract the estimated transition probability matrix from a fitted
continuous-time multi-state model for a given time interval, at a given set
of covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmatrix.msm(
  x = NULL,
  t = 1,
  t1 = 0,
  covariates = "mean",
  ci = c("none", "normal", "bootstrap"),
  cl = 0.95,
  B = 1000,
  cores = NULL,
  qmatrix = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmatrix.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="pmatrix.msm_+3A_t">t</code></td>
<td>
<p>The time interval to estimate the transition probabilities for, by
default one unit.</p>
</td></tr>
<tr><td><code id="pmatrix.msm_+3A_t1">t1</code></td>
<td>
<p>The starting time of the interval. Used for models <code>x</code> with
piecewise-constant intensities fitted using the <code>pci</code> option to
<code><a href="#topic+msm">msm</a></code>. The probabilities will be computed on the interval [t1,
t1+t].</p>
</td></tr>
<tr><td><code id="pmatrix.msm_+3A_covariates">covariates</code></td>
<td>
<p>The covariate values at which to estimate the transition
probabilities.  This can either be:<br />
</p>
<p>the string <code>"mean"</code>, denoting the means of the covariates in the data
(this is the default),<br />
</p>
<p>the number <code>0</code>, indicating that all the covariates should be set to
zero,<br />
</p>
<p>or a list of values, with optional names. For example
</p>
<p><code>list (60, 1)</code>
</p>
<p>where the order of the list follows the order of the covariates originally
given in the model formula, or a named list,
</p>
<p><code>list (age = 60, sex = 1)</code>
</p>
<p>If some covariates are specified but not others, the missing ones default to
zero.
</p>
<p>For time-inhomogeneous models fitted using the <code>pci</code> option to
<code><a href="#topic+msm">msm</a></code>, &quot;covariates&quot; here include only those specified using the
<code>covariates</code> argument to <code><a href="#topic+msm">msm</a></code>, and exclude the artificial
covariates representing the time period.
</p>
<p>For time-inhomogeneous models fitted &quot;by hand&quot; by using a time-dependent
covariate in the <code>covariates</code> argument to <code><a href="#topic+msm">msm</a></code>, the
function <code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code> should be used to to calculate
transition probabilities.</p>
</td></tr>
<tr><td><code id="pmatrix.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"normal"</code>, then calculate a confidence interval for the
transition probabilities by simulating <code>B</code> random vectors from the
asymptotic multivariate normal distribution implied by the maximum
likelihood estimates (and covariance matrix) of the log transition
intensities and covariate effects, then calculating the resulting transition
probability matrix for each replicate. See, e.g. Mandel (2013) for a
discussion of this approach.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.
</p>
<p>If <code>"none"</code> (the default) then no confidence interval is calculated.</p>
</td></tr>
<tr><td><code id="pmatrix.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval, relative to 1.</p>
</td></tr>
<tr><td><code id="pmatrix.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates, or number of normal simulations
from the distribution of the MLEs</p>
</td></tr>
<tr><td><code id="pmatrix.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="pmatrix.msm_+3A_qmatrix">qmatrix</code></td>
<td>
<p>A transition intensity matrix.  Either this or a fitted model
<code>x</code> must be supplied.  No confidence intervals are available if
<code>qmatrix</code> is supplied.</p>
</td></tr>
<tr><td><code id="pmatrix.msm_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+MatrixExp">MatrixExp</a></code> to
control the method of computing the matrix exponential.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a continuous-time homogeneous Markov process with transition intensity
matrix <code class="reqn">Q</code>, the probability of occupying state <code class="reqn">s</code> at time <code class="reqn">u +
t</code> conditionally on occupying state <code class="reqn">r</code> at time <code class="reqn">u</code> is given by the
<code class="reqn">(r,s)</code> entry of the matrix <code class="reqn">P(t) = \exp(tQ)</code>, where
<code class="reqn">\exp()</code> is the matrix exponential.
</p>
<p>For non-homogeneous processes, where covariates and hence the transition
intensity matrix <code class="reqn">Q</code> are piecewise-constant in time, the transition
probability matrix is calculated as a product of matrices over a series of
intervals, as explained in <code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code>.
</p>
<p>The <code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code> function is only necessary for
models fitted using a time-dependent covariate in the <code>covariates</code>
argument to <code><a href="#topic+msm">msm</a></code>. For time-inhomogeneous models fitted using
&quot;pci&quot;, <code>pmatrix.msm</code> can be used, with arguments <code>t</code> and
<code>t1</code>, to calculate transition probabilities over any time period.
</p>


<h3>Value</h3>

<p>The matrix of estimated transition probabilities <code class="reqn">P(t)</code> in the
given time.  Rows correspond to &quot;from-state&quot; and columns to &quot;to-state&quot;.
</p>
<p>Or if <code>ci="normal"</code> or <code>ci="bootstrap"</code>, <code>pmatrix.msm</code>
returns a list with components <code>estimates</code> and <code>ci</code>, where
<code>estimates</code> is the matrix of estimated transition probabilities, and
<code>ci</code> is a list of two matrices containing the upper and lower
confidence limits.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>.
</p>


<h3>References</h3>

<p>Mandel, M. (2013). &quot;Simulation based confidence intervals for
functions with complicated derivatives.&quot; The American Statistician
67(2):76-81
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>, <code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code>,
<code><a href="#topic+boot.msm">boot.msm</a></code>
</p>

<hr>
<h2 id='pmatrix.piecewise.msm'>Transition probability matrix for processes with piecewise-constant
intensities</h2><span id='topic+pmatrix.piecewise.msm'></span>

<h3>Description</h3>

<p>Extract the estimated transition probability matrix from a fitted
non-time-homogeneous multi-state model for a given time interval.  This is a
generalisation of <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code> to models with time-dependent
covariates.  Note that <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code> is sufficient to calculate
transition probabilities for time-inhomogeneous models fitted using the
<code>pci</code> argument to <code><a href="#topic+msm">msm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmatrix.piecewise.msm(
  x = NULL,
  t1,
  t2,
  times,
  covariates,
  ci = c("none", "normal", "bootstrap"),
  cl = 0.95,
  B = 1000,
  cores = NULL,
  qlist = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmatrix.piecewise.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>. This
should be a non-homogeneous model, whose transition intensity matrix depends
on a time-dependent covariate.</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_t1">t1</code></td>
<td>
<p>The start of the time interval to estimate the transition
probabilities for.</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_t2">t2</code></td>
<td>
<p>The end of the time interval to estimate the transition
probabilities for.</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_times">times</code></td>
<td>
<p>Cut points at which the transition intensity matrix changes.</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_covariates">covariates</code></td>
<td>
<p>A list with number of components one greater than the
length of <code>times</code>.  Each component of the list is specified in the same
way as the <code>covariates</code> argument to <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>.  The
components correspond to the covariate values in the intervals
</p>
<p><code>(t1, times[1]], (times[1], times[2]], ..., (times[length(times)], t2]</code>
</p>
<p>(assuming that all elements of <code>times</code> are in the interval <code>(t1,
t2)</code>).</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"normal"</code>, then calculate a confidence interval for the
transition probabilities by simulating <code>B</code> random vectors from the
asymptotic multivariate normal distribution implied by the maximum
likelihood estimates (and covariance matrix) of the log transition
intensities and covariate effects, then calculating the resulting transition
probability matrix for each replicate.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.
</p>
<p>If <code>"none"</code> (the default) then no confidence interval is calculated.</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval, relative to 1.</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates, or number of normal simulations
from the distribution of the MLEs</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_qlist">qlist</code></td>
<td>
<p>A list of transition intensity matrices, of length one greater
than the length of <code>times</code>.  Either this or a fitted model <code>x</code>
must be supplied.  No confidence intervals are available if (just)
<code>qlist</code> is supplied.</p>
</td></tr>
<tr><td><code id="pmatrix.piecewise.msm_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+MatrixExp">MatrixExp</a></code> to
control the method of computing the matrix exponential.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose a multi-state model has been fitted, in which the transition
intensity matrix <code class="reqn">Q(x(t))</code> is modelled in terms of time-dependent
covariates <code class="reqn">x(t)</code>.  The transition probability matrix <code class="reqn">P(t_1,
t_n)</code> for the time interval <code class="reqn">(t_1, </code><code class="reqn">
t_n)</code> cannot be calculated from the estimated intensity matrix as
<code class="reqn">\exp((t_n - t_1) Q)</code>, because <code class="reqn">Q</code> varies within
the interval <code class="reqn">t_1, t_n</code>.  However, if the covariates are
piecewise-constant, or can be approximated as piecewise-constant, then we
can calculate <code class="reqn">P(t_1, t_n)</code> by multiplying together
individual matrices <code class="reqn">P(t_i, </code><code class="reqn"> t_{i+1}) = \exp((t_{i+1} - t_i) Q)</code>, calculated over intervals where Q is constant:
</p>
<p style="text-align: center;"><code class="reqn">P(t_1, t_n) = P(t_1, t_2) P(t_2, t_3)\ldots P(t_{n-1}, </code>
</p>
<p style="text-align: center;"><code class="reqn"> t_n)</code>
</p>



<h3>Value</h3>

<p>The matrix of estimated transition probabilities <code class="reqn">P(t)</code> for the
time interval <code>[t1, tn]</code>.  That is, the probabilities of occupying
state <code class="reqn">s</code> at time <code class="reqn">t_n</code> conditionally on occupying state <code class="reqn">r</code>
at time <code class="reqn">t_1</code>.  Rows correspond to &quot;from-state&quot; and columns to
&quot;to-state&quot;.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## In a clinical study, suppose patients are given a placebo in the
## first 5 weeks, then they begin treatment 1 at 5 weeks, and
## a combination of treatments 1 and 2 from 10 weeks.
## Suppose a multi-state model x has been fitted for the patients'
## progress, with treat1 and treat2 as time dependent covariates.

## Cut points for when treatment covariate changes
times &lt;- c(0, 5, 10)

## Indicators for which treatments are active in the four intervals
## defined by the three cut points
covariates &lt;- list( list (treat1=0, treat2=0), list (treat1=0, treat2=0), list(treat1=1, treat2=0),
list(treat1=1, treat2=1) )

## Calculate transition probabilities from the start of the study to 15 weeks
pmatrix.piecewise.msm(x, 0, 15, times, covariates)

## End(Not run)

</code></pre>

<hr>
<h2 id='pnext.msm'>Probability of each state being next</h2><span id='topic+pnext.msm'></span>

<h3>Description</h3>

<p>Compute a matrix of the probability of each state <code class="reqn">s</code> being the next
state of the process after each state <code class="reqn">r</code>.  Together with the mean
sojourn times in each state (<code><a href="#topic+sojourn.msm">sojourn.msm</a></code>), these fully define
a continuous-time Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnext.msm(
  x,
  covariates = "mean",
  ci = c("normal", "bootstrap", "delta", "none"),
  cl = 0.95,
  B = 1000,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnext.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="pnext.msm_+3A_covariates">covariates</code></td>
<td>
<p>The covariate values at which to estimate the intensities.
This can either be:<br />
</p>
<p>the string <code>"mean"</code>, denoting the means of the covariates in the data
(this is the default),<br />
</p>
<p>the number <code>0</code>, indicating that all the covariates should be set to
zero,<br />
</p>
<p>or a list of values, with optional names. For example
</p>
<p><code>list (60, 1)</code>
</p>
<p>where the order of the list follows the order of the covariates originally
given in the model formula, or a named list,
</p>
<p><code>list (age = 60, sex = 1)</code></p>
</td></tr>
<tr><td><code id="pnext.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"normal"</code> (the default) then calculate a confidence
interval by simulating <code>B</code> random vectors from the asymptotic
multivariate normal distribution implied by the maximum likelihood estimates
(and covariance matrix) of the log transition intensities and covariate
effects, then transforming.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.
</p>
<p>If <code>"delta"</code> then confidence intervals are calculated based on the
delta method SEs of the log rates, but this is not recommended since it may
not respect the constraint that probabilities are less than one.</p>
</td></tr>
<tr><td><code id="pnext.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval to present.  Defaults
to 0.95.</p>
</td></tr>
<tr><td><code id="pnext.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates, or number of normal simulations
from the distribution of the MLEs.</p>
</td></tr>
<tr><td><code id="pnext.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a continuous-time Markov process in state <code class="reqn">r</code>, the probability that
the next state is <code class="reqn">s</code> is <code class="reqn">-q_{rs} / q_{rr}</code>, where <code class="reqn">q_{rs}</code> is
the transition intensity (<code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>).
</p>
<p>A continuous-time Markov model is fully specified by these probabilities
together with the mean sojourn times <code class="reqn">-1/q_{rr}</code> in each state <code class="reqn">r</code>.
This gives a more intuitively meaningful description of a model than the
intensity matrix.
</p>
<p>Remember that <span class="pkg">msm</span> deals with continuous-time, not discrete-time
models, so these are <em>not</em> the same as the probability of observing
state <code class="reqn">s</code> at a fixed time in the future.  Those probabilities are given
by <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>.
</p>


<h3>Value</h3>

<p>The matrix of probabilities that the next move of a process in state
<code class="reqn">r</code> (rows) is to state <code class="reqn">s</code> (columns).
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>,<code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>,<code><a href="#topic+qratio.msm">qratio.msm</a></code>
</p>

<hr>
<h2 id='ppass.msm'>Passage probabilities</h2><span id='topic+ppass.msm'></span>

<h3>Description</h3>

<p>Probabilities of having visited each state by a particular time in a
continuous time Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppass.msm(
  x = NULL,
  qmatrix = NULL,
  tot,
  start = "all",
  covariates = "mean",
  piecewise.times = NULL,
  piecewise.covariates = NULL,
  ci = c("none", "normal", "bootstrap"),
  cl = 0.95,
  B = 1000,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppass.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_qmatrix">qmatrix</code></td>
<td>
<p>Instead of <code>x</code>, you can simply supply a transition
intensity matrix in <code>qmatrix</code>.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_tot">tot</code></td>
<td>
<p>Finite time to forecast the passage probabilites for.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_start">start</code></td>
<td>
<p>Starting state (integer).  By default (<code>start="all"</code>),
this will return a matrix one row for each starting state.
</p>
<p>Alternatively, this can be used to obtain passage probabilities from a
<em>set</em> of states, rather than single states.  To achieve this,
<code>state</code> is set to a vector of weights, with length equal to the number
of states in the model.  These weights should be proportional to the
probability of starting in each of the states in the desired set, so that
weights of zero are supplied for other states.  The function will calculate
the weighted average of the passage probabilities from each of the
corresponding states.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_covariates">covariates</code></td>
<td>
<p>Covariate values defining the intensity matrix for the
fitted model <code>x</code>, as supplied to <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_piecewise.times">piecewise.times</code></td>
<td>
<p>Currently ignored: not implemented for
time-inhomogeneous models.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_piecewise.covariates">piecewise.covariates</code></td>
<td>
<p>Currently ignored: not implemented for
time-inhomogeneous models.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"normal"</code>, then calculate a confidence interval by
simulating <code>B</code> random vectors from the asymptotic multivariate normal
distribution implied by the maximum likelihood estimates (and covariance
matrix) of the log transition intensities and covariate effects.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.
</p>
<p>If <code>"none"</code> (the default) then no confidence interval is calculated.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval, relative to 1.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="ppass.msm_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+MatrixExp">MatrixExp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The passage probabilities to state <code class="reqn">s</code> are computed by setting the
<code class="reqn">s</code>th row of the transition intensity matrix <code class="reqn">Q</code> to zero, giving an
intensity matrix <code class="reqn">Q*</code> for a simplified model structure where state
<code class="reqn">s</code> is absorbing.  The probabilities of passage are then equivalent to
row <code class="reqn">s</code> of the transition probability matrix <code class="reqn">Exp(tQ*)</code> under this
simplified model for <code class="reqn">t=</code><code>tot</code>.
</p>
<p>Note this is different from the probability of occupying each state at
exactly time <code class="reqn">t</code>, given by <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>.  The passage
probability allows for the possibility of having visited the state before
<code class="reqn">t</code>, but then occupying a different state at <code class="reqn">t</code>.
</p>
<p>The mean of the passage distribution is the expected first passage time,
<code><a href="#topic+efpt.msm">efpt.msm</a></code>.
</p>
<p>This function currently only handles time-homogeneous Markov models.  For
time-inhomogeneous models the covariates are held constant at the value
supplied, by default the column means of the design matrix over all
observations.
</p>


<h3>Value</h3>

<p>A matrix whose <code class="reqn">r, s</code> entry is the probability of having visited
state <code class="reqn">s</code> at least once before time <code class="reqn">t</code>, given the state at time
<code class="reqn">0</code> is <code class="reqn">r</code>.  The diagonal entries should all be 1.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Norris, J. R. (1997) Markov Chains. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efpt.msm">efpt.msm</a></code>, <code><a href="#topic+totlos.msm">totlos.msm</a></code>,
<code><a href="#topic+boot.msm">boot.msm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Q &lt;- rbind(c(-0.5, 0.25, 0, 0.25), c(0.166, -0.498, 0.166, 0.166),
           c(0, 0.25, -0.5, 0.25), c(0, 0, 0, 0))

## ppass[1,2](t) converges to 0.5 with t, since given in state 1, the
## probability of going to the absorbing state 4 before visiting state
## 2 is 0.5, and the chance of still being in state 1 at t decreases.

ppass.msm(qmatrix=Q, tot=2)
ppass.msm(qmatrix=Q, tot=20)
ppass.msm(qmatrix=Q, tot=100)

Q &lt;- Q[1:3,1:3]; diag(Q) &lt;- 0; diag(Q) &lt;- -rowSums(Q)

## Probability of about 1/2 of visiting state 3 by time 10.5, the
## median first passage time

ppass.msm(qmatrix=Q, tot=10.5)

## Mean first passage time from state 2 to state 3 is 10.02: similar
## to the median

efpt.msm(qmatrix=Q, tostate=3)

</code></pre>

<hr>
<h2 id='prevalence.msm'>Tables of observed and expected prevalences</h2><span id='topic+prevalence.msm'></span>

<h3>Description</h3>

<p>This provides a rough indication of the goodness of fit of a multi-state
model, by estimating the observed numbers of individuals occupying each
state at a series of times, and comparing these with forecasts from the
fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prevalence.msm(
  x,
  times = NULL,
  timezero = NULL,
  initstates = NULL,
  covariates = "population",
  misccovariates = "mean",
  piecewise.times = NULL,
  piecewise.covariates = NULL,
  ci = c("none", "normal", "bootstrap"),
  cl = 0.95,
  B = 1000,
  cores = NULL,
  interp = c("start", "midpoint"),
  censtime = Inf,
  subset = NULL,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prevalence.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model produced by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_times">times</code></td>
<td>
<p>Series of times at which to compute the observed and expected
prevalences of states.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_timezero">timezero</code></td>
<td>
<p>Initial time of the Markov process. Expected values are
forecasted from here. Defaults to the minimum of the observation times given
in the data.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_initstates">initstates</code></td>
<td>
<p>Optional vector of the same length as the number of
states. Gives the numbers of individuals occupying each state at the initial
time, to be used for forecasting expected prevalences.  The default is those
observed in the data.  These should add up to the actual number of people in
the study at the start.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_covariates">covariates</code></td>
<td>
<p>Covariate values for which to forecast expected state
occupancy.  With the default <code>covariates="population"</code>, expected
prevalences are produced by summing model predictions over the covariates
observed in the original data, for a fair comparison with the observed
prevalences.  This may be slow, particularly with continuous covariates.
</p>
<p>Predictions for fixed covariates can be obtained by supplying covariate
values in the standard way, as in <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>. Therefore if
<code>covariates="population"</code> is too slow, using the mean observed values
through <code>covariates="mean"</code> may give a reasonable approximation.
</p>
<p>This argument is ignored if <code>piecewise.times</code> is specified. If there
are a mixture of time-constant and time-dependent covariates, then the
values for all covariates should be supplied in <code>piecewise.covariates</code>.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_misccovariates">misccovariates</code></td>
<td>
<p>(Misclassification models only) Values of covariates
on the misclassification probability matrix for converting expected true to
expected misclassified states.  Ignored if <code>covariates="population"</code>,
otherwise defaults to the mean values of the covariates in the data set.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_piecewise.times">piecewise.times</code></td>
<td>
<p>Times at which piecewise-constant intensities change.
See <code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code> for how to specify this.  Ignored if
<code>covariates="population"</code>.  This is only required for
time-inhomogeneous models specified using explicit time-dependent
covariates, and should not be used for models specified using &quot;pci&quot;.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_piecewise.covariates">piecewise.covariates</code></td>
<td>
<p>Covariates on which the piecewise-constant
intensities depend. See <code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code> for how to
specify this. Ignored if <code>covariates="population"</code>.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"normal"</code>, then calculate a confidence interval for the
expected prevalences by simulating <code>B</code> random vectors from the
asymptotic multivariate normal distribution implied by the maximum
likelihood estimates (and covariance matrix) of the log transition
intensities and covariate effects, then calculating the expected prevalences
for each replicate.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.
</p>
<p>If <code>"none"</code> (the default) then no confidence interval is calculated.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval, relative to 1</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_interp">interp</code></td>
<td>
<p>Suppose an individual was observed in states <code class="reqn">S_{r-1}</code> and
<code class="reqn">S_r</code> at two consecutive times <code class="reqn">t_{r-1}</code> and <code class="reqn">t_r</code>, and we want
to estimate 'observed' prevalences at a time <code class="reqn">t</code> between <code class="reqn">t_{r-1}</code>
and <code class="reqn">t_r</code>.
</p>
<p>If <code>interp="start"</code>, then individuals are assumed to be in state
<code class="reqn">S_{r-1}</code> at time <code class="reqn">t</code>, the same state as they were at <code class="reqn">t_{r-1}</code>.
</p>
<p>If <code>interp="midpoint"</code> then if <code class="reqn">t &lt;= (t_{r-1} + t_r) / 2</code>, the
midpoint of <code class="reqn">t_{r-1}</code> and <code class="reqn">t_r</code>, the state at <code class="reqn">t</code> is assumed to
be <code class="reqn">S_{r-1}</code>, otherwise <code class="reqn">S_{r}</code>. This is generally more reasonable
for &quot;progressive&quot; models.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_censtime">censtime</code></td>
<td>
<p>Adjustment to the observed prevalences to account for
limited follow-up in the data.
</p>
<p>If the time is greater than <code>censtime</code> and the patient has reached an
absorbing state, then that subject will be removed from the risk set.  For
example, if patients have died but would only have been observed up to this
time, then this avoids overestimating the proportion of people who are dead
at later times.
</p>
<p>This can be supplied as a single value, or as a vector with one element per
subject (after any <code>subset</code> has been taken), in the same order as the
original data.  This vector also only includes subjects with complete data,
thus it excludes for example subjects with only one observation (thus no
observed transitions), and subjects for whom every observation has missing
values.  (Note, to help construct this, the complete data used for the model
fit can be accessed with <code>model.frame(x)</code>, where <code>x</code> is the fitted
model object)
</p>
<p>This is ignored if it is less than the subject's maximum observation time.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_subset">subset</code></td>
<td>
<p>Subset of subjects to calculate observed prevalences for.</p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_plot">plot</code></td>
<td>
<p>Generate a plot of observed against expected prevalences. See
<code><a href="#topic+plot.prevalence.msm">plot.prevalence.msm</a></code></p>
</td></tr>
<tr><td><code id="prevalence.msm_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="#topic+plot.prevalence.msm">plot.prevalence.msm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitted transition probability matrix is used to forecast expected
prevalences from the state occupancy at the initial time.  To produce the
expected number in state <code class="reqn">j</code> at time <code class="reqn">t</code> after the start, the number
of individuals under observation at time <code class="reqn">t</code> (including those who have
died, but not those lost to follow-up) is multiplied by the product of the
proportion of individuals in each state at the initial time and the
transition probability matrix in the time interval <code class="reqn">t</code>.  The proportion
of individuals in each state at the &quot;initial&quot; time is estimated, if
necessary, in the same way as the observed prevalences.
</p>
<p>For misclassification models (fitted using an <code>ematrix</code>), this aims to
assess the fit of the full model for the <em>observed</em> states.  That is,
the combined Markov progression model for the true states and the
misclassification model. Thus, expected prevalences of <em>true</em> states
are estimated from the assumed proportion occupying each state at the
initial time using the fitted transition probabiliy matrix. The vector of
expected prevalences of true states is then multiplied by the fitted
misclassification probability matrix to obtain the expected prevalences of
<em>observed</em> states.
</p>
<p>For general hidden Markov models, the observed state is taken to be the
predicted underlying state from the Viterbi algorithm
(<code><a href="#topic+viterbi.msm">viterbi.msm</a></code>).  The goodness of fit of these states to the
underlying Markov model is tested.
</p>
<p>In any model, if there are censored states, then these are replaced by
imputed values of highest probability from the Viterbi algorithm in order to
calculate the observed state prevalences.
</p>
<p>For an example of this approach, see Gentleman <em>et al.</em> (1994).
</p>


<h3>Value</h3>

<p>A list of matrices, with components:
</p>
<table>
<tr><td><code>Observed</code></td>
<td>
<p>Table of observed numbers of individuals in each state at
each time</p>
</td></tr>
<tr><td><code>Observed percentages</code></td>
<td>
<p>Corresponding percentage of the individuals at
risk at each time.</p>
</td></tr>
<tr><td><code>Expected</code></td>
<td>
<p>Table of corresponding expected numbers.</p>
</td></tr>
<tr><td><code>Expected percentages</code></td>
<td>
<p>Corresponding percentage of the individuals at
risk at each time.</p>
</td></tr>
</table>
<p>Or if <code>ci.boot = TRUE</code>, the component <code>Expected</code> is a list with
components <code>estimates</code> and <code>ci</code>.<br /> <code>estimates</code> is a matrix
of the expected prevalences, and <code>ci</code> is a list of two matrices,
containing the confidence limits. The component <code>Expected percentages</code>
has a similar format.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Gentleman, R.C., Lawless, J.F., Lindsey, J.C. and Yan, P.
Multi-state Markov models for analysing incomplete disease history data with
illustrations for HIV disease.  <em>Statistics in Medicine</em> (1994) 13(3):
805&ndash;821.
</p>
<p>Titman, A.C., Sharples, L. D.  Model diagnostics for multi-state models.
<em>Statistical Methods in Medical Research</em> (2010) 19(6):621-651.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>, <code><a href="#topic+summary.msm">summary.msm</a></code>
</p>

<hr>
<h2 id='print.msm'>Print a fitted msm model object</h2><span id='topic+print.msm'></span><span id='topic+printnew.msm'></span>

<h3>Description</h3>

<p>Print a fitted msm model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msm'
print(x, covariates = NULL, digits = 4, ...)

printnew.msm(x, covariates = NULL, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.msm_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+msm">msm</a></code>, representing a fitted multi-state
model object.</p>
</td></tr>
<tr><td><code id="print.msm_+3A_covariates">covariates</code></td>
<td>
<p>Covariates for which to print &ldquo;baseline&rdquo; transition
intensities or misclassification probabilities. See
<code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="print.msm_+3A_digits">digits</code></td>
<td>
<p>Minimum number of significant digits, passed to
<code><a href="base.html#topic+format">format</a></code>. Defaults to 4.</p>
</td></tr>
<tr><td><code id="print.msm_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="base.html#topic+format">format</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the new method of formatting msm objects for printing.  The old
method was based on printing lists of matrices. That produced a lot of
wasted space for parameters which were zero, and it was difficult to match
corresponding numbers between matrices. The new method presents all the
transition intensities and covariate effects as a single compact table, and
likewise for misclassification matrices.
</p>
<p>Also in the old method, covariate effects were presented as log hazard
ratios or log odds ratios.  The log scale is more convenient mathematically,
but unnatural to interpret.  The new method presents hazard ratios for
covariates on transition intensities and odds ratios for misclassification
probabilities.
</p>
<p><code>printnew.msm</code> is an alias for <code>print.msm</code>.
</p>


<h3>Value</h3>

<p>The object returned by <code>print.msm</code> is a numeric matrix with one
column for each estimate or confidence limit for intensities and their
covariates, in the same arrangement as printed, but with the underlying
numbers in full precision.  The results formatted for printing are stored in
the <code>"formatted"</code> attribute of the object, as a character matrix.
These can alternatively be produced by <code><a href="#topic+msm.form.qoutput">msm.form.qoutput</a></code>, which
has no printing side-effect. <code><a href="#topic+msm.form.eoutput">msm.form.eoutput</a></code> produces the
same arrangement for misclassification probabilities instead of intensities.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>, <code><a href="#topic+printold.msm">printold.msm</a></code>,
<code><a href="#topic+msm.form.qoutput">msm.form.qoutput</a></code>.
</p>

<hr>
<h2 id='printold.msm'>Print a fitted msm model object</h2><span id='topic+printold.msm'></span>

<h3>Description</h3>

<p>Print a fitted msm model object (in old format, from msm 1.3.1 and earlier)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printold.msm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printold.msm_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+msm">msm</a></code>, representing a fitted multi-state
model object.</p>
</td></tr>
<tr><td><code id="printold.msm_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="base.html#topic+format">format</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+print.msm">print.msm</a></code> for a better and cleaner output format, and an
explanation of the change.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.msm">print.msm</a></code>
</p>

<hr>
<h2 id='psor'>Psoriatic arthritis data</h2><span id='topic+psor'></span>

<h3>Description</h3>

<p>A series of observations of grades of psoriatic arthritis, as indicated by
numbers of damaged joints.
</p>


<h3>Format</h3>

<p>A data frame containing 806 observations, representing visits to a
psoriatic arthritis (PsA) clinic from 305 patients.  The rows are grouped by
patient number and ordered by examination time. Each row represents an
examination and contains additional covariates.
</p>

<table>
<tr>
 <td style="text-align: right;"> <code>ptnum</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Patient identification
number </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>months</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Examination time in months </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>state</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Clinical state of PsA.  Patients in states
1, 2, 3 and 4 </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> have 0, 1 to 4, 5 to 9 and 10 or more damaged
joints, </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> respectively.  </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>hieffusn</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;">
Presence of five or more effusions </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>ollwsdrt</code> </td><td style="text-align: left;"> (character) </td><td style="text-align: left;">
Erythrocyte sedimentation rate of less than 15 mm/h </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>



<h3>References</h3>

<p>Gladman, D. D. and Farewell, V.T. (1999) Progression in
psoriatic arthritis: role of time-varying clinical indicators.  J.
Rheumatol. 26(11):2409-13
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Four-state progression-only model with high effusion and low
## sedimentation rate as covariates on the progression rates.  High
## effusion is assumed to have the same effect on the 1-2, 2-3, and 3-4
## progression rates, while low sedimentation rate has the same effect
## on the 1-2 and 2-3 intensities, but a different effect on the 3-4. 

data(psor)
psor.q &lt;- rbind(c(0,0.1,0,0),c(0,0,0.1,0),c(0,0,0,0.1),c(0,0,0,0))
psor.msm &lt;- msm(state ~ months, subject=ptnum, data=psor, 
                qmatrix = psor.q, covariates = ~ollwsdrt+hieffusn,
                constraint = list(hieffusn=c(1,1,1),ollwsdrt=c(1,1,2)),
                fixedpars=FALSE, control = list(REPORT=1,trace=2), method="BFGS")
qmatrix.msm(psor.msm)
sojourn.msm(psor.msm)
hazard.msm(psor.msm)

</code></pre>

<hr>
<h2 id='qcmodel.object'>Developer documentation: model for covariates on transition intensities</h2><span id='topic+qcmodel.object'></span>

<h3>Description</h3>

<p>A list representing the model for covariates on transition intensities
</p>


<h3>Value</h3>

<table>
<tr><td><code>npars</code></td>
<td>
<p>Number of covariate effect parameters.  This is defined
as the number of covariates on intensities (with factors expanded as
contrasts) multiplied by the number of allowed transitions in the model.
</p>
<p>Note if <code><a href="#topic+msm">msm</a></code> was called with <code>covariates</code> set to a list of
different covariates for different intensities, then this will include
covariate effects that are implicitly defined as zero by this list.  The
information in <code><a href="#topic+paramdata.object">paramdata</a></code> objects can be
used to identify wich ones are fixed at zero.
</p>
<p>This also includes any <code>timeperiod</code> covariates in a time-inhomogeneous
model defined by the <code>pci</code> option to <code><a href="#topic+msm">msm</a></code>.  </p>
</td></tr>
<tr><td><code>ndpars</code></td>
<td>
<p>Number of distinct covariate effect parameters, as
<code>npars</code>, but after any equality constraints have been applied.</p>
</td></tr>
<tr><td><code>ncovs</code></td>
<td>
<p>Number of covariates on intensities, with factors expanded as
contrasts.</p>
</td></tr> <tr><td><code>constr</code></td>
<td>
<p>List of equality constraints on these covariate
effects, as supplied in the <code>constraint</code> argument to
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>covlabels</code></td>
<td>
<p>Names / labels of these covariates in
the model matrix (see <code><a href="#topic+model.matrix.msm">model.matrix.msm</a></code>).</p>
</td></tr> <tr><td><code>inits</code></td>
<td>
<p>Initial
values for these covariate effects, as a vector formed from the
<code>covinits</code> list supplied to <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>covmeans</code></td>
<td>
<p>Means
of these covariates in the data (excluding data not required to fit the
model, such as observations with missing data in other elements or subjects'
last observations).  This includes means of 0/1 factor contrasts as well as
continuous covariates (for historic reasons, which may not be sensible).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+msm.object">msm.object</a></code>.
</p>

<hr>
<h2 id='qgeneric'>Generic function to find quantiles of a distribution</h2><span id='topic+qgeneric'></span>

<h3>Description</h3>

<p>Generic function to find the quantiles of a distribution, given the
equivalent probability distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgeneric(pdist, p, special = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qgeneric_+3A_pdist">pdist</code></td>
<td>
<p>Probability distribution function, for example,
<code><a href="stats.html#topic+pnorm">pnorm</a></code> for the normal distribution, which must be defined in
the current workspace.  This should accept and return vectorised parameters
and values.  It should also return the correct values for the entire real
line, for example a positive distribution should have <code>pdist(x)==0</code> for
<code class="reqn">x&lt;0</code>.</p>
</td></tr>
<tr><td><code id="qgeneric_+3A_p">p</code></td>
<td>
<p>Vector of probabilities to find the quantiles for.</p>
</td></tr>
<tr><td><code id="qgeneric_+3A_special">special</code></td>
<td>
<p>Vector of character strings naming arguments of the
distribution function that should not be vectorised over. Used, for example,
for the <code>rate</code> and <code>t</code> arguments in <code><a href="#topic+qpexp">qpexp</a></code>.</p>
</td></tr>
<tr><td><code id="qgeneric_+3A_...">...</code></td>
<td>
<p>The remaining arguments define parameters of the distribution
<code>pdist</code>.  These MUST be named explicitly.
</p>
<p>This may also contain the standard arguments <code>log.p</code> (logical; default
<code>FALSE</code>, if <code>TRUE</code>, probabilities p are given as log(p)), and
<code>lower.tail</code> (logical; if <code>TRUE</code> (default), probabilities are P[X
&lt;= x] otherwise, P[X &gt; x].).
</p>
<p>If the distribution is bounded above or below, then this should contain
arguments <code>lbound</code> and <code>ubound</code> respectively, and these will be
returned if <code>p</code> is 0 or 1 respectively.  Defaults to <code>-Inf</code> and
<code>Inf</code> respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to enable users to define <code>"q"</code> functions for
new distributions, in cases where the distribution function <code>pdist</code> is
available analytically, but the quantile function is not.
</p>
<p>It works by finding the root of the equation <code class="reqn">h(q) = pdist(q) - p = 0</code>.
Starting from the interval <code class="reqn">(-1, 1)</code>, the interval width is expanded by
50% until <code class="reqn">h()</code> is of opposite sign at either end.  The root is then
found using <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>
<p>This assumes a suitably smooth, continuous distribution.
</p>
<p>An identical function is provided in the <span class="pkg">flexsurv</span> package.
</p>


<h3>Value</h3>

<p>Vector of quantiles of the distribution at <code>p</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
qnorm(c(0.025, 0.975), 0, 1)
qgeneric(pnorm, c(0.025, 0.975), mean=0, sd=1) # must name the arguments

</code></pre>

<hr>
<h2 id='qmatrix.msm'>Transition intensity matrix</h2><span id='topic+qmatrix.msm'></span>

<h3>Description</h3>

<p>Extract the estimated transition intensity matrix, and the corresponding
standard errors, from a fitted multi-state model at a given set of covariate
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmatrix.msm(
  x,
  covariates = "mean",
  sojourn = FALSE,
  ci = c("delta", "normal", "bootstrap", "none"),
  cl = 0.95,
  B = 1000,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmatrix.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_covariates">covariates</code></td>
<td>
<p>The covariate values at which to estimate the intensity
matrix.  This can either be:<br />
</p>
<p>the string <code>"mean"</code>, denoting the means of the covariates in the data
(this is the default),<br />
</p>
<p>the number <code>0</code>, indicating that all the covariates should be set to
zero,<br />
</p>
<p>or a list of values, with optional names. For example
</p>
<p><code>list (60, 1)</code>
</p>
<p>where the order of the list follows the order of the covariates originally
given in the model formula. Or more clearly, a named list,
</p>
<p><code>list (age = 60, sex = 1)</code>
</p>
<p>If some covariates are specified but not others, the missing ones default to
zero.
</p>
<p>With <code>covariates="mean"</code>, for factor / categorical variables, the mean
of the 0/1 dummy variable for each factor level is used, representing an
average over all values in the data, rather than a specific factor level.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_sojourn">sojourn</code></td>
<td>
<p>Set to TRUE if the estimated sojourn times and their standard
errors should also be returned.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"delta"</code> (the default) then confidence intervals are
calculated by the delta method, or by simple transformation of the Hessian
in the very simplest cases.  Normality on the log scale is assumed.
</p>
<p>If <code>"normal"</code>, then calculate a confidence interval by simulating
<code>B</code> random vectors from the asymptotic multivariate normal distribution
implied by the maximum likelihood estimates (and covariance matrix) of the
log transition intensities and covariate effects, then transforming.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval to present.  Defaults
to 0.95.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates, or number of normal simulations
from the distribution of the MLEs.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transition intensities and covariate effects are estimated on the log scale
by <code><a href="#topic+msm">msm</a></code>. A covariance matrix is estimated from the Hessian of
the maximised log-likelihood.
</p>
<p>A more practically meaningful parameterisation of a continuous-time Markov
model with transition intensities <code class="reqn">q_{rs}</code> is in terms of the mean
sojourn times <code class="reqn">-1 / q_{rr}</code> in each state <code class="reqn">r</code> and the probabilities
that the next move of the process when in state <code class="reqn">r</code> is to state <code class="reqn">s</code>,
<code class="reqn">-q_{rs} / q_{rr}</code>.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>Estimated transition intensity matrix.</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>Corresponding approximate standard errors.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Lower confidence limits</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Upper confidence limits</p>
</td></tr>
</table>
<p>Or if <code>ci="none"</code>, then <code>qmatrix.msm</code> just returns the estimated
transition intensity matrix.
</p>
<p>If <code>sojourn</code> is <code>TRUE</code>, extra components called <code>sojourn</code>,
<code>sojournSE</code>, <code>sojournL</code> and <code>sojournU</code> are included,
containing the estimates, standard errors and confidence limits,
respectively, of the mean sojourn times in each transient state.
</p>
<p>The default print method for objects returned by <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>
presents estimates and confidence limits. To present estimates and standard
errors, do something like
</p>
<p><code>qmatrix.msm(x)[c("estimates","SE")]</code>
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>, <code><a href="#topic+sojourn.msm">sojourn.msm</a></code>,
<code><a href="#topic+deltamethod">deltamethod</a></code>, <code><a href="#topic+ematrix.msm">ematrix.msm</a></code>
</p>

<hr>
<h2 id='qmodel.object'>Developer documentation: transition model structure object</h2><span id='topic+qmodel.object'></span>

<h3>Description</h3>

<p>A list giving information about the structure of states and allowed
transitions in a multi-state model, and options for likelihood calculation.
Used in internal computations, and returned in a fitted <code><a href="#topic+msm">msm</a></code>
model object.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nstates</code></td>
<td>
<p>Number of states</p>
</td></tr> <tr><td><code>iso</code></td>
<td>
<p>Label for which basic
structure the model is isomorphic to in the list of structures for which
analytic formulae for the transition probabilities are implemented in the
source file <code>src/analyticp.c</code>.  This list is given by the internal
object <code>msm:::.msm.graphs</code> which is defined and documented in the
source file <code>R/constants.R</code>.
</p>
<p><code>iso</code> is 0 if the analytic P matrix is not implemented for this
structure, or if analytic P matrix calculations are disabled using
<code>use.analyticp=FALSE</code> in the call to <code><a href="#topic+msm">msm</a></code>.  </p>
</td></tr>
<tr><td><code>perm</code></td>
<td>
<p>Permutation required to convert the base isomorphism into the
structure of this model. A vector of integers whose <code class="reqn">r</code>th element is the
state number in the base structure representing state <code class="reqn">r</code> in the current
structure.  </p>
</td></tr> <tr><td><code>qperm</code></td>
<td>
<p>Inverse permutation: vector whose <code class="reqn">r</code>th
element is the state number in the current structure representing the
<code class="reqn">r</code>th state in the base structure.</p>
</td></tr> <tr><td><code>npars</code></td>
<td>
<p>Number of allowed
instantaneous transitions, equal to <code>sum(imatrix)</code>.</p>
</td></tr>
<tr><td><code>imatrix</code></td>
<td>
<p>Indicator matrix for allowed instantaneous transitions.  This
has <code class="reqn">(r,s)</code> entry 1 if the transition from <code class="reqn">r</code> to <code class="reqn">s</code> is
permitted in continuous time, and 0 otherwise.  The diagonal entries are
arbitrarily set to 0.</p>
</td></tr> <tr><td><code>qmatrix</code></td>
<td>
<p>Matrix of initial values for the
transition intensities, supplied as the <code>qmatrix</code> argument of
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr> <tr><td><code>inits</code></td>
<td>
<p>Vector of these initial values, reading
across rows of <code>qmatrix</code> and excluding the diagonal and disallowed
transitions.</p>
</td></tr> <tr><td><code>constr</code></td>
<td>
<p>Indicators for equality constraints on baseline
intensities, taken from the <code>qconstraint</code> argument to
<code><a href="#topic+msm">msm</a></code>, and mapped if necessary to the set (1,2,3,...).</p>
</td></tr>
<tr><td><code>ndpars</code></td>
<td>
<p>Number of distinct allowed instantaneous transitions, after
applying equality constraints.</p>
</td></tr> <tr><td><code>expm</code></td>
<td>
<p>Use <span class="pkg">expm</span> package to
calculate matrix exponentials for likelihoods, as supplied to the
<code>use.expm</code> argument of <code><a href="#topic+msm">msm</a></code>.  <code>TRUE</code> or
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+msm.object">msm.object</a></code>,<code><a href="#topic+emodel.object">emodel.object</a></code>,
<code><a href="#topic+hmodel.object">hmodel.object</a></code>.
</p>

<hr>
<h2 id='qratio.msm'>Estimated ratio of transition intensities</h2><span id='topic+qratio.msm'></span>

<h3>Description</h3>

<p>Compute the estimate and approximate standard error of the ratio of two
estimated transition intensities from a fitted multi-state model at a given
set of covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qratio.msm(
  x,
  ind1,
  ind2,
  covariates = "mean",
  ci = c("delta", "normal", "bootstrap", "none"),
  cl = 0.95,
  B = 1000,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qratio.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="qratio.msm_+3A_ind1">ind1</code></td>
<td>
<p>Pair of numbers giving the indices in the intensity matrix of
the numerator of the ratio, for example, <code>c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="qratio.msm_+3A_ind2">ind2</code></td>
<td>
<p>Pair of numbers giving the indices in the intensity matrix of
the denominator of the ratio, for example, <code>c(2,1)</code>.</p>
</td></tr>
<tr><td><code id="qratio.msm_+3A_covariates">covariates</code></td>
<td>
<p>The covariate values at which to estimate the intensities.
This can either be:<br />
</p>
<p>the string <code>"mean"</code>, denoting the means of the covariates in the data
(this is the default),<br />
</p>
<p>the number <code>0</code>, indicating that all the covariates should be set to
zero,<br />
</p>
<p>or a list of values, with optional names. For example
</p>
<p><code>list (60, 1)</code>
</p>
<p>where the order of the list follows the order of the covariates originally
given in the model formula, or a named list,
</p>
<p><code>list (age = 60, sex = 1)</code></p>
</td></tr>
<tr><td><code id="qratio.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"delta"</code> (the default) then confidence intervals are
calculated by the delta method.
</p>
<p>If <code>"normal"</code>, then calculate a confidence interval by simulating
<code>B</code> random vectors from the asymptotic multivariate normal distribution
implied by the maximum likelihood estimates (and covariance matrix) of the
log transition intensities and covariate effects, then transforming.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.</p>
</td></tr>
<tr><td><code id="qratio.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval to present.  Defaults
to 0.95.</p>
</td></tr>
<tr><td><code id="qratio.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates, or number of normal simulations
from the distribution of the MLEs</p>
</td></tr>
<tr><td><code id="qratio.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, we might want to compute the ratio of the progression rate and
recovery rate for a fitted model <code>disease.msm</code> with a health state
(state 1) and a disease state (state 2).  In this case, the progression rate
is the (1,2) entry of the intensity matrix, and the recovery rate is the
(2,1) entry.  Thus to compute this ratio with covariates set to their means,
we call
</p>
<p><code>qratio.msm(disease.msm, c(1,2), c(2,1))</code> .
</p>
<p>Standard errors are estimated by the delta method. Confidence limits are
estimated by assuming normality on the log scale.
</p>


<h3>Value</h3>

<p>A named vector with elements <code>estimate</code>, <code>se</code>, <code>L</code>
and <code>U</code> containing the estimate, standard error, lower and upper
confidence limits, respectively, of the ratio of intensities.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>
</p>

<hr>
<h2 id='recreate.olddata'>Convert data stored in msm object to old format</h2><span id='topic+recreate.olddata'></span>

<h3>Description</h3>

<p>Converts the <code>data</code> element of msm objects to the old format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recreate.olddata(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recreate.olddata_+3A_x">x</code></td>
<td>
<p>Object returned by the <code><a href="#topic+msm">msm</a></code> function, representing a
fitted multi-state model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just provided for convenience and to illustrate the changes.  It is
not guaranteed to be complete, and is liable to be withdrawn.  Users who
were relying on the previous undocumented format are advised to upgrade
their code to use the new format, which uses model frames and model design
matrices in the standard format used in version 1.4, based on
<code><a href="stats.html#topic+model.frame">model.frame</a></code> and <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>


<h3>Value</h3>

<p>A list of vectors and matrices in the undocumented ad-hoc format
used for the <code>data</code> component of <code>msm</code> objects in <span class="pkg">msm</span>
versions 1.3.1 and earlier.
</p>

<hr>
<h2 id='scoreresid.msm'>Score residuals</h2><span id='topic+scoreresid.msm'></span>

<h3>Description</h3>

<p>Score residuals for detecting outlying subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreresid.msm(x, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreresid.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="scoreresid.msm_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, display a simple plot of the residuals in
subject order, labelled by subject identifiers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The score residual for a single subject is
</p>
<p style="text-align: center;"><code class="reqn">U(\theta)^T I(\theta)^{-1} U(\theta)</code>
</p>

<p>where <code class="reqn">U(\theta)</code> is the vector of first derivatives of the
log-likelihood for that subject at maximum likelihood estimates
<code class="reqn">\theta</code>, and <code class="reqn">I(\theta)</code> is the observed Fisher
information matrix, that is, the matrix of second derivatives of minus the
log-likelihood for that subject at theta.
</p>
<p>Subjects with a higher influence on the maximum likelihood estimates will
have higher score residuals.
</p>
<p>These are only available for models with analytic derivatives (which
includes all non-hidden and most hidden Markov models).
</p>


<h3>Value</h3>

<p>Vector of the residuals, named by subject identifiers.
</p>


<h3>Author(s)</h3>

<p>Andrew Titman <a href="mailto:a.titman@lancaster.ac.uk">a.titman@lancaster.ac.uk</a> (theory), Chris
Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a> (code)
</p>

<hr>
<h2 id='sim.msm'>Simulate one individual trajectory from a continuous-time Markov model</h2><span id='topic+sim.msm'></span>

<h3>Description</h3>

<p>Simulate one realisation from a continuous-time Markov process up to a given
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.msm(
  qmatrix,
  maxtime,
  covs = NULL,
  beta = NULL,
  obstimes = 0,
  start = 1,
  mintime = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.msm_+3A_qmatrix">qmatrix</code></td>
<td>
<p>The transition intensity matrix of the Markov process. The
diagonal of <code>qmatrix</code> is ignored, and computed as appropriate so that
the rows sum to zero. For example, a possible <code>qmatrix</code> for a three
state illness-death model with recovery is:
</p>
<p><code>rbind( c( 0, 0.1, 0.02 ), c( 0.1, 0, 0.01 ), c( 0, 0, 0 ) )</code></p>
</td></tr>
<tr><td><code id="sim.msm_+3A_maxtime">maxtime</code></td>
<td>
<p>Maximum time for the simulated process.</p>
</td></tr>
<tr><td><code id="sim.msm_+3A_covs">covs</code></td>
<td>
<p>Matrix of time-dependent covariates, with one row for each
observation time and one column for each covariate.</p>
</td></tr>
<tr><td><code id="sim.msm_+3A_beta">beta</code></td>
<td>
<p>Matrix of linear covariate effects on log transition
intensities. The rows correspond to different covariates, and the columns to
the transition intensities. The intensities are ordered by reading across
rows of the intensity matrix, starting with the first, counting the positive
off-diagonal elements of the matrix.</p>
</td></tr>
<tr><td><code id="sim.msm_+3A_obstimes">obstimes</code></td>
<td>
<p>Vector of times at which the covariates are observed.</p>
</td></tr>
<tr><td><code id="sim.msm_+3A_start">start</code></td>
<td>
<p>Starting state of the process. Defaults to 1.</p>
</td></tr>
<tr><td><code id="sim.msm_+3A_mintime">mintime</code></td>
<td>
<p>Starting time of the process. Defaults to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effect of time-dependent covariates on the transition intensity matrix
for an individual is determined by assuming that the covariate is a step
function which remains constant in between the individual's observation
times.
</p>


<h3>Value</h3>

<p>A list with components,
</p>
<table>
<tr><td><code>states</code></td>
<td>
<p>Simulated states through which the process moves.  This ends
with either an absorption before <code>obstime</code>, or a transient state at
<code>obstime</code>. </p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>Exact times at which the process changes to the corresponding
states</p>
</td></tr>
<tr><td><code>qmatrix</code></td>
<td>
<p>The given transition intensity matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simmulti.msm">simmulti.msm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

qmatrix &lt;- rbind(
                 c(-0.2,   0.1,  0.1 ),
                 c(0.5,   -0.6,  0.1 ),
                 c(0,  0,  0)
                 )
sim.msm(qmatrix, 30)

</code></pre>

<hr>
<h2 id='simfitted.msm'>Simulate from a Markov model fitted using msm</h2><span id='topic+simfitted.msm'></span>

<h3>Description</h3>

<p>Simulate a dataset from a Markov model fitted using <code><a href="#topic+msm">msm</a></code>, using
the maximum likelihood estimates as parameters, and the same observation
times as in the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simfitted.msm(x, drop.absorb = TRUE, drop.pci.imp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simfitted.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model object as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="simfitted.msm_+3A_drop.absorb">drop.absorb</code></td>
<td>
<p>Should repeated observations in an absorbing state be
omitted.  Use the default of <code>TRUE</code> to avoid warnings when using the
simulated dataset for further <code><a href="#topic+msm">msm</a></code> fits.  Or set to
<code>FALSE</code> if exactly the same number of observations as the original data
are needed.</p>
</td></tr>
<tr><td><code id="simfitted.msm_+3A_drop.pci.imp">drop.pci.imp</code></td>
<td>
<p>In time-inhomogeneous models fitted using the <code>pci</code>
option to <code><a href="#topic+msm">msm</a></code>, censored observations are inserted into the
data by <code><a href="#topic+msm">msm</a></code> at the times where the intensity changes, but
dropped by default when simulating from the fitted model using this
function. Set this argument to <code>FALSE</code> to keep these observations and
the corresponding indicator variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around <code><a href="#topic+simmulti.msm">simmulti.msm</a></code>, and only
simulates panel-observed data.  To generate datasets with the exact times of
transition, use the lower-level <code><a href="#topic+sim.msm">sim.msm</a></code>.
</p>
<p>Markov models with misclassified states fitted through the <code>ematrix</code>
option to <code><a href="#topic+msm">msm</a></code> are supported, but not general hidden Markov
models with <code>hmodel</code>.  For misclassification models, this function
includes misclassification in the simulated states.
</p>
<p>This function is used for parametric bootstrapping to estimate the null
distribution of the test statistic in <code><a href="#topic+pearson.msm">pearson.msm</a></code>.
</p>


<h3>Value</h3>

<p>A dataset with variables as described in <code><a href="#topic+simmulti.msm">simmulti.msm</a></code>.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simmulti.msm">simmulti.msm</a></code>, <code><a href="#topic+sim.msm">sim.msm</a></code>,
<code><a href="#topic+pearson.msm">pearson.msm</a></code>, <code><a href="#topic+msm">msm</a></code>.
</p>

<hr>
<h2 id='simmulti.msm'>Simulate multiple trajectories from a multi-state Markov model with
arbitrary observation times</h2><span id='topic+simmulti.msm'></span>

<h3>Description</h3>

<p>Simulate a number of individual realisations from a continuous-time Markov
process. Observations of the process are made at specified arbitrary times
for each individual, giving panel-observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simmulti.msm(
  data,
  qmatrix,
  covariates = NULL,
  death = FALSE,
  start,
  ematrix = NULL,
  misccovariates = NULL,
  hmodel = NULL,
  hcovariates = NULL,
  censor.states = NULL,
  drop.absorb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simmulti.msm_+3A_data">data</code></td>
<td>
<p>A data frame with a mandatory column named <code>time</code>,
representing observation times.  The optional column named <code>subject</code>,
corresponds to subject identification numbers. If not given, all
observations are assumed to be on the same individual. Observation times
should be sorted within individuals.  The optional column named <code>cens</code>
indicates the times at which simulated states should be censored. If
<code>cens==0</code> then the state is not censored, and if <code>cens==k</code>, say,
then all simulated states at that time which are in the set
<code>censor.states</code> are replaced by <code>k</code>.  Other named columns of the
data frame represent any covariates, which may be time-constant or
time-dependent.  Time-dependent covariates are assumed to be constant
between the observation times.</p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_qmatrix">qmatrix</code></td>
<td>
<p>The transition intensity matrix of the Markov process, with
any covariates set to zero.  The diagonal of <code>qmatrix</code> is ignored, and
computed as appropriate so that the rows sum to zero. For example, a
possible <code>qmatrix</code> for a three state illness-death model with recovery
is:
</p>
<p><code>rbind( c( 0, 0.1, 0.02 ), c( 0.1, 0, 0.01 ), c( 0, 0, 0 ) )</code></p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_covariates">covariates</code></td>
<td>
<p>List of linear covariate effects on log transition
intensities. Each element is a vector of the effects of one covariate on all
the transition intensities. The intensities are ordered by reading across
rows of the intensity matrix, starting with the first, counting the positive
off-diagonal elements of the matrix.
</p>
<p>For example, for a multi-state model with three transition intensities, and
two covariates <code>x</code> and <code>y</code> on each intensity,
</p>
<p><code>covariates=list(x = c(-0.3,-0.3,-0.3), y=c(0.1, 0.1, 0.1))</code></p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_death">death</code></td>
<td>
<p>Vector of indices of the death states.  A death state is an
absorbing state whose time of entry is known exactly, but the individual is
assumed to be in an unknown transient state (&quot;alive&quot;) at the previous
instant.  This is the usual situation for times of death in chronic disease
monitoring data.  For example, if you specify <code>death = c(4, 5)</code> then
states 4 and 5 are assumed to be death states.
</p>
<p><code>death = TRUE</code> indicates that the final state is a death state, and
<code>death = FALSE</code> (the default) indicates that there is no death state.</p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_start">start</code></td>
<td>
<p>A vector with the same number of elements as there are distinct
subjects in the data, giving the states in which each corresponding
individual begins.  Or a single number, if all of these are the same.
Defaults to state 1 for each subject.</p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_ematrix">ematrix</code></td>
<td>
<p>An optional misclassification matrix for generating observed
states conditionally on the simulated true states. As defined in
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_misccovariates">misccovariates</code></td>
<td>
<p>Covariate effects on misclassification probabilities
via multinomial logistic regression. Linear effects operate on the log of
each probability relative to the probability of classification in the
correct state. In same format as <code>covariates</code>.</p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_hmodel">hmodel</code></td>
<td>
<p>An optional hidden Markov model for generating observed
outcomes conditionally on the simulated true states. As defined in
<code><a href="#topic+msm">msm</a></code>.  Multivariate outcomes (<code>hmmMV</code>) are not supported.</p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_hcovariates">hcovariates</code></td>
<td>
<p>List of the same length as <code>hmodel</code>, defining any
covariates governing the hidden Markov outcome models.  Unlike in the
<code>msm</code> function, this should also define the values of the covariate
effects. Each element of the list is a named vector of the initial values
for each set of covariates for that state.  For example, for a three-state
hidden Markov model with two, one and no covariates on the state 1, 2 and 3
outcome models respectively,
</p>
<p><code> hcovariates = list (c(acute=-8, age=0), c(acute=-8), NULL) </code></p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_censor.states">censor.states</code></td>
<td>
<p>Set of simulated states which should be replaced by a
censoring indicator at censoring times.  By default this is all transient
states (representing alive, with unknown state).</p>
</td></tr>
<tr><td><code id="simmulti.msm_+3A_drop.absorb">drop.absorb</code></td>
<td>
<p>Drop repeated observations in the absorbing state,
retaining only one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+sim.msm">sim.msm</a></code> is called repeatedly to produce a simulated trajectory
for each individual. The state at each specified observation time is then
taken to produce a new column <code>state</code>.  The effect of time-dependent
covariates on the transition intensity matrix for an individual is
determined by assuming that the covariate is a step function which remains
constant in between the individual's observation times.  If the subject
enters an absorbing state, then only the first observation in that state is
kept in the data frame. Rows corresponding to future observations are
deleted.  The entry times into states given in <code>death</code> are assumed to
be known exactly.
</p>


<h3>Value</h3>

<p>A data frame with columns, </p>
<table>
<tr><td><code>subject</code></td>
<td>
<p>Subject identification
indicators</p>
</td></tr> <tr><td><code>time</code></td>
<td>
<p>Observation times</p>
</td></tr> <tr><td><code>state</code></td>
<td>
<p>Simulated (true)
state at the corresponding time</p>
</td></tr> <tr><td><code>obs</code></td>
<td>
<p>Observed outcome at the
corresponding time, if <code>ematrix</code> or <code>hmodel</code> was supplied</p>
</td></tr>
<tr><td><code>keep</code></td>
<td>
<p>Row numbers of the original data.  Useful when
<code>drop.absorb=TRUE</code>, to show which rows were not dropped</p>
</td></tr></table>
<p> plus any
supplied covariates.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.msm">sim.msm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Simulate 100 individuals with common observation times
sim.df &lt;- data.frame(subject = rep(1:100, rep(13,100)), time = rep(seq(0, 24, 2), 100))
qmatrix &lt;- rbind(c(-0.11,   0.1,  0.01 ),
                 c(0.05,   -0.15,  0.1 ),
                 c(0.02,   0.07, -0.09))
simmulti.msm(sim.df, qmatrix)

</code></pre>

<hr>
<h2 id='sojourn.msm'>Mean sojourn times from a multi-state model</h2><span id='topic+sojourn.msm'></span>

<h3>Description</h3>

<p>Estimate the mean sojourn times in the transient states of a multi-state
model and their confidence limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sojourn.msm(
  x,
  covariates = "mean",
  ci = c("delta", "normal", "bootstrap", "none"),
  cl = 0.95,
  B = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sojourn.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="sojourn.msm_+3A_covariates">covariates</code></td>
<td>
<p>The covariate values at which to estimate the mean sojourn
times. This can either be:<br />
</p>
<p>the string <code>"mean"</code>, denoting the means of the covariates in the data
(this is the default),<br />
</p>
<p>the number <code>0</code>, indicating that all the covariates should be set to
zero,<br />
</p>
<p>a list of values, with optional names. For example,
</p>
<p><code>list(60, 1)</code>, where the order of the list follows the order of the
covariates originally given in the model formula, or a named list, e.g.
</p>
<p><code>list (age = 60, sex = 1)</code></p>
</td></tr>
<tr><td><code id="sojourn.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"delta"</code> (the default) then confidence intervals are
calculated by the delta method, or by simple transformation of the Hessian
in the very simplest cases.
</p>
<p>If <code>"normal"</code>, then calculate a confidence interval by simulating
<code>B</code> random vectors from the asymptotic multivariate normal distribution
implied by the maximum likelihood estimates (and covariance matrix) of the
log transition intensities and covariate effects, then transforming.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.</p>
</td></tr>
<tr><td><code id="sojourn.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval to present.  Defaults
to 0.95.</p>
</td></tr>
<tr><td><code id="sojourn.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates, or number of normal simulations
from the distribution of the MLEs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean sojourn time in a transient state <code class="reqn">r</code> is estimated by <code class="reqn">- 1
/ q_{rr}</code>, where <code class="reqn">q_{rr}</code> is the <code class="reqn">r</code>th entry on the diagonal of the
estimated transition intensity matrix.
</p>
<p>A continuous-time Markov model is fully specified by the mean sojourn times
and the probability that each state is next (<code><a href="#topic+pnext.msm">pnext.msm</a></code>).  This
is a more intuitively meaningful description of a model than the transition
intensity matrix (<code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>).
</p>
<p>Time dependent covariates, or time-inhomogeneous models, are not supported.
This would require the mean of a piecewise exponential distribution, and the
package author is not aware of any general analytic form for that.
</p>


<h3>Value</h3>

<p>A data frame with components:
</p>
<table>
<tr><td><code>estimates</code></td>
<td>
<p>Estimated mean sojourn times in the transient states.</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>Corresponding standard errors.</p>
</td></tr> <tr><td><code>L</code></td>
<td>
<p>Lower confidence limits.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Upper confidence limits.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>, <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>,
<code><a href="#topic+deltamethod">deltamethod</a></code>
</p>

<hr>
<h2 id='statetable.msm'>Table of transitions</h2><span id='topic+statetable.msm'></span>

<h3>Description</h3>

<p>Calculates a frequency table counting the number of times each pair of
states were observed in successive observation times.  This can be a useful
way of summarising multi-state data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statetable.msm(state, subject, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statetable.msm_+3A_state">state</code></td>
<td>
<p>Observed states, assumed to be ordered by time within each
subject.</p>
</td></tr>
<tr><td><code id="statetable.msm_+3A_subject">subject</code></td>
<td>
<p>Subject identification numbers corresponding to <code>state</code>.
If not given, all observations are assumed to be on the same subject.</p>
</td></tr>
<tr><td><code id="statetable.msm_+3A_data">data</code></td>
<td>
<p>An optional data frame in which the variables represented by
<code>subject</code> and <code>state</code> can be found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the data are intermittently observed (panel data) this table should not
be used to decide what transitions should be allowed in the <code class="reqn">Q</code> matrix,
which works in continuous time.  This function counts the transitions
between states over a time interval, not in real time.  There can be
observed transitions between state <code class="reqn">r</code> and <code class="reqn">s</code> over an interval even
if <code class="reqn">q_{rs}=0</code>, because the process may have passed through one or more
intermediate states in the middle of the interval.
</p>


<h3>Value</h3>

<p>A frequency table with starting states as rows and finishing states
as columns.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crudeinits.msm">crudeinits.msm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Heart transplant data
data(cav)

## 148 deaths from state 1, 48 from state 2 and 55 from state 3.
statetable.msm(state, PTNUM, data=cav)


</code></pre>

<hr>
<h2 id='summary.msm'>Summarise a fitted multi-state model</h2><span id='topic+summary.msm'></span><span id='topic+print.summary.msm'></span>

<h3>Description</h3>

<p>Summary method for fitted <code><a href="#topic+msm">msm</a></code> models. This is simply a wrapper
around <code><a href="#topic+prevalence.msm">prevalence.msm</a></code> which produces a table of observed and
expected state prevalences for each time, and for models with covariates,
<code><a href="#topic+hazard.msm">hazard.msm</a></code> to print hazard ratios with 95% confidence
intervals for covariate effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msm'
summary(object, hazard.scale = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.msm_+3A_object">object</code></td>
<td>
<p>A fitted multi-state model object, as returned by
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.msm_+3A_hazard.scale">hazard.scale</code></td>
<td>
<p>Vector with same elements as number of covariates on
transition rates. Corresponds to the increase in each covariate used to
calculate its hazard ratio. Defaults to all 1.</p>
</td></tr>
<tr><td><code id="summary.msm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prevalence.msm">prevalence.msm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>summary.msm</code>, with components:
</p>
<table>
<tr><td><code>prevalences</code></td>
<td>
<p>Output from <code><a href="#topic+prevalence.msm">prevalence.msm</a></code>.</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>Output from <code><a href="#topic+hazard.msm">hazard.msm</a></code>.</p>
</td></tr>
<tr><td><code>hazard.scale</code></td>
<td>
<p>Value of the <code>hazard.scale</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>,<code><a href="#topic+prevalence.msm">prevalence.msm</a></code>,
<code><a href="#topic+hazard.msm">hazard.msm</a></code>
</p>

<hr>
<h2 id='surface.msm'>Explore the likelihood surface</h2><span id='topic+surface.msm'></span><span id='topic+persp.msm'></span><span id='topic+contour.msm'></span><span id='topic+image.msm'></span>

<h3>Description</h3>

<p>Plot the log-likelihood surface with respect to two parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface.msm(
  x,
  params = c(1, 2),
  np = 10,
  type = c("contour", "filled.contour", "persp", "image"),
  point = NULL,
  xrange = NULL,
  yrange = NULL,
  ...
)

## S3 method for class 'msm'
contour(x, ...)

## S3 method for class 'msm'
persp(x, ...)

## S3 method for class 'msm'
image(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surface.msm_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+msm">msm</a></code>, representing a fitted msm model.</p>
</td></tr>
<tr><td><code id="surface.msm_+3A_params">params</code></td>
<td>
<p>Integer vector with two elements, giving the indices of the
parameters to vary. All other parameters will be fixed. Defaults to
<code>c(1,2)</code>, representing the first two log transition intensities. See
the <code>fixedpars</code> argument to <code>msm</code> for a definition of these
indices.</p>
</td></tr>
<tr><td><code id="surface.msm_+3A_np">np</code></td>
<td>
<p>Number of grid points to use in each direction, by default 10.  An
<code>np x np</code> grid will be used to evaluate the likelihood surface. If 100
likelihood function evaluations is slow, then reduce this.</p>
</td></tr>
<tr><td><code id="surface.msm_+3A_type">type</code></td>
<td>
<p>Character string specifying the type of plot to produce.
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>"contour"</code> </td><td style="text-align: left;"> Contour plot, using the R function
<code><a href="graphics.html#topic+contour">contour</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"filled.contour"</code> </td><td style="text-align: left;"> Solid-color contour
plot, using the R function <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"persp"</code>
</td><td style="text-align: left;"> Perspective plot, using the R function <code><a href="graphics.html#topic+persp">persp</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"image"</code> </td><td style="text-align: left;"> Grid color plot, using the R function
<code><a href="graphics.html#topic+image">image</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
</td></tr>
<tr><td><code id="surface.msm_+3A_point">point</code></td>
<td>
<p>Vector of length <code>n</code>, where <code>n</code> is the number of
parameters in the model, including the parameters that will be varied here.
This specifies the point at which to fix the likelihood.  By default, this
is the maximum likelihood estimates stored in the fitted model <code>x</code>,
<code>x$estimates</code>.</p>
</td></tr>
<tr><td><code id="surface.msm_+3A_xrange">xrange</code></td>
<td>
<p>Range to plot for the first varied parameter.  Defaults to
plus and minus two standard errors, obtained from the Hessian at the maximum
likelihood estimate.</p>
</td></tr>
<tr><td><code id="surface.msm_+3A_yrange">yrange</code></td>
<td>
<p>Range to plot for the second varied parameter.  Defaults to
plus and minus two standard errors, obtained from the Hessian at the maximum
likelihood estimate.</p>
</td></tr>
<tr><td><code id="surface.msm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a contour or perspective plot.  Useful for diagnosing irregularities
in the likelihood surface.  If you want to use these plots before running
the maximum likelihood estimation, then just run <code>msm</code> with all
estimates fixed at their initial values.
</p>
<p><code>contour.msm</code> just calls surface.msm with <code>type = "contour"</code>.
</p>
<p><code>persp.msm</code> just calls surface.msm with <code>type = "persp"</code>.
</p>
<p><code>image.msm</code> just calls surface.msm with <code>type = "image"</code>.
</p>
<p>As these three functions are methods of the generic functions
<code>contour</code>, <code>persp</code> and <code>image</code>, they can be invoked as
<code>contour(x)</code>, <code>persp(x)</code> or <code>image(x)</code>, where <code>x</code> is a
fitted <code>msm</code> object.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="graphics.html#topic+image">image</a></code>.
</p>

<hr>
<h2 id='tnorm'>Truncated Normal distribution</h2><span id='topic+tnorm'></span><span id='topic+dtnorm'></span><span id='topic+ptnorm'></span><span id='topic+qtnorm'></span><span id='topic+rtnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for
the truncated Normal distribution with mean equal to <code>mean</code> and
standard deviation equal to <code>sd</code> before truncation, and truncated on
the interval <code>[lower, upper]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtnorm(x, mean = 0, sd = 1, lower = -Inf, upper = Inf, log = FALSE)

ptnorm(
  q,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  lower.tail = TRUE,
  log.p = FALSE
)

qtnorm(
  p,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  lower.tail = TRUE,
  log.p = FALSE
)

rtnorm(n, mean = 0, sd = 1, lower = -Inf, upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnorm_+3A_x">x</code>, <code id="tnorm_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_lower">lower</code></td>
<td>
<p>lower truncation point.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_upper">upper</code></td>
<td>
<p>upper truncation point.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, return log density or log hazard.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x],
otherwise, P[X &gt; x].</p>
</td></tr>
<tr><td><code id="tnorm_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="tnorm_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The truncated normal distribution has density
</p>
<p style="text-align: center;"><code class="reqn"> f(x, \mu, \sigma) = \phi(x, \mu, \sigma) / (\Phi(u, \mu, \sigma) -
\Phi(l, \mu, \sigma)) </code>
</p>
<p style="text-align: center;"><code class="reqn"> </code>
</p>
<p> for <code class="reqn">l &lt;= x
&lt;= u</code>, and 0 otherwise.
</p>
<p><code class="reqn">\mu</code> is the mean of the original Normal distribution before
truncation, <br /> <code class="reqn">\sigma</code> is the corresponding standard deviation,
<br /> <code class="reqn">u</code> is the upper truncation point, <br /> <code class="reqn">l</code> is the lower
truncation point, <br /> <code class="reqn">\phi(x)</code> is the density of the
corresponding normal distribution, and <br /> <code class="reqn">\Phi(x)</code> is the
distribution function of the corresponding normal distribution.
</p>
<p>If <code>mean</code> or <code>sd</code> are not specified they assume the default values
of <code>0</code> and <code>1</code>, respectively.
</p>
<p>If <code>lower</code> or <code>upper</code> are not specified they assume the default
values of <code>-Inf</code> and <code>Inf</code>, respectively, corresponding to no
lower or no upper truncation.
</p>
<p>Therefore, for example, <code>dtnorm(x)</code>, with no other arguments, is simply
equivalent to <code>dnorm(x)</code>.
</p>
<p>Only <code>rtnorm</code> is used in the <code>msm</code> package, to simulate from
hidden Markov models with truncated normal distributions. This uses the
rejection sampling algorithms described by Robert (1995).
</p>
<p>These functions are merely provided for completion, and are not optimized
for numerical stability or speed.  To fit a hidden Markov model with a
truncated Normal response distribution, use a <code><a href="#topic+hmmTNorm">hmmTNorm</a></code>
constructor. See the <code><a href="#topic+hmm-dists">hmm-dists</a></code> help page for further details.
</p>


<h3>Value</h3>

<p><code>dtnorm</code> gives the density, <code>ptnorm</code> gives the
distribution function, <code>qtnorm</code> gives the quantile function, and
<code>rtnorm</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Robert, C. P. Simulation of truncated normal variables.
Statistics and Computing (1995) 5, 121&ndash;125
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(50, 90, by=1)
plot(x, dnorm(x, 70, 10), type="l", ylim=c(0,0.06)) ## standard Normal distribution
lines(x, dtnorm(x, 70, 10, 60, 80), type="l")       ## truncated Normal distribution

</code></pre>

<hr>
<h2 id='totlos.msm'>Total length of stay, or expected number of visits</h2><span id='topic+totlos.msm'></span><span id='topic+envisits.msm'></span>

<h3>Description</h3>

<p>Estimate the expected total length of stay, or the expected number of
visits, in each state, for an individual in a given period of evolution of a
multi-state model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totlos.msm(
  x,
  start = 1,
  end = NULL,
  fromt = 0,
  tot = Inf,
  covariates = "mean",
  piecewise.times = NULL,
  piecewise.covariates = NULL,
  num.integ = FALSE,
  discount = 0,
  env = FALSE,
  ci = c("none", "normal", "bootstrap"),
  cl = 0.95,
  B = 1000,
  cores = NULL,
  ...
)

envisits.msm(
  x = NULL,
  start = 1,
  end = NULL,
  fromt = 0,
  tot = Inf,
  covariates = "mean",
  piecewise.times = NULL,
  piecewise.covariates = NULL,
  num.integ = FALSE,
  discount = 0,
  ci = c("none", "normal", "bootstrap"),
  cl = 0.95,
  B = 1000,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totlos.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model, as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_start">start</code></td>
<td>
<p>Either a single number giving the state at the beginning of the
period, or a vector of probabilities of being in each state at this time.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_end">end</code></td>
<td>
<p>States to estimate the total length of stay (or number of visits)
in. Defaults to all states.  This is deprecated, since with the analytic
solution (see &quot;Details&quot;) it doesn't save any computation to only estimate
for a subset of states.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_fromt">fromt</code></td>
<td>
<p>Time from which to estimate.  Defaults to 0, the beginning of
the process.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_tot">tot</code></td>
<td>
<p>Time up to which the estimate is made.  Defaults to infinity,
giving the expected time spent in or number of visits to the state until
absorption. However, the calculation will be much more efficient if a finite
(potentially large) time is specified: see the &quot;Details&quot; section.  For
models without an absorbing state, <code>t</code> must be specified.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_covariates">covariates</code></td>
<td>
<p>The covariate values to estimate for.  This can either
be:<br />
</p>
<p>the string <code>"mean"</code>, denoting the means of the covariates in the data
(this is the default),<br />
</p>
<p>the number <code>0</code>, indicating that all the covariates should be set to
zero,<br />
</p>
<p>or a list of values, with optional names. For example
</p>
<p><code>list (60, 1)</code>
</p>
<p>where the order of the list follows the order of the covariates originally
given in the model formula, or a named list,
</p>
<p><code>list (age = 60, sex = 1)</code></p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_piecewise.times">piecewise.times</code></td>
<td>
<p>Times at which piecewise-constant intensities change.
See <code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code> for how to specify this. This is
only required for time-inhomogeneous models specified using explicit
time-dependent covariates, and should not be used for models specified using
&quot;pci&quot;.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_piecewise.covariates">piecewise.covariates</code></td>
<td>
<p>Covariates on which the piecewise-constant
intensities depend. See <code><a href="#topic+pmatrix.piecewise.msm">pmatrix.piecewise.msm</a></code> for how to
specify this.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_num.integ">num.integ</code></td>
<td>
<p>Use numerical integration instead of analytic solution (see
below).</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_discount">discount</code></td>
<td>
<p>Discount rate in continuous time.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_env">env</code></td>
<td>
<p>Supplied to <code><a href="#topic+totlos.msm">totlos.msm</a></code>.  If <code>TRUE</code>, return the
expected number of visits to each state. If <code>FALSE</code>, return the total
length of stay in each state. <code><a href="#topic+envisits.msm">envisits.msm</a></code> simply calls
<code><a href="#topic+totlos.msm">totlos.msm</a></code> with <code>env=TRUE</code>.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_ci">ci</code></td>
<td>
<p>If <code>"normal"</code>, then calculate a confidence interval by
simulating <code>B</code> random vectors from the asymptotic multivariate normal
distribution implied by the maximum likelihood estimates (and covariance
matrix) of the log transition intensities and covariate effects, then
calculating the total length of stay for each replicate.
</p>
<p>If <code>"bootstrap"</code> then calculate a confidence interval by non-parametric
bootstrap refitting.  This is 1-2 orders of magnitude slower than the
<code>"normal"</code> method, but is expected to be more accurate. See
<code><a href="#topic+boot.msm">boot.msm</a></code> for more details of bootstrapping in <span class="pkg">msm</span>.
</p>
<p>If <code>"none"</code> (the default) then no confidence interval is calculated.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_cl">cl</code></td>
<td>
<p>Width of the symmetric confidence interval, relative to 1</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for bootstrapping using parallel
processing. See <code><a href="#topic+boot.msm">boot.msm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="totlos.msm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the <code><a href="stats.html#topic+integrate">integrate</a></code>
function to control the numerical integration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected total length of stay in state <code class="reqn">j</code> between times <code class="reqn">t_1</code>
and <code class="reqn">t_2</code>, from the point of view of an individual in state <code class="reqn">i</code> at
time 0, is defined by the integral from <code class="reqn">t_1</code> to <code class="reqn">t_2</code> of the
<code class="reqn">i,j</code> entry of the transition probability matrix <code class="reqn">P(t) = Exp(tQ)</code>,
where <code class="reqn">Q</code> is the transition intensity matrix.
</p>
<p>The corresponding expected number of visits to state <code class="reqn">j</code> (excluding the
stay in the current state at time 0) is <code class="reqn">\sum_{i!=j} T_i Q_{i,j}</code>, where
<code class="reqn">T_i</code> is the expected amount of time spent in state <code class="reqn">i</code>.
</p>
<p>More generally, suppose that <code class="reqn">\pi_0</code> is the vector of
probabilities of being in each state at time 0, supplied in <code>start</code>,
and we want the vector <code class="reqn">\mathbf{x}</code> giving the expected lengths of
stay in each state.  The corresponding integral has the following solution
(van Loan 1978; van Rosmalen et al. 2013)
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x} =
\left[
\begin{array}{ll}
1  &amp;  \mathbf{0}_K
\end{array}
\right]
Exp(t Q')
\left[
\begin{array}{l} \mathbf{0}_K\\I_K
\end{array}
\right]
</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">Q' = \left[
\begin{array}{ll} 0 &amp; \mathbf{\pi}_0\\
\mathbf{0}_K  &amp;  Q - rI_K
\end{array}
\right]
</code>
</p>

<p><code class="reqn">\pi_0</code> is the row vector of initial state probabilities supplied
in <code>start</code>, <code class="reqn">\mathbf{0}_K</code> is the row vector of K zeros,
<code class="reqn">r</code> is the discount rate, <code class="reqn">I_K</code> is the K x K identity matrix,
and <code class="reqn">Exp</code> is the matrix exponential.
</p>
<p>Alternatively, the integrals can be calculated numerically, using the
<code><a href="stats.html#topic+integrate">integrate</a></code> function.  This may take a long time for models with
many states where <code class="reqn">P(t)</code> is expensive to calculate.  This is required
where <code>tot = Inf</code>, since the package author is not aware of any
analytic expression for the limit of the above formula as <code class="reqn">t</code> goes to
infinity.
</p>
<p>With the argument <code>num.integ=TRUE</code>, numerical integration is used even
where the analytic solution is available. This facility is just provided for
checking results against versions 1.2.4 and earlier, and will be removed
eventually. Please let the package maintainer know if any results are
different.
</p>
<p>For a model where the individual has only one place to go from each state,
and each state is visited only once, for example a progressive disease model
with no recovery or death, these are equal to the mean sojourn time in each
state.  However, consider a three-state health-disease-death model with
transitions from health to disease, health to death, and disease to death,
where everybody starts healthy.  In this case the mean sojourn time in the
disease state will be greater than the expected length of stay in the
disease state.  This is because the mean sojourn time in a state is
conditional on entering the state, whereas the expected total time diseased
is a forecast for a healthy individual, who may die before getting the
disease.
</p>
<p>In the above formulae, <code class="reqn">Q</code> is assumed to be constant over time, but the
results generalise easily to piecewise-constant intensities.  This function
automatically handles models fitted using the <code>pci</code> option to
<code><a href="#topic+msm">msm</a></code>. For any other inhomogeneous models, the user must specify
<code>piecewise.times</code> and <code>piecewise.covariates</code> arguments to
<code><a href="#topic+totlos.msm">totlos.msm</a></code>.
</p>


<h3>Value</h3>

<p>A vector of expected total lengths of stay
(<code><a href="#topic+totlos.msm">totlos.msm</a></code>), or expected number of visits
(<code><a href="#topic+envisits.msm">envisits.msm</a></code>), for each transient state.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>C. van Loan (1978). Computing integrals involving the matrix
exponential. IEEE Transactions on Automatic Control 23(3)395-404.
</p>
<p>J. van Rosmalen, M. Toy and J.F. O'Mahony (2013). A mathematical approach
for evaluating Markov models in continuous time without discrete-event
simulation.  Medical Decision Making 33:767-779.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sojourn.msm">sojourn.msm</a></code>, <code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>,
<code><a href="stats.html#topic+integrate">integrate</a></code>, <code><a href="#topic+boot.msm">boot.msm</a></code>.
</p>

<hr>
<h2 id='transient.msm'>Transient and absorbing states</h2><span id='topic+transient.msm'></span><span id='topic+absorbing.msm'></span>

<h3>Description</h3>

<p>Returns the transient and absorbing states of either a fitted model or a
transition intensity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transient.msm(x = NULL, qmatrix = NULL)

absorbing.msm(x = NULL, qmatrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transient.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model as returned by <code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="transient.msm_+3A_qmatrix">qmatrix</code></td>
<td>
<p>A transition intensity matrix. The diagonal is ignored and
taken to be minus the sum of the rest of the row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the ordinal indices of the transient or absorbing
states.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>

<hr>
<h2 id='twophase'>Coxian phase-type distribution with two phases</h2><span id='topic+twophase'></span><span id='topic+d2phase'></span><span id='topic+p2phase'></span><span id='topic+q2phase'></span><span id='topic+r2phase'></span><span id='topic+h2phase'></span>

<h3>Description</h3>

<p>Density, distribution, quantile functions and other utilities for the Coxian
phase-type distribution with two phases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2phase(x, l1, mu1, mu2, log = FALSE)

p2phase(q, l1, mu1, mu2, lower.tail = TRUE, log.p = FALSE)

q2phase(p, l1, mu1, mu2, lower.tail = TRUE, log.p = FALSE)

r2phase(n, l1, mu1, mu2)

h2phase(x, l1, mu1, mu2, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twophase_+3A_x">x</code>, <code id="twophase_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="twophase_+3A_l1">l1</code></td>
<td>
<p>Intensity for transition between phase 1 and phase 2.</p>
</td></tr>
<tr><td><code id="twophase_+3A_mu1">mu1</code></td>
<td>
<p>Intensity for transition from phase 1 to exit.</p>
</td></tr>
<tr><td><code id="twophase_+3A_mu2">mu2</code></td>
<td>
<p>Intensity for transition from phase 2 to exit.</p>
</td></tr>
<tr><td><code id="twophase_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, return log density or log hazard.</p>
</td></tr>
<tr><td><code id="twophase_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x],
otherwise, P[X &gt; x].</p>
</td></tr>
<tr><td><code id="twophase_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="twophase_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="twophase_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the distribution of the time to reach state 3 in a continuous-time
Markov model with three states and transitions permitted from state 1 to
state 2 (with intensity <code class="reqn">\lambda_1</code>) state 1 to state 3
(intensity <code class="reqn">\mu_1</code>) and state 2 to state 3 (intensity
<code class="reqn">\mu_2</code>).  States 1 and 2 are the two &quot;phases&quot; and state 3 is the
&quot;exit&quot; state.
</p>
<p>The density is
</p>
<p style="text-align: center;"><code class="reqn">f(t | \lambda_1, \mu_1) = e^{-(\lambda_1+\mu_1)t}(\mu_1 +
(\lambda_1+\mu_1)\lambda_1 t)</code>
</p>

<p>if <code class="reqn">\lambda_1 + \mu_1 = \mu_2</code>, and
</p>
<p style="text-align: center;"><code class="reqn">f(t | \lambda_1, \mu_1, \mu_2) =
\frac{(\lambda_1+\mu_1)e^{-(\lambda_1+\mu_1)t}(\mu_2-\mu_1) +
\mu_2\lambda_1e^{-\mu_2t}}{\lambda_1+\mu_1-\mu_2}</code>
</p>

<p>otherwise.  The distribution function is
</p>
<p style="text-align: center;"><code class="reqn">F(t | \lambda_1, \mu_1) = 1 - e^{-(\lambda_1+\mu_1) t} (1 + \lambda_1
t)</code>
</p>

<p>if <code class="reqn">\lambda_1 + \mu_1 = \mu_2</code>, and
</p>
<p style="text-align: center;"><code class="reqn">F(t | \lambda_1, \mu_1, \mu_2) =
1  -  \frac{e^{-(\lambda_1 + \mu_1)t} (\mu_2 - \mu_1)  +  \lambda_1 e^{-\mu_2 t}}{
\lambda_1 + \mu_1 - \mu_2}</code>
</p>

<p>otherwise.  Quantiles are calculated by numerically inverting the
distribution function.
</p>
<p>The mean is <code class="reqn">(1 + \lambda_1/\mu_2) / (\lambda_1 + \mu_1)</code>.
</p>
<p>The variance is <code class="reqn">(2 + 2\lambda_1(\lambda_1+\mu_1+ \mu_2)/\mu_2^2 - (1 +
\lambda_1/\mu_2)^2)/(\lambda_1+\mu_1)^2</code>.
</p>
<p>If <code class="reqn">\mu_1=\mu_2</code> it reduces to an exponential distribution with
rate <code class="reqn">\mu_1</code>, and the parameter <code class="reqn">\lambda_1</code> is redundant.
Or also if <code class="reqn">\lambda_1=0</code>.
</p>
<p>The hazard at <code class="reqn">x=0</code> is <code class="reqn">\mu_1</code>, and smoothly increasing if
<code class="reqn">\mu_1&lt;\mu_2</code>.  If <code class="reqn">\lambda_1 + \mu_1 \geq \mu_2</code> it increases to an asymptote of <code class="reqn">\mu_2</code>, and if
<code class="reqn">\lambda_1 + \mu_1 \leq \mu_2</code> it increases to an
asymptote of <code class="reqn">\lambda_1 + \mu_1</code>.  The hazard is decreasing if
<code class="reqn">\mu_1&gt;\mu_2</code>, to an asymptote of <code class="reqn">\mu_2</code>.
</p>


<h3>Value</h3>

<p><code>d2phase</code> gives the density, <code>p2phase</code> gives the
distribution function, <code>q2phase</code> gives the quantile function,
<code>r2phase</code> generates random deviates, and <code>h2phase</code> gives the
hazard.
</p>


<h3>Alternative parameterisation</h3>

<p>An individual following this
distribution can be seen as coming from a mixture of two populations:
</p>
<p>1) &quot;short stayers&quot; whose mean sojourn time is <code class="reqn">M_1 = </code><code class="reqn"> 1/(\lambda_1+\mu_1)</code> and sojourn
distribution is exponential with rate <code class="reqn">\lambda_1 + \mu_1</code>.
</p>
<p>2) &quot;long stayers&quot; whose mean sojourn time <code class="reqn">M_2 = </code><code class="reqn"> 1/(\lambda_1+\mu_1) + 1/\mu_2</code> and sojourn
distribution is the sum of two exponentials with rate <code class="reqn">\lambda_1 +
</code><code class="reqn"> \mu_1</code> and <code class="reqn">\mu_2</code> respectively.  The
individual is a &quot;long stayer&quot; with probability <code class="reqn">p=\lambda_1/(\lambda_1 +
\mu_1)</code>.
</p>
<p>Thus a two-phase distribution can be more intuitively parameterised by the
short and long stay means <code class="reqn">M_1 &lt; M_2</code> and the long stay probability
<code class="reqn">p</code>.  Given these parameters, the transition intensities are
<code class="reqn">\lambda_1=p/M_1</code>, <code class="reqn">\mu_1=(1-p)/M_1</code>, and
<code class="reqn">\mu_2=1/(M_2-M_1)</code>.  This can be useful for choosing
intuitively reasonable initial values for procedures to fit these models to
data.
</p>
<p>The hazard is increasing at least if <code class="reqn">M_2 &lt; 2M_1</code>, and also
only if <code class="reqn">(M_2 - 2M_1)/(M_2 - M_1) &lt; p</code>.
</p>
<p>For increasing hazards with <code class="reqn">\lambda_1 + \mu_1 \leq \mu_2</code>, the maximum hazard ratio between any time <code class="reqn">t</code> and time 0 is
<code class="reqn">1/(1-p)</code>.
</p>
<p>For increasing hazards with <code class="reqn">\lambda_1 + \mu_1 \geq \mu_2</code>, the maximum hazard ratio is <code class="reqn">M_1/((1-p)(M_2 - </code><code class="reqn"> M_1))</code>. This is the minimum hazard ratio for
decreasing hazards.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>C. Dutang, V. Goulet and M. Pigeon (2008). actuar: An R Package
for Actuarial Science. Journal of Statistical Software, vol. 25, no. 7,
1-37. URL http://www.jstatsoft.org/v25/i07
</p>

<hr>
<h2 id='updatepars.msm'>Update the maximum likelihood estimates in a fitted model object.</h2><span id='topic+updatepars.msm'></span>

<h3>Description</h3>

<p>Update the maximum likelihood estimates in a fitted model object.  Intended for
developer use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updatepars.msm(x, pars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepars.msm_+3A_x">x</code></td>
<td>
<p>A fitted multi-state model object, as returned by
<code><a href="#topic+msm">msm</a></code>.</p>
</td></tr>
<tr><td><code id="updatepars.msm_+3A_pars">pars</code></td>
<td>
<p>Vector of new parameters, in their untransformed real-line
parameterisations, to substitute for the maximum likelihood estimates
corresponding to those in the <code>estimates</code> component of the fitted model
object (<code><a href="#topic+msm.object">msm.object</a></code>).  The order of the parameters is
documented in <code><a href="#topic+msm">msm</a></code>, argument <code>fixedpars</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code><a href="#topic+msm">msm</a></code> model object with the updated maximum
likelihood estimates, but with the covariances / standard errors unchanged.
</p>
<p>Point estimates from output functions such as <code><a href="#topic+qmatrix.msm">qmatrix.msm</a></code>,
<code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>, or any related function, can then be evaluated
with the new parameters, and at arbitrary covariate values.
</p>
<p>This function is used, for example, when computing confidence intervals from
<code><a href="#topic+pmatrix.msm">pmatrix.msm</a></code>, and related functions, using the
<code>ci="normal"</code> method.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>

<hr>
<h2 id='viterbi.msm'>Calculate the probabilities of underlying states and the most likely path
through them</h2><span id='topic+viterbi.msm'></span>

<h3>Description</h3>

<p>For a fitted hidden Markov model, or a model with censored state
observations, the Viterbi algorithm recursively constructs the path with the
highest probability through the underlying states.  The probability of each
hidden state is also computed for hidden Markov models, using the
forward-backward algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viterbi.msm(x, normboot = FALSE, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viterbi.msm_+3A_x">x</code></td>
<td>
<p>A fitted hidden Markov multi-state model, or a model with censored
state observations, as produced by <code><a href="#topic+msm">msm</a></code></p>
</td></tr>
<tr><td><code id="viterbi.msm_+3A_normboot">normboot</code></td>
<td>
<p>If <code>TRUE</code>, then before running the algorithm, the
maximum likelihood estimates of the model parameters are replaced by an
alternative set of parameters drawn randomly from the asymptotic
multivariate normal distribution of the MLEs.</p>
</td></tr>
<tr><td><code id="viterbi.msm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame containing observations on which to
construct the Viterbi path and forward-backward probabilities. It must be in
the same format as the data frame used to fit <code>x</code>.  If <code>NULL</code>, the
data frame used to fit <code>x</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns:
</p>
<p><code>subject</code> = subject identification numbers
</p>
<p><code>time</code> = times of observations
</p>
<p><code>observed</code> = corresponding observed states
</p>
<p><code>fitted</code> = corresponding fitted states found by Viterbi recursion. If
the model is not a hidden Markov model and there are no censored state
observations, this is just the observed states.
</p>
<p>For hidden Markov models, an additional matrix <code>pstate</code> is also
returned inside the data frame, giving the probability of each hidden state
at each point, conditionally on all the data.  This is computed by the
forward/backward algorithm.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Durbin, R., Eddy, S., Krogh, A. and Mitchison, G.
<em>Biological sequence analysis</em>, Cambridge University Press, 1998.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msm">msm</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
