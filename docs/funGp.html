<!DOCTYPE html><html><head><title>Help for package funGp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {funGp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[[,Xfgpm-method'><p>Refit a <code>fgpm</code> model in a <code>Xfgpm</code> object</p></a></li>
<li><a href='#antsLog-class'><p>S4 class for log of models explored by ant colony in funGp</p></a></li>
<li><a href='#black-boxes'><p>Analytic models for the exploration of the funGp package</p></a></li>
<li><a href='#decay'><p>Decay functions for ant colony optimization in funGp</p></a></li>
<li><a href='#decay2probs'><p>Probability functions for ant colony optimization in funGp</p></a></li>
<li><a href='#factoryCall-class'><p>S4 class for fgpm_factory function calls</p></a></li>
<li><a href='#fgpKern-class'><p>S4 class for structures linked to the kernel of a <code>fgpm</code> model</p></a></li>
<li><a href='#fgpm'><p>Gaussian process models for scalar and functional inputs</p></a></li>
<li><a href='#fgpm_factory'><p>Structural optimization of Gaussian process models</p></a></li>
<li><a href='#fgpm-class'><p>S4 class for funGp Gaussian process models</p></a></li>
<li><a href='#fgpProj-class'><p>S4 class for structures linked to projections in a <code>fgpm</code> model</p></a></li>
<li><a href='#funGp-package'><p>Gaussian Process Models for Scalar and Functional Inputs</p></a></li>
<li><a href='#gaussian_cor'><p>Gaussian correlation function</p></a></li>
<li><a href='#get_active_in'><p>Extraction of active inputs in a given model structure</p></a></li>
<li><a href='#matern32_cor'><p>Matern 3/2 correlation function</p></a></li>
<li><a href='#matern52_cor'><p>Matern 5/2 correlation function</p></a></li>
<li><a href='#modelCall-class'><p>S4 class for calls to the fgpm function in funGp</p></a></li>
<li><a href='#modelDef'><p>Retrieve a <code>fgpm</code> from within a <code>Xfgpm</code> object</p></a></li>
<li><a href='#plot,fgpm-method'><p>Plot method for the class <code>"fgpm"</code></p></a></li>
<li><a href='#plot,Xfgpm-method'><p>Plot method for the class <code>"Xfgpm"</code></p></a></li>
<li><a href='#plot.predict.fgpm'><p>Plot method for the predictions of a <code>fgpm</code> model</p></a></li>
<li><a href='#plot.simulate.fgpm'><p>Plot method for the simulations of a <code>fgpm</code> model</p></a></li>
<li><a href='#precalculated_Xfgpm_objects'><p>Precalculated Xfgpm objects</p></a></li>
<li><a href='#predict,fgpm-method'><p>Prediction from a <code>fgpm</code> Gaussian process model</p></a></li>
<li><a href='#simulate,fgpm-method'><p>Random sampling from a <code>fgpm</code> model</p></a></li>
<li><a href='#summary,fgpm-method'><p>Summary method for <code>fgpm</code> objects</p></a></li>
<li><a href='#summary,Xfgpm-method'><p>Summary method for <code>Xfgpm</code> objects</p></a></li>
<li><a href='#update,fgpm-method'><p>Easy update of <code>fgpm</code> models</p></a></li>
<li><a href='#which_on'><p>Indices of active inputs in a given model structure</p></a></li>
<li><a href='#Xfgpm-class'><p>S4 class for funGp model selection data structures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Process Models for Scalar and Functional Inputs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose Betancourt &lt;djbetancourt@uninorte.edu.co&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Construction and smart selection of Gaussian process models
	for analysis of computer experiments
	with emphasis on treatment of functional inputs that are regularly sampled. This package
	offers: (i) flexible modeling of functional-input regression
	problems through the fairly general Gaussian process model; (ii)
	built-in dimension reduction for functional inputs; (iii)
	heuristic optimization of the structural parameters of the model
	(e.g., active inputs, kernel function, type of distance).
	Metamodeling background is provided in
	Betancourt et al. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.ress.2020.106870">doi:10.1016/j.ress.2020.106870</a>&gt;.
	The algorithm for structural parameter optimization is described
	in <a href="https://hal.archives-ouvertes.fr/hal-02532713">https://hal.archives-ouvertes.fr/hal-02532713</a>.</td>
</tr>
<tr>
<td>Note:</td>
<td>research product of the RISCOPE project (ANR, project
No.16CE04-0011) &lt;https://perso.math.univ-toulouse.fr/riscope/&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://djbetancourt-gh.github.io/funGp/">https://djbetancourt-gh.github.io/funGp/</a>,
<a href="https://github.com/djbetancourt-gh/funGp">https://github.com/djbetancourt-gh/funGp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/djbetancourt-gh/funGp/issues">https://github.com/djbetancourt-gh/funGp/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, foreach, knitr, scales, microbenchmark, doFuture,
doRNG, future, progressr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'0_funGp_Doc.R' '0_show_Doc.R' '0_summary_Doc.R'
'8_outilsCode.R' '3_ant_admin.R' '2_fgpKern_Class.R'
'2_fgpProj_Class.R' '1_fgpm_Class.R' '1_Xfgpm_Class.R'
'3_ant_search.R' '3_training_F.R' '3_training_S.R'
'3_training_SF.R' '4_prediction_F.R' '4_prediction_S.R'
'4_prediction_SF.R' '5_simulation_F.R' '5_simulation_S.R'
'5_simulation_SF.R' '6_updating.R' '7_blackBoxFunctions.R'
'7_checkingFunctions.R' '7_correlFunctions.R'
'7_dimRedFunctions.R' '7_distanceFunctions.R'
'7_plottingFunctions.R' '7_plottingFunctionsStandard.R'
'8_outilsStats.R' '8_precalculated_Xfgpm_objects.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-25 07:24:37 UTC; djbet</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose Betancourt [cre, aut],
  François Bachoc [aut],
  Thierry Klein [aut],
  Jeremy Rohmer [aut],
  Yves Deville [ctb],
  Deborah Idier [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-25 07:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+5B+2CXfgpm-method'>Refit a <code>fgpm</code> model in a <code>Xfgpm</code> object</h2><span id='topic++5B+5B+2CXfgpm-method'></span>

<h3>Description</h3>

<p>Refit a <code>fgpm</code> model as described in a <code>Xfgpm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Xfgpm'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B+2B2CXfgpm-method_+3A_x">x</code></td>
<td>
<p>A <code>Xfgpm</code> object.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B2CXfgpm-method_+3A_i">i</code></td>
<td>
<p>An integer giving the index of the model to refit. The
models are in decreasing fit quality as assessed by the
Leave-One-Out <code class="reqn">Q^2</code>.</p>
</td></tr>
</table>


<h3>Caution</h3>

<p>While the syntax may suggest that the function
<em>extracts</em> a fitted <code>fgpm</code> model, this not true. The
<code>fgpm</code> model is refitted using the call that was used
when this model was assessed. The refitted <code>fgpm</code> model
keeps the same structural parameters as the one assessed
(active variables, kernel, ...), but since the optimization
uses random initial values, the optimized hyper-parameters may
differ from those of the corresponding <code>fgpm</code> in the
<code>Xfgpm</code> object <code>x</code>. As a result, the model can be
different and show a different LOO performance.
</p>


<h3>Note</h3>

<p>The slot <code>@model</code> returns the best <code>fgpm</code> as
assessed in a <code>Xfgm</code> model <code>x</code>. So this model can be
expected to be close to the same as <code>x[[1]]</code>. Yet due to
the refit, the two models <code>x@model</code> and <code>x[[1]]</code> can
differ, see the explanations in the <b>Caution</b> section.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+modelDef">modelDef</a></code> function to extract the
definition of a <code>fgpm</code> model e.g., to evaluate it using new
data <code>sIn</code>, <code>fIn</code> and <code>sOut</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see `?xm` to see how to recreate the pre-caclulated `Xfgpm` object `xm`.
xm[[2]]

</code></pre>

<hr>
<h2 id='antsLog-class'>S4 class for log of models explored by ant colony in funGp</h2><span id='topic+antsLog-class'></span>

<h3>Description</h3>

<p>Register of model structures and their performance statistics, if available.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sols</code></dt><dd><p>Object of class <code>"data.frame"</code>. Compendium of model structures arranged by rows. Each
column is linked to one structural parameter of the model such as the state of one variable (inactive,
active) or the type of kernel function.</p>
</dd>
<dt><code>args</code></dt><dd><p>Object of class <code>"list"</code>. Compendium of model structures represented by objects of class
<code>"<a href="#topic+modelCall-class">modelCall</a>"</code>.</p>
</dd>
<dt><code>fitness</code></dt><dd><p>Object of class <code>"numeric"</code>. Performance statistic of each model, if available.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

<hr>
<h2 id='black-boxes'>Analytic models for the exploration of the funGp package</h2><span id='topic+black-boxes'></span><span id='topic+fgp_BB1'></span><span id='topic+fgp_BB2'></span><span id='topic+fgp_BB3'></span><span id='topic+fgp_BB4'></span><span id='topic+fgp_BB5'></span><span id='topic+fgp_BB6'></span><span id='topic+fgp_BB7'></span>

<h3>Description</h3>

<p>Set of analytic functions that take functional
variables as inputs.  Since they run quickly, they can be used
for testing of <span class="pkg">funGp</span> functionalities as if they were black box
computer models. They cover different situations (number of
scalar inputs and complexity of the inputs-output mathematical
relationship).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgp_BB1(sIn, fIn, n.tr)

fgp_BB2(sIn, fIn, n.tr)

fgp_BB3(sIn, fIn, n.tr)

fgp_BB4(sIn, fIn, n.tr)

fgp_BB5(sIn, fIn, n.tr)

fgp_BB6(sIn, fIn, n.tr)

fgp_BB7(sIn, fIn, n.tr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="black-boxes_+3A_sin">sIn</code></td>
<td>
<p>Object with class <code>"matrix"</code>. The scalar input
points. Variables are arranged by columns and coordinates by rows.</p>
</td></tr>
<tr><td><code id="black-boxes_+3A_fin">fIn</code></td>
<td>
<p>Object with class <code>"list"</code>. The functional inputs.
Each element of the list must be a matrix containing the set of curves
corresponding to one functional input.</p>
</td></tr>
<tr><td><code id="black-boxes_+3A_n.tr">n.tr</code></td>
<td>
<p>Object with class <code>"numeric"</code>. The number of
input points provided and correspondingly, the number of observations
to produce.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all the functions, the <code class="reqn">d_s</code> scalar inputs
<code class="reqn">x_i</code> are in the real interval <code class="reqn">[0,\,1]</code> and
the <code class="reqn">d_f</code> functional inputs
<code class="reqn">f_i(t_i)</code> are defined on the interval
<code class="reqn">[0,\,1]</code>. Expressions for the values are as follows.
</p>

<ul>
<li><p><b><code>fgp_BB1 </code></b>With <code class="reqn">d_s = 2</code> <code class="reqn">d_f = 2</code>
</p>
<pre>
   x1 * sin(x2) + x1 * mean(f1) - x2^2 * diff(range(f2))</pre>
</li>
<li><p><b><code>fgp_BB2 </code></b>With <code class="reqn">d_s = 2</code> and <code class="reqn">d_f = 2</code>
</p>
<pre>
   x1 * sin(x2) + mean(exp(x1 * t1) * f1) - x2^2 * mean(f2^2 * t2)</pre>
</li>
<li><p><b><code>fgp_BB3 </code></b>With  <code class="reqn">d_s = 2</code> and <code class="reqn">d_f = 2</code>
is the first analytical example in Muehlenstaedt et al (2017)
</p>
<pre>
   x1 + 2 * x2 + 4 * mean(t1 * f1) + mean(f2)</pre>
</li>
<li><p><b><code>fgp_BB4 </code></b>With  <code class="reqn">d_s = 2</code> and <code class="reqn">d_f = 2</code> is the
second analytical example in <em>preprint</em> of Muehlenstaedt et al (2017)
</p>
<pre>
   (x2 - (5 / (4 * pi^2)) * x1^2 + (5 / pi) * x1 - 6)^2 +
       10 * (1 - (1 / (8 * pi))) * cos(x1) + 10 +
       (4 / 3) * pi * (42 * mean(f1 * (1 - t1)) +
                       pi * ((x1 + 5) / 5) + 15) * mean(t2 * f2))</pre>
</li>
<li><p><b><code>fgp_BB5 </code></b>With  <code class="reqn">d_s=2</code> and <code class="reqn">d_f=2</code> is
inspired by the  second analytical example in <em>final version</em> of Muehlenstaedt et al (2017)
</p>
<pre>
   (x2 - (5 / (4 * pi^2)) * x1^2 + (5 / pi) * x1 - 6)^2 +
       10 * (1 - (1 / (8 * pi))) * cos(x1) + 10 +
       (4 / 3) * pi * (42 * mean(15 * f1 * (1 - t1) - 5) +
                       pi * ((x1 + 5) / 5) + 15) * mean(15 * t2 * f2))</pre>
</li>
<li><p><b><code>fgp_BB6 </code></b>With  <code class="reqn">d_s = 2</code> and <code class="reqn">d_f = 2</code>
is inspired by the analytical example in Nanty et al (2016)
</p>
<pre>
   2 * x1^2 + 2 * mean(f1 + t1) + 2 * mean(f2 + t2) + max(f2) + x2</pre>
</li>
<li><p><b><code>fgp_BB7 </code></b>With <code class="reqn">d_s = 5</code> and <code class="reqn">d_f = 2</code> is
inspired by the second analytical example in <em>final version</em> of Muehlenstaedt et al (2017)
</p>
<pre>
   (x2 + 4 * x3 - (5 / (4 * pi^2)) * x1^2 + (5 / pi) * x1 - 6)^2 +
       10 * (1 - (1 / (8 * pi))) * cos(x1) * x2^2 * x5^3 + 10 +
       (4 / 3) * pi * (42 * sin(x4) * mean(15 * f1 * (1 - t1) - 5) +
                       pi * (((x1 * x5 + 5) / 5) + 15) * mean(15 * t2 * f2))</pre>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"matrix"</code> with the values of the output at the specified input coordinates.
</p>


<h3>Note</h3>

<p>The functions listed above were used to validate the functionality and stability of this package.
Several tests involving <a href="#topic+funGp-package">all main functions, plotters and getters</a> were run
for scalar-input, functional-input and hybrid-input models. In all cases, the output of the functions
were correct from the statistical and programmatic perspectives. For an example on the kind of tests
performed, the interested user is referred to
<a href="https://hal.archives-ouvertes.fr/hal-02536624">the introductory funGp manual</a>.
</p>


<h3>References</h3>

<p>Muehlenstaedt, T., Fruth, J., and Roustant, O. (2017),
&quot;Computer experiments with functional inputs and scalar outputs by a norm-based approach&quot;.
<em>Statistics and Computing</em>, <strong>27</strong>, 1083-1097.
<a href="https://link.springer.com/article/10.1007/s11222-016-9672-z">[SC]</a>
</p>
<p>Nanty, S., Helbert, C., Marrel, A., Pérot, N., and Prieur, C. (2016),
&quot;Sampling, metamodeling, and sensitivity analysis of numerical simulators with functional stochastic inputs&quot;.
<em>SIAM/ASA Journal on Uncertainty Quantification</em>, <strong>4</strong>(1), 636-659.
<a href="https://doi.org/10.1137/15M1033319">doi:10.1137/15M1033319</a>
</p>

<hr>
<h2 id='decay'>Decay functions for ant colony optimization in funGp</h2><span id='topic+decay'></span>

<h3>Description</h3>

<p>This function is intended to aid the selection of the heuristic parameters <em>tao0</em>,
<em>delta</em> and <em>dispr</em> in the call to the model selection function <a href="#topic+fgpm_factory">fgpm_factory</a>.
The values computed by decay are the ones that would be used by the ant colony algorithm as initial
pheromone load of the links pointing out to projection on each dimension. For more details, check the
<a href="https://hal.archives-ouvertes.fr/hal-02532713">technical report</a>
explaining the ant colony algorithm implemented in funGp, and the
<a href="https://hal.archives-ouvertes.fr/hal-02536624">
manual</a> of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay(
  k,
  pmax = NULL,
  tao0 = 0.1,
  delta = 2,
  dispr = 1.4,
  doplot = TRUE,
  deliver = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay_+3A_k">k</code></td>
<td>
<p>A number indicating the dimension of the functional input under analysis.</p>
</td></tr>
<tr><td><code id="decay_+3A_pmax">pmax</code></td>
<td>
<p>An optional number specifying the hypothetical maximum projection dimension of this input. The
user will be able to set this value later in the call to <a href="#topic+fgpm_factory">fgpm_factory</a> as a constraint. If
not specified, it takes the value of k.</p>
</td></tr>
<tr><td><code id="decay_+3A_tao0">tao0</code></td>
<td>
<p>Explained in the description of <em>dispr</em>.</p>
</td></tr>
<tr><td><code id="decay_+3A_delta">delta</code></td>
<td>
<p>Explained in the description of <em>dispr</em>.</p>
</td></tr>
<tr><td><code id="decay_+3A_dispr">dispr</code></td>
<td>
<p>The arguments <em>tao0</em>, <em>delta</em> and <em>dispr</em>, are optional numbers specifying the
loss function that determines the initial pheromone load on the links pointing out to projection
dimensions. Such a function is defined as
</p>
<p style="text-align: center;"><code class="reqn">tao = tao0 * exp(-.5 * ((p - delta - 1)^2/(-dispr^2/(2*log(.5)),</code>
</p>

<p>with p taking the values of the projection dimensions. The argument <em>tao0</em> indicates the pheromone
load in the links pointing out to the smallest dimensions; <em>delta</em> specifies how many dimensions
should preserve the maximum pheromone load; <em>dispr</em> determines how fast the pheromone load drops
in dimensions further than <code class="reqn">delta + 1</code>. If <em>pmax</em> = <em>k</em>, then the dimension 0,
representing no projection, receives a pheromone load identical to that of dimension <em>k</em>. This, in
order to represent the fact that both the representation of the function in its original dimension or
a projection in a space of the same dimension, are equally heavy for the model. The default values of
<em>tao0</em>, <em>delta</em> and <em>dispr</em>, are 0.1, 2 and 1.4, respectively, which match the default
values used by the <a href="#topic+fgpm_factory">fgpm_factory</a> function. Check
<a href="https://hal.archives-ouvertes.fr/hal-02532713">this technical
report</a> for more details.</p>
</td></tr>
<tr><td><code id="decay_+3A_doplot">doplot</code></td>
<td>
<p>An optional boolean indicating if the pheromone loads should be plotted. Default = TRUE.</p>
</td></tr>
<tr><td><code id="decay_+3A_deliver">deliver</code></td>
<td>
<p>An optional boolean indicating if the pheromone loads should be returned. Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If deliver is TRUE, an object of class <code>"numeric"</code> containing the initial pheromone values
corresponding to the specified projection dimensions. Otherwise, the function plots the pheromones and
nothing is returned.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+decay2probs">decay2probs</a> for the function to generate the initial probability load;
</p>
<p><strong>*</strong> <a href="#topic+fgpm_factory">fgpm_factory</a> for heuristic funGp model selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using default decay arguments____________________________________________________________
# input of dimension 15 projected maximum in dimension 15
decay(15)

# input of dimension 15 projected maximum in dimension 8
decay(15, 8)


# playing with decay arguments_____________________________________________________________
# input of dimension 15 projected maximum in dimension 15
decay(15)

# using a larger value of tao0
decay(15, tao0 = .3)

# using a larger value of tao0, keeping it fixed up to higher dimensions
decay(15, tao0 = .3, delta = 5)

# using a larger value of tao0, keeping it fixed up to higher dimensions, with slower decay
decay(15, tao0 = .3, delta = 5, dispr = 5.2)


# requesting pheromone values______________________________________________________________
# input of dimension 15 projected maximum in dimension 15
decay(15, deliver = TRUE)

</code></pre>

<hr>
<h2 id='decay2probs'>Probability functions for ant colony optimization in funGp</h2><span id='topic+decay2probs'></span>

<h3>Description</h3>

<p>This function is intended to aid the selection of the heuristic parameters <em>tao0</em>,
<em>delta</em> and <em>dispr</em> in the call to the model selection function <a href="#topic+fgpm_factory">fgpm_factory</a>.
The values computed by decay2probs are the ones that would be used by the ant colony algorithm as
probability load of the links pointing out to projection on each dimension. These values result from
the normalization of the initial pheromone loads delivered by the <a href="#topic+decay">decay</a> function, which
are made to sum 1. For more details, check the
<a href="https://hal.archives-ouvertes.fr/hal-02532713">technical report</a>
explaining the ant colony algorithm implemented in funGp, and the
<a href="https://hal.archives-ouvertes.fr/hal-02536624">
manual</a> of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay2probs(
  k,
  pmax = NULL,
  tao0 = 0.1,
  delta = 2,
  dispr = 1.4,
  doplot = TRUE,
  deliver = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay2probs_+3A_k">k</code></td>
<td>
<p>A number indicating the dimension of the functional input under analysis.</p>
</td></tr>
<tr><td><code id="decay2probs_+3A_pmax">pmax</code></td>
<td>
<p>An optional number specifying the hypothetical maximum projection dimension of this input. The
user will be able to set this value later in the call to <a href="#topic+fgpm_factory">fgpm_factory</a> as a constraint. If
not specified, it takes the value of k.</p>
</td></tr>
<tr><td><code id="decay2probs_+3A_tao0">tao0</code></td>
<td>
<p>Explained in the description of <em>dispr</em>.</p>
</td></tr>
<tr><td><code id="decay2probs_+3A_delta">delta</code></td>
<td>
<p>Explained in the description of <em>dispr</em>.</p>
</td></tr>
<tr><td><code id="decay2probs_+3A_dispr">dispr</code></td>
<td>
<p>The arguments <em>tao0</em>, <em>delta</em> and <em>dispr</em>, are optional numbers specifying the
loss function that determines the initial pheromone load on the links pointing out to projection
dimensions. Such a function is defined as
</p>
<p style="text-align: center;"><code class="reqn">tao = tao0 * exp(-.5 * ((p - delta - 1)^2/(-dispr^2/(2*log(.5)),</code>
</p>

<p>with p taking the values of the projection dimensions. The argument <em>tao0</em> indicates the pheromone
load in the links pointing out to the smallest dimensions; <em>delta</em> specifies how many dimensions
should preserve the maximum pheromone load; <em>dispr</em> determines how fast the pheromone load drops
in dimensions further than <code class="reqn">delta + 1</code>. If <em>pmax</em> = <em>k</em>, then the dimension 0,
representing no projection, receives a pheromone load identical to that of dimension <em>k</em>. This, in
order to represent the fact that both the representation of the function in its original dimension or
a projection in a space of the same dimension, are equally heavy for the model. In order to obtain the
probability loads, the initial pheromone values are normalized to sum 1. Note that the normalization
makes the value of tao0 become irrelevant in the initial probability load. This does not mean that the
effect of tao0 is completely removed from the algorithm. Despite the fact that tao0 does not have
influence on the selection of the projection dimension during the first iteration, it will be
protagonist during the global pheromone update and will have an impact on every further iteration.
The argument tao0 is left active in the input just for a better comprehension of the functioning of the
mechanisms defining the initial pheromone and probability loads. The default values of
<em>tao0</em>, <em>delta</em> and <em>dispr</em>, are 0.1, 2 and 1.4, respectively, which match the default
values used by the <a href="#topic+fgpm_factory">fgpm_factory</a> function. Check
<a href="https://hal.archives-ouvertes.fr/hal-02532713">this technical
report</a> for more details.</p>
</td></tr>
<tr><td><code id="decay2probs_+3A_doplot">doplot</code></td>
<td>
<p>An optional boolean indicating if the probability loads should be plotted. Default = TRUE.</p>
</td></tr>
<tr><td><code id="decay2probs_+3A_deliver">deliver</code></td>
<td>
<p>An optional boolean indicating if the probability loads should be returned. Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If deliver is TRUE, an object of class <code>"numeric"</code> containing the normalized initial pheromone values
corresponding to the specified projection dimensions. Otherwise, the function plots the normalized
pheromones and nothing is returned.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+decay">decay</a> for the function to generate the initial pheromone load;
</p>
<p><strong>*</strong> <a href="#topic+fgpm_factory">fgpm_factory</a> for heuristic model selection in funGp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using default decay arguments____________________________________________________________
# input of dimension 15 projected maximum in dimension 15
decay(15) # initial pheromone load
decay2probs(15) # initial probability load

# input of dimension 15 projected maximum in dimension 8
decay(15, 8) # initial pheromone load
decay2probs(15, 8) # initial probability load


# playing with decay2probs arguments_______________________________________________________
# varying the initial pheromone load
decay(15) # input of dimension 15 projected maximum in dimension 15
decay(15, tao0 = .3) # larger value of tao0
decay(15, tao0 = .3, delta = 5) # larger tao0 kept to higher dimensions
decay(15, tao0 = .3, delta = 5, dispr = 5.2) # larger tao0 kept to higher dimensions
                                             # and slower decay

# varying the initial probability load
decay2probs(15) # input of dimension 15 projected maximum in dimension 15
decay2probs(15, tao0 = .3) # larger value of tao0 (no effect whatsoever)
decay2probs(15, tao0 = .3, delta = 5) # larger tao0 kept to higher dimensions
decay2probs(15, tao0 = .3, delta = 5, dispr = 5.2) # larger tao0 kept to higher dimensions
                                                   # and slower decay


# requesting probability values____________________________________________________________
# input of dimension 15 projected maximum in dimension 15
decay2probs(15, deliver = TRUE)

</code></pre>

<hr>
<h2 id='factoryCall-class'>S4 class for fgpm_factory function calls</h2><span id='topic+factoryCall-class'></span>

<h3>Description</h3>

<p>User reminder of the <a href="#topic+fgpm">fgpm</a> function call.
</p>


<h3>Slots</h3>


<dl>
<dt><code>string</code></dt><dd><p>Object of class <code>"character"</code>. User call reminder in string format.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

<hr>
<h2 id='fgpKern-class'>S4 class for structures linked to the kernel of a <code>fgpm</code> model</h2><span id='topic+fgpKern-class'></span>

<h3>Description</h3>

<p>This is the formal representation for data structures linked to the kernel of a Gaussian
process model within the <a href="#topic+funGp-package">funGp package</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>kerType</code></dt><dd><p>Object of class <code>"character"</code>. Kernel type. To be set from &quot;gauss&quot;, &quot;matern5_2&quot;,
&quot;matern3_2&quot;.</p>
</dd>
<dt><code>f_disType</code></dt><dd><p>Object of class <code>"character"</code>. Distance type. To be set from &quot;L2_bygroup&quot;,
&quot;L2_index&quot;.</p>
</dd>
<dt><code>varHyp</code></dt><dd><p>Object of class <code>"numeric"</code>. Estimated variance parameter.</p>
</dd>
<dt><code>s_lsHyps</code></dt><dd><p>Object of class <code>"numeric"</code>. Estimated length-scale parameters for scalar inputs.</p>
</dd>
<dt><code>f_lsHyps</code></dt><dd><p>Object of class <code>"numeric"</code>. Estimated length-scale parameters for functional
inputs.</p>
</dd>
<dt><code>f_lsOwners</code></dt><dd><p>Object of class <code>"character"</code>. Index of functional input variable linked to each
element in <em>f_lsHyps</em></p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

<hr>
<h2 id='fgpm'>Gaussian process models for scalar and functional inputs</h2><span id='topic+fgpm'></span>

<h3>Description</h3>

<p>This function enables fitting of Gaussian process regression models. The inputs can be
either scalar, functional or a combination of both types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgpm(
  sIn = NULL,
  fIn = NULL,
  sOut,
  kerType = "matern5_2",
  f_disType = "L2_bygroup",
  f_pdims = 3,
  f_basType = "B-splines",
  var.hyp = NULL,
  ls_s.hyp = NULL,
  ls_f.hyp = NULL,
  nugget = 1e-08,
  n.starts = 1,
  n.presample = 20,
  par.clust = NULL,
  trace = TRUE,
  pbars = TRUE,
  control.optim = list(trace = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgpm_+3A_sin">sIn</code></td>
<td>
<p>An optional matrix of scalar input values to train the model. Each column must match an input
variable and each row a training point. Either scalar input coordinates (sIn), functional input
coordinates (fIn), or both must be provided.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_fin">fIn</code></td>
<td>
<p>An optional list of functional input values to train the model. Each element of the list must
be a matrix containing the set of curves corresponding to one functional input. Either scalar input
coordinates (sIn), functional input coordinates (fIn), or both must be provided.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_sout">sOut</code></td>
<td>
<p>A vector (or 1-column matrix) containing the values of the scalar output at the specified
input points.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_kertype">kerType</code></td>
<td>
<p>An optional character string specifying the covariance structure to be used. To be chosen
between &quot;gauss&quot;, &quot;matern5_2&quot; and &quot;matern3_2&quot;. Default is &quot;matern5_2&quot;.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_f_distype">f_disType</code></td>
<td>
<p>An optional array of character strings specifying the distance function to be used for
each functional coordinates within the covariance function of the Gaussian process. To be chosen between
&quot;L2_bygroup&quot; and &quot;L2_byindex&quot;. The L2_bygroup distance considers each curve as a whole and uses a single
length-scale parameter per functional input variable. The L2_byindex distance uses as many length-scale
parameters per functional input as discretization points it has. For instance an input discretized as
a vector of size 8 will use 8 length-scale parameters when using L2_byindex. If dimension reduction of
a functional input is requested, then L2_byindex uses as many length scale parameters as effective
dimensions used to represent the input. A single character string can also be passed as a general
selection for all the functional inputs of the model. More details in
<a href="https://www.sciencedirect.com/science/article/abs/pii/S0951832019301693">
the reference article</a>
and
<a href="https://hal.archives-ouvertes.fr/hal-02536624">
the in-depth package manual</a>. Default is &quot;L2_bygroup&quot;.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_f_pdims">f_pdims</code></td>
<td>
<p>An optional array with the projection dimension for each functional input. For each input,
the projection dimension should be an integer between 0 and its original dimension, with 0 denoting
no projection. A single character string can also be passed as a general selection for all the functional
inputs of the model. Default is 3.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_f_bastype">f_basType</code></td>
<td>
<p>An optional array of character strings specifying the family of basis functions to be used
in the projection of each functional input. To be chosen between &quot;B-splines&quot; and &quot;PCA&quot;. A single character
string can also be passed as a general selection for all the functional inputs of the model. This argument
will be ignored for those inputs for which no projection was requested (i.e., for which f_pdims = 0).
Default is &quot;B-splines&quot;.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_var.hyp">var.hyp</code></td>
<td>
<p>An optional number indicating the value that should be used as the variance parameter of the
model. If not provided, it is estimated through likelihood maximization.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_ls_s.hyp">ls_s.hyp</code></td>
<td>
<p>An optional numeric array indicating the values that should be used as length-scale parameters
for the scalar inputs. If provided, the size of the array should match the number of scalar inputs. If not
provided, these parameters are estimated through likelihood maximization.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_ls_f.hyp">ls_f.hyp</code></td>
<td>
<p>An optional numeric array indicating the values that should be used as length-scale parameters
for the functional inputs. If provided, the size of the array should match the number of effective dimensions.
Each input using the &quot;L2_bygroup&quot; distance will count 1 effective dimension, and each input using the
&quot;L2_byindex&quot; distance will count as many effective dimensions as specified by the corresponding element of
the f_pdims argument. For instance, two functional inputs of original dimensions 10 and 22, the first one
projected onto a space of dimension 5 with &quot;L2_byindex&quot; distance, and the second one not projected with
&quot;L2_bygroup&quot; distance will make up a total of 6 effective dimensions; five for the first functional input and
one for second one. If this argument is not provided, the functional length-scale parameters are estimated
through likelihood maximization.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_nugget">nugget</code></td>
<td>
<p>An optional variance value standing for the homogeneous nugget effect. A tiny nugget might help
to overcome numerical problems related to the ill-conditioning of the covariance matrix. Default is 1e-8.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_n.starts">n.starts</code></td>
<td>
<p>An optional integer indicating the number of initial points to use for the optimization of the
hyperparameters. A parallel processing cluster can be exploited in order to speed up the evaluation of
multiple initial points. More details in the description of the argument par.clust below. Default is 1.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_n.presample">n.presample</code></td>
<td>
<p>An optional integer indicating the number of points to be tested in order to select the
n.starts initial points. The n.presample points will be randomly sampled from the hyper-rectangle defined by: <br /> <br />
1e-10 <code class="reqn">\le</code> <code>ls_s.hyp[i]</code> <code class="reqn">\le</code> 2*max(<code>sMs[[i]]</code>), for i in 1 to the number of scalar inputs, <br />
1e-10 <code class="reqn">\le</code> <code>ls_f.hyp[i]</code> <code class="reqn">\le</code> 2*max(<code>fMs[[i]]</code>), for i in 1 to the number of functional inputs, <br /> <br />
with  sMs and fMs the lists of distance matrices for the scalar and functional inputs, respectively. The value of
n.starts will be assigned to n.presample if this last is smaller. Default is 20.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_par.clust">par.clust</code></td>
<td>
<p>An optional parallel processing cluster created with the <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function
of the <a href="lattice.html#topic+parallel">parallel package</a>. If not provided, multistart optimizations are done in sequence.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_trace">trace</code></td>
<td>
<p>An optional boolean indicating if control messages native of the <a href="#topic+funGp-package">funGp package</a> should be printed to
console. Default is TRUE. For complementary control on the display of funGp-native progress bars and
<code><a href="stats.html#topic+optim">optim</a></code> trace about the hyperparameter optimization process, have a look at the <code>pbars</code> and
<code>control.optim</code> arguments, respectively.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_pbars">pbars</code></td>
<td>
<p>An optional boolean indicating if progress bars should be displayed. Default is TRUE.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_control.optim">control.optim</code></td>
<td>
<p>An optional list to be passed as the <code>control</code> argument to <code><a href="stats.html#topic+optim">optim</a></code>, the function
in charge of the non-linear optimization of the hyperparameters. Default is <code>list(trace = TRUE)</code>, equivalent to
<code>list(trace = 1)</code>, which enables the printing of tracing information on the progress of the optimization. Before
interacting with the <code><a href="#topic+fgpm">fgpm</a>()</code> <code>control.optim</code> argument, please carefully check the documentation about
the <code>control</code> argument provided in <code><a href="stats.html#topic+optim">optim</a></code> to ensure a coherent behavior and sound results. Note
that: (i) at this time, only the <code>"L-BFGS-B"</code> method (Byrd et. al., 1995) is enabled in <code><a href="#topic+fgpm">fgpm</a>()</code>;
(ii) <code>control.optim$fnscale</code> should not be used since our optimization problem is strictly of minimization, not maximization.</p>
</td></tr>
<tr><td><code id="fgpm_+3A_...">...</code></td>
<td>
<p>Extra control parameters. Currently only used internally for some <code>update()</code> calls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+fgpm-class">fgpm</a> containing the data structures representing the fitted funGp model.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>References</h3>

<p>Betancourt, J., Bachoc, F., Klein, T., Idier, D., Pedreros, R., and Rohmer, J. (2020),
&quot;Gaussian process metamodeling of functional-input code for coastal flood hazard assessment&quot;.
<em>Reliability Engineering &amp; System Safety</em>, <strong>198</strong>, 106870.
<a href="https://www.sciencedirect.com/science/article/abs/pii/S0951832019301693">[RESS]</a>
<a href="https://hal.archives-ouvertes.fr/hal-01998724">[HAL]</a>
</p>
<p>Betancourt, J., Bachoc, F., Klein, T., and Gamboa, F. (2020),
Technical Report: &quot;Ant Colony Based Model Selection for Functional-Input Gaussian Process Regression. Ref. D3.b (WP3.2)&quot;.
<em>RISCOPE project</em>.
<a href="https://hal.archives-ouvertes.fr/hal-02532713">[HAL]</a>
</p>
<p>Betancourt, J., Bachoc, F., and Klein, T. (2020),
R Package Manual: &quot;Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour&quot;.
<em>RISCOPE project</em>.
<a href="https://hal.archives-ouvertes.fr/hal-02536624">[HAL]</a>
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+plot+2Cfgpm-method">plot,fgpm-method</a>: validation plot for a <code>fgpm</code> model;
</p>
<p><strong>*</strong> <a href="#topic+predict+2Cfgpm-method">predict,fgpm-method</a> for predictions based on a <code>fgpm</code> model;
</p>
<p><strong>*</strong> <a href="#topic+simulate+2Cfgpm-method">simulate,fgpm-method</a> for simulations based on a <code>fgpm</code> model;
</p>
<p><strong>*</strong> <a href="#topic+update+2Cfgpm-method">update,fgpm-method</a> for post-creation updates on a <code>fgpm</code> model;
</p>
<p><strong>*</strong> <a href="#topic+fgpm_factory">fgpm_factory</a> for funGp heuristic model selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating funGp model using default fgpm arguments________________________________________
# generating input data for training
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))

# generating output data for training
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)

# building a scalar-input funGp model
ms &lt;- fgpm(sIn = sIn, sOut = sOut)

# building a functional-input funGp model
mf &lt;- fgpm(fIn = fIn, sOut = sOut)

# building a hybrid-input funGp model
msf &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# plotting the three models
plot(ms)
plot(mf)
plot(msf)

# printing the three models
summary(ms) # equivalent to show(ms)
summary(mf) # equivalent to show(mf)
summary(msf) # equivalent to show(msf)


# recovering useful information from a funGp model_________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# recovering data from model slots
m1@f_proj@coefs # list of projection coefficients for the functional inputs
m1@f_proj@basis # list of projection basis functions for the functional inputs
Map(function(a, b) a %*% t(b), m1@f_proj@coefs, m1@f_proj@basis) # list of projected
                                                                 # functional inputs
tcrossprod(m1@preMats$L) # training auto-covariance matrix


# making predictions based on a funGp model________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# generating input data for prediction
n.pr &lt;- 100
sIn.pr &lt;- as.matrix(expand.grid(x1 = seq(0,1,length = sqrt(n.pr)),
                                x2 = seq(0,1,length = sqrt(n.pr))))
fIn.pr &lt;- list(f1 = matrix(runif(n.pr*10), ncol = 10), matrix(runif(n.pr*22), ncol = 22))

# making predictions
m1.preds &lt;- predict(m1, sIn.pr = sIn.pr, fIn.pr = fIn.pr)

# plotting predictions
plot(m1.preds)


# simulating from a funGp model____________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# generating input data for simulation
n.sm &lt;- 100
sIn.sm &lt;- as.matrix(expand.grid(x1 = seq(0,1,length = sqrt(n.sm)),
                                x2 = seq(0,1,length = sqrt(n.sm))))
fIn.sm &lt;- list(f1 = matrix(runif(n.sm*10), ncol = 10), matrix(runif(n.sm*22), ncol = 22))

# making simulations
m1.sims &lt;- simulate(m1, nsim = 10, sIn.sm = sIn.sm, fIn.sm = fIn.sm)

# plotting simulations
plot(m1.sims)


# creating funGp model using custom fgpm arguments_________________________________________
# generating input and output data
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)

# original dimensions
# f1: 10
# f2: 22

# building a the model with the following structure
#    - Kernel: Gaussian
#    - f1: L2_byindex distance, no projection -&gt; 10 length-scale parameters
#    - f2: L2_bygroup distance, B-spline basis of dimension 5 -&gt; 1 length-scale parameter
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut,
           kerType = "gauss", f_disType = c("L2_byindex", "L2_bygroup"),
           f_pdims = c(0,5), f_basType = c(NA, "B-splines"))

# plotting the model
plot(m1)

# printing the model
m1 # equivalent to show(m1)

## Not run: 
# multistart and parallelization in fgpm___________________________________________________
# generating input and output data
set.seed(100)
n.tr &lt;- 243
sIn &lt;- expand.grid(x1 = seq(0,1,length = n.tr^(1/5)), x2 = seq(0,1,length = n.tr^(1/5)),
                   x3 = seq(0,1,length = n.tr^(1/5)), x4 = seq(0,1,length = n.tr^(1/5)),
                   x5 = seq(0,1,length = n.tr^(1/5)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB7(sIn, fIn, n.tr)

# calling fgpm with multistart in parallel
cl &lt;- parallel::makeCluster(2)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut, n.starts = 10, par.clust = cl) # (~14 seconds)
parallel::stopCluster(cl)

# NOTE: in order to provide progress bars for the monitoring of time consuming processes
#       ran in parallel, funGp relies on the doFuture and future packages. Parallel processes
#       suddenly interrupted by the user tend to leave corrupt connections. This problem is
#       originated outside funGp, which limits our control over it. In the manual
#       of funGp, we provide a temporary solution to the issue and we remain attentive in
#       case it appears a more elegant way to handle it or a manner to suppress it.
#
#       funGp manual: https://hal.archives-ouvertes.fr/hal-02536624

## End(Not run)

</code></pre>

<hr>
<h2 id='fgpm_factory'>Structural optimization of Gaussian process models</h2><span id='topic+fgpm_factory'></span>

<h3>Description</h3>

<p>This function enables the smart exploration of the solution space of potential structural
configurations of a funGp model, and the consequent selection of a high quality configuration. funGp
currently relies on an ant colony based algorithm to perform this task. The algorithm defines the
solution space based on the levels of each structural parameter currently available in the
<a href="#topic+fgpm">fgpm</a> function, and performs a smart exploration of it. More details on the algorithm are
provided in a dedicated
<a href="https://hal.archives-ouvertes.fr/hal-02532713">technical report</a>.
funGp might evolve in the future to include improvements in the current algorithm or alternative
solution methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgpm_factory(
  sIn = NULL,
  fIn = NULL,
  sOut = NULL,
  ind.vl = NULL,
  ctraints = list(),
  setup = list(),
  time.lim = Inf,
  nugget = 1e-08,
  n.starts = 1,
  n.presample = 20,
  par.clust = NULL,
  trace = TRUE,
  pbars = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgpm_factory_+3A_sin">sIn</code></td>
<td>
<p>An optional matrix of scalar input values to train the model. Each column must match an input
variable and each row a training point. Either scalar input coordinates (sIn), functional input
coordinates (fIn), or both must be provided.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_fin">fIn</code></td>
<td>
<p>An optional list of functional input values to train the model. Each element of the list must
be a matrix containing the set of curves corresponding to one functional input. Either scalar input
coordinates (sIn), functional input coordinates (fIn), or both must be provided.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_sout">sOut</code></td>
<td>
<p>A vector (or 1-column matrix) containing the values of the scalar output at the specified
input points.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_ind.vl">ind.vl</code></td>
<td>
<p>An optional numerical matrix specifying which points in the three structures above should be
used for training and which for validation. If provided, the optimization will be conducted in terms of
the hold-out coefficient of determination Q², which comes from training the model with a subset of the points, and then estimating the
prediction error in the remaining points. In that case, each column of <em>ind.vl</em> will be interpreted
as one validation set, and the multiple columns will imply replicates. In the simplest case,
<em>ind.vl</em> will be a one-column matrix or simply an array, meaning that a simple replicate should be
used for each model configuration explored. If not provided, the optimization will be conducted in terms
of the leave-one-out cross-validation Q², which for a total number of n observations, comes from training
the model n times, each using n-1 points for training and the remaining one for validation. This procedure
is typically costly due to the large number of hyperparameter optimizations that should be conducted,
nonetheless, fgpm_factory implements the virtual equations introduced by Dubrule (1983) for Gaussian
processes, which require a single hyperparameter optimization. See the reference below for more details.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_ctraints">ctraints</code></td>
<td>
<p>An optional list specifying the constraints of the structural optimization problem. Valid
entries for this list are: <br /><br />
<strong>*</strong><em>s_keepOn</em>: a numerical array indicating the scalar inputs that should remain active in the
model. It should contain the indices of the columns of sIn corresponding to the inputs to keep active. <br /><br />
<strong>*</strong><em>f_keepOn</em>: a numerical array indicating the functional inputs that should remain active in
the model. It should contain the indices of the elements of fIn corresponding to the inputs to keep active. <br /><br />
<strong>*</strong><em>f_disTypes</em>: a list specifying the set of distances that should be tested for some
functional inputs. The values should be taken from the possibilities offered by the <a href="#topic+fgpm">fgpm</a>
function for the argument <em>f_disType</em> therein. Valid choices at this time are &quot;L2_bygroup&quot; and
&quot;L2_byindex&quot;. Each element of the list should receive as name the index of a functional input variable,
and should contain an array of strings with the name of the distances allowed for this input. All the
available distances will be tried for any functional input not included in the list. <br /><br />
<strong>*</strong><em>f_fixDims</em>: a two-row matrix specifying a particular projection dimension for some
functional inputs. For each input, the value should be a number between 0 and its original dimension,
with 0 denoting no projection. The first row of the matrix should contain the index of each input, and
the second row should contain the corresponding dimensions. All the possible dimensions will be tried
for any functional input not included in the matrix (unless affected by the <em>f_maxDims</em> argument
below). <br /><br />
<strong>*</strong><em>f_maxDims</em>: a two-row matrix specifying the largest projection dimension for some
functional inputs. For each input, the value should be a number between 1 and its original dimension.
The first row of the matrix should contain the index of each input, and the second row should contain
the corresponding largest dimensions. All the possible dimensions will be tried for any functional input
not included in the matrix (unless affected by the <em>f_fixDims</em> argument above). <br /><br />
<strong>*</strong><em>f_basTypes</em>: a list specifying the set of basis families that should be tested for some
functional inputs. The values should be taken from the possibilities offered by the <a href="#topic+fgpm">fgpm</a>
function for the argument <em>f_basType</em> therein. Valid choices at this time are &quot;B-splines&quot; and &quot;PCA&quot;.
Each element of the list should receive as name the index of a functional input variable, and should
contain an array of strings with the name of the distances allowed for this input. All the available
basis families will be tried for any functional input not included in the list. <br /><br />
<strong>*</strong><em>kerTypes</em>: an array of strings specifying the kernel functions allowed to be tested. The
values should be taken from the possibilities offered by the <a href="#topic+fgpm">fgpm</a> function for the argument
<em>kerType</em> therein. Valid choices at this time are &quot;gauss&quot;, &quot;matern5_2&quot; and &quot;matern3_2&quot;. If not
provided, all the available kernel functions will be tried.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_setup">setup</code></td>
<td>
<p>An optional list indicating the value for some parameters of the structural optimization
algorithm. The ant colony optimization algorithm available at this time allows the following entries: <br /><br />
<strong>Initial pheromone load</strong><br /><br />
<strong>*</strong><em>tao0</em>: a number indicating the initial pheromone load on links pointing out to the
selection of a distance type, a projection basis or a kernel type. Default is 0.1. <br /><br />
<strong>*</strong><em>dop.s</em>: a number controlling how likely it is to activate a scalar input. It operates on a
relation of the type <code class="reqn">A  = dop.s * I</code>, where <em>A</em> is the initial pheromone load of links
pointing out to the activation of scalar inputs and <em>I</em> is the initial pheromone load of links
pointing out to their inactivation. Default is 1. <br /><br />
<strong>*</strong><em>dop.f</em>: analogous to <em>dop.s</em> for functional inputs. Default is 1. <br /><br />
<strong>*</strong><em>delta.f and dispr.f</em>: two numbers used as shape parameters for the regularization
function that determines the initial pheromone values on the links connecting the L2_byindex distance
with the projection dimension. Default are 2 and 1.4, respectively. <br /><br />
<strong>Local pheromone update</strong><br /><br />
<strong>*</strong><em>rho.l</em>: a number specifying the pheromone evaporation rate. Default is 0.1. <br /><br />
<strong>Global pheromone update</strong><br /><br />
<strong>*</strong><em>u.gbest</em>: a boolean indicating if at each iteration, the pheromone load on the links
of the best ant of the whole trial should be reinforced. Default is FALSE. <br /><br />
<strong>*</strong><em>n.ibest</em>: a number indicating how many top ants of each iteration should be used for
pheromone reinforcement. Default is 1. <br /><br />
<strong>*</strong><em>rho.g</em>: a number specifying the learning reinforcement rate. Default is 0.1. <br /><br />
<strong>Population factors</strong><br /><br />
<strong>*</strong><em>n.iter</em>: a number specifying the amount of iterations of the algorithm. Default is 15. <br /><br />
<strong>*</strong><em>n.pop</em>: a number specifying the amount of ants per iteration; each ant corresponds to one
structural configuration for the model. Default is 10. <br /><br />
<strong>Bias strength</strong><br /><br />
<strong>*</strong><em>q0</em>: ants use one of two rules to select their next node at each step. The first rule leads
the ant through the link with higher pheromone load; the second rule works based on probabilities which
are proportional to the pheromone load on the feasible links. The ants will randomly chose one of the two
rules at each time. They will opt for rule 1 with probability <em>q0</em>. Default is 0.95.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_time.lim">time.lim</code></td>
<td>
<p>An optional number specifying a time limit in seconds to be used as stopping condition for the
structural optimization.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_nugget">nugget</code></td>
<td>
<p>An optional variance value standing for the homogeneous nugget effect. A tiny nugget might help
to overcome numerical problems related to the ill-conditioning of the covariance matrix. Default is 1e-8.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_n.starts">n.starts</code></td>
<td>
<p>An optional integer indicating the number of initial points to use for the optimization of the
hyperparameters. A parallel processing cluster can be exploited in order to speed up the evaluation of
multiple initial points. More details in the description of the argument par.clust below. Default is 1.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_n.presample">n.presample</code></td>
<td>
<p>An optional integer indicating the number of points to be tested in order to select the
n.starts initial points. The n.presample points will be randomly sampled from the hyper-rectangle defined by: <br /> <br />
1e-10 <code class="reqn">\le</code> <code>ls_s.hyp[i]</code> <code class="reqn">\le</code> 2*max(<code>sMs[[i]]</code>), for i in 1 to the number of scalar inputs, <br />
1e-10 <code class="reqn">\le</code> <code>ls_f.hyp[i]</code> <code class="reqn">\le</code> 2*max(<code>fMs[[i]]</code>), for i in 1 to the number of functional inputs, <br /> <br />
with  sMs and fMs the lists of distance matrices for the scalar and functional inputs, respectively. The value of
n.starts will be assigned to n.presample if this last is smaller. Default is 20.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_par.clust">par.clust</code></td>
<td>
<p>An optional parallel processing cluster created with the <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>
function of the <a href="lattice.html#topic+parallel">parallel package</a>. If not provided, structural configurations are evaluated in
sequence.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_trace">trace</code></td>
<td>
<p>An optional boolean indicating if control messages native of the <a href="#topic+funGp-package">funGp package</a> should be
printed to console. Default is TRUE. For complementary control on the display of funGp-native progress bars, have a look at
the <code>pbars</code> argument below.</p>
</td></tr>
<tr><td><code id="fgpm_factory_+3A_pbars">pbars</code></td>
<td>
<p>An optional boolean indicating if progress bars should be displayed. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+Xfgpm-class">Xfgpm</a> containing the data structures linked to the structural optimization
of a funGp model. It includes as the main component an object of class <a href="#topic+fgpm-class">fgpm</a> corresponding to the
optimized model. It is accessible through the <code>@model</code> slot of the Xfgpm object.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>References</h3>

<p>Betancourt, J., Bachoc, F., Klein, T., Idier, D., Pedreros, R., and Rohmer, J. (2020),
&quot;Gaussian process metamodeling of functional-input code for coastal flood hazard assessment&quot;.
<em>Reliability Engineering &amp; System Safety</em>, <strong>198</strong>, 106870.
<a href="https://www.sciencedirect.com/science/article/abs/pii/S0951832019301693">[RESS]</a>
<a href="https://hal.archives-ouvertes.fr/hal-01998724">[HAL]</a>
</p>
<p>Betancourt, J., Bachoc, F., Klein, T., and Gamboa, F. (2020),
Technical Report: &quot;Ant Colony Based Model Selection for Functional-Input Gaussian Process Regression. Ref. D3.b (WP3.2)&quot;.
<em>RISCOPE project</em>.
<a href="https://hal.archives-ouvertes.fr/hal-02532713">[HAL]</a>
</p>
<p>Betancourt, J., Bachoc, F., and Klein, T. (2020),
R Package Manual: &quot;Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour&quot;.
<em>RISCOPE project</em>.
<a href="https://hal.archives-ouvertes.fr/hal-02536624">[HAL]</a>
</p>
<p>Dubrule, O. (1983),
&quot;Cross validation of kriging in a unique neighborhood&quot;.
<em>Journal of the International Association for Mathematical Geology</em>, <strong>15</strong>,  687-699.
<a href="https://link.springer.com/article/10.1007/BF01033232">[MG]</a>
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+plot+2CXfgpm-method">plot,Xfgpm-method</a> with
<code>which = "evolution"</code> for visualizing the evolution of
the ACO algorithm, or with <code>which = "diag"</code> for a
diagnostic plot;
</p>
<p><strong>*</strong> <a href="#topic+get_active_in">get_active_in</a> for post-processing
of input data structures following a fgpm_factory call;
</p>
<p><strong>*</strong> <a href="#topic+predict+2Cfgpm-method">predict,fgpm-method</a> for
predictions based on a funGp model;
</p>
<p><strong>*</strong> <a href="#topic+simulate+2Cfgpm-method">simulate,fgpm-method</a> for
simulations based on a funGp model;
</p>
<p><strong>*</strong> <a href="#topic+update+2Cfgpm-method">update,fgpm-method</a> for
post-creation updates on a funGp model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#construction of a fgpm object
set.seed(100)
n.tr &lt;- 32
x1 &lt;- x2 &lt;- x3 &lt;- x4 &lt;- x5 &lt;- seq(0,1,length = n.tr^(1/5))
sIn &lt;- expand.grid(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5)
fIn &lt;- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
            f2 = matrix(runif(n.tr * 22), ncol = 22))
sOut &lt;- fgp_BB7(sIn, fIn, n.tr)

# optimizing the model structure with fgpm_factory (~12 seconds)
## Not run: 
xm &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut)

## End(Not run)

# assessing the quality of the model
# in the absolute and also w.r.t. the other explored models
plot(xm, which = "diag")

# checking the evolution of the algorithm
plot(xm, which = "evol")

# Summary of the tested configurations
summary(xm)

# checking the log of crashed iterations
print(xm@log.crashes)

# building the model with the default fgpm arguments to compare
set.seed(100)
n.tr &lt;- 32
x1 &lt;- x2 &lt;- x3 &lt;- x4 &lt;- x5 &lt;- seq(0,1,length = n.tr^(1/5))
sIn &lt;- expand.grid(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5)
fIn &lt;- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
f2 &lt;- matrix(runif(n.tr * 22), ncol = 22))
sOut &lt;- fgp_BB7(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)
plot(m1) # plotting the model

# improving performance with more iterations_______________________________________________
# call to fgpm_factory (~22 seconds)
## Not run: 
xm25 &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut,
                     setup = list(n.iter = 25))

## End(Not run)

# assessing evolution and quality
plot(xm25, which = "evol")
plot(xm25, which = "diag")

# custom solution space____________________________________________________________________
myctr &lt;- list(s_keepOn = c(1,2), # keep both scalar inputs always on
f_keepOn = c(2), # keep f2 always active
f_disTypes = list("2" = c("L2_byindex")), # only use L2_byindex distance for f2
f_fixDims = matrix(c(2,4), ncol = 1), # f2 projected in dimension 4
f_maxDims = matrix(c(1,5), ncol = 1), # f1 projected in dimension max 5
f_basTypes = list("1" = c("B-splines")), # only use B-splines projection for f1
kerTypes = c("matern5_2", "gauss")) # test only Matern 5/2 and Gaussian kernels
#
# call to fgpm_factory (~12 seconds)
## Not run: 
xmc &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut, ctraints = myctr)

## End(Not run)

# assessing evolution and quality
plot(xmc, which = "evol")
plot(xmc, which = "diag")

# verifying constraints with the log of some successfully built models
summary(xmc)

# custom heuristic parameters______________________________________________________________
mysup &lt;- list(n.iter = 30, n.pop = 12, tao0 = .15, dop.s = 1.2,
              dop.f = 1.3, delta.f = 4, dispr.f = 1.1, q0 = .85,
              rho.l = .2, u.gbest = TRUE, n.ibest = 2, rho.g = .08)

# call to fgpm_factory (~20 seconds)
## Not run: 
xmh &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut, setup = mysup)

## End(Not run)

# verifying heuristic setup through the details of the Xfgpm object
unlist(xmh@details$param)

# stopping condition based on time_________________________________________________________
mysup &lt;- list(n.iter = 2000)
mytlim &lt;- 60

# call to fgpm_factory (~60 seconds)
## Not run: 
xms &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut,
                    setup = mysup, time.lim = mytlim)

## End(Not run)
summary(xms)

## Not run: 
# parallelization in the model factory_____________________________________________________
# generating input and output data
set.seed(100)
n.tr &lt;- 243
sIn &lt;- expand.grid(x1 = seq(0,1,length = n.tr^(1/5)), x2 = seq(0,1,length = n.tr^(1/5)),
                   x3 = seq(0,1,length = n.tr^(1/5)), x4 = seq(0,1,length = n.tr^(1/5)),
                   x5 = seq(0,1,length = n.tr^(1/5)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB7(sIn, fIn, n.tr)

# calling fgpm_factory in parallel
cl &lt;- parallel::makeCluster(2)
xm.par &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut, par.clust = cl) #  (~260 seconds)
parallel::stopCluster(cl)

# NOTE: in order to provide progress bars for the monitoring of time consuming processes
#       ran in parallel, funGp relies on the doFuture and future packages. Parallel processes
#       suddenly interrupted by the user tend to leave corrupt connections. This problem is
#       originated outside funGp, which limits our control over it. In the manual
#       of funGp, we provide a temporary solution to the issue and we remain attentive in
#       case it appears a more elegant way to handle it or a manner to suppress it.
#
#       funGp manual: https://hal.archives-ouvertes.fr/hal-02536624

## End(Not run)

</code></pre>

<hr>
<h2 id='fgpm-class'>S4 class for funGp Gaussian process models</h2><span id='topic+fgpm-class'></span>

<h3>Description</h3>

<p>This is the formal representation of Gaussian process models within the
<a href="#topic+funGp-package">funGp package</a>. Gaussian process models are useful statistical tools in the
modeling of complex input-output relationships.
</p>

<ul>
<li><p><strong>Main methods</strong><br />
<a href="#topic+fgpm">fgpm</a>: creation of funGp regression models <br />
<a href="#topic+predict+2Cfgpm-method">predict,fgpm-method</a>: output estimation at new input points based on a <code>fgpm</code> model <br />
<a href="#topic+simulate+2Cfgpm-method">simulate,fgpm-method</a>: random sampling from a <code>fgpm</code> model <br />
<a href="#topic+update+2Cfgpm-method">update,fgpm-method</a>: modification of data and hyperparameters of a <code>fgpm</code> model

</p>
</li>
<li><p><strong>Plotters</strong><br />
<a href="#topic+plot+2Cfgpm-method">plot,fgpm-method</a>: validation plot for a <code>fgpm</code> model <br />
<a href="#topic+plot.predict.fgpm">plot.predict.fgpm</a>: plot of predictions based on a <code>fgpm</code> model <br />
<a href="#topic+plot.simulate.fgpm">plot.simulate.fgpm</a>: plot of simulations based on a <code>fgpm</code> model

</p>
</li></ul>



<h3>Slots</h3>


<dl>
<dt><code>howCalled</code></dt><dd><p>Object of class <code>"<a href="#topic+modelCall-class">modelCall</a>"</code>. User call reminder.</p>
</dd>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>. Type of model based on type of inputs. To be set from
&quot;scalar&quot;, &quot;functional&quot;, &quot;hybrid&quot;.</p>
</dd>
<dt><code>ds</code></dt><dd><p>Object of class <code>"numeric"</code>. Number of scalar inputs.</p>
</dd>
<dt><code>df</code></dt><dd><p>Object of class <code>"numeric"</code>. Number of functional inputs.</p>
</dd>
<dt><code>f_dims</code></dt><dd><p>Object of class <code>"numeric"</code>. An array with the original dimension of each functional
input.</p>
</dd>
<dt><code>sIn</code></dt><dd><p>Object of class <code>"matrix"</code>. The scalar input points. Variables are arranged by columns and
coordinates by rows.</p>
</dd>
<dt><code>fIn</code></dt><dd><p>Object of class <code>"list"</code>. The functional input points. Each element of the list contains
a functional input in the form of a matrix. In each matrix, curves representing functional coordinates
are arranged by rows.</p>
</dd>
<dt><code>sOut</code></dt><dd><p>Object of class <code>"matrix"</code>. The scalar output values at the coordinates specified by sIn
and/or fIn.</p>
</dd>
<dt><code>n.tot</code></dt><dd><p>Object of class <code>"integer"</code>. Number of observed points used to compute the training-training
and training-prediction covariance matrices.</p>
</dd>
<dt><code>n.tr</code></dt><dd><p>Object of class <code>"integer"</code>. Among all the points loaded in the model, the amount used for
training.</p>
</dd>
<dt><code>f_proj</code></dt><dd><p>Object of class <code>"fgpProj"</code>. Data structures related to the projection of functional
inputs. Check <a href="#topic+fgpProj-class">fgpProj</a> for more details.</p>
</dd>
<dt><code>kern</code></dt><dd><p>Object of class <code>"fgpKern"</code>. Data structures related to the kernel of the Gaussian process
model. Check <a href="#topic+fgpKern-class">fgpKern</a> for more details.</p>
</dd>
<dt><code>nugget</code></dt><dd><p>Object of class <code>"numeric"</code>. Variance parameter standing for the homogeneous nugget effect.</p>
</dd>
<dt><code>preMats</code></dt><dd><p>Object of class <code>"list"</code>. L and LInvY matrices pre-computed for prediction. L is a lower
diagonal matrix such that <code class="reqn">L'L</code> equals the training auto-covariance matrix <code class="reqn">K.tt</code>. On the other
hand, <code class="reqn">LInvY = L^(-1) * sOut</code>.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>Object of class <code>"numeric"</code>. Integer code either confirming convergence or indicating
an error. Check the convergence component of the Value returned by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>negLogLik</code></dt><dd><p>Object of class <code>"numeric"</code>. Negated log-likelihood obained by <code><a href="stats.html#topic+optim">optim</a></code>
during hyperparameter optimization.</p>
</dd>
</dl>


<h3>Useful material</h3>


<ul>
<li><p><strong>Manual</strong>
<a href="https://hal.archives-ouvertes.fr/hal-02536624">
Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour
</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

<hr>
<h2 id='fgpProj-class'>S4 class for structures linked to projections in a <code>fgpm</code> model</h2><span id='topic+fgpProj-class'></span>

<h3>Description</h3>

<p>This is the formal representation for data structures linked to projection of inputs in a
Gaussian process model within the <a href="#topic+funGp-package">funGp package</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pdims</code></dt><dd><p>Object of class <code>"numeric"</code>. Projection dimension of each input.</p>
</dd>
<dt><code>basType</code></dt><dd><p>Object of class <code>"character"</code>. To be chosen from &quot;PCA&quot;, &quot;B-splines&quot;.</p>
</dd>
<dt><code>basis</code></dt><dd><p>Object of class <code>"list"</code>. Projection basis. For functional inputs, each element
(fDims_i x fpDims_i) contains the basis functions used for the projection of one functional input.</p>
</dd>
<dt><code>coefs</code></dt><dd><p>Object of class <code>"list"</code>. Each element (n x fpDims_i) contains the coefficients used for
the projection of one functional input.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

<hr>
<h2 id='funGp-package'>Gaussian Process Models for Scalar and Functional Inputs</h2><span id='topic+funGp-package'></span>

<h3>Description</h3>

<p>Construction and smart selection of Gaussian process models for analysis of computer experiments with emphasis on treatment of functional inputs that are regularly sampled. Smart selection is based on Ant Colony Optimization ACO algorithm.
</p>


<h3>Base functionalities</h3>


<ul>
<li><p><strong>Main methods</strong><br />
<a href="#topic+fgpm">fgpm</a>: creation of funGp regression models <br />
<a href="#topic+predict+2Cfgpm-method">predict,fgpm-method</a>: output estimation at new input points based on a funGp model <br />
<a href="#topic+simulate+2Cfgpm-method">simulate,fgpm-method</a>: random sampling from a funGp Gaussian process model <br />
<a href="#topic+update+2Cfgpm-method">update,fgpm-method</a>: modification of data and hyperparameters of a funGp model

</p>
</li>
<li><p><strong>Plotters</strong><br />
<a href="#topic+plot+2Cfgpm-method">plot,fgpm-method</a>: validation plot for a <code>fgpm</code> model <br />
<a href="#topic+plot.predict.fgpm">plot.predict.fgpm</a>: plot of predictions based on a <code>fgpm</code> model <br />
<a href="#topic+plot.simulate.fgpm">plot.simulate.fgpm</a>: plot of simulations based on a <code>fgpm</code> model

</p>
</li></ul>



<h3>Model selection</h3>


<ul>
<li><p><strong>Main method</strong><br />
<a href="#topic+fgpm_factory">fgpm_factory</a>: structural parameter optimization

</p>
</li>
<li><p><strong>Functions for pre-optimization</strong><br />
<a href="#topic+decay">decay</a>: regularized initial pheromones <br />
<a href="#topic+decay2probs">decay2probs</a>: normalized initial pheromones

</p>
</li>
<li><p><strong>Plotters post-optimization</strong><br />
<a href="#topic+plot+2CXfgpm-method">plot,Xfgpm-method</a>: plot of the evolution of the algorithm with <code>which = "evolution"</code>
or of the absolute and relative quality of the optimized model with <code>which = "diag"</code>
</p>

</li>
<li><p><strong>Correction post-optimization of input data structures</strong><br />
<a href="#topic+which_on">which_on</a>: indices of active inputs in a model
structure delivered by <a href="#topic+fgpm_factory">fgpm_factory</a><br />
<a href="#topic+get_active_in">get_active_in</a>: extraction of active input
data based on a model structure delivered by <a href="#topic+fgpm_factory">fgpm_factory</a>

</p>
</li></ul>



<h3>Useful material</h3>


<ul>
<li><p><strong>Manual</strong>
<a href="https://hal.archives-ouvertes.fr/hal-02536624">
Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour
</a>
</p>
</li>
<li><p><strong>Paper</strong>
<a href="https://www.sciencedirect.com/science/article/abs/pii/S0951832019301693">
Gaussian process metamodeling of functional-input code for coastal flood hazard assessment
</a>
</p>
</li>
<li><p><strong>Tech. report</strong>
<a href="https://hal.archives-ouvertes.fr/hal-02532713">
Ant Colony Based Model Selection for Functional-Input Gaussian Process Regression
</a>
</p>
</li></ul>



<h3>Authors</h3>

<p>José Betancourt, François Bachoc and Thierry Klein
</p>


<h3>Contributors</h3>

<p>Déborah Idier and Jérémy Rohmer
</p>


<h3>Note</h3>

<p>This package was first developed in the frame of the RISCOPE research project, funded
by the French Agence Nationale de la Recherche (ANR) for the period 2017-2021 (ANR,
project No. 16CE04-0011,
<a href="https://perso.math.univ-toulouse.fr/riscope/">
RISCOPE.fr</a>), and certified by SAFE Cluster.
</p>

<hr>
<h2 id='gaussian_cor'>Gaussian correlation function</h2><span id='topic+gaussian_cor'></span>

<h3>Description</h3>

<p>Applies the Gaussian correlation function to a list of distance matrices using corresponding length-scale parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_cor(Ms, thetas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_cor_+3A_ms">Ms</code></td>
<td>
<p>a list with as many elements as inputs. Each element of the list must be a n times n matrix of differences
between the observation coordinates, with n the number of input coordinates.</p>
</td></tr>
<tr><td><code id="gaussian_cor_+3A_thetas">thetas</code></td>
<td>
<p>an array with the length-scale parameters corresponding to the inputs for which the distance matrices were provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of dimension n times n computed from the Gaussian correlation function.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

<hr>
<h2 id='get_active_in'>Extraction of active inputs in a given model structure</h2><span id='topic+get_active_in'></span>

<h3>Description</h3>

<p>The <a href="#topic+fgpm_factory">fgpm_factory</a> function returns an object of class <code>"<a href="#topic+Xfgpm-class">Xfgpm</a>"</code>
with the function call of all the evaluated models stored in the <code>@log.success@args</code> and
<code>@log.crashes@args</code> slots. The <code>get_active_in</code> function interprets the arguments linked to any
structural configuration and returns a list with two elements: (i) a <code>matrix</code> of scalar input
variables kept active; and (ii) a <code>list</code> of functional input variables kept active.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_active_in(sIn = NULL, fIn = NULL, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_active_in_+3A_sin">sIn</code></td>
<td>
<p>An optional matrix of scalar input coordinates with all the orignal scalar input variables.</p>
</td></tr>
<tr><td><code id="get_active_in_+3A_fin">fIn</code></td>
<td>
<p>An optional list of functional input coordinates with all the original functional input
variables.</p>
</td></tr>
<tr><td><code id="get_active_in_+3A_args">args</code></td>
<td>
<p>An object of class <code>"<a href="#topic+modelCall-class">modelCall</a>"</code>, which specifies the model structure for
which the active inputs should be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"list"</code>, containing the following information extracted from the
<em>args</em> parameter: (i) a <code>matrix</code> of scalar input variables kept active; and (ii) a <code>list</code>
of functional input variables kept active.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>References</h3>

<p>Betancourt, J., Bachoc, F., and Klein, T. (2020),
R Package Manual: &quot;Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour&quot;.
<em>RISCOPE project</em>.
<a href="https://hal.archives-ouvertes.fr/hal-02536624">[HAL]</a>
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+which_on">which_on</a> for details on how to obtain only the indices of the active inputs.
</p>
<p><strong>*</strong> <a href="#topic+modelCall-class">modelCall</a> for details on the <em>args</em> argument.
</p>
<p><strong>*</strong> <a href="#topic+fgpm_factory">fgpm_factory</a> for funGp heuristic model selection.
</p>
<p><strong>*</strong> <a href="#topic+Xfgpm-class">Xfgpm</a> for details on object delivered by <a href="#topic+fgpm_factory">fgpm_factory</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use precalculated Xfgpm object named xm
# indices of active inputs in the best model
xm@log.success@args[[1]] # the full fgpm call
set.seed(100)
n.tr &lt;- 32
sIn &lt;- expand.grid(x1 = seq(0,1,length = n.tr^(1/5)), x2 = seq(0,1,length = n.tr^(1/5)),
x3 = seq(0,1,length = n.tr^(1/5)), x4 = seq(0,1,length = n.tr^(1/5)),
x5 = seq(0,1,length = n.tr^(1/5)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
which_on(sIn, fIn, xm@log.success@args[[1]]) # only the indices extracted by which_on

# data structures of active inputs
active &lt;- get_active_in(sIn, fIn, xm@log.success@args[[1]])
active$sIn.on # scalar data structures
active$fIn.on # functional data structures
# identifying selected model and corresponding fgpm arguments
opt.model &lt;- xm@model
opt.args &lt;- xm@log.success@args[[1]]

# generating new input data for prediction
n.pr &lt;- 243
sIn.pr &lt;- expand.grid(x1 = seq(0,1,length = n.pr^(1/5)), x2 = seq(0,1,length = n.pr^(1/5)),
                      x3 = seq(0,1,length = n.pr^(1/5)), x4 = seq(0,1,length = n.pr^(1/5)),
                      x5 = seq(0,1,length = n.pr^(1/5)))
fIn.pr &lt;- list(f1 = matrix(runif(n.pr*10), ncol = 10), f2 = matrix(runif(n.pr*22), ncol = 22))

# pruning data structures for prediction to keep only active inputs!!
active &lt;- get_active_in(sIn.pr, fIn.pr, opt.args)

# making predictions
preds &lt;- predict(opt.model, sIn.pr = active$sIn.on, fIn.pr = active$fIn.on)

# plotting predictions
plot(preds)


# preparing new data for simulation based on inputs kept active____________________________
opt.model &lt;- xm@model
opt.args &lt;- xm@log.success@args[[1]]

# generating new input data for simulation
n.sm &lt;- 243
sIn.sm &lt;- expand.grid(x1 = seq(0,1,length = n.pr^(1/5)), x2 = seq(0,1,length = n.pr^(1/5)),
                      x3 = seq(0,1,length = n.pr^(1/5)), x4 = seq(0,1,length = n.pr^(1/5)),
                      x5 = seq(0,1,length = n.pr^(1/5)))
fIn.sm &lt;- list(f1 = matrix(runif(n.sm*10), ncol = 10), f2 = matrix(runif(n.sm*22), ncol = 22))

# pruning data structures for simulation to keep only active inputs!!
active &lt;- get_active_in(sIn.sm, fIn.sm, opt.args)

# making light simulations
sims_l &lt;- simulate(opt.model, nsim = 10, sIn.sm = active$sIn.on, fIn.sm = active$fIn.on)

# plotting light simulations
plot(sims_l)

## Not run: 
# rebuilding of 3 best models using new data_______________________________________________
# NOTE: this example is of higher complexity than the previous ones. We recomend you run
#       the previous examples and understand the @log.success and @log.crashes slots in
#       the Xfgpm object delivered by fgpm_factory.
#
#       In the second example above we showed how to use get_active_in to prune the input
#       data structures for prediction based on the fgpm arguments of the best model found
#       by fgpm_factory. In this new example we generalize that concept by: (i) rebuilding
#       the 3 best models found by fgpm_factory using new data, (ii) pruning the input
#       data structures used for prediction with each of the models, and (iii) plotting
#       the predictions made by the three models. The key ingredient here is that the
#       three best models might have different scalar and functional inputs active. The
#       get_active_in function will allow to process the data structures in order to
#       extract only the scalar inputs required to re-build the model and then to make
#       predictions with each model. Check also the funGp manual for further details
#
#       funGp manual: https://hal.archives-ouvertes.fr/hal-02536624


# &lt;&lt;&lt;&lt;&lt;&lt;&lt; PART 1: calling fgpm_factory to perform the structural optimization &gt;&gt;&gt;&gt;&gt;&gt;&gt;
#         -------------------------------------------------------------------
# this part is precalculated and loaded via data("precalculated_Xfgpm_objects")
summary(xm)

# &lt;&lt;&lt;&lt;&lt;&lt;&lt; PART 2: re-building the three best models found by fgpm_factory &gt;&gt;&gt;&gt;&gt;&gt;&gt;
#         ---------------------------------------------------------------
# recovering the fgpm arguments of the three best models
argStack &lt;- xm@log.success@args[1:3]

# new data arrived, now we have 243 observations
n.nw &lt;- 243 # more points!
sIn.nw &lt;- expand.grid(x1 = seq(0,1,length = n.nw^(1/5)), x2 = seq(0,1,length = n.nw^(1/5)),
                      x3 = seq(0,1,length = n.nw^(1/5)), x4 = seq(0,1,length = n.nw^(1/5)),
                      x5 = seq(0,1,length = n.nw^(1/5)))
fIn.nw &lt;- list(f1 = matrix(runif(n.nw*10), ncol = 10), f2 = matrix(runif(n.nw*22), ncol = 22))
sOut.nw &lt;- fgp_BB7(sIn.nw, fIn.nw, n.nw)

# the second best model
modelDef(xm,2)
# re-building the three best models based on the new data (compact code with all 3 calls)
newEnv &lt;- list(sIn = sIn.nw, fIn = fIn.nw, sOut = sOut.nw)
modStack &lt;- lapply(1:3, function(i) eval(parse(text =  modelDef(xm,i)), env = newEnv))


# &lt;&lt;&lt;&lt;&lt;&lt;&lt; PART 3: making predictions from the three best models found by fgpm_factory &gt;&gt;&gt;&gt;&gt;&gt;&gt;
#         ---------------------------------------------------------------------------
# generating input data for prediction
n.pr &lt;- 32
sIn.pr &lt;- expand.grid(x1 = seq(0,1,length = n.pr^(1/5)), x2 = seq(0,1,length = n.pr^(1/5)),
                      x3 = seq(0,1,length = n.pr^(1/5)), x4 = seq(0,1,length = n.pr^(1/5)),
                      x5 = seq(0,1,length = n.pr^(1/5)))
fIn.pr &lt;- list(f1 = matrix(runif(n.pr*10), ncol = 10), matrix(runif(n.pr*22), ncol = 22))

# making predictions based on the three best models (compact code with all 3 calls)
preds &lt;- do.call(cbind, Map(function(model, args) {
  active &lt;- get_active_in(sIn.pr, fIn.pr, args)
  predict(model, sIn.pr = active$sIn.on, fIn.pr = active$fIn.on)$mean
}, modStack, argStack))


# &lt;&lt;&lt;&lt;&lt;&lt;&lt; PART 4: plotting predictions from the three best models found by fgpm_factory &gt;&gt;&gt;&gt;&gt;&gt;&gt;
#         -----------------------------------------------------------------------------
# plotting predictions made by the three models
plot(1, xlim = c(1,nrow(preds)), ylim = range(preds), xaxt = "n",
     xlab = "Prediction point index", ylab = "Output",
     main = "Predictions with best 3 structural configurations")
axis(1, 1:nrow(preds))
for (i in seq_len(n.pr)) {lines(rep(i,2), range(preds[i,1:3]), col = "grey35", lty = 3)}
points(preds[,1], pch = 21, bg = "black")
points(preds[,2], pch = 23, bg = "red")
points(preds[,3], pch = 24, bg = "green")
legend("bottomleft", legend = c("Model 1", "Model 2", "Model 3"),
       pch = c(21, 23, 24), pt.bg = c("black", "red", "green"), inset = c(.02,.08))

## End(Not run)

</code></pre>

<hr>
<h2 id='matern32_cor'>Matern 3/2 correlation function</h2><span id='topic+matern32_cor'></span>

<h3>Description</h3>

<p>Applies the Matern 5/2 correlation function to a list of distance matrices using corresponding length-scale parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern32_cor(Ms, thetas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern32_cor_+3A_ms">Ms</code></td>
<td>
<p>a list with as many elements as inputs. Each element of the list must be a n times n matrix of differences
between the observation coordinates, with n the number of input coordinates.</p>
</td></tr>
<tr><td><code id="matern32_cor_+3A_thetas">thetas</code></td>
<td>
<p>an array with the length-scale parameters corresponding to the inputs for which the distance matrices were provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of dimension n times n computed from the Matern 3/2 correlation function.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

<hr>
<h2 id='matern52_cor'>Matern 5/2 correlation function</h2><span id='topic+matern52_cor'></span>

<h3>Description</h3>

<p>Applies the Matern 5/2 correlation function to a list of distance matrices using corresponding length-scale parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern52_cor(Ms, thetas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern52_cor_+3A_ms">Ms</code></td>
<td>
<p>a list with as many elements as inputs. Each element of the list must be a n times n matrix of differences
between the observation coordinates, with n the number of input coordinates.</p>
</td></tr>
<tr><td><code id="matern52_cor_+3A_thetas">thetas</code></td>
<td>
<p>an array with the length-scale parameters corresponding to the inputs for which the distance matrices were provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of dimension n times n computed from the Matern 5/2 correlation function.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

<hr>
<h2 id='modelCall-class'>S4 class for calls to the fgpm function in funGp</h2><span id='topic+modelCall-class'></span>

<h3>Description</h3>

<p>User reminder of the <a href="#topic+fgpm">fgpm</a> function call.
</p>


<h3>Slots</h3>


<dl>
<dt><code>string</code></dt><dd><p>Object of class <code>"character"</code>. User call reminder in string format.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

<hr>
<h2 id='modelDef'>Retrieve a <code>fgpm</code> from within a <code>Xfgpm</code> object</h2><span id='topic+modelDef'></span>

<h3>Description</h3>

<p>Retrieve the <code>fgpm</code> model with index (or rank) <code>i</code> from
within a <code>Xfgpm</code> object. By evaluating this code in an
environment containing suitable objects <code>sIn</code>, <code>fIn</code> and
<code>sOut</code> we can re-create a <code>fgpm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelDef(
  object,
  ind,
  trace = TRUE,
  pbars = TRUE,
  control.optim = list(trace = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelDef_+3A_object">object</code></td>
<td>
<p>A <code>Xfgpm</code> object as created by
<code><a href="#topic+fgpm_factory">fgpm_factory</a></code>.</p>
</td></tr>
<tr><td><code id="modelDef_+3A_ind">ind</code></td>
<td>
<p>The index (or rank) of the model in <code>object</code>.</p>
</td></tr>
<tr><td><code id="modelDef_+3A_trace">trace</code></td>
<td>
<p>An optional boolean indicating whether funGp-native progress
messages should be displayed. Default is TRUE. See the <code><a href="#topic+fgpm">fgpm</a>()</code>
documentation for more details.</p>
</td></tr>
<tr><td><code id="modelDef_+3A_pbars">pbars</code></td>
<td>
<p>An optional boolean indicating whether progress bars managed by
<code><a href="#topic+fgpm">fgpm</a>()</code> should be displayed. Default is TRUE. See the
<code><a href="#topic+fgpm">fgpm</a>()</code> documentation for more details.</p>
</td></tr>
<tr><td><code id="modelDef_+3A_control.optim">control.optim</code></td>
<td>
<p>An optional list to be passed as the control argument to
<code><a href="stats.html#topic+optim">optim</a></code>(), the function in charge of the non-linear
optimization of the hyperparameters. Default is list(trace = TRUE). See the
<code><a href="#topic+fgpm">fgpm</a>()</code> documentation for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The models are sorted by decreasing quality so <code>i = 1</code> extracts
the definition of the best model.
</p>


<h3>Value</h3>

<p>A parsed R code defining the <code>fgpm</code> model.
</p>


<h3>Note</h3>

<p>Remind that the models are sorted by decreasing quality so
<code>i = 1</code> extracts the definition of the best model.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic++5B+5B+2CXfgpm-method">[[,Xfgpm-method</a></code> that can also be used
to re-create a <code>fgpm</code> object using <em>the same data</em>
as that used to create the <code>Xfgpm</code> object in
<code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =========================================================================
## Using the pre-calculated object `xm` to save time. See `?xm` to re-create
## this object.
## =========================================================================

## 'xm@model' is the best 'fgpm' model in 'xm'
plot(xm@model)

## see the R code to use to recreate the model
modelDef(xm, i = 1)

## Not run: 
    ## Define new data in a list. Using an environment would also work,
    ## including the global environment, which is the default in  `eval`.
    L &lt;- list()
    set.seed(341)
    n.new &lt;- 3^5
    x1 &lt;- x2 &lt;- x3 &lt;- x4 &lt;- x5 &lt;- seq(0, 1, length = n.new^(1/5))

    ## create the data objects required to fit the model
    L$sIn &lt;- as.matrix(expand.grid(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5))
    L$fIn &lt;- list(f1 = matrix(runif(n.new * 10), ncol = 10),
                   f2 = matrix(runif(n.new * 22), ncol = 22))
    L$sOut &lt;- fgp_BB7(L$sIn, L$fIn, n.new)

    ## Now evaluate
    fgpm.new &lt;- eval(modelDef(xm, i = 1), envir = L)
    plot(fgpm.new, main = "Re-created 'fgpm' model with different data")
    plot(xm[[1]], main = "Re-created 'fgpm' model with the same data")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot+2Cfgpm-method'>Plot method for the class <code>"fgpm"</code></h2><span id='topic+plot+2Cfgpm-method'></span>

<h3>Description</h3>

<p>This method provides a diagnostic plot for the
validation of regression models. It displays a calibration plot
based on the leave-one-out predictions of the output at the
points used to train the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fgpm'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cfgpm-method_+3A_x">x</code></td>
<td>
<p>A <code>fgpm</code> object.</p>
</td></tr>
<tr><td><code id="plot+2B2Cfgpm-method_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot+2B2Cfgpm-method_+3A_...">...</code></td>
<td>
<p>Graphical parameters. These currently include
</p>

<ul>
<li><p><code>xlim</code>, <code>ylim</code> to set the limits of the axes.
</p>
</li>
<li><p><code>pch</code>, <code>pt.col</code>, <code>pt.bg</code>, <code>pt.cex</code> to set
the symbol used for the points and the related properties.
</p>
</li>
<li><p><code>line</code> to set the color used for the line.
</p>
</li>
<li><p><code>xlab</code>, <code>ylab</code>, <code>main</code> to set
the labels of the axes and the main title. See
<b>Examples</b>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the Leave-One-Out (LOO) calibration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating input and output data for training
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)),
                   x2 = seq(0, 1, length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10),
            f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)

# building the model
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# plotting the model
plot(m1)
# change some graphical parameters if wanted
plot(m1, line = "SpringGreen3" ,
     pch = 21, pt.col = "orangered", pt.bg = "gold",
     main = "LOO cross-validation")

</code></pre>

<hr>
<h2 id='plot+2CXfgpm-method'>Plot method for the class <code>"Xfgpm"</code></h2><span id='topic+plot+2CXfgpm-method'></span>

<h3>Description</h3>

<p>Plot an object with class <code>"Xfgpm"</code> representing
a collection of functional GP models corresponding to
different structural parameters.
</p>
<p>Two types of graphics can be shown depending on the choice of
<code>which</code>. The choice <code>which = "diag"</code> is used to display
diagnostics of the quality of the optimized model. Two types of
diagnostic plots are shown as sub-plots by default, but each can be
discarded if wanted. The choice <code>which = "evol"</code> is used to
assess the quality of the fitted <code>fgpm</code> models on the basis of
Leave-One-Out cross-validation.
</p>
<p>The choice <code>which = "diag"</code> (default) provides two plots for
assessing the quality of the output delivered by the model selection
algorithm in the <a href="#topic+fgpm_factory">fgpm_factory</a> function. The first
one is a calibration plot similar to the one offered for
<a href="#topic+fgpm-class">fgpm</a> objects by <a href="#topic+plot+2Cfgpm-method">plot,fgpm-method</a>.
This plot allows to validate the absolute quality of the selected
model. The second one displays the performance statistic of all
the models successfully evaluated by the model selection
algorithm. This provides a notion of the relative quality of the
selected model with respect to the other models that can be made
using the same data.
</p>
<p>The choice <code>which = "evol"</code> displays the evolution of the
quality of the configurations evaluated along the iterations, by
the model selection algorithm in the <code>fgpm_factory</code> function. For
each iteration, the performance statistic of all the evaluated
models is printed, along with the corresponding median of the
group. The plot also includes the global maximum, which
corresponds to the best performance statistic obtained up to the
current iteration. In this plot, it is typical to have some points
falling relatively far from the maximum, even after multiple
iterations. This happens mainly because we have multiple
categorical features, whose alteration might change the
performance statistic in a nonsmooth way. On the other hand, the
points that fall below zero usually correspond to models whose
hyperparameters were hard to optimize. This occurs sporadically
during the log-likelihood optimization for Gaussian processes, due
to the non-linearity of the objective function.  As long as the
maximum keeps improving and the median remains close to it, none
of the two aforementioned phenomena is matter for worries.  Both
of them respond to the mechanism of exploration implemented in the
algorithm, which makes it able to progressively move towards
better model configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Xfgpm'
plot(
  x,
  y = NULL,
  which = c("diag", "evol"),
  calib = TRUE,
  fitp = TRUE,
  horiz = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CXfgpm-method_+3A_x">x</code></td>
<td>
<p>The <code>Xfgpm</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CXfgpm-method_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot+2B2CXfgpm-method_+3A_which">which</code></td>
<td>
<p>Character giving the type of plot wanted. Can take the value
<code>"diag"</code> or <code>"evol"</code>. See <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="plot+2B2CXfgpm-method_+3A_calib">calib</code></td>
<td>
<p>Logical. If <code>TRUE</code> the calibration plot of the
selected model will be included in the display in its
&quot;diagnostic&quot; part if <code>which</code> is set to <code>"diag"</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CXfgpm-method_+3A_fitp">fitp</code></td>
<td>
<p>Logical. If <code>TRUE</code> a scatter plot of the quality
of all explored models will be included in the display in its
&quot;diagnostic&quot; part if <code>which</code> is set to <code>"diag"</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CXfgpm-method_+3A_horiz">horiz</code></td>
<td>
<p>Logical. Used only when <code>which</code> is <code>"diag"</code>
and when both <code>calib</code> and <code>fitp</code> are <code>TRUE</code>. If
<code>horiz</code> is <code>TRUE</code> the two subplots are displayed
horizontally (on a same row) rather than vertically which is
the default.</p>
</td></tr>
<tr><td><code id="plot+2B2CXfgpm-method_+3A_...">...</code></td>
<td>
<p>Other graphical parameters such as <code>main</code> of
<code>xlab</code>. When <code>which</code> is <code>"diag"</code> and both
<code>calib</code> and <code>fitp</code> are <code>TRUE</code>, the graphical parameters
should be enclosed into a list and passed with the formal name
<code>calib.gpars</code> or <code>fitp.gpars</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+fgpm_factory">fgpm_factory</a> for structural
optimization of funGp models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating input and output data
set.seed(100)
n.tr &lt;- 2^5
x1 &lt;- x2 &lt;- x3 &lt;- x4 &lt;- x5 &lt;- seq(0, 1, length = n.tr^(1/5))
sIn &lt;- expand.grid(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5)
fIn &lt;- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
            f2 = matrix(runif(n.tr * 22), ncol = 22))
sOut &lt;- fgp_BB7(sIn, fIn, n.tr)
## Not run: 
# optimizing the model structure with 'fgpm_factory' (~10 seconds)
xm &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut)
# assessing the quality of the model - absolute and w.r.t. the other
# explored models
plot(xm, which = "evol")
# diagnostics (two subplots)
plot(xm, which = "diag")
plot(xm, which = "diag", horiz = TRUE)
# diagnostics (one plot)
plot(xm, which = "diag", fitp = FALSE)
plot(xm, which = "diag", calib = FALSE)
# customizing some graphical parameters
plot(xm, calib.gpars = list(xlim = c(800,1000), ylim = c(600,1200)),
     fitp.gpars = list(main = "Relative quality", legends = FALSE))


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.predict.fgpm'>Plot method for the predictions of a <code>fgpm</code> model</h2><span id='topic+plot.predict.fgpm'></span>

<h3>Description</h3>

<p>This method displays the predicted output values
delivered by a funGp Gaussian process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict.fgpm'
plot(x, y = NULL, sOut.pr = NULL, calib = TRUE, sortp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.predict.fgpm_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"predict.fgpm"</code>. This is a
list containing the predictions and confidence bands as
created by <a href="#topic+predict+2Cfgpm-method">predict,fgpm-method</a> for the S3 class
<code>"fgpm"</code>.</p>
</td></tr>
<tr><td><code id="plot.predict.fgpm_+3A_y">y</code></td>
<td>
<p>An optional vector (or 1-column matrix) containing
the true values of the scalar output at the prediction
points. If provided, the method will display two figures: (i) a
calibration plot with true vs predicted output values, and (ii)
a plot including the true and predicted output along with the
confidence bands, sorted according to the increasing order of
the true output. If not provided, only the second plot will be
made, and the predictions will be arranged according to the
increasing order of the predicted output.</p>
</td></tr>
<tr><td><code id="plot.predict.fgpm_+3A_sout.pr">sOut.pr</code></td>
<td>
<p>Alias of <code>y</code>, used for compatibility reasons.</p>
</td></tr>
<tr><td><code id="plot.predict.fgpm_+3A_calib">calib</code></td>
<td>
<p>An optional boolean indicating if the calibration
plot should be displayed. Ignored if <code>sOut.pr</code> is not
provided. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.predict.fgpm_+3A_sortp">sortp</code></td>
<td>
<p>An optional boolean indicating if the plot of sorted
output should be displayed. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.predict.fgpm_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the display. Since this
method allows to generate two plots from a single function
call, the extra arguments for each plot should be included in a
list. For the calibration plot, the list should be called
<em>calib.gpars</em>. For the plot of the output in increasing
order, the list should be called <em>sortp.gpars</em>. The
following typical graphics parameters are valid entries of both
lists: <em>xlim</em>, <em>ylim</em>, <em>xlab</em>, <em>ylab</em>,
<em>main</em>. The boolean argument <em>legends</em> can also be
included in any of the two lists in order to control the
display of legends in the corresponding plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc and Thierry Klein
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+fgpm">fgpm</a> for the construction of funGp models;
</p>
<p><strong>*</strong> <a href="#topic+plot+2Cfgpm-method">plot,fgpm-method</a> for model diagnostic plots;
</p>
<p><strong>*</strong> <a href="#topic+simulate+2Cfgpm-method">simulate,fgpm-method</a> for simulations based on a funGp model;
</p>
<p><strong>*</strong> <a href="#topic+plot.simulate.fgpm">plot.simulate.fgpm</a> for simulation plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plotting predictions without the true output values_______________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0, 1, length = sqrt(n.tr)),
                   x2 = seq(0, 1, length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
            f2 = matrix(runif(n.tr * 22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# making predictions
n.pr &lt;- 100
sIn.pr &lt;- as.matrix(expand.grid(x1 = seq(0,1,length = sqrt(n.pr)),
                                x2 = seq(0,1,length = sqrt(n.pr))))
fIn.pr &lt;- list(f1 = matrix(runif(n.pr * 10), ncol = 10),
               f2 = matrix(runif(n.pr * 22), ncol = 22))
m1.preds &lt;- predict(m1, sIn.pr = sIn.pr, fIn.pr = fIn.pr)

# plotting predictions
plot(m1.preds)

# plotting predictions and true output values_______________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0, 1, length = sqrt(n.tr)),
                   x2 = seq(0, 1, length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
            f2 = matrix(runif(n.tr * 22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# making predictions
n.pr &lt;- 100
sIn.pr &lt;- as.matrix(expand.grid(x1 = seq(0,1,length = sqrt(n.pr)),
                                x2 = seq(0,1,length = sqrt(n.pr))))
fIn.pr &lt;- list(f1 = matrix(runif(n.pr*10), ncol = 10),
               f2 = matrix(runif(n.pr*22), ncol = 22))
m1.preds &lt;- predict(m1, sIn.pr = sIn.pr, fIn.pr = fIn.pr)

# generating output data for validation
sOut.pr &lt;- fgp_BB3(sIn.pr, fIn.pr, n.pr)

# plotting predictions. Note that the 2-nd argument is the output, 'y'
plot(m1.preds, sOut.pr)

# only calibration plot
plot(m1.preds, sOut.pr = sOut.pr, sortp = FALSE)

# only sorted output plot
plot(m1.preds, sOut.pr = sOut.pr, calib = FALSE)

</code></pre>

<hr>
<h2 id='plot.simulate.fgpm'>Plot method for the simulations of a <code>fgpm</code> model</h2><span id='topic+plot.simulate.fgpm'></span>

<h3>Description</h3>

<p>This method displays the simulated output values
delivered by a funGp Gaussian process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simulate.fgpm'
plot(x, y = NULL, detail = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.simulate.fgpm_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>simulate.fgpm</code> as created
by <a href="#topic+simulate+2Cfgpm-method">simulate,fgpm-method</a>.</p>
</td></tr>
<tr><td><code id="plot.simulate.fgpm_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot.simulate.fgpm_+3A_detail">detail</code></td>
<td>
<p>An optional character string specifying the data
elements that should be included in the plot, to be chosen
between <code>"light"</code> and <code>"full"</code>. A <em>light</em> plot
will include only the simulated values, while a
<em>full</em> plot will also include the predicted mean and
confidence bands at the simulation points. This argument will
only be used if full simulations (including the mean and
confidence bands) are provided, otherwise it will be
ignored. See <a href="#topic+simulate+2Cfgpm-method">simulate,fgpm-method</a> for more details on the
generation of light and full simulations.</p>
</td></tr>
<tr><td><code id="plot.simulate.fgpm_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the display. The
following typical graphics parameters are valid entries:
<em>xlim</em>, <em>ylim</em>, <em>xlab</em>, <em>ylab</em>,
<em>main</em>. The boolean argument <em>legends</em> can also be
included in any of the two lists in order to control the
display of legends in the corresponding plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc and Thierry Klein
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+fgpm">fgpm</a> for the construction of funGp models;
</p>
<p><strong>*</strong> <a href="#topic+plot+2Cfgpm-method">plot,fgpm-method</a> for model diagnostic plots;
</p>
<p><strong>*</strong> <a href="#topic+predict+2Cfgpm-method">predict,fgpm-method</a> for predictions based on a funGp model;
</p>
<p><strong>*</strong> <a href="#topic+plot.predict.fgpm">plot.predict.fgpm</a> for prediction plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plotting light simulations________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0, 1, length = sqrt(n.tr)),
                   x2 = seq(0, 1, length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
            f2 = matrix(runif(n.tr * 22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# making light simulations
n.sm &lt;- 100
sIn.sm &lt;- as.matrix(expand.grid(x1 = seq(0, 1, length = sqrt(n.sm)),
                                x2 = seq(0, 1, length = sqrt(n.sm))))
fIn.sm &lt;- list(f1 = matrix(runif(n.sm * 10), ncol = 10),
               f2 = matrix(runif(n.sm * 22), ncol = 22))
simsl &lt;- simulate(m1, nsim = 10, sIn.sm = sIn.sm, fIn.sm = fIn.sm)

# plotting light simulations
plot(simsl)


# plotting full simulations_________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0, 1, length = sqrt(n.tr)),
                   x2 = seq(0, 1, length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
            f2 = matrix(runif(n.tr * 22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# making full simulations
n.sm &lt;- 100
sIn.sm &lt;- as.matrix(expand.grid(x1 = seq(0, 1, length = sqrt(n.sm)),
                                x2 = seq(0, 1 ,length = sqrt(n.sm))))
fIn.sm &lt;- list(f1 = matrix(runif(n.sm * 10), ncol = 10),
               f2 = matrix(runif(n.sm * 22), ncol = 22))
simsf &lt;- simulate(m1, nsim = 10, sIn.sm = sIn.sm, fIn.sm = fIn.sm,
                  detail = "full")

# plotting full simulations in "full" mode
plot(simsf)

# plotting full simulations in "light" mode
plot(simsf, detail = "light")

</code></pre>

<hr>
<h2 id='precalculated_Xfgpm_objects'>Precalculated Xfgpm objects</h2><span id='topic+precalculated_Xfgpm_objects'></span><span id='topic+xm'></span><span id='topic+xm25'></span><span id='topic+xmc'></span><span id='topic+xmh'></span><span id='topic+xms'></span>

<h3>Description</h3>

<p>A dataset containing the results of the application of
<code>fgpm_factory</code> to <code>fgp_BB7</code> analytic black-box
function. See <b>Examples</b> for details.
</p>


<h3>Format</h3>

<p>Five objects of class <code>"Xfgpm"</code>:
</p>

<dl>
<dt>xm</dt><dd><p>With 32 training points and default parameters.</p>
</dd>
<dt>xm25</dt><dd><p>With 32 training points and 25 iterations of the algorithm.</p>
</dd>
<dt>xmc</dt><dd><p>With 32 training points and customized solution space.</p>
</dd>
<dt>xmh</dt><dd><p>With 32 training points and customized heuristic parameters.</p>
</dd>
<dt>xms</dt><dd><p>With 32 training points and a time budget constraint and large number of iterations.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

##################################################################
## Construction of xm object with default parameters (~12 seconds)
##################################################################
set.seed(100)
n.tr &lt;- 32
x1 &lt;- x2 &lt;- x3 &lt;- x4 &lt;- x5 &lt;- seq(0,1,length = n.tr^(1/5))
sIn &lt;- expand.grid(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5)
fIn &lt;- list(f1 = matrix(runif(n.tr * 10), ncol = 10),
            f2 = matrix(runif(n.tr * 22), ncol = 22))
sOut &lt;- fgp_BB7(sIn, fIn, n.tr)
xm &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut)

##################################################################
## Construction of xm25 object with 25 iterations (~20 seconds)
##################################################################
xm25 &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut,
                     setup = list(n.iter = 25))

##################################################################
## Construction of xmc object with customized solution space (~12 seconds)
##################################################################
myctr &lt;- list(s_keepOn = c(1,2), # keep both scalar inputs always on
f_keepOn = c(2), # keep f2 always active
f_disTypes = list("2" = c("L2_byindex")), # only use L2_byindex distance for f2
f_fixDims = matrix(c(2,4), ncol = 1), # f2 projected in dimension 4
f_maxDims = matrix(c(1,5), ncol = 1), # f1 projected in dimension max 5
f_basTypes = list("1" = c("B-splines")), # only use B-splines projection for f1
kerTypes = c("matern5_2", "gauss")) # test only Matern 5/2 and Gaussian kernels
xmc &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut, ctraints = myctr)

##################################################################
## Construction of xmc object with customized heuristic parameters (~15 seconds)
##################################################################
mysup &lt;- list(n.iter = 30, n.pop = 12, tao0 = .15, dop.s = 1.2,
              dop.f = 1.3, delta.f = 4, dispr.f = 1.1, q0 = .85,
              rho.l = .2, u.gbest = TRUE, n.ibest = 2, rho.g = .08)
xmh &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut, setup = mysup)

##################################################################
## Construction of xmc object with time budget constraint (~60 seconds)
##################################################################
mysup &lt;- list(n.iter = 2000)
mytlim &lt;- 60
xms &lt;- fgpm_factory(sIn = sIn, fIn = fIn, sOut = sOut,
                    setup = mysup, time.lim = mytlim)


## End(Not run)

</code></pre>

<hr>
<h2 id='predict+2Cfgpm-method'>Prediction from a <code>fgpm</code> Gaussian process model</h2><span id='topic+predict+2Cfgpm-method'></span>

<h3>Description</h3>

<p>This method enables prediction based on a <code>fgpm</code> model, at any given set of
points. Check <code><a href="#topic+fgpm">fgpm</a></code> for information on how to create <code>fgpm</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fgpm'
predict(object, sIn.pr = NULL, fIn.pr = NULL, detail = c("light", "full"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict+2B2Cfgpm-method_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+fgpm-class">fgpm</a> corresponding to the funGp model that should be used
to predict the output.</p>
</td></tr>
<tr><td><code id="predict+2B2Cfgpm-method_+3A_sin.pr">sIn.pr</code></td>
<td>
<p>An optional matrix of scalar input coordinates at which the output values should be
predicted. Each column is interpreted as a scalar input variable and each row as a coordinate.
Either scalar input coordinates (sIn.pr), functional input coordinates (fIn.pr), or both must be provided.</p>
</td></tr>
<tr><td><code id="predict+2B2Cfgpm-method_+3A_fin.pr">fIn.pr</code></td>
<td>
<p>An optional list of functional input coordinates at which the output values should be
predicted. Each element of the list is interpreted as a functional input variable. Every functional input
variable should be provided as a matrix with one curve per row. Either scalar input coordinates (sIn.pr),
functional input coordinates (fIn.pr), or both must be provided.</p>
</td></tr>
<tr><td><code id="predict+2B2Cfgpm-method_+3A_detail">detail</code></td>
<td>
<p>An optional character specifying the extent of information that should be delivered
by the method, to be chosen between <code>"light"</code> (default) and <code>"full"</code>.
<em>Light</em> predictions produce a list including
the predicted mean, standard deviation and limits of the 95% confidence intervals at the prediction
points. <em>Full</em> predictions produce the same information as light ones, in addition to the
training-prediction cross-covariance matrix and the prediction auto-covariance matrix.</p>
</td></tr>
<tr><td><code id="predict+2B2Cfgpm-method_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"list"</code> containing the data structures linked to predictions. For
<em>light</em> predictions, the list will include the mean, standard deviation and limits of the 95%
confidence intervals at the prediction points. For <em>full</em> predictions, it will include the same
information, plus the training-prediction cross-covariance matrix and the prediction auto-covariance
matrix.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+plot.predict.fgpm">plot.predict.fgpm</a> for the prediction plot of a <code>fgpm</code> model;
</p>
<p><strong>*</strong> <a href="#topic+simulate+2Cfgpm-method">simulate,fgpm-method</a> for simulations based on a <code>fgpm</code> model;
</p>
<p><strong>*</strong> <a href="#topic+plot.simulate.fgpm">plot.simulate.fgpm</a> for the simulation plot of a <code>fgpm</code> model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># light predictions________________________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# generating input data for prediction
n.pr &lt;- 100
sIn.pr &lt;- as.matrix(expand.grid(x1 = seq(0,1,length = sqrt(n.pr)),
                                x2 = seq(0,1,length = sqrt(n.pr))))
fIn.pr &lt;- list(f1 = matrix(runif(n.pr*10), ncol = 10), matrix(runif(n.pr*22), ncol = 22))

# making predictions
m1.preds &lt;- predict(m1, sIn.pr = sIn.pr, fIn.pr = fIn.pr)

# checking content of the list
summary(m1.preds)

# ~R output:~
#         Length Class  Mode
# mean    100    -none- numeric
# sd      100    -none- numeric
# lower95 100    -none- numeric
# upper95 100    -none- numeric

# plotting predictions
plot(m1.preds)


# comparison against true output___________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# making predictions
n.pr &lt;- 100
sIn.pr &lt;- as.matrix(expand.grid(x1 = seq(0,1,length = sqrt(n.pr)),
                                x2 = seq(0,1,length = sqrt(n.pr))))
fIn.pr &lt;- list(f1 = matrix(runif(n.pr*10), ncol = 10), matrix(runif(n.pr*22), ncol = 22))
m1.preds &lt;- predict(m1, sIn.pr = sIn.pr, fIn.pr = fIn.pr)

# generating output data for validation
sOut.pr &lt;- fgp_BB3(sIn.pr, fIn.pr, n.pr)

# plotting predictions along with true output values
plot(m1.preds, sOut.pr)


# full predictions_________________________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# making full predictions
n.pr &lt;- 100
sIn.pr &lt;- as.matrix(expand.grid(x1 = seq(0,1,length = sqrt(n.pr)),
                                x2 = seq(0,1,length = sqrt(n.pr))))
fIn.pr &lt;- list(f1 = matrix(runif(n.pr*10), ncol = 10), matrix(runif(n.pr*22), ncol = 22))
m1.preds_f &lt;- predict(m1, sIn.pr = sIn.pr, fIn.pr = fIn.pr, detail = "full")

# checking content of the list
summary(m1.preds_f)

# ~R output:~
#         Length Class  Mode
# mean      100  -none- numeric
# sd        100  -none- numeric
# K.tp     2500  -none- numeric
# K.pp    10000  -none- numeric
# lower95   100  -none- numeric
# upper95   100  -none- numeric

# plotting predictions
plot(m1.preds)

</code></pre>

<hr>
<h2 id='simulate+2Cfgpm-method'>Random sampling from a <code>fgpm</code> model</h2><span id='topic+simulate+2Cfgpm-method'></span>

<h3>Description</h3>

<p>This method enables simulation of Gaussian process values at any given set of points
based on a pre-built <code>fgpm</code> model. Check <code><a href="#topic+fgpm">fgpm</a></code> for information on how to create funGp models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fgpm'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  sIn.sm = NULL,
  fIn.sm = NULL,
  nugget.sm = 0,
  detail = c("light", "full"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2Cfgpm-method_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+fgpm-class">fgpm</a> corresponding to the funGp model from which
simulations must be performed.</p>
</td></tr>
<tr><td><code id="simulate+2B2Cfgpm-method_+3A_nsim">nsim</code></td>
<td>
<p>An optional integer indicating the number of samples to produce. Default is 1.</p>
</td></tr>
<tr><td><code id="simulate+2B2Cfgpm-method_+3A_seed">seed</code></td>
<td>
<p>An optional value interpreted as an integer, that will be used as argument of
<code><a href="base.html#topic+set.seed">set.seed</a></code> just before simulating the response values.</p>
</td></tr>
<tr><td><code id="simulate+2B2Cfgpm-method_+3A_sin.sm">sIn.sm</code></td>
<td>
<p>An optional matrix of scalar input coordinates at which the output values should be
simulated. Each column is interpreted as a scalar input variable and each row as a coordinate.
Either scalar input coordinates (sIn.sm), functional input coordinates (fIn.sm), or both must be provided.</p>
</td></tr>
<tr><td><code id="simulate+2B2Cfgpm-method_+3A_fin.sm">fIn.sm</code></td>
<td>
<p>An optional list of functional input coordinates at which the output values should be
simulated. Each element of the list is interpreted as a functional input variable. Every functional input
variable should be provided as a matrix with one curve per row. Either scalar input coordinates (sIn.sm),
functional input coordinates (fIn.sm), or both must be provided.</p>
</td></tr>
<tr><td><code id="simulate+2B2Cfgpm-method_+3A_nugget.sm">nugget.sm</code></td>
<td>
<p>An optional number corresponding to a numerical nugget effect. If provided, this number
is added to the main diagonal of the simulation covariance matrix in order to prevent numerical
instabilities during Cholesky decomposition. A small number in the order of 1e-8 is often enough.
Default is 0.</p>
</td></tr>
<tr><td><code id="simulate+2B2Cfgpm-method_+3A_detail">detail</code></td>
<td>
<p>An optional character specifying the extent of information that should be delivered
by the method, to be chosen between <code>"light"</code> (default)  and <code>"full"</code>.
<em>Light</em> simulations produce a matrix of
simulated output values, with as many rows as requested random samples. <em>Full</em> simulations produce a
list with the matrix of simulated output values, along with the predicted mean, standard deviation and
limits of the 95% confidence intervals at the simulation points.</p>
</td></tr>
<tr><td><code id="simulate+2B2Cfgpm-method_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object containing the data structures linked to simulations. For <em>light</em> simulations, the
output will be a matrix of simulated output values, with as many rows as requested random samples.
For <em>full</em> simulations, the output will be a list with the matrix of simulated output values,
along with the predicted mean, standard deviation and limits of the 95% confidence intervals at the
simulation points.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+plot.simulate.fgpm">plot.simulate.fgpm</a> for the simulation plot of a <code>fgpm</code> model;
</p>
<p><strong>*</strong> <a href="#topic+predict+2Cfgpm-method">predict,fgpm-method</a> for predictions based on a <code>fgpm</code> model;
</p>
<p><strong>*</strong> <a href="#topic+plot.predict.fgpm">plot.predict.fgpm</a> for the prediction plot of a <code>fgpm</code> model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># light simulations _______________________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# generating input data for simulation
n.sm &lt;- 100
sIn.sm &lt;- as.matrix(expand.grid(x1 = seq(0,1,length = sqrt(n.sm)),
                                x2 = seq(0,1,length = sqrt(n.sm))))
fIn.sm &lt;- list(f1 = matrix(runif(n.sm*10), ncol = 10), matrix(runif(n.sm*22), ncol = 22))

# making light simulations
m1.sims_l &lt;- simulate(m1, nsim = 10, sIn.sm = sIn.sm, fIn.sm = fIn.sm)

# plotting light simulations
plot(m1.sims_l)


# full simulations ________________________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# making full simulations
m1.sims_f &lt;- simulate(m1, nsim = 10, sIn.sm = sIn.sm, fIn.sm = fIn.sm, detail = "full")

# checking content of the list
summary(m1.sims_f)

# ~R output:~
#         Length Class  Mode
# sims    1000   -none- numeric
# mean     100   -none- numeric
# sd       100   -none- numeric
# lower95  100   -none- numeric
# upper95  100   -none- numeric

# plotting full simulations in full mode
plot(m1.sims_f)

# plotting full simulations in light mode
plot(m1.sims_f, detail = "light")

</code></pre>

<hr>
<h2 id='summary+2Cfgpm-method'>Summary method for <code>fgpm</code> objects</h2><span id='topic+summary+2Cfgpm-method'></span>

<h3>Description</h3>

<p>Display the structure of a <code>fgpm</code>
object and the value of the parameters (variance and length-scales).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fgpm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2Cfgpm-method_+3A_object">object</code></td>
<td>
<p>An <code>fgpm</code> object.</p>
</td></tr>
<tr><td><code id="summary+2B2Cfgpm-method_+3A_...">...</code></td>
<td>
<p>Not used yet.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This method is actually identical to the <code>show</code> method
for this class which is called when the name of the object is
entered in an interactive session.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- xm@model
class(m)
summary(m)
m
</code></pre>

<hr>
<h2 id='summary+2CXfgpm-method'>Summary method for <code>Xfgpm</code> objects</h2><span id='topic+summary+2CXfgpm-method'></span>

<h3>Description</h3>

<p>Display a summary of the structure of a <code>Xfgpm</code>
object, with a short description of up to <code>n</code> <code>fgpm</code>
objects visited during the ACO optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Xfgpm'
summary(object, n = 24, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CXfgpm-method_+3A_object">object</code></td>
<td>
<p>A <code>Xfgpm</code> object.</p>
</td></tr>
<tr><td><code id="summary+2B2CXfgpm-method_+3A_n">n</code></td>
<td>
<p>Maximal number of lines (<code>fgpm</code> objects) to show.</p>
</td></tr>
<tr><td><code id="summary+2B2CXfgpm-method_+3A_...">...</code></td>
<td>
<p>Not used yet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The displayed information depends on the number of
candidate inputs, in order to maintain compact tables.  The
inputs are labelled with integer suffixes, the prefix being
<code>"X"</code> for scalar inputs and <code>"F"</code> for functional
inputs.
</p>

<ul>
<li><p>With a small number of inputs, the list
contains only one data frame. For each candidate
input (either scalar or functional) a column with
the input name indicates if the input
is active (cross <code>x</code>) or not (white space)
in the <code>fgpm</code> object corresponding to the row. For each
functional variable also shown are: the distance used <code>D_</code>,
the dimension <code>Bas_</code> after dimension reduction,
the type of basis used <code>B_</code>. Remind that the
kernel (<code>Kern</code>) is the same for all functional
inputs. Also shown is the value of the Leave-One-Out
coefficient <code>Q²</code>.

</p>
</li>
<li><p>With a large number of inputs, the list contains
two data frames. The first one tells which inputs
are active among the scalar and functional candidate
inputs. The second data frame gives more details
for functional inputs as before.
</p>
</li></ul>



<h3>Value</h3>

<p>An object inheriting from <code>list</code>, actually a list
containing one or two data frames depending on the number of
inputs. In each data frame, the <code>n</code> rows provide
information on the best <code>fgpm</code> objects visited.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(xm)
</code></pre>

<hr>
<h2 id='update+2Cfgpm-method'>Easy update of <code>fgpm</code> models</h2><span id='topic+update+2Cfgpm-method'></span>

<h3>Description</h3>

<p>This method enables the update of data or hyperparameters of a <code>fgpm</code> model.
It corresponds to an object of the class <a href="#topic+fgpm-class">fgpm</a>. The method allows addition, subtraction
and substitution of data points, as well as substitution and re-estimation of hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fgpm'
update(
  object,
  sIn.nw = NULL,
  fIn.nw = NULL,
  sOut.nw = NULL,
  sIn.sb = NULL,
  fIn.sb = NULL,
  sOut.sb = NULL,
  ind.sb = NULL,
  ind.dl = NULL,
  var.sb = NULL,
  ls_s.sb = NULL,
  ls_f.sb = NULL,
  var.re = FALSE,
  ls_s.re = FALSE,
  ls_f.re = FALSE,
  extend = FALSE,
  trace = TRUE,
  pbars = TRUE,
  control.optim = list(trace = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2Cfgpm-method_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+fgpm-class">fgpm</a> corresponding to the funGp model to update.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_sin.nw">sIn.nw</code></td>
<td>
<p>An optional matrix of scalar input values to be added to the model. Each column must match
an input variable and each row a scalar coordinate.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_fin.nw">fIn.nw</code></td>
<td>
<p>An optional list of functional input values to be added to the model. Each element of the
list must be a matrix containing the set of curves corresponding to one functional input.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_sout.nw">sOut.nw</code></td>
<td>
<p>An optional vector (or 1-column matrix) containing the values of the scalar output at the
new input points.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_sin.sb">sIn.sb</code></td>
<td>
<p>An optional matrix of scalar input values to be used as substitutes of other scalar input
values already stored in the model. Each column must match an input variable and each row a coordinate.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_fin.sb">fIn.sb</code></td>
<td>
<p>An optional list of functional input values to be added to the model. Each element of the
list must be a matrix containing the set of curves corresponding to one functional input.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_sout.sb">sOut.sb</code></td>
<td>
<p>An optional vector (or 1-column matrix) containing the values of the scalar output at the
substituting input points.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_ind.sb">ind.sb</code></td>
<td>
<p>An optional numeric array indicating the indices of the input and output points stored in
the model, that should be replaced by the values specified through sIn.sb, fIn.sb and/or sOut.sb.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_ind.dl">ind.dl</code></td>
<td>
<p>An optional numeric array indicating the indices of the input and output points stored in
the model that should be deleted.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_var.sb">var.sb</code></td>
<td>
<p>An optional number indicating the value that should be used to substitute the current
variance parameter of the model.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_ls_s.sb">ls_s.sb</code></td>
<td>
<p>An optional numerical array indicating the values that should be used to substitute the
current length-scale parameters for the scalar inputs of the model.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_ls_f.sb">ls_f.sb</code></td>
<td>
<p>An optional numerical array indicating the values that should be used to substitute the
current length-scale parameters for the functional inputs of the model.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_var.re">var.re</code></td>
<td>
<p>An optional boolean indicating whether the variance parameter should be re-estimated.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_ls_s.re">ls_s.re</code></td>
<td>
<p>An optional boolean indicating whether the length-scale parameters of the scalar inputs
should be re-estimated. Default is FALSE.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_ls_f.re">ls_f.re</code></td>
<td>
<p>An optional boolean indicating whether the length-scale parameters of the functional
inputs should be re-estimated. Default is FALSE.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_extend">extend</code></td>
<td>
<p>An optional boolean indicating whether the re-optimization should extend from the current
hyperparameters of the model using them as initial points. Default is FALSE, meaning that the
re-optimization picks brand new initial points in the way described in <code><a href="#topic+fgpm">fgpm</a>()</code>. If
both hyperparameter substitution and re-estimation are requested in a single <code>update()</code> call and
<code>extend</code> is set to <code>TRUE</code>, the values used as initial points for the re-optimization are those
stored by the model after the substitution step.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_trace">trace</code></td>
<td>
<p>An optional boolean indicating whether funGp-native progress messages and a summary update
should be displayed. Default is TRUE. See the <code><a href="#topic+fgpm">fgpm</a>()</code> documentation for more details.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_pbars">pbars</code></td>
<td>
<p>An optional boolean indicating whether progress bars managed by <code><a href="#topic+fgpm">fgpm</a>()</code>
should be displayed (in case the update requires an <code><a href="#topic+fgpm">fgpm</a>()</code> call). Default is TRUE.
See the <code><a href="#topic+fgpm">fgpm</a>()</code> documentation for more details.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_control.optim">control.optim</code></td>
<td>
<p>An optional list to be passed as the control argument to <code><a href="stats.html#topic+optim">optim</a></code>()
(in case the update requires an <code><a href="#topic+fgpm">fgpm</a>()</code> call), the function in charge of the non-linear
optimization of the hyperparameters. Default is list(trace = TRUE). See the <code><a href="#topic+fgpm">fgpm</a>()</code>
documentation for more details.</p>
</td></tr>
<tr><td><code id="update+2B2Cfgpm-method_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments listed above enable the completion of the following updating tasks:
</p>

<ul>
<li> <p><strong>Deletion</strong> of data points: ind.dl;
</p>
</li>
<li> <p><strong>Addition</strong> of data points: sIn.nw, fIn.nw, sOut.nw;
</p>
</li>
<li> <p><strong>Substitution</strong> of data points: sIn.sb, fIn.sb, sOut.sb, ind.sb;
</p>
</li>
<li> <p><strong>Substitution</strong> of hyperparameters: var.sb, ls_s.sb, ls_f.sb;
</p>
</li>
<li> <p><strong>Re-estimation</strong> of hyperparameters: var.re, ls_s.re, ls_f.re.
</p>
</li></ul>

<p>All the arguments listed above are optional since any of these tasks can be requested without need to
request any of the other tasks. In fact, most of the arguments can be used even if the other
arguments related to the same task are not. For instance, the re-estimation of the variance can be
requested via var.re without requiring re-estimation of the scalar or functional length-scale
parameters. The only two exceptions are: (i) for data addition, the new output sOut.nw should always
be provided and the new input points should correspond to the set of variables already stored in the
<a href="#topic+fgpm-class">fgpm</a> object passed for update; and (ii) for data substitution, the argument ind.sb is
always mandatory.
</p>
<p><strong>Conflicting task combinations:</strong>
</p>

<ul>
<li><p> Data points deletion and substitution;
</p>
</li>
<li><p> Substitution and re-estimation of the same hyperparameter.
</p>
</li></ul>

<p>Note that the parameters of the model will not be updated after modifying the model unless explicitly
requested through the var.re, ls_s.re and ls_f.re arguments. If, for instance, some points are added
to the model without requesting parameter re-estimation, the new data will be included in the
training-training and training-prediction covariance matrices, but the hyperparameters will not
be updated. This allows to make updates in the data that might help to improve predictions,
without the immediate need to perform a training procedure that could be time consuming. At any later
time, the user is allowed to request the re-estimation of the hyperparameters, which will make
the model fully up to date.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+fgpm-class">fgpm</a> representing the updated funGp model.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+fgpm">fgpm</a> for creation of a funGp model;
</p>
<p><strong>*</strong> <a href="#topic+predict+2Cfgpm-method">predict,fgpm-method</a> for predictions based on a <code>fgpm</code> model;
</p>
<p><strong>*</strong> <a href="#topic+simulate+2Cfgpm-method">simulate,fgpm-method</a> for simulations based on a <code>fgpm</code> model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># deletion and addition of data points_____________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# deleting two points
ind.dl &lt;- sample(1:m1@n.tot, 2)
m1up &lt;- update(m1, ind.dl = ind.dl)

# adding five points
n.nw &lt;- 5
sIn.nw &lt;- matrix(runif(n.nw * m1@ds), nrow = n.nw)
fIn.nw &lt;- list(f1 = matrix(runif(n.nw*10), ncol = 10), f2 = matrix(runif(n.nw*22), ncol = 22))
sOut.nw &lt;- fgp_BB3(sIn.nw, fIn.nw, n.nw)
m1up &lt;- update(m1, sIn.nw = sIn.nw, fIn.nw = fIn.nw, sOut.nw = sOut.nw)


# substitution of data points______________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# generating substituting input data for updating
n.sb &lt;- 2
sIn.sb &lt;- matrix(runif(n.sb * m1@ds), nrow = n.sb)
fIn.sb &lt;- list(f1 = matrix(runif(n.sb*10), ncol = 10), f2 = matrix(runif(n.sb*22), ncol = 22))

# generating substituting output data for updating
sOut.sb &lt;- fgp_BB3(sIn.sb, fIn.sb, n.sb)

# generating indices for substitution
ind.sb &lt;- sample(1:(m1@n.tot), n.sb)

# updating all, the scalar inputs, functional inputs and the outputs
m1up &lt;- update(m1, sIn.sb = sIn.sb, fIn.sb = fIn.sb, sOut.sb = sOut.sb, ind.sb = ind.sb)

# updating only some of the data structures
m1up1 &lt;- update(m1, sIn.sb = sIn.sb, ind.sb = ind.sb) # only the scalar inputs
m1up2 &lt;- update(m1, sOut.sb = sOut.sb, ind.sb = ind.sb) # only the outputs
m1up3 &lt;- update(m1, sIn.sb = sIn.sb, sOut.sb = sOut.sb, ind.sb = ind.sb) # the scalar inputs
                                                                         # and the outputs


# substitution of hyperparameters__________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# defining hyperparameters for substitution
var.sb &lt;- 3
ls_s.sb &lt;- c(2.44, 1.15)
ls_f.sb &lt;- c(5.83, 4.12)

# updating the model
m1up &lt;- update(m1, var.sb = var.sb, ls_s.sb = ls_s.sb, ls_f.sb = ls_f.sb)


# re-estimation of hyperparameters_________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# re-estimating the hyperparameters
m1up &lt;- update(m1, var.re = TRUE) # only the variance
m1up &lt;- update(m1, ls_s.re = TRUE) # only the scalar length-scale parameters
m1up &lt;- update(m1, ls_s.re = TRUE, ls_f.re = TRUE) # all length-scale parameters
m1up &lt;- update(m1, var.re = TRUE, ls_s.re = TRUE, ls_f.re = TRUE) # all hyperparameters

# same as above but now extending optimization from previously stored values
m1up &lt;- update(m1, var.re = TRUE, extend = TRUE)
m1up &lt;- update(m1, ls_s.re = TRUE, extend = TRUE)
m1up &lt;- update(m1, ls_s.re = TRUE, ls_f.re = TRUE, extend = TRUE)
m1up &lt;- update(m1, var.re = TRUE, ls_s.re = TRUE, ls_f.re = TRUE, extend = TRUE)

</code></pre>

<hr>
<h2 id='which_on'>Indices of active inputs in a given model structure</h2><span id='topic+which_on'></span>

<h3>Description</h3>

<p>The <a href="#topic+fgpm_factory">fgpm_factory</a> function returns an object of class <code>"<a href="#topic+Xfgpm-class">Xfgpm</a>"</code>
with the function calls of all the evaluated models stored in the <code>@log.success@args</code> and
<code>@log.crashes@args</code> slots. The <code>which_on</code> function interprets the arguments linked to any
structural configuration and returns a list with two elements: (i) an <code>array</code> of indices of the scalar
inputs kept active; and (ii) an <code>array</code> of indices of the functional inputs kept active.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_on(sIn = NULL, fIn = NULL, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_on_+3A_sin">sIn</code></td>
<td>
<p>An optional matrix of scalar input coordinates with all the orignal scalar input variables.
This is used only to know the total number of scalar input variables. Any <code>matrix</code> with as many
columns as original scalar input variables could be used instead.</p>
</td></tr>
<tr><td><code id="which_on_+3A_fin">fIn</code></td>
<td>
<p>An optional list of functional input coordinates with all the original functional input
variables. This is used only to know the total number of functional input variables. Any <code>list</code>
with as many elements as original functional input variables could be used instead.</p>
</td></tr>
<tr><td><code id="which_on_+3A_args">args</code></td>
<td>
<p>An object of class <code>"<a href="#topic+modelCall-class">modelCall</a>"</code>, which specifies the model structure for
which the active inputs should be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"list"</code>, containing the following information extracted from the
<em>args</em> parameter: (i) an array of indices of the scalar inputs kept active; and (ii) an array of
indices of the functional inputs kept active.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>References</h3>

<p>Betancourt, J., Bachoc, F., and Klein, T. (2020),
R Package Manual: &quot;Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour&quot;.
<em>RISCOPE project</em>.
<a href="https://hal.archives-ouvertes.fr/hal-02536624">[HAL]</a>
</p>


<h3>See Also</h3>

<p><strong>*</strong> <a href="#topic+get_active_in">get_active_in</a> for details on how to obtain the data structures linked to the
active inputs;
</p>
<p><strong>*</strong> <a href="#topic+modelCall-class">modelCall</a> for details on the <em>args</em> argument;
</p>
<p><strong>*</strong> <a href="#topic+fgpm_factory">fgpm_factory</a> for funGp heuristic model selection;
</p>
<p><strong>*</strong> <a href="#topic+Xfgpm-class">Xfgpm</a> for details on object delivered by <a href="#topic+fgpm_factory">fgpm_factory</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># extracting the indices of the active inputs in an optimized model________________________
# use precalculated Xfgpm object named xm
# active inputs in the best model
xm@log.success@args[[1]] # the full fgpm call
set.seed(100)
n.tr &lt;- 32
sIn &lt;- expand.grid(x1 = seq(0,1,length = n.tr^(1/5)), x2 = seq(0,1,length = n.tr^(1/5)),
x3 = seq(0,1,length = n.tr^(1/5)), x4 = seq(0,1,length = n.tr^(1/5)),
x5 = seq(0,1,length = n.tr^(1/5)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
which_on(sIn, fIn, xm@log.success@args[[1]]) # only the indices extracted by which_on

</code></pre>

<hr>
<h2 id='Xfgpm-class'>S4 class for funGp model selection data structures</h2><span id='topic+Xfgpm-class'></span>

<h3>Description</h3>

<p>This is the formal representation of the assembly of data structures delivered by the model
selection routines in the <a href="#topic+funGp-package">funGp package</a>. An <code>Xfgpm</code> object contains the
trace of an optimization process, conducted to build Gaussian process models of outstanding performance.
</p>

<ul>
<li><p><strong>Main methods</strong><br />
<a href="#topic+fgpm_factory">fgpm_factory</a>: structural optimization of <code>fgpm</code> models,
creator of the <code>"Xfgpm"</code> class. <br />

</p>
</li>
<li><p><strong>Plotters</strong><br />
<a href="#topic+plot+2CXfgpm-method">plot,Xfgpm-method</a>: plot of the evolution of the algorithm with <code>which = "evolution"</code>
or of the absolute and relative quality of the optimized model with <code>which = "diag"</code>.

</p>
</li></ul>



<h3>Slots</h3>


<dl>
<dt><code>factoryCall</code></dt><dd><p>Object of class <code>"<a href="#topic+factoryCall-class">factoryCall</a>"</code>. User call reminder.</p>
</dd>
<dt><code>model</code></dt><dd><p>Object of class <code>"<a href="#topic+fgpm-class">fgpm</a>"</code>. Model selected by the heuristic structural
optimization algorithm.</p>
</dd>
<dt><code>stat</code></dt><dd><p>Object of class <code>"character"</code>. Performance measure optimized to select the model. To be
set from &quot;Q2loocv&quot;, &quot;Q2hout&quot;.</p>
</dd>
<dt><code>fitness</code></dt><dd><p>Object of class <code>"numeric"</code>. Value of the performance measure for the selected model.</p>
</dd>
<dt><code>structure</code></dt><dd><p>Object of class <code>"data.frame"</code>. Structural configuration of the selected model.</p>
</dd>
<dt><code>log.success</code></dt><dd><p>Object of class <code>"<a href="#topic+antsLog-class">antsLog</a>"</code>. Record of models successfully
evaluated during the structural optimization. It contains the structural configuration both in
data.frame and <code>"<a href="#topic+modelCall-class">modelCall</a>"</code> format, along with the fitness of each model. The
models are sorted by fitness, starting with the best model in the first position.</p>
</dd>
<dt><code>log.crashes</code></dt><dd><p>Object of class <code>"<a href="#topic+antsLog-class">antsLog</a>"</code>. Record of models crashed during the
structural optimization. It contains the structural configuration of each model, both in data.frame
and <code>"<a href="#topic+modelCall-class">modelCall</a>"</code> format.</p>
</dd>
<dt><code>n.solspace</code></dt><dd><p>Object of class <code>"numeric"</code>. Number of possible structural configurations for
the optimization instance resolved.</p>
</dd>
<dt><code>n.explored</code></dt><dd><p>Object of class <code>"numeric"</code>. Number of structural configurations successfully
evaluated by the algorithm.</p>
</dd>
<dt><code>details</code></dt><dd><p>Object of class <code>"list"</code>. Further information about the parameters of the ant colony
optimization algorithm and the evolution of the fitness along the iterations.</p>
</dd>
<dt><code>sIn</code></dt><dd><p>An object of class <code>"matrix"</code> containing a copy of
the provided scalar inputs.</p>
</dd>
<dt><code>fIn</code></dt><dd><p>An object of class <code>"list"</code> containing a copy of
the provided functional inputs.</p>
</dd>
<dt><code>sOut</code></dt><dd><p>An object of class <code>"matrix"</code> containing a copy of the provided outputs.</p>
</dd>
</dl>


<h3>Useful material</h3>


<ul>
<li><p><strong>Manual</strong>
<a href="https://hal.archives-ouvertes.fr/hal-02536624">
Gaussian Process Regression for Scalar and Functional Inputs with funGp - The in-depth tour
</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
