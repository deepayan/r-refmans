<!DOCTYPE html><html lang="en"><head><title>Help for package psyphy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {psyphy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#psyphy-package'>
<p>Functions for analyzing psychophysical functions</p></a></li>
<li><a href='#dprime.ABX'><p> d' for ABX Paradigm</p></a></li>
<li><a href='#dprime.mAFC'><p> d' for m-alternative Forced-choice</p></a></li>
<li><a href='#dprime.oddity'><p>d' for 3 Stimulus Oddity Paradigm</p></a></li>
<li><a href='#dprime.SD'><p>d' for Same-different Paradigm</p></a></li>
<li><a href='#ecc2'><p>4-afc Detection and Identification of Letters</p></a></li>
<li><a href='#glm.lambda'><p> mafc Probit Fit to Psychometric Function Profiled on Upper Asymptote</p></a></li>
<li><a href='#glm.WH'><p> mafc Probit Fit to Psychometric Function with Upper Asymptote Less than One</p></a></li>
<li><a href='#logit.2asym'><p> Links for Binomial Family with Variable Upper/Lower Asymptotes</p></a></li>
<li><a href='#mafc'><p>Links for Binomial Family for m-alternative Forced-choice</p></a></li>
<li><a href='#probit.lambda'><p> mafc Probit Link for Binomial Family with Upper Asymptote &lt; 1</p></a></li>
<li><a href='#psyfun.2asym'><p>Fit Psychometric Functions and Upper and Lower Asymptotes</p></a></li>
<li><a href='#RGB'><p> Luminance Calibration Data from Video Projector</p></a></li>
<li><a href='#SS.RGBcalib'><p>  Self-Start Functions for Fitting Luminance vs Grey Level Relation on CRT displays</p></a></li>
<li><a href='#summary.lambda'><p> Summary Method for Objects of Class &lsquo;lambda&rsquo;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Analyzing Psychophysical Data in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Kenneth Knoblauch</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ken Knoblauch &lt;ken.knoblauch@inserm.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, nlme, lattice</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>An assortment of functions that could be useful in analyzing data from psychophysical experiments. It includes functions for calculating d' from several different experimental designs, links for m-alternative forced-choice (mafc) data to be used with the binomial family in glm (and possibly other contexts) and self-Start functions for estimating gamma values for CRT screen calibrations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 13:51:23 UTC; ken</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='psyphy-package'>
Functions for analyzing psychophysical functions
</h2><span id='topic+psyphy-package'></span><span id='topic+psyphy'></span>

<h3>Description</h3>

<p>An assortment of functions that could be useful in analyzing data from pyschophysical experiments. It includes functions for calculating d' from several different experimental designs, links for mafc to be used with the binomial family in glm (and possibly other contexts) and a self-Start function for estimating gamma values for CRT screen calibrations.
</p>


<h3>Details</h3>

<p>For the moment, the package contains several functions for calculating
<code class="reqn">d'</code> for a variety of psychophysical paradigms, some link functions for
the binomial family in glm (and perhaps other functions) for fitting
psychometric functions from mAFC experiments and a self-Start function
for estimating the value of the exponent, gamma, based on the
luminance calibration of the three channels of a CRT-like display.
</p>


<h3>Author(s)</h3>

<p>Kenneth Knoblauch
&lt;ken.knoblauch@inserm.fr&gt;
</p>

<hr>
<h2 id='dprime.ABX'> d' for ABX Paradigm </h2><span id='topic+dprime.ABX'></span>

<h3>Description</h3>

<p>Calulate <code class="reqn">d'</code> for ABX paradigm either 
assuming a differencing strategy or independent observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprime.ABX(Hits, FA, zdiff, Pc.unb, method = "diff")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dprime.ABX_+3A_hits">Hits</code></td>
<td>
<p>numeric in [0, 1] corresponding to Hit rate</p>
</td></tr>
<tr><td><code id="dprime.ABX_+3A_fa">FA</code></td>
<td>
<p>numeric in [0, 1] corresponding to False alarm rate</p>
</td></tr>
<tr><td><code id="dprime.ABX_+3A_zdiff">zdiff</code></td>
<td>
<p>numeric. Difference of z-scores for Hit and False Alarm rates
</p>
</td></tr>
<tr><td><code id="dprime.ABX_+3A_pc.unb">Pc.unb</code></td>
<td>
<p>numeric in [0, 1].  Proportion correct for an unbiased observer,
<code>pnorm(zdiff)</code></p>
</td></tr>
<tr><td><code id="dprime.ABX_+3A_method">method</code></td>
<td>
<p>character. Specifies the model to describe
the observer's criterion for dividing up the decision space,
must be either &quot;diff&quot; for a differencing strategy (the default)
or &quot;IO&quot; for independent observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two different strategies have been described for how the
observer partitions the decision space in the ABX
paradigm, either based on Independent Observations of
each stimulus or on a differencing strategy.  The differecing
strategy is the default. <code class="reqn">d'</code> can be calculated
either from the <code>H</code> and <code>FA</code> rates, from the difference of
z-scores or from the probability correct of an unbiased observer.
</p>


<h3>Value</h3>

<p>Returns the value of <code class="reqn">d'</code>
</p>


<h3>Author(s)</h3>

<p>Kenneth Knoblauch</p>


<h3>References</h3>

<p>MacMillan, N. A. and Creeman, C. D. (1991) <em>Detection
Theory: A User's Guide</em> Cambridge University Press
</p>
<p>Green, D. M. and Swets, J. A. (1966) <em>Signal Detection
Theory and Psychophysics</em> Robert E. Krieger Publishing Company  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dprime.mAFC">dprime.mAFC</a></code>, <code><a href="#topic+dprime.SD">dprime.SD</a></code>,
<code><a href="#topic+dprime.oddity">dprime.oddity</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dprime.ABX(H = 0.75, F = 0.3)
dprime.ABX(H = 0.75, F = 0.3, method = "IO")
dprime.ABX(zdiff = qnorm(0.75) - qnorm(0.3))
dprime.ABX(Pc.unb = pnorm( (qnorm(0.75) - qnorm(0.3))/2 ))

</code></pre>

<hr>
<h2 id='dprime.mAFC'> d' for m-alternative Forced-choice </h2><span id='topic+dprime.mAFC'></span>

<h3>Description</h3>

<p>Calculate the value of <code class="reqn">d'</code> for an m-alternative forced choice paradigm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprime.mAFC(Pc, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dprime.mAFC_+3A_pc">Pc</code></td>
<td>
<p> The proportion of correct responses based on either the Hit
rate or based on an unbiased observer</p>
</td></tr>
<tr><td><code id="dprime.mAFC_+3A_m">m</code></td>
<td>
<p> The number of alternative choices, an integer &gt; 1. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability of a correct response in m-alternative forced-choice,
assuming independence, is based on the product of the likelihoods
of the signal alternative generating the strongest response and
the m - 1 noise alternatives generating responses less than this
value (Green and Dai, 1991).
For a Yes-No paradigm, the sensitivity is calculated
more simply as </p>
<p style="text-align: center;"><code class="reqn">d' = \code{qnorm}(H) - \code{qnorm}(F)</code>
</p>

<p>where <code class="reqn">H</code> and <code class="reqn">F</code> are the Hit and False Alarm rates,
respectively.
</p>


<h3>Value</h3>

<p>Returns the value of <code class="reqn">d'</code>
</p>


<h3>Note</h3>

  
<p>Currently is only valid for <code class="reqn">d'</code> in the interval [-10, 10]
which should be well outside the range of sensory differences that
this paradigm is used to investigate.
</p>


<h3>Author(s)</h3>

<p> Kenneth Knoblauch </p>


<h3>References</h3>

<p>Green, D. M. and Dai, H. (1991) Probability of being correct with
1 of M orthogonal signals.  <em>Perception &amp; Psychophysics</em>,
<b>49</b>, 100&ndash;101.
</p>
<p>Green, D. M. and Swets, J. A. (1966) <em>Signal Detection
Theory and Psychophysics</em> Robert E. Krieger Publishing Company  </p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+dprime.ABX">dprime.ABX</a></code>, <code><a href="#topic+dprime.SD">dprime.SD</a></code>,
<code><a href="#topic+dprime.oddity">dprime.oddity</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
dprime.mAFC(0.8, 4)
</code></pre>

<hr>
<h2 id='dprime.oddity'>d' for 3 Stimulus Oddity Paradigm </h2><span id='topic+dprime.oddity'></span>

<h3>Description</h3>

<p>Calculate <code class="reqn">d'</code> for a 3 stimulus (triangular) paradigm.  Two of the
stimuli are the same and the observer must designate the stimulus that
is different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprime.oddity(Pc.tri)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dprime.oddity_+3A_pc.tri">Pc.tri</code></td>
<td>
<p>numeric in (1/3, 1).  The proportion of correct
responses for an unbiased observer.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of <code class="reqn">d'</code>
</p>


<h3>Author(s)</h3>

<p>Kenneth Knoblauch</p>


<h3>References</h3>

<p>Frijters, G. S., Kooistra, A. and Verijken, P. F. G. (1980) Tables of <code class="reqn">d'</code>
for the triangular method and the 3-AFC signal detection procedure.
<em>Perception &amp; Psychophysics</em>, <b>27</b>, 176&ndash;178.
</p>
<p>MacMillan, N. A. and Creeman, C. D. (1991) <em>Detection
Theory: A User's Guide</em> Cambridge University Press
</p>
<p>Green, D. M. and Swets, J. A. (1966) <em>Signal Detection
Theory and Psychophysics</em> Robert E. Krieger Publishing Company  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dprime.mAFC">dprime.mAFC</a></code>, <code><a href="#topic+dprime.SD">dprime.SD</a></code>,
<code><a href="#topic+dprime.ABX">dprime.ABX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dprime.oddity(0.8)
</code></pre>

<hr>
<h2 id='dprime.SD'>d' for Same-different Paradigm</h2><span id='topic+dprime.SD'></span>

<h3>Description</h3>

<p>Calulate <code class="reqn">d'</code> for same-different paradigm either 
assuming a differencing strategy or independent observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprime.SD(H, FA, zdiff, Pcmax, method = "diff")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dprime.SD_+3A_h">H</code></td>
<td>
<p>numeric in [0, 1] corresponding to Hit rate</p>
</td></tr>
<tr><td><code id="dprime.SD_+3A_fa">FA</code></td>
<td>
<p>numeric in [0, 1] corresponding to False alarm rate</p>
</td></tr>
<tr><td><code id="dprime.SD_+3A_zdiff">zdiff</code></td>
<td>
<p>numeric. Difference of z-scores for Hit and False Alarm rates
( only valid for method &quot;IO&quot;)</p>
</td></tr>
<tr><td><code id="dprime.SD_+3A_pcmax">Pcmax</code></td>
<td>
<p>numeric in [0, 1].  Proportion correct for an unbiased observer,
<code>pnorm(zdiff/2)</code> (only valid for method &quot;IO&quot;).
</p>
</td></tr>
<tr><td><code id="dprime.SD_+3A_method">method</code></td>
<td>
<p>character. Specifies the model to describe
the observer's criterion for dividing up the decision space,
must be either &quot;diff&quot; for a differencing strategy (the default)
or &quot;IO&quot; for independent observations. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two different strategies have been described for how the
observer partitions the decision space in the same-different
paradigm.  With Independent Observations, <code class="reqn">d'</code> can be calculated
either from the <code>H</code> and <code>FA</code> rates, from the difference of
z-scores or from the probability correct of an unbiased observer.
Only one of these three choices should be specified in the arguments.
For the differencing strategy, only the first of these choices is valid.
</p>


<h3>Value</h3>

<p>Returns the value of <code class="reqn">d'</code>
</p>


<h3>Author(s)</h3>

<p>Kenneth Knoblauch </p>


<h3>References</h3>

<p>MacMillan, N. A. and Creeman, C. D. (1991) <em>Detection
Theory: A User's Guide</em> Cambridge University Press
</p>
<p>Green, D. M. and Swets, J. A. (1966) <em>Signal Detection
Theory and Psychophysics</em> Robert E. Krieger Publishing Company   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dprime.mAFC">dprime.mAFC</a></code>, <code><a href="#topic+dprime.ABX">dprime.ABX</a></code>,
<code><a href="#topic+dprime.oddity">dprime.oddity</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>dprime.SD(H = 0.642, F = 0.3)
dprime.SD(H = 0.75, F = 0.3, method = "IO")
dprime.SD(zdiff = qnorm(0.75) - qnorm(0.3), method = "IO")
dprime.SD(Pcmax = pnorm( (qnorm(0.75) - qnorm(0.3))/2 ), method = "IO")
</code></pre>

<hr>
<h2 id='ecc2'>4-afc Detection and Identification of Letters</h2><span id='topic+ecc2'></span>

<h3>Description</h3>

<p>Letter detection and identification at 2 degrees eccentricity in
the visual field.  On each trial, one of four letters (b, d, p, q) were presented in one of four positions (superior, inferior, left, right) in the visual field.  In a given session, the letter
height was fixed.  Six contrast levels were tested in each
session.  The data indicate the proportion of correctly
identified positions, referred to here as detection, and
the proportion of correctly identified letters, conditional
on correct identification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ecc2)</code></pre>


<h3>Format</h3>

<p>A data frame with 48 observations on the following 5 variables.
</p>

<dl>
<dt><code>Contr</code></dt><dd><p>numeric. The contrast of the stimulus, defined as
Weberian contrast.</p>
</dd>
<dt><code>task</code></dt><dd><p>a factor with levels <code>DET</code> <code>ID</code>
indicating the two tasks, detection and identification.</p>
</dd>
<dt><code>Size</code></dt><dd><p>a numeric vector indicating the letter height</p>
</dd>
<dt><code>Correct</code></dt><dd><p>an integer vector indicating the number of correct responses (<code>DET</code> or <code>ID</code>).</p>
</dd>
<dt><code>Incorrect</code></dt><dd><p>an integer vector, indicating the number
of incorrect responses.</p>
</dd>
</dl>



<h3>References</h3>

<p>Yssaad-Fesselier, R. and Knoblauch, K. (2006) Modeling psychometric
functions in R. <em> Behav Res Methods.</em>,  <b>38(1)</b>, 28&ndash;41.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecc2)
library(lattice)
xyplot(Correct/(Correct + Incorrect) ~ Contr | Size * task, ecc2, 
		type = "b", scale = list(x = list(log = TRUE), 
		y = list(limits = c(0, 1.05))),
		xlab = "Contrast", ylab = "Proportion Correct Response",
		panel = function(x, y, ...) {
			panel.xyplot(x, y, ...)
			panel.abline(h = 0.25, lty = 2)
			})

</code></pre>

<hr>
<h2 id='glm.lambda'> mafc Probit Fit to Psychometric Function Profiled on Upper Asymptote </h2><span id='topic+glm.lambda'></span>

<h3>Description</h3>

<p>A wrapper for <code>glm</code> in which the deviance for the model with binomial family and link <code>probit.lambda</code> is profiled as a function of <code>lambda</code>, the upper asymptote of the psychometric function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.lambda(formula, data, NumAlt = 2, lambda = seq(0, 0.1, len = 40), 
	plot.it = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.lambda_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit </p>
</td></tr>
<tr><td><code id="glm.lambda_+3A_data">data</code></td>
<td>
<p> an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>glm</code> is called. </p>
</td></tr>
<tr><td><code id="glm.lambda_+3A_numalt">NumAlt</code></td>
<td>
<p> the number of alternatives, <code>m</code> in the mafc experiment from which the data arise </p>
</td></tr>
<tr><td><code id="glm.lambda_+3A_lambda">lambda</code></td>
<td>
<p> a sequence of values to profile for the upper asymptote of the psychometric function </p>
</td></tr>
<tr><td><code id="glm.lambda_+3A_plot.it">plot.it</code></td>
<td>
<p> logical indicating whether to plot the profile of the deviances as a function of <code>lambda</code></p>
</td></tr>
<tr><td><code id="glm.lambda_+3A_...">...</code></td>
<td>
<p> further arguments passed to <code>glm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The psychometric function fit to the data is described by
</p>
<p style="text-align: center;"><code class="reqn">P(x) = 1/m + (1 -  1/m - \lambda) \Phi(x)</code>
</p>
<p> where <code class="reqn">m</code> is the number of alternatives and the lower asymptote, <code class="reqn">1 - \lambda</code> is the upper asymptote and <code class="reqn">\Phi</code> is the cumulative normal function.
</p>


<h3>Value</h3>

<p>returns an object of class &lsquo;lambda&rsquo; which inherits from classes &lsquo;glm&rsquo; and &lsquo;lm&rsquo;.  It only differs from an object of class &lsquo;glm&rsquo; in including two additional components, <code>lambda</code>, giving the estimated minimum of the profile by fitting a quadratic to the profile and a data frame containing the profiled deviance values for each value of <code>lambda</code> tested.  The degrees of freedom are reduced by 1 to take into account the estimation of <code>lambda</code>.
</p>


<h3>Note</h3>

<p> If the minimum occurs outside the interval examined, an error might occur.  In any case, re-running the function with a new range of <code>lambda</code> that includes the minimum should work.  if the plotted profile indicates that the fitted quadratic does not describe well the profile at the minimum, refitting with a more restricted range of <code>lambda</code> is recommended.
</p>


<h3>Author(s)</h3>

<p> Ken Knoblauch</p>


<h3>References</h3>

<p> Wichmann, F. A. and Hill, N. J. (2001) The psychometric function: I.Fitting, sampling, and goodness of fit. Percept Psychophys., 63(8), 1293&ndash;1313.
</p>
<p>Yssaad-Fesselier, R. and Knoblauch, K. (2006) Modeling psychometric
functions in R. <em> Behav Res Methods.</em>,  <b>38(1)</b>, 28&ndash;41. (for examples
with <code>gnlr</code>).	
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mafc">mafc</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+probit.lambda">probit.lambda</a></code>, <code><a href="stats.html#topic+family">family</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- 3.5
g &lt;- 1/3
d &lt;- 0.025
a &lt;- 0.04
p &lt;- c(a, b, g, d)
num.tr &lt;- 160
cnt &lt;- 10^seq(-2, -1, length = 6) # contrast levels

#simulated Weibull-Quick observer responses
set.seed(12161952)
truep &lt;- g + (1 - g - d) * pweibull(cnt, b, a)
ny &lt;- rbinom(length(cnt), num.tr, truep)
nn &lt;- num.tr - ny
phat &lt;- ny/(ny + nn)
resp.mat &lt;- matrix(c(ny, nn), ncol = 2)

## First with upper asymptote at 1
dd.glm &lt;- glm(resp.mat ~ cnt, family = binomial(mafc.probit(3)))
summary(dd.glm)
dd.lam &lt;- glm.lambda(resp.mat ~ cnt, NumAlt = 3, lambda = seq(0, 0.03, 
	len = 100), plot.it = TRUE)
summary(dd.lam)
## can refine interval, but doesn't change result much
dd.lam2 &lt;- glm.lambda(resp.mat ~ cnt, NumAlt = 3, 
	lambda = seq(dd.lam$lambda/sqrt(2), dd.lam$lambda*sqrt(2), 
	len = 100), plot.it = TRUE)
summary(dd.lam2)
## Compare fits w/ and w/out lambda
anova(dd.glm, dd.lam2, test = "Chisq")

plot(cnt, phat, log = "x", cex = 1.5, ylim = c(0, 1))
pcnt &lt;- seq(0.01, 0.1, len = 100)
lines(pcnt, predict(dd.glm, data.frame(cnt = pcnt),
                    type = "response"), lwd = 2)
lines(pcnt, predict(dd.lam, data.frame(cnt = pcnt),
                    type = "response"), lwd = 2, lty = 2)

</code></pre>

<hr>
<h2 id='glm.WH'> mafc Probit Fit to Psychometric Function with Upper Asymptote Less than One</h2><span id='topic+glm.WH'></span>

<h3>Description</h3>

<p>A probit fit of a psychometric function with upper asymptote less than 1 is obtained by cycling between a fit with <code>glm</code> using the <code>probit.lambda</code> link and <code>optimize</code> to estimate <code>lambda</code>, 1 - the upper asymptotic value, until the log Likelihood changes by less than a  pre-set tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.WH(formula, data, NumAlt = 2, lambda.init = 0.01, 
	interval = c(0, 0.05), trace = FALSE, tol = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.WH_+3A_formula">formula</code></td>
<td>
<p> a symbolic description of the model to be fit. </p>
</td></tr>
<tr><td><code id="glm.WH_+3A_data">data</code></td>
<td>
<p> an optional data frame, list or enviroment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> containing the variables in the model.  If not found in data, the variables are taken from the <code>environment(formula)</code>, typically the environment from <code>glm.WH</code> was called.</p>
</td></tr>
<tr><td><code id="glm.WH_+3A_numalt">NumAlt</code></td>
<td>
<p> integer indicating the number of alternatives (&gt; 1) in the mafc-task.  (Default: 2). </p>
</td></tr>
<tr><td><code id="glm.WH_+3A_lambda.init">lambda.init</code></td>
<td>
<p> numeric, initial estimate of 1 - upper asymptote. </p>
</td></tr>
<tr><td><code id="glm.WH_+3A_interval">interval</code></td>
<td>
<p> numeric vector giving interval endpoints within which to search for <code>lambda</code>. </p>
</td></tr>
<tr><td><code id="glm.WH_+3A_trace">trace</code></td>
<td>
<p> logical, indicating whether or not to print out a trace of the iterative process. </p>
</td></tr>
<tr><td><code id="glm.WH_+3A_tol">tol</code></td>
<td>
<p> numeric, tolerance for ending iterations.</p>
</td></tr>
<tr><td><code id="glm.WH_+3A_...">...</code></td>
<td>
<p> futher arguments passed to <code>glm</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The psychometric function fit to the data is described by
</p>
<p style="text-align: center;"><code class="reqn">P(x) = 1/m + (1 -  1/m - \lambda) \Phi(x)</code>
</p>
<p> where <code class="reqn">m</code> is the number of alternatives and the lower asymptote, <code class="reqn">1 - \lambda</code> is the upper asymptote and <code class="reqn">\Phi</code> is the cumulative normal function.</p>


<h3>Value</h3>

<p>returns an object of class &lsquo;lambda&rsquo; which inherits from classes &lsquo;glm&rsquo; and &lsquo;lm&rsquo;.  It only differs from an object of class &lsquo;glm&rsquo; in including an additional components, <code>lambda</code>, giving the estimated minimum of <code>lambda</code>.  The degrees of freedom are reduced by 1 to take into account the estimation of <code>lambda</code>.</p>


<h3>Author(s)</h3>

<p> Ken Knoblauch </p>


<h3>References</h3>

<p>Wichmann, F. A. and Hill, N. J. (2001) The psychometric function: I.Fitting, sampling, and goodness of fit. Percept Psychophys., 63(8), 1293&ndash;1313.
</p>
<p>Yssaad-Fesselier, R. and Knoblauch, K. (2006) Modeling psychometric
functions in R. <em> Behav Res Methods.</em>,  <b>38(1)</b>, 28&ndash;41. (for examples
with <code>gnlr</code>).	
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mafc">mafc</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>,<code><a href="#topic+glm.lambda">glm.lambda</a></code>, <code><a href="#topic+probit.lambda">probit.lambda</a></code>, <code><a href="stats.html#topic+family">family</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- 3.5
g &lt;- 1/4
d &lt;- 0.04
a &lt;- 0.04
p &lt;- c(a, b, g, d)
num.tr &lt;- 160
cnt &lt;- 10^seq(-2, -1, length = 6) # contrast levels

#simulated Weibull-Quick observer responses
truep &lt;- g + (1 - g - d) * pweibull(cnt, b, a)
ny &lt;- rbinom(length(cnt), num.tr, truep)
nn &lt;- num.tr - ny
phat &lt;- ny/(ny + nn)
resp.mat &lt;- matrix(c(ny, nn), ncol = 2)

tst.glm &lt;- glm(resp.mat ~ cnt, binomial(mafc.probit(1/g)))
pcnt &lt;- seq(0.005, 1, len = 1000)
plot(cnt, phat, log = "x", ylim = c(0, 1), xlim = c(0.005, 1),
	cex = 1.75)
lines(pcnt, predict(tst.glm, data.frame(cnt = pcnt), type = "response"), lwd = 2)
tst.lam &lt;- glm.WH(resp.mat ~ cnt, NumAlt = 1/g, trace = TRUE)
lines(pcnt, predict(tst.lam, data.frame(cnt = pcnt), 
	type = "response"), lty = 2, lwd = 2)

</code></pre>

<hr>
<h2 id='logit.2asym'> Links for Binomial Family with Variable Upper/Lower Asymptotes</h2><span id='topic+logit.2asym'></span><span id='topic+probit.2asym'></span><span id='topic+cauchit.2asym'></span><span id='topic+cloglog.2asym'></span><span id='topic+weib.2asym'></span>

<h3>Description</h3>

<p>These functions provide links for the binamial family so that psychometric functions can be fit with <em>both</em> the upper and lower asymptotes different from 1 and 0, respectively.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit.2asym(g, lam)
probit.2asym(g, lam)
cauchit.2asym(g, lam)
cloglog.2asym(g, lam)
weib.2asym( ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit.2asym_+3A_g">g</code></td>
<td>
<p> numeric in the range (0, 1), normally &lt;= 0.5, however, which specifies the lower asymptote of the psychometric function. </p>
</td></tr>
<tr><td><code id="logit.2asym_+3A_lam">lam</code></td>
<td>
<p> numeric in the range (0, 1), specifying 1 - the upper asymptote of the psychometric function. </p>
</td></tr>
<tr><td><code id="logit.2asym_+3A_...">...</code></td>
<td>
<p> used just to pass along the formals of <code>cloglog.2asym</code> as arguments to <code>weib.2asym</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These links are used to specify psychometric functions with the form
</p>
<p style="text-align: center;"><code class="reqn"> P(x) = \gamma + (1 - \gamma - \lambda) p(x)
  	</code>
</p>

<p>where <code class="reqn">\gamma</code> is the lower asymptote and <code class="reqn">lambda</code> is <code class="reqn">1 - </code> the upper asymptote,  and <code class="reqn">p(x)</code> is the base psychometric function, varying between 0 and 1.
</p>


<h3>Value</h3>

<p>Each
link returns a list containing functions required for relating the
response to the linear predictor in generalized linear models and the
name of the link.
</p>
<table role = "presentation">
<tr><td><code>linkfun</code></td>
<td>
<p>The link function</p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>The inverse link function</p>
</td></tr>
<tr><td><code>mu.eta</code></td>
<td>
<p>The derivative of the inverse link </p>
</td></tr>
<tr><td><code>valideta</code></td>
<td>
<p>The domain over which the linear predictor is valid</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>A name to be used for the link </p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Kenneth Knoblauch</p>


<h3>References</h3>

 
<p>Klein S. A. (2001) Measuring, estimating, and understanding the
psychometric function: a commentary. <em>Percept Psychophys.</em>, <b>63(8)</b>, 1421&ndash;1455.
</p>
<p>Wichmann, F. A. and Hill, N. J. (2001) The psychometric function: I.Fitting, sampling, and goodness of fit. <em>Percept Psychophys.</em>, <b>63(8)</b>, 1293&ndash;1313. </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> <code><a href="stats.html#topic+make.link">make.link</a></code>, <code><a href="#topic+psyfun.2asym">psyfun.2asym</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#A toy example,
b &lt;- 3
g &lt;- 0.05 # simulated false alarm rate
d &lt;- 0.03
a &lt;- 0.04
p &lt;- c(a, b, g, d)
num.tr &lt;- 160
cnt &lt;- 10^seq(-2, -1, length = 6) # contrast levels

#simulated Weibull-Quick observer responses
truep &lt;- g + (1 - g - d) * pweibull(cnt, b, a)
ny &lt;- rbinom(length(cnt), num.tr, truep)
nn &lt;- num.tr - ny
phat &lt;- ny/(ny + nn)
resp.mat &lt;- matrix(c(ny, nn), ncol = 2)

ddprob.glm &lt;- psyfun.2asym(resp.mat ~ cnt, link = probit.2asym)
ddlog.glm &lt;- psyfun.2asym(resp.mat ~ cnt, link = logit.2asym)
# Can fit a Weibull function, but use log contrast as variable
ddweib.glm &lt;- psyfun.2asym(resp.mat ~ log(cnt), link = weib.2asym) 
ddcau.glm &lt;- psyfun.2asym(resp.mat ~ cnt, link = cauchit.2asym)

plot(cnt, phat, log = "x", cex = 1.5, ylim = c(0, 1))
pcnt &lt;- seq(0.01, 0.1, len = 100)
lines(pcnt, predict(ddprob.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 5)
lines(pcnt, predict(ddlog.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 2, lty = 2, col = "blue")
lines(pcnt, predict(ddweib.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 3, col = "grey")
lines(pcnt, predict(ddcau.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 3, col = "grey", lty = 2)

</code></pre>

<hr>
<h2 id='mafc'>Links for Binomial Family for m-alternative Forced-choice </h2><span id='topic+mafc'></span><span id='topic+mafc.logit'></span><span id='topic+mafc.probit'></span><span id='topic+mafc.cloglog'></span><span id='topic+mafc.weib'></span><span id='topic+mafc.cauchit'></span>

<h3>Description</h3>

<p> These provide links for the binomial family for fitting
m-alternative forced-choice psychophysical functions.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>mafc.logit( .m = 2 )
mafc.probit( .m = 2 )
mafc.cloglog( .m = 2 )
mafc.weib( ... )
mafc.cauchit( .m = 2 )
</code></pre>


<h3>Arguments</h3>

 <table role = "presentation">
<tr><td><code id="mafc_+3A_.m">.m</code></td>
<td>
<p>is the integer number (&gt;1) of choices (Default to
2AFC).  For m = 1 (Yes/No paradigm), use one of the built-in links
for the binomial family.</p>
</td></tr>  
<tr><td><code id="mafc_+3A_...">...</code></td>
<td>
<p> just to pass along the formals of <code>mafc.cloglog</code>.</p>
</td></tr></table>


<h3>Details</h3>

<p> These
functions provide links for fitting psychometric functions arising from
an m-alternative forced-choice experiment.  The estimated coefficients
of the linear predictor influence both the location and the slope of the
psychometric function(s), but provide no means of estimating the upper
aymptote which is constrained to approach 1.  If the upper asympotote
must be estimated, it would be better to maximize directly the
likelihood, either with a function like <code>optim</code> or <code>gnlr</code> from
package <span class="pkg">gnlm</span> (available at
<a href="https://www.commanster.eu/rcode.html">https://www.commanster.eu/rcode.html</a>). Alternatively,
the function <code><a href="#topic+probit.lambda">probit.lambda</a></code> can be used with a known
upper asymptote, or <code><a href="#topic+glm.lambda">glm.lambda</a></code> or <code><a href="#topic+glm.WH">glm.WH</a></code>
to estimate one, with a probit link.  <code>mafc.weib</code> is just an
alias for <code>mafc.cloglog</code>.</p>


<h3>Value</h3>

<p> Each
link returns a list containing functions required for relating the
response to the linear predictor in generalized linear models and the
name of the link.
</p>
<table role = "presentation">
<tr><td><code>linkfun</code></td>
<td>
<p>The link function</p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>The inverse link function</p>
</td></tr>
<tr><td><code>mu.eta</code></td>
<td>
<p>The derivative of the inverse link </p>
</td></tr>
<tr><td><code>valideta</code></td>
<td>
<p>The domain over which the linear predictor is valid</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>A name to be used for the link </p>
</td></tr> </table>


<h3>Author(s)</h3>

<p>Kenneth Knoblauch</p>


<h3>References</h3>

 
<p>Williams J, Ramaswamy D and Oulhaj A (2006) 10 Hz flicker improves
recognition memory in older people <em>BMC Neurosci.</em> 2006 5;7:21
<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1434755/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1434755/</a>
(for an example developed prior to this one, but for m = 2).
</p>
<p>Klein S. A. (2001) Measuring, estimating, and understanding the
psychometric function: a commentary. <em>Percept Psychophys.</em>, <b>63(8)</b>, 1421&ndash;1455.
</p>
<p>Wichmann, F. A. and Hill, N. J. (2001) The psychometric function: I.Fitting,
sampling, and goodness of fit. <em>Percept Psychophys.</em>,
<b>63(8)</b>, 1293&ndash;1313.
</p>
<p>Yssaad-Fesselier, R. and Knoblauch, K. (2006) Modeling psychometric
functions in R. <em> Behav Res Methods.</em>,  <b>38(1)</b>, 28&ndash;41. (for examples
with <code>gnlr</code>).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+family">family</a></code>, <code><a href="stats.html#topic+make.link">make.link</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+probit.lambda">probit.lambda</a></code>, <code><a href="#topic+glm.lambda">glm.lambda</a></code>,
<code><a href="#topic+glm.WH">glm.WH</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#A toy example,
b &lt;- 3.5
g &lt;- 1/3
d &lt;- 0.0
a &lt;- 0.04
p &lt;- c(a, b, g, d)
num.tr &lt;- 160
cnt &lt;- 10^seq(-2, -1, length = 6) # contrast levels

#simulated observer responses
truep &lt;- g + (1 - g - d) * pweibull(cnt, b, a)
ny &lt;- rbinom(length(cnt), num.tr, truep)
nn &lt;- num.tr - ny
phat &lt;- ny/(ny + nn)
resp.mat &lt;- matrix(c(ny, nn), ncol = 2)

ddprob.glm &lt;- glm(resp.mat ~ cnt, family = binomial(mafc.probit(3)))
ddlog.glm &lt;- glm(resp.mat ~ cnt, family = binomial(mafc.logit(3)))
# Can fit a Weibull function, but use log contrast as variable
ddweib.glm &lt;- glm(resp.mat ~ log(cnt), family = binomial(mafc.cloglog(3))) 
ddcau.glm &lt;- glm(resp.mat ~ log(cnt), family = binomial(mafc.cauchit(3)))

plot(cnt, phat, log = "x", cex = 1.5, ylim = c(0, 1))
pcnt &lt;- seq(0.01, 0.1, len = 100)
lines(pcnt, predict(ddprob.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 2)
lines(pcnt, predict(ddlog.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 2, lty = 2)
lines(pcnt, predict(ddweib.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 3, col = "grey")
lines(pcnt, predict(ddcau.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 3, col = "grey", lty = 2)

# Weibull parameters \alpha and \beta
cc &lt;- coef(ddweib.glm)
alph &lt;- exp(-cc[1]/cc[2])
bet &lt;- cc[2]


#More interesting example with data from Yssaad-Fesselier and Knoblauch
data(ecc2)
ecc2.glm &lt;- glm(cbind(Correct, Incorrect) ~ Contr * Size * task, 
			family = binomial(mafc.probit(4)), data = ecc2)
summary(ecc2.glm)
ecc2$fit &lt;- fitted(ecc2.glm)
library(lattice)
xyplot(Correct/(Correct + Incorrect) ~ Contr | Size * task, data = ecc2,
	subscripts = TRUE, ID = with(ecc2, Size + as.numeric(task)),
	scale = list(x = list(log = TRUE), 
				 y = list(limits = c(0, 1.05))),
	xlab = "Contrast", ylab = "Proportion Correct Response",
	aspect = "xy",
	panel = function(x, y, subscripts, ID, ...) {
		which = unique(ID[subscripts])
		llines(x, ecc2$fit[which ==ID], col = "black", ...)
		panel.xyplot(x, y, pch = 16, ...)
		panel.abline(h = 0.25, lty = 2, ...)
		}
)

</code></pre>

<hr>
<h2 id='probit.lambda'> mafc Probit Link for Binomial Family with Upper Asymptote &lt; 1 </h2><span id='topic+probit.lambda'></span>

<h3>Description</h3>

<p>This function provides a link for the binomial family for fitting m-alternative forced-choice, with a probit link and with the upper asymptote permitted to be less than 1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>probit.lambda(m = 2, lambda = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probit.lambda_+3A_m">m</code></td>
<td>
<p> is the integer number (&gt;1) of choices (Default to 2AFC).  </p>
</td></tr>
<tr><td><code id="probit.lambda_+3A_lambda">lambda</code></td>
<td>
<p> number in [0, 1] indicating 1 minus the upper asymptotic value of the psychometric function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a link for fitting psychometric functions arising from an m-alternative forced-choice experiment using a probit link and allowing that the upper aymptote is less than 1.  The psychometric function fit to the data is described by
</p>
<p style="text-align: center;"><code class="reqn">P(x) = 1/m + (1 -  1/m - \lambda) \Phi(x)</code>
</p>
<p> where <code class="reqn">m</code> is the number of alternatives and the lower asymptote, <code class="reqn">1 - \lambda</code> is the upper asymptote and <code class="reqn">\Phi</code> is the cumulative normal function.
</p>


<h3>Value</h3>

<p>The link returns a list containing functions required for relating the response to the linear predictor in generalized linear models and the name of the link.
</p>
<table role = "presentation">
<tr><td><code>linkfun</code></td>
<td>
<p>The link function</p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>DTHe inverse link function</p>
</td></tr>
<tr><td><code>mu.eta</code></td>
<td>
<p>The derivative of the inverse link function</p>
</td></tr>
<tr><td><code>valideta</code></td>
<td>
<p>The domain over which the linear predictor is valid</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>A name to be used for the link</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Due to the difficulty of the task, subject error or incorrectly recorded data, psychophysical data may reveal less than perfect performance when stimulus differences are readily visible.  When this occurs, letting the upper asymptote be less than 1 often results in a better fit to the data and a less-biased estimate of the steepness of the curve (see example below). 
</p>


<h3>Author(s)</h3>

<p>Ken Knoblauch</p>


<h3>References</h3>

<p>Wichmann, F. A. and Hill, N. J. (2001) The psychometric function: I.Fitting, sampling, and goodness of fit. <em>Percept Psychophys.</em>, 63(8), 1293&ndash;1313.</p>


<h3>See Also</h3>

<p><code><a href="#topic+mafc">mafc</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+glm.lambda">glm.lambda</a></code>, <code><a href="stats.html#topic+family">family</a></code>, <code><a href="stats.html#topic+make.link">make.link</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- 3.5
g &lt;- 1/3
d &lt;- 0.025
a &lt;- 0.04
p &lt;- c(a, b, g, d)
num.tr &lt;- 160
cnt &lt;- 10^seq(-2, -1, length = 6) # contrast levels

#simulated Weibull-Quick observer responses
truep &lt;- g + (1 - g - d) * pweibull(cnt, b, a)
ny &lt;- rbinom(length(cnt), num.tr, truep)
nn &lt;- num.tr - ny
phat &lt;- ny/(ny + nn)
resp.mat &lt;- matrix(c(ny, nn), ncol = 2)

ddprob.glm &lt;- glm(resp.mat ~ cnt, family = binomial(mafc.probit(3)))
ddprob.lam &lt;- glm(resp.mat ~ cnt, family = binomial(probit.lambda(3, 0.025)))
AIC(ddprob.glm, ddprob.lam)

plot(cnt, phat, log = "x", cex = 1.5, ylim = c(0, 1))
pcnt &lt;- seq(0.01, 0.1, len = 100)
lines(pcnt, predict(ddprob.glm, data.frame(cnt = pcnt),
                        type = "response"), lwd = 2)
lines(pcnt, predict(ddprob.lam, data.frame(cnt = pcnt),
                        type = "response"), lwd = 2, lty = 2)
</code></pre>

<hr>
<h2 id='psyfun.2asym'>Fit Psychometric Functions and Upper and Lower Asymptotes</h2><span id='topic+psyfun.2asym'></span>

<h3>Description</h3>

<p>Fits psychometric functions allowing for variation of both upper and lower asymptotes.  Uses a procedure that alternates between fitting linear predictor with <code>glm</code> and estimating the asymptotes with <code>optim</code> until a minimum in -log likelihood is obtained within a tolerance. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psyfun.2asym(formula, data, link = logit.2asym, init.g = 0.01, 
	init.lam = 0.01, trace = FALSE, tol = 1e-06, 
	mxNumAlt = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psyfun.2asym_+3A_formula">formula</code></td>
<td>
<p>a two sided formula specifying the response and the linear predictor </p>
</td></tr>
<tr><td><code id="psyfun.2asym_+3A_data">data</code></td>
<td>
<p> a data frame within which the formula terms are interpreted </p>
</td></tr>
<tr><td><code id="psyfun.2asym_+3A_link">link</code></td>
<td>
<p> a link function for the binomial family that allows specifying both upper and lower asymptotes </p>
</td></tr>
<tr><td><code id="psyfun.2asym_+3A_init.g">init.g</code></td>
<td>
<p> numeric specifying the initial estimate for the lower asymptote </p>
</td></tr>
<tr><td><code id="psyfun.2asym_+3A_init.lam">init.lam</code></td>
<td>
<p> numeric specifying initial estimate for 1 - upper asymptote </p>
</td></tr>
<tr><td><code id="psyfun.2asym_+3A_trace">trace</code></td>
<td>
<p> logical indicating whether to show the trace of the minimization of -log likelihood </p>
</td></tr>
<tr><td><code id="psyfun.2asym_+3A_tol">tol</code></td>
<td>
<p> numeric indicating change in -log likelihood as a criterion for stopping iteration. </p>
</td></tr>
<tr><td><code id="psyfun.2asym_+3A_mxnumalt">mxNumAlt</code></td>
<td>
<p> integer indicating maximum number of alternations between <code>glm</code> and <code>optim</code> steps to perform if minimum not reached.</p>
</td></tr>
<tr><td><code id="psyfun.2asym_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code>glm</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper for <code>glm</code> for fitting psychometric functions with the equation
</p>
<p style="text-align: center;"><code class="reqn"> P(x) = \gamma + (1 - \gamma - \lambda) p(x)
  	</code>
</p>

<p>where <code class="reqn">\gamma</code> is the lower asymptote and <code class="reqn">lambda</code> is <code class="reqn">1 - </code> the upper asymptote,  and <code class="reqn">p(x)</code> is the base psychometric function, varying between 0 and 1.
</p>


<h3>Value</h3>

<p>list of class &lsquo;lambda&rsquo; inheriting from classes &lsquo;glm&rsquo; and &lsquo;lm&rsquo; and containing additional components
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>numeric indicating 1 - upper asymptote</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>numeric indicating lower asymptote</p>
</td></tr>
<tr><td><code>SElambda</code></td>
<td>
<p>numeric indicating standard error estimate for lambda based on the Hessian of the last interation of <code>optim</code>.  The optimization is done on the value transformed by the function <code>plogis</code> and the value is stored in on this scale</p>
</td></tr>
<tr><td><code>SEgam</code></td>
<td>
<p>numeric indicating standard error estimate for gam estimated in the same fashion as <code>SElambda</code></p>
</td></tr>
</table>
<p>If a diagonal element of the Hessian is sufficiently close to 0, <code>NA</code> is returned.
</p>


<h3>Note</h3>

<p>The <code>cloglog.2asym</code> and its alias, <code>weib.2asym</code>, don't converge on
occasion.  This can be observed by using the <code>trace</code> argument.
One strategy is to modify the initial estimates.
</p>


<h3>Author(s)</h3>

<p> Kenneth Knoblauch </p>


<h3>References</h3>

<p> Klein S. A. (2001) Measuring, estimating, and understanding the psychometric function: a commentary. <em>Percept Psychophys.</em>, <b>63(8)</b>, 1421&ndash;1455.
</p>
<p>Wichmann, F. A. and Hill, N. J. (2001) The psychometric function: I.Fitting, sampling, and goodness of fit. <em>Percept Psychophys.</em>, <b>63(8)</b>, 1293&ndash;1313. 
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+glm.lambda">glm.lambda</a></code>, <code><a href="#topic+mafc">mafc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#A toy example,
set.seed(12161952)
b &lt;- 3
g &lt;- 0.05 # simulated false alarm rate
d &lt;- 0.03
a &lt;- 0.04
p &lt;- c(a, b, g, d)
num.tr &lt;- 160
cnt &lt;- 10^seq(-2, -1, length = 6) # contrast levels

#simulated Weibull-Quick observer responses
truep &lt;- g + (1 - g - d) * pweibull(cnt, b, a)
ny &lt;- rbinom(length(cnt), num.tr, truep)
nn &lt;- num.tr - ny
phat &lt;- ny/(ny + nn)
resp.mat &lt;- matrix(c(ny, nn), ncol = 2)

ddprob.glm &lt;- psyfun.2asym(resp.mat ~ cnt, link = probit.2asym)
ddlog.glm &lt;- psyfun.2asym(resp.mat ~ cnt, link = logit.2asym)
# Can fit a Weibull function, but use log contrast as variable
ddweib.glm &lt;- psyfun.2asym(resp.mat ~ log(cnt), link = weib.2asym) 
ddcau.glm &lt;- psyfun.2asym(resp.mat ~ cnt, link = cauchit.2asym)

plot(cnt, phat, log = "x", cex = 1.5, ylim = c(0, 1))
pcnt &lt;- seq(0.01, 0.1, len = 100)
lines(pcnt, predict(ddprob.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 5)
lines(pcnt, predict(ddlog.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 2, lty = 2, col = "blue")
lines(pcnt, predict(ddweib.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 3, col = "grey")
lines(pcnt, predict(ddcau.glm, data.frame(cnt = pcnt),
			type = "response"), lwd = 3, col = "grey", lty = 2)
summary(ddprob.glm)
</code></pre>

<hr>
<h2 id='RGB'> Luminance Calibration Data from Video Projector</h2><span id='topic+RGB'></span>

<h3>Description</h3>

<p>The data were obtained from the measurements of the luminance
of the <code>R</code>, <code>G</code> and <code>B</code> channels individually,
as well as the three together, W, for each of 21 grey levels,
<code>GL</code> from a screen on which a video projector was displaying
an image of a uniform field. Grey level has been normalized to
the interval [0, 1], though originally it is specified as integers
in [0, 255].  The measurements were obtained with a Photo Research
650 spectro-radiometer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RGB)</code></pre>


<h3>Format</h3>

<p>A data frame with 84 observations on the following 3 variables.
</p>

<dl>
<dt><code>Lum</code></dt><dd><p>numeric vector of the measured luminance
in candelas/meter<code class="reqn">^2</code> </p>
</dd>
<dt><code>GL</code></dt><dd><p>The grey level normalized to the interval [0, 1]</p>
</dd>
<dt><code>Gun</code></dt><dd><p>factor with levels <code>R</code> <code>G</code> <code>B</code> <code>W</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(RGB)

</code></pre>

<hr>
<h2 id='SS.RGBcalib'>  Self-Start Functions for Fitting Luminance vs Grey Level Relation on CRT displays</h2><span id='topic+SS.RGBcalib'></span><span id='topic+SS.calib'></span>

<h3>Description</h3>

<p>This <code>selfStart</code> model evaluates the parameters for describing
the luminance vs grey level relation of the R, G and B guns of
a CRT-like display, fitting a single exponent, gamma, for each
of the 3 guns.  It has an initial attribute that will evaluate
initial estimates of the parameters, <code>Blev</code>, <code>Br</code>,
<code>Bg</code>, <code>Bb</code> and <code>gamm</code>.
In the case of fitting data from a single gun or for a combination of guns, as in the sum of the three for calibrating the <em>white</em>, the parameter <code>k</code> is used for the coefficient.
Both functions include gradient and hessian attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS.calib(Blev, k, gamm, GL)
SS.RGBcalib(Blev, Br, Bg, Bb, gamm, Rgun, Ggun, Bgun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS.RGBcalib_+3A_blev">Blev</code></td>
<td>
<p>numeric. The black level is the luminance at the 0 grey level </p>
</td></tr>
<tr><td><code id="SS.RGBcalib_+3A_k">k</code></td>
<td>
<p>numeric, coefficient of one gun for fitting single gun</p>
</td></tr>
<tr><td><code id="SS.RGBcalib_+3A_br">Br</code></td>
<td>
<p>numeric, coefficient of the R gun </p>
</td></tr>
<tr><td><code id="SS.RGBcalib_+3A_bg">Bg</code></td>
<td>
<p>numeric, coefficient of the G gun </p>
</td></tr>
<tr><td><code id="SS.RGBcalib_+3A_bb">Bb</code></td>
<td>
<p>numeric, coefficient of the B gun </p>
</td></tr>
<tr><td><code id="SS.RGBcalib_+3A_gamm">gamm</code></td>
<td>
<p>numeric, the exponent, gamma, applied to the grey level </p>
</td></tr>
<tr><td><code id="SS.RGBcalib_+3A_gl">GL</code></td>
<td>
<p>numeric, is the grey level for the gun tested, covariate in model matrix in one gun case</p>
</td></tr>
<tr><td><code id="SS.RGBcalib_+3A_rgun">Rgun</code></td>
<td>
<p>numeric, is a covariate in the model matrix that indicates the grey
level for the R gun.  See the example below.</p>
</td></tr>
<tr><td><code id="SS.RGBcalib_+3A_ggun">Ggun</code></td>
<td>
<p>numeric, is a covariate in the model matrix that indicates the grey
level for the G gun </p>
</td></tr>
<tr><td><code id="SS.RGBcalib_+3A_bgun">Bgun</code></td>
<td>
<p>numeric, is a covariate in the model matrix that indicates the grey
level for the B gun </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model
</p>
<p style="text-align: center;"><code class="reqn"> Lum(GL) = Blev + \beta_i * GL^\gamma </code>
</p>

<p>where i is in {R, G, B},
usually provides a reasonable description of the change
in luminance of a display gun with grey level, <code>GL</code>.
This <code>selfStart</code>
function estimates <code class="reqn">\gamma</code> and the other parameters using the
<code>nls</code> function.  It is assumed that grey level is normalized
to the interval [0, 1].  This results in lower correlation between
the linear coefficients of the guns, <code class="reqn">\beta_i</code> , than if the
actual bit-level is used, e.g., [0, 255], for an 8-bit graphics
card (see the example).  
Also, with this normalization of the data, the coefficients,
<code class="reqn">\beta_i</code>, provide estimates of the maximum luminance for
each gun. The need for the arguments <code>Rgun</code>, <code>Ggun</code> and
<code>Bgun</code> is really a kludge in order to add gradient and
hessian information to the model.
</p>


<h3>Value</h3>

<p>returns a numeric vector giving the estimated luminance given the parameters passed as arguments and a gradient matrix and a hessian array as attributes.</p>


<h3>Author(s)</h3>

<p>Kenneth Knoblauch </p>


<h3>References</h3>

<p> ~put references to the literature/web site here ~ </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nls">nls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(RGB)

#Fitting a single gun
W.nls &lt;- nls(Lum ~ SS.calib(Blev, k, gamm, GL), data = RGB,
				subset = (Gun == "W"))
summary(W.nls)

#curvature (parameter effect) is greater when GL is 0:255
Wc.nls &lt;- nls(Lum ~ SS.calib(Blev, k, gamm, GL*255), data = RGB,
				subset = (Gun == "W"))
MASS::rms.curv(W.nls)
MASS::rms.curv(Wc.nls)
pairs(profile(Wc.nls), absVal = FALSE)
pairs(profile(W.nls), absVal = FALSE)


#Fitting 3 guns with independent gamma's		
RGB0.nls &lt;- nlme::nlsList(Lum ~ SS.calib(Blev, k, gamm, GL) | Gun,
		data = subset(RGB, Gun != "W"))
summary(RGB0.nls)
plot(nlme::intervals(RGB0.nls))

# Add covariates to data.frame for R, G and B grey levels
gg &lt;- model.matrix(~-1 + Gun/GL, RGB)[ , c(5:7)]
RGB$Rgun &lt;- gg[, 1]
RGB$Ggun &lt;- gg[, 2]
RGB$Bgun &lt;- gg[, 3]
RGB.nls &lt;- nls(Lum ~ SS.RGBcalib(Blev, Br, Bg, Bb, gamm, Rgun, Ggun, Bgun), 
 			              data = RGB, subset = (Gun != "W") )
summary(RGB.nls)
confint(RGB.nls)

</code></pre>

<hr>
<h2 id='summary.lambda'> Summary Method for Objects of Class &lsquo;lambda&rsquo;</h2><span id='topic+summary.lambda'></span><span id='topic+print.summary.lambda'></span>

<h3>Description</h3>

<p>Identical to <code>summary.glm</code> but with one line of additional output: the estimate of lambda from <code>glm.lambda</code>, obtained by profiling the deviance and estimating its minimum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lambda'
summary(object, ...)
## S3 method for class 'summary.lambda'
print(x, digits = max(3, getOption("digits") - 3), 
  symbolic.cor = x$symbolic.cor, 
  signif.stars = getOption("show.signif.stars"), ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lambda_+3A_object">object</code></td>
<td>
<p> Fitted model object of class &ldquo;lambda&rdquo; inheriting from <code>glm</code> and <code>lm</code>.  Typically the output of <code>glm.lambda</code>.</p>
</td></tr>
<tr><td><code id="summary.lambda_+3A_x">x</code></td>
<td>
<p> an object of class &ldquo;summary.lambda&rdquo;, usually a result of a call to <code>summary.lambda</code>.  </p>
</td></tr>
<tr><td><code id="summary.lambda_+3A_digits">digits</code></td>
<td>
<p> the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.lambda_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the correlations in a symbolic form (see <code><a href="stats.html#topic+symnum">symnum</a></code>) rather than as numbers.</p>
</td></tr>
<tr><td><code id="summary.lambda_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical.  If <code>TRUE</code>, &ldquo;significance stars&rdquo; are printed for each coefficient.</p>
</td></tr>
<tr><td><code id="summary.lambda_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides a summary of the class <code>lambda</code> object generated by <code>glm.lambda</code>.
</p>


<h3>Value</h3>

<p>Returns the same structure as <code><a href="stats.html#topic+summary.glm">summary.glm</a></code> with an added component, <code>lambda</code>.  <code class="reqn">1 - \lambda</code> is the estimated upper asymptote of the psychometric function.
</p>


<h3>Author(s)</h3>

<p> Ken Knoblauch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+probit.lambda">probit.lambda</a></code>,  <code><a href="#topic+glm.lambda">glm.lambda</a></code> </p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
