<!DOCTYPE html><html lang="en"><head><title>Help for package bmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bmm-package'><p>Easy and Accesible Bayesian Measurement Models Using 'brms'</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#bmf2bf'><p>Convert <code>bmmformula</code> objects to <code>brmsformula</code> objects</p></a></li>
<li><a href='#bmm'><p>Fit Bayesian Measurement Models</p></a></li>
<li><a href='#bmm_options'><p>View or change global bmm options</p></a></li>
<li><a href='#bmmformula'><p>Create formula for predicting parameters of a <code>bmmodel</code></p></a></li>
<li><a href='#c_parametrizations'><p>Convert between parametrizations of the c parameter of the SDM distribution</p></a></li>
<li><a href='#calc_error_relative_to_nontargets'><p>Calculate response error relative to non-target values</p></a></li>
<li><a href='#check_data'><p>Generic S3 method for checking data based on model type</p></a></li>
<li><a href='#check_formula'><p>Generic S3 method for checking if the formula is valid for the specified model</p></a></li>
<li><a href='#check_model'><p>Generic S3 method for checking if the model is supported and model preprocessing</p></a></li>
<li><a href='#circle_transform'><p>Convert degrees to radians or radians to degrees.</p></a></li>
<li><a href='#configure_model'><p>Generic S3 method for configuring the model to be fit by brms</p></a></li>
<li><a href='#configure_prior'><p>Generic S3 method for configuring the default prior for a bmmodel</p></a></li>
<li><a href='#default_prior.bmmformula'><p>Get Default priors for Measurement Models specified in BMM</p></a></li>
<li><a href='#fit_info'><p>Extract information from a brmsfit object</p></a></li>
<li><a href='#imm'><p>Interference measurement model by Oberauer and Lin (2017).</p></a></li>
<li><a href='#IMMdist'><p>Distribution functions for the Interference Measurement Model (IMM)</p></a></li>
<li><a href='#k2sd'><p>Transform kappa of the von Mises distribution to the circular standard</p>
deviation</a></li>
<li><a href='#mixture2p'><p>Two-parameter mixture model by Zhang and Luck (2008).</p></a></li>
<li><a href='#mixture2p_dist'><p>Distribution functions for the two-parameter mixture model (mixture2p)</p></a></li>
<li><a href='#mixture3p'><p>Three-parameter mixture model by Bays et al (2009).</p></a></li>
<li><a href='#mixture3p_dist'><p>Distribution functions for the three-parameter mixture model (mixture3p)</p></a></li>
<li><a href='#oberauer_lin_2017'><p>Data from Experiment 1 reported by Oberauer &amp; Lin (2017)</p></a></li>
<li><a href='#postprocess_brm'><p>Generic S3 method for postprocessing the fitted brm model</p></a></li>
<li><a href='#print_pretty_models_md'><p>Generate a markdown list of the measurement models available in <code>bmm</code></p></a></li>
<li><a href='#restructure.bmmfit'><p>Restructure Old <code>bmmfit</code> Objects</p></a></li>
<li><a href='#revert_postprocess_brm'><p>Generic S3 method for reverting any postprocessing of the fitted brm model</p></a></li>
<li><a href='#sdm'><p>Signal Discrimination Model (SDM) by Oberauer (2023)</p></a></li>
<li><a href='#SDMdist'><p>Distribution functions for the Signal Discrimination Model (SDM)</p></a></li>
<li><a href='#softmax'><p>Softmax and logsoftmax functions and their inverse functions</p></a></li>
<li><a href='#stancode.bmmformula'><p>Generate Stan code for bmm models</p></a></li>
<li><a href='#standata.bmmformula'><p>Stan data for <code>bmm</code> models</p></a></li>
<li><a href='#summary.bmmfit'><p>Create a summary of a fitted model represented by a <code>bmmfit</code> object</p></a></li>
<li><a href='#supported_models'><p>Measurement models available in <code>bmm</code></p></a></li>
<li><a href='#update.bmmfit'><p>Update a bmm model</p></a></li>
<li><a href='#use_model_template'><p>Create a file with a template for adding a new model (for developers)</p></a></li>
<li><a href='#wrap'><p>Wrap angles that extend beyond (-pi;pi)</p></a></li>
<li><a href='#zhang_luck_2008'><p>Data from Experiment 2 reported by Zhang &amp; Luck (2008)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Easy and Accessible Bayesian Measurement Models Using 'brms'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit computational and measurement models using full Bayesian
    inference. The package provides a simple and accessible interface by
    translating complex domain-specific models into 'brms' syntax, a
    powerful and flexible framework for fitting Bayesian regression models
    using 'Stan'. The package is designed so that users can easily apply
    state-of-the-art models in various research fields, and so that
    researchers can use it as a new model development framework.
    References: Frischkorn and Popov (2023) &lt;<a href="https://doi.org/10.31234%2Fosf.io%2Fumt57">doi:10.31234/osf.io/umt57</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/venpopov/bmm">https://github.com/venpopov/bmm</a>, <a href="https://venpopov.github.io/bmm/">https://venpopov.github.io/bmm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/venpopov/bmm/issues">https://github.com/venpopov/bmm/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brms (&ge; 2.21.0), crayon, dplyr, fs, glue, magrittr,
matrixStats, methods, parallel, stats, tidyr, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, cmdstanr (&ge; 0.7.0), cowplot, fansi, ggplot2,
ggthemes, knitr, mixtur, remotes, rmarkdown, stringr, testthat
(&ge; 3.0.0), tidybayes, usethis, waldo</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-27 14:36:59 UTC; vpopov</td>
</tr>
<tr>
<td>Author:</td>
<td>Vencislav Popov <a href="https://orcid.org/0000-0002-8073-4199"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Gidon T. Frischkorn
    <a href="https://orcid.org/0000-0002-5055-9764"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph],
  Paul-Christian Bürkner [cph] (Creator of 'brms', code portions of which
    are used in 'bmm'.)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vencislav Popov &lt;vencislav.popov@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-27 18:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='bmm-package'>Easy and Accesible Bayesian Measurement Models Using 'brms'</h2><span id='topic+bmm-package'></span>

<h3>Description</h3>

<p>Fit computational and measurement models using full Bayesian inference. The package provides a simple and accessible interface by translating complex domain-specific models into 'brms' syntax, a powerful and flexible framework for fitting Bayesian regression models using 'Stan'. The package is designed so that users can easily apply state-of-the-art models in various research fields, and so that researchers can use it as a new model development framework. References: Frischkorn and Popov (2023) <a href="https://doi.org/10.31234/osf.io/umt57">doi:10.31234/osf.io/umt57</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Vencislav Popov <a href="mailto:vencislav.popov@gmail.com">vencislav.popov@gmail.com</a> (<a href="https://orcid.org/0000-0002-8073-4199">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Gidon T. Frischkorn <a href="mailto:gidon.frischkorn@psychologie.uzh.ch">gidon.frischkorn@psychologie.uzh.ch</a> (<a href="https://orcid.org/0000-0002-5055-9764">ORCID</a>) [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Paul-Christian Bürkner <a href="mailto:paul.buerkner@gmail.com">paul.buerkner@gmail.com</a> (Creator of 'brms', code portions of which are used in 'bmm'.) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/venpopov/bmm">https://github.com/venpopov/bmm</a>
</p>
</li>
<li> <p><a href="https://venpopov.github.io/bmm/">https://venpopov.github.io/bmm/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/venpopov/bmm/issues">https://github.com/venpopov/bmm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code style="white-space: pre;">&#8288;magrittr::[\%&gt;\%][magrittr::pipe]&#8288;</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='bmf2bf'>Convert <code>bmmformula</code> objects to <code>brmsformula</code> objects</h2><span id='topic+bmf2bf'></span>

<h3>Description</h3>

<p>Called by <code><a href="#topic+configure_model">configure_model()</a></code> inside <code><a href="#topic+bmm">bmm()</a></code> to convert the <code>bmmformula</code> into a
<code>brmsformula</code> based on information in the model object. It will call the
appropriate bmf2bf.\* methods based on the classes defined in the model_\* function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmf2bf(model, formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmf2bf_+3A_model">model</code></td>
<td>
<p>The model object defining one of the supported 'bmmodels&ldquo;</p>
</td></tr>
<tr><td><code id="bmf2bf_+3A_formula">formula</code></td>
<td>
<p>The <code>bmmformula</code> that should be converted to a <code>brmsformula</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>brmsformula</code> defining the response variables and the additional parameter
formulas for the specified <code>bmmodel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  model &lt;- mixture2p(resp_error = "error")

  formula &lt;- bmmformula(
    thetat ~ 0 + set_size + (0 + set_size | id),
    kappa ~ 1 + (1 | id)
  )

  brms_formula &lt;- bmf2bf(model, formula)
</code></pre>

<hr>
<h2 id='bmm'>Fit Bayesian Measurement Models</h2><span id='topic+bmm'></span><span id='topic+fit_model'></span>

<h3>Description</h3>

<p>Fit a Bayesian measurement model using <strong>brms</strong> as a
backend interface to Stan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmm(
  formula,
  data,
  model,
  prior = NULL,
  sort_data = getOption("bmm.sort_data", "check"),
  silent = getOption("bmm.silent", 1),
  backend = getOption("brms.backend", NULL),
  file = NULL,
  file_compress = TRUE,
  file_refit = getOption("bmm.file_refit", FALSE),
  ...
)

fit_model(
  formula,
  data,
  model,
  prior = NULL,
  sort_data = getOption("bmm.sort_data", "check"),
  silent = getOption("bmm.silent", 1),
  backend = getOption("brms.backend", NULL),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmm_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>bmmformula</code>. A symbolic description of the
model to be fitted.</p>
</td></tr>
<tr><td><code id="bmm_+3A_data">data</code></td>
<td>
<p>An object of class data.frame, containing data of all variables
used in the model. The names of the variables must match the variable names
passed to the <code>bmmodel</code> object for required argurments.</p>
</td></tr>
<tr><td><code id="bmm_+3A_model">model</code></td>
<td>
<p>A description of the model to be fitted. This is a call to a
<code>bmmodel</code> such as <code>mixture3p()</code> function. Every model function has a
number of required arguments which need to be specified within the function
call. Call <code><a href="#topic+supported_models">supported_models()</a></code> to see the list of supported models and
their required arguments</p>
</td></tr>
<tr><td><code id="bmm_+3A_prior">prior</code></td>
<td>
<p>One or more <code>brmsprior</code> objects created by <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>
or related functions and combined using the c method or the + operator. See
also <code><a href="#topic+default_prior">default_prior()</a></code> for more help. Not necessary for the default model
fitting, but you can provide prior constraints to model parameters</p>
</td></tr>
<tr><td><code id="bmm_+3A_sort_data">sort_data</code></td>
<td>
<p>Logical. If TRUE, the data will be sorted by the predictor
variables for faster sampling. If FALSE, the data will not be sorted, but
sampling will be slower. If &quot;check&quot; (the default), <code><a href="#topic+bmm">bmm()</a></code> will check if
the data is sorted, and ask you via a console prompt if it should be
sorted. You can set the default value for this option using global
<code style="white-space: pre;">&#8288;options(bmm.sort_data = TRUE/FALSE/"check)&#8288;</code>)<code style="white-space: pre;">&#8288;or via&#8288;</code>bmm_options(sort_data)'</p>
</td></tr>
<tr><td><code id="bmm_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between 0 and 2. If 1 (the default), most of the
informational messages of compiler and sampler are suppressed. If 2, even
more messages are suppressed. The actual sampling progress is still
printed. Set refresh = 0 to turn this off as well. If using backend =
&quot;rstan&quot; you can also set open_progress = FALSE to prevent opening
additional progress bars.</p>
</td></tr>
<tr><td><code id="bmm_+3A_backend">backend</code></td>
<td>
<p>Character. The backend to use for fitting the model. Can be
&quot;rstan&quot; or &quot;cmdstanr&quot;. If NULL (the default), &quot;cmdstanr&quot; will be used if
the cmdstanr package is installed, otherwise &quot;rstan&quot; will be used. You can
set the default backend using global <code>options(brms.backend = "rstan"/"cmdstanr")</code></p>
</td></tr>
<tr><td><code id="bmm_+3A_file">file</code></td>
<td>
<p>Either <code>NULL</code> or a character string. If a string, the fitted
model object is saved via <a href="base.html#topic+saveRDS">saveRDS</a> in a file named after the string. The
<code style="white-space: pre;">&#8288;.rds extension is added automatically. If the file already exists, &#8288;</code>bmm<code style="white-space: pre;">&#8288;will load and return the saved model object. Unless you specify the&#8288;</code>file_refit<code style="white-space: pre;">&#8288;argument as well, the existing files won't be overwritten, you have to manually remove the file in order to refit and save the model under an existing file name. The file name is stored in the&#8288;</code>bmmfit' object for
later usage. If the directory of the file does not exist, it will be created.</p>
</td></tr>
<tr><td><code id="bmm_+3A_file_compress">file_compress</code></td>
<td>
<p>Logical or a character string, specifying one of the
compression algorithms supported by <a href="base.html#topic+saveRDS">saveRDS</a> when saving
the fitted model object.</p>
</td></tr>
<tr><td><code id="bmm_+3A_file_refit">file_refit</code></td>
<td>
<p>Logical. Modifies when the fit stored via the <code>file</code> argument is
re-used. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"bmm.file_refit"</code> option (see <a href="base.html#topic+options">options</a>). If <code>TRUE</code> (the default), the
model is re-used if the file exists. If <code>FALSE</code>, the model is re-fitted. Note
that unlike <code>brms</code>, there is no &quot;on_change&quot; option</p>
</td></tr>
<tr><td><code id="bmm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+brm">brms::brm()</a></code> or Stan. See the
description of <code><a href="brms.html#topic+brm">brms::brm()</a></code> for more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class brmsfit which contains the posterior draws along
with many other useful information about the model. Use methods(class =
&quot;brmsfit&quot;) for an overview on available methods.
</p>


<h3>Supported Models</h3>

<p>The following models are supported:
</p>

<ul>
<li><p> imm(resp_error, nt_features, nt_distances, set_size, regex, version)
</p>
</li>
<li><p> mixture2p(resp_error)
</p>
</li>
<li><p> mixture3p(resp_error, nt_features, set_size, regex)
</p>
</li>
<li><p> sdm(resp_error, version)
</p>
</li></ul>

<p>Type  ?modelname  to get information about a specific model, e.g.  ?imm
</p>


<h3>bmmformula syntax</h3>

<p>see <a href="https://venpopov.github.io/bmm/articles/bmm_bmmformula.html">this online article</a> for a detailed description of the syntax and how
it differs from the syntax for <strong>brmsformula</strong>
</p>


<h3>Default priors, Stan code and Stan data</h3>

<p>For more information about the default priors in <strong>bmm</strong> and about who to extract the Stan code and data generated by bmm and #'   brms, see <a href="https://venpopov.github.io/bmm/articles/bmm_extract_info.html">the online article</a>.
</p>


<h3>Miscellaneous</h3>

<p>Type <code>help(package=bmm)</code> for a full list of available help topics.
</p>
<p><strong>fit_model()</strong> is a deprecated alias for <strong>bmm()</strong>.
</p>


<h3>References</h3>

<p>Frischkorn, G. T., &amp; Popov, V. (2023). A tutorial for estimating
mixture models for visual working memory tasks in brms: Introducing the
Bayesian Measurement Modeling  (bmm) package for R.
https://doi.org/10.31234/osf.io/umt57
</p>


<h3>See Also</h3>

<p><code><a href="#topic+supported_models">supported_models()</a></code>, <code><a href="brms.html#topic+brm">brms::brm()</a></code>, <a href="#topic+default_prior.bmmformula">default_prior()</a>, <code><a href="#topic+bmmformula">bmmformula()</a></code>, <a href="#topic+stancode.bmmformula">stancode()</a>, <a href="#topic+standata.bmmformula">standata()</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate artificial data from the Signal Discrimination Model
dat &lt;- data.frame(y = rsdm(2000))

# define formula
ff &lt;- bmmformula(c ~ 1, kappa ~ 1)

# fit the model
fit &lt;- bmm(formula = ff,
           data = dat,
           model = sdm(resp_error = "y"),
           cores = 4,
           backend = 'cmdstanr')

</code></pre>

<hr>
<h2 id='bmm_options'>View or change global bmm options</h2><span id='topic+bmm_options'></span>

<h3>Description</h3>

<p>View or change global bmm options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmm_options(
  sort_data,
  parallel,
  default_priors,
  silent,
  color_summary,
  file_refit,
  reset_options = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmm_options_+3A_sort_data">sort_data</code></td>
<td>
<p>logical. If TRUE, the data will be sorted by the predictors.
If FALSE, the data will not be sorted, but sampling will be slower. If
&quot;check&quot; (the default), <code>bmm()</code> will check if the data is sorted, and
ask you via a console prompt if it should be sorted. <strong>Default: &quot;check&quot;</strong></p>
</td></tr>
<tr><td><code id="bmm_options_+3A_parallel">parallel</code></td>
<td>
<p>logical. If TRUE, chains will be run in parallel. If FALSE,
chains will be run sequentially. You can also set these value for each
model separately via the argument <code>parallel</code> in <code>bmm()</code>. <strong>Default:
FALSE</strong></p>
</td></tr>
<tr><td><code id="bmm_options_+3A_default_priors">default_priors</code></td>
<td>
<p>logical. If TRUE (default), the default bmm priors will
be used. If FALSE, only the basic <code>brms</code> priors will be used. <strong>Default:
TRUE</strong></p>
</td></tr>
<tr><td><code id="bmm_options_+3A_silent">silent</code></td>
<td>
<p>numeric. Verbosity level between 0 and 2. If 1 ( the default),
most of the informational messages of compiler and sampler are suppressed.
If 2, even more messages are suppressed. The actual sampling progress is
still printed. <strong>Default: 1</strong></p>
</td></tr>
<tr><td><code id="bmm_options_+3A_color_summary">color_summary</code></td>
<td>
<p>logical. If TRUE, the summary of the model will be
printed in color. <strong>Default: TRUE</strong></p>
</td></tr>
<tr><td><code id="bmm_options_+3A_file_refit">file_refit</code></td>
<td>
<p>logical. If TRUE, bmm() will refit the model even if the
file argument is specified. <strong>Default: FALSE</strong></p>
</td></tr>
<tr><td><code id="bmm_options_+3A_reset_options">reset_options</code></td>
<td>
<p>logical. If TRUE, the options will be reset to their
default values <strong>Default: FALSE</strong></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>bmm_options</code> function is used to view or change the current bmm
options. If no arguments are provided, the function will return the current
options. If arguments are provided, the function will change the options
and return the old options invisibly. If you provide only some of the
arguments, the other options will not be changed. The options are stored in
the global options list and will be used by <code>bmm()</code> and other
functions in the <code>bmm</code> package. Each of these options can also be set
manually using the built-in <code>options()</code> function, by setting the
<code>bmm.sort_data</code>,  <code>bmm.default_priors</code>, and <code>bmm.silent</code> options.
</p>


<h3>Value</h3>

<p>A message with the current bmm options and their values, and
invisibly returns the old options for use with on.exit() and friends.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# view the current options
bmm_options()

# change the options to always sort the data and to use parallel sampling
bmm_options(sort_data = TRUE, parallel = TRUE)

# restore the default options
bmm_options(reset_options = TRUE)

# you can change the options using the options() function as well
options(bmm.sort_data = TRUE, bmm.parallel = TRUE)
bmm_options()

# reset the options to their default values
bmm_options(reset_options = TRUE)

# bmm_options(sort_data = TRUE, parallel = TRUE) will also return the old options
# so you can use it with on.exit()
old_op &lt;- bmm_options(sort_data = TRUE, parallel = TRUE)
on.exit(bmm_options(old_op))

bmm_options(reset_options = TRUE)
</code></pre>

<hr>
<h2 id='bmmformula'>Create formula for predicting parameters of a <code>bmmodel</code></h2><span id='topic+bmmformula'></span><span id='topic+bmf'></span>

<h3>Description</h3>

<p>This function is used to specify the formulas predicting the
different parameters of a <code>bmmodel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmmformula(...)

bmf(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmmformula_+3A_...">...</code></td>
<td>
<p>Formulas for predicting a <code>bmmodel</code> parameter. Each formula for a
parameter should be specified as a separate argument, separated by commas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of formulas for each parameters being predicted
</p>


<h3>General formula structure</h3>

<p>The formula argument accepts formulas of the following syntax:
</p>
<div class="sourceCode r"><pre>parameter ~ fixed_effects + (random_effects | grouping_variable)
</pre></div>
<p><code>bmm</code> formulas are built on <code>brms</code> formulas and function in nearly the same
way, so you can use most of the <code>brms</code> formula syntax. The main differences
is that in <code>bmm</code> formulas, the response variable is not specified in the
formula. Instead, each parameter of the model is explicitly specified as the
left-hand side of the formula. In <code>brms</code>, the response variable is always
specified as the left-hand side of the first formula, which implicitly means
that any predictors in the first formula are predictors of the <code>mu</code> parameter
of the model. In general, measurement models do not all have a <code>mu</code>
parameter, therefore it is more straigthforward to explicitely predict each
parameter of the model.
</p>
<p>For example, in the following <code>brms</code> formula for the drift diffusion model,
the first line corresponds to the drift rate parameter, but this is not
explicitely stated.
</p>
<div class="sourceCode"><pre>      brmsformula(rt | dec(response) ~ condition + (condition | id),
                  bs ~ 1 + (1 | id),
                  ndt ~ 1 + (1 | id),
                  bias ~ 1 + (1 | id))
</pre></div>
<p>In <code>bmm</code>, the same formula would be written as:
</p>
<div class="sourceCode"><pre>      bmmformula(drift ~ condition + (condition | id),
                 bs ~ 1 + (1 | id),
                 ndt ~ 1 + (1 | id),
                 bias ~ 1 + (1 | id))
</pre></div>
<p>and the rt and response variables would be specified in the model argument of
the <code>bmm()</code> function.
</p>
<p>Aside from that, the <code>bmm</code> formula syntax is the same as the <code>brms</code> formula
syntax. For more information on the <code>brms</code> formula syntax, see
<code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code>.
</p>
<p>You can also use the <code>bmf()</code> function as a shorthand for <code>bmmformula()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imm_formula &lt;- bmmformula(
  c ~ 0 + set_size + (0 + set_size | id),
  a ~ 1,
  kappa ~ 0 + set_size + (0 + set_size | id)
)

# or use the shorter alias 'bmf'
imm_formula2 &lt;- bmf(
  c ~ 0 + set_size + (0 + set_size | id),
  a ~ 1,
  kappa ~ 0 + set_size + (0 + set_size | id)
)
identical(imm_formula, imm_formula2)
</code></pre>

<hr>
<h2 id='c_parametrizations'>Convert between parametrizations of the c parameter of the SDM distribution</h2><span id='topic+c_parametrizations'></span><span id='topic+c_sqrtexp2bessel'></span><span id='topic+c_bessel2sqrtexp'></span>

<h3>Description</h3>

<p>Convert between parametrizations of the c parameter of the SDM distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_sqrtexp2bessel(c, kappa)

c_bessel2sqrtexp(c, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_parametrizations_+3A_c">c</code></td>
<td>
<p>Vector of memory strength values</p>
</td></tr>
<tr><td><code id="c_parametrizations_+3A_kappa">kappa</code></td>
<td>
<p>Vector of precision values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>c_bessel2sqrtexp</code> converts the memory strength parameter (c)
from the bessel parametrization to the sqrtexp parametrization,
<code>c_sqrtexp2bessel</code> converts from the sqrtexp parametrization to the
bessel parametrization.
</p>
<p>See <a href="https://venpopov.github.io/bmm/articles/bmm_sdm_simple.html">the online article</a> for details on the
parameterization. The sqrtexp parametrization is the default in the
<code>bmm</code> package.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>c</code> and <code>kappa</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c_bessel &lt;- c_sqrtexp2bessel(c = 4, kappa = 3)
c_sqrtexp &lt;- c_bessel2sqrtexp(c = c_bessel, kappa = 3)

</code></pre>

<hr>
<h2 id='calc_error_relative_to_nontargets'>Calculate response error relative to non-target values</h2><span id='topic+calc_error_relative_to_nontargets'></span>

<h3>Description</h3>

<p>Given a vector of responses, and the values of non-targets, this
function computes the error relative to each of the non-targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_error_relative_to_nontargets(data, response, nt_features)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_error_relative_to_nontargets_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> object where each row is a single observation</p>
</td></tr>
<tr><td><code id="calc_error_relative_to_nontargets_+3A_response">response</code></td>
<td>
<p>Character. The name of the column in <code>data</code> which contains
the response</p>
</td></tr>
<tr><td><code id="calc_error_relative_to_nontargets_+3A_nt_features">nt_features</code></td>
<td>
<p>Character vector. The names of the columns in <code>data</code> which
contain the values of the non-targets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with n*m rows, where n is the number of rows of <code>data</code>
and m is the number of non-target variables. It preserves all other columns
of <code>data</code>, except for the non-target locations, and adds a column <code>y_nt</code>,
which contains the transformed response error relative to the non-targets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- oberauer_lin_2017
data &lt;- calc_error_relative_to_nontargets(data, "dev_rad", paste0("col_nt", 1:7))
hist(data$y_nt, breaks = 100)

</code></pre>

<hr>
<h2 id='check_data'>Generic S3 method for checking data based on model type</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p>Called by <code><a href="#topic+bmm">bmm()</a></code> to automatically perform checks on the
data depending on the model type. It will call the appropriate check_data
methods based on the list of classes defined in the .model_* functions. For
models with several classes listed, it will call the functions in the order
they are listed. Thus, any operations that are common to a group of models
should be defined in the appropriate check_data.* function, where \*
corresponds to the shared class. For example, for the .model_imm_abc model,
this corresponds to the following order of check_data.* functions:
check_data() -&gt; check_data.circular(), check_data.non_targets() the output of the
final function is returned to bmm().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(model, data, formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_data_+3A_model">model</code></td>
<td>
<p>A model list object returned from check_model()</p>
</td></tr>
<tr><td><code id="check_data_+3A_data">data</code></td>
<td>
<p>The user supplied data.frame containing the data to be checked</p>
</td></tr>
<tr><td><code id="check_data_+3A_formula">formula</code></td>
<td>
<p>The user supplied formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the same number of rows as the input data, but with
additional columns added as necessary, any necessary transformations
applied, and attributes added to the data.frame for later use. If you need
to reuse variables created by the check_data.* functions in subsequent
stages (e.g. in configure_model()), you can store and access them using the
attr() function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- oberauer_lin_2017
model &lt;- sdmSimple(resp_error = "dev_rad")
formula &lt;- bmf(c ~ 1, kappa ~ 1)
checked_data &lt;- check_data(model, data, formula)
</code></pre>

<hr>
<h2 id='check_formula'>Generic S3 method for checking if the formula is valid for the specified model</h2><span id='topic+check_formula'></span>

<h3>Description</h3>

<p>Generic S3 method for checking if the formula is valid for the specified model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_formula(model, data, formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_formula_+3A_model">model</code></td>
<td>
<p>a model list object returned from check_model()</p>
</td></tr>
<tr><td><code id="check_formula_+3A_data">data</code></td>
<td>
<p>user supplied data</p>
</td></tr>
<tr><td><code id="check_formula_+3A_formula">formula</code></td>
<td>
<p>user supplied formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the formula object
</p>

<hr>
<h2 id='check_model'>Generic S3 method for checking if the model is supported and model preprocessing</h2><span id='topic+check_model'></span>

<h3>Description</h3>

<p>In addition for validating the model, specific methods might add information
to the model object based on the provided data and formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_model(model, data = NULL, formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_model_+3A_model">model</code></td>
<td>
<p>the model argument supplied by the user</p>
</td></tr>
<tr><td><code id="check_model_+3A_data">data</code></td>
<td>
<p>the data argument supplied by the user</p>
</td></tr>
<tr><td><code id="check_model_+3A_formula">formula</code></td>
<td>
<p>the formula argument supplied by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type 'bmmodel'
</p>

<hr>
<h2 id='circle_transform'>Convert degrees to radians or radians to degrees.</h2><span id='topic+circle_transform'></span><span id='topic+deg2rad'></span><span id='topic+rad2deg'></span>

<h3>Description</h3>

<p>The helper functions <code>deg2rad</code> and <code>rad2deg</code> should add
convenience in transforming data from degrees to radians and from radians to
degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg2rad(deg)

rad2deg(rad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circle_transform_+3A_deg">deg</code></td>
<td>
<p>A numeric vector of values in degrees.</p>
</td></tr>
<tr><td><code id="circle_transform_+3A_rad">rad</code></td>
<td>
<p>A numeric vector of values in radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>deg</code> or <code>rad</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>degrees &lt;- runif(100, min = 0, max = 360)
radians &lt;- deg2rad(degrees)
degrees_again &lt;- rad2deg(radians)
</code></pre>

<hr>
<h2 id='configure_model'>Generic S3 method for configuring the model to be fit by brms</h2><span id='topic+configure_model'></span>

<h3>Description</h3>

<p>Called by bmm() to automatically construct the model
formula, family objects and default priors for the model specified by the
user. It will call the appropriate configure_model.* functions based on the
list of classes defined in the .model_* functions. Currently, we have a
method only for the last class listed in the .model_* functions. This is to
keep model configuration as simple as possible. In the future we may add
shared methods for classes of models that share the same configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configure_model(model, data, formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="configure_model_+3A_model">model</code></td>
<td>
<p>A model list object returned from check_model()</p>
</td></tr>
<tr><td><code id="configure_model_+3A_data">data</code></td>
<td>
<p>The user supplied data.frame containing the data to be checked</p>
</td></tr>
<tr><td><code id="configure_model_+3A_formula">formula</code></td>
<td>
<p>The user supplied formula</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bare bones configure_model.* method should look like this:
</p>
<div class="sourceCode r"><pre>configure_model.newmodel &lt;- function(model, data, formula) {

   # preprocessing - e.g. extract arguments from data check, construct new variables
   &lt;preprocessing code&gt;

   # construct the formula
   formula &lt;- bmf2bf(formula, model)

   # construct the family
   family &lt;- &lt;code for new family&gt;

   # construct the default prior
   prior &lt;- &lt;code for new prior&gt;

   # return the list
   nlist(formula, data, family, prior)
}
</pre></div>


<h3>Value</h3>

<p>A named list containing at minimum the following elements:
</p>

<ul>
<li><p> formula: An object of class <code>brmsformula</code>. The constructed model formula
</p>
</li>
<li><p> data: the user supplied data.frame, preprocessed by check_data
</p>
</li>
<li><p> family: the brms family object
</p>
</li>
<li><p> prior: the brms prior object
</p>
</li>
<li><p> stanvars: (optional) An object of class <code>stanvars</code> (for custom families).
See <code><a href="brms.html#topic+custom_family">brms::custom_family()</a></code> for more details.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
configure_model.mixture3p &lt;- function(model, data, formula) {
  # retrieve arguments from the data check
  max_set_size &lt;- attr(data, "max_set_size")
  lure_idx &lt;- attr(data, "lure_idx_vars")
  nt_features &lt;- model$other_vars$nt_features
  set_size_var &lt;- model$other_vars$set_size

  # construct initial brms formula
  formula &lt;- bmf2bf(model, formula) +
    brms::lf(kappa2 ~ 1) +
    brms::lf(mu2 ~ 1) +
    brms::nlf(theta1 ~ thetat) +
    brms::nlf(kappa1 ~ kappa)

  # additional internal terms for the mixture model formula
  kappa_nts &lt;- paste0("kappa", 3:(max_set_size + 1))
  theta_nts &lt;- paste0("theta", 3:(max_set_size + 1))
  mu_nts &lt;- paste0("mu", 3:(max_set_size + 1))

  for (i in 1:(max_set_size - 1)) {
    formula &lt;- formula +
      glue_nlf("{kappa_nts[i]} ~ kappa") +
      glue_nlf(
        "{theta_nts[i]} ~ {lure_idx[i]} * (thetant + log(inv_ss)) + ",
        "(1 - {lure_idx[i]}) * (-100)"
      ) +
      glue_nlf("{mu_nts[i]} ~ {nt_features[i]}")
  }

  # define mixture family
  vm_list &lt;- lapply(1:(max_set_size + 1), function(x) brms::von_mises(link = "identity"))
  vm_list$order &lt;- "none"
  formula$family &lt;- brms::do_call(brms::mixture, vm_list)

  nlist(formula, data)
}

</code></pre>

<hr>
<h2 id='configure_prior'>Generic S3 method for configuring the default prior for a bmmodel</h2><span id='topic+configure_prior'></span>

<h3>Description</h3>

<p>Called by bmm() to automatically construct the priors for a given
model, data and formula, and combine it with the prior given by the user. The
first method executed is configure_prior.bmmodel, which will build the prior
based on information from the model object such as fixed_parameters,
default_priors, etc. Thus it is important to define these values in the model
object. The function will also recognize if the user has specified that some
parameters should be fixed to a constant and put the appropriate constant
priors. Any additional priors that a developer wants to specify, which are
not based on information in the model object, can be defined in the
configure_prior.* method for the model. See configure_prior.imm_full for an
example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configure_prior(model, data, formula, user_prior, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="configure_prior_+3A_model">model</code></td>
<td>
<p>A <code>bmmodel</code> object</p>
</td></tr>
<tr><td><code id="configure_prior_+3A_data">data</code></td>
<td>
<p>A data.frame containing the data used in the model</p>
</td></tr>
<tr><td><code id="configure_prior_+3A_formula">formula</code></td>
<td>
<p>A <code>brmsformula</code> object returned from configure_model()</p>
</td></tr>
<tr><td><code id="configure_prior_+3A_user_prior">user_prior</code></td>
<td>
<p>A <code>brmsprior</code> object given by the user as an argument to
bmm()</p>
</td></tr>
<tr><td><code id="configure_prior_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>brmsprior</code> object containing the default priors for the model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
configure_prior.mixture3p &lt;- function(model, data, formula, user_prior, ...) {
  # if there is set_size 1 in the data, set constant prior over thetant for set_size1
  prior &lt;- brms::empty_prior()
  set_size_var &lt;- model$other_vars$set_size
  prior_cond &lt;- any(data$ss_numeric == 1) &amp;&amp; !is.numeric(data[[set_size_var]])

  thetant_preds &lt;- rhs_vars(formula$pforms$thetant)
  if (prior_cond &amp;&amp; set_size_var %in% thetant_preds) {
    prior &lt;- prior + brms::prior_("constant(-100)",
      class = "b",
      coef = paste0(set_size_var, 1),
      nlpar = "thetant"
    )
  }
  # check if there is a random effect on theetant that include set_size as predictor
  bterms &lt;- brms::brmsterms(formula$pforms$thetant)
  re_terms &lt;- bterms$dpars$mu$re
  if (!is.null(re_terms)) {
    for (i in 1:nrow(re_terms)) {
      group &lt;- re_terms$group[[i]]
      form &lt;- re_terms$form[[i]]
      thetant_preds &lt;- rhs_vars(form)

      if (prior_cond &amp;&amp; set_size_var %in% thetant_preds) {
        prior &lt;- prior + brms::prior_("constant(1e-8)",
          class = "sd",
          coef = paste0(set_size_var, 1),
          group = group,
          nlpar = "thetant"
        )
      }
    }
  }

  prior
}

</code></pre>

<hr>
<h2 id='default_prior.bmmformula'>Get Default priors for Measurement Models specified in BMM</h2><span id='topic+default_prior.bmmformula'></span><span id='topic+default_prior'></span>

<h3>Description</h3>

<p>Obtain the default priors for a Bayesian multilevel measurement
model, as well as information for which parameters priors can be specified.
Given the <code>model</code>, the <code>data</code> and the <code>formula</code> for the model, this
function will return the default priors that would be used to estimate the
model. Additionally, it will return all model parameters that have no prior
specified (flat priors). This can help to get an idea about which priors
need to be specified and also know which priors were used if no
user-specified priors were passed to the <code><a href="#topic+bmm">bmm()</a></code> function.
</p>
<p>The default priors in <code>bmm</code> tend to be more informative than the default
priors in <code>brms</code>, as we use domain knowledge to specify the priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmmformula'
default_prior(object, data, model, formula = object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_prior.bmmformula_+3A_object">object</code></td>
<td>
<p>A <code>bmmformula</code> object</p>
</td></tr>
<tr><td><code id="default_prior.bmmformula_+3A_data">data</code></td>
<td>
<p>An object of class data.frame, containing data of all variables
used in the model. The names of the variables must match the variable names
passed to the <code>bmmodel</code> object for required argurments.</p>
</td></tr>
<tr><td><code id="default_prior.bmmformula_+3A_model">model</code></td>
<td>
<p>A description of the model to be fitted. This is a call to a
<code>bmmodel</code> such as <code>mixture3p()</code> function. Every model function has a
number of required arguments which need to be specified within the function
call. Call <code><a href="#topic+supported_models">supported_models()</a></code> to see the list of supported models and
their required arguments</p>
</td></tr>
<tr><td><code id="default_prior.bmmformula_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>bmmformula</code>. A symbolic description of the
model to be fitted.</p>
</td></tr>
<tr><td><code id="default_prior.bmmformula_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+default_prior">brms::default_prior()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns specifying the <code>prior</code>, the <code>class</code>, the
<code>coef</code> and <code>group</code> for each of the priors specified. Separate rows contain
the information on the parameters (or parameter classes) for which priors
can be specified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+supported_models">supported_models()</a></code>, <code><a href="brms.html#topic+default_prior">brms::default_prior()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>default_prior(bmf(c ~ 1, kappa ~ 1),
  data = oberauer_lin_2017,
  model = sdm(resp_error = "dev_rad")
)
</code></pre>

<hr>
<h2 id='fit_info'>Extract information from a brmsfit object</h2><span id='topic+fit_info'></span>

<h3>Description</h3>

<p>Extract information from a brmsfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_info(fit, what)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_info_+3A_fit">fit</code></td>
<td>
<p>A brmsfit object, or a list of brmsfit objects</p>
</td></tr>
<tr><td><code id="fit_info_+3A_what">what</code></td>
<td>
<p>String. What to return:
</p>

<ul>
<li><p> &quot;time&quot; for the sampling time per chain
</p>
</li>
<li><p> &quot;time_mean&quot; for the mean sampling time
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on <code>what</code> and the class of <code>fit</code>. For <code>brmsfit</code> objects,
information about the single fit is returned. For <code>brmsfit_list</code> objects, a
list or data.frame with the information for each fit is returned.
</p>

<ul>
<li><p> &quot;time&quot;: A data.frame with the sampling time per chain
</p>
</li>
<li><p> &quot;time_mean&quot;: A named numeric vector with the mean sampling time
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- bmm(
  formula = bmmformula(c ~ 1, kappa ~ 1),
  data = data.frame(y = rsdm(1000)),
  model = sdm(resp_error = "y")
)

fit_info(fit, "time")

</code></pre>

<hr>
<h2 id='imm'>Interference measurement model by Oberauer and Lin (2017).</h2><span id='topic+imm'></span><span id='topic+IMMfull'></span><span id='topic+IMMbsc'></span><span id='topic+IMMabc'></span>

<h3>Description</h3>

<p>Three versions of the Interference measurement model by Oberauer and Lin (2017). - the full, bsc, and abc.
<code>IMMfull()</code>, <code>IMMbsc()</code>, and <code>IMMabc()</code> are deprecated and will be removed in the future.
Please use <code>imm(version = 'full')</code>, <code>imm(version = 'bsc')</code>, or <code>imm(version = 'abc')</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imm(
  resp_error,
  nt_features,
  nt_distances,
  set_size,
  regex = FALSE,
  version = "full",
  ...
)

IMMfull(resp_error, nt_features, nt_distances, set_size, regex = FALSE, ...)

IMMbsc(resp_error, nt_features, nt_distances, set_size, regex = FALSE, ...)

IMMabc(resp_error, nt_features, set_size, regex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imm_+3A_resp_error">resp_error</code></td>
<td>
<p>The name of the variable in the provided dataset containing
the response error. The response Error should code the response relative to
the to-be-recalled target in radians. You can transform the response error
in degrees to radian using the <code>deg2rad</code> function.</p>
</td></tr>
<tr><td><code id="imm_+3A_nt_features">nt_features</code></td>
<td>
<p>A character vector with the names of the non-target
variables. The non_target variables should be in radians and be centered
relative to the target. Alternatively, if regex=TRUE, a regular
expression can be used to match the non-target feature columns in the
dataset.</p>
</td></tr>
<tr><td><code id="imm_+3A_nt_distances">nt_distances</code></td>
<td>
<p>A vector of names of the columns containing the distances
of non-target items to the target item. Alternatively, if regex=TRUE, a regular
expression can be used to match the non-target distances columns in the
dataset. Only necessary for the <code>bsc</code> and <code>full</code> versions.</p>
</td></tr>
<tr><td><code id="imm_+3A_set_size">set_size</code></td>
<td>
<p>Name of the column containing the set size variable (if
set_size varies) or a numeric value for the set_size, if the set_size is
fixed.</p>
</td></tr>
<tr><td><code id="imm_+3A_regex">regex</code></td>
<td>
<p>Logical. If TRUE, the <code>nt_features</code> and <code>nt_distances</code> arguments
are interpreted as a regular expression to match the non-target feature
columns in the dataset.</p>
</td></tr>
<tr><td><code id="imm_+3A_version">version</code></td>
<td>
<p>Character. The version of the IMM model to use. Can be one of
<code>full</code>, <code>bsc</code>, or <code>abc</code>. The default is <code>full</code>.</p>
</td></tr>
<tr><td><code id="imm_+3A_...">...</code></td>
<td>
<p>used internally for testing, ignore it</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><strong>Domain:</strong> Visual working memory
</p>
</li>
<li> <p><strong>Task:</strong> Continuous reproduction
</p>
</li>
<li> <p><strong>Name:</strong> Interference measurement model by Oberauer and Lin (2017).
</p>
</li>
<li> <p><strong>Citation:</strong>
</p>

<ul>
<li><p> Oberauer, K., &amp; Lin, H.Y. (2017). An interference model of visual working memory. Psychological Review, 124(1), 21-59
</p>
</li></ul>

</li></ul>



<h4>Version: <code>full</code></h4>


<ul>
<li> <p><strong>Requirements:</strong>
</p>

<ul>
<li><p> The response vairable should be in radians and represent the angular error relative to the target
</p>
</li></ul>

</li></ul>


<ul>
<li><p> The non-target features should be in radians and be centered relative to the target
</p>
</li></ul>


<ul>
<li> <p><strong>Parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code>: Location parameter of the von Mises distribution for memory responses (in radians). Fixed internally to 0 by default.
</p>
</li>
<li> <p><code>kappa</code>: Concentration parameter of the von Mises distribution
</p>
</li>
<li> <p><code>a</code>: General activation of memory items
</p>
</li>
<li> <p><code>c</code>: Context activation
</p>
</li>
<li> <p><code>s</code>: Spatial similarity gradient
</p>
</li></ul>

</li>
<li> <p><strong>Fixed parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code> = 0
</p>
</li>
<li> <p><code>mu2</code> = 0
</p>
</li>
<li> <p><code>kappa2</code> = -100
</p>
</li></ul>

</li>
<li> <p><strong>Default parameter links:</strong>
</p>

<ul>
<li><p> mu1 = tan_half; kappa = log; a = log; c = log; s = log
</p>
</li></ul>

</li>
<li> <p><strong>Default priors:</strong>
</p>

<ul>
<li> <p><code>mu1</code>:
</p>

<ul>
<li> <p><code>main</code>: student_t(1, 0, 1)
</p>
</li></ul>

</li>
<li> <p><code>kappa</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(2, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>a</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(0, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>c</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(0, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>s</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(0, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li></ul>

</li></ul>




<h4>Version: <code>bsc</code></h4>


<ul>
<li> <p><strong>Requirements:</strong>
</p>

<ul>
<li><p> The response vairable should be in radians and represent the angular error relative to the target
</p>
</li></ul>

</li></ul>


<ul>
<li><p> The non-target features should be in radians and be centered relative to the target
</p>
</li></ul>


<ul>
<li> <p><strong>Parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code>: Location parameter of the von Mises distribution for memory responses (in radians). Fixed internally to 0 by default.
</p>
</li>
<li> <p><code>kappa</code>: Concentration parameter of the von Mises distribution
</p>
</li>
<li> <p><code>c</code>: Context activation
</p>
</li>
<li> <p><code>s</code>: Spatial similarity gradient
</p>
</li></ul>

</li>
<li> <p><strong>Fixed parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code> = 0
</p>
</li>
<li> <p><code>mu2</code> = 0
</p>
</li>
<li> <p><code>kappa2</code> = -100
</p>
</li></ul>

</li>
<li> <p><strong>Default parameter links:</strong>
</p>

<ul>
<li><p> mu1 = tan_half; kappa = log; c = log; s = log
</p>
</li></ul>

</li>
<li> <p><strong>Default priors:</strong>
</p>

<ul>
<li> <p><code>mu1</code>:
</p>

<ul>
<li> <p><code>main</code>: student_t(1, 0, 1)
</p>
</li></ul>

</li>
<li> <p><code>kappa</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(2, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>c</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(0, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>s</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(0, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li></ul>

</li></ul>




<h4>Version: <code>abc</code></h4>


<ul>
<li> <p><strong>Requirements:</strong>
</p>

<ul>
<li><p> The response vairable should be in radians and represent the angular error relative to the target
</p>
</li></ul>

</li></ul>


<ul>
<li><p> The non-target features should be in radians and be centered relative to the target
</p>
</li></ul>


<ul>
<li> <p><strong>Parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code>: Location parameter of the von Mises distribution for memory responses (in radians). Fixed internally to 0 by default.
</p>
</li>
<li> <p><code>kappa</code>: Concentration parameter of the von Mises distribution
</p>
</li>
<li> <p><code>a</code>: General activation of memory items
</p>
</li>
<li> <p><code>c</code>: Context activation
</p>
</li></ul>

</li>
<li> <p><strong>Fixed parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code> = 0
</p>
</li>
<li> <p><code>mu2</code> = 0
</p>
</li>
<li> <p><code>kappa2</code> = -100
</p>
</li></ul>

</li>
<li> <p><strong>Default parameter links:</strong>
</p>

<ul>
<li><p> mu1 = tan_half; kappa = log; a = log; c = log
</p>
</li></ul>

</li>
<li> <p><strong>Default priors:</strong>
</p>

<ul>
<li> <p><code>mu1</code>:
</p>

<ul>
<li> <p><code>main</code>: student_t(1, 0, 1)
</p>
</li></ul>

</li>
<li> <p><code>kappa</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(2, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>a</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(0, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>c</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(0, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li></ul>

</li></ul>

<p>Additionally, all imm models have an internal parameter that is fixed to 0 to
allow the model to be identifiable. This parameter is not estimated and is not
included in the model formula. The parameter is:
</p>

<ul>
<li><p> b = &quot;Background activation (internally fixed to 0)&quot;
</p>
</li></ul>




<h3>Value</h3>

<p>An object of class <code>bmmodel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
data &lt;- oberauer_lin_2017

# define formula
ff &lt;- bmmformula(
  kappa ~ 0 + set_size,
  c ~ 0 + set_size,
  a ~ 0 + set_size,
  s ~ 0 + set_size
)

# specify the full IMM model with explicit column names for non-target features and distances
# by default this fits the full version of the model
model1 &lt;- imm(resp_error = "dev_rad",
              nt_features = paste0('col_nt', 1:7),
              nt_distances = paste0('dist_nt', 1:7),
              set_size = 'set_size')

# fit the model
fit &lt;- bmm(formula = ff,
           data = data,
           model = model1,
           cores = 4,
           backend = 'cmdstanr')

# alternatively specify the IMM model with a regular expression to match non-target features
# this is equivalent to the previous call, but more concise
model2 &lt;- imm(resp_error = "dev_rad",
              nt_features = 'col_nt',
              nt_distances = 'dist_nt',
              set_size = 'set_size',
              regex = TRUE)

# fit the model
fit &lt;- bmm(formula = ff,
           data = data,
           model = model2,
           cores = 4,
           backend = 'cmdstanr')

# you can also specify the `bsc` or `abc` versions of the model to fit a reduced version
model3 &lt;- imm(resp_error = "dev_rad",
              nt_features = 'col_nt',
              set_size = 'set_size',
              regex = TRUE,
              version = 'abc')
fit &lt;- bmm(formula = ff,
           data = data,
           model = model3,
           cores = 4,
           backend = 'cmdstanr')

</code></pre>

<hr>
<h2 id='IMMdist'>Distribution functions for the Interference Measurement Model (IMM)</h2><span id='topic+IMMdist'></span><span id='topic+dimm'></span><span id='topic+pimm'></span><span id='topic+qimm'></span><span id='topic+rimm'></span>

<h3>Description</h3>

<p>Density, distribution, and random generation functions for the
interference measurement model with the location of <code>mu</code>, strength of cue-
dependent activation <code>c</code>, strength of cue-independent activation <code>a</code>, the
generalization gradient <code>s</code>, and the precision of memory representations
<code>kappa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimm(
  x,
  mu = c(0, 2, -1.5),
  dist = c(0, 0.5, 2),
  c = 5,
  a = 2,
  b = 1,
  s = 2,
  kappa = 5,
  log = FALSE
)

pimm(
  q,
  mu = c(0, 2, -1.5),
  dist = c(0, 0.5, 2),
  c = 1,
  a = 0.2,
  b = 0,
  s = 2,
  kappa = 5
)

qimm(
  p,
  mu = c(0, 2, -1.5),
  dist = c(0, 0.5, 2),
  c = 1,
  a = 0.2,
  b = 0,
  s = 2,
  kappa = 5
)

rimm(
  n,
  mu = c(0, 2, -1.5),
  dist = c(0, 0.5, 2),
  c = 1,
  a = 0.2,
  b = 1,
  s = 2,
  kappa = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IMMdist_+3A_x">x</code></td>
<td>
<p>Vector of observed responses</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_mu">mu</code></td>
<td>
<p>Vector of locations</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_dist">dist</code></td>
<td>
<p>Vector of distances of the item locations to the cued location</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_c">c</code></td>
<td>
<p>Vector of strengths for cue-dependent activation</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_a">a</code></td>
<td>
<p>Vector of strengths for cue-independent activation</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_b">b</code></td>
<td>
<p>Vector of baseline activation</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_s">s</code></td>
<td>
<p>Vector of generalization gradients</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_kappa">kappa</code></td>
<td>
<p>Vector of precision values</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_p">p</code></td>
<td>
<p>Vector of probability</p>
</td></tr>
<tr><td><code id="IMMdist_+3A_n">n</code></td>
<td>
<p>Number of observations to generate data for</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dimm</code> gives the density of the interference measurement model,
<code>pimm</code> gives the cumulative distribution function of the interference
measurement model, <code>qimm</code> gives the quantile function of the interference
measurement model, and <code>rimm</code> gives the random generation function for the
interference measurement model.
</p>


<h3>References</h3>

<p>Oberauer, K., Stoneking, C., Wabersich, D., &amp; Lin, H.-Y. (2017).
Hierarchical Bayesian measurement models for continuous reproduction of
visual features from working memory. Journal of Vision, 17(5), 11.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random samples from the imm and overlay the density
r &lt;- rimm(10000, mu = c(0, 2, -1.5), dist = c(0, 0.5, 2),
          c = 5, a = 2, s = 2, b = 1, kappa = 4)
x &lt;- seq(-pi,pi,length.out=10000)
d &lt;- dimm(x, mu = c(0, 2, -1.5), dist = c(0, 0.5, 2),
          c = 5, a = 2, s = 2, b = 1, kappa = 4)
hist(r, breaks=60, freq=FALSE)
lines(x,d,type="l", col="red")

</code></pre>

<hr>
<h2 id='k2sd'>Transform kappa of the von Mises distribution to the circular standard
deviation</h2><span id='topic+k2sd'></span>

<h3>Description</h3>

<p>This function transforms the precision parameter kappa of the
von Mises distribution to the circular standard deviation. Adapted from
Matlab code by Paul Bays (https://www.paulbays.com/code.php)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k2sd(K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k2sd_+3A_k">K</code></td>
<td>
<p>numeric. A vector of kappa values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of sd values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappas &lt;- runif(1000, 0.01, 100)

# calcualte SD (in radians)
SDs &lt;- k2sd(kappas)

# transform SDs from radians to degrees
SDs_degress &lt;- SDs * 180 / pi

# plot the relationship between kappa and circular SD
plot(kappas,SDs)
plot(kappas,SDs_degress)

</code></pre>

<hr>
<h2 id='mixture2p'>Two-parameter mixture model by Zhang and Luck (2008).</h2><span id='topic+mixture2p'></span>

<h3>Description</h3>

<p>Two-parameter mixture model by Zhang and Luck (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture2p(resp_error, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixture2p_+3A_resp_error">resp_error</code></td>
<td>
<p>The name of the variable in the provided dataset containing
the response error. The response Error should code the response relative to
the to-be-recalled target in radians. You can transform the response error
in degrees to radian using the <code>deg2rad</code> function.</p>
</td></tr>
<tr><td><code id="mixture2p_+3A_...">...</code></td>
<td>
<p>used internally for testing, ignore it</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><strong>Domain:</strong> Visual working memory
</p>
</li>
<li> <p><strong>Task:</strong> Continuous reproduction
</p>
</li>
<li> <p><strong>Name:</strong> Two-parameter mixture model by Zhang and Luck (2008).
</p>
</li>
<li> <p><strong>Citation:</strong>
</p>

<ul>
<li><p> Zhang, W., &amp; Luck, S. J. (2008). Discrete fixed-resolution representations in visual working memory. Nature, 453(7192), 233-235
</p>
</li></ul>

</li>
<li> <p><strong>Requirements:</strong>
</p>

<ul>
<li><p> The response vairable should be in radians and represent the angular error relative to the target
</p>
</li></ul>

</li>
<li> <p><strong>Parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code>: Location parameter of the von Mises distribution for memory responses (in radians). Fixed internally to 0 by default.
</p>
</li>
<li> <p><code>kappa</code>: Concentration parameter of the von Mises distribution
</p>
</li>
<li> <p><code>thetat</code>: Mixture weight for target responses
</p>
</li></ul>

</li>
<li> <p><strong>Fixed parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code> = 0
</p>
</li>
<li> <p><code>mu2</code> = 0
</p>
</li>
<li> <p><code>kappa2</code> = -100
</p>
</li></ul>

</li>
<li> <p><strong>Default parameter links:</strong>
</p>

<ul>
<li><p> mu1 = tan_half; kappa = log; thetat = identity
</p>
</li></ul>

</li>
<li> <p><strong>Default priors:</strong>
</p>

<ul>
<li> <p><code>mu1</code>:
</p>

<ul>
<li> <p><code>main</code>: student_t(1, 0, 1)
</p>
</li></ul>

</li>
<li> <p><code>kappa</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(2, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>thetat</code>:
</p>

<ul>
<li> <p><code>main</code>: logistic(0, 1)
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Value</h3>

<p>An object of class <code>bmmodel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate artificial data
dat &lt;- data.frame(y = rmixture2p(n=2000))

# define formula
ff &lt;- bmmformula(kappa ~ 1, thetat ~ 1)

model &lt;- mixture2p(resp_error = "y")

# fit the model
fit &lt;- bmm(formula = ff,
           data = dat,
           model = model,
           cores = 4,
           iter = 500,
           backend = 'cmdstanr')

</code></pre>

<hr>
<h2 id='mixture2p_dist'>Distribution functions for the two-parameter mixture model (mixture2p)</h2><span id='topic+mixture2p_dist'></span><span id='topic+dmixture2p'></span><span id='topic+pmixture2p'></span><span id='topic+qmixture2p'></span><span id='topic+rmixture2p'></span>

<h3>Description</h3>

<p>Density, distribution, and random generation functions for the
two-parameter mixture model with the location of <code>mu</code>, precision of memory
representations <code>kappa</code> and probability of recalling items from memory
<code>p_mem</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixture2p(x, mu = 0, kappa = 5, p_mem = 0.6, log = FALSE)

pmixture2p(q, mu = 0, kappa = 7, p_mem = 0.8)

qmixture2p(p, mu = 0, kappa = 5, p_mem = 0.6)

rmixture2p(n, mu = 0, kappa = 5, p_mem = 0.6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixture2p_dist_+3A_x">x</code></td>
<td>
<p>Vector of observed responses</p>
</td></tr>
<tr><td><code id="mixture2p_dist_+3A_mu">mu</code></td>
<td>
<p>Vector of locations</p>
</td></tr>
<tr><td><code id="mixture2p_dist_+3A_kappa">kappa</code></td>
<td>
<p>Vector of precision values</p>
</td></tr>
<tr><td><code id="mixture2p_dist_+3A_p_mem">p_mem</code></td>
<td>
<p>Vector of probabilities for memory recall</p>
</td></tr>
<tr><td><code id="mixture2p_dist_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="mixture2p_dist_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="mixture2p_dist_+3A_p">p</code></td>
<td>
<p>Vector of probability</p>
</td></tr>
<tr><td><code id="mixture2p_dist_+3A_n">n</code></td>
<td>
<p>Number of observations to generate data for</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dmixture2p</code> gives the density of the two-parameter mixture model,
<code>pmixture2p</code> gives the cumulative distribution function of the
two-parameter mixture model, <code>qmixture2p</code> gives the quantile function of
the two-parameter mixture model, and <code>rmixture2p</code> gives the random
generation function for the two-parameter mixture model.
</p>


<h3>References</h3>

<p>Zhang, W., &amp; Luck, S. J. (2008). Discrete fixed-resolution
representations in visual working memory. Nature, 453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random samples from the mixture2p model and overlay the density
r &lt;- rmixture2p(10000, mu = 0, kappa = 4, p_mem = 0.8)
x &lt;- seq(-pi,pi,length.out=10000)
d &lt;- dmixture2p(x, mu = 0, kappa = 4, p_mem = 0.8)
hist(r, breaks=60, freq=FALSE)
lines(x,d,type="l", col="red")

</code></pre>

<hr>
<h2 id='mixture3p'>Three-parameter mixture model by Bays et al (2009).</h2><span id='topic+mixture3p'></span>

<h3>Description</h3>

<p>Three-parameter mixture model by Bays et al (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture3p(resp_error, nt_features, set_size, regex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixture3p_+3A_resp_error">resp_error</code></td>
<td>
<p>The name of the variable in the dataset containing
the response error. The response error should code the response relative to
the to-be-recalled target in radians. You can transform the response error
in degrees to radians using the <code>deg2rad</code> function.</p>
</td></tr>
<tr><td><code id="mixture3p_+3A_nt_features">nt_features</code></td>
<td>
<p>A character vector with the names of the non-target
feature values. The non_target feature values should be in radians and
centered relative to the target. Alternatively, if regex=TRUE, a regular
expression can be used to match the non-target feature columns in the
dataset.</p>
</td></tr>
<tr><td><code id="mixture3p_+3A_set_size">set_size</code></td>
<td>
<p>Name of the column containing the set size variable (if
set_size varies) or a numeric value for the set_size, if the set_size is
fixed.</p>
</td></tr>
<tr><td><code id="mixture3p_+3A_regex">regex</code></td>
<td>
<p>Logical. If TRUE, the <code>nt_features</code> argument is interpreted as
a regular expression to match the non-target feature columns in the dataset.</p>
</td></tr>
<tr><td><code id="mixture3p_+3A_...">...</code></td>
<td>
<p>used internally for testing, ignore it</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><strong>Domain:</strong> Visual working memory
</p>
</li>
<li> <p><strong>Task:</strong> Continuous reproduction
</p>
</li>
<li> <p><strong>Name:</strong> Three-parameter mixture model by Bays et al (2009).
</p>
</li>
<li> <p><strong>Citation:</strong>
</p>

<ul>
<li><p> Bays, P. M., Catalao, R. F. G., &amp; Husain, M. (2009). The precision of visual working memory is set by allocation of a shared resource. Journal of Vision, 9(10), 1-11
</p>
</li></ul>

</li>
<li> <p><strong>Requirements:</strong>
</p>

<ul>
<li><p> The response vairable should be in radians and represent the angular error relative to the target
</p>
</li></ul>

</li></ul>


<ul>
<li><p> The non-target features should be in radians and be centered relative to the target
</p>
</li></ul>


<ul>
<li> <p><strong>Parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code>: Location parameter of the von Mises distribution for memory responses (in radians). Fixed internally to 0 by default.
</p>
</li>
<li> <p><code>kappa</code>: Concentration parameter of the von Mises distribution
</p>
</li>
<li> <p><code>thetat</code>: Mixture weight for target responses
</p>
</li>
<li> <p><code>thetant</code>: Mixture weight for non-target responses
</p>
</li></ul>

</li>
<li> <p><strong>Fixed parameters:</strong>
</p>

<ul>
<li> <p><code>mu1</code> = 0
</p>
</li>
<li> <p><code>mu2</code> = 0
</p>
</li>
<li> <p><code>kappa2</code> = -100
</p>
</li></ul>

</li>
<li> <p><strong>Default parameter links:</strong>
</p>

<ul>
<li><p> mu1 = tan_half; kappa = log; thetat = identity; thetant = identity
</p>
</li></ul>

</li>
<li> <p><strong>Default priors:</strong>
</p>

<ul>
<li> <p><code>mu1</code>:
</p>

<ul>
<li> <p><code>main</code>: student_t(1, 0, 1)
</p>
</li></ul>

</li>
<li> <p><code>kappa</code>:
</p>

<ul>
<li> <p><code>main</code>: normal(2, 1)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>thetat</code>:
</p>

<ul>
<li> <p><code>main</code>: logistic(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>thetant</code>:
</p>

<ul>
<li> <p><code>main</code>: logistic(0, 1)
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Value</h3>

<p>An object of class <code>bmmodel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate artificial data from the Bays et al (2009) 3-parameter mixture model
dat &lt;- data.frame(
  y = rmixture3p(n=2000, mu = c(0,1,-1.5,2)),
  nt1_loc = 1,
  nt2_loc = -1.5,
  nt3_loc = 2
)

# define formula
ff &lt;- bmmformula(
  kappa ~ 1,
  thetat ~ 1,
  thetant ~ 1
)

# specify the 3-parameter model with explicit column names for non-target features
model1 &lt;- mixture3p(resp_error = "y", nt_features = paste0('nt',1:3,'_loc'), set_size = 4)

# fit the model
fit &lt;- bmm(formula = ff,
           data = dat,
           model = model1,
           cores = 4,
           iter = 500,
           backend = 'cmdstanr')

# alternatively specify the 3-parameter model with a regular expression to match non-target features
# this is equivalent to the previous call, but more concise
model2 &lt;- mixture3p(resp_error = "y", nt_features = "nt.*_loc", set_size = 4, regex = TRUE)

# fit the model
fit &lt;- bmm(formula = ff,
           data = dat,
           model = model2,
           cores = 4,
           iter = 500,
           backend = 'cmdstanr')

</code></pre>

<hr>
<h2 id='mixture3p_dist'>Distribution functions for the three-parameter mixture model (mixture3p)</h2><span id='topic+mixture3p_dist'></span><span id='topic+dmixture3p'></span><span id='topic+pmixture3p'></span><span id='topic+qmixture3p'></span><span id='topic+rmixture3p'></span>

<h3>Description</h3>

<p>Density, distribution, and random generation functions for the
three-parameter mixture model with the location of <code>mu</code>, precision of
memory representations <code>kappa</code>, probability of recalling items from memory
<code>p_mem</code>, and probability of recalling non-targets <code>p_nt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixture3p(
  x,
  mu = c(0, 2, -1.5),
  kappa = 5,
  p_mem = 0.6,
  p_nt = 0.2,
  log = FALSE
)

pmixture3p(q, mu = c(0, 2, -1.5), kappa = 5, p_mem = 0.6, p_nt = 0.2)

qmixture3p(p, mu = c(0, 2, -1.5), kappa = 5, p_mem = 0.6, p_nt = 0.2)

rmixture3p(n, mu = c(0, 2, -1.5), kappa = 5, p_mem = 0.6, p_nt = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixture3p_dist_+3A_x">x</code></td>
<td>
<p>Vector of observed responses</p>
</td></tr>
<tr><td><code id="mixture3p_dist_+3A_mu">mu</code></td>
<td>
<p>Vector of locations. First value represents the location of the
target item and any additional values indicate the location of non-target
items.</p>
</td></tr>
<tr><td><code id="mixture3p_dist_+3A_kappa">kappa</code></td>
<td>
<p>Vector of precision values</p>
</td></tr>
<tr><td><code id="mixture3p_dist_+3A_p_mem">p_mem</code></td>
<td>
<p>Vector of probabilities for memory recall</p>
</td></tr>
<tr><td><code id="mixture3p_dist_+3A_p_nt">p_nt</code></td>
<td>
<p>Vector of probabilities for swap errors</p>
</td></tr>
<tr><td><code id="mixture3p_dist_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="mixture3p_dist_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="mixture3p_dist_+3A_p">p</code></td>
<td>
<p>Vector of probability</p>
</td></tr>
<tr><td><code id="mixture3p_dist_+3A_n">n</code></td>
<td>
<p>Number of observations to generate data for</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dmixture3p</code> gives the density of the three-parameter mixture model,
<code>pmixture3p</code> gives the cumulative distribution function of the
two-parameter mixture model, <code>qmixture3p</code> gives the quantile function of
the two-parameter mixture model, and <code>rmixture3p</code> gives the random
generation function for the two-parameter mixture model.
</p>


<h3>References</h3>

<p>Bays, P. M., Catalao, R. F. G., &amp; Husain, M. (2009). The
precision of visual working memory is set by allocation of a shared
resource. Journal of Vision, 9(10), 7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random samples from the mixture3p model and overlay the density
r &lt;- rmixture3p(10000, mu = c(0, 2, -1.5), kappa = 4, p_mem = 0.6, p_nt = 0.2)
x &lt;- seq(-pi,pi,length.out=10000)
d &lt;- dmixture3p(x, mu = c(0, 2, -1.5), kappa = 4, p_mem = 0.6, p_nt = 0.2)
hist(r, breaks=60, freq=FALSE)
lines(x,d,type="l", col="red")

</code></pre>

<hr>
<h2 id='oberauer_lin_2017'>Data from Experiment 1 reported by Oberauer &amp; Lin (2017)</h2><span id='topic+oberauer_lin_2017'></span>

<h3>Description</h3>

<p>Raw data of 19 subjects that completed a continuous reproduction task
with set size 1 to 8 reported by Oberauer &amp; Lin (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oberauer_lin_2017
</code></pre>


<h3>Format</h3>



<h4><code>oberauer_lin_2017</code></h4>

<p>A data frame with 15,200 rows and 19 columns:
</p>

<dl>
<dt>ID</dt><dd><p>Integer uniquely identifying different subjects</p>
</dd>
<dt>session</dt><dd><p>Session number</p>
</dd>
<dt>trial</dt><dd><p>Trial number within each session</p>
</dd>
<dt>set_size</dt><dd><p>The set_size of the data in this row</p>
</dd>
<dt>dev_rad</dt><dd><p>The response error, that is the difference between the response
given and the target color in radians.</p>
</dd>
<dt>col_nt1, col_nt2, col_nt3, col_nt4, col_nt5, col_nt6, col_nt7</dt><dd><p>The non-target items' color value relative to the target.</p>
</dd>
<dt>dist_nt1, dist_nt2, dist_nt3, dist_nt4, dist_nt5, dist_nt6, dist_nt7, dist_nt8</dt><dd><p>The spatial distance between all non-target items and the target item in radians.</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://osf.io/m4shu">https://osf.io/m4shu</a>
</p>

<hr>
<h2 id='postprocess_brm'>Generic S3 method for postprocessing the fitted brm model</h2><span id='topic+postprocess_brm'></span>

<h3>Description</h3>

<p>Called by bmm() to automatically perform some type of postprocessing
depending on the model type. It will call the appropriate postprocess_brm.*
methods based on the list of classes defined in the .model_* functions. For
models with several classes listed, it will call the functions in the order
they are listed. Thus, any operations that are common to a group of models
should be defined in the appropriate postprocess_brm.* function, where \*
corresponds to the shared class. For example, for the sdm model, the
postprocessing involves setting the link function for the c parameter to &quot;log&quot;,
because it was coded manually in the stan code, but it was specified as &quot;identity&quot;
in the brms custom family. If your model requires no postprocessing, you can
skip this method, and the default method will be used (which returns the same
brmsfit object that was passed to it).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postprocess_brm(model, fit, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="postprocess_brm_+3A_model">model</code></td>
<td>
<p>A model list object returned from check_model()</p>
</td></tr>
<tr><td><code id="postprocess_brm_+3A_fit">fit</code></td>
<td>
<p>the fitted brm model returned by <code>call_brm()</code></p>
</td></tr>
<tr><td><code id="postprocess_brm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class brmsfit, with any necessary postprocessing applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- readRDS("my_saved_fit.rds")
postprocessed_fit &lt;- prostprocess_brm(fit)

</code></pre>

<hr>
<h2 id='print_pretty_models_md'>Generate a markdown list of the measurement models available in <code>bmm</code></h2><span id='topic+print_pretty_models_md'></span>

<h3>Description</h3>

<p>Used internally to automatically populate information in the
README file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_pretty_models_md()
</code></pre>


<h3>Value</h3>

<p>Markdown code for printing the list of measurement models available
in <code>bmm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print_pretty_models_md()

</code></pre>

<hr>
<h2 id='restructure.bmmfit'>Restructure Old <code>bmmfit</code> Objects</h2><span id='topic+restructure.bmmfit'></span><span id='topic+restructure'></span>

<h3>Description</h3>

<p>Restructure old <code>bmmfit</code> objects to work with
the latest <span class="pkg">bmm</span> version. This function is called
internally when applying post-processing methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmmfit'
restructure(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restructure.bmmfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>bmmfit</code>.</p>
</td></tr>
<tr><td><code id="restructure.bmmfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bmmfit</code> object compatible with the latest version
of <span class="pkg">bmm</span> and <span class="pkg">brms</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load an old bmmfit object
old_fit &lt;- readRDS("bmmfit_old.rds")
new_fit &lt;- restructure(old_fit)

</code></pre>

<hr>
<h2 id='revert_postprocess_brm'>Generic S3 method for reverting any postprocessing of the fitted brm model</h2><span id='topic+revert_postprocess_brm'></span>

<h3>Description</h3>

<p>Called by update.bmmfit() to automatically revert some of the postprocessing
depending on the model type. It will call the appropriate revert_postprocess_brm.*
methods based on the list of classes defined in the .model_* functions. For
models with several classes listed, it will call the functions in the order
they are listed. For example, for the sdm model, the
postprocessing involves setting the link function for the c parameter to &quot;log&quot;,
because it was coded manually in the stan code, but it was specified as &quot;identity&quot;
in the brms custom family. However, during the update process, the link function
should be set back to &quot;identity&quot;. Only use this if you have a specific reason to
revert the postprocessing (if otherwise the update method would produce incorrect
results).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revert_postprocess_brm(model, fit, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="revert_postprocess_brm_+3A_model">model</code></td>
<td>
<p>A model list object returned from check_model()</p>
</td></tr>
<tr><td><code id="revert_postprocess_brm_+3A_fit">fit</code></td>
<td>
<p>the fitted brm model returned by <code>call_brm()</code></p>
</td></tr>
<tr><td><code id="revert_postprocess_brm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class brmsfit, with any necessary postprocessing applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- readRDS("my_saved_fit.rds")
postprocessed_fit &lt;- prostprocess_brm(fit)
reverted_fit &lt;- revert_postprocess_brm(postprocessed_fit)

</code></pre>

<hr>
<h2 id='sdm'>Signal Discrimination Model (SDM) by Oberauer (2023)</h2><span id='topic+sdm'></span><span id='topic+sdmSimple'></span>

<h3>Description</h3>

<p>Signal Discrimination Model (SDM) by Oberauer (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdm(resp_error, version = "simple", ...)

sdmSimple(resp_error, version = "simple", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdm_+3A_resp_error">resp_error</code></td>
<td>
<p>The name of the variable in the dataset containing the
response error. The response error should code the response relative to the
to-be-recalled target in radians. You can transform the response error in
degrees to radians using the <code>deg2rad</code> function.</p>
</td></tr>
<tr><td><code id="sdm_+3A_version">version</code></td>
<td>
<p>Character. The version of the model to use. Currently only
&quot;simple&quot; is supported.</p>
</td></tr>
<tr><td><code id="sdm_+3A_...">...</code></td>
<td>
<p>used internally for testing, ignore it</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <a href="https://venpopov.github.io/bmm/articles/bmm_sdm_simple.html">the online article</a> for a detailed description of the model
and how to use it. * <strong>Domain:</strong> Visual working memory
</p>

<ul>
<li> <p><strong>Task:</strong> Continuous reproduction
</p>
</li>
<li> <p><strong>Name:</strong> Signal Discrimination Model (SDM) by Oberauer (2023)
</p>
</li>
<li> <p><strong>Citation:</strong>
</p>

<ul>
<li><p> Oberauer, K. (2023). Measurement models for visual working memory - A factorial model comparison. Psychological Review, 130(3), 841-852
</p>
</li></ul>

</li>
<li> <p><strong>Version:</strong> simple
</p>
</li>
<li> <p><strong>Requirements:</strong>
</p>

<ul>
<li><p> The response variable should be in radians and represent the angular error relative to the target
</p>
</li></ul>

</li>
<li> <p><strong>Parameters:</strong>
</p>

<ul>
<li> <p><code>mu</code>: Location parameter of the SDM distribution (in radians; by default fixed internally to 0)
</p>
</li>
<li> <p><code>c</code>: Memory strength parameter of the SDM distribution
</p>
</li>
<li> <p><code>kappa</code>: Precision parameter of the SDM distribution
</p>
</li></ul>

</li>
<li> <p><strong>Fixed parameters:</strong>
</p>

<ul>
<li> <p><code>mu</code> = 0
</p>
</li></ul>

</li>
<li> <p><strong>Default parameter links:</strong>
</p>

<ul>
<li><p> mu = tan_half; c = log; kappa = log
</p>
</li></ul>

</li>
<li> <p><strong>Default priors:</strong>
</p>

<ul>
<li> <p><code>mu</code>:
</p>

<ul>
<li> <p><code>main</code>: student_t(1, 0, 1)
</p>
</li></ul>

</li>
<li> <p><code>kappa</code>:
</p>

<ul>
<li> <p><code>main</code>: student_t(5, 1.75, 0.75)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li>
<li> <p><code>c</code>:
</p>

<ul>
<li> <p><code>main</code>: student_t(5, 2, 0.75)
</p>
</li>
<li> <p><code>effects</code>: normal(0, 1)
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Value</h3>

<p>An object of class <code>bmmodel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate data from the model
dat &lt;- data.frame(y = rsdm(n = 1000, c = 4, kappa = 3))

# specify formula
ff &lt;- bmf(c ~ 1,
          kappa ~ 1)

# specify the model
fit &lt;- bmm(formula = ff,
           data = dat,
           model = sdm(resp_error = 'y'),
           cores = 4,
           backend = 'cmdstanr')

</code></pre>

<hr>
<h2 id='SDMdist'>Distribution functions for the Signal Discrimination Model (SDM)</h2><span id='topic+SDMdist'></span><span id='topic+dsdm'></span><span id='topic+psdm'></span><span id='topic+qsdm'></span><span id='topic+rsdm'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation for the
Signal Discrimination Model (SDM) Distribution with location <code>mu</code>,
memory strength <code>c</code>, and precision <code>kappa</code>. Currently only a
single activation source is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsdm(x, mu = 0, c = 3, kappa = 3.5, log = FALSE, parametrization = "sqrtexp")

psdm(
  q,
  mu = 0,
  c = 3,
  kappa = 3.5,
  lower.tail = TRUE,
  log.p = FALSE,
  lower.bound = -pi,
  parametrization = "sqrtexp"
)

qsdm(p, mu = 0, c = 3, kappa = 3.5, parametrization = "sqrtexp")

rsdm(n, mu = 0, c = 3, kappa = 3.5, parametrization = "sqrtexp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SDMdist_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_mu">mu</code></td>
<td>
<p>Vector of location values in radians</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_c">c</code></td>
<td>
<p>Vector of memory strength values</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_kappa">kappa</code></td>
<td>
<p>Vector of precision values</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_parametrization">parametrization</code></td>
<td>
<p>Character; either <code>"bessel"</code> or <code>"sqrtexp"</code>
(default). See <a href="https://venpopov.github.io/bmm/articles/bmm_sdm_simple.html">the online article</a> for details on the
parameterization.</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x). Else,
return P(X &gt; x)</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if <code>TRUE</code>, probabilities are returned on the log
scale.</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_lower.bound">lower.bound</code></td>
<td>
<p>Numeric; Lower bound of integration for the cumulative
distribution</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_p">p</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
<tr><td><code id="SDMdist_+3A_n">n</code></td>
<td>
<p>Number of observations to sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Parametrization</strong>
</p>
<p>See <a href="https://venpopov.github.io/bmm/articles/bmm_sdm_simple.html">the online article</a> for details on the parameterization.
Oberauer (2023) introduced the SDM with the bessel parametrization. The
sqrtexp parametrization is the default in the <code>bmm</code> package for
numerical stability and efficiency. The two parametrizations are related by
the functions <code>c_bessel2sqrtexp()</code> and <code>c_sqrtexp2bessel()</code>.
</p>
<p><strong>The cumulative distribution function</strong>
</p>
<p>Since responses are on the circle, the cumulative distribution function
requires you to choose a lower bound of integration. The default is
<code class="reqn">-\pi</code>, as for the brms::pvon_mises() function but you can choose any
value in the argument <code>lower_bound</code> of <code>psdm</code>. Another useful
choice is the mean of the response distribution minus <code class="reqn">\pi</code>, e.g.
<code>lower_bound = mu-pi</code>. This is the default in
<code>circular::pvonmises()</code>, and it ensures that 50% of the cumulative
probability mass is below the mean of the response distribution.
</p>


<h3>Value</h3>

<p><code>dsdm</code> gives the density, <code>psdm</code> gives the distribution
function, <code>qsdm</code> gives the quantile function, <code>rsdm</code> generates
random deviates, and <code>.dsdm_integrate</code> is a helper function for
calculating the density of the SDM distribution.
</p>


<h3>References</h3>

<p>Oberauer, K. (2023). Measurement models for visual working
memory - A factorial model comparison. Psychological Review, 130(3), 841–852
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot the density of the SDM distribution
x &lt;- seq(-pi,pi,length.out=10000)
plot(x,dsdm(x,0,2,3),type="l", xlim=c(-pi,pi),ylim=c(0,1),
     xlab="Angle error (radians)",
     ylab="density",
     main="SDM density")
lines(x,dsdm(x,0,9,1),col="red")
lines(x,dsdm(x,0,2,8),col="green")
legend("topright",c("c=2, kappa=3.0, mu=0",
                    "c=9, kappa=1.0, mu=0",
                    "c=2, kappa=8, mu=1"),
       col=c("black","red","green"),lty=1, cex=0.8)

# plot the cumulative distribution function of the SDM distribution
p &lt;- psdm(x, mu = 0, c = 3.1, kappa = 5)
plot(x,p,type="l")

# generate random deviates from the SDM distribution and overlay the density
r &lt;- rsdm(10000, mu = 0, c = 3.1, kappa = 5)
d &lt;- dsdm(x, mu = 0, c = 3.1, kappa = 5)
hist(r, breaks=60, freq=FALSE)
lines(x,d,type="l", col="red")
</code></pre>

<hr>
<h2 id='softmax'>Softmax and logsoftmax functions and their inverse functions</h2><span id='topic+softmax'></span><span id='topic+softmaxinv'></span>

<h3>Description</h3>

<p><code>softmax</code> returns the value of the softmax function
<code>softmaxinv</code> returns the value of the inverse-softmax function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>softmax(eta, lambda = 1)

softmaxinv(p, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="softmax_+3A_eta">eta</code></td>
<td>
<p>A numeric vector input</p>
</td></tr>
<tr><td><code id="softmax_+3A_lambda">lambda</code></td>
<td>
<p>Tuning parameter (a single positive value)</p>
</td></tr>
<tr><td><code id="softmax_+3A_p">p</code></td>
<td>
<p>A probability vector (i.e., numeric vector of non-negative values that sum to one)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The softmax function is a bijective function that maps a real vector with length <code>m-1</code> to a probability vector
with length <code>m</code> with all non-zero probabilities.  The present functions define the softmax function and its inverse, both with a tuning
parameter.
</p>
<p>The current functions define the softmax as:
</p>
<p style="text-align: center;"><code class="reqn">\Large P(\eta_i) = \frac{e^{\lambda \eta_i}}{1+ \sum_{j=1}^m e^{\lambda \eta_j}}</code>
</p>

<p>Code adapted from the <a href="https://github.com/ben-oneill/utilities/">utilities</a> package
</p>


<h3>Value</h3>

<p>Value of the softmax function or its inverse
</p>


<h3>Examples</h3>

<pre><code class='language-R'>softmax(5:7)
softmaxinv(softmax(5:7))
</code></pre>

<hr>
<h2 id='stancode.bmmformula'>Generate Stan code for bmm models</h2><span id='topic+stancode.bmmformula'></span><span id='topic+stancode'></span>

<h3>Description</h3>

<p>Given the <code>model</code>, the <code>data</code> and the <code>formula</code> for the model,
this function will return the combined stan code generated by <code>bmm</code> and
<code>brms</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmmformula'
stancode(object, data, model, prior = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stancode.bmmformula_+3A_object">object</code></td>
<td>
<p>A <code>bmmformula</code> object</p>
</td></tr>
<tr><td><code id="stancode.bmmformula_+3A_data">data</code></td>
<td>
<p>An object of class data.frame, containing data of all variables
used in the model. The names of the variables must match the variable names
passed to the <code>bmmodel</code> object for required argurments.</p>
</td></tr>
<tr><td><code id="stancode.bmmformula_+3A_model">model</code></td>
<td>
<p>A description of the model to be fitted. This is a call to a
<code>bmmodel</code> such as <code>mixture3p()</code> function. Every model function has a
number of required arguments which need to be specified within the function
call. Call <code><a href="#topic+supported_models">supported_models()</a></code> to see the list of supported models and
their required arguments</p>
</td></tr>
<tr><td><code id="stancode.bmmformula_+3A_prior">prior</code></td>
<td>
<p>One or more <code>brmsprior</code> objects created by <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>
or related functions and combined using the c method or the + operator. See
also <code><a href="#topic+default_prior">default_prior()</a></code> for more help. Not necessary for the default model
fitting, but you can provide prior constraints to model parameters</p>
</td></tr>
<tr><td><code id="stancode.bmmformula_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+stancode">brms::stancode()</a></code>. See the
description of <code><a href="brms.html#topic+stancode">brms::stancode()</a></code> for more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string containing the fully commented Stan code to fit a
bmm model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+supported_models">supported_models()</a></code>, <code><a href="brms.html#topic+stancode">brms::stancode()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scode1 &lt;- stancode(bmf(c ~ 1, kappa ~ 1),
  data = oberauer_lin_2017,
  model = sdm(resp_error = "dev_rad")
)
cat(scode1)
</code></pre>

<hr>
<h2 id='standata.bmmformula'>Stan data for <code>bmm</code> models</h2><span id='topic+standata.bmmformula'></span><span id='topic+standata'></span>

<h3>Description</h3>

<p>Given the <code>model</code>, the <code>data</code> and the <code>formula</code> for the model,
this function will return the combined stan data generated by <code>bmm</code> and
<code>brms</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmmformula'
standata(object, data, model, prior = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standata.bmmformula_+3A_object">object</code></td>
<td>
<p>A <code>bmmformula</code> object</p>
</td></tr>
<tr><td><code id="standata.bmmformula_+3A_data">data</code></td>
<td>
<p>An object of class data.frame, containing data of all variables
used in the model. The names of the variables must match the variable names
passed to the <code>bmmodel</code> object for required argurments.</p>
</td></tr>
<tr><td><code id="standata.bmmformula_+3A_model">model</code></td>
<td>
<p>A description of the model to be fitted. This is a call to a
<code>bmmodel</code> such as <code>mixture3p()</code> function. Every model function has a
number of required arguments which need to be specified within the function
call. Call <code><a href="#topic+supported_models">supported_models()</a></code> to see the list of supported models and
their required arguments</p>
</td></tr>
<tr><td><code id="standata.bmmformula_+3A_prior">prior</code></td>
<td>
<p>One or more <code>brmsprior</code> objects created by <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>
or related functions and combined using the c method or the + operator. See
also <code><a href="#topic+default_prior">default_prior()</a></code> for more help. Not necessary for the default model
fitting, but you can provide prior constraints to model parameters</p>
</td></tr>
<tr><td><code id="standata.bmmformula_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+standata">brms::standata()</a></code>. See the
description of <code><a href="brms.html#topic+standata">brms::standata()</a></code> for more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of objects containing the required data to fit a bmm
model with Stan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+supported_models">supported_models()</a></code>, <code><a href="brms.html#topic+standata">brms::standata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sdata1 &lt;- standata(bmf(c ~ 1, kappa ~ 1),
  data = oberauer_lin_2017,
  model = sdm(resp_error = "dev_rad")
)
str(sdata1)
</code></pre>

<hr>
<h2 id='summary.bmmfit'>Create a summary of a fitted model represented by a <code>bmmfit</code> object</h2><span id='topic+summary.bmmfit'></span>

<h3>Description</h3>

<p>Create a summary of a fitted model represented by a <code>bmmfit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmmfit'
summary(
  object,
  priors = FALSE,
  prob = 0.95,
  robust = FALSE,
  mc_se = FALSE,
  ...,
  backend = "bmm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bmmfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="summary.bmmfit_+3A_priors">priors</code></td>
<td>
<p>Logical; Indicating if priors should be included
in the summary. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.bmmfit_+3A_prob">prob</code></td>
<td>
<p>A value between 0 and 1 indicating the desired probability
to be covered by the uncertainty intervals. The default is 0.95.</p>
</td></tr>
<tr><td><code id="summary.bmmfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.</p>
</td></tr>
<tr><td><code id="summary.bmmfit_+3A_mc_se">mc_se</code></td>
<td>
<p>Logical; Indicating if the uncertainty in <code>Estimate</code>
caused by the MCMC sampling should be shown in the summary. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.bmmfit_+3A_...">...</code></td>
<td>
<p>Other potential arguments</p>
</td></tr>
<tr><td><code id="summary.bmmfit_+3A_backend">backend</code></td>
<td>
<p>Choose whether to display the <em>bmm</em> summary method (default),
or to display the <em>brms</em> summary method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>bmmsummary</code> containing the summary of the model's
parameters, the model formula, the model, and the data used to fit the model.
</p>


<h3>Note</h3>

<p>You can turn off the color output by setting the option
options(bmm.color_summary = FALSE) or bmm_options(color_summary = FALSE)
</p>


<h3>See Also</h3>

<p><code>summary.brmsfit</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate artificial data from the Signal Discrimination Model
dat &lt;- data.frame(y = rsdm(2000))

# define formula
ff &lt;- bmmformula(c ~ 1, kappa ~ 1)

# fit the model
fit &lt;- bmm(
  formula = ff,
  data = dat,
  model = sdm(resp_error = "y"),
  cores = 4,
  backend = "cmdstanr"
)

# summary of the model
summary(fit)

</code></pre>

<hr>
<h2 id='supported_models'>Measurement models available in <code>bmm</code></h2><span id='topic+supported_models'></span>

<h3>Description</h3>

<p>Measurement models available in <code>bmm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supported_models(print_call = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supported_models_+3A_print_call">print_call</code></td>
<td>
<p>Logical; If TRUE (default), the function will print
information about how each model function should be called and its required
arguments. If FALSE, the function will return a character vector with the
names of the available models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of measurement models available in <code>bmm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>supported_models()
</code></pre>

<hr>
<h2 id='update.bmmfit'>Update a bmm model</h2><span id='topic+update.bmmfit'></span>

<h3>Description</h3>

<p>Update an existing bmm mode. This function calls
<code><a href="brms.html#topic+update.brmsfit">brms::update.brmsfit()</a></code>, but it applies the necessary bmm postprocessing
to the model object before and after the update.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmmfit'
update(object, formula., newdata = NULL, recompile = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.bmmfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>bmmfit</code></p>
</td></tr>
<tr><td><code id="update.bmmfit_+3A_formula.">formula.</code></td>
<td>
<p>A <code><a href="#topic+bmmformula">bmmformula()</a></code>. If missing, the original formula
is used. Currently you have to specify a full <code>bmmformula</code></p>
</td></tr>
<tr><td><code id="update.bmmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame containing the variables in the model</p>
</td></tr>
<tr><td><code id="update.bmmfit_+3A_recompile">recompile</code></td>
<td>
<p>Logical, indicating whether the Stan model should be recompiled. If
NULL (the default), update tries to figure out internally, if recompilation
is necessary. Setting it to FALSE will cause all Stan code changing
arguments to be ignored.</p>
</td></tr>
<tr><td><code id="update.bmmfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+update.brmsfit">brms::update.brmsfit()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When updating a brmsfit created with the cmdstanr backend in a
different R session, a recompilation will be triggered because by default,
cmdstanr writes the model executable to a temporary directory. To avoid
that, set option &quot;cmdstanr_write_stan_file_dir&quot; to a nontemporary path of
your choice before creating the original bmmfit.
</p>
<p>For more information and examples, see <code><a href="brms.html#topic+update.brmsfit">brms::update.brmsfit()</a></code>
</p>


<h3>Value</h3>

<p>An updated <code>bmmfit</code> object refit to the new data and/or formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate artificial data from the Signal Discrimination Model
# generate artificial data from the Signal Discrimination Model
dat &lt;- data.frame(y = rsdm(2000))

# define formula
ff &lt;- bmf(c ~ 1, kappa ~ 1)

# fit the model
fit &lt;- bmm(formula = ff,
           data = dat,
           model = sdm(resp_error = "y"),
           cores = 4,
           backend = 'cmdstanr')

# update the model
fit &lt;- update(fit, newdata = data.frame(y = rsdm(2000, kappa = 5)))

</code></pre>

<hr>
<h2 id='use_model_template'>Create a file with a template for adding a new model (for developers)</h2><span id='topic+use_model_template'></span>

<h3>Description</h3>

<p>Create a file with a template for adding a new model (for developers)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_model_template(
  model_name,
  custom_family = FALSE,
  stanvar_blocks = c("data", "tdata", "parameters", "tparameters", "model", "likelihood",
    "genquant", "functions"),
  open_files = TRUE,
  testing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_model_template_+3A_model_name">model_name</code></td>
<td>
<p>A string with the name of the model. The file will be named
<code>model_model_name.R</code> and all necessary functions will be created with
the appropriate names and structure. The file will be saved in the <code style="white-space: pre;">&#8288;R/&#8288;</code>
directory</p>
</td></tr>
<tr><td><code id="use_model_template_+3A_custom_family">custom_family</code></td>
<td>
<p>Logical; Do you plan to define a brms::custom_family()?
If TRUE the function will add a section for the custom family, placeholders
for the stan_vars and corresponding empty .stan files in
<code style="white-space: pre;">&#8288;inst/stan_chunks/&#8288;</code>, that you can fill For an example, see the sdm
model in <code style="white-space: pre;">&#8288;/R/model_sdm.R&#8288;</code>. If FALSE (default) the function will
not add the custom family section nor stan files.</p>
</td></tr>
<tr><td><code id="use_model_template_+3A_stanvar_blocks">stanvar_blocks</code></td>
<td>
<p>A character vector with the names of the blocks that
will be added to the custom family section. See <code><a href="brms.html#topic+stanvar">brms::stanvar()</a></code> for more
details. The default lists all the possible blocks, but it is unlikely that
you will need all of them. You can specify a vector of only those that you
need. The function will add a section for each block in the list</p>
</td></tr>
<tr><td><code id="use_model_template_+3A_open_files">open_files</code></td>
<td>
<p>Logical; If TRUE (default), the function will open the
template files that were created in RStudio</p>
</td></tr>
<tr><td><code id="use_model_template_+3A_testing">testing</code></td>
<td>
<p>Logical; If TRUE, the function will return the file content but
will not save the file. If FALSE (default), the function will save the file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you get a warning during check() about non-ASCII characters, this
is often due to the citation field. You can find what the problem is by
running
</p>
<div class="sourceCode r"><pre>remotes::install_github("eddelbuettel/dang")
dang::checkPackageAsciiCode(dir = ".")
</pre></div>
<p>usually rewriting the numbers (issue, page numbers) manually fixes it
</p>


<h3>Value</h3>

<p>If <code>testing</code> is TRUE, the function will return the file content as a
string. If <code>testing</code> is FALSE, the function will return NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(usethis)

# create a new model file without a brms::custom_family, and open the file
use_model_template("newmodel")

# create a new model file with a brms::custom_family, three .stan files in
# inst/stan_chunks/ and open the files
use_model_template("abc",
  custom_family = TRUE,
  stanvar_blocks = c("functions", "likelihood", "tdata")
)

</code></pre>

<hr>
<h2 id='wrap'>Wrap angles that extend beyond (-pi;pi)</h2><span id='topic+wrap'></span>

<h3>Description</h3>

<p>On the circular space, angles can be only in the range (-pi;pi
or -180;180). When subtracting angles, this can result in values outside of
this range. For example, when calculating the difference between a value of
10 degrees minus 340 degrees, this results in a difference of 330 degrees.
However, the true difference between these two values is -30 degrees. This
function wraps such values, so that they occur in the circle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap(x, radians = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap_+3A_x">x</code></td>
<td>
<p>A numeric vector, matrix or data.frame of angles to be wrapped. In
radians (default) or degrees.</p>
</td></tr>
<tr><td><code id="wrap_+3A_radians">radians</code></td>
<td>
<p>Logical. Is x in radians (default=TRUE) or degrees (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(1000, -pi, pi)
y &lt;- runif(1000, -pi, pi)
diff &lt;- x - y
hist(diff)
wrapped_diff &lt;- wrap(x - y)
hist(wrapped_diff)

</code></pre>

<hr>
<h2 id='zhang_luck_2008'>Data from Experiment 2 reported by Zhang &amp; Luck (2008)</h2><span id='topic+zhang_luck_2008'></span>

<h3>Description</h3>

<p>Raw data of 8 subjects for the response error in a continuous reproduction task
with set size 1, 2, 3, and 6 reported by Zhang &amp; Luck (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zhang_luck_2008
</code></pre>


<h3>Format</h3>



<h4><code>zhang_luck_2008</code></h4>

<p>A data frame with 4,000 rows and 9 columns:
</p>

<dl>
<dt>subID</dt><dd><p>Integer uniquely identifying different subjects</p>
</dd>
<dt>trial</dt><dd><p>Trial identifyier</p>
</dd>
<dt>setsize</dt><dd><p>The set_size of the data in this row</p>
</dd>
<dt>response_error</dt><dd><p>The response error, that is the difference between the response
given and the target color in radians.</p>
</dd>
<dt>col_lure1, col_Lure2, col_Lure3, col_Lure4, col_Lure5</dt><dd><p>Color value of the lure items coded relative to the target color.</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://www.nature.com/articles/nature06860">https://www.nature.com/articles/nature06860</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
