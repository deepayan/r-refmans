<!DOCTYPE html><html><head><title>Help for package flashlight</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flashlight}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_shap'><p>DEPRECATED - Add SHAP values to (multi-)flashlight</p></a></li>
<li><a href='#all_identical'><p>all_identical</p></a></li>
<li><a href='#auto_cut'><p>Discretizes a Vector</p></a></li>
<li><a href='#cut3'><p>Modified cut</p></a></li>
<li><a href='#flashlight'><p>Create or Update a flashlight</p></a></li>
<li><a href='#grouped_center'><p>Grouped, weighted mean centering</p></a></li>
<li><a href='#grouped_counts'><p>Grouped count</p></a></li>
<li><a href='#grouped_stats'><p>Grouped Weighted Means, Quartiles, or Variances</p></a></li>
<li><a href='#grouped_weighted_mean'><p>Fast Grouped Weighted Mean</p></a></li>
<li><a href='#is.flashlight'><p>Check functions for flashlight Classes</p></a></li>
<li><a href='#light_breakdown'><p>Variable Contribution Breakdown for Single Observation</p></a></li>
<li><a href='#light_check'><p>Check flashlight</p></a></li>
<li><a href='#light_combine'><p>Combine Objects</p></a></li>
<li><a href='#light_effects'><p>Combination of Response, Predicted, Partial Dependence, and ALE profiles.</p></a></li>
<li><a href='#light_global_surrogate'><p>Global Surrogate Tree</p></a></li>
<li><a href='#light_ice'><p>Individual Conditional Expectation (ICE)</p></a></li>
<li><a href='#light_importance'><p>Variable Importance</p></a></li>
<li><a href='#light_interaction'><p>Interaction Strength</p></a></li>
<li><a href='#light_performance'><p>Model Performance of Flashlight</p></a></li>
<li><a href='#light_profile'><p>Partial Dependence and other Profiles</p></a></li>
<li><a href='#light_profile2d'><p>2D Partial Dependence and other 2D Profiles</p></a></li>
<li><a href='#light_recode'><p>Recode Factor Columns</p></a></li>
<li><a href='#light_scatter'><p>Scatter</p></a></li>
<li><a href='#most_important'><p>Most Important Variables.</p></a></li>
<li><a href='#multiflashlight'><p>Create or Update a multiflashlight</p></a></li>
<li><a href='#plot_counts'><p>DEPRECATED - Add Counts to Effects Plot</p></a></li>
<li><a href='#plot.light_breakdown'><p>Visualize Variable Contribution Breakdown for Single Observation</p></a></li>
<li><a href='#plot.light_effects'><p>Visualize Multiple Types of Profiles Together</p></a></li>
<li><a href='#plot.light_global_surrogate'><p>Plot Global Surrogate Trees</p></a></li>
<li><a href='#plot.light_ice'><p>Visualize ICE profiles</p></a></li>
<li><a href='#plot.light_importance'><p>Visualize Variable Importance</p></a></li>
<li><a href='#plot.light_performance'><p>Visualize Model Performance</p></a></li>
<li><a href='#plot.light_profile'><p>Visualize Profiles, e.g. Partial Dependence</p></a></li>
<li><a href='#plot.light_profile2d'><p>Visualize 2D-Profiles, e.g., of Partial Dependence</p></a></li>
<li><a href='#plot.light_scatter'><p>Scatter Plot</p></a></li>
<li><a href='#predict.flashlight'><p>Predictions for flashlight</p></a></li>
<li><a href='#predict.multiflashlight'><p>Predictions for multiflashlight</p></a></li>
<li><a href='#print.flashlight'><p>Prints a flashlight</p></a></li>
<li><a href='#print.light'><p>Prints light Object</p></a></li>
<li><a href='#print.multiflashlight'><p>Prints a multiflashlight</p></a></li>
<li><a href='#residuals.flashlight'><p>Residuals for flashlight</p></a></li>
<li><a href='#residuals.multiflashlight'><p>Residuals for multiflashlight</p></a></li>
<li><a href='#response'><p>Response of multi/-flashlight</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Shed Light on Black Box Machine Learning Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Shed light on black box machine learning models by the help
    of model performance, variable importance, global surrogate models,
    ICE profiles, partial dependence (Friedman J. H. (2001)
    &lt;<a href="https://doi.org/10.1214%2Faos%2F1013203451">doi:10.1214/aos/1013203451</a>&gt;), accumulated local effects (Apley D. W.
    (2016) &lt;<a href="https://doi.org/10.48550/arXiv.1612.08468">doi:10.48550/arXiv.1612.08468</a>&gt;), further effects plots, interaction
    strength, and variable contribution breakdown (Gosiewska and Biecek
    (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1903.11420">doi:10.48550/arXiv.1903.11420</a>&gt;).  All tools are implemented to work with
    case weights and allow for stratified analysis.  Furthermore, multiple
    flashlights can be combined and analyzed together.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>cowplot, dplyr (&ge; 1.1.0), ggplot2, MetricsWeighted (&ge;
0.3.0), rlang (&ge; 0.3.0), rpart, rpart.plot, stats, tibble,
tidyr (&ge; 1.0.0), tidyselect, utils, withr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mayer79/flashlight">https://github.com/mayer79/flashlight</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mayer79/flashlight/issues">https://github.com/mayer79/flashlight/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-09 19:39:34 UTC; Michael</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Mayer [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Mayer &lt;mayermichael79@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-10 02:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_shap'>DEPRECATED - Add SHAP values to (multi-)flashlight</h2><span id='topic+add_shap'></span><span id='topic+add_shap.default'></span><span id='topic+add_shap.flashlight'></span><span id='topic+add_shap.multiflashlight'></span>

<h3>Description</h3>

<p>The function calls <code><a href="#topic+light_breakdown">light_breakdown()</a></code> for <code>n_shap</code> observations and adds the
resulting (approximate) SHAP decompositions as static element &quot;shap&quot; to the
(multi)-flashlight for further analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_shap(x, ...)

## Default S3 method:
add_shap(x, ...)

## S3 method for class 'flashlight'
add_shap(
  x,
  v = NULL,
  visit_strategy = c("permutation", "importance", "v"),
  n_shap = 200,
  n_max = Inf,
  n_perm = 12,
  seed = NULL,
  use_linkinv = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'multiflashlight'
add_shap(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_shap_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="add_shap_+3A_...">...</code></td>
<td>
<p>Further arguments passed from or to other methods.</p>
</td></tr>
<tr><td><code id="add_shap_+3A_v">v</code></td>
<td>
<p>Vector of variables to assess contribution for.
Defaults to all except those specified by &quot;y&quot;, &quot;w&quot; and &quot;by&quot;.</p>
</td></tr>
<tr><td><code id="add_shap_+3A_visit_strategy">visit_strategy</code></td>
<td>
<p>In what sequence should variables be visited? By <code>n_perm</code>
&quot;permutation&quot; (slow), by &quot;importance&quot; (fast), or as &quot;v&quot; (not recommended).</p>
</td></tr>
<tr><td><code id="add_shap_+3A_n_shap">n_shap</code></td>
<td>
<p>Number of SHAP decompositions to calculate.</p>
</td></tr>
<tr><td><code id="add_shap_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of rows in <code>data</code> to consider in the reference data.
Set to lower value if <code>data</code> is large.</p>
</td></tr>
<tr><td><code id="add_shap_+3A_n_perm">n_perm</code></td>
<td>
<p>Number of permutations of random visit sequences.
Only used if <code>visit_strategy = "permutation"</code>.</p>
</td></tr>
<tr><td><code id="add_shap_+3A_seed">seed</code></td>
<td>
<p>An integer random seed.</p>
</td></tr>
<tr><td><code id="add_shap_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied?
We suggest to keep the default (<code>FALSE</code>) as the values can be retransformed later.</p>
</td></tr>
<tr><td><code id="add_shap_+3A_verbose">verbose</code></td>
<td>
<p>Should progress bar be shown? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We offer two approximations to SHAP: For <code>visit_strategy = "importance"</code>,
the breakdown algorithm (see reference) is used with importance based visit order.
Use the default <code>visit_strategy = "permutation"</code> to run breakdown for
multiple random permutations, averaging the results.
This approximation will be closer to exact SHAP values, but very slow.
Most available arguments can be chosen to reduce computation time.
</p>


<h3>Value</h3>

<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;
with additional element &quot;shap&quot; of class &quot;shap&quot; (and &quot;list&quot;).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>add_shap(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>add_shap(flashlight)</code>: Variable attribution to single observation for a flashlight.
</p>
</li>
<li> <p><code>add_shap(multiflashlight)</code>: Add SHAP to multiflashlight.
</p>
</li></ul>


<h3>References</h3>

<p>A. Gosiewska and P. Biecek (2019). IBREAKDOWN: Uncertainty of model explanations
for non-additive predictive models. ArXiv &lt;arxiv.org/abs/1903.11420&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- lm(Sepal.Length ~ . + Petal.Length:Species, data = iris)
x &lt;- flashlight(model = fit, label = "lm", data = iris, y = "Sepal.Length")
x &lt;- add_shap(x)
is.shap(x$shap)
plot(light_importance(x, type = "shap"))
plot(light_scatter(x, type = "shap", v = "Petal.Length"))
plot(light_scatter(x, type = "shap", v = "Petal.Length", by = "Species"))

## End(Not run)
</code></pre>

<hr>
<h2 id='all_identical'>all_identical</h2><span id='topic+all_identical'></span>

<h3>Description</h3>

<p>Checks if an aspect is identical for all elements in a nested list.
The aspect is specified by <code>fun</code>, e.g., <code>[[</code>, followed by the element
name to compare.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_identical(x, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_identical_+3A_x">x</code></td>
<td>
<p>A nested list of objects.</p>
</td></tr>
<tr><td><code id="all_identical_+3A_fun">fun</code></td>
<td>
<p>Function used to extract information of each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="all_identical_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>fun()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of length one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = 1, b = 2)
y &lt;- list(a = 1, b = 3)
all_identical(list(x, y), `[[`, "a")
all_identical(list(x, y), `[[`, "b")
</code></pre>

<hr>
<h2 id='auto_cut'>Discretizes a Vector</h2><span id='topic+auto_cut'></span>

<h3>Description</h3>

<p>This function takes a vector <code>x</code> and returns a list with information on
disretized version of <code>x</code>. The construction of level names can be controlled
by passing <code>...</code> arguments to <code><a href="base.html#topic+formatC">formatC()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_cut(
  x,
  breaks = NULL,
  n_bins = 27L,
  cut_type = c("equal", "quantile"),
  x_name = "value",
  level_name = "level",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_cut_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="auto_cut_+3A_breaks">breaks</code></td>
<td>
<p>An optional vector of breaks. Only relevant for numeric <code>x</code>.</p>
</td></tr>
<tr><td><code id="auto_cut_+3A_n_bins">n_bins</code></td>
<td>
<p>If <code>x</code> is numeric and no breaks are provided,
this is the maximum number of bins allowed or to be created (approximately).</p>
</td></tr>
<tr><td><code id="auto_cut_+3A_cut_type">cut_type</code></td>
<td>
<p>For the default type &quot;equal&quot;, bins of equal width are created
by <code><a href="base.html#topic+pretty">pretty()</a></code>. Choose &quot;quantile&quot; to create quantile bins.</p>
</td></tr>
<tr><td><code id="auto_cut_+3A_x_name">x_name</code></td>
<td>
<p>Column name with the values of <code>x</code> in the output.</p>
</td></tr>
<tr><td><code id="auto_cut_+3A_level_name">level_name</code></td>
<td>
<p>Column name with the bin labels of <code>x</code> in the output.</p>
</td></tr>
<tr><td><code id="auto_cut_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+cut3">cut3()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>data</code>: A <code>data.frame</code> with colums <code>x_name</code> and
<code>level_name</code> each with the same length as <code>x</code>.
The column <code>x_name</code> has values in output <code>bin_means</code>
while the column <code>level_name</code> has values in <code>bin_labels</code>.
</p>
</li>
<li> <p><code>breaks</code>: A vector of increasing and unique breaks used to cut a
numeric <code>x</code> with too many distinct levels. <code>NULL</code> otherwise.
</p>
</li>
<li> <p><code>bin_means</code>: The midpoints of subsequent breaks, or if there are no
<code>breaks</code> in the output, factor levels or distinct values of <code>x</code>.
</p>
</li>
<li> <p><code>bin_labels</code>: Break labels of the form &quot;(low, high]&quot; if there are <code>breaks</code>
in the output, otherwise the same as <code>bin_means</code>. Same order as <code>bin_means</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>auto_cut(1:10, n_bins = 3)
auto_cut(c(NA, 1:10), n_bins = 3)
auto_cut(1:10, breaks = 3:4, n_bins = 3)
auto_cut(1:10, n_bins = 3, cut_type = "quantile")
auto_cut(LETTERS[4:1], n_bins = 2)
auto_cut(factor(LETTERS[1:4], LETTERS[4:1]), n_bins = 2)
auto_cut(990:1100, n_bins = 3, big.mark = "'", format = "fg")
auto_cut(c(0.0001, 0.0002, 0.0003, 0.005), n_bins = 3, format = "fg")
</code></pre>

<hr>
<h2 id='cut3'>Modified cut</h2><span id='topic+cut3'></span>

<h3>Description</h3>

<p>Slightly modified version of <code><a href="base.html#topic+cut.default">cut.default()</a></code>. Both modifications refer
to the construction of break labels. Firstly, <code>...</code> arguments are passed to
<code><a href="base.html#topic+formatC">formatC()</a></code> in formatting the numbers in the labels.
Secondly, a separator between the two numbers can be specified with default &quot;, &quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut3(
  x,
  breaks,
  labels = NULL,
  include.lowest = FALSE,
  right = TRUE,
  dig.lab = 3L,
  ordered_result = FALSE,
  sep = ", ",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut3_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="cut3_+3A_breaks">breaks</code></td>
<td>
<p>Numeric vector of cut points or a single number
specifying the number of intervals desired.</p>
</td></tr>
<tr><td><code id="cut3_+3A_labels">labels</code></td>
<td>
<p>Labels for the levels of the final categories.</p>
</td></tr>
<tr><td><code id="cut3_+3A_include.lowest">include.lowest</code></td>
<td>
<p>Flag if minimum value should be added to intervals
of type &quot;(,]&quot; (or maximum for &quot;[,)&quot;).</p>
</td></tr>
<tr><td><code id="cut3_+3A_right">right</code></td>
<td>
<p>Flag if intervals should be closed to the right or left.</p>
</td></tr>
<tr><td><code id="cut3_+3A_dig.lab">dig.lab</code></td>
<td>
<p>Number of significant digits passed to <code><a href="base.html#topic+formatC">formatC()</a></code>.</p>
</td></tr>
<tr><td><code id="cut3_+3A_ordered_result">ordered_result</code></td>
<td>
<p>Flag if resulting output vector should be ordered.</p>
</td></tr>
<tr><td><code id="cut3_+3A_sep">sep</code></td>
<td>
<p>Separater between from-to labels.</p>
</td></tr>
<tr><td><code id="cut3_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+formatC">formatC()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of the same length as x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 998:1001
cut3(x, breaks = 2)
cut3(x, breaks = 2, big.mark = "'", sep = ":")
</code></pre>

<hr>
<h2 id='flashlight'>Create or Update a flashlight</h2><span id='topic+flashlight'></span><span id='topic+flashlight.default'></span><span id='topic+flashlight.flashlight'></span>

<h3>Description</h3>

<p>Creates or updates a &quot;flashlight&quot; object. If a flashlight is to be created,
all arguments are optional except <code>label</code>. If a flashlight is to be updated,
all arguments are optional up to <code>x</code> (the flashlight to be updated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flashlight(x, ...)

## Default S3 method:
flashlight(
  x,
  model = NULL,
  data = NULL,
  y = NULL,
  predict_function = stats::predict,
  linkinv = function(z) z,
  w = NULL,
  by = NULL,
  metrics = list(rmse = MetricsWeighted::rmse),
  label = NULL,
  shap = NULL,
  ...
)

## S3 method for class 'flashlight'
flashlight(x, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flashlight_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot;. If not provided, a new flashlight is
created based on further input. Otherwise, <code>x</code> is updated based on further input.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_...">...</code></td>
<td>
<p>Arguments passed from or to other functions.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_model">model</code></td>
<td>
<p>A fitted model of any type. Most models require a customized
<code>predict_function</code>.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>tibble</code> used as basis for calculations.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_y">y</code></td>
<td>
<p>Variable name of response.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_predict_function">predict_function</code></td>
<td>
<p>A real valued function with two arguments:
A model and a data of the same structure as <code>data</code>.
Only the order of the two arguments matter, not their names.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_linkinv">linkinv</code></td>
<td>
<p>An inverse transformation function applied after <code>predict_function</code>.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_w">w</code></td>
<td>
<p>A variable name of case weights.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_by">by</code></td>
<td>
<p>A character vector with names of grouping variables.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_metrics">metrics</code></td>
<td>
<p>A named list of metrics. Here, a metric is a function with exactly
four arguments: actual, predicted, w (case weights) and <code>...</code>
like those in package MetricsWeighted.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_label">label</code></td>
<td>
<p>Name of the flashlight. Required.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_shap">shap</code></td>
<td>
<p>An optional shap object. Typically added by calling <code><a href="#topic+add_shap">add_shap()</a></code>.</p>
</td></tr>
<tr><td><code id="flashlight_+3A_check">check</code></td>
<td>
<p>When updating the flashlight: Should internal checks be performed?
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;flashlight&quot; (and <code>list</code>) containing each
input (except <code>x</code>) as element.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>flashlight(default)</code>: Used to create a flashlight object.
No <code>x</code> has to be passed in this case.
</p>
</li>
<li> <p><code>flashlight(flashlight)</code>: Used to update an existing flashlight object.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+multiflashlight">multiflashlight()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
(fl &lt;- flashlight(model = fit, data = iris, y = "Sepal.Length", label = "ols"))
(fl_updated &lt;- flashlight(fl, linkinv = exp))
</code></pre>

<hr>
<h2 id='grouped_center'>Grouped, weighted mean centering</h2><span id='topic+grouped_center'></span>

<h3>Description</h3>

<p>Centers a numeric variable within optional groups and optional weights.
The order of values is unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped_center(data, x, w = NULL, by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grouped_center_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="grouped_center_+3A_x">x</code></td>
<td>
<p>Variable name in <code>data</code> to center.</p>
</td></tr>
<tr><td><code id="grouped_center_+3A_w">w</code></td>
<td>
<p>Optional name of the column in <code>data</code> with case weights.</p>
</td></tr>
<tr><td><code id="grouped_center_+3A_by">by</code></td>
<td>
<p>An optional vector of column names in <code>data</code> used to group the results.</p>
</td></tr>
<tr><td><code id="grouped_center_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to mean calculation (e.g. <code>na.rm = TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with centered values in column <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ir &lt;- data.frame(iris, w = 1)
mean(grouped_center(ir, "Sepal.Width"))
rowsum(grouped_center(ir, "Sepal.Width", by = "Species"), ir$Species)
mean(grouped_center(ir, "Sepal.Width", w = "w"))
rowsum(grouped_center(ir, "Sepal.Width", by = "Species", w = "w"), ir$Species)
</code></pre>

<hr>
<h2 id='grouped_counts'>Grouped count</h2><span id='topic+grouped_counts'></span>

<h3>Description</h3>

<p>Calculates weighted counts grouped by optional columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped_counts(data, by = NULL, w = NULL, value_name = "n", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grouped_counts_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="grouped_counts_+3A_by">by</code></td>
<td>
<p>An optional vector of column names in <code>data</code> used to group the results.</p>
</td></tr>
<tr><td><code id="grouped_counts_+3A_w">w</code></td>
<td>
<p>Optional name of the column in <code>data</code> with case weights.</p>
</td></tr>
<tr><td><code id="grouped_counts_+3A_value_name">value_name</code></td>
<td>
<p>Name of the resulting column with counts.</p>
</td></tr>
<tr><td><code id="grouped_counts_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+sum">sum()</a></code> (only if weights are provided).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>by</code> and <code>value_name</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grouped_counts(iris)
grouped_counts(iris, by = "Species")
grouped_counts(iris, w = "Petal.Length")
grouped_counts(iris, by = "Species", w = "Petal.Length")
</code></pre>

<hr>
<h2 id='grouped_stats'>Grouped Weighted Means, Quartiles, or Variances</h2><span id='topic+grouped_stats'></span>

<h3>Description</h3>

<p>Calculates weighted means, quartiles, or variances (and counts) of a
variable grouped by optional columns. By default, counts are not weighted,
even if there is a weighting variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped_stats(
  data,
  x,
  w = NULL,
  by = NULL,
  stats = c("mean", "quartiles", "variance"),
  counts = TRUE,
  counts_weighted = FALSE,
  counts_name = "counts",
  value_name = x,
  q1_name = "q1",
  q3_name = "q3",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grouped_stats_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_x">x</code></td>
<td>
<p>Variable name in <code>data</code> to summarize.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_w">w</code></td>
<td>
<p>Optional name of the column in <code>data</code> with case weights.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_by">by</code></td>
<td>
<p>An optional vector of column names in <code>data</code> used to group the results.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_stats">stats</code></td>
<td>
<p>Statistic to calculate: &quot;mean&quot;, &quot;quartiles&quot;, or &quot;variance&quot;.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_counts">counts</code></td>
<td>
<p>Should group counts be added?</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_counts_weighted">counts_weighted</code></td>
<td>
<p>Should counts be weighted by the case weights?
If <code>TRUE</code>, the sum of <code>w</code> is returned by group.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_counts_name">counts_name</code></td>
<td>
<p>Name of column in the resulting <code>data.frame</code> containing the counts.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_value_name">value_name</code></td>
<td>
<p>Name of the resulting column with mean, median, or variance.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_q1_name">q1_name</code></td>
<td>
<p>Name of the resulting column with first quartile values.
Only relevant if <code>stats = "quartiles"</code>.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_q3_name">q3_name</code></td>
<td>
<p>Name of the resulting column with third quartile values.
Only relevant if <code>stats = "quartiles"</code>.</p>
</td></tr>
<tr><td><code id="grouped_stats_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to corresponding <code style="white-space: pre;">&#8288;weighted_*()&#8288;</code> functions in
MetricsWeighted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>by</code>, <code>x</code>, and optionally <code>counts_name</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grouped_stats(iris, "Sepal.Width")
grouped_stats(iris, "Sepal.Width", stats = "quartiles")
grouped_stats(iris, "Sepal.Width", stats = "variance")
grouped_stats(iris, "Sepal.Width", w = "Petal.Width", counts_weighted = TRUE)
grouped_stats(iris, "Sepal.Width", by = "Species")
</code></pre>

<hr>
<h2 id='grouped_weighted_mean'>Fast Grouped Weighted Mean</h2><span id='topic+grouped_weighted_mean'></span>

<h3>Description</h3>

<p>Fast version of <code>grouped_stats(..., counts = FALSE)</code>.
Works if there is at most one &quot;by&quot; variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped_weighted_mean(
  data,
  x,
  w = NULL,
  by = NULL,
  na.rm = TRUE,
  value_name = x
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grouped_weighted_mean_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="grouped_weighted_mean_+3A_x">x</code></td>
<td>
<p>Variable name in <code>data</code> to summarize.</p>
</td></tr>
<tr><td><code id="grouped_weighted_mean_+3A_w">w</code></td>
<td>
<p>Optional name of the column in <code>data</code> with case weights.</p>
</td></tr>
<tr><td><code id="grouped_weighted_mean_+3A_by">by</code></td>
<td>
<p>An optional vector of column names in <code>data</code> used to group the results.</p>
</td></tr>
<tr><td><code id="grouped_weighted_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values in <code>x</code> be removed?</p>
</td></tr>
<tr><td><code id="grouped_weighted_mean_+3A_value_name">value_name</code></td>
<td>
<p>Name of the resulting column with means.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with grouped weighted means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
data &lt;- data.frame(
  x = rnorm(n),
  w = runif(n),
  group = factor(sample(1:3, n, TRUE))
)
grouped_weighted_mean(data, x = "x", w = "w", by = "group")
</code></pre>

<hr>
<h2 id='is.flashlight'>Check functions for flashlight Classes</h2><span id='topic+is.flashlight'></span><span id='topic+is.multiflashlight'></span><span id='topic+is.light'></span><span id='topic+is.light_performance'></span><span id='topic+is.light_performance_multi'></span><span id='topic+is.light_importance'></span><span id='topic+is.light_importance_multi'></span><span id='topic+is.light_breakdown'></span><span id='topic+is.light_breakdown_multi'></span><span id='topic+is.light_ice'></span><span id='topic+is.light_ice_multi'></span><span id='topic+is.light_profile'></span><span id='topic+is.light_profile_multi'></span><span id='topic+is.light_profile2d'></span><span id='topic+is.light_profile2d_multi'></span><span id='topic+is.light_effects'></span><span id='topic+is.light_effects_multi'></span><span id='topic+is.shap'></span><span id='topic+is.light_scatter'></span><span id='topic+is.light_scatter_multi'></span><span id='topic+is.light_global_surrogate'></span><span id='topic+is.light_global_surrogate_multi'></span>

<h3>Description</h3>

<p>Checks if an object inherits specific class relevant for the flashlight package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.flashlight(x)

is.multiflashlight(x)

is.light(x)

is.light_performance(x)

is.light_performance_multi(x)

is.light_importance(x)

is.light_importance_multi(x)

is.light_breakdown(x)

is.light_breakdown_multi(x)

is.light_ice(x)

is.light_ice_multi(x)

is.light_profile(x)

is.light_profile_multi(x)

is.light_profile2d(x)

is.light_profile2d_multi(x)

is.light_effects(x)

is.light_effects_multi(x)

is.shap(x)

is.light_scatter(x)

is.light_scatter_multi(x)

is.light_global_surrogate(x)

is.light_global_surrogate_multi(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.flashlight_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of length one.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>is.multiflashlight()</code>: Check for multiflashlight object.
</p>
</li>
<li> <p><code>is.light()</code>: Check for light object.
</p>
</li>
<li> <p><code>is.light_performance()</code>: Check for light_performance object.
</p>
</li>
<li> <p><code>is.light_performance_multi()</code>: Check for light_performance_multi object.
</p>
</li>
<li> <p><code>is.light_importance()</code>: Check for light_importance object.
</p>
</li>
<li> <p><code>is.light_importance_multi()</code>: Check for light_importance_multi object.
</p>
</li>
<li> <p><code>is.light_breakdown()</code>: Check for light_breakdown object.
</p>
</li>
<li> <p><code>is.light_breakdown_multi()</code>: Check for light_breakdown_multi object.
</p>
</li>
<li> <p><code>is.light_ice()</code>: Check for light_ice object.
</p>
</li>
<li> <p><code>is.light_ice_multi()</code>: Check for light_ice_multi object.
</p>
</li>
<li> <p><code>is.light_profile()</code>: Check for light_profile object.
</p>
</li>
<li> <p><code>is.light_profile_multi()</code>: Check for light_profile_multi object.
</p>
</li>
<li> <p><code>is.light_profile2d()</code>: Check for light_profile2d object.
</p>
</li>
<li> <p><code>is.light_profile2d_multi()</code>: Check for light_profile2d_multi object.
</p>
</li>
<li> <p><code>is.light_effects()</code>: Check for light_effects object.
</p>
</li>
<li> <p><code>is.light_effects_multi()</code>: Check for light_effects_multi object.
</p>
</li>
<li> <p><code>is.shap()</code>: Check for shap object.
</p>
</li>
<li> <p><code>is.light_scatter()</code>: Check for light_scatter object.
</p>
</li>
<li> <p><code>is.light_scatter_multi()</code>: Check for light_scatter_multi object.
</p>
</li>
<li> <p><code>is.light_global_surrogate()</code>: Check for light_global_surrogate object.
</p>
</li>
<li> <p><code>is.light_global_surrogate_multi()</code>: Check for light_global_surrogate_multi object.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- flashlight(label = "a")
is.flashlight(a)
is.flashlight("a")
</code></pre>

<hr>
<h2 id='light_breakdown'>Variable Contribution Breakdown for Single Observation</h2><span id='topic+light_breakdown'></span><span id='topic+light_breakdown.default'></span><span id='topic+light_breakdown.flashlight'></span><span id='topic+light_breakdown.multiflashlight'></span>

<h3>Description</h3>

<p>Calculates sequential additive variable contributions (approximate SHAP) to
the prediction of a single observation, see Gosiewska and Biecek (see reference)
and the details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_breakdown(x, ...)

## Default S3 method:
light_breakdown(x, ...)

## S3 method for class 'flashlight'
light_breakdown(
  x,
  new_obs,
  data = x$data,
  by = x$by,
  v = NULL,
  visit_strategy = c("importance", "permutation", "v"),
  n_max = Inf,
  n_perm = 20,
  seed = NULL,
  use_linkinv = FALSE,
  description = TRUE,
  digits = 2,
  ...
)

## S3 method for class 'multiflashlight'
light_breakdown(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_breakdown_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+prettyNum">prettyNum()</a></code> to format numbers
in description text.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_new_obs">new_obs</code></td>
<td>
<p>One single new observation to calculate variable attribution for.
Needs to be a <code>data.frame</code> of same structure as <code>data</code>.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to filter <code>data</code>
for rows with equal values in &quot;by&quot; variables as <code>new_obs</code>.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_v">v</code></td>
<td>
<p>Vector of variable names to assess contribution for.
Defaults to all except those specified by &quot;y&quot;, &quot;w&quot; and &quot;by&quot;.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_visit_strategy">visit_strategy</code></td>
<td>
<p>In what sequence should variables be visited?
By &quot;importance&quot;, by <code>n_perm</code> &quot;permutation&quot; or as &quot;v&quot; (see Details).</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of rows in <code>data</code> to consider in the reference data.
Set to lower value if <code>data</code> is large.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_n_perm">n_perm</code></td>
<td>
<p>Number of permutations of random visit sequences.
Only used if <code>visit_strategy = "permutation"</code>.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_seed">seed</code></td>
<td>
<p>An integer random seed used to shuffle rows if <code>n_max</code>
is smaller than the number of rows in <code>data</code>.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_description">description</code></td>
<td>
<p>Should descriptions be added? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="light_breakdown_+3A_digits">digits</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+prettyNum">prettyNum()</a></code> to format numbers in description text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The breakdown algorithm works as follows: First, the visit order
<code class="reqn">(x_1, ..., x_m)</code> of the variables <code>v</code> is specified.
Then, in the query <code>data</code>, the column <code class="reqn">x_1</code> is set to the value of <code class="reqn">x_1</code>
of the single observation <code>new_obs</code> to be explained.
The change in the (weighted) average prediction on <code>data</code> measures the
contribution of <code class="reqn">x_1</code> on the prediction of <code>new_obs</code>.
This procedure is iterated over all <code class="reqn">x_i</code> until eventually, all rows
in <code>data</code> are identical to <code>new_obs</code>.
</p>
<p>A complication with this approach is that the visit order is relevant,
at least for non-additive models. Ideally, the algorithm could be repeated
for all possible permutations of <code>v</code> and its results averaged per variable.
This is basically what SHAP values do, see the reference below for an explanation.
Unfortunately, there is no efficient way to do this in a model agnostic way.
</p>
<p>We offer two visit strategies to approximate SHAP:
</p>

<ol>
<li><p> &quot;importance&quot;: Using the short-cut described in the reference below:
The variables are sorted by the size of their contribution in the same way as the
breakdown algorithm but without iteration, i.e., starting from the original query
data for each variable <code class="reqn">x_i</code>.
</p>
</li>
<li><p> &quot;permutation&quot;: Averages contributions from a small number of random permutations
of <code>v</code>.
</p>
</li></ol>

<p>Note that the minimum required elements in the (multi-)flashlight are a
&quot;predict_function&quot;, &quot;model&quot;, and &quot;data&quot;. The latter can also directly be passed to
<code><a href="#topic+light_breakdown">light_breakdown()</a></code>. Note that by default, no retransformation function is applied.
</p>


<h3>Value</h3>

<p>An object of class &quot;light_breakdown&quot; with the following elements:
</p>

<ul>
<li> <p><code>data</code> A tibble with results. Can be used to build fully customized
visualizations. Column names can be controlled by <code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code> Same as input <code>by</code>.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_breakdown(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_breakdown(flashlight)</code>: Variable attribution to single observation
for a flashlight.
</p>
</li>
<li> <p><code>light_breakdown(multiflashlight)</code>: Variable attribution to single observation
for a multiflashlight.
</p>
</li></ul>


<h3>References</h3>

<p>A. Gosiewska and P. Biecek (2019). IBREAKDOWN: Uncertainty of model explanations
for non-additive predictive models. ArXiv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.light_breakdown">plot.light_breakdown()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ . + Petal.Length:Species, data = iris)
fl &lt;- flashlight(model = fit, label = "lm", data = iris, y = "Sepal.Length")
light_breakdown(fl, new_obs = iris[1, ])
</code></pre>

<hr>
<h2 id='light_check'>Check flashlight</h2><span id='topic+light_check'></span><span id='topic+light_check.default'></span><span id='topic+light_check.flashlight'></span><span id='topic+light_check.multiflashlight'></span>

<h3>Description</h3>

<p>Checks if an object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;
is consistently defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_check(x, ...)

## Default S3 method:
light_check(x, ...)

## S3 method for class 'flashlight'
light_check(x, ...)

## S3 method for class 'multiflashlight'
light_check(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_check_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_check_+3A_...">...</code></td>
<td>
<p>Further arguments passed from or to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>x</code> or an error message.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_check(default)</code>: Default check method not implemented yet.
</p>
</li>
<li> <p><code>light_check(flashlight)</code>: Checks if a flashlight object is consistently defined.
</p>
</li>
<li> <p><code>light_check(multiflashlight)</code>: Checks if a multiflashlight object is consistently defined.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fit_log &lt;- lm(log(Sepal.Length) ~ ., data = iris)
fl &lt;- flashlight(fit, data = iris, y = "Sepal.Length", label = "ols")
fl_log &lt;- flashlight(fit_log,  y = "Sepal.Length", label = "ols", linkinv = exp)
light_check(fl)
light_check(fl_log)
</code></pre>

<hr>
<h2 id='light_combine'>Combine Objects</h2><span id='topic+light_combine'></span><span id='topic+light_combine.default'></span><span id='topic+light_combine.light'></span><span id='topic+light_combine.list'></span>

<h3>Description</h3>

<p>Combines a list of similar objects each of class &quot;light&quot; by row binding
<code>data.frame</code> slots and retaining the other slots from the first list element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_combine(x, ...)

## Default S3 method:
light_combine(x, ...)

## S3 method for class 'light'
light_combine(x, new_class = NULL, ...)

## S3 method for class 'list'
light_combine(x, new_class = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_combine_+3A_x">x</code></td>
<td>
<p>A list of objects of the same class.</p>
</td></tr>
<tr><td><code id="light_combine_+3A_...">...</code></td>
<td>
<p>Further arguments passed from or to other methods.</p>
</td></tr>
<tr><td><code id="light_combine_+3A_new_class">new_class</code></td>
<td>
<p>An optional vector with additional class names to be added
to the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a list, an object like each element but with unioned rows
in data slots.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_combine(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_combine(light)</code>: Since there is nothing to combine, the input is returned
except for additional classes.
</p>
</li>
<li> <p><code>light_combine(list)</code>: Combine a list of similar light objects.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fit_lm &lt;- lm(Sepal.Length ~ ., data = iris)
fit_glm &lt;- glm(Sepal.Length ~ ., family = Gamma(link = "log"), data = iris)
mod_lm &lt;- flashlight(model = fit_lm, label = "lm", data = iris, y = "Sepal.Length")
mod_glm &lt;- flashlight(
  model = fit_glm,
  label = "glm",
  data = iris,
  y = "Sepal.Length",
  predict_function = function(object, newdata)
    predict(object, newdata, type = "response")
)
mods &lt;- multiflashlight(list(mod_lm, mod_glm))
perf_lm &lt;- light_performance(mod_lm)
perf_glm &lt;- light_performance(mod_glm)
manual_comb &lt;- light_combine(
  list(perf_lm, perf_glm),
  new_class = "light_performance_multi"
)
auto_comb &lt;- light_performance(mods)
all.equal(manual_comb, auto_comb)
</code></pre>

<hr>
<h2 id='light_effects'>Combination of Response, Predicted, Partial Dependence, and ALE profiles.</h2><span id='topic+light_effects'></span><span id='topic+light_effects.default'></span><span id='topic+light_effects.flashlight'></span><span id='topic+light_effects.multiflashlight'></span>

<h3>Description</h3>

<p>Calculates response- prediction-, partial dependence, and ALE profiles of a
(multi-)flashlight with respect to a covariable <code>v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_effects(x, ...)

## Default S3 method:
light_effects(x, ...)

## S3 method for class 'flashlight'
light_effects(
  x,
  v,
  data = NULL,
  by = x$by,
  stats = c("mean", "quartiles"),
  breaks = NULL,
  n_bins = 11L,
  cut_type = c("equal", "quantile"),
  use_linkinv = TRUE,
  counts_weighted = FALSE,
  v_labels = TRUE,
  pred = NULL,
  pd_indices = NULL,
  pd_n_max = 1000L,
  pd_seed = NULL,
  ale_two_sided = TRUE,
  ...
)

## S3 method for class 'multiflashlight'
light_effects(
  x,
  v,
  data = NULL,
  breaks = NULL,
  n_bins = 11L,
  cut_type = c("equal", "quantile"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_effects_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+cut3">cut3()</a></code> in forming the
cut breaks of the <code>v</code> variable.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_v">v</code></td>
<td>
<p>The variable name to be profiled.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>. Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_stats">stats</code></td>
<td>
<p>Statistic to calculate for the response profile: &quot;mean&quot; or &quot;quartiles&quot;.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_breaks">breaks</code></td>
<td>
<p>Cut breaks for a numeric <code>v</code>. Used to overwrite automatic binning via
<code>n_bins</code> and <code>cut_type</code>. Ignored if <code>v</code> is not numeric.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_n_bins">n_bins</code></td>
<td>
<p>Approximate number of unique values to evaluate for numeric <code>v</code>.
Ignored if <code>v</code> is not numeric or if <code>breaks</code> is specified.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_cut_type">cut_type</code></td>
<td>
<p>Should a numeric <code>v</code> be cut into &quot;equal&quot; or &quot;quantile&quot; bins?
Ignored if <code>v</code> is not numeric or if <code>breaks</code> is specified.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied? Default is <code>TRUE</code>.
Not used for type &quot;shap&quot;.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_counts_weighted">counts_weighted</code></td>
<td>
<p>Should counts be weighted by the case weights?
If <code>TRUE</code>, the sum of <code>w</code> is returned by group.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_v_labels">v_labels</code></td>
<td>
<p>If <code>FALSE</code>, return group centers of <code>v</code> instead of labels.
Only relevant if <code>v</code> is numeric with many distinct values.
In that case useful for instance when different flashlights use different data sets.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_pred">pred</code></td>
<td>
<p>Optional vector with predictions (after application of inverse link).
Can be used to avoid recalculation of predictions over and over if the functions
is to be repeatedly called for different <code>v</code> and predictions are computationally
expensive to make. Not implemented for multiflashlight.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_pd_indices">pd_indices</code></td>
<td>
<p>A vector of row numbers to consider in calculating
partial dependence profiles and &quot;ale&quot;.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_pd_n_max">pd_n_max</code></td>
<td>
<p>Maximum number of ICE profiles to calculate (will be randomly
picked from <code>data</code>) for partial dependence and ALE.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_pd_seed">pd_seed</code></td>
<td>
<p>Integer random seed used to select ICE profiles for partial dependence
and ALE.</p>
</td></tr>
<tr><td><code id="light_effects_+3A_ale_two_sided">ale_two_sided</code></td>
<td>
<p>If <code>TRUE</code>, <code>v</code> is continuous and <code>breaks</code>
are passed or being calculated, then two-sided derivatives are calculated
for ALE instead of left derivatives. More specifically: Usually, local effects
at value x are calculated using points in <code class="reqn">[x-e, x]</code>.
Set <code>ale_two_sided = TRUE</code> to use points in <code class="reqn">[x-e/2, x+e/2]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that ALE profiles are being calibrated by (weighted) average predictions.
The resulting level might be quite different from the one of the partial
dependence profiles.
</p>


<h3>Value</h3>

<p>An object of class &quot;light_effects&quot; with the following elements:
</p>

<ul>
<li> <p><code>response</code>: A tibble containing the response profiles.
Column names can be controlled by <code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>predicted</code>: A tibble containing the prediction profiles.
</p>
</li>
<li> <p><code>pd</code>: A tibble containing the partial dependence profiles.
</p>
</li>
<li> <p><code>ale</code>: A tibble containing the ALE profiles.
</p>
</li>
<li> <p><code>by</code>: Same as input <code>by</code>.
</p>
</li>
<li> <p><code>v</code>: The variable(s) evaluated.
</p>
</li>
<li> <p><code>stats</code>: Same as input <code>stats</code>.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_effects(default)</code>: Default method.
</p>
</li>
<li> <p><code>light_effects(flashlight)</code>: Profiles for a flashlight object.
</p>
</li>
<li> <p><code>light_effects(multiflashlight)</code>: Effect profiles for a multiflashlight object.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+light_profile">light_profile()</a></code>, <code><a href="#topic+plot.light_effects">plot.light_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
light_effects(fl, v = "Species")
</code></pre>

<hr>
<h2 id='light_global_surrogate'>Global Surrogate Tree</h2><span id='topic+light_global_surrogate'></span><span id='topic+light_global_surrogate.default'></span><span id='topic+light_global_surrogate.flashlight'></span><span id='topic+light_global_surrogate.multiflashlight'></span>

<h3>Description</h3>

<p>Model predictions are modelled by a single decision tree, serving as an easy
to interprete surrogate to the original model.
As suggested in Molnar (see reference below), the quality of the surrogate
tree can be measured by its R-squared. The size of the tree can be modified
by passing <code>...</code> arguments to <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_global_surrogate(x, ...)

## Default S3 method:
light_global_surrogate(x, ...)

## S3 method for class 'flashlight'
light_global_surrogate(
  x,
  data = x$data,
  by = x$by,
  v = NULL,
  use_linkinv = TRUE,
  n_max = Inf,
  seed = NULL,
  keep_max_levels = 4L,
  ...
)

## S3 method for class 'multiflashlight'
light_global_surrogate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_global_surrogate_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_global_surrogate_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code>, such as <code>maxdepth</code>.</p>
</td></tr>
<tr><td><code id="light_global_surrogate_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="light_global_surrogate_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.
For each group, a separate tree is grown.</p>
</td></tr>
<tr><td><code id="light_global_surrogate_+3A_v">v</code></td>
<td>
<p>Vector of variables used in the surrogate model.
Defaults to all variables in <code>data</code> except &quot;by&quot;, &quot;w&quot; and &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="light_global_surrogate_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="light_global_surrogate_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of data rows to consider to build the tree.</p>
</td></tr>
<tr><td><code id="light_global_surrogate_+3A_seed">seed</code></td>
<td>
<p>An integer random seed used to select data rows if <code>n_max</code> is lower than
the number of data rows.</p>
</td></tr>
<tr><td><code id="light_global_surrogate_+3A_keep_max_levels">keep_max_levels</code></td>
<td>
<p>Number of levels of categorical and factor variables to keep.
Other levels are combined to a level &quot;Other&quot;. This prevents <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code> to
take too long to split non-numeric variables with many levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;light_global_surrogate&quot; with the following elements:
</p>

<ul>
<li> <p><code>data</code> A tibble with results. Can be used to build fully customized visualizations.
Column names can be controlled by <code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code> Same as input <code>by</code>.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_global_surrogate(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_global_surrogate(flashlight)</code>: Surrogate model for a flashlight.
</p>
</li>
<li> <p><code>light_global_surrogate(multiflashlight)</code>: Surrogate model for a multiflashlight.
</p>
</li></ul>


<h3>References</h3>

<p>Molnar C. (2019). Interpretable Machine Learning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.light_global_surrogate">plot.light_global_surrogate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
x &lt;- flashlight(model = fit, label = "lm", data = iris)
light_global_surrogate(x)
</code></pre>

<hr>
<h2 id='light_ice'>Individual Conditional Expectation (ICE)</h2><span id='topic+light_ice'></span><span id='topic+light_ice.default'></span><span id='topic+light_ice.flashlight'></span><span id='topic+light_ice.multiflashlight'></span>

<h3>Description</h3>

<p>Generates Individual Conditional Expectation (ICE) profiles.
An ICE profile shows how the prediction of an observation changes if
one or multiple variables are systematically changed across its ranges,
holding all other values fixed (see the reference below for details).
The curves can be centered in order to increase visibility of interaction effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_ice(x, ...)

## Default S3 method:
light_ice(x, ...)

## S3 method for class 'flashlight'
light_ice(
  x,
  v = NULL,
  data = x$data,
  by = x$by,
  evaluate_at = NULL,
  breaks = NULL,
  grid = NULL,
  n_bins = 27L,
  cut_type = c("equal", "quantile"),
  indices = NULL,
  n_max = 20L,
  seed = NULL,
  use_linkinv = TRUE,
  center = c("no", "first", "middle", "last", "mean", "0"),
  ...
)

## S3 method for class 'multiflashlight'
light_ice(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_ice_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_v">v</code></td>
<td>
<p>The variable name to be profiled.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_evaluate_at">evaluate_at</code></td>
<td>
<p>Vector with values of <code>v</code> used to evaluate the profile.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_breaks">breaks</code></td>
<td>
<p>Cut breaks for a numeric <code>v</code>. Used to overwrite automatic
binning via <code>n_bins</code> and <code>cut_type</code>. Ignored if <code>v</code> is not numeric or if <code>grid</code>
or <code>evaluate_at</code> are specified.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_grid">grid</code></td>
<td>
<p>A <code>data.frame</code> with evaluation grid. For instance, can be generated by
<code><a href="base.html#topic+expand.grid">expand.grid()</a></code>.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_n_bins">n_bins</code></td>
<td>
<p>Approximate number of unique values to evaluate for numeric <code>v</code>.
Ignored if <code>v</code> is not numeric or if <code>breaks</code>, <code>grid</code> or <code>evaluate_at</code> are specified.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_cut_type">cut_type</code></td>
<td>
<p>Should a numeric <code>v</code> be cut into &quot;equal&quot; or &quot;quantile&quot; bins?
Ignored if <code>v</code> is not numeric or if <code>breaks</code>, <code>grid</code> or <code>evaluate_at</code> are specified.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_indices">indices</code></td>
<td>
<p>A vector of row numbers to consider.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_n_max">n_max</code></td>
<td>
<p>If <code>indices</code> is not given, maximum number of rows to consider.
Will be randomly picked from <code>data</code> if necessary.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_seed">seed</code></td>
<td>
<p>An integer random seed.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="light_ice_+3A_center">center</code></td>
<td>
<p>How should curves be centered?
</p>

<ul>
<li><p> Default is &quot;no&quot;.
</p>
</li>
<li><p> Choose &quot;first&quot;, &quot;middle&quot;, or &quot;last&quot; to 0-center at specific evaluation points.
</p>
</li>
<li><p> Choose &quot;mean&quot; to center all profiles at the within-group means.
</p>
</li>
<li><p> Choose &quot;0&quot; to mean-center curves at 0.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways to specify the variable(s) to be profiled.
</p>

<ol>
<li><p> Pass the variable name via <code>v</code> and an optional vector with evaluation points
<code>evaluate_at</code> (or <code>breaks</code>). This works for dependence on a single variable.
</p>
</li>
<li><p> More general: Specify any <code>grid</code> as a <code>data.frame</code> with one or
more columns. For instance, it can be generated by a call to <code><a href="base.html#topic+expand.grid">expand.grid()</a></code>.
</p>
</li></ol>

<p>The minimum required elements in the (multi-)flashlight are &quot;predict_function&quot;,
&quot;model&quot;, &quot;linkinv&quot; and &quot;data&quot;, where the latest can be passed on the fly.
</p>
<p>Which rows in <code>data</code> are profiled? This is specified by <code>indices</code>.
If not given and <code>n_max</code> is smaller than the number of rows in <code>data</code>,
then row indices will be sampled randomly from <code>data</code>.
If the same rows should be used for all flashlights in a multiflashlight,
there are two options: Either pass a <code>seed</code> or a vector of indices used to select rows.
In both cases, <code>data</code> should be the same for all flashlights considered.
</p>


<h3>Value</h3>

<p>An object of class &quot;light_ice&quot; with the following elements:
</p>

<ul>
<li> <p><code>data</code> A tibble containing the results. Can be used to build fully customized
visualizations. Column names can be controlled by <code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code> Same as input <code>by</code>.
</p>
</li>
<li> <p><code>v</code> The variable(s) evaluated.
</p>
</li>
<li> <p><code>center</code> How centering was done.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_ice(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_ice(flashlight)</code>: ICE profiles for a flashlight object.
</p>
</li>
<li> <p><code>light_ice(multiflashlight)</code>: ICE profiles for a multiflashlight object.
</p>
</li></ul>


<h3>References</h3>

<p>Goldstein, A. et al. (2015). Peeking inside the black box: Visualizing statistical
learning with plots of individual conditional expectation.
Journal of Computational and Graphical Statistics, 24:1
&lt;doi.org/10.1080/10618600.2014.907095&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_profile">light_profile()</a></code>, <code><a href="#topic+plot.light_ice">plot.light_ice()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "lm", data = iris)
light_ice(fl, v = "Species")
</code></pre>

<hr>
<h2 id='light_importance'>Variable Importance</h2><span id='topic+light_importance'></span><span id='topic+light_importance.default'></span><span id='topic+light_importance.flashlight'></span><span id='topic+light_importance.multiflashlight'></span>

<h3>Description</h3>

<p>Two algorithms to calculate variable importance are available:
</p>

<ol>
<li><p> Permutation importance, and
</p>
</li>
<li><p> SHAP importance
</p>
</li></ol>

<p>Algorithm 1 measures importance of variable v as the drop in performance
by permuting the values of v, see Fisher et al. 2018 (reference below).
Algorithm 2 measures variable importance by averaging absolute SHAP values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_importance(x, ...)

## Default S3 method:
light_importance(x, ...)

## S3 method for class 'flashlight'
light_importance(
  x,
  data = x$data,
  by = x$by,
  type = c("permutation", "shap"),
  v = NULL,
  n_max = Inf,
  seed = NULL,
  m_repetitions = 1L,
  metric = x$metrics[1L],
  lower_is_better = TRUE,
  use_linkinv = FALSE,
  ...
)

## S3 method for class 'multiflashlight'
light_importance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_importance_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+light_performance">light_performance()</a></code>.
Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>. Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_type">type</code></td>
<td>
<p>Type of importance: &quot;permutation&quot; (default) or &quot;shap&quot;.
&quot;shap&quot; is only available if a &quot;shap&quot; object is contained in <code>x</code>.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_v">v</code></td>
<td>
<p>Vector of variable names to assess importance for.
Defaults to all variables in <code>data</code> except &quot;by&quot; and &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of rows to consider. Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_seed">seed</code></td>
<td>
<p>An integer random seed used to select and shuffle rows.
Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_m_repetitions">m_repetitions</code></td>
<td>
<p>Number of permutations. Defaults to 1.
A value above 1 provides more stable estimates of variable importance and
allows the calculation of standard errors measuring the uncertainty from permuting.
Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_metric">metric</code></td>
<td>
<p>An optional named list of length one with a metric as element.
Defaults to the first metric in the flashlight. The metric needs to be a function
with at least four arguments: actual, predicted, case weights w and <code>...</code>.
Irrelevant for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_lower_is_better">lower_is_better</code></td>
<td>
<p>Logical flag indicating if lower values in the metric
are better or not. If set to <code>FALSE</code>, the increase in metric is multiplied by -1.
Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_importance_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied?
Default is <code>FALSE</code>. Not uses for <code>type = "shap"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Algorithm 1, the minimum required elements in the
(multi-)flashlight are &quot;y&quot;, &quot;predict_function&quot;, &quot;model&quot;, &quot;data&quot; and &quot;metrics&quot;.
For Algorithm 2, the only required element is &quot;shap&quot;. Call <code><a href="#topic+add_shap">add_shap()</a></code> once to
add such object.
</p>
<p>Note: The values of the permutation Algorithm 1. are on the scale
of the selected metric. For SHAP Algorithm 2, the values are on the scale
of absolute values of the predictions.
</p>


<h3>Value</h3>

<p>An object of class &quot;light_importance&quot; with the following elements:
</p>

<ul>
<li> <p><code>data</code> A tibble with results. Can be used to build fully customized visualizations.
Column names can be controlled by <code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code> Same as input <code>by</code>.
</p>
</li>
<li> <p><code>type</code> Same as input <code>type</code>. For information only.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_importance(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_importance(flashlight)</code>: Variable importance for a flashlight.
</p>
</li>
<li> <p><code>light_importance(multiflashlight)</code>: Variable importance for a multiflashlight.
</p>
</li></ul>


<h3>References</h3>

<p>Fisher A., Rudin C., Dominici F. (2018). All Models are Wrong but many are Useful:
Variable Importance for Black-Box, Proprietary, or Misspecified Prediction
Models, using Model Class Reliance. Arxiv.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+most_important">most_important()</a></code>, <code><a href="#topic+plot.light_importance">plot.light_importance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)
fl &lt;- flashlight(model = fit, label = "full", data = iris, y = "Sepal.Length")
light_importance(fl)
</code></pre>

<hr>
<h2 id='light_interaction'>Interaction Strength</h2><span id='topic+light_interaction'></span><span id='topic+light_interaction.default'></span><span id='topic+light_interaction.flashlight'></span><span id='topic+light_interaction.multiflashlight'></span>

<h3>Description</h3>

<p>This function provides Friedman's H statistic for overall interaction strength per
covariable as well as its version for pairwise interactions, see the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_interaction(x, ...)

## Default S3 method:
light_interaction(x, ...)

## S3 method for class 'flashlight'
light_interaction(
  x,
  data = x$data,
  by = x$by,
  v = NULL,
  pairwise = FALSE,
  type = c("H", "ice"),
  normalize = TRUE,
  take_sqrt = TRUE,
  grid_size = 200L,
  n_max = 1000L,
  seed = NULL,
  use_linkinv = FALSE,
  ...
)

## S3 method for class 'multiflashlight'
light_interaction(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_interaction_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_v">v</code></td>
<td>
<p>Vector of variable names to be assessed.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_pairwise">pairwise</code></td>
<td>
<p>Should overall interaction strength per variable be shown or
pairwise interactions? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_type">type</code></td>
<td>
<p>Are measures based on Friedman's H statistic (&quot;H&quot;) or on &quot;ice&quot; curves?
Option &quot;ice&quot; is available only if <code>pairwise = FALSE</code>.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_normalize">normalize</code></td>
<td>
<p>Should the variances explained be normalized?
Default is <code>TRUE</code> in order to reproduce Friedman's H statistic.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_take_sqrt">take_sqrt</code></td>
<td>
<p>In order to reproduce Friedman's H statistic,
resulting values are root transformed. Set to <code>FALSE</code> if squared values
should be returned.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_grid_size">grid_size</code></td>
<td>
<p>Grid size used to form the outer product. Will be randomly
picked from data (after limiting to <code>n_max</code>).</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of data rows to consider. Will be randomly picked
from <code>data</code> if necessary.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_seed">seed</code></td>
<td>
<p>An integer random seed used for subsampling.</p>
</td></tr>
<tr><td><code id="light_interaction_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a fast alternative to assess overall interaction strength, with <code>type = "ice"</code>,
the function offers a method based on centered ICE curves:
The corresponding H* statistic measures how much of the variability of a c-ICE curve
is unexplained by the main effect. As for Friedman's H statistic, it can be useful
to consider unnormalized or squared values (see Details below).
</p>
<p>Friedman's H statistic relates the interaction strength of a variable (pair)
to the total effect strength of that variable (pair) based on partial dependence
curves. Due to this normalization step, even variables with low importance can
have high values for H. The function <code><a href="#topic+light_interaction">light_interaction()</a></code> offers the option
to skip normalization in order to have a more direct comparison of the interaction
effects across variable (pairs). The values of such unnormalized H statistics are
on the scale of the response variable. Use <code>take_sqrt = FALSE</code> to return
squared values of H. Note that in general, for each variable (pair), predictions
are done on a data set with <code>grid_size * n_max</code>, so be cautious with
increasing the defaults too much. Still, even with larger <code>grid_size</code>
and <code>n_max</code>, there might be considerable variation across different runs,
thus, setting a seed is recommended.
</p>
<p>The minimum required elements in the (multi-) flashlight are a &quot;predict_function&quot;,
&quot;model&quot;, and &quot;data&quot;.
</p>


<h3>Value</h3>

<p>An object of class &quot;light_importance&quot; with the following elements:
</p>

<ul>
<li> <p><code>data</code> A tibble containing the results. Can be used to build fully customized
visualizations. Column names can be controlled by
<code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code> Same as input <code>by</code>.
</p>
</li>
<li> <p><code>type</code> Same as input <code>type</code>. For information only.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_interaction(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_interaction(flashlight)</code>: Interaction strengths for a flashlight object.
</p>
</li>
<li> <p><code>light_interaction(multiflashlight)</code>: for a multiflashlight object.
</p>
</li></ul>


<h3>References</h3>

<p>Friedman, J. H. and Popescu, B. E. (2008). &quot;Predictive learning via rule
ensembles.&quot; The Annals of Applied Statistics. JSTOR, 91654.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_ice">light_ice()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c("Petal.Length", "Petal.Width")
fit_add &lt;- stats::lm(Sepal.Length ~ Petal.Length + Petal.Width, data = iris)
fit_nonadd &lt;- stats::lm(Sepal.Length ~ Petal.Length * Petal.Width, data = iris)
fl_add &lt;- flashlight(model = fit_add, label = "additive")
fl_nonadd &lt;- flashlight(model = fit_nonadd, label = "nonadditive")
fls &lt;- multiflashlight(list(fl_add, fl_nonadd), data = iris)
plot(st &lt;- light_interaction(fls, v = v), fill = "darkgreen")
plot(light_interaction(fls, v = v, pairwise = TRUE), fill = "darkgreen")
plot(st &lt;- light_interaction(fls, v = v, by = "Species"), fill = "darkgreen")
</code></pre>

<hr>
<h2 id='light_performance'>Model Performance of Flashlight</h2><span id='topic+light_performance'></span><span id='topic+light_performance.default'></span><span id='topic+light_performance.flashlight'></span><span id='topic+light_performance.multiflashlight'></span>

<h3>Description</h3>

<p>Calculates performance of a flashlight with respect to one or more
performance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_performance(x, ...)

## Default S3 method:
light_performance(x, ...)

## S3 method for class 'flashlight'
light_performance(
  x,
  data = x$data,
  by = x$by,
  metrics = x$metrics,
  use_linkinv = FALSE,
  ...
)

## S3 method for class 'multiflashlight'
light_performance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_performance_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_performance_+3A_...">...</code></td>
<td>
<p>Arguments passed from or to other functions.</p>
</td></tr>
<tr><td><code id="light_performance_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="light_performance_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.
Will overwrite <code>x$by</code>.</p>
</td></tr>
<tr><td><code id="light_performance_+3A_metrics">metrics</code></td>
<td>
<p>An optional named list with metrics. Each metric takes at least
four arguments: actual, predicted, case weights w and <code>...</code>.</p>
</td></tr>
<tr><td><code id="light_performance_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimal required elements in the (multi-) flashlight are &quot;y&quot;, &quot;predict_function&quot;,
&quot;model&quot;, &quot;data&quot; and &quot;metrics&quot;. The latter two can also directly be passed to
<code><a href="#topic+light_performance">light_performance()</a></code>. Note that by default, no retransformation function is applied.
</p>


<h3>Value</h3>

<p>An object of class &quot;light_performance&quot; with the following elements:
</p>

<ul>
<li> <p><code>data</code>: A tibble containing the results. Can be used to build fully customized
visualizations. Column names can be controlled by
<code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code> Same as input <code>by</code>.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_performance(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_performance(flashlight)</code>: Model performance of flashlight object.
</p>
</li>
<li> <p><code>light_performance(multiflashlight)</code>: Model performance of multiflashlight object.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+plot.light_performance">plot.light_performance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "lm", data = iris, y = "Sepal.Length")
light_performance(fl)
light_performance(fl, by = "Species")
</code></pre>

<hr>
<h2 id='light_profile'>Partial Dependence and other Profiles</h2><span id='topic+light_profile'></span><span id='topic+light_profile.default'></span><span id='topic+light_profile.flashlight'></span><span id='topic+light_profile.multiflashlight'></span>

<h3>Description</h3>

<p>Calculates different types of profiles across covariable values.
By default, partial dependence profiles are calculated (see Friedman).
Other options are profiles of ALE (accumulated local effects, see Apley),
response, predicted values (&quot;M plots&quot; or &quot;marginal plots&quot;, see Apley),
residuals, and shap. The results are aggregated either by (weighted) means or by
(weighted) quartiles.
</p>
<p>Note that ALE profiles are calibrated by (weighted) average predictions.
In contrast to the suggestions in Apley, we calculate ALE profiles of factors
in the same order as the factor levels.
They are not being reordered based on similiarity of other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_profile(x, ...)

## Default S3 method:
light_profile(x, ...)

## S3 method for class 'flashlight'
light_profile(
  x,
  v = NULL,
  data = NULL,
  by = x$by,
  type = c("partial dependence", "ale", "predicted", "response", "residual", "shap"),
  stats = c("mean", "quartiles"),
  breaks = NULL,
  n_bins = 11L,
  cut_type = c("equal", "quantile"),
  use_linkinv = TRUE,
  counts = TRUE,
  counts_weighted = FALSE,
  v_labels = TRUE,
  pred = NULL,
  pd_evaluate_at = NULL,
  pd_grid = NULL,
  pd_indices = NULL,
  pd_n_max = 1000L,
  pd_seed = NULL,
  pd_center = c("no", "first", "middle", "last", "mean", "0"),
  ale_two_sided = FALSE,
  ...
)

## S3 method for class 'multiflashlight'
light_profile(
  x,
  v = NULL,
  data = NULL,
  type = c("partial dependence", "ale", "predicted", "response", "residual", "shap"),
  breaks = NULL,
  n_bins = 11L,
  cut_type = c("equal", "quantile"),
  pd_evaluate_at = NULL,
  pd_grid = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_profile_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+cut3">cut3()</a></code> in forming the
cut breaks of the <code>v</code> variable.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_v">v</code></td>
<td>
<p>The variable name to be profiled.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>. Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_type">type</code></td>
<td>
<p>Type of the profile: Either &quot;partial dependence&quot;, &quot;ale&quot;, &quot;predicted&quot;,
&quot;response&quot;, &quot;residual&quot;, or &quot;shap&quot;.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_stats">stats</code></td>
<td>
<p>Statistic to calculate: &quot;mean&quot; or &quot;quartiles&quot;. For ALE profiles,
only &quot;mean&quot; makes sense.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_breaks">breaks</code></td>
<td>
<p>Cut breaks for a numeric <code>v</code>. Used to overwrite automatic binning via
<code>n_bins</code> and <code>cut_type</code>. Ignored if <code>v</code> is not numeric.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_n_bins">n_bins</code></td>
<td>
<p>Approximate number of unique values to evaluate for numeric <code>v</code>.
Ignored if <code>v</code> is not numeric or if <code>breaks</code> is specified.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_cut_type">cut_type</code></td>
<td>
<p>Should a numeric <code>v</code> be cut into &quot;equal&quot; or &quot;quantile&quot; bins?
Ignored if <code>v</code> is not numeric or if <code>breaks</code> is specified.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied? Default is <code>TRUE</code>.
Not used for type &quot;shap&quot;.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_counts">counts</code></td>
<td>
<p>Should observation counts be added?</p>
</td></tr>
<tr><td><code id="light_profile_+3A_counts_weighted">counts_weighted</code></td>
<td>
<p>If <code>counts = TRUE</code>: Should counts be weighted by the
case weights? If <code>TRUE</code>, the sum of <code>w</code> is returned by group.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_v_labels">v_labels</code></td>
<td>
<p>If <code>FALSE</code>, return group centers of <code>v</code> instead of labels.
Only relevant for types &quot;response&quot;, &quot;predicted&quot; or &quot;residual&quot; and if <code>v</code>
is being binned. In that case useful, for instance, if different flashlights
use different data sets and bin labels would not match.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_pred">pred</code></td>
<td>
<p>Optional vector with predictions (after application of inverse link).
Can be used to avoid recalculation of predictions over and over if the functions
is to be repeatedly called for different <code>v</code> and predictions are computationally
expensive to make. Not implemented for multiflashlight.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_pd_evaluate_at">pd_evaluate_at</code></td>
<td>
<p>Vector with values of <code>v</code> used to evaluate the profile.
Only relevant for type = &quot;partial dependence&quot; and &quot;ale&quot;.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_pd_grid">pd_grid</code></td>
<td>
<p>A <code>data.frame</code> with grid values, e.g., generated by <code><a href="base.html#topic+expand.grid">expand.grid()</a></code>.
Only used for type = &quot;partial dependence&quot;.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_pd_indices">pd_indices</code></td>
<td>
<p>A vector of row numbers to consider in calculating
partial dependence profiles and &quot;ale&quot;.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_pd_n_max">pd_n_max</code></td>
<td>
<p>Maximum number of ICE profiles to calculate (will be randomly
picked from <code>data</code>) for partial dependence and ALE.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_pd_seed">pd_seed</code></td>
<td>
<p>Integer random seed used to select ICE profiles for partial dependence
and ALE.</p>
</td></tr>
<tr><td><code id="light_profile_+3A_pd_center">pd_center</code></td>
<td>
<p>How should ICE curves be centered?
</p>

<ul>
<li><p> Default is &quot;no&quot;.
</p>
</li>
<li><p> Choose &quot;first&quot;, &quot;middle&quot;, or &quot;last&quot; to 0-center at specific evaluation points.
</p>
</li>
<li><p> Choose &quot;mean&quot; to center all profiles at the within-group means.
</p>
</li>
<li><p> Choose &quot;0&quot; to mean-center curves at 0. Only relevant for partial dependence.
</p>
</li></ul>
</td></tr>
<tr><td><code id="light_profile_+3A_ale_two_sided">ale_two_sided</code></td>
<td>
<p>If <code>TRUE</code>, <code>v</code> is continuous and <code>breaks</code>
are passed or being calculated, then two-sided derivatives are calculated
for ALE instead of left derivatives. More specifically: Usually, local effects
at value x are calculated using points in <code class="reqn">[x-e, x]</code>.
Set <code>ale_two_sided = TRUE</code> to use points in <code class="reqn">[x-e/2, x+e/2]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numeric covariables <code>v</code> with more than <code>n_bins</code> disjoint values
are binned into <code>n_bins</code> bins. Alternatively, <code>breaks</code> can be provided
to specify the binning. For partial dependence profiles
(and partly also ALE profiles), this behaviour can be overwritten either
by providing a vector of evaluation points (<code>pd_evaluate_at</code>) or an
evaluation <code>pd_grid</code>. By the latter we mean a data frame with column name(s)
with a (multi-)variate evaluation grid.
</p>
<p>For partial dependence, ALE, and prediction profiles, &quot;model&quot;, &quot;predict_function&quot;,
&quot;linkinv&quot; and &quot;data&quot; are required. For response profiles its &quot;y&quot;, &quot;linkinv&quot; and
&quot;data&quot;, and for shap profiles it is just &quot;shap&quot;. &quot;data&quot; can be passed on the fly.
</p>


<h3>Value</h3>

<p>An object of class &quot;light_profile&quot; with the following elements:
</p>

<ul>
<li> <p><code>data</code> A tibble containing results. Can be used to build fully customized
visualizations. Column names can be controlled by <code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code> Names of group by variable.
</p>
</li>
<li> <p><code>v</code> The variable(s) evaluated.
</p>
</li>
<li> <p><code>type</code> Same as input <code>type</code>. For information only.
</p>
</li>
<li> <p><code>stats</code> Same as input <code>stats</code>.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_profile(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_profile(flashlight)</code>: Profiles for flashlight.
</p>
</li>
<li> <p><code>light_profile(multiflashlight)</code>: Profiles for multiflashlight.
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Friedman J. H. (2001). Greedy function approximation: A gradient boosting machine. The Annals of Statistics, 29:11891232.
</p>
</li>
<li><p> Apley D. W. (2016). Visualizing the effects of predictor variables in black box supervised learning models.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+light_effects">light_effects()</a></code>, <code><a href="#topic+plot.light_profile">plot.light_profile()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
light_profile(fl, v = "Species")
light_profile(fl, v = "Petal.Width", type = "residual")
</code></pre>

<hr>
<h2 id='light_profile2d'>2D Partial Dependence and other 2D Profiles</h2><span id='topic+light_profile2d'></span><span id='topic+light_profile2d.default'></span><span id='topic+light_profile2d.flashlight'></span><span id='topic+light_profile2d.multiflashlight'></span>

<h3>Description</h3>

<p>Calculates different types of 2D-profiles across two variables.
By default, partial dependence profiles are calculated (see Friedman).
Other options are response, predicted values, residuals, and shap.
The results are aggregated by (weighted) means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_profile2d(x, ...)

## Default S3 method:
light_profile2d(x, ...)

## S3 method for class 'flashlight'
light_profile2d(
  x,
  v = NULL,
  data = NULL,
  by = x$by,
  type = c("partial dependence", "predicted", "response", "residual", "shap"),
  breaks = NULL,
  n_bins = 11L,
  cut_type = "equal",
  use_linkinv = TRUE,
  counts = TRUE,
  counts_weighted = FALSE,
  pd_evaluate_at = NULL,
  pd_grid = NULL,
  pd_indices = NULL,
  pd_n_max = 1000L,
  pd_seed = NULL,
  ...
)

## S3 method for class 'multiflashlight'
light_profile2d(
  x,
  v = NULL,
  data = NULL,
  type = c("partial dependence", "predicted", "response", "residual", "shap"),
  breaks = NULL,
  n_bins = 11L,
  cut_type = "equal",
  pd_evaluate_at = NULL,
  pd_grid = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_profile2d_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+cut3">cut3()</a></code> in forming
the cut breaks of the <code>v</code> variables. Not relevant for partial dependence profiles.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_v">v</code></td>
<td>
<p>A vector of exactly two variable names to be profiled.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>. Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_type">type</code></td>
<td>
<p>Type of the profile: Either &quot;partial dependence&quot;, &quot;predicted&quot;,
&quot;response&quot;, &quot;residual&quot;, or &quot;shap&quot;.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_breaks">breaks</code></td>
<td>
<p>Named list of cut breaks specifying how to bin one or more numeric
variables. Used to overwrite automatic binning via <code>n_bins</code> and <code>cut_type</code>.
Ignored for non-numeric <code>v</code>.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_n_bins">n_bins</code></td>
<td>
<p>Approximate number of unique values to evaluate for numeric <code>v</code>.
Can be an unnamed vector of length 2 to distinguish between v.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_cut_type">cut_type</code></td>
<td>
<p>Should numeric <code>v</code> be cut into &quot;equal&quot; or &quot;quantile&quot; bins?
Can be an unnamed vector of length 2 to distinguish between v.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied?
Default is <code>TRUE</code>. Not used for type &quot;shap&quot;.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_counts">counts</code></td>
<td>
<p>Should observation counts be added?</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_counts_weighted">counts_weighted</code></td>
<td>
<p>If <code>counts</code> is TRUE: Should counts be weighted by the
case weights? If <code>TRUE</code>, the sum of <code>w</code> is returned by group.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_pd_evaluate_at">pd_evaluate_at</code></td>
<td>
<p>An named list of evaluation points for one or more variables.
Only relevant for type = &quot;partial dependence&quot;.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_pd_grid">pd_grid</code></td>
<td>
<p>An evaluation <code>data.frame</code> with exactly two columns,
e.g., generated by <code><a href="base.html#topic+expand.grid">expand.grid()</a></code>. Only used for type = &quot;partial dependence&quot;.
Offers maximal flexibility.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_pd_indices">pd_indices</code></td>
<td>
<p>A vector of row numbers to consider in calculating partial
dependence profiles. Only used for type = &quot;partial dependence&quot;.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_pd_n_max">pd_n_max</code></td>
<td>
<p>Maximum number of ICE profiles to calculate
(will be randomly picked from <code>data</code>). Only used for type = &quot;partial dependence&quot;.</p>
</td></tr>
<tr><td><code id="light_profile2d_+3A_pd_seed">pd_seed</code></td>
<td>
<p>Integer random seed used to select ICE profiles.
Only used for type = &quot;partial dependence&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different binning options are available, see arguments below.
For high resolution partial dependence plots, it might be necessary to specify
<code>breaks</code>, <code>pd_evaluate_at</code> or <code>pd_grid</code> in order to avoid empty parts
in the plot. A high value of <code>n_bins</code> might not have the desired effect as it
internally capped at the number of distinct values of a variable.
</p>
<p>For partial dependence and prediction profiles, &quot;model&quot;, &quot;predict_function&quot;,
&quot;linkinv&quot; and &quot;data&quot; are required. For response profiles it is &quot;y&quot;, &quot;linkinv&quot;
and &quot;data&quot; and for shap profiles it is just &quot;shap&quot;. &quot;data&quot; can be passed on the fly.
</p>


<h3>Value</h3>

<p>An object of class &quot;light_profile2d&quot; with the following elements:
</p>

<ul>
<li> <p><code>data</code> A tibble containing results. Can be used to build fully customized
visualizations. Column names can be controlled by
<code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code> Names of group by variables.
</p>
</li>
<li> <p><code>v</code> The two variable names evaluated.
</p>
</li>
<li> <p><code>type</code> Same as input <code>type</code>. For information only.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_profile2d(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_profile2d(flashlight)</code>: 2D profiles for flashlight.
</p>
</li>
<li> <p><code>light_profile2d(multiflashlight)</code>: 2D profiles for multiflashlight.
</p>
</li></ul>


<h3>References</h3>

<p>Friedman J. H. (2001). Greedy function approximation: A gradient boosting machine.
The Annals of Statistics, 29:11891232.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_profile">light_profile()</a></code>, <code><a href="#topic+plot.light_profile2d">plot.light_profile2d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
light_profile2d(fl, v = c("Petal.Length", "Species"))
</code></pre>

<hr>
<h2 id='light_recode'>Recode Factor Columns</h2><span id='topic+light_recode'></span><span id='topic+light_recode.default'></span><span id='topic+light_recode.light'></span>

<h3>Description</h3>

<p>Recodes factor levels of columns in data slots of an object of class &quot;light&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_recode(x, ...)

## Default S3 method:
light_recode(x, ...)

## S3 method for class 'light'
light_recode(x, what, levels, labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_recode_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light&quot;.</p>
</td></tr>
<tr><td><code id="light_recode_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>factor</code>.</p>
</td></tr>
<tr><td><code id="light_recode_+3A_what">what</code></td>
<td>
<p>Column identifier to be recoded, e.g., &quot;type&quot;. For backward
compatibility, also the option identifier (e.g. &quot;type_name&quot;) can be passed.</p>
</td></tr>
<tr><td><code id="light_recode_+3A_levels">levels</code></td>
<td>
<p>Current levels/values of <code>type_name</code> column (in desired order).</p>
</td></tr>
<tr><td><code id="light_recode_+3A_labels">labels</code></td>
<td>
<p>New levels of <code>type_name</code> column in same order as <code>levels</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with new factor levels of <code>type_name</code> column.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_recode(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_recode(light)</code>: Recoding factors in data slots of &quot;light&quot; object.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+plot.light_effects">plot.light_effects()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_full &lt;- lm(Sepal.Length ~ ., data = iris)
fit_part &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)
mod_full &lt;- flashlight(
  model = fit_full, label = "full", data = iris, y = "Sepal.Length"
)
mod_part &lt;- flashlight(
  model = fit_part, label = "part", data = iris, y = "Sepal.Length"
)
mods &lt;- multiflashlight(list(mod_full, mod_part))
eff &lt;- light_effects(mods, v = "Species")
eff &lt;- light_recode(
  eff,
  what = "type_name",
  levels = c("response", "predicted", "partial dependence", "ale"),
  labels = c("Observed", "Fitted", "PD", "ALE")
)
plot(eff, use = "all")
</code></pre>

<hr>
<h2 id='light_scatter'>Scatter</h2><span id='topic+light_scatter'></span><span id='topic+light_scatter.default'></span><span id='topic+light_scatter.flashlight'></span><span id='topic+light_scatter.multiflashlight'></span>

<h3>Description</h3>

<p>This function prepares values for drawing a scatter plot of predicted values,
responses, residuals, or SHAP values against a selected variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_scatter(x, ...)

## Default S3 method:
light_scatter(x, ...)

## S3 method for class 'flashlight'
light_scatter(
  x,
  v,
  data = x$data,
  by = x$by,
  type = c("predicted", "response", "residual", "shap"),
  use_linkinv = TRUE,
  n_max = 400,
  seed = NULL,
  ...
)

## S3 method for class 'multiflashlight'
light_scatter(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_scatter_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flashlight&quot; or &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="light_scatter_+3A_...">...</code></td>
<td>
<p>Further arguments passed from or to other methods.</p>
</td></tr>
<tr><td><code id="light_scatter_+3A_v">v</code></td>
<td>
<p>The variable name to be shown on the x-axis.</p>
</td></tr>
<tr><td><code id="light_scatter_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code>. Not relevant for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_scatter_+3A_by">by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.</p>
</td></tr>
<tr><td><code id="light_scatter_+3A_type">type</code></td>
<td>
<p>Type of the profile: Either &quot;predicted&quot;, &quot;response&quot;, &quot;residual&quot;,
or &quot;shap&quot;.</p>
</td></tr>
<tr><td><code id="light_scatter_+3A_use_linkinv">use_linkinv</code></td>
<td>
<p>Should retransformation function be applied? Default is <code>TRUE</code>.
Not used for <code>type = "shap"</code>.</p>
</td></tr>
<tr><td><code id="light_scatter_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of data rows to select. Will be randomly picked from the
relevant data.</p>
</td></tr>
<tr><td><code id="light_scatter_+3A_seed">seed</code></td>
<td>
<p>An integer random seed used for subsampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;light_scatter&quot; with the following elements:
</p>

<ul>
<li> <p><code>data</code>: A tibble with results. Can be used to build fully customized
visualizations. Column names can be controlled by
<code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code>: Same as input <code>by</code>.
</p>
</li>
<li> <p><code>v</code>: The variable evaluated.
</p>
</li>
<li> <p><code>type</code>: Same as input <code>type</code>. For information only.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_scatter(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_scatter(flashlight)</code>: Variable profile for a flashlight.
</p>
</li>
<li> <p><code>light_scatter(multiflashlight)</code>: light_scatter for a multiflashlight.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+plot.light_scatter">plot.light_scatter()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_a &lt;- lm(Sepal.Length ~ . -Petal.Length, data = iris)
fit_b &lt;- lm(Sepal.Length ~ ., data = iris)
fl_a &lt;- flashlight(model = fit_a, label = "without Petal.Length")
fl_b &lt;- flashlight(model = fit_b, label = "all")
fls &lt;- multiflashlight(list(fl_a, fl_b), data = iris, y = "Sepal.Length")
pr &lt;- light_scatter(fls, v = "Petal.Length")
plot(
  light_scatter(fls, "Petal.Length", by = "Species", type = "residual"),
  alpha = 0.2
)
</code></pre>

<hr>
<h2 id='most_important'>Most Important Variables.</h2><span id='topic+most_important'></span><span id='topic+most_important.default'></span><span id='topic+most_important.light_importance'></span>

<h3>Description</h3>

<p>Returns the most important variable names sorted descendingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>most_important(x, top_m = Inf)

## Default S3 method:
most_important(x, top_m = Inf)

## S3 method for class 'light_importance'
most_important(x, top_m = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="most_important_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_importance&quot;.</p>
</td></tr>
<tr><td><code id="most_important_+3A_top_m">top_m</code></td>
<td>
<p>Maximum number of important variables to be returned.
Defaults to <code>Inf</code>, i.e., return all variables in descending order of importance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of variable names sorted in descending order by importance.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>most_important(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>most_important(light_importance)</code>: Extracts most important variables from an object of class
&quot;light_importance&quot;.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+light_importance">light_importance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "ols", data = iris, y = "Sepal.Length")
(imp &lt;- light_importance(fl, seed = 4))
most_important(imp)
most_important(imp, 2)
</code></pre>

<hr>
<h2 id='multiflashlight'>Create or Update a multiflashlight</h2><span id='topic+multiflashlight'></span><span id='topic+multiflashlight.default'></span><span id='topic+multiflashlight.flashlight'></span><span id='topic+multiflashlight.list'></span><span id='topic+multiflashlight.multiflashlight'></span>

<h3>Description</h3>

<p>Combines a list of flashlights to an object of class &quot;multiflashlight&quot;
and/or updates a multiflashlight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiflashlight(x, ...)

## Default S3 method:
multiflashlight(x, ...)

## S3 method for class 'flashlight'
multiflashlight(x, ...)

## S3 method for class 'list'
multiflashlight(x, ...)

## S3 method for class 'multiflashlight'
multiflashlight(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiflashlight_+3A_x">x</code></td>
<td>
<p>An object of class &quot;multiflashlight&quot;, &quot;flashlight&quot; or a list of flashlights.</p>
</td></tr>
<tr><td><code id="multiflashlight_+3A_...">...</code></td>
<td>
<p>Optional arguments in the flashlights to update, see examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;multiflashlight&quot; (a named list of flashlight objects).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>multiflashlight(default)</code>: Used to create a flashlight object.
No <code>x</code> has to be passed in this case.
</p>
</li>
<li> <p><code>multiflashlight(flashlight)</code>: Updates an existing flashlight object and turns
into a multiflashlight.
</p>
</li>
<li> <p><code>multiflashlight(list)</code>: Creates (and updates) a multiflashlight from a list
of flashlights.
</p>
</li>
<li> <p><code>multiflashlight(multiflashlight)</code>: Updates an object of class &quot;multiflashlight&quot;.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+flashlight">flashlight()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_lm &lt;- lm(Sepal.Length ~ ., data = iris)
fit_glm &lt;- glm(Sepal.Length ~ ., family = Gamma(link = log), data = iris)
mod_lm &lt;- flashlight(model = fit_lm, label = "lm")
mod_glm &lt;- flashlight(model = fit_glm, label = "glm")
(mods &lt;- multiflashlight(list(mod_lm, mod_glm)))
</code></pre>

<hr>
<h2 id='plot_counts'>DEPRECATED - Add Counts to Effects Plot</h2><span id='topic+plot_counts'></span>

<h3>Description</h3>

<p>Add counts as labelled bar plot on top of light_effects plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_counts(
  p,
  x,
  text_size = 3,
  facet_scales = "free_x",
  show_labels = TRUE,
  big.mark = "'",
  scientific = FALSE,
  digits = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_counts_+3A_p">p</code></td>
<td>
<p>The result of <code><a href="#topic+plot.light_effects">plot.light_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_effects&quot;.</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_text_size">text_size</code></td>
<td>
<p>Size of count labels.</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_facet_scales">facet_scales</code></td>
<td>
<p>Scales argument passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_show_labels">show_labels</code></td>
<td>
<p>Should count labels be added as text?</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_big.mark">big.mark</code></td>
<td>
<p>Parameter passed to <code><a href="base.html#topic+format">format()</a></code> the labels. Default is &quot;'&quot;.</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_scientific">scientific</code></td>
<td>
<p>Parameter passed to <code><a href="base.html#topic+format">format()</a></code> the labels. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_digits">digits</code></td>
<td>
<p>Used to round the labels. Default is 0.</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental. Uses package ggpubr to rearrange the figure.
Thus, the resulting plot cannot be easily modified.
Furthermore, adding counts only works if the legend in <code><a href="#topic+plot.light_effects">plot.light_effects()</a></code>
is not placed on the left or right side of the plot.
It has to be placed inside or at the bottom.
</p>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.light_effects">plot.light_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
x &lt;- light_effects(fl, v = "Species")
plot_counts(plot(x), x, width = 0.3, alpha = 0.2)
</code></pre>

<hr>
<h2 id='plot.light_breakdown'>Visualize Variable Contribution Breakdown for Single Observation</h2><span id='topic+plot.light_breakdown'></span>

<h3>Description</h3>

<p>Minimal visualization of an object of class &quot;light_breakdown&quot; as waterfall plot.
The object returned is of class &quot;ggplot&quot; and can be further customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light_breakdown'
plot(x, facet_scales = "free", facet_ncol = 1, rotate_x = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.light_breakdown_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_breakdown&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_breakdown_+3A_facet_scales">facet_scales</code></td>
<td>
<p>Scales argument passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.light_breakdown_+3A_facet_ncol">facet_ncol</code></td>
<td>
<p><code>ncol</code> argument passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.light_breakdown_+3A_rotate_x">rotate_x</code></td>
<td>
<p>Should x axis labels be rotated by 45 degrees?</p>
</td></tr>
<tr><td><code id="plot.light_breakdown_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_label()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The waterfall plot is to be read from top to bottom.
The first line describes the (weighted) average prediction in the query data
used to start with. Then, each additional line shows how the prediction changes
due to the impact of the corresponding variable.
The last line finally shows the original prediction of the selected observation.
Multiple flashlights are shown in different facets.
Positive and negative impacts are visualized with different colors.
</p>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_breakdown">light_breakdown()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ . + Petal.Length:Species, data = iris)
fl &lt;- flashlight(model = fit, label = "lm", data = iris, y = "Sepal.Length")
plot(light_breakdown(fl, new_obs = iris[1, ]))
</code></pre>

<hr>
<h2 id='plot.light_effects'>Visualize Multiple Types of Profiles Together</h2><span id='topic+plot.light_effects'></span>

<h3>Description</h3>

<p>Visualizes response-, prediction-, partial dependence, and/or ALE profiles
of a (multi-)flashlight with respect to a covariable <code>v</code>.
Different flashlights or a single flashlight with one &quot;by&quot; variable are separated
by a facet wrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light_effects'
plot(
  x,
  use = c("response", "predicted", "pd"),
  zero_counts = TRUE,
  size_factor = 1,
  facet_scales = "free_x",
  facet_nrow = 1L,
  rotate_x = TRUE,
  show_points = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.light_effects_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_effects&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_effects_+3A_use">use</code></td>
<td>
<p>A vector of elements to show. Any subset of (&quot;response&quot;, &quot;predicted&quot;,
&quot;pd&quot;, &quot;ale&quot;) or &quot;all&quot;. Defaults to all except &quot;ale&quot;</p>
</td></tr>
<tr><td><code id="plot.light_effects_+3A_zero_counts">zero_counts</code></td>
<td>
<p>Logical flag if 0 count levels should be shown on the x axis.</p>
</td></tr>
<tr><td><code id="plot.light_effects_+3A_size_factor">size_factor</code></td>
<td>
<p>Factor used to enlarge default <code>size/linewidth</code> in
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> and <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.light_effects_+3A_facet_scales">facet_scales</code></td>
<td>
<p>Scales argument passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.light_effects_+3A_facet_nrow">facet_nrow</code></td>
<td>
<p>Number of rows in <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.
Must be 1 if <code><a href="#topic+plot_counts">plot_counts()</a></code> should be used.</p>
</td></tr>
<tr><td><code id="plot.light_effects_+3A_rotate_x">rotate_x</code></td>
<td>
<p>Should x axis labels be rotated by 45 degrees?</p>
</td></tr>
<tr><td><code id="plot.light_effects_+3A_show_points">show_points</code></td>
<td>
<p>Should points be added to the line (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.light_effects_+3A_...">...</code></td>
<td>
<p>Further arguments passed to geoms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_effects">light_effects()</a></code>, <code><a href="#topic+plot_counts">plot_counts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
plot(light_effects(fl, v = "Species"))
</code></pre>

<hr>
<h2 id='plot.light_global_surrogate'>Plot Global Surrogate Trees</h2><span id='topic+plot.light_global_surrogate'></span>

<h3>Description</h3>

<p>Use <code><a href="rpart.plot.html#topic+rpart.plot">rpart.plot::rpart.plot()</a></code> to visualize trees fitted by
<code><a href="#topic+light_global_surrogate">light_global_surrogate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light_global_surrogate'
plot(x, type = 5, auto_main = TRUE, mfrow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.light_global_surrogate_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_global_surrogate&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_global_surrogate_+3A_type">type</code></td>
<td>
<p>Plot type, see help of <code><a href="rpart.plot.html#topic+rpart.plot">rpart.plot::rpart.plot()</a></code>. Default is 5.</p>
</td></tr>
<tr><td><code id="plot.light_global_surrogate_+3A_auto_main">auto_main</code></td>
<td>
<p>Automatic plot titles (only if multiple trees are shown).</p>
</td></tr>
<tr><td><code id="plot.light_global_surrogate_+3A_mfrow">mfrow</code></td>
<td>
<p>If multiple trees are shown in the same figure:
what value of <code>mfrow</code> to use in <code><a href="graphics.html#topic+par">graphics::par()</a></code>?</p>
</td></tr>
<tr><td><code id="plot.light_global_surrogate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="rpart.plot.html#topic+rpart.plot">rpart.plot::rpart.plot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_global_surrogate">light_global_surrogate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
x &lt;- flashlight(model = fit, label = "lm", data = iris)
plot(light_global_surrogate(x))
</code></pre>

<hr>
<h2 id='plot.light_ice'>Visualize ICE profiles</h2><span id='topic+plot.light_ice'></span>

<h3>Description</h3>

<p>Minimal visualization of an object of class &quot;light_ice&quot; as <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>.
The object returned is of class &quot;ggplot&quot; and can be further customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light_ice'
plot(x, facet_scales = "fixed", rotate_x = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.light_ice_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_ice&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_ice_+3A_facet_scales">facet_scales</code></td>
<td>
<p>Scales argument passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.light_ice_+3A_rotate_x">rotate_x</code></td>
<td>
<p>Should x axis labels be rotated by 45 degrees?</p>
</td></tr>
<tr><td><code id="plot.light_ice_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each observation is visualized by a line. The first &quot;by&quot; variable is represented
by the color, a second &quot;by&quot; variable or a multiflashlight by facets.
</p>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_ice">light_ice()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_full &lt;- lm(Sepal.Length ~ ., data = iris)
fit_part &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)
mod_full &lt;- flashlight(model = fit_full, label = "full", data = iris)
mod_part &lt;- flashlight(model = fit_part, label = "part", data = iris)
mods &lt;- multiflashlight(list(mod_full, mod_part))
plot(light_ice(mod_full, v = "Species"), alpha = 0.2)
indices &lt;- (1:15) * 10
plot(light_ice(mods, v = "Species", indices = indices))
plot(light_ice(mods, v = "Species", indices = indices, center = "first"))
plot(light_ice(mods, v = "Petal.Width", by = "Species", n_bins = 5, indices = indices))
</code></pre>

<hr>
<h2 id='plot.light_importance'>Visualize Variable Importance</h2><span id='topic+plot.light_importance'></span>

<h3>Description</h3>

<p>Minimal visualization of an object of class &quot;light_importance&quot; via
<code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code>.
If available, standard errors are added by <code><a href="ggplot2.html#topic+geom_linerange">ggplot2::geom_errorbar()</a></code>.
The object returned is of class &quot;ggplot&quot; and can be further customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light_importance'
plot(
  x,
  top_m = Inf,
  swap_dim = FALSE,
  facet_scales = "fixed",
  rotate_x = FALSE,
  error_bars = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.light_importance_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_importance&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_importance_+3A_top_m">top_m</code></td>
<td>
<p>Maximum number of important variables to be returned.</p>
</td></tr>
<tr><td><code id="plot.light_importance_+3A_swap_dim">swap_dim</code></td>
<td>
<p>If multiflashlight and one &quot;by&quot; variable or single flashlight with
two &quot;by&quot; variables, swap the role of dodge/fill variable and facet variable.
If multiflashlight or one &quot;by&quot; variable, use facets instead of colors.</p>
</td></tr>
<tr><td><code id="plot.light_importance_+3A_facet_scales">facet_scales</code></td>
<td>
<p>Scales argument passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.light_importance_+3A_rotate_x">rotate_x</code></td>
<td>
<p>Should x axis labels be rotated by 45 degrees?</p>
</td></tr>
<tr><td><code id="plot.light_importance_+3A_error_bars">error_bars</code></td>
<td>
<p>Should error bars be added? Defaults to <code>TRUE</code>.
Only available if <code><a href="#topic+light_importance">light_importance()</a></code> was run with multiple permutations
by setting <code>m_repetitions</code> &gt; 1.</p>
</td></tr>
<tr><td><code id="plot.light_importance_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is organized as a bar plot with variable names as x-aesthetic.
Up to two additional dimensions (multiflashlight and one &quot;by&quot; variable or single
flashlight with two &quot;by&quot; variables) can be visualized by facetting and dodge/fill.
Set <code>swap_dim = FALSE</code> to revert the role of these two dimensions.
One single additional dimension is visualized by a facet wrap,
or - if <code>swap_dim = FALSE</code> - by dodge/fill.
</p>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_importance">light_importance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_full &lt;- lm(Sepal.Length ~ ., data = iris)
fit_part &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)
mod_full &lt;- flashlight(model = fit_full, label = "full", data = iris, y = "Sepal.Length")
mod_part &lt;- flashlight(model = fit_part, label = "part", data = iris, y = "Sepal.Length")
mods &lt;- multiflashlight(list(mod_full, mod_part), by = "Species")
plot(light_importance(mod_part, m_repetitions = 4), fill = "darkred")
plot(light_importance(mods), swap_dim = TRUE)
</code></pre>

<hr>
<h2 id='plot.light_performance'>Visualize Model Performance</h2><span id='topic+plot.light_performance'></span>

<h3>Description</h3>

<p>Minimal visualization of an object of class &quot;light_performance&quot; as
<code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code>. The object returned has class &quot;ggplot&quot;,
and can be further customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light_performance'
plot(
  x,
  swap_dim = FALSE,
  geom = c("bar", "point"),
  facet_scales = "free_y",
  rotate_x = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.light_performance_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_performance&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_performance_+3A_swap_dim">swap_dim</code></td>
<td>
<p>Should representation of dimensions
(either two &quot;by&quot; variables or one &quot;by&quot; variable and multiflashlight)
of x aesthetic and dodge fill aesthetic be swapped? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.light_performance_+3A_geom">geom</code></td>
<td>
<p>Geometry of plot (either &quot;bar&quot; or &quot;point&quot;)</p>
</td></tr>
<tr><td><code id="plot.light_performance_+3A_facet_scales">facet_scales</code></td>
<td>
<p>Scales argument passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.light_performance_+3A_rotate_x">rotate_x</code></td>
<td>
<p>Should x axis labels be rotated by 45 degrees?</p>
</td></tr>
<tr><td><code id="plot.light_performance_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code> or
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is organized as a bar plot as follows:
For flashlights without &quot;by&quot; variable specified, a single bar is drawn.
Otherwise, the &quot;by&quot; variable (or the flashlight label if there is no &quot;by&quot; variable)
is represented by the &quot;x&quot; aesthetic.
</p>
<p>The flashlight label (in case of one &quot;by&quot; variable) is represented by dodged bars.
This strategy makes sure that performance of different flashlights can
be compared easiest. Set &quot;swap_dim = TRUE&quot; to revert the role of dodging and x
aesthetic. Different metrics are always represented by facets.
</p>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_performance">light_performance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "ols", data = iris, y = "Sepal.Length")
plot(light_performance(fl, by = "Species"), fill = "darkred")
</code></pre>

<hr>
<h2 id='plot.light_profile'>Visualize Profiles, e.g. Partial Dependence</h2><span id='topic+plot.light_profile'></span>

<h3>Description</h3>

<p>Minimal visualization of an object of class &quot;light_profile&quot;.
The object returned is of class &quot;ggplot&quot; and can be further customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light_profile'
plot(
  x,
  swap_dim = FALSE,
  facet_scales = "free_x",
  rotate_x = x$type != "partial dependence",
  show_points = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.light_profile_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_profile&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_profile_+3A_swap_dim">swap_dim</code></td>
<td>
<p>If multiflashlight and one &quot;by&quot; variable or
single flashlight with two &quot;by&quot; variables, swap the role of dodge/fill variable
and facet variable. If multiflashlight or one &quot;by&quot; variable,
use facets instead of colors.</p>
</td></tr>
<tr><td><code id="plot.light_profile_+3A_facet_scales">facet_scales</code></td>
<td>
<p>Scales argument passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.light_profile_+3A_rotate_x">rotate_x</code></td>
<td>
<p>Should x axis labels be rotated by 45 degrees?</p>
</td></tr>
<tr><td><code id="plot.light_profile_+3A_show_points">show_points</code></td>
<td>
<p>Should points be added to the line (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.light_profile_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> or
<code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either lines and points are plotted (if stats = &quot;mean&quot;) or quartile boxes.
If there is a &quot;by&quot; variable or a multiflashlight, this first dimension
is represented by color (or if <code>swap_dim = TRUE</code> by facets).
If there are two &quot;by&quot; variables or a multiflashlight with one &quot;by&quot; variable,
the first &quot;by&quot; variable is visualized as color, while the second one
or the multiflashlight is shown via facet (change with <code>swap_dim</code>).
</p>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_profile">light_profile()</a></code>, <code><a href="#topic+plot.light_effects">plot.light_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
plot(light_profile(fl, v = "Species"))
plot(light_profile(fl, v = "Petal.Width", by = "Species", evaluate_at = 2:4))
plot(light_profile(fl, v = "Petal.Width", type = "predicted"))
</code></pre>

<hr>
<h2 id='plot.light_profile2d'>Visualize 2D-Profiles, e.g., of Partial Dependence</h2><span id='topic+plot.light_profile2d'></span>

<h3>Description</h3>

<p>Minimal visualization of an object of class &quot;light_profile2d&quot;.
The object returned is of class &quot;ggplot&quot; and can be further customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light_profile2d'
plot(x, swap_dim = FALSE, rotate_x = TRUE, numeric_as_factor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.light_profile2d_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_profile2d&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_profile2d_+3A_swap_dim">swap_dim</code></td>
<td>
<p>Swap the <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code> dimensions.</p>
</td></tr>
<tr><td><code id="plot.light_profile2d_+3A_rotate_x">rotate_x</code></td>
<td>
<p>Should the x axis labels be rotated by 45 degrees? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.light_profile2d_+3A_numeric_as_factor">numeric_as_factor</code></td>
<td>
<p>Should numeric x and y values be converted to factors first?
Default is <code>FALSE</code>. Useful if <code>cut_type</code> was not set to &quot;equal&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_profile2d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_tile()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main geometry is <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_tile()</a></code>. Additional dimensions
(&quot;by&quot; variable(s) and/or multiflashlight) are represented by <code>facet_wrap/grid</code>.
For all types of profiles except &quot;partial dependence&quot;, it is natural to see
empty parts in the plot. These are combinations of the <code>v</code> variables that
do not appear in the data. Even for type &quot;partial dependence&quot;, such gaps can occur,
e.g. for <code>cut_type = "quantile"</code> or if <code>n_bins</code> are larger than the number
of distinct values of a <code>v</code> variable.
Such gaps can be suppressed by setting <code>numeric_as_factor = TRUE</code>
or by using the arguments <code>breaks</code>, <code>pd_evaluate_at</code> or <code>pd_grid</code> in
<code><a href="#topic+light_profile2d">light_profile2d()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_profile2d">light_profile2d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
plot(light_profile2d(fl, v = c("Petal.Length", "Species")))
</code></pre>

<hr>
<h2 id='plot.light_scatter'>Scatter Plot</h2><span id='topic+plot.light_scatter'></span>

<h3>Description</h3>

<p>Values are plotted against a variable. The object returned is of class &quot;ggplot&quot;
and can be further customized. To avoid overplotting, try <code>alpha = 0.2</code> or
<code>position = "jitter"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light_scatter'
plot(x, swap_dim = FALSE, facet_scales = "free_x", rotate_x = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.light_scatter_+3A_x">x</code></td>
<td>
<p>An object of class &quot;light_scatter&quot;.</p>
</td></tr>
<tr><td><code id="plot.light_scatter_+3A_swap_dim">swap_dim</code></td>
<td>
<p>If multiflashlight and one &quot;by&quot; variable, or single flashlight
with two &quot;by&quot; variables, swap the role of color variable and facet variable.
If multiflashlight or one &quot;by&quot; variable, use colors instead of facets.</p>
</td></tr>
<tr><td><code id="plot.light_scatter_+3A_facet_scales">facet_scales</code></td>
<td>
<p>Scales argument passed to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.light_scatter_+3A_rotate_x">rotate_x</code></td>
<td>
<p>Should x axis labels be rotated by 45 degrees?</p>
</td></tr>
<tr><td><code id="plot.light_scatter_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>. Typical arguments
would be <code>alpha = 0.2</code> or <code>position = "jitter"</code> to avoid overplotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;ggplot&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+light_scatter">light_scatter()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "ols", data = iris)
plot(light_scatter(fl, v = "Petal.Length", by = "Species"), alpha = 0.2)
</code></pre>

<hr>
<h2 id='predict.flashlight'>Predictions for flashlight</h2><span id='topic+predict.flashlight'></span>

<h3>Description</h3>

<p>Predict method for an object of class &quot;flashlight&quot;.
Pass additional elements to update the flashlight, typically <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flashlight'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.flashlight_+3A_object">object</code></td>
<td>
<p>An object of class &quot;flashlight&quot;.</p>
</td></tr>
<tr><td><code id="predict.flashlight_+3A_...">...</code></td>
<td>
<p>Arguments used to update the flashlight.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, data = iris, y = "Sepal.Length", label = "ols")
predict(fl)[1:5]
predict(fl, data = iris[1:5, ])
</code></pre>

<hr>
<h2 id='predict.multiflashlight'>Predictions for multiflashlight</h2><span id='topic+predict.multiflashlight'></span>

<h3>Description</h3>

<p>Predict method for an object of class &quot;multiflashlight&quot;.
Pass additional elements to update the flashlight, typically <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiflashlight'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.multiflashlight_+3A_object">object</code></td>
<td>
<p>An object of class &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="predict.multiflashlight_+3A_...">...</code></td>
<td>
<p>Arguments used to update the multiflashlight.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of prediction vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_part &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)
fit_full &lt;- lm(Sepal.Length ~ ., data = iris)
mod_full &lt;- flashlight(model = fit_full, label = "full")
mod_part &lt;- flashlight(model = fit_part, label = "part")
mods &lt;- multiflashlight(list(mod_full, mod_part), data = iris, y = "Sepal.Length")
predict(mods, data = iris[1:5, ])
</code></pre>

<hr>
<h2 id='print.flashlight'>Prints a flashlight</h2><span id='topic+print.flashlight'></span>

<h3>Description</h3>

<p>Print method for an object of class &quot;flashlight&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flashlight'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.flashlight_+3A_x">x</code></td>
<td>
<p>A on object of class &quot;flashlight&quot;.</p>
</td></tr>
<tr><td><code id="print.flashlight_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the input is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flashlight">flashlight()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
x &lt;- flashlight(model = fit, label = "lm", y = "Sepal.Length", data = iris)
x
</code></pre>

<hr>
<h2 id='print.light'>Prints light Object</h2><span id='topic+print.light'></span>

<h3>Description</h3>

<p>Print method for an object of class &quot;light&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'light'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.light_+3A_x">x</code></td>
<td>
<p>A on object of class &quot;light&quot;.</p>
</td></tr>
<tr><td><code id="print.light_+3A_...">...</code></td>
<td>
<p>Further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the input is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "lm", y = "Sepal.Length", data = iris)
light_performance(fl, v = "Species")
</code></pre>

<hr>
<h2 id='print.multiflashlight'>Prints a multiflashlight</h2><span id='topic+print.multiflashlight'></span>

<h3>Description</h3>

<p>Print method for an object of class &quot;multiflashlight&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiflashlight'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.multiflashlight_+3A_x">x</code></td>
<td>
<p>An object of class &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="print.multiflashlight_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+print.flashlight">print.flashlight()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the input is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiflashlight">multiflashlight()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_lm &lt;- lm(Sepal.Length ~ ., data = iris)
fit_glm &lt;- glm(Sepal.Length ~ ., family = Gamma(link = log), data = iris)
fl_lm &lt;- flashlight(model = fit_lm, label = "lm")
fl_glm &lt;- flashlight(model = fit_glm, label = "glm")
multiflashlight(list(fl_lm, fl_glm), data = iris)
</code></pre>

<hr>
<h2 id='residuals.flashlight'>Residuals for flashlight</h2><span id='topic+residuals.flashlight'></span>

<h3>Description</h3>

<p>Residuals method for an object of class &quot;flashlight&quot;.
Pass additional elements to update the flashlight before calculation of residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flashlight'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.flashlight_+3A_object">object</code></td>
<td>
<p>An object of class &quot;flashlight&quot;.</p>
</td></tr>
<tr><td><code id="residuals.flashlight_+3A_...">...</code></td>
<td>
<p>Arguments used to update the flashlight before calculating the residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
x &lt;- flashlight(model = fit, data = iris, y = "Sepal.Length", label = "ols")
residuals(x)[1:5]
</code></pre>

<hr>
<h2 id='residuals.multiflashlight'>Residuals for multiflashlight</h2><span id='topic+residuals.multiflashlight'></span>

<h3>Description</h3>

<p>Residuals method for an object of class &quot;multiflashlight&quot;.
Pass additional elements to update the multiflashlight before calculation of
residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiflashlight'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.multiflashlight_+3A_object">object</code></td>
<td>
<p>An object of class &quot;multiflashlight&quot;.</p>
</td></tr>
<tr><td><code id="residuals.multiflashlight_+3A_...">...</code></td>
<td>
<p>Arguments used to update the multiflashlight before
calculating the residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with residuals per flashlight.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_part &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)
fit_full &lt;- lm(Sepal.Length ~ ., data = iris)
mod_full &lt;- flashlight(model = fit_full, label = "full")
mod_part &lt;- flashlight(model = fit_part, label = "part")
mods &lt;- multiflashlight(list(mod_full, mod_part), data = iris, y = "Sepal.Length")
residuals(mods, data = head(iris))
</code></pre>

<hr>
<h2 id='response'>Response of multi/-flashlight</h2><span id='topic+response'></span><span id='topic+response.default'></span><span id='topic+response.flashlight'></span><span id='topic+response.multiflashlight'></span>

<h3>Description</h3>

<p>Extracts response from object of class &quot;flashlight&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response(object, ...)

## Default S3 method:
response(object, ...)

## S3 method for class 'flashlight'
response(object, ...)

## S3 method for class 'multiflashlight'
response(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_+3A_object">object</code></td>
<td>
<p>An object of class &quot;flashlight&quot;.</p>
</td></tr>
<tr><td><code id="response_+3A_...">...</code></td>
<td>
<p>Arguments used to update the flashlight before extracting the response.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of responses.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>response(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>response(flashlight)</code>: Extract response from flashlight object.
</p>
</li>
<li> <p><code>response(multiflashlight)</code>: Extract responses from multiflashlight object.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
(fl &lt;- flashlight(model = fit, data = iris, y = "Sepal.Length", label = "ols"))
response(fl)[1:5]
response(fl, data = iris[1:5, ])
response(fl, data = iris[1:5, ], linkinv = exp)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
