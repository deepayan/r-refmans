<!DOCTYPE html><html><head><title>Help for package cauphy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cauphy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ancestral'><p>Posterior density of a node</p></a></li>
<li><a href='#cauphylm'><p>Phylogenetic Regression using a Cauchy Process</p></a></li>
<li><a href='#check_tree'><p>Check Binary Tree object</p></a></li>
<li><a href='#checkDuplicates'><p>Check For Duplicated Entries</p></a></li>
<li><a href='#checkTraitTree'><p>Check Matrix Parameter</p></a></li>
<li><a href='#compute_vcov'><p>Compute Approximated Variance Covariance Matrix</p></a></li>
<li><a href='#do_optim'><p>NLOPT optimization</p></a></li>
<li><a href='#find_modes'><p>Find modes of a distribution</p></a></li>
<li><a href='#fit_function'><p>Maximum Likelihood estimator for a Cauchy model</p></a></li>
<li><a href='#fitCauchy'><p>Model fitting for a Cauchy Process</p></a></li>
<li><a href='#fitCauchy.internal'><p>Maximum Likelihood estimator for a Cauchy model</p></a></li>
<li><a href='#getBounds'><p>Get bounds</p></a></li>
<li><a href='#getBoundsCauchy'><p>Get bound for a Cauchy process</p></a></li>
<li><a href='#getBoundsLambda'><p>Get bounds for a Cauchy Lambda</p></a></li>
<li><a href='#getParamNames'><p>Get parameter names</p></a></li>
<li><a href='#getStartingValues'><p>Get starting values</p></a></li>
<li><a href='#getStartingValuesCauchy'><p>Get starting values for a Cauchy</p></a></li>
<li><a href='#getStartingValuesLambda'><p>Get starting values for a Cauchy Lambda</p></a></li>
<li><a href='#hdi.ancestralCauchy'><p>Highest (Posterior) Density Interval</p></a></li>
<li><a href='#increment'><p>Posterior density of an increment</p></a></li>
<li><a href='#initDispersionParameter'><p>Initialization of the dispersion parameter.</p></a></li>
<li><a href='#initLambdaParameter'><p>Initialization of the lambda parameter.</p></a></li>
<li><a href='#initPositionParameter'><p>Initialization of the position parameter.</p></a></li>
<li><a href='#lizards'><p>Greater Antillean Anolis lizard dataset</p></a></li>
<li><a href='#logDensityTipsCauchy'><p>Log Density of a Cauchy Process</p></a></li>
<li><a href='#maxLambda'><p>Maximum lambda value</p></a></li>
<li><a href='#minusLikelihoodFixedRoot'><p>Minus Likelihood function for a Cauchy model</p></a></li>
<li><a href='#minusLikelihoodFixedRoot_lm'><p>Minus Likelihood function for a Cauchy model</p></a></li>
<li><a href='#minusLikelihoodFixedRoot_mu'><p>Minus Likelihood function for a Cauchy model</p></a></li>
<li><a href='#minusLikelihoodRandomRoot'><p>Minus Likelihood function for a Cauchy model</p></a></li>
<li><a href='#minusLikelihoodREML'><p>Minus REML function for a Cauchy model</p></a></li>
<li><a href='#plot_asr'><p>Plot Ancestral States Reconstructions</p></a></li>
<li><a href='#plot.ancestralCauchy'><p>Plot for class <code>ancestralCauchy</code></p></a></li>
<li><a href='#plot.invisible'><p>Invisible Plotting</p></a></li>
<li><a href='#plot.profile.cauphyfit'><p>Plot for class <code>profile.cauphyfit</code></p></a></li>
<li><a href='#posteriorDensityAncestral'><p>Posterior density of a node</p></a></li>
<li><a href='#posteriorDensityIncrement'><p>Posterior density of an increment</p></a></li>
<li><a href='#print.cauphyfit'><p>Generic Methods for S3 class <code>cauphyfit</code>.</p></a></li>
<li><a href='#print.cauphylm'><p>Generic Methods for S3 class <code>cauphylm</code>.</p></a></li>
<li><a href='#printRTreeTest'><p>Print a tree</p></a></li>
<li><a href='#profile.cauphyfit'><p>Method for Profiling <code>cauphyfit</code> Objects</p></a></li>
<li><a href='#reroottip'><p>Re root tree at a tip</p></a></li>
<li><a href='#rTraitCauchy'><p>Cauchy Trait Simulation</p></a></li>
<li><a href='#safe_get'><p>Safely get element of a named vector</p></a></li>
<li><a href='#simulateTipsCauchy'><p>Simulate using the Cauchy Process</p></a></li>
<li><a href='#transformBranchLengths'><p>Transform branch lengths</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Trait Evolution on Phylogenies Using the Cauchy Process</td>
</tr>
<tr>
<td>Description:</td>
<td>The Cauchy Process can model pulsed continuous trait evolution
    on phylogenies. The likelihood is tractable, and is used for parameter
    inference and ancestral trait reconstruction.
    See Bastide and Didier (2023) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyad053">doi:10.1093/sysbio/syad053</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), ape (&ge; 5.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, robustbase, phylolm, nloptr, pracma, foreach,
doParallel, HDInterval</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, spelling, geiger, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gilles-didier.github.io/cauphy/">https://gilles-didier.github.io/cauphy/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gilles-didier/cauphy/issues">https://github.com/gilles-didier/cauphy/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 12:49:10 UTC; bastidep</td>
</tr>
<tr>
<td>Author:</td>
<td>Gilles Didier [aut, cph],
  Paul Bastide [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Bastide &lt;paul.bastide@cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ancestral'>Posterior density of a node</h2><span id='topic+ancestral'></span><span id='topic+ancestral.cauphylm'></span><span id='topic+ancestral.cauphyfit'></span>

<h3>Description</h3>

<p>Compute the posterior density of a node value under a fitted Cauchy process on a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestral(x, ...)

## S3 method for class 'cauphylm'
ancestral(x, node, values, n_values = 100, n_cores = 1, ...)

## S3 method for class 'cauphyfit'
ancestral(x, node, values, n_values = 100, n_cores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancestral_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+fitCauchy">fitCauchy</a></code> or <code><a href="#topic+cauphylm">cauphylm</a></code>.</p>
</td></tr>
<tr><td><code id="ancestral_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the method.</p>
</td></tr>
<tr><td><code id="ancestral_+3A_node">node</code></td>
<td>
<p>the vector of nodes for which to compute the posterior density. 
If not specified, the reconstruction is done on all the nodes.</p>
</td></tr>
<tr><td><code id="ancestral_+3A_values">values</code></td>
<td>
<p>the vector of values where the density should be computed. 
If not specified, the reconstruction is done for a grid of <code>n_values</code> values 
between <code>1.5 * min(x$y)</code> and <code>1.5 * max(x$y)</code>.</p>
</td></tr>
<tr><td><code id="ancestral_+3A_n_values">n_values</code></td>
<td>
<p>the number of point for the grid of values. 
Default to <code>100</code>. Ignored if <code>values</code> is provided.</p>
</td></tr>
<tr><td><code id="ancestral_+3A_n_cores">n_cores</code></td>
<td>
<p>number of cores for the parallelization. Default to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes a Cauchy Process on the tree with fitted parameters 
(see <code><a href="#topic+fitCauchy">fitCauchy</a></code>),
and computes the posterior ancestral density of internal nodes, 
conditionally on the vector of tip values.
</p>
<p>It computes the posterior density on all the points in <code>values</code>,
that should be refined enough to get a good idea of the density curve.
</p>


<h3>Value</h3>

<p>an object of S3 class <code>ancestralCauchy</code>,
which is a matrix of posterior values, with nodes in rows and values in columns.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ancestral(cauphylm)</code>: <code><a href="#topic+cauphylm">cauphylm</a></code> object
</p>
</li>
<li> <p><code>ancestral(cauphyfit)</code>: <code><a href="#topic+fitCauchy">fitCauchy</a></code> object
</p>
</li></ul>


<h3>References</h3>

<p>Bastide, P. and Didier, G. 2023. The Cauchy Process on Phylogenies: a Tractable Model for Pulsed Evolution. Systematic Biology. doi:10.1093/sysbio/syad053.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCauchy">fitCauchy</a></code>, <code><a href="#topic+cauphylm">cauphylm</a></code>,
<code><a href="#topic+plot.ancestralCauchy">plot.ancestralCauchy</a></code>, <code><a href="#topic+plot_asr">plot_asr</a></code>, <code><a href="#topic+increment">increment</a></code>,
<code><a href="#topic+hdi.ancestralCauchy">hdi.ancestralCauchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1289)
# Simulate tree and data
phy &lt;- ape::rphylo(10, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                    parameters = list(root.value = 10, disp = 0.1))
# Fit the data
fit &lt;- fitCauchy(phy, dat, model = "cauchy", method = "reml")
# Reconstruct the ancestral nodes
anc &lt;- ancestral(fit)
plot_asr(fit, anc = anc, offset = 3)
plot(anc, type = "l", node = c(11, 17))
# Refine grid for node 12 and 17
anc2 &lt;- ancestral(fit, node = c(12, 17), n_values = 1000)
plot(anc2, type = "l")
# Find HDI
library(HDInterval)
hdi_anc &lt;- hdi(anc2)
hdi_anc
plot(anc2, interval = hdi_anc, type = "l")

</code></pre>

<hr>
<h2 id='cauphylm'>Phylogenetic Regression using a Cauchy Process</h2><span id='topic+cauphylm'></span>

<h3>Description</h3>

<p>Perform a phylogenetic regression using the Cauchy Process, by numerical optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cauphylm(
  formula,
  data = list(),
  phy,
  model = c("cauchy", "lambda"),
  lower.bound = list(disp = 0, lambda = 0),
  upper.bound = list(disp = Inf, lambda = NULL),
  starting.value = list(disp = NULL, lambda = NULL),
  hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cauphylm_+3A_formula">formula</code></td>
<td>
<p>a model formula.</p>
</td></tr>
<tr><td><code id="cauphylm_+3A_data">data</code></td>
<td>
<p>a data frame containing variables in the model.
If not found in data, the variables are taken from current environment.</p>
</td></tr>
<tr><td><code id="cauphylm_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="cauphylm_+3A_model">model</code></td>
<td>
<p>a model for the trait evolution. One of <code>"cauchy"</code> or <code>"lambda"</code> (see Details).</p>
</td></tr>
<tr><td><code id="cauphylm_+3A_lower.bound">lower.bound</code></td>
<td>
<p>named list with lower bound values for the parameters. See Details for the default values.</p>
</td></tr>
<tr><td><code id="cauphylm_+3A_upper.bound">upper.bound</code></td>
<td>
<p>named list with upper bound values for the parameters. See Details for the default values.</p>
</td></tr>
<tr><td><code id="cauphylm_+3A_starting.value">starting.value</code></td>
<td>
<p>named list initial values for the parameters.
See Details for the default values.</p>
</td></tr>
<tr><td><code id="cauphylm_+3A_hessian">hessian</code></td>
<td>
<p>if <code>TRUE</code>, then the numerical hessian is computed, for confidence interval computations. See <code><a href="#topic+compute_vcov">compute_vcov</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a Cauchy Process on the phylogeny, using maximum likelihood
and the <code>"fixed.root"</code> method (see <code><a href="#topic+fitCauchy">fitCauchy</a></code>).
It further assumes that the root value <code>x0</code> is a linear combination of the
covariables in <code>formula</code>.
The corresponding regression model is:
</p>
<p style="text-align: center;"><code class="reqn">Y = X \beta + E,</code>
</p>

<p>with:
</p>

<dl>
<dt><code class="reqn">Y</code></dt><dd><p> the vector of traits at the tips of the tree;</p>
</dd>
<dt><code class="reqn">X</code></dt><dd><p> the regression matrix of covariables in <code>formula</code>;</p>
</dd>
<dt><code class="reqn">\beta</code></dt><dd><p> the vector of coefficients;</p>
</dd>
<dt><code class="reqn">E</code></dt><dd><p> a centered error vector that is Cauchy distributed,
and can be seen as the result of a Cauchy process starting at 0 at the root,
and with a dispersion <code>disp</code> (see <code><a href="#topic+fitCauchy">fitCauchy</a></code>).</p>
</dd>
</dl>

<p>Unless specified by the user, the initial values for the parameters 
are taken according to the following heuristics:
</p>

<dl>
<dt><code>coefficients</code>:</dt><dd> <p><code class="reqn">\beta</code> are obtained from a robust regression using <code><a href="robustbase.html#topic+lmrob.S">lmrob.S</a></code>;</p>
</dd>
<dt><code>disp</code>:</dt><dd><p> is initialized from the trait centered and normalized 
by tip heights, with one of the following statistics, taken from Rousseeuw &amp; Croux 1993:</p>
</dd>
</dl>

<dl>
<dt><code>IQR</code>:</dt><dd><p> half of the inter-quartile range (see <code><a href="stats.html#topic+IQR">IQR</a></code>);</p>
</dd>
<dt><code>MAD</code>:</dt><dd><p> median absolute deviation with constant equal to 1 (see <code><a href="stats.html#topic+mad">mad</a></code>);</p>
</dd>
<dt><code>Sn</code>:</dt><dd><p> Sn statistics with constant 0.7071 (see <code><a href="robustbase.html#topic+Sn">Sn</a></code>);</p>
</dd>
<dt><code>Qn</code>:</dt><dd><p> Qn statistics with constant 1.2071 (see <code><a href="robustbase.html#topic+Qn">Qn</a></code>).</p>
</dd>
</dl>


<p>Unless specified by the user, <code>disp</code> is taken positive unbounded.
</p>
<p>The function uses <code><a href="nloptr.html#topic+nloptr">nloptr</a></code> for the numerical optimization of the 
(restricted) likelihood, computed with function <code><a href="#topic+logDensityTipsCauchy">logDensityTipsCauchy</a></code>.
It uses algorithms <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#bobyqa"><code>BOBYQA</code></a>
and <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#mlsl-multi-level-single-linkage"><code>MLSL_LDS</code></a>
for local and global optimization.
</p>
<p>If <code>model="lambda"</code>, the CP is fit on a tree with branch lengths re-scaled 
using the Pagel's lambda transform (see <code><a href="phylolm.html#topic+transf.branch.lengths">transf.branch.lengths</a></code>),
and the <code>lambda</code> value is estimated using numerical optimization.
The default initial value for the <code>lambda</code> parameter is computed using adequate robust moments.
The default maximum value is computed using <code>phytools:::maxLambda</code>,
and is the ratio between the maximum height of a tip node over the maximum height of an internal node.
This can be larger than 1.
The default minimum value is 0.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the named vector of estimated coefficients.</p>
</td></tr>
<tr><td><code>disp</code></td>
<td>
<p>the maximum likelihood estimate of the dispersion parameter.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the maximum of the log likelihood.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of all parameters of the model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC value of the model.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>raw residuals</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations (tips in the tree)</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>number of dependent variables</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the model formula</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original call to the function</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the phylogenetic model for the covariance</p>
</td></tr>
<tr><td><code>phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the ml estimate of the lambda parameter (for <code>model="lambda"</code>)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bastide, P. and Didier, G. 2023. The Cauchy Process on Phylogenies: a Tractable Model for Pulsed Evolution. Systematic Biology. doi:10.1093/sysbio/syad053.
</p>
<p>Rothenberg T. J., Fisher F. M., Tilanus C. B. 1964. A Note on Estimation from a Cauchy Sample. Journal of the American Statistical Association. 59:460–463.
</p>
<p>Rousseeuw P.J., Croux C. 1993. Alternatives to the Median Absolute Deviation. Journal of the American Statistical Association. 88:1273–1283.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCauchy">fitCauchy</a></code>, <code><a href="#topic+confint.cauphylm">confint.cauphylm</a></code>, <code><a href="#topic+ancestral">ancestral</a></code>, <code><a href="#topic+increment">increment</a></code>, <code><a href="#topic+logDensityTipsCauchy">logDensityTipsCauchy</a></code>, <code><a href="phylolm.html#topic+phylolm">phylolm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate tree and data
set.seed(1289)
phy &lt;- ape::rphylo(20, 0.1, 0)
error &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                      parameters = list(root.value = 0, disp = 0.1))
x1 &lt;- ape::rTraitCont(phy, model = "BM", sigma = 0.1, root.value = 0)
trait &lt;- 3 + 2*x1 + error
# Fit the data
fit &lt;- cauphylm(trait ~ x1, phy = phy)
fit
# Approximate confidence intervals
confint(fit)

</code></pre>

<hr>
<h2 id='check_tree'>Check Binary Tree object</h2><span id='topic+check_tree'></span><span id='topic+check_binary_tree'></span>

<h3>Description</h3>

<p>Perform check on the tree: it needs to be a <code>phylo</code> object,
with branch lengths, binary, with tip labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_tree(tree)

check_binary_tree(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_tree_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value returned.
</p>

<hr>
<h2 id='checkDuplicates'>Check For Duplicated Entries</h2><span id='topic+checkDuplicates'></span>

<h3>Description</h3>

<p>Check that the trait are compatible with the tree. Throws an error if not.
Assumes that the trait and tree tips are in the same order, using function 
<code><a href="#topic+checkTraitTree">checkTraitTree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDuplicates(trait, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkDuplicates_+3A_trait">trait</code></td>
<td>
<p>(named) vector or matrix of traits being tested.</p>
</td></tr>
<tr><td><code id="checkDuplicates_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree.</p>
</td></tr>
</table>

<hr>
<h2 id='checkTraitTree'>Check Matrix Parameter</h2><span id='topic+checkTraitTree'></span>

<h3>Description</h3>

<p>Check that the parameters are compatible with the tree. Throws an error if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTraitTree(trait, tree, name = "trait")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkTraitTree_+3A_trait">trait</code></td>
<td>
<p>(named) vector or matrix of traits being tested.</p>
</td></tr>
<tr><td><code id="checkTraitTree_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree.</p>
</td></tr>
<tr><td><code id="checkTraitTree_+3A_name">name</code></td>
<td>
<p>name of the trait. Default to 'trait'.</p>
</td></tr>
</table>

<hr>
<h2 id='compute_vcov'>Compute Approximated Variance Covariance Matrix</h2><span id='topic+compute_vcov'></span>

<h3>Description</h3>

<p>Find the approximated variance covariance matrix of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_vcov(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_vcov_+3A_obj">obj</code></td>
<td>
<p>a fitted object, either with <code><a href="#topic+fitCauchy">fitCauchy</a></code> or <code><a href="#topic+cauphylm">cauphylm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the numerical Hessian of the likelihood at the optimal value
using function <code><a href="pracma.html#topic+hessian">hessian</a></code>, and then uses its inverse 
to approximate the variance covariance matrix.
It can be used to compute confidence intervals with functions <code><a href="#topic+confint.cauphylm">confint.cauphylm</a></code>
or <code><a href="#topic+confint.cauphyfit">confint.cauphyfit</a></code>.
</p>
<p><code><a href="#topic+confint.cauphylm">confint.cauphylm</a></code> and <code><a href="#topic+confint.cauphyfit">confint.cauphyfit</a></code>
internally call <code>compute_vcov</code>, but do not save the result.
This function can be used to save the vcov matrix.
</p>


<h3>Value</h3>

<p>The same object, with added vcov entry.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCauchy">fitCauchy</a></code>, <code><a href="#topic+cauphylm">cauphylm</a></code>, 
<code><a href="#topic+confint.cauphylm">confint.cauphylm</a></code>, <code><a href="#topic+confint.cauphyfit">confint.cauphyfit</a></code>,
<code><a href="#topic+vcov.cauphylm">vcov.cauphylm</a></code>, <code><a href="#topic+vcov.cauphyfit">vcov.cauphyfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate tree and data
set.seed(1289)
phy &lt;- ape::rphylo(20, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                    parameters = list(root.value = 10, disp = 0.1))
# Fit the data, without computing the Hessian at the estimated parameters.
fit &lt;- fitCauchy(phy, dat, model = "cauchy", method = "reml", hessian = FALSE)
# Precompute the vcov matrix
fit &lt;- compute_vcov(fit)
# Approximate confidence intervals
confint(fit)

</code></pre>

<hr>
<h2 id='do_optim'>NLOPT optimization</h2><span id='topic+do_optim'></span>

<h3>Description</h3>

<p>Perform the optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_optim(
  minus_like,
  start.values,
  lower.values,
  upper.values,
  options_nloptr = list(algorithm = "NLOPT_LN_BOBYQA", xtol_rel = 1e-08, maxeval = 1000),
  optim = c("local", "global"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_optim_+3A_minus_like">minus_like</code></td>
<td>
<p>the function to be minimized</p>
</td></tr>
<tr><td><code id="do_optim_+3A_start.values">start.values</code></td>
<td>
<p>vector of starting values</p>
</td></tr>
<tr><td><code id="do_optim_+3A_lower.values">lower.values</code></td>
<td>
<p>vector of lower values</p>
</td></tr>
<tr><td><code id="do_optim_+3A_upper.values">upper.values</code></td>
<td>
<p>vector of upper values</p>
</td></tr>
<tr><td><code id="do_optim_+3A_options_nloptr">options_nloptr</code></td>
<td>
<p>options to be passed to <code>nloptr</code></p>
</td></tr>
<tr><td><code id="do_optim_+3A_optim">optim</code></td>
<td>
<p>should a global optimization be performed first ?</p>
</td></tr>
<tr><td><code id="do_optim_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to minus_like</p>
</td></tr>
</table>

<hr>
<h2 id='find_modes'>Find modes of a distribution</h2><span id='topic+find_modes'></span>

<h3>Description</h3>

<p>Find modes of a distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_modes(anc, node, mode_proba_method = "integral")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_modes_+3A_anc">anc</code></td>
<td>
<p>an object of class <code>ancestralCauchy</code></p>
</td></tr>
<tr><td><code id="find_modes_+3A_node">node</code></td>
<td>
<p>a vector of node number in the tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, with <code>opt_vals</code> the abscissa values where the distribution is maximum,
and <code>prop_vals</code> the approximate density under each optimal value, normalized to sum to one.
</p>

<hr>
<h2 id='fit_function'>Maximum Likelihood estimator for a Cauchy model</h2><span id='topic+fit_function'></span>

<h3>Description</h3>

<p>Find the maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_function(
  minus_like,
  tree,
  trait,
  X,
  model,
  start.values,
  lower.values,
  upper.values,
  optim,
  rootTip
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_function_+3A_minus_like">minus_like</code></td>
<td>
<p>a function giving the minus likelihood of the model.</p>
</td></tr>
<tr><td><code id="fit_function_+3A_trait">trait</code></td>
<td>
<p>named vector of traits at the tips.</p>
</td></tr>
<tr><td><code id="fit_function_+3A_model">model</code></td>
<td>
<p>a model for the trait evolution. One of <code>"cauchy"</code> or <code>"lambda"</code> (see Details).</p>
</td></tr>
<tr><td><code id="fit_function_+3A_optim">optim</code></td>
<td>
<p>if &quot;local&quot;, only a local optimization around the initial parameter values is performed (the default).
If &quot;global&quot;, a global maximization is attempted using the &quot;MLSL&quot; approach (see <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>).</p>
</td></tr>
<tr><td><code id="fit_function_+3A_roottip">rootTip</code></td>
<td>
<p>root tip for the reml.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, with the maximum likelihood rate parameter, and the likelihood value.
</p>

<hr>
<h2 id='fitCauchy'>Model fitting for a Cauchy Process</h2><span id='topic+fitCauchy'></span>

<h3>Description</h3>

<p>Fit the Cauchy process on a phylogeny, using numerical optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitCauchy(
  phy,
  trait,
  model = c("cauchy", "lambda"),
  method = c("reml", "random.root", "fixed.root"),
  starting.value = list(x0 = NULL, disp = NULL, lambda = NULL),
  lower.bound = list(disp = 0, lambda = 0),
  upper.bound = list(disp = Inf, lambda = NULL),
  root.edge = 100,
  hessian = FALSE,
  optim = c("local", "global"),
  method.init.disp = c("Qn", "Sn", "MAD", "IQR")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitCauchy_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_trait">trait</code></td>
<td>
<p>named vector of traits at the tips.</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_model">model</code></td>
<td>
<p>a model for the trait evolution. One of <code>"cauchy"</code> or <code>"lambda"</code> (see Details).</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_method">method</code></td>
<td>
<p>the method used to fit the process.
One of <code>reml</code> (the default), <code>fixed.root</code> or <code>random.root</code>.
See Details.</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_starting.value">starting.value</code></td>
<td>
<p>starting value for the parameters of the Cauchy.
This should be a named list, with <code>x0</code> and <code>disp</code> the root starting value and the dispersion parameter.
The default initial values are computed from standard statistics used on (independent) Cauchy variables, see Details.</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_lower.bound">lower.bound</code></td>
<td>
<p>named list with lower bound values for the parameters. See Details for the default values.</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_upper.bound">upper.bound</code></td>
<td>
<p>named list with upper bound values for the parameters. See Details for the default values.</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_root.edge">root.edge</code></td>
<td>
<p>multiplicative factor for the root dispersion, equal to the length of the root edge. Ignored if <code>method!=random.root</code>.</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_hessian">hessian</code></td>
<td>
<p>if <code>TRUE</code>, then the numerical hessian is computed, for confidence interval computations. See <code><a href="#topic+compute_vcov">compute_vcov</a></code>.</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_optim">optim</code></td>
<td>
<p>if &quot;local&quot;, only a local optimization around the initial parameter values is performed (the default).
If &quot;global&quot;, a global maximization is attempted using the &quot;MLSL&quot; approach (see <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>).</p>
</td></tr>
<tr><td><code id="fitCauchy_+3A_method.init.disp">method.init.disp</code></td>
<td>
<p>the initialization method for the dispersion.
One of &quot;Qn&quot;, &quot;Sn&quot;, &quot;MAD&quot;, &quot;IQR&quot;. Default to the &quot;Qn&quot; statistics.
See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the default <code>model="cauchy"</code>, the parameters of the Cauchy Process (CP)
are <code>disp</code>, the dispersion of the process,
and <code>x0</code>, the starting value of the process at the root (for <code>method="fixed.root"</code>).
</p>
<p>The model assumes that each increment of the trait <code class="reqn">X</code> on a branch going from node <code class="reqn">k</code> to <code class="reqn">l</code> 
follows a Cauchy distribution, with a dispersion proportional to the length <code class="reqn">t_l</code> of the branch:
</p>
<p style="text-align: center;"><code class="reqn">X_l - X_k \sim \mathcal{C}(0, \mbox{disp} \times t_l).</code>
</p>

<p>Unless specified by the user, the initial values for the parameters are taken according to the following heuristics:
</p>

<dl>
<dt><code>x0</code>:</dt><dd><p> is the trimmed mean of the trait,
keeping only 24% of the observations, as advocated in Rothenberg et al. 1964
(for <code>method="fixed.root"</code>);</p>
</dd>
<dt><code>disp</code>:</dt><dd><p> is initialized from the trait centered and normalized 
by tip heights, with one of the following statistics, taken from Rousseeuw &amp; Croux 1993:</p>
</dd>
</dl>

<dl>
<dt><code>IQR</code>:</dt><dd><p> half of the inter-quartile range (see <code><a href="stats.html#topic+IQR">IQR</a></code>);</p>
</dd>
<dt><code>MAD</code>:</dt><dd><p> median absolute deviation with constant equal to 1 (see <code><a href="stats.html#topic+mad">mad</a></code>);</p>
</dd>
<dt><code>Sn</code>:</dt><dd><p> Sn statistics with constant 0.7071 (see <code><a href="robustbase.html#topic+Sn">Sn</a></code>);</p>
</dd>
<dt><code>Qn</code>:</dt><dd><p> (default) Qn statistics with constant 1.2071 (see <code><a href="robustbase.html#topic+Qn">Qn</a></code>).</p>
</dd>
</dl>


<p>Unless specified by the user, <code>x0</code> is taken to be unbounded,
<code>disp</code> positive unbounded.
</p>
<p>The <code>method</code> argument specifies the method used for the fit:
</p>

<dl>
<dt><code>method="reml"</code>:</dt><dd> 
<p>the dispersion parameter is fitted using the REML criterion,
obtained by re-rooting the tree to one of the tips.
See <code><a href="#topic+logDensityTipsCauchy">logDensityTipsCauchy</a></code> for the default choice of the re-rooting tip;
</p>
</dd>
<dt><code>method="random.root"</code>:</dt><dd> 
<p>the root value is assumed to be a random Cauchy variable, centered at <code>x0=0</code>,
and with a dispersion <code>disp_root = disp * root.edge</code>;
</p>
</dd>
<dt><code>method="fixed.root"</code>:</dt><dd> 
<p>the model is fitted conditionally on the root value <code>x0</code>,
i.e. with a model where the root value is fixed and inferred from the data.
</p>
</dd>
</dl>

<p>In the first two cases, the optimization is done on the dispersion only,
while in the last case the optimization is on the root value and the dispersion.
</p>
<p>The function uses <code><a href="nloptr.html#topic+nloptr">nloptr</a></code> for the numerical optimization of the 
(restricted) likelihood, computed with function <code><a href="#topic+logDensityTipsCauchy">logDensityTipsCauchy</a></code>.
It uses algorithms <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#bobyqa"><code>BOBYQA</code></a>
and <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#mlsl-multi-level-single-linkage"><code>MLSL_LDS</code></a>
for local and global optimization.
</p>
<p>If <code>model="lambda"</code>, the CP is fit on a tree with branch lengths re-scaled 
using the Pagel's lambda transform (see <code><a href="phylolm.html#topic+transf.branch.lengths">transf.branch.lengths</a></code>),
and the <code>lambda</code> value is estimated using numerical optimization.
The default initial value for the <code>lambda</code> parameter is computed using adequate robust moments.
The default maximum value is computed using <code>phytools:::maxLambda</code>,
and is the ratio between the maximum height of a tip node over the maximum height of an internal node.
This can be larger than 1.
The default minimum value is 0.
</p>


<h3>Value</h3>

<p>An object of S3 class <code>cauphyfit</code>, with fields:
</p>
<table>
<tr><td><code>x0</code></td>
<td>
<p>the fitted starting value (for <code>method="fixed.root"</code>)</p>
</td></tr>
<tr><td><code>disp</code></td>
<td>
<p>the ml or reml estimate of the dispersion parameter</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the ml or reml estimate of the lambda parameter (for <code>model="lambda"</code>)</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the maximum of the log (restricted) likelihood</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of parameters of the model</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the AIC value of the model</p>
</td></tr>
<tr><td><code>trait</code></td>
<td>
<p>the named vector of traits at the tips used in the fit</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the named vector of traits at the tips used in the fit</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of tips in the tree</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>the number of dependent variables</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original call of the function</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the phylogenetic model (one of <code>"cauchy"</code> or <code>"lambda"</code>)</p>
</td></tr>
<tr><td><code>phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used (one of <code>"reml"</code>, <code>"fixed.root"</code>, <code>"random.root"</code>)</p>
</td></tr>
<tr><td><code>random.root</code></td>
<td>
<p><code>TRUE</code> if <code>method="random.root"</code></p>
</td></tr>
<tr><td><code>reml</code></td>
<td>
<p><code>TRUE</code> if <code>method="reml"</code></p>
</td></tr>
<tr><td><code>root_tip_reml</code></td>
<td>
<p>name of the tip used to reroot the tree (for  <code>method="reml"</code>)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bastide, P. and Didier, G. 2023. The Cauchy Process on Phylogenies: a Tractable Model for Pulsed Evolution. Systematic Biology. doi:10.1093/sysbio/syad053.
</p>
<p>Rothenberg T. J., Fisher F. M., Tilanus C. B. 1964. A Note on Estimation from a Cauchy Sample. Journal of the American Statistical Association. 59:460–463.
</p>
<p>Rousseeuw P.J., Croux C. 1993. Alternatives to the Median Absolute Deviation. Journal of the American Statistical Association. 88:1273–1283.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.cauphyfit">confint.cauphyfit</a></code>, <code><a href="#topic+profile.cauphyfit">profile.cauphyfit</a></code>, <code><a href="#topic+ancestral">ancestral</a></code>, <code><a href="#topic+increment">increment</a></code>, <code><a href="#topic+logDensityTipsCauchy">logDensityTipsCauchy</a></code>, <code><a href="#topic+cauphylm">cauphylm</a></code>, <code><a href="geiger.html#topic+fitContinuous">fitContinuous</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate tree and data
set.seed(1289)
phy &lt;- ape::rphylo(20, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                    parameters = list(root.value = 10, disp = 0.1))
# Fit the data
fit &lt;- fitCauchy(phy, dat, model = "cauchy", method = "reml")
fit
# Approximate confidence intervals
confint(fit)
# Profile likelihood
pl &lt;- profile(fit)
plot(pl)

</code></pre>

<hr>
<h2 id='fitCauchy.internal'>Maximum Likelihood estimator for a Cauchy model</h2><span id='topic+fitCauchy.internal'></span>

<h3>Description</h3>

<p>Find the maximum likelihood, using numerical optimization with <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitCauchy.internal(
  phy,
  X,
  y,
  model = c("cauchy", "lambda"),
  method = c("reml", "random.root", "fixed.root"),
  starting.value = list(x0 = NULL, disp = NULL, lambda = NULL),
  lower.bound = list(disp = 0, lambda = 0),
  upper.bound = list(disp = Inf, lambda = 1),
  root.edge = 100,
  optim = c("local", "global"),
  method.init.disp = "Qn",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitCauchy.internal_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="fitCauchy.internal_+3A_model">model</code></td>
<td>
<p>a model for the trait evolution. One of <code>"cauchy"</code> or <code>"lambda"</code> (see Details).</p>
</td></tr>
<tr><td><code id="fitCauchy.internal_+3A_method">method</code></td>
<td>
<p>the method used to fit the process.
One of <code>reml</code> (the default), <code>fixed.root</code> or <code>random.root</code>.
See Details.</p>
</td></tr>
<tr><td><code id="fitCauchy.internal_+3A_starting.value">starting.value</code></td>
<td>
<p>starting value for the parameters of the Cauchy.
This should be a named list, with <code>x0</code> and <code>disp</code> the root starting value and the dispersion parameter.
The default initial values are computed from standard statistics used on (independent) Cauchy variables, see Details.</p>
</td></tr>
<tr><td><code id="fitCauchy.internal_+3A_lower.bound">lower.bound</code></td>
<td>
<p>named list with lower bound values for the parameters. See Details for the default values.</p>
</td></tr>
<tr><td><code id="fitCauchy.internal_+3A_upper.bound">upper.bound</code></td>
<td>
<p>named list with upper bound values for the parameters. See Details for the default values.</p>
</td></tr>
<tr><td><code id="fitCauchy.internal_+3A_root.edge">root.edge</code></td>
<td>
<p>multiplicative factor for the root dispersion, equal to the length of the root edge. Ignored if <code>method!=random.root</code>.</p>
</td></tr>
<tr><td><code id="fitCauchy.internal_+3A_optim">optim</code></td>
<td>
<p>if &quot;local&quot;, only a local optimization around the initial parameter values is performed (the default).
If &quot;global&quot;, a global maximization is attempted using the &quot;MLSL&quot; approach (see <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>).</p>
</td></tr>
<tr><td><code id="fitCauchy.internal_+3A_method.init.disp">method.init.disp</code></td>
<td>
<p>the initialization method for the dispersion.
One of &quot;Qn&quot;, &quot;Sn&quot;, &quot;MAD&quot;, &quot;IQR&quot;. Default to the &quot;Qn&quot; statistics.
See Details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, with the maximum likelihood rate parameter, and the likelihood value.
</p>


<h3>References</h3>

<p>Rothenberg T. J., Fisher F. M., Tilanus C. B. 1964. A Note on Estimation from a Cauchy Sample. Journal of the American Statistical Association. 59:460–463.
</p>


<h3>See Also</h3>

<p>cauphylm
</p>

<hr>
<h2 id='getBounds'>Get bounds</h2><span id='topic+getBounds'></span>

<h3>Description</h3>

<p>Get bounds given the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBounds(model, phy, X, y, values, default.values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBounds_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="getBounds_+3A_phy">phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
<tr><td><code id="getBounds_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="getBounds_+3A_y">y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code id="getBounds_+3A_values">values</code></td>
<td>
<p>the input values for the bound</p>
</td></tr>
<tr><td><code id="getBounds_+3A_default.values">default.values</code></td>
<td>
<p>the default values for the bound</p>
</td></tr>
</table>

<hr>
<h2 id='getBoundsCauchy'>Get bound for a Cauchy process</h2><span id='topic+getBoundsCauchy'></span>

<h3>Description</h3>

<p>Get bounds for a Cauchy process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBoundsCauchy(phy, X, y, values, default.values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBoundsCauchy_+3A_phy">phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
<tr><td><code id="getBoundsCauchy_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="getBoundsCauchy_+3A_y">y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code id="getBoundsCauchy_+3A_values">values</code></td>
<td>
<p>the input values for the bound</p>
</td></tr>
<tr><td><code id="getBoundsCauchy_+3A_default.values">default.values</code></td>
<td>
<p>the default values for the bound</p>
</td></tr>
</table>

<hr>
<h2 id='getBoundsLambda'>Get bounds for a Cauchy Lambda</h2><span id='topic+getBoundsLambda'></span>

<h3>Description</h3>

<p>Get bounds for a Cauchy Lambda process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBoundsLambda(phy, X, y, values, default.values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBoundsLambda_+3A_phy">phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
<tr><td><code id="getBoundsLambda_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="getBoundsLambda_+3A_y">y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code id="getBoundsLambda_+3A_values">values</code></td>
<td>
<p>the input values for the bound</p>
</td></tr>
<tr><td><code id="getBoundsLambda_+3A_default.values">default.values</code></td>
<td>
<p>the default values for the bound</p>
</td></tr>
</table>

<hr>
<h2 id='getParamNames'>Get parameter names</h2><span id='topic+getParamNames'></span>

<h3>Description</h3>

<p>Get the names of the parameters depending on the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParamNames(model, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParamNames_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="getParamNames_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
</table>

<hr>
<h2 id='getStartingValues'>Get starting values</h2><span id='topic+getStartingValues'></span>

<h3>Description</h3>

<p>Get starting values given the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStartingValues(model, phy, X, y, starting.value, method.init.disp, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStartingValues_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="getStartingValues_+3A_phy">phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
<tr><td><code id="getStartingValues_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="getStartingValues_+3A_y">y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code id="getStartingValues_+3A_starting.value">starting.value</code></td>
<td>
<p>the input starting values</p>
</td></tr>
</table>

<hr>
<h2 id='getStartingValuesCauchy'>Get starting values for a Cauchy</h2><span id='topic+getStartingValuesCauchy'></span>

<h3>Description</h3>

<p>Get starting values for a Cauchy process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStartingValuesCauchy(phy, X, y, starting.value, method.init.disp, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStartingValuesCauchy_+3A_phy">phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
<tr><td><code id="getStartingValuesCauchy_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="getStartingValuesCauchy_+3A_y">y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code id="getStartingValuesCauchy_+3A_starting.value">starting.value</code></td>
<td>
<p>the input starting values</p>
</td></tr>
</table>

<hr>
<h2 id='getStartingValuesLambda'>Get starting values for a Cauchy Lambda</h2><span id='topic+getStartingValuesLambda'></span>

<h3>Description</h3>

<p>Get starting values for a Cauchy Lambda process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStartingValuesLambda(phy, X, y, starting.value, method.init.disp, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStartingValuesLambda_+3A_phy">phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
<tr><td><code id="getStartingValuesLambda_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="getStartingValuesLambda_+3A_y">y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code id="getStartingValuesLambda_+3A_starting.value">starting.value</code></td>
<td>
<p>the input starting values</p>
</td></tr>
</table>

<hr>
<h2 id='hdi.ancestralCauchy'>Highest (Posterior) Density Interval</h2><span id='topic+hdi.ancestralCauchy'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>ancestralCauchy</code>, result of function
<code><a href="#topic+ancestral">ancestral</a></code> or <code><a href="#topic+increment">increment</a></code>, and find the Highest (Posterior) Density Interval 
of reconstructed states for given nodes.
It relies on function <code><a href="HDInterval.html#topic+hdi">hdi</a></code> from package <code><a href="HDInterval.html#topic+HDInterval">HDInterval</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ancestralCauchy'
hdi(object, credMass = 0.95, allowSplit = TRUE, node, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdi.ancestralCauchy_+3A_object">object</code></td>
<td>
<p>an object of class <code>ancestralCauchy</code>, result of function
<code><a href="#topic+ancestral">ancestral</a></code> or <code><a href="#topic+increment">increment</a></code>.</p>
</td></tr>
<tr><td><code id="hdi.ancestralCauchy_+3A_credmass">credMass</code></td>
<td>
<p>a scalar between 0 and 1 specifying the mass within the credible interval.</p>
</td></tr>
<tr><td><code id="hdi.ancestralCauchy_+3A_allowsplit">allowSplit</code></td>
<td>
<p>if FALSE and the proper HDI is discontinuous,
a single credible interval is returned, but this is not HDI.
See <code><a href="HDInterval.html#topic+hdi">hdi</a></code> for details. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hdi.ancestralCauchy_+3A_node">node</code></td>
<td>
<p>the vector of nodes where to plot the ancestral reconstruction.
Can be missing, in which case all the nodes reconstructed in the <code>ancestralCauchy</code></p>
</td></tr>
<tr><td><code id="hdi.ancestralCauchy_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function relies on the <code>density</code> method of the <code><a href="HDInterval.html#topic+hdi">hdi</a></code> function.
Package <code><a href="HDInterval.html#topic+HDInterval">HDInterval</a></code> must be loaded in the workspace for this
function to work.
See documentation of this functions for more details on the definition and
computation of the HDI.
</p>
<p>The density is obtained on the grid of values defined by the 
<code>ancestralCauchy</code> object, which defaults to 100 values.
See details in the documentation of the 
<code><a href="#topic+ancestral">ancestral</a></code> and <code><a href="#topic+increment">increment</a></code> functions.
</p>
<p>NOTE: if the grid of values is too coarse (if it has too few values),
then the result can be a poor approximation.
Please make sure to use an appropriate grid in the reconstruction to 
get meaningful results (see example).
</p>


<h3>Value</h3>

<p>A named list. Each item of the list is named after a node,
and contains the HDI interval of the node, in the same format
as in <code><a href="HDInterval.html#topic+hdi">hdi</a></code>: 
a vector of length 2 or a 2-row matrix with the lower and upper limits of the HDI, 
with an attribute <code>credMass</code>.
If <code>allowSplit=TRUE</code>, the matrix has a row for each component of a discontinuous HDI 
and columns for begin and end.
It has an additional attribute &quot;height&quot; giving the probability density at the limits of the HDI.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ancestralCauchy">plot.ancestralCauchy</a></code>, <code><a href="#topic+ancestral">ancestral</a></code>, <code><a href="#topic+increment">increment</a></code>, <code><a href="#topic+fitCauchy">fitCauchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lizard dataset
data(lizards)
attach(lizards)
# Fit CP
fit_CP &lt;- fitCauchy(phy, svl, model = "cauchy", method = "reml")
# Reconstruct increments for some branches
inc &lt;- increment(fit_CP, node = c(142, 151), n_cores = 1)
# HDI
library(HDInterval)
inc_int &lt;- hdi(inc)
plot(inc, intervals = inc_int, type = "l")
# HDI of edge ending at node 142 is unimodal
inc_int[["142"]]
# HDI of edge ending at node 151 is bimodal
inc_int[["151"]]
# If the grid is coarse, the result is meaningless
inc &lt;- increment(fit_CP, node = c(151), n_cores = 1, n_values = 10)
inc_int &lt;- hdi(inc)
plot(inc, intervals = inc_int, type = "l")

</code></pre>

<hr>
<h2 id='increment'>Posterior density of an increment</h2><span id='topic+increment'></span><span id='topic+increment.cauphylm'></span><span id='topic+increment.cauphyfit'></span>

<h3>Description</h3>

<p>Compute the posterior density of a branch increment under a fitted Cauchy process on a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increment(x, ...)

## S3 method for class 'cauphylm'
increment(x, node, values, n_values = 100, n_cores = 1, ...)

## S3 method for class 'cauphyfit'
increment(x, node, values, n_values = 100, n_cores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="increment_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+fitCauchy">fitCauchy</a></code> or <code><a href="#topic+cauphylm">cauphylm</a></code>.</p>
</td></tr>
<tr><td><code id="increment_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the method.</p>
</td></tr>
<tr><td><code id="increment_+3A_node">node</code></td>
<td>
<p>vector of nodes ending the branches for which to compute the posterior density of the increment. If not specified, the reconstruction is done on all the possible edges.</p>
</td></tr>
<tr><td><code id="increment_+3A_values">values</code></td>
<td>
<p>the vector of values where the density should be computed. If not specified, the reconstruction is done for a grid of <code>n_values</code> values between <code>-1.5 * maxdiff</code> and <code>1.5 * maxdiff</code>, where <code>maxdiff</code> is the difference between the larger and smaller tip value.</p>
</td></tr>
<tr><td><code id="increment_+3A_n_values">n_values</code></td>
<td>
<p>the number of point for the grid of values. Default to <code>100</code>. Ignored if <code>values</code> is provided.</p>
</td></tr>
<tr><td><code id="increment_+3A_n_cores">n_cores</code></td>
<td>
<p>number of cores for the parallelization. Default to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes a Cauchy Process on the tree with fitted parameters 
(see <code><a href="#topic+fitCauchy">fitCauchy</a></code>),
and computes the posterior ancestral density of trait increments at branches
(ie, the difference between the traits value at the end and beginning of the branch),
conditionally on the vector of tip values.
</p>
<p>It computes the posterior density on all the points in <code>values</code>,
that should be refined enough to get a good idea of the density curve.
</p>


<h3>Value</h3>

<p>an object of S3 class <code>ancestralCauchy</code>,
which is a matrix of posterior increment values, with nodes in rows and values in columns.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>increment(cauphylm)</code>: <code><a href="#topic+cauphylm">cauphylm</a></code> object
</p>
</li>
<li> <p><code>increment(cauphyfit)</code>: <code><a href="#topic+fitCauchy">fitCauchy</a></code> object
</p>
</li></ul>


<h3>References</h3>

<p>Bastide, P. and Didier, G. 2023. The Cauchy Process on Phylogenies: a Tractable Model for Pulsed Evolution. Systematic Biology. doi:10.1093/sysbio/syad053.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCauchy">fitCauchy</a></code>, <code><a href="#topic+cauphylm">cauphylm</a></code>,
<code><a href="#topic+plot.ancestralCauchy">plot.ancestralCauchy</a></code>, <code><a href="#topic+plot_asr">plot_asr</a></code>, <code><a href="#topic+ancestral">ancestral</a></code>,
<code><a href="#topic+hdi.ancestralCauchy">hdi.ancestralCauchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1289)
# Simulate tree and data
phy &lt;- ape::rphylo(10, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                    parameters = list(root.value = 10, disp = 0.1))
# Fit the data
fit &lt;- fitCauchy(phy, dat, model = "cauchy", method = "reml")
# Reconstruct the ancestral increments
inc &lt;- increment(fit)
plot_asr(fit, inc = inc, offset = 3)
plot(inc, node = c(3, 8), type = "l")
# Refine grid for edges ending at tips 3 and 8
inc2 &lt;- increment(fit, node = c(3, 8), values = seq(-3, 3, 0.01))
plot(inc2, type = "l")
# Find HDI
library(HDInterval)
hdi_inc &lt;- hdi(inc2)
hdi_inc
plot(inc2, interval = hdi_inc, type = "l")

</code></pre>

<hr>
<h2 id='initDispersionParameter'>Initialization of the dispersion parameter.</h2><span id='topic+initDispersionParameter'></span>

<h3>Description</h3>

<p>Initialize the dispersion parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initDispersionParameter(
  tree,
  trait,
  center,
  method.init.disp = c("Qn", "Sn", "MAD", "IQR"),
  method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initDispersionParameter_+3A_trait">trait</code></td>
<td>
<p>named vector of traits at the tips.</p>
</td></tr>
<tr><td><code id="initDispersionParameter_+3A_center">center</code></td>
<td>
<p>the center parameter of the distribution</p>
</td></tr>
<tr><td><code id="initDispersionParameter_+3A_method.init.disp">method.init.disp</code></td>
<td>
<p>the robust estimator method</p>
</td></tr>
<tr><td><code id="initDispersionParameter_+3A_method">method</code></td>
<td>
<p>the method used to fit the process.
One of <code>reml</code> (the default), <code>fixed.root</code> or <code>random.root</code>.
See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constants are taken from Rousseeuw &amp; Croux, 1993.
</p>


<h3>Value</h3>

<p>The initial dispersion parameter.
</p>


<h3>References</h3>

<p>Rousseeuw P.J., Croux C. 1993. Alternatives to the Median Absolute Deviation. Journal of the American Statistical Association. 88:1273–1283.
</p>

<hr>
<h2 id='initLambdaParameter'>Initialization of the lambda parameter.</h2><span id='topic+initLambdaParameter'></span>

<h3>Description</h3>

<p>Initialize the lambda parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initLambdaParameter(tree, trait, disp_hat, tol = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initLambdaParameter_+3A_trait">trait</code></td>
<td>
<p>named vector of traits at the tips.</p>
</td></tr>
<tr><td><code id="initLambdaParameter_+3A_disp_hat">disp_hat</code></td>
<td>
<p>the previously estimated dispersion</p>
</td></tr>
<tr><td><code id="initLambdaParameter_+3A_tol">tol</code></td>
<td>
<p>the percentage of tip pairs to keep for the computation. Default to 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use linear combinations of cherries to get a first estimate of lambda.
</p>


<h3>Value</h3>

<p>The initial lambda parameter.
</p>

<hr>
<h2 id='initPositionParameter'>Initialization of the position parameter.</h2><span id='topic+initPositionParameter'></span>

<h3>Description</h3>

<p>Initialize using the trimmed mean of the trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initPositionParameter(trait)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initPositionParameter_+3A_trait">trait</code></td>
<td>
<p>named vector of traits at the tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The initial position parameter.
</p>


<h3>References</h3>

<p>Rothenberg T. J., Fisher F. M., Tilanus C. B. 1964. A Note on Estimation from a Cauchy Sample. Journal of the American Statistical Association. 59:460–463.
Rousseeuw P.J., Croux C. 1993. Alternatives to the Median Absolute Deviation. Journal of the American Statistical Association. 88:1273–1283.
</p>

<hr>
<h2 id='lizards'>Greater Antillean Anolis lizard dataset</h2><span id='topic+lizards'></span>

<h3>Description</h3>

<p>A dataset containing the dated phylogeny and the log snout-to-vent length for
Greater Antillean Anolis lizard species,
taken from Mahler et al. 2013.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lizards
</code></pre>


<h3>Format</h3>

<p>A data frame with 53940 rows and 10 variables:
</p>

<dl>
<dt>phy</dt><dd><p>Bayesian maximum clade credibility chronogram for Greater Antillean Anolis from Mahler et al. 2013</p>
</dd>
<dt>svl</dt><dd><p>Natural log-transformed species average snout-to-vent length</p>
</dd>
<dt>ecomorph</dt><dd><p>Ecomorph assignments for each of the species</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.5061/dryad.9g182">doi:10.5061/dryad.9g182</a>
</p>


<h3>References</h3>

<p>Mahler, D. Luke; Ingram, Travis; Revell, Liam J.; Losos, Jonathan B. (2013), Data from: Exceptional convergence on the macroevolutionary landscape in island lizard radiations, Dryad, Dataset, https://doi.org/10.5061/dryad.9g182
</p>

<hr>
<h2 id='logDensityTipsCauchy'>Log Density of a Cauchy Process</h2><span id='topic+logDensityTipsCauchy'></span>

<h3>Description</h3>

<p>Compute the log density of the vector of trait at the tips of the phylogenetic tree, 
assuming a Cauchy process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logDensityTipsCauchy(
  tree,
  tipTrait,
  root.value = NULL,
  disp,
  method = c("reml", "random.root", "fixed.root"),
  rootTip = NULL,
  do_checks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logDensityTipsCauchy_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="logDensityTipsCauchy_+3A_tiptrait">tipTrait</code></td>
<td>
<p>a names vector of tip trait values, with names matching the tree labels.</p>
</td></tr>
<tr><td><code id="logDensityTipsCauchy_+3A_root.value">root.value</code></td>
<td>
<p>the root starting value of the process.</p>
</td></tr>
<tr><td><code id="logDensityTipsCauchy_+3A_disp">disp</code></td>
<td>
<p>the dispersion value.</p>
</td></tr>
<tr><td><code id="logDensityTipsCauchy_+3A_method">method</code></td>
<td>
<p>the method used to compute the likelihood.
One of <code>reml</code> (the default), <code>fixed.root</code> or <code>random.root</code>.
See Details.</p>
</td></tr>
<tr><td><code id="logDensityTipsCauchy_+3A_roottip">rootTip</code></td>
<td>
<p>the tip used to re-root the tree, when the REML method is used.
If <code>NULL</code>, the tip with the smallest distance to all the others is used (see Details).
Ignored in <code>method != "reml"</code>.</p>
</td></tr>
<tr><td><code id="logDensityTipsCauchy_+3A_do_checks">do_checks</code></td>
<td>
<p>if <code>FALSE</code>, the entry parameters are not checked for consistency.
This can be useful when doing multiple calls to the function, as in numerical optimization.
Default to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters of the Cauchy Process (CP)
are <code>disp</code>, the dispersion of the process,
and <code>root.value</code>, the starting value of the process at the root (for <code>method="fixed.root"</code>).
</p>
<p>The model assumes that each increment of the trait <code class="reqn">X</code> on a branch going from node <code class="reqn">k</code> to <code class="reqn">l</code> 
follows a Cauchy distribution, with a dispersion proportional to the length <code class="reqn">t_l</code> of the branch:
</p>
<p style="text-align: center;"><code class="reqn">X_l - X_k \sim \mathcal{C}(0, \mbox{disp} \times t_l).</code>
</p>

<p>The <code>method</code> argument specifies the type of likelihood that is computed:
</p>

<dl>
<dt><code>method="reml"</code>:</dt><dd> 
<p>the dispersion parameter is fitted using the REML criterion,
obtained by re-rooting the tree to one of the tips.
The default tip used to reroot the tree is:
<code>rootTip = which.min(colSums(cophenetic.phylo(tree)))</code>.
Any tip can be used, but this default empirically proved to be the most robust numerically;
</p>
</dd>
<dt><code>method="random.root"</code>:</dt><dd> 
<p>the root value is assumed to be a random Cauchy variable, centered at <code>root.value=0</code>,
and with a dispersion <code>disp_root = disp * root.edge</code>;
</p>
</dd>
<dt><code>method="fixed.root"</code>:</dt><dd> 
<p>the model is fitted conditionally on the root value <code>root.value</code>,
i.e. with a model where the root value is fixed and inferred from the data.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>the log density value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCauchy">fitCauchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phy &lt;- ape::rphylo(5, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy", parameters = list(root.value = 0, disp = 1))
logDensityTipsCauchy(phy, dat, 0, 1, method = "fixed.root")

</code></pre>

<hr>
<h2 id='maxLambda'>Maximum lambda value</h2><span id='topic+maxLambda'></span>

<h3>Description</h3>

<p>Find maximum lambda value.
Function taken from <code>phytools:::maxLambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLambda(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxLambda_+3A_phy">phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
</table>

<hr>
<h2 id='minusLikelihoodFixedRoot'>Minus Likelihood function for a Cauchy model</h2><span id='topic+minusLikelihoodFixedRoot'></span>

<h3>Description</h3>

<p>Gives the minus likelihood function, with fixed root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minusLikelihoodFixedRoot(Xdesign)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minusLikelihoodFixedRoot_+3A_xdesign">Xdesign</code></td>
<td>
<p>the design matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function
</p>

<hr>
<h2 id='minusLikelihoodFixedRoot_lm'>Minus Likelihood function for a Cauchy model</h2><span id='topic+minusLikelihoodFixedRoot_lm'></span>

<h3>Description</h3>

<p>Gives the minus likelihood function, with fixed root, lm model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minusLikelihoodFixedRoot_lm(
  param,
  param_names,
  tree,
  trait,
  Xdesign,
  model,
  rootTip
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minusLikelihoodFixedRoot_lm_+3A_param">param</code></td>
<td>
<p>the parameters where to evaluate the function</p>
</td></tr>
<tr><td><code id="minusLikelihoodFixedRoot_lm_+3A_param_names">param_names</code></td>
<td>
<p>the parameter names</p>
</td></tr>
<tr><td><code id="minusLikelihoodFixedRoot_lm_+3A_xdesign">Xdesign</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="minusLikelihoodFixedRoot_lm_+3A_model">model</code></td>
<td>
<p>a model for the trait evolution. One of <code>"cauchy"</code> or <code>"lambda"</code> (see Details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of minus the log-likelihood.
</p>

<hr>
<h2 id='minusLikelihoodFixedRoot_mu'>Minus Likelihood function for a Cauchy model</h2><span id='topic+minusLikelihoodFixedRoot_mu'></span>

<h3>Description</h3>

<p>Gives the minus likelihood function, with fixed root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minusLikelihoodFixedRoot_mu(
  param,
  param_names,
  tree,
  trait,
  Xdesign,
  model,
  rootTip
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minusLikelihoodFixedRoot_mu_+3A_param">param</code></td>
<td>
<p>the parameters where to evaluate the function</p>
</td></tr>
<tr><td><code id="minusLikelihoodFixedRoot_mu_+3A_param_names">param_names</code></td>
<td>
<p>the parameter names</p>
</td></tr>
<tr><td><code id="minusLikelihoodFixedRoot_mu_+3A_xdesign">Xdesign</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="minusLikelihoodFixedRoot_mu_+3A_model">model</code></td>
<td>
<p>a model for the trait evolution. One of <code>"cauchy"</code> or <code>"lambda"</code> (see Details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of minus the log-likelihood.
</p>

<hr>
<h2 id='minusLikelihoodRandomRoot'>Minus Likelihood function for a Cauchy model</h2><span id='topic+minusLikelihoodRandomRoot'></span>

<h3>Description</h3>

<p>Gives the minus likelihood function, with random root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minusLikelihoodRandomRoot(
  param,
  param_names,
  tree,
  trait,
  Xdesign,
  model,
  rootTip
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minusLikelihoodRandomRoot_+3A_param">param</code></td>
<td>
<p>the parameters where to evaluate the function</p>
</td></tr>
<tr><td><code id="minusLikelihoodRandomRoot_+3A_param_names">param_names</code></td>
<td>
<p>the parameter names</p>
</td></tr>
<tr><td><code id="minusLikelihoodRandomRoot_+3A_xdesign">Xdesign</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="minusLikelihoodRandomRoot_+3A_model">model</code></td>
<td>
<p>a model for the trait evolution. One of <code>"cauchy"</code> or <code>"lambda"</code> (see Details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of minus the log-likelihood.
</p>

<hr>
<h2 id='minusLikelihoodREML'>Minus REML function for a Cauchy model</h2><span id='topic+minusLikelihoodREML'></span>

<h3>Description</h3>

<p>Gives the minus REML function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minusLikelihoodREML(param, param_names, tree, trait, Xdesign, model, rootTip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minusLikelihoodREML_+3A_param">param</code></td>
<td>
<p>the parameters where to evaluate the function</p>
</td></tr>
<tr><td><code id="minusLikelihoodREML_+3A_param_names">param_names</code></td>
<td>
<p>the parameter names</p>
</td></tr>
<tr><td><code id="minusLikelihoodREML_+3A_xdesign">Xdesign</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="minusLikelihoodREML_+3A_model">model</code></td>
<td>
<p>a model for the trait evolution. One of <code>"cauchy"</code> or <code>"lambda"</code> (see Details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of minus the log-REML.
</p>

<hr>
<h2 id='plot_asr'>Plot Ancestral States Reconstructions</h2><span id='topic+plot_asr'></span>

<h3>Description</h3>

<p>Plot the ancestral states reconstructions from a fitted Cauchy model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_asr(
  x,
  anc = NULL,
  inc = NULL,
  common_colorscale = FALSE,
  x.legend = "topleft",
  y.legend = NULL,
  adj = c(0.5, 0.5),
  piecol = NULL,
  width.node = NULL,
  height.node = NULL,
  width.edge = NULL,
  height.edge = NULL,
  style = "bars",
  offset = 1,
  scaling = 1,
  x.lim = NULL,
  x.intersp = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_asr_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+cauphylm">cauphylm</a></code> or <code><a href="#topic+fitCauchy">fitCauchy</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_anc">anc</code></td>
<td>
<p>(optional) an object of class <code>ancestralCauchy</code>, obtained with <code><a href="#topic+ancestral">ancestral</a></code>.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_inc">inc</code></td>
<td>
<p>(optional) an object of class <code>ancestralCauchy</code>, obtained with <code><a href="#topic+increment">increment</a></code>.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_common_colorscale">common_colorscale</code></td>
<td>
<p>If both plotted, should the ancestral states and the increment be represented by the same color scale ? Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_x.legend">x.legend</code>, <code id="plot_asr_+3A_y.legend">y.legend</code></td>
<td>
<p>the x and y co-ordinates to be used to position the legend. They can be specified by keyword or in any way which is accepted by <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_adj">adj</code></td>
<td>
<p>one or two numeric values specifying the horizontal and
vertical, respectively, justification of the text or symbols. By
default, the text is centered horizontally and vertically. If a
single value is given, this alters only the horizontal position of
the text.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_piecol">piecol</code></td>
<td>
<p>a list of colours (given as a character vector) to be
used by <code>thermo</code> or <code>pie</code>; if left <code>NULL</code>, a series
of colours given by the function <code>rainbow</code> is used.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_width.node">width.node</code>, <code id="plot_asr_+3A_height.node">height.node</code>, <code id="plot_asr_+3A_width.edge">width.edge</code>, <code id="plot_asr_+3A_height.edge">height.edge</code></td>
<td>
<p>parameters controlling the aspect of thermometers for the nodes and the edges; by default, their width and height are determined automatically.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_style">style</code></td>
<td>
<p>a character string specifying the type of graphics; can
be abbreviated (see details).</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_offset">offset</code></td>
<td>
<p>offset of the tip labels (can be negative).</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_scaling">scaling</code></td>
<td>
<p>the scaling factor to apply to the data.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_x.lim">x.lim</code></td>
<td>
<p>a numeric vector of length one or two giving the limit(s)
of the x-axis. If <code>NULL</code>, this is computed with respect to
various parameters such as the string lengths of the labels and the
branch lengths. If a single value is given, this is taken as the
upper limit.</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_x.intersp">x.intersp</code></td>
<td>
<p>character interspacing factor for horizontal (x) spacing between symbol and legend text (see <code><a href="graphics.html#topic+legend">legend</a></code>).</p>
</td></tr>
<tr><td><code id="plot_asr_+3A_...">...</code></td>
<td>
<p>other parameters to be passed on to <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code> or <code><a href="ape.html#topic+phydataplot">phydataplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main plot is done with <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>,
the node annotation use <code><a href="ape.html#topic+nodelabels">nodelabels</a></code>, and the 
tip data plot use <code><a href="ape.html#topic+phydataplot">phydataplot</a></code>.
Please refer to these functions for the details of the parameters.
</p>
<p>The width of each color in the thermo plots approximately represents the 
weight of each node of the distribution, that is estimated by numerically 
integrating the density function around each mode.
Function <code><a href="pracma.html#topic+findpeaks">findpeaks</a></code> is first used to find the modes and
estimate their starting and ending points.
Then function <code><a href="pracma.html#topic+trapz">trapz</a></code> estimates the integral of the density
around the mode.
</p>
<p>For an exact representation of a node posterior density, please plot it separately,
using function <code><a href="#topic+plot.ancestralCauchy">plot.ancestralCauchy</a></code>.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cauphylm">cauphylm</a></code>, <code><a href="#topic+fitCauchy">fitCauchy</a></code>, <code><a href="#topic+ancestral">ancestral</a></code>, <code><a href="#topic+increment">increment</a></code>,
<code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>, <code><a href="ape.html#topic+phydataplot">phydataplot</a></code>, <code><a href="ape.html#topic+nodelabels">nodelabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1289)
# Simulate tree and data
phy &lt;- ape::rphylo(10, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                    parameters = list(root.value = 10, disp = 0.1))
# Fit the data
fit &lt;- fitCauchy(phy, dat, model = "cauchy", method = "reml")
# Reconstruct the ancestral states and increments
inc &lt;- increment(fit, n_values = 100)
anc &lt;- ancestral(fit, n_values = 100)
plot_asr(fit, inc = inc, anc = anc, offset = 3,
         width.node = 0.8, height.node = 0.5, 
         width.edge = 1.5, height.edge = 0.2,
         x.legend = "topright")


</code></pre>

<hr>
<h2 id='plot.ancestralCauchy'>Plot for class <code>ancestralCauchy</code></h2><span id='topic+plot.ancestralCauchy'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>ancestralCauchy</code>, result of function
<code><a href="#topic+ancestral">ancestral</a></code> or <code><a href="#topic+increment">increment</a></code>, and plots the reconstructed states for given nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ancestralCauchy'
plot(x, node, n_col, intervals = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ancestralCauchy_+3A_x">x</code></td>
<td>
<p>an object of class <code>ancestralCauchy</code>, result of function
<code><a href="#topic+ancestral">ancestral</a></code> or <code><a href="#topic+increment">increment</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ancestralCauchy_+3A_node">node</code></td>
<td>
<p>the vector of nodes where to plot the ancestral reconstruction.
Can be missing, in which case all the nodes reconstructed in the <code>ancestralCauchy</code>
object are plotted.</p>
</td></tr>
<tr><td><code id="plot.ancestralCauchy_+3A_n_col">n_col</code></td>
<td>
<p>the number of columns on which to display the plot.
Can be missing, in which case a default number is used.</p>
</td></tr>
<tr><td><code id="plot.ancestralCauchy_+3A_intervals">intervals</code></td>
<td>
<p>a list of HDI intervals produced by function <code><a href="#topic+hdi.ancestralCauchy">hdi.ancestralCauchy</a></code>.
If the HDI of a plotted node is in the list, then it is plotted by the function.</p>
</td></tr>
<tr><td><code id="plot.ancestralCauchy_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_asr">plot_asr</a></code>, <code><a href="#topic+ancestral">ancestral</a></code>, <code><a href="#topic+increment">increment</a></code>, <code><a href="#topic+fitCauchy">fitCauchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1289)
# Simulate tree and data
phy &lt;- ape::rphylo(10, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                    parameters = list(root.value = 10, disp = 0.1))
# Fit the data
fit &lt;- fitCauchy(phy, dat, model = "cauchy", method = "reml")
# Reconstruct the ancestral values
inc &lt;- increment(fit, node = c(3, 8), values = seq(-3, 3, 0.01))
plot(inc, type = "l")
anc &lt;- ancestral(fit, node = c(12, 17), n_values = 1000)
plot(anc, type = "l")

</code></pre>

<hr>
<h2 id='plot.invisible'>Invisible Plotting</h2><span id='topic+plot.invisible'></span>

<h3>Description</h3>

<p>Invisible Plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'invisible'
plot(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.invisible_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See https://stackoverflow.com/a/20363489
</p>


<h3>Value</h3>

<p>the result of the plot, without displaying it.
</p>

<hr>
<h2 id='plot.profile.cauphyfit'>Plot for class <code>profile.cauphyfit</code></h2><span id='topic+plot.profile.cauphyfit'></span>

<h3>Description</h3>

<p>This function takes an object of class <code><a href="#topic+profile.cauphyfit">profile.cauphyfit</a></code>,
and plots the profile likelihood for each parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile.cauphyfit'
plot(x, n_col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.profile.cauphyfit_+3A_x">x</code></td>
<td>
<p>an object of class <code>profile.cauphyfit</code></p>
</td></tr>
<tr><td><code id="plot.profile.cauphyfit_+3A_n_col">n_col</code></td>
<td>
<p>the number of columns on which to display the plot. Can be left blank.</p>
</td></tr>
<tr><td><code id="plot.profile.cauphyfit_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile.cauphyfit">profile.cauphyfit</a></code>, <code><a href="#topic+fitCauchy">fitCauchy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phy &lt;- ape::rphylo(5, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy", parameters = list(root.value = 0, disp = 1))
fit &lt;- fitCauchy(phy, dat, model = "cauchy", method = "fixed.root")
pr &lt;- profile(fit)
plot(pr)

</code></pre>

<hr>
<h2 id='posteriorDensityAncestral'>Posterior density of a node</h2><span id='topic+posteriorDensityAncestral'></span>

<h3>Description</h3>

<p>Compute the posterior density of a set of node values under a Cauchy process on a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorDensityAncestral(
  node,
  vals,
  tree,
  tipTrait,
  root.value = NULL,
  disp,
  method = c("reml", "random.root", "fixed.root")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorDensityAncestral_+3A_node">node</code></td>
<td>
<p>the node for which to compute the posterior density.</p>
</td></tr>
<tr><td><code id="posteriorDensityAncestral_+3A_vals">vals</code></td>
<td>
<p>the table of values where the density should be computed.</p>
</td></tr>
<tr><td><code id="posteriorDensityAncestral_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="posteriorDensityAncestral_+3A_tiptrait">tipTrait</code></td>
<td>
<p>a names vector of tip trait values, with names matching the tree labels.</p>
</td></tr>
<tr><td><code id="posteriorDensityAncestral_+3A_root.value">root.value</code></td>
<td>
<p>the root starting value of the process.</p>
</td></tr>
<tr><td><code id="posteriorDensityAncestral_+3A_disp">disp</code></td>
<td>
<p>the dispersion value.</p>
</td></tr>
<tr><td><code id="posteriorDensityAncestral_+3A_method">method</code></td>
<td>
<p>the method used to compute the likelihood.
One of <code>reml</code> (the default), <code>fixed.root</code> or <code>random.root</code>.
See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+ancestral">ancestral</a></code>, which
is the preferred way of doing ancestral reconstruction on a fitted
object.
</p>


<h3>Value</h3>

<p>the posterior density value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ancestral">ancestral</a></code>, <code><a href="#topic+fitCauchy">fitCauchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phy &lt;- ape::rphylo(5, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy", parameters = list(root.value = 0, disp = 1))
posteriorDensityAncestral(7, 0.1, phy, dat, disp = 1)


</code></pre>

<hr>
<h2 id='posteriorDensityIncrement'>Posterior density of an increment</h2><span id='topic+posteriorDensityIncrement'></span>

<h3>Description</h3>

<p>Compute the posterior density of a set of branch increments under a Cauchy process on a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorDensityIncrement(
  node,
  vals,
  tree,
  tipTrait,
  root.value = NULL,
  disp,
  method = c("reml", "random.root", "fixed.root")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorDensityIncrement_+3A_node">node</code></td>
<td>
<p>the node ending the branch for which to compute the posterior density of the increment.</p>
</td></tr>
<tr><td><code id="posteriorDensityIncrement_+3A_vals">vals</code></td>
<td>
<p>the table of values where the density should be computed.</p>
</td></tr>
<tr><td><code id="posteriorDensityIncrement_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="posteriorDensityIncrement_+3A_tiptrait">tipTrait</code></td>
<td>
<p>a names vector of tip trait values, with names matching the tree labels.</p>
</td></tr>
<tr><td><code id="posteriorDensityIncrement_+3A_root.value">root.value</code></td>
<td>
<p>the root starting value of the process.</p>
</td></tr>
<tr><td><code id="posteriorDensityIncrement_+3A_disp">disp</code></td>
<td>
<p>the dispersion value.</p>
</td></tr>
<tr><td><code id="posteriorDensityIncrement_+3A_method">method</code></td>
<td>
<p>the method used to compute the likelihood.
One of <code>reml</code> (the default), <code>fixed.root</code> or <code>random.root</code>.
See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+increment">increment</a></code>, which
is the preferred way of doing ancestral reconstruction on a fitted
object.
</p>


<h3>Value</h3>

<p>the posterior density value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+increment">increment</a></code>, <code><a href="#topic+fitCauchy">fitCauchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1289)
phy &lt;- ape::rphylo(5, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy", parameters = list(root.value = 0, disp = 1))
posteriorDensityIncrement(2, 0.1, phy, dat, disp = 1)


</code></pre>

<hr>
<h2 id='print.cauphyfit'>Generic Methods for S3 class <code>cauphyfit</code>.</h2><span id='topic+print.cauphyfit'></span><span id='topic+vcov.cauphyfit'></span><span id='topic+logLik.cauphyfit'></span><span id='topic+AIC.logLik.cauphyfit'></span><span id='topic+AIC.cauphyfit'></span><span id='topic+confint.cauphyfit'></span><span id='topic+coef.cauphyfit'></span>

<h3>Description</h3>

<p>Generic Methods for S3 class <code>cauphyfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cauphyfit'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'cauphyfit'
vcov(object, ...)

## S3 method for class 'cauphyfit'
logLik(object, ...)

## S3 method for class 'logLik.cauphyfit'
AIC(object, k = 2, ...)

## S3 method for class 'cauphyfit'
AIC(object, k = 2, ...)

## S3 method for class 'cauphyfit'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'cauphyfit'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cauphyfit_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylolm"</code>.</p>
</td></tr>
<tr><td><code id="print.cauphyfit_+3A_digits">digits</code></td>
<td>
<p>number of digits to show in summary method.</p>
</td></tr>
<tr><td><code id="print.cauphyfit_+3A_...">...</code></td>
<td>
<p>further arguments to methods.</p>
</td></tr>
<tr><td><code id="print.cauphyfit_+3A_object">object</code></td>
<td>
<p>an object of class <code>cauphyfit</code>.</p>
</td></tr>
<tr><td><code id="print.cauphyfit_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
<tr><td><code id="print.cauphyfit_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="print.cauphyfit_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same value as the associated methods from the <code>stats</code> package:
</p>

<dl>
<dt><code><a href="stats.html#topic+vcov">vcov</a></code></dt><dd><p> an estimated covariance matrix, see <code><a href="#topic+compute_vcov">compute_vcov</a></code>;</p>
</dd>
<dt><code><a href="stats.html#topic+logLik">logLik</a></code></dt><dd><p> an object of class <code><a href="stats.html#topic+logLik">logLik</a></code>;</p>
</dd>
<dt><code><a href="stats.html#topic+AIC">AIC</a></code></dt><dd><p> a numeric value;</p>
</dd>
<dt><code><a href="stats.html#topic+confint">confint</a></code></dt><dd><p> a matrix (or vector) with columns giving lower and upper confidence limits for each parameter;</p>
</dd>
<dt><code><a href="stats.html#topic+coef">coef</a></code></dt><dd><p> coefficients extracted from the model;</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+fitCauchy">fitCauchy</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>
<code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="phylolm.html#topic+predict.phylolm">predict.phylolm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate tree and data
set.seed(1289)
phy &lt;- ape::rphylo(20, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                    parameters = list(root.value = 10, disp = 0.1))
# Fit the data
fit &lt;- fitCauchy(phy, dat, model = "cauchy", method = "reml")
fit
# vcov matrix
vcov(fit)
# Approximate confidence intervals
confint(fit)
# log likelihood of the fitted object
logLik(fit)
# AIC of the fitted object
AIC(fit)
# coefficients
coef(fit)

</code></pre>

<hr>
<h2 id='print.cauphylm'>Generic Methods for S3 class <code>cauphylm</code>.</h2><span id='topic+print.cauphylm'></span><span id='topic+vcov.cauphylm'></span><span id='topic+logLik.cauphylm'></span><span id='topic+AIC.logLik.cauphylm'></span><span id='topic+AIC.cauphylm'></span><span id='topic+predict.cauphylm'></span><span id='topic+confint.cauphylm'></span><span id='topic+coef.cauphylm'></span>

<h3>Description</h3>

<p>Generic Methods for S3 class <code>cauphylm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cauphylm'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'cauphylm'
vcov(object, ...)

## S3 method for class 'cauphylm'
logLik(object, ...)

## S3 method for class 'logLik.cauphylm'
AIC(object, k = 2, ...)

## S3 method for class 'cauphylm'
AIC(object, k = 2, ...)

## S3 method for class 'cauphylm'
predict(object, newdata = NULL, ...)

## S3 method for class 'cauphylm'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'cauphylm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cauphylm_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylolm"</code>.</p>
</td></tr>
<tr><td><code id="print.cauphylm_+3A_digits">digits</code></td>
<td>
<p>number of digits to show in summary method.</p>
</td></tr>
<tr><td><code id="print.cauphylm_+3A_...">...</code></td>
<td>
<p>further arguments to methods.</p>
</td></tr>
<tr><td><code id="print.cauphylm_+3A_object">object</code></td>
<td>
<p>an object of class <code>cauphylm</code>.</p>
</td></tr>
<tr><td><code id="print.cauphylm_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
<tr><td><code id="print.cauphylm_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame to provide the predictor values
at which predictions should be made. If omitted, the fitted values are used. Currently, predictions are made for new species whose placement in the tree is unknown. Only their covariate information is used. The prediction for the trend model is not currently implemented.</p>
</td></tr>
<tr><td><code id="print.cauphylm_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="print.cauphylm_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same value as the associated methods from the <code>stats</code> package:
</p>

<dl>
<dt><code><a href="stats.html#topic+vcov">vcov</a></code></dt><dd><p> an estimated covariance matrix, see <code><a href="#topic+compute_vcov">compute_vcov</a></code>;</p>
</dd>
<dt><code><a href="stats.html#topic+logLik">logLik</a></code></dt><dd><p> an object of class <code><a href="stats.html#topic+logLik">logLik</a></code>;</p>
</dd>
<dt><code><a href="stats.html#topic+AIC">AIC</a></code></dt><dd><p> a numeric value;</p>
</dd>
<dt><code><a href="stats.html#topic+confint">confint</a></code></dt><dd><p> a matrix (or vector) with columns giving lower and upper confidence limits for each parameter;</p>
</dd>
<dt><code><a href="stats.html#topic+coef">coef</a></code></dt><dd><p> coefficients extracted from the model;</p>
</dd>
<dt><code><a href="stats.html#topic+predict">predict</a></code></dt><dd><p> a vector of predicted values.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+cauphylm">cauphylm</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>
<code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="phylolm.html#topic+predict.phylolm">predict.phylolm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate tree and data
set.seed(1289)
phy &lt;- ape::rphylo(20, 0.1, 0)
error &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                      parameters = list(root.value = 0, disp = 0.1))
x1 &lt;- ape::rTraitCont(phy, model = "BM", sigma = 0.1, root.value = 0)
trait &lt;- 3 + 2*x1 + error
# Fit the data
fit &lt;- cauphylm(trait ~ x1, phy = phy)
fit
# vcov matrix
vcov(fit)
# Approximate confidence intervals
confint(fit)
# log likelihood of the fitted object
logLik(fit)
# AIC of the fitted object
AIC(fit)
# predicted values
predict(fit)
# coefficients
coef(fit)

</code></pre>

<hr>
<h2 id='printRTreeTest'>Print a tree</h2><span id='topic+printRTreeTest'></span>

<h3>Description</h3>

<p><code>printRtree</code> prints a tree in Newick format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printRTreeTest(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printRTreeTest_+3A_tree">tree</code></td>
<td>
<p>a phylogeny in <code><a href="ape.html#topic+ape">ape</a></code> <code><a href="ape.html#topic+phylo">phylo</a></code> format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value returned.
</p>

<hr>
<h2 id='profile.cauphyfit'>Method for Profiling <code>cauphyfit</code> Objects</h2><span id='topic+profile.cauphyfit'></span>

<h3>Description</h3>

<p>Investigates the profile log-likelihood function for a fitted model of class <code>cauphyfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cauphyfit'
profile(fitted, which = 1:npar, level = 0.8, npoints = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile.cauphyfit_+3A_fitted">fitted</code></td>
<td>
<p>the <code>cauphyfit</code> fitted model object.</p>
</td></tr>
<tr><td><code id="profile.cauphyfit_+3A_which">which</code></td>
<td>
<p>the original model parameters which should be profiled. This can be a numeric or character vector. By default, all parameters are profiled.</p>
</td></tr>
<tr><td><code id="profile.cauphyfit_+3A_level">level</code></td>
<td>
<p>highest confidence level for parameters intervals, computed using the approximated Hessian (see <code><a href="#topic+compute_vcov">compute_vcov</a></code>).</p>
</td></tr>
<tr><td><code id="profile.cauphyfit_+3A_npoints">npoints</code></td>
<td>
<p>number of points to profile the likelihood for each parameter.</p>
</td></tr>
<tr><td><code id="profile.cauphyfit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a confidence interval for the parameters using <code><a href="#topic+confint.cauphyfit">confint.cauphyfit</a></code>,
and then computes the likelihood function on a grid with <code>npoints</code> values
evenly spaced between the bounds of the interval, for each parameter one by one,
all other parameters being fixed.
</p>


<h3>Value</h3>

<p>An object of class <code>profile.cauphyfit</code>, 
which is a list with an element for each parameter being profiled.
The elements are data-frames with two variables:
</p>

<dl>
<dt><code>par.vals</code>:</dt><dd><p> a matrix of parameter values for each fitted model.</p>
</dd>
<dt><code>profLogLik</code>:</dt><dd><p> the profile log likelihood.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+fitCauchy">fitCauchy</a></code>, <code><a href="#topic+plot.profile.cauphyfit">plot.profile.cauphyfit</a></code>, <code><a href="stats.html#topic+profile">profile</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phy &lt;- ape::rphylo(5, 0.1, 0)
dat &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy", parameters = list(root.value = 0, disp = 1))
fit &lt;- fitCauchy(phy, dat, model = "cauchy", method = "reml")
pr &lt;- profile(fit)
plot(pr)

</code></pre>

<hr>
<h2 id='reroottip'>Re root tree at a tip</h2><span id='topic+reroottip'></span>

<h3>Description</h3>

<p>Re root tree at a tip, taking care of the root length.
This function is only used for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reroottip(tree, tip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reroottip_+3A_tree">tree</code></td>
<td>
<p>the original tree</p>
</td></tr>
<tr><td><code id="reroottip_+3A_tip">tip</code></td>
<td>
<p>the tip to re-root at</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the re-rooted tree at the tip
</p>

<hr>
<h2 id='rTraitCauchy'>Cauchy Trait Simulation</h2><span id='topic+rTraitCauchy'></span>

<h3>Description</h3>

<p>Simulate a continuous trait using the Cauchy Process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTraitCauchy(
  n = 1,
  phy,
  model = c("cauchy", "lambda", "kappa", "delta"),
  parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rTraitCauchy_+3A_n">n</code></td>
<td>
<p>number of independent replicates</p>
</td></tr>
<tr><td><code id="rTraitCauchy_+3A_phy">phy</code></td>
<td>
<p>a phylogeny in <code><a href="ape.html#topic+ape">ape</a></code> <code><a href="ape.html#topic+phylo">phylo</a></code> format.</p>
</td></tr>
<tr><td><code id="rTraitCauchy_+3A_model">model</code></td>
<td>
<p>a phylogenetic model. Default is &quot;cauchy&quot;, for the Cauchy process. Alternative are &quot;lambda&quot;, &quot;kappa&quot;, and &quot;delta&quot;.</p>
</td></tr>
<tr><td><code id="rTraitCauchy_+3A_parameters">parameters</code></td>
<td>
<p>list of parameters for the model (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default choice of parameters is as follow:
</p>

<dl>
<dt><code>model = cauchy</code></dt><dd> 
<p><code>root.value = 0</code>, <code>disp = 1</code>
</p>
</dd>
<dt><code>model = lambda</code></dt><dd> 
<p><code>root.value = 0</code>, <code>disp = 1</code>, <code>lambda = 1</code>
</p>
</dd>
<dt><code>model = kappa</code></dt><dd> 
<p><code>root.value = 0</code>, <code>disp = 1</code>, <code>kappa = 1</code>
</p>
</dd>
<dt><code>model = delta</code></dt><dd> 
<p><code>root.value = 0</code>, <code>disp = 1</code>, <code>delta = 1</code>
</p>
</dd>
</dl>



<h3>Value</h3>

<p>If n=1, a numeric vector with names from the tip labels in the tree.
For more than 1 replicate, a matrix with the tip labels as row names, and one column per replicate.
</p>


<h3>See Also</h3>

<p><code><a href="phylolm.html#topic+rTrait">rTrait</a></code>, <code><a href="ape.html#topic+rTraitCont">rTraitCont</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1289)
phy &lt;- ape::rphylo(40, 0.01, 0)
# One trait
y &lt;- rTraitCauchy(n = 1, phy = phy, model = "cauchy",
                  parameters = list(root.value = 0, disp = 0.1))
y
plot(phy, x.lim = c(0, 750))
phydataplot(y, phy, offset = 150)
# Many trait
y &lt;- rTraitCauchy(n = 10, phy = phy, model = "cauchy",
                  parameters = list(root.value = 0, disp = 0.1))
head(y)


</code></pre>

<hr>
<h2 id='safe_get'>Safely get element of a named vector</h2><span id='topic+safe_get'></span>

<h3>Description</h3>

<p>If the element does not exist, return NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safe_get(x, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="safe_get_+3A_x">x</code></td>
<td>
<p>a named vector</p>
</td></tr>
<tr><td><code id="safe_get_+3A_name">name</code></td>
<td>
<p>the name of the element to retrieve.</p>
</td></tr>
</table>

<hr>
<h2 id='simulateTipsCauchy'>Simulate using the Cauchy Process</h2><span id='topic+simulateTipsCauchy'></span>

<h3>Description</h3>

<p>Simulate tip values with a Cauchy process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateTipsCauchy(tree, root.value, disp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateTipsCauchy_+3A_tree">tree</code></td>
<td>
<p>a phylogeny in <code><a href="ape.html#topic+ape">ape</a></code> <code><a href="ape.html#topic+phylo">phylo</a></code> format.</p>
</td></tr>
<tr><td><code id="simulateTipsCauchy_+3A_root.value">root.value</code></td>
<td>
<p>the initial root trait value.</p>
</td></tr>
<tr><td><code id="simulateTipsCauchy_+3A_disp">disp</code></td>
<td>
<p>the dispersion parameter of the Cauchy process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of simulated values.
</p>

<hr>
<h2 id='transformBranchLengths'>Transform branch lengths</h2><span id='topic+transformBranchLengths'></span>

<h3>Description</h3>

<p>Transform branch lengths for pagel lambda model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformBranchLengths(phy, model, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformBranchLengths_+3A_phy">phy</code></td>
<td>
<p>the phylogenetic tree</p>
</td></tr>
<tr><td><code id="transformBranchLengths_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="transformBranchLengths_+3A_param">param</code></td>
<td>
<p>the parameters</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
