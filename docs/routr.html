<!DOCTYPE html><html><head><title>Help for package routr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {routr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#routr-package'><p>routr: A Simple Router for HTTP and WebSocket Requests</p></a></li>
<li><a href='#ressource_route'><p>Create a route for fetching files</p></a></li>
<li><a href='#Route'><p>Create a route for dispatching on URL</p></a></li>
<li><a href='#RouteStack'><p>Combine multiple routes for sequential routing</p></a></li>
<li><a href='#sizelimit_route'><p>Limit the size of requests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Simple Router for HTTP and WebSocket Requests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In order to make sure that web request ends up in the correct 
    handler function a router is often used. 'routr' is a package implementing a
    simple but powerful routing functionality for R based servers. It is a fully
    functional 'fiery' plugin, but can also be used with other 'httpuv' based
    servers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, assertthat, uuid, reqres, stringi, tools, digest</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, fiery</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://routr.data-imaginist.com">https://routr.data-imaginist.com</a>,
<a href="https://github.com/thomasp85/routr#routr">https://github.com/thomasp85/routr#routr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/routr/issues">https://github.com/thomasp85/routr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-19 13:22:22 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 13:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='routr-package'>routr: A Simple Router for HTTP and WebSocket Requests</h2><span id='topic+routr'></span><span id='topic+routr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>In order to make sure that web request ends up in the correct handler function a router is often used. 'routr' is a package implementing a simple but powerful routing functionality for R based servers. It is a fully functional 'fiery' plugin, but can also be used with other 'httpuv' based servers.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://routr.data-imaginist.com">https://routr.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/routr#routr">https://github.com/thomasp85/routr#routr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/routr/issues">https://github.com/thomasp85/routr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ressource_route'>Create a route for fetching files</h2><span id='topic+ressource_route'></span>

<h3>Description</h3>

<p>This function creates a route mapping different paths to files on the server
filesystem. Different subpaths can be mapped to different locations on the
server so that e.g. <code style="white-space: pre;">&#8288;/data/&#8288;</code> maps to <code style="white-space: pre;">&#8288;/path/to/data/&#8288;</code> and <code style="white-space: pre;">&#8288;/assets/&#8288;</code> maps to
<code style="white-space: pre;">&#8288;/a/completely/different/path/&#8288;</code>. The route support automatic expansion of
paths to a default extension or file, using compressed versions of files if
the request permits it, and setting the correct headers so that results are
cached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ressource_route(
  ...,
  default_file = "index.html",
  default_ext = "html",
  finalize = NULL,
  continue = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ressource_route_+3A_...">...</code></td>
<td>
<p>Named arguments mapping a subpath in the URL to a location on the
file system. These mappings will be checked in sequence</p>
</td></tr>
<tr><td><code id="ressource_route_+3A_default_file">default_file</code></td>
<td>
<p>The default file to look for if the path does not map to
a file directly (see Details)</p>
</td></tr>
<tr><td><code id="ressource_route_+3A_default_ext">default_ext</code></td>
<td>
<p>The default file extension to add to the file if a file
cannot be found at the provided path and the path does not have an extension
(see Details)</p>
</td></tr>
<tr><td><code id="ressource_route_+3A_finalize">finalize</code></td>
<td>
<p>An optional function to run if a file is found. The function
will recieve the request as the first argument, the response as the second,
and anything passed on through <code>...</code> in the <code>dispatch</code> method. Any return
value from the function is discarded.</p>
</td></tr>
<tr><td><code id="ressource_route_+3A_continue">continue</code></td>
<td>
<p>A logical that should be returned if a file is found.
Defaults to <code>FALSE</code> indicating that the response should be send unmodified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The way paths are resolved to a file is, for every mounted location,
</p>

<ol>
<li><p> Check if the path contains the mount point. If not, continue to the next
mount point
</p>
</li>
<li><p> substitute the mount point for the local location in the path
</p>
</li>
<li><p> if the path ends with <code>/</code> add the <code>default_file</code> (defaults to <code>index.html</code>)
</p>
</li>
<li><p> see if the file exists along with compressed versions (versions with
<code>.gz</code>, <code>.zip</code>, <code>.br</code>, <code>.zz</code> appended)
</p>
</li>
<li><p> if any version exists, chose the prefered encoding based on the
<code>Accept-Encoding</code> header in the request, and return.
</p>
</li>
<li><p> if none exists and the path does not specify a file extension, add
<code>default_ext</code> to the path and repeat 3-4
</p>
</li>
<li><p> if none exists still and the path does not specify a file extension, add
<code>default_file</code> to the path and repeat 3-4
</p>
</li>
<li><p> if none exists still, continue to the next mount point
</p>
</li></ol>

<p>This means that for the path <code style="white-space: pre;">&#8288;/data/mtcars&#8288;</code>, the following locations will be
tested (assuming the <code style="white-space: pre;">&#8288;/data/&#8288;</code> -&gt; <code style="white-space: pre;">&#8288;/path/to/data/&#8288;</code> mapping):
</p>

<ol>
<li> <p><code style="white-space: pre;">&#8288;/path/to/data/mtcars&#8288;</code>, <code style="white-space: pre;">&#8288;/path/to/data/mtcars.gz&#8288;</code>,
<code style="white-space: pre;">&#8288;/path/to/data/mtcars.zip&#8288;</code>, <code style="white-space: pre;">&#8288;/path/to/data/mtcars.br&#8288;</code>,
<code style="white-space: pre;">&#8288;/path/to/data/mtcars.zz&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;/path/to/data/mtcars.html&#8288;</code>, <code style="white-space: pre;">&#8288;/path/to/data/mtcars.html.gz&#8288;</code>,
<code style="white-space: pre;">&#8288;/path/to/data/mtcars.html.zip&#8288;</code>, <code style="white-space: pre;">&#8288;/path/to/data/mtcars.html.br&#8288;</code>,
<code style="white-space: pre;">&#8288;/path/to/data/mtcars.html.zz&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;/path/to/data/mtcars/index.html&#8288;</code>, <code style="white-space: pre;">&#8288;/path/to/data/mtcars/index.html.gz&#8288;</code>,
<code style="white-space: pre;">&#8288;/path/to/data/mtcars/index.html.zip&#8288;</code>, <code style="white-space: pre;">&#8288;/path/to/data/mtcars/index.html.br&#8288;</code>,
<code style="white-space: pre;">&#8288;/path/to/data/mtcars/index.html.zz&#8288;</code>
</p>
</li></ol>

<p>Assuming the default values of <code>default_file</code> and <code>default_ext</code>
</p>
<p>If a file is not found, the route will simply return <code>TRUE</code> to hand of
control to subsequent routes in the stack, otherwise it will return the
logical value in the <code>continue</code> argument (defaults to <code>FALSE</code>, thus
shortcutting any additional routes in the stack).
</p>
<p>If a file is found the request headers <code>If-Modified-Since</code> and
<code>If-None-Match</code>, will be fetched and, if exist, will be used to determine
whether a <code style="white-space: pre;">&#8288;304 - Not Modified&#8288;</code> response should be send instead of the file.
If the file should be send, it will be added to the response along with the
following headers:
</p>

<ul>
<li> <p><code>Content-Type</code> based on the extension of the file (without any encoding
extensions)
</p>
</li>
<li> <p><code>Content-Encoding</code> based on the negotiated file encoding
</p>
</li>
<li> <p><code>ETag</code> based on <code><a href="digest.html#topic+digest">digest::digest()</a></code> of the last modified date
</p>
</li>
<li> <p><code>Cache-Control</code> set to <code>max-age=3600</code>
</p>
</li></ul>

<p>Furthermore <code>Content-Length</code> will be set automatically by <code>httpuv</code>
</p>
<p>Lastly, if found, the finalize function will be called, forwarding the
<code>request</code>, <code>response</code> and <code>...</code> from the <code>dispatch</code> method.
</p>


<h3>Value</h3>

<p>Either <code>TRUE</code> if no file is found or <code>continue = TRUE</code> or <code>FALSE</code> if
a file is found and <code>continue = FALSE</code>
</p>


<h3>See Also</h3>

<p>Other Route constructors: 
<code><a href="#topic+sizelimit_route">sizelimit_route</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Map package files
res_route &lt;- ressource_route(
  '/package_files/' = system.file(package = 'routr')
)

rook &lt;- fiery::fake_request('http://example.com/package_files/DESCRIPTION')
req &lt;- reqres::Request$new(rook)
res_route$dispatch(req)
req$response$as_list()
</code></pre>

<hr>
<h2 id='Route'>Create a route for dispatching on URL</h2><span id='topic+Route'></span>

<h3>Description</h3>

<p>The <code>Route</code> class is used to encapsulate a single URL dispatch, that is,
chose a single handler from a range based on a URL path. A handler will be
called with a request, response, and keys argument as well as any additional
arguments passed on to <code>dispatch()</code>.
</p>


<h3>Details</h3>

<p>The path will strip the query string prior to assignment of the handler, can
contain wildcards, and can be parameterised using the <code>:</code> prefix. If there
are multiple matches of the request path the most specific will be chosen.
Specificity is based on number of elements (most), number of parameters
(least), and number of wildcards (least), in that order. Parameter
values will be available in the keys argument passed to the handler, e.g. a
path of <code style="white-space: pre;">&#8288;/user/:user_id&#8288;</code> will provide <code>list(user_id = 123)</code> for a dispatch on
<code style="white-space: pre;">&#8288;/user/123&#8288;</code> in the <code>keys</code> argument.
</p>
<p>Handlers are only called for their side-effects and are expected to return
either <code>TRUE</code> or <code>FALSE</code> indicating whether additional routes in a
<code><a href="#topic+RouteStack">RouteStack</a></code> should be called, e.g. if a handler is returning <code>FALSE</code> all
further processing of the request will be terminated and the response will be
passed along in its current state. Thus, the intend of the handlers is to
modify the request and response objects, in place. All calls to handlers will
be wrapped in <code><a href="base.html#topic+try">try()</a></code> and if an exception is raised the response code will be
set to <code>500</code> with the body of the response being the error message. Further
processing of the request will be terminated. If a different error handling
scheme is wanted it must be implemented within the handler (the standard
approach is chosen to avoid handler errors resulting in a server crash).
</p>
<p>A handler is referencing a specific HTTP method (<code>get</code>, <code>post</code>, etc.) but can
also reference <code>all</code> to indicate that it should match all types of requests.
Handlers referencing <code>all</code> have lower precedence than those referencing
specific methods, so will only be called if a match is not found within the
handlers of the specific method.
</p>


<h3>Initialization</h3>

<p>A new 'Route'-object is initialized using the <code>new()</code> method on the
generator:
</p>
<p><strong>Usage</strong>
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>route &lt;- Route$new(...)</code>
</td>
</tr>

</table>

<p><strong>Arguments</strong>
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> Handlers to add up front. Must be in the form of named
lists where the names corresponds to paths and the elements are the handlers.
The name of the argument itself defines the method to listen on (see examples)
</td>
</tr>

</table>



<h3>Methods</h3>

<p>The following methods are accessible in a <code>Route</code> object:
</p>

<dl>
<dt><code>add_handler(method, path, handler)</code></dt><dd><p>Add a handler to the specified
method and path. The special method <code>'all'</code> will allow the handler to match
all http request methods. The path is a URL path consisting of strings,
parameters (strings prefixed with <code>:</code>), and wildcards (<code>*</code>), separated by
<code>/</code>. A wildcard will match anything and is thus not restricted to a single
path element (i.e. it will span multiple <code>/</code> if possible). The handler must
be a function containing the arguments <code>request</code>, <code>response</code>, <code>keys</code>, and
<code>...</code>, and must return either <code>TRUE</code> or <code>FALSE</code>. The <code>request</code> argument will
be a <a href="reqres.html#topic+Request">reqres::Request</a> object and the <code>response</code> argument will be a
<a href="reqres.html#topic+Response">reqres::Response</a> object matching the current exchange. The <code>keys</code> argument
will be a named list with the value of all matched parameters from the path.
Any additional argument passed on to the <code>dispatch</code> method will be avaiable
as well. This method will override an existing handler with the same method
and path.</p>
</dd>
<dt><code>remove_handler(method, path)</code></dt><dd><p>Removes the handler assigned to the
specified method and path. If no handler have been assigned it will throw a
warning.</p>
</dd>
<dt><code>get_handler(method, path)</code></dt><dd><p>Returns a handler already assigned
to the specified method and path. If no handler have been assigned it will
throw a warning.</p>
</dd>
<dt><code>remap_handlers(.f)</code></dt><dd><p>Allows you to loop through all added handlers
and reassings them at will. A function with the parameters <code>method</code>, <code>path</code>,
and <code>handler</code> must be provided which is responsible for reassigning the
handler given in the arguments. If the function does not reassign the
handler, then the handler is removed.</p>
</dd>
<dt><code>dispatch(request, ...)</code></dt><dd><p>Based on a <a href="reqres.html#topic+Request">reqres::Request</a> object the
route will find the correct handler and call it with the correct arguments.
Anything passed in with <code>...</code> will be passed along to the handler.</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Route-new"><code>Route$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Route-print"><code>Route$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Route-add_handler"><code>Route$add_handler()</code></a>
</p>
</li>
<li> <p><a href="#method-Route-remove_handler"><code>Route$remove_handler()</code></a>
</p>
</li>
<li> <p><a href="#method-Route-get_handler"><code>Route$get_handler()</code></a>
</p>
</li>
<li> <p><a href="#method-Route-remap_handlers"><code>Route$remap_handlers()</code></a>
</p>
</li>
<li> <p><a href="#method-Route-dispatch"><code>Route$dispatch()</code></a>
</p>
</li>
<li> <p><a href="#method-Route-clone"><code>Route$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Route-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Route$new(...)</pre></div>


<hr>
<a id="method-Route-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Route$print(...)</pre></div>


<hr>
<a id="method-Route-add_handler"></a>



<h4>Method <code>add_handler()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Route$add_handler(method, path, handler)</pre></div>


<hr>
<a id="method-Route-remove_handler"></a>



<h4>Method <code>remove_handler()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Route$remove_handler(method, path)</pre></div>


<hr>
<a id="method-Route-get_handler"></a>



<h4>Method <code>get_handler()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Route$get_handler(method, path)</pre></div>


<hr>
<a id="method-Route-remap_handlers"></a>



<h4>Method <code>remap_handlers()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Route$remap_handlers(.f)</pre></div>


<hr>
<a id="method-Route-dispatch"></a>



<h4>Method <code>dispatch()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Route$dispatch(request, ...)</pre></div>


<hr>
<a id="method-Route-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Route$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+RouteStack">RouteStack</a> for binding multiple routes sequentially
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Initialise an empty route
route &lt;- Route$new()

# Initialise a route with handlers assigned
route &lt;- Route$new(
  all = list(
    '/*' = function(request, response, keys, ...) {
      message('Request recieved')
      TRUE
    }
  )
)

# Remove it again
route$remove_handler('all', '/*')

</code></pre>

<hr>
<h2 id='RouteStack'>Combine multiple routes for sequential routing</h2><span id='topic+RouteStack'></span>

<h3>Description</h3>

<p>The <code>RouteStack</code> class encapsulate multiple <a href="#topic+Route">Route</a>s and lets a request be
passed through each sequentially. If a route is returning <code>FALSE</code> upon
dispatch further dispatching is cancelled.
</p>


<h3>Initialization</h3>

<p>A new 'RouteStack'-object is initialized using the <code>new()</code> method on the
generator:
</p>
<p><strong>Usage</strong>
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>route &lt;- RouteStack$new(..., path_extractor = function(msg, bin) '/')</code>
</td>
</tr>

</table>

<p><strong>Arguments</strong>
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> Routes to add up front. Must be in the form of named
arguments containing <code>Route</code> objects. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>path_extractor</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> A function that returns a path to dispatch
on from a WebSocket message. Will only be used if
<code>attach_to == 'message'</code>. Defaults to a function returning <code>'/'</code>
</td>
</tr>

</table>



<h3>Field</h3>

<p>The following fields are accessible in a <code>RouteStack</code> object:
</p>

<dl>
<dt><code>attach_to</code></dt><dd><p>Either <code>"request"</code> (default), <code>"header"</code>, or <code>"message"</code>
that defines which event the router should be attached to when used as a
<code>fiery</code> plugin.</p>
</dd>
<dt><code>name</code></dt><dd><p>The plugin name (used by <code>fiery</code>). Will return <code>'&lt;attach_to&gt;_routr'</code> (e.g. <code>'request_routr'</code> if <code>attach_to == 'request'</code>)</p>
</dd>
</dl>



<h3>Methods</h3>

<p>The following methods are accessible in a <code>RouteStack</code> object:
</p>

<dl>
<dt><code>add_route(route, name, after = NULL)</code></dt><dd><p>Adds a new route to the stack.
<code>route</code> must be a <code>Route</code> object, <code>name</code> must be a string. If <code>after</code> is
given the route will be inserted after the given index, if not (or <code>NULL</code>)
it will be inserted in the end of the stack.</p>
</dd>
<dt><code>has_route(name)</code></dt><dd><p>Test if the routestack contains a route with the
given name.</p>
</dd>
<dt><code>remove(name)</code></dt><dd><p>Removes the route with the given name from the stack.</p>
</dd>
<dt><code>dispatch(request, ...)</code></dt><dd><p>Passes a <a href="reqres.html#topic+Request">reqres::Request</a> through the stack
of routes in sequence until one of the routes return <code>FALSE</code> or every route
have been passed through. <code>...</code> will be passed on to the dispatch of each
<code>Route</code> on the stack.</p>
</dd>
<dt><code>on_error(fun)</code></dt><dd><p>Set the error handling function. This must be a
function that accepts an <code>error</code>, <code>request</code>, and <code>reponse</code> argument. The
error handler will be called if any of the route handlers throws an error
and can be used to modify the <code>500</code> response before it is send back. By
default, the error will be signaled using <code>message</code></p>
</dd>
<dt><code>on_attach(app, on_error = NULL, ...)</code></dt><dd><p>Method for use by <code>fiery</code> when
attached as a plugin. Should not be called directly.</p>
</dd>
</dl>



<h3>Fiery plugin</h3>

<p>A <code>RouteStack</code> object is a valid <code>fiery</code> plugin and can thus be passed in to
the <code>attach()</code> method of a <code>Fire</code> object. When used as a fiery plugin it is
important to be concious for what event it is attached to. By default it will
be attached to the <code>request</code> event and thus be used to handle HTTP request
messaging. An alternative is to attach it to the <code>header</code> event that is fired
when all headers have been recieved but before the body is. This allows you
to short-circuit request handling and e.g. reject requests above a certain
size. When the router is attached to the <code>header</code> event any handler returning
<code>FALSE</code> will signal that further handling of the request should be stopped
and the response in its current form should be returned without fetching the
request body.
</p>
<p>One last possibility is to attach it to the <code>message</code> event and thus use it
to handle WebSocket messages. This use case is a bit different from that of
<code>request</code> and <code>header</code>. As <code>routr</code> uses <code>Request</code> objects as a vessel between
routes and WebSocket messages are not HTTP requests, some modification is
needed. The way <code>routr</code> achieves this is be modifying the HTTP request that
established the WebSocket connection and send this through the routes. Using
the <code>path_extractor</code> function provided in the <code>RouteStack</code> constructor it
will extract a path to dispatch on and assign it to the request. Furthermore
it assigns the message to the body of the request and sets the <code>Content-Type</code>
header based on whether the message is binary <code>application/octet-stream</code> or
not <code>text/plain</code>. As WebSocket communication is asynchronous the response is
ignored when attached to the <code>message</code> event. If communication should be send
back, use <code>server$send()</code> inside the handler(s).
</p>
<p>How a <code>RouteStack</code> is attached is defined by the <code>attach_to</code> field which must
be either <code>'request'</code>, <code>'header'</code>, or <code>'message'</code>.
</p>
<p>When attaching the <code>RouteStack</code> it is possible to modify how errors are
handled, using the <code>on_error</code> argument, which will change the error handler
set on the <code>RouteStack</code>. By default the error handler will be changed to
using the <code>fiery</code> logging system if the <code>Fire</code> object supports it.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RouteStack-new"><code>RouteStack$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RouteStack-print"><code>RouteStack$print()</code></a>
</p>
</li>
<li> <p><a href="#method-RouteStack-add_route"><code>RouteStack$add_route()</code></a>
</p>
</li>
<li> <p><a href="#method-RouteStack-get_route"><code>RouteStack$get_route()</code></a>
</p>
</li>
<li> <p><a href="#method-RouteStack-has_route"><code>RouteStack$has_route()</code></a>
</p>
</li>
<li> <p><a href="#method-RouteStack-remove_route"><code>RouteStack$remove_route()</code></a>
</p>
</li>
<li> <p><a href="#method-RouteStack-dispatch"><code>RouteStack$dispatch()</code></a>
</p>
</li>
<li> <p><a href="#method-RouteStack-on_attach"><code>RouteStack$on_attach()</code></a>
</p>
</li>
<li> <p><a href="#method-RouteStack-on_error"><code>RouteStack$on_error()</code></a>
</p>
</li>
<li> <p><a href="#method-RouteStack-clone"><code>RouteStack$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RouteStack-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RouteStack$new(..., path_extractor = function(msg, bin) "/")</pre></div>


<hr>
<a id="method-RouteStack-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RouteStack$print(...)</pre></div>


<hr>
<a id="method-RouteStack-add_route"></a>



<h4>Method <code>add_route()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RouteStack$add_route(route, name, after = NULL)</pre></div>


<hr>
<a id="method-RouteStack-get_route"></a>



<h4>Method <code>get_route()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RouteStack$get_route(name)</pre></div>


<hr>
<a id="method-RouteStack-has_route"></a>



<h4>Method <code>has_route()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RouteStack$has_route(name)</pre></div>


<hr>
<a id="method-RouteStack-remove_route"></a>



<h4>Method <code>remove_route()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RouteStack$remove_route(name)</pre></div>


<hr>
<a id="method-RouteStack-dispatch"></a>



<h4>Method <code>dispatch()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RouteStack$dispatch(request, ...)</pre></div>


<hr>
<a id="method-RouteStack-on_attach"></a>



<h4>Method <code>on_attach()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RouteStack$on_attach(app, on_error = NULL, ...)</pre></div>


<hr>
<a id="method-RouteStack-on_error"></a>



<h4>Method <code>on_error()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RouteStack$on_error(fun)</pre></div>


<hr>
<a id="method-RouteStack-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RouteStack$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+Route">Route</a> for defining single routes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new stack
routes &lt;- RouteStack$new()

# Populate it wih routes
first &lt;- Route$new()
first$add_handler('all', '*', function(request, response, keys, ...) {
  message('This will always get called first')
  TRUE
})
second &lt;- Route$new()
second$add_handler('get', '/demo/', function(request, response, keys, ...) {
  message('This will get called next if the request asks for /demo/')
  TRUE
})
routes$add_route(first, 'first')
routes$add_route(second, 'second')

# Send a request through
rook &lt;- fiery::fake_request('http://example.com/demo/', method = 'get')
req &lt;- reqres::Request$new(rook)
routes$dispatch(req)

</code></pre>

<hr>
<h2 id='sizelimit_route'>Limit the size of requests</h2><span id='topic+sizelimit_route'></span>

<h3>Description</h3>

<p>This route is meant for being called prior to retrieving of the request body.
It inspects the <code>Content-Length</code> header and determines if the request should
be allowed to proceed. The limit can be made variable by supplying a function
to the <code>limit</code> argument returning a numeric. If the <code>Content-Length</code> header
is missing and the limit is not <code>Inf</code> the response will be set to
<code style="white-space: pre;">&#8288;411 - Length Required&#8288;</code>, If the header exists but exceeds the limit the
response will be set to <code style="white-space: pre;">&#8288;413 - Request Entity Too Large&#8288;</code>. Otherwise the route
will return <code>TRUE</code> and leave the response unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizelimit_route(limit = 5 * 1024^2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sizelimit_route_+3A_limit">limit</code></td>
<td>
<p>Either a numeric or a function returning a numeric when called
with the request</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the request are allowed to proceed, or <code>FALSE</code> if it should
be terminated
</p>


<h3>See Also</h3>

<p>Other Route constructors: 
<code><a href="#topic+ressource_route">ressource_route</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>limit_route &lt;- sizelimit_route() # Default 5Mb limit
rook &lt;- fiery::fake_request('http://www.example.com', 'post',
                            headers = list(Content_Length = 30*1024^2))
req &lt;- reqres::Request$new(rook)
limit_route$dispatch(req)
req$respond()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
