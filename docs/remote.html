<!DOCTYPE html><html><head><title>Help for package remote</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {remote}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#remote-package'><p>R EMpirical Orthogonal TEleconnections</p></a></li>
<li><a href='#anomalize'><p>Create an anomaly RasterStack</p></a></li>
<li><a href='#australiaGPCP'><p>Monthly GPCP precipitation data for Australia</p></a></li>
<li><a href='#calcVar'><p>Calculate space-time variance of a RasterStack or RasterBrick</p></a></li>
<li><a href='#covWeight'><p>Create a weighted covariance matrix</p></a></li>
<li><a href='#cutStack'><p>Shorten a RasterStack</p></a></li>
<li><a href='#deg2rad'><p>Convert degrees to radians</p></a></li>
<li><a href='#denoise'><p>Noise filtering through principal components</p></a></li>
<li><a href='#deseason'><p>Create seasonal anomalies</p></a></li>
<li><a href='#eot'><p>EOT analysis of a predictor and (optionally) a response RasterStack</p></a></li>
<li><a href='#EotCycle'><p>Calculate a single EOT</p></a></li>
<li><a href='#EotMode-class'><p>Class EotMode</p></a></li>
<li><a href='#EotStack-class'><p>Class EotStack</p></a></li>
<li><a href='#geoWeight'><p>Geographic weighting</p></a></li>
<li><a href='#getWeights'><p>Calculate weights from latitude</p></a></li>
<li><a href='#lagalize'><p>Create lagged RasterStacks</p></a></li>
<li><a href='#longtermMeans'><p>Calculate long-term means from a 'RasterStack'</p></a></li>
<li><a href='#names'><p>Names of Eot* objects</p></a></li>
<li><a href='#nmodes'><p>Number of modes of an EotStack</p></a></li>
<li><a href='#nXplain'><p>Number of EOTs needed for variance explanation</p></a></li>
<li><a href='#pacificSST'><p>Monthly SSTs for the tropical Pacific Ocean</p></a></li>
<li><a href='#plot'><p>Plot an Eot* object</p></a></li>
<li><a href='#predict'><p>EOT based spatial prediction</p></a></li>
<li><a href='#subset'><p>Subset modes in EotStacks</p></a></li>
<li><a href='#vdendool'><p>Mean seasonal (DJF) 700 mb geopotential heights</p></a></li>
<li><a href='#writeEot'><p>Write Eot* objects to disk</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Empirical Orthogonal Teleconnections in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-09-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Appelhans, Florian Detsch, Thomas Nauss</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Appelhans &lt;tim.appelhans@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Empirical orthogonal teleconnections in R.
    'remote' is short for 'R(-based) EMpirical Orthogonal TEleconnections'.
    It implements a collection of functions to facilitate empirical
    orthogonal teleconnection analysis. Empirical Orthogonal Teleconnections
    (EOTs) denote a regression based approach to decompose spatio-temporal
    fields into a set of independent orthogonal patterns. They are quite
    similar to Empirical Orthogonal Functions (EOFs) with EOTs producing
    less abstract results. In contrast to EOFs, which are orthogonal in both
    space and time, EOT analysis produces patterns that are orthogonal in
    either space or time.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), Rcpp (&ge; 0.10.3), raster, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, gridExtra, latticeExtra, mapdata, scales, stats,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>maps, lattice, grid, sp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-09-17 09:32:58 UTC; ede</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-09-17 18:03:36</td>
</tr>
</table>
<hr>
<h2 id='remote-package'>R EMpirical Orthogonal TEleconnections</h2><span id='topic+remote'></span><span id='topic+remote-package'></span>

<h3>Description</h3>

<p>R EMpirical Orthogonal TEleconnections
</p>


<h3>Details</h3>

<p>A collection of functions to facilitate empirical orthogonal teleconnection analysis. 
Some handy functions for preprocessing, such as deseasoning, denoising, lagging 
are readily available for ease of usage.
</p>


<h3>Author(s)</h3>

<p>Tim Appelhans, Florian Detsch<br />
<br />
<em>Maintainer:</em> Tim Appelhans <a href="mailto:tim.appelhans@gmail.com">tim.appelhans@gmail.com</a>
</p>


<h3>References</h3>

<p>Empirical Orthogonal Teleconnections<br />
H. M. van den Dool, S. Saha, A. Johansson (2000)<br />
Journal of Climate, Volume 13, Issue 8 (April 2000) pp. 1421 - 1435<br />
</p>
<p>Empirical methods in short-term climate prediction<br />
H. M. van den Dool (2007)<br />
Oxford University Press, Oxford, New York (2007)<br />
</p>


<h3>See Also</h3>

<p><span class="pkg">remote</span> is built upon Raster* classes from the <code><a href="raster.html#topic+raster-package">raster-package</a></code>.
Please see their documentation for data preparation etc.
</p>

<hr>
<h2 id='anomalize'>Create an anomaly RasterStack</h2><span id='topic+anomalize'></span>

<h3>Description</h3>

<p>The function creates an anomaly RasterStack either based on the
overall mean of the original stack, or a supplied reference RasterLayer.
For the creation of seasonal anomalies use <code><a href="#topic+deseason">deseason</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anomalize(x, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anomalize_+3A_x">x</code></td>
<td>
<p>a RasterStack</p>
</td></tr>
<tr><td><code id="anomalize_+3A_reference">reference</code></td>
<td>
<p>an optional RasterLayer to be used as the reference</p>
</td></tr>
<tr><td><code id="anomalize_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="raster.html#topic+calc">calc</a></code> (and, in turn, 
<code><a href="raster.html#topic+writeRaster">writeRaster</a></code>) which is used under the hood</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an anomaly RasterStack
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deseason">deseason</a></code>, <code><a href="#topic+denoise">denoise</a></code>, <code><a href="raster.html#topic+calc">calc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(australiaGPCP)

aus_anom &lt;- anomalize(australiaGPCP)

opar &lt;- par(mfrow = c(1,2))
plot(australiaGPCP[[10]], main = "original")
plot(aus_anom[[10]], main = "anomalized")
par(opar)
</code></pre>

<hr>
<h2 id='australiaGPCP'>Monthly GPCP precipitation data for Australia</h2><span id='topic+australiaGPCP'></span>

<h3>Description</h3>

<p>Monthly Gridded Precipitation Climatology Project precipitation data 
for Australia from 1982/01 to 2010/12
</p>


<h3>Format</h3>

<p>a RasterBrick with the following attributes<br />
<br />
dimensions  : 12, 20, 240, 348  (nrow, ncol, ncell, nlayers)<br />
resolution  : 2.5, 2.5  (x, y)<br />
extent      : 110, 160, -40, -10  (xmin, xmax, ymin, ymax)<br />
coord. ref. : +proj=longlat +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +no_defs<br /></p>


<h3>Details</h3>

<p>Monthly Gridded Precipitation Climatology Project precipitation data 
for Australia from 1982/01 to 2010/12
</p>


<h3>References</h3>

<p>The Version-2 Global Precipitation Climatology Project (GPCP) Monthly Precipitation Analysis (1979 - Present)<br />
Adler et al. (2003)<br />
Journal of Hydrometeorology, Volume 4, Issue 6, pp. 1147 - 1167<br />
<a href="http://dx.doi.org/10.1175/1525-7541(2003)004%3C1147:TVGPCP%3E2.0.CO;2">http://dx.doi.org/10.1175/1525-7541(2003)004&lt;1147:TVGPCP&gt;2.0.CO;2</a>
</p>

<hr>
<h2 id='calcVar'>Calculate space-time variance of a RasterStack or RasterBrick</h2><span id='topic+calcVar'></span>

<h3>Description</h3>

<p>The function calculates the (optionally standardised) space-time 
variance of a RasterStack or RasterBrick.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVar(x, standardised = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVar_+3A_x">x</code></td>
<td>
<p>a RasterStack or RasterBrick</p>
</td></tr>
<tr><td><code id="calcVar_+3A_standardised">standardised</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="calcVar_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean (optionally standardised) space-time variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pacificSST")

calcVar(pacificSST)
</code></pre>

<hr>
<h2 id='covWeight'>Create a weighted covariance matrix</h2><span id='topic+covWeight'></span>

<h3>Description</h3>

<p>Create a weighted covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covWeight(m, weights, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covWeight_+3A_m">m</code></td>
<td>
<p>a matrix (e.g. as returned by <code><a href="raster.html#topic+getValues">getValues</a></code>)</p>
</td></tr>
<tr><td><code id="covWeight_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights. For lat/lon data this 
can be produced with <code><a href="#topic+getWeights">getWeights</a></code></p>
</td></tr>
<tr><td><code id="covWeight_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+cov.wt">cov.wt</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>see <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov.wt">cov.wt</a></code>
</p>

<hr>
<h2 id='cutStack'>Shorten a RasterStack</h2><span id='topic+cutStack'></span>

<h3>Description</h3>

<p>The function cuts a specified number of layers off a RrasterStack in 
order to create lagged RasterStacks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutStack(x, tail = TRUE, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutStack_+3A_x">x</code></td>
<td>
<p>a RasterStack</p>
</td></tr>
<tr><td><code id="cutStack_+3A_tail">tail</code></td>
<td>
<p>logical. If <code>TRUE</code> the layers will be taken off
the end of the stack. If <code>FALSE</code> layers will be taken off
the beginning.</p>
</td></tr>
<tr><td><code id="cutStack_+3A_n">n</code></td>
<td>
<p>the number of layers to take away.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a RasterStack shortened by <code>n</code> layers either from the 
beginning or the end, depending on the specification of <code>tail</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(australiaGPCP)

# 6 layers from the beginning
cutStack(australiaGPCP, tail = FALSE, n = 6)
# 8 layers from the end
cutStack(australiaGPCP, tail = TRUE, n = 8)

</code></pre>

<hr>
<h2 id='deg2rad'>Convert degrees to radians</h2><span id='topic+deg2rad'></span>

<h3>Description</h3>

<p>Convert degrees to radians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg2rad(deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deg2rad_+3A_deg">deg</code></td>
<td>
<p>vector of degrees to be converted to radians</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vdendool)

## latitude in degrees
degrees &lt;- coordinates(vdendool)[, 2]
head(degrees)

## latitude in radians
radians &lt;- deg2rad(coordinates(vdendool)[, 2])
head(radians)

</code></pre>

<hr>
<h2 id='denoise'>Noise filtering through principal components</h2><span id='topic+denoise'></span>

<h3>Description</h3>

<p>Filter noise from a RasterStack by decomposing into principal components 
and subsequent reconstruction using only a subset of components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoise(x, k = NULL, expl.var = NULL, weighted = TRUE, use.cpp = TRUE,
  verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoise_+3A_x">x</code></td>
<td>
<p>RasterStack to be filtered</p>
</td></tr>
<tr><td><code id="denoise_+3A_k">k</code></td>
<td>
<p>number of components to be kept for reconstruction 
(ignored if <code>expl.var</code> is supplied)</p>
</td></tr>
<tr><td><code id="denoise_+3A_expl.var">expl.var</code></td>
<td>
<p>minimum amount of variance to be kept after reconstruction
(should be set to NULL or omitted if <code>k</code> is supplied)</p>
</td></tr>
<tr><td><code id="denoise_+3A_weighted">weighted</code></td>
<td>
<p>logical. If <code>TRUE</code> the covariance matrix will be 
geographically weighted using the cosine of latitude during decomposition 
(only important for lat/lon data)</p>
</td></tr>
<tr><td><code id="denoise_+3A_use.cpp">use.cpp</code></td>
<td>
<p>logical. Determines whether to use <strong>Rcpp</strong> 
functionality, defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="denoise_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> some details about the 
calculation process will be output to the console</p>
</td></tr>
<tr><td><code id="denoise_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+princomp">princomp</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a denoised RasterStack
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anomalize">anomalize</a></code>, <code><a href="#topic+deseason">deseason</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("vdendool")
vdd_dns &lt;- denoise(vdendool, expl.var = 0.8)

opar &lt;- par(mfrow = c(1,2))
plot(vdendool[[1]], main = "original")
plot(vdd_dns[[1]], main = "denoised")
par(opar)
</code></pre>

<hr>
<h2 id='deseason'>Create seasonal anomalies</h2><span id='topic+deseason'></span><span id='topic+deseason+2CRasterStackBrick-method'></span><span id='topic+deseason+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The function calculates anomalies of a RasterStack by supplying a 
suitable seasonal window. E. g. to create monthly anomalies of a 
raster stack of 12 layers per year, use <code>cycle.window = 12</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterStackBrick'
deseason(x, cycle.window = 12L,
  use.cpp = FALSE, filename = "", ...)

## S4 method for signature 'numeric'
deseason(x, cycle.window = 12L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deseason_+3A_x">x</code></td>
<td>
<p>An object of class 'RasterStack' (or 'RasterBrick') or, 
alternatively, a 'numeric' time series.</p>
</td></tr>
<tr><td><code id="deseason_+3A_cycle.window">cycle.window</code></td>
<td>
<p>Integer. The window for the creation of the anomalies.</p>
</td></tr>
<tr><td><code id="deseason_+3A_use.cpp">use.cpp</code></td>
<td>
<p>Logical. Determines whether or not to use <strong>Rcpp</strong> 
functionality, defaults to <code>TRUE</code>. Only applies if <code>x</code> is a 
'RasterStack' (or 'RasterBrick') object.</p>
</td></tr>
<tr><td><code id="deseason_+3A_filename">filename</code></td>
<td>
<p><code>character</code>. Output filename (optional).</p>
</td></tr>
<tr><td><code id="deseason_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>, only 
considered if <code>filename</code> is specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a 'RasterStack' (or 'RasterBrick') object, a 
deseasoned 'RasterStack'; else a deseasoned 'numeric' vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anomalize">anomalize</a></code>, <code><a href="#topic+denoise">denoise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("australiaGPCP")

aus_dsn &lt;- deseason(australiaGPCP, 12)

opar &lt;- par(mfrow = c(1,2))
plot(australiaGPCP[[1]], main = "original")
plot(aus_dsn[[1]], main = "deseasoned")
par(opar)
</code></pre>

<hr>
<h2 id='eot'>EOT analysis of a predictor and (optionally) a response RasterStack</h2><span id='topic+eot'></span><span id='topic+eot+2CRasterStackBrick-method'></span>

<h3>Description</h3>

<p>Calculate a given number of EOT modes either internally or between 
RasterStacks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RasterStackBrick'
eot(x, y = NULL, n = 1, standardised = TRUE,
  write.out = FALSE, path.out = ".", prefix = "remote",
  reduce.both = FALSE, type = c("rsq", "ioa"), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eot_+3A_x">x</code></td>
<td>
<p>a RasterStack used as predictor</p>
</td></tr>
<tr><td><code id="eot_+3A_y">y</code></td>
<td>
<p>a RasterStack used as response. If <code>y</code> is <code>NULL</code>,
<code>x</code> is used as <code>y</code></p>
</td></tr>
<tr><td><code id="eot_+3A_n">n</code></td>
<td>
<p>the number of EOT modes to calculate</p>
</td></tr>
<tr><td><code id="eot_+3A_standardised">standardised</code></td>
<td>
<p>logical. If <code>FALSE</code> the calculated r-squared values 
will be multiplied by the variance</p>
</td></tr>
<tr><td><code id="eot_+3A_write.out">write.out</code></td>
<td>
<p>logical. If <code>TRUE</code> results will be written to disk 
using <code>path.out</code></p>
</td></tr>
<tr><td><code id="eot_+3A_path.out">path.out</code></td>
<td>
<p>the file path for writing results if <code>write.out</code> is <code>TRUE</code>.
Defaults to current working directory</p>
</td></tr>
<tr><td><code id="eot_+3A_prefix">prefix</code></td>
<td>
<p>optional prefix to be used for naming of results if 
<code>write.out</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="eot_+3A_reduce.both">reduce.both</code></td>
<td>
<p>logical. If <code>TRUE</code> both <code>x</code> and <code>y</code> 
are reduced after each iteration. If <code>FALSE</code> only <code>y</code> is reduced</p>
</td></tr>
<tr><td><code id="eot_+3A_type">type</code></td>
<td>
<p>the type of the link function. Defaults to <code>'rsq'</code> as in original
proposed method from <cite>van den Dool 2000</cite>. If set to <code>'ioa'</code> index of agreement is
used instead</p>
</td></tr>
<tr><td><code id="eot_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> some details about the 
calculation process will be output to the console</p>
</td></tr>
<tr><td><code id="eot_+3A_...">...</code></td>
<td>
<p>not used at the moment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed description of the EOT algorithm and the mathematics behind it,
see the References section. In brief, the algorithm works as follows: 
First, the temporal profiles of each pixel <em>xp</em> of the predictor domain 
are regressed against the profiles of all pixels <em>xr</em> in the 
response domain. 
The calculated coefficients of determination are summed up and the pixel 
with the highest sum is identified as the 'base point' of the first/leading mode. 
The temporal profile at this base point is the first/leading EOT. 
Then, the residuals from the regression are taken to be the basis 
for the calculation of the next EOT, thus ensuring orthogonality 
of the identified teleconnections. This procedure is repeated until 
a predefined amount of <em>n</em> EOTs is calculated. In general, 
<span class="pkg">remote</span> implements a 'brute force' spatial data mining approach to 
identify locations of enhanced potential to explain spatio-temporal 
variability within the same or another geographic field.
</p>


<h3>Value</h3>

<p>if n = 1 an <em>EotMode</em>, if n &gt; 1 an <em>EotStack</em> of <code>n</code> 
<em>EotMode</em>s. Each <em>EotMode</em> has the following components:
</p>

<ul>
<li> <p><em>mode</em> - the number of the identified mode (1 - n)
</p>
</li>
<li> <p><em>eot</em> - the EOT (time series) at the identified base point. 
Note, this is a simple numeric vector, not of class <code>ts</code>
</p>
</li>
<li> <p><em>coords_bp</em> - the coordinates of the identified base point
</p>
</li>
<li> <p><em>cell_bp</em> - the cell number of the indeified base point
</p>
</li>
<li> <p><em>cum_exp_var</em> - the (cumulative) explained variance of the considered EOT
</p>
</li>
<li> <p><em>r_predictor</em> - the <em>RasterLayer</em> of the correlation coefficients 
between the base point and each pixel of the predictor domain
</p>
</li>
<li> <p><em>rsq_predictor</em> - as above but for the coefficient of determination
</p>
</li>
<li> <p><em>rsq_sums_predictor</em> - as above but for the sums of coefficient of determination
</p>
</li>
<li> <p><em>int_predictor</em> - the <em>RasterLayer</em> of the intercept of the 
regression equation for each pixel of the predictor domain
</p>
</li>
<li> <p><em>slp_predictor</em> - same as above but for the slope of the 
regression equation for each pixel of the predictor domain
</p>
</li>
<li> <p><em>p_predictor</em> - the <em>RasterLayer</em> of the significance (p-value) 
of the the regression equation for each pixel of the predictor domain
</p>
</li>
<li> <p><em>resid_predictor</em> - the <em>RasterBrick</em> of the reduced data 
for the predictor domain
</p>
</li></ul>

<p>Apart from <em>rsq_sums_predictor</em>, all <em>*_predictor</em> fields are 
also returned for the <em>*_response</em> domain, 
even if predictor and response domain are equal. This is due to that fact, 
that if not both fields are reduced after the first EOT is found, 
these <em>RasterLayers</em> will differ.
</p>


<h3>References</h3>

<p><b>Empirical Orthogonal Teleconnections</b><br />
H. M. van den Dool, S. Saha, A. Johansson (2000)<br />
Journal of Climate, Volume 13, Issue 8, pp. 1421-1435<br />
<a href="http://journals.ametsoc.org/doi/abs/10.1175/1520-0442%282000%29013%3C1421%3AEOT%3E2.0.CO%3B2">http://journals.ametsoc.org/doi/abs/10.1175/1520-0442%282000%29013%3C1421%3AEOT%3E2.0.CO%3B2</a>
</p>
<p><b>Empirical methods in short-term climate prediction</b><br />
H. M. van den Dool (2007)<br />
Oxford University Press, Oxford, New York<br />
<a href="https://global.oup.com/academic/product/empirical-methods-in-short-term-climate-prediction-9780199202782?cc=de&amp;lang=en&amp;">https://global.oup.com/academic/product/empirical-methods-in-short-term-climate-prediction-9780199202782?cc=de&amp;lang=en&amp;</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### EXAMPLE I
### a single field
data(vdendool)

## claculate 2 leading modes
nh_modes &lt;- eot(x = vdendool, y = NULL, n = 2, 
                standardised = FALSE, 
                verbose = TRUE)

plot(nh_modes, y = 1, show.bp = TRUE)
plot(nh_modes, y = 2, show.bp = TRUE)

</code></pre>

<hr>
<h2 id='EotCycle'>Calculate a single EOT</h2><span id='topic+EotCycle'></span>

<h3>Description</h3>

<p>EotCycle() calculates a single EOT and is controlled by the main eot() function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EotCycle(x, y, n = 1, standardised, orig.var, write.out, path.out, prefix,
  type, verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EotCycle_+3A_x">x</code></td>
<td>
<p>a ratser stack used as predictor</p>
</td></tr>
<tr><td><code id="EotCycle_+3A_y">y</code></td>
<td>
<p>a RasterStack used as response. If <code>y</code> is <code>NULL</code>,
<code>x</code> is used as <code>y</code></p>
</td></tr>
<tr><td><code id="EotCycle_+3A_n">n</code></td>
<td>
<p>the number of EOT modes to calculate</p>
</td></tr>
<tr><td><code id="EotCycle_+3A_standardised">standardised</code></td>
<td>
<p>logical. If <code>FALSE</code> the calculated r-squared values 
will be multiplied by the variance</p>
</td></tr>
<tr><td><code id="EotCycle_+3A_orig.var">orig.var</code></td>
<td>
<p>original variance of the response domain</p>
</td></tr>
<tr><td><code id="EotCycle_+3A_write.out">write.out</code></td>
<td>
<p>logical. If <code>TRUE</code> results will be written to disk 
using <code>path.out</code></p>
</td></tr>
<tr><td><code id="EotCycle_+3A_path.out">path.out</code></td>
<td>
<p>the file path for writing results if <code>write.out</code> is <code>TRUE</code>.
Defaults to current working directory</p>
</td></tr>
<tr><td><code id="EotCycle_+3A_prefix">prefix</code></td>
<td>
<p>optional prefix to be used for naming of results if 
<code>write.out</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="EotCycle_+3A_type">type</code></td>
<td>
<p>the type of the link function. Defaults to <code>'rsq'</code> as in original
proposed method from <cite>Dool2000</cite>. If set to <code>'ioa'</code> index of agreement is
used instead</p>
</td></tr>
<tr><td><code id="EotCycle_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> some details about the 
calculation process will be output to the console</p>
</td></tr>
<tr><td><code id="EotCycle_+3A_...">...</code></td>
<td>
<p>not used at the moment</p>
</td></tr>
</table>

<hr>
<h2 id='EotMode-class'>Class EotMode</h2><span id='topic+EotMode-class'></span>

<h3>Description</h3>

<p>Class EotMode
</p>


<h3>Slots</h3>


<dl>
<dt><code>mode</code></dt><dd><p>the number of the identified mode</p>
</dd>
<dt><code>name</code></dt><dd><p>the name of the mode</p>
</dd>
<dt><code>eot</code></dt><dd><p>the EOT (time series) at the identified base point. Note, this is a simple numeric vector</p>
</dd>
<dt><code>coords_bp</code></dt><dd><p>the coordinates of the identified base point</p>
</dd>
<dt><code>cell_bp</code></dt><dd><p>the cell number of the indeified base point</p>
</dd>
<dt><code>cum_exp_var</code></dt><dd><p>the cumulative explained variance of the considered EOT mode</p>
</dd>
<dt><code>r_predictor</code></dt><dd><p>the RasterLayer of the correlation coefficients between the base point and each pixel of the predictor domain</p>
</dd>
<dt><code>rsq_predictor</code></dt><dd><p>as above but for the coefficient of determination of the predictor domain</p>
</dd>
<dt><code>rsq_sums_predictor</code></dt><dd><p>as above but for the sums of coefficient of determination of the predictor domain</p>
</dd>
<dt><code>int_predictor</code></dt><dd><p>the RasterLayer of the intercept of the regression equation for each pixel of the predictor domain</p>
</dd>
<dt><code>slp_predictor</code></dt><dd><p>same as above but for the slope of the regression equation for each pixel of the predictor domain</p>
</dd>
<dt><code>p_predictor</code></dt><dd><p>the RasterLayer of the significance (p-value) of the the regression equation for each pixel of the predictor domain</p>
</dd>
<dt><code>resid_predictor</code></dt><dd><p>the RasterBrick of the reduced data for the predictor domain</p>
</dd>
<dt><code>r_response</code></dt><dd><p>the RasterLayer of the correlation coefficients between the base point and each pixel of the response domain</p>
</dd>
<dt><code>rsq_response</code></dt><dd><p>as above but for the coefficient of determination of the response domain</p>
</dd>
<dt><code>int_response</code></dt><dd><p>the RasterLayer of the intercept of the regression equation for each pixel of the response domain</p>
</dd>
<dt><code>slp_response</code></dt><dd><p>as above but for the slope of the regression equation for each pixel of the response domain</p>
</dd>
<dt><code>p_response</code></dt><dd><p>same the RasterLayer of the significance (p-value) of the the regression equation for each pixel of the response domain</p>
</dd>
<dt><code>resid_response</code></dt><dd><p>the RasterBrick of the reduced data for the response domain</p>
</dd>
</dl>

<hr>
<h2 id='EotStack-class'>Class EotStack</h2><span id='topic+EotStack-class'></span>

<h3>Description</h3>

<p>Class EotStack
</p>


<h3>Slots</h3>


<dl>
<dt><code>modes</code></dt><dd><p>a list containing the individual 'EotMode's of the 'EotStack'</p>
</dd>
<dt><code>names</code></dt><dd><p>the names of the modes</p>
</dd>
</dl>

<hr>
<h2 id='geoWeight'>Geographic weighting</h2><span id='topic+geoWeight'></span>

<h3>Description</h3>

<p>The function performs geographic weighting of non-projected long/lat
data. By default it uses the cosine of latitude to compensate for the 
area distortion, though the user can supply other functions via <code>f</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoWeight(x, f = function(x) cos(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geoWeight_+3A_x">x</code></td>
<td>
<p>a Raster* object</p>
</td></tr>
<tr><td><code id="geoWeight_+3A_f">f</code></td>
<td>
<p>a function to be used to the weighting.
Defaults to <code>cos(x)</code></p>
</td></tr>
<tr><td><code id="geoWeight_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to f</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a weighted Raster* object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vdendool)

wgtd &lt;- geoWeight(vdendool)

opar &lt;- par(mfrow = c(1,2))
plot(vdendool[[1]], main = "original")
plot(wgtd[[1]], main = "weighted")
par(opar)
</code></pre>

<hr>
<h2 id='getWeights'>Calculate weights from latitude</h2><span id='topic+getWeights'></span>

<h3>Description</h3>

<p>Calculate weights using the cosine of latitude to compensate for area 
distortion of non-projected lat/lon data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeights(x, f = function(x) cos(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWeights_+3A_x">x</code></td>
<td>
<p>a Raster* object</p>
</td></tr>
<tr><td><code id="getWeights_+3A_f">f</code></td>
<td>
<p>a function to be used to the weighting.
Defaults to <code>cos(x)</code></p>
</td></tr>
<tr><td><code id="getWeights_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to f</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("australiaGPCP")
wghts &lt;- getWeights(australiaGPCP)
wghts_rst &lt;- australiaGPCP[[1]]
wghts_rst[] &lt;- wghts

opar &lt;- par(mfrow = c(1,2))
plot(australiaGPCP[[1]], main = "data")
plot(wghts_rst, main = "weights")
par(opar)

</code></pre>

<hr>
<h2 id='lagalize'>Create lagged RasterStacks</h2><span id='topic+lagalize'></span>

<h3>Description</h3>

<p>The function is used to produce two lagged RasterStacks. The second is cut
from the beginning, the first from the tail to ensure equal output lengths
(provided that input lengths were equal).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagalize(x, y, lag = NULL, freq = 12, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagalize_+3A_x">x</code></td>
<td>
<p>a RasterStack (to be cut from tail)</p>
</td></tr>
<tr><td><code id="lagalize_+3A_y">y</code></td>
<td>
<p>a RasterStack (to be cut from beginning)</p>
</td></tr>
<tr><td><code id="lagalize_+3A_lag">lag</code></td>
<td>
<p>the desired lag (in the native frequency of the RasterStack)</p>
</td></tr>
<tr><td><code id="lagalize_+3A_freq">freq</code></td>
<td>
<p>the frequency of the RasterStacks</p>
</td></tr>
<tr><td><code id="lagalize_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the two RasterStacks lagged by <code>lag</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pacificSST)
data(australiaGPCP)

# lag GPCP by 4 months
lagged &lt;- lagalize(pacificSST, australiaGPCP, lag = 4, freq = 12)
lagged[[1]][[1]] #check names to see date of layer
lagged[[2]][[1]] #check names to see date of layer

</code></pre>

<hr>
<h2 id='longtermMeans'>Calculate long-term means from a 'RasterStack'</h2><span id='topic+longtermMeans'></span>

<h3>Description</h3>

<p>Calculate long-term means from an input 'RasterStack' (or 'RasterBrick') 
object. Ideally, the number of input layers should be divisable by the 
supplied <code>cycle.window</code>. For instance, if <code>x</code> consists of monthly 
layers, <code>cycle.window</code> should be a multiple of 12.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longtermMeans(x, cycle.window = 12L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longtermMeans_+3A_x">x</code></td>
<td>
<p>A 'RasterStack' (or 'RasterBrick') object.</p>
</td></tr>
<tr><td><code id="longtermMeans_+3A_cycle.window">cycle.window</code></td>
<td>
<p>'integer'. See <code><a href="#topic+deseason">deseason</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>cycle.window</code> equals <code>nlayers(x)</code> (which obviously doesn't make 
much sense), a 'RasterLayer' object; else a 'RasterStack' object.
</p>


<h3>Author(s)</h3>

<p>Florian Detsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deseason">deseason</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("australiaGPCP")

longtermMeans(australiaGPCP)

</code></pre>

<hr>
<h2 id='names'>Names of Eot* objects</h2><span id='topic+names'></span><span id='topic+names+2CEotMode-method'></span><span id='topic+names+2CEotStack-method'></span><span id='topic+names+3C-'></span><span id='topic+names+3C-+2CEotMode-method'></span><span id='topic+names+3C-+2CEotStack-method'></span>

<h3>Description</h3>

<p>Get or set names of Eot* objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EotStack'
names(x)

## S4 replacement method for signature 'EotStack'
names(x) &lt;- value

## S4 method for signature 'EotMode'
names(x)

## S4 replacement method for signature 'EotMode'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names_+3A_x">x</code></td>
<td>
<p>a EotMode or EotStack</p>
</td></tr>
<tr><td><code id="names_+3A_value">value</code></td>
<td>
<p>name to be assigned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>x</code> is a EotStack, the names of all mdoes, 
if <code>x</code> is a EotMode, the name the respective mode
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vdendool)

nh_modes &lt;- eot(vdendool, n = 2)

## mode names
names(nh_modes)
names(nh_modes) &lt;- c("vdendool1", "vdendool2")

names(nh_modes)
names(nh_modes[[2]])

</code></pre>

<hr>
<h2 id='nmodes'>Number of modes of an EotStack</h2><span id='topic+nmodes'></span><span id='topic+nmodes+2CEotStack-method'></span>

<h3>Description</h3>

<p>Number of modes of an EotStack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EotStack'
nmodes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmodes_+3A_x">x</code></td>
<td>
<p>an EotStack</p>
</td></tr>
</table>


<h3>Details</h3>

<p>retrieves the number of modes of an EotStack
</p>


<h3>Value</h3>

<p>integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vdendool)

nh_modes &lt;- eot(vdendool, n = 2)

nmodes(nh_modes)

</code></pre>

<hr>
<h2 id='nXplain'>Number of EOTs needed for variance explanation</h2><span id='topic+nXplain'></span><span id='topic+nXplain+2CEotStack-method'></span>

<h3>Description</h3>

<p>The function identifies the number of modes needed to explain a certain amount of
variance within the response field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EotStack'
nXplain(x, var = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nXplain_+3A_x">x</code></td>
<td>
<p>an <em>EotStack</em></p>
</td></tr>
<tr><td><code id="nXplain_+3A_var">var</code></td>
<td>
<p>the minimum amount of variance to be explained by the modes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer denoting the number of EOTs needed to explain <code>var</code>
</p>


<h3>Note</h3>

<p>This is a post-hoc function. It needs an <em>EotStack</em> 
created as returned by <code><a href="#topic+eot">eot</a></code>. Depending on the potency
of the identified EOTs, it may be necessary to compute a high number of 
modes in order to be able to explain a large enough part of the variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vdendool)

nh_modes &lt;- eot(x = vdendool, y = NULL, n = 3, 
                standardised = FALSE, 
                verbose = TRUE)
             
### How many modes are needed to explain 25% of variance?              
nXplain(nh_modes, 0.25)

</code></pre>

<hr>
<h2 id='pacificSST'>Monthly SSTs for the tropical Pacific Ocean</h2><span id='topic+pacificSST'></span>

<h3>Description</h3>

<p>Monthly NOAA sea surface temperatures for the tropical Pacific Ocean from 1982/01 to 2010/12
</p>


<h3>Format</h3>

<p>a RasterBrick with the following attributes<br />
<br />
dimensions  : 30, 140, 4200, 348  (nrow, ncol, ncell, nlayers)<br />
resolution  : 1, 1  (x, y)<br />
extent      : 150, 290, -15, 15  (xmin, xmax, ymin, ymax)<br />
coord. ref. : +proj=longlat +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +no_defs<br /></p>


<h3>Details</h3>

<p>Monthly NOAA sea surface temperatures for the tropical Pacific Ocean from 1982/01 to 2010/12
</p>


<h3>References</h3>

<p>Daily High-Resolution-Blended Analyses for Sea Surface Temperature<br />
Reynolds et al. (2007)<br />
Journal of Climate, Volume 20, Issue 22, pp. 5473 - 5496<br />
<a href="http://dx.doi.org/10.1175/2007JCLI1824.1">http://dx.doi.org/10.1175/2007JCLI1824.1</a>
</p>

<hr>
<h2 id='plot'>Plot an Eot* object</h2><span id='topic+plot'></span><span id='topic+plot+2CEotMode+2CANY-method'></span><span id='topic+plot+2CEotStack+2CANY-method'></span>

<h3>Description</h3>

<p>This is the standard plotting routine for the results of <code><a href="#topic+eot">eot</a></code>.
Three panels will be drawn i) the predictor domain, ii) the response 
domain, iii) the time series at the identified base point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EotMode,ANY'
plot(x, y, pred.prm = "rsq", resp.prm = "r",
  show.bp = FALSE, anomalies = TRUE, add.map = TRUE, ts.vec = NULL,
  arrange = c("wide", "long"), clr = NULL, locations = FALSE, ...)

## S4 method for signature 'EotStack,ANY'
plot(x, y, pred.prm = "rsq", resp.prm = "r",
  show.bp = FALSE, anomalies = TRUE, add.map = TRUE, ts.vec = NULL,
  arrange = c("wide", "long"), clr = NULL, locations = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>either an object of EotMode or EotStack as returned by <code><a href="#topic+eot">eot</a></code></p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>integer or character of the mode to be plotted (e.g. 2 or &quot;mode_2&quot;)</p>
</td></tr>
<tr><td><code id="plot_+3A_pred.prm">pred.prm</code></td>
<td>
<p>the parameter of the predictor to be plotted.<br />
Can be any of &quot;r&quot;, &quot;rsq&quot;, &quot;rsq.sums&quot;, &quot;p&quot;, &quot;int&quot; or &quot;slp&quot;</p>
</td></tr>
<tr><td><code id="plot_+3A_resp.prm">resp.prm</code></td>
<td>
<p>the parameter of the response to be plotted.<br />
Can be any of &quot;r&quot;, &quot;rsq&quot;, &quot;rsq.sums&quot;, &quot;p&quot;, &quot;int&quot; or &quot;slp&quot;</p>
</td></tr>
<tr><td><code id="plot_+3A_show.bp">show.bp</code></td>
<td>
<p>logical. If <code>TRUE</code> a grey circle will be drawn 
in the predictor image to indicate the location of the base point</p>
</td></tr>
<tr><td><code id="plot_+3A_anomalies">anomalies</code></td>
<td>
<p>logical. If <code>TRUE</code> a reference line will be drawn
a 0 in the EOT time series</p>
</td></tr>
<tr><td><code id="plot_+3A_add.map">add.map</code></td>
<td>
<p>logical. If <code>TRUE</code> country outlines will be added 
to the predictor and response images</p>
</td></tr>
<tr><td><code id="plot_+3A_ts.vec">ts.vec</code></td>
<td>
<p>an (optional) time series vector of the considered 
EOT calculation to be shown as the x-axis in the time series plot</p>
</td></tr>
<tr><td><code id="plot_+3A_arrange">arrange</code></td>
<td>
<p>whether the final plot should be arranged in &quot;wide&quot; or
&quot;long&quot; format</p>
</td></tr>
<tr><td><code id="plot_+3A_clr">clr</code></td>
<td>
<p>an (optional) color palette for displaying of the 
predictor and response fields</p>
</td></tr>
<tr><td><code id="plot_+3A_locations">locations</code></td>
<td>
<p>logical. If x is an EotStack, set this to TRUE to 
produce a map showing the locations of all modes. Ignored if x is an
EotMode</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="raster.html#topic+spplot">spplot</a></code></p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>x = EotStack,y = ANY</code>: EotStack
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data(vdendool)

## claculate 2 leading modes
nh_modes &lt;- eot(x = vdendool, y = NULL, n = 2, 
                standardised = FALSE, 
                verbose = TRUE)

## default settings 
plot(nh_modes, y = 1) # is equivalent to

## Not run: 
plot(nh_modes[[1]]) 

plot(nh_modes, y = 2) # shows variance explained by mode 2 only
plot(nh_modes[[2]]) # shows cumulative variance explained by modes 1 &amp; 2

## showing the loction of the mode
plot(nh_modes, y = 1, show.bp = TRUE)

## changing parameters
plot(nh_modes, y = 1, show.bp = TRUE,
     pred.prm = "r", resp.prm = "p")
        
## change plot arrangement
plot(nh_modes, y = 1, show.bp = TRUE, arrange = "long") 

## plot locations of all base points
plot(nh_modes, locations = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='predict'>EOT based spatial prediction</h2><span id='topic+predict'></span><span id='topic+predict+2CEotMode-method'></span><span id='topic+predict+2CEotStack-method'></span>

<h3>Description</h3>

<p>Make spatial predictions using the fitted model returned by <code>eot</code>.
A (user-defined) set of <em>n</em> modes will be used to model the outcome 
using the identified link functions of the respective modes which are
added together to produce the final prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EotStack'
predict(object, newdata, n = 1, ...)

## S4 method for signature 'EotMode'
predict(object, newdata, n = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>an Eot* object</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>the data to be used as predictor</p>
</td></tr>
<tr><td><code id="predict_+3A_n">n</code></td>
<td>
<p>the number of modes to be used for the prediction.
See <code><a href="#topic+nXplain">nXplain</a></code> for calculating the number of modes based 
on their explnatory power.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <a href="raster.html#topic+calc">calc</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <em>RasterStack</em> of <code>nlayers(newdata)</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>EotMode</code>: EotMode
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>### not very useful, but highlights the workflow
data(pacificSST)
data(australiaGPCP)

## train data using eot()
train &lt;- eot(x = pacificSST[[1:10]], 
             y = australiaGPCP[[1:10]], 
             n = 1)

## predict using identified model
pred &lt;- predict(train, 
                newdata = pacificSST[[11:20]], 
                n = 1)

## compare results
opar &lt;- par(mfrow = c(1,2))
plot(australiaGPCP[[13]], main = "original", zlim = c(0, 10))
plot(pred[[3]], main = "predicted", zlim = c(0, 10))
par(opar)

</code></pre>

<hr>
<h2 id='subset'>Subset modes in EotStacks</h2><span id='topic++5B+5B+2CEotStack+2CANY+2CANY-method'></span><span id='topic+subset'></span><span id='topic+subset+2CEotStack-method'></span>

<h3>Description</h3>

<p>Extract a set of modes from an EotStack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EotStack'
subset(x, subset, drop = FALSE, ...)

## S4 method for signature 'EotStack,ANY,ANY'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>EotStack to be subset</p>
</td></tr>
<tr><td><code id="subset_+3A_subset">subset</code></td>
<td>
<p>integer or character. The modes to ectract (either by
integer or by their names)</p>
</td></tr>
<tr><td><code id="subset_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> a single mode will be returned as an EotMode</p>
</td></tr>
<tr><td><code id="subset_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="subset_+3A_i">i</code></td>
<td>
<p>number of EotMode to be subset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an Eot* object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vdendool)

nh_modes &lt;- eot(x = vdendool, y = NULL, n = 3, 
                standardised = FALSE, 
                verbose = TRUE)
                
subs &lt;- subset(nh_modes, 2:3) # is the same as
subs &lt;- nh_modes[[2:3]]

## effect of 'drop=FALSE' when selecting a single layer
subs &lt;- subset(nh_modes, 2)
class(subs)
subs &lt;- subset(nh_modes, 2, drop = TRUE)
class(subs)

</code></pre>

<hr>
<h2 id='vdendool'>Mean seasonal (DJF) 700 mb geopotential heights</h2><span id='topic+vdendool'></span>

<h3>Description</h3>

<p>NCEP/NCAR reanalysis data of mean seasonal (DJF) 700 mb geopotential heights from 1948 to 1998
</p>


<h3>Format</h3>

<p>a RasterBrick with the following attributes<br />
<br />
dimensions  : 14, 36, 504, 50  (nrow, ncol, ncell, nlayers)<br />
resolution  : 10, 4.931507  (x, y)<br />
extent      : -180, 180, 20.9589, 90  (xmin, xmax, ymin, ymax)<br />
coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0<br /></p>


<h3>Details</h3>

<p>NCEP/NCAR reanalysis data of mean seasonal (DJF) 700 mb geopotential heights from 1948 to 1998
</p>


<h3>Source</h3>

<p><a href="http://www.esrl.noaa.gov/psd/data/gridded/data.ncep.reanalysis.derived.pressure.html">http://www.esrl.noaa.gov/psd/data/gridded/data.ncep.reanalysis.derived.pressure.html</a><br />
<em>Original Source:</em> NOAA National Center for Environmental Prediction
</p>


<h3>References</h3>

<p>The NCEP/NCAR 40-year reanalysis project<br />
Kalnay et al. (1996)<br />
Bulletin of the American Meteorological Society, Volume 77, Issue 3, pp 437 - 471<br />
<a href="http://journals.ametsoc.org/doi/abs/10.1175/1520-0477(1996)077%3C0437%3ATNYRP%3E2.0.CO%3B2">http://journals.ametsoc.org/doi/abs/10.1175/1520-0477(1996)077%3C0437%3ATNYRP%3E2.0.CO%3B2</a>
</p>

<hr>
<h2 id='writeEot'>Write Eot* objects to disk</h2><span id='topic+writeEot'></span><span id='topic+writeEot+2CEotMode-method'></span><span id='topic+writeEot+2CEotStack-method'></span>

<h3>Description</h3>

<p>Write Eot* objects to disk. This is merely a wrapper around 
<a href="raster.html#topic+writeRaster">writeRaster</a> so see respective help section for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EotMode'
writeEot(x, path.out = ".", prefix = "remote",
  overwrite = TRUE, ...)

## S4 method for signature 'EotStack'
writeEot(x, path.out = ".", prefix, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeEot_+3A_x">x</code></td>
<td>
<p>an Eot* object</p>
</td></tr>
<tr><td><code id="writeEot_+3A_path.out">path.out</code></td>
<td>
<p>the path to the folder to write the files to</p>
</td></tr>
<tr><td><code id="writeEot_+3A_prefix">prefix</code></td>
<td>
<p>a prefix to be added to the file names (see Details)</p>
</td></tr>
<tr><td><code id="writeEot_+3A_overwrite">overwrite</code></td>
<td>
<p>see <a href="raster.html#topic+writeRaster">writeRaster</a>. 
Defaults to <code>TRUE</code> in <code>writeEot</code></p>
</td></tr>
<tr><td><code id="writeEot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <a href="raster.html#topic+writeRaster">writeRaster</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>writeEot</code> will write the results of either an EotMode or an EotStack
to disk. For each mode the following files will be written:
</p>

<ul>
<li> <p><em>pred_r</em> - the <em>RasterLayer</em> of the correlation coefficients 
between the base point and each pixel of the predictor domain
</p>
</li>
<li> <p><em>pred_rsq</em> - as above but for the coefficient of determination
</p>
</li>
<li> <p><em>pred_rsq_sums</em> - as above but for the sums of coefficient of determination
</p>
</li>
<li> <p><em>pred_int</em> - the <em>RasterLayer</em> of the intercept of the 
regression equation for each pixel of the predictor domain
</p>
</li>
<li> <p><em>pred_slp</em> - same as above but for the slope of the 
regression equation for each pixel of the predictor domain
</p>
</li>
<li> <p><em>pred_p</em> - the <em>RasterLayer</em> of the significance (p-value) 
of the the regression equation for each pixel of the predictor domain
</p>
</li>
<li> <p><em>pred_resid</em> - the <em>RasterBrick</em> of the reduced data 
for the predictor domain
</p>
</li></ul>

<p>Apart from <em>pred_rsq_sums</em>, all these files are also created for 
the response domain as <em>resp_*</em>. These will be pasted together
with the prefix &amp; the respective mode so that the file names will 
look like, e.g.:
</p>
<p><em>prefix_mode_n_pred_r.grd</em>
</p>
<p>for the <em>RasterLayer</em> of the predictor correlation coefficient 
of mode n using the standard <em>raster</em> file type (.grd).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>EotStack</code>: EotStack
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="raster.html#topic+writeRaster">writeRaster</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vdendool)

nh_modes &lt;- eot(x = vdendool, y = NULL, n = 2, 
                standardised = FALSE, 
                verbose = TRUE)

## write the complete EotStack
writeEot(nh_modes, prefix = "vdendool")

## write only one EotMode
writeEot(nh_modes[[2]], prefix = "vdendool")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
