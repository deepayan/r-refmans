<!DOCTYPE html><html><head><title>Help for package PPtreeregViz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PPtreeregViz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dataXY'><p>Simulated data</p></a></li>
<li><a href='#decisionplot'><p>Decision plot</p></a></li>
<li><a href='#explain_PP'><p>Make explain of <code>PPTreeregObj</code> for <code>DALEX</code> package</p></a></li>
<li><a href='#feature_exact'><p>feature_exact</p></a></li>
<li><a href='#insurance'><p>Insurance Data</p></a></li>
<li><a href='#observation_impute_cpp_simple'><p>Get imputed data</p></a></li>
<li><a href='#plot.PPimportance'><p>Variable importance plot of <code>PPTreereg</code></p></a></li>
<li><a href='#plot.PPTreereg'><p>PPTreereg plot</p></a></li>
<li><a href='#pp_ggparty'><p>PPTreereg plot with independent variable</p></a></li>
<li><a href='#PPimportance'><p>Calculate variable importance</p></a></li>
<li><a href='#PPregNodeViz'><p>Node visualization</p></a></li>
<li><a href='#PPregVarViz'><p>Visualize independent variable action in projection pursuit regression tree.</p></a></li>
<li><a href='#PPshapdependence'><p>Dependency plot</p></a></li>
<li><a href='#ppshapr_prep'><p>Calculate <code>PPKernelSHAP</code> for all train data set</p></a></li>
<li><a href='#ppshapr.empirical'><p>Calculate <code>PPKernelSHAP</code> values with empirical methods</p></a></li>
<li><a href='#ppshapr.simple'><p>Calculate <code>PPKernelSHAP</code> values with simple methods</p></a></li>
<li><a href='#PPshapsummary'><p>Summary plot</p></a></li>
<li><a href='#PPTreereg'><p>Construct the projection pursuit regression tree</p></a></li>
<li><a href='#predict.PPTreereg'><p>predict <code>PPTreereg</code></p></a></li>
<li><a href='#print.PPTreereg'><p>Print PPTreereg result</p></a></li>
<li><a href='#shapley_weights'><p>shapley_weights</p></a></li>
<li><a href='#subpick'><p>projection pursuit <code>submodular</code> pick algorithm <code>PP SP-LIME</code></p></a></li>
<li><a href='#summary.PPTreereg'><p>Summary <code>PPTreereg</code> result</p></a></li>
<li><a href='#waterfallplot'><p>Waterfall plot</p></a></li>
<li><a href='#weight_matrix'><p>weight_matrix</p></a></li>
<li><a href='#weight_matrix_cpp'><p>Calculate weight matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Projection Pursuit Regression Tree Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>HyunSun Cho &lt;sunsmiling@naver.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>It was developed as a tool for exploring 'PPTreereg' (Projection Pursuit TREE of REGression). 
  It uses various projection pursuit indexes and 'XAI' (eXplainable Artificial Intelligence) methods to help 
  understand the model by finding connections between the input variables and prediction values of the model. 
  The 'KernelSHAP' (Aas, Jullum and Løland (2019) &lt;<a href="https://arxiv.org/abs/1903.10464">arXiv:1903.10464</a>&gt;) algorithm was modified to fit ‘PPTreereg’, 
  and some codes were modified from the 'shapr' package (Sellereite, Nikolai, and Martin Jullum (2020) &lt;<a href="https://doi.org/10.21105%2Fjoss.02027">doi:10.21105/joss.02027</a>&gt;). 
  The implemented methods help to explore the model at the single instance level as well as at the whole dataset level. 
  Users can compare with other machine learning models by applying it to the 'DALEX' package of 'R'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-19</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, data.table, DALEX, shapr, ggplot2, dplyr, tidyr, tibble,
PPtreeViz, reshape2, magrittr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), gridExtra, grid, ggExtra, partykit,
ggparty, progress, tidyselect, ggforce, waterfalls, forcats,
RColorBrewer, gtable, knitr, rmarkdown, MASS, covr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sunsmiling/PPtreeregViz">https://github.com/sunsmiling/PPtreeregViz</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-23 06:45:16 UTC; sunny</td>
</tr>
<tr>
<td>Author:</td>
<td>Eun-Kyung Lee [aut, ctb],
  HyunSun Cho [aut, cre],
  Nikolai Sellereite [ctb, cph] (Author of included shapr fragments),
  Martin Jullum [ctb, cph] (Author of included shapr fragments),
  Annabelle Redelmeier [ctb, cph] (Author of included shapr fragments),
  Norsk Regnesentral [cph]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-23 19:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='dataXY'>Simulated data</h2><span id='topic+dataXY'></span>

<h3>Description</h3>

<p>The <code>dataXY</code> dataset is simulated data for running Projection Pursuit Regression Tree Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataXY)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 4 variables.
</p>


<h3>Details</h3>

<p>It contains 100 rows and 4 variables.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.3390/app11219885">doi:10.3390/app11219885</a>
</p>

<hr>
<h2 id='decisionplot'>Decision plot</h2><span id='topic+decisionplot'></span>

<h3>Description</h3>

<p>decision plot for <code>PPKernelSHAP</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decisionplot(
  PPTreeregOBJ,
  testObs,
  final.rule = 5,
  method = "simple",
  varImp = "shapImp",
  final.leaf = NULL,
  Yrange = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decisionplot_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object - a model to be explained</p>
</td></tr>
<tr><td><code id="decisionplot_+3A_testobs">testObs</code></td>
<td>
<p>test data observation</p>
</td></tr>
<tr><td><code id="decisionplot_+3A_final.rule">final.rule</code></td>
<td>
<p>final rule to assign numerical values in the final nodes.
1: mean value in the final nodes
2: median value in the final nodes
3: using optimal projection
4: using all independent variables
5: using several significant independent variables</p>
</td></tr>
<tr><td><code id="decisionplot_+3A_method">method</code></td>
<td>
<p>simple or empirical method to calculate <code>PPKernelSHAP</code></p>
</td></tr>
<tr><td><code id="decisionplot_+3A_varimp">varImp</code></td>
<td>
<p><code>shapImp</code> or <code>treeImp</code> - Sorted by descending order of variance or the variable importance from coefficient values of the nodes inside
the <code>PPTreereg</code>.</p>
</td></tr>
<tr><td><code id="decisionplot_+3A_final.leaf">final.leaf</code></td>
<td>
<p>location of final leaf</p>
</td></tr>
<tr><td><code id="decisionplot_+3A_yrange">Yrange</code></td>
<td>
<p>show the entire final prediction range of the dependent variable. Default value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Decision plots are mainly used to explain individual predictions that how the model makes decision,
by focusing more on how model’s  predictions reach to their expected y value with <code>PPKernelSHAP</code> values.
</p>


<h3>Value</h3>

<p>An object of the class <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
testX &lt;- dataXY[1,-1]
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
decisionplot(Model, testX, final.rule =5, method="simple")

</code></pre>

<hr>
<h2 id='explain_PP'>Make explain of <code>PPTreeregObj</code> for <code>DALEX</code> package</h2><span id='topic+explain_PP'></span>

<h3>Description</h3>

<p>Create Model Explainer for PPTreereg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explain_PP(PPTreeregOBJ, data, y, final.rule,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explain_PP_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object - a model to be explained</p>
</td></tr>
<tr><td><code id="explain_PP_+3A_data">data</code></td>
<td>
<p>data.frame or matrix - data that was used for fitting. If not provided then will be extracted from the model. Data should be passed without target column (this shall be provided as the y argument).</p>
</td></tr>
<tr><td><code id="explain_PP_+3A_y">y</code></td>
<td>
<p>numeric vector with outputs / scores. If provided then it shall have the same size as data</p>
</td></tr>
<tr><td><code id="explain_PP_+3A_final.rule">final.rule</code></td>
<td>
<p>rule to calculate the final node value</p>
</td></tr>
<tr><td><code id="explain_PP_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a unified representation explain of PPTreereg model for cooperate with <code>DALEX</code> package.
</p>


<h3>Value</h3>

<p>An object of the class <code>explainer</code>.
</p>


<h3>References</h3>

<p>Explanatory Model Analysis. Explore, Explain and Examine Predictive Models. <a href="https://ema.drwhy.ai/">https://ema.drwhy.ai/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("DALEX")
library("dplyr")
data(dataXY)
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
new_explainer &lt;- explain_PP(Model, data = dataXY[,-1],y = dataXY[,1],final.rule= 5)
DALEX::model_performance(new_explainer) %&gt;% plot(geom = "ecdf")

</code></pre>

<hr>
<h2 id='feature_exact'>feature_exact</h2><span id='topic+feature_exact'></span>

<h3>Description</h3>

<p>The original source for much of this came from 'shapr' package
code in github.com/NorskRegnesentral/shapr/blob/master/R/features.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature_exact(m, weight_zero_m = 10^6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature_exact_+3A_m">m</code></td>
<td>
<p>List. Contains vector of integers indicating the feature numbers for the different groups.</p>
</td></tr>
<tr><td><code id="feature_exact_+3A_weight_zero_m">weight_zero_m</code></td>
<td>
<p>weight_zero_m</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below is the original license statement for 'shapr' package.
</p>
<p>MIT License
Copyright (c) 2019 Norsk Regnesentral
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>


<h3>Value</h3>

<p>A data.table with all feature group combinations, shapley weights etc.
</p>


<h3>Author(s)</h3>

<p>Nikolai Sellereite
</p>


<h3>References</h3>

<p>The <code>shapr</code> package developed by
Nikolai Sellereite, Martin Jullum, Annabelle Redelmeier, Norsk Regnesentral.
<a href="https://doi.org/10.1016/j.artint.2021.103502">doi:10.1016/j.artint.2021.103502</a> and modified some codes at
<a href="https://github.com/NorskRegnesentral/shapr">https://github.com/NorskRegnesentral/shapr</a>
</p>

<hr>
<h2 id='insurance'>Insurance Data</h2><span id='topic+insurance'></span>

<h3>Description</h3>

<p>Dataset <code>insurance</code> is a part of dataset imported from
<code>insurance.csv</code> in  Kaggle &quot;Medical Cost Personal Dataset&quot;.
This data source material comes from Machine Learning with R by Brett Lantz book.
It is simply come cleaned up and, it contains 1338 rows and 7 variables. These are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(insurance)
</code></pre>


<h3>Format</h3>

<p>a data frame with 1338 rows and 7 columns.
</p>


<h3>Details</h3>


<ul>
<li><p> charges - Individual medical costs billed by health insurance.
</p>
</li>
<li><p> age - age of primary beneficiary.
</p>
</li>
<li><p> sex - insurance contractor gender, female, male.
</p>
</li>
<li><p> bmi - Body mass index, providing an understanding of body, weights that are relatively high or low relative to height,
objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9.
</p>
</li>
<li><p> children - Number of children covered by health insurance / Number of dependents.
</p>
</li>
<li><p> smoker - Smoking.
</p>
</li>
<li><p> region - the beneficiary's residential area in the US, northeast, southeast, southwest, northwest.
</p>
</li></ul>

<p>Source: <a href="https://www.kaggle.com/mirichoi0218/insurance">https://www.kaggle.com/mirichoi0218/insurance</a>
</p>


<h3>Source</h3>

<p>The <code>insurance.csv</code> dataset was downloaded from the <code>Kaggle</code> site.
The dataset was obtained from
<a href="https://www.kaggle.com/mirichoi0218/insurance">https://www.kaggle.com/mirichoi0218/insurance</a> on May 11, 2021.
</p>

<hr>
<h2 id='observation_impute_cpp_simple'>Get imputed data</h2><span id='topic+observation_impute_cpp_simple'></span>

<h3>Description</h3>

<p>Get imputed data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observation_impute_cpp_simple(xbar, index_simple, xtest, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="observation_impute_cpp_simple_+3A_xbar">xbar</code></td>
<td>
<p>mean of each leaf.</p>
</td></tr>
<tr><td><code id="observation_impute_cpp_simple_+3A_index_simple">index_simple</code></td>
<td>
<p>Positive integer.</p>
</td></tr>
<tr><td><code id="observation_impute_cpp_simple_+3A_xtest">xtest</code></td>
<td>
<p>Numeric matrix. Represents a single test observation.</p>
</td></tr>
<tr><td><code id="observation_impute_cpp_simple_+3A_s">S</code></td>
<td>
<p>Integer matrix of dimension <code>n_combinations x m</code>, where <code>n_combinations</code> equals
the total number of sampled/non-sampled feature combinations and <code>m</code> equals
the total number of unique features. Note that <code>m = ncol(xtrain)</code>. See details
for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix
</p>


<h3>Author(s)</h3>

<p>Nikolai Sellereite
</p>

<hr>
<h2 id='plot.PPimportance'>Variable importance plot of <code>PPTreereg</code></h2><span id='topic+plot.PPimportance'></span>

<h3>Description</h3>

<p>Visualize importance measure of trained <code>PPTreereg</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PPimportance'
plot(x, marginal = FALSE, num_var = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PPimportance_+3A_x">x</code></td>
<td>
<p>an importance object of the class <code>PPimpobj</code>, created with <code><a href="#topic+PPimportance">PPimportance</a></code> function</p>
</td></tr>
<tr><td><code id="plot.PPimportance_+3A_marginal">marginal</code></td>
<td>
<p>plot global importance. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="plot.PPimportance_+3A_num_var">num_var</code></td>
<td>
<p>number of variables to show.</p>
</td></tr>
<tr><td><code id="plot.PPimportance_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To visualize the variable importance values of <code>PPTreereg</code> model, two types of plots are
provided - importance of variables for each final node and global variable importance.
</p>


<h3>Value</h3>

<p>An object of the class <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
Tree.Imp &lt;- PPimportance(Model)
plot(Tree.Imp)
plot(Tree.Imp, marginal = TRUE)

</code></pre>

<hr>
<h2 id='plot.PPTreereg'>PPTreereg plot</h2><span id='topic+plot.PPTreereg'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>projection pursuit regression tree plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PPTreereg'
plot(x, font.size = 17, width.size = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PPTreereg_+3A_x">x</code></td>
<td>
<p>PPTreereg class object</p>
</td></tr>
<tr><td><code id="plot.PPTreereg_+3A_font.size">font.size</code></td>
<td>
<p>font size of plot</p>
</td></tr>
<tr><td><code id="plot.PPTreereg_+3A_width.size">width.size</code></td>
<td>
<p>size of eclipse in each node.</p>
</td></tr>
<tr><td><code id="plot.PPTreereg_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draw projection pursuit regression tree with tree structure. It is modified from a function in <code>party</code> library.
</p>


<h3>Value</h3>

<p>plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
plot(Model)

</code></pre>

<hr>
<h2 id='pp_ggparty'>PPTreereg plot with independent variable</h2><span id='topic+pp_ggparty'></span>

<h3>Description</h3>

<p>projection pursuit regression tree plot with independent variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_ggparty(PPTreeregOBJ,ind_variable,final.rule=5,Rule=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_ggparty_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object</p>
</td></tr>
<tr><td><code id="pp_ggparty_+3A_ind_variable">ind_variable</code></td>
<td>
<p>independent variable to show</p>
</td></tr>
<tr><td><code id="pp_ggparty_+3A_final.rule">final.rule</code></td>
<td>
<p>final rule to assign numerical values in the final nodes.
1: mean value in the final nodes
2: median value in the final nodes
3: using optimal projection
4: using all independent variables
5: using several significant independent variables</p>
</td></tr>
<tr><td><code id="pp_ggparty_+3A_rule">Rule</code></td>
<td>
<p>split rule
1: mean of two group means
2: weighted mean of two group means - weight with group size
3: weighted mean of two group means - weight with group sd
4: weighted mean of two group means - weight with group se
5: mean of two group medians
6: weighted mean of two group medians - weight with group size
7: weighted mean of two group median - weight with group IQR
8: weighted mean of two group median - weight with group IQR
and group size</p>
</td></tr>
<tr><td><code id="pp_ggparty_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draw projection pursuit regression tree with independent variable. It is modified
from a function in <code>partykit</code> library.
</p>


<h3>Value</h3>

<p>An object of the class <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
pp_ggparty(Model, "X1", final.rule=5)

</code></pre>

<hr>
<h2 id='PPimportance'>Calculate variable importance</h2><span id='topic+PPimportance'></span>

<h3>Description</h3>

<p>Calculate the importance of variables in the <code>PPTreereg</code> model.
For local importance, weighted sum of projection coefficients with the number of data corresponding to
each node as the weighted value in each node is used.
The global importance is absolute sum of local importance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPimportance(PPTreeregOBJ,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPimportance_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object - a model to be explained</p>
</td></tr>
<tr><td><code id="PPimportance_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>PPimpobj</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
PPimportance(Model)

</code></pre>

<hr>
<h2 id='PPregNodeViz'>Node visualization</h2><span id='topic+PPregNodeViz'></span>

<h3>Description</h3>

<p>Visualize node in projection pursuit regression tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPregNodeViz(PPTreeregOBJ,node.id,Rule=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPregNodeViz_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object - a model to be explained</p>
</td></tr>
<tr><td><code id="PPregNodeViz_+3A_node.id">node.id</code></td>
<td>
<p>node ID of inner or final node</p>
</td></tr>
<tr><td><code id="PPregNodeViz_+3A_rule">Rule</code></td>
<td>
<p>split rule
1: mean of two group means
2: weighted mean of two group means - weight with group size
3: weighted mean of two group means - weight with group sd
4: weighted mean of two group means - weight with group se
5: mean of two group medians
6: weighted mean of two group medians - weight with group size
7: weighted mean of two group median - weight with group IQR
8: weighted mean of two group median - weight with group IQR
and group size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is developed for the visualization of inner and final nodes.
Visual representation of the projection coefficient value of each node and
the result of projected data help understand growth process of the projection pursuit regression tree.
For the inner node, two plots are provided - the bar chart style plot with
projection pursuit coefficients of each variable, the histogram of the
projected data.
For the final node, scatter plot of observed Y vs. fitted Y according to the final rules.
</p>


<h3>Value</h3>

<p>An object of the class <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
PPregNodeViz(Model,node.id=1)
PPregNodeViz(Model,node.id=4)

</code></pre>

<hr>
<h2 id='PPregVarViz'>Visualize independent variable action in projection pursuit regression tree.</h2><span id='topic+PPregVarViz'></span>

<h3>Description</h3>

<p>This function is developed to see the influence of independent variables on the range of dependent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPregVarViz(PPTreeregOBJ,var.id,indiv=FALSE,
                   DEPTH=NULL,smoothMethod="auto", var.factor=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPregVarViz_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object - a model to be explained</p>
</td></tr>
<tr><td><code id="PPregVarViz_+3A_var.id">var.id</code></td>
<td>
<p>independent variable name</p>
</td></tr>
<tr><td><code id="PPregVarViz_+3A_indiv">indiv</code></td>
<td>
<p>TRUE: individual group plot, FALSE: combined one plot</p>
</td></tr>
<tr><td><code id="PPregVarViz_+3A_depth">DEPTH</code></td>
<td>
<p>depth for exploration</p>
</td></tr>
<tr><td><code id="PPregVarViz_+3A_smoothmethod">smoothMethod</code></td>
<td>
<p>method in geom_smooth function</p>
</td></tr>
<tr><td><code id="PPregVarViz_+3A_var.factor">var.factor</code></td>
<td>
<p>TRUE when indepedent variable is a categorical variable (as factor)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
PPregVarViz(Model,"X1")
PPregVarViz(Model,"X1",indiv = TRUE)

</code></pre>

<hr>
<h2 id='PPshapdependence'>Dependency plot</h2><span id='topic+PPshapdependence'></span>

<h3>Description</h3>

<p>Dependency plot using <code>PPKernelSHAP</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPshapdependence(data_long, x, y=NULL, color_feature=NULL, smooth=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPshapdependence_+3A_data_long">data_long</code></td>
<td>
<p><code>ppshapr_prep</code> class object.</p>
</td></tr>
<tr><td><code id="PPshapdependence_+3A_x">x</code></td>
<td>
<p>the independent variable to see</p>
</td></tr>
<tr><td><code id="PPshapdependence_+3A_y">y</code></td>
<td>
<p>the interaction effect by putting the values of the independent variables in different colors.</p>
</td></tr>
<tr><td><code id="PPshapdependence_+3A_color_feature">color_feature</code></td>
<td>
<p>display other variables with color. Default value is NULL.</p>
</td></tr>
<tr><td><code id="PPshapdependence_+3A_smooth">smooth</code></td>
<td>
<p>geom_smooth option. Default value is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependency plots are designed to show the effect of one independent variable on the model's prediction.
Each point corresponds to each row of the training data,
and the y axis corresponds the <code>PPKernelSHAP</code> value of the variable,
indicating how much knowing the value of the variable changes the output of the model
for the prediction of the data.
</p>


<h3>Value</h3>

<p>An object of the class <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
testX &lt;- dataXY[1,-1]
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
shap_long &lt;- ppshapr_prep(Model, final.rule =5, method="simple")
PPshapdependence(shap_long,x = "X1")

</code></pre>

<hr>
<h2 id='ppshapr_prep'>Calculate <code>PPKernelSHAP</code> for all train data set</h2><span id='topic+ppshapr_prep'></span>

<h3>Description</h3>

<p>All train data set to calculate <code>PPKernelSHAP</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppshapr_prep(PPTreeregOBJ = NULL, final.rule = 5, method = "simple")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppshapr_prep_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object - a model to be explained</p>
</td></tr>
<tr><td><code id="ppshapr_prep_+3A_final.rule">final.rule</code></td>
<td>
<p>final rule to assign numerical values in the final nodes.
1: mean value in the final nodes
2: median value in the final nodes
3: using optimal projection
4: using all independent variables
5: using several significant independent variables</p>
</td></tr>
<tr><td><code id="ppshapr_prep_+3A_method">method</code></td>
<td>
<p>simple or empirical method to calculate <code>PPKernelSHAP</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ppshapr_prep class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
testX &lt;- dataXY[1,-1]
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
shap_long &lt;- ppshapr_prep(Model, final.rule =5, method="simple")

</code></pre>

<hr>
<h2 id='ppshapr.empirical'>Calculate <code>PPKernelSHAP</code> values with empirical methods</h2><span id='topic+ppshapr.empirical'></span>

<h3>Description</h3>

<p>This function should only be called internally, and not be used as
a stand-alone function.
The original source for much of this came from 'shapr' package
code in github.com/NorskRegnesentral/shapr/blob/master/R/predictions.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppshapr.empirical(PPTreeregOBJ, testObs, final.rule, final.leaf = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppshapr.empirical_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object - a model to be explained</p>
</td></tr>
<tr><td><code id="ppshapr.empirical_+3A_testobs">testObs</code></td>
<td>
<p>test data observation</p>
</td></tr>
<tr><td><code id="ppshapr.empirical_+3A_final.rule">final.rule</code></td>
<td>
<p>final rule to assign numerical values in the final nodes.
1: mean value in the final nodes
2: median value in the final nodes
3: using optimal projection
4: using all independent variables
5: using several significant independent variables</p>
</td></tr>
<tr><td><code id="ppshapr.empirical_+3A_final.leaf">final.leaf</code></td>
<td>
<p>location of final leaf</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below is the original license statement for 'shapr' package.
</p>
<p>MIT License
Copyright (c) 2019 Norsk Regnesentral
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>


<h3>Value</h3>

<p>List of empirical methods and model values
</p>

<hr>
<h2 id='ppshapr.simple'>Calculate <code>PPKernelSHAP</code> values with simple methods</h2><span id='topic+ppshapr.simple'></span>

<h3>Description</h3>

<p>This function should only be called internally, and not be used as
a stand-alone function.
The original source for much of this came from 'shapr' package
code in github.com/NorskRegnesentral/shapr/blob/master/R/predictions.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppshapr.simple(PPTreeregOBJ, testObs, final.rule, final.leaf = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppshapr.simple_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object - a model to be explained</p>
</td></tr>
<tr><td><code id="ppshapr.simple_+3A_testobs">testObs</code></td>
<td>
<p>test data observation</p>
</td></tr>
<tr><td><code id="ppshapr.simple_+3A_final.rule">final.rule</code></td>
<td>
<p>final rule to assign numerical values in the final nodes.
1: mean value in the final nodes
2: median value in the final nodes
3: using optimal projection
4: using all independent variables
5: using several significant independent variables</p>
</td></tr>
<tr><td><code id="ppshapr.simple_+3A_final.leaf">final.leaf</code></td>
<td>
<p>location of final leaf</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below is the original license statement for 'shapr' package.
</p>
<p>MIT License
Copyright (c) 2019 Norsk Regnesentral
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>


<h3>Value</h3>

<p>List of simple methods and model values
</p>

<hr>
<h2 id='PPshapsummary'>Summary plot</h2><span id='topic+PPshapsummary'></span>

<h3>Description</h3>

<p>Summary plot using <code>PPKernelSHAP</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPshapsummary(data_long,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPshapsummary_+3A_data_long">data_long</code></td>
<td>
<p><code>ppshapr_prep</code> class object.</p>
</td></tr>
<tr><td><code id="PPshapsummary_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A summary plot is used to see the aspects of important variables for each final node.
The summary plot summarizes information about the independent variables that contributed the most to the model's prediction
in the training data in the form of a density plot.
</p>


<h3>Value</h3>

<p>An object of the class <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dataXY)
testX &lt;- dataXY[1,-1]
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
shap_long &lt;- ppshapr_prep(Model, final.rule =5, method="simple")
PPshapsummary(shap_long)

</code></pre>

<hr>
<h2 id='PPTreereg'>Construct the projection pursuit regression tree</h2><span id='topic+PPTreereg'></span>

<h3>Description</h3>

<p>Find regression tree structure using various projection pursuit indices
in each split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPTreereg(formula,data,DEPTH=NULL,Rr=1,PPmethod="LDA",
                 weight=TRUE,lambda=0.1,r=1,TOL.CV=0.1,selP=NULL,
                 energy=0,maxiter=500,
                 standardized=TRUE,even=TRUE,space=0,
                 maxFinalNode=20,maxNodeN=10,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPTreereg_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_depth">DEPTH</code></td>
<td>
<p>depth of the projection pursuit regression tree</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_rr">Rr</code></td>
<td>
<p>cutoff rule in each node</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_ppmethod">PPmethod</code></td>
<td>
<p>method for projection pursuit; <code>"LDA"</code>, <code>"PDA"</code>, <code>"Lr"</code>,
<code>"GINI"</code>, and <code>"ENTROPY"</code>.</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_weight">weight</code></td>
<td>
<p>weight flag in <code>LDA</code>, <code>PDA</code> and <code>Lr</code> index</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_lambda">lambda</code></td>
<td>
<p>lambda in PDA index</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_r">r</code></td>
<td>
<p>r in Lr index</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_tol.cv">TOL.CV</code></td>
<td>
<p>CV limit for the final node</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_selp">selP</code></td>
<td>
<p>number of variables for the final node in Method 5</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_energy">energy</code></td>
<td>
<p>energy parameter</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_maxiter">maxiter</code></td>
<td>
<p>number of maximum iteration</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_standardized">standardized</code></td>
<td>
<p>standardize each X variable before fitting
the tree structure. Default value is TRUE</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_even">even</code></td>
<td>
<p>divide evenly at each node. Default value is TRUE</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_space">space</code></td>
<td>
<p>space between two groups of dependent variable</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_maxfinalnode">maxFinalNode</code></td>
<td>
<p>maximum number of final node</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_maxnoden">maxNodeN</code></td>
<td>
<p>maximum number of observations in the final node</p>
</td></tr>
<tr><td><code id="PPTreereg_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tree.result projection pursuit regression tree result with
<code>PPtreeclass</code> object format
</p>
<p>MSE mean squared error of the final tree
</p>
<p><code>mean.G</code>  means of the observations in the final node
</p>
<p><code>sd.G</code> standard deviations of the observations in the final node.
</p>
<p><code>coef.G</code> regression coefficients for Method 3, 4 and 5
</p>
<p><code>origY</code> original dependent variable vector
</p>
<p><code>origX.mean</code> mean of original X
</p>
<p><code>origX.sd</code> standard deviation of original X
</p>
<p><code>class.origX.mean</code> means of the each independent variables in the final node
</p>


<h3>References</h3>

<p>...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
Tree.result &lt;- PPTreereg(mpg~.,mtcars,DEPTH=2,PPmethod="LDA")
Tree.result

</code></pre>

<hr>
<h2 id='predict.PPTreereg'>predict <code>PPTreereg</code></h2><span id='topic+predict.PPTreereg'></span><span id='topic+predict'></span>

<h3>Description</h3>

<p>predict projection pursuit regression tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PPTreereg'
predict(
  object,
  newdata = NULL,
  Rule = 1,
  final.rule = 1,
  classinfo = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.PPTreereg_+3A_object">object</code></td>
<td>
<p>a fitted object of class inheriting from <code>PPTreereg</code></p>
</td></tr>
<tr><td><code id="predict.PPTreereg_+3A_newdata">newdata</code></td>
<td>
<p>the test data set</p>
</td></tr>
<tr><td><code id="predict.PPTreereg_+3A_rule">Rule</code></td>
<td>
<p>split rule
1: mean of two group means
2: weighted mean of two group means - weight with group size
3: weighted mean of two group means - weight with group sd
4: weighted mean of two group means - weight with group se
5: mean of two group medians
6: weighted mean of two group medians - weight with group size
7: weighted mean of two group median - weight with group IQR
8: weighted mean of two group median - weight with group IQR
and group size
9: cutoff that minimize error rates in each node</p>
</td></tr>
<tr><td><code id="predict.PPTreereg_+3A_final.rule">final.rule</code></td>
<td>
<p>final rule to assign numerical values in the final nodes.
1: mean value in the final nodes
2: median value in the final nodes
3: using optimal projection
4: using all independent variables
5: using several significant independent variables</p>
</td></tr>
<tr><td><code id="predict.PPTreereg_+3A_classinfo">classinfo</code></td>
<td>
<p>return final node information. Default value is FALSE</p>
</td></tr>
<tr><td><code id="predict.PPTreereg_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predict class for the test set with the fitted projection pursuit regression tree and
calculate prediction error.
</p>


<h3>Value</h3>

<p>Numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
predict(Model)

</code></pre>

<hr>
<h2 id='print.PPTreereg'>Print PPTreereg result</h2><span id='topic+print.PPTreereg'></span>

<h3>Description</h3>

<p>Print PP.Tree.reg result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PPTreereg'
print(
  x,
  tree.print = TRUE,
  coef.print = FALSE,
  cutoff.print = FALSE,
  verbose = TRUE,
  final.rule = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PPTreereg_+3A_x">x</code></td>
<td>
<p>PPTreereg object</p>
</td></tr>
<tr><td><code id="print.PPTreereg_+3A_tree.print">tree.print</code></td>
<td>
<p>print the tree structure when TRUE</p>
</td></tr>
<tr><td><code id="print.PPTreereg_+3A_coef.print">coef.print</code></td>
<td>
<p>print the projection coefficient in each node when TRUE</p>
</td></tr>
<tr><td><code id="print.PPTreereg_+3A_cutoff.print">cutoff.print</code></td>
<td>
<p>print the cutoff values in each node when TRUE</p>
</td></tr>
<tr><td><code id="print.PPTreereg_+3A_verbose">verbose</code></td>
<td>
<p>print if TRUE, no output if FALSE</p>
</td></tr>
<tr><td><code id="print.PPTreereg_+3A_final.rule">final.rule</code></td>
<td>
<p>rule to calculate the final node value</p>
</td></tr>
<tr><td><code id="print.PPTreereg_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print the projection pursuit regression tree result
</p>


<h3>Value</h3>

<p>tree print
</p>

<hr>
<h2 id='shapley_weights'>shapley_weights</h2><span id='topic+shapley_weights'></span>

<h3>Description</h3>

<p>The original source for much of this came from 'shapr' package
code in github.com/NorskRegnesentral/shapr/blob/master/R/shapley.R
Below is the original license statement for 'shapr' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapley_weights(m, N, n_components, weight_zero_m = 10^6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapley_weights_+3A_m">m</code></td>
<td>
<p>m</p>
</td></tr>
<tr><td><code id="shapley_weights_+3A_n">N</code></td>
<td>
<p>N</p>
</td></tr>
<tr><td><code id="shapley_weights_+3A_n_components">n_components</code></td>
<td>
<p>n_components</p>
</td></tr>
<tr><td><code id="shapley_weights_+3A_weight_zero_m">weight_zero_m</code></td>
<td>
<p>weight_zero_m</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MIT License
Copyright (c) 2019 Norsk Regnesentral
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>


<h3>Value</h3>

<p>Numeric
</p>


<h3>Author(s)</h3>

<p>Nikolai Sellereite
</p>


<h3>References</h3>

<p>The <code>shapr</code> package developed by
Nikolai Sellereite, Martin Jullum, Annabelle Redelmeier, Norsk Regnesentral.
<a href="https://doi.org/10.1016/j.artint.2021.103502">doi:10.1016/j.artint.2021.103502</a> and modified some codes at
<a href="https://github.com/NorskRegnesentral/shapr">https://github.com/NorskRegnesentral/shapr</a>
</p>

<hr>
<h2 id='subpick'>projection pursuit <code>submodular</code> pick algorithm <code>PP SP-LIME</code></h2><span id='topic+subpick'></span>

<h3>Description</h3>

<p>Pick several data containing various information for each final node for <code>PPTreereg</code>
<code>submodular</code> Pick (<code>SP-LIME</code>) was developed (Ribeiro et al., 2016) to selects
representative data with important information to determine the
reliability of model based on the <code>LIME</code> algorithm.
In order to extract data for each final node in the <code>PPTreereg</code> model,
<code>PP SP-LIME</code> was proposed based on <code>SP-LIME</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subpick(data_long, final.leaf, obsnum = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subpick_+3A_data_long">data_long</code></td>
<td>
<p><code>ppshapr_prep</code> class object.</p>
</td></tr>
<tr><td><code id="subpick_+3A_final.leaf">final.leaf</code></td>
<td>
<p>location of final leaf</p>
</td></tr>
<tr><td><code id="subpick_+3A_obsnum">obsnum</code></td>
<td>
<p>The number of budgets (instance to be selected). Default value is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Observation names and their original values as data
</p>


<h3>References</h3>

<p>Ribeiro, Marco Tulio, Sameer Singh, and Carlos Guestrin.
&quot;&quot; Why should i trust you?&quot; Explaining the predictions of any classifier.&quot; Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining. 2016.
<a href="https://doi.org/10.1145/2939672.2939778">doi:10.1145/2939672.2939778</a>
<a href="https://github.com/marcotcr/lime/blob/master/lime/submodular_pick.py">https://github.com/marcotcr/lime/blob/master/lime/submodular_pick.py</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dataXY")
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
shap_long=ppshapr_prep(Model,final.rule =3,method="simple")
subpick(shap_long,final.leaf = 1, obsnum = 5)


</code></pre>

<hr>
<h2 id='summary.PPTreereg'>Summary <code>PPTreereg</code> result</h2><span id='topic+summary.PPTreereg'></span>

<h3>Description</h3>

<p>summary <code>PPTreereg</code> result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PPTreereg'
summary(object, c = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PPTreereg_+3A_object">object</code></td>
<td>
<p>a fitted object of class inheriting from <code>PPTreereg</code></p>
</td></tr>
<tr><td><code id="summary.PPTreereg_+3A_c">c</code></td>
<td>
<p>choose node id to summary. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="summary.PPTreereg_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>summary the projection pursuit regression tree result
</p>


<h3>Value</h3>

<p>coefficient results of tree
</p>

<hr>
<h2 id='waterfallplot'>Waterfall plot</h2><span id='topic+waterfallplot'></span>

<h3>Description</h3>

<p>waterfall plot for <code>PPKernelSHAP</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waterfallplot(
  PPTreeregOBJ,
  testObs,
  final.rule = 5,
  method = "simple",
  final.leaf = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waterfallplot_+3A_pptreeregobj">PPTreeregOBJ</code></td>
<td>
<p>PPTreereg class object - a model to be explained</p>
</td></tr>
<tr><td><code id="waterfallplot_+3A_testobs">testObs</code></td>
<td>
<p>test data observation</p>
</td></tr>
<tr><td><code id="waterfallplot_+3A_final.rule">final.rule</code></td>
<td>
<p>final rule to assign numerical values in the final nodes.
1: mean value in the final nodes
2: median value in the final nodes
3: using optimal projection
4: using all independent variables
5: using several significant independent variables</p>
</td></tr>
<tr><td><code id="waterfallplot_+3A_method">method</code></td>
<td>
<p>simple or empirical method to calculate <code>PPKernelSHAP</code></p>
</td></tr>
<tr><td><code id="waterfallplot_+3A_final.leaf">final.leaf</code></td>
<td>
<p>location of final leaf</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Waterfall plot is mainly used to explain individual predictions,
and is suitable for showing an explanation when a single piece of data is
entered as an input using <code>PPKernelSHAP</code> values.
</p>


<h3>Value</h3>

<p>An object of the class <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataXY)
testX &lt;- dataXY[1,-1]
Model &lt;- PPTreereg(Y~., data = dataXY, DEPTH = 2)
waterfallplot(Model, testX, final.rule =5, method="simple")


</code></pre>

<hr>
<h2 id='weight_matrix'>weight_matrix</h2><span id='topic+weight_matrix'></span>

<h3>Description</h3>

<p>The original source for much of this came from 'shapr' package
code in github.com/NorskRegnesentral/shapr/blob/master/R/shapley.R
Below is the original license statement for 'shapr' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_matrix(X, normalize_W_weights = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_matrix_+3A_x">X</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="weight_matrix_+3A_normalize_w_weights">normalize_W_weights</code></td>
<td>
<p>default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MIT License
Copyright (c) 2019 Norsk Regnesentral
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>


<h3>Value</h3>

<p>Numeric matrix
</p>


<h3>Author(s)</h3>

<p>Nikolai Sellereite
</p>


<h3>References</h3>

<p>The <code>shapr</code> package developed by
Nikolai Sellereite, Martin Jullum, Annabelle Redelmeier, Norsk Regnesentral.
<a href="https://doi.org/10.1016/j.artint.2021.103502">doi:10.1016/j.artint.2021.103502</a> and modified some codes at
<a href="https://github.com/NorskRegnesentral/shapr">https://github.com/NorskRegnesentral/shapr</a>
</p>

<hr>
<h2 id='weight_matrix_cpp'>Calculate weight matrix</h2><span id='topic+weight_matrix_cpp'></span>

<h3>Description</h3>

<p>Calculate weight matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_matrix_cpp(subsets, m, n, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_matrix_cpp_+3A_subsets">subsets</code></td>
<td>
<p>List. Each of the elements equals an integer
vector representing a valid combination of features/feature groups.</p>
</td></tr>
<tr><td><code id="weight_matrix_cpp_+3A_m">m</code></td>
<td>
<p>Integer. Number of features/feature groups</p>
</td></tr>
<tr><td><code id="weight_matrix_cpp_+3A_n">n</code></td>
<td>
<p>Integer. Number of combinations</p>
</td></tr>
<tr><td><code id="weight_matrix_cpp_+3A_w">w</code></td>
<td>
<p>Numeric vector of length <code>n</code>, i.e. <code>w[i]</code> equals
the Shapley weight of feature/feature group combination <code>i</code>, represented by
<code>subsets[[i]]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of dimension n x m + 1
</p>


<h3>Author(s)</h3>

<p>Nikolai Sellereite
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
