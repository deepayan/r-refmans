<!DOCTYPE html><html><head><title>Help for package DoE.wrapper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DoE.wrapper}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DoE.wrapper-package'><p> Wrapper package for design of experiments functionality</p></a></li>
<li><a href='#bbd.design'><p> Function for generating Box-Behnken designs</p></a></li>
<li><a href='#ccd.augment'><p> Function for augmenting an existing cube with a star portion, using package rsm</p></a></li>
<li><a href='#ccd.design'><p> Function for accessing central composite designs from package rsm</p></a></li>
<li><a href='#CentralCompositeDesigns'><p> Statistical background of central composite designs</p></a></li>
<li><a href='#Dopt.augment'><p> Function for augmenting a design with D-optimal additional points using optFederov from package AlgDesign</p></a></li>
<li><a href='#Dopt.design'><p> Function for creating D-optimal designs with or without blocking from package AlgDesign</p></a></li>
<li><a href='#lhs.design'><p> Functions for accessing latin hypercube sampling designs from package lhs</p>
or space-filling designs from package DiceDesign</a></li>
<li><a href='#optimality.criteria'><p> Overview of optimality criteria in experimental design packages</p></a></li>
<li><a href='#rsmformula'><p> Functions for supporting response surface analysis with package rsm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Wrapper Package for Design of Experiments Functionality</td>
</tr>
<tr>
<td>Version:</td>
<td>0.12</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.1.0), FrF2(&ge; 1.6-5), DoE.base(&ge; 0.23-4), rsm</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, lhs, DiceDesign, AlgDesign(&ge; 1.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>skpr</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Various kinds of designs for
 (industrial) experiments can be created. The package uses, and sometimes enhances,
        design generation routines from other packages. 
        So far, response surface designs from package 'rsm', Latin hypercube
        samples from packages 'lhs' and 'DiceDesign', and 
        D-optimal designs from package 'AlgDesign' have been implemented.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://prof.bht-berlin.de/groemping/DoE/">https://prof.bht-berlin.de/groemping/DoE/</a>,
<a href="https://prof.bht-berlin.de/groemping/">https://prof.bht-berlin.de/groemping/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 11:38:35 UTC; Gr&lt;c3&gt;&lt;b6&gt;mping</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrike Groemping [aut, cre],
  Lenth Russ [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ulrike Groemping &lt;ulrike.groemping@bht-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 14:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='DoE.wrapper-package'> Wrapper package for design of experiments functionality </h2><span id='topic+DoE.wrapper-package'></span><span id='topic+DoE.wrapper'></span>

<h3>Description</h3>

<p>This package creates various kinds of designs for (industrial) experiments. 
It uses, and sometimes enhances, design generation routines from other packages. 
So far, response surface designs from package rsm, designs for computer 
experiments (latin hypercube samples etc.) from packages lhs and DiceDesign 
and D-optimal designs from package AlgDesign have been implemented.
</p>


<h3>Details</h3>

<p>Currently, the package provides classical response surface designs from package 
<span class="pkg">rsm</span>: Box-Behnken designs by Box and Behnken (function <code><a href="#topic+bbd.design">bbd.design</a></code> 
and central composite designs by Box and Wilson (<code><a href="#topic+ccd.design">ccd.design</a></code>) are implemented. 
For the latter, there is also a function for augmenting 2-level fractional factorials 
into central composite designs (<code><a href="#topic+ccd.design">ccd.design</a></code>).
</p>
<p>Furthermore, latin hypercube samples and other designs for computer experiments 
from packages <span class="pkg">lhs</span> and <span class="pkg">DiceDesign</span> are provided. 
</p>
<p>Furthermore, D-optimal designs have been implemented, 
using package <span class="pkg">AlgDesign</span>. This implementation is currently in beta shape.
</p>
<p>All designs created by this package are class <code><a href="DoE.base.html#topic+class-design">design</a></code> objects, 
which are data frames with attributes.
</p>
<p>Apart from providing designs, the package also provides functions for comparing 
the quality of several designs with quantitative variables (function <code>compare</code>).
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box, G.E.P. and Behnken, D.W. (1960). Some new three-level designs for the study of 
quantitative variables. <em>Technometrics</em> <b>2</b>, 455-475.
</p>
<p>Box, G.E.P., Hunter, J.S. and Hunter, W.G. (2005, 2nd ed.). <em>Statistics for Experimenters</em>. 
Wiley, New York.
</p>
<p>Box, G.E.P. and Wilson, K.B. (1951). On the Experimental Attainment of Optimum Conditions. 
<em>J. Royal Statistical Society</em>, <b>B13</b>, 1-45.
</p>
<p>NIST/SEMATECH e-Handbook of Statistical Methods, 
<a href="http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm">http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm</a>, 
accessed August 20th, 2009.
</p>
<p>Myers, R.H., Montgomery, D.C. and Anderson-Cook, C.M. (2009). <em>Response Surface Methodology. 
Process and Product Optimization Using Designed Experiments</em>. Wiley, New York.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ccd.design">ccd.design</a></code>, <code><a href="#topic+ccd.augment">ccd.augment</a></code>, <code><a href="#topic+bbd.design">bbd.design</a></code>, <code><a href="#topic+lhs.design">lhs.design</a></code>, 
<code><a href="#topic+Dopt.design">Dopt.design</a></code>, <code><a href="#topic+Dopt.augment">Dopt.augment</a></code>,
<code><a href="lhs.html#topic+lhs-package">lhs-package</a></code>, <code><a href="rsm.html#topic+rsm">rsm</a></code>, <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code>, 
<code><a href="AlgDesign.html#topic+optBlock">optBlock</a></code>, <code><a href="#topic+compare">compare</a></code>, <code><a href="FrF2.html#topic+FrF2">FrF2</a></code> </p>

<hr>
<h2 id='bbd.design'> Function for generating Box-Behnken designs </h2><span id='topic+bbd.design'></span>

<h3>Description</h3>

<p>Function for generating Box-Behnken designs, 
making use of package rsm 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbd.design(nfactors, ncenter=4, factor.names = NULL, default.levels=c(-1,1), 
          block.name=NULL, randomize=TRUE, seed=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbd.design_+3A_nfactors">nfactors</code></td>
<td>
<p> number of factors </p>
</td></tr>
<tr><td><code id="bbd.design_+3A_ncenter">ncenter</code></td>
<td>
<p> integer number of center points for each block </p>
</td></tr>
<tr><td><code id="bbd.design_+3A_factor.names">factor.names</code></td>
<td>
<p> list of scale end values for each factor 
(the middle value is calculated);<br /> 
names are used as variable names; <br />
<b>the names must not be x1, x2, ..., as these are used for the variables 
in coded units</b>;<br />
if the list is not named, the variable names are A, B and so forth;
in the coded units used in attribute desnum, <code>-1</code> corresponds to the smaller, <code>+1</code> to the larger value. </p>
</td></tr>
<tr><td><code id="bbd.design_+3A_default.levels">default.levels</code></td>
<td>
<p> default levels (vector of length 2) for all factors for 
which no specific levels are given; must consist of two numeric values for the scale ends, 
the default middle level is calculated </p>
</td></tr>
<tr><td><code id="bbd.design_+3A_block.name">block.name</code></td>
<td>
<p> name of block factor that distinguishes between the blocks;
blocks are usable for nfactors=4 and nfactors=5 only, <code>block.name</code> is ignored otherwise. </p>
</td></tr>
<tr><td><code id="bbd.design_+3A_randomize">randomize</code></td>
<td>
<p> logical that indicates whether or not randomization should occur </p>
</td></tr>
<tr><td><code id="bbd.design_+3A_seed">seed</code></td>
<td>
<p> optional seed for random number generation in randomization<br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>bbd.design</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="bbd.design_+3A_...">...</code></td>
<td>
<p> reserved for future usage</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>bbd.design</code> creates a Box-Behnken design, which is a design for quantitative 
factors with all factors on three levels. Box-Behnken designs should not be used if the combinations 
of the extreme levels of the factors are of interest (cf. also Myers, Montgomery and Anderson-Cook 2009). 
There are designs for 3 to 7 factors, and the unreplicated versions of these have 
14 (3 factors), 24 (4 factors), 40 (5 factors), 48 (6 factors), and 56 (7 factors) runs 
plus the specified number of center points <code>ncenter</code>.
</p>
<p>Function <code>bbd.design</code> is an interface to function <code><a href="rsm.html#topic+bbd">bbd</a></code> from package <span class="pkg">rsm</span> 
that makes this design accessible using similar syntax as used in packages <span class="pkg">DoE.base</span> and <span class="pkg">FrF2</span> 
and creates an output object that is also treatable by the convenience functions available in package 
<span class="pkg">DoE.base</span>.
</p>
<p>Currently, creation of replications and repeated measurements - as would be usual for other design 
functions - is not implemented. This is planned for the future, but does not have high priority.
</p>


<h3>Value</h3>

<p>The function returns a data frame of S3 class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
with attributes attached. The data frame itself is in the original data scale. 
The matrix <code>desnum</code> attached as attribute <code>desnum</code> contains the coded data,
the attribute <code>run.order</code> contains the standard order and the actual run order 
of the design (contrary to package <code>rsm</code>, the row names of the design refer to 
the actual rather than the standard run order).
</p>
<p>The attribute <code>design.info</code> is a list of design properties. 
The element <code>type</code> of that list is the character string <code>bbd</code>. 
Besides the elements present in all class <code><a href="DoE.base.html#topic+class-design">design</a></code> objects, 
there are the elements quantitative (vector with <code>nfactor</code> TRUE entries),
and a <code>codings</code> element usable in the coding functions available in the <span class="pkg">rsm</span> 
package, e.g. <code><a href="rsm.html#topic+coded.data">coded.data</a></code>.
</p>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome. <code>bbd.design</code> is based on version 1 of package <span class="pkg">rsm</span>. </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box, G.E.P. and Behnken, D.W. (1960). Some new three-level designs for the study of 
quantitative variables. <em>Technometrics</em> <b>2</b>, 455-475.
</p>
<p>Box, G.E.P., Hunter, J.S. and Hunter, W.G. (2005, 2nd ed.). <em>Statistics for Experimenters</em>. 
Wiley, New York.
</p>
<p>Box, G.E.P. and Wilson, K.B. (1951). On the Experimental Attainment of Optimum Conditions. 
<em>J. Royal Statistical Society</em>, <b>B13</b>, 1-45.
</p>
<p>NIST/SEMATECH e-Handbook of Statistical Methods, 
<a href="http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm">http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm</a>, 
accessed August 20th, 2009.
</p>
<p>Myers, R.H., Montgomery, D.C. and Anderson-Cook, C.M. (2009). <em>Response Surface Methodology. 
Process and Product Optimization Using Designed Experiments</em>. Wiley, New York.
</p>


<h3>See Also</h3>

<p> See also <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, <code><a href="#topic+ccd.design">ccd.design</a></code>, <code><a href="lhs.html#topic+lhs-package">lhs-package</a></code>, <code><a href="rsm.html#topic+rsm">rsm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>plan1 &lt;- bbd.design(5)  ## default for 5 factors is unblocked design, contrary to package rsm
plan1
## blocked design for 4 factors, using default levels
plan2 &lt;- bbd.design(4,block.name="block",default.levels=c(10,30))
plan2
desnum(plan2)
## design with factor.names and modified ncenter
bbd.design(3,ncenter=6, 
  factor.names=list("one"=c(25,35),"two"=c(-5,20), "three"=c(20,60)))
## design with character factor.names and default levels
bbd.design(3,factor.names=c("one","two", "three"), default.levels=c(10,20))
</code></pre>

<hr>
<h2 id='ccd.augment'> Function for augmenting an existing cube with a star portion, using package rsm </h2><span id='topic+ccd.augment'></span>

<h3>Description</h3>

<p>Function for augmenting an existing fractional factorial with a star portion 
in case of a late decision for a sequential procedure. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccd.augment(cube, ncenter = 4, columns="all", block.name="Block.ccd",
        alpha = "orthogonal", randomize=TRUE, seed=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccd.augment_+3A_cube">cube</code></td>
<td>
<p>design generated by function <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>. The design 
must not be a split-plot design, nor a parameter design in long version. </p>
</td></tr>
<tr><td><code id="ccd.augment_+3A_ncenter">ncenter</code></td>
<td>
<p> integer number of center points, 
or vector with two numbers, the first for the cube and the second for 
the star portion of the design. <br />
If only one number is given, this is either used for each block (if the 
cube block does not have center points yet) or for the star portion of the 
design only. </p>
</td></tr>
<tr><td><code id="ccd.augment_+3A_block.name">block.name</code></td>
<td>
<p> name of block factor that distinguishes (at least) between blocks; 
even for unblocked cubes, the ccd design has a cube and a star point block </p>
</td></tr>
<tr><td><code id="ccd.augment_+3A_alpha">alpha</code></td>
<td>
 <p>&ldquo;orthogonal&rdquo;, &ldquo;rotatable&rdquo;, 
or a number that indicates the position of the star points;
the number 1 would create a face-centered design. </p>
</td></tr>
<tr><td><code id="ccd.augment_+3A_randomize">randomize</code></td>
<td>
<p> logical that indicates whether or not randomization should occur </p>
</td></tr>
<tr><td><code id="ccd.augment_+3A_seed">seed</code></td>
<td>
<p> NULL or a vector of two integer seeds for random number generation in randomization<br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>ccd.augment</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="ccd.augment_+3A_...">...</code></td>
<td>
<p> reserved for future usage </p>
</td></tr>
<tr><td><code id="ccd.augment_+3A_columns">columns</code></td>
<td>
<p>not yet implemented; 
it is intended to later allow to add star points for only some factors 
of a design (after eliminating the others as unimportant in a sequential process), 
and columns will be used to indicate those</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistical background of central composite designs is briefly described 
under <code><a href="#topic+CentralCompositeDesigns">CentralCompositeDesigns</a></code>.
</p>
<p>Function <code>ccd.augment</code> augments an existing 2-level fractional factorial 
that should already have been run with center points and should have resolution V. 
</p>
<p>In exceptional situations, it may be useful to base a ccd on a resolution IV design 
that allows estimation of all 2-factor interactions of interest. Thus, it can be 
interesting to apply function <code>ccd.augment</code> to a cube 
based on the <code>estimable</code> functionality of function <code><a href="FrF2.html#topic+FrF2">FrF2</a></code> 
in cases where a resolution V cube is not feasible.
Of course, this does not allow to estimate the aliased 2-factor interactions 
and therefore generates a warning.
</p>


<h3>Value</h3>

<p>The function returns a data frame of S3 class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
with attributes attached. The data frame itself is in the original data scale. 
The data frame <code>desnum</code> attached as attribute <code>desnum</code> is the original data frame 
returned by package <code>rsm</code>. The attribute <code>design.info</code> is a list of various design properties. 
The element <code>type</code> of that list is the character string <code>ccd</code>.
Besides the elements present in all class <code><a href="DoE.base.html#topic+class-design">design</a></code> objects, 
there are the elements quantitative (vector with <code>nfactor</code> TRUE entries),
and a <code>codings</code> element usable in the coding functions available in the <span class="pkg">rsm</span> 
package, e.g. <code><a href="rsm.html#topic+coded.data">coded.data</a></code>.
</p>
<p>Note that the row names and the standard order column in the <code>run.order</code> 
attribute of ccd designs based on 
estimability requirements (cf. also the details section) are not in conventional order 
and should not be used as the basis for any calculations. The same is true for 
blocked designs, if the blocking routine <code><a href="FrF2.html#topic+blockpick">blockpick.big</a></code> was used.
</p>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome. <code>ccd.augment</code> is based on version 1 of package <span class="pkg">rsm</span>. </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box, G.E.P., Hunter, J.S. and Hunter, W.G. (2005, 2nd ed.). <em>Statistics for Experimenters</em>. 
Wiley, New York.
</p>
<p>Box, G.E.P. and Wilson, K.B. (1951). On the Experimental Attainment of Optimum Conditions. 
<em>J. Royal Statistical Society</em>, <b>B13</b>, 1-45.
</p>
<p>NIST/SEMATECH e-Handbook of Statistical Methods, 
<a href="http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm">http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm</a>, 
accessed August 20th, 2009.
</p>
<p>Myers, R.H., Montgomery, D.C. and Anderson-Cook, C.M. (2009). <em>Response Surface Methodology. 
Process and Product Optimization Using Designed Experiments</em>. Wiley, New York.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ccd.design">ccd.design</a></code>, <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, 
<code><a href="lhs.html#topic+lhs-package">lhs-package</a></code>, <code><a href="rsm.html#topic+rsm">rsm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## purely technical examples for the sequential design creation process
    ## start with a fractional factorial with center points
    plan &lt;- FrF2(16,5,default.levels=c(10,30),ncenter=6)
    ## collect data and add them to the design
    y &lt;- rexp(22)
    plan &lt;- add.response(plan,y)
    ## assuming that an analysis has created the suspicion that a second order 
    ## model should be fitted (not to be expected for the above random numbers):
    plan.augmented &lt;- ccd.augment(plan, ncenter=4)
    ## add new responses to the design
    y &lt;- c(y, rexp(14))  ## append responses for the 14=5*2 + 4 star points
    r.plan.augmented &lt;- add.response(plan.augmented, y, replace=TRUE)

  ## for info: how to analyse results from such a desgin
    lm.result &lt;- lm(y~Block.ccd+(.-Block.ccd)^2+I(A^2)+I(B^2)+I(C^2)+I(D^2)+I(E^2), 
                      r.plan.augmented)
    summary(lm.result)
    ## analysis with function rsm
    rsm.result &lt;- rsm(y~Block.ccd+SO(A,B,C,D,E), r.plan.augmented)
    summary(rsm.result)  ## provides more information than lm.result
    loftest(rsm.result)  ## separate lack of fit test
    ## graphical analysis 
    ## (NOTE: purely for demo purposes, the model is meaningless here)
    ## individual contour plot
    contour(rsm.result,B~A)
    ## several contour plots
    par(mfrow=c(1,2))
    contour(rsm.result,list(B~A, C~E))
    ## many contourplots, all pairs of some factors
    par(mfrow=c(2,3))
    contour(rsm.result,~A+B+C+D)
</code></pre>

<hr>
<h2 id='ccd.design'> Function for accessing central composite designs from package rsm </h2><span id='topic+ccd.design'></span>

<h3>Description</h3>

<p>Function for accessing central composite designs from package rsm, 
with automatic creation of an appropriate cube portion 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccd.design(nfactors=NULL, factor.names=NULL, default.levels=c(-1,1), ncube=NULL, 
        resolution=if (identical(blocks,1) &amp; is.null(ncube)) 5 else NULL, 
        generators=NULL, ncenter = 4, alpha = "orthogonal", 
        replications=1, 
        block.name="Block.ccd", blocks=1, 
        randomize=TRUE, seed=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccd.design_+3A_nfactors">nfactors</code></td>
<td>
<p> number of factors </p>
</td></tr>
<tr><td><code id="ccd.design_+3A_factor.names">factor.names</code></td>
<td>
<p> list of cube corner values for each factor; 
names are used as variable names; 
<b>the names must not be x1, x2, ..., as these are used for the variables 
in coded units</b>;<br />
if the list is not named, the variable names are X1, X2 and so forth;
in coded units, <code>-1</code> corresponds to the smaller, <code>+1</code> to the larger value.</p>
</td></tr>
<tr><td><code id="ccd.design_+3A_default.levels">default.levels</code></td>
<td>
<p> default levels (vector of length 2) for all factors for 
which no specific levels are given </p>
</td></tr>
<tr><td><code id="ccd.design_+3A_ncube">ncube</code></td>
<td>
<p> integer number of cube points (without center points for the cube) </p>
</td></tr>
<tr><td><code id="ccd.design_+3A_resolution">resolution</code></td>
<td>
<p> arabic numeral for the requested resolution of the cube portion 
of the design; cubes for ccd designs should usually be at least of resolution V. 
the default value for resolution is therefore 5, unless <code>generators</code> 
or <code>blocks</code> are specified, in which case the default is NULL</p>
</td></tr>
<tr><td><code id="ccd.design_+3A_generators">generators</code></td>
<td>
<p> generators in the form allowed in function <code><a href="FrF2.html#topic+FrF2">FrF2</a></code> </p>
</td></tr>
<tr><td><code id="ccd.design_+3A_ncenter">ncenter</code></td>
<td>
<p> integer number of center points for each cube or star point block, 
or vector with two numbers, the first for the cube and the second for 
the star portion of the design </p>
</td></tr>
<tr><td><code id="ccd.design_+3A_alpha">alpha</code></td>
<td>
 <p>&ldquo;orthogonal&rdquo;, &ldquo;rotatable&rdquo;, 
or a number that indicates the position of the star points;
the number 1 would create a face-centered design. </p>
</td></tr>
<tr><td><code id="ccd.design_+3A_replications">replications</code></td>
<td>
<p> the number of replications of the design; 
currently, only proper replications can be generated;
these are randomized in blocks within the center point and star blocks.
The same number of replications is used for both the cube and the star blocks.</p>
</td></tr>
<tr><td><code id="ccd.design_+3A_block.name">block.name</code></td>
<td>
<p> name of block factor that distinguishes between blocks; 
even for unblocked cubes, the ccd design has at least one cube and one star point block </p>
</td></tr>
<tr><td><code id="ccd.design_+3A_blocks">blocks</code></td>
<td>
<p> the same as in function <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>;<br />
is EITHER <br /> 
the number of blocks into which the experiment is subdivided <br />
OR a character vector of names of independent factors that are used as block constructors <br />
OR a vector or list of generators similar to <code>generators</code>. <br />
In the latter case, 
the differences to <code>generators</code> are <br /> 
</p>

<ul>
<li><p> that numbers/letters refer to the factors of the experiment and not to 
column numbers of the Yates matrix 
</p>
</li>
<li><p> that numbers/letters can refer to *all* <code>nfactors</code> factors rather than the log2(nruns) base factors only, 
</p>
</li>
<li><p> that one single number is always interpreted as the number of blocks rather than a column reference, 
</p>
</li>
<li><p> that individual numbers are allowed in a list (i.e. individual factors specified in the experiment can be used as block factors) and
</p>
</li>
<li><p> that no negative signs are allowed. </p>
</li></ul>

<p>If <code>blocks</code> is a single number, it must be a power of 2. 
A blocked design can have at most <code>nruns-blocks</code> treatment 
factors, but should usually have fewer than that. <br />
</p>
<p>If the experiment is randomized, randomization happens within blocks. <br />
</p>
<p>For the statistical and algorithmic background of blocked designs, see <code><a href="FrF2.html#topic+block">block</a></code>.<br />
Note that the blocking strategy of package <span class="pkg">FrF2</span> was modified with version 2 (2.1) of the package.
</p>
</td></tr>
<tr><td><code id="ccd.design_+3A_randomize">randomize</code></td>
<td>
<p> logical that indicates whether or not randomization should occur </p>
</td></tr>
<tr><td><code id="ccd.design_+3A_seed">seed</code></td>
<td>
<p> NULL or a vector of two integer seeds for random number generation in randomization<br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>ccd.design</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="ccd.design_+3A_...">...</code></td>
<td>
<p> reserved for future usage</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistical background of central composite designs is briefly described 
under <code><a href="#topic+CentralCompositeDesigns">CentralCompositeDesigns</a></code>.
</p>
<p>Function <code>ccd.design</code> creates a central composite design from scratch. 
It proceeds by generating a cube design with function <code><a href="FrF2.html#topic+FrF2">FrF2</a></code> and then 
augmenting this cube design using functions <code><a href="FrF2.html#topic+add.center">add.center</a></code> from package 
<span class="pkg">FrF2</span> for adding center points to the cube and subsequently function 
<code><a href="rsm.html#topic+ccd">ccd</a></code> from package <span class="pkg">rsm</span> for generating the star portion of 
the design. 
</p>
<p>There are two main purposes for this function: one is to provide 
central composite designs within the same syntax philosophy 
used in packages <code><a href="DoE.base.html#topic+DoE.base-package">DoE.base-package</a></code> and <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>. 
The other is to automatically identify good (=resolution V) cube portions, 
which can be achieved by using the resolution parameter.
</p>
<p>In comparison to direct usage of package <span class="pkg">ccd</span>, the functions make the syntax closer to 
that of the other packages in the DoE.wrapper suite and allow automatic selection of fractional 
factorials as cubes. 
</p>
<p>Function <code>ccd.design</code> does not allow direct use of the <code>estimable</code> functionality 
that is available in function <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>. Nevertheless, ccd designs with a cube 
based on the <code>estimable</code> functionality can be generated 
by first using function <code>FrF2</code> and subsequently applying 
function <code><a href="#topic+ccd.augment">ccd.augment</a></code>. It may for example be interesting to use designs based on 
estimability requirements for 2-factor interactions in cases where a resolution V cube 
for the ccd is not feasible - of course, this does not allow to estimate the full second order model
and therefore generates a warning.
</p>


<h3>Value</h3>

<p>The function returns a data frame of S3 class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
with attributes attached. The data frame itself is in the original data scale. 
The data frame <code>desnum</code> attached as attribute <code>desnum</code> is the coded design. 
The attribute <code>design.info</code> is a list of various design properties. 
The element <code>type</code> of that list is the character string <code>ccd</code>.
Besides the elements present in all class <code><a href="DoE.base.html#topic+class-design">design</a></code> objects, 
there are the elements quantitative (vector with <code>nfactor</code> TRUE entries),
and a <code>codings</code> element usable in the coding functions available in the <span class="pkg">rsm</span> 
package, e.g. <code><a href="rsm.html#topic+coded.data">coded.data</a></code>.
</p>
<p>Note that the row names and the standard order column in the 
<code>run.order</code> attribute of ccd designs 
are not in conventional order, 
if the blocking routine <code><a href="FrF2.html#topic+blockpick">blockpick.big</a></code> was used. 
In such situations, these should not be used as the basis for any calculations. 
</p>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome. <code>ccd.design</code> is based on version 1 of package <span class="pkg">rsm</span>. </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box, G.E.P., Hunter, J.S. and Hunter, W.G. (2005, 2nd ed.). <em>Statistics for Experimenters</em>. 
Wiley, New York.
</p>
<p>Box, G.E.P. and Wilson, K.B. (1951). On the Experimental Attainment of Optimum Conditions. 
<em>J. Royal Statistical Society</em>, <b>B13</b>, 1-45.
</p>
<p>NIST/SEMATECH e-Handbook of Statistical Methods, 
<a href="http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm">http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm</a>, 
accessed August 20th, 2009.
</p>
<p>Myers, R.H., Montgomery, D.C. and Anderson-Cook, C.M. (2009). <em>Response Surface Methodology. 
Process and Product Optimization Using Designed Experiments</em>. Wiley, New York.
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ccd.augment">ccd.augment</a></code>, <code><a href="FrF2.html#topic+add.center">add.center</a></code>, 
<code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, <code><a href="lhs.html#topic+lhs-package">lhs-package</a></code>, <code><a href="rsm.html#topic+rsm">rsm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>ccd.design(5) ## per default uses the resolution V design in 16 runs for the cube
ccd.design(5, ncube=32) ## uses the full factorial for the cube
ccd.design(5, ncenter=6, default.levels=c(-10,10))
## blocked design (requires ncube to be specified)
ccd.design(5, ncube=32, blocks=4) 
## there is only one star point block

## for usage of other options, look at the FrF2 documentation
</code></pre>

<hr>
<h2 id='CentralCompositeDesigns'> Statistical background of central composite designs </h2><span id='topic+CentralCompositeDesigns'></span>

<h3>Description</h3>

<p>Brief description of the statistical background of 
central composite designs 
</p>


<h3>Details</h3>

<p>Central composite designs (ccd's) were invented by Box and Wilson (1951) 
for response surface experimentation with quantitative factors. 
They are used for estimation of second order 
response surface models, i.e. models that allow to estimate linear, quadratic and 
interaction effects for all factors. 
</p>
<p>Central composite designs consist of a cube and star points (also called 
axial points). Both the cube and the star portion of the design should have some center 
points. The cube is a (fractional) factorial design and should be at least of resolution V. 
The line between the center points and the star points intersects the faces of the cube 
in their middle (see the link to the NIST/Sematech e-Handbook 
for a visualization). There are two star points per factor, i.e. the number of runs 
for (each block of) the star 
portion of the design is twice the number of factors plus the number of center points 
in the star portion. 
</p>
<p>The tuning parameter <code>alpha</code> determines whether the star points lie on the 
faces of the cube (<code>alpha=1</code>, face-centered), inside the cube (<code>alpha&lt;1</code>, 
inscribed) or outside the cube (<code>alpha&gt;1</code>, circumscribed). 
The latter case is the usual one. The value of 
<code>alpha</code> can be chosen such that the design is rotatable (may be useful if the scales 
of the factors are comparable) or such that the design is orthogonally blocked 
(i.e. the block effects do not affect the effect estimates of interest). The default 
is to generate orthogonally blocked designs.
</p>
<p>Central composite designs are particularly useful in sequential experimentation, 
where a (fractional) factorial with center points is followed up by a star portion 
of the design. While the cube can already estimate the linear and interaction effects, 
the center points can only estimate the sum of all quadratic effects. If this indicates 
that quadratic effects are important, a star portion can be added in order to investigate 
the model more deeply.
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome.  </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Box, G.E.P., Hunter, J.S. and Hunter, W.G. (2005, 2nd ed.). <em>Statistics for Experimenters</em>. 
Wiley, New York.
</p>
<p>Box, G.E.P. and Wilson, K.B. (1951). On the Experimental Attainment of Optimum Conditions. 
<em>J. Royal Statistical Society</em>, <b>B13</b>, 1-45.
</p>
<p>NIST/SEMATECH e-Handbook of Statistical Methods, 
<a href="http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm">http://www.itl.nist.gov/div898/handbook/pri/section3/pri3361.htm</a>, 
accessed August 20th, 2009.
</p>
<p>Myers, R.H., Montgomery, D.C. and Anderson-Cook, C.M. (2009). Response Surface Methodology. 
Process and Product Optimization Using Designed Experiments. Wiley, New York.
</p>


<h3>See Also</h3>

<p> See Also <code><a href="rsm.html#topic+ccd">ccd</a></code>, <code><a href="#topic+ccd.design">ccd.design</a></code>, <code><a href="#topic+ccd.augment">ccd.augment</a></code> </p>

<hr>
<h2 id='Dopt.augment'> Function for augmenting a design with D-optimal additional points using optFederov from package AlgDesign </h2><span id='topic+Dopt.augment'></span>

<h3>Description</h3>

<p>Function for comfortably augmenting a design with D-optimal additional points;
this functionality is still somewhat experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dopt.augment(design, m=1, formula=NULL, candidates=NULL, constraint=NULL, 
    center=FALSE, nRepeats=5, 
    seed=NULL, randomize=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dopt.augment_+3A_design">design</code></td>
<td>
<p>an experimental design of class <code>design</code>, 
which may not be a blocked, split-plot, neither 
crossed or parameter design; it also must not be replicated with repeat.only replications. 
</p>
</td></tr>
<tr><td><code id="Dopt.augment_+3A_m">m</code></td>
<td>
<p>integer number of additional points to add to design <code>design</code> </p>
</td></tr>
<tr><td><code id="Dopt.augment_+3A_formula">formula</code></td>
<td>
<p> a model formula (starting with a tilde), for the estimation of which a D-optimal design is sought;<br />
it can contain all column names from <code>data</code> 
or elements or element names from <code>factor.names</code>, respectively;<br />
usage of the &ldquo;.&rdquo;-notation for &ldquo;all variables&rdquo; from <code>data</code> or <code>factor.names</code> 
is possible. <br />
The default formula (if the value <code>NULL</code> is not changed) is the formula associated with 
the design (by function <code>formula.design</code>). 
</p>
<p>For quantitative factors, functions <code>quad()</code> and <code>cubic</code> describe the 
full quadratic or full cubic model in the listed variables (cf. examples 
and the <code><a href="AlgDesign.html#topic+expand.formula">expand.formula</a></code>-function from package <span class="pkg">AlgDesign</span>).  
</p>
</td></tr>
<tr><td><code id="Dopt.augment_+3A_candidates">candidates</code></td>
<td>
<p>data frame of candidate points; if not specified, candidates 
are constructed as a full factorial from the 
<code>factor.names</code> element of the <code>design.info</code> attribute of <code>design</code></p>
</td></tr>
<tr><td><code id="Dopt.augment_+3A_constraint">constraint</code></td>
<td>
<p> a condition (character string!) used for reducing the candidate 
set to admissible points only. <br />
<code>constraint</code> is evaluated on the specified data set or after automatic creation 
of a full factorial candidate data set.<br /> 
The variable names from <code>data</code> or <code>factor.names</code> can be used by the constraint.<br />
Per default (i.e. if the constraint is <code>NULL</code>), the constraint attribute from 
<code>design</code> is used. <br />
If a previously-applied constraint is to be removed, specify <code>constraint = ""</code>.<br />
It is not possible to apply a constraint that is already violated by the 
design that is to be augmented.
</p>
</td></tr>
<tr><td><code id="Dopt.augment_+3A_center">center</code></td>
<td>
<p> requests that optimization is run for the centered model; 
the design is nevertheless output in non-centered coordinates
</p>
</td></tr>
<tr><td><code id="Dopt.augment_+3A_nrepeats">nRepeats</code></td>
<td>
<p> number of independent repeats of the design optimization process; 
increasing this number may improve the chance of finding a global optimum, 
but will also increase search time
</p>
</td></tr>
<tr><td><code id="Dopt.augment_+3A_seed">seed</code></td>
<td>
<p> seed for generation and randomization of the design (integer number);<br /> 
here, the seed is needed even if the design is not randomized, because the 
generation process for the optimum design involves random numbers, even if the 
order of the final design is not randomized;<br />
if a reproducible design is needed, it is therefore recommended to specify a seed<br /><br /> 
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>Dopt.augment</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="Dopt.augment_+3A_randomize">randomize</code></td>
<td>
<p> logical deciding whether or not the design should be randomized; 
if it is <code>TRUE</code>, the design (or the additional portion of the design) returned by the 
workhorse function <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code> is brought 
into random order after generation. Note that the generation process 
itself contains a random element per default; if exact repeatability for the 
returned design is desired, it is necessary to specify a seed (option <code>seed</code>) 
if in the case <code>randomize=FALSE</code>. </p>
</td></tr>
<tr><td><code id="Dopt.augment_+3A_...">...</code></td>
<td>
<p> additional arguments to function <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code> 
from package <span class="pkg">AlgDesign</span>;<br /> 
interesting arguments: <code>maxIteration</code>, 
<code>nullify</code> (calculate good starting design, especially set to 1, 
in which case <code>nRepeats</code> is set to 1;<br /> 
arguments <code>criterion</code> and <code>augment</code> are not available, neither 
are <code>evaluateI</code>, <code>space</code>, or <code>rows</code>, and <code>args</code> 
does not have an effect. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>Dopt.augment</code> augments an existing design by <code>m</code> D-optimal 
additional points (unblocked designs, no split-plot, no parameter or crossed design, 
no repeat.only replications), i.e. by points that make the design particularly efficient 
for the intended model. 
</p>
<p>Option <code>center</code>, which is available for both blocked and unblocked designs as part of the ... argument, 
requests optimization for the centered model; the design that is created is nevertheless an uncentered design.
</p>
<p>NULL entries in the arguments are filled with automatic values that are determined 
from <code>design</code>.
</p>


<h3>Value</h3>

<p>The function returns a data frame of S3 class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
with attributes attached. 
The data frame contains the experimental settings.
The matrix <code>desnum</code> attached as attribute <code>desnum</code> contains the 
model matrix of the design, using the formula as specified in the call. <br />
Function <code>Dopt.augment</code> preserves additional variables (e.g. responses) that 
have been added to the design <code>design</code> before augmenting. Note, however, that 
the response data are NOT used in deciding about which points to augment the design with.
</p>
<p>The attribute <code>run.order</code> provides the run number in standard order (as returned from 
function <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code> in package <span class="pkg">AlgDesign</span>) as well 
as the randomized actual run order. The third column is always identical to the first. 
Note that the first n runs (the ones that are already present before augmentation) 
have run numbers in standard order from 1 to n (i.e. their original run numbers 
in standard order, if they were also generated by <code><a href="#topic+Dopt.design">Dopt.design</a></code> are lost).
</p>
<p>The attribute <code>design.info</code> is a list of various design properties, with type resolving to &ldquo;Dopt.augment&rdquo;. 
In addition to the standard list elements (cf. <code><a href="DoE.base.html#topic+class-design">design</a></code>), the element 
<code>quantitative</code> is a vector of <code>nfactor</code> logical values or NAs, 
and the optional <code>digits</code> elements indicates the number of digits to 
which the data were rounded. 
The list contains further entries regarding the optimality that has been achieved 
(<code>D</code>, <code>Dea</code> and <code>A</code>). 
</p>
<p>Note that the original design is contained in the first rows of the new data set. 
The original design also contains columns that are not directly part of the 
design, e.g. comment columns. <br />
Note that <code>replications</code> is always set to 1, even if the original design was 
replicated, and <code>repeat.only</code> is always FALSE. 
These elements are only present to fulfill the formal requirements for class <code>design</code>.)
</p>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Atkinson, A.C. and Donev, A.N. (1992). <em>Optimum experimental designs</em>. Clarendon Press, Oxford. 
</p>
<p>Federov, V.V. (1972). <em>Theory of optimal experiments</em>. Academic Press, New York. 
</p>
<p>Wheeler, R.E. (2004). <em>Comments on algorithmic design</em>. Vignette accompanying package <span class="pkg">AlgDesign</span>. 
<a href="../../AlgDesign/doc/AlgDesign.pdf">../../AlgDesign/doc/AlgDesign.pdf</a>.
</p>


<h3>See Also</h3>

<p> See also <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code>, <code><a href="DoE.base.html#topic+fac.design">fac.design</a></code>, 
<code><a href="AlgDesign.html#topic+expand.formula">quad</a></code>, <code><a href="AlgDesign.html#topic+expand.formula">cubic</a></code>, 
<code><a href="#topic+Dopt.design">Dopt.design</a></code>. Furthermore, unrelated to function <code>Dopt.augment</code>, 
see also function <code><a href="skpr.html#topic+gen_design">gen_design</a></code> from package <span class="pkg">skpr</span> 
for a new general R package for creating D-optimal or other letter optimal designs.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## a full quadratic model with constraint in three quantitative factors 
   plan &lt;- Dopt.design(36,factor.names=list(eins=c(100,250),zwei=c(10,30),drei=c(-25,25)),
                          nlevels=c(4,3,6), 
                          formula=~quad(.), 
                          constraint="!(eins&gt;=200 &amp; zwei==30 &amp; drei==25)")
   summary(plan)
   y &lt;- rnorm(36)
   r.plan &lt;- add.response(plan, y)
   plan2 &lt;- Dopt.augment(r.plan, m=10)
   summary(plan2)
   ## add the new response values after conducting additional experiments
   y &lt;- c(y, rnorm(10))
   r.plan2 &lt;- add.response(plan2,y, replace=TRUE)
   summary(r.plan2, brief=FALSE)
   
</code></pre>

<hr>
<h2 id='Dopt.design'> Function for creating D-optimal designs with or without blocking from package AlgDesign </h2><span id='topic+Dopt.design'></span>

<h3>Description</h3>

<p>Function for comfortably creating a D-optimal design with or without blocking 
based on functions optFederov or optBlock from package AlgDesign;
this functionality is still somewhat experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dopt.design(nruns, data=NULL, formula=~., factor.names=NULL, nlevels=NULL, 
    digits=NULL, constraint=NULL, center=FALSE, nRepeats=5, seed=NULL, randomize=TRUE, 
    blocks=1, block.name="Blocks", wholeBlockData=NULL, qual=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dopt.design_+3A_nruns">nruns</code></td>
<td>
<p> number of runs in the requested design </p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_data">data</code></td>
<td>
<p> data frame or matrix of candidate design points;<br />
if <code>data</code> is specified, <code>factor.names</code> and <code>levels</code> are ignored</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_formula">formula</code></td>
<td>
<p> a model formula (starting with a tilde), 
for the estimation of which a D-optimal design is sought;<br />
it can contain all column names from <code>data</code> 
or elements or element names from <code>factor.names</code>, respectively;<br />
usage of the &ldquo;.&rdquo;-notation for &ldquo;all variables&rdquo; from <code>data</code> or <code>factor.names</code> 
is possible. <br />
The default formula linearly includes all main effects for columns of <code>data</code> or factors from 
<code>factor.names</code> respectively, by using the &ldquo;.&rdquo;-notation. 
Note that the variables from <code>wholeBlockData</code> must be explicitly included into the formula 
and are not covered by the &ldquo;.&rdquo;-notation for &ldquo;all variables&rdquo;. (Thus, the default formula 
does not work, if <code>wholeBlockData</code> is used.)
For quantitative factors, functions <code>quad()</code> and <code>cubic</code> describe the 
full quadratic or full cubic model in the listed variables (cf. examples 
and the <code><a href="AlgDesign.html#topic+expand.formula">expand.formula</a></code>-function from package <span class="pkg">AlgDesign</span>).  
</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_factor.names">factor.names</code></td>
<td>
<p> is used for creating a candidate set (for the within Block factors) 
with the help of function 
<code><a href="DoE.base.html#topic+fac.design">fac.design</a></code>, if <code>data</code> is not specified. It is a 
list of vectors which contain<br />
- individual levels<br />
- or (in case of numerical values combined with nlevels) lower and upper scale end values <br />
for each factor.<br />
The element names are used as variable names; <br />
if the list is not named, the variable names are A, B and so forth (from function 
<code><a href="DoE.base.html#topic+fac.design">fac.design</a></code>).<br />
<code>factor.names</code> can also be a character vector. 
In this case, <code>nlevels</code> must be specified, and levels are automatically assigned 
as integers starting with 1, which implies quantitative factors, 
unless <code>qual=TRUE</code> is specified.
</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_nlevels">nlevels</code></td>
<td>
<p> can be omitted if the list <code>factor.names</code> explicitly 
lists all factor levels (which of course defines the number of levels).<br /> 
For numeric factors for which <code>factor.names</code> only specifies the 
two scale ends, these are filled with equally-spaced intermediate points, 
using the nlevels entry as the <code>length.out</code> argument to function 
<code><a href="base.html#topic+seq">seq</a></code>.<br /> 
If <code>factor.names</code> is a character vector of factor names only, 
<code>nlevels</code> is required, and default levels are created. 
</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_digits">digits</code></td>
<td>
<p> is used for creating a candidate set if <code>data</code> is not specified.<br /> 
It specifies the digits to which numeric design columns are rounded in case of 
automatic creation of intermediate values. It can consist of one single value 
(the same for all such factors) or a numeric vector of the same length 
as <code>factor.names</code> with integer entries.
</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_constraint">constraint</code></td>
<td>
<p> a condition (character string!) used for reducing the candidate 
set to admissible points only. 
<code>constraint</code> is evaluated on the specified data set or after automatic creation 
of a full factorial candidate data set. <br /> 
The variable names from <code>data</code> or <code>factor.names</code> can be used by the constraint.
The variable names from <code>wholePlotData</code> can NOT be used. <br />
See <code><a href="base.html#topic+Syntax">Syntax</a></code> and <code><a href="base.html#topic+Logic">Logic</a></code> 
for an explanation of the syntax of general and especially logical 
R expressions.
</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_center">center</code></td>
<td>
<p> requests that optimization is run for the centered model; 
the design is nevertheless output in non-centered coordinates
</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_nrepeats">nRepeats</code></td>
<td>
<p> number of independent repeats of the design optimization process; 
increasing this number may improve the chance of finding a global optimum, 
but will also increase search time
</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_seed">seed</code></td>
<td>
<p> seed for generation and randomization of the design (integer number);<br /> 
here, the seed is needed even if the design is not randomized, because the 
generation process for the optimum design involves random numbers, even if the 
order of the final design is not randomized;<br />
if a reproducible design is needed, it is therefore recommended to specify a seed.<br /><br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>Dopt.design</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.
</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_randomize">randomize</code></td>
<td>
<p> logical deciding whether or not the design should be randomized; 
if it is <code>TRUE</code>, the design (or the additional portion of the design) returned by the 
workhorse function <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code> is brought 
into random order after generation. Note that the generation process 
itself contains a random element per default; if exact repeatability for the 
returned design is desired, it is necessary to specify a seed (option <code>seed</code>) 
if in the case <code>randomize=FALSE</code>. </p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_blocks">blocks</code></td>
<td>
<p> a single integer giving the number of blocks (default 1, if no blocking is needed)<br /> 
OR<br />
a vector of block sizes which enable blocks of different sizes;<br /> 
for a scalar value, <code>nruns</code> must be divisible into blocks equally-sized blocks; 
for a vector value, the block sizes must add up to <code>nruns</code>.<br />
If blocking is requested, the following two options are potentially important.</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_block.name">block.name</code></td>
<td>
<p> character string: name of the blocking variable (used only if blocks are requested) </p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_wholeblockdata">wholeBlockData</code></td>
<td>
<p> optional matrix or data frame that specifies the whole block characteristics;<br /> 
can only be used if blocks are requested; if used, it must have as many rows as there are block sizes.<br />
If this is specified, the resulting design is a split-plot design with the whole-plot 
factors specified in wholeBlockData, the split-plot factors specified in data. 
Note that usage of this option makes it necessary to explicitly specify a formula.<br />
</p>
<p>Since wholeBlockData must be completely specified by the user, optimization is 
for the split-plot portion of the design only. The rationale is (assumably) that the 
characteristics of the available blocks are known. If this is not the case, users 
may want to try out various possible whole block setups, or to proceed sequentially 
by first optimizing a whole block design for a model with the whole block factors only 
and subsequently using this model for adding split-plot factors.</p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_qual">qual</code></td>
<td>
<p>optional logical (length 1 or same as number of factors); ignored, if <code>data</code> 
is specified; overrides automatic determination of whether or not factors are quantitative;<br /> 
if neither <code>qual</code> nor <code>data</code> are specified, factors are per default quantitative, 
unless they have non-numeric levels in a list-valued <code>factor.names</code></p>
</td></tr>
<tr><td><code id="Dopt.design_+3A_...">...</code></td>
<td>
<p> additional arguments to functions <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code> 
or <code><a href="AlgDesign.html#topic+optBlock">optBlock</a></code> (if blocking is requested) 
from package <span class="pkg">AlgDesign</span>;<br /> 
interesting arguments for <code>optFederov</code>: <code>maxIteration</code>, 
<code>nullify</code> (calculate good starting design, especially set to 1, 
in which case <code>nRepeats</code> is set to 1);<br /> 
arguments <code>criterion</code> and <code>augment</code> are not available, neither 
are <code>evaluateI</code>, <code>space</code>, or <code>rows</code>, and <code>args</code> 
does not have an effect. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>Dopt.design</code> creates a D-optimal design, optionally with blocking, 
and even as a split-plot design. If no blocks are required, calculations are carried 
out through function <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code> from package <span class="pkg">AlgDesign</span>. 
In case of blocked designs, function <code><a href="AlgDesign.html#topic+optBlock">optBlock</a></code> from package <span class="pkg">AlgDesign</span> 
is behind the calculations. By specifying <code>wholeBlockData</code>, a blocked design becomes 
a split-plot design. The model formula can refer to both the within block data (only those 
are referred to by the &ldquo;.&rdquo; notation) and the whole block data and interactions between both. <br />
In comparison to direct usage of package <span class="pkg">AlgDesign</span>, the function adds the possibility 
of automatically creating the candidate points on the fly, with or without constraints.
Furthermore, it embeds the D-optimal designs into the class <code><a href="DoE.base.html#topic+class-design">design</a></code>. 
On the other hand, it sacrifices some of <span class="pkg">AlgDesign</span>s flexibility; of course, users 
can still use <span class="pkg">AlgDesign</span> directly. <br />
</p>
<p>The D-optimal designs are particularly useful, if the classical regular designs are too demanding 
in run size requirements, or if constraints preclude automatic generation of orthogonal designs. 
Note, however, that the best design in few runs can still be very bad in absolute terms!
</p>
<p>When specifying the design without the <code>data</code> option, a full factorial in the 
requested factors is the default candidate set of design points. For some situations - especially 
with many factors - it may be better to start from a restricted candidate set. Such a candidate set 
can be produced with another R function, e.g. <code><a href="DoE.base.html#topic+oa.design">oa.design</a></code> or <code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, 
or can be manually created. 
</p>
<p>If there are doubts, whether the process has delivered a design close to the absolute optimum, 
<code>nRepeats</code> can be increased.
</p>
<p>For unblocked designs, it is additionally possible to increase <code>maxIteration</code>. 
Also, improving the starting 
value by <code>nullify=1</code> or <code>nullify=2</code> may lead to an improved design. 
These options are handed through to function <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code> 
from package <span class="pkg">AlgDesign</span> and are documented there.
</p>


<h3>Value</h3>

<p>The function returns a data frame of S3 class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
with attributes attached. 
The data frame contains the experimental settings.
The matrix <code>desnum</code> attached as attribute <code>desnum</code> contains the 
model matrix of the design, using the formula as specified in the call. <br />
Function <code>Dopt.augment</code> preserves additional variables (e.g. responses) that 
have been added to the design <code>design</code> before augmenting. Note, however, that 
the response data are NOT used in deciding about which points to augment the design with.
</p>
<p>The attribute <code>run.order</code> provides the run number in standard order (as returned from 
function <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code> in package <span class="pkg">AlgDesign</span>) as well 
as the randomized actual run order. The third column is always identical to the first.
</p>
<p>The attribute <code>design.info</code> is a list of various design properties, with type resolving to &ldquo;Dopt&rdquo;, 
&ldquo;Dopt.blocked&rdquo;, &ldquo;Dopt.splitplot&rdquo;. 
In addition to the standard list elements (cf. <code><a href="DoE.base.html#topic+class-design">design</a></code>), the element 
<code>quantitative</code> is a vector of <code>nfactor</code> logical values or NAs, 
and the optional <code>digits</code> elements indicates the number of digits to 
which the data were rounded. 
For blocked and splitplot designs, the list contains additional information on numbers and sizes of blocks or plots, 
as well as the number of whole plot factors (which are always the first few factors) and split-plot factors.<br />
The list contains a list of optimality criteria as calculated by function <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code>, 
see documentation there) 
with elements <code>D</code>, <code>Dea</code>, <code>A</code> and <code>G</code>. 
</p>
<p>(Note that <code>replications</code> is always 1 and <code>repeat.only</code> is always FALSE; 
these elements are only present to fulfill the formal requirements for class <code>design</code>.
Note however, that blocked designs do in fact repeat experimental runs if <code>nruns</code> and <code>blocks</code>
imply this.)
</p>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Atkinson, A.C. and Donev, A.N. (1992). <em>Optimum experimental designs</em>. Clarendon Press, Oxford. 
</p>
<p>Federov, V.V. (1972). <em>Theory of optimal experiments</em>. Academic Press, New York. 
</p>
<p>Wheeler, R.E. (2004). <em>Comments on algorithmic design</em>. Vignette accompanying package <span class="pkg">AlgDesign</span>. 
<a href="../../AlgDesign/doc/AlgDesign.pdf">../../AlgDesign/doc/AlgDesign.pdf</a>.
</p>


<h3>See Also</h3>

<p> See also <code><a href="AlgDesign.html#topic+optFederov">optFederov</a></code>, <code><a href="DoE.base.html#topic+fac.design">fac.design</a></code>, 
<code><a href="AlgDesign.html#topic+expand.formula">quad</a></code>, <code><a href="AlgDesign.html#topic+expand.formula">cubic</a></code>,
<code><a href="#topic+Dopt.augment">Dopt.augment</a></code>. Furthermore, unrelated to function <code>Dopt.design</code>, 
see also function <code><a href="skpr.html#topic+gen_design">gen_design</a></code> from package <span class="pkg">skpr</span> 
for a new general R package for creating D-optimal or other letter optimal designs.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## a full quadratic model with constraint in three quantitative factors 
   plan &lt;- Dopt.design(36,factor.names=list(eins=c(100,250),zwei=c(10,30),drei=c(-25,25)),
                          nlevels=c(4,3,6), 
                          formula=~quad(.), 
                          constraint="!(eins&gt;=200 &amp; zwei==30 &amp; drei==25)")
   plan
   cor(plan)
   y &lt;- rnorm(36)
   r.plan &lt;- add.response(plan, y)
   plan2 &lt;- Dopt.augment(r.plan, m=10)
   plot(plan2)
   cor(plan2)
   
   ## designs with qualitative factors and blocks for
   ## an experiment on assessing stories of social situations
   ## where each subject is a block and receives a deck of 5 stories
   plan.v &lt;- Dopt.design(480, factor.names=list(cause=c("sick","bad luck","fault"), 
             consequences=c("alone","children","sick spouse"),
             gender=c("Female","Male"),
             Age=c("young","medium","old")),
             blocks=96,
             constraint="!(Age==\"young\" &amp; consequences==\"children\")",
             formula=~.+cause:consequences+gender:consequences+Age:cause)
   ## an experiment on assessing stories of social situations
   ## with the whole block (=whole plot) factor gender of the assessor
   ##    not run for saving test time on CRAN
   ## Not run: plan.v.splitplot &lt;- Dopt.design(480, factor.names=list(cause=c("sick","bad luck","fault"), 
             consequences=c("alone","children","sick spouse"),
             gender.story=c("Female","Male"),
             Age=c("young","medium","old")),
             blocks=96,
             wholeBlockData=cbind(gender=rep(c("Female","Male"),each=48)),
             constraint="!(Age==\"young\" &amp; consequences==\"children\")",
             formula=~.+gender+cause:consequences+gender.story:consequences+
                 gender:consequences+Age:cause+gender:gender.story)
## End(Not run)
</code></pre>

<hr>
<h2 id='lhs.design'> Functions for accessing latin hypercube sampling designs from package lhs 
or space-filling designs from package DiceDesign</h2><span id='topic+lhs.design'></span><span id='topic+lhs.augment'></span>

<h3>Description</h3>

<p>Functions for comfortably accessing latin hypercube sampling designs from package lhs 
or space-filling designs from package DiceDesign, 
which are useful for quantitative factors with many possible levels. In particular, 
they can be used in computer experiments. Most of the designs are random samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs.design(nruns, nfactors, type="optimum", factor.names=NULL, seed=NULL, digits=NULL, 
         nlevels = nruns, default.levels = c(0, 1), randomize = FALSE, ...)
lhs.augment(lhs, m=1, type="optAugment", seed=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lhs.design_+3A_nruns">nruns</code></td>
<td>
<p> number of runs in the latin hypercube sample; <br />
for type <code>fact</code> (a full factorial with equally-space levels), 
if <code>nlevels</code> is not separately specified, 
this number is taken to be the common number of levels of all factors, 
i.e. the resulting design will have <code>nruns^nfactors</code> runs;<br />
alternatively, if <code>nlevels</code> is separately specified as a vector of different numbers of levels, 
<code>nruns</code> can be missing or can be the correctly-specified number of runs.
</p>
</td></tr>
<tr><td><code id="lhs.design_+3A_nfactors">nfactors</code></td>
<td>
<p> number of factors in the latin hypercube sample </p>
</td></tr>
<tr><td><code id="lhs.design_+3A_type">type</code></td>
<td>
<p> character string indicating the type of design or augmentation method;
defaults are &ldquo;optimum&rdquo; for <code>lhs.design</code> and &ldquo;optAugment&rdquo; 
for <code>lhs.augment</code>.<br /><br />
Function <code>lhs.design</code> calls <br />
a function named typeLHS from package 
<span class="pkg">lhs</span> (types <code>genetic</code>, <code>improved</code>, <code>maximin</code>, <code>optimum</code>, <code>random</code>), <br />
a function named typeDesign from package <span class="pkg">DiceDesign</span> (types <code>dmax</code>, <code>strauss</code>, <code>fact</code>)<br />
or function <code>runif.faure</code> from package <span class="pkg">DiceDesign</span> (type <code>faure</code>).<br /> <br />
Function <code>lhs.augment</code> calls function typeLHS from package <span class="pkg">lhs</span>, <br />
where possible choices for <code>type</code> are <code>augment</code>, <code>optSeeded</code>, or <code>optAugment</code>.<br /> 
see the respective functions from packages <span class="pkg"><a href="lhs.html#topic+lhs-package">lhs</a></span> and 
<span class="pkg"><a href="DiceDesign.html#topic+DiceDesign-package">DiceDesign</a></span>. </p>
</td></tr>
<tr><td><code id="lhs.design_+3A_seed">seed</code></td>
<td>
<p> seed for random number generation; latin hypercube samples from package 
<span class="pkg">lhs</span> are random samples. Specifying a seed used to make the result reproducible for 
early versions of package <span class="pkg"><a href="lhs.html#topic+lhs-package">lhs</a></span> - lately, 
results are reproducible within a package version, but reproducibility between 
package versions cannot be guaranteed.</p>
</td></tr>
<tr><td><code id="lhs.design_+3A_factor.names">factor.names</code></td>
<td>
<p> list of scale end values for each factor; 
names are used as variable names;<br />
the names should not be x1, x2, ..., as this would interfere with usability 
of standard second order analysis methods on the resulting data (<code>link{rsmformula}</code>);<br />
if the list is not named, the variable names are X1, X2 and so forth;
the original unit cube calculated by package <span class="pkg">lhs</span> (scale ends 0 and 1 for each variable) 
is rescaled to the values given in factor.names. </p>
</td></tr>
<tr><td><code id="lhs.design_+3A_digits">digits</code></td>
<td>
<p> digits to which the design columns are rounded; one single value 
(the same for all factors) or a vector of length <code>nfactors</code>;<br />
note that the rounding is applied after generation of the design on the actual 
data scale, i.e. the unit cube generated by the functions from packages <span class="pkg">lhs</span> 
or <span class="pkg">DiceDesign</span> is NOT rounded</p>
</td></tr>
<tr><td><code id="lhs.design_+3A_nlevels">nlevels</code></td>
<td>
<p>used for type <code>fact</code> only; integer number or numeric vector of <code>nfactor</code> 
integers; specifies the number of levels for each factor. If all factors have the same number 
of levels, the number of levels can also be specified through <code>nruns</code>, which is 
interpreted as the number of levels for type <code>fact</code>, if <code>nlevels</code> is 
not separately specified</p>
</td></tr>
<tr><td><code id="lhs.design_+3A_default.levels">default.levels</code></td>
<td>
<p>scale ends for all factors; convenient, 
if all factors have the same scaling that deviates from the default 0/1 scale ends. </p>
</td></tr>
<tr><td><code id="lhs.design_+3A_randomize">randomize</code></td>
<td>
<p>logical that prevents randomization per default. The option has an effect 
for types <code>fact</code> and <code>faure</code> only. All other types are based on random 
design generation anyway. 
Note that preventing randomization is the default here, because these designs 
are assumed to be used mostly for computer experimentation, where the systematics 
of the non-randomized design may be beneficial. For hardware experimentation, 
randomization should be set to <code>TRUE</code>!<br /><br />
If randomization is requested, the following information is relevant:<br />
In R version 3.6.0 and later, the default behavior of function <code><a href="base.html#topic+sample">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.0) R version want to 
run code interchangeably on R 3.6.0 and an earlier R version,
you have to change the RNGkind setting in the later R version by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>lhs.design</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="DoE.base.html#topic+VSGFS">VSGFS</a></code>.</p>
</td></tr>
<tr><td><code id="lhs.design_+3A_lhs">lhs</code></td>
<td>
<p>design generated by function <code>lhs.design</code> (class <code>design</code>, 
of type <code>lhs</code></p>
</td></tr>
<tr><td><code id="lhs.design_+3A_m">m</code></td>
<td>
<p>integer number of additional points to add to design <code>lhs</code> (note, however, 
that <code>optSeeded</code> does not necessarily preserve all original runs!)</p>
</td></tr>
<tr><td><code id="lhs.design_+3A_...">...</code></td>
<td>
<p> additional arguments to the functions from packages <span class="pkg">lhs</span> 
or <span class="pkg">DiceDesign</span>. 
Refer to their documentation. <br />
Functions for generating lhs designs: 
<code><a href="lhs.html#topic+randomLHS">randomLHS</a></code>, <code><a href="lhs.html#topic+geneticLHS">geneticLHS</a></code>, 
<code><a href="lhs.html#topic+improvedLHS">improvedLHS</a></code>, <code><a href="lhs.html#topic+maximinLHS">maximinLHS</a></code>, 
<code><a href="lhs.html#topic+optimumLHS">optimumLHS</a></code>, <code><a href="DiceDesign.html#topic+dmaxDesign">dmaxDesign</a></code>, 
<code><a href="DiceDesign.html#topic+straussDesign">straussDesign</a></code>, <code><a href="DiceDesign.html#topic+runif.faure">runif.faure</a></code>, 
<code><a href="DiceDesign.html#topic+factDesign">factDesign</a></code>; <br />
functions for augmenting lhs designs: 
<code><a href="lhs.html#topic+augmentLHS">augmentLHS</a></code>, 
<code><a href="lhs.html#topic+optSeededLHS">optSeededLHS</a></code>, 
<code><a href="lhs.html#topic+optAugmentLHS">optAugmentLHS</a></code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>lhs.design</code> creates a latin hypercube sample, 
function <code>lhs.augment</code> augments an existing latin hypercube sample (or in case of 
type <code>optSeeded</code> takes the existing sample as the starting point but potentially modifies it). 
In comparison to direct usage of package <span class="pkg">lhs</span>, the functions add the possibility 
of recoding lhs samples to a desired range, and they embed the lhs designs into 
class <code><a href="DoE.base.html#topic+class-design">design</a></code>.<br />
Range coding is based on the recoding facility from package <span class="pkg">rsm</span> and the 
<code>factor.names</code> parameter used analogously to packages <span class="pkg">DoE.base</span> and <span class="pkg">FrF2</span>.
</p>
<p>The lhs designs are useful for quantitative factors, if it is considered desirable to uniformly 
distribute design points over a hyperrectangular space. This is e.g. considered interesting 
for computer experiments, where replications of the same settings are often useless.
</p>
<p>Supported design types are described in the documentation for 
packages <code><a href="lhs.html#topic+lhs-package">lhs</a></code> 
and <code><a href="DiceDesign.html#topic+DiceDesign-package">DiceDesign</a></code>.
</p>


<h3>Value</h3>

<p>Both functions return a data frame of S3 class <code><a href="DoE.base.html#topic+class-design">design</a></code> 
with attributes attached. 
The data frame contains the experimental settings as recoded to the scale ends defined in factor.names (if given), 
rounded to the number of digits given in <code>digits</code> (if given).
The experimental factors in the matrix <code>desnum</code> attached as attribute <code>desnum</code> contain the 
design in the unit cube (all experimental factors ranging from 0 to 1) as 
returned by packages <span class="pkg">lhs</span> or <span class="pkg">DiceDesign</span>. <br />
Function <code>lhs.augment</code> preserves additional variables (e.g. responses) that 
have been added to the design <code>lhs</code> before augmenting. Note, however, that 
the response data are NOT used in deciding about which points to augment the design with. 
</p>
<p>The attribute <code>run.order</code> is not very useful for most of these designs, as there is no standard order. 
It therefore is present for formal reasons only and contains three identical columns of 1,2,...,nruns. 
For designs created with <code>type=fact</code> or <code>type=faure</code>, the standard order is the order 
in which package <span class="pkg">DiceDesign</span> creates the design, and the actual run order may be different in case of 
randomization.<br />
In case of <code>lhs.augment</code>, if the design to be augmented had been reordered before, 
the augmented design preserves this reorder and also the respective numbering of the design.
</p>
<p>The attribute <code>design.info</code> is a list of various design properties, with type resolving to &ldquo;lhs&rdquo;. 
In addition to the standard list elements (cf. <code><a href="DoE.base.html#topic+class-design">design</a></code>), the <code>subtype</code> 
element indicates the type of latin hypercube designs and possibly additional augmentations, the element 
<code>quantitative</code> is a vector of <code>nfactor</code> logical TRUEs, 
and the <code>digits</code> elements indicates the digits to which the data were rounded. <br />
For designs created with package <span class="pkg">DiceDesign</span>, special list elements from this package 
are also added to <code>design.info</code>.<br />
<code>randomize</code> is always TRUE for designs generated by random sampling, but may be FALSE for 
designs created with <code>type=fact</code> or <code>type=faure</code>. <br />
<code>coding</code> provides formulae for making the designs comfortably usable with 
standard second order methodology implemented in package <span class="pkg">rsm</span>. 
<code>replications</code> is always 1 and <code>repeat.only</code> is always FALSE; 
these elements are only present to fulfill the formal requirements for class <code>design</code>.
</p>


<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="base.html#topic+sample">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For using code that randomizes a design interchangeably between a new R version (3.6.0 or later) 
and an older one, please follow the steps described with the argument <code>randomize</code>.
</p>
<p>Note also: Package <span class="pkg">lhs</span> does not promise to keep designs reproducible between package versions. Thus, 
please make sure to store important designs for the future, if needed (of course, this is always wise anyway!).
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome.  </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Beachkofski, B., Grandhi, R. (2002) Improved Distributed Hypercube Sampling. American Institute of Aeronautics and Astronautics Paper 1274.
</p>
<p>Currin C., Mitchell T., Morris M. and Ylvisaker D. (1991) 
Bayesian Prediction of Deterministic Functions With Applications to the Design and Analysis of Computer Experiments, 
<em>Journal of the American Statistical Association</em> <b>86</b>, 953&ndash;963.
</p>
<p>Santner T.J., Williams B.J. and Notz W.I. (2003) The Design and Analysis of Computer Experiments, Springer, 121&ndash;161.
</p>
<p>Shewry, M. C. and Wynn and H. P. (1987) Maximum entropy sampling. <em>Journal of Applied Statistics</em> <b>14</b>, 165&ndash;170.
</p>
<p>Fang K.-T., Li R. and Sudjianto A. (2006) <em>Design and Modeling for Computer Experiments</em>, Chapman &amp; Hall.
</p>
<p>Stein, M. (1987) Large Sample Properties of Simulations Using Latin Hypercube Sampling. <em>Technometrics</em> <b>29</b>, 143&ndash;151. 
</p>
<p>Stocki, R. (2005) A method to improve design reliability using optimal Latin hypercube sampling. 
<em>Computer Assisted Mechanics and Engineering Sciences</em> <b>12</b>, 87&ndash;105.
</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+compare">compare</a></code> for comparing optimality criteria for various 
designs, <br />
<code><a href="lhs.html#topic+lhs-package">lhs-package</a></code> and 
<code><a href="DiceDesign.html#topic+DiceDesign-package">DiceDesign-package</a></code> for the packages that do the calculations,<br /> 
<code><a href="FrF2.html#topic+FrF2">FrF2</a></code>, <code><a href="DoE.base.html#topic+oa.design">oa.design</a></code>, 
<code><a href="DoE.base.html#topic+fac.design">fac.design</a></code>, <code><a href="FrF2.html#topic+pb">pb</a></code> for other possibilites of generating designs</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## maximin design from package lhs
   plan &lt;- lhs.design(20,7,"maximin",digits=2) 
   plan
   plot(plan)
   cor(plan)
   y &lt;- rnorm(20)
   r.plan &lt;- add.response(plan, y)
   
   ## augmenting the design with 10 additional points, default method
   plan2 &lt;- lhs.augment(plan, m=10)
   plot(plan2)
   cor(plan2)
   
   ## purely random design (usually not ideal)
   plan3 &lt;- lhs.design(20,4,"random",
          factor.names=list(c(15,25), c(10,90), c(0,120), c(12,24)), digits=2)
   plot(plan3)
   cor(plan3)
   
   ## optimum design from package lhs (default)
   plan4 &lt;- lhs.design(20,4,"optimum",
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2)
   plot(plan4)
   cor(plan4)
   
   ## dmax design from package DiceDesign
   ## arguments range and niter_max are required
   ## ?dmaxDesign for more info
   plan5 &lt;- lhs.design(20,4,"dmax",
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2,
              range=0.2, niter_max=500)
   plot(plan5)
   cor(plan5)
   
   ## Strauss design from package DiceDesign
   ## argument RND is required
   ## ?straussDesign for more info
   plan6 &lt;- lhs.design(20,4,"strauss",
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2,
              RND = 0.2)
   plot(plan6)
   cor(plan6)
   
   ## full factorial design from package DiceDesign
   ## mini try-out version
   plan7 &lt;- lhs.design(3,4,"fact",
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2)
   plot(plan7)
   cor(plan7)
   
   ## Not run: 
   
   ## full factorial design from package DiceDesign
   ## not as many different levels as runs, but only a fixed set of levels
   ##    caution: too many levels can easily bring down the computer
   ##    above design with 7 distinct levels for each factor, 
   ##    implying 2401 runs 
   plan7 &lt;- lhs.design(7,4,"fact",
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2)
   plot(plan7)
   cor(plan7)
   
   ## equivalent call
   plan7 &lt;- lhs.design(,4,"fact",nlevels=7,
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2)
   
   ## different number of levels for each factor
   plan8 &lt;- lhs.design(,4,"fact",nlevels=c(5,6,5,7),
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2)
   plot(plan8)
   cor(plan8)

   ## equivalent call (specifying nruns, not necessary but a good check)
   plan8 &lt;- lhs.design(1050,4,"fact",nlevels=c(5,6,5,7),
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2)
   
## End(Not run)
   </code></pre>

<hr>
<h2 id='optimality.criteria'> Overview of optimality criteria in experimental design packages</h2><span id='topic+optimality.criteria'></span><span id='topic+Scalc'></span><span id='topic+compare'></span>

<h3>Description</h3>

<p>One function for calculating the S-optimality criterion is provided here. 
This help file documents this function and also describes optimality criteria from 
other related packages, referring to space filling optimality like the S criterion 
or to model-based optimality like the well-known D-criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Scalc(design)
compare(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimality.criteria_+3A_design">design</code></td>
<td>
<p> matrix, often normalized to unit cube, <br />
OR<br />
design (class <code>design</code>) of type <code>lhs</code> or <code>Dopt</code>.<br />
For <code>design</code> objects, calculations are applied to the 
<code>desnum</code> attribute.</p>
</td></tr>
<tr><td><code id="optimality.criteria_+3A_...">...</code></td>
<td>
<p>two or more designs, either all of type <code>lhs</code> or all of type <code>Dopt</code>, 
can be compared w.r.t. some optimality criteria that are stored 
in their <code>design.info</code> attribute (only works with designs created 
by <span class="pkg">DoE.wrapper</span> version 0.7 or higher)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>Scalc</code> calculates the S criterion for optimality, which is 
employed in package <span class="pkg">lhs</span> for most optimization purposes (exception: 
maximin designs). The criterion is the harmonic mean of all pairwise 
interpoint distances, and space-filling optimization tries to maximize it. 
</p>
<p>Function <code><a href="AlgDesign.html#topic+eval.design">eval.design</a></code> from package <span class="pkg">AlgDesign</span> 
calculates various model-based optimality criteria: 
</p>

<dl>
<dt>confounding</dt><dd><p>a confounding matrix of effects, if requested</p>
</dd>
<dt>determinant</dt><dd><p>the k-th root of the determinant of Z'Z/N, where Z is the 
model matrix of the model under investigation, k is the number of columns 
of Z and N the number of rows; this is the quantity optimized for D-optimal 
designs</p>
</dd>
<dt>A</dt><dd><p>the arithmetic mean of coeffient variance multipliers, 
i.e. the average diagonal element of the inverse of Z'Z/N, intercept included</p>
</dd>
<dt>I</dt><dd><p>the average prediction variance over a space X; calculated only, if X is specified</p>
</dd>
<dt>Ge</dt><dd><p>the minimax normalized variance over X; calculated only, if X is specified</p>
</dd>
<dt>Dea</dt><dd><p>A lower bound on D efficiency for approximate theory designs. 
It is equal to exp(1-1/Ge), i.e. is also calculated only, if X is specified.</p>
</dd>
<dt>diagonality</dt><dd><p>the k-th root of the ratio of the determinant of M1 
divided by the product of diagonal elements of M1, 
where M1 is Z'Z with the column and row referring to the intercept removed, 
and k the number of columns of M1; if this is 1, the coefficient estimates 
are uncorrelated.</p>
</dd>
<dt>gmean.variances</dt><dd><p>the geometric mean of normalized coeffient variance multipliers
(intercept excluded), i.e. the geometric mean of the diagonal elements of the inverse of Z'Z/N, 
without the first element, if an intercept is in the model.</p>
</dd>
</dl>

<p>Several functions from package <span class="pkg">DiceDesign</span> calculate optimality criteria 
regarding the space filling qualities of a design. These functions 
normalize the design to lie in the unit cube, 
if it does not yet do so. Application of these functions 
to designs with qualitative factors does not make sense and 
yields errors. The following functions are available:<br />
</p>
<p><code><a href="DiceDesign.html#topic+mindist">mindist</a></code> calculates the minimum distance between 
any pair of design points. This is the criterion which is maximized by 
maximin designs, i.e. should be large for a space-filling design. 
</p>
<p>For the next two distance metrics, it is helpful to define <code>g_i</code> as the minimal 
distance of design point <code>i</code> to any other design point.
</p>
<p><code><a href="DiceDesign.html#topic+meshRatio">meshRatio</a></code> calculates the ratio of the 
maximum <code>g_i</code> to the minimum <code>g_i</code> 
(a small mesh ratio indicates a similar minimal 
distance for all design points).  
</p>
<p><code><a href="DiceDesign.html#topic+coverage">coverage</a></code> calculates the coefficient of variation 
of the <code>g_i</code>, however using the denominator <code>n</code> instead of <code>n-1</code> 
for the standard deviation (a large coverage indicates that the average minimal 
distance for of design points is large relative to their standard deviation; 
large values are desirable).
</p>
<p>Function <code><a href="DiceDesign.html#topic+discrepancyCriteria">discrepancyCriteria</a></code> calculates 
several versions of L2 discrepancy. 
</p>
<p>Function <code>link[skpr]{eval_design}</code> calculates effect and parameter powers 
for a design for a specified model and a specified significance level <code>alpha</code>. 
</p>


<h3>Value</h3>

<p>Function <code>Scalc</code> returns a single number: the harmonic mean of all pairwise interpoint distances 
is calculated, based on the matrix <code>design</code> or the desnum attribute of the design <code>design</code>. 
(This value should be as large as possible for a space-filling design.) 
</p>
<p>Note that the resulting S value differs from the printed optimum value by function <code>lhs.design</code> for 
type <code>optimum</code> in two respects: the printed optimum value is the sum of inverse distances, 
i.e. the denominator of the harmonic mean. choose(nruns, 2) divided by the printed final optimal value 
is approximately equal to the calculated S; perfect equality cannot be achieved 
because the underlying the printed final optimum refers to an interim latin hypercube of integers 
that is subsequently rescaled to the unit cube and scrambled by random numbers.
</p>
<p>Function <code>compare</code> returns a matrix, with rows representing the criteria 
and columns the different designs. Apart from many of the criteria mentioned above, the 
determinant of the correlation matrix is shown, which should ideally be close to one for 
a near-orthogonal design (at least in terms of linear effects).
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome.  </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Beachkofski, B., Grandhi, R. (2002) Improved Distributed Hypercube Sampling. American Institute of Aeronautics and Astronautics Paper 1274.
</p>
<p>Currin C., Mitchell T., Morris M. and Ylvisaker D. (1991) 
Bayesian Prediction of Deterministic Functions With Applications to the Design and Analysis of Computer Experiments, 
<em>Journal of the American Statistical Association</em> <b>86</b>, 953&ndash;963.
</p>
<p>Santner T.J., Williams B.J. and Notz W.I. (2003) The Design and Analysis of Computer Experiments, Springer, 121&ndash;161.
</p>
<p>Shewry, M. C. and Wynn and H. P. (1987) Maximum entropy sampling. <em>Journal of Applied Statistics</em> <b>14</b>, 165&ndash;170.
</p>
<p>Fang K.-T., Li R. and Sudjianto A. (2006) <em>Design and Modeling for Computer Experiments</em>, Chapman &amp; Hall.
</p>
<p>Stein, M. (1987) Large Sample Properties of Simulations Using Latin Hypercube Sampling. <em>Technometrics</em> <b>29</b>, 143&ndash;151. 
</p>
<p>Stocki, R. (2005) A method to improve design reliability using optimal Latin hypercube sampling. 
<em>Computer Assisted Mechanics and Engineering Sciences</em> <b>12</b>, 87&ndash;105.
</p>


<h3>See Also</h3>

<p> See Also <code><a href="lhs.html#topic+lhs-package">lhs-package</a></code>, 
<code><a href="DiceDesign.html#topic+DiceDesign-package">DiceDesign-package</a></code>, 
<code><a href="AlgDesign.html#topic+eval.design">eval.design</a></code>, 
<code><a href="skpr.html#topic+eval_design">eval_design</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## optimum design from package lhs (default)
   plan &lt;- lhs.design(20,4,"optimum",
          factor.names=list(c(15,25), c(10,90), c(0,120), c(12,24)), digits=2)
   ## maximin design 
   plan2 &lt;- lhs.design(20,4,"maximin",
          factor.names=list(c(15,25), c(10,90), c(0,120), c(12,24)), digits=2)
   ## purely random design (usually not ideal)
   plan3 &lt;- lhs.design(20,4,"random",
          factor.names=list(c(15,25), c(10,90), c(0,120), c(12,24)), digits=2)
   ## genetic design 
   plan4 &lt;- lhs.design(20,4,"genetic",
          factor.names=list(c(15,25), c(10,90), c(0,120), c(12,24)), digits=2)
   ## dmax design from package DiceDesign
   ## arguments range and niter_max are required
   ## ?dmaxDesign for more info
   plan5 &lt;- lhs.design(20,4,"dmax",
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2,
              range=0.2, niter_max=500)
   ## Strauss design from package DiceDesign
   ## argument RND is required
   ## ?straussDesign for more info
   plan6 &lt;- lhs.design(20,4,"strauss",
        factor.names=list(torque=c(10,14),friction=c(25,35),
              temperature=c(-5,35),pressure=c(20,50)),digits=2,
              RND = 0.2)
   ## compare all these designs
   compare(plan, plan2, plan3, plan4, plan5, plan6)
   </code></pre>

<hr>
<h2 id='rsmformula'> Functions for supporting response surface analysis with package rsm </h2><span id='topic+rsmformula'></span><span id='topic+code.design'></span><span id='topic+decode.design'></span>

<h3>Description</h3>

<p>These functions support response surface analysis with package rsm. 
Function rsmformula creates a model formula for use with function rsm, 
using the FO, TWI and PQ notation. Function code.design prepares a fractional 
factorial 2-level design with center points from package FrF2 or a ccd, bbd 
or lhs design from this package for convenient use with package rsm functionality, 
function decode.design reverses the coding action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code.design(design)
decode.design(design)
rsmformula(design, response=NULL, factor.names=NULL, 
    use.blockvar = TRUE, degree=2, coded=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsmformula_+3A_design">design</code></td>
<td>
<p> a response surface design of class <code>design</code> 
with at least one response variable and 
of a type derived from <code>ccd</code>, <code>bbd</code>, or <code>lhs</code></p>
</td></tr>
<tr><td><code id="rsmformula_+3A_response">response</code></td>
<td>
<p> character string specifying the response variable to be analysed 
(default: the first response of the design) </p>
</td></tr>
<tr><td><code id="rsmformula_+3A_factor.names">factor.names</code></td>
<td>
<p> character vector specifying the factors to be included 
(default: all experimental factors) </p>
</td></tr>
<tr><td><code id="rsmformula_+3A_use.blockvar">use.blockvar</code></td>
<td>
<p> logical indicating whether or not the block effect (if available) 
is to be included into the model </p>
</td></tr>
<tr><td><code id="rsmformula_+3A_degree">degree</code></td>
<td>
<p> default is 2 for a full second order model. 
For a first order only model, specify 1; 
for a model with main effects and 2-factor interactions, specify 1.5. 
<code>degree</code> corresponds to the <code>order</code> element of the object created by 
function <code><a href="rsm.html#topic+rsm">rsm</a></code>. </p>
</td></tr>
<tr><td><code id="rsmformula_+3A_coded">coded</code></td>
<td>
<p> logical indicating whether the formula is to be provided in 
coded names (x1, x2 etc., <code>coded=TRUE</code>) or original variable names (<code>coded=FALSE</code>)</p>
</td></tr>
<tr><td><code id="rsmformula_+3A_...">...</code></td>
<td>
<p> reserved for future usage</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>code.design</code> rescales the variables of a design with quantitative 
variables according to the information stored in the <code>coding</code> element of 
the <code>design.info</code> attribute of <code>design</code>, 
function <code>decode.design</code> rescales a coded design to original units. 
</p>
<p>Function <code>rsmformula</code> creates a formula for use with function <code><a href="rsm.html#topic+rsm">rsm</a></code>. 
If this function is created in coded variable names (which is the default), 
it can be used in function <code><a href="rsm.html#topic+rsm">rsm</a></code> 
together with the coded data object created by function <code>code.design</code> 
for creating a response surface model, which can be post-processed by the utilities provided 
in package <span class="pkg">rsm</span>, especially the <code>[rsm:rsm]{methods}</code> for class <code>rsm</code> objects 
and functions <code><a href="rsm.html#topic+steepest">steepest</a></code> or <code><a href="rsm.html#topic+steepest">canonical.path</a></code>. 
</p>
<p>IMPORTANT: coded vs. original units<br />
The text below assumes that the design has been entered using the <code>default.levels</code> or the 
<code>factor.names</code> option to specify the factor levels in original units.<br />
The usual steepest ascent analysis is done
in coded units, i.e. if e.g. factor X1 has original units 10 (code -1 = (10-20)/10) 
and 30 (code +1 = (30-20)/10) 
and factor X2 has original units 0.1 (code -1 = (0.1 - 0.2)/0.1) 
and 0.3 (code +1 = (0.3 - 0.2)/0.1), 
an increase of 10 for a change in factor X1 from 10 to 30 is considered 
steeper (slope 10/2) than an increase of 9 for a change in factor X2 
from 0.1 to 0.3 (slope 9/2). If this behavior is 
desired, usage of <code>rsmformula</code> with option coded=TRUE and a design generated 
by <code>code.design</code> is needed. <br />
Otherwise, i.e. when assessment is desired 
in original units, the ascent for factor X2 (9/0.2) would of course be much steeper  
than for factor X1 (10/20) in the above example. For obtaining an assessment based 
on the original units, one can simply use <code>rsmformula</code> with option coded=FALSE 
and the design itself in original units in the 
<code><a href="rsm.html#topic+rsm">rsm</a></code> model. This only makes sense for first order models: 
function <code><a href="rsm.html#topic+steepest">steepest</a></code> always assesses the slope at the origin; 
for first order models, it does not matter where the slope is assessed. For models 
with order (=<code>degree</code>) 1.5 or 2, the <code>steepest</code> analysis in original units 
is adequate only for the exceptional case that 0 is the point of interest.
</p>


<h3>Value</h3>

<p>Function <code>code.design</code> returns a <code><a href="rsm.html#topic+coded.data">coded.data</a></code> object 
for usage with function <code><a href="rsm.html#topic+rsm">rsm</a></code>; this object can be returned to its 
original state by applying function <code>decode.design</code>. 
</p>
<p>Function <code>rsmformula</code> returns a formula with an <code>FO</code> (=first order) portion, 
for <code>degree=1.5</code> additionally a <code>TWI</code> (=two factor interactions, 2fis) portion,
and for <code>degree=2</code> also a <code>PQ</code> (=pure quadratic) portion. 
</p>
<p>This representation of the model formula is needed for response surface analyses 
with package <span class="pkg">rsm</span>. Per default, the formula comes 
in coded variable names (<code>x1</code>, <code>x2</code> etc.).
</p>


<h3>Note</h3>

<p> This package is still under (slow) development. Reports about bugs and inconveniences are welcome.  </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Lenth, R.V. (2009). Response-Surface Methods in R, using <span class="pkg">rsm</span>.
<em>Journal of Statistical Software</em> <b>32</b>(7), 1-17. 
URLhttp://www.jstatsoft.org/v32/i07/.
</p>
<p>Myers, R.H., Montgomery, D.C. and Anderson-Cook, C.M. (2009). <em>Response Surface Methodology. 
Process and Product Optimization Using Designed Experiments</em>. Wiley, New York.
</p>


<h3>See Also</h3>

<p> See also <code><a href="rsm.html#topic+rsm">rsm</a></code>, 
<code><a href="rsm.html#topic+steepest">steepest</a></code>, <code><a href="rsm.html#topic+steepest">canonical.path</a></code>, 
<code><a href="rsm.html#topic+contour.lm">contour.lm</a></code>,
. 
The <code><a href="DoE.base.html#topic+formula.design">formula</a></code> method for class <code>design</code> objects 
creates equivalent model formulae in standard model notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## an artificial example with random response
  ## purely for demonstrating how the functions work together with rsm
  plan &lt;- ccd.design(5, ncenter=6, 
         factor.names = list(one=c(10,30),two=c(1,5),three=c(0.1,0.9),
                             four=c(2,4),five=c(-1,1)))
  set.seed(298)
  plan &lt;- add.response(plan, rnorm(38))
  
  ## coding
  plan.c &lt;- code.design(plan)
  plan.c
  decode.design(plan.c)
  
  ## first order analysis
     ## formulae needed for first order models:
    rsmformula(plan, degree=1)                ## coded
    rsmformula(plan, degree=1, coded=FALSE)   ## original units
    
    ## steepest ascent: steepness assessed in coded units, 
    ## results also presented in original units
    linmod1 &lt;- rsm(rsmformula(plan, degree=1), data=plan.c)
    summary(linmod1)
    steepest(linmod1)
    
    ## steepest ascent: steepness assessed in original units!!! 
    ## this is different from the usual approach!!! 
    ## cf. explanation in Details section
    linmod1.original &lt;- rsm(rsmformula(plan, degree=1, coded=FALSE), data=plan)
    summary(linmod1.original)
    steepest(linmod1.original)

  ## second order analysis (including quadratic, degree=1.5 would omit quadratic
    ## formulae needed for second order models:
    rsmformula(plan, degree=2)               ## coded
    rsmformula(plan, degree=2, coded=FALSE)  ## original units
       ## the formulae can also be constructed analogously to the FO formulae 
       ## by using SO instead of FO
       ## rsmformula returns the more detailed function because 
       ##     it can be more easily modified to omit one of the effects
    
    ## the stationary point is not affected by using coded or original units
    ##     neither is the decision about the nature of the stationary point
    ## a subsequent canonical path analysis will however be affected,
    ##     analogously to the steepest ascent (cf. Details section)
    
    ## analysis in coded units
    linmod2 &lt;- rsm(rsmformula(plan, degree=2), data=plan.c)
    summary(linmod2)
    ## analysis in original units
    linmod2.original &lt;- rsm(rsmformula(plan, degree=2, coded=FALSE), data=plan)
    summary(linmod2.original)
    ## the contour plot may be nicer when using original units
    contour(linmod2, form=~x1*x2)
    contour(linmod2.original, form=~one*two)
    ## the canonical path is usually more reasonable in coded units
    canonical.path(linmod2)            ## coded units
    canonical.path(linmod2.original)   ## original units
    
    ## analogous analysis without the special formula notation of function rsm
    linmod &lt;- rsm(rnorm.38. ~ Block.ccd + (one + two + three + four + five)^2 + 
          I(one^2) + I(two^2) + I(three^2) + I(four^2) + I(five^2), data=plan)
    summary(linmod)
    contour(linmod, form=~one*two)  ## contour plot is possible
    ## steepest or canonical.path cannot be used, 
    ## because the model is a conventional lm
 
    ## contour will not work on the convenience model
    ## lm(plan), which is otherwise identical to linmod
    ## (it will neither work on lm(formula(plan), plan))
    ## or lm(rsmformula(plan), plan)
   </code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
