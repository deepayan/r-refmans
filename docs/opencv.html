<!DOCTYPE html><html><head><title>Help for package opencv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {opencv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ocv_face'><p>OpenCV Computer Vision</p></a></li>
<li><a href='#ocv_keypoints'><p>OpenCV keypoints</p></a></li>
<li><a href='#ocv_qr_detect'><p>Detect and Decode a QR code</p></a></li>
<li><a href='#opencv-area'><p>OpenCV area manipulation</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bindings to 'OpenCV' Computer Vision Library</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Exposes some of the available 'OpenCV' <a href="https://opencv.org/">https://opencv.org/</a> algorithms,
    such as a QR code scanner, and edge, body or face detection. These can either be 
    applied to analyze static images, or to filter live video footage from a camera device.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>OpenCV 3 or newer: libopencv-dev (Debian, Ubuntu)
or opencv-devel (Fedora). The QR code detector requires at
least libopencv 4.5.2.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ropensci.r-universe.dev/opencv">https://ropensci.r-universe.dev/opencv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/opencv/issues">https://github.com/ropensci/opencv/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>grDevices, qrcode, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-29 13:42:29 UTC; jeroen</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Jan Wijffels [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeroen Ooms &lt;jeroen@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-29 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ocv_face'>OpenCV Computer Vision</h2><span id='topic+ocv_face'></span><span id='topic+ocv_facemask'></span><span id='topic+ocv_read'></span><span id='topic+ocv_write'></span><span id='topic+ocv_destroy'></span><span id='topic+ocv_bitmap'></span><span id='topic+ocv_edges'></span><span id='topic+ocv_picture'></span><span id='topic+ocv_resize'></span><span id='topic+ocv_mog2'></span><span id='topic+ocv_knn'></span><span id='topic+ocv_hog'></span><span id='topic+ocv_blur'></span><span id='topic+ocv_sketch'></span><span id='topic+ocv_stylize'></span><span id='topic+ocv_markers'></span><span id='topic+ocv_info'></span><span id='topic+ocv_copyto'></span><span id='topic+ocv_display'></span><span id='topic+ocv_video'></span><span id='topic+ocv_grayscale'></span><span id='topic+ocv_version'></span>

<h3>Description</h3>

<p>Tools to experiment with computer vision algorithms. Use <a href="#topic+ocv_read">ocv_read</a> and
<a href="#topic+ocv_write">ocv_write</a> to load/save images on disk, or use <a href="#topic+ocv_picture">ocv_picture</a> / <a href="#topic+ocv_video">ocv_video</a>
to use your webcam. In RSudio IDE the image objects will automatically be
displayed in the viewer pane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocv_face(image)

ocv_facemask(image)

ocv_read(path)

ocv_write(image, path)

ocv_destroy(image)

ocv_bitmap(image)

ocv_edges(image)

ocv_picture()

ocv_resize(image, width = 0, height = 0)

ocv_mog2(image)

ocv_knn(image)

ocv_hog(image)

ocv_blur(image, ksize = 5)

ocv_sketch(image, color = TRUE)

ocv_stylize(image)

ocv_markers(image)

ocv_info(image)

ocv_copyto(image, target, mask)

ocv_display(image)

ocv_video(filter, stop_on_result = FALSE)

ocv_grayscale(image)

ocv_version()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ocv_face_+3A_image">image</code></td>
<td>
<p>an ocv image object created from e.g. <code><a href="#topic+ocv_read">ocv_read()</a></code></p>
</td></tr>
<tr><td><code id="ocv_face_+3A_path">path</code></td>
<td>
<p>image file such as png or jpeg</p>
</td></tr>
<tr><td><code id="ocv_face_+3A_width">width</code></td>
<td>
<p>output width in pixels</p>
</td></tr>
<tr><td><code id="ocv_face_+3A_height">height</code></td>
<td>
<p>output height in pixels</p>
</td></tr>
<tr><td><code id="ocv_face_+3A_ksize">ksize</code></td>
<td>
<p>size of blurring matrix</p>
</td></tr>
<tr><td><code id="ocv_face_+3A_color">color</code></td>
<td>
<p>true or false</p>
</td></tr>
<tr><td><code id="ocv_face_+3A_target">target</code></td>
<td>
<p>the output image</p>
</td></tr>
<tr><td><code id="ocv_face_+3A_mask">mask</code></td>
<td>
<p>only copy pixels from the mask</p>
</td></tr>
<tr><td><code id="ocv_face_+3A_filter">filter</code></td>
<td>
<p>an R function that takes and returns an opecv image</p>
</td></tr>
<tr><td><code id="ocv_face_+3A_stop_on_result">stop_on_result</code></td>
<td>
<p>stop if an object is detected</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Silly example
mona &lt;- ocv_read('https://jeroen.github.io/images/monalisa.jpg')

# Edge detection
ocv_edges(mona)
ocv_markers(mona)

# Find face
faces &lt;- ocv_face(mona)

# To show locations of faces
facemask &lt;- ocv_facemask(mona)
attr(facemask, 'faces')

# This is not strictly needed
ocv_destroy(mona)
</code></pre>

<hr>
<h2 id='ocv_keypoints'>OpenCV keypoints</h2><span id='topic+ocv_keypoints'></span>

<h3>Description</h3>

<p>Find key points in images
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocv_keypoints(
  image,
  method = c("FAST", "Harris"),
  control = ocv_keypoints_options(method, ...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ocv_keypoints_+3A_image">image</code></td>
<td>
<p>an ocv grayscale image object</p>
</td></tr>
<tr><td><code id="ocv_keypoints_+3A_method">method</code></td>
<td>
<p>the type of keypoint detection algorithm</p>
</td></tr>
<tr><td><code id="ocv_keypoints_+3A_control">control</code></td>
<td>
<p>a list of arguments passed on to the algorithm</p>
</td></tr>
<tr><td><code id="ocv_keypoints_+3A_...">...</code></td>
<td>
<p>further arguments passed on to ocv_keypoints_options</p>
</td></tr>
</table>


<h3>FAST algorithm arguments</h3>


<ul>
<li><p> threshold threshold on difference between intensity of the central pixel and pixels of a circle around this pixel.
</p>
</li>
<li><p> nonmaxSuppression if true, non-maximum suppression is applied to detected corners (keypoints).
</p>
</li>
<li><p> type one of the three neighborhoods as defined in the paper: TYPE_9_16, TYPE_7_12, TYPE_5_8
</p>
</li></ul>



<h3>Harris algorithm arguments</h3>


<ul>
<li><p> numOctaves the number of octaves in the scale-space pyramid
</p>
</li>
<li><p> corn_thresh the threshold for the Harris cornerness measure
</p>
</li>
<li><p> DOG_thresh the threshold for the Difference-of-Gaussians scale selection
</p>
</li>
<li><p> maxCorners the maximum number of corners to consider
</p>
</li>
<li><p> num_layers the number of intermediate scales per octave
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mona &lt;- ocv_read('https://jeroen.github.io/images/monalisa.jpg')
mona &lt;- ocv_resize(mona, width = 320, height = 477)

# FAST-9
pts &lt;- ocv_keypoints(mona, method = "FAST", type = "TYPE_9_16", threshold = 40)
# Harris
pts &lt;- ocv_keypoints(mona, method = "Harris", maxCorners = 50)

# Convex Hull of points
pts &lt;- ocv_chull(pts)


</code></pre>

<hr>
<h2 id='ocv_qr_detect'>Detect and Decode a QR code</h2><span id='topic+ocv_qr_detect'></span><span id='topic+qr_scanner'></span>

<h3>Description</h3>

<p>Detect and decode a QR code from an image or camera. By default it returns
the text value from the QR code if detected, or NULL if no QR was found. If
<code>draw = TRUE</code> then it returns an annotated image with the position and
value of the QR drawn into the image, and qr text value as an attribute.
The <code>qr_scanner</code> function opens the camera device (if available on your
computer) and repeats <a href="#topic+ocv_qr_detect">ocv_qr_detect</a> until it a QR is detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocv_qr_detect(image, draw = FALSE, decoder = c("wechat", "quirc"))

qr_scanner(draw = FALSE, decoder = c("wechat", "quirc"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ocv_qr_detect_+3A_image">image</code></td>
<td>
<p>an ocv image object created from e.g. <code><a href="#topic+ocv_read">ocv_read()</a></code></p>
</td></tr>
<tr><td><code id="ocv_qr_detect_+3A_draw">draw</code></td>
<td>
<p>if TRUE, the function returns an annotated image showing
the position and value of the QR code.</p>
</td></tr>
<tr><td><code id="ocv_qr_detect_+3A_decoder">decoder</code></td>
<td>
<p>which decoder implementation to use, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>OpenCV has two separate QR decoders. The 'wechat' decoder was added in
libopencv 4.5.2 and generally has better performance and fault-tolerance.
The old 'quirc' decoder is available on some older versions of libopencv as
a plug-in, but many Linux distros did not include it. If you get an error
<em>Library QUIRC is not linked. No decoding is performed.</em> this sadly means
your Linux distribution is too old and does not support QR decoding.
</p>


<h3>Value</h3>

<p>if a QR code is detected, this returns either the text value of the QR,
or if <code>draw</code> it returns the annotated image, with the value as an attribute.
Returns NULL if no QR was found in the image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>png("test.png")
plot(qrcode::qr_code("This is a test"))
dev.off()
ocv_qr_detect(ocv_read('test.png'))
unlink("test.png")
</code></pre>

<hr>
<h2 id='opencv-area'>OpenCV area manipulation</h2><span id='topic+opencv-area'></span><span id='topic+ocv_rectangle'></span><span id='topic+ocv_polygon'></span><span id='topic+ocv_bbox'></span><span id='topic+ocv_chull'></span>

<h3>Description</h3>

<p>Manipulate image regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocv_rectangle(image, x = 0L, y = 0L, width, height)

ocv_polygon(image, pts, convex = FALSE, crop = FALSE, color = 255)

ocv_bbox(image, pts)

ocv_chull(pts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opencv-area_+3A_image">image</code></td>
<td>
<p>an ocv image object</p>
</td></tr>
<tr><td><code id="opencv-area_+3A_x">x</code></td>
<td>
<p>horizontal location</p>
</td></tr>
<tr><td><code id="opencv-area_+3A_y">y</code></td>
<td>
<p>vertical location</p>
</td></tr>
<tr><td><code id="opencv-area_+3A_width">width</code></td>
<td>
<p>width of the area</p>
</td></tr>
<tr><td><code id="opencv-area_+3A_height">height</code></td>
<td>
<p>height of the area</p>
</td></tr>
<tr><td><code id="opencv-area_+3A_pts">pts</code></td>
<td>
<p>a list of points with elements x and y</p>
</td></tr>
<tr><td><code id="opencv-area_+3A_convex">convex</code></td>
<td>
<p>are the points convex</p>
</td></tr>
<tr><td><code id="opencv-area_+3A_crop">crop</code></td>
<td>
<p>crop the resulting area to its bounding box</p>
</td></tr>
<tr><td><code id="opencv-area_+3A_color">color</code></td>
<td>
<p>color for the non-polygon area</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mona &lt;- ocv_read('https://jeroen.github.io/images/monalisa.jpg')

# Rectangular area
ocv_rectangle(mona, x = 400, y = 300, height = 300, width = 350)
ocv_rectangle(mona, x = 0, y = 100, height = 200)
ocv_rectangle(mona, x = 500, y = 0, width = 75)

# Polygon area
img &lt;- ocv_resize(mona, width = 320, height = 477)
pts &lt;- list(x = c(184, 172, 146, 114,  90,  76,  92, 163, 258),
            y = c(72,   68,  70,  90, 110, 398, 412, 385, 210))
ocv_polygon(img, pts)
ocv_polygon(img, pts, crop = TRUE)
ocv_polygon(img, pts, convex = TRUE, crop = TRUE)

# Bounding box based on points
ocv_bbox(img, pts)

# Bounding box of non-zero pixel area
area &lt;- ocv_polygon(img, pts, color = 0, crop = FALSE)
area
area &lt;- ocv_bbox(area)
area


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
