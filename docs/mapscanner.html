<!DOCTYPE html><html><head><title>Help for package mapscanner</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mapscanner}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mapscanner-package'><p>mapscanner: Print Maps, Draw on Them, Scan Them Back in</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#ms_aggregate_polys'><p>Aggregate disparate polygons</p></a></li>
<li><a href='#ms_generate_map'><p>Generate maps for 'mapscanner' use</p></a></li>
<li><a href='#ms_rectify_map'><p>Rectify one map to another</p></a></li>
<li><a href='#ms_rotate_map'><p>Rotate maps</p></a></li>
<li><a href='#set_mapbox_token'><p>Set 'mapbox' token</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Print Maps, Draw on Them, Scan Them Back in</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables preparation of maps to be printed and drawn on.
    Modified maps can then be scanned back in, and hand-drawn marks
    converted to spatial objects.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | <a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/mapscanner">https://github.com/ropensci/mapscanner</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/mapscanner/issues">https://github.com/ropensci/mapscanner/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, curl, fs, glue, magick, magrittr, memoise, pdftools, png,
purrr, raster, Rcpp, reproj, RNiftyReg, sf, slippymath, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, ggplot2, gibble, jpeg, knitr, lwgeom, mapview, mmand,
osmdata, polyclip, rmarkdown, spelling, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-25 11:04:23 UTC; smexus</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Padgham [aut, cre],
  Michael D. Sumner [aut],
  Kelly Hondula [rev] (Kelly reviewed the package for rOpenSci, see
    https://github.com/ropensci/software-review/issues/330),
  Nicholas Potter [rev] (Nichola reviewed the package for rOpenSci, see
    https://github.com/ropensci/software-review/issues/330),
  Stanislaw Adaszewski [cph] (author of include concaveman-cpp code)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark Padgham &lt;mark.padgham@email.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-25 23:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='mapscanner-package'>mapscanner: Print Maps, Draw on Them, Scan Them Back in</h2><span id='topic+mapscanner'></span><span id='topic+mapscanner-package'></span>

<h3>Description</h3>

<p>Enables preparation of maps to be printed and drawn on. Modified maps can then be scanned back in, and hand-drawn marks converted to spatial objects.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mark Padgham <a href="mailto:mark.padgham@email.com">mark.padgham@email.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Michael D. Sumner <a href="mailto:mdsumner@gmail.com">mdsumner@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Kelly Hondula (Kelly reviewed the package for rOpenSci, see https://github.com/ropensci/software-review/issues/330) [reviewer]
</p>
</li>
<li><p> Nicholas Potter (Nichola reviewed the package for rOpenSci, see https://github.com/ropensci/software-review/issues/330) [reviewer]
</p>
</li>
<li><p> Stanislaw Adaszewski (author of include concaveman-cpp code) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ropensci/mapscanner">https://github.com/ropensci/mapscanner</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/mapscanner/issues">https://github.com/ropensci/mapscanner/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='ms_aggregate_polys'>Aggregate disparate polygons</h2><span id='topic+ms_aggregate_polys'></span>

<h3>Description</h3>

<p>Planar partition from disparate polygon inputs. Overlaps aggregate to <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms_aggregate_polys(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ms_aggregate_polys_+3A_p">p</code></td>
<td>
<p>input (multi-)polygons (assumed to be overlapping)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input is a single simple features polygon data frame. No attribute data is
considered.
</p>


<h3>Value</h3>

<p>Set of <span class="pkg">sf</span>-format polygons with additional column, <code>n</code>, denoting
number of overlaps contributing to each of the resultant polygons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sf::st_sfc(list(sf::st_point(cbind(0, 0)),
                     sf::st_point(cbind(0, 1)),
                     sf::st_point(cbind(1, 0))))
pts &lt;- sf::st_sf(a = 1:3,  geometry = g)
overlapping_polys &lt;- sf::st_buffer(pts, 0.75)

## decompose and count space-filling from overlapping polygons
x &lt;- ms_aggregate_polys(overlapping_polys)
plot(x)
## Not run: 
library(ggplot2)
ggplot(x) + geom_sf() + facet_wrap(~n)

## End(Not run)

library(sf)
set.seed(6)
pts &lt;- expand.grid (x = 1:8, y = 1:10) %&gt;% st_as_sf (coords = c("x", "y"))
xsf &lt;- sf::st_buffer (pts, runif (nrow (pts), 0.2, 1.5))
## Not run: 
out &lt;- ms_aggregate_polys (xsf)

## End(Not run)
</code></pre>

<hr>
<h2 id='ms_generate_map'>Generate maps for 'mapscanner' use</h2><span id='topic+ms_generate_map'></span>

<h3>Description</h3>

<p>Generate a map image for a specified area or bounding box, by downloading
tiles from <a href="https://www.mapbox.com/">https://www.mapbox.com/</a>. Map is automatically saved in both
<code>.pdf</code> and <code>.png</code> formats, by default in current working directory, or
alternative location when <code>mapname</code> includes the full path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms_generate_map(
  bbox,
  max_tiles = 16L,
  mapname = NULL,
  bw = TRUE,
  style = "light",
  raster_brick = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ms_generate_map_+3A_bbox">bbox</code></td>
<td>
<p>Either a string specifying the location, or a numeric bounding
box as a single vector of (xmin, ymin, xmax, ymax), or a 2-by-2 matrix with
columns of (min, max) and rows of (x, y), respectively.</p>
</td></tr>
<tr><td><code id="ms_generate_map_+3A_max_tiles">max_tiles</code></td>
<td>
<p>Maximum number of tiles to use to create map</p>
</td></tr>
<tr><td><code id="ms_generate_map_+3A_mapname">mapname</code></td>
<td>
<p>Name of map to be produced, optionally including full path.
Extension will be ignored.</p>
</td></tr>
<tr><td><code id="ms_generate_map_+3A_bw">bw</code></td>
<td>
<p>If <code>FALSE</code>, print maps in colour, otherwise black-and-white. Note
that the default <code>style = "light"</code> is monochrome, and that this parameter
only has effect for <code>style</code> values of <code>"streets"</code> or <code>"outdoors"</code>.</p>
</td></tr>
<tr><td><code id="ms_generate_map_+3A_style">style</code></td>
<td>
<p>The style of the map to be generated; one of 'light', 'streets',
or 'outdoors', rendered in black and white. See
<a href="https://docs.mapbox.com/api/maps/#styles/">https://docs.mapbox.com/api/maps/#styles/</a> for examples.</p>
</td></tr>
<tr><td><code id="ms_generate_map_+3A_raster_brick">raster_brick</code></td>
<td>
<p>Instead of automatically downloading tiles within a given
<code>bbox</code>, a pre-downloaded <code>raster::rasterBrick</code> object may be submitted and
used to generate the <code>.pdf</code> and <code>.png</code> equivalents.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a <code>rasterBrick</code> object from the <span class="pkg">raster</span>
package containing all data used to generate the map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# code used to generate internal files for a portion of Omaha:
bb &lt;- osmdata::getbb ("omaha nebraska")
shrink &lt;- 0.3 # shrink that bb to 30% size
bb &lt;- t (apply (bb, 1, function (i)
                mean (i) + c (-shrink, shrink) * diff (i) / 2))
ms_generate_map (bb, max_tiles = 16L, mapname = "omaha")

## End(Not run)

</code></pre>

<hr>
<h2 id='ms_rectify_map'>Rectify one map to another</h2><span id='topic+ms_rectify_map'></span>

<h3>Description</h3>

<p>Rectify two previously scanned-in pdf or png maps with <code>RNiftyReg</code>, and
return the modifications in <code>map_modified</code> as spatial objects in <span class="pkg">sf</span>
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms_rectify_map(
  map_original,
  map_modified,
  nitems = NULL,
  non_linear = 1,
  type = "hulls",
  downsample = 10,
  concavity = 0,
  length_threshold = 10,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ms_rectify_map_+3A_map_original">map_original</code></td>
<td>
<p>File name of the original map without anything drawn over
it (either a <code>.pdf</code> or <code>.png</code>; extension will be ignored).</p>
</td></tr>
<tr><td><code id="ms_rectify_map_+3A_map_modified">map_modified</code></td>
<td>
<p>File name of the modified version with drawings (either a
<code>.pdf</code> or <code>.png</code>; extension will be ignored).</p>
</td></tr>
<tr><td><code id="ms_rectify_map_+3A_nitems">nitems</code></td>
<td>
<p>Optional parameter to explicitly specify number of distinct
items to be extracted from map; if possible, specifying this parameter may
improve results.</p>
</td></tr>
<tr><td><code id="ms_rectify_map_+3A_non_linear">non_linear</code></td>
<td>
<p>Integer value of 0, 1, or 2 representing degree of
non-linearity in modified image - see Note.</p>
</td></tr>
<tr><td><code id="ms_rectify_map_+3A_type">type</code></td>
<td>
<p>Currently either &quot;points&quot;, &quot;polygons&quot;, or &quot;hulls&quot;, where
&quot;points&quot; simply reduces each distinct object to a single, central point;
&quot;polygons&quot; identifies individual groups and returns the polygon representing
the outer boundary of each; and &quot;hulls&quot; constructs convex or concave polygons
around each group.</p>
</td></tr>
<tr><td><code id="ms_rectify_map_+3A_downsample">downsample</code></td>
<td>
<p>Factor by which to downsample <code>type = "polygons"</code>, noting
that polygons initially include every outer pixel of image, so can generally
be downsampled by at least an order or magnitude (<code>n = 10</code>). Higher values
may be used for higher-resolution images; lower values will generally only be
necessary for very low lower resolution images.</p>
</td></tr>
<tr><td><code id="ms_rectify_map_+3A_concavity">concavity</code></td>
<td>
<p>For <code>type = "hulls"</code>, a value between 0 and 1, with 0 giving
convex hulls and 1 giving highly concave hulls.</p>
</td></tr>
<tr><td><code id="ms_rectify_map_+3A_length_threshold">length_threshold</code></td>
<td>
<p>For <code>type = "hulls"</code>, the minimal length of a segment
to be made more convex. Low values will produce highly detailed hulls which
may cause problems; if in doubt, or if odd results appear, increase this
value.</p>
</td></tr>
<tr><td><code id="ms_rectify_map_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, display progress information on screen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <span class="pkg">sf</span> object representing the drawn additions to map_modified.
</p>


<h3>Note</h3>

<p>The <code>non-linear</code> parameter should generally set according to how the
modified maps were digitised. A value of 0 will give fastest results, and
should be used for directly scanned or photocopied images. A value of 1 (the
default) still presumes modified images have been linearly translated, and
will apply affine transformations (rotations, contractions, dilations). This
value should be used when modified images have been photographed (potentially
from an oblique angle). A value of 2 should only be used when modified maps
have somehow been non-linearly distorted, for example through having been
crumpled or screwed up. Rectification with <code>non-linear = 2</code> will likely take
considerably longer than with lower values.
</p>

<hr>
<h2 id='ms_rotate_map'>Rotate maps</h2><span id='topic+ms_rotate_map'></span>

<h3>Description</h3>

<p>Display original and modified maps to determine necessary rotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms_rotate_map(map_original, map_modified, rotation = 0, apply_rotation = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ms_rotate_map_+3A_map_original">map_original</code></td>
<td>
<p>File name of the original map without anything drawn over
it (either a <code>.pdf</code> or <code>.png</code>; extension will be ignored).</p>
</td></tr>
<tr><td><code id="ms_rotate_map_+3A_map_modified">map_modified</code></td>
<td>
<p>File name of the modified version with drawings (either a
<code>.pdf</code> or <code>.png</code>; extension will be ignored).</p>
</td></tr>
<tr><td><code id="ms_rotate_map_+3A_rotation">rotation</code></td>
<td>
<p>Rotation value to be applied, generally +/- 90</p>
</td></tr>
<tr><td><code id="ms_rotate_map_+3A_apply_rotation">apply_rotation</code></td>
<td>
<p>If <code>FALSE</code>, display results of rotation without
actually applying it; otherwise transform the specified <code>map_modified</code> image
according to the specified rotation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Function either modifies files on disk by rotating
images by the specified amount (if <code>apply_rotation = TRUE</code>), or displays a
rotated version of <code>map_original</code> (if <code>apply_rotation = FALSE</code>).
</p>


<h3>Note</h3>

<p>If a call to <a href="#topic+ms_rectify_map">ms_rectify_map</a> detects potential image rotation,
that function will stop and suggest that rotation be applied using this
function in order to determine the required degree of image rotation. Values
for <code>rotation</code> can be trialled in order to determine the correct value,
following which that value can be entered with <code>apply_rotation = TRUE</code> in
order to actually apply that rotation to the modified image.
</p>

<hr>
<h2 id='set_mapbox_token'>Set 'mapbox' token</h2><span id='topic+set_mapbox_token'></span>

<h3>Description</h3>

<p>Set a mapbox token for use with the <a href="#topic+ms_generate_map">ms_generate_map</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_mapbox_token(token)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_mapbox_token_+3A_token">token</code></td>
<td>
<p>Personal mapbox API token, obtained from
<a href="https://docs.mapbox.com/api/#access-tokens-and-token-scopes">https://docs.mapbox.com/api/#access-tokens-and-token-scopes</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the token was able to be set; otherwise <code>FALSE</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
