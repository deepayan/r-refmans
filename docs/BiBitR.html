<!DOCTYPE html><html><head><title>Help for package BiBitR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BiBitR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bibit'><p>The BiBit Algorithm</p></a></li>
<li><a href='#bibit_columnextension'><p>Column Extension Procedure</p></a></li>
<li><a href='#bibit2'><p>The BiBit Algorithm with Noise Allowance</p></a></li>
<li><a href='#bibit3'><p>The BiBit Algorithm with Noise Allowance guided by Provided Patterns.</p></a></li>
<li><a href='#bibit3_patternBC'><p>Extract BC from <code>bibit3</code> result and add pattern</p></a></li>
<li><a href='#BiBitR'><p>A biclustering algorithm for extracting bit-patterns from binary datasets</p></a></li>
<li><a href='#BiBitWorkflow'><p>BiBit Workflow</p></a></li>
<li><a href='#ClusterRowCoverage'><p>Row Coverage Plots</p></a></li>
<li><a href='#ColInfo'><p>Column Info of Biclusters</p></a></li>
<li><a href='#ColNoiseBC'><p>Barplots of Column Noise for Biclusters</p></a></li>
<li><a href='#CompareResultJI'><p>Compare Biclustering Results using Jaccard Index</p></a></li>
<li><a href='#make_arff_row_col'><p>Transform R matrix object to BiBit input files.</p></a></li>
<li><a href='#MaxBC'><p>Finding Maximum Size Biclusters</p></a></li>
<li><a href='#NoiseScree'><p>Noise Scree Plots</p></a></li>
<li><a href='#RowTest_Fisher'><p>Apply Fisher Exact Test on Bicluster Rows</p></a></li>
<li><a href='#summary,Biclust-method'><p>Summary Method for Biclust Class</p></a></li>
<li><a href='#UpdateBiclust_RowNoise'><p>Update a Biclust or BiBitWorkflow Object with a new Noise Level</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Wrapper for Java Implementation of BiBit</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-06-30</td>
</tr>
<tr>
<td>Author:</td>
<td>De Troyer Ewoud</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>De Troyer Ewoud &lt;ewoud.detroyer@uhasselt.be&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A simple R wrapper for the Java BiBit algorithm from "A
    biclustering algorithm for extracting bit-patterns from binary datasets"
    from Domingo et al. (2011) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtr464">doi:10.1093/bioinformatics/btr464</a>&gt;. An simple adaption for the BiBit algorithm which allows noise in the biclusters is also introduced as well as a function to guide the algorithm towards given (sub)patterns. Further, a workflow to derive noisy biclusters from discoverd larger column patterns is included as well.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats,foreign,methods,utils,viridis,cluster,dendextend,lattice,grDevices,graphics,randomcoloR,biclust</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-06-30 08:58:09 UTC; lucp8394</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-06-30 17:38:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='bibit'>The BiBit Algorithm</h2><span id='topic+bibit'></span>

<h3>Description</h3>

<p>A R-wrapper which directly calls the original Java code for the BiBit algorithm (<a href="http://eps.upo.es/bigs/BiBit.html">http://eps.upo.es/bigs/BiBit.html</a>) and transforms it to the output format of the <code>Biclust</code> R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bibit(matrix = NULL, minr = 2, minc = 2, arff_row_col = NULL,
  output_path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bibit_+3A_matrix">matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td></tr>
<tr><td><code id="bibit_+3A_minr">minr</code></td>
<td>
<p>The minimum number of rows of the Biclusters.</p>
</td></tr>
<tr><td><code id="bibit_+3A_minc">minc</code></td>
<td>
<p>The minimum number of columns of the Biclusters.</p>
</td></tr>
<tr><td><code id="bibit_+3A_arff_row_col">arff_row_col</code></td>
<td>
<p>If you want to circumvent the internal R function to convert the matrix to <code>.arff</code> format, provide the pathname of this file here. Additionally, two <code>.csv</code> files should be provided containing 1 column of row and column names. These two files should not contain a header or quotes around the names, simply 1 column with the names.<br /> 
(<em>Example</em>: <code>arff_row_col=c("...\\data\\matrix.arff","...\\data\\rownames.csv","...\\data\\colnames.csv")</code>)<br />
<em>Note:</em> These files can be generated with the <code><a href="#topic+make_arff_row_col">make_arff_row_col</a></code> function.
<br /> <strong>Warning:</strong> Should you use the <code>write.arff</code> function from the <code>foreign</code> package, remember to transpose the matrix first.</p>
</td></tr>
<tr><td><code id="bibit_+3A_output_path">output_path</code></td>
<td>
<p>If as output, the original txt output of the Java code is desired, provide the outputh path here (without extension). In this case the <code>bibit</code> function will skip the transformation to a Biclust class object and simply return <code>NULL</code>.<br /> 
(<em>Example</em>: <code>output_path="...\\out\\bibitresult"</code>)
<br />
(<em>Description Output</em>: The following information about every bicluster generated will be printed in the output file: number of rows, number of columns, name of rows and name of columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the original Java code directly (with the intended input and output). Because the Java code was not refactored, the <code>rJava</code> package could not be used.
The <code>bibit</code> function does the following:
</p>

<ol>
<li><p> Convert R matrix to a <code>.arff</code> output file.
</p>
</li>
<li><p> Use the <code>.arff</code> file as input for the Java code which is called by <code>system()</code>.
</p>
</li>
<li><p> The outputted <code>.txt</code> file from the Java BiBit algorithm is read in and transformed to a <code>Biclust</code> object.
</p>
</li></ol>

<p>Because of this, there is a chance of <em>overhead</em> when applying the algorithm on large datasets. Make sure your machine has enough RAM available when applying to big data.
</p>


<h3>Value</h3>

<p>A Biclust S4 Class object.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>References</h3>

<p>Domingo S. Rodriguez-Baena, Antonia J. Perez-Pulido and Jesus S. Aguilar-Ruiz (2011), &quot;A biclustering algorithm for extracting bit-patterns from binary datasets&quot;, <em>Bioinformatics</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
data &lt;- data[sample(1:nrow(data),nrow(data)),sample(1:ncol(data),ncol(data))]
result &lt;- bibit(data,minr=5,minc=5)
result
MaxBC(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='bibit_columnextension'>Column Extension Procedure</h2><span id='topic+bibit_columnextension'></span>

<h3>Description</h3>

<p>Function which accepts result from <code><a href="#topic+bibit">bibit</a></code>, <code><a href="#topic+bibit2">bibit2</a></code> or <code><a href="#topic+bibit3">bibit3</a></code> and will (re-)apply the column extension procedure. This means if the result already contained extended biclusters that these will be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bibit_columnextension(result, matrix, arff_row_col = NULL, BC = NULL,
  extend_columns = "naive", extend_mincol = 1, extend_limitcol = 1,
  extend_noise = 1, extend_contained = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bibit_columnextension_+3A_result">result</code></td>
<td>
<p>Result from <code><a href="#topic+bibit">bibit</a></code>, <code><a href="#topic+bibit2">bibit2</a></code> or <code><a href="#topic+bibit3">bibit3</a></code>.</p>
</td></tr>
<tr><td><code id="bibit_columnextension_+3A_matrix">matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td></tr>
<tr><td><code id="bibit_columnextension_+3A_arff_row_col">arff_row_col</code></td>
<td>
<p>The same file directories (with the same limitations) as given in <code><a href="#topic+bibit">bibit</a></code>, <code><a href="#topic+bibit2">bibit2</a></code> or <code><a href="#topic+bibit3">bibit3</a></code>.</p>
</td></tr>
<tr><td><code id="bibit_columnextension_+3A_bc">BC</code></td>
<td>
<p>A numeric/integer vector of BC's which should be extended. Different behaviour for the 3 types of input results:
</p>

<dl>
<dt><code>bibit</code></dt><dd><p><code>BC</code> directly takes the corresponding biclusters from the result and extends them. (e.g. <code>BC=c(1,10)</code> is then remapped to <code>c("BC1","BC1_Ext1","BC2","BC2_Ext1") in the new output</code>)</p>
</dd>
<dt><code>bibit2</code></dt><dd><p><code>BC</code> corresponds with the original non-extended biclusters from the <code><a href="#topic+bibit2">bibit2</a></code> result. These original biclusters are selected and extended. (e.g. <code>BC=c(1,10)</code> selects biclusters <code>c("BC1","BC10")</code> which are then remapped to <code>c("BC1","BC1_Ext1","BC2","BC2_Ext1") in the new output</code>)</p>
</dd> 
<dt><code>bibit3</code></dt><dd><p><code>BC</code> corresponds with the biclusters when combining the FULLPATTERN and SUBPATTERN result together. For example choosing <code>BC=1</code> would only select the 1 FULLPATTERN bicluster for each pattern and try to extend it. (e.g. <code>BC=c(1,10)</code> selects biclusters 1 and 10 from the combined fullpattern and subpattern result (meaning the full pattern BC and the 9th subpattern BC) which are then remapped to <code>c("BC1","BC1_Ext1","BC2","BC2_Ext1") in the new output</code>) </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bibit_columnextension_+3A_extend_columns">extend_columns</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> Can be one of the following: <code>"naive"</code> or <code>"recursive"</code> which will apply either a naive or recursive column extension procedure. (See Details Section for more information.)
<br /> Based on the extension, additional biclusters will be created in the Biclust object which can be seen in the column and row names of the <code>RowxNumber</code> and <code>NumberxCol</code> slots (<code>"_Ext"</code> suffix).
<br /> The <code>info</code> slot will also contain some additional information. Inside this slot, <code>BC.Extended</code> contains info on which original biclusters were extended, how many columns were added, and in how many extra extended biclusters this resulted.
<br /> <br /> <strong>Warning:</strong> Using a percentage-based <code>extend_noise</code> in combination with the recursive procedure will result in a large amount of biclusters and increase the computation time a lot. Depending on the data when using recursive in combination with a noise percentage, it is advised to keep it reasonable small (e.g. 10%). Another remedy is to sufficiently increase the <code>extend_limitcol</code> either as a percentage or integer to limit the candidates of columns.</p>
</td></tr>
<tr><td><code id="bibit_columnextension_+3A_extend_mincol">extend_mincol</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> A minimum number of columns that a bicluster should be able to be extended with before saving the result. (Default=1)</p>
</td></tr>
<tr><td><code id="bibit_columnextension_+3A_extend_limitcol">extend_limitcol</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> The number (<code>extend_limitcol&gt;=1</code>) or percentage (<code>0&lt;extend_limitcol&lt;1</code>) of 1's that a column (subsetted on the BC rows) should at least contain for it to be a candidate to be added to the bicluster as an extension. (Default=1) (Increase this parameter if the recursive extension takes too long. Limiting the pool of candidates will decrease computation time, but restrict the results more.)</p>
</td></tr>
<tr><td><code id="bibit_columnextension_+3A_extend_noise">extend_noise</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> The maximum allowed noise (in each row) when extending the columns of the bicluster. Can take the same as the <code>noise</code> parameter.</p>
</td></tr>
<tr><td><code id="bibit_columnextension_+3A_extend_contained">extend_contained</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> Logical value if extended results should be checked if they contain each other (and deleted if this is the case). Default = <code>FALSE</code>. This can be a lengthy procedure for a large amount of biclusters (&gt;1000).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Biclust S4 Class object or bibit3 S3 list Class object
</p>


<h3>Details - Column Extension</h3>

<p>An optional procedure which can be applied <em>after</em> applying the BiBit algorithm (with noise) is called <em>Column Extension</em>. 
The procedure will add extra columns to a BiBit bicluster, keeping into account the allowed <code>extend_noise</code> level in each row.
The primary goal is to, after applying BiBit with noise, to also try and add some noise to the 2 initial 'perfect' rows.
Other parameters like <code>extend_mincol</code> and <code>extend_limitcol</code> can also further restrict which extensions should be discovered.
<br /> This procedure can be done either <em>naively</em> (fast) or <em>recursively</em> (more slow and thorough) with the <code>extend_columns</code> parameter.
</p>

<dl>
<dt><code>"naive"</code></dt><dd><p>Subsetting on the bicluster rows, the column candidates are ordered based on the most 1's in a column. Afterwards, in this order, each column is sequentially checked and added when the resulted BC is still within row noise levels.
<br /> This has 2 major consequences:
</p>

<ul>
<li><p>If 2 columns are identical, the first in the dataset is added, while the second isn't (depending on the noise level allowed per row).
</p>
</li>
<li><p>If 2 non-identical columns are viable to be added (correct row noise), the column with the most 1's is added. Afterwards the second column might not be viable anymore.
</p>
</li></ul>

<p>Note that using this method will always result in a maximum of 1 extended bicluster per original bicluster.
</p>
</dd>
<dt><code>"recursive"</code></dt><dd>
<p>Conditioning the group of candidates for the allowed row noise level, each possible/allowed combination of adding columns to the bicluster is checked. Only the resulted biclusters with the highest number of extra columns are saved.
Of course this could result in multiple extensions for 1 bicluster if there are multiple 'maximum added columns' results.
</p>
</dd>
</dl>

<p><em>Note:</em> These procedures are followed by a fast check if the extensions resulted in any duplicate biclusters. If so, these are deleted from the final result.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

set.seed(1)
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
data &lt;- data[sample(1:nrow(data),nrow(data)),sample(1:ncol(data),ncol(data))]

result &lt;- bibit2(data,minr=5,minc=5,noise=0.1,extend_columns = "recursive",
              extend_mincol=1,extend_limitcol=1)
result
result2 &lt;- bibit_columnextension(result=out,matrix=data,arff_row_col=NULL,BC=c(1,10),
                              extend_columns="recursive",extend_mincol=1,
                              extend_limitcol=1,extend_noise=2,extend_contained=FALSE)
result2

## End(Not run)
</code></pre>

<hr>
<h2 id='bibit2'>The BiBit Algorithm with Noise Allowance</h2><span id='topic+bibit2'></span>

<h3>Description</h3>

<p>Same function as <code><a href="#topic+bibit">bibit</a></code> with an additional new noise parameter which allows 0's in the discovered biclusters (See Details for more info).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bibit2(matrix = NULL, minr = 2, minc = 2, noise = 0,
  arff_row_col = NULL, output_path = NULL, extend_columns = "none",
  extend_mincol = 1, extend_limitcol = 1, extend_noise = noise,
  extend_contained = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bibit2_+3A_matrix">matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td></tr>
<tr><td><code id="bibit2_+3A_minr">minr</code></td>
<td>
<p>The minimum number of rows of the Biclusters.</p>
</td></tr>
<tr><td><code id="bibit2_+3A_minc">minc</code></td>
<td>
<p>The minimum number of columns of the Biclusters.</p>
</td></tr>
<tr><td><code id="bibit2_+3A_noise">noise</code></td>
<td>
<p>Noise parameter which determines the amount of zero's allowed in the bicluster (i.e. in the extra added rows to the starting row pair).
</p>

<ul>
<li> <p><code>noise=0</code>: No noise allowed. This gives the same result as using the <code><a href="#topic+bibit">bibit</a></code> function. (default)
</p>
</li>
<li> <p><code>0&lt;noise&lt;1</code>: The <code>noise</code> parameter will be a noise percentage. The number of allowed 0's in a (extra) row in the bicluster will depend on the column size of the bicluster. 
More specifically <code>zeros_allowed = ceiling(noise * columnsize)</code>. For example for <code>noise=0.10</code> and a bicluster column size of <code>5</code>, the number of allowed 0's would be <code>1</code>.
</p>
</li>
<li> <p><code>noise&gt;=1</code>: The <code>noise</code> parameter will be the number of allowed 0's in a (extra) row in the bicluster independent from the column size of the bicluster. In this noise option, the noise parameter should be an integer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bibit2_+3A_arff_row_col">arff_row_col</code></td>
<td>
<p>If you want to circumvent the internal R function to convert the matrix to <code>.arff</code> format, provide the pathname of this file here. Additionally, two <code>.csv</code> files should be provided containing 1 column of row and column names. These two files should not contain a header or quotes around the names, simply 1 column with the names.<br /> 
(<em>Example</em>: <code>arff_row_col=c("...\\data\\matrix.arff","...\\data\\rownames.csv","...\\data\\colnames.csv")</code>)<br />
<em>Note:</em> These files can be generated with the <code><a href="#topic+make_arff_row_col">make_arff_row_col</a></code> function.
<br /> <strong>Warning:</strong> Should you use the <code>write.arff</code> function from the <code>foreign</code> package, remember to transpose the matrix first.</p>
</td></tr>
<tr><td><code id="bibit2_+3A_output_path">output_path</code></td>
<td>
<p>If as output, the original txt output of the Java code is desired, provide the outputh path here (without extension). In this case the <code>bibit</code> function will skip the transformation to a Biclust class object and simply return <code>NULL</code>.<br /> 
(<em>Example</em>: <code>output_path="...\\out\\bibitresult"</code>)
<br />
(<em>Description Output</em>: The following information about every bicluster generated will be printed in the output file: number of rows, number of columns, name of rows and name of columns.</p>
</td></tr>
<tr><td><code id="bibit2_+3A_extend_columns">extend_columns</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> Can be one of the following: <code>"none"</code>, <code>"naive"</code>, <code>"recursive"</code> which will apply either a naive or recursive column extension procedure. (See Details Section for more information.)
<br /> Based on the extension, additional biclusters will be created in the Biclust object which can be seen in the column and row names of the <code>RowxNumber</code> and <code>NumberxCol</code> slots (<code>"_Ext"</code> suffix).
<br /> The <code>info</code> slot will also contain some additional information. Inside this slot, <code>BC.Extended</code> contains info on which original biclusters were extended, how many columns were added, and in how many extra extended biclusters this resulted.
<br /> <br /> <strong>Warning:</strong> Using a percentage-based <code>extend_noise</code> (or <code>noise</code> by default) in combination with the recursive procedure will result in a large amount of biclusters and increase the computation time a lot. Depending on the data when using recursive in combination with a noise percentage, it is advised to keep it reasonable small (e.g. 10%). Another remedy is to sufficiently increase the <code>extend_limitcol</code> either as a percentage or integer to limit the candidates of columns.</p>
</td></tr>
<tr><td><code id="bibit2_+3A_extend_mincol">extend_mincol</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> A minimum number of columns that a bicluster should be able to be extended with before saving the result. (Default=1)</p>
</td></tr>
<tr><td><code id="bibit2_+3A_extend_limitcol">extend_limitcol</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> The number (<code>extend_limitcol&gt;=1</code>) or percentage (<code>0&lt;extend_limitcol&lt;1</code>) of 1's that a column (subsetted on the BC rows) should at least contain for it to be a candidate to be added to the bicluster as an extension. (Default=1) (Increase this parameter if the recursive extension takes too long. Limiting the pool of candidates will decrease computation time, but restrict the results more.)</p>
</td></tr>
<tr><td><code id="bibit2_+3A_extend_noise">extend_noise</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> The maximum allowed noise (in each row) when extending the columns of the bicluster. Can take the same as the <code>noise</code> parameter. By default this is the same value as <code>noise</code>.</p>
</td></tr>
<tr><td><code id="bibit2_+3A_extend_contained">extend_contained</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> Logical value if extended results should be checked if they contain each other (and deleted if this is the case). Default = <code>FALSE</code>. This can be a lengthy procedure for a large amount of biclusters (&gt;1000).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Biclust S4 Class object.
</p>


<h3>Details - General</h3>

<p><code>bibit2</code> follows the same steps as described in the Details section of <code><a href="#topic+bibit">bibit</a></code>.<br />
Following the general steps of the BiBit algorithm, the allowance for noise in the biclusters is inserted in the original algorithm as such:
</p>

<ol>
<li><p> Binary data is encoded in bit words.
</p>
</li>
<li><p> Take a pair of rows as your starting point.
</p>
</li>
<li><p> Find the maximal overlap of 1's between these two rows and save this as a pattern/motif. You now have a bicluster of 2 rows and N columns in which N is the number of 1's in the motif.
</p>
</li>
<li><p> Check all remaining rows if they match this motif, <em>however</em> allow a specific amount of 0's in this matching as defined by the <code>noise</code> parameter. Those rows that match completely or those within the allowed noise range are added to bicluster.
</p>
</li>
<li><p> Go back to <em>Step 2</em> and repeat for all possible row pairs.
</p>
</li></ol>

<p><em>Note:</em> Biclusters are only saved if they satisfy the <code>minr</code> and <code>minc</code> parameter settings and if the bicluster is not already contained completely within another bicluster.<br />
<br />
What you will end up with are biclusters not only consisting out of 1's, but biclusters in which 2 rows (the starting pair) are all 1's and in which the other rows could contain 0's (= noise).<br />
<br />
<em>Note:</em> Because of the extra checks involved in the noise allowance, using noise might increase the computation time a little bit.
</p>


<h3>Details - Column Extension</h3>

<p>An optional procedure which can be applied <em>after</em> applying the BiBit algorithm (with noise) is called <em>Column Extension</em>. 
The procedure will add extra columns to a BiBit bicluster, keeping into account the allowed <code>extend_noise</code> level in each row.
The primary goal is to, after applying BiBit with noise, to also try and add some noise to the 2 initial 'perfect' rows.
Other parameters like <code>extend_mincol</code> and <code>extend_limitcol</code> can also further restrict which extensions should be discovered.
<br /> This procedure can be done either <em>naively</em> (fast) or <em>recursively</em> (more slow and thorough) with the <code>extend_columns</code> parameter.
</p>

<dl>
<dt><code>"naive"</code></dt><dd><p>Subsetting on the bicluster rows, the column candidates are ordered based on the most 1's in a column. Afterwards, in this order, each column is sequentially checked and added when the resulted BC is still within row noise levels.
<br /> This has 2 major consequences:
</p>

<ul>
<li><p>If 2 columns are identical, the first in the dataset is added, while the second isn't (depending on the noise level allowed per row).
</p>
</li>
<li><p>If 2 non-identical columns are viable to be added (correct row noise), the column with the most 1's is added. Afterwards the second column might not be viable anymore.
</p>
</li></ul>

<p>Note that using this method will always result in a maximum of 1 extended bicluster per original bicluster.
</p>
</dd>
<dt><code>"recursive"</code></dt><dd>
<p>Conditioning the group of candidates for the allowed row noise level, each possible/allowed combination of adding columns to the bicluster is checked. Only the resulted biclusters with the highest number of extra columns are saved.
Of course this could result in multiple extensions for 1 bicluster if there are multiple 'maximum added columns' results.
</p>
</dd>
</dl>

<p><em>Note:</em> These procedures are followed by a fast check if the extensions resulted in any duplicate biclusters. If so, these are deleted from the final result.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>References</h3>

<p>Domingo S. Rodriguez-Baena, Antonia J. Perez-Pulido and Jesus S. Aguilar-Ruiz (2011), &quot;A biclustering algorithm for extracting bit-patterns from binary datasets&quot;, <em>Bioinformatics</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
data &lt;- data[sample(1:nrow(data),nrow(data)),sample(1:ncol(data),ncol(data))]

result1 &lt;- bibit2(data,minr=5,minc=5,noise=0.2)
result1
MaxBC(result1,top=1)

result2 &lt;- bibit2(data,minr=5,minc=5,noise=3)
result2
MaxBC(result2,top=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='bibit3'>The BiBit Algorithm with Noise Allowance guided by Provided Patterns.</h2><span id='topic+bibit3'></span>

<h3>Description</h3>

<p>Same function as <code><a href="#topic+bibit2">bibit2</a></code> but only aims to discover biclusters containing the (sub) pattern of provided patterns or their combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bibit3(matrix = NULL, minr = 1, minc = 2, noise = 0,
  pattern_matrix = NULL, subpattern = TRUE, pattern_combinations = FALSE,
  arff_row_col = NULL, extend_columns = "none", extend_mincol = 1,
  extend_limitcol = 1, extend_noise = noise, extend_contained = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bibit3_+3A_matrix">matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td></tr>
<tr><td><code id="bibit3_+3A_minr">minr</code></td>
<td>
<p>The minimum number of rows of the Biclusters. (Note that in contrast to <code><a href="#topic+bibit">bibit</a></code> and <code><a href="#topic+bibit2">bibit2</a></code>, this can be be set to 1 since we are looking for additional rows to the provided pattern.)</p>
</td></tr>
<tr><td><code id="bibit3_+3A_minc">minc</code></td>
<td>
<p>The minimum number of columns of the Biclusters.</p>
</td></tr>
<tr><td><code id="bibit3_+3A_noise">noise</code></td>
<td>
<p>Noise parameter which determines the amount of zero's allowed in the bicluster (i.e. in the extra added rows to the starting row pair).
</p>

<ul>
<li> <p><code>noise=0</code>: No noise allowed. This gives the same result as using the <code><a href="#topic+bibit">bibit</a></code> function. (default)
</p>
</li>
<li> <p><code>0&lt;noise&lt;1</code>: The <code>noise</code> parameter will be a noise percentage. The number of allowed 0's in a (extra) row in the bicluster will depend on the column size of the bicluster. 
More specifically <code>zeros_allowed = ceiling(noise * columnsize)</code>. For example for <code>noise=0.10</code> and a bicluster column size of <code>5</code>, the number of allowed 0's would be <code>1</code>.
</p>
</li>
<li> <p><code>noise&gt;=1</code>: The <code>noise</code> parameter will be the number of allowed 0's in a (extra) row in the bicluster independent from the column size of the bicluster. In this noise option, the noise parameter should be an integer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bibit3_+3A_pattern_matrix">pattern_matrix</code></td>
<td>
<p>Matrix (Number of Patterns x Number of Data Columns) containing the patterns of interest.</p>
</td></tr>
<tr><td><code id="bibit3_+3A_subpattern">subpattern</code></td>
<td>
<p>Boolean value if sub patterns are of interest as well (default=TRUE).</p>
</td></tr>
<tr><td><code id="bibit3_+3A_pattern_combinations">pattern_combinations</code></td>
<td>
<p>Boolean value if the pairwise combinations of patterns (the intersecting 1's) should also used as starting points (default=FALSE).</p>
</td></tr>
<tr><td><code id="bibit3_+3A_arff_row_col">arff_row_col</code></td>
<td>
<p>Same argument as in <code><a href="#topic+bibit">bibit</a></code> and <code><a href="#topic+bibit2">bibit2</a></code>. However you can only provide 1 pattern by using this option. For <code>bibit3</code> to work, the pattern has to be added 2 times on top of the matrix (= identical first 2 rows).</p>
</td></tr>
<tr><td><code id="bibit3_+3A_extend_columns">extend_columns</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> Can be one of the following: <code>"none"</code>, <code>"naive"</code>, <code>"recursive"</code> which will apply either a naive or recursive column extension procedure. (See Details Section for more information.)
<br /> Based on the extension, additional biclusters will be created in the Biclust object which can be seen in the column and row names of the <code>RowxNumber</code> and <code>NumberxCol</code> slots (<code>"_Ext"</code> suffix).
<br /> The <code>info</code> slot will also contain some additional information. Inside this slot, <code>BC.Extended</code> contains info on which original biclusters were extended, how many columns were added, and in how many extra extended biclusters this resulted.
<br /> <br /> <strong>Warning:</strong> Using a percentage-based <code>extend_noise</code> (or <code>noise</code> by default) in combination with the recursive procedure will result in a large amount of biclusters and increase the computation time a lot. Depending on the data when using recursive in combination with a noise percentage, it is advised to keep it reasonable small (e.g. 10%). Another remedy is to sufficiently increase the <code>extend_limitcol</code> either as a percentage or integer to limit the candidates of columns.</p>
</td></tr>
<tr><td><code id="bibit3_+3A_extend_mincol">extend_mincol</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> A minimum number of columns that a bicluster should be able to be extended with before saving the result. (Default=1)</p>
</td></tr>
<tr><td><code id="bibit3_+3A_extend_limitcol">extend_limitcol</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> The number (<code>extend_limitcol&gt;=1</code>) or percentage (<code>0&lt;extend_limitcol&lt;1</code>) of 1's that a column (subsetted on the BC rows) should at least contain for it to be a candidate to be added to the bicluster as an extension. (Default=1) (Increase this parameter if the recursive extension takes too long. Limiting the pool of candidates will decrease computation time, but restrict the results more.)</p>
</td></tr>
<tr><td><code id="bibit3_+3A_extend_noise">extend_noise</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> The maximum allowed noise (in each row) when extending the columns of the bicluster. Can take the same as the <code>noise</code> parameter. By default this is the same value as <code>noise</code>.</p>
</td></tr>
<tr><td><code id="bibit3_+3A_extend_contained">extend_contained</code></td>
<td>
<p><em>Column Extension Parameter</em><br /> Logical value if extended results should be checked if they contain each other (and deleted if this is the case). Default = <code>FALSE</code>. This can be a lengthy procedure for a large amount of biclusters (&gt;1000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of the <code><a href="#topic+bibit3">bibit3</a></code> function is to provide one or multiple patterns in order to only find those biclusters exhibiting those patterns.
Multiple patterns can be given in matrix format, <code>pattern_matrix</code>, and their pairwise combinations can automatically be added to this matrix by setting <code>pattern_combinations=TRUE</code>.
All discovered biclusters are still subject to the provided <code>noise</code> level.
</p>
<p>Three types of Biclusters can be discovered:
</p>

<dl>
<dt><em>Full Pattern: </em></dt><dd><p>Bicluster which overlaps completely (within allowed noise levels) with the provided pattern. The column size of this bicluster is always equal to the number of 1's in the pattern.</p>
</dd>
<dt><em>Sub Pattern: </em></dt><dd><p>Biclusters which overlap with a part of the provided pattern within allowed noise levels. Will only be given if <code>subpattern=TRUE</code> (default). Setting this option to <code>FALSE</code> decreases computation time.</p>
</dd>
<dt><em>Extended: </em></dt><dd><p>Using the resulting biclusters from the full and sub patterns, other columns will be attempted to be added to the biclusters while keeping the noise as low as possible (the number of rows in the BC stays constant). 
This can be done either with <code>extend_columns</code> equal to <code>"naive"</code> or <code>"recursive"</code>. More info on the difference can be found in the Details Section of <code><a href="#topic+bibit2">bibit2</a></code>.
<br /> Naturally the articially added pattern rows will not be taken into account with the noise levels as they are 0 in each other column.
<br /> The question which is attempted to be answered here is <em>'Do the rows, which overlap partly or fully with the given pattern, have other similarities outside the given pattern?'</em>
</p>
</dd>
</dl>
 
<p><em>How?</em>
<br /> The BiBit algorithm is applied to a data matrix that contains 2 identical artificial rows at the top which contain the given pattern. 
The default algorithm is then slightly altered to only start from this articial row pair (=Full Pattern) or from 1 artificial row and 1 other row (=Sub Pattern).
</p>
<p><em>Note 1 - Large Data:</em>
<br /> The <code>arff_row_col</code> can still be provided in case of large data matrices, but the <code>.arff</code> file should already contain the pattern of interest in the first two rows. Consequently not more than 1 pattern at a time can be investigated with a single call of <code>bibit3</code>.
</p>
<p><em>Note 2 - Viewing Results:</em>
<br /> A <code>print</code> and <code>summary</code> method has been implemented for the output object of <code>bibit3</code>. It gives an overview of the amount of discovered biclusters and their dimensions
<br /> Additionally, the <code><a href="#topic+bibit3_patternBC">bibit3_patternBC</a></code> function can extract a Bicluster and add the artificial pattern rows to investigate the results.
</p>


<h3>Value</h3>

<p>A S3 list object, <code>"bibit3"</code> in which each element (apart from the last one) corresponds with a provided pattern or combination thereof. <br />
Each element is a list containing:
</p>

<dl>
<dt><code>Number</code>: </dt><dd><p>Number of Initially found BC's by applying BiBit with the provided pattern.</p>
</dd> 
<dt><code>Number_Extended</code>: </dt><dd><p>Number of additional discovered BC's by extending the columns.</p>
</dd>
<dt><code>FullPattern</code>: </dt><dd><p>Biclust S4 Class Object containing the Bicluster with the Full Pattern.</p>
</dd>
<dt><code>SubPattern</code>: </dt><dd><p>Biclust S4 Class Object containing the Biclusters showing parts of the pattern.</p>
</dd>
<dt><code>Extended</code>: </dt><dd><p>Biclust S4 Class Object containing the additional Biclusters after extending the biclusters (column wise) of the full and sub patterns</p>
</dd>
<dt><code>info</code>: </dt><dd><p>Contains <code>Time_Min</code> element which includes the elapsed time of parts and the full analysis.</p>
</dd>
</dl>

<p>The last element in the list is a matrix containing all the investigated patterns.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>References</h3>

<p>Domingo S. Rodriguez-Baena, Antonia J. Perez-Pulido and Jesus S. Aguilar-Ruiz (2011), &quot;A biclustering algorithm for extracting bit-patterns from binary datasets&quot;, <em>Bioinformatics</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
set.seed(1)
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
colsel &lt;- sample(1:ncol(data),ncol(data))
data &lt;- data[sample(1:nrow(data),nrow(data)),colsel]

pattern_matrix &lt;- matrix(0,nrow=3,ncol=100)
pattern_matrix[1,1:7] &lt;- 1
pattern_matrix[2,11:15] &lt;- 1
pattern_matrix[3,13:20] &lt;- 1

pattern_matrix &lt;- pattern_matrix[,colsel]


out &lt;- bibit3(matrix=data,minr=2,minc=2,noise=0.1,pattern_matrix=pattern_matrix,
              subpattern=TRUE,extend_columns=TRUE,pattern_combinations=TRUE)
out  # OR print(out) OR summary(out)


bibit3_patternBC(result=out,matrix=data,pattern=c(1),type=c("full","sub","ext"),BC=c(1,2))

## End(Not run)
</code></pre>

<hr>
<h2 id='bibit3_patternBC'>Extract BC from <code>bibit3</code> result and add pattern</h2><span id='topic+bibit3_patternBC'></span>

<h3>Description</h3>

<p>Function which will print the BC matrix and add 2 duplicate articial pattern rows on top. The function allows you to see the BC and the pattern the BC was guided towards to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bibit3_patternBC(result, matrix, pattern = c(1), type = c("full", "sub",
  "ext"), BC = c(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bibit3_patternBC_+3A_result">result</code></td>
<td>
<p>Result produced by <code><a href="#topic+bibit3">bibit3</a></code></p>
</td></tr>
<tr><td><code id="bibit3_patternBC_+3A_matrix">matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td></tr>
<tr><td><code id="bibit3_patternBC_+3A_pattern">pattern</code></td>
<td>
<p>Vector containing either the number or name of which patterns the BC results should be extracted.</p>
</td></tr>
<tr><td><code id="bibit3_patternBC_+3A_type">type</code></td>
<td>
<p>Vector for which BC results should be printed.
</p>

<ul>
<li><p> Full Pattern (<code>"full"</code>)
</p>
</li>
<li><p> Sub Pattern (<code>"sub"</code>)
</p>
</li>
<li><p> Extended (<code>"ext"</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="bibit3_patternBC_+3A_bc">BC</code></td>
<td>
<p>Vector of BC indices which should be printed, conditioned on <code>pattern</code> and <code>type</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints queried biclusters.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
set.seed(1)
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
colsel &lt;- sample(1:ncol(data),ncol(data))
data &lt;- data[sample(1:nrow(data),nrow(data)),colsel]

pattern_matrix &lt;- matrix(0,nrow=3,ncol=100)
pattern_matrix[1,1:7] &lt;- 1
pattern_matrix[2,11:15] &lt;- 1
pattern_matrix[3,13:20] &lt;- 1

pattern_matrix &lt;- pattern_matrix[,colsel]


out &lt;- bibit3(matrix=data,minr=2,minc=2,noise=0.1,pattern_matrix=pattern_matrix,
              subpattern=TRUE,extend_columns=TRUE,pattern_combinations=TRUE)
out  # OR print(out) OR summary(out)


bibit3_patternBC(result=out,matrix=data,pattern=c(1),type=c("full","sub","ext"),BC=c(1,2))

## End(Not run)
</code></pre>

<hr>
<h2 id='BiBitR'>A biclustering algorithm for extracting bit-patterns from binary datasets</h2><span id='topic+BiBitR'></span><span id='topic+BiBitR-package'></span>

<h3>Description</h3>

<p>BiBitR is a simple R wrapper which directly calls the original Java code for applying the BiBit algorithm.
The original Java code can be found at <a href="http://eps.upo.es/bigs/BiBit.html">http://eps.upo.es/bigs/BiBit.html</a> by Domingo S. Rodriguez-Baena, Antonia J. Perez-Pulido and Jesus S. Aguilar-Ruiz.
</p>
<p>The BiBitR package also includes the following functions and/or workflows:
</p>

<ul>
<li><p> A slightly adapted version of the original BiBit algorithm which now allows allows noise when adding rows to the bicluster (<code><a href="#topic+bibit2">bibit2</a></code>).
</p>
</li>
<li><p> A function which accepts a pattern and, using the BiBit algorithm, will find biclusters fully or partly fitting the given pattern (<code><a href="#topic+bibit3">bibit3</a></code>).
</p>
</li>
<li><p> A workflow which can discover larger patterns (and their biclusters) using BiBit and classic hierarchical clustering approaches (<code><a href="#topic+BiBitWorkflow">BiBitWorkflow</a></code>).
</p>
</li></ul>



<h3>References</h3>

<p>Domingo S. Rodriguez-Baena, Antonia J. Perez-Pulido and Jesus S. Aguilar-Ruiz (2011), &quot;A biclustering algorithm for extracting bit-patterns from binary datasets&quot;, <em>Bioinformatics</em>
</p>

<hr>
<h2 id='BiBitWorkflow'>BiBit Workflow</h2><span id='topic+BiBitWorkflow'></span>

<h3>Description</h3>

<p>Workflow to discover larger (noisy) patterns in big data using BiBit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiBitWorkflow(matrix, minr = 2, minc = 2, similarity_type = "col",
  func = "agnes", link = "average", par.method = 0.625,
  cut_type = "gap", cut_pm = "Tibs2001SEmax", gap_B = 500,
  gap_maxK = 50, noise = 0.1, noise_select = 0, plots = c(3:5),
  BCresult = NULL, simmatresult = NULL, treeresult = NULL,
  plot.type = "device", filename = "BiBitWorkflow", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiBitWorkflow_+3A_matrix">matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_minr">minr</code></td>
<td>
<p>The minimum number of rows of the Biclusters.</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_minc">minc</code></td>
<td>
<p>The minimum number of columns of the Biclusters.</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_similarity_type">similarity_type</code></td>
<td>
<p>Which dimension to use for the Jaccard Index in Step 2. This is either columns (<code>"col"</code>, default) or both (<code>"both"</code>).</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_func">func</code></td>
<td>
<p>Which clustering function to use in Step 3. Either <code>"agnes"</code> (= default) or <code>"hclust"</code>.</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_link">link</code></td>
<td>
<p>Which clustering link to use in Step 3. The available links (depending on <code>func</code>) are:
</p>

<ul>
<li><p><code>hclust</code>: <code>"ward.D"</code>, <code>"ward.D2"</code>, <code>"single"</code>, <code>"complete"</code>, <code>"average"</code>, <code>"mcquitty"</code>, <code>"median"</code> or <code>"centroid"</code>  
</p>
</li>
<li><p><code>agnes</code>: <code>"average"</code> (default), <code>"single"</code>, <code>"complete"</code>, <code>"ward"</code>, <code>"weighted"</code>, <code>"gaverage"</code> or <code>"flexible"</code>   
</p>
</li></ul>

<p>(More details in <code><a href="stats.html#topic+hclust">hclust</a></code> and <code><a href="cluster.html#topic+agnes">agnes</a></code>)</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_par.method">par.method</code></td>
<td>
<p>Additional parameters used for flexible link (See <code><a href="cluster.html#topic+agnes">agnes</a></code>). Default is <code>c(0.625)</code></p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_cut_type">cut_type</code></td>
<td>
<p>Which method should be used to decide the number of clusters in the tree in Step 4? 
</p>

<ul>
<li> <p><code>"gap"</code>: Use the Gap Statistic (default).
</p>
</li>
<li> <p><code>"number"</code>: Select a set number of clusters.
</p>
</li>
<li> <p><code>"height"</code>: Cut the tree at specific dissimilarity height.
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_cut_pm">cut_pm</code></td>
<td>
<p>Cut Parameter (depends on <code>cut_type</code>) for Step 4
</p>

<ul>
<li><p> Gap Statistic (<code>cut_type="gap"</code>): How to compute optimal number of clusters? Choose one of the following: <code>"Tibs2001SEmax"</code> (default), <code>"globalmax"</code>, <code>"firstmax"</code>, <code>"firstSEmax"</code> or <code>"globalSEmax"</code>.
</p>
</li>
<li><p> Number (<code>cut_type="number"</code>): Integer for number of clusters.
</p>
</li>
<li><p> Height (<code>cut_type="height"</code>): Numeric dissimilarity value where the tree should be cut (<code>[0,1]</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_gap_b">gap_B</code></td>
<td>
<p>Number of bootstrap samples (default=500) for Gap Statistic (<code><a href="cluster.html#topic+clusGap">clusGap</a></code>).</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_gap_maxk">gap_maxK</code></td>
<td>
<p>Number of clusters to consider (default=50) for Gap Statistic (<code><a href="cluster.html#topic+clusGap">clusGap</a></code>).</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_noise">noise</code></td>
<td>
<p>The allowed noise level when growing the rows on the merged patterns in Step 6. (default=<code>0.1</code>, namely allow 10% noise.)
</p>

<ul>
<li> <p><code>noise=0</code>: No noise allowed.
</p>
</li>
<li> <p><code>0&lt;noise&lt;1</code>: The <code>noise</code> parameter will be a noise percentage. The number of allowed 0's in a row in the bicluster will depend on the column size of the bicluster.
More specifically <code>zeros_allowed = ceiling(noise * columnsize)</code>. For example for <code>noise=0.10</code> and a bicluster column size of <code>5</code>, the number of allowed 0's would be <code>1</code>.
</p>
</li>
<li> <p><code>noise&gt;=1</code>: The <code>noise</code> parameter will be the number of allowed 0's in a row in the bicluster independent from the column size of the bicluster. In this noise option, the noise parameter should be an integer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_noise_select">noise_select</code></td>
<td>
<p>Should the allowed noise level be automatically selected for each pattern? (Using ad hoc method to find the elbow/kink in the Noise Scree plots)
</p>

<ul>
<li> <p><code>noise_select=0</code>: Do <em>NOT</em> automatically select the noise levels. Use the the noise level given in the <code>noise</code> parameter (default).
</p>
</li>
<li> <p><code>noise_select=1</code>: Using the Noise Scree plot (with 'Added Rows' on the y-axis), find the noise level where the current number of added rows at this noise level is larger than the mean of 'added rows' at the lower noise levels. 
After locating this noise level, lower the noise level by 1. This is your automatically selected elbow/kink and therefore your noise level.
</p>
</li>
<li> <p><code>noise_select=2</code>: Applies the same steps as for <code>noise_select=1</code>, but instead of decreasing the noise level by only 1, keep decreasing the noise level until the number of added rows isn't decreasing anymore either.
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_plots">plots</code></td>
<td>
<p>Vector for which plots to draw:
</p>

<ol>
<li><p> Image plot of the similarity matrix computed in Step 2.
</p>
</li>
<li><p> Same as <code>plots=1</code>, but the rows and columns are reordered with the hierarchical tree.
</p>
</li>
<li><p> Dendrogram of the tree, its clusters colored after the chosen cut has been applied.
</p>
</li>
<li><p> Noise Scree plots for all the Saved Patterns. Two plots will be plotted, both with Noise on the x-axis. The first one will have the number of Added Number of Rows on that noise level on the y-axis, while the second will have the Total Number of Rows (i.e. cumulative of the first).
If the title of one of the subplots is red, then this means that the Bicluster grown from this pattern, using the chosen noise level, was eventually deleted due to being a duplicate or non-maximal.
</p>
</li>
<li><p> Image plot of the Jaccard Index similarity matrix between the final biclusters after Step 6.
</p>
</li></ol>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_bcresult">BCresult</code></td>
<td>
<p>Import a BiBit Biclust result for Step 1 (e.g. extract from an older BiBitWorkflow object <code>$info$BiclustInitial</code>). This can be useful if you want to cut the tree differently/make different plots, but don't want to do the BiBit calculation again.</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_simmatresult">simmatresult</code></td>
<td>
<p>Import a (custom) Similarity Matrix (e.g. extract from older BiBitWorkflow object <code>$info$BiclustSimInitial</code>). Note that Step 1 (BiBit) will still be executed if <code>BCresult</code> is not provided.</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_treeresult">treeresult</code></td>
<td>
<p>Import a (custom) tree (<code>hclust</code> object) based on the BiBit/Similarity (e.g. extract from older BiBitWorkflow object <code>$info$Tree</code>).</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_plot.type">plot.type</code></td>
<td>
<p>Output Type
</p>

<ul>
<li> <p><code>"device"</code>: All plots are outputted to new R graphics devices (default).
</p>
</li>
<li> <p><code>"file"</code>: All plots are saved in external files. Plots 1 and 2 are saved in separate <code>.png</code> files while all other plots are joint together in a single <code>.pdf</code> file.
</p>
</li>
<li> <p><code>"other"</code>: All plots are outputted to the current graphics device, but will overwrite each other. Use this if you want to include one or more plots in a sweave/knitr file or if you want to export a single plot by your own chosen format.
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_filename">filename</code></td>
<td>
<p>Base filename (with/without directory) for the plots if <code>plot.type="file"</code> (default=<code>"BiBitWorkflow"</code>).</p>
</td></tr>
<tr><td><code id="BiBitWorkflow_+3A_verbose">verbose</code></td>
<td>
<p>Logical value if progress of workflow should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Looking for Noisy Biclusters in large data using BiBit (<code><a href="#topic+bibit2">bibit2</a></code>) often results in many (overlapping) biclusters.
In order decrease the number of biclusters and find larger meaningful patterns which make up noisy biclusters, the following workflow can be applied.
Note that this workflow is primarily used for data where there are many more rows (e.g. patients) than columns (e.g. symptoms). For example the workflow would discover larger meaningful symptom patterns which, conditioned on the allowed noise/zeros, subsets of the patients share.
</p>

<ol>
<li><p> Apply BiBit with <em>no noise</em> (Preferably with high enough <code>minr</code> and <code>minc</code>).
</p>
</li>
<li><p> Compute Similarity Matrix (Jaccard Index) of all biclusters. By default this measure is only based on column similarity.
This implies that the rows of the BC's are not of interest in this step. The goal then would be to discover highly overlapping column patterns and, in the next steps, merge them together.
</p>
</li>
<li><p> Apply Agglomerative Hierarchical Clustering on Similarity Matrix (default = average link)
</p>
</li>
<li><p> Cut the dendrogram of the clustering result and merge the biclusters based on this. (default = number of clusters is determined by the Tibs2001SEmax Gap Statistic)
</p>
</li>
<li><p> Extract Column Memberships of the Merged Biclusters. These are saved as the new column <em>Patterns</em>.
</p>
</li>
<li><p> Starting from these patterns, <em>(noisy) rows</em> are grown which match the pattern, creating a single final bicluster for each pattern. At the end duplicate/non-maximal BC's are deleted.
</p>
</li></ol>

<p>Using the described workflow (and column similarity in Step 2), the final result will contain biclusters which focus on larger column patterns.
</p>


<h3>Value</h3>

<p>A BiBitWorkflow S3 List Object with 3 slots:
</p>

<ul>
<li> <p><code>Biclust</code>: Biclust Class Object of Final Biclustering Result (after Step 6).
</p>
</li>
<li> <p><code>BiclustSim</code>: Jaccard Index Similarity Matrix of Final Biclustering Result (after Step 6).
</p>
</li>
<li> <p><code>info</code>: List Object containing:
</p>

<ul>
<li> <p><code>BiclustInitial</code>: Biclust Class Object of Initial Biclustering Result (after Step 1).
</p>
</li>
<li> <p><code>BiclustSimInitial</code>: Jaccard Index Similarity Matrix of Initial Biclustering Result (after Step 1).
</p>
</li>
<li> <p><code>Tree</code>: Hierarchical Tree of <code>BiclustSimInitial</code> as <code>hclust</code> object.
</p>
</li>
<li> <p><code>Number</code>: Vector containing the initial number of biclusters (<code>InitialNumber</code>), the number of saved patterns after cutting the tree (<code>PatternNumber</code>) and the final number of biclusters (<code>FinalNumber</code>).
</p>
</li>
<li> <p><code>GapStat</code>: Vector containing all different optimal cluster numbers based on the Gap Statistic.
</p>
</li>
<li> <p><code>BC.Merge</code>: A list (length of merged saved patterns) containing which biclusters were merged together after cutting the tree.
</p>
</li>
<li> <p><code>MergedColPatterns</code>: A list (length of merged saved patterns) containing the indices of which columns make up that pattern.
</p>
</li>
<li> <p><code>MergedNoiseThresholds</code>: A vector containing the selected noise levels for the merged saved patterns.
</p>
</li>
<li> <p><code>Coverage</code>: A list containing: 1. a vector of the total number (and percentage) of unique rows the final biclusters cover. 2. a table showing how many rows are used more than a single time in the final biclusters.
</p>
</li>
<li> <p><code>Call</code>: A match.call of the original function call.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Simulate Data ##
# DATA: 10000x50
# BC1: 200x10
# BC2: 100x10
# BC1 and BC2 overlap 5 columns

# BC3: 200x10
# BC4: 100x10
# BC3 and bC4 overlap 2 columns

# Background 1 percentage: 0.15
# BC Signal Percentage: 0.9
 
set.seed(273)
mat &lt;- matrix(sample(c(0,1),10000*50,replace=TRUE,prob=c(1-0.15,0.15)),
              nrow=10000,ncol=50)
mat[1:200,1:10] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                          nrow=200,ncol=10)
mat[300:399,6:15] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                            nrow=100,ncol=10)
mat[400:599,21:30] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=200,ncol=10)
mat[700:799,29:38] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=100,ncol=10)
mat &lt;- mat[sample(1:10000,10000,replace=FALSE),sample(1:50,50,replace=FALSE)]


# Computing gap statistic for initial 1381 BC takes approx. 15 min.
# Gap Statistic chooses 4 clusters. 
out &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.2) 
summary(out$Biclust)

# Reduce computation by selecting number of clusters manually.
# Note: The "ClusterRowCoverage" function can be used to provided extra info 
#       on the number of cluster choice.
#       How?
#       - More clusters result in smaller column patterns and more matching rows.
#       - Less clusters result in larger column patterns and less matching rows.
# Step 1: Initial Workflow Run
out2 &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.2,cut_type="number",cut_pm=10)
# Step 2: Use ClusterRowCoverage
temp &lt;- ClusterRowCoverage(result=out2,matrix=mat,noise=0.2,plots=2)
# Step 3: Use BiBitWorkflow again (using previously computed parts) with new cut parameter
out3 &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.2,cut_type="number",cut_pm=4,
                      BCresult = out2$info$BiclustInitial,
                      simmatresult = out2$info$BiclustSimInitial)
summary(out3$Biclust)

## End(Not run)
</code></pre>

<hr>
<h2 id='ClusterRowCoverage'>Row Coverage Plots</h2><span id='topic+ClusterRowCoverage'></span>

<h3>Description</h3>

<p>Plotting function to be used with the <code><a href="#topic+BiBitWorkflow">BiBitWorkflow</a></code> output. It plots the number of clusters (of the hierarchical tree) versus the number/percentage of row coverage and number of final biclusters (see Details for more information).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusterRowCoverage(result, matrix, maxCluster = 20, noise = 0.1,
  noise_select = 0, plots = c(1:3), verbose = TRUE,
  plot.type = "device", filename = "RowCoverage")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClusterRowCoverage_+3A_result">result</code></td>
<td>
<p>A BiBitWorkflow Object.</p>
</td></tr>
<tr><td><code id="ClusterRowCoverage_+3A_matrix">matrix</code></td>
<td>
<p>Accompanying binary data matrix which was used to obtain <code>result</code>.</p>
</td></tr>
<tr><td><code id="ClusterRowCoverage_+3A_maxcluster">maxCluster</code></td>
<td>
<p>Maximum number of clusters to cut the tree at (default=20).</p>
</td></tr>
<tr><td><code id="ClusterRowCoverage_+3A_noise">noise</code></td>
<td>
<p>The allowed noise level when growing the rows on the merged patterns after cutting the tree. (default=<code>0.1</code>, namely allow 10% noise.)
</p>

<ul>
<li> <p><code>noise=0</code>: No noise allowed.
</p>
</li>
<li> <p><code>0&lt;noise&lt;1</code>: The <code>noise</code> parameter will be a noise percentage. The number of allowed 0's in a row in the bicluster will depend on the column size of the bicluster.
More specifically <code>zeros_allowed = ceiling(noise * columnsize)</code>. For example for <code>noise=0.10</code> and a bicluster column size of <code>5</code>, the number of allowed 0's would be <code>1</code>.
</p>
</li>
<li> <p><code>noise&gt;=1</code>: The <code>noise</code> parameter will be the number of allowed 0's in a row in the bicluster independent from the column size of the bicluster. In this noise option, the noise parameter should be an integer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ClusterRowCoverage_+3A_noise_select">noise_select</code></td>
<td>
<p>Should the allowed noise level be automatically selected for each pattern? (Using ad hoc method to find the elbow/kink in the Noise Scree plots)
</p>

<ul>
<li> <p><code>noise_select=0</code>: Do <em>NOT</em> automatically select the noise levels. Use the the noise level given in the <code>noise</code> parameter (default)
</p>
</li>
<li> <p><code>noise_select=1</code>: Using the Noise Scree plot (with 'Added Rows' on the y-axis), find the noise level where the current number of added rows at this noise level is larger than the mean of 'added rows' at the lower noise levels. 
After locating this noise level, lower the noise level by 1. This is your automatically selected elbow/kink and therefore your noise level.
</p>
</li>
<li> <p><code>noise_select=2</code>: Applies the same steps as for <code>noise_select=1</code>, but instead of decreasing the noise level by only 1, keep decreasing the noise level until the number of added rows isn't decreasing anymore either.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ClusterRowCoverage_+3A_plots">plots</code></td>
<td>
<p>Vector for which plots to draw:
</p>

<ol>
<li><p> Number of Clusters versus Row Coverage Percentage
</p>
</li>
<li><p> Number of Clusters versus Number of Row Coverage
</p>
</li>
<li><p> Number of Clusters versus Final Number of Biclusters
</p>
</li></ol>
</td></tr>
<tr><td><code id="ClusterRowCoverage_+3A_verbose">verbose</code></td>
<td>
<p>Logical value if the progress bar of merging/growing the biclusters should be shown. (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="ClusterRowCoverage_+3A_plot.type">plot.type</code></td>
<td>
<p>Output Type
</p>

<ul>
<li> <p><code>"device"</code>: All plots are outputted to new R graphics devices (default).
</p>
</li>
<li> <p><code>"file"</code>: All plots are saved in external files. Plots are joint together in a single <code>.pdf</code> file.
</p>
</li>
<li> <p><code>"other"</code>: All plots are outputted to the current graphics device, but will overwrite each other. Use this if you want to include one or more plots in a sweave/knitr file or if you want to export a single plot by your own chosen format.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ClusterRowCoverage_+3A_filename">filename</code></td>
<td>
<p>Base filename (with/without directory) for the plots if <code>plot.type="file"</code> (default=<code>"RowCoverage"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph of number of chosen tree clusters versus the final row coverage can help you to make a decision on how many clusters to choose in the hierarchical tree. 
The more clusters you choose, the smaller (albeit more similar) the patterns are and the more rows will fit your patterns (i.e. more row coverage).
</p>


<h3>Value</h3>

<p>A data frame containing the number of clusters and the corresponding number of row coverage, percentage of row coverage and the number of final biclusters.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Prepare some data ##
set.seed(254)
mat &lt;- matrix(sample(c(0,1),5000*50,replace=TRUE,prob=c(1-0.15,0.15)),
              nrow=5000,ncol=50)
mat[1:200,1:10] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                          nrow=200,ncol=10)
mat[300:399,6:15] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                            nrow=100,ncol=10)
mat[400:599,21:30] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=200,ncol=10)
mat[700:799,29:38] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=100,ncol=10)
mat &lt;- mat[sample(1:5000,5000,replace=FALSE),sample(1:50,50,replace=FALSE)]

## Apply BiBitWorkflow ##
out &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.2,cut_type="number",cut_pm=10)
# Make ClusterRowCoverage Plots
ClusterRowCoverage(result=out,matrix=mat,maxCluster=20,noise=0.2)

## End(Not run)
</code></pre>

<hr>
<h2 id='ColInfo'>Column Info of Biclusters</h2><span id='topic+ColInfo'></span>

<h3>Description</h3>

<p>Function that returns which column labels are part of the pattern derived from the biclusters.
Additionally, a biclustmember plot and a general barplot of the column labels (retrieved from the biclusters) can be drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ColInfo(result, matrix, plots = c(1, 2), plot.type = "device",
  filename = "ColInfo")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ColInfo_+3A_result">result</code></td>
<td>
<p>A Biclust Object.</p>
</td></tr>
<tr><td><code id="ColInfo_+3A_matrix">matrix</code></td>
<td>
<p>Accompanying data matrix which was used to obtain <code>result</code>.</p>
</td></tr>
<tr><td><code id="ColInfo_+3A_plots">plots</code></td>
<td>
<p>Which plots to draw:
</p>

<ol>
<li><p> Barplot of number of appearances of column labels in bicluster results.
</p>
</li>
<li><p> Biclustmember plot of BC results (see <code><a href="biclust.html#topic+biclustmember">biclustmember</a></code>).
</p>
</li></ol>
</td></tr>
<tr><td><code id="ColInfo_+3A_plot.type">plot.type</code></td>
<td>
<p>Output Type
</p>

<ul>
<li> <p><code>"device"</code>: All plots are outputted to new R graphics devices (default).
</p>
</li>
<li> <p><code>"file"</code>: All plots are saved in external files. Plots are joint together in a single <code>.pdf</code> file.
</p>
</li>
<li> <p><code>"other"</code>: All plots are outputted to the current graphics device, but will overwrite each other. Use this if you want to include one or more plots in a sweave/knitr file or if you want to export a single plot by your own chosen format.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ColInfo_+3A_filename">filename</code></td>
<td>
<p>Base filename (with/without directory) for the plots if <code>plot.type="file"</code> (default=<code>"RowCoverage"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object (length equal to number of Biclusters) in which vectors of column labels are saved.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
data &lt;- data[sample(1:nrow(data),nrow(data)),sample(1:ncol(data),ncol(data))]
result &lt;- bibit(data,minr=5,minc=5)
ColInfo(result=result,matrix=data)

## End(Not run)
</code></pre>

<hr>
<h2 id='ColNoiseBC'>Barplots of Column Noise for Biclusters</h2><span id='topic+ColNoiseBC'></span>

<h3>Description</h3>

<p>Draws barplots of column noise of chosen biclusters. This plot can be helpful in determining which column label is often zero in noisy biclusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ColNoiseBC(result, matrix, BC = 1:result@Number, plot.type = "device",
  filename = "ColNoise")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ColNoiseBC_+3A_result">result</code></td>
<td>
<p>A Biclust Object.</p>
</td></tr>
<tr><td><code id="ColNoiseBC_+3A_matrix">matrix</code></td>
<td>
<p>Accompanying binary data matrix which was used to obtain <code>result</code>.</p>
</td></tr>
<tr><td><code id="ColNoiseBC_+3A_bc">BC</code></td>
<td>
<p>Numeric vector to select of which BC's a column noise bar plot should be drawn.</p>
</td></tr>
<tr><td><code id="ColNoiseBC_+3A_plot.type">plot.type</code></td>
<td>
<p>Output Type
</p>

<ul>
<li> <p><code>"device"</code>: All plots are outputted to new R graphics devices (default).
</p>
</li>
<li> <p><code>"file"</code>: All plots are saved in external files. Plots are joint together in a single <code>.pdf</code> file.
</p>
</li>
<li> <p><code>"other"</code>: All plots are outputted to the current graphics device, but will overwrite each other. Use this if you want to include one or more plots in a sweave/knitr file or if you want to export a single plot by your own chosen format.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ColNoiseBC_+3A_filename">filename</code></td>
<td>
<p>Base filename (with/without directory) for the plots if <code>plot.type="file"</code> (default=<code>"RowCoverage"</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
data &lt;- data[sample(1:nrow(data),nrow(data)),sample(1:ncol(data),ncol(data))]
result &lt;- bibit2(data,minr=5,minc=5,noise=1)
ColNoiseBC(result=result,matrix=data,BC=1:3)

## End(Not run)
</code></pre>

<hr>
<h2 id='CompareResultJI'>Compare Biclustering Results using Jaccard Index</h2><span id='topic+CompareResultJI'></span>

<h3>Description</h3>

<p>Creates a heatmap and returns a similarity matrix of the Jaccard Index (Row, Column or both dimensions) in order to compare 2 different biclustering results or compare the biclusters of a single result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareResultJI(BCresult1, BCresult2 = NULL, type = "both", plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareResultJI_+3A_bcresult1">BCresult1</code></td>
<td>
<p>A S4 Biclust object. If only this input Biclust object is given, the biclusters of this single result will be compared.</p>
</td></tr>
<tr><td><code id="CompareResultJI_+3A_bcresult2">BCresult2</code></td>
<td>
<p>A second S4 Biclust object to which <code>BCresult1</code> should be compared. (default=<code>NULL</code>)</p>
</td></tr>
<tr><td><code id="CompareResultJI_+3A_type">type</code></td>
<td>
<p>Of which dimension should the Jaccard Index be computed? Can be <code>"row"</code>, <code>"col"</code> or <code>"both"</code> (default).</p>
</td></tr>
<tr><td><code id="CompareResultJI_+3A_plot">plot</code></td>
<td>
<p>Logical value if plot should be outputted (default=<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jaccard Index between two biclusters is calculated as following:
</p>
<p style="text-align: center;"><code class="reqn">JI(BC1,BC2) = \frac{(m_1+m_2-m_{12})}{m_{12}}</code>
</p>

<p>in which
</p>

<ul>
<li> <p><code>type="row"</code> or <code>type="col"</code>   
</p>

<ul>
<li> <p><code class="reqn">m_1=</code> Number of rows/columns of BC1
</p>
</li>
<li> <p><code class="reqn">m_2=</code> Number of rows/columns of BC2
</p>
</li>
<li> <p><code class="reqn">m_{12}=</code> Number of rows/columns of union of row/column membership of BC1 and BC2
</p>
</li></ul>

</li>
<li> <p><code>type="both"</code>
</p>

<ul>
<li> <p><code class="reqn">m_1=</code> Size of BC1 (rows times columns)
</p>
</li>
<li> <p><code class="reqn">m_2=</code> Size of BC2 (rows times columns)
</p>
</li>
<li> <p><code class="reqn">m_{12}= m_1+m_2 -</code> size of overlapping BC of BC1 and BC2 
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>SimMat</code>: The JI Similarity Matrix between the compared biclusters.
</p>
</li>
<li> <p><code>MaxSim</code>: A list containing the maximum values on each row (<code>BCResult1</code>) and each column (<code>BCResult2</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
data &lt;- data[sample(1:nrow(data),nrow(data)),sample(1:ncol(data),ncol(data))]

# Result 1
result1 &lt;- bibit(data,minr=5,minc=5)
result1

# Result 2
result2 &lt;- bibit(data,minr=2,minc=2)
result2

## Compare all BC's of Result 1 ##
Sim1 &lt;- CompareResultJI(BCresult1=result1,type="both")
Sim1$SimMat

## Compare BC's of Result 1 and 2 ##
Sim12 &lt;- CompareResultJI(BCresult1=result1,BCresult2=result2,type="both",plot=FALSE)
str(Sim12)

## End(Not run)
</code></pre>

<hr>
<h2 id='make_arff_row_col'>Transform R matrix object to BiBit input files.</h2><span id='topic+make_arff_row_col'></span>

<h3>Description</h3>

<p>Transform the R matrix object to 1 <code>.arff</code> for the data and 2 <code>.csv</code> files for the row and column names. These are the 3 files required for the original BiBit Java algorithm
The path of these 3 files can then be used in the <code>arff_row_col</code> parameter of the <code>bibit</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_arff_row_col(matrix, name = "data", path = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_arff_row_col_+3A_matrix">matrix</code></td>
<td>
<p>The binary input matrix.</p>
</td></tr>
<tr><td><code id="make_arff_row_col_+3A_name">name</code></td>
<td>
<p>Basename for the 3 input files.</p>
</td></tr>
<tr><td><code id="make_arff_row_col_+3A_path">path</code></td>
<td>
<p>Directory path where to write the 3 input files to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3 input files for BiBit:
</p>

<ul>
<li><p> One <code>.arff</code> file containing the data.
</p>
</li>
<li><p> One <code>.csv</code> file for the row names. The file contains 1 column of names without quotation.
</p>
</li>
<li><p> One <code>.csv</code> file for the column names. The file contains 1 column of names without quotation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
data &lt;- data[sample(1:nrow(data),nrow(data)),sample(1:ncol(data),ncol(data))]

make_arff_row_col(matrix=data,name="data",path="")

result &lt;- bibit(data,minr=5,minc=5,
                arff_row_col=c("data_arff.arff","data_rownames.csv","data_colnames.csv"))

## End(Not run)
</code></pre>

<hr>
<h2 id='MaxBC'>Finding Maximum Size Biclusters</h2><span id='topic+MaxBC'></span>

<h3>Description</h3>

<p>Simple function which scans a <code>Biclust</code> result and returns which biclusters have maximum row, column or size (row*column).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxBC(result, top = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaxBC_+3A_result">result</code></td>
<td>
<p>A <code>Biclust</code> result. (e.g. The return object from <code>bibit</code> or <code>bibit2</code>)</p>
</td></tr>
<tr><td><code id="MaxBC_+3A_top">top</code></td>
<td>
<p>The number of top row/col/size dimension which are searched for. (e.g. default <code>top=1</code> gives only the maximum)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>$row</code>: A matrix containing in the columns the Biclusters which had maximum rows, and in the rows the Row Dimension, Column Dimension and Size.
</p>
</li>
<li> <p><code>$column</code>: A matrix containing in the columns the Biclusters which had maximum columns, and in the rows the Row Dimension, Column Dimension and Size.
</p>
</li>
<li> <p><code>$size</code>: A matrix containing in the columns the Biclusters which had maximum size, and in the rows the Row Dimension, Column Dimension and Size.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- matrix(sample(c(0,1),100*100,replace=TRUE,prob=c(0.9,0.1)),nrow=100,ncol=100)
data[1:10,1:10] &lt;- 1 # BC1
data[11:20,11:20] &lt;- 1 # BC2
data[21:30,21:30] &lt;- 1 # BC3
data &lt;- data[sample(1:nrow(data),nrow(data)),sample(1:ncol(data),ncol(data))]
result &lt;- bibit(data,minr=2,minc=2)

MaxBC(result)


## End(Not run)
</code></pre>

<hr>
<h2 id='NoiseScree'>Noise Scree Plots</h2><span id='topic+NoiseScree'></span>

<h3>Description</h3>

<p>Extract patterns from either a Biclust or BiBitWorkflow object (see Details) and plot the Noise Scree plot (same as plot 4 in <code><a href="#topic+BiBitWorkflow">BiBitWorkflow</a></code>). Additionally, if <code>FisherResult</code> is available (from <code><a href="#topic+RowTest_Fisher">RowTest_Fisher</a></code>), this info will be added to the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NoiseScree(result, matrix, type = c("Added", "Total"), pattern = NULL,
  noise_select = 0, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NoiseScree_+3A_result">result</code></td>
<td>
<p>A Biclust or BiBitWorkflow Object.</p>
</td></tr>
<tr><td><code id="NoiseScree_+3A_matrix">matrix</code></td>
<td>
<p>Accompanying binary data matrix which was used to obtain <code>result</code>.</p>
</td></tr>
<tr><td><code id="NoiseScree_+3A_type">type</code></td>
<td>
<p>Either <code>"Added"</code> or <code>"Total"</code>. Should the noise level be plotted against the number of added rows (at that noise level) or the total number of rows (up to that noise level)?</p>
</td></tr>
<tr><td><code id="NoiseScree_+3A_pattern">pattern</code></td>
<td>
<p>Numeric vector for which patterns the noise scree plot should be drawn (default = all patterns).</p>
</td></tr>
<tr><td><code id="NoiseScree_+3A_noise_select">noise_select</code></td>
<td>
<p>Should an automatic noise selection be applied and drawn (blue vertical line) on the plot? (Using ad hoc method to find the elbow/kink in the Noise Scree plots)
</p>

<ul>
<li> <p><code>noise_select=0</code>: No noise selection is applied and no line is drawn (default).
</p>
</li>
<li> <p><code>noise_select=1</code>: Using the Noise Scree plot (with 'Added Rows' on the y-axis), find the noise level where the current number of added rows at this noise level is larger than the mean of 'added rows' at the lower noise levels. 
After locating this noise level, lower the noise level by 1. This is your automatically selected elbow/kink and therefore your noise level.
</p>
</li>
<li> <p><code>noise_select=2</code>: Applies the same steps as for <code>noise_select=1</code>, but instead of decreasing the noise level by only 1, keep decreasing the noise level until the number of added rows isn't decreasing anymore either.
</p>
</li></ul>
</td></tr>
<tr><td><code id="NoiseScree_+3A_alpha">alpha</code></td>
<td>
<p>If info from the Fisher Exact test is available, which significance level should be used to in the plot (Noise versus Significant Fisher Exact Test rows). (default=0.05)</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><em>Biclust S4 Object</em></dt><dd>
<p>Using the column patterns of the Biclust result, the noise level is plotted versus the number of <code>"Total"</code> or <code>"Added"</code> rows.
</p>
</dd>
<dt><em>BiBitWorkflow S3 Object</em></dt><dd>
<p>The merged column patterns (after cutting the hierarchical tree) are extracted from the BiBitWorkflow object, namely the <code>$info$MergedColPatterns</code> slot. 
These patterns are used to plot the noise level versus the number of <code>"Total"</code> or <code>"Added"</code> rows.
</p>
</dd>
</dl>

<p>If information on the Fisher Exact Test is available, then this info will added to the plot (noise level versus significant rows).
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Prepare some data ##
set.seed(254)
mat &lt;- matrix(sample(c(0,1),5000*50,replace=TRUE,prob=c(1-0.15,0.15)),
              nrow=5000,ncol=50)
mat[1:200,1:10] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                          nrow=200,ncol=10)
mat[300:399,6:15] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                            nrow=100,ncol=10)
mat[400:599,21:30] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=200,ncol=10)
mat[700:799,29:38] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=100,ncol=10)
mat &lt;- mat[sample(1:5000,5000,replace=FALSE),sample(1:50,50,replace=FALSE)]

## Apply BiBitWorkflow ##
out &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.2,cut_type="number",cut_pm=4)
# Make Noise Scree Plot - Default
NoiseScree(result=out,matrix=mat,type="Added")
NoiseScree(result=out,matrix=mat,type="Total")
# Make Noise Scree Plot - Use Automatic Noies Selection
NoiseScree(result=out,matrix=mat,type="Added",noise_select=2)
NoiseScree(result=out,matrix=mat,type="Total",noise_select=2)

## Apply RowTest_Fisher on BiBitWorkflow Object ##
out2 &lt;- RowTest_Fisher(result=out,matrix=mat)
# Fisher output is added to "NoiseScree" plot
NoiseScree(result=out2,matrix=mat,type="Added")
NoiseScree(result=out2,matrix=mat,type="Total")

## End(Not run)
</code></pre>

<hr>
<h2 id='RowTest_Fisher'>Apply Fisher Exact Test on Bicluster Rows</h2><span id='topic+RowTest_Fisher'></span>

<h3>Description</h3>

<p>Accepts a Biclust or BiBitWorkflow result and applies the Fisher Exact Test for each row (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RowTest_Fisher(result, matrix, p.adjust = "BH", alpha = 0.05,
  pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RowTest_Fisher_+3A_result">result</code></td>
<td>
<p>A Biclust or BiBitWorkflow Object.</p>
</td></tr>
<tr><td><code id="RowTest_Fisher_+3A_matrix">matrix</code></td>
<td>
<p>Accompanying binary data matrix which was used to obtain <code>result</code>.</p>
</td></tr>
<tr><td><code id="RowTest_Fisher_+3A_p.adjust">p.adjust</code></td>
<td>
<p>Which method to use when adjusting p-values, see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> (default=<code>"BH"</code>).</p>
</td></tr>
<tr><td><code id="RowTest_Fisher_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (adjusted p-values) when constructing the <code>FisherInfo</code> object (default=0.05).</p>
</td></tr>
<tr><td><code id="RowTest_Fisher_+3A_pattern">pattern</code></td>
<td>
<p>Numeric vector for which patterns/biclusters the Fisher Exact Test needs to be computed (default = all patterns/biclusters).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracts the patterns from either a <code>Biclust</code> or <code>BiBitWorkflow</code> object (see below). 
Afterwards for each pattern all rows will be tested using the Fisher Exact Test. This test compares the part of the row inside the pattern (of the bicluster) with the part of the row outside the pattern.
The Fisher Exact Test gives you some information on if the row is uniquely active for this pattern.
</p>
<p>Depending on the <code>result</code> input, different patterns will be extract and different info will be returned:
</p>

<dl>
<dt><em>Biclust S4 Object</em></dt><dd>
<p>Using the column patterns of the Biclust result, all rows are tested using the Fisher Exact Test. 
Afterwards the following 2 objects are added to the <code>info</code> slot of the Biclust object:
</p>

<ul>
<li> <p><code>FisherResult</code>: A list object (one element for each pattern) of data frames (Number of Rows <code class="reqn">\times</code> 6) which contain the names of the rows (<code>Names</code>), the noise level of the row inside the pattern (<code>Noise</code>), the signal percentage inside the pattern (<code>InsidePerc1</code>), the signal percentage outside the pattern (<code>OutsidePerc1</code>), the p-value of the Fisher Exact Test (<code>Fisher_pvalue</code>) and the adjusted p-value of the Fisher Exact Test (<code>Fisher_pvalue_adj</code>).
</p>
</li>
<li> <p><code>FisherInfo</code>: Info object which contains a comparison of the current row membership for each pattern with a 'new' row membership based on the significant rows (from the Fisher Exact Test) for each pattern.
It is a list object (one element for each pattern) of lists (6 elements). These list objects per pattern contain the number of new, removed and identical rows (<code>NewRows</code>, <code>RemovedRows</code>, <code>SameRows</code>) when comparing the significant rows with the original row membership (as well as their indices (<code>NewRows_index</code>, <code>RemovedRows_index</code>)). The <code>MaxNoise</code> element contains the maximum noise of all Fisher significant rows. 
</p>
</li></ul>
 
</dd>
<dt><em>BiBitWorkflow S3 Object</em></dt><dd> 
<p>The merged column patterns (after cutting the hierarchical tree) are extracted from the BiBitWorkflow object, namely the <code>$info$MergedColPatterns</code> slot. 
Afterwards the following object is added to the <code>$info</code> slot of the BiBitWorkflow object:
</p>

<ul>
<li> <p><code>FisherResult</code>: Same as above
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>Depending on <code>result</code>, a <code>FisherResult</code> and/or <code>FisherInfo</code> object will be added to the <code>result</code> and returned (see Details).
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Prepare some data ##
set.seed(254)
mat &lt;- matrix(sample(c(0,1),5000*50,replace=TRUE,prob=c(1-0.15,0.15)),
              nrow=5000,ncol=50)
mat[1:200,1:10] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                          nrow=200,ncol=10)
mat[300:399,6:15] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                            nrow=100,ncol=10)
mat[400:599,21:30] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=200,ncol=10)
mat[700:799,29:38] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=100,ncol=10)
mat &lt;- mat[sample(1:5000,5000,replace=FALSE),sample(1:50,50,replace=FALSE)]

## Apply BiBitWorkflow ##
out &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.2,cut_type="number",cut_pm=4)

## Apply RowTest_Fisher on Biclust Object -&gt; returns Biclust Object ##
out_new &lt;- RowTest_Fisher(result=out$Biclust,matrix=mat)
# FisherResult output in info slot
str(out_new@info$FisherResult)
# FisherInfo output in info slot (comparison with original BC's)
str(out_new@info$FisherInfo)


## Apply RowTest_Fisher on BiBitWorkflow Object -&gt; returns BiBitWorkflow Object ##
out_new2 &lt;- RowTest_Fisher(result=out,matrix=mat)
# FisherResult output in BiBitWorkflow info element
str(out_new2$info$FisherResult)
# Fisher output is added to "NoiseScree" plot
NoiseScree(result=out_new2,matrix=mat,type="Added")

## End(Not run)
</code></pre>

<hr>
<h2 id='summary+2CBiclust-method'>Summary Method for Biclust Class</h2><span id='topic+summary+2CBiclust-method'></span>

<h3>Description</h3>

<p>Summary Method for Biclust Class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Biclust'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CBiclust-method_+3A_object">object</code></td>
<td>
<p>Biclust S4 Object</p>
</td></tr>
</table>

<hr>
<h2 id='UpdateBiclust_RowNoise'>Update a Biclust or BiBitWorkflow Object with a new Noise Level</h2><span id='topic+UpdateBiclust_RowNoise'></span>

<h3>Description</h3>

<p>Apply a new noise level on a Biclust object result or BiBitWorkflow result. See Details on how both objects are affected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateBiclust_RowNoise(result, matrix, noise = 0.1, noise_select = 0,
  removeBC = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpdateBiclust_RowNoise_+3A_result">result</code></td>
<td>
<p>A Biclust or BiBitWorkflow Object.</p>
</td></tr>
<tr><td><code id="UpdateBiclust_RowNoise_+3A_matrix">matrix</code></td>
<td>
<p>Accompanying binary data matrix which was used to obtain <code>result</code>.</p>
</td></tr>
<tr><td><code id="UpdateBiclust_RowNoise_+3A_noise">noise</code></td>
<td>
<p>The new noise level which should be used in the rows of the biclusters. (default=<code>0.1</code>, namely allow 10% noise.).
</p>

<ul>
<li> <p><code>noise=0</code>: No noise allowed.
</p>
</li>
<li> <p><code>0&lt;noise&lt;1</code>: The <code>noise</code> parameter will be a noise percentage. The number of allowed 0's in a row in the bicluster will depend on the column size of the bicluster.
More specifically <code>zeros_allowed = ceiling(noise * columnsize)</code>. For example for <code>noise=0.10</code> and a bicluster column size of <code>5</code>, the number of allowed 0's would be <code>1</code>.
</p>
</li>
<li> <p><code>noise&gt;=1</code>: The <code>noise</code> parameter will be the number of allowed 0's in a row in the bicluster independent from the column size of the bicluster. In this noise option, the noise parameter should be an integer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="UpdateBiclust_RowNoise_+3A_noise_select">noise_select</code></td>
<td>
<p>Should the allowed noise level be automatically selected for each pattern? (Using ad hoc method to find the elbow/kink in the Noise Scree plots)
</p>

<ul>
<li> <p><code>noise_select=0</code>: Do <em>NOT</em> automatically select the noise levels. Use the the noise level given in the <code>noise</code> parameter (default)
</p>
</li>
<li> <p><code>noise_select=1</code>: Using the Noise Scree plot (with 'Added Rows' on the y-axis), find the noise level where the current number of added rows at this noise level is larger than the mean of 'added rows' at the lower noise levels. 
After locating this noise level, lower the noise level by 1. This is your automatically selected elbow/kink and therefore your noise level.
</p>
</li>
<li> <p><code>noise_select=2</code>: Applies the same steps as for <code>noise_select=1</code>, but instead of decreasing the noise level by only 1, keep decreasing the noise level until the number of added rows isn't decreasing anymore either.
</p>
</li></ul>
</td></tr>
<tr><td><code id="UpdateBiclust_RowNoise_+3A_removebc">removeBC</code></td>
<td>
<p><em>(Only applicable when result is a Biclust object)</em> Logical value if after applying a new noise level, duplicate and non-maximal BC's should be deleted.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><em>Biclust S4 Object</em></dt><dd>
<p>Using the column patterns of the Biclust result, new grows are grown using the inputted <code>noise</code> level.
The <code>removeBC</code> parameter decides if duplicate and non-maximal BC's should be deleted. Afterwards a new <code>Biclust</code> S4 object is returned with the new biclusters.
</p>
</dd>
<dt><em>BiBitWorkflow S3 Object</em></dt><dd>
<p>The merged column patterns (after cutting the hierarchical tree) are extracted from the BiBitWorkflow object, namely the <code>$info$MergedColPatterns</code> slot. 
Afterwards, using the new <code>noise</code> level, new rows are grown and the returned object is an updated <code>BiBitWorkflow</code> object. (e.g. The final Biclust slot, MergedNoiseThresholds, coverage,etc. are updated)
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>Biclust</code> or <code>BiBitWorkflow</code> Object (See Details)
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Prepare some data ##
set.seed(254)
mat &lt;- matrix(sample(c(0,1),5000*50,replace=TRUE,prob=c(1-0.15,0.15)),
              nrow=5000,ncol=50)
mat[1:200,1:10] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                          nrow=200,ncol=10)
mat[300:399,6:15] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                            nrow=100,ncol=10)
mat[400:599,21:30] &lt;- matrix(sample(c(0,1),200*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=200,ncol=10)
mat[700:799,29:38] &lt;- matrix(sample(c(0,1),100*10,replace=TRUE,prob=c(1-0.9,0.9)),
                             nrow=100,ncol=10)
mat &lt;- mat[sample(1:5000,5000,replace=FALSE),sample(1:50,50,replace=FALSE)]

## Apply BiBitWorkflow ##
out &lt;- BiBitWorkflow(matrix=mat,minr=50,minc=5,noise=0.1,cut_type="number",cut_pm=4)
summary(out$Biclust)

## Update Rows with new noise level on Biclust Obect -&gt; returns Biclust Object ##
out_new &lt;- UpdateBiclust_RowNoise(result=out$Biclust,matrix=mat,noise=0.3)
summary(out_new)
out_new@info$Noise.Threshold # New Noise Levels

## Update Rows with new noise level on BiBitWorkflow Obect -&gt; returns BiBitWorkflow Object ##
out_new2 &lt;- UpdateBiclust_RowNoise(result=out,matrix=mat,noise=0.2)
summary(out_new2$Biclust)
out_new2$info$MergedNoiseThresholds # New Noise Levels

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
