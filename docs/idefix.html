<!DOCTYPE html><html><head><title>Help for package idefix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {idefix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#idefix-package'><p>idefix: efficient designs for discrete choice experiments.</p></a></li>
<li><a href='#aggregate_design'><p>Discrete choice aggregate design.</p></a></li>
<li><a href='#CEA'><p>Coordinate Exchange algorithm for MNL models.</p></a></li>
<li><a href='#Datatrans'><p>Data transformation.</p></a></li>
<li><a href='#DBerr'><p>DB error</p></a></li>
<li><a href='#Decode'><p>Coded design to readable design.</p></a></li>
<li><a href='#example_design'><p>Discrete choice design.</p></a></li>
<li><a href='#example_design2'><p>Discrete choice design.</p></a></li>
<li><a href='#ImpsampMNL'><p>Importance sampling MNL</p></a></li>
<li><a href='#LoadData'><p>Load numeric choice data from directory</p></a></li>
<li><a href='#Modfed'><p>Modified Fedorov algorithm for MNL models.</p></a></li>
<li><a href='#nochoice_design'><p>Discrete choice design with no choice option.</p></a></li>
<li><a href='#Profiles'><p>Profiles generation.</p></a></li>
<li><a href='#RespondMNL'><p>Response generation</p></a></li>
<li><a href='#SeqCEA'><p>Sequential Coordinate Exchange algorithm for MNL model.</p></a></li>
<li><a href='#SeqKL'><p>Sequential Kullback-Leibler based algorithm for the MNL model.</p></a></li>
<li><a href='#SeqMOD'><p>Sequential modified federov algorithm for MNL model.</p></a></li>
<li><a href='#SurveyApp'><p>Shiny application to generate a discrete choice survey.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Designs for Discrete Choice Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frits Traets &lt;frits.traets@kuleuven.be&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates efficient designs for discrete choice experiments based on the multinomial logit model, and individually adapted designs for the mixed multinomial logit model. The generated designs can be presented on screen and choice data can be gathered using a shiny application. Traets F, Sanchez G, and Vandebroek M (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v096.i03">doi:10.18637/jss.v096.i03</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1), shiny</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, MASS, parallel, Rcpp (&ge; 0.12.18), Rdpack, stats,
scales, tmvtnorm, utils, dfidx</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/traets/idefix">https://github.com/traets/idefix</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>RSGHB, bayesm, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-28 08:41:08 UTC; u0105757</td>
</tr>
<tr>
<td>Author:</td>
<td>Frits Traets [aut, cre],
  Daniel Gil [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-28 12:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='idefix-package'>idefix: efficient designs for discrete choice experiments.</h2><span id='topic+idefix'></span><span id='topic+idefix-package'></span>

<h3>Description</h3>

<p>Generates efficient designs for discrete choice experiments based on the
Multinomial Logit (MNL) model, and individually adapted designs for the Mixed
Multinomial Logit model. The (adaptive) designs can be presented on screen and
choice data can be gathered using a shiny application.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Frits Traets <a href="mailto:frits.traets@kuleuven.be">frits.traets@kuleuven.be</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Daniel Gil <a href="mailto:danielgils@gmail.com">danielgils@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Traets F, Sanchez G, Vandebroek M (2020).
&ldquo;Generating Optimal Designs for Discrete Choice Experiments in R: The idefix Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>96</b>(3).
</p>

<ul>
<li><p> To generate efficient designs using the Modified Federov algorithm, please consult the <a href="#topic+Modfed">Modfed</a> documentation.
</p>
</li>
<li><p> To generate efficient designs using the Coordinate Exchange algorithm,
please consult the <a href="#topic+CEA">CEA</a> documentation.
</p>
</li>
<li><p> To generate adaptive designs using the Modified Fedorov algorithm,
please consult the <a href="#topic+SeqMOD">SeqMOD</a> documentation.
</p>
</li>
<li><p> To generate adaptive designs using the Coordinate Exchange algorithm,
please consult the <a href="#topic+SeqCEA">SeqCEA</a> documentation.
</p>
</li>
<li><p> To generate a discrete choice survey on screen, please consult the <a href="#topic+SurveyApp">SurveyApp</a> documentation.
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/traets/idefix">https://github.com/traets/idefix</a>
</p>
</li></ul>


<hr>
<h2 id='aggregate_design'>Discrete choice aggregate design.</h2><span id='topic+aggregate_design'></span>

<h3>Description</h3>

<p>The dataset contains fictional data for seven participants, each
responding to eight choice sets with two alternatives. Each alternative
consists of three attributes, and each attribute contains three levels, which
are dummy coded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aggregate_design)
</code></pre>


<h3>Format</h3>

<p>A matrix with 112 rows and 9 variables
</p>

<hr>
<h2 id='CEA'>Coordinate Exchange algorithm for MNL models.</h2><span id='topic+CEA'></span>

<h3>Description</h3>

<p>The algorithm improves an initial start design by considering changes on an
attribute-by-attribute basis. By doing this, it tries to minimize the
D(B)-error based on a multinomial logit model. This routine is repeated for
multiple starting designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEA(
  lvls,
  coding,
  c.lvls = NULL,
  n.sets,
  n.alts,
  par.draws,
  alt.cte = NULL,
  no.choice = FALSE,
  start.des = NULL,
  parallel = TRUE,
  max.iter = Inf,
  n.start = 12,
  best = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEA_+3A_lvls">lvls</code></td>
<td>
<p>A numeric vector which contains for each attribute the number
of levels.</p>
</td></tr>
<tr><td><code id="CEA_+3A_coding">coding</code></td>
<td>
<p>Type of coding that needs to be used for each attribute.</p>
</td></tr>
<tr><td><code id="CEA_+3A_c.lvls">c.lvls</code></td>
<td>
<p>A list containing numeric vectors with the attribute levels for
each continuous attribute. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CEA_+3A_n.sets">n.sets</code></td>
<td>
<p>Numeric value indicating the number of choice sets.</p>
</td></tr>
<tr><td><code id="CEA_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="CEA_+3A_par.draws">par.draws</code></td>
<td>
<p>A matrix or a list, depending on <code>alt.cte</code>.</p>
</td></tr>
<tr><td><code id="CEA_+3A_alt.cte">alt.cte</code></td>
<td>
<p>A binary vector indicating for each alternative whether an
alternative specific constant is desired. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CEA_+3A_no.choice">no.choice</code></td>
<td>
<p>A logical value indicating whether a no choice alternative
should be added to each choice set. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CEA_+3A_start.des">start.des</code></td>
<td>
<p>A list containing one or more matrices corresponding to
initial start design(s). The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CEA_+3A_parallel">parallel</code></td>
<td>
<p>Logical value indicating whether computations should be done
over multiple cores. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CEA_+3A_max.iter">max.iter</code></td>
<td>
<p>A numeric value indicating the maximum number allowed
iterations. The default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="CEA_+3A_n.start">n.start</code></td>
<td>
<p>A numeric value indicating the number of random start designs
to use. The default is 12.</p>
</td></tr>
<tr><td><code id="CEA_+3A_best">best</code></td>
<td>
<p>A logical value indicating whether only the best design should be
returned. The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each iteration will loop through all profiles from the initial design,
evaluating the change in D(B)-error for every level in each attribute.
The algorithm stops when an iteration occured without replacing a profile or
when <code>max.iter</code> is reached.
</p>
<p>By specifying a numeric vector in <code>par.draws</code>, the D-error will be
calculated and the design will be optimised locally. By specifying a matrix,
in which each row is a draw from a multivariate distribution, the DB-error
will be calculated, and the design will be optimised globally. Whenever there
are alternative specific constants, <code>par.draws</code> should be a list
containing two matrices: The first matrix containing the parameter draws for
the alternative specific constant parameters. The second matrix containing
the draws for the rest of the parameters.
</p>
<p>The DB-error is calculated by taking the mean over D-errors. It could be that
for some draws the design results in an infinite D-error. The percentage of
draws for which this was true for the final design can be found in the output
<code>inf.error</code>.
</p>
<p>Alternative specific constants can be specified in <code>alt.cte</code>. The length
of this binary vector should equal <code>n.alts</code>, were <code>0</code> indicates the
absence of an alternative specific constant and <code>1</code> the opposite.
</p>
<p><code>start.des</code> is a list with one or several matrices corresponding to
initial start design(s). In each matrix each row is a profile. The number of rows
equals <code>n.sets * n.alts</code>, and the
number of columns equals the number of columns of the design matrix + the
number of non-zero elements in <code>alt.cte</code>. Consider that for a
categorical attribute with <em>p</em> levels, there are <em>p - 1</em> columns in the design
matrix, whereas for a continuous attribute there is only one column. If
<code>start.des = NULL</code>, <code>n.start</code> random initial designs will be
generated. If start designs are provided, <code>n.start</code> is ignored.
</p>
<p>If <code>no.choice</code> is <code>TRUE</code>, in each choice set an alternative with
one alternative specific constant is added. The return value of the
D(B)-error is however based on the design without the no choice option.
</p>
<p>When <code>parallel</code> is <code>TRUE</code>, <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will
be used to decide upon the number of available cores. That number minus 1
cores will be used to search for efficient designs. The computation time will
decrease significantly when <code>parallel = TRUE</code>.
</p>


<h3>Value</h3>

<p>If <code>best = TRUE</code> the design with the lowest D(B)-error is returned.
If <code>best = FALSE</code>, the results of all (provided) start designs are
returned. </p>
<table>
<tr><td><code>design</code></td>
<td>
<p>A
numeric matrix wich contains an efficient design.</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>Numeric
value indicating the D(B)-error of the design.</p>
</td></tr> <tr><td><code>inf.error</code></td>
<td>
<p>Numeric
value indicating the percentage of draws for which the D-error was
<code>Inf</code>.</p>
</td></tr> <tr><td><code>probs</code></td>
<td>
<p>Numeric matrix containing the probabilities of
each alternative in each choice set. If a sample matrix was provided in
<code>par.draws</code>, this is the average over all draws.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# DB-efficient designs
# 3 Attributes, all dummy coded. 1 alternative specific constant = 7 parameters
mu &lt;- c(1.2, 0.8, 0.2, -0.3, -1.2, 1.6, 2.2) # Prior parameter vector
v &lt;- diag(length(mu)) # Prior variance.
set.seed(123) 
pd &lt;- MASS::mvrnorm(n = 10, mu = mu, Sigma = v) # 10 draws.
p.d &lt;- list(matrix(pd[,1], ncol = 1), pd[,2:7])
CEA(lvls = c(3, 3, 3), coding = c("D", "D", "D"), par.draws = p.d,
n.alts = 2, n.sets = 8, parallel = FALSE, alt.cte = c(0, 1))

# DB-efficient design with categorical and continuous factors
# 2 categorical attributes with 4 and 2 levels (effect coded) and 1 
# continuous attribute (= 5 parameters)
mu &lt;- c(0.5, 0.8, 0.2, 0.4, 0.3) 
v &lt;- diag(length(mu)) # Prior variance.
set.seed(123) 
pd &lt;- MASS::mvrnorm(n = 3, mu = mu, Sigma = v) # 10 draws.
CEA(lvls = c(4, 2, 3), coding = c("E", "E", "C"), par.draws = pd,
c.lvls = list(c(2, 4, 6)), n.alts = 2, n.sets = 6, parallel = FALSE)

# DB-efficient design with start design provided.  
# 3 Attributes with 3 levels, all dummy coded (= 6 parameters).
mu &lt;- c(0.8, 0.2, -0.3, -0.2, 0.7, 0.4) 
v &lt;- diag(length(mu)) # Prior variance.
sd &lt;- list(example_design)
set.seed(123)
ps &lt;- MASS::mvrnorm(n = 10, mu = mu, Sigma = v) # 10 draws.
CEA(lvls = c(3, 3, 3), coding = c("D", "D", "D"), par.draws = ps,
n.alts = 2, n.sets = 8, parallel = FALSE, start.des = sd)

</code></pre>

<hr>
<h2 id='Datatrans'>Data transformation.</h2><span id='topic+Datatrans'></span>

<h3>Description</h3>

<p>Transforms the data into the desired data format required by different
estimation packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Datatrans(pkg, des, y, n.alts, n.sets, n.resp, bin, alt.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Datatrans_+3A_pkg">pkg</code></td>
<td>
<p>Indicates the desired estimation package. Options are
<code>bayesm = <a href="bayesm.html#topic+rhierMnlRwMixture">rhierMnlRwMixture</a></code>, <code>RSGHB = <a href="RSGHB.html#topic+doHB">doHB</a></code>,
<code>Mixed.Probit = <a href="bayesm.html#topic+rbprobitGibbs">rbprobitGibbs</a></code>, <code>mlogit = 
  <a href="mlogit.html#topic+mlogit">mlogit</a></code>, <code>logitr = <a href="logitr.html#topic+logitr">logitr</a></code>).</p>
</td></tr>
<tr><td><code id="Datatrans_+3A_des">des</code></td>
<td>
<p>A design matrix in which each row is a profile.</p>
</td></tr>
<tr><td><code id="Datatrans_+3A_y">y</code></td>
<td>
<p>A numeric vector containing binary or discrete responses. See <code>bin</code> argument.</p>
</td></tr>
<tr><td><code id="Datatrans_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="Datatrans_+3A_n.sets">n.sets</code></td>
<td>
<p>Numeric value indicating the number of choice sets.</p>
</td></tr>
<tr><td><code id="Datatrans_+3A_n.resp">n.resp</code></td>
<td>
<p>Numeric value indicating the number of respondents.</p>
</td></tr>
<tr><td><code id="Datatrans_+3A_bin">bin</code></td>
<td>
<p>Logical value indicating whether the reponse vector contains
binary data (<code>TRUE</code>) or discrete data (<code>FALSE</code>). See <code>y</code> argument.</p>
</td></tr>
<tr><td><code id="Datatrans_+3A_alt.names">alt.names</code></td>
<td>
<p>A character vector containing the names of the alternatives.
The default = <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The design (<code>des</code>) specified should be the full aggregated design.
Thus, if all participants responded to the same design, <code>des</code> will be a repetition of
that design matrix.
</p>
<p>The responses in <code>y</code> should be successive when there are multiple
respondents. There can be <code>n.sets</code> elements for each respondent with
discrete values indicating the chosen alternative for each set. Or there can
be <code>n.sets * n.alts</code> elements for each respondent with binary values
indicating for each alternative whether it was chosen or not. In the latter
case the <code>bin</code> argument should be <code>TRUE</code>.
</p>
<p><code>n.sets</code> indicates the number of sets each respondent responded to. It is
assumed that every responded responded to the same number of choice sets.
</p>


<h3>Value</h3>

<p>The data ready to be used by the specified package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idefix.data &lt;- aggregate_design 
des &lt;- as.matrix(idefix.data[, 3:8], ncol = 6)
y &lt;- idefix.data[, 9]
bayesm.data &lt;- Datatrans(pkg = "bayesm", des = des, y = y, 
n.alts = 2, n.sets = 8, n.resp = 7, bin = TRUE)
Mix.pro.data &lt;- Datatrans(pkg = "Mixed.Probit", des = des, y = y,
 n.alts = 2, n.sets = 8, n.resp = 7, bin = TRUE)
mlogit.data &lt;- Datatrans(pkg = "mlogit", des = des, y = y,
 n.alts = 2, n.sets = 8, n.resp = 7, bin = TRUE)
</code></pre>

<hr>
<h2 id='DBerr'>DB error</h2><span id='topic+DBerr'></span>

<h3>Description</h3>

<p>Function to calculate the DB-error given a design, and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBerr(par.draws, des, n.alts, weights = NULL, mean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBerr_+3A_par.draws">par.draws</code></td>
<td>
<p>Numeric matrix in which each row is a draw from a multivariate parameter distribution.</p>
</td></tr>
<tr><td><code id="DBerr_+3A_des">des</code></td>
<td>
<p>A design matrix in which each row is an alternative.</p>
</td></tr>
<tr><td><code id="DBerr_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="DBerr_+3A_weights">weights</code></td>
<td>
<p>A numeric vector containing weights of <code>par.draws</code>. The
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="DBerr_+3A_mean">mean</code></td>
<td>
<p>A logical value indicating whether the mean (DB) error should be returned or not. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value indicating the DB-error of the design given the
parameter draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>des &lt;- example_design
mu = c(-1, -1.5, -1, -1.5, 0.5, 1)
Sigma = diag(length(mu))
par.draws &lt;- MASS::mvrnorm(100, mu = mu, Sigma = Sigma)
n.alts = 2
DBerr(par.draws = par.draws, des = des, n.alts = n.alts)

mu = c(-0.5, -1, -0.5, -1, 0.5, 1)
Sigma = diag(length(mu))
par.draws &lt;- MASS::mvrnorm(100, mu = mu, Sigma = Sigma)
DBerr(par.draws = par.draws, des = des, n.alts = n.alts)
</code></pre>

<hr>
<h2 id='Decode'>Coded design to readable design.</h2><span id='topic+Decode'></span>

<h3>Description</h3>

<p>Transforms a coded design matrix into a design containing character attribute
levels, ready to be used in a survey. The frequency of each attribute level
in the design is also included in the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Decode(
  des,
  n.alts,
  lvl.names,
  coding,
  alt.cte = NULL,
  c.lvls = NULL,
  no.choice = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Decode_+3A_des">des</code></td>
<td>
<p>A numeric matrix which represents the design matrix. Each row is a
profile.</p>
</td></tr>
<tr><td><code id="Decode_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="Decode_+3A_lvl.names">lvl.names</code></td>
<td>
<p>A list containing character vectors with the values of each
level of each attribute.</p>
</td></tr>
<tr><td><code id="Decode_+3A_coding">coding</code></td>
<td>
<p>A character vector denoting the type of coding used for each
attribute. See also <code><a href="#topic+Profiles">Profiles</a></code>.</p>
</td></tr>
<tr><td><code id="Decode_+3A_alt.cte">alt.cte</code></td>
<td>
<p>A binary vector indicating for each alternative if an
alternative specific constant is present. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Decode_+3A_c.lvls">c.lvls</code></td>
<td>
<p>A list containing numeric vectors with the attribute levels for
each continuous attribute. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Decode_+3A_no.choice">no.choice</code></td>
<td>
<p>An integer indicating the no choice alternative. The default
is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>des</code> A design matrix, this can also be a single choice set. See for
example the output of <a href="#topic+Modfed">Modfed</a> or <a href="#topic+CEA">CEA</a>.
</p>
<p>In <code>lvl.names</code>, the number of character vectors in the list should equal
the number of attributes in de choice set. The number of elements in each
character vector should equal the number of levels for that attribute.
</p>
<p>Valid arguments for <code>coding</code> are <code>C</code>, <code>D</code> and <code>E</code>. When
using <code>C</code> the attribute will be treated as continuous and no coding will
be applied. All possible levels of that attribute should then be specified in
<code>c.lvls</code>. If <code>D</code> (dummy coding) is used
<code><a href="stats.html#topic+contr.treatment">contr.treatment</a></code> will be applied to that attribute. The first
attribute wil be used as reference level.  For <code>E</code> (effect coding)
<code><a href="stats.html#topic+contr.sum">contr.sum</a></code> is applied, in this case the last attribute level is
used as reference level.
</p>
<p>If <code>des</code> contains columns for alternative specific constants,
<code>alt.cte</code> should be specified. In this case, the first column(s) (equal
to the number of nonzero elements in <code>alt.cte</code>) will be removed from
<code>des</code> before decoding the alternatives.
</p>


<h3>Value</h3>

<table>
<tr><td><code>design</code></td>
<td>
<p>A character matrix which represents the design.</p>
</td></tr>
<tr><td><code>lvl.balance</code></td>
<td>
<p>A list containing the frequency of appearance of each
attribute level in the design.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example without continuous attributes.
design &lt;- example_design 
coded &lt;- c("D", "D", "D") # Coding.
# Levels as they should appear in survey. 
al &lt;- list(
  c("$50", "$75", "$100"), # Levels attribute 1.
  c("2 min", "15 min", "30 min"), # Levels attribute 2.
  c("bad", "moderate", "good") # Levels attribute 3.
) 
# Decode
Decode(des = design, n.alts = 2, lvl.names = al, coding = coded) 

# Example with alternative specific constants
design &lt;- example_design2 
coded &lt;- c("D", "D", "D") # Coding.
# Levels as they should appear in survey. 
al &lt;- list(
  c("$50", "$75", "$100"), # Levels attribute 1.
  c("2 min", "15 min", "30 min"), # Levels attribute 2.
  c("bad", "moderate", "good") # Levels attribute 3.
) 
# Decode
Decode(des = design, n.alts = 3, lvl.names = al, coding = coded, alt.cte = c(1, 1, 0)) 

## End(Not run)
</code></pre>

<hr>
<h2 id='example_design'>Discrete choice design.</h2><span id='topic+example_design'></span>

<h3>Description</h3>

<p>This discrete choice design is generated using the <code><a href="#topic+Modfed">Modfed</a></code>
function. There are 8 choice sets, each containig 2 alternatives (rows). The
alternatives consist of 3 attributes (time, price, comfort) with 3
levels each, all of which are dummy coded (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_design)
</code></pre>


<h3>Format</h3>

<p>A matrix with 16 rows and 6 columns.
</p>

<hr>
<h2 id='example_design2'>Discrete choice design.</h2><span id='topic+example_design2'></span>

<h3>Description</h3>

<p>This discrete choice design is generated using the <code><a href="#topic+Modfed">Modfed</a></code>
function. There are 8 choice sets, each containig 3 alternatives (rows). The
alternatives consist of 3 attributes (time, price, comfort) with 3
levels each, all of which are dummy coded (columns). The first two colums are
alternative specific constants for alternative 1 and 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_design2)
</code></pre>


<h3>Format</h3>

<p>A matrix with 24 rows and 8 columns.
</p>

<hr>
<h2 id='ImpsampMNL'>Importance sampling MNL</h2><span id='topic+ImpsampMNL'></span>

<h3>Description</h3>

<p>This function samples from the posterior distribution using importance
sampling, assuming a multivariate (truncated) normal prior distribution and a
MNL likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImpsampMNL(
  n.draws,
  prior.mean,
  prior.covar,
  des,
  n.alts,
  y,
  alt.cte = NULL,
  lower = NULL,
  upper = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ImpsampMNL_+3A_n.draws">n.draws</code></td>
<td>
<p>Numeric value indicating the number of draws.</p>
</td></tr>
<tr><td><code id="ImpsampMNL_+3A_prior.mean">prior.mean</code></td>
<td>
<p>Numeric vector indicating the mean of the multivariate
normal distribution (prior).</p>
</td></tr>
<tr><td><code id="ImpsampMNL_+3A_prior.covar">prior.covar</code></td>
<td>
<p>Covariance matrix of the prior distribution.</p>
</td></tr>
<tr><td><code id="ImpsampMNL_+3A_des">des</code></td>
<td>
<p>A design matrix in which each row is a profile. If alternative
specific constants are present, those should be included as the first
column(s) of the design. Can be generated with <code><a href="#topic+Modfed">Modfed</a></code> or <code><a href="#topic+CEA">CEA</a></code>.</p>
</td></tr>
<tr><td><code id="ImpsampMNL_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="ImpsampMNL_+3A_y">y</code></td>
<td>
<p>A binary response vector. <code><a href="#topic+RespondMNL">RespondMNL</a></code> can be used to
simulate response data.</p>
</td></tr>
<tr><td><code id="ImpsampMNL_+3A_alt.cte">alt.cte</code></td>
<td>
<p>A binary vector indicating for each alternative whether an
alternative specific constant is desired. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ImpsampMNL_+3A_lower">lower</code></td>
<td>
<p>Numeric vector of lower truncation points, the default
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ImpsampMNL_+3A_upper">upper</code></td>
<td>
<p>Numeric vector of upper truncation points, the default
is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the proposal distribution a t-distribution with degrees of freedom equal
to the number of parameters is used. The posterior mode is estimated using
<code><a href="stats.html#topic+optim">optim</a></code>, and the covariance matrix is calculated as the negative
inverse of the generalized Fisher information matrix. See reference for more
information.
</p>
<p>From this distribution a lattice grid of draws is generated.
</p>
<p>If truncation is present, incorrect draws are rejected and new ones are
generated untill <code>n.draws</code> is reached. The covariance matrix is in this case
still calculated as if no truncation was present.
</p>


<h3>Value</h3>

<table>
<tr><td><code>sample</code></td>
<td>
<p>Numeric vector with the (unweigthted) draws from the
posterior distribution.</p>
</td></tr> <tr><td><code>weights</code></td>
<td>
<p>Numeric vector with the associated
weights of the draws.</p>
</td></tr> <tr><td><code>max</code></td>
<td>
<p>Numeric vector with the estimated
mode of the posterior distribution.</p>
</td></tr> <tr><td><code>covar</code></td>
<td>
<p>Matrix representing the
estimated variance covariance matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yu J, Goos P, Vandebroek M (2011).
&ldquo;Individually adapted sequential Bayesian conjoint-choice designs in the presence of consumer heterogeneity.&rdquo;
<a href="https://www.sciencedirect.com/science/article/pii/S0167811611000668">https://www.sciencedirect.com/science/article/pii/S0167811611000668</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: sample from posterior, no constraints, no alternative specific constants 
# choice design  
design &lt;- example_design
# Respons.
truePar &lt;- c(0.7, 0.6, 0.5, -0.5, -0.7, 1.7) # some values
set.seed(123)
resp &lt;- RespondMNL(par = truePar, des = design, n.alts = 2)
#prior
pm &lt;- c(1, 1, 1, -1, -1, 1) # mean vector 
pc &lt;- diag(1, ncol(design)) # covariance matrix 
# draws from posterior.
ImpsampMNL(n.draws = 100, prior.mean =  pm, prior.covar = pc,
           des = design, n.alts = 2, y = resp)

## example 2:  sample from posterior with constraints 
# and alternative specific constants
# choice design. 
design &lt;- example_design2
# Respons.
truePar &lt;- c(0.2, 0.8, 0.7, 0.6, 0.5, -0.5, -0.7, 1.7) # some values
set.seed(123)
resp &lt;- RespondMNL(par = truePar, des = design, n.alts = 3)
# prior
pm &lt;- c(1, 1, 1, 1, 1, -1, -1, 1) # mean vector 
pc &lt;- diag(1, ncol(design)) # covariance matrix
low = c(-Inf, -Inf, 0, 0, 0, -Inf, -Inf, 0)
up = c(Inf, Inf, Inf, Inf, Inf, 0, 0, Inf)
# draws from posterior.
ImpsampMNL(n.draws = 100, prior.mean =  pm, prior.covar = pc, des = design,
           n.alts = 3, y = resp, lower = low, upper = up, alt.cte = c(1, 1, 0))
</code></pre>

<hr>
<h2 id='LoadData'>Load numeric choice data from directory</h2><span id='topic+LoadData'></span>

<h3>Description</h3>

<p>Reads all individual choice data files, created by <code><a href="#topic+SurveyApp">SurveyApp</a></code>
function, from a directory and concatenates
those files into a single data file. Files containing either &quot;num&quot; or &quot;char&quot;
will be read, with num indicating numeric data and char indicating character
data. For more information, see output of <code><a href="#topic+SurveyApp">SurveyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadData(data.dir, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadData_+3A_data.dir">data.dir</code></td>
<td>
<p>A character string containing the directory to read from.</p>
</td></tr>
<tr><td><code id="LoadData_+3A_type">type</code></td>
<td>
<p>Character vector containing either num or char.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containg the full design and all the responses of the
combined data files that were found. Different files are indicated by an
ID variable.
</p>

<hr>
<h2 id='Modfed'>Modified Fedorov algorithm for MNL models.</h2><span id='topic+Modfed'></span>

<h3>Description</h3>

<p>The algorithm swaps every profile of an initial start design with candidate
profiles. By doing this, it tries to minimize the D(B)-error, based on a
multinomial logit model. This routine is repeated for multiple starting
designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Modfed(
  cand.set,
  n.sets,
  n.alts,
  par.draws,
  alt.cte = NULL,
  no.choice = FALSE,
  start.des = NULL,
  parallel = TRUE,
  max.iter = Inf,
  n.start = 12,
  best = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Modfed_+3A_cand.set">cand.set</code></td>
<td>
<p>A numeric matrix in which each row is a possible profile. The
<code><a href="#topic+Profiles">Profiles</a></code> function can be used to generate this matrix.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_n.sets">n.sets</code></td>
<td>
<p>Numeric value indicating the number of choice sets.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_par.draws">par.draws</code></td>
<td>
<p>A matrix or a list, depending on <code>alt.cte</code>.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_alt.cte">alt.cte</code></td>
<td>
<p>A binary vector indicating for each alternative whether an
alternative specific constant is desired. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_no.choice">no.choice</code></td>
<td>
<p>A logical value indicating whether a no choice alternative
should be added to each choice set. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_start.des">start.des</code></td>
<td>
<p>A list containing one or more matrices corresponding to initial start design(s). The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_parallel">parallel</code></td>
<td>
<p>Logical value indicating whether computations should be done
over multiple cores. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_max.iter">max.iter</code></td>
<td>
<p>A numeric value indicating the maximum number allowed
iterations. The default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_n.start">n.start</code></td>
<td>
<p>A numeric value indicating the number of random start designs
to use. The default is 12.</p>
</td></tr>
<tr><td><code id="Modfed_+3A_best">best</code></td>
<td>
<p>A logical value indicating whether only the best design should be
returned. The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each iteration will loop through all profiles from the initial design,
evaluating the change in D(B)-error for every profile from <code>cand.set</code>.
The algorithm stops when an iteration occured without replacing a profile or
when <code>max.iter</code> is reached.
</p>
<p>By specifying a numeric vector in <code>par.draws</code>, the D-error will be
calculated and the design will be optimised locally. By specifying a matrix,
in which each row is a draw from a multivariate distribution, the DB-error
will be calculated, and the design will be optimised globally. Whenever there
are alternative specific constants, <code>par.draws</code> should be a list
containing two matrices: The first matrix containing the parameter draws for
the alternative specific constant parameters. The second matrix containing
the draws for the rest of the parameters.
</p>
<p>The DB-error is calculated by taking the mean over D-errors. It could be that
for some draws the design results in an infinite D-error. The percentage of
draws for which this was true for the final design can be found in the output
<code>inf.error</code>.
</p>
<p>Alternative specific constants can be specified in <code>alt.cte</code>. The length
of this binary vector should equal <code>n.alts</code>, were <code>0</code> indicates the
absence of an alternative specific constant and <code>1</code> the opposite.
</p>
<p><code>start.des</code> is a list with one or several matrices  corresponding to
initial start design(s). In each matrix each
row is a profile. The number of rows equals <code>n.sets * n.alts</code>, and the
number of columns equals the number of columns of <code>cand.set</code> + the
number of non-zero elements in <code>alt.cte</code>. If <code>start.des
= NULL</code>, <code>n.start</code> random initial designs will be
generated. If start designs are provided, <code>n.start</code> is ignored.
</p>
<p>If <code>no.choice</code> is <code>TRUE</code>, in each choice set an alternative with
one alternative specific constant is added. The return value of the
D(B)-error is however based on the design without the no choice option.
</p>
<p>When <code>parallel</code> is <code>TRUE</code>, <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will
be used to decide upon the number of available cores. That number minus 1
cores will be used to search for efficient designs. The computation time will
decrease significantly when <code>parallel = TRUE</code>.
</p>


<h3>Value</h3>

<p>If <code>best = TRUE</code> the design with the lowest D(B)-error is returned.
If <code>best = FALSE</code>, the results of all (provided) start designs are
returned. </p>
<table>
<tr><td><code>design</code></td>
<td>
<p>A
numeric matrix wich contains an efficient design.</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>Numeric
value indicating the D(B)-error of the design.</p>
</td></tr> <tr><td><code>inf.error</code></td>
<td>
<p>Numeric
value indicating the percentage of draws for which the D-error was
<code>Inf</code>.</p>
</td></tr> <tr><td><code>probs</code></td>
<td>
<p>Numeric matrix containing the probabilities of
each alternative in each choice set. If a sample matrix was provided in
<code>par.draws</code>, this is the average over all draws.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Traets F, Sanchez G, Vandebroek M (2020).
&ldquo;Generating Optimal Designs for Discrete Choice Experiments in R: The idefix Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>96</b>(3).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# DB-efficient designs
# 3 Attributes, all dummy coded. 1 alternative specific constant = 7 parameters
cand.set &lt;- Profiles(lvls = c(3, 3, 3), coding = c("D", "D", "D"))
mu &lt;- c(0.5, 0.8, 0.2, -0.3, -1.2, 1.6, 2.2) # Prior parameter vector
v &lt;- diag(length(mu)) # Prior variance.
set.seed(123) 
pd &lt;- MASS::mvrnorm(n = 10, mu = mu, Sigma = v) # 10 draws.
p.d &lt;- list(matrix(pd[,1], ncol = 1), pd[,2:7])
Modfed(cand.set = cand.set, n.sets = 8, n.alts = 2, 
       alt.cte = c(1, 0), parallel = FALSE, par.draws = p.d, best = FALSE)

# DB-efficient design with start design provided.  
# 3 Attributes with 3 levels, all dummy coded (= 6 parameters).
cand.set &lt;- Profiles(lvls = c(3, 3, 3), coding = c("D", "D", "D")) 
mu &lt;- c(0.8, 0.2, -0.3, -0.2, 0.7, 0.4) # Prior mean (total = 5 parameters).
v &lt;- diag(length(mu)) # Prior variance.
sd &lt;- list(example_design)
set.seed(123)
ps &lt;- MASS::mvrnorm(n = 10, mu = mu, Sigma = v) # 10 draws.
Modfed(cand.set = cand.set, n.sets = 8, n.alts = 2, 
       alt.cte = c(0, 0), parallel = FALSE, par.draws = ps, start.des = sd)

## End(Not run)
</code></pre>

<hr>
<h2 id='nochoice_design'>Discrete choice design with no choice option.</h2><span id='topic+nochoice_design'></span>

<h3>Description</h3>

<p>This discrete choice design is generated using the <code><a href="#topic+Modfed">Modfed</a></code>
function. There are 8 choice sets, each containig 3 alternatives (rows), of
which one is a no choice option. The no choice option consist of an
alternative specific constant and zero's for all other attribute levels. There
are three attributes (time, price, comfort) with 3 levels each, all of which
are dummy coded (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nochoice_design)
</code></pre>


<h3>Format</h3>

<p>A matrix with 24 rows and 7 variables
</p>

<hr>
<h2 id='Profiles'>Profiles generation.</h2><span id='topic+Profiles'></span>

<h3>Description</h3>

<p>Function to generate all possible combinations of attribute levels (i.e. all
possible profiles).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Profiles(lvls, coding, c.lvls = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Profiles_+3A_lvls">lvls</code></td>
<td>
<p>A numeric vector which contains for each attribute the number
of levels.</p>
</td></tr>
<tr><td><code id="Profiles_+3A_coding">coding</code></td>
<td>
<p>Type of coding that needs to be used for each attribute.</p>
</td></tr>
<tr><td><code id="Profiles_+3A_c.lvls">c.lvls</code></td>
<td>
<p>A list containing numeric vectors with the attribute levels for
each continuous attribute. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid arguments for <code>coding</code> are <code>C</code>, <code>D</code> and <code>E</code>. When
using <code>C</code> the attribute will be treated as continuous and no coding will
be applied. All possible levels should then be specified in <code>c.lvls</code>. If
<code>D</code> (dummy coding) is used <code><a href="stats.html#topic+contr.treatment">contr.treatment</a></code> will be applied
to that attribute. For <code>E</code> (effect coding) <code><a href="stats.html#topic+contr.sum">contr.sum</a></code> will
be applied.
</p>


<h3>Value</h3>

<p>A numeric matrix which contains all possible profiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Without continuous attributes
at.lvls &lt;- c(3, 4, 2) # 3 Attributes with respectively 3, 4 and 2 levels. 
c.type &lt;- c("E", "E", "E") # All Effect coded.
Profiles(lvls = at.lvls, coding = c.type) # Generate profiles.

# With continuous attributes 
at.lvls &lt;- c(3, 4, 2) # 3 attributes with respectively 3, 4 and 2 levels. 
# First attribute is dummy coded, second and third are continuous. 
c.type &lt;- c("D", "C", "C") 
# Levels for continuous attributes, in the same order. 
con.lvls &lt;- list(c(4, 6, 8, 10), c(7, 9))
Profiles(lvls = at.lvls, coding = c.type, c.lvls = con.lvls)
</code></pre>

<hr>
<h2 id='RespondMNL'>Response generation</h2><span id='topic+RespondMNL'></span>

<h3>Description</h3>

<p>Function to generate random responses given parameter values and a design
matrix, assuming a MNL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RespondMNL(par, des, n.alts, bin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RespondMNL_+3A_par">par</code></td>
<td>
<p>Numeric vector containing parameter values.</p>
</td></tr>
<tr><td><code id="RespondMNL_+3A_des">des</code></td>
<td>
<p>A design matrix in which each row is a profile. If alternative
specific constants are present, those should be included as the first
column(s) of the design. Can be generated with <code><a href="#topic+Modfed">Modfed</a></code> or <code><a href="#topic+CEA">CEA</a></code>.</p>
</td></tr>
<tr><td><code id="RespondMNL_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="RespondMNL_+3A_bin">bin</code></td>
<td>
<p>A logical value indicating whether the returned value should be a
binary vector or a discrete value which denotes the chosen alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector indicating the chosen alternatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># design: 3 dummy coded attributes, each 3 levels. There are 8 choice sets.
des &lt;- example_design
set.seed(123)
true_par &lt;- rnorm(6)
RespondMNL(par = true_par, des = des, n.alts = 2)
</code></pre>

<hr>
<h2 id='SeqCEA'>Sequential Coordinate Exchange algorithm for MNL model.</h2><span id='topic+SeqCEA'></span>

<h3>Description</h3>

<p>Selects the choice set that minimizes the DB-error when added to an initial
design, given (updated) parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeqCEA(
  des = NULL,
  lvls,
  coding,
  c.lvls = NULL,
  n.alts,
  par.draws,
  prior.covar,
  alt.cte = NULL,
  no.choice = NULL,
  weights = NULL,
  parallel = TRUE,
  reduce = TRUE,
  n.cs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeqCEA_+3A_des">des</code></td>
<td>
<p>A design matrix in which each row is a profile. If alternative
specific constants are present, those should be included as the first
column(s) of the design. Can be generated with <code><a href="#topic+Modfed">Modfed</a></code> or
<code><a href="#topic+CEA">CEA</a></code></p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_lvls">lvls</code></td>
<td>
<p>A numeric vector which contains for each attribute the number
of levels.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_coding">coding</code></td>
<td>
<p>Type of coding that needs to be used for each attribute.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_c.lvls">c.lvls</code></td>
<td>
<p>A list containing numeric vectors with the attribute levels for
each continuous attribute. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_par.draws">par.draws</code></td>
<td>
<p>A matrix or a list, depending on <code>alt.cte</code>.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_prior.covar">prior.covar</code></td>
<td>
<p>Covariance matrix of the prior distribution.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_alt.cte">alt.cte</code></td>
<td>
<p>A binary vector indicating for each alternative whether an
alternative specific constant is desired. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_no.choice">no.choice</code></td>
<td>
<p>An integer indicating the no choice alternative. The default
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_weights">weights</code></td>
<td>
<p>A vector containing the weights of the draws. Default is
<code>NULL</code>. See also <code><a href="#topic+ImpsampMNL">ImpsampMNL</a></code>.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_parallel">parallel</code></td>
<td>
<p>Logical value indicating whether computations should be done
over multiple cores.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_reduce">reduce</code></td>
<td>
<p>Logical value indicating whether the candidate set should be
reduced or not.</p>
</td></tr>
<tr><td><code id="SeqCEA_+3A_n.cs">n.cs</code></td>
<td>
<p>An integer indicating the number of possible random choice sets to
consider in the search for the next best choice set possible. The default is
<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is ideally used in an adaptive context. The algorithm will
select the next DB-efficient choice set given parameter values and possible
previously generated choice sets. In an adaptive context these parameter
values are updated after each observed response.
</p>
<p>Previously generated choice sets, which together form an initial design, can
be provided in <code>des</code>. When no design is provided, the algorithm will
select the most efficient choice set based on the fisher information of the
prior covariance matrix <code>prior.covar</code>.
</p>
<p>If <code>alt.cte = NULL</code>, <code>par.draws</code> should be a matrix in which each
row is a sample from the multivariate parameter distribution. In case that
<code>alt.cte</code> is not <code>NULL</code>, a list containing two matrices should be
provided to <code>par.draws</code>. The first matrix containing the parameter draws
for the alternative specific parameters. The second matrix containing the
draws for the rest of the parameters.
</p>
<p>The list of potential choice sets is created by selecting randomly a level for
each attribute in an alternative/profile. <code>n.cs</code> controls the number of
potential choice sets to consider. The default is <code>
NULL</code>, which means that the number of possible choice sets is the product of
attribute levels considered in the experiment. For instance, an experiment
with 3 attribute and 3 levels each will consider 3^3 = 27 possible choice sets.
</p>
<p>The <code>weights</code> argument can be used when the <code>par.draws</code> have
weights. This is for example the case when parameter values are updated using
<code><a href="#topic+ImpsampMNL">ImpsampMNL</a></code>.
</p>
<p>When <code>parallel</code> is <code>TRUE</code>, <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will
be used to decide upon the number of available cores. That number minus 1
cores will be used to search for the optimal choice set. For small problems
(6 parameters), <code>parallel = TRUE</code> can be slower. For larger problems the
computation time will decrease significantly.
</p>
<p><em>Note:</em> this function is faster than <code><a href="#topic+SeqMOD">SeqMOD</a></code>, but
the output is not as stable. This happens because this function
makes a random search to get the choice set, whereas
<code><a href="#topic+SeqMOD">SeqMOD</a></code> makes an exhaustive search.
</p>


<h3>Value</h3>

<table>
<tr><td><code>set</code></td>
<td>
<p>A matrix representing a DB efficient choice set.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>A numeric value indicating the DB-error of the whole
design.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Traets F, Sanchez G, Vandebroek M (2020).
&ldquo;Generating Optimal Designs for Discrete Choice Experiments in R: The idefix Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>96</b>(3).
</p>
<p>Yu J, Goos P, Vandebroek M (2011).
&ldquo;Individually adapted sequential Bayesian conjoint-choice designs in the presence of consumer heterogeneity.&rdquo;
<a href="https://www.sciencedirect.com/science/article/pii/S0167811611000668">https://www.sciencedirect.com/science/article/pii/S0167811611000668</a>.
</p>
<p>Meyer RK, Nachtsheim CJ (1995).
&ldquo;The Coordinate-Exchange Algorithm for Constructing Exact Optimal Experimental Designs.&rdquo;
<em>Technometrics</em>, <b>37</b>(1), 60&ndash;69.
ISSN 00401706, <a href="https://www.jstor.org/stable/1269153">https://www.jstor.org/stable/1269153</a>.
</p>
<p>Kessels R, Jones B, Goos P, Vandebroek M (2009).
&ldquo;An Efficient Algorithm for Constructing Bayesian Optimal Choice Designs.&rdquo;
<em>Journal of Business &amp; Economic Statistics</em>, <b>27</b>(2), 279&ndash;291.
ISSN 07350015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DB efficient choice set, given a design and parameter draws. 
# 3 attributes with 3 levels each
m &lt;- c(0.3, 0.2, -0.3, -0.2, 1.1, 2.4) # mean (total = 6 parameters).
pc &lt;- diag(length(m)) # covariance matrix
set.seed(123)
sample &lt;- MASS::mvrnorm(n = 10, mu = m, Sigma = pc)
# Initial design.
des &lt;- example_design
# Efficient choice set to add.
SeqCEA(des = des, lvls = c(3, 3, 3), coding = c("D", "D", "D"), n.alts = 2,
       par.draws = sample, prior.covar = pc, parallel = FALSE)

# DB efficient choice set, given parameter draws. 
# with alternative specific constants 
des &lt;- example_design2
ac &lt;- c(1, 1, 0) # Alternative specific constants.
m &lt;- c(0.3, 0.2, -0.3, -0.2, 1.1, 2.4, 1.8, 1.2) # mean
pc &lt;- diag(length(m)) # covariance matrix
pos &lt;- MASS::mvrnorm(n = 10, mu = m, Sigma = pc)
sample &lt;- list(pos[ , 1:2], pos[ , 3:8])
# Efficient choice set.
SeqCEA(des = des, lvls = c(3, 3, 3), coding = c("D", "D", "D"), n.alts = 3, 
      par.draws = sample, alt.cte = ac, prior.covar = pc, parallel = FALSE)
</code></pre>

<hr>
<h2 id='SeqKL'>Sequential Kullback-Leibler based algorithm for the MNL model.</h2><span id='topic+SeqKL'></span>

<h3>Description</h3>

<p>Selects the choice set that maximizes the Kullback-Leibler divergence between
the prior parameter values and the expected posterior, assuming a MNL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeqKL(
  des = NULL,
  cand.set,
  n.alts,
  par.draws,
  alt.cte = NULL,
  no.choice = NULL,
  weights = NULL,
  allow.rep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeqKL_+3A_des">des</code></td>
<td>
<p>A design matrix in which each row is a profile. If alternative
specific constants are present, those should be included as the first
column(s) of the design. Can be generated with <code><a href="#topic+Modfed">Modfed</a></code> or <code><a href="#topic+CEA">CEA</a></code>.</p>
</td></tr>
<tr><td><code id="SeqKL_+3A_cand.set">cand.set</code></td>
<td>
<p>A numeric matrix in which each row is a possible profile. The
<code><a href="#topic+Profiles">Profiles</a></code> function can be used to generate this matrix.</p>
</td></tr>
<tr><td><code id="SeqKL_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="SeqKL_+3A_par.draws">par.draws</code></td>
<td>
<p>A matrix or a list, depending on <code>alt.cte</code>.</p>
</td></tr>
<tr><td><code id="SeqKL_+3A_alt.cte">alt.cte</code></td>
<td>
<p>A binary vector indicating for each alternative if an
alternative specific constant is desired.</p>
</td></tr>
<tr><td><code id="SeqKL_+3A_no.choice">no.choice</code></td>
<td>
<p>An integer indicating the no choice alternative. The default
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SeqKL_+3A_weights">weights</code></td>
<td>
<p>A vector containing the weights of the draws. Default is
<code>NULL</code>, See also <code><a href="#topic+ImpsampMNL">ImpsampMNL</a></code>.</p>
</td></tr>
<tr><td><code id="SeqKL_+3A_allow.rep">allow.rep</code></td>
<td>
<p>Logical value indicating whether repeated choice sets are
allowed in the design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is ideally used in an adaptive context. The algorithm selects
the choice set that maximizes the Kullback-Leibler
divergence between prior and expected posterior. Otherwisely framed the
algorithm selects the choice set that maximizes the expected information
gain.
</p>
<p>If <code>alt.cte = NULL</code>, <code>par.draws</code> should be a matrix in which each
row is a sample from the multivariate parameter distribution. In case that
<code>alt.cte</code> is not <code>NULL</code>, a list containing two matrices should be
provided to <code>par.draws</code>. The first matrix containing the parameter draws
for the alternative specific parameters. The second matrix containing the
draws for the rest of the parameters.
</p>
<p>The list of potential choice sets are created using
<code><a href="utils.html#topic+combn">combn</a></code>. The <code>weights</code> argument can be used when the
<code>par.draws</code> have
weights. This is for example the case when parameter values are updated using
<code><a href="#topic+ImpsampMNL">ImpsampMNL</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>set</code></td>
<td>
<p>Numeric matrix containing the choice set that maximizes the expected KL divergence.</p>
</td></tr>
<tr><td><code>kl</code></td>
<td>
<p>Numeric value which is the Kullback leibler divergence.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Crabbe M, Akinc D, Vandebroek M (2014).
&ldquo;Fast algorithms to generate individualized designs for the mixed logit choice model.&rdquo;
<a href="https://www.sciencedirect.com/science/article/pii/S0191261513002178">https://www.sciencedirect.com/science/article/pii/S0191261513002178</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># KL efficient choice set, given parameter draws. 
# Candidate profiles 
cs &lt;- Profiles(lvls = c(3, 3), coding = c("E", "E"))
m &lt;- c(0.3, 0.2, -0.3, -0.2) # Prior mean (4 parameters).
pc &lt;- diag(length(m)) # Prior variance
set.seed(123)
ps &lt;- MASS::mvrnorm(n = 10, mu = m, Sigma = pc) # 10 draws.
# Efficient choice set to add. 
SeqKL(cand.set = cs, n.alts = 2, alt.cte = NULL, par.draws = ps, weights = NULL)

# KL efficient choice set, given parameter draws. 
# Candidate profiles 
cs &lt;- Profiles(lvls = c(3, 3), coding = c("C", "E"), c.lvls = list(c(5,3,1)))
m &lt;- c(0.7, 0.3, -0.3, -0.2) # Prior mean (4 parameters).
pc &lt;- diag(length(m)) # Prior variance
set.seed(123)
ps &lt;- MASS::mvrnorm(n = 10, mu = m, Sigma = pc) # 10 draws.
sample &lt;- list(ps[ , 1], ps[ , 2:4])
ac &lt;- c(1, 0) # Alternative specific constant. 
# Efficient choice set to add. 
SeqKL(cand.set = cs, n.alts = 2, alt.cte = ac, par.draws = sample, weights = NULL)
</code></pre>

<hr>
<h2 id='SeqMOD'>Sequential modified federov algorithm for MNL model.</h2><span id='topic+SeqMOD'></span>

<h3>Description</h3>

<p>Selects the choice set that minimizes the DB-error when added to an initial
design, given (updated) parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeqMOD(
  des = NULL,
  cand.set,
  n.alts,
  par.draws,
  prior.covar,
  alt.cte = NULL,
  no.choice = NULL,
  weights = NULL,
  parallel = TRUE,
  reduce = TRUE,
  allow.rep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeqMOD_+3A_des">des</code></td>
<td>
<p>A design matrix in which each row is a profile. If alternative
specific constants are present, those should be included as the first
column(s) of the design. Can be generated with <code><a href="#topic+Modfed">Modfed</a></code> or <code><a href="#topic+CEA">CEA</a></code>.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_cand.set">cand.set</code></td>
<td>
<p>A numeric matrix in which each row is a possible profile. The
<code><a href="#topic+Profiles">Profiles</a></code> function can be used to generate this matrix.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_n.alts">n.alts</code></td>
<td>
<p>Numeric value indicating the number of alternatives per choice
set.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_par.draws">par.draws</code></td>
<td>
<p>A matrix or a list, depending on <code>alt.cte</code>.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_prior.covar">prior.covar</code></td>
<td>
<p>Covariance matrix of the prior distribution.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_alt.cte">alt.cte</code></td>
<td>
<p>A binary vector indicating for each alternative whether an
alternative specific constant is desired. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_no.choice">no.choice</code></td>
<td>
<p>An integer indicating the no choice alternative. The default
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_weights">weights</code></td>
<td>
<p>A vector containing the weights of the draws. Default is
<code>NULL</code>, See also <code><a href="#topic+ImpsampMNL">ImpsampMNL</a></code>.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_parallel">parallel</code></td>
<td>
<p>Logical value indicating whether computations should be done
over multiple cores.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_reduce">reduce</code></td>
<td>
<p>Logical value indicating whether the candidate set should be
reduced or not.</p>
</td></tr>
<tr><td><code id="SeqMOD_+3A_allow.rep">allow.rep</code></td>
<td>
<p>Logical value indicating whether repeated choice sets are
allowed in the design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is ideally used in an adaptive context. The algorithm will
select the next DB-efficient choice set given parameter values and possible
previously generated choice sets. In an adaptive context these parameter
values are updated after each observed response.
</p>
<p>Previously generated choice sets, which together form an initial design, can
be provided in <code>des</code>. When no design is provided, the algorithm will
select te most efficient choice set based on the fisher information of the
prior covariance matrix <code>prior.covar</code>.
</p>
<p>If <code>alt.cte = NULL</code>, <code>par.draws</code> should be a matrix in which each
row is a sample from the multivariate parameter distribution. In case that
<code>alt.cte</code> is not <code>NULL</code>, a list containing two matrices should be
provided to <code>par.draws</code>. The first matrix containing the parameter draws
for the alternative specific parameters. The second matrix containing the
draws for the rest of the parameters.
</p>
<p>The list of potential choice sets are created using
<code><a href="utils.html#topic+combn">combn</a></code>. If <code>reduce</code> is <code>TRUE</code>,
<code>allow.rep = FALSE</code> and vice versa. Furthermore, the list of
potential choice sets will be screaned in order to select only those choice
sets with a unique information matrix. If no alternative specific constants are used,
<code>reduce</code> should always be <code>TRUE</code>. When alternative specific
constants are used <code>reduce</code> can be <code>TRUE</code> so that the algorithm
will be faster, but the combinations of constants and profiles will not be
evaluated exhaustively.
</p>
<p>The <code>weights</code> argument can be used when the <code>par.draws</code> have
weights. This is for example the case when parameter values are updated using
<code><a href="#topic+ImpsampMNL">ImpsampMNL</a></code>.
</p>
<p>When <code>parallel</code> is <code>TRUE</code>, <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will
be used to decide upon the number of available cores. That number minus 1
cores will be used to search for the optimal choice set. For small problems
(6 parameters), <code>parallel = TRUE</code> can be slower. For larger problems the
computation time will decrease significantly.
</p>
<p><em>Note:</em> this function is more stable than <code><a href="#topic+SeqCEA">SeqCEA</a></code>, but
it takes more time to get the output. This happens because this function
makes an exhaustive search to get the choice set, whereas
<code><a href="#topic+SeqCEA">SeqCEA</a></code> makes a random search.
</p>


<h3>Value</h3>

<table>
<tr><td><code>set</code></td>
<td>
<p>A matrix representing a DB efficient choice set.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>A numeric value indicating the DB-error of the whole
design.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Traets F, Sanchez G, Vandebroek M (2020).
&ldquo;Generating Optimal Designs for Discrete Choice Experiments in R: The idefix Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>96</b>(3).
</p>
<p>Yu J, Goos P, Vandebroek M (2011).
&ldquo;Individually adapted sequential Bayesian conjoint-choice designs in the presence of consumer heterogeneity.&rdquo;
<a href="https://www.sciencedirect.com/science/article/pii/S0167811611000668">https://www.sciencedirect.com/science/article/pii/S0167811611000668</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DB efficient choice set, given a design and parameter draws. 
# Candidate profiles 
cs &lt;- Profiles(lvls = c(3, 3, 3), coding = c("D", "D", "D"))
m &lt;- c(0.3, 0.2, -0.3, -0.2, 1.1, 2.4) # mean (total = 6 parameters).
pc &lt;- diag(length(m)) # covariance matrix
set.seed(123)
sample &lt;- MASS::mvrnorm(n = 10, mu = m, Sigma = pc)
# Initial design.
des &lt;- example_design 
# Efficient choice set to add. 
SeqMOD(des = des, cand.set = cs, n.alts = 2, par.draws = sample, 
           prior.covar = pc, parallel = FALSE)

# DB efficient choice set, given parameter draws. 
# with alternative specific constants 
des &lt;- example_design2 
cs &lt;- Profiles(lvls = c(3, 3, 3), coding = c("D", "D", "D"))
ac &lt;- c(1, 1, 0) # Alternative specific constants. 
m &lt;- c(0.3, 0.2, -0.3, -0.2, 1.1, 2.4, 1.8, 1.2) # mean 
pc &lt;- diag(length(m)) # covariance matrix
pos &lt;- MASS::mvrnorm(n = 10, mu = m, Sigma = pc)
sample &lt;- list(pos[ , 1:2], pos[ , 3:8])
# Efficient choice set. 
SeqMOD(des = des, cand.set = cs, n.alts = 3, par.draws = sample, alt.cte = ac, 
           prior.covar = pc, parallel = FALSE)
</code></pre>

<hr>
<h2 id='SurveyApp'>Shiny application to generate a discrete choice survey.</h2><span id='topic+SurveyApp'></span>

<h3>Description</h3>

<p>This function starts a shiny application which puts choice sets on screen and
saves the responses. The complete choice design can be provided in advance, or
can be generated sequentially adaptively, or can be a combination of both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurveyApp(
  des = NULL,
  n.total,
  alts,
  atts,
  lvl.names,
  coding,
  alt.cte = NULL,
  no.choice = NULL,
  buttons.text,
  intro.text,
  end.text,
  data.dir = NULL,
  c.lvls = NULL,
  prior.mean = NULL,
  prior.covar = NULL,
  cand.set = NULL,
  n.draws = NULL,
  lower = NULL,
  upper = NULL,
  parallel = TRUE,
  reduce = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurveyApp_+3A_des">des</code></td>
<td>
<p>A numeric matrix which represents the design matrix. Each row is a
profile.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_n.total">n.total</code></td>
<td>
<p>A numeric value indicating the total number of choice sets.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_alts">alts</code></td>
<td>
<p>A character vector containing the names of the alternatives.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_atts">atts</code></td>
<td>
<p>A character vector containing the names of the attributes.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_lvl.names">lvl.names</code></td>
<td>
<p>A list containing character vectors with the values of each
level of each attribute.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_coding">coding</code></td>
<td>
<p>A character vector denoting the type of coding used for each
attribute. See also <code><a href="#topic+Profiles">Profiles</a></code>.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_alt.cte">alt.cte</code></td>
<td>
<p>A binary vector indicating for each alternative if an
alternative specific constant is present. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_no.choice">no.choice</code></td>
<td>
<p>An integer indicating which alternative should be a no choice
alternative. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_buttons.text">buttons.text</code></td>
<td>
<p>A string containing the text presented together with the
option buttons.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_intro.text">intro.text</code></td>
<td>
<p>A string containing the text presented before the choice
survey.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_end.text">end.text</code></td>
<td>
<p>A string containing the text presented after the choice
survey.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_data.dir">data.dir</code></td>
<td>
<p>A character string with the directory denoting where the data
needs to be written. The default is NULL</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_c.lvls">c.lvls</code></td>
<td>
<p>A list containing numeric vectors with the attribute levels for
each continuous attribute. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_prior.mean">prior.mean</code></td>
<td>
<p>Numeric vector indicating the mean of the multivariate
normal distribution (prior).</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_prior.covar">prior.covar</code></td>
<td>
<p>Covariance matrix of the prior distribution.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_cand.set">cand.set</code></td>
<td>
<p>A numeric matrix in which each row is a possible profile. The
<code><a href="#topic+Profiles">Profiles</a></code> function can be used to generate this matrix.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_n.draws">n.draws</code></td>
<td>
<p>Numeric value indicating the number of draws.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_lower">lower</code></td>
<td>
<p>Numeric vector of lower truncation points, the default
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_upper">upper</code></td>
<td>
<p>Numeric vector of upper truncation points, the default
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_parallel">parallel</code></td>
<td>
<p>Logical value indicating whether computations should be done
over multiple cores. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="SurveyApp_+3A_reduce">reduce</code></td>
<td>
<p>Logical value indicating whether the candidate set should be
reduced or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pregenerated design can be specified in <code>des</code>. This should be a matrix
in which each row is a profile. This can be generated with <code><a href="#topic+Modfed">Modfed</a></code>
or  <code><a href="#topic+CEA">CEA</a></code>, but it is not necessary.
</p>
<p>If <code>n.total</code> = <code>nrow(des)</code> / <code>length(alts)</code>, the specified
design will be put on screen, one set after the other, and the responses will
be saved. If <code>n.total</code> &gt; (<code>nrow(des)</code> / <code>length(alts)</code>), first
the specified design will be shown and afterwards the remaining sets will be
generated adaptively. If <code>des</code> = <code>NULL</code>, <code>n.total</code> sets will be
generated adaptively. See <code><a href="#topic+SeqMOD">SeqMOD</a></code> for more information on adaptive
choice sets.
</p>
<p>Whenever adaptive sets will be generated, <code>prior.mean</code>,
<code>prior.covar</code>, <code>cand.set</code> and <code>n.draws</code>, should be specified.
These arguments are necessary for the underlying importance sampling algorithm
to update the prior preference distribution. <code>lower</code> and <code>upper</code> can
be used to specify lower and upper truncation points. See
<code><a href="#topic+ImpsampMNL">ImpsampMNL</a></code> for more details.
</p>
<p>The names specified in <code>alts</code> will be used to label the choice
alternatives. The names specified in <code>atts</code> will be used to name the
attributes in the choice sets. The values of <code>lvl.names</code> will be used to
create the values in the choice sets. See <code><a href="#topic+Decode">Decode</a></code> for more
details.
</p>
<p>The text specified in <code>buttons.text</code> will be displayed above the buttons
to indicate the preferred choice (for example: &quot;indicate your preferred
choice&quot;). The text specified in <code>intro.text</code> will be displayed before the
choice sets. This will generally be a description of the survey and some
instructions. The text specified in <code>end.text</code> will be displayed after
the survey. This will generally be a thanking note and some further
instructions.
</p>
<p>A no choice alternative is coded as an alternative with 1 alternative specific
constant and zero's for all other attribute levels. If a no choice alternative
is present in <code>des</code>, or is desired when generating adaptive choice sets,
<code>no.choice</code> should be specified. This should be done with an integer,
indicating which alternative is the no choice option. This alternative will
not be presented on screen, but the option to select &quot;no choice&quot; will be. The
<code>alt.cte</code> argument should be specified accordingly, namely with a
<code>1</code> on the location of the <code>no.choice</code> option. See examples for
illustration.
</p>
<p>When <code>parallel</code> is <code>TRUE</code>, <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will
be used to decide upon the number of available cores. That number minus 1
cores will be used to search for the optimal adaptive choice set. For small problems
(6 parameters), <code>parallel = TRUE</code> can be slower. For larger problems the
computation time will decrease significantly.
</p>
<p>When <code>reduce = TRUE</code>, the set of all potential choice sets will be
reduced to choice sets that have a unique information matrix. If no
alternative specific constants are used, <code>reduce</code> should always be
<code>TRUE</code>. When alternative specific constants are used <code>reduce</code> can be
<code>TRUE</code> so that the algorithm will be faster, but the combinations of
constants and profiles will not be evaluated exhaustively.
</p>


<h3>Value</h3>

<p>After completing the survey, two text files can be found in
<code>data.dir</code>. The file with &quot;num&quot; in the filename is a matrix with the
numeric choice data. The coded design matrix (&quot;par&quot;), presented during the
survey, together with the observed responses (&quot;resp&quot;) can be found here.
Rownames indicate the setnumbers. The file with &quot;char&quot; in the filename is a
matrix with character choice data. The labeled design matrix (&quot;par&quot;),
presented during the survey, together with the observed responses (&quot;resp&quot;)
can be found here. See <code><a href="#topic+LoadData">LoadData</a></code> to load the data.
</p>


<h3>References</h3>

<p>Yu J, Goos P, Vandebroek M (2011).
&ldquo;Individually adapted sequential Bayesian conjoint-choice designs in the presence of consumer heterogeneity.&rdquo;
<a href="https://www.sciencedirect.com/science/article/pii/S0167811611000668">https://www.sciencedirect.com/science/article/pii/S0167811611000668</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### Present choice design without adaptive sets (n.total = sets in des)
# example design 
data("example_design") # pregenerated design
xdes &lt;- example_design
### settings of the design 
code &lt;- c("D", "D", "D")
n.sets &lt;- 8
# settings of the survey
alternatives &lt;- c("Alternative A", "Alternative B")
attributes &lt;- c("Price", "Time", "Comfort")
labels &lt;- vector(mode="list", length(attributes))
labels[[1]] &lt;- c("$10", "$5", "$1")
labels[[2]] &lt;- c("20 min", "12 min", "3 min")
labels[[3]] &lt;- c("bad", "average", "good")
i.text &lt;- "Welcome, here are some instructions ... good luck!"
b.text &lt;- "Please choose the alternative you prefer"
e.text &lt;- "Thanks for taking the survey"
dataDir &lt;- getwd()
# Display the survey 
SurveyApp (des = xdes, n.total = n.sets, alts = alternatives, 
          atts = attributes, lvl.names = labels, coding = code, 
          buttons.text = b.text, intro.text = i.text, end.text = e.text)

#### Present choice design with partly adaptive sets (n.total &gt; sets in des)
# example design 
data("example_design") # pregenerated design
xdes &lt;- example_design
### settings of the design 
code &lt;- c("D", "D", "D")
n.sets &lt;- 12
# settings of the survey
alternatives &lt;- c("Alternative A", "Alternative B")
attributes &lt;- c("Price", "Time", "Comfort")
labels &lt;- vector(mode="list", length(attributes))
labels[[1]] &lt;- c("$10", "$5", "$1")
labels[[2]] &lt;- c("20 min", "12 min", "3 min")
labels[[3]] &lt;- c("bad", "average", "good")
i.text &lt;- "Welcome, here are some instructions ... good luck!"
b.text &lt;- "Please choose the alternative you prefer"
e.text &lt;- "Thanks for taking the survey"
# setting for adaptive sets 
levels &lt;- c(3, 3, 3)
cand &lt;- Profiles(lvls = levels, coding = code)
p.mean &lt;- c(0.3, 0.7, 0.3, 0.7, 0.3, 0.7)
p.var &lt;- diag(length(p.mean))
dataDir &lt;- getwd()
# Display the survey 
SurveyApp(des = xdes, n.total = n.sets, alts = alternatives, 
          atts = attributes, lvl.names = labels, coding = code, 
          buttons.text = b.text, intro.text = i.text, end.text = e.text, 
          prior.mean = p.mean, prior.covar = p.var, cand.set = cand, 
          n.draws = 50)
          
#### Choice design with only adaptive sets (des=NULL)
# setting for adaptive sets 
levels &lt;- c(3, 3, 3)
p.mean &lt;- c(0.3, 0.7, 0.3, 0.7, 0.3, 0.7)
low = c(-Inf, -Inf, -Inf, 0, 0, -Inf)
up = rep(Inf, length(p.mean))
p.var &lt;- diag(length(p.mean)) 
code &lt;- c("D", "D", "D")
cand &lt;- Profiles(lvls = levels, coding = code)
n.sets &lt;- 12
# settings of the survey
alternatives &lt;- c("Alternative A", "Alternative B")
attributes &lt;- c("Price", "Time", "Comfort")
labels &lt;- vector(mode="list", length(attributes))
labels[[1]] &lt;- c("$10", "$5", "$1")
labels[[2]] &lt;- c("20 min", "12 min", "3 min")
labels[[3]] &lt;- c("bad", "average", "good")
i.text &lt;- "Welcome, here are some instructions ... good luck!"
b.text &lt;- "Please choose the alternative you prefer"
e.text &lt;- "Thanks for taking the survey"
dataDir &lt;- getwd()
# Display the survey 
SurveyApp(des = NULL, n.total = n.sets, alts = alternatives,
          atts = attributes, lvl.names = labels, coding = code, 
          buttons.text = b.text, intro.text = i.text, end.text = e.text, 
          prior.mean = p.mean, prior.covar = p.var, cand.set = cand, 
          lower = low, upper = up, n.draws = 50)
# If CEA algorithm is desired, cand.set argument is not needed
SurveyApp(des = NULL, n.total = n.sets, alts = alternatives,
         atts = attributes, lvl.names = labels, coding = code, 
         buttons.text = b.text, intro.text = i.text, end.text = e.text, 
         prior.mean = p.mean, prior.covar = p.var, 
         lower = low, upper = up, n.draws = 50)
         
#### Present choice design with a no choice alternative.
# example design 
data("nochoice_design") # pregenerated design
xdes &lt;- nochoice_design
### settings of the design 
code &lt;- c("D", "D", "D")
n.sets &lt;- 8
# settings of the survey
alternatives &lt;- c("Alternative A", "Alternative B", "None")
attributes &lt;- c("Price", "Time", "Comfort")
labels &lt;- vector(mode = "list", length(attributes))
labels[[1]] &lt;- c("$10", "$5", "$1")
labels[[2]] &lt;- c("20 min", "12 min", "3 min")
labels[[3]] &lt;- c("bad", "average", "good")
i.text &lt;- "Welcome, here are some instructions ... good luck!"
b.text &lt;- "Please choose the alternative you prefer"
e.text &lt;- "Thanks for taking the survey"

# Display the survey 
SurveyApp(des = xdes, n.total = n.sets, alts = alternatives, 
          atts = attributes, lvl.names = labels, coding = code, 
          buttons.text = b.text, intro.text = i.text, end.text = e.text,
          no.choice = 3, alt.cte = c(0, 0, 1))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
