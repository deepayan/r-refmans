<!DOCTYPE html><html><head><title>Help for package bimets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bimets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A1D'>
<p>A1D</p></a></li>
<li><a href='#ANNUAL'>
<p>Annual Time Series (Dis)Aggregation</p></a></li>
<li><a href='#as.bimets'>
<p>Convert a Time Series to BIMETS</p></a></li>
<li><a href='#bimets-package'>
<p>bimets :: Time Series And Econometric Modeling In R</p></a></li>
<li><a href='#bimetsConf'>
<p>BIMETS Global Options Configuration</p></a></li>
<li><a href='#bimetsDataset'>
<p>BIMETS Internal Datasets</p></a></li>
<li><a href='#CUMPROD'>
<p>Cumulative Product</p></a></li>
<li><a href='#CUMSUM'>
<p>Cumulative Sum</p></a></li>
<li><a href='#DAILY'>
<p>Daily Time Series (Dis)Aggregation</p></a></li>
<li><a href='#date2yp'>
<p>Date to Year-Period Conversion</p></a></li>
<li><a href='#ELIMELS'>
<p>Eliminate Elements from Arrays or Time Series</p></a></li>
<li><a href='#ESTIMATE'>
<p>Estimate a BIMETS model</p></a></li>
<li><a href='#frequency'>
<p>Frequency of a Time Series</p></a></li>
<li><a href='#fromBIMETStoTS'>
<p>Convert BIMETS to TS</p></a></li>
<li><a href='#fromBIMETStoXTS'>
<p>Convert BIMETS to XTS</p></a></li>
<li><a href='#fromTStoXTS'>
<p>Convert TS to XTS</p></a></li>
<li><a href='#fromXTStoTS'>
<p>Convert XTS to TS</p></a></li>
<li><a href='#GETDATE'>
<p>Retrieve Dates of Time Series</p></a></li>
<li><a href='#GETRANGE'>
<p>Time Series Common Range</p></a></li>
<li><a href='#GETYEARPERIOD'>
<p>Get Time Series Year-Period</p></a></li>
<li><a href='#idxOver'>
<p>BIMETS Time Series Indexing</p></a></li>
<li><a href='#INDEXNUM'>
<p>Rebase a Time Series</p></a></li>
<li><a href='#INTS'>
<p>Create Range of Indices</p></a></li>
<li><a href='#is.bimets'>
<p>Check the Compliance of a Time Series</p></a></li>
<li><a href='#LOAD_MODEL'>
<p>Load a BIMETS model description file</p></a></li>
<li><a href='#LOAD_MODEL_DATA'>
<p>Load time series data into a BIMETS model</p></a></li>
<li><a href='#LOCS'>
<p>Select Time Series Indices</p></a></li>
<li><a href='#MDL'>
<p>BIMETS Model Description Language</p></a></li>
<li><a href='#MONTHLY'>
<p>Monthly Time Series (Dis)Aggregation</p></a></li>
<li><a href='#MOVAVG'>
<p>Moving Average</p></a></li>
<li><a href='#MOVTOT'>
<p>Moving Sum</p></a></li>
<li><a href='#MULTMATRIX'>
<p>Compute the multiplier matrix of a BIMETS model</p></a></li>
<li><a href='#NAMELIST'>
<p>Named List of Time Series</p></a></li>
<li><a href='#NOELS'>
<p>Count Elements</p></a></li>
<li><a href='#normalizeYP'>
<p>Normalize Year-Period Array</p></a></li>
<li><a href='#NUMPERIOD'>
<p>Distance Between Two Year-Periods</p></a></li>
<li><a href='#OPTIMIZE'>
<p>Optimal control of a BIMETS model</p></a></li>
<li><a href='#QUARTERLY'>
<p>Quarterly (Dis)Aggregation</p></a></li>
<li><a href='#RENORM'>
<p>Endogenous targeting of a BIMETS model.</p></a></li>
<li><a href='#SEMIANNUAL'>
<p>Semiannual (Dis)Aggregation</p></a></li>
<li><a href='#SIMULATE'>
<p>Simulation of a BIMETS model</p></a></li>
<li><a href='#STOCHSIMULATE'>
<p>Stochastic simulation of a BIMETS model</p></a></li>
<li><a href='#summary.BIMETS_MODEL'>
<p>Print basic information about a BIMETS model</p></a></li>
<li><a href='#TABIT'>
<p>Print Time Series Data</p></a></li>
<li><a href='#TSDELTA'>
<p>Time Series Lag Differences (Delta)</p></a></li>
<li><a href='#TSDELTALOG'>
<p>Time Series Lag Logarithmic Differences</p></a></li>
<li><a href='#TSDELTAP'>
<p>Time Series Percentage Lag Differences (Delta Percentage)</p></a></li>
<li><a href='#TSERIES'>
<p>Create a Time Series</p></a></li>
<li><a href='#TSEXTEND'>
<p>Extend Time Series</p></a></li>
<li><a href='#TSINFO'>
<p>Get Time Series Info</p></a></li>
<li><a href='#TSJOIN'>
<p>Join Time Series</p></a></li>
<li><a href='#TSLAG'>
<p>Lag Time Series</p></a></li>
<li><a href='#TSLEAD'>
<p>Lead Time Series</p></a></li>
<li><a href='#TSLOOK'>
<p>Lookup a Time Series</p></a></li>
<li><a href='#TSMERGE'>
<p>Merge Time Series</p></a></li>
<li><a href='#TSPROJECT'>
<p>Project a Time series</p></a></li>
<li><a href='#TSTRIM'>
<p>Trim a Time Series</p></a></li>
<li><a href='#VERIFY_MAGNITUDE'>
<p>Time Series Magnitude Test</p></a></li>
<li><a href='#ym2yp'>
<p>yearmon to Year-Period Conversion</p></a></li>
<li><a href='#yq2yp'>
<p>yearqtr to Year-Period Conversion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series and Econometric Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-09</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrea Luciani &lt;andrea.luciani@bancaditalia.it&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrea Luciani <a href="https://orcid.org/0000-0002-7372-358X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Roberto Stok [aut],
  Bank of Italy [cph]</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Time series analysis, (dis)aggregation and manipulation, e.g. time series extension, merge, projection, lag, lead, delta, moving and cumulative average and product, selection by index, date and year-period, conversion to daily, monthly, quarterly, (semi)annually. Simultaneous equation models definition, estimation, simulation and forecasting with coefficient restrictions, error autocorrelation, exogenization, add-factors, impact and interim multipliers analysis, conditional equation evaluation, endogenous targeting and model renormalization, structural stability, stochastic simulation and forecast, optimal control.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), xts, zoo</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/andrea-luciani/bimets/issues">https://github.com/andrea-luciani/bimets/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/andrea-luciani/bimets">https://github.com/andrea-luciani/bimets</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-13 16:02:01 UTC; m025732</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='A1D'>
A1D
</h2><span id='topic+A1D'></span>

<h3>Description</h3>

<p>This function returns the array built with input argument values. Input can be time series, numerical arrays, or strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A1D(..., length = NULL, avoidCompliance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A1D_+3A_...">...</code></td>
<td>

<p>Input argument list.
This function accepts strings, time series, objects of class <code>numeric</code> or <code>logical</code>. Input time series must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="A1D_+3A_length">length</code></td>
<td>

<p>Length of output array, that must be greater than the sum of each input argument size: if the length of the output array is provided, than the output array will be eventually filled with zeros. 
</p>
</td></tr>
<tr><td><code id="A1D_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an array of the same class of the input.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NOELS">NOELS</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+TSDATES">TSDATES</a></code><br />
<code><a href="#topic+LOCS">LOCS</a></code><br />
<code><a href="#topic+NAMELIST">NAMELIST</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+TSINFO">TSINFO</a></code><br />
<code><a href="#topic+TSLOOK">TSLOOK</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
<code><a href="#topic+ELIMELS">ELIMELS</a></code><br />
<code><a href="#topic+INDEXNUM">INDEXNUM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	n&lt;-10;
	#create ts
	ts1&lt;-TSERIES(rnorm(n),START=c(2000,1),FREQ=1)

	#create A1D() array with scalars, ts, and NA
	out_a1d&lt;-A1D(length=25, ts1, 1, -8.9, NA)
	print(out_a1d)
	
	#same example no length specified
	out_a1d&lt;-A1D(ts1, 1, -8.9, NA)
	print(out_a1d)
	
	#strings example
	out_a1d&lt;-A1D(length=5,'aa','bb','ccc')
	print(out_a1d)
</code></pre>

<hr>
<h2 id='ANNUAL'>
Annual Time Series (Dis)Aggregation
</h2><span id='topic+ANNUAL'></span><span id='topic+YEARLY'></span>

<h3>Description</h3>

<p>This function returns a yearly aggregated time series, by using as input a semiannual, quarterly, monthly or daily time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANNUAL(x = NULL, fun = NULL, avoidCompliance = FALSE, ...)
YEARLY(x = NULL, fun = NULL, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ANNUAL_+3A_x">x</code></td>
<td>

<p>Input time series, that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="ANNUAL_+3A_fun">fun</code></td>
<td>
 
<p><b>STOCK</b>: the output value of a year is equal to the value of the input time series in the last period of the same year <br />
<b>NSTOCK</b>: the output value of a year is equal to the value of the input time series in the last non-missing <code>NA</code> period of the same year <br />
<b>SUM</b>: the output value of a year is equal to the sum of all the observations of the input time series in the same year <br />
<b>NSUM</b>: the output value of a year is equal to the sum of all the non-missing <code>NA</code> observations of the input time series in the same year <br />
<b>AVE</b>: the output value of a year is equal to the average of all the observations of the input time series in the same year <br />
<b>NAVE</b>: the output value of a year is equal to the average of all the non-missing <code>NA</code> observations of the input time series in the same year <br />
</p>
</td></tr>
<tr><td><code id="ANNUAL_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="ANNUAL_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a yearly BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SEMIANNUAL">SEMIANNUAL</a></code><br />
<code><a href="#topic+QUARTERLY">QUARTERLY</a></code><br />
<code><a href="#topic+MONTHLY">MONTHLY</a></code><br />
<code><a href="#topic+DAILY">DAILY</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#TS DAILY TO ANNUAL
	n&lt;-366
	ts1&lt;-TIMESERIES(0:n,START=c(2000,1),FREQ='D')
	ts1[10]&lt;-NA
	TABIT(ANNUAL(ts1,fun='NAVE'))
	
	#TS DAILY TO ANNUAL
	n&lt;-36
	ts1&lt;-TIMESERIES(0:n,START=c(2000,1),FREQ='M')
	ts1[10]&lt;-NA
	TABIT(YEARLY(ts1,fun='SUM'))
</code></pre>

<hr>
<h2 id='as.bimets'>
Convert a Time Series to BIMETS
</h2><span id='topic+as.bimets'></span>

<h3>Description</h3>

<p>This function tries to convert a time series of class <code>ts()</code> or <code>xts()</code> into a BIMETS time series that satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code><br />
</p>
<p>All the information in the input time series will be preserved.<br /><br /> Input time series must be of class <code>ts()</code> or <code>xts()</code>, and will be converted in the BIMETS class-type specified in the global option <code>BIMETS_CONF_CCT</code> (see <code><a href="#topic+bimetsConf">BIMETS configuration</a></code>). 
<br /><br /> If the input time series has a temporal discontinuity (i.e. a missing pair Date-Value in the case of <code>xts()</code> time series) then the missing pair Date-Value is inserted in the output time series with a  missing value <code>NA</code>, or with the value provided in the <code>FILLVALUE</code> argument. <br /><br /> If <code>BIMETS_CONF_CCT='XTS'</code>, in the case of a monthly input time series the <code>.indexCLASS</code> is converted to the class <code>yearmon()</code>; in the case of a quarterly input time series the <code>.indexCLASS</code> is converted to <code>yearqtr()</code>; in the case of other input frequency the <code>.indexCLASS</code> is converted to <code>Date()</code>. If <code>BIMETS_CONF_CCT='XTS'</code> the dates of all the output observations are set accordingly to the BIMETS global option <code>BIMETS_CONF_DIP</code>, i.e. the first or the last dates in the period (see <code><a href="#topic+bimetsConf">BIMETS configuration</a></code>). <br /><br />
If the input time series has multiple observations in the same date, e.g. an <code>xts()</code> with a two or more observations in the same date, the duplication is removed and the output time series will contain only the later observation (see example).
<br /><br /> If the input time series is multivariate, the output time series will contain only the first column of the input matrix of data (where the matrix of data is the matrix built by binding input time series values as columns). <br /><br /> If the input time series is a daily time series of class <code>xts()</code> and the global option <code>BIMETS_CONF_CCT='TS'</code> then the 366th period of the output time series in each non-bissextile year will have the value of the 365th period in the same year (duplicated value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.bimets(x=NULL, FILLVALUE=NA, VERBOSE=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.bimets_+3A_x">x</code></td>
<td>

<p>Input time series of class <code>ts()</code> or <code>xts()</code>. 
</p>
</td></tr>
<tr><td><code id="as.bimets_+3A_fillvalue">FILLVALUE</code></td>
<td>

<p>Value inserted in the output time series in the case of temporal discontinuity. Defaults to missing NA.
</p>
</td></tr>
<tr><td><code id="as.bimets_+3A_verbose">VERBOSE</code></td>
<td>

<p>If <code>TRUE</code>, a verbose description of inserted and/or removed observations, if any, will be shown.
</p>
</td></tr>
<tr><td><code id="as.bimets_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series (see also <code><a href="#topic+bimetsConf">BIMETS configuration</a></code>)
.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
<code><a href="#topic+fromBIMETStoXTS">fromBIMETStoXTS</a></code><br />
<code><a href="#topic+fromBIMETStoTS">fromBIMETStoTS</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#xts series with dates equal to the first date in the period, 
	#and some missing observations
	#first...set option and work with xts
	setBIMETSconf('BIMETS_CONF_CCT','XTS')
	#create xts
	xt&lt;-xts(1:10,order.by=seq(as.Date('2000-01-01'),len=10,by='year'))
	#remove some data
	xt&lt;-xt[-5]
	xt&lt;-xt[-3] 
	#convert to bimets
	xtBimets&lt;-as.bimets(xt)
	#print before and after...
	print(xt)
	print(xtBimets)
	
	#ts bivariate series into xts
	setBIMETSconf('BIMETS_CONF_CCT','XTS')
	ts&lt;-ts(matrix(c(1,2,3,4,5,6),nrow=3,ncol=2),start=c(2000,1),frequency=1)
	print(ts)
	xtsBimets&lt;-as.bimets(ts)
	print(xtsBimets)
	
	#reset defaults
	setBIMETSconf('BIMETS_CONF_DIP','LAST')
	setBIMETSconf('BIMETS_CONF_CCT','TS')
	
	#xts quarterly with irregular dates and missings data 
	xt&lt;-xts(1:10,order.by=seq(as.Date('2000-01-03'),len=10,by='3 months'))
	#remove some data
	xt&lt;-xt[-5]
	xt&lt;-xt[-3] 
	#convert
	tsBimets&lt;-as.bimets(xt)
	#print before and after
	print(xt)
	print(tsBimets)
	
	#xts daily with duplicated observations and missing data
	xt&lt;-xts(1:11,order.by=c(as.Date('2000-01-01'),
	                     seq(as.Date('2000-01-01'),
	                     len=10,by='day')))
	xt&lt;-xt[-5]
	xt&lt;-xt[-3] 
	#convert
	tsBimets&lt;-as.bimets(xt)
	#print before and after
	print(xt)
	print(tsBimets)
	
	#verbose and fillvalue
	xt&lt;-xts(1:11,order.by=c(as.Date('2000-01-01'),
                       seq(as.Date('2000-01-01'),
                       len=10,by='day')))
xt&lt;-xt[-5]
xt&lt;-xt[-3]
as.bimets(xt,FILLVALUE=99.99,VERBOSE=TRUE)

</code></pre>

<hr>
<h2 id='bimets-package'>
bimets :: Time Series And Econometric Modeling In R
</h2><span id='topic+bimets'></span><span id='topic+bimets-package'></span>

<h3>Description</h3>

<p>BIMETS is a software framework developed by using <code>R</code> language and designed for time series analysis and econometric modeling, which allows creating and manipulating time series, specifying simultaneous equation models of any size by using a kind of high-level description language, and performing model estimation and structural stability analysis, deterministic and stochastic simulation and forecasting, optimal control.<br /><br />
Besides, BIMETS computational capabilities provide many tools to pre-process data and post-process results, designed for statisticians and economists. These operations are fully integrated with the <code>R</code> environment.<br /> <br />
The package can be installed and loaded in <code>R</code> with the following commands (with <code>R&gt;</code> as the <code>R</code> command prompt):
</p>
<pre>
R&gt; install.packages('bimets')
R&gt; library(bimets)
</pre>
<p>If you have general questions about using BIMETS, or for bug reports, please use the <a href="https://github.com/andrea-luciani/bimets/issues">git issue tracker</a> or write to the <a href="mailto:andrea.luciani@bancaditalia.it">maintainer</a>.
</p>

<table>
<tr>
 <td style="text-align: center;"><b>TIME SERIES </b>  </td>
</tr>

</table>

<p>BIMETS supports daily, weekly, monthly, quarterly, semiannual and yearly time series. Time series with a frequency of 24 and 36 periods per year are also supported. Time series are created by the <code><a href="#topic+TIMESERIES">TIMESERIES</a></code> function.<br /><br />
Example: 
</p>
<pre>
R&gt; #yearly time series
R&gt; myTS &lt;- TIMESERIES(1:10,START=as.Date('2000-01-01'),FREQ=1)

R&gt; #monthly time series
R&gt; myTS &lt;- TIMESERIES(1:10,START=c(2002,3),FREQ='M')
</pre>
<p>The main BIMETS time series capabilities are:<br /><br />
- <em>Indexing</em><br />
- <em>Aggregation / Disaggregation</em><br />
- <em>Manipulation</em><br />
</p>

<table>
<tr>
 <td style="text-align: center;"><em>Time Series Indexing</em> </td>
</tr>

</table>

<p>The BIMETS package extends R indexing capabilities in order to ease time series analysis and manipulation. Users can access and modify time series data:<br /><br />
- <em>by date</em>:  users can select and modify a single observation by date by using the syntax <code>ts['Date']</code>, or multiple observations by using <code>ts['StartDate/EndDate']</code>; <br /><br />
- <em>by year-period</em>: users can select and modify observations by providing the year and the period requested, i.e. <code>ts[[Year,Period]]</code>;<br /><br />
- <em>by observation index</em>: users can select and modify observations by simply providing the array of requested indices, i.e. <code>ts[indices]</code>;<br /><br />
Example:
</p>
<pre>
R&gt; #create a daily time series
R&gt; myTS &lt;- TIMESERIES((1:100),START=c(2000,1),FREQ='D')

R&gt; myTS[1:3]                      #get first three obs.
R&gt; myTS['2000-01-12']             #get Jan 12, 2000 data
R&gt; myTS['2000-02-03/2000-02-14']  #get Feb 3 up to Feb 14
R&gt; myTS[[2000,14]]                #get year 2000 period 14

R&gt; myTS['2000-01-15'] &lt;- NA        #assign to Jan 15, 2000
R&gt; myTS[[2000,42]] &lt;- NA           #assign to Feb 11, 2000
R&gt; myTS[[2000,100]] &lt;- c(-1,-2,-3) #extend time series starting from period 100


</pre>

<table>
<tr>
 <td style="text-align: center;"><em>Time Series Aggregation / Disaggregation</em> </td>
</tr>

</table>

<p>The BIMETS package provides advanced (dis)aggregation capabilities, having linear interpolation capabilities in disaggregation, and aggregation functions (e.g. <code>STOCK</code>, <code>SUM</code>, <code>AVE</code>, etc.) while reducing the time series frequency. <br /><br />
Example:
</p>
<pre>
R&gt; #create a monthly time series
R&gt; myMonthlyTS &lt;- TIMESERIES(1:100,START=c(2000,1),FREQ='M')

R&gt; #convert to yearly time series by using the average as aggregation fun
R&gt; myYearlyTS &lt;- YEARLY(myMonthlyTS,'AVE')

R&gt; #convert to daily by using central interpolation as disaggregation fun
R&gt; myDailyTS &lt;- DAILY(myMonthlyTS,'INTERP_CENTER')




</pre>

<table>
<tr>
 <td style="text-align: center;"><em>Time Series Manipulation</em> </td>
</tr>

</table>

<p>The BIMETS package provides, among others, the following time series manipulation capabilities:<br /><br />
- Time series extension <code><a href="#topic+TSEXTEND">TSEXTEND</a></code> <br /> 
- Time series merging <code><a href="#topic+TSMERGE">TSMERGE</a></code> <br />
- Time series projection <code><a href="#topic+TSPROJECT">TSPROJECT</a></code> <br />
- Lag <code><a href="#topic+TSLAG">TSLAG</a></code><br />
- Lead <code><a href="#topic+TSLEAD">TSLEAD</a></code><br />
- Lag differences: standard, percentage, and logarithmic <code><a href="#topic+TSDELTA">TSDELTA</a></code> <code><a href="#topic+TSDELTAP">TSDELTAP</a></code> <code><a href="#topic+TSDELTALOG">TSDELTALOG</a></code><br />
- Cumulative product <code><a href="#topic+CUMPROD">CUMPROD</a></code> <br />
- Cumulative sum <code><a href="#topic+CUMSUM">CUMSUM</a></code> <br />
- Moving average <code><a href="#topic+MOVAVG">MOVAVG</a></code> <br />
- Moving sum <code><a href="#topic+MOVSUM">MOVSUM</a></code> <br />
- Time series data presentation <code><a href="#topic+TABIT">TABIT</a></code><br /><br />
</p>
<p>Example:
</p>
<pre>
R&gt; #define two time series
R&gt; myTS1 &lt;- TIMESERIES(1:100,START=c(2000,1),FREQ='M')
R&gt; myTS2 &lt;- TIMESERIES(-(1:100),START=c(2005,1),FREQ='M')

R&gt; #extend time series up to Apr 2020 with quadratic formula
R&gt; myExtendedTS &lt;- TSEXTEND(myTS1,UPTO=c(2020,4),EXTMODE='QUADRATIC')

R&gt; #merge two time series with sum
R&gt; myMergedTS &lt;- TSMERGE(myExtendedTS,myTS2,fun='SUM')

R&gt; #project time series on arbitrary time range
R&gt; myProjectedTS &lt;- TSPROJECT(myMergedTS,TSRANGE=c(2004,2,2006,4))

R&gt; #lag and delta% time series
R&gt; myLagTS &lt;- TSLAG(myProjectedTS,2)
R&gt; myDeltaPTS &lt;- TSDELTAP(myLagTS,2)

R&gt; #moving average
R&gt; myMovAveTS &lt;- MOVAVG(myDeltaPTS,5)

R&gt; #print data
R&gt; TABIT(myMovAveTS,
      myTS1,
      TSRANGE=c(2004,8,2004,12)
      )

    Date, Prd., myMovAveTS , myTS1
Aug 2004, 8   ,            , 56
Sep 2004, 9   ,            , 57
Oct 2004, 10  , 3.849002   , 58
Nov 2004, 11  , 3.776275   , 59
Dec 2004, 12  , 3.706247   , 60
 
</pre>

<table>
<tr>
 <td style="text-align: center;"><b>ECONOMETRIC MODELING</b> </td>
</tr>

</table>
 
<p>BIMETS econometric modeling capabilities comprehend:<br /><br />
- <em>Model Definition Language</em> <br />
- <em>Estimation</em> <br />
- <em>Structural Stability</em> <br />
- <em>Simulation</em> <br />
- <em>Stochastic Simulation</em> <br />
- <em>Multipliers Analysis</em> <br />
- <em>Endogenous Targeting </em> <br />
- <em>Optimal Control </em> <br /><br />
We will go through each item of the list with a simple Klein model example (ref: <em>&quot;Economic Fluctuations in the United States 1921-1941&quot;</em> by L. R. Klein, Wiley and Sons Inc., New York, 1950). <br />
</p>

<table>
<tr>
 <td style="text-align: center;"><em>Model Definition Language</em> </td>
</tr>

</table>

<p>BIMETS provides a language to specify an econometric model unambiguously. This section describes how to create a model and its general structure. The specification of an econometric model is translated and identified by keyword statements which are grouped in a model file, i.e. a plain text file or a <code>character</code> variable with a specific syntax. Collectively, these keyword statements constitute the BIMETS Model Description Language (from now on <code><a href="#topic+MDL">MDL</a></code>). The model specifications consist of groups of statements. Each statement begins with a keyword. The keyword classifies the component of the model which is being specified.<br /><br />
Below is an example of Klein's model, which can either be stored in an <code>R</code> variable of class <code>character</code> or in a plain text file with an <code>MDL</code> compliant syntax. <br /><br />
The content of the <em>klein1.txt</em> variable  is:
</p>
<pre>
R&gt; klein1.txt &lt;- "
MODEL 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1921 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END
"
</pre>
<p>Given: <br /> <br />
- <code>cn</code> as <em>Private Consumption Expenditure</em>;   <br />
- <code>i</code> as <em>Investment</em>;    <br />
- <code>w1</code> as <em>Wage Bill of the Private Sector (Demand for Labor)</em>;   <br />
- <code>p</code> as <em>Profits</em>;  <br />
- <code>k</code> as <em>Stock of Capital Goods</em>;   <br />
- <code>y</code> as <em>Gross National Product</em>;  <br />  
- <code>w2</code> as <em>Wage Bill of the Government Sector</em>;   <br />
- <code>time</code> as an annual index of the passage of time;   <br />
- <code>g</code> as <em>Government Expenditure plus Net Exports</em>;   <br />
- <code>t</code> as <em>Business Taxes</em>.   <br /> <br />
<code>a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4</code> are coefficients to be estimated.  <br /> <br />
<br /> 
</p>
<p>This system has only six equations, three of which must be fitted to assess the coefficients. It may not seem challenging to solve this system. However, the objective complexity emerges if you look at the incidence graph in the following figure, wherein endogenous variables are plotted in blue and exogenous variables are plotted in pink.<br /> <br />
</p>
<p><img src="../help/figures/KleinIG.png" alt="KleinIG.png" /> <br /> <br />
</p>
<p>Each edge states a simultaneous dependence from a variable to another, e.g. the <code>w1</code> equation depends on the current value of the <code>time</code> time series; complexity arises because in this model there are several circular dependencies, one of which is plotted in dark blue.  <br /> <br />
A circular dependency in the incidence graph of a model implies that the model is a <em>simultaneous</em> equations model. It must be estimated using ad-hoc procedures; moreover, it can be simulated, e.g. performing a forecast, only using an iterative algorithm.
</p>
<p>As shown in the code, the model definition is quite intuitive. The first keyword is <code>MODEL</code>, while at the end of the model definition we can find the <code>END</code> keyword. Available tags in the definition of a generic BIMETS model are: 
</p>
<p>- <b>EQUATION&gt;</b> or <b>BEHAVIORAL&gt;</b> indicate the beginning of a series of keyword statements describing a behavioral equation;<br /> <br />
- <b>IDENTITY&gt;</b> indicates the beginning of a series of keyword statements describing an identity or technical equation;<br /> <br />
- <b>EQ&gt;</b> specifies the mathematical expression for a behavioral equation or an identity equation;<br /> <br />
- <b>COEFF&gt;</b> specifies the coefficient names used in the EQ&gt; keyword statement of a behavioral equation;<br /> <br />
- <b>ERROR&gt;</b> specifies an autoregressive process of a given order for the regression error;<br /> <br />
- <b>PDL&gt;</b> defines an Almon polynomial distributed lag;<br />  <br />
- <b>RESTRICT&gt;</b> is a keyword that can be used to specify linear coefficient restrictions;<br /> <br />
- <b>IF&gt;</b> is used to conditionally evaluate an identity during a simulation, depending on a logical expression's value. Thus, it is possible to have a model alternating between two or more identity specifications for each simulation period, depending upon results from other equations;<br /> <br />
- <b>IV&gt;</b> specifies the mathematical expression for an instrumental variable used in a behavioral equation;<br /> <br />
- <b>COMMENT&gt;</b> can be used to insert comments into a model;<br /> <br />
The mathematical expression in the EQ&gt; and IF&gt; definitions can include the standard arithmetic operators, parentheses, and the following MDL time series functions: <br /> <br />
- <code>TSLAG(ts,i)</code>: lag the <code>ts</code> time series by <code>i</code>-periods;<br /> <br />
- <code>TSDELTA(ts,i)</code>: <code>i</code>-periods difference of the <code>ts</code> time series;<br /> <br />
- <code>TSDELTAP(ts,i)</code>: <code>i</code>-periods percentage difference of the <code>ts</code> time series;<br /> <br />
- <code>TSDELTALOG(ts,i)</code>: <code>i</code>-periods logarithmic difference of the <code>ts</code> time series;<br /> <br />
- <code>MOVAVG(ts,i)</code>: <code>i</code>-periods moving average of the <code>ts</code> time series;<br /> <br />
- <code>MOVSUM(ts,i)</code>: <code>i</code>-periods moving sum of the  <code>ts</code> time series;<br /> <br />
- <code>LOG(ts)</code>: log of the <code>ts</code> time series.;<br /> <br />
- <code>EXP(ts)</code>: exponential of the <code>ts</code> time series; <br /> <br />
- <code>ABS(ts)</code>: absolute values of the <code>ts</code> time series;<br /> <br />
</p>
<p>More details are available in <code><a href="#topic+MDL">MDL</a></code> and <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code> help pages. <code>LOAD_MODEL()</code> is the BIMETS function that reads an MDL model file and creates an equivalent R data structure.<br /> <br />
Back to Klein's model example, the BIMETS <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code> function reads the <em>klein1.txt</em> model as previously defined:
</p>
<pre>
R&gt; kleinModel &lt;- LOAD_MODEL(modelText = klein1.txt)

Analyzing behaviorals...
Analyzing identities...
Optimizing...
Loaded model "klein1.txt":
    3 behaviorals
    3 identities
    12 coefficients
...LOAD MODEL OK
</pre>
<p>As shown in the output, BIMETS counted 3 behavioral equations, 3 identities and 12 coefficients. Now in the <code>R</code> session there is a variable named <em>kleinModel</em> that contains the model structure defined in the <em>klein1.txt</em> variable. From now on, users can ask BIMETS about any details of this model.<br /><br />
For example, to gather information on the &quot;<code>cn</code>&quot; <em>Consumption</em> behavioral equation: 
</p>
<pre>
R&gt; kleinModel$behaviorals$cn

$eq
[1] "cn=a1+a2*p+a3*TSLAG(p,1)+a4*(w1+w2)"

$eqCoefficientsNames
[1] "a1" "a2" "a3" "a4"

$eqComponentsNames
[1] "cn" "p" "w1" "w2"

$tsrange
[1] 1921 1 1941 1

$eqRegressorsNames
[1] "1" "p" "TSLAG(p,1)" "(w1+w2)"

$eqSimExp
expression(cn[2, ] = cn__ADDFACTOR[2, ] + +cn__a1 * 1 + cn__a2 *
p[2, ] + cn__a3 * (p[1, ]) + cn__a4 * (w1[2, ] + w2[2, ]))

etc...
</pre>
<p>Users can always read (or carefully change) any model parameters. The <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code> function parses behavioral and identity expressions of the <code><a href="#topic+MDL">MDL</a></code> definition, but it also does a significant optimization. Properly reordering the model equations is a key preparatory step in the later phase of the simulation, in order to guarantee performance and convergence, if any, with the aim of minimizing the number of <em>feedback</em> endogenous variables (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>).<br /><br />
The <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code> function builds the model's incidence matrix, and uses this matrix to calculate the proper evaluation order of the model equations during the simulation.<br /><br /> Back to the Klein's model example, the incidence matrix and the reordering of the equations are stored in the following variables:
</p>
<pre>
R&gt; kleinModel$incidence_matrix

   cn i w1 y p k
cn 0  0 1  0 1 0
i  0  0 0  0 1 0
w1 0  0 0  1 0 0
y  1  1 0  0 0 0
p  0  0 1  1 0 0
k  0  1 0  0 0 0

R&gt; kleinModel$vpre

NULL

R&gt; kleinModel$vsim

[1] "w1" "p" "cn" "i" "y"

R&gt; kleinModel$vfeed

[1] "y"

R&gt; kleinModel$vpost

[1] "k"

</pre>
<p>While simulating the Klein's model, BIMETS will iterate on the computation of, in order,<br /> <code>w1 -&gt; p -&gt; cn -&gt; i -&gt; y</code> (the <code>vsim</code> variables), by looking for convergence on <code>y</code> (the <code>vfeed</code> variable, only one in this example) that is the feedback variable. If the convergence is achieved, it will calculate <code>k</code> (the <code>vpost</code> variable). The <code>vpre</code> array in this example is empty; therefore, no equation has to be evaluated before the iterative algorithm.<br /><br />
More details on the equations reordering are available in <code><a href="#topic+SIMULATE">SIMULATE</a></code> and <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code> help pages.<br /><br />
Once the model has been parsed, users need to load the data of all the time series involved in the model, by using the <code><a href="#topic+LOAD_MODEL_DATA">LOAD_MODEL_DATA</a></code> function. In the following example, the code defines a list of time series and loads this list into the Klein's model previously defined:
</p>
<pre>
R&gt; kleinModelData &lt;- list(  
    cn  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,
                 55,50.9,45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7, 	
                 START=c(1920,1),FREQ=1),
    g   =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,
                 10.2,9.3,10,10.5,10.3,11,13,14.4,15.4,22.3,	
                 START=c(1920,1),FREQ=1),
    i   =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,
                 -5.1,-3,-1.3,2.1,2,-1.9,1.3,3.3,4.9,	
                 START=c(1920,1),FREQ=1),
    k   =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,
                 210.6,215.7,216.7,213.3,207.1,202,199,197.7,199.8,
                 201.8,199.9,201.2,204.5,209.4,	
                 START=c(1920,1),FREQ=1),
    p   =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,
                 15.6,11.4,7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,	
                 START=c(1920,1),FREQ=1),
    w1  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,
                 37.9,34.5,29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,	
                 START=c(1920,1),FREQ=1),
    y   =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,
                 50.7,41.3,45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,	
                 START=c(1920,1),FREQ=1),
    t   =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,
                 6.8,7.2,8.3,6.7,7.4,8.9,9.6,11.6,	
                 START=c(1920,1),FREQ=1),
    time=TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,
                 1,2,3,4,5,6,7,8,9,10,	
                 START=c(1920,1),FREQ=1),
    w2  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,
                 5.3,5.6,6,6.1,7.4,6.7,7.7,7.8,8,8.5,	
                 START=c(1920,1),FREQ=1)
	)

R&gt; kleinModel &lt;- LOAD_MODEL_DATA(kleinModel,kleinModelData)
</pre>
<p>Since time series and other data (e.g. regressor coefficients, error coefficients, constant adjustments, targets, instruments, etc...) are stored in the model object, users can define multiple model objects - each with its own arbitrary data - in the same <code>R</code> session. BIMETS makes it possible to estimate, simulate and compare results from different models with different data sets. Furthermore, users can easily save an estimated or a simulated model as a standard <code>R</code> variable, thus reloading it later, having all available data and time series stored in it, i.e. endogenous and exogenous time series, estimated coefficients, constant adjustments, simulation options, simulated time series, calculated instruments, targets, etc. (see also <code><a href="#topic+SIMULATE">SIMULATE</a></code>, <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>, <code><a href="#topic+RENORM">RENORM</a></code>, <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code>)<br /><br />
An advanced MDL model example follows:
</p>
<pre>

R&gt; #KLEIN MODEL WITH AUTOCORRELATION, RESTRICTIONS, 
R&gt; #CONDITIONAL EVALUATIONS AND LHS FUNCTIONS

R&gt; lhsKlein1.txt &lt;- "
MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL,
COMMENT&gt; autocorrelation on errors, restrictions, 
COMMENT&gt; conditional evaluations and LHS functions on EQ

COMMENT&gt; Exp Consumption
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; EXP(cn) = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Log Investment
BEHAVIORAL&gt; i
TSRANGE 1925 1 1941 1
EQ&gt; LOG(i) = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(TSDELTA(y)+t-w2) + c3*TSLAG(TSDELTA(y)+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 3

COMMENT&gt; Delta Gross National Product
IDENTITY&gt; y
EQ&gt; TSDELTA(y) = EXP(cn) + LOG(i) + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = TSDELTA(y) - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + LOG(i)
IF&gt; LOG(i) &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1)
IF&gt; LOG(i) &lt;= 0

END"

</pre>
<p>See <code><a href="#topic+MDL">MDL</a></code> help page for details.
</p>

<table>
<tr>
 <td style="text-align: center;"><em>Estimation</em> </td>
</tr>

</table>

<p>The BIMETS <code><a href="#topic+ESTIMATE">ESTIMATE</a></code> function estimates equations that are linear in the coefficients, as specified in the behavioral equations of the model object. Coefficients can be estimated for single equations or blocks of simultaneous equations. The estimation function supports:<br /><br />
- <em>Ordinary Least Squares</em>;<br />
- <em>Instrumental Variables</em>;<br />
- <em>Deterministic linear restrictions on the coefficients</em>;<br />
- <em>Almon Polynomial Distributed Lags</em>;<br />
- <em>Autocorrelation of the errors</em>;<br />
- <em>Structural stability analysis (Chow tests)</em>;<br /><br />
Restrictions procedure derives from Lagrange Multipliers' theory, while the Cochrane-Orcutt method allows accounting for residuals autocorrelation. <br /><br />
The estimation of the previously defined Klein's model is shown in the following example:  
</p>
<pre>
R&gt; kleinModel &lt;- ESTIMATE(kleinModel)
</pre>
<p>Users can also estimate a selection of behavioral equations:
</p>
<pre>
R&gt; kleinModel &lt;- ESTIMATE(kleinModel,eqList=c('cn'))

Estimate the Model klein1.txt:
the number of behavioral equations to be estimated is 1.
The total number of coefficients is 4.

_________________________________________

BEHAVIORAL EQUATION: cn
Estimation Technique: OLS

cn                  = 16.2366
                        T-stat. 12.46382 ***
                        
                    + 0.1929344 p
                        T-stat. 2.115273 *
                        
                    + 0.0898849 TSLAG(p,1)
                        T-stat. 0.9915824
                    
                    + 0.7962187 (w1+w2)
                        T-stat. 19.93342 ***


STATs:
R-Squared                       : 0.9810082
Adjusted R-Squared              : 0.9776567
Durbin-Watson Statistic         : 1.367474
Sum of squares of residuals     : 17.87945
Standard Error of Regression    : 1.02554
Log of the Likelihood Function  : -28.10857
F-statistic                     : 292.7076
F-probability                   : 7.993606e-15
Akaike's IC                     : 66.21714
Schwarz's IC                    : 71.43975
Mean of Dependent Variable      : 53.99524
Number of Observations          : 21
Number of Degrees of Freedom    : 17
Current Sample (year-period)    : 1921-1 / 1941-1


Signif. codes: *** 0.001 ** 0.01 * 0.05

...ESTIMATE OK
</pre>
<p>A similar output is shown for each estimated regression. Once the estimation is completed, coefficient values, residuals, statistics, etc. are stored in the model object.
</p>
<pre>
R&gt; #print estimated coefficients
R&gt; kleinModel$behaviorals$cn$coefficients

   [,1]
a1 16.2366003
a2 0.1929344
a3 0.0898849
a4 0.7962187

R&gt; #print residuals
R&gt; kleinModel$behaviorals$cn$residuals

Time Series:
Start = 1921
End = 1941
Frequency = 1
[1]  -0.323893544 -1.250007790 -1.565741401 -0.493503129  0.007607907
[6]   0.869096295  1.338476868  1.054978943 -0.588557053  0.282311734
[11] -0.229653489 -0.322131892  0.322281007 -0.058010257 -0.034662717
[16]  1.616497310 -0.435973632  0.210054350  0.989201310  0.785077489
[21] -2.173448309

R&gt; #print a selection of estimate statistics
R&gt; kleinModel$behaviorals$cn$statistics$DegreesOfFreedom

[1] 17

R&gt; kleinModel$behaviorals$cn$statistics$StandardErrorRegression

[1] 1.02554

R&gt; kleinModel$behaviorals$cn$statistics$CoeffCovariance

    a1            a2            a3            a4
a1  1.6970227814  0.0005013886 -0.0177068887 -0.0329172192
a2  0.0005013886  0.0083192948 -0.0052704304 -0.0013188865
a3 -0.0177068887 -0.0052704304  0.0082170486 -0.0006710788
a4 -0.0329172192 -0.0013188865 -0.0006710788  0.0015955167

R&gt; kleinModel$behaviorals$cn$statistics$AdjustedRSquared
[1] 0.9776567

R&gt; kleinModel$behaviorals$cn$statistics$LogLikelihood
[1] -28.10857
</pre>
<p>Below is an example of a model estimation that presents coefficient restrictions, PDL, error autocorrelation, and conditional equation evaluations:
</p>
<pre>

R&gt; #define model
R&gt; advancedKlein1.txt &lt;- 
"MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL, 
COMMENT&gt; autocorrelation on errors, restrictions and 
COMMENT&gt; conditional equation evaluations

COMMENT&gt; Consumption with autocorrelation on errors
BEHAVIORAL&gt; cn
TSRANGE 1923 1 1940 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment with restrictions
BEHAVIORAL&gt; i
TSRANGE 1923 1 1940 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor with PDL
BEHAVIORAL&gt; w1 
TSRANGE 1923 1 1940 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 2

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with IF switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) 
IF&gt; i &lt;= 0

END"

R&gt; #load model and data
R&gt; advancedKleinModel &lt;- LOAD_MODEL(modelText=advancedKlein1.txt)

Analyzing behaviorals...
Analyzing identities...
Optimizing...
Loaded model "advancedKlein1.txt":
    3 behaviorals
    3 identities
    12 coefficients
...LOAD MODEL OK

R&gt; advancedKleinModel &lt;- LOAD_MODEL_DATA(advancedKleinModel,kleinModelData)

Load model data "kleinModelData" into model "advancedKlein1.txt"...
...LOAD MODEL DATA OK

R&gt; #estimate model
R&gt; advancedKleinModel &lt;- ESTIMATE(advancedKleinModel)

Estimate the Model advancedKlein1.txt:
the number of behavioral equations to be estimated is 3.
The total number of coefficients is 13.

_________________________________________

BEHAVIORAL EQUATION: cn
Estimation Technique: OLS
Autoregression of Order  2  (Cochrane-Orcutt procedure)

Convergence was reached in  6  /  20  iterations.


cn                  =   14.82685    
                        T-stat. 7.608453    ***

                    +   0.2589094   p
                        T-stat. 2.959808    *

                    +   0.01423821  TSLAG(p,1)
                        T-stat. 0.1735191   

                    +   0.8390274   (w1+w2)
                        T-stat. 14.67959    ***

ERROR STRUCTURE:  AUTO(2) 

AUTOREGRESSIVE PARAMETERS:
Rho             Std. Error      T-stat.         
 0.2542111       0.2589487       0.9817045       
-0.05250591      0.2593578      -0.2024458       


STATs:
R-Squared                      : 0.9826778   
Adjusted R-Squared             : 0.9754602   
Durbin-Watson Statistic        : 2.256004    
Sum of squares of residuals    : 8.071633    
Standard Error of Regression   : 0.8201439   
Log of the Likelihood Function : -18.32275   
F-statistic                    : 136.1502    
F-probability                  : 3.873514e-10
Akaike's IC                    : 50.6455     
Schwarz's IC                   : 56.8781     
Mean of Dependent Variable     : 54.29444    
Number of Observations         : 18
Number of Degrees of Freedom   : 12
Current Sample (year-period)   : 1923-1 / 1940-1


Signif. codes:   *** 0.001  ** 0.01  * 0.05  



_________________________________________

BEHAVIORAL EQUATION: i
Estimation Technique: OLS

i                   =   0.5348561   
                        T-stat. 0.06197295  

                    +   0.6267204   p
                        T-stat. 4.835884    ***

                    +   0.3732796   TSLAG(p,1)
                        T-stat. 2.88029     *

                    -   0.0796483   TSLAG(k,1)
                        T-stat. -1.871304   

RESTRICTIONS:
b2+b3=1

RESTRICTIONS F-TEST:
F-value            : 5.542962       
F-prob(1,14)       : 0.03368297     


STATs:
R-Squared                      : 0.9009016   
Adjusted R-Squared             : 0.8876885   
Durbin-Watson Statistic        : 1.284709    
Sum of squares of residuals    : 23.40087    
Standard Error of Regression   : 1.249023    
Log of the Likelihood Function : -27.90251   
F-statistic                    : 68.18238    
F-probability                  : 2.954599e-08
Akaike's IC                    : 63.80501    
Schwarz's IC                   : 67.3665     
Mean of Dependent Variable     : 1.111111    
Number of Observations         : 18
Number of Degrees of Freedom   : 15
Current Sample (year-period)   : 1923-1 / 1940-1


Signif. codes:   *** 0.001  ** 0.01  * 0.05  



_________________________________________

BEHAVIORAL EQUATION: w1
Estimation Technique: OLS

w1                  =   2.916775    
                        T-stat. 1.808594    

                    +   0.4229623   (y+t-w2)
                        T-stat. 10.32315    ***

                    +   c3          TSLAG(y+t-w2,1)
                        PDL

                    +   0.1020647   time
                        T-stat. 3.048413    **

PDL:
c3 1 2

Distributed Lag Coefficient: c3
Lag     Coeff.         Std. Error     T-stat.        
0        0.1292072      0.06348684     2.035181      
1        0.01035948     0.04266269     0.2428229     
SUM      0.1395667      0.03801893    


STATs:
R-Squared                      : 0.9806112   
Adjusted R-Squared             : 0.9746454   
Durbin-Watson Statistic        : 2.038182    
Sum of squares of residuals    : 6.59422     
Standard Error of Regression   : 0.7122132   
Log of the Likelihood Function : -16.50329   
F-statistic                    : 164.3727    
F-probability                  : 5.454803e-11
Akaike's IC                    : 45.00658    
Schwarz's IC                   : 50.34881    
Mean of Dependent Variable     : 36.41667    
Number of Observations         : 18
Number of Degrees of Freedom   : 13
Current Sample (year-period)   : 1923-1 / 1940-1


Signif. codes:   *** 0.001  ** 0.01  * 0.05  


...ESTIMATE OK
</pre>

<table>
<tr>
 <td style="text-align: center;"><em>Structural Stability</em> </td>
</tr>

</table>

<p>One of the main purposes of econometric modeling is its use for forecast and policy evaluation and, to this end, the stability of any behavioral equation parameters over time should be verified. In order to check for structural stability two different procedures, which can be derived from the so-called Chow-tests, are applied.<br /> <br />
Given a sample of observations (i.e. the base <code>TSRANGE</code>) and selecting an arbitrary forward extension (i.e. the extended <code>TSRANGE</code>) we can perform the same regression by using these two time ranges.<br /><br />
In general, a stability analysis is carried on in the following ways:<br />
- comparing the parameter estimates arising from the two regressions: this is known as the covariance analysis;<br />
- checking the accuracy of the forecast for the dependent variable in the extended <code>TSRANGE</code>, using the estimates produced in the base <code>TSRANGE</code>: this is known as the predictive power test.<br /><br />
The test statistic follows the <code>F</code> distribution  and can be performed during the <code>ESTIMATE()</code> function execution by using the <code>CHOWTEST</code> argument set to <code>TRUE</code> (more details in the <code><a href="#topic+ESTIMATE">ESTIMATE</a></code> help page).<br /> <br />
Example:
</p>
<pre>
#chow test for the consumption equation
#base TSRANGE set to 1921/1935
R&gt; kleinModelChow &lt;- ESTIMATE(kleinModel
                       ,eqList='cn'
                       ,TSRANGE=c(1921,1,1935,1)
                       ,forceTSRANGE=TRUE
                       ,CHOWTEST=TRUE)

Estimate the Model klein1.txt:
the number of behavioral equations to be estimated is 1.
The total number of coefficients is 4.

_________________________________________

BEHAVIORAL EQUATION: cn
Estimation Technique: OLS

cn                  =   13.1275    
                        T-stat. 6.5046     ***

                    +   0.16698    p
                        T-stat. 2.18304    

                    +   0.0885684  TSLAG(p,1)
                        T-stat. 0.975042   

                    +   0.887964   (w1+w2)
                        T-stat. 12.61      ***


STATs:
R-Squared                      : 0.978728   
Adjusted R-Squared             : 0.972926   
Durbin-Watson Statistic        : 1.38       
Sum of squares of residuals    : 6.9186     
Standard Error of Regression   : 0.793072   
Log of the Likelihood Function : -15.4803   
F-statistic                    : 168.7      
F-probability                  : 1.77673e-09
Akaike's IC                    : 40.9606    
Schwarz's IC                   : 44.5009    
Mean of Dependent Variable     : 50.9133    
Number of Observations         : 15
Number of Degrees of Freedom   : 11
Current Sample (year-period)   : 1921-1 / 1935-1


Signif. codes:   *** 0.001  ** 0.01  * 0.05  



STABILITY ANALYSIS:
Behavioral equation: cn 

Chow test:
Sample (auto)      : 1936-1 / 1941-1 
F-value            : 4.48873       
F-prob(6,17)       : 0.00668723      

Predictive Power:

Date, Prd., Actual  , Predict   , Error      , Std. Error, T-stat         

1936, 1   ,  57.7   ,  56.5544  ,  1.14564   ,  1.01181  ,  1.13227      
1937, 1   ,  58.7   ,  59.931   , -1.23099   ,  1.0201   , -1.20673      
1938, 1   ,  57.5   ,  57.9721  , -0.472122  ,  0.968638 , -0.487409     
1939, 1   ,  61.6   ,  61.5207  ,  0.0793139 ,  1.20048  ,  0.0660685    
1940, 1   ,  65     ,  65.3957  , -0.395718  ,  1.24227  , -0.318545     
1941, 1   ,  69.7   ,  73.7965  , -4.09655   ,  1.6693   , -2.45405   
          

...ESTIMATE OK                      
</pre>

<table>
<tr>
 <td style="text-align: center;"><em>Simulation</em> </td>
</tr>

</table>

<p>The simulation of an econometric model basically consists in solving the system of the equations describing the model for each time period in the specified time interval. Since the equations may not be linear in the variables, and since the graph derived from the incidence matrix may be cyclic, the usual methods based on linear algebra are not applicable. The simulation must be solved by using an iterative algorithm. <br /> <br />
BIMETS simulation capabilities support:<br /><br />
- <em>Static simulations</em>: a static multiple equation simulation, in which the historical values for the lagged endogenous variables are used in the solutions of subsequent periods; <br /><br />
- <em>Dynamic simulations</em>: a dynamic simulation, in which the simulated values for the lagged endogenous variables are used in the solutions of subsequent periods;<br /><br />
- <em>Forecast simulations</em>: similar to dynamic simulation, but during the initialization of the iterative algorithm the starting values of endogenous variables in a period are set equal to the simulated values of the previous period. This allows the simulation of future endogenous observations, i.e. the forecast;  <br /><br />
- <em>Residuals check</em>: a single period, single equation simulation; simulated time series in output are just the computation of the RHS (right-hand-side) of their equation, by using the historical values of the involved time series and by accounting for error autocorrelation and PDLs, if any;<br /><br />
- <em>Stochastic Simulation</em>: see <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>;<br /><br />
- <em>Partial or total exogenization of endogenous variables</em>: in the provided time interval (i.e. partial exog.) or in whole simulation time range (i.e. total exog.), the values of the selected endogenous variables can be definitely set to their historical values, by excluding their equations from the iterative algorithm of simulation;<br /><br />
- <em>Constant adjustment of endogenous variables (add-factors)</em>: adds up a new exogenous time series (i.e. the &quot;constant adjustment&quot;) in the equation of the selected endogenous variables.<br /><br />
- <em>Gauss-Seidel</em> and <em>Newton-Raphson</em> simulation algorithms: the Gauss-Seidel algorithm is simple, robust, and works well for many backward-looking macro-econometric models. Equations are evaluated as-is in a proper order until the convergence, if any, is verified on feedback variables. It is slower than Newton algorithms for a very low convergence criterion, and fails to find a convergence for a small set of econometric models, even when a convergence exists. The Newton-Raphson algorithm allows users to solve a broader set of macro-econometric models than the Gauss-Seidel algorithm. Moreover, it is usually faster than the Gauss-Seidel algorithm (on modern computers, users must simulate an extensive econometric model with a low convergence criterion to appreciate the speedup). This type of algorithm requires the construction and the inversion of the Jacobian matrix for the feedback variables; thus, in some scenarios, numerical issues can arise, and users are required to manually exclude some feedback variables from the Jacobian matrix by using the <code>JacobianDrop</code> argument of the <code><a href="#topic+SIMULATE">SIMULATE</a></code> procedure.<br /><br />
More details are available in the <code><a href="#topic+SIMULATE">SIMULATE</a></code> help page. <br /> <br />
Back to Kelin's model example, let's forecast the <em>GNP</em> (i.e. the &quot;<code>y</code>&quot; endogenous variable, originally referred as &quot;Net national income, measured in billions of 1934 dollars&quot;, pag. 141 in &quot;Economic Fluctuations in the United States&quot; by L. R. Klein, Wiley and Sons Inc., New York, 1950) up to 1943: 
</p>
<pre>
R&gt; #FORECAST GNP in 1942:1944

R&gt; #we need to extend exogenous variables in 1942 up to 1944
R&gt; kleinModel$modelData &lt;- within(kleinModel$modelData,{
            w2   = TSEXTEND(w2,  UPTO=c(1944,1),EXTMODE='CONSTANT')
            t    = TSEXTEND(t,   UPTO=c(1944,1),EXTMODE='CONSTANT')
            g    = TSEXTEND(g,   UPTO=c(1944,1),EXTMODE='CONSTANT')
            time = TSEXTEND(time,UPTO=c(1944,1),EXTMODE='LINEAR')
            })

 
R&gt; #simulate model
R&gt; kleinModel &lt;- SIMULATE(kleinModel
            ,simType='FORECAST'
            ,TSRANGE=c(1941,1,1944,1)
            ,simConvergence=0.00001
            ,simIterLimit=100
            )
  
Simulation: 100.00 %
...SIMULATE OK

R&gt; #get forecasted GNP
R&gt; TABIT(kleinModel$simulation$y)

Date, Prd., kleinModel$simulation$y
1941, 1   ,  95.41613      
1942, 1   ,  106.8923      
1943, 1   ,  107.4302      
1944, 1   ,  100.7512     
</pre>
<p><img src="../help/figures/KleinGNP.png" alt="KleinGNP.png" /> <br /> <br />
</p>
<p>Below is an example of advanced simulation using the <code>NEWTON</code> algorithm:
</p>
<pre>

R&gt; #DYNAMIC NEWTON SIMULATION EXAMPLE 
R&gt; #WITH EXOGENIZATION AND CONSTANT ADJUSTMENTS
 
R&gt; #define exogenization list
R&gt; #'cn' exogenized in 1923-1925
R&gt; #'i' exogenized in whole TSRANGE
R&gt; exogenizeList &lt;- list(
                  cn = c(1923,1,1925,1),
                  i  = TRUE
                  )
 
R&gt; #define add-factor list
R&gt; #cn add-factor will be 1 in 1923 and -1 in 1924
R&gt; #y add-factor will be 0.1 in 1926, -0.1 in 1927 and -0.5 in 1928
R&gt; constantAdjList &lt;- list(
                 cn = TIMESERIES(1,-1,START=c(1923,1),FREQ='A'),
                 y  = TIMESERIES(0.1,-0.1,-0.5,START=c(1926,1),FREQ='A')
                 )
 
R&gt; #simulate model
R&gt; kleinModel &lt;- SIMULATE(kleinModel
                  ,simAlgo='NEWTON'
                  ,simType='DYNAMIC'
                  ,TSRANGE=c(1923,1,1941,1)
                  ,simConvergence=0.00001
                  ,simIterLimit=100
                  ,Exogenize=exogenizeList
                  ,ConstantAdjustment=constantAdjList 
                  )
</pre>

<table>
<tr>
 <td style="text-align: center;"><em>Stochastic Simulation</em></td>
</tr>

</table>

<p>Forecasts produced by structural econometric models are subject to several sources of error, such as random disturbance term of each stochastic equation, errors in estimated coefficients, errors in forecasts of exogenous variables, errors in preliminary data and mis-specification of the model.<br /><br />
The forecast error depending on the structural disturbances can be analyzed by using the stochastic simulation procedure.<br /><br />
The deterministic simulation is the simultaneous solution of an econometric model obtained by applying, for each stochastic (behavioral) equation, the expected values of the structural disturbances, which are all zero by assumption. In the BIMETS <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> stochastic simulation, the structural disturbances are given values that have specified stochastic properties. The error terms of the estimated behavioral equation of the model are appropriately perturbed. Identity equations and exogenous variables can be as well perturbed by disturbances that have specified stochastic properties. The model is then solved for each data set with different values of the disturbances. Finally, mean and standard deviation are computed for each simulated endogenous variable. <br /><br />
In terms of computational efficiency, the procedure takes advantage of the fact that multiple datasets are bound together in matrices. Therefore, to achieve a global convergence, the iterative simulation algorithm is executed once for all perturbed datasets. This solution can be viewed as a sort of a SIMD (i.e. Single Instruction Multiple Data) parallel simulation: <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> function transforms time series into matrices; consequently, the procedure can easily bind multiple datasets by column. At the same time, a single run ensures a fast code execution. Finally, each column in the output matrices represents a stochastic realization.<br /><br />
By using the <code>StochStructure</code> argument of this function, users can define a stochastic structure for the disturbances. For each variable of the model, users can provide a distinct probability distribution for the disturbance, and a specific time range of application. Mean and standard deviation for each simulated endogenous time series will be stored in the <code>stochastic_simulation</code> element of the output model object; all the stochastic realizations will be stored in the <code>simulation_MM</code> element of the output model object as named matrices.
</p>
<p>In the following figure, the advanced Klein model (see code example), has been perturbed during the forecast operation by applying a normal disturbance to the endogenous <em>Consumption</em> behavioral <code>cn</code> add-factor in year 1942, and a uniform disturbance to the exogenous <em>Government Expenditure</em> time series <code>g</code> along all the simulation <code>TSRANGE</code>. The normal disturbance applied to the <code>cn</code> behavioral has a zero mean and a standard deviation equal to the behavioral regression standard error,<br /> i.e. <code>advancedKleinModel$behaviorals$cn$statistics$StandardErrorRegression</code>, thus roughly replicating the <code><a href="#topic+ESTIMATE">ESTIMATE</a></code> regression error during the current perturbation (not accounting for inter-equations cross-covariance).<br /> <br /> 
<img src="../help/figures/StochKleinGNP.png" alt="StochKleinGNP.png" /> <br /> <br />
</p>
<pre>

R&gt; #we want to perform a stochastic forecast of the GNP up to 1944
R&gt; #we will add normal disturbances to endogenous Consumption 'cn' 
R&gt; #in 1942 by using its regression standard error
R&gt; #we will add uniform disturbances to exogenous Government Expenditure 'g'
R&gt; #in whole TSRANGE
R&gt; nSD=advancedKleinModel$behaviorals$cn$statistics$StandardErrorRegression
R&gt; myStochStructure &lt;- list(
  cn=list(
        TSRANGE=c(1942,1,1942,1),
        TYPE='NORM',
        PARS=c(0,nSD)
        ),
  g=list(
        TSRANGE=TRUE,
        TYPE='UNIF',
        PARS=c(-1,1)
        )
  )

R&gt; #we need to extend exogenous variables up to 1944
R&gt; advancedKleinModel$modelData &lt;- within(advancedKleinModel$modelData,{
    w2    = TSEXTEND(w2,  UPTO=c(1944,1),EXTMODE='CONSTANT')
    t     = TSEXTEND(t,   UPTO=c(1944,1),EXTMODE='LINEAR')
    g     = TSEXTEND(g,   UPTO=c(1944,1),EXTMODE='CONSTANT')
    k     = TSEXTEND(k,   UPTO=c(1944,1),EXTMODE='LINEAR')
    time  = TSEXTEND(time,UPTO=c(1944,1),EXTMODE='LINEAR')
  })

R&gt; #stochastic model forecast
R&gt; advancedKleinModel &lt;- STOCHSIMULATE(advancedKleinModel
                      ,simType='FORECAST'
                      ,TSRANGE=c(1941,1,1944,1)
                      ,StochStructure=myStochStructure
                      ,StochSeed=123
                      )
                      
R&gt; #print mean and standard deviation of forecasted GNP
R&gt; with(advancedKleinModel$stochastic_simulation,TABIT(y$mean, y$sd))

      Date, Prd., y$mean         , y$sd           

      1941, 1   ,  125.5045      ,  4.250935      
      1942, 1   ,  173.2946      ,  9.2632        
      1943, 1   ,  185.9602      ,  11.87774      
      1944, 1   ,  141.0807      ,  11.6973  

R&gt; #print the unperturbed forecasted GNP along with the
R&gt; #first 5 perturbed realizations
R&gt; with(advancedKleinModel$simulation_MM,print(y[,1:6]))


</pre>

<table>
<tr>
 <td style="text-align: center;"><em>Multipliers Analysis</em></td>
</tr>

</table>

<p>The BIMETS <code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code> function computes the matrix of both impact and interim multipliers, for a selected set of endogenous variables (i.e. <code>TARGET</code>) with respect to a selected set of exogenous variables (i.e. <code>INSTRUMENT</code>), by subtracting the results from different simulations in each period of the provided time range (i.e. <code>TSRANGE</code>). The simulation algorithms are the same as those used for the <code><a href="#topic+SIMULATE">SIMULATE</a></code> operation. <br /><br />
The <code>MULTMATRIX</code> procedure is articulated as follows:<br /><br />
1. simultaneous simulations are done;<br /><br />
2. the first simulation establishes the base line solution (without shocks);<br /><br />
3. the other simulations are done with shocks applied to each of the <code>INSTRUMENT</code> one at a time for every period in <code>TSRANGE</code>;<br /><br />
4. each simulation follows the defaults described in the <code><a href="#topic+SIMULATE">SIMULATE</a></code> help page, but has to be <code>STATIC</code> for the IMPACT multipliers and <code>DYNAMIC</code> for INTERIM multipliers;<br /><br />
5. given <code>MM_SHOCK</code> shock amount as a very small positive number, derivatives are computed by subtracting the base line solution of the <code>TARGET</code> from the shocked solution, then dividing by the value of the base line <code>INSTRUMENT</code> times the <code>MM_SHOCK</code>;<br /><br /><br />
BIMETS users can also declare an endogenous variable as the <code>INSTRUMENT</code> variable. In this case, the constant adjustment (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>) related to the provided endogenous variable will be used as the <code>INSTRUMENT</code> exogenous variable. <br /><br />
Back to our Klein's model example, we can calculate impact multipliers of <em>Government Expenditure</em> &quot;<code>g</code>&quot; and <em>Government Wage Bill</em> &quot;<code>w2</code>&quot; with respect of <em>Consumption</em> &quot;<code>cn</code>&quot; and <em>Gross National Product</em> &quot;<code>y</code>&quot; in the year 1941 by using the previously estimated model: 
</p>
<pre>
R&gt; kleinModel &lt;- MULTMATRIX(kleinModel,
                        symType='STATIC',
                        TSRANGE=c(1941,1,1941,1),
                        INSTRUMENT=c('w2','g'),
                        TARGET=c('cn','y')
                        )
Multiplier Matrix: 100.00 %
...MULTMATRIX OK

R&gt; kleinModel$MultiplierMatrix

           w2_1        g_1
cn_1  0.4540346   1.671956
y_1   0.2532000   3.653260
</pre>
<p>Results show that the impact multiplier of &quot;<code>y</code>&quot; with respect to &quot;<code>g</code>&quot; is +3.65. If we change the <em>Government Expenditure</em> &quot;<code>g</code>&quot; value in 1941 from 22.3 (his historical value) to 23.3 (+1), then the simulated <em>Gross National Product</em> &quot;<code>y</code>&quot; in 1941 changes from 95.2 to 99, thusly roughly confirming the +3.65 impact multiplier. Note that &quot;<code>g</code>&quot; only appears once in the model definition, and only in the &quot;<code>y</code>&quot; equation, with a coefficient equal to one (Keynes would approve).<br /><br />
An interim-multiplier example follows: 
</p>
<pre>
R&gt; #multi-period interim multipliers
R&gt; kleinModel &lt;- MULTMATRIX(kleinModel,
                   TSRANGE=c(1940,1,1941,1),
                   INSTRUMENT=c('w2','g'),
                   TARGET=c('cn','y'))
Multiplier Matrix: 100.00 %
...MULTMATRIX OK

R&gt; #output multipliers matrix (note the zeros where the period
R&gt; #of the INSTRUMENT is greater than the period of the TARGET)
R&gt; kleinModel$MultiplierMatrix

            w2_1       g_1       w2_2      g_2
cn_1   0.4478202  1.582292  0.0000000 0.000000
y_1    0.2433382  3.510971  0.0000000 0.000000
cn_2  -0.3911001  1.785042  0.4540346 1.671956
y_2   -0.6251177  2.843960  0.2532000 3.653260
</pre>

<table>
<tr>
 <td style="text-align: center;"><em>Endogenous Targeting</em></td>
</tr>

</table>

<p>The endogenous targeting of econometric models consists of solving the model while interchanging the role of one or more endogenous variables with an equal number of exogenous variables.<br /><br />
The BIMETS <code><a href="#topic+RENORM">RENORM</a></code>  procedure determines the values for the <code>INSTRUMENT</code> exogenous variables that allow the objective <code>TARGET</code> endogenous values to be achieved, with respect to the constraints given by the model equations (see <code><a href="#topic+MDL">MDL</a></code>).<br /><br />
This is an approach to economic and monetary policy analysis, and is based on two assumptions:<br /><br />
1. there exists a desired level for a set of the <code>n</code> endogenous variables defined as <code>TARGET</code>;<br />
2. there exists a set of the <code>n</code> exogenous variables defined as <code>INSTRUMENT</code>;<br /><br />
Given these premises, the endogenous targeting process consists in determining the values of the exogenous variables chosen as <code>INSTRUMENT</code> allowing us to achieve the desired values for the endogenous variables designated as <code>TARGET</code>. In other words the procedure allows users to exchange the role of exogenous and endogenous among a set of variables pairs. <br /><br />
Given a list of exogenous <code>INSTRUMENT</code> variables and a list of <code>TARGET</code> endogenous time series, the iterative procedure can be split into the following steps:<br /><br />
1. Computation of the multipliers matrix <code>MULTMAT</code> of the <code>TARGET</code> endogenous variables with respect to the <code>INSTRUMENT</code> exogenous variables (this is a square matrix by construction);<br /><br />
2. Solution of the linear system (if any): 
</p>
<p><code class="reqn">V_{exog}(i+1) = V_{exog}(i) +</code> <code>MULTMAT</code> <code class="reqn">^{-1} * (V_{endog}(i) -</code> <code>TARGET</code> <code class="reqn">)</code>, where <code class="reqn">V_{exog}(i)</code> are the exogenous variables in the <code>INSTRUMENT</code> list and <code class="reqn">V_{endog}(i)</code> are the endogenous variables that have a related target in the <code>TARGET</code> list, given <code>i</code> the current iteration;<br /><br />
3. Simulation of the model with the new set of exogenous variables computed in step 2, then a convergence check by comparing the subset of endogenous variables arising from this simulation and the related time series in <code>TARGET</code> list. If the convergence condition is satisfied, or the maximum number of iterations is reached, the algorithm will stop, otherwise it will go back to step 1;<br /><br />
Users can also declare an endogenous variable as an <code>INSTRUMENT</code> variable. In this case, the constant adjustment (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>) related to the provided endogenous variable will be used as the instrument exogenous variable. This procedure is particularly suited for the automatic computation of the add-factors needed to fine tune the model into a baseline path and to improve the forecasting accuracy.<br /><br />
If the convergence condition is satisfied, the <code>RENORM</code> procedure will return the <code>INSTRUMENT</code> time series allowing us to achieve the desired values for endogenous variables designated as <code>TARGET</code>.<br /><br />
Back to our Klein's model example, we can perform the endogenous targeting of the previously estimated model. First of all, the targets must be defined:
</p>
<pre>

R&gt; #we want an arbitrary value on Consumption of 66 in 1940 and 78 in 1941
R&gt; #we want an arbitrary value on GNP of 77 in 1940 and 98 in 1941

R&gt; kleinTargets  &lt;-  list(
              cn = TIMESERIES(66,78,START=c(1940,1),FREQ=1),
              y  = TIMESERIES(77,98,START=c(1940,1),FREQ=1)
              )
</pre>
<p>Then, we can perform the model endogenous targeting by using the &quot;<code>w2</code>&quot; (<em>Wage Bill of the Government Sector</em>) and the &quot;<code>g</code>&quot; (<em>Government Expenditure</em>) exogenous variables as <code>INSTRUMENT</code>, in the years 1940 and 1941:
</p>
<pre>
R&gt; kleinModel &lt;- RENORM(kleinModel
                   ,INSTRUMENT = c('w2','g')
                   ,TARGET = kleinTargets
                   ,TSRANGE = c(1940,1,1941,1)
                   ,simIterLimit = 100
                    )
</pre>
<p>Once <code>RENORM</code> completes, the calculated values of exogenous <code>INSTRUMENT</code> allowing us to achieve the desired endogenous <code>TARGET</code> values are stored in the model:
</p>
<pre>
R&gt; with(kleinModel,TABIT(modelData$w2,
                      renorm$INSTRUMENT$w2,
                      modelData$g,
                      renorm$INSTRUMENT$g,
                      TSRANGE=c(1940,1,1941,1)
                      )
          )
     
Date, Prd., modelData$w2, renorm$INSTRUMENT$w2, modelData$g, renorm$INSTRUMENT$g
1940,  1  , 8           , 7.413331            , 15.4       , 16.1069
1941,  1  , 8.5         , 9.3436              , 22.3       , 22.65985
     
</pre>
<p>So, if we want to achieve on &quot;<code>cn</code>&quot; (<em>Consumption</em>) an arbitrary simulated value of 66 in 1940 and 78 in 1941, and if we want to achieve on &quot;<code>y</code>&quot; (<em>GNP</em>) an arbitrary simulated value of 77 in 1940 and 98 in 1941, we need to change exogenous &quot;<code>w2</code>&quot; (<em>Wage Bill of the Government Sector</em>) from 8 to 7.41 in 1940 and from 8.5 to 9.34 in 1941, and we need to change exogenous &quot;<code>g</code>&quot; (<em>Government Expenditure</em>) from 15.4 to 16.1 in 1940 and from 22.3 to 22.66 in 1941. <br /><br />
</p>
<p>Let's verify:
</p>
<pre>
R&gt; #create a new model
R&gt; kleinRenorm &lt;- kleinModel

R&gt; #get instruments to be used
R&gt; newInstruments &lt;- kleinModel$renorm$INSTRUMENT

R&gt; #change exogenous by using new instruments data
R&gt; kleinRenorm$modelData &lt;- within(kleinRenorm$modelData,
                 {
                   w2[[1940,1]]=newInstruments$w2[[1940,1]]
                   w2[[1941,1]]=newInstruments$w2[[1941,1]]
                   g[[1940,1]] =newInstruments$g[[1940,1]]
                   g[[1941,1]] =newInstruments$g[[1941,1]]
                 }
                )
R&gt; #users can also replace last two commands with:
R&gt; #kleinRenorm$modelData &lt;- kleinRenorm$renorm$modelData

R&gt; #simulate the new model
R&gt; kleinRenorm &lt;- SIMULATE(kleinRenorm
                      ,TSRANGE=c(1940,1,1941,1)
                      ,simConvergence=0.00001
                      ,simIterLimit=100
                      )
Simulation: 100.00 %
...SIMULATE OK

R&gt; #verify targets are achieved
R&gt; with(kleinRenorm$simulation,
     TABIT(cn,y)
     )
     
Date, Prd., cn        , y
1940,  1  , 66.01116  , 77.01772
1941,  1  , 78.02538  , 98.04121


</pre>

<table>
<tr>
 <td style="text-align: center;"><em>Optimal Control</em></td>
</tr>

</table>

<p>An approach to policy evaluation is via a so-called &quot;social welfare function&quot;. This approach relaxes the assumptions of the instruments-targets framework, i.e. the <code><a href="#topic+RENORM">RENORM</a></code> procedure. Rather than assuming specific desired targets for some endogenous variables, it assumes the existence of a social welfare function determining a scalar measure of performance based on both endogenous and policy (exogenous) variables.
<br /><br />
The social welfare function can incorporate information about tradeoffs in objectives that are not allowed by the <code><a href="#topic+RENORM">RENORM</a></code> instruments-targets approach.
<br /><br />
BIMETS supplies the <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code> procedure in order to perform optimal control exercises on econometric models.
<br /><br />
The optimization consists of maximizing a social welfare function, i.e. the objective-function, depending on exogenous and (simulated) endogenous variables, subject to user constraints plus the constraints imposed by the econometric model equations. Users are allowed to define constraints and objective-functions of any degree, and are allowed to provide different constraints and objective-functions in different optimization time periods.
<br /><br />
The core of the <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code> procedure is based on a Monte Carlo method that takes advantage of the <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> procedure. Policy variables, i.e. <code>INSTRUMENT</code>, are uniformly perturbed in the range defined by the user-provided boundaries, then the <code>INSTRUMENT</code> values that i) verify the user-provided constraints and ii) maximize the objective-functions are selected and stored into the <code>optimize</code> element of the output BIMETS model.
<br /><br />
</p>
<p>In the following figure, the scatter plot is populated with <code>2916</code> objective function stochastic realizations, computed by using the example code at the end of this section; the <code>210.58</code> local maximum  is highlighted<br />(i.e. <code>advancedKleinModel$optimize$optFunMax</code> in code example).<br /><br /> In this example:<br /><br /> 
i) The objective function definition is:<br /> 
<code class="reqn">f(y,cn,g) = (y-110)+(cn-90)*|cn-90|-\sqrt{g-20}</code> <br />
given <code class="reqn">y</code> as the simulated <em>Gross National Product</em>, <code class="reqn">cn</code> as the simulated <em>Consumption</em> and <code class="reqn">g</code> as the exogenous <em>Government Expenditure</em>: the basic idea is to maximize <em>Consumption</em>, and secondarily the <em>Gross National Product</em>, while reducing the <em>Government Expenditure</em>;<br /><br /> 
ii) The <code>INSTRUMENT</code> variables are the <code class="reqn">cn</code> <em>Consumption</em> &quot;booster&quot; (i.e. the add-factor, not to be confused with the simulated <em>Consumption</em> in the objective function) and the <code class="reqn">g</code> <em>Government Expenditure</em>, defined over the following domains: <code class="reqn"> cn \in (-5,5)</code>, <code class="reqn">g \in (15,25)</code>;<br /><br />
iii) The following restrictions are applied to the <code>INSTRUMENT</code>: <code class="reqn">g + cn^2/2 &lt; 27 \wedge g + cn &gt; 17</code>, given <code class="reqn">cn</code> as the <em>Consumption</em> &quot;booster&quot; (i.e. the add-factor) and <code class="reqn">g</code> as the <em>Government Expenditure</em>;
</p>
<p><img src="../help/figures/OptKlein.png" alt="OptKlein.png" /> <br /> <br />
The figure clearly shows that non-linear restrictions have been applied, and that non-computable objective functions have been discarded, e.g. the stochastic realizations having <code class="reqn">g&lt;20</code> due to the square root operation in the objective function, given instrument <code class="reqn">g \in (15,25)</code>.
</p>
<p>An example of an optimal control exercise applied to the previoously defined <code>advancedKleinModel</code> follows:
</p>
<pre>

R&gt; #reset time series of the model object that have been 
R&gt; #modified in the stochastic simulation section
R&gt; advancedKleinModel &lt;- LOAD_MODEL_DATA(advancedKleinModel,kleinModelData)

R&gt; #we want to maximize the non-linear objective function:
R&gt; #f()=(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5
R&gt; #in 1942 by using INSTRUMENT cn in range (-5,5) 
R&gt; #(cn is endogenous so we use the add-factor)
R&gt; #and g in range (15,25)
R&gt; #we will also impose the following non-linear restriction:
R&gt; #g+(cn^2)/2&lt;27 &amp; g+cn&gt;17

R&gt; #we need to extend exogenous variables up to 1942
R&gt; advancedKleinModel$modelData &lt;- within(advancedKleinModel$modelData,{
    w2    = TSEXTEND(w2,  UPTO=c(1942,1),EXTMODE='CONSTANT')
    t     = TSEXTEND(t,   UPTO=c(1942,1),EXTMODE='LINEAR')
    g     = TSEXTEND(g,   UPTO=c(1942,1),EXTMODE='CONSTANT')
    k     = TSEXTEND(k,   UPTO=c(1942,1),EXTMODE='LINEAR')
    time  = TSEXTEND(time,UPTO=c(1942,1),EXTMODE='LINEAR')
})

R&gt; #define INSTRUMENT and boundaries
R&gt; myOptimizeBounds &lt;- list(
    cn=list(TSRANGE=TRUE,
            BOUNDS=c(-5,5)),
    g=list(TSRANGE=TRUE,
           BOUNDS=c(15,25))
)

R&gt; #define restrictions
R&gt; myOptimizeRestrictions &lt;- list(
    myRes1=list(
        TSRANGE=TRUE,
        INEQUALITY='g+(cn^2)/2&lt;27 &amp; g+cn&gt;17')
)

R&gt; #define objective function
R&gt; myOptimizeFunctions &lt;- list(
    myFun1=list(
        TSRANGE=TRUE,
        FUNCTION='(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5')
)

R&gt; #Monte-Carlo optimization by using 10000 stochastic realizations
R&gt; #and 1E-4 convergence criterion 
R&gt; advancedKleinModel &lt;- OPTIMIZE(advancedKleinModel
                          ,simType = 'FORECAST'
                          ,TSRANGE=c(1942,1,1942,1)
                          ,simConvergence= 1E-4
                          ,simIterLimit  = 1000
                          ,StochReplica  = 10000
                          ,StochSeed = 123
                          ,OptimizeBounds = myOptimizeBounds
                          ,OptimizeRestrictions = myOptimizeRestrictions
                          ,OptimizeFunctions = myOptimizeFunctions)
OPTIMIZE(): optimization boundaries for the add-factor of endogenous 
            variable "cn" are (-5,5) from year-period 1942-1 to 1942-1.
OPTIMIZE(): optimization boundaries for the exogenous 
            variable "g" are (15,25) from year-period 1942-1 to 1942-1.
OPTIMIZE(): optimization restriction "myRes1" is active 
            from year-period 1942-1 to 1942-1.
OPTIMIZE(): optimization objective function "myFun1" is active 
            from year-period 1942-1 to 1942-1.

Optimize:     100.00 %
OPTIMIZE(): 2916 out of 10000 objective function realizations (29%) 
            are finite and verify the provided restrictions.
...OPTIMIZE OK

R&gt; #print local maximum
R&gt; advancedKleinModel$optimize$optFunMax
[1] 210.5755

R&gt; #print INSTRUMENT that allow local maximum to be achieved
R&gt; advancedKleinModel$optimize$INSTRUMENT
$cn
Time Series:
Start = 1942 
End = 1942 
Frequency = 1 
[1] 2.032203

$g
Time Series:
Start = 1942 
End = 1942 
Frequency = 1 
[1] 24.89773

R&gt; #LET'S VERIFY RESULTS
R&gt; #copy into modelData the computed INSTRUMENT 
R&gt; #that allow to maximize the objective function 
R&gt; advancedKleinModel$modelData &lt;- advancedKleinModel$optimize$modelData

R&gt; #simulate the model by using the new INSTRUMENT
R&gt; #note: we used cn add-factor as OPTIMIZE instrument, so we need 
R&gt; #to pass the computed cn add-factor to the SIMULATE call
R&gt; newConstantAdjustment &lt;- advancedKleinModel$optimize$ConstantAdjustment
R&gt; advancedKleinModel &lt;- SIMULATE(advancedKleinModel
                  ,simType = 'FORECAST'
                  ,TSRANGE = c(1942,1,1942,1)
                  ,simConvergence = 1E-5
                  ,simIterLimit = 1000
                  ,ConstantAdjustment = newConstantAdjustment)

R&gt; #calculate objective function by using the SIMULATE output time series
R&gt; #(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5
R&gt; y  &lt;- advancedKleinModel$simulation$y
R&gt; cn &lt;- advancedKleinModel$simulation$cn
R&gt; g  &lt;- advancedKleinModel$modelData$g
R&gt; optFunTest &lt;- (y-110)+(cn-90)*abs(cn-90)-(g-20)^0.5

R&gt; #verify computed max is equal to optimization max
R&gt; #(in the following command TSPROJECT could be omitted because
R&gt; #myFun1$TSRANGE = TRUE)
R&gt; abs(sum(TSPROJECT(optFunTest
              ,TSRANGE=c(1942,1,1942,1)
              ,ARRAY = TRUE)
        ) - advancedKleinModel$optimize$optFunMax)  &lt; 1E-4
[1] TRUE
</pre>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bimets - Time Series And Econometric Modeling In R</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
 
<p>BIMETS estimation and simulation results have been compared to the output results of leading commercial econometric software by using several large and complex models.<br /><br />
The models used in the comparison have more than:<br /><br />
+100  behavioral equations;<br />
+700  technical identities;<br />
+500  coefficients;<br />
+1000 time series of endogenous and exogenous variables;<br /><br />
In these models, there are equations with restricted coefficients, polynomial distributed lags, error autocorrelation, and conditional evaluation of technical identities; all models have been simulated in <em>static</em>, <em>dynamic</em>, and <em>forecast</em> mode, with exogenization and constant adjustments of endogenous variables through the use of BIMETS capabilities.<br /><br />
In the +800 endogenous simulated time series over the +20 simulated periods (i.e. more than 16.000 simulated observations), the average <em>percentage</em> difference between BIMETS and leading commercial software results has a magnitude of <code class="reqn">10^{-7} \% </code>. The difference between results calculated by using different commercial software has the same average magnitude.<br /><br />
BIMETS stands for Bank of Italy Model Easy Time Series; it does not depend on compilers or third-party software so it can be freely downloaded and installed on Linux, MS Windows(R) and Mac OSX(R), without any further requirements. <br /><br />
More details in:<br /><br />
- <code><a href="#topic+MDL">MDL</a></code><br />
- <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
- <code><a href="#topic+ESTIMATE">ESTIMATE</a></code><br />
- <code><a href="#topic+SIMULATE">SIMULATE</a></code><br />
- <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code><br />
- <code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code><br />
- <code><a href="#topic+RENORM">RENORM</a></code><br />
- <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code><br />
</p>
<p>Disclaimer: <em>The views and opinions expressed in these pages are those of the authors and do not necessarily reflect the official policy or position of the Bank of Italy. Examples of analysis performed within these pages are only examples. They should not be utilized in real-world analytic products as they are based only on very limited and dated open source information. Assumptions made within the analysis are not reflective of the position of the Bank of Italy.</em><br />
</p>


<h3>Author(s)</h3>

<p> Andrea Luciani  &lt;andrea.luciani@bancaditalia.it&gt; <br />
Roberto Stok  &lt;roberto.stok@bancaditalia.it&gt; 
<br /> <br /> 
</p>

<hr>
<h2 id='bimetsConf'>
BIMETS Global Options Configuration
</h2><span id='topic+setBIMETSconf'></span><span id='topic+getBIMETSconf'></span><span id='topic+BIMETS+20configuration'></span><span id='topic+bimetsConf'></span>

<h3>Description</h3>

<p>BIMETS package depends on some options in order to transform and to present time series data. These options can be read or changed by using the functions:<br /> <code>setBIMETSconf(opt,value)</code> and <code>getBIMETSconf(opt)</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setBIMETSconf(opt=NULL, value=NULL, suppressOutput=FALSE)
getBIMETSconf(opt=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bimetsConf_+3A_opt">opt</code></td>
<td>

<p>Name of the BIMETS option. Available option names are:<br /> <br /> 
<b>BIMETS_CONF_DIP</b>: Date In Period. Users can associate to each observation in a time series the first or the last date in the period, i.e.  1 January or 31 December in the case of a yearly time series, 1 January/1 July or 30 June/31 December in the case of a semiannual time series, 1 January/31 January in the case of a monthly time series in January, etc. The assignments by date to time series (e.g. <code>ts['2000-01-01']=value</code>) need to be coherent to the value of this global option. Accepted values are:<br />
LAST: (default) each observation has associated the last date of the period, e.g. 31 Mar for a quarterly time series, 31 January for a monthly time series in the first period, etc.<br />
FIRST: each observation has associated the first date of the period, e.g. 1 Jan for a quarterly time series, 1 Feb for a monthly time series in the second period, etc.
<br /> <br />
<b>BIMETS_CONF_CCT</b>: Constructor Class Type. The package supports <code>ts()</code> and <code>xts()</code> time series as input arguments. Users can select the base class of a BIMETS time series, i.e. the class used when a time series is created with <code>TIMESERIES()</code> or converted to a BIMETS time series using <code>as.bimets()</code>. This is a global option; users can locally override the selection of the output class using the <code>class='TS'</code> or <code>class='XTS'</code> argument in the <code>TIMESERIES()</code> function. The option <code>BIMETS_CONF_CCT</code> can be assigned to the following values:<br />
TS: (default) the time series constructor <code>TIMESERIES()</code> and the conversion function <code>as.bimets()</code> return an object of class <code>ts()</code><br />
XTS: the time series constructor <code>TIMESERIES()</code> and the conversion function <code>as.bimets()</code> return an object of class <code>xts()</code>.
<br /> <br />
Please note that BIMETS package is faster using BIMETS_CONF_CCT='TS'<br /><br />
<b>BIMETS_CONF_NOC</b>: NO Compliance test. If this option is set <code>TRUE</code> then the compliance control check on input time series, i.e. <code><a href="#topic+is.bimets">is.bimets()</a></code>, will be globally disabled. The default is set to <code>FALSE</code>. The compliance check on input time series should generally be active, otherwise a malformed input time series can produce unwanted results in operations. 
<br />
</p>
</td></tr>
<tr><td><code id="bimetsConf_+3A_value">value</code></td>
<td>
 
<p>The value to be assigned to the BIMETS option.
</p>
</td></tr>
<tr><td><code id="bimetsConf_+3A_suppressoutput">suppressOutput</code></td>
<td>
 
<p>If <code>TRUE</code>, the output messages will be disabled.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>This function set or read global BIMETS options, and return a NULL value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+as.bimets">as.bimets</a></code><br />
<code><a href="#topic+fromBIMETStoXTS">fromBIMETStoXTS</a></code><br />
<code><a href="#topic+fromBIMETStoTS">fromBIMETStoTS</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#default BIMETS_CONF_DIP is LAST
	#create ts
	ts1&lt;-TSERIES((1:10),START=c(2000,1),FREQ=1)
	
	#transform to xts and print
	xt1&lt;-fromBIMETStoXTS(ts1)
	print(xt1)  #....dates as of 31 Dec
	
	#set configuration BIMETS_CONF_DIP to FIRST
	setBIMETSconf('BIMETS_CONF_DIP','FIRST')
	
	#create ts
	ts1&lt;-TSERIES((1:10),START=c(2000,1),FREQ=1)
	
	#transform to xts and print
	xt1&lt;-fromBIMETStoXTS(ts1)
	print(xt1)  #....dates as of 1 Jan
	
	#set configuration BIMETS_CONF_DIP to LAST
	setBIMETSconf('BIMETS_CONF_DIP','LAST')
	
	#default to XTS
	setBIMETSconf('BIMETS_CONF_CCT','XTS')
	
	#check compliance of xt1 and fail...	
	is.bimets(xt1) #... FALSE
	
	#set configuration BIMETS_CONF_DIP to FIRST
	setBIMETSconf('BIMETS_CONF_DIP','FIRST')
	
	#check compliance of xt1 and ok...	
	is.bimets(xt1) #... TRUE
	
	print(getBIMETSconf('BIMETS_CONF_DIP')) # ... returns FIRST		
	print(getBIMETSconf('BIMETS_CONF_CCT')) # ... returns XTS
	
	print(is.xts(TSERIES(1:10,START=c(2000,1),FREQ=1))) #...print TRUE
	print(is.ts(TSERIES(1:10,START=c(2000,1),FREQ=1,class='TS'))) #...print TRUE
	
	
	
	#NOC
	setBIMETSconf('BIMETS_CONF_CCT','XTS')
	is.bimets(xts()) #FALSE
	setBIMETSconf('BIMETS_CONF_NOC',TRUE) 
	is.bimets(xts()) #TRUE
	
	
	#...back to defaults
	setBIMETSconf('BIMETS_CONF_DIP','LAST')
	setBIMETSconf('BIMETS_CONF_CCT','TS')
	setBIMETSconf('BIMETS_CONF_NOC',FALSE)
	
	
</code></pre>

<hr>
<h2 id='bimetsDataset'>
BIMETS Internal Datasets
</h2><span id='topic+BIMETS+20Datasets'></span><span id='topic+bimets_12F_YP2D__'></span><span id='topic+bimets_12L_YP2D__'></span><span id='topic+bimets_12_D2YP__'></span><span id='topic+bimets_1F_YP2D__'></span><span id='topic+bimets_1L_YP2D__'></span><span id='topic+bimets_1_D2YP__'></span><span id='topic+bimets_24F_YP2D__'></span><span id='topic+bimets_24L_YP2D__'></span><span id='topic+bimets_24_D2YP__'></span><span id='topic+bimets_2F_YP2D__'></span><span id='topic+bimets_2L_YP2D__'></span><span id='topic+bimets_2_D2YP__'></span><span id='topic+bimets_366_D2YP__'></span><span id='topic+bimets_366_YP2D__'></span><span id='topic+bimets_36F_YP2D__'></span><span id='topic+bimets_36L_YP2D__'></span><span id='topic+bimets_36_D2YP__'></span><span id='topic+bimets_3F_YP2D__'></span><span id='topic+bimets_3L_YP2D__'></span><span id='topic+bimets_3_D2YP__'></span><span id='topic+bimets_4F_YP2D__'></span><span id='topic+bimets_4L_YP2D__'></span><span id='topic+bimets_4_D2YP__'></span><span id='topic+bimets_53F_YP2D__'></span><span id='topic+bimets_53L_YP2D__'></span><span id='topic+bimets_53_D2YP__'></span><span id='topic+bimets_static_TD90_1__'></span><span id='topic+bimets_static_TD90_2__'></span><span id='topic+bimets_static_TD90_3__'></span><span id='topic+bimets_static_TD90_4__'></span><span id='topic+bimets_static_TD90_5__'></span><span id='topic+bimets_static_TD90_6__'></span><span id='topic+bimets_static_TD90__'></span><span id='topic+bimets_static_G90_1__'></span><span id='topic+bimets_static_G90_2__'></span><span id='topic+bimets_static_G90_3__'></span><span id='topic+bimets_static_G90_4__'></span><span id='topic+bimets_static_G90_5__'></span><span id='topic+bimets_static_G90_6__'></span><span id='topic+bimets_static_G90__'></span><span id='topic+bimets_static_startYear___'></span><span id='topic+bimets_static_totalLength___'></span>

<h3>Description</h3>

<p>BIMETS package contains hidden datasets that allow a faster performance in time series analysis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+as.bimets">as.bimets</a></code><br />
<code><a href="#topic+fromBIMETStoXTS">fromBIMETStoXTS</a></code><br />
<code><a href="#topic+fromBIMETStoTS">fromBIMETStoTS</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
</p>

<hr>
<h2 id='CUMPROD'>
Cumulative Product
</h2><span id='topic+CUMPROD'></span>

<h3>Description</h3>

<p>This function returns the cumulative product of the elements of the input array or time series. The result is an object of the same class of the input, and its elements are the cumulative product of the current and the previous elements of the input. <br /> If the input is a time series, users can provide the argument <code>TSRANGE</code> in order to project the input time series before the cumulative product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CUMPROD(x=NULL, TSRANGE=NULL, avoidCompliance=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CUMPROD_+3A_x">x</code></td>
<td>

<p>Input numerical array or time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="CUMPROD_+3A_tsrange">TSRANGE</code></td>
<td>

<p>Optional date range of operations that process the input time series. <code>TSRANGE</code> must be specified as an array composed by starting year, starting period, ending year and ending period, i.e. <code>TSRANGE=c(START_Y,START_P,END_Y,END_P)</code>. The projection into the time interval specified in <code>TSRANGE</code> takes place before the cumulative product.
</p>
</td></tr>
<tr><td><code id="CUMPROD_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="CUMPROD_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of the same class of the input, i.e. an array or a BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+TSMERGE">MOVAVG</a></code><br />
<code><a href="#topic+TSDELTA">TSDELTA</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSLEAD">TSLEAD</a></code><br />
<code><a href="#topic+INDEXNUM">INDEXNUM</a></code><br />
<code><a href="#topic+VERIFY_MAGNITUDE">VERIFY_MAGNITUDE</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#create ts
	ts1&lt;-TSERIES(INTS(1,10),START=c(2000,1),FREQ='M')
	out_CUMPROD&lt;-CUMPROD(ts1)
	TABIT(out_CUMPROD)
	    
	out_CUMPROD&lt;-CUMPROD(ts1,TSRANGE=c(2000,4,2001,1))	
	TABIT(ts1,out_CUMPROD)
  
	#define an array
	arr1&lt;-c(INTS(1,5),INTS(-1,-5))
	out_CUMPROD&lt;-CUMPROD(arr1)
	print(out_CUMPROD)
	
	
</code></pre>

<hr>
<h2 id='CUMSUM'>
Cumulative Sum
</h2><span id='topic+CUMSUM'></span><span id='topic+CUMULO'></span>

<h3>Description</h3>

<p>This function returns the cumulative sum of the elements of the input array or time series. The result is an object of the same class of the input, and its elements are the cumulative sum of the current and the previous elements of the input. <br /> If the input is a time series, users can provide the argument <code>TSRANGE</code> in order to project the input time series before the cumulative sum. <br /> <code>CUMULO</code> is an alias form <code>CUMSUM</code> with the argument <code>MODE='YEARLY'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CUMSUM(x=NULL, TSRANGE=NULL, MODE=NULL, avoidCompliance=FALSE,...)
CUMULO(x=NULL, TSRANGE=NULL, avoidCompliance=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CUMSUM_+3A_x">x</code></td>
<td>

<p>Input numerical array or time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="CUMSUM_+3A_tsrange">TSRANGE</code></td>
<td>

<p>Optional date range of operations that process time series. <code>TSRANGE</code> must be specified as an array composed by starting year, starting period, ending year and ending period,<br /> i.e. <code>TSRANGE=c(START_YEAR,START_PERIOD,END_YEAR,END_PERIOD)</code>. The projection into the time interval specified in <code>TSRANGE</code> takes place before the cumulative sum.
</p>
</td></tr>
<tr><td><code id="CUMSUM_+3A_mode">MODE</code></td>
<td>

<p>When selecting <code>MODE='YEARLY'</code> or <code>MODE='MONTHLY'</code> the sum is reset to zero when a new year or a new month starts.
</p>
</td></tr>
<tr><td><code id="CUMSUM_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="CUMSUM_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of the same class of the input, i.e. an array or a BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+TSMERGE">MOVAVG</a></code><br />
<code><a href="#topic+TSDELTA">TSDELTA</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSLEAD">TSLEAD</a></code><br />
<code><a href="#topic+INDEXNUM">INDEXNUM</a></code><br />
<code><a href="#topic+CUMPROD">CUMPROD</a></code><br />
<code><a href="#topic+VERIFY_MAGNITUDE">VERIFY_MAGNITUDE</a></code><br />
<code><a href="#topic+GETRANGE">GETRANGE</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#create ts
	ts1&lt;-TSERIES(INTS(1,30),START=c(2000,1),FREQ='M')
	out_CUMSUM&lt;-CUMSUM(ts1)
	TABIT(out_CUMSUM)
	
	    
	out_CUMSUM&lt;-CUMSUM(ts1,TSRANGE=c(2000,4,2001,7))	
	out_CUMSUM_Y&lt;-CUMSUM(ts1,TSRANGE=c(2000,4,2001,7),MODE='YEARLY')
	TABIT(ts1,out_CUMSUM,out_CUMSUM_Y)
	
	
  
	#define an array
	arr1&lt;-c(INTS(1,10),INTS(-1,-10))
	out_CUMSUM&lt;-CUMSUM(arr1)
	print(out_CUMSUM)
	
	#print...1  3  6 10 15 21 ... 27 19 10  0
  
	
</code></pre>

<hr>
<h2 id='DAILY'>
Daily Time Series (Dis)Aggregation
</h2><span id='topic+DAILY'></span>

<h3>Description</h3>

<p>This function returns a daily disaggregated time series, by using as input an annual, semiannual, quarterly or monthly time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DAILY(x = NULL, fun = NULL, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DAILY_+3A_x">x</code></td>
<td>

<p>Input time series, that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="DAILY_+3A_fun">fun</code></td>
<td>
 
<p><b>NULL</b>: (default) the output value of each daily observation is set equal to the value of the input observation the date belongs to (i.e. duplicated values over the period)<br />
<b>INTERP_END</b>: the value of the input time series in a period is copied into the last day of the output time series that lies in the same period. Other values are calculated by linear interpolation.<br />
<b>INTERP_CENTER</b>: the value of the input time series in a period is copied into the median day of the output time series that lies in the same period. Other values are calculated by linear interpolation. <br />
<b>INTERP_BEGIN</b>: the value of the input time series in a period is copied into the first day of the output time series that lies in the same period. Other values are calculated by linear interpolation. <br />
</p>
</td></tr>
<tr><td><code id="DAILY_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See  <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="DAILY_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a daily BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+YEARLY">YEARLY</a></code><br />
<code><a href="#topic+SEMIANNUAL">SEMIANNUAL</a></code><br />
<code><a href="#topic+QUARTERLY">QUARTERLY</a></code><br />
<code><a href="#topic+MONTHLY">MONTHLY</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#TS quarterly
	ts1&lt;-TSERIES((1:2),START=c(2000,1),FREQ='Q')
	TABIT(DAILY(ts1,fun='INTERP_CENTER'))	
	
	#TS monthly
	ts1&lt;-TSERIES((1:4),START=c(2000,1),FREQ=12)
	TABIT(DAILY(ts1))	
	
</code></pre>

<hr>
<h2 id='date2yp'>
Date to Year-Period Conversion
</h2><span id='topic+date2yp'></span>

<h3>Description</h3>

<p>This function converts an object of class <code>Date()</code> to an array <code>c(YEAR,PERIOD)</code>, where <code>YEAR</code> and <code>PERIOD</code> are the year-period the input <code>Date()</code> belongs to, given an input frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date2yp(x = NULL, f = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date2yp_+3A_x">x</code></td>
<td>

<p>Input of class <code>Date()</code>.  
</p>
</td></tr>
<tr><td><code id="date2yp_+3A_f">f</code></td>
<td>

<p>Positive integer. Valid values are: 1, 2, 3, 4, 12, 24, 36, 53, 366
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a two-dimensional array <code>c(YEAR,PERIOD)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+yq2yp">yq2yp</a></code><br />
<code><a href="#topic+ym2yp">ym2yp</a></code><br />
<code><a href="#topic+GETDATE">GETDATE</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
print(date2yp(as.Date('2001/06/30'),2)) #2001,1
print(date2yp(as.Date('2002/03/23'),1)) #2002,1
print(date2yp(as.Date('2003/07/01'),366)) #2003,182
print(date2yp(as.Date('2004/09/13'),2)) #2004,2
print(date2yp(as.Date('2004/01/13'),12)) #2004,1	
print(date2yp(as.Date('2004/07/24'),4)) #2004,3
print(date2yp(c(as.Date('1900-01-01'),as.Date('1944-12-01'),
as.Date('1964-06-12'),as.Date('1923-03-01'),
as.Date('1943-12-05')),f=366)) #...
</code></pre>

<hr>
<h2 id='ELIMELS'>
Eliminate Elements from Arrays or Time Series
</h2><span id='topic+ELIMELS'></span>

<h3>Description</h3>

<p>This function eliminates the selected elements from the input array or the input time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ELIMELS(x=NULL, idx=NULL, avoidCompliance=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ELIMELS_+3A_x">x</code></td>
<td>

<p>Input numerical array or time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>. 
</p>
</td></tr>
<tr><td><code id="ELIMELS_+3A_idx">idx</code></td>
<td>

<p>Numerical array built with the indices of selected elements to be removed from the input. If the input is a time series the index must be provided as a sequence of numbers <code>IDX=YEAR+PERIOD/FREQ</code> with <code>YEAR</code> and <code>PERIOD</code> the year and the period to be removed (see example).
</p>
</td></tr>
<tr><td><code id="ELIMELS_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="ELIMELS_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an array with the kept elements from the input array or the input time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+LOCS">LOCS</a></code><br />
<code><a href="#topic+NAMELIST">NAMELIST</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+TSINFO">TSINFO</a></code><br />
<code><a href="#topic+TSLOOK">TSLOOK</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
<code><a href="#topic+NOELS">NOELS</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	
	print(ELIMELS(INTS(1,10),c(1,4,5))) 
	#print 2 3 6 7 8 9 10
	
	print(ELIMELS(TSERIES(1:10,START=c(2000,1),FREQ=4),c(2000.25,2000.75))) 
	#print 2  4  5  6  7  8  9 10 
	
				
</code></pre>

<hr>
<h2 id='ESTIMATE'>
Estimate a BIMETS model
</h2><span id='topic+ESTIMATE'></span>

<h3>Description</h3>

<p>This function estimates equations that are linear in the coefficients, as specified in the behavioral equations of the input model object. Coefficients can be estimated for single equations or blocks of simultaneous equations. Coefficients restriction procedure derives from Lagrange Multipliers' theory, while the Cochrane-Orcutt method allows accounting for residuals autocorrelation.<br /><br /> The estimation function supports:<br /><br />
- <em>Ordinary Least Squares</em>;<br />
- <em>Instrumental Variables</em>;<br />
- <em>Deterministic linear restrictions on the coefficients</em>;<br />
- <em>Almon Polynomial Distributed Lags</em>;<br />
- <em>Autocorrelation of the errors</em>;<br />
- <em>Structural stability analysis (Chow tests)</em>;<br /><br /> Further details on estimation calculus can be found in <code><a href="#topic+MDL">MDL</a></code> help page; further details on Chow test can be found below in this section;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESTIMATE(model=NULL, 
         eqList=NULL, 
         TSRANGE=NULL,
         forceTSRANGE=FALSE,
         estTech='OLS',
         IV=NULL,
         forceIV=FALSE,
         quietly=FALSE,
         tol=1e-28,
         digits=getOption('digits'),
         centerCOV=TRUE,
         CHOWTEST=FALSE,
         CHOWPAR=NULL,
         avoidCompliance=FALSE,
         ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESTIMATE_+3A_model">model</code></td>
<td>

<p>The BIMETS model object to be estimated (see also <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code>).
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_eqlist">eqList</code></td>
<td>

<p>The <code>character</code> array of behavioral names to be estimated. If it is <code>NULL</code> then all the behaviorals of the model will be estimated.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_tsrange">TSRANGE</code></td>
<td>

<p>The time range of the estimation, as a four dimensional numerical array, <br /> i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code>. The <code>TSRANGE</code> provided in the behavioral <code><a href="#topic+MDL">MDL</a></code> definition takes precedence over this function argument.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_forcetsrange">forceTSRANGE</code></td>
<td>

<p>If <code>TRUE</code>, the <code>TSRANGE</code> defined in the previous argument takes precedence over the <code>TSRANGE</code> provided in the behavioral <code><a href="#topic+MDL">MDL</a></code> definition.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_esttech">estTech</code></td>
<td>

<p>The estimation technique used in the regression. Ordinary Least Squares <code>OLS</code> and Instrumental Variables estimation <code>IV</code> are supported.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_iv">IV</code></td>
<td>

<p>The <code>character</code> array built with the Instrumental Variable expressions, in the case of Instrumental Variables estimation (see example).
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_forceiv">forceIV</code></td>
<td>

<p>If <code>TRUE</code>, the <code>IV</code> defined in the previous argument takes precedence over the <code>IV</code> provided in the behavioral <code><a href="#topic+MDL">MDL</a></code> definition.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_quietly">quietly</code></td>
<td>

<p>If <code>TRUE</code>, information messages will be suppressed, e.g. results and regression statistics.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_tol">tol</code></td>
<td>

<p>The tolerance for detecting linear dependencies in a matrix's columns when its inverse is requested. 
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_digits">digits</code></td>
<td>

<p>Controls the number of digits to print when printing coefficients and statistics of the estimation. Valid values are 1 to 22 with a default of 7.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_centercov">centerCOV</code></td>
<td>

<p>If <code>TRUE</code>, the function subtracts the mean from the residuals before calculating the residual covariance matrix.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_chowtest">CHOWTEST</code></td>
<td>

<p>If <code>TRUE</code>, the structural stability analysis will be performed.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_chowpar">CHOWPAR</code></td>
<td>

<p>Indicates the last year-period where the stability test is performed. If <code>NULL</code> it will be automatically calculated by using all available time series data. It must be provided as an integer array, e.g. <code>c(YEAR,PERIOD)</code>.
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of model time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="ESTIMATE_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>outputText=TRUE</code>, for each behavioral in the <code>eqList</code> this function will print out:<br /><br />
- the name of the estimated behavioral;<br />
- the estimation technique used;<br />
- the autocorrelation order of the error, if any, and the iterations count required to achieve the convergence;<br />
- the estimated equation with calculated coefficients and regressor expression; for each coefficient the T-statistic and the significance will be printed out;<br />
- the restriction equations imposed on the coefficients, if any;<br />
- the F-test for the restrictions, including the PDL restrictions, if any;<br />
- the final autocorrelation parameters for the error, along with their standard error, the T-statistic and the significance;<br />
- the <em>R-Squared</em> and the <em>Adjusted R-Squared</em>;<br />
- the <em>Durbin-Watson Statistic</em>;<br />
- the <em>Sum of squares of residuals</em>;<br />
- the <em>Standard Error of Regression</em>;<br />
- the <em>Log of the Likelihood Function</em>;<br />
- the <em>F-statistic</em> and the <em>F-probability</em>;<br />
- the <em>AIC</em> and the <em>BIC</em>;<br />
- the <em>Mean of the Dependent Variable</em>;<br />
- the <em>Number of Observations</em>;<br />
- the <em>Number of Degrees of Freedom</em>;<br />
- the <em>Current Sample</em>, i.e. the <code>TSRANGE</code> of estimation;<br />
</p>
<p>All probabilities lie between <code>[0, 1]</code>.<br />
</p>
<p>For each behavioral in the <code>eqList</code> this function will add 4 new named elements into the related behavioral of the output model object:<br /><br />
1) <code>coefficients</code>: a numerical array built with the estimated coefficients;<br />
2) <code>errorCoefficients</code>: a numerical array built with the estimated coefficient for the error autoregression, if the <code>ERROR&gt;</code> structure has been provided in the model <code><a href="#topic+MDL">MDL</a></code> definition;<br />
3) <code>residuals</code>: the time series of the regression residuals. If an <code>ERROR&gt;</code> structure has been provided in the behavioral definition, the related residuals will be calculated as described in the Cochrane-Orcutt procedure (see <code><a href="#topic+MDL">MDL</a></code>).<br />
3) <code>residuals_no_error_correction</code>:  if an <code>ERROR&gt;</code> structure has been provided in the behavioral definition, the residuals calcucated by using the original dependent and independent variables are stored into this list element.<br />
4) <code>statistics</code>: a list built with the parameters and the statistics of the estimation, e.g.:<br />
- <code>TSRANGE</code>: TSRANGE requested in the latest estimation of the behavioral;<br />
- <code>estimationTechinque</code>: estimation technique requested in the latest estimation of the behavioral;<br />
- <code>CoeffCovariance</code>: coefficients covariance;<br />
- <code>StandardErrorRegression</code> and <code>StandardErrorRegressionNotCentered</code>: standard error of the regression (centered and not-centered);<br />
- <code>CoeffTstatistic</code>: T-statistic of the coefficients;<br />
- <code>RSquared</code>: R-Squared;<br />
- <code>AdjustedRSquared</code>: adjusted R-Squared;<br />
- <code>DegreesOfFreedom</code>: degrees of freedom of the regression;<br />
- <code>CoeffPvalues</code>: coefficients p-values;<br />
- <code>LogLikelihood</code>:  Log of the Likelihood Function;<br />
- <code>Fstatistics</code>: F-statistics;<br />
- <code>RhosTstatistics</code>: rhos T-statistic (if any);<br />
- <code>FtestRestrValue</code>: F-test value for the restrictions;<br />
- <code>FtestRestrProbability</code>: F-test probability for the restrictions;<br />
- <code>AIC</code>: Akaike's Information Criterion;<br />
- <code>BIC</code>: Schwarz's Information Criterion;<br />
- <code>matrixX</code>: the regressors matrix;<br />
- <code>vectorY</code>: the dependent variable;<br />
- <code>matrixX_error_corrected</code>: the regressors matrix arising from the Cochrane-Orcutt procedure;<br />
- etc.
<br /><br />
</p>
<p><em>Structural Stability - Chow test</em><br /><br />
One of the main purposes of econometric modeling is its use for forecast and policy evaluation and, to this end, the stability of any behavioral equation parameters over time should be verified. In order to check for structural stability two different procedures, which can be derived from the so-called Chow-tests, are applied.<br />
</p>
<p>Given a sample of <code class="reqn">T_{0} = t_{k},...,t_{n}</code> observations (i.e. the base <code>TSRANGE</code>) and selecting an arbitrary forward extension in <code class="reqn">T_{1} = t_{k},...,t_{n},...,t_{m}</code> observations (i.e. the extended <code>TSRANGE</code>), with <code class="reqn"> k &lt; n &lt; m</code>, in the general case we have the following two regressions: <br /><br />
1) <code class="reqn">Y_{0} = \beta_{0}*X_{0}+\epsilon_{0},  \quad    \epsilon_{0} \sim \mathcal{N}(0,\,\sigma_{0}^{2}) </code>, having time series projected on the base <code>TSRANGE</code><br />
2) <code class="reqn">Y_{1} = \beta_{1}*X_{1}+\epsilon_{1},  \quad    \epsilon_{1} \sim \mathcal{N}(0,\,\sigma_{1}^{2}) </code>, having time series projected on the extended <code>TSRANGE</code><br />
</p>
<p>In general, a stability analysis is carried on in the following ways:<br />
- comparing the parameter estimates arising from the two regressions: this is known as the covariance analysis;<br />
- checking the accuracy of the forecast for the dependent variable in the extended <code>TSRANGE</code>, using the estimates produced in the base <code>TSRANGE</code>: this is known as the predictive power test.<br /><br />
The first Chow test is calculated as:
<code class="reqn">\tau = \frac{SSR_{1}-SSR_{0}}{SSR_{0}} \frac{DoF_{1}}{DoF_{1}-DoF_{0}} </code>, <br /> <br /> with <code class="reqn">SSR_{i}</code> as the sum of squared residuals and <code class="reqn">DoF_{i}</code> as the number of degrees of freedom in the regression <code class="reqn">i=0,1</code>. <br />
</p>
<p>The test is completed by calculating the following time series on the extended <code>TSRANGE</code>:<br />
- the forecast error;<br />
- the standard error of forecast;<br />
- the t-statistic for the error;<br /><br />
The standard error of the forecast for the <code class="reqn">t_j</code> observation in the extended <code>TSRANGE</code> is computed according to: <br />
</p>
<p><code class="reqn">SE_{j} = \sigma_{0} \sqrt{1+x_j^\top * ( X_{0}^\top * X_{0}^{ })^{-1} * x_j} </code> <br /><br /> having <code class="reqn">x_j</code> as the independent values (i.e. regressors) on the <code class="reqn">t_{j}</code> observation in the <code class="reqn">T_{1}</code> extended <code>TSRANGE</code>,  with <code class="reqn">n &lt; j \leq m</code>. <br /><br />
The null hypothesis for <code class="reqn">\tau</code> is: <br /><br />
<code class="reqn"> H^{*} : \beta_{1} = \beta_{0}</code>, given <code class="reqn">\sigma_{1}^{2} = \sigma_{0}^{2}</code> <br /><br />
The test statistic <code class="reqn">\tau</code> follows the <code class="reqn">F</code> distribution with  <code class="reqn"> ( DoF_{1}-DoF_{0} ) </code> and <code class="reqn">DoF_{1}</code> degrees of freedom, and can be performed during the <code>ESTIMATE()</code> function execution by using the <code>CHOWTEST</code> argument set to <code>TRUE</code>.
</p>
<p>If <code>CHOWTEST</code> is <code>TRUE</code>, for each behavioral in the <code>eqList</code> the output model will have the following named element:<br />
- <code>ChowTest</code>: it contains the statistics and the time series computed during the last structural analysis performed on the related behavioral.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MDL">MDL</a></code><br />
<code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
<code><a href="#topic+SIMULATE">SIMULATE</a></code><br />
<code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code><br />
<code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code><br />
<code><a href="#topic+RENORM">RENORM</a></code><br />
<code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
<code><a href="#topic+summary.BIMETS_MODEL">summary</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#define model
myModelDefinition&lt;-
"MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL,
COMMENT&gt; autocorrelation on errors, restrictions 
COMMENT&gt; and conditional evaluations

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; cn = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1923 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 3

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1)
IF&gt; i &lt;= 0
END"

#define model data
myModelData&lt;-list(
  cn
  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
              45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
              START=c(1920,1),FREQ=1),
  g
  =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
              10.5,10.3,11,13,14.4,15.4,22.3,
              START=c(1920,1),FREQ=1),
  i
  =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
              2.1,2,-1.9,1.3,3.3,4.9,
              START=c(1920,1),FREQ=1),
  k
  =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
              216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
              201.2,204.5,209.4,
              START=c(1920,1),FREQ=1),
  p
  =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
              7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
              START=c(1920,1),FREQ=1),
  w1
  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
              29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
              START=c(1920,1),FREQ=1),
  y
  =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
              45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
              START=c(1920,1),FREQ=1),
  t
  =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
              8.3,6.7,7.4,8.9,9.6,11.6,
              START=c(1920,1),FREQ=1),
  time 
  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
              START=c(1920,1),FREQ=1),
  w2
  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
              7.4,6.7,7.7,7.8,8,8.5,
              START=c(1920,1),FREQ=1)
)


#load model 
myModel&lt;-LOAD_MODEL(modelText=myModelDefinition)

#load data into the model
myModel&lt;-LOAD_MODEL_DATA(myModel,myModelData,showWarnings = TRUE)

#################################################
#OLS case

#estimate the model
myModel&lt;-ESTIMATE(myModel)

#HERE BELOW THE OUTPUT OF THE ESTIMATION (COMMENTED OUT):
#.CHECK_MODEL_DATA(): warning, there are undefined values in time series "time".
#
#Estimate the Model myModelDefinition:
#the number of behavioral equations to be estimated is 3.
#The total number of coefficients is 14.
#
#_________________________________________
#
#BEHAVIORAL EQUATION: cn
#Estimation Technique: OLS
#Autoregression of Order  2  (Cochrane-Orcutt procedure)
#
#Convergence was reached in  9  /  20  iterations.
#
#
#cn                  =   19.01352    
#                        T-stat. 12.13083    ***
#
#                    +   0.3442816   p
#                        T-stat. 3.533253    **
#
#                    +   0.03443117  TSLAG(p,1)
#                        T-stat. 0.3937881   
#
#                    +   0.6993905   (w1+w2)
#                        T-stat. 14.0808     ***
#
#ERROR STRUCTURE:  AUTO(2) 
#
#AUTOREGRESSIVE PARAMETERS:
#Rho             Std. Error      T-stat.         
# 0.05743131      0.3324101       0.1727725       
# 0.007785936     0.2647013       0.02941404      
#
#
#STATs:
#R-Squared                      : 0.985263    
#Adjusted R-Squared             : 0.9785644   
#Durbin-Watson Statistic        : 1.966609    
#Sum of squares of residuals    : 9.273455    
#Standard Error of Regression   : 0.9181728   
#Log of the Likelihood Function : -18.97047   
#F-statistic                    : 147.0844    
#F-probability                  : 1.090551e-09
#Akaike's IC                    : 51.94093    
#Schwarz's IC                   : 57.77343    
#Mean of Dependent Variable     : 55.71765    
#Number of Observations         : 17
#Number of Degrees of Freedom   : 11
#Current Sample (year-period)   : 1925-1 / 1941-1
#
#
#Signif. codes:   *** 0.001  ** 0.01  * 0.05  
#
#
#
#_________________________________________
#
#BEHAVIORAL EQUATION: i
#Estimation Technique: OLS
#
#i                   =   2.868104    
#                        T-stat. 0.3265098   
#
#                    +   0.5787626   p
#                        T-stat. 4.456542    ***
#
#                    +   0.4212374   TSLAG(p,1)
#                        T-stat. 3.243579    **
#
#                    -   0.09160307  TSLAG(k,1)
#                        T-stat. -2.11748    
#
#RESTRICTIONS:
#b2+b3=1
#
#RESTRICTIONS F-TEST:
#F-value            : 8.194478       
#F-prob(1,15)       : 0.0118602      
#
#
#STATs:
#R-Squared                      : 0.8928283   
#Adjusted R-Squared             : 0.8794319   
#Durbin-Watson Statistic        : 1.173106    
#Sum of squares of residuals    : 26.76483    
#Standard Error of Regression   : 1.293368    
#Log of the Likelihood Function : -30.215     
#F-statistic                    : 66.64659    
#F-probability                  : 1.740364e-08
#Akaike's IC                    : 68.43001    
#Schwarz's IC                   : 72.20776    
#Mean of Dependent Variable     : 1.310526    
#Number of Observations         : 19
#Number of Degrees of Freedom   : 16
#Current Sample (year-period)   : 1923-1 / 1941-1
#
#
#Signif. codes:   *** 0.001  ** 0.01  * 0.05  
#
#
#
#_________________________________________
#
#BEHAVIORAL EQUATION: w1
#Estimation Technique: OLS
#
#w1                  =   1.12869     
#                        T-stat. 0.6479266   
#
#                    +   0.4398767   (y+t-w2)
#                        T-stat. 12.01268    ***
#
#                    +   c3          TSLAG(y+t-w2,1)
#                        PDL
#
#                    +   0.1368206   time
#                        T-stat. 3.373905    **
#
#PDL:
#c3 1 3
#
#Distributed Lag Coefficient: c3
#Lag     Coeff.         Std. Error     T-stat.        
#0        0.1076812      0.04283967     2.513586      *
#1        0.05074557     0.01291231     3.930015      **
#2       -0.00619005     0.03110492    -0.1990055     
#SUM      0.1522367      0.03873693    
#
#RESTRICTIONS F-TEST:
#F-value            : 0.06920179     
#F-prob(1,11)       : 0.7973647      
#
#
#STATs:
#R-Squared                      : 0.9890855   
#Adjusted R-Squared             : 0.9854474   
#Durbin-Watson Statistic        : 2.174168    
#Sum of squares of residuals    : 6.392707    
#Standard Error of Regression   : 0.7298805   
#Log of the Likelihood Function : -15.80848   
#F-statistic                    : 271.8645    
#F-probability                  : 1.172284e-11
#Akaike's IC                    : 43.61697    
#Schwarz's IC                   : 48.61625    
#Mean of Dependent Variable     : 37.69412    
#Number of Observations         : 17
#Number of Degrees of Freedom   : 12
#Current Sample (year-period)   : 1925-1 / 1941-1
#
#
#Signif. codes:   *** 0.001  ** 0.01  * 0.05  
#
#
#...ESTIMATE OK

#get residuals of 'cn'
myModel$behaviorals$cn$residuals
#Time Series:
#Start = 1925 
#End = 1941 
#Frequency = 1 
# [1] -0.88562504  0.25109884  0.66750111  ...
#[17] -1.41795908

#get residuals of 'i'
myModel$behaviorals$i$residuals
#Time Series:
#Start = 1923 
#End = 1941 
#Frequency = 1 
# [1]  1.464518775 -1.469763968  0.078674017  ...
#[16] -2.425079127 -0.698071507 -1.352967430 -1.724306054

#get estimation coefficients of 'cn' and 'w1'
myModel$behaviorals$cn$coefficients
#          [,1]
#a1 19.01352476
#a2  0.34428157
#a3  0.03443117
#a4  0.69939052

myModel$behaviorals$cn$errorCoefficients
#             [,1]
#RHO_1 0.057431312
#RHO_2 0.007785936

myModel$behaviorals$w1$coefficients
#                [,1]
#c1        1.12869024
#c2        0.43987666
#c3        0.10768118
#c3_PDL_1  0.05074557
#c3_PDL_2 -0.00619005
#c4        0.13682057


#################################################
#IV case

#estimation of Consumption "cn" with arbitrary IVs
#and error autocorrelation
myModel&lt;-ESTIMATE(myModel,
                 eqList = 'cn',
                 estTech = 'IV', 
                 IV=c('1',
                      'TSLAG(y)',
                      'TSLAG(w1)*pi+0.5',
                      'exp(w2)'))
#Estimate the Model myModelDefinition:
#the number of behavioral equations to be estimated is 1.
#The total number of coefficients is 4.
#
#_________________________________________
#
#BEHAVIORAL EQUATION: cn
#Estimation Technique: IV
#Autoregression of Order  2  (Cochrane-Orcutt procedure)
#
#Convergence was reached in  7  /  20  iterations.
#
#
#cn                  =   18.07073    
#                        T-stat. 11.72958    ***
#
#                    +   0.2530483   p
#                        T-stat. 1.583881    
#
#                    +   0.08631646  TSLAG(p,1)
#                        T-stat. 0.7556204   
#
#                    +   0.7363227   (w1+w2)
#                        T-stat. 13.11572    ***
#
#ERROR STRUCTURE:  AUTO(2) 
#
#AUTOREGRESSIVE PARAMETERS:
#Rho             Std. Error      T-stat.         
#0.01559806      0.343195        0.04544955      
#-0.1196327       0.283432       -0.422086        
#
#
#STATs:
#R-Squared                      : 0.9843186   
#Adjusted R-Squared             : 0.9771907   
#Durbin-Watson Statistic        : 1.917329    
#Sum of squares of residuals    : 9.867739    
#Standard Error of Regression   : 0.9471363   
#Log of the Likelihood Function : -19.49844   
#F-statistic                    : 138.0938    
#F-probability                  : 1.532807e-09
#Akaike's IC                    : 52.99689    
#Schwarz's IC                   : 58.82938    
#Mean of Dependent Variable     : 55.71765    
#Number of Observations         : 17
#Number of Degrees of Freedom   : 11
#Current Sample (year-period)   : 1925-1 / 1941-1
#
#
#Signif. codes:   *** 0.001  ** 0.01  * 0.05  
#
#
#...ESTIMATE OK

#define model
myShortModelDefinition&lt;-
  "MODEL
  COMMENT&gt; Consumption with IV
  BEHAVIORAL&gt; cn
  TSRANGE 1925 1 1941 1
  EQ&gt; cn = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
  COEFF&gt; a1 a2 a3 a4
  IV&gt; 1
  IV&gt; TSLAG(y)
  IV&gt; TSLAG(w1)*pi+0.5
  IV&gt; exp(w2)
  END
  " 


#load model 
myShortModel&lt;-LOAD_MODEL(modelText=myShortModelDefinition)

#load data into the model
myShortModel&lt;-LOAD_MODEL_DATA(myShortModel,myModelData,showWarnings = TRUE)

#estimation of Consumption "cn" with arbitrary IVs
#and error autocorrelation
myShortModel&lt;-ESTIMATE(myShortModel,
                 eqList = 'cn',
                 estTech = 'IV')


#estimation of Investment "i" with arbitrary IVs
#and coefficient restrictions
myModel&lt;-ESTIMATE(myModel,
                 eqList = 'i',
                 estTech = 'IV', 
                 IV=c('1',
                      'TSLAG(w2)',
                      'TSLAG(w1)*pi+0.5',
                      'exp(w2)'))

#.CHECK_MODEL_DATA(): warning, there are undefined values in time series "time".
#
#Estimate the Model myModelDefinition:
#the number of behavioral equations to be estimated is 1.
#The total number of coefficients is 4.
#
#_________________________________________
#
#BEHAVIORAL EQUATION: i
#Estimation Technique: IV
#
#i                   =   34.517544    
#                        T-stat. 1.264388   
#
#                    +   0.3216326   p
#                        T-stat. 0.8648297   
#
#                    +   0.6783672   TSLAG(p,1)
#                        T-stat. 1.824043    
#
#                    -   0.2475568   TSLAG(k,1)
#                        T-stat. -1.842520   
#
#RESTRICTIONS:
#b2+b3=1
#
#RESTRICTIONS F-TEST:
#F-value            : 2.465920       
#F-prob(1,15)       : 0.137190
#
#
#STATs:
#R-Squared                      : 0.805773   
#Adjusted R-Squared             : 0.781494   
#Durbin-Watson Statistic        : 0.940534   
#Sum of squares of residuals    : 48.50580  
#Standard Error of Regression   : 1.741152    
#Log of the Likelihood Function : -35.86365   
#F-statistic                    : 33.18894    
#F-probability                  : 2.025229e-06
#Akaike's IC                    : 79.72731     
#Schwarz's IC                   : 83.50506    
#Mean of Dependent Variable     : 1.310526    
#Number of Observations         : 19
#Number of Degrees of Freedom   : 16
#Current Sample (year-period)   : 1923-1 / 1941-1
#
#
#Signif. codes:   *** 0.001  ** 0.01  * 0.05  
#
#
#...ESTIMATE OK

##############################################################
#CHOW TEST on w1

#base TSRANGE set to 1925 / 1935
myModel&lt;-ESTIMATE(myModel,
                  eqList='w1',
                  TSRANGE=c(1925,1,1935,1),
                  forceTSRANGE=TRUE,
                  CHOWTEST=TRUE)

#Estimate the Model myModelDefinition:
#the number of behavioral equations to be estimated is 1.
#The total number of coefficients is 6.
#
#_________________________________________
#
#BEHAVIORAL EQUATION: w1
#Estimation Technique: OLS
#
#w1                = -   4.48873    
#                        T-stat. -2.47402   *
#
#                    +   0.545102   (y+t-w2)
#                        T-stat. 15.3462    ***
#
#                    +   c3         TSLAG(y+t-w2,1)
#                        PDL
#
#                    +   0.292018   time
#                        T-stat. 5.58588    **
#
#PDL:
#c3 1 3
#
#Distributed Lag Coefficient: c3
#Lag     Coeff.        Std. Error    T-stat.       
#0        0.0413985     0.0336676     1.22963      
#1        0.0493551     0.00742323    6.64873      ***
#2        0.0573116     0.0265487     2.15873      
#SUM      0.148065      0.0222697    
#
#RESTRICTIONS F-TEST:
#F-value            : 3.35954       
#F-prob(1,5)        : 0.126295      
#
#
#STATs:
#R-Squared                      : 0.995931   
#Adjusted R-Squared             : 0.993219   
#Durbin-Watson Statistic        : 2.43313    
#Sum of squares of residuals    : 0.737093   
#Standard Error of Regression   : 0.350498   
#Log of the Likelihood Function : -0.742173  
#F-statistic                    : 367.183    
#F-probability                  : 2.68564e-07
#Akaike's IC                    : 13.4843    
#Schwarz's IC                   : 15.8717    
#Mean of Dependent Variable     : 34.9909    
#Number of Observations         : 11
#Number of Degrees of Freedom   : 6
#Current Sample (year-period)   : 1925-1 / 1935-1
#
#
#Signif. codes:   *** 0.001  ** 0.01  * 0.05  
#
#
#
#STABILITY ANALYSIS:
#Behavioral equation: w1 
#
#Chow test:
#Sample (auto)      : 1936-1 / 1941-1 
#F-value            : 15.3457       
#F-prob(6,12)       : 5.34447e-05    
#
#Predictive Power:
#
#Date, Prd., Actual        , Predict       , Error         , Std. Error    , T-stat         
#
#1936, 1   ,  36.8         ,  38.439       , -1.63901      ,  0.547471     , -2.99378      
#1937, 1   ,  41           ,  40.824       ,  0.176033     ,  0.630905     ,  0.279017     
#1938, 1   ,  38.2         ,  39.6553      , -1.4553       ,  0.672192     , -2.165        
#1939, 1   ,  41.6         ,  45.0547      , -3.45466      ,  0.834433     , -4.14012      
#1940, 1   ,  45           ,  49.0118      , -4.01179      ,  0.966472     , -4.15096      
#1941, 1   ,  53.3         ,  56.6727      , -3.37275      ,  1.23486      , -2.73127   
#     
#
#...ESTIMATE OK
</code></pre>

<hr>
<h2 id='frequency'>
Frequency of a Time Series
</h2><span id='topic+frequency'></span><span id='topic+frequency.xts'></span>

<h3>Description</h3>

<p>This function returns the frequency of a time series. In the case of a sparse <code>xts()</code> time series, and in other cases, the R functions <code>xts::periodicity()</code> and <code>frequency()</code> do not return BIMETS compliant values. Therefore, these functions have been extended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
frequency(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frequency_+3A_x">x</code></td>
<td>

<p>Input time series.
</p>
</td></tr>
<tr><td><code id="frequency_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the integer value stored in the attribute <code>.bimetsFreq</code> of the input time series, if any. Otherwise, the frequency will be calculated by using the shortest time difference between two observations, while accounting for day-saving and bissextile years. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalizeYP">normalizeYP</a></code><br />
<code><a href="#topic+NUMPERIOD">NUMPERIOD</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>		
	#build a sparse xts()
	xArr&lt;-rnorm(13)
	dateArr&lt;-seq(as.Date('2000/01/01'),by='6 months',length=10)
	dateArr2&lt;-seq(as.Date('2010/01/01'),by='3 months',length=3)
	
	#strange array of dates here below...
	dateArr3&lt;-c(dateArr,dateArr2)
	dataF&lt;-data.frame(dateArr3,xArr)
	xt&lt;-xts(dataF[,2],order.by=dataF[,1])
	
	#get bimets calculated frequency
	cat(frequency(xt)) #print 4... without bimets R returns 1
	
	#...legacy periodicity()
	periodicity(xt)
	
	
</code></pre>

<hr>
<h2 id='fromBIMETStoTS'>
Convert BIMETS to TS
</h2><span id='topic+fromBIMETStoTS'></span>

<h3>Description</h3>

<p>This function transforms a BIMETS compliant time series (as defined in <code><a href="#topic+is.bimets">is.bimets</a></code>) into a time series of class <code>ts()</code>. The core R function as.ts() does not satisfy all the compliance control check requirements, so it has been extended. Attributes and description of the input time series will be copied to the output time series (see <code><a href="#topic+TSERIES">TIMESERIES</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromBIMETStoTS(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromBIMETStoTS_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="fromBIMETStoTS_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a time series of class <code>ts()</code> that has the same observations of the input BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fromBIMETStoXTS">fromBIMETStoXTS</a></code><br />
<code><a href="#topic+as.bimets">as.bimets</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	
	#work with XTS
	setBIMETSconf('BIMETS_CONF_CCT','XTS')
	
	#create yearly time series
	xts&lt;-TSERIES(1:10,START=c(2000,1),FREQ='A')
	print(is.ts(xts))#FALSE
	#convert to ts
	ts&lt;-fromBIMETStoTS(xts)
	print(is.ts(ts))#TRUE
	print(ts)
	
	#create monthly time series
	xts&lt;-TSERIES(1:10,START=c(2000,1),FREQ='M')
	print(is.ts(xts))#FALSE
	#convert to ts
	ts&lt;-fromBIMETStoTS(xts)
	print(is.ts(ts))#TRUE
	print(ts)
	
	#create daily time series
	xts&lt;-TSERIES(1:10,START=c(2000,1),FREQ='D')
	print(is.ts(xts))#FALSE
	#convert to ts
	ts&lt;-fromBIMETStoTS(xts)
	print(is.ts(ts))#TRUE
	print(ts)
	

	
	#reset default	
	setBIMETSconf('BIMETS_CONF_CCT','TS')
</code></pre>

<hr>
<h2 id='fromBIMETStoXTS'>
Convert BIMETS to XTS
</h2><span id='topic+fromBIMETStoXTS'></span>

<h3>Description</h3>

<p>This function transforms a BIMETS compliant time series (as defined in <code><a href="#topic+is.bimets">is.bimets</a></code>) 
into a time series of class <code>xts()</code>.<br /> The core XTS function as.xts() does not satisfy all the compliance control check requirements, so it has been extended. If the output time series will have an <code>.indexClass</code> of type <code>Date()</code>, i.e. neither monthly nor quarterly, the output dates will be chosen accordingly to the BIMETS option <code>BIMETS_CONF_DIP</code>: if this option is set to <code>LAST</code> (default), the output <code>xts()</code> time series will have the date of the period set equal to the last day in the same period, e.g. 31 December for yearly time series, 30 June for semiannual, etc.; if the BIMETS option <code>BIMETS_CONF_DIP</code> is set to <code>FIRST</code>, the output <code>xts()</code> time series will have the date of the period set equal to the first day in the same period, e.g. 1 January for yearly time series, 1 July for semiannual time series on the second period, etc. <br /> In the case of quarterly time series the <code>.indexClass=yearqtr</code>; <br />
in the case of monthly time series the <code>.indexClass=yearmon</code>.<br /> Attributes and description of the input time series will be copied to the output time series (see <code><a href="#topic+TSERIES">TIMESERIES</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromBIMETStoXTS(x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromBIMETStoXTS_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="fromBIMETStoXTS_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a time series of class <code>xts()</code> that has the same observations of the input BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fromBIMETStoTS">fromBIMETStoTS</a></code><br />
<code><a href="#topic+as.bimets">as.bimets</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#create yearly time series
	ts&lt;-TSERIES(1:10,START=c(2000,1),FREQ='A')
	print(is.xts(ts))#FALSE
	#convert to xts
	xts&lt;-fromBIMETStoXTS(ts)
	print(is.xts(xts))#TRUE
	print(xts)
	
	#create monthly time series
	ts&lt;-TSERIES(1:10,START=c(2000,1),FREQ='M')
	print(is.xts(ts))#FALSE
	#convert to xts
	xts&lt;-fromBIMETStoXTS(ts)
	print(is.xts(xts))#TRUE
	print(xts)
	
	#create daily time series
	ts&lt;-TSERIES(1:10,START=c(2000,1),FREQ='D')
	print(is.xts(ts))#FALSE
	#convert to xts
	xts&lt;-fromBIMETStoXTS(ts)
	print(is.xts(xts))#TRUE
	print(xts)
	
	#create yearly time series with first date on period
	setBIMETSconf('BIMETS_CONF_DIP','FIRST')
	ts&lt;-TSERIES(1:10,START=c(2000,1),FREQ='A')
	print(is.xts(ts))#FALSE
	#convert to xts
	xts=fromBIMETStoXTS(ts)
	print(is.xts(xts))#TRUE
	print(xts)#dates on Jan 1
	
	#reset default
	setBIMETSconf('BIMETS_CONF_DIP','LAST')
	
	
</code></pre>

<hr>
<h2 id='fromTStoXTS'>
Convert TS to XTS
</h2><span id='topic+fromTStoXTS'></span>

<h3>Description</h3>

<p>This function transforms a BIMETS compliant <code>ts</code> time series (as defined in <code><a href="#topic+is.bimets">is.bimets</a></code>) into a time series of class <code>xts()</code>.<br /> The core XTS function as.xts() does not satisfy all the compliance control check requirements, so it has been extended. If the output time series has an <code>.indexClass</code> of type <code>Date()</code>, i.e. neither monthly nor quarterly, the output dates are chosen accordingly to the BIMETS option <code>BIMETS_CONF_DIP</code>: if this option is set to <code>LAST</code> (default), the output <code>xts()</code> time series will have the date of the period set equal to the last day in the same period, e.g. 31 December for yearly time series, 30 June for semiannual, etc.; if BIMETS option <code>BIMETS_CONF_DIP</code> is set to <code>FIRST</code>, the output <code>xts()</code> time series will have the date of the period set equal to the first day in the same period, e.g. 1 January for yearly time series, 1 July for semiannual time series on the second period, etc. <br /> In the case of quarterly time series the <code>.indexClass=yearqtr</code>; <br />
in the case of monthly time series the <code>.indexClass=yearmon</code>.<br /> Attributes and description of the input time series will be copied to the output time series (see <code><a href="#topic+TSERIES">TIMESERIES</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromTStoXTS(x = NULL, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromTStoXTS_+3A_x">x</code></td>
<td>

<p>Input <code>ts</code> time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>. 
</p>
</td></tr>
<tr><td><code id="fromTStoXTS_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="fromTStoXTS_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a time series of class <code>xts()</code> that has the same observations of the input <code>ts</code> time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fromXTStoTS">fromXTStoTS</a></code><br />
<code><a href="#topic+as.bimets">as.bimets</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#day and month names can change depending on locale
	Sys.setlocale('LC_ALL','C')
	Sys.setlocale('LC_TIME','C')
  
	#BIMETS_CONF_DIP default on LAST
	print('yearly')
	t&lt;-ts(1:20,start=c(2005,2),frequency=1)
	ts&lt;-fromTStoXTS(t)
	print(t);print(ts) #...dates on 31 Dec
	
	print('semiannual')
	t&lt;-ts(1:20,start=c(2005,2),frequency=2)
	ts&lt;-fromTStoXTS(t)
	print(t);print(ts) #...dates on 31 Dec/30 Jun
	
	#set configuration BIMETS_CONF_DIP on FIRST
	setBIMETSconf('BIMETS_CONF_DIP','FIRST')
	
	print('yearly')
	t&lt;-ts(1:20,start=c(2005,2),frequency=1)
	ts&lt;-fromTStoXTS(t)
	print(t);print(ts) #...dates on 1 Jan
	
	print('semiannual')
	t&lt;-ts(1:20,start=c(2005,2),frequency=2)
	ts&lt;-fromTStoXTS(t)
	print(t);print(ts) #...dates on 1 Jan/1 Jul
	
	print('quarterly')
	t&lt;-ts(1:20,start=c(2004,3),frequency=4)
	ts&lt;-fromTStoXTS(t)
	print(t);print(ts)
	
	print('monthly')
	t&lt;-ts(1:20,start=c(2003,5),frequency=12)
	ts&lt;-fromTStoXTS(t)
	print(t);print(ts)
	
	
	print('daily')
	t&lt;-ts(1:20,start=c(2003,125),frequency=366)
	ts&lt;-fromTStoXTS(t)
	print(t);print(ts)
	
</code></pre>

<hr>
<h2 id='fromXTStoTS'>
Convert XTS to TS
</h2><span id='topic+fromXTStoTS'></span>

<h3>Description</h3>

<p>This function transforms a BIMETS compliant <code>xts()</code> time series (as defined in <code><a href="#topic+is.bimets">is.bimets</a></code>) into a time series of class <code>ts()</code>. The core R function as.ts() does not satisfy all the compliance control check requirements, so it has been extended. Attributes and description of the input time series will be copied to the output time series (see <code><a href="#topic+TSERIES">TIMESERIES</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromXTStoTS(x = NULL, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromXTStoTS_+3A_x">x</code></td>
<td>

<p>Input <code>xts()</code> time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>. 
</p>
</td></tr>
<tr><td><code id="fromXTStoTS_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="fromXTStoTS_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a time series of class <code>ts()</code> that has the same observations of the input <code>xts()</code> time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fromTStoXTS">fromTStoXTS</a></code><br />
<code><a href="#topic+as.bimets">as.bimets</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#day and month names can change depending on locale
	Sys.setlocale('LC_ALL','C')
	Sys.setlocale('LC_TIME','C')
  
	#set configuration BIMETS_CONF_DIP on FIRST
	setBIMETSconf('BIMETS_CONF_DIP','FIRST')
	
	#set configuration BIMETS_CONF_CCT on XTS
	setBIMETSconf('BIMETS_CONF_CCT','XTS')
	
	#semiannual with Date()
	n&lt;-10
	xArr&lt;-rnorm(n)
	dateArr&lt;-seq(as.Date('2000/07/01'),by='6 months',length=n) 
	dataF&lt;-data.frame(dateArr,xArr)
	xt&lt;-xts(dataF[,2],order.by=dataF[,1])
	print(fromXTStoTS(xt))
	
	#set configuration BIMETS_CONF_DIP on LAST
	setBIMETSconf('BIMETS_CONF_DIP','LAST')
	
	#yearly with Date()
	n&lt;-10
	xArr&lt;-rnorm(n)
	dateArr&lt;-seq(as.Date('2000/12/31'),by='year',length=n)
	dataF&lt;-data.frame(dateArr,xArr)
	xt&lt;-xts(dataF[,2],order.by=dataF[,1])
	print(fromXTStoTS(xt))
	
	#quarterly with yearqtr()
	n&lt;-10
	xArr&lt;-rnorm(n+1)
	dateArr&lt;-as.yearqtr('2000 Q2') + 0:n/4
	dataF&lt;-data.frame(dateArr,xArr)
	xt&lt;-xts(dataF[,2],order.by=dataF[,1])
	print(fromXTStoTS(xt))
	
	#monthly with yearmon()
	n&lt;-10
	xArr&lt;-rnorm(n+1)
	dateArr&lt;-as.yearmon('Jul 2000') + 0:n/12
	dataF&lt;-data.frame(dateArr,xArr)
	xt&lt;-xts(dataF[,2],order.by=dataF[,1])
	print(fromXTStoTS(xt))
	
	#daily with Date()
	n&lt;-10
	xArr&lt;-rnorm(n)
	dateArr&lt;-seq(as.Date('2000/07/14'),by='day',length=n) 
	dataF&lt;-data.frame(dateArr,xArr)
	xt&lt;-xts(dataF[,2],order.by=dataF[,1])
	print(fromXTStoTS(xt))
	
	#restore defaults
	setBIMETSconf('BIMETS_CONF_DIP','LAST')
	setBIMETSconf('BIMETS_CONF_CCT','TS')
	
	
</code></pre>

<hr>
<h2 id='GETDATE'>
Retrieve Dates of Time Series
</h2><span id='topic+GETDATE'></span>

<h3>Description</h3>

<p>This function returns the date array of selected observations, in the requested print format. Dates will be provided accordingly to the BIMETS configuration option <code>BIMETS_CONF_DIP</code> <br /> (see <code><a href="#topic+bimetsConf">BIMETS configuration</a></code> )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GETDATE(x=NULL, index=NULL, format='%Y-%m-%d', avoidCompliance=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GETDATE_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>. 
</p>
</td></tr>
<tr><td><code id="GETDATE_+3A_index">index</code></td>
<td>

<p>Index of observations to be selected. The output dates will be the dates of the selected observations. If <code>index=NULL</code> this function will retrieve all available dates in the input time series.
</p>
</td></tr>
<tr><td><code id="GETDATE_+3A_format">format</code></td>
<td>

<p>Output print format, provided as a paste of the following codes:<br />
<b>%Y</b>: 4 digits year<br />
<b>%y</b>: 2 digits year<br />
<b>%j</b>: period in the year for daily time series<br />
<b>%q</b>: quarter index, available only if also %y or %Y have been requested<br />
<b>%m</b>: 2 digits month<br />
<b>%b</b>: 3 digits month<br />
<b>%B</b>: full month name<br />
<b>%d</b>: 2 digits day<br />
<b>%a</b>: 3 letters weekday<br />
<b>%A</b>: full weekday name<br />
</p>
</td></tr>
<tr><td><code id="GETDATE_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="GETDATE_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the date array of selected observations, in the requested print format. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+yq2yp">yq2yp</a></code><br />
<code><a href="#topic+ym2yp">ym2yp</a></code><br />
<code><a href="#topic+date2yp">date2yp</a></code><br />
<code><a href="#topic+LOCS">LOCS</a></code><br />
<code><a href="#topic+NAMELIST">NAMELIST</a></code><br />
<code><a href="#topic+TSLOOK">TSLOOK</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
<code><a href="#topic+ELIMELS">ELIMELS</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
#day and month names can change depending on locale
Sys.setlocale('LC_ALL','C')
Sys.setlocale('LC_TIME','C')

#work on xts
setBIMETSconf('BIMETS_CONF_CCT','XTS')

#XTS yearly
n&lt;-10
xArr&lt;-(n:1)
dateArr&lt;-seq(as.Date('2000-12-31'),by='year',length=n)
dataF&lt;-data.frame(dateArr,xArr)
ts1&lt;-xts(dataF[,2],order.by=dataF[,1])
ts1[5]&lt;-NA
print(GETDATE(ts1,5)) #...print 2004-12-31
print(GETDATE(ts1,5,'%A %d %b %Y')) #print... Friday 31 Dec 2004
print(GETDATE(ts1)) #print... "2000-12-31" "2001-12-31" ... "2009-12-31"

#XTS quarterly
n&lt;-15
xArr&lt;-(n:0)
dateArr&lt;-as.yearqtr('2000 Q1')+0:n/4
dataF&lt;-data.frame(dateArr,xArr)
ts1&lt;-xts(dataF[,2],order.by=dataF[,1])	
print(GETDATE(ts1,9,'%b %Y')) #print...Mar 2002	

#XTS monthly
#set configuration BIMETS_CONF_DIP to FIRST
setBIMETSconf('BIMETS_CONF_DIP','FIRST')
n&lt;-15
xArr&lt;-(n:0)
dateArr&lt;-as.yearmon('Jan 2000')+0:n/12
dataF&lt;-data.frame(dateArr,xArr)
ts1&lt;-xts(dataF[,2],order.by=dataF[,1])	
print(GETDATE(ts1,9,'%b %Y')) #print...Sep 2000	

#set configuration BIMETS_CONF_DIP to LAST
setBIMETSconf('BIMETS_CONF_DIP','LAST')

#2000 is bissextile... 
print(GETDATE(ts1,2)) #print... 2000-02-29

#quarter...
print(GETDATE(ts1,5,'%Y Q%q')) #print... 2000 Q2

#restore default
setBIMETSconf('BIMETS_CONF_CCT','TS')
				
</code></pre>

<hr>
<h2 id='GETRANGE'>
Time Series Common Range
</h2><span id='topic+GETRANGE'></span>

<h3>Description</h3>

<p>Given a time series list, this function returns intersection or union of time series' ranges.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GETRANGE( x=list(), 
          type='INNER', 
          avoidCompliance=FALSE,  
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GETRANGE_+3A_x">x</code></td>
<td>

<p>Input list, having elements as time series of class <code>ts</code> or <code>xts</code>. This argument can be also a single time series.
</p>
</td></tr>
<tr><td><code id="GETRANGE_+3A_type">type</code></td>
<td>
<p> If <code>type='INNER'</code> then this funtion will return the intersection (if not <code>NULL</code>) of input time series' ranges. If <code>type='OUTER'</code> then this funtion will return the union of input time series' ranges.
</p>
</td></tr>
<tr><td><code id="GETRANGE_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="GETRANGE_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the common range of the input time series as a 4-integer array built by <code>c(START_Y,START_P,END_Y,END_P)</code>. If <code>type='INNER'</code> and there is no intersection of time series' ranges, then this function will return a <code>NULL</code>.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>		
	#create ts
	ts1=TSERIES((1:40), START=c(2000,1), FREQ=4)
	ts2=TSERIES((1:40), START=c(2001,1), FREQ=4)
	ts3=TSERIES((1:40), START=c(2002,1), FREQ=4)
	
	myList=list(ts1,ts2,ts3)
	
	print(GETRANGE(myList))
	print(GETRANGE(myList,type='OUTER'))
</code></pre>

<hr>
<h2 id='GETYEARPERIOD'>
Get Time Series Year-Period
</h2><span id='topic+GETYEARPERIOD'></span><span id='topic+TSDATES'></span>

<h3>Description</h3>

<p>This function returns a two-element list (or a two-columns matrix in the case of <code>JOIN=TRUE</code>) built with of the years and the periods of the input time series observations. Users can provide the output list names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GETYEARPERIOD(x=NULL, YEARS='YEAR', PERIODS='PRD', JOIN=FALSE, avoidCompliance=FALSE, ...)
TSDATES(x=NULL, YEARS='YEAR', PERIODS='PRD',  JOIN=FALSE, avoidCompliance=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GETYEARPERIOD_+3A_x">x</code></td>
<td>

<p>Input time series, that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="GETYEARPERIOD_+3A_years">YEARS</code></td>
<td>

<p>Argument of type string that will be the output list name for the array of observation years.
</p>
</td></tr>
<tr><td><code id="GETYEARPERIOD_+3A_periods">PERIODS</code></td>
<td>

<p>Argument of type string that will be the output list name for the array of observation periods.
</p>
</td></tr>
<tr><td><code id="GETYEARPERIOD_+3A_join">JOIN</code></td>
<td>
<p>If <code>TRUE</code>, the output will be a matrix having each row built with the year and the period of the related observation.</p>
</td></tr>
<tr><td><code id="GETYEARPERIOD_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="GETYEARPERIOD_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class <code>list()</code>. If <code>JOIN=TRUE</code>, this function returns a matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NOELS">NOELS</a></code><br />
<code><a href="#topic+TSERIES">TSERIES</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+TSLEAD">TSLEAD</a></code><br />
<code><a href="#topic+TSINFO">TSINFO</a></code><br />
<code><a href="#topic+TSLOOK">TSLOOK</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
<code><a href="#topic+ELIMELS">ELIMELS</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #create quarterly ts
  n&lt;-20
  ts1&lt;-TSERIES((n:1),START=c(2000,1),FREQ=4)
  myYP&lt;-GETYEARPERIOD(ts1)
  print(myYP$YEAR) #print 2000 2000 ... 
  print(myYP$PRD) #print 1 2 3 4 1 2 ...
  
  #create monthly ts
  ts1&lt;-TSERIES((n:1),START=c(2000,1),FREQ='M')
  myYP&lt;-GETYEARPERIOD(ts1)
  print(myYP$YEAR) #print 2000 2000 ... 
  print(myYP$PRD) #print 1 2 3 4 5 6 7 ...
  
  #create yearly ts
  ts1&lt;-TSERIES((1:n),START=c(2000,1),FREQ=1)
  myYP&lt;-GETYEARPERIOD(ts1,YEARS='YEARSS', PERIODS='PRDSS')
  print(myYP$YEARSS) #print 2000 2001 2002 ... 
  print(myYP$PRDSS) #print 1 1 1 1.....
  
  #JOIN=TRUE
  ts1&lt;-TSERIES((n:1),START=c(2000,1),FREQ='M')
  myYP&lt;-GETYEARPERIOD(ts1,JOIN=TRUE)
  print(myYP) #print 2000 2000 ... 
  #      [,1] [,2]
  #[1,] 2000    1
  #[2,] 2000    2
  #[3,] 2000    3
  #...	
</code></pre>

<hr>
<h2 id='idxOver'>
BIMETS Time Series Indexing
</h2><span id='topic+BIMETS+20indexing'></span><span id='topic+idxOver'></span>

<h3>Description</h3>

<p>Bimets package extends the way users can access and modify time series data.
<br /> <br />
<b>SELECTING BY DATE</b>: users can select a single observation by date by using the syntax <code>ts['Date']</code> and  multiple observations by using <code>ts['StartDate/EndDate']</code> or <br /> <code>ts['StartDate'+(0:n)/f]</code>, with <code>f=frequency, n=#observations</code>. <br /> Data modification follows the same syntax: <br /> <code>ts['Date']=value, ts['Date/Date']=c(value1,value2,...,valueN)</code>, etc. Users can also provide the string representing only the year of selection, or the year and the month of selection. For quarterly and monthly time series it is possible to select dates by using instances of class <code>yearmon()</code> and <code>yearqtr()</code> (See example).<br /> <br />
<b>SELECTING BY YEAR-PERIOD</b>: Users can select observations by providing the year and the period requested. Selection and modification of data require the double square bracket syntax, <br /> e.g.
<code>ts[[YEAR,PERIOD]]=value</code>. Users can also assign an array of values to the input time series, starting from the <code>[[YEAR,PERIOD]]</code> provided, <br /> i.e. <code>ts[[YEAR,PERIOD]]=c(value1,value2,...,valueN)</code>: in this case the input time series will be eventually extended in order to sequentially insert all values of the provided array (See example). <br /> <br />
<b>SELECTING BY INDICES</b>: (core R) Users can select observations by simply providing the array of requested indices, <br /> e.g. <code>ts[c(idx1,idx2,...,idxN)]</code> while reading and <br /> <code>ts[c(idx1,idx2,...,idxN)]=c(value1,value2,...,valueN)</code> while modifying time series data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GETDATE">GETDATE</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
<code><a href="#topic+date2yp">date2yp</a></code><br />
<code><a href="#topic+yq2yp">yq2yp</a></code><br />
<code><a href="#topic+ym2yp">ym2yp</a></code><br />
<code><a href="#topic+as.bimets">as.bimets</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+LOCS">LOCS</a></code><br />
<code><a href="#topic+NAMELIST">NAMELIST</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
<code><a href="#topic+ELIMELS">ELIMELS</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #day and month names can change depending on locale
  Sys.setlocale('LC_ALL','C')
  Sys.setlocale('LC_TIME','C')
	
	#monthly
  #-------------------------------
  print('MONTHLY GET by DATE')
  
  n&lt;-25
  
  #create ts
  ts1&lt;-TIMESERIES((0:n),START=c(2000,1),FREQ=12) 
  
  print(ts1['2001-01']) #get Jan 2001
  print(ts1[as.yearmon('Jan 2001')]) #get Jan 2001
  print(ts1['2000-09/2001-01']) #get data from Sep 2000 to Jan 2001
  print(ts1['2000-09/']) #get data from Sep 2000 
  print(ts1['/2001-01']) #get data till Jan 2001
  print(ts1['2001'])  #gat all data in year 2001
  
  #get 3 consecutive months starting from Jan 2001
  print(ts1[as.yearmon('Jan 2001')+ 0:2/12]) 
  
  
  print(ts1[c(2,4,5)]) #get observation number 2,4 and 5
  
  print('MONTHLY GET by YEAR-PERIOD')

  print(ts1[[2000,5]]) #get year 2000 period 5
  
  #get year 2010 period 1 (out of range)
  tryCatch({print(ts1[[2010,1]])},error=function(e){cat(e$message)})
  
  print(ts1[[2002,2]]) #get year 2002 period 2
  
  print('MONTHLY SET by DATE')

  ts1['2000-08']&lt;-9.9 #assign to Aug 2000
  ts1[as.yearmon('Feb 2001')]&lt;-8.8 #assign to Feb 2001
  
  #assign 8.8 on Feb 2001 and give warning
  ts1[as.yearmon('Feb 2001')]=c(8.8,7.7) 
  
  #assign same value to all observation in range Sep 2000 - Jan 2001
  ts1['2000-09/2001-01']&lt;-11.11
  
  #assign repeatedly the two values to each observation starting from Sep 2001 
  ts1['2001-09/']&lt;-c(1.1,2.2) 
  print(ts1)
  
  print('MONTHLY SET by YEAR-PERIOD')

  ts1[[2000,5]]&lt;-NA #set year 2000 period 5
  
  #assign an array starting from year 2002 period 2 (extend time series)
  ts1[[2002,2]]&lt;-c(-1,-2,-3,-4,-5) 
  TABIT(ts1)
  
  
  #quarterly
  #-------------------------------
  print('QUARTERLY GET by DATE')
  
  #create ts
  ts1&lt;-TSERIES((0:n),START=c(2000,1),FREQ=4)
    
  print(ts1[as.yearqtr('2001 Q1')]) #get 2001 Q1
  print(ts1['2001']) #get all data in year 2001
  
  #get 4 consecutive quarters starting from 2002 Q2
  print(ts1[as.yearqtr('2002 Q2')+ 0:3/4])  
  
  print(ts1['2003/']) #gat all data from 2003 Q1 
  
  print('QUARTERLY GET by YEAR-PERIOD')
  
  print(ts1[[2002,4]]) #get year 2002 period 4
      
  print('QUARTERLY SET by DATE')
  
  ts1[as.yearqtr('2001 Q1')]&lt;-7.7 #assign to 2001 Q1
  ts1['2002']&lt;-NA #assign to all observations of 2002
  
  #assign to 3 quaters starting from 2003 Q2
  ts1[as.yearqtr('2003 Q2')+ 0:2/4]&lt;-0 
  
  ts1['2004/']&lt;- -1 #assign to all observations starting from 2004
  TABIT(ts1)
  
  print('QUARTERLY SET by YEAR-PERIOD')
  
  ts1[[2005,4]]&lt;-c(1,2,3) #assign array starting from year 2005 period 4
  TABIT(ts1)
  
  
  #yearly 
  #-------------------------------
  print('YEARLY GET by DATE')
  
  #create ts
  ts1&lt;-TSERIES((1:n),START=c(2000,1),FREQ=1)
  
  print(ts1['2002-12-31']) #get 2002 data
  print(ts1['2002'])  #get 2002 data
  print(ts1['2000/2004'])  #get data from 2000 to 2004
  print(ts1['2005/']) #get data starting from 2005
  
  print('YEARLY GET by YEAR-PERIOD')
  
  print(ts1[[2005,1]]) #get year 2005
  #get year 2032 (out of range)
  tryCatch({print(ts1[[2032,1]])},error=function(e){cat(e$message)})
  
  
  print('YEARLY SET by DATE')
  
  ts1['2004']&lt;-NA #assign to 2004
  ts1['2007/']&lt;-0.0 #assign starting from 2007
  ts1['2000/2002']&lt;- -1 #assign in range 2000/2002
  TABIT(ts1)
 
  print('YEARLY SET by YEAR-PERIOD')
 
  ts1[[2005,1]]&lt;-NA #assign to 2005
  ts1[[2014,1]]&lt;- c(-1,-2,-3) #assign array starting from 2014 (extend series)
  TABIT(ts1)
  
  #daily 
  #-------------------------------
  print('DAILY GET by DATE')
  
  #create ts
  ts1&lt;-TSERIES((1:n),START=c(2000,1),FREQ='D')
  
  print(ts1['2000-01-12']) #get Jan 12, 2000 data
  
  print('DAILY GET by YEAR-PERIOD')
  
  print(ts1[[2000,14]]) #get year 2000 period 14
  #get year 2032 (out of range)
  tryCatch({print(ts1[[2032,1]]) },error=function(e){cat(e$message)})
  
  print('DAILY SET by DATE')
  
  ts1['2000-01-15']&lt;-NA #assign to Jan 15, 2000
  TABIT(ts1)
  
  print('DAILY SET by YEAR-PERIOD')
  
  ts1[[2000,3]]&lt;-NA #assign to Jan 3, 2000
  
  #assign array starting from 2000 period 35 (extend series)
  ts1[[2000,35]]&lt;- c(-1,-2,-3)
  TABIT(ts1)  
   

</code></pre>

<hr>
<h2 id='INDEXNUM'>
Rebase a Time Series
</h2><span id='topic+INDEXNUM'></span>

<h3>Description</h3>

<p>This function rebases an input time series to the value of 100 in the year selected by the <code>BASEYEAR</code> argument. If the input time series frequency is greater than one, the initial reference is set to the average value of the input time series observations that lie in the <code>BASEYEAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INDEXNUM(x=NULL, BASEYEAR=NULL, avoidCompliance=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="INDEXNUM_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="INDEXNUM_+3A_baseyear">BASEYEAR</code></td>
<td>

<p>Rebasing year.
</p>
</td></tr>
<tr><td><code id="INDEXNUM_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="INDEXNUM_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>		
	#create yearly ts
	n&lt;-20
	ts1&lt;-TSERIES(1:n,START=c(2000,1),FREQ=1)
	TABIT(ts1, INDEXNUM(ts1,2005))
	
	#quarterly
	ts1&lt;-TSERIES(1:n,START=c(2000,1),FREQ=4)
	ts1[5]&lt;-NA
	TABIT(ts1, INDEXNUM(ts1,2000))
</code></pre>

<hr>
<h2 id='INTS'>
Create Range of Indices
</h2><span id='topic+INTS'></span>

<h3>Description</h3>

<p>A command such <code>INTS(i,j)</code> returns a one-dimensional array built of the integers <code>i, i+1, i+2, ..., j</code> when <code>i, j</code> are both scalars, and <code>j</code> is greater than <code>i</code>. When <code>j</code> is less than <code>i</code>, the command shown above defines a one-dimensional array built of the integers <code>i, i-1, i-2, ..., j</code>.<br /><br /> Users can specify the <code>k</code> increment using a syntax like <code>INTS(i, j, k)</code> which defines a one-dimensional array built of the values <code>i, i+k, i+2*k, ..., i+N*k</code>.<br /><br />
The value of the last element of the array is the maximum value of <code>i+N*k</code> that is less than or equal to <code>j</code>, for positive <code>k</code>. For negative <code>k</code>, the value of the last element of the array is the minimum value of <code>i+N*k</code> that is greater than or equal to <code>j</code>.<br /><br />
The command can be used with one parameter by using a syntax like <code>INTS(i)</code> where <code>i</code> is a positive scalar. The result is a one-dimensional array built with the integers <code>1, 2, 3, ..., i</code>. When <code>i</code> is less than <code>1</code>, the array is built with the integers <code>-1, -2, ..., -i</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INTS(FROM=NULL, TO=NULL, BY=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="INTS_+3A_from">FROM</code></td>
<td>

<p>The first integer of the sequence. If arguments  <code>TO</code> and <code>BY</code> are <code>NULL</code> and <code>FROM&gt;0</code> the sequence will start from <code>1</code> and will end in <code>FROM</code>; If arguments  <code>TO</code> and <code>BY</code> are <code>NULL</code> and <code>FROM&lt;0</code> the sequence will start from <code>-1</code>  and will end in <code>FROM</code> (see example).
</p>
</td></tr>
<tr><td><code id="INTS_+3A_to">TO</code></td>
<td>

<p>The last integer of the sequence.
</p>
</td></tr>
<tr><td><code id="INTS_+3A_by">BY</code></td>
<td>

<p>The increment between two elements of the sequence.
</p>
</td></tr>
<tr><td><code id="INTS_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class <code>c()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSINFO">TSINFO</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
<code><a href="#topic+ELIMELS">ELIMELS</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	print(INTS(10,1,-2)) #... 10  8  6  4  2
	
	#...Error in INTS(10, 1, -0.5) : INTS(): inputs must be integers.
	tryCatch({print(INTS(10,1,-0.5));},error=function(e){cat(e$message)})
	
	print(INTS(10))  #...  1  2  3  4  5  6  7  8  9 10
	print(INTS(-10)) #  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10
	
	# Error in INTS(0) : INTS(): magnitude must be &gt;=1
	tryCatch({print(INTS(0));},error=function(e){cat(e$message)})
	
	print(INTS(-10,-45)) # -10 -11 -12 ... -41 -42 -43 -44 -45
	
	#...Error in seq.default(FROM, TO, BY) : wrong sign in 'by' argument
	tryCatch({print(INTS(-10,-45,3));},error=function(e){cat(e$message)})
	
	print(INTS(-10,-45,-3)) # -10 -13 -16 -19 -22 -25 -28 -31 -34 -37 -40 -43
</code></pre>

<hr>
<h2 id='is.bimets'>
Check the Compliance of a Time Series
</h2><span id='topic+is.bimets'></span>

<h3>Description</h3>

<p>This function checks the compliance of the input time series that must verify the following BIMETS requirements:<br /><br />
- the input time series must be of the class defined in <code>BIMETS_CONF_CCT</code> (see <code><a href="#topic+bimetsConf">BIMETS configuration</a></code>) <br /><br />
- If <code>BIMETS_CONF_CCT='TS'</code> the input time series must be of class <code>ts</code>, univariate, with at least one observation and with a frequency <code>f=1, 2, 3, 4, 12, 24, 36, 53 or 366</code> per year.<br /><br />
- if <code>BIMETS_CONF_CCT='XTS'</code> the input time series must be of class <code>xts</code>, univariate, with at least one observation and with a frequency <code>f=1, 2, 3, 4, 12, 24, 36, 53 or 366</code> per year; the input time series must also be stricty regular, i.e. without any temporal discontinuity, and must have an <code>.indexClass</code> of type <code>yearmon()</code> for monthly time series, of type <code>yearqtr()</code> for quarterly time series and of type <code>Date()</code> for any other frequency. If configuration option <code>BIMETS_CONF_DIP='LAST'</code>, i.e. the default value, the provided observation dates of the input <code>xts()</code> time series must be the last dates in the period, e.g. Dec. 31 for yearly time series, Jun. 30 for the first period in a semiannual time series, etc.; If configuration option <code>BIMETS_CONF_DIP='FIRST'</code> the provided observation dates of the input <code>xts()</code> time series must be the first dates in the period, e.g. Jan. 1 for an yearly time series, Jul. 1 for the second period in a semiannual time series, etc.; <br /> <br /> BIMETS package functions return time series that are compliant to the above requirements.<br /><br /> The compliance check can be locally disabled by using the function argument <code>avoidCompliance=TRUE</code>, that is available in almost all package functions. The compliance check of a BIMETS generated time series can be avoided; moreover, disabling the control check can speed up the execution time, and is suggested when users concatenate several call to the package functions, e.g. the compliance check of the <code>ts2</code> time series in the following example can be avoided: <br /> <code>ts2=TSLAG(ts1);ts3=TSDELTA(ts2,avoidCompliance=TRUE);</code>.<br /><br /> Time series must lie in the year range 1800-2199: in this range the conversion between a date and the related year-period (and vice versa) has been hardcoded in order to speed up the code execution.<br /><br />
If the compliance check is disabled, i.e. <code>avoidCompliance=TRUE</code> and the input time series does not verify all the above requirements, the package functions can have an erroneous behavior. Should any doubt arise, we suggest to call the package functions using the default arguments; we also suggest to create time series object by using the command <code><a href="#topic+TSERIES">TIMESERIES</a></code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bimets(x = NULL, suppressErrors=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.bimets_+3A_x">x</code></td>
<td>

<p>Input time series. 
</p>
</td></tr>
<tr><td><code id="is.bimets_+3A_suppresserrors">suppressErrors</code></td>
<td>

<p>If <code>suppressErrors=TRUE</code> the function returns a logical value <code>TRUE/FALSE</code> whenever the input time series is BIMETS compliant. If <code>suppressErrors=FALSE</code> the function will throw an error if the input time series is not BIMETS compliant.
</p>
</td></tr>
<tr><td><code id="is.bimets_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a logical value <code>TRUE/FALSE</code> whenever the input time series is compliant to the above BIMETS requirements. If the test fails and <code>suppressErrors=FALSE</code> this function will throw an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.bimets">as.bimets</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
<code><a href="#topic+fromBIMETStoTS">fromBIMETStoTS</a></code><br />
<code><a href="#topic+fromBIMETStoXTS">fromBIMETStoXTS</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #day and month names can change depending on locale
  Sys.setlocale('LC_ALL','C')
  Sys.setlocale('LC_TIME','C')
  
  #set day in period to last 
  setBIMETSconf('BIMETS_CONF_DIP','LAST')
  
  #set constructor class type
  setBIMETSconf('BIMETS_CONF_CCT','XTS')
  
  #create an xts
  xt&lt;-TIMESERIES(1:10,START=c(2000,1),FREQ='A')
  
  print(xt); #...dates are at Dec 31
  
  print(is.bimets(xt)) #...TRUE
  
  #change setting
  setBIMETSconf('BIMETS_CONF_DIP','FIRST')
  
  print(is.bimets(xt)) #...FALSE
  
  #set constructor class type
  setBIMETSconf('BIMETS_CONF_CCT','TS')
  
  #bivariate ts
  tsBiv&lt;-ts(matrix(c(1,2,3,4,5,6),nrow=3,ncol=2),start=c(2000,1),frequency=1)
  
  print(is.bimets(tsBiv)) #...FALSE
  
  #...error
  tryCatch({is.bimets(tsBiv,suppressError=FALSE)},
  	error=function(e){cat(e$message)});try({is.bimets(tsBiv,suppressError=FALSE)}) 
  
  #ts year 
  n&lt;-10
  xArr&lt;-rnorm(n)
  t&lt;-ts(data=xArr,start=c(2000,1),frequency=1)
  cat('is compliant?',is.bimets(t),'\n')
  
  #ts semestral 
  n&lt;-10
  xArr&lt;-rnorm(n)
  t&lt;-ts(data=xArr,start=c(2000,1),frequency=2)
  cat('is compliant?',is.bimets(t),'\n')
  
  #set configuration BIMETS_CONF_DIP on FIRST
  setBIMETSconf('BIMETS_CONF_DIP','FIRST')
  
  #work with XTS
  setBIMETSconf('BIMETS_CONF_CCT','XTS')
  
  #xts yearly with dates
  n&lt;-10
  xArr&lt;-rnorm(n)
  dateArr&lt;-seq(as.Date('2000/01/01'),by='year',length=n)
  dataF&lt;-data.frame(dateArr,xArr)
  xt&lt;-xts(dataF[,2],order.by=dataF[,1])
  cat('is compliant?',is.bimets(xt),'\n')
  
  
  #xts daily
  n&lt;-10
  xArr&lt;-rnorm(n)
  dateArr&lt;-seq(as.Date('2000/01/01'),by='day',length=n)
  dataF&lt;-data.frame(dateArr,xArr)
  xt&lt;-xts(dataF[,2],order.by=dataF[,1])
  cat('is compliant?',is.bimets(xt),'\n')
  
  #xts monthly with dates
  n&lt;-10
  xArr&lt;-rnorm(n)
  dateArr&lt;-seq(as.Date('2000/01/01'),by='month',length=n)
  dataF&lt;-data.frame(dateArr,xArr)
  xt&lt;-xts(dataF[,2],order.by=dataF[,1])
  cat('monthly with dates is compliant? ',is.bimets(xt),'\n') #...false
  
  
  #xts monthly with yearmon
  n&lt;-10
  xArr&lt;-rnorm(n+1)
  dateArr&lt;-as.yearmon('Jan 2001')+0:n/12
  dataF&lt;-data.frame(dateArr,xArr)
  xt&lt;-xts(dataF[,2],order.by=dataF[,1])
  cat('monthly with yearmon is compliant? ',is.bimets(xt),'\n') #...true
  
  
  #restore defaults
  setBIMETSconf('BIMETS_CONF_CCT','TS')
  setBIMETSconf('BIMETS_CONF_DIP','LAST')

</code></pre>

<hr>
<h2 id='LOAD_MODEL'>
Load a BIMETS model description file
</h2><span id='topic+LOAD_MODEL'></span>

<h3>Description</h3>

<p>This function parses a <code><a href="#topic+MDL">MDL</a></code> model definition and creates an equivalent R data structure that can be estimated and simulated. The input model definition can be either an external plain text file or a <code>character</code> variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOAD_MODEL( modelFile=NULL, 
            modelText=NULL,  
            quietly=FALSE,
            oldStyleModel=FALSE, 
            ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOAD_MODEL_+3A_modelfile">modelFile</code></td>
<td>

<p>The path to the text file containing the <code><a href="#topic+MDL">MDL</a></code> model definition.
</p>
</td></tr>
<tr><td><code id="LOAD_MODEL_+3A_modeltext">modelText</code></td>
<td>

<p>The <code>character</code> variable containing the <code><a href="#topic+MDL">MDL</a></code> model definition. <code>modelText</code> takes precedence over <code>modelFile</code> if both are defined.
</p>
</td></tr>
<tr><td><code id="LOAD_MODEL_+3A_quietly">quietly</code></td>
<td>

<p>If <code>TRUE</code>, information messages will be suppressed.
</p>
</td></tr>
<tr><td><code id="LOAD_MODEL_+3A_oldstylemodel">oldStyleModel</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
<tr><td><code id="LOAD_MODEL_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS model object containing all the information gathered the input model definition's parsing. <br /><br />
A BIMETS model created with the <code>LOAD_MODEL</code> function can be viewed as a complex R <code>list()</code> containing the following elements (see example):<br /><br />
- <b>rawData</b> and <b>cleanModel</b>: string arrays containing the original model definition. <code>cleanModel</code> is a clean version of the model definition, i.e. without comments, blank lines, etc.; <br /><br />
- <b>behaviorals</b> and <b>identities</b>: sub-lists containing all the information gathered from the behavioral and the identity definitions. This sub lists are described later in this page; <br /><br />
- <b>vendog</b> and <b>vexog</b>: string array containing the names of the endogenous and exogenous variables of the model; the former is also subsetted into <b>vendogBehaviorals</b> and <b>vendogIdentities</b><br /><br />
- <b>totNumEqs</b>, <b>totNumIds</b> and <b>eqCoeffNum</b>: integer variables containing the behaviorals count, the identities count and the coefficients count of the model;<br /><br />
- <b>incidence_matrix</b>: the incidence matrix built from the model equations; it is a square matrix in which each row and each column represent an endogenous variable. If the <code>(i,j)</code> element is equal to <code>1</code> than in the model definition the current value of the endogenous variable referred by the <code>i</code>-row directly depends on the current value of the endogenous variable referred by the <code>j</code>-column. (see example)<br /><br />
- <b>vpre</b>, <b>vsim</b>, <b>vfeed</b> and <b>vpost</b>: the simulation process takes advantage of an appropriate ordering of the equations to increase the performances by iteratively solving only one subset of equations, while the other equations are solved straightforwardly.  (Ref: <em>Don Gallo - Solving large sparse systems of equations in econometric models - Journal of Forecasting 1987</em> and <em>Numerical methods for simulation and optimal control of large-scale macroeconomic models - Nepomiastchy, Rachidi, Ravelli - 1980</em>). The optimal reordering of the model equations is achieved by using an iterative algorithm applied to the incidence matrix, that produces 4 ordered arrays of endogenous variables: <br /> 1. <code>vpre</code> is the ordered list containing the names of the endogenous pre-recursive variables to be sequentially computed (once per simulation period, by using their <code>EQ&gt;</code> definition in the <code>MDL</code>) before the simulation iterative algorithm takes place;<br />
2. <code>vsim</code> (the simultaneous block) is the ordered list containing the names of the endogenous variables to be sequentially computed during each iteration of the simulation iterative algorithm; <br />
3. <code>vfeed</code> is the list containing the names of the endogenous feedback variables; generally <code>vfeed</code> are the last variables of the ordered <code>vsim</code> list; <br />
4. <code>vpost</code> is the ordered list containing the names of the endogenous post-recursive variables to be sequentially computed (once per simulation period, by using their <code>EQ&gt;</code> definition in the <code>MDL</code>) after the simulation iterative algorithm has found a solution in the simultaenous block (more details in <code><a href="#topic+SIMULATE">SIMULATE</a></code> help pages);<br /><br />
- <b>max_lag</b>: the max lag of the model, i.e. the highest number of periods a time series of the model is lagged by in the <code>MDL</code> definition. It also accounts for recursive lagging<br /> (e.g. <code>TSLAG(...TSLAG(...)...)</code>), PDLs and for the order of the error autocorrelation, if any; <br /><br />
- <b>modelName</b>: the name of the model, copied from the input file name or from the input <code>character</code> variable name containing the model definition; <br /><br />
BEHAVIORALS and IDENTITIES<br /><br />
The elements <b>'behaviorals'</b> and <b>'identities'</b> of the BIMETS model are named lists that contain information on behaviorals and identities of the model. In both of this two lists, the name of each element is the name of the behavioral or the identity the data refer to, as specified in the model definition file: e.g. given a BIMETS model named <code>myModel</code>, the information on a behavioral named <code>cn</code> (i.e there exists a &quot;BEHAVIORAL&gt; cn&quot; in the <code>MDL</code> definition of the model) is stored into  <code>myModel$behaviorals$cn</code>.<br /><br />
Behavioral elements have the following components:<br /><br />
- <b>eq</b>: the equation of the behavioral, as a <code>character</code> variable;<br /><br />
- <b>eqCoefficientsNames</b>: the names of the coefficients (the original ones and eventually the ones created by the <code>PDL&gt;</code> expansion);<br /><br />
- <b>eqCoefficientsNamesOriginal</b>: the names of the original coefficients;<br /><br />
- <b>eqComponentsNames</b>: the names of endogenous and exogenous variables that appear in the behavioral equation;<br /><br />
- <b>eqComponentsNamesBehaviorals</b>: the names of behavioral endogenous variables that appear in the behavioral equation;<br /><br />
- <b>eqComponentsNamesIdentities</b>: the names of identity endogenous variables that appear in the behavioral equation;<br /><br />
- <b>eqComponentsNamesExogenous</b>: the names of exogenous variables that appear in the behavioral equation;<br /><br />
- <b>tsrange</b>: the estimation time range as a 4 integer array;<br /><br />
- <b>eqRegressorsNames</b>: a <code>character</code> array containing the regressor expressions (the original ones and eventually the ones created by the <code>PDL&gt;</code> expansion); <br /><br />
- <b>eqRegressorsNamesOriginal</b>:  a <code>character</code> array containing the expressions of the original regressors;<br /><br />
- <b>errorRaw</b>: the original definition of the error autocorrelation, if any (see <code><a href="#topic+MDL">MDL</a></code>);<br /><br />
- <b>errorType</b>: the type of the error structure;<br /><br />
- <b>errorDim</b>: the dimension of the error autocorrelation;<br /><br />
- <b>eqSimExp</b>: the <code>R</code> optimized <code>expression</code> of the behavioral equation that is used in the simulation algorithm;<br /><br />
- <b>matrixR</b>: the <code>R</code> Lagrange matrix that is used in restriction analysis (see <code><a href="#topic+MDL">MDL</a></code>);<br /><br />
- <b>vectorR</b>: the <code>r</code> Lagrange vector that is used in restriction analysis (see <code><a href="#topic+MDL">MDL</a></code>);<br /><br />
- <b>restrictRaw</b>: the original definition of the coefficient restrictions, if any.<br /><br />
- <b>pdlRaw</b>: the original definition of the PDL restrictions, if any (see example and <code><a href="#topic+MDL">MDL</a></code>).<br /><br />
- <b>pdlRestrictionMatrix</b>: the <code>R</code> Lagrange matrix that is used in PDL restriction analysis (see example and <code><a href="#topic+MDL">MDL</a></code>);<br /><br />
- <b>IVComponentsNames</b>: the names of endogenous and exogenous variables that appear in the instrumental variables equations, if any;<br /><br />
- <b>iv</b>: the original definitions of instrumental variables, if any.<br /><br />
For example, given a BIMETS model named <code>myModel</code>, the information on a technical identity named <code>y</code> (i.e there exists an &quot;IDENTITY&gt; y&quot; in the <code>MDL</code> definition of the model) is stored in <code>myModel$identities$y</code>.<br /><br /> Identity elements have the following components:<br /><br />
- <b>eqRaw</b>: the original equations  of the identity (more than one if the identity has multiple equations and has <code>IF&gt;</code> conditions), as a <code>character</code> variable (see example and <code><a href="#topic+MDL">MDL</a></code>);<br /><br />
- <b>ifRaw</b>: the original <code>IF&gt;</code> conditions, if any, of the identity, as a <code>character</code> variable;<br /><br />
- <b>eqFull</b>: the full expression of the identity, composed with <code>IF&gt;</code> conditions and related equations (see example), as a <code>character</code> variable;<br /><br />
- <b>eqComponentsNames</b>: the names of endogenous and exogenous variables that appear in the identity equation;<br /><br />
- <b>eqComponentsNamesBehaviorals</b>: the names of behavioral endogenous variables that appear in the identity equation;<br /><br />
- <b>eqComponentsNamesIdentities</b>: the names of identity endogenous variables that appear in the identity equation;<br /><br />
- <b>eqSimExp</b>: the <code>R</code> optimized <code>expression</code> of the identity equation that is used in the simulation algorithm;<br /><br />
- <b>hasIF</b>: boolean, <code>TRUE</code> if the identity has an <code>IF&gt;</code> condition;<br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MDL">MDL</a></code><br />
<code><a href="#topic+LOAD_MODEL_DATA">LOAD_MODEL_DATA</a></code><br />
<code><a href="#topic+ESTIMATE">ESTIMATE</a></code><br />
<code><a href="#topic+SIMULATE">SIMULATE</a></code><br />
<code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code><br />
<code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code><br />
<code><a href="#topic+RENORM">RENORM</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define model
myModelDefinition&lt;-
"MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL,
COMMENT&gt; autocorrelation on errors, restrictions and conditional evaluations

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; cn = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1923 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 3

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1)
IF&gt; i &lt;= 0
END"

#load model 
myModel&lt;-LOAD_MODEL(modelText=myModelDefinition)

#retrieve model structure...
#get definition
myModel$cleanModel
# [1] "BEHAVIORAL&gt; cn"                                        
# [2] "TSRANGE 1925 1 1941 1"                                 
# [3] "EQ&gt; cn = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)"       
# [4] "COEFF&gt; a1 a2 a3 a4"                                    
# [5] "ERROR&gt; AUTO(2)"                                        
# [6] "BEHAVIORAL&gt; i"                                         
# [7] "TSRANGE 1923 1 1941 1"                                 
# [8] "EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)"     
# [9] "COEFF&gt; b1 b2 b3 b4"                                    
#[10] "RESTRICT&gt; b2 + b3 = 1"                                 
#[11] "BEHAVIORAL&gt; w1"                                        
#[12] "TSRANGE 1925 1 1941 1"                                 
#[13] "EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1)+c4*time"
#[14] "COEFF&gt; c1 c2 c3 c4"                                    
#[15] "PDL&gt; c3 1 3"                                           
#[16] "IDENTITY&gt; y"                                           
#[17] "EQ&gt; y = cn + i + g - t"                                
#[18] "IDENTITY&gt; p"                                           
#[19] "EQ&gt; p = y - (w1+w2)"                                   
#[20] "IDENTITY&gt; k"                                           
#[21] "EQ&gt; k = TSLAG(k,1) + i"                                
#[22] "IF&gt; i &gt; 0"                                             
#[23] "IDENTITY&gt; k"                                           
#[24] "EQ&gt; k = TSLAG(k,1)"                                    
#[25] "IF&gt; i &lt;= 0"                                            

#get endogenous and exogenous
myModel$vendog
#[1] "cn" "i"  "w1" "y"  "p"  "k" 
myModel$vexog
#[1] "w2"   "t"    "time" "g"   

#get behaviorals, identities and coefficients count
myModel$totNumEqs
#[1] 3
myModel$totNumIds
#[1] 3
myModel$eqCoeffNum
#[1] 12

#get the incidence matrix
myModel$incidence_matrix
#   cn i w1 y p k
#cn  0 0  1 0 1 0
#i   0 0  0 0 1 0
#w1  0 0  0 1 0 0
#y   1 1  0 0 0 0
#p   0 0  1 1 0 0
#k   0 1  0 0 0 0

#get the optimal reordering arrays
myModel$vpre
#NULL
myModel$vsim
#[1] "w1" "p"  "cn" "i"  "y" 
myModel$vfeed
#[1] "y"
myModel$vpost
#[1] "k"

#get the model max lag and the model name
myModel$max_lag
#[1] 3
myModel$modelName
#myModelDefinition



#get infos on behavioral w1

myModel$behaviorals$w1$eq
#[1] "w1=c1+c2*(y+t-w2)+c3*TSLAG(y+t-w2,1)+c4*time"

myModel$behaviorals$w1$eqCoefficientsNames
#[1] "c1"       "c2"       "c3"       "c3_PDL_1" "c3_PDL_2" "c4"  

myModel$behaviorals$w1$eqCoefficientsNamesOriginal
#[1] "c1" "c2" "c3" "c4"

myModel$behaviorals$w1$eqComponentsNames
#[1] "t"    "time" "w1"   "w2"   "y"   

myModel$behaviorals$w1$tsrange
#[1] 1925    1 1941    1

myModel$behaviorals$w1$eqRegressorsNames
#[1] "1"                       "(y+t-w2)"               
#[3] "TSLAG(y+t-w2,1)"  "TSLAG(TSLAG(y+t-w2,1),1)" "TSLAG(TSLAG(y+t-w2,1),2)" "time"

myModel$behaviorals$w1$eqRegressorsNamesOriginal
#[1] "1"                "(y+t-w2)"       
#[3] "TSLAG(y+t-w2,1)" "time"

myModel$behaviorals$w1$pdlRaw
#[1] "c3 1 3;"

myModel$behaviorals$w1$pdlRestrictionMatrix
#     [,1] [,2] [,3] [,4] [,5] [,6]
#[1,]    0    0    1   -2    1    0



#get infos on behavioral cn

myModel$behaviorals$cn$errorRaw
#[1] "AUTO(2)"

myModel$behaviorals$cn$errorType
#[1] "AUTO"

myModel$behaviorals$cn$errorDim
#[1] 2

myModel$behaviorals$cn$eqSimExp
#expression(cn[4,]=cn__ADDFACTOR[4,]+cn__a1+cn__a2*p[4,]+cn__a3*(p[3,])+
#cn__a4*(w1[4,]+w2[4,])+cn__RHO_1*(cn[3,]-(cn__ADDFACTOR[3,]+
#cn__a1+cn__a2*p[3,]+cn__a3*(p[2,])+cn__a4*(w1[3,]+w2[3,])))+
#cn__RHO_2*(cn[2,]-(cn__ADDFACTOR[2,]+cn__a1+cn__a2*p[2,]+
#cn__a3*(p[1,])+cn__a4*(w1[2,]+w2[2,]))))



#get infos on behavioral i

myModel$behaviorals$i$matrixR
#    [,1] [,2] [,3] [,4]
#[1,]   0    1    1    0

myModel$behaviorals$i$vectorR
#[1] 1

myModel$behaviorals$i$restrictRaw
#[1] "b2+b3=1;"



#get infos on identitiy k

myModel$identities$k$eqRaw
#[1] "k=TSLAG(k,1)+i;k=TSLAG(k,1);"

myModel$identities$k$ifRaw
#[1] "i &gt; 0;i &lt;= 0;"

myModel$identities$k$eqFull
#[1] "__IF__ (i &gt; 0) __THEN__ k=TSLAG(k,1)+i;__IF__ (i &lt;= 0) __THEN__ k=TSLAG(k,1);"

myModel$identities$k$eqComponentsNames
#[1] "i" "k"

myModel$identities$k$eqSimExp
#expression(k[4,]=.MODEL_VIF(k[4,],i[4,] &gt; 0,k_ADDFACTOR[4,]+
#(k[3,])+i[4,]),k[4,]=.MODEL_VIF(k[4,],i[4,] &lt;= 0,
#k_ADDFACTOR[4,]+(k[3,])))

myModel$identities$k$hasIF
#[1] TRUE


</code></pre>

<hr>
<h2 id='LOAD_MODEL_DATA'>
Load time series data into a BIMETS model
</h2><span id='topic+LOAD_MODEL_DATA'></span>

<h3>Description</h3>

<p>This function verifies the input time series list and copies the data into a BIMETS model object. Provided time series must be BIMETS compliant, as defined in <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOAD_MODEL_DATA(model=NULL, modelData=NULL, quietly=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOAD_MODEL_DATA_+3A_model">model</code></td>
<td>

<p>The BIMETS model object (see <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code>).
</p>
</td></tr>
<tr><td><code id="LOAD_MODEL_DATA_+3A_modeldata">modelData</code></td>
<td>

<p>The input time series list containing endogenous and exogenous data (see example).
</p>
</td></tr>
<tr><td><code id="LOAD_MODEL_DATA_+3A_quietly">quietly</code></td>
<td>

<p>If <code>TRUE</code>, information messages will be suppressed.
</p>
</td></tr>
<tr><td><code id="LOAD_MODEL_DATA_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function add a new named element, i.e. <code>modelData</code>, into the output model object.<br /><br /> The new <code>modelData</code> element is a named list that contains all the input time series. Each element name of this list is set equal to the name of the endogenous or exogenous variable the time series data refer to.<br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MDL">MDL</a></code><br />
<code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
<code><a href="#topic+ESTIMATE">ESTIMATE</a></code><br />
<code><a href="#topic+SIMULATE">SIMULATE</a></code><br />
<code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code><br />
<code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code><br />
<code><a href="#topic+RENORM">RENORM</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define model data
myModelData&lt;-list(
  cn
  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
              45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
              START=c(1920,1),FREQ=1),
  g
  =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
              10.5,10.3,11,13,14.4,15.4,22.3,
              START=c(1920,1),FREQ=1),
  i
  =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
              2.1,2,-1.9,1.3,3.3,4.9,
              START=c(1920,1),FREQ=1),
  k
  =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
              216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
              201.2,204.5,209.4,
              START=c(1920,1),FREQ=1),
  p
  =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
              7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
              START=c(1920,1),FREQ=1),
  w1
  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
              29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
              START=c(1920,1),FREQ=1),
  y
  =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
              45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
              START=c(1920,1),FREQ=1),
  t
  =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
              8.3,6.7,7.4,8.9,9.6,11.6,
              START=c(1920,1),FREQ=1),
  time 
  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
              START=c(1920,1),FREQ=1),
  w2
  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
              7.4,6.7,7.7,7.8,8,8.5,
              START=c(1920,1),FREQ=1)
)

#define model
myModelDefinition&lt;-
"MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL,
COMMENT&gt; autocorrelation on errors, restrictions and conditional evaluations

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; cn = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1923 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 3

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t
COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1)
IF&gt; i &lt;= 0

END"

#load model 
myModel&lt;-LOAD_MODEL(modelText=myModelDefinition)

#load data into the model
myModel&lt;-LOAD_MODEL_DATA(myModel,myModelData,showWarnings = TRUE)
#Load model data "myModelData" into model "myModelDefinition"...
#CHECK_MODEL_DATA(): warning, there are missing values in series "time".
#...LOAD MODEL DATA OK


#retrieve data from model object

myModel$modelData$cn
#Time Series:
#Start = 1920 
#End = 1941 
#Frequency = 1 
# [1] 39.8 41.9 45.0 49.2 50.6 52.6 55.1 56.2 57.3 
#57.8 55.0 50.9 45.6 46.5 48.7 51.3 57.7 58.7 57.5 61.6
#[21] 65.0 69.7

myModel$modelData$w1
#Time Series:
#Start = 1920 
#End = 1941 
#Frequency = 1 
# [1] 28.8 25.5 29.3 34.1 33.9 35.4 37.4 37.9 39.2 
#41.3 37.9 34.5 29.0 28.5 30.6 33.2 36.8 41.0 38.2 41.6
#[21] 45.0 53.3

myModel$modelData$i
#Time Series:
#Start = 1920 
#End = 1941 
#Frequency = 1 
# [1]  2.7 -0.2  1.9  5.2  3.0  5.1  5.6  4.2  3.0  5.1  
#1.0 -3.4 -6.2 -5.1 -3.0 -1.3  2.1  2.0 -1.9  1.3
#[21]  3.3  4.9

myModel$modelData$time
#Time Series:
#Start = 1920 
#End = 1941 
#Frequency = 1 
# [1]  NA -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   
#0   1   2   3   4   5   6   7   8   9  10

</code></pre>

<hr>
<h2 id='LOCS'>
Select Time Series Indices
</h2><span id='topic+LOCS'></span>

<h3>Description</h3>

<p>This function returns the indices of the input <code>TRUE</code> elements. The input can be either an array or a time series. The result is usually used as a structured index to produce a new array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOCS(x=NULL, options='ALL', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOCS_+3A_x">x</code></td>
<td>

<p>This function accepts as input a boolean array or a boolean time series, often as the result of a logic comparison between an expression and a numerical array or a numerical time series: <br /> e.g. <code>LOCS(c(a,b,c,...)&gt;=k); LOCS(ts==j);</code> <br />
<code>LOCS(ts&lt;expr); LOCS(is.na(ts)); etc...</code>
</p>
</td></tr>
<tr><td><code id="LOCS_+3A_options">options</code></td>
<td>
<p>A selection option can refine the result:<br />
<b>ALL</b>: (default) all the <code>TRUE</code> indices will be returned in the output.<br />
<b>UNIQUE</b>: return the index of the unique <code>TRUE</code> result; if there are multiple <code>TRUE</code> results then an error will be thrown.<br />
<b>FIRST</b>: return the first <code>TRUE</code> result.<br />
<b>LAST</b>: return the last <code>TRUE</code> result.<br />
</p>
</td></tr>
<tr><td><code id="LOCS_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numerical array built with the indices of the values that are <code>TRUE</code> in the input boolean array or in the input boolean time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NOELS">NOELS</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+TSERIES">TSERIES</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+NOELS">NOELS</a></code><br />
<code><a href="#topic+NAMELIST">NAMELIST</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+TSINFO">TSINFO</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
<code><a href="#topic+ELIMELS">ELIMELS</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#create ts
	n&lt;-10
	ts1&lt;-TSERIES((1:n),START=c(2000,1),FREQ=1)
	print(LOCS(ts1&gt;7,options='FIRST')) #print 8
	
	#generate error: print LOCS(): input has more than one TRUE element.
	tryCatch({print(LOCS(ts1&gt;=3,options='UNIQUE'));},error=function(e){print(e$message);})
	
	print(LOCS(is.na(c(1,2,NA,4,5,6,7,NA,NA)))) #print c(3,8,9)
</code></pre>

<hr>
<h2 id='MDL'>
BIMETS Model Description Language
</h2><span id='topic+MDL'></span>

<h3>Description</h3>

<p>BIMETS provides a language to unambiguously specify an econometric model. This page describes how to create a model and its general structure. The specification of an econometric model is translated and identified by keyword statements which are grouped in a model file, i.e. a plain text file or a <code>character</code> variable with a specific syntax. Collectively, these keyword statements constitute the BIMETS Model Description Language (from now on <code>MDL</code>). The model specifications consist of groups of statements. Each statement begins with a keyword. The keyword classifies the component of the model which is being specified.<br /><br />
Below is an example of a Klein's model  with an <code>MDL</code> compliant syntax which can either be stored in a <code>character</code> variable or in a plain text file.<br /><br /> The content of the <em>klein1.txt</em> variable  is:
</p>
<pre>
R&gt; klein1.txt="
MODEL 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1921 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END
"
</pre>
<p>Please note that there are circular dependencies between equations of the model, e.g. <code>p &lt;- w1 &lt;- y &lt;- p</code> as shown in the <code><a href="#topic+bimets">&quot;BIMETS package&quot;</a></code> section figure in the <a href="https://CRAN.R-project.org/package=bimets/bimets.pdf">pdf version</a> of the manual. Circular dependencies imply that the model simulation must be solved with an iterative algorithm.<br /><br />
As shown, the model definition is quite intuitive. The first keyword is <code>MODEL</code>, while at the end of the model definition we can find the <code>END</code> keyword. Available tags in the definition of a generic BIMETS model are: 
<br /><br />
- <b>EQUATION&gt;</b> or <b>BEHAVIORAL&gt;</b> indicate the beginning of a series of keyword statements describing a behavioral equation. The behavioral statement general form is: <br />
<code>BEHAVIORAL&gt; name  [TSRANGE startYear, startPeriod, endYear, endPeriod]</code>  <br />
where <code>name</code> is the name of the behavioral equation and the optional <code>TSRANGE</code> specifies that the provided time interval must be used to estimate the coefficients. The optional <code>TSRANGE</code> is defined as a 4-dimensional numerical array built with starting year, starting period, ending year, and ending period.<br /><br />
Given <code class="reqn">Y=\beta*X+\epsilon</code>, where <code class="reqn">Y</code> are the historical values of the dependent variable and <code class="reqn">X</code> are the historical values of the regressors, if the requested estimation method is <code>OLS</code> (Ordinary Least Squares), in the general case (i.e. no restrictions nor error auto-correlation, as described later) the coefficients will be calculated as: <code class="reqn">\beta_{OLS}=(X' * X) ^{-1} * X' * Y</code>.<br /><br />
If the requested estimation method is <code>IV</code> (Instrumental Variables), given <code class="reqn">Z</code> the matrix built with instrumental variables as columns <code class="reqn">Z_i</code>, that should not be correlated to the disturbance terms, i.e. <code class="reqn">E[ \epsilon ' * Z_i] = 0</code>, the coefficients will be either calculated as <br /> <code class="reqn">\beta_{IV}=(Z' * X) ^{-1} * Z' * Y</code>, or more generally as: <code class="reqn">\beta_{IV}=(\hat{X}' * \Omega^{-1} * \hat{X}) ^{-1} * \hat{X}' * \Omega^{-1} * Y</code> where <code class="reqn">\hat{X} = Z * (Z' * Z)^{-1} * Z' * X</code> and <code class="reqn">\Omega = \sigma^{2} * I</code>,  <code class="reqn">\sigma^{2} = E[ \epsilon' * \epsilon]</code><br /><br />
- <b>IDENTITY&gt;</b> indicates the beginning of a series of keyword statements describing an identity or technical equation. The identity statement general form is: <br />
<code>IDENTITY&gt; name</code><br /> where <code>name</code> is the identity name.<br /><br />
- <b>EQ&gt;</b> specifies the mathematical expression for a behavioral or an identity equation. <br /><br />
The equation statement general form for a behavioral equation is:<br />
<code>EQ&gt; LHS = coeff1*f1 + coeff2*f2 + coeff3*f3 + ...</code><br />
where <code>LHS</code> is a function of the behavioral variable, <br /> <code>coeff1, coeff2, coeff3, ...</code> are the coefficient names of the equation and <br /> <code>f1, f2, f3, ...</code> are functions of variables.<br /><br />
The equation statement general form for an identity equation is:<br /> <code>EQ&gt; LHS = f1 + f2 + f3 + ...</code> <br /> where <code>LHS</code> is a function of the identity variable and <br /> <code>f1, f2, f3, ...</code> are functions of variables.<br /><br />
The following <code>MDL</code> functions can be used in the <code>LHS</code> left-hand side of the equation, with <code>name</code> as the name of the behavioral or the identity variable: <br /><br />
- <code>name</code> - i.e. the identity function;<br /> <br />
- <code>TSDELTA(name,i)</code> - <code>i</code>-periods difference of the <code>name</code> time series;<br /> <br />
- <code>TSDELTAP(name,i)</code> - <code>i</code>-periods percentage difference of the <code>name</code> time series;<br /> <br />
- <code>TSDELTALOG(name,i)</code> - <code>i</code>-periods logarithmic difference of the <code>name</code> time series;<br /> <br />
- <code>LOG(name)</code> - log of the <code>name</code> time series;<br /> <br />
- <code>EXP(name)</code> - exponential of the <code>name</code> time series. <br /> <br />
On the other side, the mathematical expression available for use in the <code>RHS</code> right-hand side of the <code>EQ&gt;</code> equation and in the <code>IV&gt;</code> expression described later in this page (i.e. <code>f1, f2, f3, ...</code>) can include the standard arithmetic operators, parentheses and the following <code>MDL</code> functions:<br /> <br />
- <code>TSLAG(ts,i)</code> - lag the <code>ts</code> time series by <code>i</code>-periods;<br /> <br />
- <code>TSDELTA(ts,i)</code> - <code>i</code>-periods difference of the <code>ts</code> time series;<br /> <br />
- <code>TSDELTAP(ts,i)</code> - <code>i</code>-periods percentage difference of the <code>ts</code> time series;<br /> <br />
- <code>TSDELTALOG(ts,i)</code> - <code>i</code>-periods logarithmic difference of the <code>ts</code> time series;<br /> <br />
- <code>MOVAVG(ts,i)</code> - <code>i</code>-periods moving average of the <code>ts</code> time series;<br /> <br />
- <code>MOVSUM(ts,i)</code> - <code>i</code>-periods moving sum of the <code>ts</code> time series;<br /> <br />
- <code>LOG(ts)</code> - log of the <code>ts</code> time series;<br /> <br />
- <code>EXP(ts)</code> - exponential of the <code>ts</code> time series; <br /> <br />
- <code>ABS(ts)</code> - absolute values of the <code>ts</code> time series.<br /> <br />
<code>MDL</code> function names are reserved names. They cannot be used as variable or coefficient names. The coefficient names are specified in a subsequent <code>COEFF&gt;</code> keyword statement within a behavioral equation. By definition, identities do not have any coefficient that must be assessed. Any name not specified as a coefficient name or mentioned on the list of the available <code>MDL</code> functions is assumed to be a variable.<br /><br />
- <b>COEFF&gt;</b> specifies the coefficient names used in the EQ&gt; keyword statement of a behavioral equation. The coefficients statement general form is:<br />
<code>COEFF&gt; coeff0 coeff1 coeff2 ... coeffn</code>. <br /> The coefficients order in this statement must be the same as it appears in the behavioral equation.<br /><br />
- <b>ERROR&gt;</b> specifies an autoregressive process of a given order for the regression error. The error statement general form is:<br />
<code>ERROR&gt; AUTO(n)</code> <br /> where <code>n</code> is the order of the autoregressive process for the error.<br /><br /> During an estimation, users must ensure that the required data are available for the specified error structure: <code>n</code> periods of data before the time interval specified by <code>TSRANGE</code> must be defined in any time series involved in the regression.<br /><br /> The solution requires an iterative algorithm. Given <code class="reqn">Y_{1}=\beta_{1}*X_{1}+\epsilon_{1}</code>, where <code class="reqn">Y_{1}</code> are the historical values of the dependent variable and <code class="reqn">X_{1}</code> are the historical values of the regressors, the iterative algorithm is based on the Cochrane-Orcutt procedure:<br /> <br />
1) Make an initial estimation by using the original TSRANGE extended backward <code>n</code> periods (given <code>n</code> as the autocorrelation order).<br /><br />
2) Estimate the error autocorrelation coefficients <code class="reqn">\rho_{i}=\rho_{i,1},...,\rho_{i,n}</code> with <code class="reqn">i=1</code> by regressing the residuals <code class="reqn">\epsilon_{i}</code> on their lagged values by using the auxiliary model: <br /> <code class="reqn">\epsilon_{i}=\rho_{i,1}*TSLAG(\epsilon_{i},1)+...+\rho_{i,n}*TSLAG(\epsilon_{i},n)</code><br /><br />
3) Transform the data for the dependent and the independent variables by using the estimated <code class="reqn">\rho_{i}</code>. The new dependent variable will be: <code class="reqn">Y_{i+1}=P_i*Y_i</code>, and the new independent variables will be <code class="reqn">X_{i+1}=P_i*X_i</code> with the matrix <code class="reqn">P_i</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn"> P_i = \left( \begin{array}{ccccccc}
1 &amp; 0 &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; 0 \cr 
-\rho_{i,1} &amp; 1 &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; 0 \cr 
-\rho_{i,2} &amp; -\rho_{i,1} &amp; 1 &amp; 0 &amp; ... &amp; 0 &amp; 0 \cr 
 &amp;  &amp;  &amp; ... &amp;  &amp;  &amp;  \cr 
0 &amp; 0 &amp; ... &amp; -\rho_{i,n} &amp; ... &amp; -\rho_{i,1} &amp; 1 
\end{array} \right) </code>
</p>
 <p><br />
4) Run another estimation on the original model <code class="reqn">Y_{i+1}=\beta_{i+1}*X_{i+1}+\epsilon_{i+1}</code> by using the suitable <code>TSRANGE</code> and the transformed data coming out of step 3 and compute the new time series for the residuals. <br /><br />
5) Estimate the new autocorrelation coefficients <code class="reqn">\rho_{i+1}=\rho_{i+1,1},...,\rho_{i+1,n}</code>, by regressing the new residuals arising from step 4 (similar to step 2)<br /><br />
6) Carry out the convergence check through a comparison among the previous <code class="reqn">\rho_{i}</code> and the new ones arising from steps 5. <br /> If <code class="reqn">all(abs(\rho_{i+1}-\rho_{i})&lt;\delta)</code>, where <code class="reqn">\rho_{i}</code> is the <code class="reqn">\rho</code> vector at the iteration <code class="reqn">i</code> and <code class="reqn">\delta</code> is a small convergence factor, then exit otherwise repeat from step 3 with <code>i &lt;- i+1</code>. <br /><br />
- <b>RESTRICT&gt;</b> is a keyword that can be used to specify linear coefficient restrictions. A deterministic restriction can be applied to any equation coefficient. Any number of <code>RESTRICT&gt;</code> keywords is allowed for each behavioral equation.<br /><br /> A deterministic (exact) coefficient restriction sets a linear expression containing one or more coefficients equal to a constant. The restriction only affects the coefficients of the behavioral equation in which it is specified. The restriction statement general form is:
</p>
<pre>
RESTRICT&gt; linear_combination_of_coefficients_1 = value_1
...
linear_combination_of_coefficients_n = value_n
</pre><p> where <code>linear_combination_of_coefficients_i, i=1..n</code> is a linear combination of the coefficient(s) to be restricted and <code>value_i</code> is the in-place scalar value to which the linear combination of the coefficients is set equal. Each linear combination can be set equal to a different value.<br /><br /> <code>MDL</code> example:
</p>
<pre>
RESTRICT&gt; coeff1 = 0
coeff2 = 10.5
coeff3-3*coeff4+1.2*coeff5 = 0
</pre>
<p>In many econometric packages, linear restrictions have to be coded by hand in the equations. BIMETS allows users to write down the restriction in a natural way, thus applying a constrained minimization. This procedure, although it leads to approximate numerical estimates, allows an easy implementation.<br /><br />
The theory behind this procedure is that of the Lagrange multipliers. Presented here is an example of its implementation.<br /><br /> Suppose that we have an equation defined as:
</p>
<pre>
EQUATION&gt; Y TSRANGE 2010 1 2015 4 
EQ&gt; Y = C1*X1 + C2*X2 + C3*X3 
COEFF&gt; C1 C2 C3 
RESTRICT&gt; 1.1*C1 + 1.3*C3 = 2.1 
1.2*C2 = 0.8
</pre>
<p>Coefficients <code>C1, C2, C3</code> are to be estimated. They are subject to the linear constraints specified by the <code>RESTRICT&gt;</code> keyword statement. In the case of <code>OLS</code> estimation, this is carried out in the following steps:<br /><br />
1) Compute the cross-product matrices <code class="reqn">X' X </code> and <code class="reqn">X' Y</code> where <code class="reqn">X</code> is a matrix with dimension <br /> <code>[NOBS x NREG]</code> containing the values of the independent variables (regressors) historical observations (and a vector of ones for the constant term, if any), and where <code class="reqn">Y</code> is a <code>NOBS</code> elements vector of the dependent variable (regressand) historical observations; <code>NOBS</code> is the number of observations available on the <code>TSRANGE</code> specified in the behavioral equation, and <code>NREG</code> is the number of regressors, or coefficients;<br /><br />
2) Build the restriction matrices. In the example:<br /><br />
<code class="reqn">R = \left( \begin{array}{ccc}1.1 &amp; 0 &amp; 1.3  \cr 0 &amp; 1.2 &amp; 0 \end{array} \right) </code> <br /> <br />
and <br /> <br />
<code class="reqn">r = \left( \begin{array}{c} 2.1  \cr 0.8  \end{array} \right)</code> <br /> <br />
</p>
<p><code>R</code> is a matrix of <code>[NRES x NREG]</code> size, and <code>r</code> is a vector of <code>[NRES]</code> length, where <code>NRES</code> is the number of restrictions;<br /><br />
3) Compute the scaling factors for the augmentation to be performed in the next step:<br />
</p>
<p style="text-align: center;"><code class="reqn">Rscale[i]=\frac{mean(X' X)}{max(abs(R[i,]))}</code>
</p>

<p>where <code class="reqn">R[i,]</code> is the i-th row of the <code>R</code> matrix.<br /><br />
Assuming <code class="reqn">mean(X' X) = 5000</code>, in the example above we will have:<br />
<code class="reqn">Rscale[1]=5000 / 1.3</code> <br />
<code class="reqn">Rscale[2]=5000 / 1.2</code> <br /><br />
The augmented matrices will then be defined as:<br /><br />
<code class="reqn">R_{aug} = \left( \begin{array}{ccc} 1.1 * Rscale[1] &amp; 0 &amp; 1.3 * Rscale[1] \cr 0 &amp; 1.2 * Rscale[2] &amp; 0 \end{array} \right) </code>
</p>
<p>and <br /> <br />
<code class="reqn">r_{aug} = \left( \begin{array}{c} 2.1 * Rscale[1] \cr 0.8 * Rscale[2]  \end{array} \right) </code> <br />
</p>
<p>4) Compute the so-called &quot;augmented&quot; cross-product matrix <code class="reqn">(X' X)_{aug}</code> by adding to the cross-product matrix <code class="reqn">(X' X)</code> a total of <code>NRES</code> rows and <code>NRES</code> columns:
<br /><br />
<code class="reqn">(X' X)_{aug} = \left( \begin{array}{cc} X' X &amp; R_{aug}' \cr R_{aug} &amp; 0 \end{array} \right) </code>
<br /><br />
5) Similarly, compute the so-called &quot;augmented&quot; cross-product matrix <code class="reqn">(X' Y)_{aug}</code> by adding a total of <code>NRES</code> elements to the cross-product matrix <code class="reqn">(X' Y)</code>:
<br /><br />
<code class="reqn">(X' Y)_{aug}=\left( \begin{array}{c} X' Y \cr r_{aug}  \end{array} \right) </code>
<br /><br />
6) Calculate the <code class="reqn">\hat{\beta}_{aug}</code> augmented coefficients by regressing the <code class="reqn">(X' Y)_{aug}</code> on the <code class="reqn">(X' X)_{aug}</code>.<br /><br /> The first <code>NREG</code> values of the augmented coefficients <code class="reqn">\hat{\beta}_{aug}</code> array are the estimated coefficients with requested restrictions. The last <code>NRES</code> values are the errors we have on the deterministic restrictions.<br /><br />
In the case of <code>IV</code> estimation, the procedure is the same as in the <code>OLS</code> case, but the matrix <code class="reqn">X</code> has to be replaced with the matrix <code class="reqn">\hat{X}</code>, as previously defined in the <code>BEHAVIORAL&gt;</code> keyword.<br /><br />
- <b>PDL&gt;</b> is a keyword that defines an Almon polynomial distributed lag to be used in estimation. Almon Polynomial distributed lags are specific kind of deterministic restrictions imposed on the coefficients of the distributed lags of a specific regressor. Multiple PDLs on a single behavioral equation can be defined. <br /><br /> The PDL&gt; statement general form is:<br /> <code>PDL&gt; coeffname degree laglength [N] [F]</code><br /> where <code>coeffname</code> is the name of a coefficient, <code>degree</code> is an integer scalar specifying the degree of the polynomial, <code>laglength</code> is an integer scalar specifying the length of the polynomial (in number of time periods), the optional <code>N</code> (i.e. &quot;nearest&quot;) means that the nearest lagged term of the expansion, i.e., the first term, is restricted to zero, and the optional <code>F</code> (i.e. &quot;farthest&quot;) means that the farthest lagged term of the expansion, i.e., the last term, is restricted to zero; the <code>PDL&gt;</code> keyword statement thusly defined applies an Almon polynomial distributed lag to the regressor associated with the <code>coeffname</code> coefficient, of <code>laglength</code> length and <code>degree</code> degree, by providing the appropriate expansion and the deterministic restrictions for the degree and length specified. These expansions are not explicitly shown to the user, i.e., the original model is not changed.<br /><br /> <code>laglength</code> must be greater than <code>degree</code> (see example below).<br /><br /> A PDL term can be further referenced in a <code>RESTRICT&gt;</code> keyword statement by using the following syntax: <code>LAG(coefname, pdllag)</code>.<br /><br /> Example: <code>RESTRICT&gt; LAG(coeff2,3) = 0</code> means that, during the estimation, the regressor related to the coefficient <code>coeff2</code> and lagged by 3 periods in the PDL expansion must have a coefficient equal to zero. This example also implies that a <code>PDL&gt; coeff2 x y</code> with <code>y &gt; 3</code> has been declared in the same behavioral. <br /><br />
The implementing rules are the following:<br /><br />
1) Read off the <code>laglength</code> of the PDL keyword and expand the column of the regressor related to <code>coeffname</code> in the matrix <code>X</code> (i.e. the original regressors matrix) with the lagged values of the regressor, from left to right, starting form the lag 1 to the lag <code>laglength-1</code>. The matrix <code>X</code> will now have a <code>[NOBS x (NREG+laglength-1)]</code> size, with <code>NOBS</code> as the number of observations in the specified <code>TSRANGE</code> and <code>NREG</code> as the number of regressors, or coefficients.<br /><br />
2) Build the restriction matrix <code>R</code> with the following <code>[ Nrow x Ncol ]</code> dimensions:<br />
<code>Nrow = laglength - ( degree + 1 )</code><br />
<code>Ncol = NREG + laglength - 1</code><br /><br />
This matrix's elements will be zero except for the (<code>laglength</code>)-columns related to the section of the expanded columns in the <code>X</code> matrix. For every row we will have to insert <code>degree+2</code> numbers different from zero.<br /><br />
The <code>degree+2</code> numbers are taken form the Tartaglia's-like triangle:
</p>
<pre>
1 -2  1
1 -3  3 -1
1 -4  6 -4   1
1 -5 10 -10  5  1
... ... ... ...
</pre>
<p>where in the <code>i</code>-th row we find the numbers for a PDL of <code>degree=i</code>.<br /><br />
The <code>r</code> vector giving the knows terms for the restrictions is a vector of<br /> <code>NRES = laglength - (degree + 1)</code> elements equal to zero.<br /><br />
An example will clarify:
</p>
<pre>
EQUATION&gt; Y TSRANGE 2010 1 2015 4 
EQ&gt; Y = C1*X1 + C2*X2 + C3*X3 
COEFF&gt; C1 C2 C3 
PDL&gt; C2 2 5
</pre><p> then <br /> <br />
<code class="reqn">R = \left( \begin{array}{ccccccc} 0 &amp; 1 &amp; -3 &amp; 3 &amp; 1 &amp; 0 &amp; 0 \cr 0 &amp; 0 &amp; 1 &amp; -3 &amp; 3 &amp; 1 &amp; 0 \end{array} \right) </code>
<br /> <br /> and <br /> <br />
<code class="reqn">r = \left( \begin{array}{c} 0  \cr 0 \end{array} \right) </code>
<br /><br /> <br />
The expanded regressors are:<br /> <code>X1, X2, TSLAG(X2,1), TSLAG(X2,2), TSLAG(X2,3), TSLAG(X2,4), X3</code>.<br /><br /> The scaling factor is given, as in the standard restriction case, by: <code class="reqn">mean(X' X) / max(abs(R[i,]))</code> <br /><br />
</p>
<p>- <b>IF&gt;</b> keyword is used to conditionally evaluate an identity during a simulation, depending on a logical expression's value. Thus, it is possible to have a model alternating between two or more identity specifications for each simulation period, depending upon results from other equations.<br /> <br />
The IF&gt; statement general form is:<br />
<code>IF&gt; logical_expression</code><br /><br /> The <code>IF&gt;</code> keyword must be specified within an identity group; this keyword causes the equation specified in the identity group to be evaluated during the current simulation period only when the <code>logical_expression</code> is <code>TRUE</code>.<br /><br /> Only one <code>IF&gt;</code> keyword is allowed in an identity group. Further occurrences produce an error message, and processing stops.<br /><br />
The <code>logical_expression</code> can be composed of constants, endogenous variables, exogenous variables, an expression among variables, combinations of the logical operators; mathematical operators and the <code>MDL</code> functions listed in the <code>EQ&gt;</code> section are allowed.<br /><br />
In the following <code>MDL</code> example, the value of the endogenous <code>myIdentity</code> variable is specified with two complementary conditional identities, depending on the <code>TSDELTA()</code> result:
</p>
<pre>
IDENTITY&gt; myIdentity
IF&gt; TSDELTA(myEndog*(1-myExog)) &gt; 0
EQ&gt; myIdentity = TSLAG(myIdentity)+1

IDENTITY&gt; myIdentity
IF&gt; TSDELTA(myEndog*(1-myExog)) &lt;= 0
EQ&gt; myIdentity = TSLAG(myIdentity)
</pre>
<p>- <b>IV&gt;</b> specifies the mathematical expression for an instrumental variable used in a behavioral equation. <br /><br />
The general form for an instrumental variable expression is:<br /> <code>IV&gt; f1 + f2 + f3 + ...</code> <br /> <code>f1, f2, f3, ...</code> are functions of variables.<br /><br />
The mathematical expression available for use in the <code>IV&gt;</code> definition are those already described in the <code>EQ&gt;</code> section.<br /> <br />
- <b>COMMENT&gt;</b> can be used to insert comments into a model. The general form of this keyword is:<br />
<code>COMMENT&gt; text</code><br /> <br />
The <code>text</code> following the <code>COMMENT&gt;</code> keyword is ignored during all processing and must lie in the same line. Comments cannot be inserted within another keyword statement. A dollar sign in the first position of a line is equivalent to using the COMMENT&gt; keyword, as in this exmaple:<br />
<code>
$This is a comment
</code>
<br /><br /> No other keywords are currently allowed in the <code>MDL</code> syntax.<br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
<code><a href="#topic+ESTIMATE">ESTIMATE</a></code><br />
<code><a href="#topic+SIMULATE">SIMULATE</a></code><br />
<code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code><br />
<code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code><br />
<code><a href="#topic+RENORM">RENORM</a></code><br />
<code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
<code><a href="#topic+summary.BIMETS_MODEL">summary</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#########################################################
#KLEIN MODEL WITH AUTOCORRELATION, RESTRICTIONS AND 
#CONDITIONAL EVALUATIONS

#define model
myModel&lt;-
"MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL, 
COMMENT&gt; autocorrelation on errors, restrictions and conditional evaluations

COMMENT&gt; Consumption with autocorrelation on errors
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment with restrictions
BEHAVIORAL&gt; i
TSRANGE 1923 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor with PDL
BEHAVIORAL&gt; w1 
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 2

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) 
IF&gt; i &lt;= 0

END"

#define model data
modelData&lt;-list(
  cn    =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
            45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
            START=c(1920,1),FREQ=1),
  g     =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
            10.5,10.3,11,13,14.4,15.4,22.3,
            START=c(1920,1),FREQ=1),
  i     =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
            2.1,2,-1.9,1.3,3.3,4.9,
            START=c(1920,1),FREQ=1),
  k     =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
            216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
            201.2,204.5,209.4,
            START=c(1920,1),FREQ=1),
  p     =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
            7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
            START=c(1920,1),FREQ=1),
  w1    =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
            29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
            START=c(1920,1),FREQ=1),
  y     =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
            45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
            START=c(1920,1),FREQ=1),
  t     =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
            8.3,6.7,7.4,8.9,9.6,11.6,
            START=c(1920,1),FREQ=1),
  time  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,  
            START=c(1920,1),FREQ=1),   
  w2    =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
            7.4,6.7,7.7,7.8,8,8.5,
            START=c(1920,1),FREQ=1)
)

#load model and model data
model&lt;-LOAD_MODEL(modelText=myModel)
model&lt;-LOAD_MODEL_DATA(model,modelData)

#estimate model
model&lt;-ESTIMATE(model)

#simulate model
model&lt;-SIMULATE(model
               ,TSRANGE=c(1923,1,1941,1)
               ,simConvergence=0.00001
               ,simIterLimit=100
)


#########################################################
#KLEIN MODEL WITH LHS FUNCTIONS


#define the model with LHS funs
myModel&lt;-'MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL,
COMMENT&gt; autocorrelation on errors, restrictions and conditional evaluations
COMMENT&gt; LHS functions on EQ

COMMENT&gt; Exp Consumption
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; EXP(cn) = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Log Investment
BEHAVIORAL&gt; i
TSRANGE 1925 1 1941 1
EQ&gt; LOG(i) = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(TSDELTA(y)+t-w2) + c3*TSLAG(TSDELTA(y)+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 3

COMMENT&gt; Delta Gross National Product
IDENTITY&gt; y
EQ&gt; TSDELTA(y) = EXP(cn) + LOG(i) + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = TSDELTA(y) - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + LOG(i)
IF&gt; LOG(i) &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1)
IF&gt; LOG(i) &lt;= 0

END'

 
#define model data
modelData&lt;-list(
  cn=TSERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,
            57.8,55,50.9,45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
            START=c(1920,1),FREQ=1),
  g=TSERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,
            10.7,10.2,9.3,10,10.5,10.3,11,13,14.4,15.4,22.3,
            START=c(1920,1),FREQ=1),
  i=TSERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,
            -6.2,-5.1,-3,-1.3,2.1,2,-1.9,1.3,3.3,4.9,
            START=c(1920,1),FREQ=1),
  k=TSERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,
            207.6,210.6,215.7,216.7,213.3,207.1,202,
            199,197.7,199.8,201.8,199.9,201.2,204.5,209.4,
            START=c(1920,1),FREQ=1),
  p=TSERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,
            21.7,15.6,11.4,7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
            START=c(1920,1),FREQ=1),
  w1=TSERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,
            41.3,37.9,34.5,29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
            START=c(1920,1),FREQ=1),
  y=TSERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,
            57.7,50.7,41.3,45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
            START=c(1920,1),FREQ=1),
  t=TSERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,
            8.3,5.4,6.8,7.2,8.3,6.7,7.4,8.9,9.6,11.6,
            START=c(1920,1),FREQ=1),
  time=TSERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,
            3,4,5,6,7,8,9,10,  
            START=c(1920,1),FREQ=1),   
  w2=TSERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,
            4.8,5.3,5.6,6,6.1,7.4,6.7,7.7,7.8,8,8.5,
            START=c(1920,1),FREQ=1)
)


#example data transformation
modelData&lt;-within(modelData,{
  i=exp(i);     #we have LOG(i)     in the model MDL definition
  cn=log(cn);   #we have EXP(cn)    in the model MDL definition
  y=CUMSUM(y)   #we have TSDELTA(y) in the model MDL definition
})

#load model and model data
model&lt;-LOAD_MODEL(modelText=myModel)
model&lt;-LOAD_MODEL_DATA(model,modelData)

#estimate model
model&lt;-ESTIMATE(model)

#simulate model
model&lt;-SIMULATE(model
               ,TSRANGE=c(1925,1,1930,1)
               ,simConvergence=0.00001
               ,simIterLimit=100
)

#########################################################
#SIMPLE MODEL WITH IV


#define the model with IVs
myShortModelDefinition&lt;-"
MODEL
COMMENT&gt; Consumption with IV
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; cn = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
IV&gt; 1
IV&gt; TSLAG(y)
IV&gt; TSLAG(w1)*pi+0.5
IV&gt; exp(w2)
END
" 

#load model 
myShortModel&lt;-LOAD_MODEL(modelText=myShortModelDefinition)

</code></pre>

<hr>
<h2 id='MONTHLY'>
Monthly Time Series (Dis)Aggregation
</h2><span id='topic+MONTHLY'></span>

<h3>Description</h3>

<p>This function returns a monthly (dis)aggregated time series, by using as input an annual, semiannual, quarterly or daily time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MONTHLY(x = NULL, fun = NULL, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MONTHLY_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="MONTHLY_+3A_fun">fun</code></td>
<td>
<p> Only for daily input time series:<br /> 
<b>STOCK</b>: the value of the input time series in the last observation of a month is assigned to the same month of the output time series.<br />
<b>NSTOCK</b>: the value of the input time series in the last non-missing observation of a month is assigned to the same month of the output time series.<br />
<b>SUM</b>: the sum of input observations in a month is assigned to the same month of the output time series.<br />
<b>NSUM</b>:  the sum of input non-missing observations in a month is assigned to the same month of the output time series. <br />
<b>AVE</b>: the average of input observations in a month is assigned to the same month of the output time series. <br />
<b>NAVE</b>: the average of input non-missing observations in a month is assigned to the same month of the output time series.<br /> <br />
Only for quarterly, semiannual or annual input time series:<br />
<b>NULL</b>: (default) the output value of each monthly observation is set equal to the value of the input observation the month belongs to (i.e. duplicated values over the period)<br />
<b>INTERP_END</b>: the value of the input time series in a period is copied into the last month of the output time series that lies in the same period. Other values are calculated by linear interpolation.<br />
<b>INTERP_CENTER</b>: the value of the input time series in a period is copied into the median month of the output time series that lies in the same period. Other values are calculated by linear interpolation. <br />
<b>INTERP_BEGIN</b>: the value of the input time series in a period is copied into the first month of the output time series that lies in the same period. Other values are calculated by linear interpolation.
</p>
</td></tr>
<tr><td><code id="MONTHLY_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code></p>
</td></tr>
<tr><td><code id="MONTHLY_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a monthly BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+YEARLY">YEARLY</a></code><br />
<code><a href="#topic+SEMIANNUAL">SEMIANNUAL</a></code><br />
<code><a href="#topic+QUARTERLY">QUARTERLY</a></code><br />
<code><a href="#topic+DAILY">DAILY</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#TS FREQ 2 SEMIANNUAL TO MONTHLY
	ts1&lt;-TSERIES((1:10),START=c(2000,1),FREQ=2)
	TABIT(MONTHLY(ts1,fun='INTERP_CENTER'))
	
	#TS DAILY TO MONTHLY
	ts1&lt;-TSERIES((1:366),START=c(2000,1),FREQ='D')
	TABIT(MONTHLY(ts1,fun='STOCK'))
	
	
	
</code></pre>

<hr>
<h2 id='MOVAVG'>
Moving Average
</h2><span id='topic+MOVAVG'></span><span id='topic+MAVE'></span>

<h3>Description</h3>

<p>This function returns the moving average of the elements of the input array or the input time series. The result is an object of the same class of the input, and its elements are the moving average of length <code>L</code> of the input values. If the input is a time series, the <code>DIRECTION</code> of the moving average, i.e backward, forward or centered, can be provided. <code>MAVE</code> is an alias for <code>MOVAVG</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>MOVAVG(x = NULL, L = NULL, DIRECTION = NULL, avoidCompliance = FALSE, ...) 
MAVE(x = NULL, L = NULL, DIRECTION = NULL, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOVAVG_+3A_x">x</code></td>
<td>

<p>Input numerical array or  time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="MOVAVG_+3A_l">L</code></td>
<td>

<p>Length of the mean. Must be a positive integer.
</p>
</td></tr>
<tr><td><code id="MOVAVG_+3A_direction">DIRECTION</code></td>
<td>
<p>if <code>x</code> is a time series, given <code>y</code> as output and <code>x</code> as input: <br />
<b>AHEAD</b>: the output observation value in index <code>n</code> will be <br /> <code>y[n] = mean(x[n],x[n+1],...,x[n+L-1])</code>.<br />
<b>CENTER</b>: the output observation value in index <code>n</code> will be <br /> <code>y[n] = mean(x[n-trunc(L/2)],...,x[n],x[n+1],...,x[n+trunc(L/2)])</code>.<br />
<b>NULL</b> o <b>BACK</b>: (default) the output observation value in index <code>n</code> will be <br /> <code>y[n] = mean(x[n+1-L],...,x[n-1],x[n])</code>.<br /> 
</p>
</td></tr>
<tr><td><code id="MOVAVG_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="MOVAVG_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>This function returns an object of the same class of the input, i.e. an array or a BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSDELTA">TSDELTA</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSLEAD">TSLEAD</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
<code><a href="#topic+INDEXNUM">INDEXNUM</a></code><br />
<code><a href="#topic+VERIFY_MAGNITUDE">VERIFY_MAGNITUDE</a></code><br />
<code><a href="#topic+GETRANGE">GETRANGE</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#input data	
	inputArray&lt;-c(1,2,3,4,NA,1,2,3,4,5)
	
	#array lag 3
	out_movavg&lt;-MOVAVG(inputArray,3)
	print(out_movavg)

	#ts lag 4 centered with missings	
	ts1&lt;-TSERIES(inputArray,START=c(2000,1),FREQ='A')
	out_movavg&lt;-MAVE(ts1,4,'CENTER')
	TABIT(out_movavg)
	
	#ts daily	
	ts1&lt;-TSERIES(inputArray,START=c(2000,1),FREQ='D')
	out_movavg&lt;-MAVE(ts1,3)
	TABIT(ts1,out_movavg)
	
	
</code></pre>

<hr>
<h2 id='MOVTOT'>
Moving Sum
</h2><span id='topic+MOVTOT'></span><span id='topic+MTOT'></span><span id='topic+MOVSUM'></span><span id='topic+MSUM'></span>

<h3>Description</h3>

<p>This function returns the moving sum of the elements of the input array or the input time series. The result is an object of the same class of the input, and its elements are the moving sum of length <code>L</code> of the input values. If the input is a time series, the <code>DIRECTION</code> of the moving sum, i.e backward, forward or centered, can be provided. <code>MTOT</code> and <code>MSUM</code> are alias for <code>MOVTOT</code> and <code>MOVSUM</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOVSUM(x = NULL, L = NULL, DIRECTION = NULL, avoidCompliance = FALSE, ...)
MOVTOT(x = NULL, L = NULL, DIRECTION = NULL, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOVTOT_+3A_x">x</code></td>
<td>

<p>Input numerical array or time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="MOVTOT_+3A_l">L</code></td>
<td>

<p>Length of the sum. It must be a positive integer.
</p>
</td></tr>
<tr><td><code id="MOVTOT_+3A_direction">DIRECTION</code></td>
<td>
<p>if <code>x</code> is a time series, given <code>y</code> as output and <code>x</code> as input: <br />
<b>AHEAD</b>: the output observation value in index <code>n</code> will be <br /> <code>y[n] = sum(x[n],x[n+1],...,x[n+L-1])</code>.<br />
<b>CENTER</b>: the output observation value in index <code>n</code> will be <br /> <code>y[n] = sum(x[n-trunc(L/2)],...x[n],x[n+1],...,x[n+trunc(L/2)])</code>.<br />
<b>NULL</b> o <b>BACK</b>: (default) the output observation value in index <br /> <code>n</code> will be <code>y[n] = sum(x[n+1-L],...,x[n-1],x[n])</code>.<br /> 
</p>
</td></tr>
<tr><td><code id="MOVTOT_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="MOVTOT_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of the same class of the input, i.e. an array or a BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSDELTA">TSDELTA</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSLEAD">TSLEAD</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
<code><a href="#topic+INDEXNUM">INDEXNUM</a></code><br />
<code><a href="#topic+VERIFY_MAGNITUDE">VERIFY_MAGNITUDE</a></code><br />
<code><a href="#topic+GETRANGE">GETRANGE</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
	#input data	
	inputArray&lt;-c(1,2,3,4,NA,1,2,3,4,5)
	
	#array lag 3
	out_movtot&lt;-MOVSUM(inputArray,3)
	print(out_movtot)

	#ts lag 4 centered with missings	
	ts1&lt;-TSERIES(inputArray,START=c(2000,1),FREQ='A')
	out_movtot&lt;-MOVSUM(ts1,4,'CENTER')
	TABIT(out_movtot)
	
	#ts daily	
	ts1&lt;-TSERIES(inputArray,START=c(2000,1),FREQ='D')
	out_movtot&lt;-MSUM(ts1,3)
	TABIT(ts1,out_movtot)
	
	
</code></pre>

<hr>
<h2 id='MULTMATRIX'>
Compute the multiplier matrix of a BIMETS model
</h2><span id='topic+MULTMATRIX'></span>

<h3>Description</h3>

<p>This function computes the matrix of both impact and interim multipliers, for a selected set of endogenous variables (i.e. <code>TARGET</code>) with respect to a selected set of exogenous variables (i.e. <code>INSTRUMENT</code>), by subtracting the results from different simulations in each period of the provided time range (i.e. <code>TSRANGE</code>). The simulation algorithms are the same as those used for the <code><a href="#topic+SIMULATE">SIMULATE</a></code> operation. <br /><br />
The <code>MULTMATRIX</code> procedure is articulated as follows:<br /><br />
1- simultaneous simulations are done;<br /><br />
2- the first simulation establishes the base line solution (without shocks);<br /><br />
3- the other simulations are done with shocks applied to each of the <code>INSTRUMENT</code> one at a time for every period in <code>TSRANGE</code>;<br /><br />
4- each simulation follows the defaults described in the <code><a href="#topic+SIMULATE">SIMULATE</a></code> help page, but has to be <code>STATIC</code> for the IMPACT multipliers and <code>DYNAMIC</code> for INTERIM multipliers;<br /><br />
5- given <code>MM_SHOCK</code> shock amount as a very small positive number, derivatives are computed by subtracting the base line solution of the <code>TARGET</code> from the shocked solution, then dividing by the value of the base line <code>INSTRUMENT</code> time the <code>MM_SHOCK</code>.<br /><br /><br />
The IMPACT multipliers measure the effects of impulse exogenous changes on the endogenous variables in the same time period. They can be defined as partial derivatives of each current endogenous variable with respect to each current exogenous variable, all other exogenous variables being kept constant.<br />
</p>
<p>Given <code class="reqn">Y(t)</code> an endogenous variable at time <code class="reqn">t</code> and <code class="reqn">X(t)</code> an exogenous variable at time <code class="reqn">t</code> the impact multiplier <code class="reqn">m(Y,X,t)</code> is defined as <code class="reqn">m(Y,X,t) = \partial Y(t)/\partial X(t)</code> and can be approximated by <code class="reqn">m(Y,X,t)\approx(Y_{shocked}(t)-Y(t))/(X_{shocked}(t)-X(t))</code>, with <code class="reqn">Y_{shocked}(t)</code> the values fo the simulated endogenous variable <code class="reqn">Y</code> at time <code class="reqn">t</code> when <code class="reqn">X(t)</code> is shocked to <code class="reqn">X_{shocked}(t)=X(t)(1+MM\_SHOCK)</code>
<br /><br /> The INTERIM or delay-<code>r</code> multipliers measure the delay-<code>r</code> effects of impulse exogenous changes on the endogenous variables in the same time period. The delay-<code>r</code> multipliers of the endogenous variable <code>Y</code> with respect to the exogenous variable <code>X</code> related to a dynamic simulation from time <code>t</code> to time <code>t+r</code> can be defined as the partial derivative of the current endogenous variable <code>Y</code> at time <code>t+r</code> with respect to the exogenous variable <code>X</code> at time <code>t</code>, all other exogenous variables being kept constant.<br />
</p>
<p>Given <code class="reqn">Y(t+r)</code> an endogenous variable at time <code class="reqn">t+r</code> and <code class="reqn">X(t)</code> an exogenous variable at time <code class="reqn">t</code> the impact interim or delay-<code>r</code> multiplier <code class="reqn">m(Y,X,t,r)</code> is defined as <code class="reqn">m(Y,X,t,r) = \partial Y(t+r)/\partial X(t)</code> and can be approximated by <code class="reqn">m(Y,X,t,r)\approx(Y_{shocked}(t+r)-Y(t+r))/(X_{shocked}(t)-X(t))</code>, with <code class="reqn">Y_{shocked}(t+r)</code> the values fo the simulated endogenous variable <code class="reqn">Y</code> at time <code class="reqn">t+r</code> when <code class="reqn">X(t)</code> is shocked to <code class="reqn">X_{shocked}(t)=X(t)(1+MM\_SHOCK)</code>
<br /> <br />
Users can also declare an endogenous variable as the <code>INSTRUMENT</code> variable. In this case, the constant adjustment (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>) related to the provided endogenous variable will be used as the <code>INSTRUMENT</code> exogenous variable (see example);
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MULTMATRIX(model=NULL,
           simAlgo='GAUSS-SEIDEL',
           TSRANGE=NULL,
           simType='DYNAMIC',
           simConvergence=0.01,
           simIterLimit=100,
           ZeroErrorAC=FALSE,
           Exogenize=NULL,
           ConstantAdjustment=NULL,
           verbose=FALSE,
           verboseSincePeriod=0,
           verboseVars=NULL,
           TARGET=NULL,
           INSTRUMENT=NULL,
           MM_SHOCK=0.00001,
           quietly=FALSE,
           JACOBIAN_SHOCK=1e-4,
           JacobianDrop=NULL,
           avoidCompliance=FALSE,
           ...)		   

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MULTMATRIX_+3A_model">model</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_simalgo">simAlgo</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_tsrange">TSRANGE</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_simtype">simType</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_simconvergence">simConvergence</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_simiterlimit">simIterLimit</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_zeroerrorac">ZeroErrorAC</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_exogenize">Exogenize</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_constantadjustment">ConstantAdjustment</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_verbose">verbose</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_verbosesinceperiod">verboseSincePeriod</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_verbosevars">verboseVars</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_target">TARGET</code></td>
<td>
<p>  A <code>character</code> array built with the names of the endogenous variables for which the multipliers are requested </p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_instrument">INSTRUMENT</code></td>
<td>

<p>A <code>character</code> array built with the names of the exogenous variables with respect to which the multipliers are evaluated. Users can also declare an endogenous variable as <code>INSTRUMENT</code> variable: in this case the constant adjustment (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>) related to the provided endogenous variable will be used as the instrument exogenous variable
</p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_mm_shock">MM_SHOCK</code></td>
<td>
<p>The value of the shock added to <code>INSTRUMENT</code> variables in the derivative calculation of the multipliers. The default value is <code>0.00001</code> times the value of the exogenous variable
</p>
</td></tr> 
<tr><td><code id="MULTMATRIX_+3A_quietly">quietly</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_jacobian_shock">JACOBIAN_SHOCK</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_jacobiandrop">JacobianDrop</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_avoidcompliance">avoidCompliance</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="MULTMATRIX_+3A_...">...</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will add a new element named <code>MultiplierMatrix</code> into the output BIMETS model object.<br /><br />
The new <code>MultiplierMatrix</code> element is a <br /> <code>(NumPeriods * Nendogenous) X (NumPeriods * Nexogenous)</code> matrix,<br /> with <code>NumPeriods</code> as the number of periods specified in the <code>TSRANGE</code>, <code>Nendogeous</code> the count of the endogenous variables in the <code>TARGET</code> array and <code>Nexogenous</code> the count of the exogenous variables in the <code>INSTRUMENT</code> array. <br /><br /> The arguments passed to the function call during the latest <code>MULTMATRIX</code> run will be inserted into the <code>'__SIM_PARAMETERS__'</code> element of the model <code>simulation</code> list (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>); this data can be helpful in order to replicate the multiplier matrix results. <br /><br />
Row and column names in the output multiplier matrix identify the variables and the periods involved in the derivative solution, with the syntax <code>VARIABLE_PERIOD</code> (see example).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MDL">MDL</a></code><br />
<code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
<code><a href="#topic+ESTIMATE">ESTIMATE</a></code><br />
<code><a href="#topic+SIMULATE">SIMULATE</a></code><br />
<code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code><br />
<code><a href="#topic+RENORM">RENORM</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#define model
myModelDefinition&lt;-
"MODEL 
COMMENT&gt; Klein Model 1 of the U.S. Economy 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1921 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1)+c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END"

#define model data
myModelData&lt;-list(
  cn
  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
              45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
              START=c(1920,1),FREQ=1),
  g
  =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
              10.5,10.3,11,13,14.4,15.4,22.3,
              START=c(1920,1),FREQ=1),
  i
  =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
              2.1,2,-1.9,1.3,3.3,4.9,
              START=c(1920,1),FREQ=1),
  k
  =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
              216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
              201.2,204.5,209.4,
              START=c(1920,1),FREQ=1),
  p
  =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
              7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
              START=c(1920,1),FREQ=1),
  w1
  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
              29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
              START=c(1920,1),FREQ=1),
  y
  =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
              45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
              START=c(1920,1),FREQ=1),
  t
  =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
              8.3,6.7,7.4,8.9,9.6,11.6,
              START=c(1920,1),FREQ=1),
  time 
  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
              START=c(1920,1),FREQ=1),
  w2
  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
              7.4,6.7,7.7,7.8,8,8.5,
              START=c(1920,1),FREQ=1)
)

#load model and model data
myModel&lt;-LOAD_MODEL(modelText=myModelDefinition)
myModel&lt;-LOAD_MODEL_DATA(myModel,myModelData)

#estimate model
myModel&lt;-ESTIMATE(myModel)

#calculate impact multipliers of Government Expenditure 'g' and
#Government Wage Bill 'w2' with respect of Consumption 'cn' and
#Gross National Product 'y' in the Klein model on the year 1941:

myModel&lt;-MULTMATRIX(myModel,
                  symType='STATIC',
                  TSRANGE=c(1941,1,1941,1),
                  INSTRUMENT=c('w2','g'),
                  TARGET=c('cn','y'))
                  
#Multiplier Matrix:    100.00%
#...MULTMATRIX OK

print(myModel$MultiplierMatrix)
#          w2_1      g_1
#cn_1 0.4540346 1.671956
#y_1  0.2532000 3.653260

#Results show that the impact multiplier of "y"
#with respect to "g" is +3.65
#If we change Government Expenditure 'g' value in 1941 
#from 22.3 (its historical value) to 23.3 (+1) 
#then the simulated Gross National Product "y" 
#in 1941 changes from 95.2 to 99, 
#thusly roughly confirming the +3.65 impact multiplier.
#Note that "g" appears only once in the model definition, and only 
#in the "y" equation, with a coefficient equal to one. (Keynes would approve)



#multi-period interim multipliers
myModel&lt;-MULTMATRIX(myModel,
                   TSRANGE=c(1940,1,1941,1),
                   INSTRUMENT=c('w2','g'),
                   TARGET=c('cn','y'))

#output multipliers matrix (note the zeros when the period
#of the INSTRUMENT is greater than the period of the TARGET)
print(myModel$MultiplierMatrix)
#           w2_1      g_1      w2_2      g_2
#cn_1  0.4478202 1.582292 0.0000000 0.000000
#y_1   0.2433382 3.510971 0.0000000 0.000000
#cn_2 -0.3911001 1.785042 0.4540346 1.671956
#y_2  -0.6251177 2.843960 0.2532000 3.653260


#multiplier matrix with endogenous variable 'w1' as instrument
#note the ADDFACTOR suffix in the column name, referring to the
#constant adjustment of the endogneous 'w1'
myModel&lt;-MULTMATRIX(myModel,
                    TSRANGE=c(1940,1,1941,1),
                    INSTRUMENT=c('w2','w1'),
                    TARGET=c('cn','y'))

#Multiplier Matrix:    100.00%
#...MULTMATRIX OK
myModel$MultiplierMatrix
#           w2_1 w1_ADDFACTOR_1      w2_2 w1_ADDFACTOR_2
#cn_1  0.4478202      0.7989328 0.0000000      0.0000000
#y_1   0.2433382      0.4341270 0.0000000      0.0000000
#cn_2 -0.3911001     -0.4866248 0.4540346      0.8100196
#y_2  -0.6251177     -0.9975073 0.2532000      0.4517209


</code></pre>

<hr>
<h2 id='NAMELIST'>
Named List of Time Series
</h2><span id='topic+NAMELIST'></span>

<h3>Description</h3>

<p>In the case of strings input, this function returns a string array built with the input strings. In the case of time series input, this function returns a list built with the input time series; the output list names will be the variable names passed as arguments. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NAMELIST(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NAMELIST_+3A_...">...</code></td>
<td>

<p>List of strings or list of time series. In the case of a list of strings, if an input string is not eligible to be a variable name, e.g. a string composed only with numbers, or with special characters, a warning will be thrown and a message will describe the required change made to the input string in order to make it eligible to be a variable name (see example). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the case of strings as input, this function returns a string array built with the input strings. In the case of time series as input, this function returns a list built with the input time series; the output list names will be the variable names passed as arguments. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NOELS">NOELS</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+TSERIES">TSERIES</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+LOCS">LOCS</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#NAMELIST with time series...
	
	ts1&lt;-TSERIES(1:10,START=c(2000,1),FREQ=12)
	ts2&lt;-TSERIES(10:20,START=c(2002,5),FREQ=12)
	myNameList&lt;-NAMELIST(ts1,ts2)
	print(myNameList)
	
	#prints a list with $ts1 and $ts2 elements 
	#please note that names are 'ts1' and 'ts2'...	
	#$ts1
	#     Jan Feb Mar Apr May Jun Jul Aug Sep Oct
	#2000   1   2   3   4   5   6   7   8   9  10
	
	#$ts2
	#     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
	#2002                  10  11  12  13  14  15  16  17
	#2003  18  19  20
	
	
	
	#define strange namelist
	#print warnings... '' converted in 'X', '9' converted in 'X9'
	myNAMELIST&lt;-NAMELIST('pp','oo','ii','','9');
	
	print(myNAMELIST)
	
</code></pre>

<hr>
<h2 id='NOELS'>
Count Elements
</h2><span id='topic+NOELS'></span>

<h3>Description</h3>

<p>This function returns a numerical array built with the length of each input argument. Input arguments can be numerical or time series. Input arguments can also be string variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOELS(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NOELS_+3A_...">...</code></td>
<td>

<p>List of input arguments. This function accepts input of class <code>numerical</code>, <code>character</code>, or BIMETS time series. <code>character</code> arguments are exclusive: if an argument is of class <code>character</code>, all other arguments must be of class <code>character</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an array of class <code>c()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+TSDATES">TSDATES</a></code><br />
<code><a href="#topic+LOCS">LOCS</a></code><br />
<code><a href="#topic+NAMELIST">NAMELIST</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+TSINFO">TSINFO</a></code><br />
<code><a href="#topic+TSLOOK">TSLOOK</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	out_NOELS&lt;-NOELS(c(1,2,3,4),c(5,6,7))
	print(out_NOELS) #print c(4,3)
	
	out_NOELS&lt;-NOELS(TSERIES(c(1,2,3,4),START=c(2000,1),FREQ=1),c(5,6,7))
	print(out_NOELS) #print c(4,3)
	
	out_NOELS&lt;-NOELS('aaa','bb')
	print(out_NOELS) #print c(3,2)
	
</code></pre>

<hr>
<h2 id='normalizeYP'>
Normalize Year-Period Array
</h2><span id='topic+normalizeYP'></span>

<h3>Description</h3>

<p>This function normalizes a numerical array <code>c(YEAR,PERIOD)</code>, given a frequency <code>f</code> and <code>PERIOD&gt;=f</code>.<br /> e.g. <code>normalizeYP(c(2000,15),12) = c(2001,3)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeYP(x = NULL, f = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeYP_+3A_x">x</code></td>
<td>

<p>Input numerical array <code>c(YEAR,PERIOD)</code>
</p>
</td></tr>
<tr><td><code id="normalizeYP_+3A_f">f</code></td>
<td>

<p>Frequency of normalization. Must be a positive integer.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numerical array <code>c(YEAR,PERIOD)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NUMPERIOD">NUMPERIOD</a></code><br />
<code><a href="#topic+frequency">frequency</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#c(2,13) and frequency=4 =&gt; c(5,1)
	print(normalizeYP(c(2,13),4))
	
</code></pre>

<hr>
<h2 id='NUMPERIOD'>
Distance Between Two Year-Periods
</h2><span id='topic+NUMPERIOD'></span>

<h3>Description</h3>

<p>This function returns the number of time periods that lie between the provided starting period <code>x1=c(YEAR1,PRD1)</code> and the provided ending period <code>x2=c(YEAR2,PRD2)</code>, given a frequency <code>f</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NUMPERIOD(x1, x2, f = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NUMPERIOD_+3A_x1">x1</code></td>
<td>

<p>Starting period specified as a numerical array <code>c(YEAR,PRD)</code>
</p>
</td></tr>
<tr><td><code id="NUMPERIOD_+3A_x2">x2</code></td>
<td>

<p>Ending period specified as a numerical array <code>c(YEAR,PRD)</code>
</p>
</td></tr>
<tr><td><code id="NUMPERIOD_+3A_f">f</code></td>
<td>

<p>Frequency over the year. It must be a positive integer.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an integer of class <code>numeric</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalizeYP">normalizeYP</a></code><br />
<code><a href="#topic+frequency">frequency</a></code><br />
<code><a href="#topic+GETDATE">GETDATE</a></code><br />
<code><a href="#topic+LOCS">LOCS</a></code><br />
<code><a href="#topic+NAMELIST">NAMELIST</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	# f=5, c(3,4) - c(2,3) = 6 periods
	print(NUMPERIOD(c(2,3),c(3,4),5))
</code></pre>

<hr>
<h2 id='OPTIMIZE'>
Optimal control of a BIMETS model
</h2><span id='topic+OPTIMIZE'></span>

<h3>Description</h3>

<p>The <code>OPTIMIZE</code> procedure provides a convenient method for performing optimal control exercises; the procedure maximizes an arbitrary objective-function under the constraints imposed by the econometric model and by user-specified constraints.
<br /><br />
An approach to policy evaluation is via a so-called &quot;social welfare function&quot;. This approach relaxes the assumptions of the instruments-targets framework, i.e. the <code><a href="#topic+RENORM">RENORM</a></code> procedure. Rather than assuming specific desired targets for some endogenous variables, it assumes the existence of a social welfare function determining a scalar measure of performance based on both endogenous and policy (exogenous) variables.
<br /><br />
The social welfare function can incorporate information about tradeoffs in objectives that are not allowed by the <code><a href="#topic+RENORM">RENORM</a></code> instruments-targets approach.
<br /><br />
BIMETS supplies the <code>OPTIMIZE</code> procedure in order to perform optimal control exercises on econometric models.
<br /><br />
The optimization consists of maximizing a social welfare function, i.e. the objective-function, depending on exogenous and (simulated) endogenous variables, subject to user constraints plus the constraints imposed by the econometric model equations. Users are allowed to define constraints and objective-functions of any degree, and are allowed to provide different constraints and objective-functions in different optimization time periods.
<br /><br />
The core of the <code>OPTIMIZE</code> procedure is based on a Monte Carlo method that takes advantage of the <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> procedure. Policy variables, i.e. <code>INSTRUMENT</code>, are uniformly perturbed in the range defined by the user-provided boundaries, then the <code>INSTRUMENT</code> values that i) verify the user-provided constraints and ii) maximize the objective-functions are selected and stored into the <code>optimize</code> element of the output BIMETS model.
<br /><br />
The following steps can describe the procedure implemented in <code>OPTIMIZE</code>:
<br /><br />
1) check the correctness of input arguments;<br /><br />
2) perform a <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> by uniformly perturbing the <code>INSTRUMENT</code> variables inside the user-boundaries provided in the <code>OptimizeBounds</code> function argument;<br /><br />
3) during the <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>, for each period in the optimization <code>TSRANGE</code>: i) discard the stochastic realizations that do not verify the restrictions provided in the <code>OptimizeRestrictions</code> argument; ii) for all the remaining realizations, compute the current value of the objective-functions time series, as defined in the <code>OptimizeFunctions</code> argument, by using the exogenous and (simulated) endogenous stochastic time series;<br /><br />
4) once the <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> completes, select the stochastic realization that presents the higher value in the sum of the corresponding objective-function time series values, and return, among other data, the related optimal <code>INSTRUMENT</code> time series.<br /><br />
</p>
<p>In the following figure, the scatter plot is populated with <code>2916</code> objective function stochastic realizations, computed by using the example code at the end of this section; the <code>210.58</code> local maximum  is highlighted<br />(i.e. <code>advancedKleinModel$optimize$optFunMax</code> in first example).<br /><br /> In this example:<br /><br /> 
i) The objective function definition is:<br /> 
<code class="reqn">f(y,cn,g) = (y-110)+(cn-90)*|cn-90|-\sqrt{g-20}</code> <br />
given <code class="reqn">y</code> as the simulated <em>Gross National Product</em>, <code class="reqn">cn</code> as the simulated <em>Consumption</em> and <code class="reqn">g</code> as the exogenous <em>Government Expenditure</em>: the basic idea is to maximize <em>Consumption</em>, and secondarily the <em>Gross National Product</em>, while reducing the <em>Government Expenditure</em>;<br /><br /> 
ii) The <code>INSTRUMENT</code> variables are the <code class="reqn">cn</code> <em>Consumption</em> &quot;booster&quot; (i.e. the add-factor, not to be confused with the simulated <em>Consumption</em> in the objective function) and the <code class="reqn">g</code> <em>Government Expenditure</em>, defined over the following domains: <code class="reqn"> cn \in (-5,5)</code>, <code class="reqn">g \in (15,25)</code>;<br /><br />
iii) The following restrictions are applied to the <code>INSTRUMENT</code>: <code class="reqn">g + cn^2/2 &lt; 27  \wedge  g + cn &gt; 17</code>, given <code class="reqn">cn</code> as the <em>Consumption</em> &quot;booster&quot; (i.e. the add-factor) and <code class="reqn">g</code> as the <em>Government Expenditure</em>;
</p>
<p><img src="../help/figures/OptKlein.png" alt="OptKlein.png" /><br /> <br />
</p>
<p>The figure clearly shows that non-linear restrictions have been applied, and that non-computable objective functions have been discarded, e.g. the stochastic realizations having <code class="reqn">g&lt;20</code> due to the square root operation in the objective function, given instrument <code class="reqn">g \in (15,25)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OPTIMIZE( model=NULL,
          simAlgo='GAUSS-SEIDEL',
          TSRANGE=NULL,
          simType='DYNAMIC',
          simConvergence=0.01,
          simIterLimit=100,
          ZeroErrorAC=FALSE,
          Exogenize=NULL,
          ConstantAdjustment=NULL,
          verbose=FALSE,
          verboseSincePeriod=0,
          verboseVars=NULL,
          StochReplica=100,
          StochSeed=NULL,
          OptimizeBounds=NULL,
          OptimizeRestrictions=NULL,
          OptimizeFunctions=NULL,
          quietly=FALSE,
          RESCHECKeqList=NULL,
          JACOBIAN_SHOCK=1e-4,
          JacobianDrop=NULL,
          avoidCompliance=FALSE,
          ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OPTIMIZE_+3A_model">model</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_simalgo">simAlgo</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_tsrange">TSRANGE</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_simtype">simType</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_simconvergence">simConvergence</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_simiterlimit">simIterLimit</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_zeroerrorac">ZeroErrorAC</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_exogenize">Exogenize</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_constantadjustment">ConstantAdjustment</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_verbose">verbose</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_verbosesinceperiod">verboseSincePeriod</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_verbosevars">verboseVars</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_stochreplica">StochReplica</code></td>
<td>
<p>see <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_stochseed">StochSeed</code></td>
<td>
<p>see <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_optimizebounds">OptimizeBounds</code></td>
<td>
<p>the named <code>list()</code> that defines the search boundaries applied to <code>INSTRUMENT</code> exogenous variables. Each list element must have a name equal to an endogenous or an exogenous model variable.<br /> <br /> 
The list names define the <code>INSTRUMENT</code>.<br /><br />
If a list element name is equal to an exogenous variable, then the boundaries will be applied directly to the related exogenous stochastic time series values. If a list element name is equal to an endogenous variable, then the boundaries will be applied to the stochastic constant adjustment  (see <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>) of the related endogenous variable. <br /><br />
Each list element must be a named list built with the following two named variables: <br /> <br /> 
- <code>TSRANGE</code>: the time range  wherein the search boundaries are active. The <code>TSRANGE</code> must be a 4 numerical array,<br /> i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code> or <code>TSRANGE=TRUE</code> in order to apply the provided boundaries to the whole <code>OPTIMIZE</code> <code>TSRANGE</code>. <br /> <br />  
- <code>BOUNDS</code>: the boundaries that are applied to the related instrument. These parameters must contain the lower and upper bound of the uniform distribution wherein the search for the objective-functions maximum is performed,<br /> i.e. <code>BOUNDS=c(lower_bound,upper_bound)</code>. <br /> <br /> 
See example in order to learn how to build a compliant boundaries structure.</p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_optimizerestrictions">OptimizeRestrictions</code></td>
<td>
<p>the named <code>list()</code> that defines the restrictions applied to <code>INSTRUMENT</code> exogenous variables. This list can be <code>NULL</code>.<br /> <br /> 
Each list element must be a named list built with the following two named variables: <br /> <br /> 
- <code>TSRANGE</code>: the time range  wherein the restriction is active. The <code>TSRANGE</code> must be a 4 numerical array,<br /> i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code> or <code>TSRANGE=TRUE</code> in order to apply the provided restriction to the whole <code>OPTIMIZE</code> <code>TSRANGE</code>. <br /> <br />  
- <code>INEQUALITY</code>: the inequality expression, i.e. a <code>character</code> variable, that defines the restriction. The <code>INEQUALITY</code> expression can contain exogenous and endogenous variable names, the standard arithmetic and logical operators, parentheses and the <code><a href="#topic+MDL">MDL</a></code> functions described in the <code>EQ</code> section of the <code><a href="#topic+MDL">MDL</a></code> help page. If in the <code>INEQUALITY</code> expression a variable name refers to an exogenous variable, then that variable will be evaluated by using the related exogenous time series stochastic values. If in the <code>INEQUALITY</code> expression a variable name refers to an endogenous variable, then that variable will be evaluated by using to the stochastic constant adjustment (see argument <code>StochStructure</code> of the <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> help page) of the related endogenous variable. <br /><br /> 
Two different <code>OptimizeRestrictions</code> list element can not have overlapping <code>TSRANGE</code>. See example in order to learn how to build a compliant restrictions structure.</p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_optimizefunctions">OptimizeFunctions</code></td>
<td>
<p>the named <code>list()</code> that defines the objective functions to be maximized.<br /> <br /> 
Each list element must be a named list built with the following two named variables: <br /> <br /> 
- <code>TSRANGE</code>: the time range  wherein the objective function is evaluated. The <code>TSRANGE</code> must be a 4 numerical array,<br /> i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code> or <code>TSRANGE=TRUE</code> in order to evaluate the objective function in each period of the <code>OPTIMIZE</code> <code>TSRANGE</code>. <br /> <br />  
- <code>FUNCTION</code>: the expression, i.e. a <code>character</code> variable, that defines the objective function. The <code>FUNCTION</code> expression can contain exogenous and endogenous variable names, the standard arithmetic and logical operators, parentheses and the <code><a href="#topic+MDL">MDL</a></code> functions described in the <code>EQ</code> section of the <code><a href="#topic+MDL">MDL</a></code> help page. If in the <code>FUNCTION</code> expression a variable name refers to an exogenous variable, then that variable will be evaluated by using the related exogenous time series stochastic values. If in the <code>FUNCTION</code> expression a variable name refers to an endogenous variable, then that variable will be evaluated by using the stochastic simulated time series (see <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>) of the related endogenous variable. <br /><br /> 
Two different <code>OptimizeFunctions</code> list element can not have overlapping <code>TSRANGE</code>. See example in order to learn how to build a compliant objective functions structure.</p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_quietly">quietly</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_rescheckeqlist">RESCHECKeqList</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_jacobian_shock">JACOBIAN_SHOCK</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_jacobiandrop">JacobianDrop</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_avoidcompliance">avoidCompliance</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="OPTIMIZE_+3A_...">...</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will add, into the output BIMETS model object, three new named elements, respectively <code>optimize</code>, <code>simulation_MM</code> and <code>INSTRUMENT_MM</code>.<br /><br />
The <code>optimize</code> element is a named <code>list()</code> that contains the following elements:<br /><br />
</p>
<p>- <code>INSTRUMENT</code>: a named list that contains the time series of the instrument exogenous variables that verify the <code>OptimizeRestrictions</code> and that allow the objective <code>OptimizeFunctions</code> to be maximized. This element is populated only if a finite solution exists. List names are equal to the names of the related exogenous variables. Users can also declare an endogenous variable as <code>INSTRUMENT</code> variable, by using the <code>OptimizeBounds</code> argument: in this case the constant adjustment (see <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>) related to the provided endogenous variable will be used as instrument exogenous variable, and this output <code>INSTRUMENT</code> list will contains the constant adjustment time series that allow the objective <code>OptimizeFunction</code> to be maximized (see example);<br />
</p>
<p>- <code>optFunMax</code>: the scalar value (local maximum) obtained by evaluating the <code>OptimizeFunctions</code> while the model is fed by the optimized <code>INSTRUMENT</code> time series. This element is populated only if a finite solution exists;<br />
</p>
<p>- <code>optFunTS</code>: the time series obtained by evaluating the <code>OptimizeFunctions</code> during each period in the <code>OPTIMIZE</code> <code>TSRANGE</code> while the model is fed by the optimized <code>INSTRUMENT</code> time series. Thus, <code>optFunMax==sum(optFunTS)</code>. This element is populated only if a finite solution exists;<br />
</p>
<p>- <code>optFunAve</code>: the scalar value that is the mean of all the stochastic <code>OptimizeFunctions</code> realizations, filtered by the restrictions imposed by the <code>OptimizeRestrictions</code> argument. This element is populated only if a finite solution exists;<br />
</p>
<p>- <code>optFunSd</code>: the scalar value that is the standard deviation of all the stochastic <code>OptimizeFunctions</code> realizations, filtered by the restrictions imposed by the <code>OptimizeRestrictions</code> argument. This element is populated only if a finite solution exists;<br />
</p>
<p>- <code>realizationsToKeep</code>: a <code>1 x StochReplica</code> boolean row array. If the <code>i</code>-th element is <code>TRUE</code> than the related objective function realization is computable and verifies the restrictions imposed by the <code>OptimizeRestricions</code> argument. It can be useful along with <code>optFunResults</code> and <code>INSTRUMENT_MM</code> in order to verify and to refine results;<br />
</p>
<p>- <code>optFunResults</code>: the numerical array containing the evaluated <code>OptimizeFunctions</code> for all the (unfiltered) realizations;<br />
</p>
<p>- <code>modelData</code>: the whole model input dataset wherein the <code>INSTRUMENT</code> exogenous variables have been modified accordingly to the <code>OPTIMIZE</code> results. This data can be useful in order to verify or to refine results (see example);<br />
</p>
<p>- <code>ConstantAdjustment</code>: a modified constant adjustment input list wherein the constant adjustment time series related to a <code>INSTRUMENT</code> endogenous variables have been modified accordingly to the <code>OPTIMIZE</code> results. This data can be useful in order to verify or to refine results (see example);<br />
</p>
<p>The arguments passed to the function call during the latest <code>OPTIMIZE</code> run will be inserted into the <code>'__OPT_PARAMETERS__'</code> element of the model <code>optimize</code> list; this data can be helpful in order to replicate the optimization results.<br />
</p>
<p>The <code>simulation_MM</code> element is a named <code>list()</code>, having the endogenous variables as names. Each element will contain an <code>R x C</code> matrix, given <code>R</code> the number of observations in the optimization <code>TSRANGE</code> and <code>C=1+StochReplica</code>. The first column of each matrix contains the related endogenous variable's unperturbed simulated values; the remaining columns will contain all the <code>StochReplica</code> stochastic realizations for the related endogenous variable. <br /> 
</p>
<p>The <code>INSTRUMENT_MM</code> element is a named <code>list()</code>, having <code>INSTRUMENT</code> variables as names. Each element will contain an <code>R x C</code> matrix, given <code>R</code> the number of observations in the optimization <code>TSRANGE</code> and <code>C=1+StochReplica</code>. The first column of each matrix contains the related <code>INSTRUMENT</code> variable's unperturbed values; the remaining columns will contain all the <code>StochReplica</code> stochastic realizations for the related <code>INSTRUMENT</code> variable. <br /> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MDL">MDL</a></code><br />
<code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
<code><a href="#topic+ESTIMATE">ESTIMATE</a></code><br />
<code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code><br />
<code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code><br />
<code><a href="#topic+RENORM">RENORM</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#define the advanced Klein model
advancedKleinModelDef &lt;- "
MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL, 
COMMENT&gt; autocorrelation on errors, restrictions and conditional equation evaluations

COMMENT&gt; Consumption with autocorrelation on errors
BEHAVIORAL&gt; cn
TSRANGE 1923 1 1940 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment with restrictions
BEHAVIORAL&gt; i
TSRANGE 1923 1 1940 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor with PDL
BEHAVIORAL&gt; w1 
TSRANGE 1923 1 1940 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 2

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with IF switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) 
IF&gt; i &lt;= 0

END
"

#load the model
advancedKleinModel &lt;- LOAD_MODEL(modelText = advancedKleinModelDef)


#define data
kleinModelData &lt;- list(  
    cn  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,
                    55,50.9,45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7, 	
                    START=c(1920,1),FREQ=1),
    g   =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,
                    10.2,9.3,10,10.5,10.3,11,13,14.4,15.4,22.3,	
                    START=c(1920,1),FREQ=1),
    i   =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,
                    -5.1,-3,-1.3,2.1,2,-1.9,1.3,3.3,4.9,	
                    START=c(1920,1),FREQ=1),
    k   =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,
                    210.6,215.7,216.7,213.3,207.1,202,199,197.7,199.8,
                    201.8,199.9,201.2,204.5,209.4,	
                    START=c(1920,1),FREQ=1),
    p   =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,
                    15.6,11.4,7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,	
                    START=c(1920,1),FREQ=1),
    w1  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,
                    37.9,34.5,29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,	
                    START=c(1920,1),FREQ=1),
    y   =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,
                    50.7,41.3,45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,	
                    START=c(1920,1),FREQ=1),
    t   =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,
                    6.8,7.2,8.3,6.7,7.4,8.9,9.6,11.6,	
                    START=c(1920,1),FREQ=1),
    time=TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,
                    1,2,3,4,5,6,7,8,9,10,	
                    START=c(1920,1),FREQ=1),
    w2  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,
                    5.3,5.6,6,6.1,7.4,6.7,7.7,7.8,8,8.5,	
                    START=c(1920,1),FREQ=1)
);

#load time series into the model object
advancedKleinModel &lt;- LOAD_MODEL_DATA(advancedKleinModel,kleinModelData)

#estimate the model
advancedKleinModel &lt;- ESTIMATE(advancedKleinModel, quietly=TRUE)

#we want to maximize the non-linear objective function:
#f()=(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5
#in 1942 by using INSTRUMENT cn in range (-5,5) 
#(cn is endogenous so we use the add-factor)
#and g in range (15,25)
#we will also impose the following non-linear restriction:
#g+(cn^2)/2&lt;27 &amp; g+cn&gt;17

#we need to extend exogenous variables up to 1942
advancedKleinModel$modelData &lt;- within(advancedKleinModel$modelData,{
    w2    = TSEXTEND(w2,  UPTO=c(1942,1),EXTMODE='CONSTANT')
    t     = TSEXTEND(t,   UPTO=c(1942,1),EXTMODE='LINEAR')
    g     = TSEXTEND(g,   UPTO=c(1942,1),EXTMODE='CONSTANT')
    k     = TSEXTEND(k,   UPTO=c(1942,1),EXTMODE='LINEAR')
    time  = TSEXTEND(time,UPTO=c(1942,1),EXTMODE='LINEAR')
})

#define INSTRUMENT and boundaries
myOptimizeBounds &lt;- list(
    cn=list(TSRANGE=TRUE,
            BOUNDS=c(-5,5)),
    g=list(TSRANGE=TRUE,
           BOUNDS=c(15,25))
)

#define restrictions
myOptimizeRestrictions &lt;- list(
    myRes1=list(
        TSRANGE=TRUE,
        INEQUALITY='g+(cn^2)/2&lt;27 &amp; g+cn&gt;17')
)

#define objective function
myOptimizeFunctions &lt;- list(
    myFun1=list(
        TSRANGE=TRUE,
        FUNCTION='(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5')
)

#Monte-Carlo optimization by using 10000 stochastic realizations
#and 1E-4 convergence criterion 
advancedKleinModel &lt;- OPTIMIZE(advancedKleinModel
                          ,simType = 'FORECAST'
                          ,TSRANGE=c(1942,1,1942,1)
                          ,simConvergence= 1E-4
                          ,simIterLimit  = 1000
                          ,StochReplica  = 10000
                          ,StochSeed = 123
                          ,OptimizeBounds = myOptimizeBounds
                          ,OptimizeRestrictions = myOptimizeRestrictions
                          ,OptimizeFunctions = myOptimizeFunctions)
                          
#OPTIMIZE(): optimization boundaries for the add-factor of endogenous 
#            variable "cn" are (-5,5) from year-period 1942-1 to 1942-1.
#OPTIMIZE(): optimization boundaries for the exogenous 
#            variable "g" are (15,25) from year-period 1942-1 to 1942-1.
#OPTIMIZE(): optimization restriction "myRes1" is active 
#            from year-period 1942-1 to 1942-1.
#OPTIMIZE(): optimization objective function "myFun1" is active 
#            from year-period 1942-1 to 1942-1.
#
#Optimize:     100.00 %
#OPTIMIZE(): 2916 out of 10000 objective function realizations (29%) 
#            are finite and verify the provided restrictions.
#...OPTIMIZE OK

#print local maximum
advancedKleinModel$optimize$optFunMax
#[1] 210.5755

#print INSTRUMENT that allow local maximum to be achieved
advancedKleinModel$optimize$INSTRUMENT
#$cn
#Time Series:
#Start = 1942 
#End = 1942 
#Frequency = 1 
#[1] 2.032203
#
#$g
#Time Series:
#Start = 1942 
#End = 1942 
#Frequency = 1 
#[1] 24.89773

#LET'S VERIFY RESULTS
#copy into modelData the computed INSTRUMENT 
#that allow to maximize the objective function 
advancedKleinModel$modelData &lt;- advancedKleinModel$optimize$modelData

#simulate the model by using the new INSTRUMENT
#note: we used cn add-factor as OPTIMIZE instrument, so we need 
#to pass the computed cn add-factor to the SIMULATE call
newConstantAdjustment &lt;- advancedKleinModel$optimize$ConstantAdjustment
advancedKleinModel &lt;- SIMULATE(advancedKleinModel
                  ,simType = 'FORECAST'
                  ,TSRANGE = c(1942,1,1942,1)
                  ,simConvergence = 1E-5
                  ,simIterLimit = 1000
                  ,ConstantAdjustment = newConstantAdjustment
)

#calculate objective function by using the SIMULATE output time series
#(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5
y  &lt;- advancedKleinModel$simulation$y
cn &lt;- advancedKleinModel$simulation$cn
g  &lt;- advancedKleinModel$modelData$g
optFunTest &lt;- (y-110)+(cn-90)*abs(cn-90)-(g-20)^0.5

#verify computed max is equal to optimization max
#(in the following command TSPROJECT could be omitted because
#myFun1$TSRANGE = TRUE)
abs(sum(TSPROJECT(optFunTest
              ,TSRANGE=c(1942,1,1942,1)
              ,ARRAY = TRUE)
        ) - advancedKleinModel$optimize$optFunMax)  &lt; 1E-4
#[1] TRUE

#we can also check that the SIMULATE time series 
#are equal to the OPTIMIZE realizations that allow to maximize
#the objective function

#get realization index that maximizes the objective function
maximizingRealizationIdx=with(advancedKleinModel$optimize,
                              which.max(optFunResults[realizationsToKeep]))

#get stochastic realizations unfiltered
#(simulation_MM and INSTRUMENT_MM are populated during the OPTIMIZE call)
y_opt  &lt;- advancedKleinModel$simulation_MM$y
cn_opt &lt;- advancedKleinModel$simulation_MM$cn
g_opt  &lt;- advancedKleinModel$INSTRUMENT_MM$g

#filter by restrictions and by finite solutions
#(first column in all matrices is related to the un-perturbed model)
y_opt  &lt;- y_opt[ ,c(FALSE,advancedKleinModel$optimize$realizationsToKeep),drop=FALSE]
cn_opt &lt;- cn_opt[,c(FALSE,advancedKleinModel$optimize$realizationsToKeep),drop=FALSE]
g_opt  &lt;- g_opt[ ,c(FALSE,advancedKleinModel$optimize$realizationsToKeep),drop=FALSE]

#get maximizing realizations
y_opt  &lt;- y_opt[ ,maximizingRealizationIdx,drop=FALSE]
cn_opt &lt;- cn_opt[,maximizingRealizationIdx,drop=FALSE]
g_opt  &lt;- g_opt[ ,maximizingRealizationIdx,drop=FALSE]

#verify that these variables are equal to the SIMULATE time series
max(abs(y-y_opt))   &lt; 1E-4  
#[1] TRUE

max(abs(cn-cn_opt)) &lt; 1E-4  
#[1] TRUE

max(abs(g[[1942,1]]-g_opt)) &lt; 1E-4  
#[1] TRUE

 
############################################################
#MULTI RESTRICTIONS, MULTI OBJECTIVE FUNCTIONS EXAMPLE

#load the model (reset stuff)
advancedKleinModel &lt;- LOAD_MODEL(modelText = advancedKleinModelDef)

#load time series into the model object
advancedKleinModel &lt;- LOAD_MODEL_DATA(advancedKleinModel,kleinModelData)

#estimate the model
advancedKleinModel &lt;- ESTIMATE(advancedKleinModel, quietly=TRUE)

#we want to maximize the non-linear objective function:
#f1()=(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5
#in 1942 by using INSTRUMENT cn in range (-5,5) 
#(cn is endogenous so we use the add-factor)
#and g in range (15,25)
#we want to maximize the non-linear objective function:
#f2()=(y-120)+(cn-100)*ABS(cn-100)-(g-20)^0.5-(w2-8)^0.5
#in 1943 by using INSTRUMENT cn in range (-5,5),
#g in range (15,25)
#and w2 in range (7.5,12.5)
#we will also impose the following non-linear restrictions:
#in 1942: g+(cn^2)/2&lt;27 &amp; g+cn&gt;17
#in 1943: (g^2)/10+(cn^2)/2+w2^2 &lt; 200

#we need to extend exogenous variables up to 1943
advancedKleinModel$modelData &lt;- within(advancedKleinModel$modelData,{
    w2    = TSEXTEND(w2,  UPTO=c(1943,1),EXTMODE='CONSTANT')
    t     = TSEXTEND(t,   UPTO=c(1943,1),EXTMODE='LINEAR')
    g     = TSEXTEND(g,   UPTO=c(1943,1),EXTMODE='CONSTANT')
    k     = TSEXTEND(k,   UPTO=c(1943,1),EXTMODE='LINEAR')
    time  = TSEXTEND(time,UPTO=c(1943,1),EXTMODE='LINEAR')
})

#define INSTRUMENT and boundaries
myOptimizeBounds &lt;- list(
    cn=list(TSRANGE=TRUE,
            BOUNDS=c(-5,5)),
    g=list(TSRANGE=TRUE,
           BOUNDS=c(15,25)),
    w2=list(TSRANGE=c(1943,1,1943,1),
            BOUNDS=c(7.5,12.5))
)

#define restrictions
myOptimizeRestrictions &lt;- list(
    myRes1=list(
        TSRANGE=c(1942,1,1942,1),
        INEQUALITY='g+(cn^2)/2 &lt; 27 &amp; g+cn &gt; 17'),
    myRes2=list(
        TSRANGE=c(1943,1,1943,1),
        INEQUALITY='(g^2)/10+(cn^2)/2+w2^2 &lt; 200')
)

#define objective functions
myOptimizeFunctions &lt;- list(
    myFun1=list(
        TSRANGE=c(1942,1,1942,1),
        FUNCTION='(y-110)+(cn-90)*ABS(cn-90)-(g-20)^0.5'),
    myFun2=list(
        TSRANGE=c(1943,1,1943,1),
        FUNCTION='(y-120)+(cn-100)*ABS(cn-100)-(g-20)^0.5-(w2-8)^0.5')
)

#Monte-Carlo optimization by using 1000 stochastic realizations
#and 1E-4 convergence
advancedKleinModel &lt;- OPTIMIZE(advancedKleinModel
                          ,simType = 'FORECAST'
                          ,TSRANGE=c(1942,1,1943,1)
                          ,simConvergence=1E-4
                          ,simIterLimit = 500
                          ,StochReplica = 1000
                          ,StochSeed = 123
                          ,OptimizeBounds = myOptimizeBounds
                          ,OptimizeRestrictions = myOptimizeRestrictions
                          ,OptimizeFunctions = myOptimizeFunctions)

#print INSTRUMENT that allow local maximum to be achieved
advancedKleinModel$optimize$INSTRUMENT

#LET'S VERIFY RESULTS
#copy into modelData the computed INSTRUMENT 
#that allow to maximize the objective function 
advancedKleinModel$modelData &lt;- advancedKleinModel$optimize$modelData

#simulate the model by using the new INSTRUMENT
newConstantAdjustment &lt;- advancedKleinModel$optimize$ConstantAdjustment
advancedKleinModel &lt;- SIMULATE(advancedKleinModel
                  ,simType = 'FORECAST'
                  ,TSRANGE = c(1942,1,1943,1)
                  ,simConvergence = 1E-5
                  ,simIterLimit = 100
                  ,ConstantAdjustment = newConstantAdjustment
)

#calculate objective functions by using the SIMULATE output time series
y  &lt;- advancedKleinModel$simulation$y
cn &lt;- advancedKleinModel$simulation$cn
g  &lt;- advancedKleinModel$modelData$g
w2 &lt;- advancedKleinModel$modelData$w2
optFunTest1 &lt;- (y-110)+(cn-90)*abs(cn-90)-(g-20)^0.5
optFunTest2 &lt;- (y-120)+(cn-100)*abs(cn-100)-(g-20)^0.5-(w2-8)^0.5

#verify computed max is equal to optimization max
abs(sum(TSPROJECT(optFunTest1
                  ,TSRANGE=c(1942,1,1942,1)
                  ,ARRAY = TRUE)+
        TSPROJECT(optFunTest2
                  ,TSRANGE=c(1943,1,1943,1)
                  ,ARRAY = TRUE)
        ) - advancedKleinModel$optimize$optFunMax)  &lt; 1E-2
#[1] TRUE
    
</code></pre>

<hr>
<h2 id='QUARTERLY'>
Quarterly (Dis)Aggregation
</h2><span id='topic+QUARTERLY'></span>

<h3>Description</h3>

<p>This function returns a quarterly (dis)aggregated time series, using as input an annual, semiannual, monthly or daily time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QUARTERLY(x = NULL, fun = NULL, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QUARTERLY_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="QUARTERLY_+3A_fun">fun</code></td>
<td>
<p> Only for daily or monthly input time series:<br /> 
<b>STOCK</b>: the value of the input time series in the last observation of a quarter is assigned to the same quarter of the output time series.<br />
<b>NSTOCK</b>: the value of the input time series in the last non-missing observation of a quarter is assigned to the same quarter of the output time series.<br />
<b>SUM</b>: the sum of input observations in a quarter is assigned to the same quarter of the output time series.<br />
<b>NSUM</b>:  the sum of input non-missing observations in a quarter is assigned to the same quarter of the output time series. <br />
<b>AVE</b>: the average of input observations in a quarter is assigned to the same quarter of the output time series. <br />
<b>NAVE</b>: the average of input non-missing observations in a quarter is assigned to the same quarter of the output time series.<br /> <br />
Only for semiannual or annual input time series:<br />
<b>NULL</b>: (default) the output value of each quarterly observation is set equal to the value of the input observation the quarter belongs to (i.e. duplicated values over the period)<br />
<b>INTERP_END</b>: the value of the input time series in a period is copied into the last quarter of the output time series that lies in the same period. Other values are calculated by linear interpolation.<br />
<b>INTERP_CENTER</b>: the value of the input time series in a period is copied into the median quarter of the output time series that lies in the same period. Other values are calculated by linear interpolation. <br />
<b>INTERP_BEGIN</b>: the value of the input time series in a period is copied into the first quarter of the output time series that lies in the same period. Other values are calculated by linear interpolation.
</p>
</td></tr>
<tr><td><code id="QUARTERLY_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="QUARTERLY_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a quarterly BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+YEARLY">YEARLY</a></code><br />
<code><a href="#topic+SEMIANNUAL">SEMIANNUAL</a></code><br />
<code><a href="#topic+MONTHLY">MONTHLY</a></code><br />
<code><a href="#topic+DAILY">DAILY</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#TS YEARLY TO QUARTERLY
	n&lt;-10
	ts1&lt;-TSERIES(1:n,START=c(2000,1),FREQ=1)
	ts1[5]&lt;-NA
	TABIT(QUARTERLY(ts1,fun='INTERP_CENTER'));
	
	#TS DAILY TO QUARTERLY
	n&lt;-600
	ts1&lt;-TSERIES(1:n,START=c(2000,1),FREQ='D')
	ts1[25]&lt;-NA
	TABIT(QUARTERLY(ts1,fun='SUM'))
</code></pre>

<hr>
<h2 id='RENORM'>
Endogenous targeting of a BIMETS model.
</h2><span id='topic+RENORM'></span>

<h3>Description</h3>

<p>The endogenous targeting of econometric models (a.k.a. &quot;renormalization&quot;) consists of solving the model while interchanging the role of one or more endogenous variables with an equal number of exogenous variables.<br /><br /> This procedure determines the values for the <code>INSTRUMENT</code> exogenous variables that allow the objective <code>TARGET</code> endogenous values to be achieved, with respect to the constraints given by the model equations (see <code><a href="#topic+MDL">MDL</a></code>).<br /><br />
This is an approach to economic and monetary policy analysis, and is based on two assumptions:<br /><br />
1. there exists a desired level for a set of the <code>n</code> endogenous variables defined as <code>TARGET</code>;<br />
2. there exists a set of the <code>n</code> exogenous variables defined as <code>INSTRUMENT</code>;<br /><br />
Given these premises, the endogenous targeting process consists in determining the values of the exogenous variables chosen as <code>INSTRUMENT</code> allowing us to achieve the desired values for the endogenous variables designated as <code>TARGET</code>. In other words the procedure allows users to exchange the role of exogenous and endogenous among a set of variables pairs. <br /><br />
Given a list of exogenous <code>INSTRUMENT</code> variables and a list of <code>TARGET</code> endogenous time series, the iterative procedure can be split into the following steps:<br /><br />
1. Computation of the multipliers matrix <code>MULTMAT</code> of the <code>TARGET</code> endogenous variables with respect to the <code>INSTRUMENT</code> exogenous variables (this is a square matrix by construction);<br /><br />
2. Solution of the linear system (if any): <br /><br />
<code class="reqn">V_{exog}(i+1) = V_{exog}(i) +</code> <code>MULTMAT</code> <code class="reqn">^{-1} * (V_{endog}(i) -</code> <code>TARGET</code> <code class="reqn">)</code>, where <code class="reqn">V_{exog}(i)</code> are the exogenous variables in the <code>INSTRUMENT</code> list and <code class="reqn">V_{endog}(i)</code> are the endogenous variables that have a related target in the <code>TARGET</code> list, given <code class="reqn">i</code> the current iteration;<br /><br />
3. Simulation of the model with the new set of exogenous variables computed in step 2, then a convergence check by comparing the subset of endogenous variables arising from this simulation and the related time series in <code>TARGET</code> list. If the convergence condition is satisfied, or the maximum number of iterations is reached, the algorithm will stop, otherwise it will go back to step 1;<br /><br />
Users can also declare an endogenous variable as an <code>INSTRUMENT</code> variable. In this case, the constant adjustment (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>) related to the provided endogenous variable will be used as the instrument exogenous variable. This procedure is particularly suited for the automatic computation of the add-factors needed to fine tune the model into a baseline path and to improve the forecasting accuracy.<br /><br />
If the convergence condition is satisfied, the <code>RENORM</code> procedure will return the <code>INSTRUMENT</code> time series allowing us to achieve the desired values for the endogenous variables designated as <code>TARGET</code>.<br /><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
RENORM(model=NULL,
       simAlgo='GAUSS-SEIDEL',
       TSRANGE=NULL,
       simType='DYNAMIC',
       simConvergence=0.01,
       simIterLimit=100,
       ZeroErrorAC=FALSE,
       Exogenize=NULL,
       ConstantAdjustment=NULL,
       verbose=FALSE,
       verboseSincePeriod=0,
       verboseVars=NULL,
       renormIterLimit=10,
       renormConvergence=1e-4,
       TARGET=NULL,
       INSTRUMENT=NULL,
       MM_SHOCK=0.00001,
       quietly=FALSE,
       quietlyMULTMATRIX=FALSE,
       tol=1e-28,
       JACOBIAN_SHOCK=1e-4,
       JacobianDrop=NULL,
       avoidCompliance=FALSE,
       ...
       )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RENORM_+3A_model">model</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_simalgo">simAlgo</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_tsrange">TSRANGE</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_simtype">simType</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_simconvergence">simConvergence</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_simiterlimit">simIterLimit</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_zeroerrorac">ZeroErrorAC</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_exogenize">Exogenize</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_constantadjustment">ConstantAdjustment</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_verbose">verbose</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_verbosesinceperiod">verboseSincePeriod</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_verbosevars">verboseVars</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_renormiterlimit">renormIterLimit</code></td>
<td>
<p>The value representing the maximum number of iterations to be performed. The iterative renormalization procedure will stop when <code>renormIterLimit</code> is reached or the <code>TARGET</code> variables satisfy the <code>renormConvergence</code> criterion</p>
</td></tr>
<tr><td><code id="RENORM_+3A_renormconvergence">renormConvergence</code></td>
<td>
<p>The convergence value requested for the iterative renormalization process, that stops when the Euclidean distance between each <code>TARGET</code> time series and the related simulated endogenous variable is less than the <code>renormConvergence</code> value
</p>
</td></tr>
<tr><td><code id="RENORM_+3A_target">TARGET</code></td>
<td>
<p>A named list that specifies the target endogenous variables. List names must be equal to the names of the target endogenous variables involved in the renormalization; each list element must contain the time series of the desired target endogenous values; time series must be compliant with the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code> (see example)</p>
</td></tr>
<tr><td><code id="RENORM_+3A_instrument">INSTRUMENT</code></td>
<td>
<p>A <code>character</code> array built with the names of the instrument exogenous variables involved in the renormalization. User can also declare an endogenous variable as <code>INSTRUMENT</code> variable: in this case the constant adjustment (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>) related to the provided endogenous variable will be used as instrument exogenous variable (see example)
</p>
</td></tr>
<tr><td><code id="RENORM_+3A_tol">tol</code></td>
<td>

<p>the tolerance for detecting linear dependencies in the columns of a matrix while an inversion is requested. </p>
</td></tr>
<tr><td><code id="RENORM_+3A_mm_shock">MM_SHOCK</code></td>
<td>
<p>see <code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_quietly">quietly</code></td>
<td>
<p>If <code>TRUE</code>, information messages related to the <code><a href="#topic+RENORM">RENORM</a></code> operation will be suppressed.</p>
</td></tr>
<tr><td><code id="RENORM_+3A_quietlymultmatrix">quietlyMULTMATRIX</code></td>
<td>
<p>If <code>TRUE</code>, information messages related to the underlying <code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code> operation will be suppressed. If <code>quietly</code> argument is set to <code>TRUE</code>, then <code>quietlyMULTMATRIX</code> will be set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="RENORM_+3A_jacobian_shock">JACOBIAN_SHOCK</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_jacobiandrop">JacobianDrop</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_avoidcompliance">avoidCompliance</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="RENORM_+3A_...">...</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will add a new named element <code>renorm</code> into the output BIMETS model object.<br /><br />
This new <code>renorm</code> element is a named list that contains the following elements:<br /><br /> 
- <code>INSTRUMENT</code>: a named list that contains the <code>INSTRUMENT</code> exogenous time series that allow the objective <code>TARGET</code> endogenous values to be achieved. This element is populated only if the convergence is reached. List names are equal to the names of the related exogenous variables. Users can also declare an endogenous variable as <code>INSTRUMENT</code> variable: in this case the constant adjustment (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>) related to the provided endogenous variable will be used as instrument exogenous variable, and this <code>INSTRUMENT</code> output list will contains the constant adjustment time series that allow the objective <code>TARGET</code> endogenous values to be achieved (see example);<br /><br />
- <code>TARGET</code>: a named list built with the achieved <code>TARGET</code> endogenous time series. List names are equal to the target endogenous variable names; <br /><br />
- <code>unConvergedTARGET</code>: the names array of the endogenous <code>TARGET</code> variables that failed the convergence. This element is populated only if the convergence has not been reached;<br /><br />
- <code>modelData</code>: the whole model input dataset wherein the <code>INSTRUMENT</code> exogenous variables have been modified accordingly to the <code>RENORM</code> results. This data can be useful in order to refine results or to verify that the model, fed with the proper <code>INSTRUMENT</code> exogenous time series, produces the desired <code>TARGET</code> endogenous values. This element is populated only if the convergence is achieved (see example);<br /><br />
- <code>ConstantAdjustment</code>: a modified constant adjustment input list (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>) wherein the constant adjustment time series related to a <code>INSTRUMENT</code> endogenous variables have been modified accordingly to the <code>RENORM</code> results. This data can be useful in order to refine results or to verify that the model, fed with the proper <code>INSTRUMENT</code> exogenous time series (therefore with the proper <code>ConstantAdjustment</code> time series, if any), produces the desired <code>TARGET</code> endogenous values (see example). This element is populated only if the convergence is achieved;<br /><br />
- <code>__RENORM_PARAMETERS__</code>: a named list that contains the arguments passed to the function call during the latest <code>RENORM</code> run, e.g. <code>TSRANGE</code>, <code>INSTRUMENT</code>, <code>TARGET</code>, <code>renormIterLimit</code>, <code>renormConvergence</code>, <code>ConstantAdjustment</code>, <code>Exogenize</code>, etc.: this data can be useful in order to replicate renorm results. <br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MDL">MDL</a></code><br />
<code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
<code><a href="#topic+ESTIMATE">ESTIMATE</a></code><br />
<code><a href="#topic+SIMULATE">SIMULATE</a></code><br />
<code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code><br />
<code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code><br />
<code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#define model
myModelDefinition&lt;-
"MODEL 
COMMENT&gt; Klein Model 1 of the U.S. Economy 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1921 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END"

#define model data
myModelData&lt;-list(
  cn
  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
              45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
              START=c(1920,1),FREQ=1),
  g
  =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
              10.5,10.3,11,13,14.4,15.4,22.3,
              START=c(1920,1),FREQ=1),
  i
  =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
              2.1,2,-1.9,1.3,3.3,4.9,
              START=c(1920,1),FREQ=1),
  k
  =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
              216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
              201.2,204.5,209.4,
              START=c(1920,1),FREQ=1),
  p
  =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
              7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
              START=c(1920,1),FREQ=1),
  w1
  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
              29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
              START=c(1920,1),FREQ=1),
  y
  =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
              45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
              START=c(1920,1),FREQ=1),
  t
  =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
              8.3,6.7,7.4,8.9,9.6,11.6,
              START=c(1920,1),FREQ=1),
  time
  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
              START=c(1920,1),FREQ=1),
  w2
  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
              7.4,6.7,7.7,7.8,8,8.5,
              START=c(1920,1),FREQ=1)
)

#load model and model data
myModel&lt;-LOAD_MODEL(modelText=myModelDefinition)
myModel&lt;-LOAD_MODEL_DATA(myModel, myModelData)

#estimate model
myModel&lt;-ESTIMATE(myModel)

#we want an arbitrary value of 66 on Consumption 'cn' in 1940 and 78 in 1941
#we want an arbitrary value of 77 on GNP 'y' in 1940 and 98 in 1941
kleinTargets&lt;-list(
  cn = TSERIES(66,78,START=c(1940,1),FREQ=1),
  y  = TSERIES(77,98,START=c(1940,1),FREQ=1)
)

#Then, we can perform the model endogenous targeting by using Government Wage Bill 'w2' 
#and Government Expenditure 'g' as 
#INSTRUMENT in the years 1940 and 1941:
myModel&lt;-RENORM(myModel
                    ,INSTRUMENT = c('w2','g')
                    ,TARGET = kleinTargets
                    ,TSRANGE = c(1940,1,1941,1)
                    ,simIterLimit = 100
)


with(myModel,TABIT(modelData$w2,
                   renorm$INSTRUMENT$w2,
                   modelData$g,
                   renorm$INSTRUMENT$g))

#  Date, Prd., modelData$w2, renorm$INSTRUMENT$w2, modelData$g, renorm$INSTRUMENT$g
# etc.
#  1938, 1   ,          7.7,                     ,          13,           
#  1939, 1   ,          7.8,                     ,        14.4,           
#  1940, 1   ,            8,              7.41333,        15.4,             16.1069
#  1941, 1   ,          8.5,               9.3436,        22.3,             22.6599
#So, if we want to achieve on Consumption 'cn' 
#an arbitrary simulated value of 66 
#in 1940 and 78 in 1941, and if we want 
#to achieve on GNP 'y' an arbitrary 
#simulated value of 77 in 1940 and 98 in 1941, 
#we need to change exogenous 'w2' from 8 to 7.41 
#in 1940 and from 8.5 to 9.34 in 1941, 
#and we need to change exogenous 'g' 
#from 15.4 to 16.1 in 1940 and from 22.3 to 22.66 in 1941

#Let's verify:
#create a new model
kleinRenorm&lt;-myModel

#get instruments to be used
newInstruments=myModel$renorm$INSTRUMENT

#change exogenous by using new instruments
kleinRenorm$modelData&lt;-within(kleinRenorm$modelData,
                 {
                   w2[[1940,1]]=newInstruments$w2[[1940,1]]
                   w2[[1941,1]]=newInstruments$w2[[1941,1]]
                   g[[1940,1]] =newInstruments$g[[1940,1]]
                   g[[1941,1]] =newInstruments$g[[1941,1]]
                 }
                )
#users can also replace last two commands with:
#kleinRenorm$modelData&lt;-kleinRenorm$renorm$modelData

#simulate the new model
kleinRenorm&lt;-SIMULATE(kleinRenorm
                      ,TSRANGE=c(1940,1,1941,1)
                      ,simConvergence=0.00001
                      ,simIterLimit=100
                      )
#Simulation: 100.00%
#...SIMULATE OK

#verify targets are achieved
with(kleinRenorm$simulation,
     TABIT(cn,y)
     )
     
#Date, Prd., cn        , y
#1940,  1  , 66.01116  , 77.01772
#1941,  1  , 78.02538  , 98.04121



######################################################################


#now use 'i' endogenous variable as an instrument

#first, define the related exogenous constant adjustment
myCA&lt;-list(i = myModel$modelData$i*0+0.1)

#run renorm with endogenous 'i' as instrument
myModel&lt;-RENORM(myModel
               ,INSTRUMENT = c('w2','i')
               ,TARGET = kleinTargets
               ,TSRANGE = c(1940,1,1941,1)
               ,simIterLimit = 100
               ,ConstantAdjustment = myCA
)

#get the values of the constant adjustment for the endogenous 'i' 
#in 1940-1941 that allow achieving the target values for 'cn' and 'y'
myModel$renorm$ConstantAdjustment
#$i
#Time Series:
#Start = 1920 
#End = 1941 
#Frequency = 1 
# [1] 0.1000000 0.1000000 0.1000000 ...
#[20] 0.1000000 0.7069039 0.4388811

#these values are also reported in the INSTRUMENT output list
myModel$renorm$INSTRUMENT$i
#Time Series:
#Start = 1940 
#End = 1941 
#Frequency = 1 
#[1] 0.7069039 0.4388811


</code></pre>

<hr>
<h2 id='SEMIANNUAL'>
Semiannual (Dis)Aggregation
</h2><span id='topic+SEMIANNUAL'></span>

<h3>Description</h3>

<p>This function returns a semi-annual (dis)aggregated time series, by using as input an annual, quarterly, monthly or daily time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMIANNUAL(x = NULL, fun = NULL, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SEMIANNUAL_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="SEMIANNUAL_+3A_fun">fun</code></td>
<td>
<p> Only for daily or monthly or quarterly input time series:<br /> 
<b>STOCK</b>: the value of the input time series in the last observation of a half-year is assigned to the same half-year of the output time series.<br />
<b>NSTOCK</b>: the value of the input time series in the last non-missing observation of a half-year is assigned to the same half-year of the output time series.<br />
<b>SUM</b>: the sum of input observations in a half-year is assigned to the same half-year of the output time series.<br />
<b>NSUM</b>:  the sum of input non-missing observations in a half-year is assigned to the same half-year of the output time series. <br />
<b>AVE</b>: the average of input observations in a half-year is assigned to the same half-year of the output time series. <br />
<b>NAVE</b>: the average of input non-missing observations in a half-year is assigned to the same half-year of the output time series.<br /> <br />
Only for annual input time series:<br />
<b>NULL</b>: (default) the output value of each half-year observation is set equal to the value of the input observation the half-year belongs to (i.e. duplicated values over the period)<br />
<b>INTERP_END</b>: the value of the input time series in a period is copied into the last half-year of the output time series that lies in the same period. Other values are calculated by linear interpolation.<br />
<b>INTERP_CENTER</b>: the value of the input time series in a period is copied into the median half-year of the output time series that lies in the same period. Other values are calculated by linear interpolation. <br />
<b>INTERP_BEGIN</b>: the value of the input time series in a period is copied into the first half-year of the output time series that lies in the same period. Other values are calculated by linear interpolation.
</p>
</td></tr>
<tr><td><code id="SEMIANNUAL_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="SEMIANNUAL_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a semi-annual BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ANNUAL">ANNUAL</a></code><br />
<code><a href="#topic+QUARTERLY">QUARTERLY</a></code><br />
<code><a href="#topic+MONTHLY">MONTHLY</a></code><br />
<code><a href="#topic+DAILY">DAILY</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#TS QUARTERLY TO SEMIANNUAL
	n&lt;-14
	xArr&lt;-(n:0)
	ts1&lt;-TSERIES(xArr,START=c(2000,1),FREQ='Q')
	print(SEMIANNUAL(ts1,fun='NAVE'))
	
	#TS ANNUAL TO SEMIANNUAL
	ts1&lt;-TSERIES((1:10),START=c(2000,1),FREQ=1)
	print(SEMIANNUAL(ts1,fun='INTERP_END'))
</code></pre>

<hr>
<h2 id='SIMULATE'>
Simulation of a BIMETS model
</h2><span id='topic+SIMULATE'></span>

<h3>Description</h3>

<p>The simulation of an econometric model basically consists in solving the system of the equations describing the model for each time period in the specified time interval. Since the equations may not be linear in the variables, and since the graph derived from the incidence matrix may be cyclic, the usual methods based on linear algebra are not applicable. The simulation must be solved by using an iterative algorithm.<br /><br />
BIMETS simulation capabilities support:<br /><br />
- <em>Static simulations</em>: a static multiple equation simulation, in which the historical values for the lagged endogenous variables are used in the solutions of subsequent periods; <br /><br />
- <em>Dynamic simulations</em>: a dynamic simulation, in which the simulated values for the lagged endogenous variables are used in the solutions of subsequent periods;<br /><br />
- <em>Residuals check</em>: a single period, single equation simulation; simulated time series in output are just the computation of the RHS (right-hand-side) of their equation, by using the historical values of the involved time series and by accounting for error autocorrelation and PDLs, if any;<br /><br />
- <em>Forecast simulations</em>: similar to dynamic simulation, but during the initialization of the iterative algorithm the starting values of endogenous variables in a period are set equal to the simulated values of the previous period. This allows the simulation of future endogenous observations, i.e. the forecast;  <br /><br />
- <em>Stochastic Simulation</em>: see <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>;<br /><br />
- <em>Partial or total exogenization of endogenous variables</em>: in the provided time interval (i.e. partial exog.) or in whole simulation time range (i.e. total exog.), the values of the selected endogenous variables can be definitely set equal to their historical values, by excluding their equations from the iterative algorithm of simulation;<br /><br />
- <em>Constant adjustment of endogenous variables (add-factors)</em>: adds up a new exogenous time series - the &quot;constant adjustment&quot; - in the equation of the selected endogenous variables.<br /><br />
- <em>Gauss-Seidel</em> and <em>Newton-Raphson</em> simulation algorithms: the Gauss-Seidel algorithm is simple, robust, and works well for many backward-looking macro-econometric models. Equations are evaluated as-is in a proper order until the convergence, if any, is verified on feedback variables. It is slower than Newton-Raphson algorithms for a very low convergence criterion, and fails to find a convergence for a small set of econometric models, even when a convergence exists. The Newton-Raphson algorithm allows users to solve a broader set of macro-econometric models than the Gauss-Seidel algorithm. Moreover, it is usually faster than the Gauss-Seidel algorithm (on modern computers, users must simulate an extensive econometric model with a low convergence criterion to appreciate the speedup). This type of algorithm requires the construction and the inversion of the Jacobian matrix for the feedback variables; thus, in some scenarios, numerical issues can arise, and users are required to manually exclude some feedback variables from the Jacobian matrix by using the <code>JacobianDrop</code> argument of the <code><a href="#topic+SIMULATE">SIMULATE</a></code> procedure.<br /><br />
In details, the generic model suitable for simulation in BIMETS can be written as: <br />
</p>
<p><code class="reqn">y_1=f_1(\bar{x},\bar{y}) </code> <br />
<code class="reqn">...</code> <br />
<code class="reqn">y_n=f_n(\bar{x},\bar{y}) </code> <br />
</p>
<p>being: <br /><br />
<code class="reqn">n</code> the number of equations in the model; <br />
<code class="reqn">\bar{y}=[y_1, ... , y_n]</code> the <code>n</code>-dimensional vector of the endogenous variables;<br />
<code class="reqn">\bar{x}=[x_1, ... , x_m]</code> the <code>m</code>-dimensional vector of the exogenous variables;<br />
<code class="reqn">f_i(...), i=1..n</code> any kind of functional expression able to be written by using the <code>MDL</code> syntax;<br /><br />
As described later on, in BIMETS a modified Gauss-Seidel iterative algorithm, or a Newton-Raphson algorithm, can solve the system of equations. The convergence properties may vary depending on the model specifications. In some conditions, the algorithm may not converge for a specific model or a specific set of data.<br /><br />
A convergence criterion and a maximum number of iterations to be performed are provided by default. Users can change these criteria by using the <code>simConvergence</code> and <code>simIterLimit</code> arguments of the <code>SIMULATE</code> function.<br /><br />
The general conceptual scheme of the simulation process (for each time period) is the following:<br /><br />
1. initialize the solution for the current simulation period;<br />
2. iteratively solve the system of equations;<br />
3. save the solution, if any;<br /><br />
Step 2 means that for each iteration, the operations are: <br /><br />
2.1 update the values of the current endogenous variables;<br />
2.2 verify that the convergence criterion is satisfied or that the maximum number of allowed iterations has been reached;<br /><br />
The initial solution for the iterative process (step 1) can be given alternatively by:<br /><br />
- the historical value of the endogenous variables for the current simulation period (the default);<br />
- the simulated value of the endogenous variables from the previous simulation period (this alternative is driven by the <code>simType='FORECAST'</code> argument of the <code>SIMULATE</code> function);<br /><br />
In the &quot;dynamic&quot; simulations (i.e. simulations performed by using either the default <code>simType='DYNAMIC'</code> or the <code>simType='FORECAST'</code>), whenever lagged endogenous variables are needed in the computation, the simulated values of the endogenous variables <code class="reqn">\bar{y}</code> assessed in the previous time periods are used. In this case, the simulation results in a given time period depend on the simulation results in the previous time periods. This kind of simulation is defined as &quot;multiple equation, multiple period&quot;.<br /><br />
As an alternative, the actual historical values can be used in the &quot;static&quot; simulations (i.e. simulations performed by using <code>simType='STATIC'</code>) rather than simulated values whenever lagged endogenous variables are needed in the computations. In this case, the simulation results in a given time period do not depend on the simulation results in the previous time periods. This kind of simulation is defined as &quot;multiple equation, single period&quot;.<br /><br />
The last simulation type available is the residual check (<code>simType='RESCHECK'</code>). With this option, a &quot;single equation, single period&quot; simulation is performed. In this case, no iteration must be carried out. The endogenous variables are assessed for each time period by using historical values for each variable on the right-hand side of the equation, for both lagged and current periods. This kind of simulation helps debug and check of the logical coherence of the equations and the data, and can be used as a simple tool to compute the add-factors.<br /><br /> The debugging of the logical coherence of equations and data is carried out through a <em>Residual Check</em> procedure.<br /><br />
It consists of the following steps:<br /><br />
1. add another exogenous variable - the constant adjustment - to every equation of the model, both behavioral and technical identity (i.e. by using the <code>ConstantAdjustment</code> argument of the <code>SIMULATE</code> function);<br />
2. fill in with the estimated residuals all the constant adjustments for the behavioral equations; <br />
3. fill in with zeroes the constant adjustments for the technical identities;<br />
4. perform a simulation of the model with the <code>simType='RESCHECK'</code> option;<br />
5. compute the difference between the historical and the simulated values for all the endogenous variables;<br />
6. check whether all the differences assessed in step 5 are zero in whole time range;<br /><br />
If a perfect tracking of the history is obtained, then the equations have been written coherently with the data, otherwise a simulated equation not tracking the historical values is an unambiguous symptom of data inconsistent with the model definition.<br /><br />
Aside from the residual check, the add-factors constitute an important tool to significantly improve the accuracy of forecasts made through an econometric model. Considering the following model: <br /><br />
<code class="reqn">y_1=f_1(\bar{x},\bar{y}) + z_1</code> <br />
<code class="reqn">...</code> <br />
<code class="reqn">y_n=f_n(\bar{x},\bar{y}) + z_n</code> <br /><br />
the add-factors <code class="reqn">\bar{z}=[z_1, ... ,z_n]</code> can be interpreted as estimates of the disturbance terms' future values or as adjustments of the intercepts in each equation. These add-factors round out the forecasts, by summarizing the effects of all the systematic factors not included in the model. One choice for the computation of the add-factors is given by past estimation residuals and past forecast errors or by an average of these errors. This consideration suggests an easy way of computing the add-factors:<br /><br />
1. add the constant adjustments to every equation of the model, both behavioral and technical identity;<br />
2. fill in with zeroes all the constant adjustments;<br />
3. solve the model, with the <code>simType='RESCHECK'</code> option, in a time interval including some periods beyond the estimation sample;<br />
4. compute the difference between the historical and the simulated values for each the endogenous variables;<br />
5. average, or process in a suitable way, the difference arising from point 4 in the time periods beyond the estimation sample to compute the constant value to be used as an add-factor in the following forecasting exercises;<br /><br />
Please note that, in the case of equation that presents an LHS function, the add-factor will be added before the application of the inverse function, i.e., during the simulation, the following:<br /><br />
<code class="reqn">g_1(y_1)=f_1(\bar{x},\bar{y}) + z_1</code> <br />
<code class="reqn">...</code> <br />
<code class="reqn">g_n(y_n)=f_n(\bar{x},\bar{y}) + z_n</code> <br /><br />
will be solved as:<br /><br />
<code class="reqn">y_1=g_{1}^{-1}(f_1(\bar{x},\bar{y}) + z_1)</code> <br />
<code class="reqn">...</code> <br />
<code class="reqn">y_n=g_{n}^{-1}(f_n(\bar{x},\bar{y}) + z_n)</code> <br /><br />
If a linear dependence between the simulated endogenous and the add-factor is preferred, users can manually insert an auxiliary equation <code class="reqn">w_i</code> into the model definition, e.g. the following:<br /><br />
<code class="reqn">g_i(y_i)=f_i(\bar{x},\bar{y})</code> <br /><br />
can be replaced by:<br /><br />
<code class="reqn">w_i=f_i(\bar{x},\bar{y})</code> <br />
<code class="reqn">y_i=g_{i}^{-1}(w_i)</code> <br /><br />
During the simulation, the add-factors (if requested by the user) will be applied as in the following:<br /><br />
<code class="reqn">w_i=f_i(\bar{x},\bar{y}) + v_i</code> <br />
<code class="reqn">y_i=g_{i}^{-1}(w_i) + z_i</code> <br /><br />
given <code class="reqn">v_i, z_i</code> as add-factors and the linear dependence from <code class="reqn">z_i</code> and <code class="reqn">y_i</code>.<br /><br />
</p>

<table>
<tr>
 <td style="text-align: center;">THE OPTIMAL REORDERING</td>
</tr>

</table>

<p>In fact, the simulation process takes advantage of an appropriate ordering of the equations to increase the performances by iteratively solving only one subset of equations, while the others are solved straightforwardly. <em>&quot;...a different ordering of the equations can substantially affect the speed of convergence of the algorithm; indeed some orderings may produce divergence. The less feedback there is, the better the chances for fast convergence...&quot;</em> - Don, Gallo - Solving large sparse systems of equations in econometric models - Journal of Forecasting 1987.<br /><br />
The <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code> function builds the model's incidence matrix, then defines the proper equation reordering. The incidence matrix is built from the equations of the model; it is a square matrix in which each row and each column represent an endogenous variable. If the <code>(i,j)</code> element is equal to 1 then in the model definition the current value of the endogenous variable referred by the <code>i</code>-row depends directly from the current value of the endogenous variable referred by the <code>j</code>-column. The reader can see an incidence matrix example in the section <code><a href="#topic+bimets">&quot;BIMETS package&quot;</a></code> of this manual wherein the content of the <code>kleinModel$incidence_matrix</code> variable is printed out.<br /><br />
In econometric models, the incidence matrix is usually very sparse. Only a few of the total set of endogenous variables are used in each equation. In this situation, ordering the equation in a particular sequence will lead to a sensible reduction of the number of iterations needed to achieve convergence. Reordering the equations is equivalent to rearranging rows and columns of the incidence matrix. In this way, the incidence matrix might be made lower triangular for a subset of the equations.
For this subset, an endogenous variable determined in a specific equation has no <em>incidence</em> in any equation above it, although the same variable might have incidence in equations below it. Such a subset of equations is called recursive. Recursive systems are easy to solve. It is only necessary to solve each equation once if this is done in the proper order. On the other hand, it is unlikely for whole model to be recursive. Indeed the incidence graph is often cyclic, as in the Klein's model that presents the following circular dependecies in the incidence matrix: <code>p &lt;- w1 &lt;- y &lt;- p</code> as shown in the <code><a href="#topic+bimets">&quot;BIMETS package&quot;</a></code> section figure.<br /><br />
For a subset of the equations, some 1's will occur in the upper triangle of the incidence matrix for all possible orderings. Such subset of equations is called <em>simultaneous</em>. To solve the endogenous variables in the simultaneous block of equations, an iterative algorithm has to be used. Nevertheless, the equations in the simultaneous block may be ordered so that the pattern of the 1's in the upper triangle of the incidence matrix forms a spike. The variables corresponding to the 1's in the upper triangle are called <em>feedback</em> variables.<br /><br />
</p>
<p>A qualitative graphical example of an ordered incidence matrix is given in the following figure. The white areas are all 0's, the gray areas contain 0's and 1's. The 1's in the light gray areas refer to variables already evaluated in previous blocks, therefore they are known terms within the block. The 1's in the dark gray areas refer to variables evaluated within the block.<br /><br />
<img src="../help/figures/Reordering.png" alt="Reordering.png" />
</p>
<p>The final pattern of an incidence matrix after the equation reordering generally features three blocks: <br /><br />
1. a recursive block (the pre-recursive block);<br />
2. a simultaneous block;<br />
3. another recursive block (the post-recursive block);<br /><br />
As said, the pre-recursive and the post-recursive blocks are lower triangular. Therefore the corresponding equations are solvable with a cascade substitution with no iteration. Just the simultaneous equations set needs an iterative algorithm to be solved. It is important to say that the convergence criterion may also be applied to these variables only: when the feedback variables converge, the rest of the simultaneous variables also do.<br /><br /> BIMETS builds and analyzes the model's incidence matrix, and then it orders the equations in pre-recursive, post-recursive and simultaneous blocks. The simultaneous block is then analyzed in order to find a minimal set of feedback variables. This last problem is known to be NP-complete (Ref: Garey, Johnson - <em>Computers and Intractability: a Guide to the Theory of NP-completeness</em> - San Francisco, Freeman 1979).<br /><br />
The optimal reordering of the model equations is programmatically achieved through the use of an iterative algorithm applied to the incidence matrix that can produce 4 ordered lists of endogenous variables:<br /><br />
1. <code>vpre</code> is the ordered list containing the names of the endogenous pre-recursive variables to be sequentially computed (once per simulation period, by using their <code>EQ&gt;</code> definition in the <code>MDL</code>) before the simulation iterative algorithm takes place;<br />
2. <code>vsim</code> (the simultaneous block) is the ordered list containing the names of the endogenous variables to be sequentially computed during each iteration of the simulation iterative algorithm; <br />
3. <code>vfeed</code> is the list containing the names of the endogenous feedback variables; generally <code>vfeed</code> are the last variables of the ordered <code>vsim</code> list; <br />
4. <code>vpost</code> is the ordered list containing the names of the endogenous post-recursive variables to be sequentially computed (once per simulation period, by using their <code>EQ&gt;</code> definition in the <code>MDL</code>) after the simulation iterative algorithm has found a solution in the simultaenous block;<br /><br />
If equations are reordered, the previous conceptual scheme is modified as follows:<br /><br />
- initialize the solution for the current simulation period;<br />
- compute the pre-recursive equations (i.e. the equation of the endogenous variables in the <code>vpre</code> ordered list);<br />
- iteratively compute the system of simultaneous equations (i.e. the equation of the endogenous variables in the <code>vsim</code> ordered list); for each iteration update the values of the current endogenous variables and verify that the convergence criterion is satisfied on the feedback variables <code>vfeed</code> or that the maximum number of iterations has been reached;<br />
- compute the post-recursive equations (i.e. the equation of the endogenous variables in the <code>vpost</code> ordered list);<br />
- save the solutions;<br /><br />
</p>

<table>
<tr>
 <td style="text-align: center;">THE SIMULATION ALGORITHMS</td>
</tr>

</table>

<p>Given <code class="reqn">x_{j}</code> the <code class="reqn">j</code>-exogenous variable, <code class="reqn">j=1..m</code>, and <code class="reqn">y_{i,k}</code>  the <code class="reqn">i</code>-endogenous variable in the simultaneous block, at the iteration <code class="reqn">k</code>, with <code class="reqn">i=1..n</code> the position of the equation in a reordered model, the modified Gauss-Seidel method takes for the approximation of the endogenous variable <code class="reqn">y_{i,k}</code> the solution of the following:<br /><br />
<code class="reqn">y_{i,k}=f_i(x_1, ..., x_m, y_{1,k}, ..., y_{i-1,k}, y_{i,k-1},..., y_{n,k-1})</code><br /><br />
Newton-Raphson's methods can be seen as an extension of the modified Gauss-Seidel algorithm, and a further step is required: in Newton-Raphson, feedback variables are updated not by using their model equations, but by using the inverse of the Jacobian matrix and the following assignment:<br /><br />
<code class="reqn">\bar{y}^F_{k} \leftarrow \bar{y}^F_{k-1}+(I-J)^{-1}[\bar{y}^F_{k}-\bar{y}^F_{k-1}]</code><br /><br />
given the vector of feedback variables values  <code class="reqn">\bar{y}^F_{k}=[y_{n-F+1,k},...,y_{n,k}]</code> at iteration <code class="reqn">k</code>, the identity matrix <code class="reqn">I</code>, and the Jacobian matrix <code class="reqn">J</code>, with <code class="reqn">I,J \in R^{F,F}</code> and <code class="reqn">F</code> equal to the number of feedback variables for the given model. Please note that the modified Gauss-Seidel algorithm can be seen as a reduced form of a Netwotn algorithm, given <code class="reqn">J=0</code>.<br /><br /> In Newton-Raphson methods, the Jacobian matrix <code class="reqn">J</code> is calculated as follows:<br />
1 - shock the feedback variables one at a time by a small amount;<br />
2 - for each shocked feedback variable, evaluate the shocked solution of the simultaneous block;<br />
3 - calculate the derivatives (i.e. the column in the Jacobian matrix related to the shocked feedback variable) using the difference quotients between the shocked and the base solution of the simultaneous block.
<br /><br />
As said, the convergence is always tested at each iteration's end on the feedback variables.<br /><br />
Newton-Raphson methods on a reordered model require the calculation of the Jacobian matrix on the feedback endogenous variables, i.e. at least <code class="reqn">F+2</code> iterations per simulation period, with <code class="reqn">F</code> as the number of feedback variables. For large models (i.e. more than 30 feedback variables) if the overall required convergence is greater than <code class="reqn">10^{-6} \%</code> the speedup over the Gauss-Seidel method is small or negative, if the Jacobian matrix is recalculated at each iteration. Moreover, the Gauss-Seidel method does not require a matrix inversion; therefore, it is more robust against algebraical and numerical issues. For small models, both methods are fast on modern computers. On the other hand, Gausse-Seidel fails to find a convergence for a small set of econometric models, even when a convergence exists. In general, given a system of equations <code class="reqn">Ax=b</code>, with <code class="reqn">x,b \in R^n, n&gt;0</code> and <code class="reqn">A \in R^{n, n}</code>, the Gauss-Seidel algorithm is known to converge if either:<br />
- <code class="reqn">A</code> is symmetric positive-definite;<br />
- <code class="reqn">A</code> is strictly or irreducibly diagonally dominant. <br /><br />
To improve simulation speed, BIMETS evaluates the Newton-Raphson algorithm performance during simulation, and, at each iteration, a new Jacobian matrix is calculated <em>only if</em> the convergence speed is slower than a predefined threshold. In a vectorized simulation (e.g., <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>,  <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code>,  <code><a href="#topic+RENORM">RENORM</a></code>), if <code>simAlgo="NEWTON"</code> the Jacobian matrix is calculated only on the unperturbed model, then applied to all realizations; if <code>simAlgo="FULLNEWTON"</code> a new Jacobian matrix is calculated for each realization.<br /><br /> The simulation of a non-trivial model, if computed by using the same data but on different hardware, software or numerical libraries, produces numerical differences. Therefore a convergence criterion smaller than <code class="reqn">10^{-7} \%</code> frequently leads to a local solution.<br /><br /> See <em>Numerical methods for simulation and optimal control of large-scale macroeconomic models - Gabay, Nepomiastchy, Rachidi, Ravelli - 1980</em> for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SIMULATE( model=NULL,
          simAlgo='GAUSS-SEIDEL',
          TSRANGE=NULL,
          simType='DYNAMIC',
          simConvergence=0.01,
          simIterLimit=100,
          ZeroErrorAC=FALSE,
          BackFill=0,
          Exogenize=NULL,
          ConstantAdjustment=NULL,
          verbose=FALSE,
          verboseSincePeriod=0,
          verboseVars=NULL,
          MULTMATRIX=FALSE,
          RENORM=FALSE,
          TARGET=NULL,
          INSTRUMENT=NULL,
          MM_SHOCK=0.00001,
          STOCHSIMULATE=FALSE,
          StochStructure=NULL,
          StochReplica=100,
          StochSeed=NULL,
          OPTIMIZE=FALSE,
          OptimizeBounds=NULL,
          OptimizeRestrictions=NULL,
          OptimizeFunctions=NULL,
          quietly=FALSE,
          RESCHECKeqList=NULL,
          JACOBIAN_SHOCK=1e-4,
          JacobianDrop=NULL,
          avoidCompliance=FALSE,
          ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SIMULATE_+3A_model">model</code></td>
<td>

<p>The BIMETS model object to be simulated. The simulation requires that all the model behaviorals, if any, have been previously estimated: all the behavioral coefficients (i.e. the regression coefficients and the autoregression coefficients for the errors, if any) must be numerically defined in the model object. (see also <code><a href="#topic+ESTIMATE">ESTIMATE</a></code>)
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_simalgo">simAlgo</code></td>
<td>

<p>The simulation algorithm to be used to solve the system of model equations for each time period in the simulation <code>TSRANGE</code>.<br />
The options are:<br />
<b>GAUSS-SEIDEL</b>: (default) the Gauss-Seidel algorithm is simple, robust, and works well for many backward-looking macro-econometric models. Equations are evaluated as-is in a proper order until the convergence, if any, is verified on feedback variables (see <em>THE SIMULATION ALGORITHMS</em> section up here). It is slower than Newton-Raphson algorithms for a very low convergence criterion, and fails to find a convergence for a small set of econometric models, even when a convergence exists. In general, given a system of equations <code class="reqn">Ax=b</code>, with <code class="reqn">x,b \in R^n, n&gt;0</code> and <code class="reqn">A \in R^{n, n}</code>, the Gauss-Seidel algorithm is known to converge if either:<br />
- <code class="reqn">A</code> is symmetric positive-definite;<br />
- <code class="reqn">A</code> is strictly or irreducibly diagonally dominant. <br />
<b>NEWTON</b>: the Newton-Raphson algorithm allows users to solve a broader set of macro-econometric models than the Gauss-Seidel algorithm. Moreover, it is faster than the Gauss-Seidel algorithm in most cases (on modern computers, users must simulate an extensive econometric model with a low convergence criterion to appreciate the speedup). This type of algorithm requires the construction and the inversion of the Jacobian matrix for the feedback variables; thus, in some scenarios (e.g., equations with unverified <code>IF&gt;</code> condition, implicit exogenizations, etc.), numerical issues can arise, and users are required to manually exclude some feedback variables from the Jacobian matrix by using the <code>JacobianDrop</code> argument.  To improve simulation speed, BIMETS evaluates the Newton-Raphson algorithm performance during simulation, and, at each iteration, a new Jacobian matrix is calculated <em>only if</em> the convergence speed is slower than a predefined threshold. In a vectorized simulation (e.g., <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>,  <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code>,  <code><a href="#topic+RENORM">RENORM</a></code>), if <code>simAlgo="NEWTON"</code> the Jacobian matrix is calculated only on the unperturbed model, then applied to all realizations; if <code>simAlgo="FULLNEWTON"</code> a new Jacobian matrix is calculated for each realization.. As in the Gauss-Seidel algorithm, the convergence is evaluated on feedback variables<br />
<b>FULLNEWTON</b>: similar to the &quot;base&quot; Newton case, but when using this option, a different Jacobian matrix is calculated for each stochastic realization in a vectorized simulation (e.g., <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code>,  <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code>,  <code><a href="#topic+RENORM">RENORM</a></code>). The collection of all the Jacobian matrices is referred to as the 3-dimensional &quot;Jacobian array&quot;. Generally, a &quot;full&quot; Newton simulation requires more computational time, mainly due to the increased number of Jacobian matrices to be calculated. However, the &quot;base&quot; Newton algorithm fails to converge when the model is highly non-linear and perturbances are significant (see examples in <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> help page). Therefore, a  &quot;full&quot; Newton algorithm is required in these cases. <br />
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_tsrange">TSRANGE</code></td>
<td>

<p>The time range of the simulation, as a four dimensional numerical array, <br /> i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code> 
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_simtype">simType</code></td>
<td>

<p>The simulation type requested:<br />
<b>DYNAMIC</b>: the default, whenever lagged endogenous variables are needed in the computations, the simulated values of the endogenous variables evaluated in the previous time periods are used;<br />
<b>STATIC</b>: rather than the simulated values, the actual historical values are used whenever lagged endogenous variables are needed in the computations;<br />
<b>FORECAST</b>: similar to the <code>'DYNAMIC'</code> option, but the initial solutions for the iterative process are given by the simulated values of the endogenous variables in the previous period. In this case there is no need for historical values of the endogenous variables in whole provided <code>TSRANGE</code>;<br />
<b>RESCHECK</b>: in this case there is no iteration to carry out. The endogenous variables are evaluated for each single time period by using the historical values for all the variables on the right-hand side of the equation, both lagged and current period;
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_simconvergence">simConvergence</code></td>
<td>

<p>The percentage convergence value requested for the iterative process, which stops when the percentage difference of all the feedback variables between iterations is less than <code>simConvergence</code> in absolute value
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_simiterlimit">simIterLimit</code></td>
<td>

<p>The value representing the maximum number of iterations to be performed. The iterative procedure will stop when <code>simIterLimit</code> is reached or the feedback variables satisfy the <code>simConvergence</code> criterion
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_zeroerrorac">ZeroErrorAC</code></td>
<td>

<p>If <code>TRUE</code> it zeroes out all the autoregressive terms, if any, in the behavioral equations
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_backfill">BackFill</code></td>
<td>

<p>Defined as an <code>integer</code>, it is the length of historical data prior to the simulation <code>TSRANGE</code> to be saved along with the solutions
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_exogenize">Exogenize</code></td>
<td>

<p>A named list that specifies the endogenous variables to be exogenized. During the simulation and inside the provided time range, the exogenized endogenous variables will be assigned to their historical values. List names must be the names of the endogenous variables to be exogenized; each element of this list contains the time range of the exogenization for the related endogenous variable, in the form of a 4-dimensional integer array, i.e. start_year, start_period, end_year, end_period. A list element can also be assigned <code>TRUE</code>: in this case the related endogenous variable will be exogenized in whole simulation <code>TSRANGE</code> (see example)
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_constantadjustment">ConstantAdjustment</code></td>
<td>

<p>A named list that specifies the constant adjustments (i.e. add factors) to be added to the selected equations of the model. Each constant adjustment can be see as a new exogenous variable added to the equation of the specified endogenous variable. The list names are the names of the involved endogenous variables; each element of this is list contains the time series to be added to the equation of the related endogenous variable. Each provided time series must verify the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code> (see example)
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code> some verbose output will be activated. Moreover the values of all endogenous variables will be printed out during each iteration of the convergence algorithm for all time periods in the simulation <code>TSRANGE</code>
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_verbosesinceperiod">verboseSincePeriod</code></td>
<td>

<p>An integer that activates the verbose output, during the iterative process, only after the provided number of simulation periods
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_verbosevars">verboseVars</code></td>
<td>

<p>A <code>character</code> array with the names of the endogenous variables for which the verbose output will be activated in the iterative process
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_multmatrix">MULTMATRIX</code></td>
<td>
<p>It is <code>TRUE</code> when the parent call is a multiplier matrix operation requested by a <code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code> procedure</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_renorm">RENORM</code></td>
<td>
<p>It is <code>TRUE</code> when the parent call is an endogenous targeting operation requested by a <code><a href="#topic+RENORM">RENORM</a></code> procedure</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_target">TARGET</code></td>
<td>
<p>see <code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code></p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_instrument">INSTRUMENT</code></td>
<td>
<p>see <code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code></p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_mm_shock">MM_SHOCK</code></td>
<td>
<p>see <code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code></p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_stochsimulate">STOCHSIMULATE</code></td>
<td>
<p>It is <code>TRUE</code> when the parent call is a stochastic simulation requested by a <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> operation</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_stochstructure">StochStructure</code></td>
<td>
<p>The <code>list()</code> that defines the disturbance structure applied to the model. See <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code></p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_stochreplica">StochReplica</code></td>
<td>
<p>An integer value that sets the number of stochastic simulation replications to be performed. See <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code></p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_stochseed">StochSeed</code></td>
<td>
<p>A number used to initialize the pseudo-random number generator. It can be useful in order to replicate stochastic results. See <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code></p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_optimize">OPTIMIZE</code></td>
<td>
<p>It is <code>TRUE</code> when the parent call is an optimize operation requested by a  procedure</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_optimizebounds">OptimizeBounds</code></td>
<td>
<p>see <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code></p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_optimizerestrictions">OptimizeRestrictions</code></td>
<td>
<p>see <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code></p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_optimizefunctions">OptimizeFunctions</code></td>
<td>
<p>see <code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code></p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_quietly">quietly</code></td>
<td>
<p> If <code>TRUE</code>, information messages will be suppressed, e.g. an information message will be printed out if any time series has a missing value in the extended <code>TSRANGE</code>, that is the simulation <code>TSRANGE</code> backward extended by <code>model$max_lag</code> periods (See <code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code> for info on model max lag)
</p>
</td></tr> 
<tr><td><code id="SIMULATE_+3A_rescheckeqlist">RESCHECKeqList</code></td>
<td>
<p> If <code>simType=RESCHECK</code>, by using this argument users can select a subset of target endogenous variables: the simulation will be performed only for the selected variables. It must be provided as an array of endogenous names, e.g. <code>c('endo1','endo2',...)</code>
</p>
</td></tr> 
<tr><td><code id="SIMULATE_+3A_jacobian_shock">JACOBIAN_SHOCK</code></td>
<td>

<p>The value of the shock added to feedback variables in the derivative calculation of the Jacobian matrix. The default value is <code>1e-4</code> times the value of the feedback variable
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_jacobiandrop">JacobianDrop</code></td>
<td>

<p>The array built with feedback variables names to be excluded from the Jacobian matrix calulation
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of model time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="SIMULATE_+3A_...">...</code></td>
<td>

<p>Backward compatibility
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will add a new element named <code>simulation</code> into the output BIMETS model object.<br /><br />
The new <code>simulation</code> element is a named list; the names of the <code>simulation</code> list are the names of the endogenous variables of the model; each element of the <code>simulation</code> list contains the simulated time series of the related endogenous variable (see example). <br /><br /> The <code>simulation</code> list also contains the <code>'__SIM_PARAMETERS__'</code> element that contains the arguments passed to the function call during the latest <code>SIMULATE</code> run, e.g. <code>TSRANGE</code>, <code>symType</code>, <code>simConvergence</code>, <code>symIterLimit</code>, <code>Exogenize</code>, etc.: this data can be helpful in order to replicate the simulation results. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MDL">MDL</a></code><br />
<code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
<code><a href="#topic+ESTIMATE">ESTIMATE</a></code><br />
<code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code><br />
<code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code><br />
<code><a href="#topic+RENORM">RENORM</a></code><br />
<code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#define model
myModelDefinition&lt;-
"MODEL 
COMMENT&gt; Klein Model 1 of the U.S. Economy 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1921 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END"

#define model data
myModelData&lt;-list(
   cn
   =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
               45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
               START=c(1920,1),FREQ=1),
   g
   =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
               10.5,10.3,11,13,14.4,15.4,22.3,
               START=c(1920,1),FREQ=1),
   i
   =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
               2.1,2,-1.9,1.3,3.3,4.9,
               START=c(1920,1),FREQ=1),
   k
   =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
               216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
               201.2,204.5,209.4,
               START=c(1920,1),FREQ=1),
   p
   =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
               7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
               START=c(1920,1),FREQ=1),
   w1
   =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
               29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
               START=c(1920,1),FREQ=1),
   y
   =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
               45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
               START=c(1920,1),FREQ=1),
   t
   =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
               8.3,6.7,7.4,8.9,9.6,11.6,
               START=c(1920,1),FREQ=1),
   time 
   =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
               START=c(1920,1),FREQ=1),
   w2
   =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
               7.4,6.7,7.7,7.8,8,8.5,
               START=c(1920,1),FREQ=1)
 )
 
#load model and model data
myModel&lt;-LOAD_MODEL(modelText=myModelDefinition)
myModel&lt;-LOAD_MODEL_DATA(myModel,myModelData)

#estimate model
myModel&lt;-ESTIMATE(myModel, quietly = TRUE)
 
#DYNAMIC SIMULATION
 
#simulate model 
myModel&lt;-SIMULATE(myModel
                 ,TSRANGE=c(1923,1,1941,1)
                 ,simConvergence=0.00001
                 ,simIterLimit=100
  )
#
#Simulation:    100.00%
#...SIMULATE OK
 
#get simulated time series "cn" and "y"
TABIT(myModel$simulation$cn)
#
#      Date, Prd., myModel$simulation$cn
#
#      1923, 1   ,     50.338
#      1924, 1   ,    55.6994
#      1925, 1   ,    56.7111
#      ...
#      1940, 1   ,    66.7799
#      1941, 1   ,     75.451
#

TABIT(myModel$simulation$y)
#
#      Date, Prd., myModel$simulation$y
#
#      1923, 1   ,    56.0305
#      1924, 1   ,    65.8526
#      1925, 1   ,     64.265
#      ...
#      1940, 1   ,    76.8049
#      1941, 1   ,    93.4459
#
 
#get latest simulation parameters
print(myModel$simulation$'__SIM_PARAMETERS__')
#$TSRANGE
#[1] 1923    1 1941    1
#
#$simType
#[1] "DYNAMIC"
#
#$simConvergence
#[1] 1e-05
#
#$simIterLimit
#[1] 100
#
#$ZeroErrorAC
#[1] FALSE
#
#...etc etc
 
 
########################################################
#RESCHECK SIMULATION
 
#simulate model
myModel&lt;-SIMULATE(myModel
                  ,simType='RESCHECK'
                  ,TSRANGE=c(1923,1,1941,1)
                  ,simConvergence=0.00001
                  ,simIterLimit=100
 )
#
#Simulation:    100.00%
#...SIMULATE OK
 
#get consumption simulated vs historical differences
TABIT(myModel$simulation$cn-myModel$modelData$cn)
#
#      Date, Prd., myModel$simulation$cn - myModel$modelData$cn
#
#      1923, 1   ,    1.56574
#      1924, 1   ,   0.493503
#      1925, 1   , -0.0076079
#      ... 
#      1939, 1   ,  -0.989201
#      1940, 1   ,  -0.785077
#      1941, 1   ,    2.17345
#
 
########################################################
#FORECAST GNP in 1942 and 1943 
 
#we need to extend exogenous variables in 1942 and 1943
myModel$modelData$w2   &lt;- TSEXTEND(myModel$modelData$w2,  UPTO=c(1943,1))
myModel$modelData$t    &lt;- TSEXTEND(myModel$modelData$t,   UPTO=c(1943,1))
myModel$modelData$g    &lt;- TSEXTEND(myModel$modelData$g,   UPTO=c(1943,1))
myModel$modelData$time &lt;- TSEXTEND(myModel$modelData$time,UPTO=c(1943,1)
                                     ,EXTMODE='LINEAR')
 
#simulate model
myModel&lt;-SIMULATE(myModel
                  ,simType='FORECAST'
                  ,TSRANGE=c(1940,1,1943,1)
                  ,simConvergence=0.00001
                  ,simIterLimit=100
)
#
#Simulation:    100.00%
#...SIMULATE OK
 
#get forecasted GNP
TABIT(myModel$simulation$y)
#
#      Date, Prd., myModel$simulation$y
#
#      1940, 1   ,    74.5781
#      1941, 1   ,    94.0153
#      1942, 1   ,    133.969
#      1943, 1   ,    199.913
#

########################################################
#VERBOSE SIMULATION
 
myModel&lt;-SIMULATE(myModel
                  ,TSRANGE=c(1923,1,1941,1)
                  ,simConvergence=0.00001
                  ,simIterLimit=100
                  ,verbose=TRUE
                  ,verboseSincePeriod=19
                  ,verboseVars=c('cn')
 )


########################################################
#DYNAMIC NEWTON SIMULATION 
#WITH EXOGENIZATION AND CONSTANT ADJUSTMENTS
 
#define exogenization list
#'cn' exogenized in 1923-1925
#'i' exogenized in whole TSRANGE
exogenizeList&lt;-list(
                cn = c(1923,1,1925,1),
                i  = TRUE
)
 
#define add factor list
constantAdjList&lt;-list(
               cn = TIMESERIES(1,-1,START=c(1923,1),FREQ='A'),
               y  = TIMESERIES(0.1,-0.1,-0.5,START=c(1926,1),FREQ='A')
)
 
#simulate model
myModel&lt;-SIMULATE(myModel
                  ,simAlgo='NEWTON'
                  ,simType='DYNAMIC'
                  ,TSRANGE=c(1923,1,1941,1)
                  ,simConvergence=0.00001
                  ,simIterLimit=100
                  ,Exogenize=exogenizeList
                  ,ConstantAdjustment=constantAdjList 
 )
#SIMULATE(): endogenous variable "cn" has been exogenized from (trunc) ...
#SIMULATE(): endogenous variable "i" has been exogenized from (trunc) ...
#SIMULATE(): endogenous variable "cn" has a constant adjustment from (trunc) ...
#SIMULATE(): endogenous variable "y" has a constant adjustment from (trunc) ...
#
#Simulation:    100.00%
#...SIMULATE OK

########################################################
#EXAMPLE OF MODEL THAT FAILS GAUSS CONVERGENCE

#define model
myNewtonModelDefinition&lt;-
"
MODEL 
 
COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1922 1 1931 1
EQ&gt; cn =  a1 + a2*p + a3*LAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4 

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1922 1 1931 1
EQ&gt; i = b1 + b2*p + b3*LAG(p,1) + b4*LAG(k,1)
COEFF&gt; b1 b2 b3 b4 

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1922 1 1931 1
EQ&gt; w1 = c1 + c2*(z+y+t-w2) + c3*LAG(z+y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4 

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t 

COMMENT&gt; Simple copy of y in z
IDENTITY&gt; z
EQ&gt; z = cn + i + g - t 

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = z + y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = LAG(k,1) + i

END
"

#add data to model
myModelData$z &lt;- myModelData$y
myNewtonModel&lt;-LOAD_MODEL(modelText=myNewtonModelDefinition)
myNewtonModel&lt;-LOAD_MODEL_DATA(myNewtonModel,myModelData)

#estimate model
myNewtonModel&lt;-ESTIMATE(myNewtonModel, quietly = TRUE)

#GAUSS simulation fails to converge...
myNewtonModel &lt;- SIMULATE(myNewtonModel,
                       TSRANGE = c(1921, 1, 1930, 1),
                       simConvergence = 1e-7)
                       
#...while NEWTON converges
myNewtonModel &lt;- SIMULATE(myNewtonModel,
                       simAlgo='NEWTON',
                       TSRANGE = c(1921, 1, 1930, 1),
                       simConvergence = 1e-7)
                       
########################################################
#EXAMPLE OF MODEL THAT REQUIRES 
#A VARIABLE EXCLUSION FROM JACOBIAN MATRIX

#define model
myNewtonWithDropModelDefinition&lt;-
"
MODEL 
 
COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1922 1 1931 1
EQ&gt; cn =  a1 + a2*p + a3*LAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4 

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1922 1 1931 1
EQ&gt; i = b1 + b2*p + b3*LAG(p,1) + b4*LAG(k,1)
COEFF&gt; b1 b2 b3 b4 

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1922 1 1931 1
EQ&gt; w1 = c1 + c2*(z+y+t-w2) + c3*LAG(z+y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4 

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t 

COMMENT&gt; Simple copy of y in z
IDENTITY&gt; z
EQ&gt; z = cn + i + g - t 

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = z + y - (w1+w2)
IF&gt; y &lt; 0

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = LAG(k,1) + i

END
"

#add data to model
myModelData$z &lt;- myModelData$y
myNewtonModel &lt;- LOAD_MODEL(modelText=myNewtonWithDropModelDefinition)
myNewtonModel &lt;- LOAD_MODEL_DATA(myNewtonModel,myModelData)

#estimate model
myNewtonModel &lt;- ESTIMATE(myNewtonModel, quietly = TRUE)

#"p" variable must be removed from Jacobian because of unverified IF&gt;
myNewtonModel &lt;- SIMULATE(myNewtonModel,
                       simAlgo='NEWTON',
                       JacobianDrop='p',
                       TSRANGE = c(1921, 1, 1930, 1),
                       simConvergence = 1e-7)
    

########################################################
#COMPARE FORECAST IN 3 ALTERNATIVE 
#EXOGENOUS SCENARIOS

#define model
myModelDefinition &lt;-
"MODEL 
COMMENT&gt; Klein Model 1 of the U.S. Economy 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1921 1 1941 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1921 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1921 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i

END"

#define model data
myModelData&lt;-list(
  cn
  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
              45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
              START=c(1920,1),FREQ=1),
  g
  =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
              10.5,10.3,11,13,14.4,15.4,22.3,
              START=c(1920,1),FREQ=1),
  i
  =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
              2.1,2,-1.9,1.3,3.3,4.9,
              START=c(1920,1),FREQ=1),
  k
  =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
              216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
              201.2,204.5,209.4,
              START=c(1920,1),FREQ=1),
  p
  =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
              7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
              START=c(1920,1),FREQ=1),
  w1
  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
              29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
              START=c(1920,1),FREQ=1),
  y
  =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
              45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
              START=c(1920,1),FREQ=1),
  t
  =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
              8.3,6.7,7.4,8.9,9.6,11.6,
              START=c(1920,1),FREQ=1),
  time 
  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
              START=c(1920,1),FREQ=1),
  w2
  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
              7.4,6.7,7.7,7.8,8,8.5,
              START=c(1920,1),FREQ=1)
)

#load model and model data
myModel &lt;- LOAD_MODEL(modelText=myModelDefinition)
myModel &lt;- LOAD_MODEL_DATA(myModel,myModelData)

#estimate model
myModel &lt;- ESTIMATE(myModel, quietly = TRUE)

#create 3 new models for the 3 scenarios
modelScenario1 &lt;- myModel
modelScenario2 &lt;- myModel
modelScenario3 &lt;- myModel

#scenario 1, define exogenous paths
modelScenario1$modelData &lt;- within(modelScenario1$modelData,{
              w2   = TSEXTEND(w2,  UPTO=c(1943,1))
              t    = TSEXTEND(t,   UPTO=c(1943,1))
              g    = TSEXTEND(g,   UPTO=c(1943,1))
              time = TSEXTEND(time,UPTO=c(1943,1)
                                  ,EXTMODE='LINEAR')
})

#scenario 2, define exogenous paths
modelScenario2$modelData &lt;- within(modelScenario2$modelData,{
              w2   = TSEXTEND(w2,  UPTO=c(1943,1))
              t    = TSEXTEND(t,   UPTO=c(1943,1))
              g    = TSEXTEND(g,   UPTO=c(1943,1)
                            ,EXTMODE='LINEAR')
              time = TSEXTEND(time,UPTO=c(1943,1)
                            ,EXTMODE='LINEAR')
})

#scenario 3, define exogenous paths
#we also change consumption cn add-factor
modelScenario3$modelData &lt;- within(modelScenario3$modelData,{
              w2   = TSEXTEND(w2,  UPTO=c(1943,1)
                              ,EXTMODE='MEAN4')
              t    = TSEXTEND(t,   UPTO=c(1943,1))
              g    = TSEXTEND(g,   UPTO=c(1943,1)
                              ,EXTMODE='LINEAR')
              time = TSEXTEND(time,UPTO=c(1943,1)
                              ,EXTMODE='LINEAR')
})
constantAdjListScenario3 &lt;- constantAdjList
constantAdjListScenario3$cn[[1941,1]] &lt;- c(1,2,3)

#simulate the 3 models
modelScenario1 &lt;- SIMULATE(modelScenario1
                            ,simAlgo='NEWTON'
                            ,simType='FORECAST'
                            ,TSRANGE=c(1940,1,1943,1)
                            ,simConvergence=1e-5
                            ,simIterLimit=20)

modelScenario2 &lt;- SIMULATE(modelScenario2
                            ,simAlgo='NEWTON'
                            ,simType='FORECAST'
                            ,TSRANGE=c(1940,1,1943,1)
                            ,simConvergence=1e-5
                            ,simIterLimit=20)

modelScenario3 &lt;- SIMULATE(modelScenario3
                            ,simAlgo='NEWTON'
                            ,simType='FORECAST'
                            ,TSRANGE=c(1940,1,1943,1)
                            ,simConvergence=1e-5
                            ,simIterLimit=20
                            ,ConstantAdjustment = constantAdjListScenario3
                            )

#compare results on GNP
TABIT(modelScenario1$simulation$y, 
      modelScenario2$simulation$y, 
      modelScenario3$simulation$y)

</code></pre>

<hr>
<h2 id='STOCHSIMULATE'>
Stochastic simulation of a BIMETS model
</h2><span id='topic+STOCHSIMULATE'></span>

<h3>Description</h3>

<p>The <code>STOCHSIMULATE</code> operation performs a stochastic simulation. The simulation algorithms are the same as those used by the <code><a href="#topic+SIMULATE">SIMULATE</a></code> operation. 
<br /><br />
Forecasts produced by structural econometric models are subject to several sources of error, such as random disturbance term of each stochastic equation, errors in estimated coefficients, errors in forecasts of exogenous variables, errors in preliminary data and mis-specification of the model.<br /><br />
The forecast error depending on the structural disturbances can be analyzed by using the stochastic simulation procedure.<br /><br />
The deterministic simulation is the simultaneous solution of an econometric model obtained by applying, for each stochastic (behavioral) equation, the expected values of the structural disturbances, which are all zero by assumption. In the BIMETS <code><a href="#topic+STOCHSIMULATE">STOCHSIMULATE</a></code> stochastic simulation, the structural disturbances are given values that have specified stochastic properties. The error terms of the estimated behavioral equation of the model are appropriately perturbed. Identity equations and exogenous variables can be as well perturbed by disturbances that have specified stochastic properties. The model is then solved for each data set with different values of the disturbances. Finally, mean and standard deviation are computed for each simulated endogenous variable. <br /><br />
In terms of computational efficiency, the procedure takes advantage of the fact that multiple datasets are bound together in matrices. Therefore, to achieve a global convergence, the iterative simulation algorithm is executed once for all perturbed datasets. This solution can be viewed as a sort of a SIMD (i.e. Single Instruction Multiple Data) parallel simulation: the <code>STOCHSIMULATE</code> function transforms time series into matrices and consequently can easily bind multiple datasets by column. At the same time, a single run ensures a fast code execution. Finally, each column in the output matrices represents a stochastic realization.<br /><br />
By using the <code>StochStructure</code> argument of this function, users can define a stochastic structure for the disturbances. For each variable of the model, users can provide a distinct probability distribution for the disturbance, and a specific time range of application. Mean and standard deviation for each simulated endogenous time series will be stored in the <code>stochastic_simulation</code> element of the output model object; all the stochastic realizations will be stored in the <code>simulation_MM</code> element of the output model object as named matrices.
</p>
<p>In the following figure, the advanced Klein model (see code example), has been perturbed during the forecast operation by applying a normal disturbance to the endogenous <em>Consumption</em> behavioral <code>cn</code> add-factor in year 1942, and a uniform disturbance to the exogenous <em>Government Expenditure</em> time series <code>g</code> along all the simulation <code>TSRANGE</code>. The normal disturbance applied to the <code>cn</code> behavioral has a zero mean and a standard deviation equal to the behavioral regression standard error,<br /> i.e. <code>advancedKleinModel$behaviorals$cn$statistics$StandardErrorRegression</code>, thus roughly replicating the <code><a href="#topic+ESTIMATE">ESTIMATE</a></code> regression error during the current perturbation (not accounting for inter-equations cross-covariance).<br /> <br /> 
<img src="../help/figures/StochKleinGNP.png" alt="StochKleinGNP.png" /> <br /> <br />
</p>
<p>At the moment, all the disturbances are i.i.d. and are not transformed into a congruent autoregressive scheme in the case the related perturbed endogenous behavioral presents an autocorrelation for the errors in its <code><a href="#topic+MDL">MDL</a></code> definition, e.g. <code>ERROR&gt; AUTO(n)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STOCHSIMULATE(model=NULL,
              simAlgo='GAUSS-SEIDEL',
              TSRANGE=NULL,
              simType='DYNAMIC',
              simConvergence=0.01,
              simIterLimit=100,
              ZeroErrorAC=FALSE,
              Exogenize=NULL,
              ConstantAdjustment=NULL,
              verbose=FALSE,
              verboseSincePeriod=0,
              verboseVars=NULL,
              StochStructure=NULL,
              StochReplica=100,
              StochSeed=NULL,
              quietly=FALSE,
              RESCHECKeqList=NULL,
              JACOBIAN_SHOCK=1e-4,
              JacobianDrop=NULL,
              avoidCompliance=FALSE,
              ...)		   

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STOCHSIMULATE_+3A_model">model</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_simalgo">simAlgo</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_tsrange">TSRANGE</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_simtype">simType</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_simconvergence">simConvergence</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_simiterlimit">simIterLimit</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_zeroerrorac">ZeroErrorAC</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_exogenize">Exogenize</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_constantadjustment">ConstantAdjustment</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_verbose">verbose</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_verbosesinceperiod">verboseSincePeriod</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_verbosevars">verboseVars</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_stochstructure">StochStructure</code></td>
<td>
<p>the named <code>list()</code> that defines the disturbance structure applied to the model. Each list element must have a name equal to an endogenous or an exogenous model variable. List names define the <code>INSTRUMENT</code>.<br /> <br /> 
If a list element name is equal to an exogenous variable, the disturbance will be applied to the related exogenous time series values. If a list element name is equal to an endogenous variable, the disturbance will be applied to the constant adjustment time series (see <code><a href="#topic+SIMULATE">SIMULATE</a></code>) of the related endogenous variable. <br /><br />
Each list element must be a named list built with the following three element: <br /> <br /> 
- <code>TSRANGE</code>: the time range  wherein the disturbance is active and additive to the related model variable. The <code>TSRANGE</code> must be a 4 numerical array, i.e. <code>TSRANGE=c(start_year, start_period, end_year, end_period)</code> or <code>TSRANGE=TRUE</code> in order to apply the provided disturbance to whole <code>STOCHSIMULATE</code> <code>TSRANGE</code>. <br /> <br />  
- <code>TYPE</code>: the type of disturbance distribution. At the moment, only normal, i.e. <code>TYPE='NORM'</code>, and uniform, i.e. <code>TYPE='UNIF'</code>, disturbance distributions are allowed; <br /> <br />
- <code>PARS</code>: the parameters that shape the disturbance. <br /><br /> In the case of a <code>TYPE='NORM'</code> distribution, these parameters must contain the mean and the standard deviation of the normal distribution, i.e. <code>PARS=c(mean,sd)</code>; <br /><br />  in the case of a <code>TYPE='UNIF'</code> distribution, these parameters must contain the lower and upper bound of the uniform distribution, i.e. <code>PARS=c(min,max)</code>; <br /><br /> in the case of a <code>TYPE='MATRIX'</code>, these parameters must contain the user-built matrix of realized disturbances, i.e. <code>PARS=matrix</code>, with <code>matrix</code> as a <code>[ TSRANGE x StochReplica ]</code> matrix. User-built provided matrix data will replace model data in specified <code>TSRANGE</code> if this list element name refers to an exogenous variable; otherwise, matrix data will be added-up to the related pre-defined add-factor, if any, in case this element list name refers to an endogenous variable.<br /> <br /> 
See example in order to learn how to build a compliant stochastic structure.
</p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_stochreplica">StochReplica</code></td>
<td>
<p>an integer value that sets the number of stochastic realizations to be performed</p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_stochseed">StochSeed</code></td>
<td>
<p>a number used to initialize the pseudo-random number generator. It can be helpful in order to replicate stochastic results</p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_quietly">quietly</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_rescheckeqlist">RESCHECKeqList</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_jacobian_shock">JACOBIAN_SHOCK</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_jacobiandrop">JacobianDrop</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_avoidcompliance">avoidCompliance</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
<tr><td><code id="STOCHSIMULATE_+3A_...">...</code></td>
<td>
<p>see <code><a href="#topic+SIMULATE">SIMULATE</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will add, into the output BIMETS model object, three new named elements, respectively <code>stochastic_simulation</code>, <code>simulation_MM</code> and <code>INSTRUMENT_MM</code>.<br /><br />
The <code>stochastic_simulation</code> element is a named <code>list()</code>, having endogenous variables as names. Each element will contain two time series: the mean and the standard deviation of the related stochastic simulated endogenous time series.<br /> <br />
The arguments passed to the function call during the latest <code>STOCHSIMULATE</code> run will be inserted into the <code>'__STOCH_SIM_PARAMETERS__'</code> element of the <code>stochastic_simulation</code> list; this data can be helpful in order to replicate the stochastic simulation results.<br /><br />
The <code>simulation_MM</code> element is a named <code>list()</code>, having the endogenous variables as names. Each element will contain an <code>R x C</code> matrix, given <code>R</code> the number of observations in the simulation <code>TSRANGE</code> and <code>C=1+StochReplica</code>. The first column of each matrix contains the related endogenous variable's unperturbed simulated values; the remaining columns will contain all the <code>StochReplica</code> stochastic realizations for the related endogenous variable (see example). <br /> <br />
The <code>INSTRUMENT_MM</code> element is a named <code>list()</code>, having <code>INSTRUMENT</code> variables as names. Each element will contain an <code>R x C</code> matrix, given <code>R</code> the number of observations in the simulation <code>TSRANGE</code> and <code>C=1+StochReplica</code>. The first column of each matrix contains the related <code>INSTRUMENT</code> variable's unperturbed values; the remaining columns will contain all the <code>StochReplica</code> stochastic realizations for the related <code>INSTRUMENT</code> variable. <br /> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MDL">MDL</a></code><br />
<code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
<code><a href="#topic+ESTIMATE">ESTIMATE</a></code><br />
<code><a href="#topic+SIMULATE">SIMULATE</a></code><br />
<code><a href="#topic+RENORM">RENORM</a></code><br />
<code><a href="#topic+OPTIMIZE">OPTIMIZE</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#define the advanced Klein model
advancedKleinModelDef &lt;- "
MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL, 
COMMENT&gt; autocorrelation on errors, restrictions and 
COMMENT&gt; conditional equation evaluations

COMMENT&gt; Consumption with autocorrelation on errors
BEHAVIORAL&gt; cn
TSRANGE 1923 1 1940 1
EQ&gt; cn =  a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2) 
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment with restrictions
BEHAVIORAL&gt; i
TSRANGE 1923 1 1940 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor with PDL
BEHAVIORAL&gt; w1 
TSRANGE 1923 1 1940 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 2

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with IF switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) 
IF&gt; i &lt;= 0

END
"

#load the model
advancedKleinModel &lt;- LOAD_MODEL(modelText = advancedKleinModelDef)


#define data
kleinModelData &lt;- list(  
  cn  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,
                  55,50.9,45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7, 	
                  START=c(1920,1),FREQ=1),
  g   =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,
                  10.2,9.3,10,10.5,10.3,11,13,14.4,15.4,22.3,	
                  START=c(1920,1),FREQ=1),
  i   =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,
                  -5.1,-3,-1.3,2.1,2,-1.9,1.3,3.3,4.9,	
                  START=c(1920,1),FREQ=1),
  k   =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,
                  210.6,215.7,216.7,213.3,207.1,202,199,197.7,199.8,
                  201.8,199.9,201.2,204.5,209.4,	
                  START=c(1920,1),FREQ=1),
  p   =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,
                  15.6,11.4,7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,	
                  START=c(1920,1),FREQ=1),
  w1  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,
                  37.9,34.5,29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,	
                  START=c(1920,1),FREQ=1),
  y   =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,
                  50.7,41.3,45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,	
                  START=c(1920,1),FREQ=1),
  t   =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,
                  6.8,7.2,8.3,6.7,7.4,8.9,9.6,11.6,	
                  START=c(1920,1),FREQ=1),
  time=TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,
                  1,2,3,4,5,6,7,8,9,10,	
                  START=c(1920,1),FREQ=1),
  w2  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,
                  5.3,5.6,6,6.1,7.4,6.7,7.7,7.8,8,8.5,	
                  START=c(1920,1),FREQ=1)
);

#load time series into the model object
advancedKleinModel &lt;- LOAD_MODEL_DATA(advancedKleinModel, kleinModelData)

#estimate the model
advancedKleinModel &lt;- ESTIMATE(advancedKleinModel, quietly=TRUE)

#we want to perform a stochastic forecast of the GNP up to 1944
#we will add normal disturbances to endogenous Consumption 'cn' 
#in 1942 by using its regression standard error
#we will add uniform disturbances to exogenous Government Expenditure 'g'
#in whole TSRANGE
myStochStructure &lt;- list(
  cn=list(
        TSRANGE=c(1942,1,1942,1),
        TYPE='NORM',
        PARS=c(0,advancedKleinModel$behaviorals$cn$statistics$StandardErrorRegression)
        ),
  g=list(
        TSRANGE=TRUE,
        TYPE='UNIF',
        PARS=c(-1,1)
        )
  )

#we need to extend exogenous variables up to 1944
advancedKleinModel$modelData &lt;- within(advancedKleinModel$modelData,{
    w2    = TSEXTEND(w2,  UPTO=c(1944,1),EXTMODE='CONSTANT')
    t     = TSEXTEND(t,   UPTO=c(1944,1),EXTMODE='LINEAR')
    g     = TSEXTEND(g,   UPTO=c(1944,1),EXTMODE='CONSTANT')
    k     = TSEXTEND(k,   UPTO=c(1944,1),EXTMODE='LINEAR')
    time  = TSEXTEND(time,UPTO=c(1944,1),EXTMODE='LINEAR')
  })

#stochastic model forecast
advancedKleinModel &lt;- STOCHSIMULATE(advancedKleinModel
                      ,simType='FORECAST'
                      ,TSRANGE=c(1941,1,1944,1)
                      ,StochStructure=myStochStructure
                      ,StochSeed=123
                      )
                      
#print mean and standard deviation of forecasted GNP
with(advancedKleinModel$stochastic_simulation,TABIT(y$mean, y$sd))

#      Date, Prd., y$mean         , y$sd           
#
#      1941, 1   ,  125.5045      ,  4.250935      
#      1942, 1   ,  173.2946      ,  9.2632        
#      1943, 1   ,  185.9602      ,  11.87774      
#      1944, 1   ,  141.0807      ,  11.6973  
      
#print the unperturbed forecasted GNP along with the
#first 5 perturbed realizations
with(advancedKleinModel$simulation_MM,print(y[,1:6]))

####################################################
#EXAMPLE WITH TYPE='MATRIX'

TSRANGE &lt;- c(1935,1,1940,1)
StochReplica &lt;- 100

#we will perturb simulation by using regression residuals
#get cn and i residuals in TSRANGE
cn_residuals &lt;- TSPROJECT(advancedKleinModel$behaviorals$cn$residuals, 
                          TSRANGE=TSRANGE,
                          ARRAY = TRUE)
i_residuals &lt;- TSPROJECT(advancedKleinModel$behaviorals$i$residuals,
                         TSRANGE=TSRANGE,
                         ARRAY = TRUE)

#define stochastic matrices
cn_matrix &lt;- c()
i_matrix &lt;- c()

#populate matrices
for (idx in 1:StochReplica)
{
  rand &lt;- rnorm(1,0,1)
  cn_matrix &lt;- cbind(cn_matrix,rand*cn_residuals)
  i_matrix &lt;- cbind(i_matrix,rand*i_residuals)
}

#define stochastic structure
myStochStructure &lt;- list(
  cn=list(
    TSRANGE=TRUE,
    TYPE='MATRIX',
    PARS=cn_matrix
  ),
  i=list(
    TSRANGE=TRUE,
    TYPE='MATRIX',
    PARS=i_matrix
  )
)

#stochastic simulation
advancedKleinModel &lt;- STOCHSIMULATE(advancedKleinModel
                                    ,TSRANGE=TSRANGE
                                    ,StochStructure=myStochStructure
)

#print GNP mean and sd
with(advancedKleinModel$stochastic_simulation,TABIT(y$mean, y$sd))

#########################################################
#EXAMPLE OF MODEL THAT REQUIRES THE FULL NEWTON ALGORITHM
#see profit equation

myFullNewtonDefinition&lt;-
"MODEL 

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1922 1 1929 1
EQ&gt; cn =  a1 + a2*p + a3*LAG(p,1) + a4*(w1+w2+w3) 
COEFF&gt; a1 a2 a3 a4

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1922 1 1929 1
EQ&gt; i = b1 + b2*p + b3*LAG(p,1) + b4*LAG(k,1)
COEFF&gt; b1 b2 b3 b4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1 
TSRANGE 1922 1 1929 1
EQ&gt; w1 = c1 + c2*(z+y+t-w2) + c3*LAG(z+y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w3 
TSRANGE 1922 1 1929 1
EQ&gt; w3 = c1 + c2*(z+y+t-w2) + c3*LAG(z+y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

IDENTITY&gt; z
EQ&gt; z = cn + i + g - t

COMMENT&gt; Profits with cubic dependence on cn
IDENTITY&gt; p
EQ&gt; p = cn^3/1000 + z + y - (w1+w2+w3)

COMMENT&gt; Capital Stock
IDENTITY&gt; k
EQ&gt; k = LAG(k,1) + i

END
"


#define model data
myModelData&lt;-list(
   cn
   =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
               45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
               START=c(1920,1),FREQ=1),
   g
   =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
               10.5,10.3,11,13,14.4,15.4,22.3,
               START=c(1920,1),FREQ=1),
   i
   =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
               2.1,2,-1.9,1.3,3.3,4.9,
               START=c(1920,1),FREQ=1),
   k
   =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
               216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
               201.2,204.5,209.4,
               START=c(1920,1),FREQ=1),
   p
   =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
               7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
               START=c(1920,1),FREQ=1),
   w1
   =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
               29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
               START=c(1920,1),FREQ=1),
   y
   =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
               45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
               START=c(1920,1),FREQ=1),
   t
   =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
               8.3,6.7,7.4,8.9,9.6,11.6,
               START=c(1920,1),FREQ=1),
   time 
   =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
               START=c(1920,1),FREQ=1),
   w2
   =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
               7.4,6.7,7.7,7.8,8,8.5,
               START=c(1920,1),FREQ=1)
 )
 

#add data to model
myModelData$z &lt;- myModelData$y
myModelData$w3 &lt;- (myModelData$w1)

myFullNewtonModel &lt;- LOAD_MODEL(modelText=myFullNewtonDefinition)
myFullNewtonModel &lt;- LOAD_MODEL_DATA(myFullNewtonModel,myModelData)

myFullNewtonModel &lt;- ESTIMATE(myFullNewtonModel)
 
#simple Newton will fail, due to 
#large variance in normal disturbances                       
#...while full Newton will converge
myFullNewtonModel &lt;- STOCHSIMULATE(myFullNewtonModel,
                       simAlgo='FULLNEWTON',
                       TSRANGE = c(1921, 1, 1923, 1),
                       simConvergence = 1e-5,
                       simIterLimit = 250,
                       StochReplica = 100,
                       StochSeed=123,
                       StochStructure = list(
                         cn=list(
                           TSRANGE=TRUE,
                           TYPE='NORM',
                           PARS=c(0,20)
                         )
                       )
                       ,verbose=TRUE
                       )
					</code></pre>

<hr>
<h2 id='summary.BIMETS_MODEL'>
Print basic information about a BIMETS model
</h2><span id='topic+print.BIMETS_MODEL'></span><span id='topic+summary.BIMETS_MODEL'></span><span id='topic+summary'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>This function prints basic information about a BIMETS model, e.g. behaviorals and identities count, coefficients count, the presence of estimated coefficients or simulated time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BIMETS_MODEL'
summary(object,...)
## S3 method for class 'BIMETS_MODEL'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BIMETS_MODEL_+3A_object">object</code></td>
<td>

<p>A BIMET model. 
</p>
</td></tr>
<tr><td><code id="summary.BIMETS_MODEL_+3A_x">x</code></td>
<td>

<p>A BIMET model. 
</p>
</td></tr>
<tr><td><code id="summary.BIMETS_MODEL_+3A_...">...</code></td>
<td>
 
<p>Arguments list for the generic method.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function prints basic information about a BIMETS model, i.e.:<br /><br />
- the name of the model;<br />
- the behaviorals count;<br />
- the identities count;<br />
- the coefficients count;<br />
- the check for the compliance of the model data;<br />
- the check for the coefficients definition in all the behaviorals;<br />
- the check for the definition of a simulated time series for each related endogenous variable of the model;<br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MDL">MDL</a></code><br />
<code><a href="#topic+LOAD_MODEL">LOAD_MODEL</a></code><br />
<code><a href="#topic+SIMULATE">SIMULATE</a></code><br />
<code><a href="#topic+MULTMATRIX">MULTMATRIX</a></code><br />
<code><a href="#topic+RENORM">RENORM</a></code><br />
<code><a href="#topic+TSERIES">TIMESERIES</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#define model
myModelDefinition&lt;-
"MODEL

COMMENT&gt; Modified Klein Model 1 of the U.S. Economy with PDL,
COMMENT&gt; autocorrelation on errors, restrictions and conditional evaluations

COMMENT&gt; Consumption
BEHAVIORAL&gt; cn
TSRANGE 1925 1 1941 1
EQ&gt; cn = a1 + a2*p + a3*TSLAG(p,1) + a4*(w1+w2)
COEFF&gt; a1 a2 a3 a4
ERROR&gt; AUTO(2)

COMMENT&gt; Investment
BEHAVIORAL&gt; i
TSRANGE 1923 1 1941 1
EQ&gt; i = b1 + b2*p + b3*TSLAG(p,1) + b4*TSLAG(k,1)
COEFF&gt; b1 b2 b3 b4
RESTRICT&gt; b2 + b3 = 1

COMMENT&gt; Demand for Labor
BEHAVIORAL&gt; w1
TSRANGE 1925 1 1941 1
EQ&gt; w1 = c1 + c2*(y+t-w2) + c3*TSLAG(y+t-w2,1) + c4*time
COEFF&gt; c1 c2 c3 c4
PDL&gt; c3 1 3

COMMENT&gt; Gross National Product
IDENTITY&gt; y
EQ&gt; y = cn + i + g - t

COMMENT&gt; Profits
IDENTITY&gt; p
EQ&gt; p = y - (w1+w2)

COMMENT&gt; Capital Stock with switches
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1) + i
IF&gt; i &gt; 0
IDENTITY&gt; k
EQ&gt; k = TSLAG(k,1)
IF&gt; i &lt;= 0

END"

#define model data
myModelData&lt;-list(
  cn
  =TIMESERIES(39.8,41.9,45,49.2,50.6,52.6,55.1,56.2,57.3,57.8,55,50.9,
              45.6,46.5,48.7,51.3,57.7,58.7,57.5,61.6,65,69.7,
              START=c(1920,1),FREQ=1),
  g
  =TIMESERIES(4.6,6.6,6.1,5.7,6.6,6.5,6.6,7.6,7.9,8.1,9.4,10.7,10.2,9.3,10,
              10.5,10.3,11,13,14.4,15.4,22.3,
              START=c(1920,1),FREQ=1),
  i
  =TIMESERIES(2.7,-.2,1.9,5.2,3,5.1,5.6,4.2,3,5.1,1,-3.4,-6.2,-5.1,-3,-1.3,
              2.1,2,-1.9,1.3,3.3,4.9,
              START=c(1920,1),FREQ=1),
  k
  =TIMESERIES(182.8,182.6,184.5,189.7,192.7,197.8,203.4,207.6,210.6,215.7,
              216.7,213.3,207.1,202,199,197.7,199.8,201.8,199.9,
              201.2,204.5,209.4,
              START=c(1920,1),FREQ=1),
  p
  =TIMESERIES(12.7,12.4,16.9,18.4,19.4,20.1,19.6,19.8,21.1,21.7,15.6,11.4,
              7,11.2,12.3,14,17.6,17.3,15.3,19,21.1,23.5,
              START=c(1920,1),FREQ=1),
  w1
  =TIMESERIES(28.8,25.5,29.3,34.1,33.9,35.4,37.4,37.9,39.2,41.3,37.9,34.5,
              29,28.5,30.6,33.2,36.8,41,38.2,41.6,45,53.3,
              START=c(1920,1),FREQ=1),
  y
  =TIMESERIES(43.7,40.6,49.1,55.4,56.4,58.7,60.3,61.3,64,67,57.7,50.7,41.3,
              45.3,48.9,53.3,61.8,65,61.2,68.4,74.1,85.3,
              START=c(1920,1),FREQ=1),
  t
  =TIMESERIES(3.4,7.7,3.9,4.7,3.8,5.5,7,6.7,4.2,4,7.7,7.5,8.3,5.4,6.8,7.2,
              8.3,6.7,7.4,8.9,9.6,11.6,
              START=c(1920,1),FREQ=1),
  time 
  =TIMESERIES(NA,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,
              START=c(1920,1),FREQ=1),
  w2
  =TIMESERIES(2.2,2.7,2.9,2.9,3.1,3.2,3.3,3.6,3.7,4,4.2,4.8,5.3,5.6,6,6.1,
              7.4,6.7,7.7,7.8,8,8.5,
              START=c(1920,1),FREQ=1)
)


#load model 
myModel&lt;-LOAD_MODEL(modelText=myModelDefinition)

#model summary
summary(myModel)

#BIMETS MODEL
#-----------------------------------
#name:             myModelDefinition
#behaviorals:      3
#identities:       3
#coefficients:     12
#model data:       not OK
#.CHECK_MODEL_DATA(): model has no data. Please use LOAD_MODEL_DATA().
#fully estimated:  FALSE
#simulated:        FALSE

#load data into the model
myModel&lt;-LOAD_MODEL_DATA(myModel,myModelData,showWarnings = TRUE)

#estimate the model
myModel&lt;-ESTIMATE(myModel)

#model summary
print(myModel)

#BIMETS MODEL
#-----------------------------------
#name:             myModelDefinition
#behaviorals:      3
#identities:       3
#coefficients:     12
#model data:       OK
#fully estimated:  TRUE
#simulated:        FALSE

</code></pre>

<hr>
<h2 id='TABIT'>
Print Time Series Data
</h2><span id='topic+TABIT'></span>

<h3>Description</h3>

<p>This function prints, in a human-readable format, the content of a list of time series. Time series can be subsetted with the projection argument <code>TSRANGE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TABIT(..., 
      TSRANGE=NULL, 
      digits=getOption('digits'),
      avoidCompliance=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TABIT_+3A_...">...</code></td>
<td>
 
<p>Input list of time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TABIT_+3A_tsrange">TSRANGE</code></td>
<td>

<p>The optional date range of data presentation. <code>TSRANGE</code> must be specified as a numerical array composed by starting year, staring period, ending year and ending period of projection, <br /> i.e. <code>TSRANGE=c(START_YEAR,START_PERIOD,END_YEAR,END_PERIOD)</code>. 
</p>
</td></tr>
<tr><td><code id="TABIT_+3A_digits">digits</code></td>
<td>

<p>Controls the number of digits to print out. Valid values are 1 to 22 with a default of 7.
</p>
</td></tr>
<tr><td><code id="TABIT_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function prints out time series data and returns a <code>NULL</code> value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+TSMERGE">MOVAVG</a></code><br />
<code><a href="#topic+TSDELTA">TSDELTA</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSLEAD">TSLEAD</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#create monthly series
ts1&lt;-TSERIES(INTS(1,15),START=c(2000,1),FREQ=12)
ts2&lt;-TSERIES(INTS(1,15),START=c(2001,1),FREQ=12)
ts3&lt;-TSERIES(rnorm(15),START=c(2002,1),FREQ=12)
ts4&lt;-TSERIES(rep(NA,15),START=c(2001,4),FREQ=12)

TABIT(ts1,ts2,ts3,ts4)
# print...
#
#      Date, Prd., ts1            , ts2            , ts3            , ts4            
#
#  Jan 2000, 1   ,  1             ,                ,                ,                
#  Feb 2000, 2   ,  2             ,                ,                ,                
#  Mar 2000, 3   ,  3             ,                ,                ,                
#  ...
#  Dec 2000, 12  ,  12            ,                ,                ,                
#  Jan 2001, 1   ,  13            ,  1             ,                ,                
#  Feb 2001, 2   ,  14            ,  2             ,                ,                
#  ...
#  Dec 2001, 12  ,                ,  12            ,                ,  NA            
#  Jan 2002, 1   ,                ,  13            , -1.419782      ,  NA            
#  Feb 2002, 2   ,                ,  14            , -1.070188      ,  NA            
#  Mar 2002, 3   ,                ,  15            ,  0.889571      ,  NA            
#  Apr 2002, 4   ,                ,                ,  0.9583392     ,  NA            
#  ...
#  Feb 2003, 2   ,                ,                , -0.3444237     ,                
#  Mar 2003, 3   ,                ,                , -0.3073225     ,                


#create quarterly series, set TSRANGE then print with 3 digits

ts1&lt;-TSERIES(INTS(1,15),START=c(2000,1),FREQ=4)
ts2&lt;-TSERIES(INTS(1,15),START=c(2001,1),FREQ=4)
ts3&lt;-TSERIES(rnorm(15),START=c(2002,1),FREQ=4)
ts4&lt;-TSERIES(rep(NA,15),START=c(2001,4),FREQ=4)

TABIT(ts1,ts2,ts3,ts4,TSRANGE=c(1991,3,2003,2),digits=3)

#print...
#	
#      Date, Prd., ts1        , ts2        , ts3        , ts4        
#
#   2000 Q1, 1   ,  1         ,            ,            ,            
#   2000 Q2, 2   ,  2         ,            ,            ,            
#   2000 Q3, 3   ,  3         ,            ,            ,            
#   2000 Q4, 4   ,  4         ,            ,            ,            
#   2001 Q1, 1   ,  5         ,  1         ,            ,            
#   2001 Q2, 2   ,  6         ,  2         ,            ,            
#   2001 Q3, 3   ,  7         ,  3         ,            ,            
#   2001 Q4, 4   ,  8         ,  4         ,            ,  NA        
#   2002 Q1, 1   ,  9         ,  5         ,  0.729     ,  NA        
#   2002 Q2, 2   ,  10        ,  6         ,  0.923     ,  NA        
#   2002 Q3, 3   ,  11        ,  7         , -0.81      ,  NA        
#   2002 Q4, 4   ,  12        ,  8         , -0.0748    ,  NA        
#   2003 Q1, 1   ,  13        ,  9         ,  0.248     ,  NA        
#   2003 Q2, 2   ,  14        ,  10        , -0.347     ,  NA   


#create daily series and set TSRANGE

ts1&lt;-TSERIES(INTS(1,25),START=c(2000,1),FREQ=366)
ts2&lt;-TSERIES(INTS(1,25),START=c(2000,10),FREQ=366)
ts3&lt;-TSERIES(rnorm(25),START=c(2000,20),FREQ=366)
ts4&lt;-TSERIES(rep(NA,25),START=c(2000,30),FREQ=366)

TABIT(ts1,ts2,ts3,ts4,TSRANGE=c(2000,5,2000,35))

#...print data

</code></pre>

<hr>
<h2 id='TSDELTA'>
Time Series Lag Differences (Delta)
</h2><span id='topic+TSDELTA'></span><span id='topic+DELTA'></span>

<h3>Description</h3>

<p>This function returns the <code>O</code>-order, <code>L</code>-lag differences of the input time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSDELTA(x = NULL, L = 1, O = 1, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSDELTA_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSDELTA_+3A_l">L</code></td>
<td>

<p>Lag.
</p>
</td></tr>
<tr><td><code id="TSDELTA_+3A_o">O</code></td>
<td>

<p>Order of the difference.
</p>
</td></tr>
<tr><td><code id="TSDELTA_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="TSDELTA_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DELTAP">TSDELTAP</a></code><br />
<code><a href="#topic+TSDELTALOG">TSDELTALOG</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#random TS
	n&lt;-10
	xArr&lt;-rnorm(n)
	ts1&lt;-TSERIES(xArr,START=c(2000,1),FREQ='A')
	TABIT(ts1,TSDELTA(ts1,1,1),TSDELTA(ts1,1,2),TSDELTA(ts1,1,3))
</code></pre>

<hr>
<h2 id='TSDELTALOG'>
Time Series Lag Logarithmic Differences 
</h2><span id='topic+TSDELTALOG'></span>

<h3>Description</h3>

<p>This function returns the <code>L</code>-lag logarithmic differences of the input time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSDELTALOG(x = NULL, L = 1,  avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSDELTALOG_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSDELTALOG_+3A_l">L</code></td>
<td>

<p>Lag.
</p>
</td></tr>
<tr><td><code id="TSDELTALOG_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="TSDELTALOG_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DELTAP">TSDELTAP</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#sequence TS
	n&lt;-10
	ts1&lt;-TSERIES(1:n,START=c(2000,1),FREQ='A')
	TABIT(ts1,TSDELTALOG(ts1,1))
</code></pre>

<hr>
<h2 id='TSDELTAP'>
Time Series Percentage Lag Differences (Delta Percentage)
</h2><span id='topic+TSDELTAP'></span><span id='topic+DELTAP'></span>

<h3>Description</h3>

<p>This function returns the <code>O</code>-order, <code>L</code>-lag percentage differences of the input time series.
If the input time series frequency is a multiple of the <code>L</code> lag argument, then it is possible to set the argument <code>ANNUALIZE=TRUE</code> in order to have the percent changes returned at annual rates, i.e. raised to the power of <code>frequency/L</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSDELTAP(x = NULL, L = 1, ANNUALIZE = FALSE, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSDELTAP_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSDELTAP_+3A_l">L</code></td>
<td>

<p>Lag.
</p>
</td></tr>
<tr><td><code id="TSDELTAP_+3A_annualize">ANNUALIZE</code></td>
<td>

<p>If TRUE the percent changes are returned as annual rates, i.e. raised to the power of frequency/L
</p>
</td></tr>
<tr><td><code id="TSDELTAP_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="TSDELTAP_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DELTA">TSDELTA</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+INDEXNUM">INDEXNUM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#TS Q
	n&lt;-10;
	ts1&lt;-TSERIES(n:0,START=c(2000,1),FREQ='Q')
	TABIT(ts1,TSDELTAP(ts1,1))
	
	#TS 366
	ts1&lt;-TSERIES(seq(1,length=10,by=-0.001),START=c(2000,1),FREQ=366)
	TABIT(ts1,TSDELTAP(ts1,1,ANNUALIZE=TRUE))
	
	</code></pre>

<hr>
<h2 id='TSERIES'>
Create a Time Series
</h2><span id='topic+TSERIES'></span><span id='topic+TIMESERIES'></span>

<h3>Description</h3>

<p>This function returns a time series that is compliant with BIMETS compliance control defined in <code><a href="#topic+is.bimets">is.bimets</a></code>. Users can provide observation values, frequency, and the starting period. Moreover, users can provide metadata information that will be stored into the time series object as attributes.<br /><br /> <code>TIMESERIES</code> is an alias for <code>TSERIES</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
TIMESERIES(..., START = c(2000,1), FREQ = 1, 
           SOURCE = NULL, TITLE = NULL, UNITS = NULL, SCALEFAC = 0, 
           class=NULL, avoidCompliance = FALSE)
           
TSERIES(..., START = c(2000,1), FREQ = 1, 
        SOURCE = NULL, TITLE = NULL, UNITS = NULL, SCALEFAC = 0, 
        class=NULL, avoidCompliance = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSERIES_+3A_...">...</code></td>
<td>

<p>List of values to be inserted into the output time series. This function accepts
arguments of class <code>ts()</code> and <code>xts()</code>, that must be BIMETS compliant as defined in <code><a href="#topic+is.bimets">is.bimets</a></code>. It also accepts numerical arrays. Please note that for daily and weekly time series, as in the default R time series class <code>ts()</code>, this function will insert provided input values always filling up to the 366th period in the daily case and up to the 53rd period in the weekly case. (see example)
</p>
</td></tr>
<tr><td><code id="TSERIES_+3A_start">START</code></td>
<td>

<p>This argument defines the start of the time series. Starting period can be specified as <code>c(YEAR,PERIOD)</code>, or as <code>Date()</code>, or as <code>yearmon()</code> if the frequency <code>FREQ=12</code>, or as <code>yearqtr()</code> if the frequency <code>FREQ=4</code>. Please note that the time series must lie in the year range 1800-2199: conversion between date and year-period has been optimized and hard-coded for all frequencies within this time range.
</p>
</td></tr>
<tr><td><code id="TSERIES_+3A_freq">FREQ</code></td>
<td>

<p>The frequency of the time series. Frequency can be <br /> <code>FREQ=1, 2, 3, 4, 12, 24, 36, 53, or 366</code>. Frequency can also be defined by using the char <code>'A'</code> or <code>'Y'</code> for annual/yearly, <code>'S'</code> for semiannual, <code>'Q'</code> for quarterly, <code>'M'</code> for monthly, <code>'W'</code> for weekly, and <code>'D'</code> for daily time series.
</p>
</td></tr>
<tr><td><code id="TSERIES_+3A_source">SOURCE</code></td>
<td>

<p>Set the metadata string that represents the source of the data. Metadata will be lost if the current time series is transformed by any function that changes its values.
</p>
</td></tr>
<tr><td><code id="TSERIES_+3A_title">TITLE</code></td>
<td>

<p>Set the metadata string that represents the description of the data. Metadata will be lost if the current time series is transformed by any function that changes its values.
</p>
</td></tr>
<tr><td><code id="TSERIES_+3A_units">UNITS</code></td>
<td>

<p>Set the metadata string that represents the unit of measure of the data. Metadata will be lost if the current time series is transformed by any function that changes its values.
</p>
</td></tr>
<tr><td><code id="TSERIES_+3A_scalefac">SCALEFAC</code></td>
<td>

<p>Set the numerical value that represents the scale factor of the data. Users may eventually want to use this value in code. Metadata will be lost if the current time series is transformed by any function that changes its values.
</p>
</td></tr>
<tr><td><code id="TSERIES_+3A_class">class</code></td>
<td>

<p>If <code>class='XTS'</code> this function will return a time series based on the <code>xts()</code> class. If <code>class='TS'</code> this function will return a time series based on the <code>ts()</code> class. If <code>class=NULL</code> (default) the output base class will be the one defined in the global BIMETS option <code>'BIMETS_CONF_CCT'</code> (see <code><a href="#topic+bimetsConf">BIMETS configuration</a></code>). Please note that package functions only accept time series belonging to the same class as the one defined in the global option <code>'BIMETS_CONF_CCT'</code>. Users can change any global option directly in the code.
</p>
<p>Please note that BIMETS package performs better with <code>class='TS'</code> or more generally with BIMETS_CONF_CCT='TS'
</p>
</td></tr> 
<tr><td><code id="TSERIES_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series that is compliant with the BIMETS compliance control defined in <code><a href="#topic+is.bimets">is.bimets</a></code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+as.bimets">as.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+bimetsConf">BIMETS configuration</a></code><br />
<code><a href="#topic+fromBIMETStoTS">fromBIMETStoTS</a></code><br />
<code><a href="#topic+fromBIMETStoXTS">fromBIMETStoXTS</a></code><br />
<code><a href="#topic+NOELS">NOELS</a></code><br />
<code><a href="#topic+TSDATES">TSDATES</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #day and month names can change depending on locale
  Sys.setlocale('LC_ALL','C')
  Sys.setlocale('LC_TIME','C')
  
  #create a simple R ts
  n&lt;-10
  ts1&lt;-ts((1:n),start=c(2000,1),frequency=1)	
  
  #create a bimets ts annual
  #having the following values: 5, (all data in ts1), NA, 8
  #starting from Jan 2020, and having custom metadata
  out_tseries&lt;-TIMESERIES(5,ts1,NA,8,START=c(2020,1),FREQ=1,
  SOURCE='mySource',TITLE='myTitle',UNITS='myUnits',SCALEFAC=2)
  
  #print out
  TABIT(out_tseries)
  
  #use Date() as start date
  TABIT(TIMESERIES(1:10,START=as.Date('2000-01-01'),FREQ='A'))
  TABIT(TIMESERIES(1:10,START=as.Date('2000-01-01'),FREQ='Y'))
  TABIT(TIMESERIES(1:10,START=as.Date('2000-07-08'),FREQ='D'))
  TABIT(TIMESERIES(1:10,START=as.Date('2018-01-01'),FREQ='W'))
  
  #use yearmon()/yearqtr() as start date
  TABIT(TIMESERIES(1:10,START=as.yearmon('Mar 2001'),FREQ='M'))
  TABIT(TIMESERIES(1:10,START=as.yearqtr('2000 Q3'),FREQ='Q'))
  
  #create ts monthly with metadata
  out_tseries&lt;-TIMESERIES(5,ts1,NA,8,START=c(2020,1),FREQ='M', 
  SOURCE='mySource',TITLE='myTitle',UNITS='myUnits',SCALEFAC=2)
  
  #print out
  TABIT(out_tseries)
  
  #create daily 
  out_tseries&lt;-TSERIES(5,ts1,NA,8,START=c(2000,1),FREQ=366, 
  SOURCE='mySource',TITLE='myTitle',UNITS='myUnits',SCALEFAC=2)
  
  #print out
  TABIT(out_tseries)
  
  #insert values skipping 366 in non-bissextile
  myLength&lt;-400
  myValues&lt;-1:myLength
  myDates&lt;-as.Date('2001-01-01')+0:(myLength-1)
  ts&lt;-as.bimets(xts(myValues,order.by = myDates))
  TABIT(ts) #366 observation will be a duplicated of 365, see as.bimets() help
	
</code></pre>

<hr>
<h2 id='TSEXTEND'>
Extend Time Series
</h2><span id='topic+TSEXTEND'></span><span id='topic+EXTEND'></span>

<h3>Description</h3>

<p>This function extends the time series definition range by using the directives specified in the <code>EXTMODE</code> and <code>FACTOR</code> arguments. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSEXTEND(x = NULL, BACKTO = NULL, UPTO = NULL, EXTMODE = "GROWTH",  
       FACTOR = NA, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSEXTEND_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSEXTEND_+3A_backto">BACKTO</code></td>
<td>

<p>Define the new start of the time series, which must be provided as <code>c(YEAR,PERIOD)</code>. It is possible to convert a <code>Date()</code>, or a <code>yearmon()</code>, or a <code>yearqtr()</code> to the related <code>c(YEAR,PERIOD)</code> by using the functions <code><a href="#topic+date2yp">date2yp</a></code>, <code><a href="#topic+ym2yp">ym2yp</a></code>, and  <code><a href="#topic+yq2yp">yq2yp</a></code>.
</p>
</td></tr>
<tr><td><code id="TSEXTEND_+3A_upto">UPTO</code></td>
<td>

<p>Define the new end of the time series, which must be provided as <code>c(YEAR,PERIOD)</code>. It is possible to convert a <code>Date()</code>, or a <code>yearmon()</code>, or a <code>yearqtr()</code> to the related <code>c(YEAR,PERIOD)</code> by using the functions <code><a href="#topic+date2yp">date2yp</a></code>, <code><a href="#topic+ym2yp">ym2yp</a></code>, and  <code><a href="#topic+yq2yp">yq2yp</a></code>.
</p>
</td></tr>
<tr><td><code id="TSEXTEND_+3A_extmode">EXTMODE</code></td>
<td>
<p> It must be one of the following:<br />
<b>MISSING</b>: extend the time series using missings values <code>NA</code>. <br />
<b>ZERO</b>: extend the time series by using 0 (zero) values. <br />
<b>CONSTANT</b>: extend the time series by using the closest non-missing observation. <br />
<b>MEAN4</b>: extend the time series by using the mean of the closest four non-missing observations. <br />
<b>LINEAR</b>: extend the time series by using the same increment of the closest couple of observations. <br />
<b>QUADRATIC</b>: extend the time series by using the same quadratic increment of the closest eight observations.<br /> 					
<b>GROWTH</b>: extends the time series by using the closest growth rate.<br />
<b>GROWTH4</b>: extend the time series by using the factor <br /> <code>
               r=(mean(x[-1:-4])/mean(x[-5:-8]))**(1/4)</code>  <br />
<b>MYCONST</b>: extend the time series by using the value defined in <code>FACTOR</code>  <br />
<b>MYRATE</b>: extend the time series by using the increment defined in <code>FACTOR</code>   <br />
</p>
</td></tr>
<tr><td><code id="TSEXTEND_+3A_factor">FACTOR</code></td>
<td>

<p>User-defined value used by some options of the <code>EXTMODE</code> argument.
</p>
</td></tr>
<tr><td><code id="TSEXTEND_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="TSEXTEND_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series built by extending the input time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
<code><a href="#topic+INDEXNUM">INDEXNUM</a></code><br />
<code><a href="#topic+TSTRIM">TSTRIM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	
	n&lt;-10;
	ts1&lt;-TIMESERIES(1:n,START=c(2000,1),FREQ='A')
	ts2&lt;-TSEXTEND(ts1,BACKTO=c(1990,1),UPTO=c(2020,1),EXTMODE='GROWTH4')
	TABIT(ts1,ts2)
		
	xArr&lt;-c(0.5,5.6,4.8,3.8,7.3,9.9,7.8,3.7,8.2,10)
	ts1&lt;-TIMESERIES(xArr,START=c(2000,1),FREQ='A')
	ts2&lt;-TSEXTEND(ts1,BACKTO=c(1990,1),UPTO=c(2020,1),EXTMODE='QUADRATIC')
	TABIT(ts1,ts2)
	
	xArr&lt;-(1:n)
	dateArr&lt;-seq(as.Date('2000/12/31'),by='year',length=n)
	dataF&lt;-data.frame(dateArr,xArr)
	ts1&lt;-TIMESERIES(xArr,START=c(2000,1),FREQ='A')
	ts2&lt;-TSEXTEND(ts1,BACKTO=c(1990,1),UPTO=c(2020,1),EXTMODE='MYRATE',FACTOR=2.5)
	TABIT(ts1,ts2)
</code></pre>

<hr>
<h2 id='TSINFO'>
Get Time Series Info
</h2><span id='topic+TSINFO'></span>

<h3>Description</h3>

<p>This function returns detailed information about the input time series list. The requested information is defined in the argument <code>MODE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSINFO(..., MODE = NULL, avoidCompliance=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSINFO_+3A_...">...</code></td>
<td>

<p>Input time series list. Each time series must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSINFO_+3A_mode">MODE</code></td>
<td>

<p>Select the information to be retrieved from the list of time series. <code>MODE</code> can be set to:<br />
<b>STARTY</b>: the output will be a numerical array built with the starting year of each time series in the input list.<br />
<b>ENDY</b>:  the output will be a numerical array built with the ending year of each time series in the input list.<br />
<b>STARTP</b>:  the output will be a numerical array built with the starting period of each time series in the input list.<br /> 
<b>ENDP</b>:  the output will be a numerical array built with the ending period of each time series in the input list.<br />
<b>START</b>:  the output will be a numerical array built with the value <br /> <code>x=START_YEAR+START_PERIOD/FREQ</code> calculated on each time series in the input list, where <code>FREQ</code> is the time series frequency.<br />
<b>END</b>:  the output will be a numerical array built with the value <br /> <code>x=END_YEAR+END_PERIOD/FREQ</code> calculated on each time series in the input list.<br />
<b>START2</b>:  the output will be a numerical matrix. For each time series in the input list the output matrix will have a <code>row=c(START_YEAR,START_PERIOD)</code> with related values.<br />
<b>END2</b>:  the output will be a numerical matrix. For each time series in the input list the output matrix will have a <code>row=c(END_YEAR,END_PERIOD)</code> with related values.<br />
<b>FREQ</b>:  the output will be a numerical array built with the frequency of each time series in the input list.<br />
<b>FACTOR</b>: the output will be a numerical array built with the SCALEFAC metadata value of each time series in the input list. <br />
<b>UNITS</b>: the output will be a string array built with the UNITS metadata string of each time series in the input list.<br />
<b>TITLE</b>:  the output will be a string array built with the TITLE metadata string of each time series in the input list.<br />
<b>SOURCE</b>: the output will be a string array built with the SOURCE metadata string of each time series in the input list. <br />
</p>
</td></tr>
<tr><td><code id="TSINFO_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an array built of the requested information about the input time series list. In the case of <code>MODE=START2</code> or <code>MODE=END2</code> the output will be of class <code>matrix()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NOELS">NOELS</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+fromBIMETStoTS">fromBIMETStoTS</a></code><br />
<code><a href="#topic+fromBIMETStoXTS">fromBIMETStoXTS</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+TSLOOK">TSLOOK</a></code><br />
<code><a href="#topic+TABIT">TABIT</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#create ts
	ts1&lt;-TIMESERIES(INTS(1,10),START=c(2004,2),FREQ=2,
	UNITS='myUnits',TITLE='myTitle',SOURCE='mySource')
	ts2&lt;-TIMESERIES(INTS(1,20),START=c(2006,3),FREQ=4,SCALEFAC=1)
	ts3&lt;-TIMESERIES(INTS(1,30),START=c(2008,7),FREQ=12)
	
	print(TSINFO(ts1,ts2,ts3,MODE='STARTY')) #print ... c(2004,2006,2008)
	print(TSINFO(ts1,ts2,ts3,MODE='ENDP')) #print ... c(1,2,12)
	print(TSINFO(ts1,ts2,ts3,MODE='FREQ')) #print ... c(2,4,12)
	
	print(TSINFO(ts1,ts2,ts3,MODE='START2')) 
	#print ... 
	#[,1] [,2]
	#[1,] 2004    2
	#[2,] 2006    3
	#[3,] 2008    7
	
	print(TSINFO(ts1,ts2,ts3,MODE='END')) #print ... c(2009.5, 2011.5, 2011.0)
	print(TSINFO(ts1,ts2,ts3,MODE='FACTOR')) #print ...  c(0,1,0)
	print(TSINFO(ts1,ts2,ts3,MODE='UNITS')) #print ...  c('myUnits','','')
	
</code></pre>

<hr>
<h2 id='TSJOIN'>
Join Time Series
</h2><span id='topic+TSJOIN'></span>

<h3>Description</h3>

<p>This function returns the join of the two input time series. If the first time series overlaps the second time series, output data is taken from the first time series up to the second time series's 
starting date, the remainder of the data being taken from the second time series. <br /> A different joining period can be specified by using the <code>JPRD</code> argument.<br /> The two time series must have the same frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSJOIN(x = NULL, y = NULL, JPRD = NULL, ALLOWGAP = FALSE, 
       WARN = FALSE, avoidCompliance = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSJOIN_+3A_x">x</code></td>
<td>

<p>First input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSJOIN_+3A_y">y</code></td>
<td>

<p>Second input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSJOIN_+3A_jprd">JPRD</code></td>
<td>

<p>This argument defines a joining period other than the starting period of the second time series.
It must be defined as <code>JPRD=c(YEAR,PERIOD)</code> and must lie in the time range of the second time series. Users can convert a <code>Date()</code>, or a <code>yearmon()</code> or a <code>yearqtr()</code> to a <code>c(YEAR,PERIOD)</code> by using <code><a href="#topic+date2yp">date2yp</a></code>, <code><a href="#topic+ym2yp">ym2yp</a></code>, <code><a href="#topic+yq2yp">yq2yp</a></code>.
</p>
</td></tr>
<tr><td><code id="TSJOIN_+3A_allowgap">ALLOWGAP</code></td>
<td>

<p>if <code>TRUE</code>, the possible gap between the two time series is filled with missing values <code>NA</code>, otherwise, if the two time ranges do not overlap, an error will be thrown.
</p>
</td></tr>
<tr><td><code id="TSJOIN_+3A_warn">WARN</code></td>
<td>

<p>Print a warning message if the two time series do not overlap or if the first time series starts after the <code>JPRD</code>. The warning is shown only if <code>ALLOWGAP=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="TSJOIN_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code></p>
</td></tr>
<tr><td><code id="TSJOIN_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series that is built by joining the two input time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
  #day and month names can change depending on locale
  Sys.setlocale('LC_ALL','C')
  Sys.setlocale('LC_TIME','C')
  
  #TS
  ts1&lt;-TSERIES((1:10),START=c(1985,1),FREQ=1)
  ts2&lt;-TSERIES((1:10),START=c(2000,1),FREQ=1)
  TABIT(ts1,ts2,TSJOIN(ts1,ts2,ALLOWGAP=TRUE))
  
  #XTS
  setBIMETSconf('BIMETS_CONF_CCT','XTS')
  n&lt;-10
  xArr&lt;-(0:n)
  dateArr&lt;-as.yearqtr('1997 Q1')+ 0:n/4
  dataF&lt;-data.frame(dateArr,xArr)
  ts1&lt;-xts(dataF[,2],order.by=dataF[,1])
  dateArr&lt;-as.yearqtr('2000 Q1')+ 0:n/4
  dataF&lt;-data.frame(dateArr,xArr)
  ts2&lt;-xts(dataF[,2],order.by=dataF[,1])
  TABIT(ts1,ts2,TSJOIN(ts1,ts2,ALLOWGAP=TRUE,JPRD=yq2yp(as.yearqtr("2001 Q3"))))
  
  #restore default
  setBIMETSconf('BIMETS_CONF_CCT','TS')
	
</code></pre>

<hr>
<h2 id='TSLAG'>
Lag Time Series
</h2><span id='topic+TSLAG'></span>

<h3>Description</h3>

<p>This function lags the input time series  by the specified number of time periods. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSLAG(x = NULL, L = 1, avoidCompliance = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSLAG_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSLAG_+3A_l">L</code></td>
<td>

<p>Lag. Must be an integer, positive or negative.
</p>
</td></tr>
<tr><td><code id="TSLAG_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code></p>
</td></tr>
<tr><td><code id="TSLAG_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code> some verbose output will be activated.</p>
</td></tr>
<tr><td><code id="TSLAG_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series built by lagging the input time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+TSLEAD">TSLEAD</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#DEFINE TS
	n&lt;-10
	ts1&lt;-TSERIES(n:1,START=c(2000,1),FREQ=1)
	ts1[5]&lt;-NA
	
	#print TSLAG
	TABIT(ts1,TSLAG(ts1,5))
	
	n&lt;-10
	ts1&lt;-TSERIES(n:1,START=c(2000,1),FREQ='D')
	ts1[5]&lt;-NA
	
	#print TSLAG
	TABIT(ts1,TSLAG(ts1,5))
</code></pre>

<hr>
<h2 id='TSLEAD'>
Lead Time Series
</h2><span id='topic+TSLEAD'></span>

<h3>Description</h3>

<p>This function leads the input time series  by the specified number of time periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSLEAD(x = NULL, L = 1, avoidCompliance = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSLEAD_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSLEAD_+3A_l">L</code></td>
<td>

<p>Lead. Must be an integer, positive or negative.
</p>
</td></tr>
<tr><td><code id="TSLEAD_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code></p>
</td></tr>
<tr><td><code id="TSLEAD_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code> some verbose output will be activated.</p>
</td></tr>
<tr><td><code id="TSLEAD_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series built by leading the input time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#DEFINE TS
	n&lt;-10
	
	ts1&lt;-TSERIES(n:1,START=c(2000,1),FREQ=1)
	ts1[5]&lt;-NA
	
	#print TSLEAD
	TABIT(ts1,TSLEAD(ts1,5))
</code></pre>

<hr>
<h2 id='TSLOOK'>
Lookup a Time Series
</h2><span id='topic+TSLOOK'></span>

<h3>Description</h3>

<p>This function returns the time range and the frequency of an input time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSLOOK(x=NULL, avoidCompliance=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSLOOK_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSLOOK_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSLOOK_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of numeric arrays built with the following elements:<br />
<code>STARTY</code> will contain the value of the starting year<br />
<code>STARTP</code> will contain the value of the starting period<br />
<code>ENDY</code> will contain the value of the ending year<br />
<code>ENDP</code> will contain the value of the ending period<br />
<code>FREQ</code> will contain the value of the time series frequency<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NOELS">NOELS</a></code><br />
<code><a href="#topic+is.bimets">is.bimets</a></code><br />
<code><a href="#topic+idxOver">BIMETS indexing</a></code><br />
<code><a href="#topic+fromBIMETStoXTS">fromBIMETStoXTS</a></code><br />
<code><a href="#topic+fromBIMETStoTS">fromBIMETStoTS</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+INTS">INTS</a></code><br />
<code><a href="#topic+TSINFO">TSINFO</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#create series
	ts1&lt;-TSERIES(INTS(1,10),START=c(2000,1),FREQ=12)
	
	ts1Look&lt;-TSLOOK(ts1)
  	
	print(ts1Look$STARTY) #print...2000 
	print(ts1Look$STARTP) #print...1
	print(ts1Look$ENDY) #print...2000
	print(ts1Look$ENDP) #print...10
	print(ts1Look$FREQ) #print...12
	
</code></pre>

<hr>
<h2 id='TSMERGE'>
Merge Time Series
</h2><span id='topic+TSMERGE'></span>

<h3>Description</h3>

<p>This function merges and concatenates two or more time series of the same frequency. The output time series will be defined over the union of dates for which the input time series are defined, from the earliest starting date to the latest ending date. <br /><br />
For each period, the output value will be set equal to the first non-missing value found in the input time series list by using the order of the arguments. If
all the input time series are missing at a period, then the output time series will be set to the missing value <code>NA</code> in the same period. Note that if the input time series' date spans do not intersect, <code>TSMERGE(X1,X2,...,XN)</code> returns a simple concatenation of <code>X1, X2,..., XN</code>.<br /><br /> By defining the argument <code>fun</code>, the value of the output time series can also be computed as a function of the values of the input time series in the same period (see example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSMERGE(..., fun = NULL, MV = FALSE, avoidCompliance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSMERGE_+3A_...">...</code></td>
<td>

<p>Input list of time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSMERGE_+3A_fun">fun</code></td>
<td>
<p> By defining the argument <code>fun</code>, the value of the output time series in a period can be computed as a function of the input time series values in the same period. <br /> <code>fun</code> can assume the following string values:<br />
<b>AVE</b>: the value of the output time series in a period will be set equal to the average of all input time series values in the same period. <br />
<b>SUM</b>: the value of the output time series in a period will be set equal to the sum of all input time series values in the same period. <br />
<b>MAX</b>: the value of the output time series in a period will be set equal to the maximum of all input time series values in the same period. <br />
<b>MIN</b>: the value of the output time series in a period will be set equal to the minimum of all input time series values in the same period. <br />
</p>
</td></tr>
<tr><td><code id="TSMERGE_+3A_mv">MV</code></td>
<td>

<p>If <code>FALSE</code>, the function defined in the argument <code>fun</code> will skip any missing values found in the input time series.
</p>
</td></tr>
<tr><td><code id="TSMERGE_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series built by merging two or more input time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+TSLEAD">TSLEAD</a></code><br />
<code><a href="#topic+TSTRIM">TSTRIM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#DEFINE TS
	n&lt;-10
	ts1&lt;-TSERIES(n:1,START=c(1995,1),FREQ=1)
	ts2&lt;-TSERIES(n:1,START=c(2000,1),FREQ=1)
	
	ts2[5]&lt;-NA
	ts1[10]&lt;-NA
	
	#print TSMERGE
	TABIT(ts1,ts2,TSMERGE(ts1,ts2,fun='SUM',MV=TRUE))
	
	#TS D
	n&lt;-20
	ts1&lt;-TSERIES(n:1,START=c(1999,360),FREQ='D')
	ts2&lt;-TSERIES(n:1,START=c(2000,1),FREQ='D')
	
	ts2[5]&lt;-NA
	ts1[10]&lt;-NA
	
	#print TSMERGE
	TABIT(ts1,ts2,TSMERGE(ts1,ts2,fun='SUM',MV=TRUE))
</code></pre>

<hr>
<h2 id='TSPROJECT'>
Project a Time series
</h2><span id='topic+TSPROJECT'></span>

<h3>Description</h3>

<p>This function projects the input time series into a time interval. The output class can be either a time series (default) or a one-dimensional array if the argument <code>ARRAY=TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSPROJECT(x=NULL, TSRANGE=NULL, ARRAY=FALSE, 
          EXTEND=FALSE, avoidCompliance=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSPROJECT_+3A_x">x</code></td>
<td>

<p>Input time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSPROJECT_+3A_tsrange">TSRANGE</code></td>
<td>

<p>Date range of data projection. <code>TSRANGE</code> must be specified as a numerical array composed by starting year, starting period, ending year and ending period of projection, <br /> i.e. <code>TSRANGE=c(START_YEAR,START_PERIOD,END_YEAR,END_PERIOD)</code>. 
</p>
</td></tr>
<tr><td><code id="TSPROJECT_+3A_array">ARRAY</code></td>
<td>

<p>If <code>TRUE</code> this function will return a numerical array built with observation values that lie in the specified time range. If <code>FALSE</code> (default) the output will be a time series.
</p>
</td></tr>
<tr><td><code id="TSPROJECT_+3A_extend">EXTEND</code></td>
<td>

<p>If <code>TRUE</code> and in the case that the input time series does not overlap with the provided <code>TSRANGE</code>, the output time series will be extended over the <code>TSRANGE</code> by inserting missing values <code>NA</code> into the new observations.
</p>
</td></tr>
<tr><td><code id="TSPROJECT_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="TSPROJECT_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a BIMETS time series, or a numerical array if the argument <code>ARRAY=TRUE</code>, built by projecting the input time series into the provided <code>TSRANGE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
<code><a href="#topic+TSTRIM">TSTRIM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>		
	#create yearly ts
	ts1&lt;-TSERIES((1:10),START=c(2000,1),FREQ=1)
  	
	print(TSPROJECT(ts1,TSRANGE=c(2002,1,2005,1)))	#print projected ts from 2002 to 2005
	
	print(TSPROJECT(ts1,TSRANGE=c(2001,1,2004,1),ARRAY=TRUE)) #print c(2,3,4,5)
	
	print(TSPROJECT(ts1,TSRANGE=c(1998,1,2002,1),EXTEND=TRUE,ARRAY=TRUE)) 
	#print c(NA,NA,1,2,3)
	
</code></pre>

<hr>
<h2 id='TSTRIM'>
Trim a Time Series
</h2><span id='topic+TSTRIM'></span>

<h3>Description</h3>

<p>This function removes trailing or leading missing values <code>NA</code> from the input array or the input time series. Users can provide the value to be removed other than <code>NA</code> missing value by using the argument <code>VALUE</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSTRIM(x=NULL, VALUE=NA, TRAIL=TRUE, LEAD=TRUE, avoidCompliance=FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSTRIM_+3A_x">x</code></td>
<td>

<p>Input numerical array or time series that must satisfy the compliance control check defined in <code><a href="#topic+is.bimets">is.bimets</a></code>.
</p>
</td></tr>
<tr><td><code id="TSTRIM_+3A_value">VALUE</code></td>
<td>

<p>Target value to be removed. Default to missing value <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="TSTRIM_+3A_trail">TRAIL</code></td>
<td>

<p>If <code>TRUE</code> this function will remove trailing target values from the input time series.
</p>
</td></tr>
<tr><td><code id="TSTRIM_+3A_lead">LEAD</code></td>
<td>

<p>If <code>TRUE</code> this function will remove leading target values from the input time series.
</p>
</td></tr>
<tr><td><code id="TSTRIM_+3A_avoidcompliance">avoidCompliance</code></td>
<td>

<p>If <code>TRUE</code>, compliance control check of input time series will be skipped. See <code><a href="#topic+is.bimets">is.bimets</a></code>
</p>
</td></tr>
<tr><td><code id="TSTRIM_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of the same class of the input, i.e. an array or a BIMETS time series, built by removing leading and trailing user-defined values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSLAG">TSLAG</a></code><br />
<code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+TSPROJECT">TSPROJECT</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
<code><a href="#topic+INDEXNUM">INDEXNUM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#TS A
	n&lt;-10
	ts1&lt;-TSERIES(c(NA,1:n,NA),START=c(2000,1),FREQ='A')
	TABIT(ts1,TSTRIM(ts1))
		
	ts1&lt;-TSERIES(c(NA,1:n,NA),START=c(2000,1),FREQ='A')
	TABIT(ts1,TSTRIM(ts1,TRAIL=FALSE))
	
	ts1&lt;-TSERIES(c(NA,1:n,NA),START=c(2000,1),FREQ='A')
	TABIT(ts1,TSTRIM(ts1,LEAD=FALSE))
	
	ts1&lt;-TSERIES(c(0,0,NA,1:n,NA,0),START=c(2000,1),FREQ='A')
	TABIT(ts1,TSTRIM(ts1,0))
	
</code></pre>

<hr>
<h2 id='VERIFY_MAGNITUDE'>
Time Series Magnitude Test
</h2><span id='topic+VERIFY_MAGNITUDE'></span>

<h3>Description</h3>

<p>Given a time series list, this function returns list indices that refer to time serie having a magnitude greater than the user provided value. Magnitude <code>M</code> is defined as <code>M = sqrt(sum(X_i^2))</code>, given <code>X_i</code> the time series values. Missing values will be discarded with a warning message.
</p>
<p>This function can be useful in comparing list of time series, e.g. differences between historical and simulated endogenous variables of an econometric model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>VERIFY_MAGNITUDE(x=list(), 
                magnitude=10e-7, 
                verbose=TRUE, 
                ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VERIFY_MAGNITUDE_+3A_x">x</code></td>
<td>

<p>Input list, having elements as time series of class <code>ts</code> or <code>xts</code>.
</p>
</td></tr>
<tr><td><code id="VERIFY_MAGNITUDE_+3A_magnitude">magnitude</code></td>
<td>
<p>A positive number that is the maximum magnitude allowed.
</p>
</td></tr>
<tr><td><code id="VERIFY_MAGNITUDE_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, output messages will be printed out.
</p>
</td></tr>
<tr><td><code id="VERIFY_MAGNITUDE_+3A_...">...</code></td>
<td>

<p>Backward compatibility.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the list indices related to time series that have a magnitude grater than the <code>magnitude</code> user argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TSJOIN">TSJOIN</a></code><br />
<code><a href="#topic+TSEXTEND">TSEXTEND</a></code><br />
<code><a href="#topic+TSMERGE">TSMERGE</a></code><br />
<code><a href="#topic+MOVAVG">MOVAVG</a></code><br />
<code><a href="#topic+GETYEARPERIOD">GETYEARPERIOD</a></code><br />
<code><a href="#topic+CUMSUM">CUMSUM</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>		
	#create ts
	ts1=TSERIES((1:10)*0.1, START=c(2000,1), FREQ=1)
	ts2=TSERIES((1:10)*0.01, START=c(2001,1), FREQ=4)
	ts3=TSERIES(c((1:10)*0.001,NA), START=c(2002,1), FREQ=12)
	
	myList=list(t1=ts1,t2=ts2,t3=ts3)
	
	print(VERIFY_MAGNITUDE(myList,magnitude=0.1))
</code></pre>

<hr>
<h2 id='ym2yp'>
yearmon to Year-Period Conversion
</h2><span id='topic+ym2yp'></span>

<h3>Description</h3>

<p>This function transforms an input variable of class <code>yearmon()</code> into an equivalent two-dimensional numerical array of type <code>c(YEAR,PERIOD)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ym2yp(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ym2yp_+3A_x">x</code></td>
<td>

<p>Input of class  <code>yearmon()</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a two-dimensional numerical array of type <code>c(YEAR,PERIOD)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+date2yp">date2yp</a></code><br />
<code><a href="#topic+yq2yp">yq2yp</a></code><br />
<code><a href="#topic+GETDATE">GETDATE</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #day and month names can change depending on locale
  Sys.setlocale('LC_ALL','C')
  Sys.setlocale('LC_TIME','C')
  
  print(ym2yp(as.yearmon("Dec 2013"))); #print c(2013,12)
  print(ym2yp(c(as.yearmon('Jan 2000'),as.yearmon('Dec 1987'),
        as.yearmon('Jan 2003'),as.yearmon('Mar 2012'))))
</code></pre>

<hr>
<h2 id='yq2yp'>
yearqtr to Year-Period Conversion
</h2><span id='topic+yq2yp'></span>

<h3>Description</h3>

<p>This function transforms an input variable of class <code>yearqtr()</code> into an equivalent two-dimensional numerical array of type <code>c(YEAR,PERIOD)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yq2yp(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yq2yp_+3A_x">x</code></td>
<td>

<p>Input of class  <code>yearmon()</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a two-dimensional numerical array of type <code>c(YEAR,PERIOD)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+date2yp">date2yp</a></code><br />
<code><a href="#topic+ym2yp">ym2yp</a></code><br />
<code><a href="#topic+GETDATE">GETDATE</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
  #day and month names can change depending on locale
  Sys.setlocale('LC_ALL','C')
  Sys.setlocale('LC_TIME','C')
  
  print(yq2yp(as.yearqtr('2001 Q3'))); #print c(2001,3)
  print(yq2yp(c(as.yearqtr('2000 Q2'),as.yearqtr('1987 Q4'),as.yearqtr('2003 Q1'))))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
