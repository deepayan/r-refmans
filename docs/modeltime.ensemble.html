<!DOCTYPE html><html><head><title>Help for package modeltime.ensemble</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {modeltime.ensemble}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#ensemble_average'><p>Creates an Ensemble Model using Mean/Median Averaging</p></a></li>
<li><a href='#ensemble_model_spec'><p>Creates a Stacked Ensemble Model from a Model Spec</p></a></li>
<li><a href='#ensemble_nested_average'><p>Nested Ensemble Average</p></a></li>
<li><a href='#ensemble_nested_weighted'><p>Nested Ensemble Weighted</p></a></li>
<li><a href='#ensemble_weighted'><p>Creates a Weighted Ensemble Model</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ensemble Algorithms for Time Series Forecasting with Modeltime</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>
    A 'modeltime' extension that implements time series ensemble forecasting methods including model averaging, 
    weighted averaging, and stacking. These techniques are popular methods 
    to improve forecast accuracy and stability. Refer to papers such as 
    "Machine-Learning Models for Sales Time Series Forecasting" Pavlyshenko, B.M. (2019) &lt;<a href="https://doi.org/10.3390">doi:10.3390</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/business-science/modeltime.ensemble">https://github.com/business-science/modeltime.ensemble</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/business-science/modeltime.ensemble/issues">https://github.com/business-science/modeltime.ensemble/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>modeltime (&ge; 1.2.3), modeltime.resample (&ge; 0.2.1), R (&ge;
3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tune (&ge; 0.1.2), rsample, yardstick, workflows (&ge; 0.2.1),
parsnip (&ge; 0.1.6), recipes (&ge; 0.1.15), timetk (&ge; 2.5.0),
tibble, dplyr (&ge; 1.0.0), tidyr, purrr, glue, stringr, rlang
(&ge; 0.1.2), cli, generics, magrittr, tictoc, parallel,
doParallel, foreach,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gt, crayon, dials, glmnet, progressr, utils, roxygen2, earth,
testthat, tidymodels, xgboost, tidyverse, lubridate, knitr,
rmarkdown, covr, qpdf, remotes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-17 18:00:39 UTC; mdanc</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Dancho [aut, cre],
  Business Science [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Dancho &lt;mdancho@business-science.io&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-18 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>A function call
</p>

<hr>
<h2 id='ensemble_average'>Creates an Ensemble Model using Mean/Median Averaging</h2><span id='topic+ensemble_average'></span>

<h3>Description</h3>

<p>Creates an Ensemble Model using Mean/Median Averaging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble_average(object, type = c("mean", "median"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensemble_average_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="ensemble_average_+3A_type">type</code></td>
<td>
<p>Specify the type of average (&quot;mean&quot; or &quot;median&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input to an <code>ensemble_average()</code> model is always a Modeltime Table,
which contains the models that you will ensemble.
</p>
<p><strong>Averaging Methods</strong>
</p>
<p>The average method uses an un-weighted average using <code>type</code> of either:
</p>

<ul>
<li> <p><code>"mean"</code>: Performs averaging using <code>mean(x, na.rm = TRUE)</code> to aggregate each
underlying models forecast at each timestamp
</p>
</li>
<li> <p><code>"median"</code>: Performs averaging using <code>stats::median(x, na.rm = TRUE)</code> to aggregate each
underlying models forecast at each timestamp
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>mdl_time_ensemble</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidymodels)
library(modeltime)
library(modeltime.ensemble)
library(tidyverse)
library(timetk)

# Make an ensemble from a Modeltime Table
ensemble_fit &lt;- m750_models %&gt;%
    ensemble_average(type = "mean")

ensemble_fit

# Forecast with the Ensemble
modeltime_table(
    ensemble_fit
) %&gt;%
    modeltime_forecast(
        new_data    = testing(m750_splits),
        actual_data = m750
    ) %&gt;%
    plot_modeltime_forecast(
        .interactive = FALSE,
        .conf_interval_show = FALSE
    )


</code></pre>

<hr>
<h2 id='ensemble_model_spec'>Creates a Stacked Ensemble Model from a Model Spec</h2><span id='topic+ensemble_model_spec'></span>

<h3>Description</h3>

<p>A 2-stage stacking regressor that follows:
</p>

<ol>
<li><p> Stage 1: Sub-Model's are Trained &amp; Predicted using <code><a href="modeltime.resample.html#topic+modeltime_fit_resamples">modeltime.resample::modeltime_fit_resamples()</a></code>.
</p>
</li>
<li><p> Stage 2: A Meta-learner (<code>model_spec</code>) is trained on Out-of-Sample Sub-Model
Predictions using <code>ensemble_model_spec()</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>ensemble_model_spec(
  object,
  model_spec,
  kfolds = 5,
  param_info = NULL,
  grid = 6,
  control = control_grid()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensemble_model_spec_+3A_object">object</code></td>
<td>
<p>A Modeltime Table. Used for ensemble sub-models.</p>
</td></tr>
<tr><td><code id="ensemble_model_spec_+3A_model_spec">model_spec</code></td>
<td>
<p>A <code>model_spec</code> object defining the
meta-learner stacking model specification to be used.
</p>
<p>Can be either:
</p>

<ol>
<li> <p><strong>A non-tunable <code>model_spec</code>:</strong> Parameters are specified and are not optimized via tuning.
</p>
</li>
<li> <p><strong>A tunable <code>model_spec</code>:</strong> Contains parameters identified for tuning with
<code>tune::tune()</code>
</p>
</li></ol>
</td></tr>
<tr><td><code id="ensemble_model_spec_+3A_kfolds">kfolds</code></td>
<td>
<p>K-Fold Cross Validation for tuning the Meta-Learner.
Controls the number of folds used in the meta-learner's cross-validation.
Gets passed to <code>rsample::vfold_cv()</code>.</p>
</td></tr>
<tr><td><code id="ensemble_model_spec_+3A_param_info">param_info</code></td>
<td>
<p>A <code>dials::parameters()</code> object or <code>NULL</code>. If none is given, a
parameters set is derived from other arguments. Passing this argument
can be useful when parameter ranges need to be customized.</p>
</td></tr>
<tr><td><code id="ensemble_model_spec_+3A_grid">grid</code></td>
<td>
<p>Grid specification or grid size for tuning the Meta Learner.
Gets passed to <code>tune::tune_grid()</code>.</p>
</td></tr>
<tr><td><code id="ensemble_model_spec_+3A_control">control</code></td>
<td>
<p>An object used to modify the tuning process.
Uses <code>tune::control_grid()</code> by default.
Use <code>control_grid(verbose = TRUE)</code> to follow the training process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Stacked Ensemble Process</strong>
</p>

<ul>
<li><p> Start with a <em>Modeltime Table</em> to define your sub-models.
</p>
</li>
<li><p> Step 1: Use <code>modeltime_fit_resamples()</code> to perform the submodel resampling procedure.
</p>
</li>
<li><p> Step 2: Use <code><a href="#topic+ensemble_model_spec">ensemble_model_spec()</a></code> to define and train the meta-learner.
</p>
</li></ul>

<p><strong>What goes on inside the Meta Learner?</strong>
</p>
<p>The Meta-Learner Ensembling Process uses the following basic steps:
</p>

<ol>
<li> <p><strong>Make Cross-Validation Predictions.</strong>
Cross validation predictions are made for each sub-model with <code>modeltime_fit_resamples()</code>.
The out-of-sample sub-model predictions contained in <code>.resample_results</code>
are used as the input to the meta-learner.
</p>
</li>
<li> <p><strong>Train a Stacked Regressor (Meta-Learner).</strong>
The sub-model out-of-sample cross validation predictions are then
modeled using a <code>model_spec</code> with options:
</p>

<ul>
<li> <p><strong>Tuning:</strong> If the <code>model_spec</code> does include tuning parameters via <code>tune::tune()</code>
then the meta-learner will be hypeparameter tuned using K-Fold Cross Validation. The
parameters and grid can adjusted using <code>kfolds</code>, <code>grid</code>, and <code>param_info</code>.
</p>
</li>
<li> <p><strong>No-Tuning:</strong> If the <code>model_spec</code> does <em>not</em> include tuning parameters via <code>tune::tune()</code>
then the meta-learner will not be hypeparameter tuned and will have the model
fitted to the sub-model predictions.
</p>
</li></ul>

</li>
<li> <p><strong>Final Model Selection.</strong>
</p>

<ul>
<li> <p><strong>If tuned</strong>, the final model is selected based on RMSE, then
retrained on the full set of out of sample predictions.
</p>
</li>
<li> <p><strong>If not-tuned</strong>, the fitted model from Stage 2 is used.
</p>
</li></ul>

</li></ol>

<p><strong>Progress</strong>
</p>
<p>The best way to follow the training process and watch progress is to use
<code>control = control_grid(verbose = TRUE)</code> to see progress.
</p>
<p><strong>Parallelize</strong>
</p>
<p>Portions of the process can be parallelized. To parallelize, set
up parallelization using <code>tune</code> via one of the backends such as
<code>doFuture</code>. Then set <code>control = control_grid(allow_par = TRUE)</code>
</p>


<h3>Value</h3>

<p>A <code>mdl_time_ensemble</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidymodels)
library(modeltime)
library(modeltime.ensemble)
library(tidyverse)
library(timetk)

# Step 1: Make resample predictions for submodels
resamples_tscv &lt;- training(m750_splits) %&gt;%
    time_series_cv(
        assess  = "2 years",
        initial = "5 years",
        skip    = "2 years",
        slice_limit = 1
    )

submodel_predictions &lt;- m750_models %&gt;%
    modeltime_fit_resamples(
        resamples = resamples_tscv,
        control   = control_resamples(verbose = TRUE)
    )

# Step 2: Metalearner ----

# * No Metalearner Tuning
ensemble_fit_lm &lt;- submodel_predictions %&gt;%
    ensemble_model_spec(
        model_spec = linear_reg() %&gt;% set_engine("lm"),
        control    = control_grid(verbose = TRUE)
    )

ensemble_fit_lm

# * With Metalearner Tuning ----
ensemble_fit_glmnet &lt;- submodel_predictions %&gt;%
    ensemble_model_spec(
        model_spec = linear_reg(
            penalty = tune(),
            mixture = tune()
        ) %&gt;%
            set_engine("glmnet"),
        grid       = 2,
        control    = control_grid(verbose = TRUE)
    )

ensemble_fit_glmnet



</code></pre>

<hr>
<h2 id='ensemble_nested_average'>Nested Ensemble Average</h2><span id='topic+ensemble_nested_average'></span>

<h3>Description</h3>

<p>Creates an Ensemble Model using Mean/Median Averaging in the
Modeltime Nested Forecasting Workflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble_nested_average(
  object,
  type = c("mean", "median"),
  keep_submodels = TRUE,
  model_ids = NULL,
  control = control_nested_fit()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensemble_nested_average_+3A_object">object</code></td>
<td>
<p>A nested modeltime object (inherits class <code>nested_mdl_time</code>)</p>
</td></tr>
<tr><td><code id="ensemble_nested_average_+3A_type">type</code></td>
<td>
<p>One of &quot;mean&quot; for mean averaging or &quot;median&quot; for median averaging</p>
</td></tr>
<tr><td><code id="ensemble_nested_average_+3A_keep_submodels">keep_submodels</code></td>
<td>
<p>Whether or not to keep the submodels in the
nested modeltime table results</p>
</td></tr>
<tr><td><code id="ensemble_nested_average_+3A_model_ids">model_ids</code></td>
<td>
<p>A vector of id's (<code>.model_id</code>) identifying which submodels to
use in the ensemble.</p>
</td></tr>
<tr><td><code id="ensemble_nested_average_+3A_control">control</code></td>
<td>
<p>Controls various aspects of the ensembling process. See <code>control_nested_fit()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If we start with a nested modeltime table, we can add ensembles.
</p>
<div class="sourceCode r"><pre>nested_modeltime_tbl

# Nested Modeltime Table
Trained on: .splits | Model Errors: [0]
# A tibble: 2 x 5
  id    .actual_data       .future_data      .splits         .modeltime_tables
  &lt;fct&gt; &lt;list&gt;             &lt;list&gt;            &lt;list&gt;          &lt;list&gt;
1 1_1   &lt;tibble [104 x 2]&gt; &lt;tibble [52 x 2]&gt; &lt;split [52|52]&gt; &lt;mdl_time_tbl [2 x 5]&gt;
2 1_3   &lt;tibble [104 x 2]&gt; &lt;tibble [52 x 2]&gt; &lt;split [52|52]&gt; &lt;mdl_time_tbl [2 x 5]&gt;
</pre></div>
<p>An ensemble can be added to a Nested modeltime table.
</p>
<div class="sourceCode r"><pre>ensem &lt;- nested_modeltime_tbl %&gt;%
    ensemble_nested_average(
        type           = "mean",
        keep_submodels = TRUE,
        control        = control_nested_fit(allow_par = FALSE, verbose = TRUE)
    )
</pre></div>
<p>We can then verify the model has been added.
</p>
<div class="sourceCode r"><pre>ensem %&gt;% extract_nested_modeltime_table()
</pre></div>
<p>This produces an ensemble .model_id 3, which is an ensemble of the first two models.
</p>
<div class="sourceCode"><pre># A tibble: 4 x 6
  id    .model_id .model         .model_desc                 .type .calibration_data
  &lt;fct&gt;     &lt;dbl&gt; &lt;list&gt;         &lt;chr&gt;                       &lt;chr&gt; &lt;list&gt;
1 1_1           1 &lt;workflow&gt;     PROPHET                     Test  &lt;tibble [52 x 4]&gt;
2 1_1           2 &lt;workflow&gt;     XGBOOST                     Test  &lt;tibble [52 x 4]&gt;
3 1_1           3 &lt;ensemble [2]&gt; ENSEMBLE (MEAN): 2 MODELS   Test  &lt;tibble [52 x 4]&gt;
</pre></div>
<p>Additional ensembles can be added by simply adding onto the nested modeltime table.
Notice that we make use of <code>model_ids</code> to make sure it only uses model id's 1 and 2.
</p>
<div class="sourceCode r"><pre>ensem_2 &lt;- ensem %&gt;%
    ensemble_nested_average(
        type           = "median",
        keep_submodels = TRUE,
        model_ids      = c(1,2),
        control        = control_nested_fit(allow_par = FALSE, verbose = TRUE)
    )
</pre></div>
<p>This returns a 4th model that is a median ensemble of the first two models.
</p>
<div class="sourceCode"><pre>ensem_2 %&gt;% extract_nested_modeltime_table()
# A tibble: 4 x 6
  id    .model_id .model         .model_desc                 .type .calibration_data
  &lt;fct&gt;     &lt;dbl&gt; &lt;list&gt;         &lt;chr&gt;                       &lt;chr&gt; &lt;list&gt;
1 1_1           1 &lt;workflow&gt;     PROPHET                     Test  &lt;tibble [52 x 4]&gt;
2 1_1           2 &lt;workflow&gt;     XGBOOST                     Test  &lt;tibble [52 x 4]&gt;
3 1_1           3 &lt;ensemble [2]&gt; ENSEMBLE (MEAN): 2 MODELS   Test  &lt;tibble [52 x 4]&gt;
4 1_1           4 &lt;ensemble [2]&gt; ENSEMBLE (MEDIAN): 2 MODELS Test  &lt;tibble [52 x 4]&gt;
</pre></div>


<h3>Value</h3>

<p>The nested modeltime table with an ensemble model added.
</p>

<hr>
<h2 id='ensemble_nested_weighted'>Nested Ensemble Weighted</h2><span id='topic+ensemble_nested_weighted'></span>

<h3>Description</h3>

<p>Creates an Ensemble Model using Weighted Averaging in the
Modeltime Nested Forecasting Workflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble_nested_weighted(
  object,
  loadings,
  scale_loadings = TRUE,
  metric = "rmse",
  keep_submodels = TRUE,
  model_ids = NULL,
  control = control_nested_fit()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensemble_nested_weighted_+3A_object">object</code></td>
<td>
<p>A nested modeltime object (inherits class <code>nested_mdl_time</code>)</p>
</td></tr>
<tr><td><code id="ensemble_nested_weighted_+3A_loadings">loadings</code></td>
<td>
<p>A vector of weights corresponding to the loadings</p>
</td></tr>
<tr><td><code id="ensemble_nested_weighted_+3A_scale_loadings">scale_loadings</code></td>
<td>
<p>If TRUE, divides by the sum of the loadings
to proportionally weight the submodels.</p>
</td></tr>
<tr><td><code id="ensemble_nested_weighted_+3A_metric">metric</code></td>
<td>
<p>The accuracy metric to rank models by the test accuracy table.
Loadings are then applied in the order from best to worst models.
Default: <code>"rmse"</code>.</p>
</td></tr>
<tr><td><code id="ensemble_nested_weighted_+3A_keep_submodels">keep_submodels</code></td>
<td>
<p>Whether or not to keep the submodels in the
nested modeltime table results</p>
</td></tr>
<tr><td><code id="ensemble_nested_weighted_+3A_model_ids">model_ids</code></td>
<td>
<p>A vector of id's (<code>.model_id</code>) identifying which submodels to
use in the ensemble.</p>
</td></tr>
<tr><td><code id="ensemble_nested_weighted_+3A_control">control</code></td>
<td>
<p>Controls various aspects of the ensembling process. See <code>control_nested_fit()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If we start with a nested modeltime table, we can add ensembles.
</p>
<div class="sourceCode r"><pre>nested_modeltime_tbl

# Nested Modeltime Table
Trained on: .splits | Model Errors: [0]
# A tibble: 2 x 5
  id    .actual_data       .future_data      .splits         .modeltime_tables
  &lt;fct&gt; &lt;list&gt;             &lt;list&gt;            &lt;list&gt;          &lt;list&gt;
1 1_1   &lt;tibble [104 x 2]&gt; &lt;tibble [52 x 2]&gt; &lt;split [52|52]&gt; &lt;mdl_time_tbl [2 x 5]&gt;
2 1_3   &lt;tibble [104 x 2]&gt; &lt;tibble [52 x 2]&gt; &lt;split [52|52]&gt; &lt;mdl_time_tbl [2 x 5]&gt;
</pre></div>
<p>An ensemble can be added to a Nested modeltime table.
</p>
<div class="sourceCode r"><pre>ensem &lt;- nested_modeltime_tbl %&gt;%
    ensemble_nested_weighted(
        loadings       = c(2,1),
        control        = control_nested_fit(allow_par = FALSE, verbose = TRUE)
    )
</pre></div>
<p>We can then verify the model has been added.
</p>
<div class="sourceCode r"><pre>ensem %&gt;% extract_nested_modeltime_table()
</pre></div>
<p>This produces an ensemble .model_id 3, which is an ensemble of the first two models.
</p>
<div class="sourceCode"><pre># A tibble: 4 x 6
  id    .model_id .model         .model_desc                   .type .calibration_data
  &lt;fct&gt;     &lt;dbl&gt; &lt;list&gt;         &lt;chr&gt;                         &lt;chr&gt; &lt;list&gt;
1 1_3           1 &lt;workflow&gt;     PROPHET                       Test  &lt;tibble [52 x 4]&gt;
2 1_3           2 &lt;workflow&gt;     XGBOOST                       Test  &lt;tibble [52 x 4]&gt;
3 1_3           3 &lt;ensemble [2]&gt; ENSEMBLE (WEIGHTED): 2 MODELS Test  &lt;tibble [52 x 4]&gt;
</pre></div>
<p>We can verify the loadings have been applied correctly. Note that the loadings will be
applied based on the model with the lowest RMSE.
</p>
<div class="sourceCode r"><pre>ensem %&gt;%
    extract_nested_modeltime_table(1) %&gt;%
    slice(3) %&gt;%
    pluck(".model", 1)
</pre></div>
<p>Note that the xgboost model gets the 66% loading and prophet gets 33% loading.
This is because xgboost has the lower RMSE in this case.
</p>
<div class="sourceCode r"><pre>-- Modeltime Ensemble -------------------------------------------
    Ensemble of 2 Models (WEIGHTED)

# Modeltime Table
# A tibble: 2 x 6
  .model_id .model     .model_desc .type .calibration_data .loadings
      &lt;int&gt; &lt;list&gt;     &lt;chr&gt;       &lt;chr&gt; &lt;list&gt;                &lt;dbl&gt;
1         1 &lt;workflow&gt; PROPHET     Test  &lt;tibble [52 x 4]&gt;     0.333
2         2 &lt;workflow&gt; XGBOOST     Test  &lt;tibble [52 x 4]&gt;     0.667
</pre></div>


<h3>Value</h3>

<p>The nested modeltime table with an ensemble model added.
</p>

<hr>
<h2 id='ensemble_weighted'>Creates a Weighted Ensemble Model</h2><span id='topic+ensemble_weighted'></span>

<h3>Description</h3>

<p>Makes an ensemble by applying <code>loadings</code> to weight sub-model predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble_weighted(object, loadings, scale_loadings = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensemble_weighted_+3A_object">object</code></td>
<td>
<p>A Modeltime Table</p>
</td></tr>
<tr><td><code id="ensemble_weighted_+3A_loadings">loadings</code></td>
<td>
<p>A vector of weights corresponding to the loadings</p>
</td></tr>
<tr><td><code id="ensemble_weighted_+3A_scale_loadings">scale_loadings</code></td>
<td>
<p>If TRUE, divides by the sum of the loadings
to proportionally weight the submodels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input to an <code>ensemble_weighted()</code> model is always a Modeltime Table,
which contains the models that you will ensemble.
</p>
<p><strong>Weighting Method</strong>
</p>
<p>The weighted method uses uses <code>loadings</code> by applying a
<em>loading x model prediction</em> for each submodel.
</p>


<h3>Value</h3>

<p>A <code>mdl_time_ensemble</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidymodels)
library(modeltime)
library(modeltime.ensemble)
library(tidyverse)
library(timetk)

# Make an ensemble from a Modeltime Table
ensemble_fit &lt;- m750_models %&gt;%
    ensemble_weighted(
        loadings = c(3, 3, 1),
        scale_loadings = TRUE
    )

ensemble_fit

# Forecast with the Ensemble
modeltime_table(
    ensemble_fit
) %&gt;%
    modeltime_forecast(
        new_data    = testing(m750_splits),
        actual_data = m750
    ) %&gt;%
    plot_modeltime_forecast(
        .interactive = FALSE,
        .conf_interval_show = FALSE
    )


</code></pre>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+expr'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+.data'></span><span id='topic++3A+3D'></span><span id='topic+as_name'></span><span id='topic+as_label'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="rlang.html#topic+sym">sym</a>()</code> creates a symbol from a string and
<code><a href="rlang.html#topic+sym">syms</a>()</code> creates a list of symbols from a
character vector.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">enquo</a>()</code> and
<code><a href="rlang.html#topic+nse-defuse">enquos</a>()</code> delay the execution of one or
several function arguments. <code>enquo()</code> returns a single quoted
expression, which is like a blueprint for the delayed computation.
<code>enquos()</code> returns a list of such quoted expressions.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+nse-defuse">expr</a>()</code> quotes a new expression <em>locally</em>. It
is mostly useful to build new expressions around arguments
captured with <code><a href="#topic+enquo">enquo()</a></code> or <code><a href="#topic+enquos">enquos()</a></code>:
<code>expr(mean(!!enquo(arg), na.rm = TRUE))</code>.
</p>
</li>
<li> <p><code><a href="rlang.html#topic+as_name">as_name</a>()</code> transforms a quoted variable name
into a string. Supplying something else than a quoted variable
name is an error.
</p>
<p>That's unlike <code><a href="rlang.html#topic+as_label">as_label</a>()</code> which also returns
a single string but supports any kind of R object as input,
including quoted function calls and vectors. Its purpose is to
summarise that object into a single label. That label is often
suitable as a default name.
</p>
<p>If you don't know what a quoted expression contains (for instance
expressions captured with <code>enquo()</code> could be a variable
name, a call to a function, or an unquoted constant), then use
<code>as_label()</code>. If you know you have quoted a simple variable
name, or would like to enforce this, use <code>as_name()</code>.
</p>
</li></ul>

<p>To learn more about tidy eval and how to use these tools, visit the
<a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming
section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a>.
</p>


<h3>Value</h3>

<p>Nothing.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
