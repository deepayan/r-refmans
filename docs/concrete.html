<!DOCTYPE html><html><head><title>Help for package concrete</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {concrete}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#concrete-package'>
<p>One-step continuous-time Targeted Minimum Loss-Based Estimator (TMLE) for outcome-specific absolute risk estimands in right-censored survival settings with or without competing risks</p></a></li>
<li><a href='#doConcrete'><p>doConcrete</p></a></li>
<li><a href='#doTmleUpdate'><p>Title</p></a></li>
<li><a href='#formatArguments'><p>formatArguments</p></a></li>
<li><a href='#getEIC'><p>get EICs</p></a></li>
<li><a href='#getHazFit'><p>Title</p></a></li>
<li><a href='#getInitialEstimate'><p>getInitialEstimate</p></a></li>
<li><a href='#getOutput'><p>getOutput</p></a></li>
<li><a href='#getPropScore'><p>getPropScore</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous-Time Competing Risks Estimation using Targeted
Minimum Loss-Based Estimation (TMLE)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-07</td>
</tr>
<tr>
<td>Author:</td>
<td>David Chen <a href="https://orcid.org/0000-0002-9413-8152"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Chen &lt;david.chen49@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>One-step continuous-time Targeted Minimum Loss-Based Estimation (TMLE) for outcome-specific absolute risk estimands in right-censored survival settings with or without competing risks, implementing the methodology described in Rytgaard et al. (2023) &lt;<a href="https://doi.org/10.1111%2Fbiom.13856">doi:10.1111/biom.13856</a>&gt; and Rytgaard and van der Laan (2023) &lt;<a href="https://doi.org/10.1007%2Fs10985-022-09576-2">doi:10.1007/s10985-022-09576-2</a>&gt;. Currently 'concrete' can be used to estimate the effects of static or dynamic interventions on binary treatments given at baseline, cross-validated initial estimation of treatment propensity is done using the 'SuperLearner' package, and initial estimation of conditional hazards is done using ensembles of Cox regressions from the 'survival' package or Coxnet from the 'glmnet' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, survival, zoo, origami, SuperLearner, nleqslv,
MASS, Rcpp (&ge; 1.0.11)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nnls, xgboost, glmnet, ranger, ggplot2, testthat (&ge; 3.0.0),
knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/imbroglio-dc/concrete">https://github.com/imbroglio-dc/concrete</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/imbroglio-dc/concrete/issues">https://github.com/imbroglio-dc/concrete/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-09 16:02:53 UTC; imbroglio</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-10 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='concrete-package'>
One-step continuous-time Targeted Minimum Loss-Based Estimator (TMLE) for outcome-specific absolute risk estimands in right-censored survival settings with or without competing risks
</h2><span id='topic+concrete-package'></span><span id='topic+concrete'></span>

<h3>Description</h3>

<p>Implements the methodology described in Rytgaard et al. (2023) &lt;doi:10.1111/biom.13856&gt; and Rytgaard and van der Laan (2023) &lt;doi:10.1007/s10985-022-09576-2&gt;. Currently can be used to estimate the effects of static or dynamic interventions on binary treatments given at baseline, cross-validated initial estimation of treatment propensity is done using the 'SuperLearner' package, and initial estimation of conditional hazards is done using ensembles of Cox regressions from the 'survival' package or Coxnet from the 'glmnet' package.
</p>


<h3>Details</h3>

<p>formatArguments()
many check...(), format...() functions
getInitialEstimates()
getPropScores()
getHazEstimates()
getEIC()
getIC()
doTMLEUpdate()
getOutput()
</p>


<h3>Author(s)</h3>

<p>David Chen, &lt;david.chen49@berkeley.edu&gt;
Maintainer: David Chen &lt;david.chen49@berkeley.edu&gt;
</p>


<h3>References</h3>

<p>Rytgaard et al. (2023) &lt;doi:10.1111/biom.13856&gt;  
Rytgaard and van der Laan (2023) &lt;doi:10.1007/s10985-022-09576-2&gt;
</p>


<h3>See Also</h3>

<p><a href="SuperLearner.html#topic+SuperLearner">SuperLearner</a>  
<a href="survival.html#topic+coxph">coxph</a>
<a href="glmnet.html#topic+glmnet">glmnet</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(concrete)
library(data.table)
set.seed(12345)
data &lt;- as.data.table(survival::pbc)
data &lt;- data[!is.na(trt), ][, trt := trt - 1]
data &lt;- data[, c("time", "status", "trt", "age", "sex", "albumin")]

ConcreteArgs &lt;- formatArguments(DataTable = data,
                                EventTime = "time",
                                EventType = "status",
                                Treatment = "trt",
                                Intervention = 0:1,
                                TargetTime = 1500,
                                TargetEvent = 1:2,
                                MaxUpdateIter = 250,
                                CVArg = list(V = 10),
                                Verbose = FALSE)
ConcreteEst &lt;- doConcrete(ConcreteArgs)
ConcreteOut &lt;- getOutput(ConcreteEst)


## Joint Intervention
data &lt;- data[, trt2 := sample(0:1, .N, replace = TRUE, prob = c(0.3, .7))]
Intervention &lt;- makeITT("A1" = data.frame(trt = rep_len(1, nrow(data)), 
                                          trt2 = rep_len(1, nrow(data))), 
                        "A0" = data.frame(trt = rep_len(0, nrow(data)), 
                                          trt2 = rep_len(0, nrow(data))))

ConcreteArgs &lt;- formatArguments(DataTable = data,
                                EventTime = "time",
                                EventType = "status",
                                Treatment = c("trt", "trt2"),
                                Intervention = Intervention,
                                TargetTime = 2000,
                                TargetEvent = 1:2,
                                MaxUpdateIter = 250,
                                CVArg = list(V = 10),
                                Verbose = FALSE)
ConcreteEst &lt;- doConcrete(ConcreteArgs)
ConcreteOut &lt;- getOutput(ConcreteEst)

</code></pre>

<hr>
<h2 id='doConcrete'>doConcrete</h2><span id='topic+doConcrete'></span><span id='topic+print.ConcreteEst'></span><span id='topic+plot.ConcreteEst'></span><span id='topic+print.ConcreteOut'></span>

<h3>Description</h3>

<p>doConcrete
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doConcrete(ConcreteArgs)

## S3 method for class 'ConcreteEst'
print(x, ...)

## S3 method for class 'ConcreteEst'
plot(x, convergence = FALSE, gweights = TRUE, ask = FALSE, ...)

## S3 method for class 'ConcreteOut'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doConcrete_+3A_concreteargs">ConcreteArgs</code></td>
<td>
<p>&quot;ConcreteArgs&quot; object : output of formatArguments()</p>
</td></tr>
<tr><td><code id="doConcrete_+3A_x">x</code></td>
<td>
<p>a ConcreteOut object</p>
</td></tr>
<tr><td><code id="doConcrete_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed into print methods</p>
</td></tr>
<tr><td><code id="doConcrete_+3A_convergence">convergence</code></td>
<td>
<p>logical: plot the PnEIC norms for each TMLE small update step</p>
</td></tr>
<tr><td><code id="doConcrete_+3A_gweights">gweights</code></td>
<td>
<p>logical: plot the densities of the intervention-related nuisance weights for each intervention</p>
</td></tr>
<tr><td><code id="doConcrete_+3A_ask">ask</code></td>
<td>
<p>logical: whether or not to prompt for user input before displaying plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object with s3 class &quot;ConcreteEst&quot;
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print(ConcreteEst)</code>: print.ConcreteEst print method for &quot;ConcreteEst&quot; class
</p>
</li>
<li> <p><code>plot(ConcreteEst)</code>: plot.ConcreteEst plot method for &quot;ConcreteEst&quot; class
</p>
</li>
<li> <p><code>print(ConcreteOut)</code>: print.ConcreteOut print method for &quot;ConcreteOut&quot; class
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(concrete)

data &lt;- as.data.table(survival::pbc)
data &lt;- data[1:200, .SD, .SDcols = c("id", "time", "status", "trt", "age", "sex")]
data[, trt := sample(0:1, nrow(data), TRUE)]

# formatArguments() returns correctly formatted arguments for doConcrete()

concrete.args &lt;- formatArguments(DataTable = data,
                                 EventTime = "time",
                                 EventType = "status",
                                 Treatment = "trt",
                                 ID = "id",
                                 TargetTime = 2500,
                                 TargetEvent = c(1, 2),
                                 Intervention = makeITT(),
                                 CVArg = list(V = 2))
                                 
# doConcrete() returns tmle (and g-formula plug-in) estimates of targeted risks
concrete.est &lt;- doConcrete(concrete.args)
</code></pre>

<hr>
<h2 id='doTmleUpdate'>Title</h2><span id='topic+doTmleUpdate'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doTmleUpdate(
  Estimates,
  SummEIC,
  Data,
  TargetEvent,
  TargetTime,
  MaxUpdateIter,
  OneStepEps,
  NormPnEIC,
  Verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doTmleUpdate_+3A_estimates">Estimates</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="doTmleUpdate_+3A_summeic">SummEIC</code></td>
<td>
<p>data.table</p>
</td></tr>
<tr><td><code id="doTmleUpdate_+3A_data">Data</code></td>
<td>
<p>data.table</p>
</td></tr>
<tr><td><code id="doTmleUpdate_+3A_targetevent">TargetEvent</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="doTmleUpdate_+3A_targettime">TargetTime</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="doTmleUpdate_+3A_maxupdateiter">MaxUpdateIter</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="doTmleUpdate_+3A_onestepeps">OneStepEps</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="doTmleUpdate_+3A_normpneic">NormPnEIC</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="doTmleUpdate_+3A_verbose">Verbose</code></td>
<td>
<p>boolean</p>
</td></tr>
</table>

<hr>
<h2 id='formatArguments'>formatArguments</h2><span id='topic+formatArguments'></span><span id='topic+makeITT'></span><span id='topic+print.ConcreteArgs'></span>

<h3>Description</h3>

<p>formatArguments() checks and reformats inputs into a form that can be interpreted by doConcrete().
makeITT() returns an Intervention list for a single, binary, point-treatment variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatArguments(
  DataTable,
  EventTime,
  EventType,
  Treatment,
  ID = NULL,
  TargetTime = NULL,
  TargetEvent = NULL,
  Intervention,
  CVArg = NULL,
  Model = NULL,
  MaxUpdateIter = 500,
  OneStepEps = 0.1,
  MinNuisance = 5/sqrt(nrow(DataTable))/log(nrow(DataTable)),
  Verbose = TRUE,
  GComp = TRUE,
  ReturnModels = TRUE,
  ConcreteArgs = NULL,
  RenameCovs = TRUE,
  ...
)

makeITT(...)

## S3 method for class 'ConcreteArgs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatArguments_+3A_datatable">DataTable</code></td>
<td>
<p>data.table (n x (d + (3:5)); data.table of the observed data, with rows n =
the number of observations and d = the number of baseline covariates. DataTable must include
the following columns:
</p>

<ul>
<li><p>&quot;EventTime&quot;: numeric; real numbers &gt; 0, the observed event or censoring time
</p>
</li>
<li><p>&quot;EventType&quot;: numeric; the observed event type, censoring events indicated by integers &lt;= 0
</p>
</li>
<li><p>&quot;Treatment&quot;: numeric; the observed treatment value. Binary treatments must be coded as 0, 1
</p>
</li>
<li><p>&quot;Treatment&quot;: numeric; the observed treatment
</p>
</li></ul>

<p>May include
</p>

<ul>
<li><p>&quot;ID&quot;: factor, character, or numeric; unique subject id. If ID column is missing, row
numbers will be used as ID. For longitudinal data, ID must be provided
</p>
</li>
<li><p>&quot;Baseline Covariates&quot;: factor, character, or numeric; 
</p>
</li></ul>
</td></tr>
<tr><td><code id="formatArguments_+3A_eventtime">EventTime</code></td>
<td>
<p>character: the column name of the observed event or censoring time</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_eventtype">EventType</code></td>
<td>
<p>character: the column name of the observed event type. (0 indicating censoring)</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_treatment">Treatment</code></td>
<td>
<p>character: the column name of the observed treatment assignment</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_id">ID</code></td>
<td>
<p>character (default: NULL): the column name of the observed subject id
longitudinal data structures</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_targettime">TargetTime</code></td>
<td>
<p>numeric: vector of target times. If NULL, the last observed non-censoring event
time will be targeted.</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_targetevent">TargetEvent</code></td>
<td>
<p>numeric: vector of target events - some subset of unique EventTypes. If NULL,
all non-censoring observed event types will be targeted.</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_intervention">Intervention</code></td>
<td>
<p>list: a list of desired interventions on the treatment variable.
Each intervention must be a list containing two named functions:
'intervention' = function(treatment vector, covariate data) and
'gstar' = function(treatment vector, covariate data)
concrete::makeITT() can be used to specify an intent-to-treat analysis for a
binary intervention variable</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_cvarg">CVArg</code></td>
<td>
<p>list: arguments to be passed into do.call(origami::make_folds). If NULL, the default is
list(n = nrow(DataTable), fold_fun = folds_vfold, cluster_ids = NULL, strata_ids = NULL)</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_model">Model</code></td>
<td>
<p>list (default: NULL): named list of models, one for each failure or censoring event
and one for the 'Treatment' variable. If Model = NULL, then
a template will be generated for the user to amend.</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_maxupdateiter">MaxUpdateIter</code></td>
<td>
<p>numeric (default: 500): the number of one-step update steps</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_onestepeps">OneStepEps</code></td>
<td>
<p>numeric (default: 1): the one-step tmle step size</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_minnuisance">MinNuisance</code></td>
<td>
<p>numeric (default: 5/log(n)/sqrt(n)): value between (0, 1) for truncating the g-related denominator of the clever covariate</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_verbose">Verbose</code></td>
<td>
<p>boolean</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_gcomp">GComp</code></td>
<td>
<p>boolean (default: TRUE): return g-computation formula plug-in estimates</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_returnmodels">ReturnModels</code></td>
<td>
<p>boolean (default: TRUE): return fitted models from the initial estimation stage</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_concreteargs">ConcreteArgs</code></td>
<td>
<p>list (default: NULL, not yet ready) : Use to recheck amended output from previous formatArguments()
calls. A non-NULL input will cause all other arguments to be ignored.</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_renamecovs">RenameCovs</code></td>
<td>
<p>boolean (default: TRUE): whether or not to rename covariates</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed into print methods</p>
</td></tr>
<tr><td><code id="formatArguments_+3A_x">x</code></td>
<td>
<p>a ConcreteArgs object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class &quot;ConcreteArgs&quot;
</p>

<ul>
<li><p>Data: data.table containing EventTime, EventType, Treatment, and potentially ID and baseline covariates. Has the following attributes
</p>

<ul>
<li><p>EventTime: the column name of the observed event or censoring time
</p>
</li>
<li><p>EventType: the column name of the observed event type. (0 indicating censoring)
</p>
</li>
<li><p>Treatment: the column name of the observed treatment assignment
</p>
</li>
<li><p>ID: the column name of the observed subject id
</p>
</li>
<li><p>RenameCovs: boolean whether or not covariates are renamed
</p>
</li></ul>

</li>
<li><p>TargetTime: numeric vector of target times to evaluate risk/survival
</p>
</li>
<li><p>TargetEvent: numeric vector of target events
</p>
</li>
<li><p>Regime: named list of desired regimes, each tagged with a 'g.star' attribute function
</p>

<ul>
<li><p>Regime[[i]]: a vector of desired treatment assignments
</p>
</li>
<li><p>attr(Regime[[i]], &quot;g.star&quot;): function of Treatment and Covariates, outputting a vector of desired treatment assignment probabilities
</p>
</li></ul>

</li>
<li><p>CVFolds: list of cross-validation fold assignments in the structure as output by origami::make_folds()
</p>
</li>
<li><p>Model: named list of model specifications, one for each unique 'EventType' and one for the 'Treatment' variable.
</p>
</li>
<li><p>MaxUpdateIter: the number of one-step update steps
</p>
</li>
<li><p>OneStepEps: list of cross-validation fold assignments in the structure as output by origami::make_folds()
</p>
</li>
<li><p>MinNuisance: numeric lower bound for the propensity score denominator in the efficient influence function
</p>
</li>
<li><p>Verbose: boolean to print additional information
</p>
</li>
<li><p>GComp: boolean to return g-computation formula plug-in estimates
</p>
</li>
<li><p>ReturnModels: boolean to return fitted models from the initial estimation stage
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>makeITT()</code>: makeITT ...
</p>
</li>
<li> <p><code>print(ConcreteArgs)</code>: print.ConcreteArgs print method for &quot;ConcreteArgs&quot; class
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(concrete)

data &lt;- as.data.table(survival::pbc)
data &lt;- data[1:200, .SD, .SDcols = c("id", "time", "status", "trt", "age", "sex")]
data[, trt := sample(0:1, nrow(data), TRUE)]

# makeITT() creates a list of functions to specify intent-to-treat
#   regimes for a binary, single, point treatment variable
intervention &lt;- makeITT()

# formatArguments() returns correctly formatted arguments for doConcrete()
#   If no input is provided for the Model argument, a default will be generated
concrete.args &lt;- formatArguments(DataTable = data,
                                 EventTime = "time",
                                 EventType = "status",
                                 Treatment = "trt",
                                 ID = "id",
                                 TargetTime = 2500,
                                 TargetEvent = c(1, 2),
                                 Intervention = intervention,
                                 CVArg = list(V = 2))

# Alternatively, estimation algorithms can be provided as a named list
model &lt;- list("trt" = c("SL.glm", "SL.glmnet"),
              "0" = list(Surv(time, status == 0) ~ .),
              "1" = list(Surv(time, status == 1) ~ .),
              "2" = list(Surv(time, status == 2) ~ .))
concrete.args &lt;- formatArguments(DataTable = data,
                                 EventTime = "time",
                                 EventType = "status",
                                 Treatment = "trt",
                                 ID = "id",
                                 TargetTime = 2500,
                                 TargetEvent = c(1, 2),
                                 Intervention = intervention,
                                 CVArg = list(V = 2), 
                                 Model = model)

# 'ConcreteArgs' output can be modified and passed back through formatArguments()
# examples of modifying the censoring and failure event candidate regressions
concrete.args[["Model"]][["0"]] &lt;-
    list(Surv(time, status == 0) ~ trt:sex + age)
concrete.args[["Model"]][["1"]] &lt;-
    list("mod1" = Surv(time, status == 1) ~ trt,
         "mod2" = Surv(time, status == 1) ~ .)
formatArguments(concrete.args)

</code></pre>

<hr>
<h2 id='getEIC'>get EICs</h2><span id='topic+getEIC'></span>

<h3>Description</h3>

<p>get EICs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEIC(
  Estimates,
  Data,
  Regime,
  TargetEvent,
  TargetTime,
  MinNuisance,
  GComp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEIC_+3A_estimates">Estimates</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="getEIC_+3A_data">Data</code></td>
<td>
<p>data.table</p>
</td></tr>
<tr><td><code id="getEIC_+3A_regime">Regime</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="getEIC_+3A_targetevent">TargetEvent</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="getEIC_+3A_targettime">TargetTime</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="getEIC_+3A_minnuisance">MinNuisance</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="getEIC_+3A_gcomp">GComp</code></td>
<td>
<p>boolean</p>
</td></tr>
</table>

<hr>
<h2 id='getHazFit'>Title</h2><span id='topic+getHazFit'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHazFit(Data, Model, CVFolds, Hazards, ReturnModels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHazFit_+3A_data">Data</code></td>
<td>
<p>data.table</p>
</td></tr>
<tr><td><code id="getHazFit_+3A_model">Model</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="getHazFit_+3A_cvfolds">CVFolds</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="getHazFit_+3A_hazards">Hazards</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="getHazFit_+3A_returnmodels">ReturnModels</code></td>
<td>
<p>boolean</p>
</td></tr>
</table>

<hr>
<h2 id='getInitialEstimate'>getInitialEstimate</h2><span id='topic+getInitialEstimate'></span>

<h3>Description</h3>

<p>getInitialEstimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInitialEstimate(
  Data,
  Model,
  CVFolds,
  MinNuisance,
  TargetEvent,
  TargetTime,
  Regime,
  ReturnModels
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInitialEstimate_+3A_data">Data</code></td>
<td>
<p>data.table</p>
</td></tr>
<tr><td><code id="getInitialEstimate_+3A_model">Model</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="getInitialEstimate_+3A_cvfolds">CVFolds</code></td>
<td>
<p>: list</p>
</td></tr>
<tr><td><code id="getInitialEstimate_+3A_minnuisance">MinNuisance</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="getInitialEstimate_+3A_targetevent">TargetEvent</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="getInitialEstimate_+3A_targettime">TargetTime</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="getInitialEstimate_+3A_regime">Regime</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="getInitialEstimate_+3A_returnmodels">ReturnModels</code></td>
<td>
<p>boolean</p>
</td></tr>
</table>

<hr>
<h2 id='getOutput'>getOutput</h2><span id='topic+getOutput'></span><span id='topic+plot.ConcreteOut'></span>

<h3>Description</h3>

<p>getOutput
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOutput(
  ConcreteEst,
  Estimand = c("Risk"),
  Intervention = seq_along(ConcreteEst),
  GComp = NULL,
  Simultaneous = TRUE,
  Signif = 0.05
)

## S3 method for class 'ConcreteOut'
plot(x, NullLine = TRUE, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOutput_+3A_concreteest">ConcreteEst</code></td>
<td>
<p>&quot;ConcreteEst&quot; object</p>
</td></tr>
<tr><td><code id="getOutput_+3A_estimand">Estimand</code></td>
<td>
<p>character: &quot;RR&quot; for Relative Risks, &quot;RD&quot; for Risk Differences, and &quot;Risk&quot; for absolute risks</p>
</td></tr>
<tr><td><code id="getOutput_+3A_intervention">Intervention</code></td>
<td>
<p>numeric (default = seq_along(ConcreteEst)): the ConcreteEst list element
corresponding to the target intervention. For comparison estimands such as RD and RR,
Intervention should be a numeric vector with length 2, the first term designating
&quot;treatment&quot; ConcreteEst list element and the second designating the &quot;control&quot;.</p>
</td></tr>
<tr><td><code id="getOutput_+3A_gcomp">GComp</code></td>
<td>
<p>logical: return g-formula point estimates based on initial nuisance parameter estimation</p>
</td></tr>
<tr><td><code id="getOutput_+3A_simultaneous">Simultaneous</code></td>
<td>
<p>logical: return simultaneous confidence intervals</p>
</td></tr>
<tr><td><code id="getOutput_+3A_signif">Signif</code></td>
<td>
<p>numeric (default = 0.05): alpha for 2-tailed hypothesis testing</p>
</td></tr>
<tr><td><code id="getOutput_+3A_x">x</code></td>
<td>
<p>a ConcreteOut object</p>
</td></tr>
<tr><td><code id="getOutput_+3A_nullline">NullLine</code></td>
<td>
<p>logical: to plot a red line at y=1 for RR plots and at y=0 for RD plots</p>
</td></tr>
<tr><td><code id="getOutput_+3A_ask">ask</code></td>
<td>
<p>logical: to prompt for user input before each plot</p>
</td></tr>
<tr><td><code id="getOutput_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed into plot methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table of point estimates and standard deviations
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(ConcreteOut)</code>: plot.ConcreteOut plot method for &quot;ConcreteOut&quot; class
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(concrete)

data &lt;- as.data.table(survival::pbc)
data &lt;- data[1:200, .SD, .SDcols = c("id", "time", "status", "trt", "age", "sex")]
data[, trt := sample(0:1, nrow(data), TRUE)]

# formatArguments() returns correctly formatted arguments for doConcrete()
concrete.args &lt;- formatArguments(DataTable = data,
                                 EventTime = "time",
                                 EventType = "status",
                                 Treatment = "trt",
                                 ID = "id",
                                 TargetTime = 2500,
                                 TargetEvent = c(1, 2),
                                 Intervention = makeITT(),
                                 CVArg = list(V = 2))
                                 
# doConcrete() returns tmle (and g-formula plug-in) estimates of targeted risks

concrete.est &lt;- doConcrete(concrete.args)

# getOutput returns risk difference, relative risk, and treatment-specific risks
#  GComp=TRUE returns g-formula plug-in estimates
#  Simultaneous=TRUE computes simultaneous CI for all output TMLE estimates 
concrete.out &lt;- getOutput(concrete.est, Estimand = c("RR", "RD", "Risk"),
                          GComp = TRUE, Simultaneous = TRUE)
print(concrete.out)
plot(concrete.out, ask = FALSE)

</code></pre>

<hr>
<h2 id='getPropScore'>getPropScore</h2><span id='topic+getPropScore'></span>

<h3>Description</h3>

<p>getPropScore
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPropScore(
  TrtVal,
  CovDT,
  TrtModel,
  MinNuisance,
  Regime,
  CVFolds,
  TrtLoss = NULL,
  ReturnModels
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPropScore_+3A_trtval">TrtVal</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="getPropScore_+3A_covdt">CovDT</code></td>
<td>
<p>data.table</p>
</td></tr>
<tr><td><code id="getPropScore_+3A_trtmodel">TrtModel</code></td>
<td>
<p>list or fitted object</p>
</td></tr>
<tr><td><code id="getPropScore_+3A_minnuisance">MinNuisance</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="getPropScore_+3A_regime">Regime</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="getPropScore_+3A_cvfolds">CVFolds</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="getPropScore_+3A_trtloss">TrtLoss</code></td>
<td>
<p>character or function(A, g.A)</p>
</td></tr>
<tr><td><code id="getPropScore_+3A_returnmodels">ReturnModels</code></td>
<td>
<p>boolean</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
