<!DOCTYPE html><html lang="en-US"><head><title>Help for package Indicator</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Indicator}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Indicator-package'><p>Indicator: A package for constructing composite indicators, imputing and evaluating missing data imputation</p></a></li>
<li><a href='#columns_with_nan'><p>Function to get the names of the columns with NAN values</p></a></li>
<li><a href='#compute_CI'><p>Calculation of Condition Indices</p></a></li>
<li><a href='#Education'><p>Education</p></a></li>
<li><a href='#geometric_aggregation'><p>Geometric Aggregation</p></a></li>
<li><a href='#get_all_performance'><p>Function to evaluate different nan imputation methods</p></a></li>
<li><a href='#get_all_performance_boot'><p>Function to evaluate different nan imputation methods with bootstrap</p></a></li>
<li><a href='#Jevons_aggregation'><p>Jevons static aggregation</p></a></li>
<li><a href='#linear_aggregation'><p>Linear Aggregation</p></a></li>
<li><a href='#linear_aggregation_AMPI'><p>Adjusted Mazziotta-Pareto index</p></a></li>
<li><a href='#linear_aggregation_MPI'><p>Mazziotta-Pareto index</p></a></li>
<li><a href='#lm_imputation'><p>Function to apply nan inputation with linear regression</p></a></li>
<li><a href='#MAD'><p>Mean absolute difference of rank</p></a></li>
<li><a href='#min_max'><p>Min-max normalization</p></a></li>
<li><a href='#min_max_GM'><p>Normalization for the Geometric Mean</p></a></li>
<li><a href='#normalization_abov_below_mean'><p>Normalization above or below the mean</p></a></li>
<li><a href='#pca_weighting'><p>Function that weight the quantitative variable by PCA method</p></a></li>
<li><a href='#performance_nan_imputation'><p>Function to evaluate nan imputation method's performance</p></a></li>
<li><a href='#rank_aggregation'><p>Ranking Aggregation</p></a></li>
<li><a href='#rank_normalisation'><p>Rank normalization</p></a></li>
<li><a href='#standardization'><p>Standardization</p></a></li>
<li><a href='#Standardization_AMPI'><p>Standardization of data with Adjusted Maziotta-Pareto index</p></a></li>
<li><a href='#standardization_MPI'><p>Standardization of data with Maziotta-Pareto index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Composite 'Indicator' Construction and Imputation Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gianmarco Borrata &lt;gianmarco.borrata@unina.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Different functions includes constructing composite indicators, imputing missing data, and evaluating imputation techniques. Additionally, different tools for data normalization. Detailed methodologies of  'Indicator' package are: OECD/European Union/EC-JRC (2008), "Handbook on Constructing Composite Indicators: Methodology and User Guide", OECD Publishing, Paris, &lt;<a href="https://doi.org/10.1787%2F533411815016">doi:10.1787/533411815016</a>&gt;, Matteo Mazziotta &amp; Adriano Pareto, (2018) "Measuring Well-Being Over Time: The Adjusted Mazziotta–Pareto Index Versus Other Non-compensatory Indices" &lt;<a href="https://doi.org/10.1007%2Fs11205-017-1577-5">doi:10.1007/s11205-017-1577-5</a>&gt; and De Muro P., Mazziotta M., Pareto A. (2011), "Composite Indices  of Development and Poverty: An Application to MDGs" &lt;<a href="https://doi.org/10.1007%2Fs11205-010-9727-z">doi:10.1007/s11205-010-9727-z</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>FactoMineR, missMethods, stats, norm</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/GianmarcoBorrata/Indicator">https://github.com/GianmarcoBorrata/Indicator</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GianmarcoBorrata/Indicator/issues">https://github.com/GianmarcoBorrata/Indicator/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-27 22:17:49 UTC; gianmarcoborrata</td>
</tr>
<tr>
<td>Author:</td>
<td>Gianmarco Borrata [aut, cre],
  Pasquale Pipiciello [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-27 22:40:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='Indicator-package'>Indicator: A package for constructing composite indicators, imputing and evaluating missing data imputation</h2><span id='topic+Indicator'></span><span id='topic+Indicator-package'></span>

<h3>Description</h3>

<p>Provides three main categories of functions: construction of composite indicators, imputation and evaluation of missing data, and data normalization.
</p>


<h3>Details</h3>

<p>Key features include:
</p>

<ul>
<li><p> Construction of composite indicators, such as Mazziotta-Pareto Index, Adjusted Mazziotta-Pareto Index, Geometric aggregation, Linear aggregation, and other functions;
</p>
</li>
<li><p> Imputation of missing data through techniques such as Linear Regression Imputation, Hot Deck Imputation, etc;
</p>
</li>
<li><p> Evaluation of missing data imputation using metrics such as R^2, RMSE, and MAE;
</p>
</li>
<li><p> Several functions to standardize and normalize data, such as Standardization by Adjusted Mazziotta-Pareto method, Normalization by Adjusted Mazziotta-Pareto method, and other functions.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gianmarco Borrata &lt;gianmarco.borrata@unina.it&gt; and
Pasquale Pipiciello &lt;pasqualepipiciello24@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p>OECD/European Union/EC-JRC (2008), &quot;Handbook on Constructing Composite Indicators: Methodology and User Guide&quot;, OECD Publishing, Paris, &lt;DOI:10.1787/533411815016&gt;
</p>
</li>
<li><p>Matteo Mazziotta &amp; Adriano Pareto (2018), &quot;Measuring Well-Being Over Time: The Adjusted Mazziotta–Pareto Index Versus Other Non-compensatory Indices&quot;,Social Indicators Research, Springer, vol. 136(3), pages 967-976, April &lt;DOI:10.1007/s11205-017-1577-5&gt;
</p>
</li>
<li><p>De Muro P., Mazziotta M., Pareto A. (2011), &quot;Composite Indices of Development and Poverty: An Application to MDGs&quot;,Social Indicators Research, Volume 104, Number 1, pp. 1-18 &lt;DOI:10.1007/s11205-010-9727-z&gt;
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/GianmarcoBorrata/Indicator">https://github.com/GianmarcoBorrata/Indicator</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/GianmarcoBorrata/Indicator/issues">https://github.com/GianmarcoBorrata/Indicator/issues</a>
</p>
</li></ul>


<hr>
<h2 id='columns_with_nan'>Function to get the names of the columns with NAN values</h2><span id='topic+columns_with_nan'></span>

<h3>Description</h3>

<p>This function identifies and returns the names of the columns in a DataFrame
that contain missing values (NaN). It is particularly useful for missing
data imputation and preliminary analysis, allowing for quick identification
of columns that need to be handled due to the presence of missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>columns_with_nan(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="columns_with_nan_+3A_data">data</code></td>
<td>
<p>The DataFrame's rows represent observations and the columns
represent variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a vector of columns with NAN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("airquality")
columns_with_nan(airquality)

</code></pre>

<hr>
<h2 id='compute_CI'>Calculation of Condition Indices</h2><span id='topic+compute_CI'></span>

<h3>Description</h3>

<p>Diagnosis of collinearity in matrix <code>X</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_CI(matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_CI_+3A_matrix">matrix</code></td>
<td>
<p>a matrix of data where rows = observations and columns =
variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Collinearities can inflate the variance of the estimated regression
coefficients and numerical stability. The condition indices are calculated
by the eigenvalues of the crossproduct matrix of the scaled but uncentered
explanatory variables. Indices &gt; 30 may indicate collinearity
</p>


<h3>Value</h3>

<p>It returns the condition index of the matrix
</p>


<h3>References</h3>

<p>Belsley, D. , Kuh, E. and Welsch, R. E. (1979), Regression
Diagnostics: Identifying Influential Data and Sources of Collinearity, John
Wiley (New York)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
compute_CI(Education)

</code></pre>

<hr>
<h2 id='Education'>Education</h2><span id='topic+Education'></span>

<h3>Description</h3>

<p>This dataset contains educational and cultural data related to Italian
regions. Each row represents a region, and there are 20 Italian regions. The
eight variables included in the dataset provide information on various
aspects of the educational system and cultural activities in the regions in
2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Education
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 8 variables:
</p>

<p>Participation in the school system of 4-5 year olds
</p>
<p>People with at least a high school diploma (25-64 years old)
</p>
<p>Graduates and other tertiary degrees (30-34 years)
</p>
<p>Participation in continuing education
</p>
<p>People earning a STEM tertiary degree in the year Cultural
</p>
<p>Participation outside the home
</p>
<p>Reading of books and newspapers
</p>
<p>Library use
</p>


<h3>Source</h3>

<p>https://www.istat.it/en/well-being-and-sustainability/the-measurement-of-well-being/indicators
</p>

<hr>
<h2 id='geometric_aggregation'>Geometric Aggregation</h2><span id='topic+geometric_aggregation'></span>

<h3>Description</h3>

<p>The purpose of the Geometric Aggregation function is to calculate a
synthetic index based on the geometric mean for a set of variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometric_aggregation(
  data,
  weights = rep(1/ncol(data), ncol(data)),
  geo_wo = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geometric_aggregation_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative</p>
</td></tr>
<tr><td><code id="geometric_aggregation_+3A_weights">weights</code></td>
<td>
<p>vector of weights (default all weights = 1/ ncol(dataframe))</p>
</td></tr>
<tr><td><code id="geometric_aggregation_+3A_geo_wo">geo_wo</code></td>
<td>
<p>(geometric mean workaround to deal with negative values),
positive number to make all variables positive</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply the product of each indicator to the power of its weight, all
raised the the power of the inverse of the sum of the weights
</p>
<p>The geometric mean is less compensatory than the arithmetic mean – low
values in one indicator only partially substitute high values in others. For
this reason, the geometric mean may sometimes be preferred when indicators
represent “essentials”. An example might be quality of life: a longer life
expectancy perhaps should not compensate severe restrictions on personal
freedoms
</p>


<h3>Value</h3>

<p>It returns a dataframe with rows = observations and column =
composite indicator
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Indicator=geometric_aggregation(Education)
print(Indicator)

#-----When there are negative values
set.seed(123)
Data=matrix(rnorm(100),nrow = 10,ncol = 10)
Indicator=geometric_aggregation(Data,geo_wo = 100)
print(Indicator)

</code></pre>

<hr>
<h2 id='get_all_performance'>Function to evaluate different nan imputation methods</h2><span id='topic+get_all_performance'></span>

<h3>Description</h3>

<p>The get_all_performance_boot function is designed to evaluate different
methods of imputing missing values into a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_performance(data, to_impute, regressors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_all_performance_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative
variables</p>
</td></tr>
<tr><td><code id="get_all_performance_+3A_to_impute">to_impute</code></td>
<td>
<p>string , name of the variables where there are NANs to
impute</p>
</td></tr>
<tr><td><code id="get_all_performance_+3A_regressors">regressors</code></td>
<td>
<p>vector of string with names of the variables to use to
apply 1st,4th imputation method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates performance metrics, such as:
</p>
<p>- <code class="reqn"> R^2 = [1/N * [({\sum_{i=1}^N(P_i - (\bar{P})(O_i -
(\bar{O})]/\sigma_{P}*\sigma_{O}]^2}</code>,
</p>
<p>- <code class="reqn">RMSE= (1/N * ({\sum_{i=1}^N(P_i - O_i)^2)^{1/2}}</code>
</p>
<p>and
</p>
<p>- <code class="reqn">MAE = 1/N * {\sum_{i=1}^N|{P_i - O_i}|}</code>
</p>
<p>for each imputation method
</p>
<p>Supported Imputation Methods:
</p>
<p>1. Linear Regression Imputation (lm_imputation): it uses a linear regression
model to predict and impute missing values
</p>
<p>2. Median Imputation (median_imputation): it replaces missing values with the
median of observed values
</p>
<p>3. Mean Imputation (mean_imputation): it replaces missing values with the mean
of observed values
</p>
<p>4. Hot Deck Imputation (hot_deck_imputation): it replaces missing values with
similar observed values
</p>
<p>5. Expectation-Maximization Imputation (EM_imputation): it uses the
Expectation-Maximization algorithm to estimate and impute missing values
</p>
<p>It evaluate different methods of imputing missing values and calculate
performance metrics for each method
</p>


<h3>Value</h3>

<p>It returns a performance measures dataframe with rows = methods
and columns = methods' performances
</p>


<h3>Note</h3>

<p>For the methods Median Imputation and Mean Imputation, it is not
possible to calculate the R^2 value.  This is because the standard deviation
is zero based on the following R^2 formula:
</p>
<p><code class="reqn"> R^2 = [1/N * [({\sum_{i=1}^N(P_i - (\bar{P})(O_i -
(\bar{O})]/\sigma_{P}*\sigma_{O}]^2}</code>
</p>
<p>where:
</p>
<p>- <code class="reqn">N</code> is the number of imputations,
</p>
<p>- <code class="reqn">O_i</code> are the observed data point,
</p>
<p>- <code class="reqn">P_i</code> are the imputed data point,
</p>
<p>- <code class="reqn">\bar{O}</code> are the average of the observed data,
</p>
<p>- <code class="reqn">\bar{P}</code> are the average of the imputed data,
</p>
<p>- <code class="reqn">\sigma_{P}</code> are the standard deviation of the imputed data,
</p>
<p>- <code class="reqn">\sigma_{O}</code> are the standard deviation of the observed data
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("airquality")
regressors&lt;-colnames(airquality[,c(3,4)])
suppressWarnings(get_all_performance(data =airquality,"Ozone",regressors = regressors))

</code></pre>

<hr>
<h2 id='get_all_performance_boot'>Function to evaluate different nan imputation methods with bootstrap</h2><span id='topic+get_all_performance_boot'></span>

<h3>Description</h3>

<p>The get_all_performance_boot function is designed to evaluate different
methods of imputing missing values into a dataset. The evaluation is
performed using bootstrapping to ensure robustness of the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_performance_boot(data, to_impute, regressors, nb = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_all_performance_boot_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative
variables</p>
</td></tr>
<tr><td><code id="get_all_performance_boot_+3A_to_impute">to_impute</code></td>
<td>
<p>string , name of the variables where there are NANs to
impute</p>
</td></tr>
<tr><td><code id="get_all_performance_boot_+3A_regressors">regressors</code></td>
<td>
<p>vector of string with names of the variables to use to
apply 1st, 4th imputation method</p>
</td></tr>
<tr><td><code id="get_all_performance_boot_+3A_nb">nb</code></td>
<td>
<p>number of bootstrap samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates performance metrics, such as:
</p>
<p>- <code class="reqn"> R^2= [1/N * [({\sum_{i=1}^N(P_i - (\bar{P})(O_i -
(\bar{O})]/\sigma_{P}*\sigma_{O}]^2}</code>,
</p>
<p>- <code class="reqn">RMSE= (1/N * ({\sum_{i=1}^N(P_i - O_i)^2)^{1/2}}</code>
</p>
<p>and
</p>
<p>- <code class="reqn">MAE = 1/N * {\sum_{i=1}^N|{P_i - O_i}|}</code>
</p>
<p>for each imputation method
</p>
<p>Supported Imputation Methods:
</p>
<p>1. Linear Regression Imputation (lm_imputation): it uses a linear regression
model to predict and impute missing values
</p>
<p>2. Median Imputation (median_imputation): it replaces missing values with the
median of observed values
</p>
<p>3. Mean Imputation (mean_imputation): it replaces missing values with the mean
of observed values
</p>
<p>4. Hot Deck Imputation (hot_deck_imputation): it replaces missing values with
similar observed values
</p>
<p>5. Expectation-Maximization Imputation (EM_imputation): it uses the
Expectation-Maximization algorithm to estimate and impute missing values
</p>
<p>Evaluate different methods of imputing missing values using bootstrapping
and calculate performance metrics for each method
</p>


<h3>Value</h3>

<p>It returns a performance measures dataframe with rows = methods
and columns = methods' performances averaged over bootstraps.
</p>


<h3>Note</h3>

<p>For the methods Median Imputation and Mean Imputation, it is not
possible to calculate the R^2 value.  This is because the standard deviation
is zero based on the following R^2 formula:
</p>
<p><code class="reqn"> R^2= [1/N * [({\sum_{i=1}^N(P_i - (\bar{P})(O_i -
(\bar{O})]/\sigma_{P}*\sigma_{O}]^2}</code>
</p>
<p>where:
</p>
<p>- <code class="reqn">N</code> is the number of imputations,
</p>
<p>- <code class="reqn">O_i</code> are the observed data point,
</p>
<p>- <code class="reqn">P_i</code> are the imputed data point,
</p>
<p>- <code class="reqn">\bar{O}</code> are the average of the observed data,
</p>
<p>- <code class="reqn">\bar{P}</code> are the average of the imputed data,
</p>
<p>- <code class="reqn">\sigma_{P}</code> are the standard deviation of the imputed data,
</p>
<p>- <code class="reqn">\sigma_{O}</code> are the standard deviation of the observed data.
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("airquality")
regressors&lt;-colnames(airquality[,c(3,4)])
suppressWarnings(get_all_performance_boot(data =airquality,"Ozone",regressors = regressors,nb=100))

</code></pre>

<hr>
<h2 id='Jevons_aggregation'>Jevons static aggregation</h2><span id='topic+Jevons_aggregation'></span>

<h3>Description</h3>

<p>The Jevons_aggregation function computes an index using the Jevons method of
static aggregation. This method calculates the geometric mean, multiplied
for 100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jevons_aggregation(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Jevons_aggregation_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative
variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a dataframe with rows = observations and column =
composite indicator
</p>


<h3>References</h3>

<p>Massoli, P., Mazziotta, M., Pareto, A., Rinaldelli, C. (2013).
Synthesis Methodologies and Spatial Analysis. Composite indices for BES,DAYS
OF RESEARCH IN ISTAT, NOVEMBER 10-11, 2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Indicator=Jevons_aggregation(Education)
print(Indicator)

</code></pre>

<hr>
<h2 id='linear_aggregation'>Linear Aggregation</h2><span id='topic+linear_aggregation'></span>

<h3>Description</h3>

<p>This is a function to apply linear aggregation index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_aggregation(data, weights = rep(1/ncol(data), ncol(data)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_aggregation_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative
variables</p>
</td></tr>
<tr><td><code id="linear_aggregation_+3A_weights">weights</code></td>
<td>
<p>vector of weights (default all weights = 1/ ncol(dataframe))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a dataframe with rows = observations and column =
composite indicator
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Indicator=linear_aggregation(Education)
print(Indicator)

</code></pre>

<hr>
<h2 id='linear_aggregation_AMPI'>Adjusted Mazziotta-Pareto index</h2><span id='topic+linear_aggregation_AMPI'></span>

<h3>Description</h3>

<p>The Adjusted Mazziotta-Pareto Index (AMPI) is a composite index for
summarizing a set of indicators that are assumed to be non-substitutable,
i.e., all components must be balanced. It is based on a non-linear function
which, starting from the arithmetic mean, introduces a penalty for the units
with unbalanced values of the indicators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_aggregation_AMPI(data, pol = "pos")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_aggregation_AMPI_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative variables</p>
</td></tr>
<tr><td><code id="linear_aggregation_AMPI_+3A_pol">pol</code></td>
<td>
<p>pol if not selected is &quot;positive&quot;&quot;, otherwise write &quot;neg&quot; (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ‘polarity’ of an indicator is the sign of the relation between the
indicator and the phenomenon to be measured ( + if the indicator represents
a dimension considered positive and - otherwise)
</p>


<h3>Value</h3>

<p>It returns a dataframe with rows = observations and column = composite indicator
</p>


<h3>References</h3>

<p>Matteo Mazziotta &amp; Adriano Pareto, 2018. &quot;Measuring Well-Being
Over Time: The Adjusted Mazziotta–Pareto Index Versus Other Non-compensatory
Indices,&quot; Social Indicators Research: An International and Interdisciplinary
Journal for Quality-of-Life Measurement, Springer, vol. 136(3), pages
967-976, April
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Indicator=linear_aggregation_AMPI(Education)
print(Indicator)

#----With negative polarity
Indicator_neg=linear_aggregation_AMPI(Education,"neg")
print(Indicator_neg)

</code></pre>

<hr>
<h2 id='linear_aggregation_MPI'>Mazziotta-Pareto index</h2><span id='topic+linear_aggregation_MPI'></span>

<h3>Description</h3>

<p>The Mazziotta–Pareto index (MPI) is a composite index for summarizing a set
of individual indicators that are assumed to be not fully substitutable. It
is based on a non-linear function which, starting from the arithmetic mean
of the normalized indicators, introduces a penalty for the units with
unbalanced values of the indicators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_aggregation_MPI(data, pol = "pos")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_aggregation_MPI_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative</p>
</td></tr>
<tr><td><code id="linear_aggregation_MPI_+3A_pol">pol</code></td>
<td>
<p>polarity if not selected is positive, otherwise write neg (see
details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ‘polarity’ of an indicator is the sign of the relation between the
indicator and the phenomenon to be measured ( + if the indicator represents
a dimension considered positive and - otherwise)
</p>


<h3>Value</h3>

<p>It returns a dataframe with rows = observations and column =
composite indicator
</p>


<h3>References</h3>

<p>De Muro P., Mazziotta M., Pareto A. (2011), &quot;Composite Indices
of Development and Poverty: An Application to MDGs&quot;, Social Indicators
Research, Volume 104, Number 1, pp. 1-18
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Indicator=linear_aggregation_MPI(Education)
print(Indicator)

#----With negative polarity
Indicator_neg=linear_aggregation_MPI(Education,"neg")
print(Indicator_neg)


</code></pre>

<hr>
<h2 id='lm_imputation'>Function to apply nan inputation with linear regression</h2><span id='topic+lm_imputation'></span>

<h3>Description</h3>

<p>The lm_imputation function aims to replace missing values (NA) in a dataset
with values estimated using a linear regression model. This technique allows
the existing relationships between variables in the dataset to be used to
accurately estimate missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_imputation(data, to_impute, regressors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm_imputation_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative
variables</p>
</td></tr>
<tr><td><code id="lm_imputation_+3A_to_impute">to_impute</code></td>
<td>
<p>string , name of the variables whre there are NANs to
impute</p>
</td></tr>
<tr><td><code id="lm_imputation_+3A_regressors">regressors</code></td>
<td>
<p>vector of string with names of the variables to use to
apply linear regression imputation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a dataframe with imputed values
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("airquality")
regressors&lt;-colnames(airquality[,c(3,4)])
lm_imputation(data =airquality,"Ozone",regressors = regressors)

</code></pre>

<hr>
<h2 id='MAD'>Mean absolute difference of rank</h2><span id='topic+MAD'></span>

<h3>Description</h3>

<p>Function to calculate the mean absolute difference of rank for different
methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAD(matrix_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAD_+3A_matrix_data">matrix_data</code></td>
<td>
<p>data matrix of indicator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to calculate the mean absolute difference of rank for different
methods. Create the matrix of ranking for different columns, the rank is the
high value is the first. Calculate the different in absolute values for
different columns and calculate the mean for different methods
</p>


<h3>Value</h3>

<p>It returns a data frame of mean absolute difference of rank for
different methods
</p>


<h3>References</h3>

<p>Matteo Mazziotta &amp; Adriano Pareto, 2018. &quot;Measuring Well-Being
Over Time: The Adjusted Mazziotta–Pareto Index Versus Other Non-compensatory
Indices,&quot; Social Indicators Research: An International and Interdisciplinary
Journal for Quality-of-Life Measurement, Springer, vol. 136(3), pages
967-976, April
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Indicator_MPI=linear_aggregation_MPI(Education)
Indicator_AMPI=linear_aggregation_AMPI(Education)
Indicator_GA=geometric_aggregation(Education)
All_Indicator=cbind(Indicator_MPI,Indicator_AMPI,Indicator_GA)
MAD=MAD(All_Indicator)
print(MAD)

</code></pre>

<hr>
<h2 id='min_max'>Min-max normalization</h2><span id='topic+min_max'></span>

<h3>Description</h3>

<p>Min-max normalization transforms each value by subtracting its minimum and
dividing by its range (maximum-minimum). The result is a new variable with a
minimum of zero and a maximum of one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_max(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="min_max_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantiative
variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Change the value of variable to negative if it has negative polarity
</p>


<h3>Value</h3>

<p>It returns a datafame of normalized data
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Normalization=min_max(Education)
print(Normalization)

</code></pre>

<hr>
<h2 id='min_max_GM'>Normalization for the Geometric Mean</h2><span id='topic+min_max_GM'></span>

<h3>Description</h3>

<p>This is a data normalization function for the geometric mean, where we
multiplied the normalized data by 198 and add 1, with positive or negative
polarity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_max_GM(data, pol = "pos")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="min_max_GM_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantiative</p>
</td></tr>
<tr><td><code id="min_max_GM_+3A_pol">pol</code></td>
<td>
<p>polarity if not selected is &quot;positive&quot;&quot;, otherwise write &quot;neg&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ‘polarity’ of an indicator is the sign of the relation between the
indicator and the phenomenon to be measured ( + if the indicator represents
a dimension considered positive and - otherwise)
</p>


<h3>Value</h3>

<p>It returns a datafame of normalized data
</p>


<h3>References</h3>

<p>Massoli, P., Mazziotta, M., Pareto, A., Rinaldelli, C. (2013).
Synthesis Methodologies and Spatial Analysis. Composite indices for BES,DAYS
OF RESEARCH IN ISTAT, NOVEMBER 10-11, 2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Normalization=min_max_GM(Education)
print(Normalization)

#----With negative polarity
Normalization_neg=linear_aggregation_AMPI(Education,"neg")
print(Normalization_neg)

</code></pre>

<hr>
<h2 id='normalization_abov_below_mean'>Normalization above or below the mean</h2><span id='topic+normalization_abov_below_mean'></span>

<h3>Description</h3>

<p>This transformation considers the indicators which are above and below an
arbitrarily defined threshold, p, around the mean. The threshold p builds a
neutral region around the mean, where the transformed indicator is zero.
This reduces the sharp discontinuity, from -1 to +1, which exists across the
mean value to two minor discontinuities, from -1 to 0 and from 0 to +1,
across the thresholds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalization_abov_below_mean(data, p = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalization_abov_below_mean_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantiative
variables</p>
</td></tr>
<tr><td><code id="normalization_abov_below_mean_+3A_p">p</code></td>
<td>
<p>threshold for the window</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function to normalize in -1, 0, and 1
</p>


<h3>Value</h3>

<p>It returns a datafame of normalized data
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Indicator=normalization_abov_below_mean(Education)
print(Indicator)

#---With different threshold
Indicator=normalization_abov_below_mean(Education,p=0.1)
print(Indicator)


</code></pre>

<hr>
<h2 id='pca_weighting'>Function that weight the quantitative variable by PCA method</h2><span id='topic+pca_weighting'></span>

<h3>Description</h3>

<p>The pca_weighting function is designed to perform a principal component
analysis (PCA) on the input data to calculate weights that correct for
overlapping information between related indicators. This process makes it
possible to create a composite indicator that captures as much information
as possible from individual indicators while reducing the dimensionality of
the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca_weighting(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pca_weighting_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative
variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a dataframe with rows = observations and column =
composite indicator
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Indicator_pca=pca_weighting(Education)
print(Indicator_pca)
</code></pre>

<hr>
<h2 id='performance_nan_imputation'>Function to evaluate nan imputation method's performance</h2><span id='topic+performance_nan_imputation'></span>

<h3>Description</h3>

<p>This function evaluates the performance of various missing value imputation
methods in a quantitative dataframe. It is designed to examine and compare
five different imputation methods using standard performance measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance_nan_imputation(data, to_impute, regressors, method = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="performance_nan_imputation_+3A_data">data</code></td>
<td>
<p>A dataframe containing the observations (rows) and quantitative
variables (columns) to be analyzed. This dataframe includes variables with
missing values to be imputed</p>
</td></tr>
<tr><td><code id="performance_nan_imputation_+3A_to_impute">to_impute</code></td>
<td>
<p>A string specifying the name of the variable in the
dataframe that contains the missing values to be imputed</p>
</td></tr>
<tr><td><code id="performance_nan_imputation_+3A_regressors">regressors</code></td>
<td>
<p>A vector of strings indicating the names of the variables
to be used as regressors for imputation in the case of methods 1
(lm_imputation) and 4 (hot deck imputation)</p>
</td></tr>
<tr><td><code id="performance_nan_imputation_+3A_method">method</code></td>
<td>
<p>An integer between 1 and 5 that specifies the imputation
method to be used. The supported methods are:
</p>
<p>1: lm_imputation (Imputation by linear model)
</p>
<p>2: median imputation (imputation by median)
</p>
<p>3: mean imputation (imputation by mean)
</p>
<p>4: hot deck imputation (imputation via hot deck)
</p>
<p>5: EM imputation (imputation via Expectation-Maximization)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for comparing the effectiveness of different methods
of imputing missing values, allowing the most appropriate method to be
chosen based on measured performance
</p>


<h3>Value</h3>

<p>The function returns a dataframe that contains a row for each
imputation method and columns with performance measures. The performance
measures included are:
</p>
<p>R^2: Coefficient of Determination, which measures how well the imputed values
fit the observed values
</p>
<p>RMSE: Root Mean Squared Error, which provides a measure of the mean square
deviation between imputed and observed values
</p>
<p>MAE: Mean Absolute Error, which represents the mean absolute deviation
between the imputed and observed values
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("airquality")
regressors&lt;-colnames(airquality[,c(3,4)])

#---Methods 1 = Imputation by linear model
performance_nan_imputation(data =airquality,"Ozone",regressors = regressors,method = 1)

#---Methods 2 = Imputation by Median
suppressWarnings(performance_nan_imputation(data =airquality,"Ozone",method = 2))

#---Methods 3 = Imputation by Mean
suppressWarnings(performance_nan_imputation(data =airquality,"Ozone",method = 3))

#---Methods 4 = Hot Deck imputation
performance_nan_imputation(data =airquality,"Ozone",regressors = regressors,method = 4)

#---Methods 5 = Expectation-Maximization imputation
performance_nan_imputation(data =airquality,"Ozone",regressors = regressors,method = 5)

</code></pre>

<hr>
<h2 id='rank_aggregation'>Ranking Aggregation</h2><span id='topic+rank_aggregation'></span>

<h3>Description</h3>

<p>It's a function to apply ranking aggregation. The highest value is the first
value of rank
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_aggregation(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank_aggregation_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantiative
variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a dataframe with rows = observations and column =
composite indicator
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Indicator_rank=rank_aggregation(Education)
print(Indicator_rank)

</code></pre>

<hr>
<h2 id='rank_normalisation'>Rank normalization</h2><span id='topic+rank_normalisation'></span>

<h3>Description</h3>

<p>It's a function that normalize by ranking method. Create the matrix of
ranking for different columns, the rank is the high value is the first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_normalisation(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank_normalisation_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantiative
variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a datafame of normalized data
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Normalized_rank=rank_normalisation(Education)
print(Normalized_rank)

</code></pre>

<hr>
<h2 id='standardization'>Standardization</h2><span id='topic+standardization'></span>

<h3>Description</h3>

<p>It performs a standardization of data, i.e., centering and scaling, so that the
data is expressed in terms of standard deviation (i.e., mean = 0, SD = 1).
When applied to a statistical model, this function extracts the dataset,
standardizes it, and refits the model with this standardized version of the
dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardization(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardization_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative
variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a dataframe of scaled data
</p>


<h3>References</h3>

<p>OECD/European Union/EC-JRC (2008), Handbook on Constructing
Composite Indicators: Methodology and User Guide, OECD Publishing, Paris,
&lt;https://doi.org/10.1787/9789264043466-en&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Standardization=standardization(Education)
print(Standardization)

</code></pre>

<hr>
<h2 id='Standardization_AMPI'>Standardization of data with Adjusted Maziotta-Pareto index</h2><span id='topic+Standardization_AMPI'></span>

<h3>Description</h3>

<p>This is a function that standardized the data with Adjusted Maziotta-Pareto
index with positive or negative polarity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Standardization_AMPI(data, pol = "pos")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Standardization_AMPI_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative
variables</p>
</td></tr>
<tr><td><code id="Standardization_AMPI_+3A_pol">pol</code></td>
<td>
<p>polarity if not selected is &quot;positive&quot;&quot;, otherwise write &quot;neg&quot;
(see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ‘polarity’ of an indicator is the sign of the relation between the
indicator and the phenomenon to be measured ( + if the indicator represents
a dimension considered positive and - otherwise)
</p>


<h3>Value</h3>

<p>It returns a dataframe of normalized data
</p>


<h3>References</h3>

<p>Matteo Mazziotta &amp; Adriano Pareto, 2018. &quot;Measuring Well-Being
Over Time: The Adjusted Mazziotta–Pareto Index Versus Other Non-compensatory
Indices,&quot; Social Indicators Research: An International and Interdisciplinary
Journal for Quality-of-Life Measurement, Springer, vol. 136(3), pages
967-976, April
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Education")
Standardization_AMPI=Standardization_AMPI(Education)
print(Standardization_AMPI)

#----With negative polarity
Standardization_AMPI_neg=Standardization_AMPI(Education,"neg")
print(Standardization_AMPI_neg)

</code></pre>

<hr>
<h2 id='standardization_MPI'>Standardization of data with Maziotta-Pareto index</h2><span id='topic+standardization_MPI'></span>

<h3>Description</h3>

<p>This is a function that standardized the data with Maziotta-Pareto index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardization_MPI(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardization_MPI_+3A_data">data</code></td>
<td>
<p>dataframe with rows = observations and columns = quantitative
variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a dataframe of normalized data
</p>


<h3>References</h3>

<p>De Muro P., Mazziotta M., Pareto A. (2011), &quot;Composite Indices
of Development and Poverty: An Application to MDGs&quot;, Social Indicators
Research, Volume 104, Number 1, pp. 1-18
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Education")
Standardization_MPI=standardization_MPI(Education)
print(Standardization_MPI)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
