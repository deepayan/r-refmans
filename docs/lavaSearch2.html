<!DOCTYPE html><html><head><title>Help for package lavaSearch2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lavaSearch2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lavaSearch2'><p>Tools for Model Specification in the Latent Variable Framework</p></a></li>
<li><a href='#.dinformation2-internal'><p>Compute the First Derivative of the Expected Information Matrix</p></a></li>
<li><a href='#addLink'><p>Add a New Link Between Two Variables in a LVM</p></a></li>
<li><a href='#autoplot_calibrateType1'><p>Graphical Display of the Bias or Type 1 Error</p></a></li>
<li><a href='#autoplot.intDensTri'><p>2D-display of the Domain Used to Compute the Integral</p></a></li>
<li><a href='#autplot-modelsearch2'><p>Display the Value of a Coefficient across the Steps.</p></a></li>
<li><a href='#calcDistMax'><p>Adjust the p.values Using the Quantiles of the Max Statistic</p></a></li>
<li><a href='#calcType1postSelection'><p>Compute the Type 1 Error After Selection [EXPERIMENTAL]</p></a></li>
<li><a href='#calibrateType1'><p>Simulation Study Assessing Bias and Type 1 Error</p></a></li>
<li><a href='#checkData'><p>Check that Validity of the Dataset</p></a></li>
<li><a href='#clean'><p>Simplify a lvm object</p></a></li>
<li><a href='#coef2'><p>Model Coefficients With Small Sample Correction</p></a></li>
<li><a href='#coefByType'><p>Extract the Coefficient by Type</p></a></li>
<li><a href='#coefType'><p>Extract the Type of Each Coefficient</p></a></li>
<li><a href='#combination'><p>Form all Unique Combinations Between two Vectors</p></a></li>
<li><a href='#combineFormula'><p>Combine formula</p></a></li>
<li><a href='#compare2'><p>Test Linear Hypotheses With Small Sample Correction</p></a></li>
<li><a href='#confint2'><p>Confidence Intervals With Small Sample Correction</p></a></li>
<li><a href='#contrast2name'><p>Create Rownames for a Contrast Matrix</p></a></li>
<li><a href='#convFormulaCharacter'><p>formula character conversion</p></a></li>
<li><a href='#createContrast'><p>Create Contrast matrix</p></a></li>
<li><a href='#createGrid'><p>Create a Mesh for the Integration</p></a></li>
<li><a href='#defineCategoricalLink'><p>Identify Categorical Links in LVM</p></a></li>
<li><a href='#dfSigma'><p>Degree of Freedom for the Chi-Square Test</p></a></li>
<li><a href='#effects2'><p>Effects Through Pathways With Small Sample Correction</p></a></li>
<li><a href='#estimate2'><p>Satterthwaite Correction and Small Sample Correction</p></a></li>
<li><a href='#evalInParentEnv'><p>Find Object in the Parent Environments</p></a></li>
<li><a href='#extractData'><p>Extract Data From a Latent Variable Model</p></a></li>
<li><a href='#findNewLink'><p>Find all New Links Between Variables</p></a></li>
<li><a href='#gaussian_weight'><p>Estimate LVM With Weights</p></a></li>
<li><a href='#getIndexOmega'><p>Identify the Endogenous Variables</p></a></li>
<li><a href='#getNewLink'><p>Extract the Links that Have Been Found by the modelsearch2.</p></a></li>
<li><a href='#getNewModel'><p>Extract the Model that Has Been Retains by the modelsearch2.</p></a></li>
<li><a href='#getStep'><p>Extract one Step From the Sequential Procedure</p></a></li>
<li><a href='#getVarCov2'><p>Residual Variance-Covariance Matrix With Small Sample Correction.</p></a></li>
<li><a href='#glht2'><p>General Linear Hypothesis Testing With Small Sample Correction</p></a></li>
<li><a href='#hessian2'><p>Hessian With Small Sample Correction.</p></a></li>
<li><a href='#hessian2-internal'><p>Compute the Hessian Matrix From the Conditional Moments</p></a></li>
<li><a href='#iid2'><p>Influence Function With Small Sample Correction.</p></a></li>
<li><a href='#iid2plot'><p>Display the i.i.d. Decomposition</p></a></li>
<li><a href='#iidJack'><p>Jackknife iid Decomposition from Model Object</p></a></li>
<li><a href='#information2'><p>Expected Information With Small Sample Correction.</p></a></li>
<li><a href='#information2-internal'><p>Compute the Expected Information Matrix From the Conditional Moments</p></a></li>
<li><a href='#initVarLink'><p>Normalize var1 and var2</p></a></li>
<li><a href='#intDensTri'><p>Integrate a Gaussian/Student Density over a Triangle</p></a></li>
<li><a href='#leverage2'><p>Leverage With Small Sample Correction.</p></a></li>
<li><a href='#matrixPower'><p>Power of a Matrix</p></a></li>
<li><a href='#modelsearch2'><p>Data-driven Extension of a Latent Variable Model</p></a></li>
<li><a href='#moments2'><p>Compute Key Quantities of a Latent Variable Model</p></a></li>
<li><a href='#nobs2'><p>Effective Sample Size.</p></a></li>
<li><a href='#nStep'><p>Find the Number of Steps Performed During the Sequential Testing</p></a></li>
<li><a href='#residuals2'><p>Residuals With Small Sample Correction.</p></a></li>
<li><a href='#sampleRepeated'><p>Simulate Repeated Measurements over time</p></a></li>
<li><a href='#score2'><p>Score With Small Sample Correction</p></a></li>
<li><a href='#score2-internal'><p>Compute the Corrected Score.</p></a></li>
<li><a href='#sCorrect'><p>Depreciated Method For Small Sample Correction</p></a></li>
<li><a href='#selectRegressor'><p>Regressor of a Formula.</p></a></li>
<li><a href='#selectResponse'><p>Response Variable of a Formula</p></a></li>
<li><a href='#setLink'><p>Set a Link to a Value</p></a></li>
<li><a href='#skeleton'><p>Pre-computation for the Score</p></a></li>
<li><a href='#summary.calibrateType1'><p>Display the Type 1 Error Rate</p></a></li>
<li><a href='#summary.glht2'><p>Outcome of Linear Hypothesis Testing</p></a></li>
<li><a href='#summary.modelsearch2'><p>summary Method for modelsearch2 Objects</p></a></li>
<li><a href='#summary2'><p>Latent Variable Model Summary After Small Sample Correction</p></a></li>
<li><a href='#symmetrize'><p>Symmetrize a Matrix</p></a></li>
<li><a href='#transformSummaryTable'><p>Apply Transformation to Summary Table</p></a></li>
<li><a href='#tryWithWarnings'><p>Run an Expression and Catch Warnings and Errors</p></a></li>
<li><a href='#var2dummy'><p>Convert Variable Names to Dummy Variables Names.</p></a></li>
<li><a href='#vcov2'><p>Variance-Covariance With Small Sample Correction</p></a></li>
<li><a href='#vcov2-internal'><p>Inverse the Information Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Model Specification in the Latent Variable Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-22</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bozenne/lavaSearch2">https://github.com/bozenne/lavaSearch2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bozenne/lavaSearch2/issues">https://github.com/bozenne/lavaSearch2/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for model specification in the latent variable framework
    (add-on to the 'lava' package). The package contains three main functionalities:
    Wald tests/F-tests with improved control of the type 1 error in small samples,
    adjustment for multiple comparisons when searching for local dependencies,
    and adjustment for multiple comparisons when doing inference for multiple latent variable models. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), ggplot2, lava (&ge; 1.6.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, doParallel, MASS, Matrix, methods, multcomp, mvtnorm,
nlme, parallel, Rcpp, reshape2, sandwich, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>clubSandwich, data.table, foreach, emmeans, lme4, lmerTest,
numDeriv, pbapply, pbkrtest, R.rsp, riskRegression, survival,
testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-22 11:18:47 UTC; hpl802</td>
</tr>
<tr>
<td>Author:</td>
<td>Brice Ozenne <a href="https://orcid.org/0000-0001-9694-2956"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brice Ozenne &lt;brice.mh.ozenne@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lavaSearch2'>Tools for Model Specification in the Latent Variable Framework</h2><span id='topic+lavaSearch2'></span><span id='topic+lavaSearch2+2C'></span><span id='topic+lavaSearch2-package'></span>

<h3>Description</h3>

<p>The package contains three main functionalities:
</p>

<ul>
<li> <p><code><a href="#topic+compare2">compare2</a></code>, <code><a href="#topic+summary2">summary2</a></code>: Wald tests/robust Wald tests/F-tests/robust F-tests with improved control of the type 1 error in small samples.
</p>
</li>
<li> <p><code><a href="#topic+glht2">glht2</a></code>: adjustment for multiple comparisons when doing inference for multiple latent variable models.
</p>
</li>
<li> <p><code><a href="#topic+modelsearch2">modelsearch2</a></code>: searching for local dependencies with adjustment for multiple comparisons.
</p>
</li></ul>

<p>It contains other useful functions such as:
</p>

<ul>
<li> <p><code><a href="#topic+calibrateType1">calibrateType1</a></code>: simulation study of the type 1 error of Wald tests.
</p>
</li>
<li> <p><code><a href="#topic+createContrast">createContrast</a></code>: user-friendly function generating a contrast matrix.
</p>
</li>
<li> <p><code><a href="#topic+getVarCov2">getVarCov2</a></code>: reconstruct the conditional variance covariance matrix.
</p>
</li>
<li> <p><code><a href="#topic+iidJack">iidJack</a></code>: extract the jackknife iid decomposition.
</p>
</li></ul>



<h3>Details</h3>

<p>The latent variable models (LVM) considered in this package can be written <br />
as a measurement model:
</p>
<p style="text-align: center;"><code class="reqn">Y_i = \nu + \eta_i \Lambda + X_i K + \epsilon_i</code>
</p>

<p>and a structural model:
</p>
<p style="text-align: center;"><code class="reqn">\eta_i = \alpha + \eta_i B + X_i \Gamma + \zeta_i</code>
</p>

<p>where <code class="reqn">\Sigma</code> is the variance covariance matrix of the residuals <code class="reqn">\epsilon</code>, <br />
and <code class="reqn">\Psi</code>   is the variance covariance matrix of the residuals <code class="reqn">\zeta</code>. <br />
</p>
<p>The corresponding conditional mean is:
</p>
<p style="text-align: center;"><code class="reqn">
\mu_i(\theta) = E[Y_i|X_i] = \nu + (\alpha + X_i \Gamma) (1-B)^{-1} \Lambda + X_i K
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\Omega(\theta) = Var[Y_i|X_i] = \Lambda^{t} (1-B)^{-t} \Psi (1-B)^{-1} \Lambda + \Sigma
</code>
</p>

<p>The package aims to provides tool for testing linear hypotheses on the model coefficients
<code class="reqn">\nu</code>, <code class="reqn">\Lambda</code>, <code class="reqn">K</code>, <code class="reqn">\Sigma</code>,
<code class="reqn">\alpha</code>, <code class="reqn">B</code>, <code class="reqn">\Gamma</code>, <code class="reqn">\Psi</code>.
Searching for local dependency enable to test whether the proposed model is too simplistic and if so to identify which additional coefficients should be added to the model.
</p>


<h3>Limitations</h3>

<p>'lavaSearch2' has been design for Gaussian latent variable models.
This means that it may not work / give valid results:
</p>

<ul>
<li><p> in presence of censored or binary outcomes.
</p>
</li>
<li><p> with stratified models (i.e. object of class <code>multigroup</code>).
</p>
</li></ul>


<hr>
<h2 id='.dinformation2-internal'>Compute the First Derivative of the Expected Information Matrix</h2><span id='topic+.dinformation2-internal'></span><span id='topic+.dInformation2'></span>

<h3>Description</h3>

<p>Compute the first derivative of the expected information matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.dInformation2(
  dmu,
  dOmega,
  d2mu,
  d2Omega,
  OmegaM1,
  missing.pattern,
  unique.pattern,
  name.pattern,
  grid.3varD1,
  grid.2meanD1.1varD1,
  grid.2meanD2.1meanD1,
  grid.2varD2.1varD1,
  name.param,
  leverage,
  n.cluster,
  weights
)
</code></pre>


<h3>Details</h3>

<p><code>calc_dinformation</code> will perform the computation individually when the
argument <code>index.Omega</code> is not null.
</p>

<hr>
<h2 id='addLink'>Add a New Link Between Two Variables in a LVM</h2><span id='topic+addLink'></span><span id='topic+addLink.lvm'></span><span id='topic+addLink.lvm.reduced'></span>

<h3>Description</h3>

<p>Generic interface to add links to <code>lvm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLink(object, ...)

## S3 method for class 'lvm'
addLink(
  object,
  var1,
  var2,
  covariance,
  all.vars = lava::vars(object),
  warnings = FALSE,
  ...
)

## S3 method for class 'lvm.reduced'
addLink(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLink_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> object.</p>
</td></tr>
<tr><td><code id="addLink_+3A_...">...</code></td>
<td>
<p>[internal] only used by the generic method and from <code>addLink.lvm.reduced</code> to <code>addLink.lvm</code>.</p>
</td></tr>
<tr><td><code id="addLink_+3A_var1">var1</code></td>
<td>
<p>[character or formula] the exogenous variable of the new link or a formula describing the link to be added to the lvm.</p>
</td></tr>
<tr><td><code id="addLink_+3A_var2">var2</code></td>
<td>
<p>[character] the endogenous variable of the new link. Disregarded if the argument <code>var1</code> is a formula.</p>
</td></tr>
<tr><td><code id="addLink_+3A_covariance">covariance</code></td>
<td>
<p>[logical] is the link is bidirectional? Ignored if one of the variables non-stochastic (e.g. exogenous variables).</p>
</td></tr>
<tr><td><code id="addLink_+3A_all.vars">all.vars</code></td>
<td>
<p>[internal] a character vector containing all the variables of the <code>lvm</code> object.</p>
</td></tr>
<tr><td><code id="addLink_+3A_warnings">warnings</code></td>
<td>
<p>[logical] Should a warning be displayed when no link is added?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>all.vars</code> is useful for <code>lvm.reduce</code> object where the command <code>vars(object)</code> does not return all variables. The command <code>vars(object, xlp = TRUE)</code> must be used instead.
</p>
<p>Arguments <code>var1</code> and <code>var2</code> are passed to <code>initVarlink</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lava)
set.seed(10)

m &lt;- lvm()
regression(m) &lt;- c(y1,y2,y3)~u
regression(m) &lt;- u~x1+x2
latent(m) &lt;- ~u
m2 &lt;- m

addLink(m, x1 ~ y1, covariance = FALSE)
addLink(m, y1 ~ x1, covariance = FALSE)
coef(addLink(m, y1 ~ y2, covariance = TRUE))

addLink(m2, "x1", "y1", covariance = FALSE)
addLink(m2, "y1", "x1", covariance = FALSE)
newM &lt;- addLink(m, "y1", "y2", covariance = TRUE)
coef(newM)

</code></pre>

<hr>
<h2 id='autoplot_calibrateType1'>Graphical Display of the Bias or Type 1 Error</h2><span id='topic+autoplot_calibrateType1'></span><span id='topic+autoplot.calibrateType1'></span>

<h3>Description</h3>

<p>Graphical display of the bias or type 1 error
for the output of <code><a href="#topic+calibrateType1">calibrateType1</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calibrateType1'
autoplot(
  object,
  type = "bias",
  plot = TRUE,
  color.threshold = "red",
  type.bias = "absolute",
  alpha = 0.05,
  nrow.legend = NULL,
  name2label = NULL,
  color = NULL,
  keep.method = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot_calibrateType1_+3A_object">object</code></td>
<td>
<p>output of <code><a href="#topic+calibrateType1">calibrateType1</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_type">type</code></td>
<td>
<p>[character] if type equals <code>"bias"</code> the bias will be displayed.
Otherwise if it equals <code>"type1error"</code> the type 1 error will be displayed.</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_plot">plot</code></td>
<td>
<p>[logical] should the plot be displayed?</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_color.threshold">color.threshold</code></td>
<td>
<p>[character] the color for the line representing the expected value(s).</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_type.bias">type.bias</code></td>
<td>
<p>[character] if type.bias equals <code>"absolute"</code> the absolute bias will be used.
Otherwise if it equals <code>"relative"</code> the relative bias will be used.
Only relevant when type equals <code>"bias"</code>.</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_alpha">alpha</code></td>
<td>
<p>[numeric, 0-1] the significance threshold to consider.
Only relevant when type equals <code>"type1error"</code>.</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_nrow.legend">nrow.legend</code></td>
<td>
<p>[integer, &gt;0] the number of rows for the legend.
Only relevant when type equals <code>"type1error"</code>.</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_name2label">name2label</code></td>
<td>
<p>[named character vector] the label for the legend.
The vector should contain the method names (see details).
Only relevant when type equals <code>"type1error"</code>.</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_color">color</code></td>
<td>
<p>[character vector] a vector of colours to be used to color the lines.
Only relevant when type equals <code>"type1error"</code>.</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_keep.method">keep.method</code></td>
<td>
<p>[character vector] the methods names for which the type 1 error should be displayed.
Only relevant when type equals <code>"type1error"</code>.</p>
</td></tr>
<tr><td><code id="autoplot_calibrateType1_+3A_...">...</code></td>
<td>
<p>[internal] Only used by the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method names:
</p>

<ul>
<li> <p><code>p.Ztest</code>
</p>
</li>
<li> <p><code>p.Satt</code>
</p>
</li>
<li> <p><code>p.KR</code>
</p>
</li>
<li> <p><code>p.robustZtest</code>
</p>
</li>
<li> <p><code>p.robustSatt</code>
</p>
</li>
<li> <p><code>p.robustKR</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An list containing:
</p>

<ul>
<li><p> plot: a ggplot object.
</p>
</li>
<li><p> data: the dataset used to generate the ggplot object.
</p>
</li></ul>


<hr>
<h2 id='autoplot.intDensTri'>2D-display of the Domain Used to Compute the Integral</h2><span id='topic+autoplot.intDensTri'></span>

<h3>Description</h3>

<p>2D-display of the domain used to compute the integral.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intDensTri'
autoplot(object, coord.plot = c("x", "y1"), plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.intDensTri_+3A_object">object</code></td>
<td>
<p>output of the function <code>intDensTri</code>.</p>
</td></tr>
<tr><td><code id="autoplot.intDensTri_+3A_coord.plot">coord.plot</code></td>
<td>
<p>[character vector] the x and y coordinates. Can be <code>"x"</code>, <code>"y1"</code> to <code>"yd"</code>, <code>"z"</code> if <code>zmin</code> was specified when calling <code>intDensTri</code>.</p>
</td></tr>
<tr><td><code id="autoplot.intDensTri_+3A_plot">plot</code></td>
<td>
<p>[logical] should the plot be displayed?</p>
</td></tr>
<tr><td><code id="autoplot.intDensTri_+3A_...">...</code></td>
<td>
<p>[internal] Only used by the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intDensTri">intDensTri</a></code>
</p>

<hr>
<h2 id='autplot-modelsearch2'>Display the Value of a Coefficient across the Steps.</h2><span id='topic+autplot-modelsearch2'></span><span id='topic+autoplot.modelsearch2'></span>

<h3>Description</h3>

<p>Display the value of a coefficient across the steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelsearch2'
autoplot(
  object,
  param,
  ci = TRUE,
  step = 0:nStep(object),
  conf.level = 0.95,
  plot = TRUE,
  add.0 = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autplot-modelsearch2_+3A_object">object</code></td>
<td>
<p>a <code>modelsearch2</code> object.</p>
</td></tr>
<tr><td><code id="autplot-modelsearch2_+3A_param">param</code></td>
<td>
<p>[character vector] the name of the coefficient(s) to be displayed.</p>
</td></tr>
<tr><td><code id="autplot-modelsearch2_+3A_ci">ci</code></td>
<td>
<p>[logical] should the confidence intervals of the coefficient(s) be displayed.</p>
</td></tr>
<tr><td><code id="autplot-modelsearch2_+3A_step">step</code></td>
<td>
<p>[integer &gt;0] the steps at which the coefficient value should be displayed.</p>
</td></tr>
<tr><td><code id="autplot-modelsearch2_+3A_conf.level">conf.level</code></td>
<td>
<p>[numeric, 0-1] confidence level of the interval.</p>
</td></tr>
<tr><td><code id="autplot-modelsearch2_+3A_plot">plot</code></td>
<td>
<p>[logical] should the graph be displayed?</p>
</td></tr>
<tr><td><code id="autplot-modelsearch2_+3A_add.0">add.0</code></td>
<td>
<p>[logical] should an horizontal line representing no effect be displayed?</p>
</td></tr>
<tr><td><code id="autplot-modelsearch2_+3A_...">...</code></td>
<td>
<p>[internal] only used by the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing </p>

<ul>
<li> <p><code>plot</code>: a ggplot object.
</p>
</li>
<li> <p><code>data</code>: the data used to generate the ggplot object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mSim &lt;- lvm(Y~G+X1+X2+X3+X4+X5)
addvar(mSim) &lt;- ~Z1+Z2

set.seed(10)
df.data &lt;- lava::sim(mSim, 1e2)

mBase &lt;- lvm(Y~G)
addvar(mBase) &lt;- ~X1+X2+X3+X4+X5+Z1+Z2
e.lvm &lt;- estimate(mBase, data = df.data)
res &lt;- modelsearch2(e.lvm, method.p.adjust = "holm", alpha = 0.05)
autoplot(res, param = "Y~G")
autoplot(res, param = c("Y","Y~G"))

## End(Not run)
</code></pre>

<hr>
<h2 id='calcDistMax'>Adjust the p.values Using the Quantiles of the Max Statistic</h2><span id='topic+calcDistMax'></span><span id='topic+calcDistMaxIntegral'></span><span id='topic+calcDistMaxBootstrap'></span>

<h3>Description</h3>

<p>Adjust the p.values using the quantiles of the max statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcDistMaxIntegral(
  statistic,
  iid,
  df,
  iid.previous = NULL,
  quantile.previous = NULL,
  quantile.compute = lava.options()$search.calc.quantile.int,
  alpha,
  cpus = 1,
  cl = NULL,
  trace
)

calcDistMaxBootstrap(
  statistic,
  iid,
  iid.previous = NULL,
  quantile.previous = NULL,
  method,
  alpha,
  cpus = 1,
  cl = NULL,
  n.sim,
  trace,
  n.repmax = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcDistMax_+3A_statistic">statistic</code></td>
<td>
<p>[numeric vector] the observed Wald statistic.
Each statistic correspond to a null hypothesis (i.e. a coefficient) that one wish to test.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_iid">iid</code></td>
<td>
<p>[matrix] zero-mean iid decomposition of the coefficient used to compute the statistic.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_df">df</code></td>
<td>
<p>[numeric] the degree of freedom defining the multivariate Student's t distribution.
If <code>NULL</code> the multivariate Gaussian distribution will be used instead.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_iid.previous">iid.previous</code></td>
<td>
<p>[matrix, EXPERIMENTAL] zero-mean iid decomposition of previously tested coefficient.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_quantile.previous">quantile.previous</code></td>
<td>
<p>[numeric, EXPERIMENTAL] rejection quantiles of the previously tested hypotheses. If not <code>NULL</code> the values should correspond the variable in to the first column(s) of the argument <code>iid.previous</code>.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_quantile.compute">quantile.compute</code></td>
<td>
<p>[logical] should the rejection quantile be computed?</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_alpha">alpha</code></td>
<td>
<p>[numeric 0-1] the significance cutoff for the p-values.
When the p-value is below, the corresponding link will be retained.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_cpus">cpus</code></td>
<td>
<p>[integer &gt;0] the number of processors to use.
If greater than 1, the computation of the p-value relative to each test is performed in parallel.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_cl">cl</code></td>
<td>
<p>[cluster] a parallel socket cluster generated by <code>parallel::makeCluster</code>
that has been registered using <code>registerDoParallel</code>.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_trace">trace</code></td>
<td>
<p>[logical] should the execution of the function be traced?</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_method">method</code></td>
<td>
<p>[character] the method used to compute the p-values.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_n.sim">n.sim</code></td>
<td>
<p>[integer &gt;0] the number of bootstrap simulations used to compute each p-values.
Disregarded when the p-values are computed using numerical integration.</p>
</td></tr>
<tr><td><code id="calcDistMax_+3A_n.repmax">n.repmax</code></td>
<td>
<p>[integer &gt;0] the maximum number of rejection for each bootstrap sample before switching to a new bootstrap sample.
Only relevant when conditioning on a previous test.
Disregarded when the p-values are computed using numerical integration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li><p> p.adjust: the adjusted p-values.
</p>
</li>
<li><p> z: the rejection threshold.
</p>
</li>
<li><p> Sigma: the correlation matrix between the test statistic.
</p>
</li>
<li><p> correctedLevel: the alpha level corrected for conditioning on previous tests.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)

set.seed(10)
n &lt;- 100
p &lt;- 4
link &lt;- letters[1:p]
n.sim &lt;- 1e3 # number of bootstrap simulations 

#### test - not conditional ####
X.iid &lt;- rmvnorm(n, mean = rep(0,p), sigma = diag(1,p))
colnames(X.iid) &lt;- link
statistic &lt;- setNames(1:p,link)


r1 &lt;- calcDistMaxIntegral(statistic = statistic, iid = X.iid, 
            trace = FALSE, alpha = 0.05, df = 1e6) 

r3 &lt;- calcDistMaxBootstrap(statistic = statistic, iid = X.iid,
            method = "residual",
            trace = FALSE, alpha = 0.05, n.sim = n.sim)

r4 &lt;- calcDistMaxBootstrap(statistic = statistic, iid = X.iid,
            method = "wild",
            trace = FALSE, alpha = 0.05, n.sim = n.sim)

rbind(integration = c(r1$p.adjust, quantile = r1$z),
      bootResidual = c(r3$p.adjust, quantile = r3$z),
      bootWild    = c(r4$p.adjust, quantile = r4$z))

#### test - conditional ####
## Not run: 
Z.iid &lt;- rmvnorm(n, mean = rep(0,p+1), sigma = diag(1,p+1))
seqQuantile &lt;- qmvnorm(p = 0.95, delta = rep(0,p+1), sigma = diag(1,p+1), 
                    tail = "both.tails")$quantile

r1c &lt;- calcDistMaxIntegral(statistic = statistic, iid = X.iid,
            iid.previous = Z.iid, quantile.previous =  seqQuantile, 
            trace = FALSE, alpha = 0.05, df = NULL)

r3c &lt;- calcDistMaxBootstrap(statistic = statistic, iid = X.iid,
            iid.previous = Z.iid, quantile.previous =  seqQuantile, method = "residual",
            trace = FALSE, alpha = 0.05, n.sim = n.sim)

r4c &lt;- calcDistMaxBootstrap(statistic = statistic, iid = X.iid,
            iid.previous = Z.iid, quantile.previous =  seqQuantile, method = "wild",
            trace = FALSE, alpha = 0.05, n.sim = n.sim)

rbind(integration = c(r1c$p.adjust, quantile = r1c$z),
      bootResidual = c(r3c$p.adjust, quantile = r3c$z),
      bootWild    = c(r4c$p.adjust, quantile = r4c$z))

## End(Not run)
</code></pre>

<hr>
<h2 id='calcType1postSelection'>Compute the Type 1 Error After Selection [EXPERIMENTAL]</h2><span id='topic+calcType1postSelection'></span>

<h3>Description</h3>

<p>Compute the type 1 error after selection [EXPERIMENTAL].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcType1postSelection(
  level,
  mu,
  Sigma,
  quantile.previous,
  distribution,
  df,
  n = 10,
  correct = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcType1postSelection_+3A_level">level</code></td>
<td>
<p>[numeric 0-1] expected coverage.</p>
</td></tr>
<tr><td><code id="calcType1postSelection_+3A_mu">mu</code></td>
<td>
<p>[numeric vector] the expectation of the joint distribution of the test statistics</p>
</td></tr>
<tr><td><code id="calcType1postSelection_+3A_sigma">Sigma</code></td>
<td>
<p>[matrix] the variance-covariance of the joint distribution of the test statistics.</p>
</td></tr>
<tr><td><code id="calcType1postSelection_+3A_quantile.previous">quantile.previous</code></td>
<td>
<p>[numeric] significance quantile used at the previous step.</p>
</td></tr>
<tr><td><code id="calcType1postSelection_+3A_distribution">distribution</code></td>
<td>
<p>[character] distribution of the test statistics.
Can be <code>"pmvnorm"</code> (normal distribution) or <code>"pvmt"</code> (Student's t distribution)</p>
</td></tr>
<tr><td><code id="calcType1postSelection_+3A_df">df</code></td>
<td>
<p>[integer &gt; 0] the degree of freedom of the joint Student's t distribution.
Only used when <code>distribution="pvmt"</code>.</p>
</td></tr>
<tr><td><code id="calcType1postSelection_+3A_n">n</code></td>
<td>
<p>[integer &gt; 0] number of points for the numerical integration</p>
</td></tr>
<tr><td><code id="calcType1postSelection_+3A_correct">correct</code></td>
<td>
<p>[logical] if true, correct the level to account for previous testings.</p>
</td></tr>
<tr><td><code id="calcType1postSelection_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+intDensTri">intDensTri</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of tests at the current step (i.e. after selection) is assumed to be
one less than the number of tests at the previous step (i.e. before selection).
</p>
<p>Arguments <code>mu</code> and <code>Sigma</code> must contain the moments for the vector of test statistics
before and after selection (in that order).
</p>


<h3>Value</h3>

<p>[numeric] the type 1 error.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
n &lt;- 350

#### only 2 tests
Sigma &lt;- rbind(c(1,0,0),c(0,1,1),c(0,1,1))
z2 &lt;- qmvnorm(0.95, mean = rep(0,2), sigma = Sigma[1:2,1:2], tail = "both.tails")$quantile

## no selection since strong effect
mu &lt;- c(10,0,0)
calcType1postSelection(0.95, quantile.previous = z2, distribution = "gaussian",
                        mu = mu, Sigma = Sigma, correct = TRUE)

## strong selection
## Not run: 
mu &lt;- c(0,0,0)
levelC &lt;- calcType1postSelection(0.95, quantile.previous = z2, distribution = "gaussian",
                        mu = mu, Sigma = Sigma)
print(levelC) # more liberal than without selection
calcType1postSelection(levelC, quantile.previous = z2, distribution = "gaussian",
                        mu = mu, Sigma = Sigma, correct = FALSE)

## End(Not run)

#### 3 tests
Sigma &lt;- diag(1,5,5)
Sigma[4,2] &lt;- 1
Sigma[2,4] &lt;- 1
Sigma[5,3] &lt;- 1
Sigma[3,5] &lt;- 1

z2 &lt;- qmvnorm(0.95, mean = mu[1:3], sigma = Sigma[1:3,1:3], tails = "both.tails")$quantile

## no selection since strong effect
## Not run: 
mu &lt;- c(10,0,0,0,0)
calcType1postSelection(0.95, quantile.previous = z2, distribution = "gaussian",
                        mu = mu, Sigma = Sigma, correct = TRUE)

## strong selection
mu &lt;- c(0,0,0,0,0)
levelC &lt;- calcType1postSelection(0.95, quantile.previous = z2,
                        mu = mu, Sigma = Sigma, distribution = "gaussian")
calcType1postSelection(levelC, quantile.previous = z2, distribution = "gaussian",
                        mu = mu, Sigma = Sigma, correct = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='calibrateType1'>Simulation Study Assessing Bias and Type 1 Error</h2><span id='topic+calibrateType1'></span><span id='topic+calibrateType1.lvm'></span><span id='topic+calibrateType1.lvmfit'></span>

<h3>Description</h3>

<p>Perform a simulation study over one or several sample size
to assess the bias of the estimate
and the type 1 error of the Wald test and robust Wald test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateType1(object, param, n.rep, ...)

## S3 method for class 'lvm'
calibrateType1(
  object,
  param,
  n.rep,
  n,
  correction = TRUE,
  warmup = NULL,
  null = NULL,
  F.test = FALSE,
  cluster = NULL,
  generative.object = NULL,
  generative.coef = NULL,
  true.coef = NULL,
  n.true = 1e+06,
  round.true = 2,
  bootstrap = FALSE,
  n.bootstrap = 1000,
  checkType1 = FALSE,
  checkType2 = FALSE,
  dir.save = NULL,
  label.file = NULL,
  seed = NULL,
  cpus = 1,
  trace = 2,
  ...
)

## S3 method for class 'lvmfit'
calibrateType1(
  object,
  param,
  n.rep,
  correction = TRUE,
  F.test = FALSE,
  bootstrap = FALSE,
  n.bootstrap = 1000,
  seed = NULL,
  trace = 2,
  cpus = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrateType1_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> object defining the model to be fitted.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_param">param</code></td>
<td>
<p>[character vector] names of the coefficient whose value will be tested.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_n.rep">n.rep</code></td>
<td>
<p>[integer, &gt;0] number of simulations per sample size.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_...">...</code></td>
<td>
<p>[internal] Only used by the generic method.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_n">n</code></td>
<td>
<p>[integer vector, &gt;0] sample size(s) considered in the simulation study.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_correction">correction</code></td>
<td>
<p>[logical] should the type 1 error after correction be computed?</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_warmup">warmup</code></td>
<td>
<p>[list of lvm] a list of <code>lvm</code> objects that will be sequentially fitted with for
starting values the parameter of the previous model in the list (if any). The parameters of the final
model of the list are used to initialize the fit of the model of interest (i.e. object).</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_null">null</code></td>
<td>
<p>[numeric vector] vector of null hypotheses, one for each model coefficient.
By default a vector of 0.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_f.test">F.test</code></td>
<td>
<p>[logical] should a multivariate Wald test be perform testing simultaneously all the null hypotheses?</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.
Will be passed to <code>lava::estimate</code>.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_generative.object">generative.object</code></td>
<td>
<p>[lvm] object defining the statistical model generating the data.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_generative.coef">generative.coef</code></td>
<td>
<p>[name numeric vector] values for the parameters of the generative model.
Can also be <code>NULL</code>: in such a case the coefficients are set to default values decided by lava (usually 0 or 1).</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_true.coef">true.coef</code></td>
<td>
<p>[name numeric vector] expected values for the parameters of the fitted model.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_n.true">n.true</code></td>
<td>
<p>[integer, &gt;0] sample size at which the estimated coefficients will be a reliable approximation of the true coefficients.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_round.true">round.true</code></td>
<td>
<p>[integer, &gt;0] the number of decimal places to be used for the true value of the coefficients. No rounding is done if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_bootstrap">bootstrap</code></td>
<td>
<p>[logical] should bootstrap resampling be performed?</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_n.bootstrap">n.bootstrap</code></td>
<td>
<p>[integer, &gt;0] the number of bootstrap sample to be used for each bootstrap.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_checktype1">checkType1</code></td>
<td>
<p>[logical] returns an error if the coefficients associated to the null hypotheses do not equal 0.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_checktype2">checkType2</code></td>
<td>
<p>[logical] returns an error if the coefficients associated to the null hypotheses equal 0.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_dir.save">dir.save</code></td>
<td>
<p>[character] path to the directory were the results should be exported.
Can also be <code>NULL</code>: in such a case the results are not exported.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_label.file">label.file</code></td>
<td>
<p>[character] element to include in the file name.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_seed">seed</code></td>
<td>
<p>[integer, &gt;0] value that will be set before adjustment for multiple comparisons to ensure reproducible results.
Can also be <code>NULL</code>: in such a case no seed is set.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_cpus">cpus</code></td>
<td>
<p>[integer &gt;0] the number of processors to use.
If greater than 1, the simulations are performed in parallel.</p>
</td></tr>
<tr><td><code id="calibrateType1_+3A_trace">trace</code></td>
<td>
<p>[integer] should the execution of the function be trace. Can be 0, 1 or 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>calibrateType1</code>.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne
</p>


<h3>See Also</h3>

<p><code>link{autoplot.calibrateType1}</code> for a graphical display of the bias or of the type 1 error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### simulate data ####
m.Sim &lt;- lvm(c(Y1[mu1:sigma]~1*eta,
               Y2[mu2:sigma]~1*eta,
               Y3[mu3:sigma]~1*eta,
               eta~beta1*Group+beta2*Gender))
latent(m.Sim) &lt;- ~eta
categorical(m.Sim, labels = c("M","F")) &lt;- ~Gender

d &lt;- lava::sim(m.Sim, 1e2)

#### calibrate type 1 error on the estimated model ####
m &lt;- lvm(Y1~eta,
         Y2~eta,
         Y3~eta,
         eta~Group+Gender)
e &lt;- lava::estimate(m, data = d)
res &lt;- calibrateType1(e, param = "eta~Group", n.rep = 100)
res &lt;- calibrateType1(e, param = c("eta~Group","Y1~eta"), F.test = TRUE, n.rep = 100)
res &lt;- calibrateType1(e, param = "eta~Group", n.rep = 100, cpus = 4)
summary(res)

## End(Not run)

</code></pre>

<hr>
<h2 id='checkData'>Check that Validity of the Dataset</h2><span id='topic+checkData'></span><span id='topic+checkData.lvm'></span>

<h3>Description</h3>

<p>Check whether the dataset can be used to fit the <code>lvm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkData(object, data, trace)

## S3 method for class 'lvm'
checkData(object, data, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkData_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> object.</p>
</td></tr>
<tr><td><code id="checkData_+3A_data">data</code></td>
<td>
<p>[data.frame] the dataset used to obtain the object.</p>
</td></tr>
<tr><td><code id="checkData_+3A_trace">trace</code></td>
<td>
<p>[logical] when <code>TRUE</code>, the outcome of the check will be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible  <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm()
regression(m) &lt;- c(y1,y2,y3)~u
regression(m) &lt;- u~x
latent(m) &lt;- ~u

d &lt;- lava::sim(m,1e2)

try(checkData(m, data = d)) # return an error

checkData(m, data = d[,-4])

try(checkData(m, data = d[,-(3:4)])) # return an error

</code></pre>

<hr>
<h2 id='clean'>Simplify a lvm object</h2><span id='topic+clean'></span><span id='topic+clean.lvm'></span>

<h3>Description</h3>

<p>Remove variables with no link.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean(x, ...)

## S3 method for class 'lvm'
clean(x, rm.exo = TRUE, rm.endo = TRUE, rm.latent = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_+3A_x">x</code></td>
<td>
<p><code>lvm</code>-object</p>
</td></tr>
<tr><td><code id="clean_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
<tr><td><code id="clean_+3A_rm.exo">rm.exo</code></td>
<td>
<p>should exogenous variables with no links be removed from the object?</p>
</td></tr>
<tr><td><code id="clean_+3A_rm.endo">rm.endo</code></td>
<td>
<p>should endogenous variables with no links be removed from the object?</p>
</td></tr>
<tr><td><code id="clean_+3A_rm.latent">rm.latent</code></td>
<td>
<p>should latent variables with no links be removed from the object?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm()
m &lt;- regression(m, x=paste0("x",1:5),y="y1")
m &lt;- regression(m, x=paste0("x",1:5),y="y2")
covariance(m) &lt;- y1~y2

cancel(m) &lt;- y1 ~ x1
cancel(m) &lt;- y2 ~ x1
clean(m)

m &lt;- lvm(y1 ~ eta + x1, y2 ~ eta, y3 ~ eta + x2)
latent(m) &lt;- ~eta
clean(m)
m
cancel(m) &lt;- y1 ~ eta
cancel(m) &lt;- y2 ~ eta
cancel(m) &lt;- y3 ~ eta
clean(m)
</code></pre>

<hr>
<h2 id='coef2'>Model Coefficients With Small Sample Correction</h2><span id='topic+coef2'></span><span id='topic+coef2.lvmfit'></span>

<h3>Description</h3>

<p>Extract the coefficients from a latent variable model.
Similar to <code>lava::compare</code> but with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef2(object, as.lava, ...)

## S3 method for class 'lvmfit'
coef2(object, as.lava = TRUE, ssc = lava.options()$ssc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="coef2_+3A_as.lava">as.lava</code></td>
<td>
<p>[logical] if <code>TRUE</code>, uses the same names as when using <code>stats::coef</code>.</p>
</td></tr>
<tr><td><code id="coef2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="coef2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the model coefficients.
</p>


<h3>Value</h3>

<p>A numeric vector named with the names of the coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
set.seed(10)
dW &lt;- sampleRepeated(10, format = "wide")
set.seed(10)
dL &lt;- sampleRepeated(10, format = "long")
dL$time2 &lt;- paste0("visit",dL$time)

#### latent variable models ####
e.lvm &lt;- estimate(lvm(c(Y1,Y2,Y3) ~ 1*eta + X1, eta ~ Z1), data = dW)
coef(e.lvm)
coef2(e.lvm)
coef2(e.lvm, as.lava = FALSE)
</code></pre>

<hr>
<h2 id='coefByType'>Extract the Coefficient by Type</h2><span id='topic+coefByType'></span><span id='topic+coefCov'></span><span id='topic+coefCov.lvm'></span><span id='topic+coefCov.lvmfit'></span><span id='topic+coefCov.multigroup'></span><span id='topic+coefExtra'></span><span id='topic+coefExtra.lvm'></span><span id='topic+coefExtra.lvmfit'></span><span id='topic+coefExtra.multigroup'></span><span id='topic+coefIndexModel'></span><span id='topic+coefIndexModel.lvm'></span><span id='topic+coefIndexModel.lvmfit'></span><span id='topic+coefIndexModel.multigroup'></span><span id='topic+coefIndexModel.multigroupfit'></span><span id='topic+coefIntercept'></span><span id='topic+coefIntercept.lvm'></span><span id='topic+coefIntercept.lvmfit'></span><span id='topic+coefIntercept.multigroup'></span><span id='topic+coefRef'></span><span id='topic+coefRef.lvmfit'></span><span id='topic+coefReg'></span><span id='topic+coefReg.lvm'></span><span id='topic+coefReg.lvmfit'></span><span id='topic+coefReg.multigroup'></span><span id='topic+coefVar'></span><span id='topic+coefVar.lvm'></span><span id='topic+coefVar.lvmfit'></span><span id='topic+coefVar.multigroup'></span>

<h3>Description</h3>

<p>Extract specific types of coefficient from a <code>lvm</code> object:
covariance coefficient(s) (<code>coefCov</code>),
extra parameter(s) (<code>coefExtra</code>),
position in the list of models for each coefficient (<code>coefIndexModel</code>),
intercept coefficient(s) (<code>coefIntercept</code>),
coefficient(s) that are used as reference (<code>coefRef</code>),
regression coefficient(s) (<code>coefReg</code>),
variance coefficient(s) (<code>coefVar</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefCov(object, value, keep.var, ...)

## S3 method for class 'lvm'
coefCov(object, value = FALSE, keep.var = FALSE, ...)

## S3 method for class 'lvmfit'
coefCov(object, value = FALSE, keep.var = FALSE, ...)

## S3 method for class 'multigroup'
coefCov(object, value = FALSE, keep.var = FALSE, ...)

coefExtra(object, value, ...)

## S3 method for class 'lvm'
coefExtra(object, value = FALSE, ...)

## S3 method for class 'lvmfit'
coefExtra(object, value = FALSE, ...)

## S3 method for class 'multigroup'
coefExtra(object, value = FALSE, ...)

coefIndexModel(object, ...)

## S3 method for class 'lvm'
coefIndexModel(object, ...)

## S3 method for class 'lvmfit'
coefIndexModel(object, ...)

## S3 method for class 'multigroup'
coefIndexModel(object, ...)

## S3 method for class 'multigroupfit'
coefIndexModel(object, ...)

coefIntercept(object, value, ...)

## S3 method for class 'lvm'
coefIntercept(object, value = FALSE, ...)

## S3 method for class 'lvmfit'
coefIntercept(object, value = FALSE, ...)

## S3 method for class 'multigroup'
coefIntercept(object, value = FALSE, ...)

coefRef(object, value, ...)

## S3 method for class 'lvmfit'
coefRef(object, value = FALSE, ...)

coefReg(object, value, ...)

## S3 method for class 'lvm'
coefReg(object, value = FALSE, ...)

## S3 method for class 'lvmfit'
coefReg(object, value = FALSE, ...)

## S3 method for class 'multigroup'
coefReg(object, value = FALSE, ...)

coefVar(object, value, ...)

## S3 method for class 'lvm'
coefVar(object, value = FALSE, ...)

## S3 method for class 'lvmfit'
coefVar(object, value = FALSE, ...)

## S3 method for class 'multigroup'
coefVar(object, value = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefByType_+3A_object">object</code></td>
<td>
<p>a lvm model or a fitted lvm model</p>
</td></tr>
<tr><td><code id="coefByType_+3A_value">value</code></td>
<td>
<p>should the name of the coefficient be returned? Else return the coefficients</p>
</td></tr>
<tr><td><code id="coefByType_+3A_keep.var">keep.var</code></td>
<td>
<p>should the variance coefficients be returned?</p>
</td></tr>
<tr><td><code id="coefByType_+3A_...">...</code></td>
<td>
<p>arguments to be passed to </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the names of the positions of the coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### regression ####
m &lt;- lvm(Y~X1+X2)
e &lt;- estimate(m, lava::sim(m, 1e2))

coefCov(m)
coefCov(m, value = TRUE)

coefCov(m, keep.var = TRUE)
coefCov(m, value = TRUE, keep.var = TRUE)

coefIndexModel(m)
coefIndexModel(e)

coefIntercept(m)
coefIntercept(m, value = TRUE)

coefReg(m)
coefReg(m, value = TRUE)

#### LVM ####
m &lt;- lvm()
regression(m) &lt;- c(y1,y2,y3)~u
regression(m) &lt;- u~x1+x2
latent(m) &lt;- ~u
covariance(m) &lt;- y1~y2

m.Sim &lt;- m
categorical(m.Sim, labels = c("a","b","c")) &lt;- ~x2
e &lt;- estimate(m, lava::sim(m.Sim, 1e2))

coefCov(m)
coefCov(m, value = TRUE) 

coefCov(m, keep.var = TRUE)
coefCov(m, value = TRUE, keep.var = TRUE)

coefExtra(m)

coefIndexModel(m)
coefIndexModel(e)

## additional categorical variable 
categorical(m, labels = as.character(1:3)) &lt;- "X1"

coefExtra(m)
coefExtra(m, value = TRUE)

## additional categorical variable
categorical(m, labels = as.character(1:3)) &lt;- "x1"

coefIntercept(m)
coefIntercept(m, value = TRUE)
coefIntercept(e)

coefReg(e, value = TRUE)

#### multigroup ####
m &lt;- lvm(Y~X1+X2)
eG &lt;- estimate(list(m,m), list(lava::sim(m, 1e2), lava::sim(m, 1e2)))

coefIndexModel(eG)

</code></pre>

<hr>
<h2 id='coefType'>Extract the Type of Each Coefficient</h2><span id='topic+coefType'></span><span id='topic+coefType.lvm'></span><span id='topic+coefType.lvmfit'></span><span id='topic+coefType.multigroup'></span>

<h3>Description</h3>

<p>Extract the type of each coefficient of a <code>lvm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefType(object, as.lava, ...)

## S3 method for class 'lvm'
coefType(object, as.lava = TRUE, data = NULL, ...)

## S3 method for class 'lvmfit'
coefType(object, as.lava = TRUE, ...)

## S3 method for class 'multigroup'
coefType(object, as.lava = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefType_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> or <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="coefType_+3A_as.lava">as.lava</code></td>
<td>
<p>[logical] export the type of coefficients mimicking <code>lava:::coef</code>.</p>
</td></tr>
<tr><td><code id="coefType_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>lava::coef</code></p>
</td></tr>
<tr><td><code id="coefType_+3A_data">data</code></td>
<td>
<p>[data.frame, optional] the dataset. Help to identify the categorical variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A lvm can be written as a measurement model:
</p>
<p style="text-align: center;"><code class="reqn">Y_i = \nu + \Lambda \eta_i + K X_i + \epsilon_i</code>
</p>

<p>and a structural model:
</p>
<p style="text-align: center;"><code class="reqn">\eta_i = \alpha + B \eta_i + \Gamma X_i + \zeta_i</code>
</p>

<p>where <code class="reqn">\Psi</code>   is the variance covariance matrix of the residuals <code class="reqn">\zeta</code> <br />
and   <code class="reqn">\Sigma</code> is the variance covariance matrix of the residuals <code class="reqn">\epsilon</code>. <br /> <br />
</p>
<p><code>coefType</code> either returns the Latin/Greek letter corresponding to the coefficients
or it groups them:
</p>

<ul>
<li><p> intercept: <code class="reqn">\nu</code> and <code class="reqn">\alpha</code>.
</p>
</li>
<li><p> regression: <code class="reqn">\Lambda</code>, <code class="reqn">K</code>, <code class="reqn">B</code>, and <code class="reqn">\Gamma</code>.
</p>
</li>
<li><p> covariance: extra-diagonal terms of <code class="reqn">\Sigma</code> and <code class="reqn">\Psi</code>.
</p>
</li>
<li><p> variance: diagonal of <code class="reqn">\Sigma</code> and <code class="reqn">\Psi</code>.
</p>
</li></ul>

<p>A link denotes a relationship between two variables.
The coefficient are used to represent the strength of the association between two variable, i.e. the strength of a link.
A coefficient may corresponds to the strength of one or several link.
</p>


<h3>Value</h3>

<p><code>coefType</code> returns a <code>data.frame</code> when <code>as.lava=FALSE</code>:
</p>

<ul>
<li><p> name: name of the link
</p>
</li>
<li><p> Y: outcome variable
</p>
</li>
<li><p> X: regression variable in the design matrix (could be a transformation of the original variables, e.g. dichotomization).
</p>
</li>
<li><p> data: original variable
</p>
</li>
<li><p> type: type of link
</p>
</li>
<li><p> value: if TRUE, the value of the link is set and not estimated.
</p>
</li>
<li><p> marginal: if TRUE, the value of the link does not impact the estimation.
</p>
</li>
<li><p> detail: a more detailed description of the type of link (see the details section)
</p>
</li>
<li><p> lava: name of the coefficient in lava
</p>
</li></ul>

<p>When <code>as.lava=TRUE</code>, <code>coefType</code> returns a named vector containing the type of each coefficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### regression ####
m &lt;- lvm(Y~X1+X2)
e &lt;- estimate(m, lava::sim(m, 1e2))

coefType(m)
coefType(e)

#### LVM ####
m &lt;- lvm()
regression(m) &lt;- c(y1,y2,y3)~u
regression(m) &lt;- u~x1+x2
latent(m) &lt;- ~u
covariance(m) &lt;- y1~y2

m.Sim &lt;- m
categorical(m.Sim, labels = c("a","b","c")) &lt;- ~x2
e &lt;- estimate(m, lava::sim(m.Sim, 1e2))

coefType(m)
coefType(e)

## additional categorical variables 
categorical(m, labels = as.character(1:3)) &lt;- "X1"

coefType(m, as.lava = FALSE)

#### LVM with constrains ####
m &lt;- lvm(c(Y1~0+1*eta1,Y2~0+1*eta1,Y3~0+1*eta1,
          Z1~0+1*eta2,Z2~0+1*eta2,Z3~0+1*eta2))
latent(m) &lt;- ~eta1 + eta2
e &lt;- estimate(m, lava::sim(m,1e2))

coefType(m)
coefType(e)

#### multigroup ####
m &lt;- lvm(Y~X1+X2)
eG &lt;- estimate(list(m,m), list(lava::sim(m, 1e2), lava::sim(m, 1e2)))
coefType(eG)

</code></pre>

<hr>
<h2 id='combination'>Form all Unique Combinations Between two Vectors</h2><span id='topic+combination'></span><span id='topic+.combination'></span>

<h3>Description</h3>

<p>Form all unique combinations between two vectors (removing symmetric combinations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.combination(..., levels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combination_+3A_...">...</code></td>
<td>
<p>[vectors] elements to be combined.</p>
</td></tr>
<tr><td><code id="combination_+3A_levels">levels</code></td>
<td>
<p>[logical] should a label for each combination be output as an attribute named levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, each row being a different combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.combination &lt;- lavaSearch2:::.combination

.combination(1,1)
.combination(1:2,1:2)
.combination(c(1:2,1:2),1:2)

.combination(alpha = 1:2, beta = 3:4)
.combination(alpha = 1:2, beta = 3:4, gamma = 1:4)
.combination(alpha = 1:3, beta = 1:3, gamma = 1:3)

</code></pre>

<hr>
<h2 id='combineFormula'>Combine formula</h2><span id='topic+combineFormula'></span>

<h3>Description</h3>

<p>Combine formula by outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineFormula(ls.formula, as.formula = TRUE, as.unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineFormula_+3A_ls.formula">ls.formula</code></td>
<td>
<p>a list of formula</p>
</td></tr>
<tr><td><code id="combineFormula_+3A_as.formula">as.formula</code></td>
<td>
<p>should a list of formula be returned. Otherwise it will be a list of characters.</p>
</td></tr>
<tr><td><code id="combineFormula_+3A_as.unique">as.unique</code></td>
<td>
<p>should regressors appears at most once in the formula</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>combineFormula(list(Y~X1,Y~X3+X5,Y1~X2))
lava.options(symbols = c("~",","))
combineFormula(list("Y~X1","Y~X3+X5","Y1~X2"))
lava.options(symbols = c("&lt;-","&lt;-&gt;"))
combineFormula(list("Y&lt;-X1","Y&lt;-X3+X5","Y1&lt;-X2"))

combineFormula(list(Y~X1,Y~X3+X1,Y1~X2))
combineFormula(list(Y~X1,Y~X3+X1,Y1~X2), as.formula = FALSE)
combineFormula(list(Y~X1,Y~X3+X1,Y1~X2), as.unique = TRUE)

lava.options(symbols = c("~","~~"))
combineFormula(list("Y~X1","Y~X3","Y1~X2"))

</code></pre>

<hr>
<h2 id='compare2'>Test Linear Hypotheses With Small Sample Correction</h2><span id='topic+compare2'></span><span id='topic+compare2.lvmfit'></span><span id='topic+compare2.lvmfit2'></span><span id='topic+compare.lvmfit2'></span>

<h3>Description</h3>

<p>Test Linear Hypotheses using Wald statistics in a latent variable model.
Similar to <code>lava::compare</code> but with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare2(
  object,
  linfct,
  rhs,
  robust,
  cluster,
  as.lava,
  F.test,
  conf.level,
  ...
)

## S3 method for class 'lvmfit'
compare2(
  object,
  linfct = NULL,
  rhs = NULL,
  robust = FALSE,
  cluster = NULL,
  as.lava = TRUE,
  F.test = TRUE,
  conf.level = 0.95,
  ssc = lava.options()$ssc,
  df = lava.options()$df,
  ...
)

## S3 method for class 'lvmfit2'
compare2(
  object,
  linfct = NULL,
  rhs = NULL,
  robust = FALSE,
  cluster = NULL,
  as.lava = TRUE,
  F.test = TRUE,
  conf.level = 0.95,
  ...
)

## S3 method for class 'lvmfit2'
compare(
  object,
  linfct = NULL,
  rhs = NULL,
  robust = FALSE,
  cluster = NULL,
  as.lava = TRUE,
  F.test = TRUE,
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="compare2_+3A_linfct">linfct</code></td>
<td>
<p>[matrix or vector of character] the linear hypotheses to be tested. Same as the argument <code>par</code> of <code><a href="#topic+createContrast">createContrast</a></code>.</p>
</td></tr>
<tr><td><code id="compare2_+3A_rhs">rhs</code></td>
<td>
<p>[vector] the right hand side of the linear hypotheses to be tested.</p>
</td></tr>
<tr><td><code id="compare2_+3A_robust">robust</code></td>
<td>
<p>[logical] should the robust standard errors be used instead of the model based standard errors?</p>
</td></tr>
<tr><td><code id="compare2_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.</p>
</td></tr>
<tr><td><code id="compare2_+3A_as.lava">as.lava</code></td>
<td>
<p>[logical] should the output be similar to the one return by <code>lava::compare</code>?</p>
</td></tr>
<tr><td><code id="compare2_+3A_f.test">F.test</code></td>
<td>
<p>[logical] should a joint test be performed?</p>
</td></tr>
<tr><td><code id="compare2_+3A_conf.level">conf.level</code></td>
<td>
<p>[numeric 0-1] level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="compare2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="compare2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="compare2_+3A_df">df</code></td>
<td>
<p>[character] method used to estimate the degree of freedoms of the Wald statistic: Satterthwaite <code>"satterthwaite"</code>. 
Otherwise (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>) the degree of freedoms are set to <code>Inf</code>.
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>linfct</code> argument and <code>rhs</code> specify the set of linear hypotheses to be tested. They can be written:
</p>
<p style="text-align: center;"><code class="reqn">
  linfct * \theta = rhs
</code>
</p>

<p>where <code class="reqn">\theta</code> is the vector of the model coefficients. <br />
The <code>par</code> argument must contain expression(s) involving the model coefficients.
For example <code>"beta = 0"</code> or <code>c("-5*beta + alpha = 3","-alpha")</code> are valid expressions if alpha and beta belong to the set of model coefficients.
A contrast matrix and the right hand side will be generated inside the function. <br />
</p>
<p>When directly specified, the contrast matrix must contain as many columns as there are coefficients in the model (mean and variance coefficients).
Each hypothesis correspond to a row in the contrast matrix. <br />
</p>
<p>The rhs vector should contain as many elements as there are row in the contrast matrix. <br />
</p>


<h3>Value</h3>

<p>If <code>as.lava=TRUE</code> an object of class <code>htest</code>.
Otherwise a <code>data.frame</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createContrast">createContrast</a></code> to create contrast matrices. <br />
<code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
set.seed(10)
mSim &lt;- lvm(Y~0.1*X1+0.2*X2)
categorical(mSim, labels = c("a","b","c")) &lt;- ~X1
transform(mSim, Id~Y) &lt;- function(x){1:NROW(x)}
df.data &lt;- lava::sim(mSim, 1e2)

#### with lvm ####
m &lt;- lvm(Y~X1+X2)
e.lvm &lt;- estimate(m, df.data)

compare2(e.lvm, linfct = c("Y~X1b","Y~X1c","Y~X2"))
compare2(e.lvm, linfct = c("Y~X1b","Y~X1c","Y~X2"), robust = TRUE)

</code></pre>

<hr>
<h2 id='confint2'>Confidence Intervals With Small Sample Correction</h2><span id='topic+confint2'></span><span id='topic+confint2.lvmfit'></span><span id='topic+model.tables2'></span>

<h3>Description</h3>

<p>Extract confidence intervals of the coefficients from a latent variable model.
Similar to <code>lava::confint</code> but with small sample correction.
</p>
<p>Extract estimate, standard error, confidence intervals and p-values associated to each coefficient of a latent variable model.
Similar to <code>lava::confint</code> but with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confint2(object, robust, cluster, transform, as.lava, conf.level, ...)

## S3 method for class 'lvmfit'
confint2(
  object,
  robust = FALSE,
  cluster = NULL,
  transform = NULL,
  as.lava = TRUE,
  conf.level = 0.95,
  ssc = lava.options()$ssc,
  df = lava.options()$df,
  ...
)

model.tables2(object, robust, cluster, transform, as.lava, conf.level, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="confint2_+3A_robust">robust</code></td>
<td>
<p>[logical] should robust standard errors be used instead of the model based standard errors? Should be <code>TRUE</code> if argument cluster is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="confint2_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.</p>
</td></tr>
<tr><td><code id="confint2_+3A_transform">transform</code></td>
<td>
<p>[function] transformation to be applied.</p>
</td></tr>
<tr><td><code id="confint2_+3A_as.lava">as.lava</code></td>
<td>
<p>[logical] when <code>TRUE</code> uses the same names as when using <code>stats::coef</code>.</p>
</td></tr>
<tr><td><code id="confint2_+3A_conf.level">conf.level</code></td>
<td>
<p>[numeric, 0-1] level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="confint2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="confint2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="confint2_+3A_df">df</code></td>
<td>
<p>[character] method used to estimate the degree of freedoms of the Wald statistic: Satterthwaite <code>"satterthwaite"</code>. 
Otherwise (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>) the degree of freedoms are set to <code>Inf</code>.
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the confidence intervals.
</p>
<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the confidence intervals.
</p>


<h3>Value</h3>

<p>A data.frame with a row per coefficient.
</p>
<p>A data.frame with a row per coefficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
set.seed(10)
dW &lt;- sampleRepeated(10, format = "wide")
set.seed(10)
dL &lt;- sampleRepeated(10, format = "long")
dL$time2 &lt;- paste0("visit",dL$time)

#### latent variable models ####
e.lvm &lt;- estimate(lvm(c(Y1,Y2,Y3) ~ 1*eta + X1, eta ~ Z1), data = dW)
confint(e.lvm)
confint2(e.lvm)
confint2(e.lvm, as.lava = FALSE)
</code></pre>

<hr>
<h2 id='contrast2name'>Create Rownames for a Contrast Matrix</h2><span id='topic+contrast2name'></span><span id='topic+.contrast2name'></span>

<h3>Description</h3>

<p>Create rownames for a contrast matrix using the coefficients and the names of the coefficients. The rownames will be [value * name] == null, e.g. [beta + 4*alpha] = 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.contrast2name(contrast, null = NULL, sep = c("[", "]"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contrast2name_+3A_contrast">contrast</code></td>
<td>
<p>[matrix] a contrast matrix defining the left hand side of the linear hypotheses to be tested.</p>
</td></tr>
<tr><td><code id="contrast2name_+3A_null">null</code></td>
<td>
<p>[vector, optional] the right hand side of the linear hypotheses to be tested.</p>
</td></tr>
<tr><td><code id="contrast2name_+3A_sep">sep</code></td>
<td>
<p>[character of length 2, optional] character used in rownames to wrap the left hand side of the equation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument <code>NULL</code> is null then the rownames will not be put into brackets and the right hand side will not be added to the name.
</p>


<h3>Value</h3>

<p>a character vector.
</p>

<hr>
<h2 id='convFormulaCharacter'>formula character conversion</h2><span id='topic+convFormulaCharacter'></span><span id='topic+formula2character'></span>

<h3>Description</h3>

<p>Conversion of formula into character string or vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula2character(f, type = "formula")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convFormulaCharacter_+3A_f">f</code></td>
<td>
<p>a formula.</p>
</td></tr>
<tr><td><code id="convFormulaCharacter_+3A_type">type</code></td>
<td>
<p>should the normal formula operator be used (<code>"formula"</code>) or the one of lava.option (<code>"symbols"</code> or <code>"symbol"</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>formula2character(Y1~X1+X2)
formula2character(Y1~X1+X2, type = "symbols")
</code></pre>

<hr>
<h2 id='createContrast'>Create Contrast matrix</h2><span id='topic+createContrast'></span><span id='topic+createContrast.character'></span><span id='topic+createContrast.lvmfit'></span><span id='topic+createContrast.lvmfit2'></span><span id='topic+createContrast.list'></span><span id='topic+createContrast.mmm'></span>

<h3>Description</h3>

<p>Returns a contrast matrix corresponding an object.
The contrast matrix will contains the hypotheses in rows and the model coefficients in columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createContrast(object, ...)

## S3 method for class 'character'
createContrast(object, ...)

## S3 method for class 'lvmfit'
createContrast(object, linfct, ...)

## S3 method for class 'lvmfit2'
createContrast(object, linfct, ...)

## S3 method for class 'list'
createContrast(object, linfct = NULL, ...)

## S3 method for class 'mmm'
createContrast(object, linfct = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createContrast_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> object or a list of  a <code>lvmfit</code> objects.</p>
</td></tr>
<tr><td><code id="createContrast_+3A_...">...</code></td>
<td>
<p>Argument to be passed to <code>.createContrast</code>:
</p>

<ul>
<li><p> diff.first [logical] should the contrasts between the first and any of the other coefficients define the null hypotheses.
</p>
</li>
<li><p> add.rowname [logical] add rownames to the contrast matrix and names to the right-hand side.
</p>
</li>
<li><p> rowname.rhs [logical] when naming the hypotheses, add the right-hand side (i.e. &quot;X1-X2=0&quot; instead of &quot;X1-X2&quot;).
</p>
</li>
<li><p> sep [character vector of length2] character surrounding the left part of the row names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="createContrast_+3A_linfct">linfct</code></td>
<td>
<p>[vector of characters] expression defining the linear hypotheses to be tested.
Can also be a regular expression (of length 1) that is used to identify the coefficients to be tested using <code>grep</code>.
See the examples section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One can initialize an empty contrast matrix setting the argument<code>linfct</code> to <code>character(0)</code>. <br /> <br />
</p>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li><p>contrast [matrix] a contrast matrix corresponding to the left hand side of the linear hypotheses.
</p>
</li>
<li><p>null [vector] the right hand side of the linear hypotheses.
</p>
</li>
<li><p>Q [integer] the rank of the contrast matrix.
</p>
</li>
<li><p>ls.contrast [list, optional] the contrast matrix corresponding to each submodel.
Only present when the <code>argument</code> object is a list of models.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data
mSim &lt;- lvm(X ~ Age + Treatment,
            Y ~ Gender + Treatment,
            c(Z1,Z2,Z3) ~ eta, eta ~ treatment,
            Age[40:5]~1)
latent(mSim) &lt;- ~eta
categorical(mSim, labels = c("placebo","SSRI")) &lt;- ~Treatment
categorical(mSim, labels = c("male","female")) &lt;- ~Gender
n &lt;- 1e2
set.seed(10)
df.data &lt;- lava::sim(mSim,n)

## Estimate separate models
lmX &lt;- lava::estimate(lvm(X ~ -1 + Age + Treatment), data = df.data)
lmY &lt;- lava::estimate(lvm(Y ~ -1 + Gender + Treatment), data = df.data)
lvmZ &lt;- lava::estimate(lvm(c(Z1,Z2,Z3) ~ -1 + 1*eta, eta ~ -1 + Treatment), 
                 data = df.data)

## Contrast matrix for a given model
createContrast(lmX, linfct = "X~Age")
createContrast(lmX, linfct = c("X~Age=0","X~Age+5*X~TreatmentSSRI=0"))
createContrast(lmX, linfct = c("X~Age=0","X~Age+5*X~TreatmentSSRI=0"), sep = NULL)
createContrast(lmX, linfct = character(0))

## Contrast matrix for the join model
ls.lvm &lt;- list(X = lmX, Y = lmY, Z = lvmZ)
createContrast(ls.lvm, linfct = "TreatmentSSRI=0")
createContrast(ls.lvm, linfct = "TreatmentSSRI=0", rowname.rhs = FALSE)
createContrast(ls.lvm, linfct = character(0))

## Contrast for multigroup models
m &lt;- lava::lvm(Y~Age+Treatment)
e &lt;- lava::estimate(list(m,m), data = split(df.data, df.data$Gender))
print(coef(e))
createContrast(e, linfct = "Y~TreatmentSSRI@1 - Y~TreatmentSSRI@2 = 0")
createContrast(e, linfct = "Y~TreatmentSSRI@2 - Y~TreatmentSSRI@1 = 0")

</code></pre>

<hr>
<h2 id='createGrid'>Create a Mesh for the Integration</h2><span id='topic+createGrid'></span>

<h3>Description</h3>

<p>Create a mesh for the integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGrid(n, xmin, xmax, d.y, d.z, zmax, fine, double)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createGrid_+3A_n">n</code></td>
<td>
<p>[integer &gt;0] the number of points for the mesh in the x direction.</p>
</td></tr>
<tr><td><code id="createGrid_+3A_xmin">xmin</code></td>
<td>
<p>[numeric] the minimal x value.</p>
</td></tr>
<tr><td><code id="createGrid_+3A_xmax">xmax</code></td>
<td>
<p>[numeric] the maximal x value.</p>
</td></tr>
<tr><td><code id="createGrid_+3A_d.y">d.y</code></td>
<td>
<p>[integer &gt;0] the number of dimensions for the triangle.</p>
</td></tr>
<tr><td><code id="createGrid_+3A_d.z">d.z</code></td>
<td>
<p>[integer &gt;0] the number of dimensions.</p>
</td></tr>
<tr><td><code id="createGrid_+3A_zmax">zmax</code></td>
<td>
<p>[numeric &gt;0] the maximal z value (in absolute value).</p>
</td></tr>
<tr><td><code id="createGrid_+3A_fine">fine</code></td>
<td>
<p>[logical] should the mesh be displayed?</p>
</td></tr>
<tr><td><code id="createGrid_+3A_double">double</code></td>
<td>
<p>[logical] should the grid be just outside the region of interest?
Otherwise it will be just inside.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This create a mesh for integrating over a triangular surface using rectangles.
The domain is define by constrains on three types of variables:
</p>

<ul>
<li><p> the x variable: [unidimensional] that varies freely between [-xmax,-xmin] U [xmin,xmax].
</p>
</li>
<li><p> the y variables: [dimension d.y] constrained to be lower in absolute value than the x variable.
In 2D this corresponds to 2 triangles, and in higher dimension to cones/hypercones.
</p>
</li>
<li><p> the z variables: [dimension d.z] constrained to vary between [-zmax,zmax].
</p>
</li></ul>

<p>The intersection of these three conditions define the domain.
</p>
<p>The mesh is obtained slicing the triangles using rectangles.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> grid: a <code>data.frame</code> where each line corresponds to a point.
</p>
</li>
<li><p> seqNames.min: a <code>character</code> giving the name of the x,y variables (min).
</p>
</li>
<li><p> seqNames.max: a <code>character</code> giving the name of the x,y variables (max).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>createGrid &lt;- lavaSearch2:::createGrid

## no z 
gridInt_2d &lt;- createGrid(5, d.y = 1, xmin = 0, xmax = 4, 
                         d.z = 0, fine = FALSE, double = FALSE)
gridExt_2d &lt;- createGrid(5, d.y = 1, xmin = 0, xmax = 4, 
                         d.z = 0, fine = FALSE, double = TRUE)

gridInt_4d &lt;- createGrid(5, d.y = 3, xmin = 0, xmax = 4, 
                         d.z = 0, fine = FALSE, double = FALSE)
gridExt_4d &lt;- createGrid(5, d.y = 3, xmin = 0, xmax = 4, 
                         d.z = 0, fine = FALSE, double = TRUE)

gridInt_2d &lt;- createGrid(5, d.y = 1, xmin = 0, xmax = 4, 
                         d.z = 0, fine = TRUE, double = FALSE)

##  z
gridIntZ1_2d &lt;- createGrid(5, d.y = 1, xmin = 0, xmax = 4, 
                           d.z = 1, zmax = 2, fine = FALSE, double = FALSE)
gridExtZ1_2d &lt;- createGrid(5, d.y = 1, xmin = 0, xmax = 4, 
                           d.z = 1, zmax = 2, fine = FALSE, double = TRUE)
 
gridIntZ2_4d &lt;- createGrid(5, d.y = 3, xmin = 0, xmax = 4, 
                           d.z = 2, zmax = 2, fine = FALSE, double = FALSE)
gridExtZ2_4d &lt;- createGrid(5, d.y = 3, xmin = 0, xmax = 4, 
                           d.z = 2, zmax = 2, fine = FALSE, double = TRUE)

</code></pre>

<hr>
<h2 id='defineCategoricalLink'>Identify Categorical Links in LVM</h2><span id='topic+defineCategoricalLink'></span><span id='topic+defineCategoricalLink.lvm'></span>

<h3>Description</h3>

<p>Identify categorical links in latent variable models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineCategoricalLink(object, link, data)

## S3 method for class 'lvm'
defineCategoricalLink(object, link = NULL, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineCategoricalLink_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> model.</p>
</td></tr>
<tr><td><code id="defineCategoricalLink_+3A_link">link</code></td>
<td>
<p>[character] the links to be analyzed. If <code>NULL</code>, all the coefficients from the lvm model are used instead.</p>
</td></tr>
<tr><td><code id="defineCategoricalLink_+3A_data">data</code></td>
<td>
<p>[data.frame] the dataset that will be used to fit the model. If <code>NULL</code>, a simulated data will be generated from the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with a description of each link in rows. <br />
The column factitious identify the links that will be replaced with other links
(e.g. &quot;Y1~X1&quot; becomes &quot;Y1~X1b&quot; and &quot;Y1~X1c&quot;). <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
defineCategoricalLink &lt;- lavaSearch2:::defineCategoricalLink
defineCategoricalLink.lvm &lt;- lavaSearch2:::defineCategoricalLink.lvm

## linear model
m &lt;- lvm(Y1~X1+X2,Y2~X1+X3)
categorical(m, K = 3) &lt;- "X1"
try(defineCategoricalLink(m)) # error

categorical(m, K = 3, labels = 1:3) &lt;- "X1"
defineCategoricalLink(m)
defineCategoricalLink(m, "Y~X1")
defineCategoricalLink(m, "X1:0|1")
defineCategoricalLink(m, "X1:1|2")
defineCategoricalLink(m, c("X1:0|1", "X1:1|2"))
defineCategoricalLink(m, c("Y~X1","Y~X2"))
defineCategoricalLink(m, c("Y~X2","Y~X1"))

## latent variable model
m &lt;- lvm()
regression(m) &lt;- c(y1,y2,y3)~u
regression(m) &lt;- u~x1+x2
latent(m) &lt;- ~u
covariance(m) &lt;- y1~y2
categorical(m, labels = as.character(1:3)) &lt;- "X1"

defineCategoricalLink(m)

## End(Not run)

</code></pre>

<hr>
<h2 id='dfSigma'>Degree of Freedom for the Chi-Square Test</h2><span id='topic+dfSigma'></span>

<h3>Description</h3>

<p>Computation of the degrees of freedom of the chi-squared distribution
relative to the model-based variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfSigma(contrast, score, vcov, rvcov, dVcov, dRvcov, keep.param, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfSigma_+3A_contrast">contrast</code></td>
<td>
<p>[numeric vector] the linear combination of parameters to test</p>
</td></tr>
<tr><td><code id="dfSigma_+3A_score">score</code></td>
<td>
<p>[numeric matrix] the individual score for each parameter.</p>
</td></tr>
<tr><td><code id="dfSigma_+3A_vcov">vcov</code></td>
<td>
<p>[numeric matrix] the model-based variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code id="dfSigma_+3A_rvcov">rvcov</code></td>
<td>
<p>[numeric matrix] the robust variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code id="dfSigma_+3A_dvcov">dVcov</code></td>
<td>
<p>[numeric array] the first derivative of the model-based variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code id="dfSigma_+3A_drvcov">dRvcov</code></td>
<td>
<p>[numeric array] the first derivative of the robust variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code id="dfSigma_+3A_keep.param">keep.param</code></td>
<td>
<p>[character vector] the name of the parameters with non-zero first derivative of their variance parameter.</p>
</td></tr>
<tr><td><code id="dfSigma_+3A_type">type</code></td>
<td>
<p>[integer] 1 corresponds to the Satterthwaite approximation of the the degrees of freedom applied to the model-based variance,
2 to the Satterthwaite approximation of the the degrees of freedom applied to the robust variance,
3 to the approximation described in (Pan, 2002) section 2 and 3.1.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wei Pan and Melanie M. Wall, Small-sample adjustments in using the sandwich variance estiamtor in generalized estimating equations. Statistics in medicine (2002) 21:1429-1441.
</p>

<hr>
<h2 id='effects2'>Effects Through Pathways With Small Sample Correction</h2><span id='topic+effects2'></span><span id='topic+effects2.lvmfit'></span><span id='topic+effects2.lvmfit2'></span><span id='topic+effects.lvmfit2'></span>

<h3>Description</h3>

<p>Test whether a path in the latent variable model correspond to a null effect.
Similar to <code>lava::effects</code> but with small sample correction (if any).
So far it only work for a single path related two variable composed of one or two edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effects2(object, linfct, robust, cluster, conf.level, ...)

## S3 method for class 'lvmfit'
effects2(
  object,
  linfct,
  robust = FALSE,
  cluster = NULL,
  conf.level = 0.95,
  to = NULL,
  from = NULL,
  df = lava.options()$df,
  ssc = lava.options()$ssc,
  ...
)

## S3 method for class 'lvmfit2'
effects2(
  object,
  linfct,
  robust = FALSE,
  cluster = NULL,
  conf.level = 0.95,
  to = NULL,
  from = NULL,
  ...
)

## S3 method for class 'lvmfit2'
effects(
  object,
  linfct,
  robust = FALSE,
  cluster = NULL,
  conf.level = 0.95,
  to = NULL,
  from = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effects2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="effects2_+3A_linfct">linfct</code></td>
<td>
<p>[character vector] The path for which the effect should be assessed (e.g. <code>"A~B"</code>),
i.e. the effect of the right variable (B) on the left variable (A).</p>
</td></tr>
<tr><td><code id="effects2_+3A_robust">robust</code></td>
<td>
<p>[logical] should robust standard errors be used instead of the model based standard errors? Should be <code>TRUE</code> if argument cluster is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="effects2_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.</p>
</td></tr>
<tr><td><code id="effects2_+3A_conf.level">conf.level</code></td>
<td>
<p>[numeric, 0-1] level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="effects2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="effects2_+3A_from">from</code>, <code id="effects2_+3A_to">to</code></td>
<td>
<p>alternative to argument <code>linfct</code>. See <code>lava::effects</code>.</p>
</td></tr>
<tr><td><code id="effects2_+3A_df">df</code></td>
<td>
<p>[character] method used to estimate the degree of freedoms of the Wald statistic: Satterthwaite <code>"satterthwaite"</code>. 
Otherwise (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>) the degree of freedoms are set to <code>Inf</code>.
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="effects2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the confidence intervals.
</p>


<h3>Value</h3>

<p>A data.frame with a row per path.
</p>

<hr>
<h2 id='estimate2'>Satterthwaite Correction and Small Sample Correction</h2><span id='topic+estimate2'></span><span id='topic+estimate2.lvm'></span><span id='topic+estimate2.lvmfit'></span><span id='topic+estimate2.list'></span><span id='topic+estimate2.mmm'></span><span id='topic+.sscResiduals'></span>

<h3>Description</h3>

<p>Correct the bias of the ML estimate of the variance and compute the first derivative of the information matrix.
</p>
<p>Compute bias corrected residuals variance covariance matrix
and information matrix.
Also provides the leverage values and corrected sample size when adjust.n is set to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate2(
  object,
  param,
  data,
  ssc,
  df,
  derivative,
  hessian,
  dVcov.robust,
  iter.max,
  tol.max,
  trace,
  ...
)

## S3 method for class 'lvm'
estimate2(
  object,
  param = NULL,
  data = NULL,
  ssc = lava.options()$ssc,
  df = lava.options()$df,
  derivative = "analytic",
  hessian = FALSE,
  dVcov.robust = FALSE,
  iter.max = 100,
  tol.max = 1e-06,
  trace = 0,
  ...
)

## S3 method for class 'lvmfit'
estimate2(
  object,
  param = NULL,
  data = NULL,
  ssc = lava.options()$ssc,
  df = lava.options()$df,
  derivative = "analytic",
  hessian = FALSE,
  dVcov.robust = FALSE,
  iter.max = 100,
  tol.max = 1e-06,
  trace = 0,
  ...
)

## S3 method for class 'list'
estimate2(object, ...)

## S3 method for class 'mmm'
estimate2(object, ...)

.sscResiduals(object, ssc, algorithm = "2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate2_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> object.</p>
</td></tr>
<tr><td><code id="estimate2_+3A_param">param</code></td>
<td>
<p>[numeric vector, optional] the values of the parameters at which to perform the correction.</p>
</td></tr>
<tr><td><code id="estimate2_+3A_data">data</code></td>
<td>
<p>[data.frame, optional] the dataset relative to which the correction should be performed.</p>
</td></tr>
<tr><td><code id="estimate2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="estimate2_+3A_df">df</code></td>
<td>
<p>[character] method used to estimate the degree of freedoms of the Wald statistic: Satterthwaite <code>"satterthwaite"</code>. 
Otherwise (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>) the degree of freedoms are set to <code>Inf</code>.
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="estimate2_+3A_derivative">derivative</code></td>
<td>
<p>[character] should the first derivative of the information matrix be computed using a formula (<code>"analytic"</code>) or numerical derivative (<code>"numeric"</code>)?</p>
</td></tr>
<tr><td><code id="estimate2_+3A_hessian">hessian</code></td>
<td>
<p>[logical] should the hessian be stored? Can be <code>NULL</code> to indicate only if computed during the small sample correction.</p>
</td></tr>
<tr><td><code id="estimate2_+3A_dvcov.robust">dVcov.robust</code></td>
<td>
<p>[logical] should the first derivative of robust variance-covariance matrix be stored?</p>
</td></tr>
<tr><td><code id="estimate2_+3A_iter.max">iter.max</code></td>
<td>
<p>[integer &gt;0] the maximum number of iterations used to estimate the bias correction.</p>
</td></tr>
<tr><td><code id="estimate2_+3A_tol.max">tol.max</code></td>
<td>
<p>[numeric &gt;0] the largest acceptable absolute difference between two succesive estimates of the bias correction.</p>
</td></tr>
<tr><td><code id="estimate2_+3A_trace">trace</code></td>
<td>
<p>[logical] should the execution of the function be traced.</p>
</td></tr>
<tr><td><code id="estimate2_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>lava::estimate</code> when using a <code>lvm</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>value</code> is equivalent to the argument <code>bias.correct</code> of the function <code>summary2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
set.seed(10)
dW &lt;- sampleRepeated(10, format = "wide")

#### latent variable model ####
m.lvm &lt;- lvm(Y1~X1+X2+Z1)

e2.lvm &lt;- estimate2(m.lvm, data = dW)
summary2(e2.lvm)

</code></pre>

<hr>
<h2 id='evalInParentEnv'>Find Object in the Parent Environments</h2><span id='topic+evalInParentEnv'></span>

<h3>Description</h3>

<p>Search an object in the parent environments. For internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalInParentEnv(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalInParentEnv_+3A_name">name</code></td>
<td>
<p>[character] the name of the object to get.</p>
</td></tr>
</table>

<hr>
<h2 id='extractData'>Extract Data From a Latent Variable Model</h2><span id='topic+extractData'></span><span id='topic+extractData.lvmfit'></span>

<h3>Description</h3>

<p>Extract data from a latent variable model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractData(object, design.matrix, as.data.frame, envir, rm.na)

## S3 method for class 'lvmfit'
extractData(
  object,
  design.matrix = FALSE,
  as.data.frame = TRUE,
  envir = environment(),
  rm.na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractData_+3A_object">object</code></td>
<td>
<p>the fitted model.</p>
</td></tr>
<tr><td><code id="extractData_+3A_design.matrix">design.matrix</code></td>
<td>
<p>[logical] should the data be extracted after transformation (e.g. conversion of categorical variables to dummy variables)?
Otherwise the original data will be returned.</p>
</td></tr>
<tr><td><code id="extractData_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>[logical] should the output be converted into a <code>data.frame</code> object?</p>
</td></tr>
<tr><td><code id="extractData_+3A_envir">envir</code></td>
<td>
<p>[environment] the environment from which to search the data.</p>
</td></tr>
<tr><td><code id="extractData_+3A_rm.na">rm.na</code></td>
<td>
<p>[logical] should the lines containing missing values in the dataset be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
set.seed(10)
n &lt;- 101

Y1 &lt;- rnorm(n, mean = 0)
Y2 &lt;- rnorm(n, mean = 0.3)
Id &lt;- findInterval(runif(n), seq(0.1,1,0.1))
data.df &lt;- rbind(data.frame(Y=Y1,G="1",Id = Id),
           data.frame(Y=Y2,G="2",Id = Id)       
           )

#### latent variable model ####
library(lava)
e.lvm &lt;- estimate(lvm(Y ~ G), data = data.df)
extractData(e.lvm)
extractData(e.lvm, design.matrix = TRUE)

</code></pre>

<hr>
<h2 id='findNewLink'>Find all New Links Between Variables</h2><span id='topic+findNewLink'></span><span id='topic+findNewLink.lvm'></span>

<h3>Description</h3>

<p>Find all new links between variables (adapted from lava::modelsearch).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findNewLink(object, ...)

## S3 method for class 'lvm'
findNewLink(
  object,
  data = NULL,
  type = "both",
  exclude.var = NULL,
  rm.latent_latent = FALSE,
  rm.endo_endo = FALSE,
  rm.latent_endo = FALSE,
  output = "names",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNewLink_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> object.</p>
</td></tr>
<tr><td><code id="findNewLink_+3A_...">...</code></td>
<td>
<p>[internal] only used by the generic method.</p>
</td></tr>
<tr><td><code id="findNewLink_+3A_data">data</code></td>
<td>
<p>[optional] a dataset used to identify the categorical variables when not specified in the <code>lvm</code> object.</p>
</td></tr>
<tr><td><code id="findNewLink_+3A_type">type</code></td>
<td>
<p>[character vector] the type of links to be considered: <code>"regression"</code>, <code>"covariance"</code>, or <code>"both"</code>, .</p>
</td></tr>
<tr><td><code id="findNewLink_+3A_exclude.var">exclude.var</code></td>
<td>
<p>[character vector] all links related to these variables will be ignore.</p>
</td></tr>
<tr><td><code id="findNewLink_+3A_rm.latent_latent">rm.latent_latent</code></td>
<td>
<p>[logical] should the links relating two latent variables be ignored?</p>
</td></tr>
<tr><td><code id="findNewLink_+3A_rm.endo_endo">rm.endo_endo</code></td>
<td>
<p>[logical] should the links relating two endogenous variables be ignored?</p>
</td></tr>
<tr><td><code id="findNewLink_+3A_rm.latent_endo">rm.latent_endo</code></td>
<td>
<p>[logical] should the links relating one endogenous variable and one latent variable be ignored?</p>
</td></tr>
<tr><td><code id="findNewLink_+3A_output">output</code></td>
<td>
<p>[character] Specify <code>"names"</code> to return the names of the variables to link
or specify <code>"index"</code> to return their position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> M.links: a matrix with two columns indicating (by name or position) the exogenous and endogenous variable corresponding to each link.
</p>
</li>
<li><p> links: the name of the additional possible links
</p>
</li>
<li><p> directional: a logical vector indicating for each link whether the link is unidirectional (<code>TRUE</code>, i.e. regression link)
or bidirectional (<code>FALSE</code>, i.e. covariance link).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(lava)

m &lt;- lvm()
regression(m) &lt;- c(y1,y2,y3)~u
categorical(m,labels=c("M","F","MF")) &lt;- ~X1
findNewLink(m, rm.endo = FALSE)
findNewLink(m, rm.endo = TRUE)
findNewLink(m, exclude.var = "X1")

regression(m) &lt;- u~x1+x2
latent(m) &lt;- ~u

findNewLink(m, rm.endo = FALSE)
findNewLink(m, rm.endo = TRUE)
findNewLink(m, rm.endo = TRUE, output = "index")
findNewLink(m, type = "covariance")
findNewLink(m, type = "regression")

</code></pre>

<hr>
<h2 id='gaussian_weight'>Estimate LVM With Weights</h2><span id='topic+gaussian_weight'></span><span id='topic+gaussian_weight.estimate.hook'></span><span id='topic+gaussian_weight_method.lvm'></span><span id='topic+gaussian_weight_logLik.lvm'></span><span id='topic+gaussian_weight_objective.lvm'></span><span id='topic+gaussian_weight_score.lvm'></span><span id='topic+gaussian_weight_gradient.lvm'></span><span id='topic+gaussian_weight_hessian.lvm'></span>

<h3>Description</h3>

<p>Estimate LVM with weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_weight.estimate.hook(x, data, estimator, ...)

gaussian_weight_method.lvm

gaussian_weight_logLik.lvm(object, type = "cond", p, data, weights, ...)

gaussian_weight_objective.lvm(x, ...)

gaussian_weight_score.lvm(
  x,
  data,
  p,
  S,
  n,
  mu = NULL,
  weights = NULL,
  debug = FALSE,
  reindex = FALSE,
  mean = TRUE,
  constrain = TRUE,
  indiv = FALSE,
  ...
)

gaussian_weight_gradient.lvm(...)

gaussian_weight_hessian.lvm(x, p, n, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_weight_+3A_x">x</code>, <code id="gaussian_weight_+3A_object">object</code></td>
<td>
<p>A latent variable model</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_estimator">estimator</code></td>
<td>
<p>name of the estimator to be used</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_...">...</code></td>
<td>
<p>passed to lower level functions.</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_type">type</code></td>
<td>
<p>must be &quot;cond&quot;</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_p">p</code></td>
<td>
<p>parameter value</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_weights">weights</code></td>
<td>
<p>weight associated to each iid replicate.</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_s">S</code></td>
<td>
<p>empirical variance-covariance matrix between variable</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_n">n</code></td>
<td>
<p>number of iid replicates</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_mu">mu</code></td>
<td>
<p>empirical mean</p>
</td></tr>
<tr><td><code id="gaussian_weight_+3A_debug">debug</code>, <code id="gaussian_weight_+3A_reindex">reindex</code>, <code id="gaussian_weight_+3A_mean">mean</code>, <code id="gaussian_weight_+3A_constrain">constrain</code>, <code id="gaussian_weight_+3A_indiv">indiv</code></td>
<td>
<p>additional arguments not used</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### linear regression with weights ####

## data
df &lt;- data.frame(Y = c(1,2,2,1,2),
                 X = c(1,1,2,2,2),
                 missing = c(0,0,0,0,1),
                 weights = c(1,1,2,1,NA))

## using lm
e.lm.GS &lt;- lm(Y~X, data = df)
e.lm.test &lt;- lm(Y~X, data = df[df$missing==0,], weights = df[df$missing==0,"weights"])

## using lvm
m &lt;- lvm(Y~X)
e.GS &lt;- estimate(m, df)
## e.lava.test &lt;- estimate(m, df[df$missing==0,], weights = df[df$missing==0,"weights"])
## warnings!!
e.test &lt;- estimate(m, data = df[df$missing==0,],
                   weights = df[df$missing==0,"weights"],
                   estimator = "gaussian_weight")

</code></pre>

<hr>
<h2 id='getIndexOmega'>Identify the Endogenous Variables</h2><span id='topic+getIndexOmega'></span><span id='topic+.getIndexOmega'></span><span id='topic+.getIndexOmega.lvm'></span><span id='topic+.getIndexOmega.lvmfit'></span>

<h3>Description</h3>

<p>Identify the endogenous variables, i.e., returns a vector with length the number of observations,
whose values are the index of the repetitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getIndexOmega(object, data, ...)

## S3 method for class 'lvm'
.getIndexOmega(object, data, ...)

## S3 method for class 'lvmfit'
.getIndexOmega(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIndexOmega_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="getIndexOmega_+3A_data">data</code></td>
<td>
<p>dataset.</p>
</td></tr>
<tr><td><code id="getIndexOmega_+3A_...">...</code></td>
<td>
<p>[internal] Only used by the generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### simulate data ####
set.seed(10)
dW &lt;- sampleRepeated(10, format = "wide")
set.seed(10)
dL &lt;- sampleRepeated(10, format = "long")
dL$time2 &lt;- paste0("visit",dL$time)

#### lvm model ####
e.lvm &lt;- estimate(lvm(c(Y1,Y2,Y3) ~ 1*eta + X1, eta ~ Z1), data = dW)
## lavaSearch2:::.getIndexOmega(e.lvm, data = dW)

## End(Not run)
</code></pre>

<hr>
<h2 id='getNewLink'>Extract the Links that Have Been Found by the modelsearch2.</h2><span id='topic+getNewLink'></span><span id='topic+getNewLink.modelsearch2'></span>

<h3>Description</h3>

<p>Extract the links that have been found relevant by modelsearch2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNewLink(object, step)

## S3 method for class 'modelsearch2'
getNewLink(object, step = 1:nStep(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNewLink_+3A_object">object</code></td>
<td>
<p>a <code>modelsearch2</code> object.</p>
</td></tr>
<tr><td><code id="getNewLink_+3A_step">step</code></td>
<td>
<p>[logical] which test should be extracted?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mSim &lt;- lvm(Y~G+X1+X2)
addvar(mSim) &lt;- ~Z1+Z2+Z3+Z4+Z5+Z6

set.seed(10)
df.data &lt;- lava::sim(mSim, 1e2)

mBase &lt;- lvm(Y~G)
addvar(mBase) &lt;- ~X1+X2+Z1+Z2+Z3+Z4+Z5+Z6
e.lvm &lt;- estimate(mBase, data = df.data)
res &lt;- modelsearch2(e.lvm, method.p.adjust = "holm")
getNewLink(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='getNewModel'>Extract the Model that Has Been Retains by the modelsearch2.</h2><span id='topic+getNewModel'></span><span id='topic+getNewModel.modelsearch2'></span>

<h3>Description</h3>

<p>Extract the model that has been retained by modelsearch2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNewModel(object, step)

## S3 method for class 'modelsearch2'
getNewModel(object, step = nStep(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNewModel_+3A_object">object</code></td>
<td>
<p>a <code>modelsearch2</code> object.</p>
</td></tr>
<tr><td><code id="getNewModel_+3A_step">step</code></td>
<td>
<p>[integer &gt;=0] the step at which the model should be extracted.
0 returns the initial model, i.e. before adding any links.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lvmfit</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mSim &lt;- lvm(Y~G+X1+X2)
addvar(mSim) &lt;- ~Z1+Z2+Z3+Z4+Z5+Z6

set.seed(10)
df.data &lt;- lava::sim(mSim, 1e2)

mBase &lt;- lvm(Y~G)
addvar(mBase) &lt;- ~X1+X2+Z1+Z2+Z3+Z4+Z5+Z6
e.lvm &lt;- estimate(mBase, data = df.data)
res &lt;- modelsearch2(e.lvm, method.p.adjust = "holm")
getNewModel(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='getStep'>Extract one Step From the Sequential Procedure</h2><span id='topic+getStep'></span><span id='topic+getStep.modelsearch2'></span>

<h3>Description</h3>

<p>Extract one step from the sequential procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStep(object, step, slot)

## S3 method for class 'modelsearch2'
getStep(object, step = nStep(object), slot = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStep_+3A_object">object</code></td>
<td>
<p>a <code>modelsearch2</code> object</p>
</td></tr>
<tr><td><code id="getStep_+3A_step">step</code></td>
<td>
<p>[integer &gt;0] which test should be extracted?</p>
</td></tr>
<tr><td><code id="getStep_+3A_slot">slot</code></td>
<td>
<p>[character] the element from the modelsearch2 object that should be extracted.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mSim &lt;- lvm(Y~G+X1+X2)
addvar(mSim) &lt;- ~Z1+Z2+Z3+Z4+Z5+Z6
df.data &lt;- lava::sim(mSim, 1e2)

mBase &lt;- lvm(Y~G)
addvar(mBase) &lt;- ~X1+X2+Z1+Z2+Z3+Z4+Z5+Z6
e.lvm &lt;- estimate(mBase, data = df.data)
res &lt;- modelsearch2(e.lvm, method.p.adjust = "holm")

getStep(res)
getStep(res, slot = "sequenceTest")
getStep(res, step = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='getVarCov2'>Residual Variance-Covariance Matrix With Small Sample Correction.</h2><span id='topic+getVarCov2'></span><span id='topic+getVarCov2.lvmfit'></span><span id='topic+getVarCov2.lvmfit2'></span>

<h3>Description</h3>

<p>Reconstruct the residual variance-covariance matrix from a latent variable model. 
It is similar to <code>nlme::getVarCov</code> but with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVarCov2(object, ...)

## S3 method for class 'lvmfit'
getVarCov2(object, ssc = lava.options()$ssc, ...)

## S3 method for class 'lvmfit2'
getVarCov2(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVarCov2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="getVarCov2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="getVarCov2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the residuals.
</p>


<h3>Value</h3>

<p>A matrix with as many rows and column as the number of endogenous variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
set.seed(10)
n &lt;- 101

Y1 &lt;- rnorm(n, mean = 0)
Y2 &lt;- rnorm(n, mean = 0.3)
Id &lt;- findInterval(runif(n), seq(0.1,1,0.1))
data.df &lt;- rbind(data.frame(Y=Y1,G="1",Id = Id),
           data.frame(Y=Y2,G="2",Id = Id)
           )

#### latent variable models ####
library(lava)
e.lvm &lt;- estimate(lvm(Y ~ G), data = data.df)
getVarCov2(e.lvm)

</code></pre>

<hr>
<h2 id='glht2'>General Linear Hypothesis Testing With Small Sample Correction</h2><span id='topic+glht2'></span><span id='topic+glht2.lvmfit'></span><span id='topic+glht2.lvmfit2'></span><span id='topic+glht2.mmm'></span><span id='topic+glht.lvmfit2'></span>

<h3>Description</h3>

<p>Test linear hypotheses on coefficients from a latent variable models with small sample corrections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glht2(object, ...)

## S3 method for class 'lvmfit'
glht2(
  object,
  linfct,
  rhs = NULL,
  robust = FALSE,
  cluster = NULL,
  ssc = lava.options()$ssc,
  df = lava.options()$df,
  ...
)

## S3 method for class 'lvmfit2'
glht2(object, linfct, rhs = NULL, robust = FALSE, cluster = NULL, ...)

## S3 method for class 'mmm'
glht2(object, linfct, rhs = 0, robust = FALSE, cluster = NULL, ...)

## S3 method for class 'lvmfit2'
glht(model, linfct, rhs = NULL, robust = FALSE, cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glht2_+3A_object">object</code>, <code id="glht2_+3A_model">model</code></td>
<td>
<p>a <code>lvmfit</code>, <code>lvmfit2</code>, or <code>mmm</code> object.</p>
</td></tr>
<tr><td><code id="glht2_+3A_...">...</code></td>
<td>
<p>[logical] arguments passed to lower level methods.</p>
</td></tr>
<tr><td><code id="glht2_+3A_linfct">linfct</code></td>
<td>
<p>[matrix or vector of character] the linear hypotheses to be tested. Same as the argument <code>par</code> of <code><a href="#topic+createContrast">createContrast</a></code>.</p>
</td></tr>
<tr><td><code id="glht2_+3A_rhs">rhs</code></td>
<td>
<p>[vector] the right hand side of the linear hypotheses to be tested.</p>
</td></tr>
<tr><td><code id="glht2_+3A_robust">robust</code></td>
<td>
<p>[logical] should robust standard error be used? 
Otherwise rescale the influence function with the standard error obtained from the information matrix.</p>
</td></tr>
<tr><td><code id="glht2_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.</p>
</td></tr>
<tr><td><code id="glht2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="glht2_+3A_df">df</code></td>
<td>
<p>[character] method used to estimate the degree of freedoms of the Wald statistic: Satterthwaite <code>"satterthwaite"</code>. 
Otherwise (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>) the degree of freedoms are set to <code>Inf</code>.
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whenever the argument linfct is not a matrix, it is passed to the function <code>createContrast</code> to generate the contrast matrix and, if not specified, rhs. <br /> <br />
</p>
<p>Since only one degree of freedom can be specify in a glht object and it must be an integer, the degree of freedom of the denominator of an F test simultaneously testing all hypotheses is retained, after rounding. <br /> <br />
</p>
<p>Argument rhs and null are equivalent.
This redondance enable compatibility between <code>lava::compare</code>, <code>compare2</code>, <code>multcomp::glht</code>, and <code>glht2</code>.
</p>


<h3>Value</h3>

<p>A <code>glht</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createContrast">createContrast</a></code> to create contrast matrices. <br />
<code><a href="#topic+estimate2">estimate2</a></code> to pre-compute quantities for the small sample correction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(multcomp)

## Simulate data
mSim &lt;- lvm(c(Y1,Y2,Y3)~ beta * eta, Z1 ~ E, Z2 ~ E, Age[40:5]~1)
latent(mSim) &lt;- "eta"
set.seed(10)
n &lt;- 1e2

df.data &lt;- lava::sim(mSim, n, latent = FALSE, p = c(beta = 1))

#### Inference on a single model ####
e.lvm &lt;- estimate(lvm(Y1~E), data = df.data)
summary(glht2(e.lvm, linfct = c("Y1~E + Y1","Y1")))

#### Inference on separate models ####
## fit separate models
lvmX &lt;- estimate(lvm(Z1 ~ E), data = df.data)
lvmY &lt;- estimate(lvm(Z2 ~ E + Age), data = df.data)
lvmZ &lt;- estimate(lvm(c(Y1,Y2,Y3) ~ eta, eta ~ E), 
                 data = df.data)

#### create mmm object #### 
e.mmm &lt;- mmm(X = lvmX, Y = lvmY, Z = lvmZ)

#### create contrast matrix ####
resC &lt;- createContrast(e.mmm, linfct = "E")

#### adjust for multiple comparisons ####
e.glht2 &lt;- glht2(e.mmm, linfct = c(X="E"), df = FALSE)
summary(e.glht2)

</code></pre>

<hr>
<h2 id='hessian2'>Hessian With Small Sample Correction.</h2><span id='topic+hessian2'></span><span id='topic+hessian2.lvmfit'></span><span id='topic+hessian2.lvmfit2'></span>

<h3>Description</h3>

<p>Extract the hessian from a latent variable model, with small sample correction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hessian2(object, indiv, cluster, as.lava, ...)

## S3 method for class 'lvmfit'
hessian2(
  object,
  indiv = FALSE,
  cluster = NULL,
  as.lava = TRUE,
  ssc = lava.options()$ssc,
  ...
)

## S3 method for class 'lvmfit2'
hessian2(object, indiv = FALSE, cluster = NULL, as.lava = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hessian2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="hessian2_+3A_indiv">indiv</code></td>
<td>
<p>[logical] If <code>TRUE</code>, the hessian relative to each observation is returned. Otherwise the total hessian is returned.</p>
</td></tr>
<tr><td><code id="hessian2_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.</p>
</td></tr>
<tr><td><code id="hessian2_+3A_as.lava">as.lava</code></td>
<td>
<p>[logical] if <code>TRUE</code>, uses the same names as when using <code>stats::coef</code>.</p>
</td></tr>
<tr><td><code id="hessian2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="hessian2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the hessian.
</p>


<h3>Value</h3>

<p>An array containing the second derivative of the likelihood relative to each sample (dim 3)
and each pair of model coefficients (dim 1,2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
n &lt;- 5e1
p &lt;- 3
X.name &lt;- paste0("X",1:p)
link.lvm &lt;- paste0("Y~",X.name)
formula.lvm &lt;- as.formula(paste0("Y~",paste0(X.name,collapse="+")))

m &lt;- lvm(formula.lvm)
distribution(m,~Id) &lt;- Sequence.lvm(0)
set.seed(10)
d &lt;- lava::sim(m,n)

#### latent variable models ####
e.lvm &lt;- estimate(lvm(formula.lvm),data=d)
hessian2(e.lvm)

</code></pre>

<hr>
<h2 id='hessian2-internal'>Compute the Hessian Matrix From the Conditional Moments</h2><span id='topic+hessian2-internal'></span><span id='topic+.hessian2'></span>

<h3>Description</h3>

<p>Compute the Hessian matrix from the conditional moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.hessian2(
  dmu,
  dOmega,
  d2mu,
  d2Omega,
  epsilon,
  OmegaM1,
  missing.pattern,
  unique.pattern,
  name.pattern,
  grid.mean,
  grid.var,
  grid.hybrid,
  name.param,
  leverage,
  n.cluster,
  weights
)
</code></pre>


<h3>Details</h3>

<p><code>calc_hessian</code> will perform the computation individually when the
argument <code>index.Omega</code> is not null.
</p>

<hr>
<h2 id='iid2'>Influence Function With Small Sample Correction.</h2><span id='topic+iid2'></span><span id='topic+iid2.lvmfit'></span><span id='topic+iid2.lvmfit2'></span><span id='topic+iid.lvmfit2'></span>

<h3>Description</h3>

<p>Extract the influence function from a latent variable model.
It is similar to <code>lava::iid</code> but with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iid2(object, ...)

## S3 method for class 'lvmfit'
iid2(
  object,
  robust = TRUE,
  cluster = NULL,
  as.lava = TRUE,
  ssc = lava.options()$ssc,
  ...
)

## S3 method for class 'lvmfit2'
iid2(object, robust = TRUE, cluster = NULL, as.lava = TRUE, ...)

## S3 method for class 'lvmfit2'
iid(x, robust = TRUE, cluster = NULL, as.lava = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iid2_+3A_object">object</code>, <code id="iid2_+3A_x">x</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="iid2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="iid2_+3A_robust">robust</code></td>
<td>
<p>[logical] if <code>FALSE</code>, the influence function is rescaled such its the squared sum equals the model-based standard error (instead of the robust standard error).
Do not match the model-based correlation though.</p>
</td></tr>
<tr><td><code id="iid2_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.</p>
</td></tr>
<tr><td><code id="iid2_+3A_as.lava">as.lava</code></td>
<td>
<p>[logical] if <code>TRUE</code>, uses the same names as when using <code>stats::coef</code>.</p>
</td></tr>
<tr><td><code id="iid2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients (<code>"none"</code>, <code>"residual"</code>, <code>"cox"</code>). Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the variance-covariance matrix.
</p>


<h3>Value</h3>

<p>A matrix containing the 1st order influence function relative to each sample (in rows)
and each model coefficient (in columns).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
n &lt;- 5e1
p &lt;- 3
X.name &lt;- paste0("X",1:p)
link.lvm &lt;- paste0("Y~",X.name)
formula.lvm &lt;- as.formula(paste0("Y~",paste0(X.name,collapse="+")))

m &lt;- lvm(formula.lvm)
distribution(m,~Id) &lt;- Sequence.lvm(0)
set.seed(10)
d &lt;- sim(m,n)

#### latent variable model ####
e.lvm &lt;- estimate(lvm(formula.lvm),data=d)
iid.tempo &lt;- iid2(e.lvm)


</code></pre>

<hr>
<h2 id='iid2plot'>Display the i.i.d. Decomposition</h2><span id='topic+iid2plot'></span>

<h3>Description</h3>

<p>Extract the i.i.d. decomposition and display it along with the corresponding coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iid2plot(object, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iid2plot_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="iid2plot_+3A_param">param</code></td>
<td>
<p>[character] name of one of the model parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='iidJack'>Jackknife iid Decomposition from Model Object</h2><span id='topic+iidJack'></span><span id='topic+iidJack.default'></span>

<h3>Description</h3>

<p>Extract iid decomposition (i.e. influence function) from model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iidJack(object, ...)

## Default S3 method:
iidJack(
  object,
  data = NULL,
  grouping = NULL,
  cpus = 1,
  keep.warnings = TRUE,
  keep.error = TRUE,
  cl = NULL,
  trace = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iidJack_+3A_object">object</code></td>
<td>
<p>a object containing the model.</p>
</td></tr>
<tr><td><code id="iidJack_+3A_...">...</code></td>
<td>
<p>[internal] only used by the generic method.</p>
</td></tr>
<tr><td><code id="iidJack_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset used to perform the jackknife.</p>
</td></tr>
<tr><td><code id="iidJack_+3A_grouping">grouping</code></td>
<td>
<p>[vector] variable defining cluster of observations that will be simultaneously removed by the jackknife.</p>
</td></tr>
<tr><td><code id="iidJack_+3A_cpus">cpus</code></td>
<td>
<p>[integer &gt;0] the number of processors to use.
If greater than 1, the fit of the model and the computation of the influence function for each jackknife sample is performed in parallel.</p>
</td></tr>
<tr><td><code id="iidJack_+3A_keep.warnings">keep.warnings</code></td>
<td>
<p>[logical] keep warning messages obtained when estimating the model with the jackknife samples.</p>
</td></tr>
<tr><td><code id="iidJack_+3A_keep.error">keep.error</code></td>
<td>
<p>[logical]keep error messages obtained when estimating the model with the jackknife samples.</p>
</td></tr>
<tr><td><code id="iidJack_+3A_cl">cl</code></td>
<td>
<p>[cluster] a parallel socket cluster generated by <code>parallel::makeCluster</code>
that has been registered using <code>registerDoParallel</code>.</p>
</td></tr>
<tr><td><code id="iidJack_+3A_trace">trace</code></td>
<td>
<p>[logical] should a progress bar be used to trace the execution of the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with in row the samples and in columns the parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
set.seed(10)
mSim &lt;- lvm(c(Y1,Y2,Y3,Y4,Y5) ~ 1*eta)
latent(mSim) &lt;- ~eta
categorical(mSim, K=2) &lt;- ~G
transform(mSim, Id ~ eta) &lt;- function(x){1:NROW(x)}
dW &lt;- lava::sim(mSim, n, latent = FALSE)

#### LVM ####
## Not run: 
m1 &lt;- lvm(c(Y1,Y2,Y3,Y4,Y5) ~ 1*eta)
latent(m1) &lt;- ~eta
regression(m1) &lt;- eta ~ G
e &lt;- estimate(m1, data = dW)

iid1 &lt;- iidJack(e)
iid2 &lt;- iid(e)
attr(iid2, "bread") &lt;- NULL

apply(iid1,2,sd)
apply(iid2,2,sd)
quantile(iid2 - iid1)

## End(Not run)


</code></pre>

<hr>
<h2 id='information2'>Expected Information With Small Sample Correction.</h2><span id='topic+information2'></span><span id='topic+information2.lvmfit'></span><span id='topic+information2.lvmfit2'></span><span id='topic+information.lvmfit2'></span>

<h3>Description</h3>

<p>Extract the expected information matrix from a latent variable model.
Similar to <code>lava::information</code> but with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>information2(object, as.lava, ssc, ...)

## S3 method for class 'lvmfit'
information2(object, as.lava = TRUE, ssc = lava.options()$ssc, ...)

## S3 method for class 'lvmfit2'
information2(object, as.lava = TRUE, ...)

## S3 method for class 'lvmfit2'
information(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="information2_+3A_object">object</code>, <code id="information2_+3A_x">x</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="information2_+3A_as.lava">as.lava</code></td>
<td>
<p>[logical] if <code>TRUE</code>, uses the same names as when using <code>stats::coef</code>.</p>
</td></tr>
<tr><td><code id="information2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="information2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the information matrix.
</p>


<h3>Value</h3>

<p>A matrix with as many rows and columns as the number of coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
n &lt;- 5e1
p &lt;- 3
X.name &lt;- paste0("X",1:p)
link.lvm &lt;- paste0("Y~",X.name)
formula.lvm &lt;- as.formula(paste0("Y~",paste0(X.name,collapse="+")))

m &lt;- lvm(formula.lvm)
distribution(m,~Id) &lt;- Sequence.lvm(0)
set.seed(10)
d &lt;- lava::sim(m,n)

#### linear models ####
e.lm &lt;- lm(formula.lvm,data=d)

#### latent variable models ####
e.lvm &lt;- estimate(lvm(formula.lvm),data=d)
information(e.lvm)
information2(e.lvm)
information2(e.lvm)[1:4,1:4] -  solve(vcov(e.lm))

</code></pre>

<hr>
<h2 id='information2-internal'>Compute the Expected Information Matrix From the Conditional Moments</h2><span id='topic+information2-internal'></span><span id='topic+.information2'></span>

<h3>Description</h3>

<p>Compute the expected information matrix from the conditional moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.information2(
  dmu,
  dOmega,
  OmegaM1,
  missing.pattern,
  unique.pattern,
  name.pattern,
  grid.mean,
  grid.var,
  name.param,
  leverage,
  weights = NULL,
  n.cluster
)
</code></pre>


<h3>Details</h3>

<p><code>calc_information</code> will perform the computation individually when the
argument <code>index.Omega</code> is not null.
</p>

<hr>
<h2 id='initVarLink'>Normalize var1 and var2</h2><span id='topic+initVarLink'></span><span id='topic+initVarLinks'></span>

<h3>Description</h3>

<p>Convert var1 and var2 from formula or covariance to character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initVarLink(
  var1,
  var2,
  rep.var1 = FALSE,
  format = "list",
  Slink = c(lava.options()$symbols[1], "~"),
  Scov = lava.options()$symbols[2]
)

initVarLinks(var1, format = "list", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initVarLink_+3A_var1">var1</code></td>
<td>
<p>[character or formula] the exogenous variable of the new link or a formula describing the link.</p>
</td></tr>
<tr><td><code id="initVarLink_+3A_var2">var2</code></td>
<td>
<p>[character] the endogenous variable of the new link.
Disregarded if the argument <code>var1</code> is a formula.</p>
</td></tr>
<tr><td><code id="initVarLink_+3A_rep.var1">rep.var1</code></td>
<td>
<p>[logical] should var1 be duplicated to match var2 length.
Only active if <code>format = "list"</code>.</p>
</td></tr>
<tr><td><code id="initVarLink_+3A_format">format</code></td>
<td>
<p>[character] should the name of the variable be returned (<code>format = "list"</code>),
a vector of character formula (<code>format = "txt.formula"</code>),
or a list of formula (<code>format = "formula"</code>).</p>
</td></tr>
<tr><td><code id="initVarLink_+3A_slink">Slink</code></td>
<td>
<p>[character] the symbol for regression link.</p>
</td></tr>
<tr><td><code id="initVarLink_+3A_scov">Scov</code></td>
<td>
<p>[character] the symbol for covariance link.</p>
</td></tr>
<tr><td><code id="initVarLink_+3A_...">...</code></td>
<td>
<p>argument to be passed to <code>initVarLink</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See argument <code>format</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initVarLink(y ~ x1)
initVarLink("y ~ x1")
initVarLink(y ~ x1 + x2)
initVarLink("y ~ x1 + x2")
initVarLink(y ~ x1 + x2, rep.var1 = TRUE)
initVarLink(y ~ x1 + x2, rep.var1 = TRUE, format = "formula")
initVarLink(y ~ x1 + x2, rep.var1 = TRUE, format = "txt.formula")
initVarLink("y", "x1", format = "formula")

initVarLink("y ~ x1:0|1")

initVarLinks(y ~ x1)
initVarLinks("y ~ x1")
initVarLinks(c("y ~ x1","y~ x2"))
initVarLinks(c(y ~ x1,y ~ x2))
initVarLinks(c("y ~ x1","y ~ x2"), format = "formula")
initVarLinks(c(y ~ x1,y ~ x2), format = "formula")
initVarLinks(c("y ~ x1","y~ x2"), format = "txt.formula")
initVarLinks(c(y ~ x1,y ~ x2), format = "txt.formula")
</code></pre>

<hr>
<h2 id='intDensTri'>Integrate a Gaussian/Student Density over a Triangle</h2><span id='topic+intDensTri'></span>

<h3>Description</h3>

<p>Consider a univariate random variable X,
two multivariate random variables Y and Z,
and t1 and t2 two real numbers.
This function can compute either
P[|X|&gt;t1,|X]&gt;|Y1|,...,|X]&gt;|Yp|] if zmin is not specified,
P[|Z1|&lt;t2,...,|Zq|&lt;t2,|X|&gt;t1,|X]&gt;|Y1|,...,|X]&gt;|Yp|] if zmin is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intDensTri(
  mu,
  Sigma,
  df,
  n,
  x.min,
  z.max = NULL,
  type = "double",
  proba.min = 1e-06,
  prune = NULL,
  distribution = "pmvnorm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intDensTri_+3A_mu">mu</code></td>
<td>
<p>[numeric vector] the expectation of the joint distribution.</p>
</td></tr>
<tr><td><code id="intDensTri_+3A_sigma">Sigma</code></td>
<td>
<p>[matrix] the variance-covariance of the joint distribution.</p>
</td></tr>
<tr><td><code id="intDensTri_+3A_df">df</code></td>
<td>
<p>[integer &gt; 0] the degree of freedom of the joint Student's t distribution.
Only used when <code>distribution="pvmt"</code>.</p>
</td></tr>
<tr><td><code id="intDensTri_+3A_n">n</code></td>
<td>
<p>[integer &gt; 0] number of points for the numerical integration.</p>
</td></tr>
<tr><td><code id="intDensTri_+3A_x.min">x.min</code></td>
<td>
<p>[numeric] the minimum value along the x axis.</p>
</td></tr>
<tr><td><code id="intDensTri_+3A_z.max">z.max</code></td>
<td>
<p>[numeric vector, optional] the maximum value along the z axis.
Define the dimension of Z.</p>
</td></tr>
<tr><td><code id="intDensTri_+3A_type">type</code></td>
<td>
<p>[character] the type of mesh to be used.
Can be <code>\"raw\"</code>, <code>\"double\"</code>, or <code>\"fine\"</code>.</p>
</td></tr>
<tr><td><code id="intDensTri_+3A_proba.min">proba.min</code></td>
<td>
<p>[numeric 0-1] the probability used to find the maximum value along the x axis.
Only used if <code>prune</code> is not specified.</p>
</td></tr>
<tr><td><code id="intDensTri_+3A_prune">prune</code></td>
<td>
<p>[integer &gt;0] number of standard deviations after which the domain ends along the x axis.</p>
</td></tr>
<tr><td><code id="intDensTri_+3A_distribution">distribution</code></td>
<td>
<p>[character] type of joint distribution.
Can be <code>"pmvnorm"</code> (normal distribution) or <code>"pvmt"</code> (Student's t distribution)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>type</code>: </p>

<ul>
<li> <p><code>\"raw\"</code>: mesh with points inside the domain
</p>
</li>
<li> <p><code>\"double\"</code>: mesh with points outside the domain
</p>
</li>
<li> <p><code>\"fine\"</code>: mesh with points inside the domain plus additional rectangles trying to fill the missing domain.
</p>
</li></ul>

<p>Argument <code>Sigma</code> and <code>mu</code>:
define the mean and variance-covariance of the random variables X, Y, Z
(in this order). The length of the argument <code>z.max</code> is used to define the dimension of Z.
The dimension of X is always 1.
</p>


<h3>Value</h3>

<p>A numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)

p &lt;- 2
Sigma &lt;- diag(p)
mu &lt;- rep(0, p)

## bivariate normal distribution
z2 &lt;- qmvt(0.975, mean = mu, sigma = Sigma, df = 1e3)$quantile

# compute integral
intDensTri(mu = mu, Sigma = Sigma, n=5, x.min=0, type = "fine")$value-1/2
intDensTri(mu = mu, Sigma = Sigma, n=30, x.min=0, type = "raw")$value-1/2
intDensTri(mu = mu, Sigma = Sigma, n=50, x.min=0, type = "raw")$value-1/2

intDensTri(mu = mu, Sigma = Sigma, df = 5, n=5, x.min=0, distribution = "pmvt")$value-1/2
res &lt;- intDensTri(mu = mu, Sigma = Sigma, df = 5, n=10, x.min=0, distribution = "pmvt")
res$value-1/2
ggplot2::autoplot(res)

## trivariate normal distribution
## Not run: 
p &lt;- 3
Sigma &lt;- diag(p)
mu &lt;- rep(0, p)

res2 &lt;- intDensTri(mu = mu, Sigma = Sigma, n=5, x.min = 0, z.max = 10)
ggplot2::autoplot(res2)
ggplot2::autoplot(res2, coord.plot = c("x","z1"))
res2

## End(Not run)

#### when the distribution is far from 0
## Not run: 
eq1 &lt;- intDensTri(mu = c(10,0), Sigma = diag(1,2), 
                  x.min = 2, n=10)
eq1$value-1
ggplot2::autoplot(eq1)

eq2 &lt;- intDensTri(mu = c(10,0,0), Sigma = diag(1,3),
                  x.min=2, z.max = 10, type = "raw",
                  n=10)
ggplot2::autoplot(eq2, coord.plot = c("y1","z1"))
eq2$value-1

## more variables
p &lt;- 5
Sigma &lt;- diag(p)
mu &lt;- rep(0, p)

res2 &lt;- intDensTri(mu = mu, Sigma = Sigma, n=5, x.min = 1, z.max = c(2,2))
res2$grid

## End(Not run)

</code></pre>

<hr>
<h2 id='leverage2'>Leverage With Small Sample Correction.</h2><span id='topic+leverage2'></span><span id='topic+leverage2.lvmfit'></span><span id='topic+leverage2.lvmfit2'></span>

<h3>Description</h3>

<p>Extract leverage values from a latent variable model, with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leverage2(object, format, ssc, ...)

## S3 method for class 'lvmfit'
leverage2(object, format = "wide", ssc = lava.options()$ssc, ...)

## S3 method for class 'lvmfit2'
leverage2(object, format = "wide", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leverage2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="leverage2_+3A_format">format</code></td>
<td>
<p>[character] Use <code>"wide"</code> to return the residuals in the wide format (one row relative to each sample).
Otherwise use <code>"long"</code> to return the residuals in the long format.</p>
</td></tr>
<tr><td><code id="leverage2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="leverage2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The leverage are defined as the partial derivative of the fitted values with respect to the observations.
</p>
<p style="text-align: center;"><code class="reqn">
leverage_i = \frac{\partial \hat{Y}_i}{\partial Y_i}
</code>
</p>

<p>See Wei et al. (1998). <br /> <br />
</p>
<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the leverage.
</p>


<h3>Value</h3>

<p>a matrix containing the leverage relative to each sample (in rows)
and each endogenous variable (in column).
</p>


<h3>References</h3>

<p>Bo-Cheng Wei et al., Generalized Leverage and its applications (1998), Scandinavian Journal of Statistics 25:1:25-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
set.seed(10)
m &lt;- lvm(Y1~eta,Y2~eta,Y3~eta)
latent(m) &lt;- ~eta
d &lt;- lava::sim(m,20, latent = FALSE)

#### latent variable models ####
e.lvm &lt;- estimate(m, data = d)
leverage2(e.lvm)

</code></pre>

<hr>
<h2 id='matrixPower'>Power of a Matrix</h2><span id='topic+matrixPower'></span>

<h3>Description</h3>

<p>Compute the power of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixPower(object, power, symmetric, tol = 1e-12, print.warning = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixPower_+3A_object">object</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="matrixPower_+3A_power">power</code></td>
<td>
<p>[numeric] power to be applied to the matrix.</p>
</td></tr>
<tr><td><code id="matrixPower_+3A_symmetric">symmetric</code></td>
<td>
<p>[logical] is the matrix symmetric? Argument passed to the function <code>eigen</code>.</p>
</td></tr>
<tr><td><code id="matrixPower_+3A_tol">tol</code></td>
<td>
<p>[numeric &gt;0] the threshold under which the eigenvalues are set to 0.</p>
</td></tr>
<tr><td><code id="matrixPower_+3A_print.warning">print.warning</code></td>
<td>
<p>[logical] should a warning be print when some or the eigenvalues are not strictly positive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## symmetric matrix
set.seed(10)
M &lt;- matrix(rnorm(20*6),20,6)
Sigma &lt;- var(M)
Sigma.half &lt;- matrixPower(Sigma, power = 1/2, symmetric = TRUE)
round(Sigma.half %*% Sigma.half - Sigma,5)

iSigma &lt;- matrixPower(Sigma, power = -1, symmetric = TRUE)
round(iSigma %*% Sigma,5)

iSigma.half &lt;- matrixPower(Sigma, power = -1/2, symmetric = TRUE)
round(iSigma.half %*% iSigma.half - iSigma,5)

## non symmetric matrix
set.seed(10)
M &lt;- matrix(abs(rnorm(9)), 3, 3) + diag(1,3,3)
M-t(M)

iM &lt;- matrixPower(M, power = -1, symmetric = FALSE)
round(iM %*% M,5)

iM.half &lt;- matrixPower(M, power = -1/2, symmetric = FALSE)
round(iM.half %*% iM.half %*% M,5)

</code></pre>

<hr>
<h2 id='modelsearch2'>Data-driven Extension of a Latent Variable Model</h2><span id='topic+modelsearch2'></span><span id='topic+modelsearch2.lvmfit'></span>

<h3>Description</h3>

<p>Procedure adding relationship between variables that are supported by the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelsearch2(
  object,
  link,
  data,
  method.p.adjust,
  method.maxdist,
  n.sample,
  na.omit,
  alpha,
  nStep,
  trace,
  cpus
)

## S3 method for class 'lvmfit'
modelsearch2(
  object,
  link = NULL,
  data = NULL,
  method.p.adjust = "fastmax",
  method.maxdist = "approximate",
  n.sample = 1e+05,
  na.omit = TRUE,
  alpha = 0.05,
  nStep = NULL,
  trace = TRUE,
  cpus = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelsearch2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_link">link</code></td>
<td>
<p>[character, optional for <code>lvmfit</code> objects] the name of the additional relationships to consider when expanding the model. Should be a vector containing strings like &quot;Y~X&quot;. See the details section.</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_data">data</code></td>
<td>
<p>[data.frame, optional] the dataset used to identify the model</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_method.p.adjust">method.p.adjust</code></td>
<td>
<p>[character] the method used to adjust the p.values for multiple comparisons.
Can be any method that is valid for the <code>stats::p.adjust</code> function (e.g. <code>"fdr"</code>).
Can also be <code>"max"</code>, <code>"fastmax"</code>, or <code>"gof"</code>.</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_method.maxdist">method.maxdist</code></td>
<td>
<p>[character] the method used to estimate the distribution of the max statistic.
<code>"resampling"</code> resample the score under the null to estimate the null distribution.
<code>"bootstrap"</code> performs a wild bootstrap of the iid decomposition of the score to estimate the null distribution.
<code>"approximate"</code> attemps to identify the latent gaussian variable corresponding to each score statistic (that is chi-2 distributed).
It approximates the correlation matrix between these latent gaussian variables and uses numerical integration to compute the distribution of the max.</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_n.sample">n.sample</code></td>
<td>
<p>[integer, &gt;0] number of samples used in the resampling approach.</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_na.omit">na.omit</code></td>
<td>
<p>should tests leading to NA for the test statistic be ignored. Otherwise this will stop the selection process.</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_alpha">alpha</code></td>
<td>
<p>[numeric 0-1] the significance cutoff for the p-values.
When the p-value is below, the corresponding link will be added to the model
and the search will continue. Otherwise the search will stop.</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_nstep">nStep</code></td>
<td>
<p>the maximum number of links that can be added to the model.</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_trace">trace</code></td>
<td>
<p>[logical] should the execution of the function be traced?</p>
</td></tr>
<tr><td><code id="modelsearch2_+3A_cpus">cpus</code></td>
<td>
<p>the number of cpus that can be used for the computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>method.p.adjust = <code>"max"</code> computes the p-values based on the distribution of the max statistic.
This max statistic is the max of the square root of the score statistic.
The p-value are computed integrating the multivariate normal distribution.
</p>
<p>method.p.adjust = <code>"fastmax"</code> only compute the p-value for the largest statistic.
It is faster than <code>"max"</code> and lead to identical results.
</p>
<p>method.p.adjust = <code>"gof"</code> keep adding links until the chi-squared test (of correct specification of the covariance matrix) is no longer significant.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> sequenceTest: the sequence of test that has been performed.
</p>
</li>
<li><p> sequenceModel: the sequence of models that has been obtained.
</p>
</li>
<li><p> sequenceQuantile: the sequence of rejection threshold. Optional. 
</p>
</li>
<li><p> sequenceIID: the influence functions relative to each test. Optional. 
</p>
</li>
<li><p> sequenceSigma: the covariance matrix relative to each test. Optional. 
</p>
</li>
<li><p> initialModel: the model before the sequential search.
</p>
</li>
<li><p> statistic: the argument <code>statistic</code>.
</p>
</li>
<li><p> method.p.adjust: the argument <code>method.p.adjust</code>.
</p>
</li>
<li><p> alpha: [numeric 0-1] the significance cutoff for the p-values.
</p>
</li>
<li><p> cv: whether the procedure has converged.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## simulate data 
mSim &lt;- lvm()
regression(mSim) &lt;- c(y1,y2,y3,y4)~u
regression(mSim) &lt;- u~x1+x2
categorical(mSim,labels=c("A","B","C")) &lt;- "x2"
latent(mSim) &lt;- ~u
covariance(mSim) &lt;- y1~y2
transform(mSim, Id~u) &lt;- function(x){1:NROW(x)}

set.seed(10)
df.data &lt;- lava::sim(mSim, n = 1e2, latent = FALSE)

## only identifiable extensions
m &lt;- lvm(c(y1,y2,y3,y4)~u)
latent(m) &lt;- ~u
addvar(m) &lt;- ~x1+x2

e &lt;- estimate(m, df.data)

## Not run: 
resSearch &lt;- modelsearch(e)
resSearch

resSearch2 &lt;- modelsearch2(e, nStep = 2)
resSearch2

## End(Not run)


## some extensions are not identifiable
m &lt;- lvm(c(y1,y2,y3)~u)
latent(m) &lt;- ~u
addvar(m) &lt;- ~x1+x2 

e &lt;- estimate(m, df.data)

## Not run: 
resSearch &lt;- modelsearch(e)
resSearch
resSearch2 &lt;- modelsearch2(e)
resSearch2

## End(Not run)

## for instance
mNI &lt;- lvm(c(y1,y2,y3)~u)
latent(mNI) &lt;- ~u
covariance(mNI) &lt;- y1~y2
## estimate(mNI, data = df.data)
## does not converge



</code></pre>

<hr>
<h2 id='moments2'>Compute Key Quantities of a Latent Variable Model</h2><span id='topic+moments2'></span><span id='topic+moments2.lvm'></span><span id='topic+moments2.lvmfit'></span>

<h3>Description</h3>

<p>Compute conditional mean, conditional variance, their first and second derivative regarding model parameters, as well as various derivatives of the log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moments2(
  object,
  param,
  data,
  weights,
  Omega,
  Psi,
  initialize,
  usefit,
  update.dmoment,
  update.d2moment,
  score,
  information,
  hessian,
  vcov,
  dVcov,
  dVcov.robust,
  residuals,
  leverage,
  derivative
)

## S3 method for class 'lvm'
moments2(
  object,
  param = NULL,
  data = NULL,
  weights = NULL,
  Omega = NULL,
  Psi = NULL,
  initialize = TRUE,
  usefit = TRUE,
  update.dmoment = TRUE,
  update.d2moment = TRUE,
  score = TRUE,
  information = TRUE,
  hessian = TRUE,
  vcov = TRUE,
  dVcov = TRUE,
  dVcov.robust = TRUE,
  residuals = TRUE,
  leverage = TRUE,
  derivative = "analytic"
)

## S3 method for class 'lvmfit'
moments2(
  object,
  param = NULL,
  data = NULL,
  weights = NULL,
  Omega = NULL,
  Psi = NULL,
  initialize = TRUE,
  usefit = TRUE,
  update.dmoment = TRUE,
  update.d2moment = TRUE,
  score = TRUE,
  information = TRUE,
  hessian = TRUE,
  vcov = TRUE,
  dVcov = TRUE,
  dVcov.robust = TRUE,
  residuals = TRUE,
  leverage = TRUE,
  derivative = "analytic"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moments2_+3A_object">object</code></td>
<td>
<p>a latent variable model.</p>
</td></tr>
<tr><td><code id="moments2_+3A_param">param</code></td>
<td>
<p>[numeric vector] value of the model parameters if different from the estimated ones.</p>
</td></tr>
<tr><td><code id="moments2_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset if different from the one used to fit the model.</p>
</td></tr>
<tr><td><code id="moments2_+3A_psi">Psi</code></td>
<td>
<p>[matrix]  Average first order bias in the residual variance. Only necessary for computing adjusted residuals.</p>
</td></tr>
<tr><td><code id="moments2_+3A_initialize">initialize</code></td>
<td>
<p>[logical] Pre-compute quantities dependent on the data but not on the parameters values.</p>
</td></tr>
<tr><td><code id="moments2_+3A_usefit">usefit</code></td>
<td>
<p>[logical] Compute key quantities based on the parameter values.</p>
</td></tr>
<tr><td><code id="moments2_+3A_update.dmoment">update.dmoment</code></td>
<td>
<p>[logical] should the first derivative of the moments be computed/updated?</p>
</td></tr>
<tr><td><code id="moments2_+3A_update.d2moment">update.d2moment</code></td>
<td>
<p>[logical] should the second derivative of the the moments be computed/updated?</p>
</td></tr>
<tr><td><code id="moments2_+3A_score">score</code></td>
<td>
<p>[logical] should the score be output?</p>
</td></tr>
<tr><td><code id="moments2_+3A_information">information</code></td>
<td>
<p>[logical] should the expected information be output?</p>
</td></tr>
<tr><td><code id="moments2_+3A_hessian">hessian</code></td>
<td>
<p>[logical] should the hessian be output?</p>
</td></tr>
<tr><td><code id="moments2_+3A_vcov">vcov</code></td>
<td>
<p>[logical] should the variance-covariance matrix based on the expected information be output?</p>
</td></tr>
<tr><td><code id="moments2_+3A_dvcov">dVcov</code></td>
<td>
<p>[logical] should the derivative of the variance-covariance matrix be output?</p>
</td></tr>
<tr><td><code id="moments2_+3A_dvcov.robust">dVcov.robust</code></td>
<td>
<p>[logical]  should the derivative of the robust variance-covariance matrix be output?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For lvmfit objects, there are two levels of pre-computation:
</p>

<ul>
<li><p> a basic one that do no involve the model coefficient (<code>conditionalMoment.lvm</code>).
</p>
</li>
<li><p> an advanced one that require the model coefficients (<code>conditionalMoment.lvmfit</code>). 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(Y1~eta,Y2~eta,Y3~eta)
latent(m) &lt;- ~eta

d &lt;- lava::sim(m,1e2)
e &lt;- estimate(m, d)

## basic pre-computation
res1 &lt;- moments2(e, data = d, initialize = TRUE, usefit = FALSE,
                score = TRUE, information = TRUE, hessian = TRUE, vcov = TRUE,
                dVcov = TRUE, dVcov.robust = TRUE, residuals = TRUE, leverage = FALSE,
                derivative = "analytic")
res1$skeleton$param$Sigma

## full pre-computation
res2 &lt;- moments2(e, param = coef(e), data = d, initialize = TRUE, usefit = TRUE,
                score = TRUE, information = TRUE, hessian = TRUE, vcov = TRUE,
                dVcov = TRUE, dVcov.robust = TRUE, residuals = TRUE, leverage = FALSE,
                derivative = "analytic")
res2$moment$Omega

</code></pre>

<hr>
<h2 id='nobs2'>Effective Sample Size.</h2><span id='topic+nobs2'></span><span id='topic+nobs2.lvmfit'></span><span id='topic+nobs2.lvmfit2'></span>

<h3>Description</h3>

<p>Extract the effective sample size, i.e. sample size minus the loss in degrees of freedom caused by the estimation of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nobs2(object, ssc, ...)

## S3 method for class 'lvmfit'
nobs2(object, ssc = lava.options()$ssc, ...)

## S3 method for class 'lvmfit2'
nobs2(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="nobs2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="nobs2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the leverage.
</p>


<h3>Value</h3>

<p>Numeric vector of length the number of endogenous variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>

<hr>
<h2 id='nStep'>Find the Number of Steps Performed During the Sequential Testing</h2><span id='topic+nStep'></span><span id='topic+nStep.modelsearch2'></span>

<h3>Description</h3>

<p>Find the number of steps performed during the sequential testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nStep(object)

## S3 method for class 'modelsearch2'
nStep(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nStep_+3A_object">object</code></td>
<td>
<p>a <code>modelsearch2</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mSim &lt;- lvm(Y~G+X1+X2)
addvar(mSim) &lt;- ~Z1+Z2+Z3+Z4+Z5+Z6
df.data &lt;- lava::sim(mSim, 1e2)

mBase &lt;- lvm(Y~G)
addvar(mBase) &lt;- ~X1+X2+Z1+Z2+Z3+Z4+Z5+Z6
e.lvm &lt;- estimate(mBase, data = df.data)
res &lt;- modelsearch2(e.lvm, method.p.adjust = "holm")
nStep(res)

## End(Not run)

</code></pre>

<hr>
<h2 id='residuals2'>Residuals With Small Sample Correction.</h2><span id='topic+residuals2'></span><span id='topic+residuals2.lvmfit'></span>

<h3>Description</h3>

<p>Extract residuals from a latent variable model.
Similar to <code>stats::residuals</code> but with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals2(object, type, format, ssc, ...)

## S3 method for class 'lvmfit'
residuals2(
  object,
  type = "response",
  format = "wide",
  ssc = lava.options()$ssc,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="residuals2_+3A_type">type</code></td>
<td>
<p>[character] the type of residual to extract:
<code>"response"</code> for raw residuals,
<code>"studentized"</code> for studentized residuals,
<code>"normalized"</code> for normalized residuals.</p>
</td></tr>
<tr><td><code id="residuals2_+3A_format">format</code></td>
<td>
<p>[character] Use <code>"wide"</code> to return the residuals in the wide format (one row relative to each sample).
Otherwise use <code>"long"</code> to return the residuals in the long format.</p>
</td></tr>
<tr><td><code id="residuals2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="residuals2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the residuals.
</p>
<p>The raw residuals are defined by  observation minus the fitted value:
</p>
<p style="text-align: center;"><code class="reqn">
\varepsilon = (Y_1 - \mu_1, ..., Y_m - \mu_m)
</code>
</p>

<p>The studentized residuals divided the raw residuals relative to each endogenous variable by the modeled variance of the endogenous variable.
</p>
<p style="text-align: center;"><code class="reqn">
\varepsilon_{stud} =(\frac{Y_1 - \mu_1}{\sigma_1}, ..., \frac{Y_m - \mu_m}{\sigma_m})
</code>
</p>

<p>The normalized residuals multiply the raw residuals by the inverse of the square root of the modeled residual variance covariance matrix.
</p>
<p style="text-align: center;"><code class="reqn">
\varepsilon_{norm} = \varepsilon \Omega^{-1/2}
</code>
</p>



<h3>Value</h3>

<p>a matrix containing the residuals relative to each sample (in rows)
and each endogenous variable (in column).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
set.seed(10)
n &lt;- 101

Y1 &lt;- rnorm(n, mean = 0)
Y2 &lt;- rnorm(n, mean = 0.3)
Id &lt;- findInterval(runif(n), seq(0.1,1,0.1))
data.df &lt;- rbind(data.frame(Y=Y1,G="1",Id = Id),
           data.frame(Y=Y2,G="2",Id = Id)
           )

#### latent variable models ####
library(lava)
e.lvm &lt;- estimate(lvm(Y ~ G), data = data.df)
residuals(e.lvm)
residuals2(e.lvm)
residuals(e.lvm) - residuals2(e.lvm)

</code></pre>

<hr>
<h2 id='sampleRepeated'>Simulate Repeated Measurements over time</h2><span id='topic+sampleRepeated'></span>

<h3>Description</h3>

<p>Simulate repeated measurements over time (one factor model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleRepeated(n, n.Xcont = 2, n.Xcat = 2, n.rep = 5, format = "long")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleRepeated_+3A_n">n</code></td>
<td>
<p>[integer] sample size.</p>
</td></tr>
<tr><td><code id="sampleRepeated_+3A_n.xcont">n.Xcont</code></td>
<td>
<p>[integer] number of continuous covariates acting on the latent variable.</p>
</td></tr>
<tr><td><code id="sampleRepeated_+3A_n.xcat">n.Xcat</code></td>
<td>
<p>[integer] number of categorical covariates acting on the latent variable.</p>
</td></tr>
<tr><td><code id="sampleRepeated_+3A_n.rep">n.rep</code></td>
<td>
<p>[integer] number of measurement of the response variable.</p>
</td></tr>
<tr><td><code id="sampleRepeated_+3A_format">format</code></td>
<td>
<p>[character] should the dataset be returned in the <code>"long"</code> format or in the <code>"wide"</code> format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sampleRepeated(10, format = "wide")
sampleRepeated(10, format = "long")
</code></pre>

<hr>
<h2 id='score2'>Score With Small Sample Correction</h2><span id='topic+score2'></span><span id='topic+score2.lvmfit'></span><span id='topic+score2.lvmfit2'></span><span id='topic+score.lvmfit2'></span>

<h3>Description</h3>

<p>Extract the (individual) score a the latent variable model.
Similar to <code>lava::score</code> but with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score2(object, indiv, cluster, as.lava, ...)

## S3 method for class 'lvmfit'
score2(
  object,
  indiv = FALSE,
  cluster = NULL,
  as.lava = TRUE,
  ssc = lava.options()$ssc,
  ...
)

## S3 method for class 'lvmfit2'
score2(object, indiv = FALSE, cluster = NULL, as.lava = TRUE, ...)

## S3 method for class 'lvmfit2'
score(x, indiv = FALSE, cluster = NULL, as.lava = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score2_+3A_object">object</code>, <code id="score2_+3A_x">x</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="score2_+3A_indiv">indiv</code></td>
<td>
<p>[logical] If <code>TRUE</code>, the score relative to each observation is returned. Otherwise the total score is returned.</p>
</td></tr>
<tr><td><code id="score2_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.</p>
</td></tr>
<tr><td><code id="score2_+3A_as.lava">as.lava</code></td>
<td>
<p>[logical] if <code>TRUE</code>, uses the same names as when using <code>stats::coef</code>.</p>
</td></tr>
<tr><td><code id="score2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="score2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the confidence intervals.
</p>


<h3>Value</h3>

<p>When argument indiv is <code>TRUE</code>, a matrix containing the score relative to each sample (in rows)
and each model coefficient (in columns). Otherwise a numeric vector of length the number of model coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
n &lt;- 5e1
p &lt;- 3
X.name &lt;- paste0("X",1:p)
link.lvm &lt;- paste0("Y~",X.name)
formula.lvm &lt;- as.formula(paste0("Y~",paste0(X.name,collapse="+")))

m &lt;- lvm(formula.lvm)
distribution(m,~Id) &lt;- Sequence.lvm(0)
set.seed(10)
d &lt;- lava::sim(m,n)

#### linear models ####
e.lm &lt;- lm(Y~X1+X2+X3, data = d)

#### latent variable models ####
m.lvm &lt;- lvm(formula.lvm)
e.lvm &lt;- estimate(m.lvm,data=d)
e2.lvm &lt;- estimate2(m.lvm,data=d)
score.tempo &lt;- score(e2.lvm, indiv = TRUE)
colSums(score.tempo)

</code></pre>

<hr>
<h2 id='score2-internal'>Compute the Corrected Score.</h2><span id='topic+score2-internal'></span><span id='topic+.score2'></span>

<h3>Description</h3>

<p>Compute the corrected score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.score2(
  dmu,
  dOmega,
  epsilon,
  OmegaM1,
  missing.pattern,
  unique.pattern,
  name.pattern,
  name.param,
  name.meanparam,
  name.varparam,
  n.cluster,
  weights
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score2-internal_+3A_n.cluster">n.cluster</code></td>
<td>
<p>[integer &gt;0] the number of observations.</p>
</td></tr>
</table>

<hr>
<h2 id='sCorrect'>Depreciated Method For Small Sample Correction</h2><span id='topic+sCorrect'></span><span id='topic+sCorrect.default'></span><span id='topic+sCorrect+3C-'></span><span id='topic+sCorrect+3C-.default'></span>

<h3>Description</h3>

<p>Depreciated method for small sample correction, now replaced by the <code><a href="#topic+estimate2">estimate2</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sCorrect(object, ...)

## Default S3 method:
sCorrect(object, ...)

sCorrect(x, ...) &lt;- value

## Default S3 replacement method:
sCorrect(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sCorrect_+3A_object">object</code>, <code id="sCorrect_+3A_x">x</code></td>
<td>
<p>a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="sCorrect_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="sCorrect_+3A_value">value</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>

<hr>
<h2 id='selectRegressor'>Regressor of a Formula.</h2><span id='topic+selectRegressor'></span><span id='topic+selectRegressor.formula'></span>

<h3>Description</h3>

<p>Return the regressor variables contained in the formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectRegressor(object, ...)

## S3 method for class 'formula'
selectRegressor(object, format = "call", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectRegressor_+3A_object">object</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="selectRegressor_+3A_...">...</code></td>
<td>
<p>[internal] Only used by the generic method.</p>
</td></tr>
<tr><td><code id="selectRegressor_+3A_format">format</code></td>
<td>
<p>[character] should an object of format call be returned (<code>format = "call"</code>),
or the names of the variables (<code>format = "vars"</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

selectRegressor &lt;- lavaSearch2:::selectRegressor
selectRegressor.formula &lt;- lavaSearch2:::selectRegressor.formula

selectRegressor(Y1~X1+X2)
selectRegressor(Y1~X1+X2, format = "vars")

selectRegressor(Y1~X1+Y1)
selectRegressor(Y1+Y2~X1+Y1, format = "vars")

selectRegressor(~X1+X2)
selectRegressor(~X1+X2, format = "vars")


## End(Not run)
</code></pre>

<hr>
<h2 id='selectResponse'>Response Variable of a Formula</h2><span id='topic+selectResponse'></span><span id='topic+selectResponse.formula'></span>

<h3>Description</h3>

<p>Return the response variable contained in the formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectResponse(object, ...)

## S3 method for class 'formula'
selectResponse(object, format = "call", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectResponse_+3A_object">object</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="selectResponse_+3A_...">...</code></td>
<td>
<p>[internal] Only used by the generic method.</p>
</td></tr>
<tr><td><code id="selectResponse_+3A_format">format</code></td>
<td>
<p>[character] should an object of type call be returned (<code>format = "call"</code>),
or the names of the variables (<code>format = "vars"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See argument <code>format</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

selectResponse &lt;- lavaSearch2:::selectResponse
selectResponse.formula &lt;- lavaSearch2:::selectResponse.formula

selectResponse(Y1~X1+X2)
selectResponse(Y1~X1+X2, format = "vars")
selectResponse(Surv(event,time)~X1+X2, format = "vars")

selectResponse(Y1~X1+Y1)
selectResponse(Y1+Y2~X1+Y1, format = "vars")

selectResponse(~X1+X2)
selectResponse(~X1+X2, format = "vars")

## End(Not run)

</code></pre>

<hr>
<h2 id='setLink'>Set a Link to a Value</h2><span id='topic+setLink'></span><span id='topic+setLink.lvm'></span>

<h3>Description</h3>

<p>Generic interface to set a value to a link in a <code>lvm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLink(object, ...)

## S3 method for class 'lvm'
setLink(object, var1, var2, value, warnings = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setLink_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> object.</p>
</td></tr>
<tr><td><code id="setLink_+3A_...">...</code></td>
<td>
<p>[internal] only used by the generic method.</p>
</td></tr>
<tr><td><code id="setLink_+3A_var1">var1</code></td>
<td>
<p>[character or formula] the exogenous variable of the new link or a formula describing the link to be added to the lvm.</p>
</td></tr>
<tr><td><code id="setLink_+3A_var2">var2</code></td>
<td>
<p>[character] the endogenous variable of the new link. Disregarded if the argument <code>var1</code> is a formula.</p>
</td></tr>
<tr><td><code id="setLink_+3A_value">value</code></td>
<td>
<p>[numeric] the value at which the link should be set.</p>
</td></tr>
<tr><td><code id="setLink_+3A_warnings">warnings</code></td>
<td>
<p>[logical] should a warning be displayed if the link is not found in the <code>lvm</code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(lava)
set.seed(10)

m &lt;- lvm()
regression(m) &lt;- c(y1,y2,y3)~u
regression(m) &lt;- u~x1+x2
latent(m) &lt;- ~u
covariance(m) &lt;- y1 ~ y2

m1 &lt;- setLink(m, y3 ~ u, value = 1)
estimate(m1, lava::sim(m,1e2))
# m1 &lt;- setLink(m, u ~ y3, value = 1)

m2 &lt;- setLink(m, y1 ~ y2, value = 0.5)
estimate(m2, lava::sim(m,1e2))

</code></pre>

<hr>
<h2 id='skeleton'>Pre-computation for the Score</h2><span id='topic+skeleton'></span><span id='topic+skeletonDtheta'></span><span id='topic+skeletonDtheta2'></span>

<h3>Description</h3>

<p>Pre-compute quantities that are necessary to compute the score of a lvm model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skeleton(object, X, endogenous, latent, n.cluster, index.Omega)

skeletonDtheta(
  object,
  X,
  endogenous,
  latent,
  missing.pattern,
  unique.pattern,
  name.pattern,
  n.cluster,
  index.Omega
)

skeletonDtheta2(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skeleton_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> object.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_x">X</code></td>
<td>
<p>[matrix] design matrix containing the covariates for each endogeneous and latent variable.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_endogenous">endogenous</code></td>
<td>
<p>[character vector] the name of the endogeneous variables.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_latent">latent</code></td>
<td>
<p>[character vector] the name of the latent variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the user specifies names for the coefficients (e.g. Y1[mu:sigma]) or uses constraints (Y1~beta*X1), <code>as.lava=FALSE</code> will use the names specified by the user (e.g. mu, sigma, beta)
while <code>as.lava=TRUE</code> will use the name of the first link defining the coefficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
skeleton &lt;- lavaSearch2::skeleton
skeleton.lvm &lt;- lavaSearch2::skeleton.lvm
skeleton.lvmfit &lt;- lavaSearch2::skeleton.lvmfit

## without constrain
m &lt;- lvm(Y1~X1+X2+eta,Y2~X3+eta,Y3~eta)
latent(m) &lt;- ~eta

e &lt;- estimate(m, lava::sim(m,1e2))
M.data &lt;- as.matrix(model.frame(e))

skeleton(e$model, as.lava = TRUE,
         name.endogenous = endogenous(e), n.endogenous = 3,
         name.latent = latent(e), 
         update.value = FALSE)
skeleton(e, data = M.data, p = pars(e), as.lava = TRUE,
         name.endogenous = endogenous(e), n.endogenous = 3,
         name.latent = latent(e), 
         update.value = TRUE)

## with constrains
m &lt;- lvm(Y[mu:sigma] ~ beta*X1+X2)
e &lt;- estimate(m, lava::sim(m,1e2))
M.data &lt;- as.matrix(model.frame(e))

skeleton(e$model, as.lava = TRUE,
         name.endogenous = "Y", n.endogenous = 1,
         name.latent = NULL, 
         update.value = FALSE)$skeleton

skeleton(e, data = M.data, p = pars(e), as.lava = FALSE,
         name.endogenous = "Y", n.endogenous = 1,
         name.latent = NULL, 
         update.value = FALSE)$skeleton


## End(Not run)
</code></pre>

<hr>
<h2 id='summary.calibrateType1'>Display the Type 1 Error Rate</h2><span id='topic+summary.calibrateType1'></span>

<h3>Description</h3>

<p>Display the type 1 error rate from the simulation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calibrateType1'
summary(
  object,
  robust = FALSE,
  type = "type1error",
  alpha = 0.05,
  log.transform = TRUE,
  digits = 5,
  print = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.calibrateType1_+3A_object">object</code></td>
<td>
<p>output of the <code>calibrateType1</code> function.</p>
</td></tr>
<tr><td><code id="summary.calibrateType1_+3A_robust">robust</code></td>
<td>
<p>[character] should the results be displayed for both model-based and robust standard errors (<code>TRUE</code>),
only  model-based standard error (<code>FALSE</code>), or only robust standard error (<code>"only"</code>)?</p>
</td></tr>
<tr><td><code id="summary.calibrateType1_+3A_type">type</code></td>
<td>
<p>[character] should the type 1 error rate be diplayed (<code>"type1error"</code>) or the bias (<code>"bias")</code>.</p>
</td></tr>
<tr><td><code id="summary.calibrateType1_+3A_alpha">alpha</code></td>
<td>
<p>[numeric, 0-1] the confidence levels.</p>
</td></tr>
<tr><td><code id="summary.calibrateType1_+3A_log.transform">log.transform</code></td>
<td>
<p>[logical] should the confidence intervals be computed on the logit scale.</p>
</td></tr>
<tr><td><code id="summary.calibrateType1_+3A_digits">digits</code></td>
<td>
<p>[integer &gt;0] the number of decimal places to use when displaying the summary.</p>
</td></tr>
<tr><td><code id="summary.calibrateType1_+3A_print">print</code></td>
<td>
<p>should the summary be printed in the terminal.</p>
</td></tr>
<tr><td><code id="summary.calibrateType1_+3A_...">...</code></td>
<td>
<p>[internal] only used by the generic method.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.glht2'>Outcome of Linear Hypothesis Testing</h2><span id='topic+summary.glht2'></span>

<h3>Description</h3>

<p>Estimates, p-values, and confidence intevals for linear hypothesis testing, possibly adjusted for multiple comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glht2'
summary(
  object,
  confint = TRUE,
  conf.level = 0.95,
  transform = NULL,
  seed = NULL,
  rowname.rhs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.glht2_+3A_object">object</code></td>
<td>
<p>a <code>glht2</code> object.</p>
</td></tr>
<tr><td><code id="summary.glht2_+3A_confint">confint</code></td>
<td>
<p>[logical] should confidence intervals be output</p>
</td></tr>
<tr><td><code id="summary.glht2_+3A_conf.level">conf.level</code></td>
<td>
<p>[numeric 0-1] level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="summary.glht2_+3A_transform">transform</code></td>
<td>
<p>[function] function to backtransform the estimates, standard errors, null hypothesis, and the associated confidence intervals
(e.g. <code>exp</code> if the outcomes have been log-transformed).</p>
</td></tr>
<tr><td><code id="summary.glht2_+3A_seed">seed</code></td>
<td>
<p>[integer] value that will be set before adjustment for multiple comparisons to ensure reproducible results.
Can also be <code>NULL</code>: in such a case no seed is set.</p>
</td></tr>
<tr><td><code id="summary.glht2_+3A_rowname.rhs">rowname.rhs</code></td>
<td>
<p>[logical] when naming the hypotheses, add the right-hand side (i.e. &quot;X1-X2=0&quot; instead of &quot;X1-X2&quot;).</p>
</td></tr>
<tr><td><code id="summary.glht2_+3A_...">...</code></td>
<td>
<p>argument passed to <code>multcomp:::summary.glht</code>, e.g. argument <code>test</code> to choose the type of adjustment for multiple comparisons.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.modelsearch2'>summary Method for modelsearch2 Objects</h2><span id='topic+summary.modelsearch2'></span>

<h3>Description</h3>

<p>summary method for modelsearch2 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelsearch2'
summary(object, print = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.modelsearch2_+3A_object">object</code></td>
<td>
<p>output of the <code>modelsearch2</code> function.</p>
</td></tr>
<tr><td><code id="summary.modelsearch2_+3A_print">print</code></td>
<td>
<p>should the summary be printed in the terminal.</p>
</td></tr>
<tr><td><code id="summary.modelsearch2_+3A_...">...</code></td>
<td>
<p>[internal] only used by the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The column <code>dp.Info</code> contains the percentage of extended models (i.e. model with one additional link)
for which the information matrix evaluated at the value of the parameters of the initial model is non positive definie.
</p>

<hr>
<h2 id='summary2'>Latent Variable Model Summary After Small Sample Correction</h2><span id='topic+summary2'></span><span id='topic+summary2.lvmfit'></span><span id='topic+summary2.lvmfit2'></span><span id='topic+summary.lvmfit2'></span>

<h3>Description</h3>

<p>Summarize a fitted latent variable model.
Similar to <code>stats::summary</code> with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary2(object, robust, cluster, digit, ...)

## S3 method for class 'lvmfit'
summary2(
  object,
  robust = FALSE,
  cluster = NULL,
  digit = max(5, getOption("digit")),
  ssc = lava.options()$ssc,
  df = lava.options()$df,
  ...
)

## S3 method for class 'lvmfit2'
summary2(
  object,
  robust = FALSE,
  cluster = NULL,
  digit = max(5, getOption("digit")),
  ...
)

## S3 method for class 'lvmfit2'
summary(
  object,
  robust = FALSE,
  cluster = NULL,
  digit = max(5, getOption("digit")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="summary2_+3A_robust">robust</code></td>
<td>
<p>[logical] should robust standard errors be used instead of the model based standard errors? Should be <code>TRUE</code> if argument cluster is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="summary2_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.</p>
</td></tr>
<tr><td><code id="summary2_+3A_digit">digit</code></td>
<td>
<p>[integer &gt; 0] the number of decimal places to use when displaying the summary.</p>
</td></tr>
<tr><td><code id="summary2_+3A_...">...</code></td>
<td>
<p>[logical] arguments passed to lower level methods.</p>
</td></tr>
<tr><td><code id="summary2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="summary2_+3A_df">df</code></td>
<td>
<p>[character] method used to estimate the degree of freedoms of the Wald statistic: Satterthwaite <code>"satterthwaite"</code>. 
Otherwise (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>) the degree of freedoms are set to <code>Inf</code>.
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary2</code> is the same as <code>summary</code>
except that it first computes the small sample correction (but does not store it).
So if <code>summary2</code> is to be called several times,
it is more efficient to pre-compute the quantities for the small sample correction
using <code>sCorrect</code> and then call <code>summary2</code>.
</p>
<p><code>summary2</code> returns an object with an element <code>table2</code> containing the estimates, standard errors, degrees of freedom,
upper and lower limits of the confidence intervals, test statistics, and p-values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
m &lt;- lvm(Y~X1+X2)
set.seed(10)
d &lt;- lava::sim(m, 2e1)

#### latent variable models ####
e.lvm &lt;- estimate(m, data = d)
summary(e.lvm)$coef

summary2(e.lvm)
summary2(e.lvm, ssc = "none")

</code></pre>

<hr>
<h2 id='symmetrize'>Symmetrize a Matrix</h2><span id='topic+symmetrize'></span>

<h3>Description</h3>

<p>Complete the upper (or lower) extra-diagonal terms  in order to obtain a symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetrize(M, update.upper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetrize_+3A_m">M</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="symmetrize_+3A_update.upper">update.upper</code></td>
<td>
<p>[logical] should the upper extra diagonal terms be updated using the lower extra diagonal terms?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>symmetrize &lt;- lavaSearch2:::symmetrize

## example
M &lt;- matrix(NA, 4, 4)
M[lower.tri(M)] &lt;- 1:6

symmetrize(M, update.upper = TRUE) # good

M[upper.tri(M, diag = FALSE)] &lt;- M[lower.tri(M, diag = FALSE)]
M # wrong
</code></pre>

<hr>
<h2 id='transformSummaryTable'>Apply Transformation to Summary Table</h2><span id='topic+transformSummaryTable'></span>

<h3>Description</h3>

<p>Update summary table according to a transformation, e.g. log-transformtion.
P-values are left unchanged but estimates, standard errors, and confidence intervals are updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformSummaryTable(object, transform = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformSummaryTable_+3A_object">object</code></td>
<td>
<p>A data.frame with columns estimate, se, lower, upper.</p>
</td></tr>
<tr><td><code id="transformSummaryTable_+3A_transform">transform</code></td>
<td>
<p>the name of a transformation or a function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame
</p>

<hr>
<h2 id='tryWithWarnings'>Run an Expression and Catch Warnings and Errors</h2><span id='topic+tryWithWarnings'></span>

<h3>Description</h3>

<p>Similar to <code>try</code> but also returns warnings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryWithWarnings(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tryWithWarnings_+3A_expr">expr</code></td>
<td>
<p>the line of code to be evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>from https://stackoverflow.com/questions/4948361/how-do-i-save-warnings-and-errors-as-output-from-a-function
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> value the result of the evaluation of the expression
</p>
</li>
<li><p> warnings warning(s) generated during the evaluation of the expression
</p>
</li>
<li><p> error error generated during the evaluation of the expression
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>FctTest &lt;- function(x){
  return(log(x))
}
tryWithWarnings(FctTest(-1))
tryWithWarnings(FctTest(1))
tryWithWarnings(FctTest(xxxx))

</code></pre>

<hr>
<h2 id='var2dummy'>Convert Variable Names to Dummy Variables Names.</h2><span id='topic+var2dummy'></span><span id='topic+var2dummy.list'></span><span id='topic+var2dummy.lvm'></span>

<h3>Description</h3>

<p>When dealing with categorical variables, the <code>estimate</code> function convert the categorical variables into dummy variables.
This function convert a set of variable names to their corresponding name in the model with dummy variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var2dummy(object, ...)

## S3 method for class 'list'
var2dummy(object, var, rm.first.factor = TRUE, ...)

## S3 method for class 'lvm'
var2dummy(object, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var2dummy_+3A_object">object</code></td>
<td>
<p>a <code>lvm</code> object.</p>
</td></tr>
<tr><td><code id="var2dummy_+3A_...">...</code></td>
<td>
<p>[internal] additional arguments to be passed from <code>var2dummy.lvm</code> to <code>var2dummy.list</code>.</p>
</td></tr>
<tr><td><code id="var2dummy_+3A_var">var</code></td>
<td>
<p>[character] the variable to be transformed.</p>
</td></tr>
<tr><td><code id="var2dummy_+3A_rm.first.factor">rm.first.factor</code></td>
<td>
<p>[logical] should the first level of each categorical variable be ignored?</p>
</td></tr>
<tr><td><code id="var2dummy_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset according to which the model should be updated.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
var2dummy &lt;- lavaSearch2:::var2dummy
var2dummy.list &lt;- lavaSearch2:::var2dummy.list
var2dummy.lvm &lt;- lavaSearch2:::var2dummy.lvm

m &lt;- lvm()
regression(m) &lt;- c(y1,y2,y3)~u
regression(m) &lt;- u ~ X1+X2
var2dummy(m, var = c("X1","X2"))
categorical(m,labels=c("M","F","MF")) &lt;- ~X1
var2dummy(m, var = c("X1","X2"))
categorical(m,labels=c("1","2","3")) &lt;- ~X2
var2dummy(m, var = c("X1","X2"))

## End(Not run)

</code></pre>

<hr>
<h2 id='vcov2'>Variance-Covariance With Small Sample Correction</h2><span id='topic+vcov2'></span><span id='topic+vcov2.lvmfit'></span><span id='topic+vcov2.lvmfit2'></span><span id='topic+vcov.lvmfit2'></span>

<h3>Description</h3>

<p>Extract the variance-covariance matrix from a latent variable model.
Similar to <code>stats::vcov</code> but with small sample correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcov2(object, robust, cluster, as.lava, ...)

## S3 method for class 'lvmfit'
vcov2(
  object,
  robust = FALSE,
  cluster = NULL,
  as.lava = TRUE,
  ssc = lava.options()$ssc,
  ...
)

## S3 method for class 'lvmfit2'
vcov2(object, robust = FALSE, cluster = NULL, as.lava = TRUE, ...)

## S3 method for class 'lvmfit2'
vcov(object, robust = FALSE, cluster = NULL, as.lava = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov2_+3A_object">object</code></td>
<td>
<p>a <code>lvmfit</code> or <code>lvmfit2</code> object (i.e. output of <code>lava::estimate</code> or <code>lavaSearch2::estimate2</code>).</p>
</td></tr>
<tr><td><code id="vcov2_+3A_robust">robust</code></td>
<td>
<p>[logical] should robust standard errors be used instead of the model based standard errors? Should be <code>TRUE</code> if argument cluster is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vcov2_+3A_cluster">cluster</code></td>
<td>
<p>[integer vector] the grouping variable relative to which the observations are iid.</p>
</td></tr>
<tr><td><code id="vcov2_+3A_as.lava">as.lava</code></td>
<td>
<p>[logical] if <code>TRUE</code>, uses the same names as when using <code>stats::coef</code>.</p>
</td></tr>
<tr><td><code id="vcov2_+3A_...">...</code></td>
<td>
<p>additional argument passed to <code>estimate2</code> when using a <code>lvmfit</code> object.</p>
</td></tr>
<tr><td><code id="vcov2_+3A_ssc">ssc</code></td>
<td>
<p>[character] method used to correct the small sample bias of the variance coefficients: no correction (<code>"none"</code>/<code>FALSE</code>/<code>NA</code>),
correct the first order bias in the residual variance (<code>"residual"</code>), or correct the first order bias in the estimated coefficients <code>"cox"</code>).
Only relevant when using a <code>lvmfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When argument object is a <code>lvmfit</code> object, the method first calls <code>estimate2</code> and then extract the variance-covariance matrix.
</p>


<h3>Value</h3>

<p>A matrix with as many rows and columns as the number of coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate2">estimate2</a></code> to obtain <code>lvmfit2</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data ####
n &lt;- 5e1
p &lt;- 3
X.name &lt;- paste0("X",1:p)
link.lvm &lt;- paste0("Y~",X.name)
formula.lvm &lt;- as.formula(paste0("Y~",paste0(X.name,collapse="+")))

m &lt;- lvm(formula.lvm)
distribution(m,~Id) &lt;- Sequence.lvm(0)
set.seed(10)
d &lt;- lava::sim(m,n)

#### linear models ####
e.lm &lt;- lm(formula.lvm,data=d)

#### latent variable models ####
e.lvm &lt;- estimate(lvm(formula.lvm),data=d)
vcov0 &lt;- vcov(e.lvm)
vcovSSC &lt;- vcov2(e.lvm)

vcovSSC/vcov0
vcovSSC[1:4,1:4]/vcov(e.lm)

</code></pre>

<hr>
<h2 id='vcov2-internal'>Inverse the Information Matrix</h2><span id='topic+vcov2-internal'></span><span id='topic+.info2vcov'></span>

<h3>Description</h3>

<p>Compute the inverse of the information matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.info2vcov(information, attr.info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov2-internal_+3A_information">information</code></td>
<td>
<p>[matrix] information matrix to be inverted.</p>
</td></tr>
<tr><td><code id="vcov2-internal_+3A_attr.info">attr.info</code></td>
<td>
<p>[logical] should the information matrix be returned as an attribute?</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
