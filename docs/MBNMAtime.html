<!DOCTYPE html><html><head><title>Help for package MBNMAtime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MBNMAtime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_index'><p>Add follow-up time and arm indices to a dataset</p></a></li>
<li><a href='#alog_pcfb'><p>Studies of alogliptin for lowering blood glucose concentration in patients with type II diabetes</p></a></li>
<li><a href='#binplot'><p>Plot relative effects from NMAs performed at multiple time-bins</p></a></li>
<li><a href='#copd'><p>Studies comparing Tiotropium, Aclidinium and Placebo for maintenance treatment of moderate to severe chronic obstructive pulmonary disease</p></a></li>
<li><a href='#cumrank'><p>Plot cumulative ranking curves from MBNMA models</p></a></li>
<li><a href='#default.priors'><p>Sets default priors for JAGS model code</p></a></li>
<li><a href='#devplot'><p>Plot deviance contributions from an MBNMA model</p></a></li>
<li><a href='#diabetes'><p>Studies comparing treatments for type 2 diabetes</p></a></li>
<li><a href='#fitplot'><p>Plot fitted values from MBNMA model</p></a></li>
<li><a href='#gen.parameters.to.save'><p>Automatically generate parameters to save for a time-course MBNMA model</p></a></li>
<li><a href='#genmaxcols'><p>Get large vector of distinct colours using Rcolorbrewer</p></a></li>
<li><a href='#genspline'><p>Generates spline basis matrices for fitting to time-course function</p></a></li>
<li><a href='#get.closest.time'><p>Create a dataset with a single time point from each study closest to specified time</p></a></li>
<li><a href='#get.earliest.time'><p>Create a dataset with the earliest time point only</p></a></li>
<li><a href='#get.latest.time'><p>Create a dataset with the latest time point only</p></a></li>
<li><a href='#get.model.vals'><p>Get MBNMA model values</p></a></li>
<li><a href='#get.prior'><p>Get current priors from JAGS model code</p></a></li>
<li><a href='#get.relative'><p>Calculates relative effects/mean differences at a particular time-point</p></a></li>
<li><a href='#getjagsdata'><p>Prepares data for JAGS</p></a></li>
<li><a href='#getnmadata'><p>Prepares NMA data for JAGS</p></a></li>
<li><a href='#goutSUA_CFB'><p>Studies of treatments for reducing serum uric acid in patients with gout</p></a></li>
<li><a href='#goutSUA_CFBcomb'><p>Studies of combined treatments for reducing serum uric acid in patients with gout</p></a></li>
<li><a href='#hyalarthritis'><p>Studies comparing hyaluronan (HA)â€“based viscosupplements for osteoarthritis</p></a></li>
<li><a href='#inconsistency.loops'><p>Identify comparisons in loops that fulfil criteria for node-splitting</p></a></li>
<li><a href='#mb.comparisons'><p>Identify unique comparisons within a network (identical to MBNMAdose)</p></a></li>
<li><a href='#mb.make.contrast'><p>Convert arm-based MBNMA data to contrast data</p></a></li>
<li><a href='#mb.nodesplit.comparisons'><p>Identify comparisons in time-course MBNMA datasets that fulfil criteria for node-splitting</p></a></li>
<li><a href='#mb.run'><p>Run MBNMA time-course models</p></a></li>
<li><a href='#mb.update'><p>Update MBNMA to obtain deviance contributions or fitted values</p></a></li>
<li><a href='#mb.validate.data'><p>Validates that a dataset fulfils requirements for MBNMA</p></a></li>
<li><a href='#mb.write'><p>Write MBNMA time-course models JAGS code</p></a></li>
<li><a href='#MBNMAtime-package'><p>MBNMAtime for Model-Based Network Meta-Analysis of longitudinal (time-course) data</p></a></li>
<li><a href='#nma.run'><p>Run an NMA model</p></a></li>
<li><a href='#obesityBW_CFB'><p>Studies of treatments for reducing body weight in patients with obesity</p></a></li>
<li><a href='#osteopain'><p>Studies of pain relief medications for osteoarthritis</p></a></li>
<li><a href='#pDcalc'><p>Calculate plugin pD from a JAGS model with univariate likelihood for studies</p>
with repeated measurements</a></li>
<li><a href='#plot.mb.network'><p>Create an <code>mb.network</code> object</p></a></li>
<li><a href='#plot.mb.predict'><p>Plots predicted responses from a time-course MBNMA model</p></a></li>
<li><a href='#plot.mb.rank'><p>Plot histograms of rankings from MBNMA models</p></a></li>
<li><a href='#plot.mbnma'><p>Forest plot for results from time-course MBNMA models</p></a></li>
<li><a href='#plot.nodesplit'><p>Perform node-splitting on a MBNMA time-course network</p></a></li>
<li><a href='#predict.mbnma'><p>Predict effects over time in a given population based on MBNMA time-course</p>
models</a></li>
<li><a href='#print.mb.network'><p>Print mb.network information to the console</p></a></li>
<li><a href='#print.mb.predict'><p>Print summary information from an mb.predict object</p></a></li>
<li><a href='#print.mb.rank'><p>Prints a summary of rankings for each parameter</p></a></li>
<li><a href='#print.nodesplit'><p>Prints basic results from a node-split to the console</p></a></li>
<li><a href='#print.relative.array'><p>Print posterior medians (95% credible intervals) for table of relative effects/mean</p>
differences between treatments/classes</a></li>
<li><a href='#radian.rescale'><p>Calculate position of label with respect to vertex location within a circle</p></a></li>
<li><a href='#rank'><p>Set rank as a method</p></a></li>
<li><a href='#rank.mb.predict'><p>Rank predictions at a specific time point</p></a></li>
<li><a href='#rank.mbnma'><p>Rank parameters from a time-course MBNMA</p></a></li>
<li><a href='#rankauc'><p>Calculates ranking probabilities for AUC from a time-course MBNMA</p></a></li>
<li><a href='#ref.comparisons'><p>Identify unique comparisons relative to study reference treatment within a</p>
network</a></li>
<li><a href='#ref.synth'><p>Synthesise single arm studies with repeated observations of the same</p>
treatment over time</a></li>
<li><a href='#ref.validate'><p>Checks the validity of ref.resp if given as data frame</p></a></li>
<li><a href='#remove.loops'><p>Removes any loops from MBNMA model JAGS code that do not contain any</p>
expressions</a></li>
<li><a href='#replace.prior'><p>Replace original priors in an MBNMA model with new priors</p></a></li>
<li><a href='#summary.mb.network'><p>Print summary mb.network information to the console</p></a></li>
<li><a href='#summary.mb.predict'><p>Prints summary of mb.predict object</p></a></li>
<li><a href='#summary.mbnma'><p>Print summary MBNMA results to the console</p></a></li>
<li><a href='#summary.nodesplit'><p>Takes node-split results and produces summary data frame</p></a></li>
<li><a href='#temax'><p>Emax time-course function</p></a></li>
<li><a href='#tfpoly'><p>Fractional polynomial time-course function</p></a></li>
<li><a href='#timeplot'><p>Plot raw responses over time by treatment or class</p></a></li>
<li><a href='#titp'><p>Integrated Two-Component Prediction (ITP) function</p></a></li>
<li><a href='#tloglin'><p>Log-linear (exponential) time-course function</p></a></li>
<li><a href='#tpoly'><p>Polynomial time-course function</p></a></li>
<li><a href='#tspline'><p>Spline time-course functions</p></a></li>
<li><a href='#tuser'><p>User-defined time-course function</p></a></li>
<li><a href='#write.beta'><p>Adds sections of JAGS code for an MBNMA model that correspond to beta</p>
parameters</a></li>
<li><a href='#write.check'><p>Checks validity of arguments for mb.write</p></a></li>
<li><a href='#write.cor'><p>Adds correlation between time-course relative effects</p></a></li>
<li><a href='#write.likelihood'><p>Adds sections of JAGS code for an MBNMA model that correspond to the</p>
likelihood</a></li>
<li><a href='#write.model'><p>Write the basic JAGS model code for MBNMA to which other lines of model</p>
code can be added</a></li>
<li><a href='#write.ref.synth'><p>Write MBNMA time-course models JAGS code for synthesis of studies</p>
investigating reference treatment</a></li>
<li><a href='#write.timecourse'><p>Adds sections of JAGS code for an MBNMA model that correspond to alpha</p>
parameters</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Run Time-Course Model-Based Network Meta-Analysis (MBNMA) Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hugo Pedder &lt;hugopedder@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits Bayesian time-course models for model-based network meta-analysis (MBNMA) that allows inclusion of multiple
  time-points from studies. Repeated measures over time are accounted for within studies by applying different time-course functions,
  following the method of Pedder et al. (2019) &lt;<a href="https://doi.org/10.1002%2Fjrsm.1351">doi:10.1002/jrsm.1351</a>&gt;. 
  The method allows synthesis of studies with multiple follow-up measurements that can account for time-course for a single or multiple 
  treatment comparisons. Several general time-course functions are provided; others may be added 
  by the user. Various characteristics can be flexibly added to the models, such as correlation between time points and shared 
  class effects. The consistency of direct and indirect evidence in the network can be assessed using unrelated mean effects 
  models and/or by node-splitting.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>knitr, grDevices, stats, graphics, utils, grid, gridExtra,
dplyr (&ge; 0.7.4), R2jags (&ge; 0.5-7), rjags (&ge; 4-8), reshape2
(&ge; 1.4.3), magrittr (&ge; 1.5), checkmate (&ge; 1.8.5), Rdpack (&ge;
0.10-1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>scales (&ge; 1.0.0), overlapping (&ge; 1.5.0), ggplot2 (&ge;
2.2.1), ggdist (&ge; 2.4.0), igraph (&ge; 1.1.2), crayon (&ge;
1.3.4), splines (&ge; 4.0.2), Hmisc (&ge; 4.4-1), lspline(&ge;
1.0-0), zoo (&ge; 1.8-8), rmarkdown, png, testthat (&ge; 1.0.2),
RColorBrewer (&ge; 1.1-2), mcmcplots (&ge; 0.4.3)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS (&gt;= 4.3.0) (http://mcmc-jags.sourceforge.net)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hugaped.github.io/MBNMAtime/">https://hugaped.github.io/MBNMAtime/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-14 14:53:52 UTC; hp17602</td>
</tr>
<tr>
<td>Author:</td>
<td>Hugo Pedder <a href="https://orcid.org/0000-0002-7813-3749"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-14 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_index'>Add follow-up time and arm indices to a dataset</h2><span id='topic+add_index'></span>

<h3>Description</h3>

<p>Adds follow-up time (<code>fups</code>, <code>fupcount</code>) and arm (<code>arms</code>, <code>narms</code>) indices to a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_index(data.ab, reference = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_index_+3A_data.ab">data.ab</code></td>
<td>
<p>A data frame of arm-level data in &quot;long&quot; format containing the columns:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers (can be numeric, factor or character)
</p>
</li>
<li> <p><code>class</code> An optional column indicating a particular class code. Treatments with the same identifier
must also have the same class code.
</p>
</li></ul>
</td></tr>
<tr><td><code id="add_index_+3A_reference">reference</code></td>
<td>
<p>A number or character (depending on the format of <code>treatment</code> within <code>data.ab</code>)
indicating the reference treatment in the network (i.e. those for which estimated relative treatment
effects estimated by the model will be compared to).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame similar to <code>data.ab</code> but with additional columns:
</p>

<ul>
<li> <p><code>arm</code> Arm identifiers coded for each study
</p>
</li>
<li> <p><code>fupcount</code> Follow-up identifiers coded for each study
</p>
</li>
<li> <p><code>fups</code> The total number of follow-up measurements in each study
</p>
</li>
<li> <p><code>narm</code> The total number of arms in each study
</p>
</li></ul>

<p>If <code>treatment</code> or <code>class</code> are non-numeric or non-sequential (i.e. with missing numeric codes),
treatments/classes in the returned data frame will be numbered and recoded to enforce sequential
numbering (a warning will be shown stating this).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Add indices to osteoarthritis pain dataset
data.ab &lt;- add_index(osteopain)

# Add indices to dataset using different network reference treatment
data.ab &lt;- add_index(osteopain, reference=3)
</code></pre>

<hr>
<h2 id='alog_pcfb'>Studies of alogliptin for lowering blood glucose concentration in patients with type II diabetes</h2><span id='topic+alog_pcfb'></span>

<h3>Description</h3>

<p>A dataset from a systematic review of Randomised-Controlled Trials (RCTs) comparing different doses of
alogliptin with placebo (Langford et al. 2016). The systematic review was simply performed and was intended to
provide data to illustrate a statistical methodology rather than for clinical inference. Alogliptin is
a treatment aimed at reducing blood glucose concentration in type II diabetes. The outcome is continuous,
and aggregate data responses correspond to the mean change in HbA1c from baseline to follow-up.
The dataset includes 14 Randomised-Controlled Trials (RCTs), comparing 5
different doses of alogliptin with placebo, leading to 6 different treatments (combination of dose and agent)
within the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alog_pcfb
</code></pre>


<h3>Format</h3>

<p>A data frame in long format (one row per arm and study), with 46 rows and 9 variables:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>clinicaltrialGov_ID</code> The clinicaltrial.gov ID code
</p>
</li>
<li> <p><code>agent</code> Character data indicating the agent to which participants were randomised
</p>
</li>
<li> <p><code>dose</code> Numeric data indicating the standardised dose received
</p>
</li>
<li> <p><code>treatment</code> Character data indicating the treatment (combination of agent and dose) to which participants were randomised
</p>
</li>
<li> <p><code>time</code> Numeric data indicating the time at which the observation was measured (given in weeks)
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean change from baseline in blood glucose concentration (mg/dL) in a study arm
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for the mean change from baseline in blood glucose concentration (mg/dL) in a study arm
</p>
</li>
<li> <p><code>n</code> Numeric data indicating the number in each arm at each follow-up time
</p>
</li></ul>



<h3>Details</h3>

<p><code>alog_pcfb</code> is a data frame in long format (one row per observation, arm and study),
with the variables <code>studyID</code>, <code>clinicaltrialGov_ID</code>, <code>agent</code>, <code>dose</code>, <code>treatment</code>, <code>time</code>, <code>y</code>, <code>se</code>, and <code>n</code>.
</p>


<h3>References</h3>

<p>Langford O, Aronson JK, van Valkenhoef G, Stevens RJ (2016).
&ldquo;Methods for meta-analysis of pharmacodynamic dose-response data with application to multi-arm studies of alogliptin.&rdquo;
<em>Stat Methods Med Res</em>.
ISSN 1477-0334 (Electronic) 0962-2802 (Linking), <a href="https://doi.org/10.1177/0962280216637093">doi:10.1177/0962280216637093</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/26994216/">https://pubmed.ncbi.nlm.nih.gov/26994216/</a>.
</p>

<hr>
<h2 id='binplot'>Plot relative effects from NMAs performed at multiple time-bins</h2><span id='topic+binplot'></span>

<h3>Description</h3>

<p>Plot relative effects from NMAs performed at multiple time-bins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binplot(
  network,
  overlay.nma = c(0, stats::quantile(network$data.ab$time)),
  method = "common",
  link = "identity",
  lim = "cred",
  plot.bins = TRUE,
  legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binplot_+3A_network">network</code></td>
<td>
<p>An object of class <code>"mb.network"</code>.</p>
</td></tr>
<tr><td><code id="binplot_+3A_overlay.nma">overlay.nma</code></td>
<td>
<p>Numeric vector used to overlay the results from a standard NMA model that
&quot;lumps&quot; time-points together within the time bin ranges specified in <code>overlay.nma</code>.
The numbers in <code>overlay.nma</code> define the boundaries of the time bins within which to perform
a standard NMA. Length must be &gt;=2, or can be left as <code>NULL</code> (the default) to indicate that no NMA
should be perfomed. <code>overlay.nma</code> can only be specified if <code>overlay.ref==TRUE</code>.
See Details for further information.</p>
</td></tr>
<tr><td><code id="binplot_+3A_method">method</code></td>
<td>
<p>Can take <code>"common"</code> or <code>"random"</code> to indicate the type of NMA model used to synthesise data points
given in <code>overlay.nma</code>. The default is <code>"random"</code> since this assumes different
time-points in <code>overlay.nma</code> have been lumped together to estimate the NMA.</p>
</td></tr>
<tr><td><code id="binplot_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="binplot_+3A_lim">lim</code></td>
<td>
<p>Specifies calculation of either 95% credible intervals (<code>lim="cred"</code>) or 95% prediction intervals (<code>lim="pred"</code>).</p>
</td></tr>
<tr><td><code id="binplot_+3A_plot.bins">plot.bins</code></td>
<td>
<p>Plot time bin boundaries as vertical dashed lines. Setting <code>plot.bins=TRUE</code> if <code>overlay.nma</code>
is specified also sets x-axis ticks to time bin boundaries automatically.</p>
</td></tr>
<tr><td><code id="binplot_+3A_legend">legend</code></td>
<td>
<p><code>TRUE</code>/<code>FALSE</code> to indicate whether a legend should be plotted.</p>
</td></tr>
<tr><td><code id="binplot_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to R2jags.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs several standard NMAs at different time &quot;bins&quot;, time periods within
which treatment effects are assumed to be constant over time. Separate NMAs
are then performed within each time bin on data points from studies that fall
within the time bin (only a single follow-up time is taken from each study
to avoid double counting).
</p>
<p>Note that the wider the time bin boundaries specified by the user, the
larger the potential range of included follow-up times and this can
introduce heterogeneity or inconsistency.
</p>
<p>Results are plotted versus the network reference and are plotted on the
specified link scale. Each time bin window is marked on the plot by
vertical dashed lines. The NMA estimates within each time bin are plotted
as a horizontal solid black line (the posterior median) with a shaded region
indicating the 95% credible interval (prediction intervals can instead
be plotted). The width of these shaded regions is equal to the range of study
time-points included in the NMA performed within that timebin, which
may therefore be more narrow than the time bin specified in the <code>binplot()</code>
command due to the follow-up times at which data is available in included
studies.
</p>


<h3>Value</h3>

<p>Plots treatment effects from NMAs performed within discrete time bins. The
object returned is a list containing the plot and a sublist of NMA results and
predictions from each time bin specified in <code>overlay.nma</code>.
</p>


<h3>Overlaying NMA results</h3>

<p><code>overlay.nma</code> indicates regions of the data (defined as &quot;time bins&quot;) over which it may be reasonable to &quot;lump&quot; different
follow-up times from different studies together and assume a standard NMA model. For example:
</p>

<ul>
<li> <p><code>overlay.nma=c(5,10)</code> indicates a single NMA of studies with follow-up times <code style="white-space: pre;">&#8288;&gt;5&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;=10&#8288;</code>
</p>
</li>
<li> <p><code>overlay.nma=c(5,10,15)</code> indicates two NMAs should be performed of studies with follow-up times <code style="white-space: pre;">&#8288;&gt;5&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;=10&#8288;</code>
of studies with follow-up times <code style="white-space: pre;">&#8288;&gt;10&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;=15&#8288;</code>
</p>
</li></ul>

<p>When used with MBNMA (via <code>predict.mbnma()</code>) this allows comparison to MBNMA results over a specific range of time within each time bin.
It can be useful to assess which time-course function might be suitable when using <code>binplot()</code>, or to
to assess if the MBNMA predictions are in agreement with predictions from an NMA model when using <code>plot.mb.predict()</code>
for a specific range of time-points. This can be a general indicator of the fit of the time-course model.
</p>
<p>However, it is important to note that the wider the range specified in <code>overlay.nma</code>, the more likely it is that different time-points
are included, and therefore that there is greater heterogeneity/inconsistency in the NMA model. If <code>overlay.nma</code> includes
several follow-up times for any study then only a single time-point will be taken (the one closest to <code>mean(overlay.nma)</code>).
The NMA predictions are plotted over the range specified in <code>overlay.nma</code> as a horizontal line, with the 95%CrI shown by a grey
rectangle. The NMA predictions represent those for <em>any time-points within this range</em> since they lump together data at
all these time-points. Predictions for treatments that are disconnected from
the network reference treatment at data points specified within <code>overlay.nma</code> cannot be estimated so are not included.
</p>
<p>It is important to note that the NMA model is not necessarily the &quot;correct&quot; model, since it &quot;lumps&quot; different time-points
together and ignores potential differences in treatment effects that may arise from this. The wider the range specified in
<code>overlay.nma</code>, the greater the effect of &quot;lumping&quot; and the stronger the assumption of similarity between studies.
</p>
<p>For an NMA model to be estimated and a corresponding prediction to be made from it, <strong>each</strong> time bin
must include the network reference treatment (treatment=1) evaluated in at least 1 connected study in the time bin.
If a given time bin does not meet this criteria then an NMA will not be calculated for it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an mb.network object from a dataset
alognet &lt;- mb.network(alog_pcfb)

# Plot relative effects from NMAs calculated for a single time-bins
# Do not plot time-bin boundaries
binplot(alognet, overlay.nma=c(0,5), plot.bins=FALSE)

# Plot relative effects from NMAs at multiple time-bins
# With random treatment effects
binplot(alognet, overlay.nma=c(5,10,15,20),
  method="random")


</code></pre>

<hr>
<h2 id='copd'>Studies comparing Tiotropium, Aclidinium and Placebo for maintenance treatment of moderate to severe chronic obstructive pulmonary disease</h2><span id='topic+copd'></span>

<h3>Description</h3>

<p>A dataset from a systematic review of Randomised-Controlled Trials (RCTs) for maintenance treatment of moderate to severe chronic
obstructive pulmonary disease (COPD) (Karabis et al. 2013). Data are extracted from (Tallarita et al. 2019).
SEs were imputed for three studies, and number of patients randomised were imputed for one study (LAS 39) in which they were missing,
using the median standard deviation calculated from other studies in the
dataset. The outcome is trough Forced Expiratory Volume in 1 second (FEV1), measured in litres and reported in each study arm as mean
change from baseline to follow-up. The dataset includes 13 Randomised-Controlled Trials (RCTs), comparing 2 treatments (Tiotropium and
Aclidinium) and placebo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copd
</code></pre>


<h3>Format</h3>

<p>A data frame in long format (one row per arm and study), with 80 rows and 6 variables:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating the time at which the observation was measured (given in weeks)
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean change from baseline in FEV1 (litres) in a study arm
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for the mean change from baseline in FEV1 in a study arm
</p>
</li>
<li> <p><code>treatment</code> Factor data indicating the treatment to which participants were randomised
</p>
</li>
<li> <p><code>n</code> Numeric data indicating the number of participants randomised to each arm
</p>
</li></ul>



<h3>Details</h3>

<p><code>copd</code> is a data frame in long format (one row per observation, arm and study),
with the variables <code>studyID</code>, <code>time</code>, <code>y</code>, <code>se</code>, <code>treatment</code>, and <code>n</code>.
</p>


<h3>References</h3>

<p>Karabis A, Lindner L, Mocarski M, Huisman E, Greening A (2013).
&ldquo;Comparative efficacy of aclidinium versus glycopyrronium and tiotropium, as maintenance treatment of moderate to severe COPD patients: a systematic review and network meta-analysis.&rdquo;
<em>Int J Chron Obstruct Pulmon Dis</em>, <b>8</b>, 405-423.
<a href="https://doi.org/10.2147/COPD.S48967">doi:10.2147/COPD.S48967</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/24043936/">https://pubmed.ncbi.nlm.nih.gov/24043936/</a>.<br /><br /> Tallarita M, De lorio M, Baio G (2019).
&ldquo;A comparative review of network meta-analysis models in longitudinal randomized controlled trial.&rdquo;
<em>Statistics in Medicine</em>, <b>38</b>(16), 3053-3072.
<a href="https://doi.org/10.1002/sim.8169">doi:10.1002/sim.8169</a>.
</p>

<hr>
<h2 id='cumrank'>Plot cumulative ranking curves from MBNMA models</h2><span id='topic+cumrank'></span>

<h3>Description</h3>

<p>Plot cumulative ranking curves from MBNMA models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumrank(x, sucra = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumrank_+3A_x">x</code></td>
<td>
<p>An object of class <code>"mb.rank"</code> generated by <code>rank.mbnma()</code></p>
</td></tr>
<tr><td><code id="cumrank_+3A_sucra">sucra</code></td>
<td>
<p>A logical object to indicate whether Surface Under Cumulative Ranking Curve (SUCRA)
values should be calculated and returned as a data frame. Areas calculated
using trapezoid approach.</p>
</td></tr>
<tr><td><code id="cumrank_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to <code>ggplot::geom_line()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Line plots showing the cumulative ranking probabilities for each agent/class for
the ranked dose response paramtere in <code>x</code>. The object returned is a list which contains the plot
(an object of <code style="white-space: pre;">&#8288;class(c("gg", "ggplot")&#8288;</code>) and a data frame of SUCRA values
if <code>sucra = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the alogliptin data
network &lt;- mb.network(alog_pcfb)

# Estimate rankings  from an Emax dose-response MBNMA
emax &lt;- mb.run(network, fun=temax())
ranks &lt;- rank(emax, param=c("emax"))

# Plot cumulative rankings for both dose-response parameters simultaneously
# Note that SUCRA values are also returned
cumrank(ranks)

</code></pre>

<hr>
<h2 id='default.priors'>Sets default priors for JAGS model code</h2><span id='topic+default.priors'></span>

<h3>Description</h3>

<p>This function creates JAGS code snippets for default MBNMA model priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default.priors(fun = tloglin())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.priors_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, each element of which is a named JAGS snippet
corresponding to a prior in the MBNMA JAGS code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
default.priors(fun=temax())

default.priors(fun=titp(p.expon=TRUE))


</code></pre>

<hr>
<h2 id='devplot'>Plot deviance contributions from an MBNMA model</h2><span id='topic+devplot'></span>

<h3>Description</h3>

<p>Plot deviance contributions from an MBNMA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>devplot(
  mbnma,
  dev.type = "dev",
  plot.type = "box",
  xaxis = "time",
  facet = TRUE,
  n.iter = round(mbnma$BUGSoutput$n.iter/4),
  n.thin = mbnma$BUGSoutput$n.thin,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="devplot_+3A_mbnma">mbnma</code></td>
<td>
<p>An S3 object of class <code>"mbnma"</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="devplot_+3A_dev.type">dev.type</code></td>
<td>
<p>Deviances to plot - can be either residual deviances (<code>"resdev"</code>) or deviances (<code>"dev"</code>, the default)</p>
</td></tr>
<tr><td><code id="devplot_+3A_plot.type">plot.type</code></td>
<td>
<p>Deviances can be plotted either as scatter points (<code>"scatter"</code> - using
<code>geom_point()</code>) or as boxplots (<code>"box"</code>, the default)</p>
</td></tr>
<tr><td><code id="devplot_+3A_xaxis">xaxis</code></td>
<td>
<p>A character object that indicates whether deviance contributions should be plotted
by time (<code>"time"</code>) or by follow-up count (<code>"fup"</code>)</p>
</td></tr>
<tr><td><code id="devplot_+3A_facet">facet</code></td>
<td>
<p>A boolean object that indicates whether or not to facet by treatment</p>
</td></tr>
<tr><td><code id="devplot_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of iterations to update the model whilst monitoring additional parameters (if necessary).
Must be a positive integer. Default is the value used in <code>mbnma</code>.</p>
</td></tr>
<tr><td><code id="devplot_+3A_n.thin">n.thin</code></td>
<td>
<p>The thinning rate. Must be a positive integer. Default is the value used in <code>mbnma</code>.</p>
</td></tr>
<tr><td><code id="devplot_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to <code>ggplot2::ggplot()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deviances should only be plotted for models that have converged successfully. If deviance
contributions have not been monitored in <code>mbnma$parameters.to.save</code> then additional
iterations will have to be run to get results for these.
</p>
<p>Deviance contributions cannot be calculated for models with a multivariate likelihood (i.e.
those that account for correlation between observations) because the covariance matrix in these
models is treated as unknown (if <code>rho="estimate"</code>) and deviance contributions will be correlated.
</p>


<h3>Value</h3>

<p>Generates a plot of deviance contributions and returns a list containing the
plot (as an object of class <code>c("gg", "ggplot")</code>), and a data.frame of posterior mean
deviance/residual deviance contributions for each observation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make network
alognet &lt;- mb.network(alog_pcfb)

# Run MBNMA
mbnma &lt;- mb.run(alognet, fun=tpoly(degree=2), intercept=FALSE)

# Plot residual deviance contributions in a scatterplot
devplot(mbnma)

# Plot deviance contributions in boxplots at each follow-up measurement
# Monitor for 500 additional iterations
devplot(mbnma, dev.type="dev", plot.type="box", xaxis="fup", n.iter=500)

</code></pre>

<hr>
<h2 id='diabetes'>Studies comparing treatments for type 2 diabetes</h2><span id='topic+diabetes'></span>

<h3>Description</h3>

<p>A dataset from of trials for reduction of haemoglobin A1c (HbA1c) in patients
with type 2 diabetes(Ding and Fu 2013).
Data are reported in each study arm as mean change from baseline to follow-up.
The dataset includes 4 Randomised-Controlled Trials (RCTs), comparing 4 treatments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diabetes
</code></pre>


<h3>Format</h3>

<p>A data frame in long format (one row per arm and study), with 28 rows and 7 variables:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>treatment</code> Numeric data indicating the treatment to which participants were randomised
</p>
</li>
<li> <p><code>time</code> Numeric data indicating the time at which the observation was measured (given in weeks)
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean change from baseline in HbA1c in a study arm
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for the mean change from baseline in HbA1c in a study arm
</p>
</li>
<li> <p><code>sd</code> Numeric data indicating the standard deviation for the mean change from baseline in HbA1c in a study arm
</p>
</li>
<li> <p><code>n</code> Numeric data indicating the number of participants in each arm at each time-point
</p>
</li></ul>



<h3>Details</h3>

<p><code>diabetes</code> is a data frame in long format (one row per observation, arm and study),
with the variables <code>studyID</code>, <code>treatment</code>, <code>time</code>, <code>y</code>, <code>se</code>, <code>sd</code>, and <code>n</code>.
</p>


<h3>References</h3>

<p>Ding Y, Fu H (2013).
&ldquo;Bayesian indirect and mixed treatment comparisons across longitudinal time points.&rdquo;
<em>Statistics in Medicine</em>, <b>32</b>, 2613-2628.
<a href="https://doi.org/10.1002/sim.5688">doi:10.1002/sim.5688</a>.
</p>

<hr>
<h2 id='fitplot'>Plot fitted values from MBNMA model</h2><span id='topic+fitplot'></span>

<h3>Description</h3>

<p>Plot fitted values from MBNMA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitplot(
  mbnma,
  treat.labs = NULL,
  disp.obs = TRUE,
  n.iter = round(mbnma$BUGSoutput$n.iter/4),
  n.thin = mbnma$BUGSoutput$n.thin,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitplot_+3A_mbnma">mbnma</code></td>
<td>
<p>An S3 object of class <code>"mbnma"</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="fitplot_+3A_treat.labs">treat.labs</code></td>
<td>
<p>A character vector of treatment labels with which to name graph panels.
Can use <code>mb.network()[["treatments"]]</code> with original dataset if in doubt.</p>
</td></tr>
<tr><td><code id="fitplot_+3A_disp.obs">disp.obs</code></td>
<td>
<p>A boolean object to indicate whether raw data responses should be
plotted as points on the graph</p>
</td></tr>
<tr><td><code id="fitplot_+3A_n.iter">n.iter</code></td>
<td>
<p>number of total iterations per chain (including burn in;
default: 2000)</p>
</td></tr>
<tr><td><code id="fitplot_+3A_n.thin">n.thin</code></td>
<td>
<p>thinning rate. Must be a positive integer.  Set
<code>n.thin</code> &gt; 1 to save memory and computation time if
<code>n.iter</code> is large.  Default is <code>max(1, floor(n.chains *
    (n.iter-n.burnin) / 1000))</code> which will only thin if there are at
least 2000 simulations.</p>
</td></tr>
<tr><td><code id="fitplot_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to <code>ggplot2::ggplot()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitted values should only be plotted for models that have converged successfully.
If fitted values (<code>theta</code>) have not been monitored in <code>mbnma$parameters.to.save</code>
then additional iterations will have to be run to get results for these.
</p>


<h3>Value</h3>

<p>Generates a plot of fitted values from the MBNMA model and returns a list containing
the plot (as an object of class <code>c("gg", "ggplot")</code>), and a data.frame of posterior mean
fitted values for each observation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make network
painnet &lt;- mb.network(osteopain)

# Run MBNMA
mbnma &lt;- mb.run(painnet,
  fun=temax(pool.emax="rel", method.emax="common",
    pool.et50="abs", method.et50="random"))

# Plot fitted values from the model
# Monitor fitted values for 500 additional iterations
fitplot(mbnma, n.iter=500)


</code></pre>

<hr>
<h2 id='gen.parameters.to.save'>Automatically generate parameters to save for a time-course MBNMA model</h2><span id='topic+gen.parameters.to.save'></span>

<h3>Description</h3>

<p>Automatically generate parameters to save for a time-course MBNMA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.parameters.to.save(fun, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.parameters.to.save_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="gen.parameters.to.save_+3A_model">model</code></td>
<td>
<p>A JAGS model written as a character object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of parameter names that should be monitored in the model
</p>

<hr>
<h2 id='genmaxcols'>Get large vector of distinct colours using Rcolorbrewer</h2><span id='topic+genmaxcols'></span>

<h3>Description</h3>

<p>Get large vector of distinct colours using Rcolorbrewer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genmaxcols()
</code></pre>

<hr>
<h2 id='genspline'>Generates spline basis matrices for fitting to time-course function</h2><span id='topic+genspline'></span>

<h3>Description</h3>

<p>Generates spline basis matrices for fitting to time-course function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genspline(
  x,
  spline = "bs",
  knots = 1,
  degree = 1,
  max.time = max(x),
  boundaries = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genspline_+3A_x">x</code></td>
<td>
<p>A numeric vector indicating all time points available in the dataset</p>
</td></tr>
<tr><td><code id="genspline_+3A_spline">spline</code></td>
<td>
<p>Indicates the type of spline function. Can be either a piecewise linear spline (<code>"ls"</code>),
natural cubic spline (<code>"ns"</code>) or B-spline (<code>"bs"</code>).</p>
</td></tr>
<tr><td><code id="genspline_+3A_knots">knots</code></td>
<td>
<p>The number/location of knots. If a single integer is given it indicates the number of knots (they will
be equally spaced across the range of time-points). If a numeric vector is given it indicates the quantiles of the knots as
a proportion of the maximum study follow-up in the dataset. For example, if the maximum follow-up time in the dataset
is 10 months, <code>knots=c(0.1,0.5)</code> would indicate knots should be fitted at 1 and 5 months follow-up.</p>
</td></tr>
<tr><td><code id="genspline_+3A_degree">degree</code></td>
<td>
<p>a positive integer giving the degree of the polynomial from which the spline function is composed
(e.g. <code>degree=3</code> represents a cubic spline).</p>
</td></tr>
<tr><td><code id="genspline_+3A_max.time">max.time</code></td>
<td>
<p>A number indicating the maximum time between which to calculate the spline function.</p>
</td></tr>
<tr><td><code id="genspline_+3A_boundaries">boundaries</code></td>
<td>
<p>A positive numeric vector of length 2 that represents the time-points at which to anchor the B-spline or natural
cubic spline basis matrix. This allows data to extend beyond the boundary knots, or for the basis parameters to not depend on <code>x</code>.
The default (<code>boundaries=NULL</code>)is the range of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spline basis matrix with number of rows equal to <code>length(x)</code> and the number of columns equal to the number
of coefficients in the spline.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:100

genspline(x)

# Generate a quadratic B-spline with 1 equally spaced internal knot
genspline(x, spline="bs", knots=2, degree=2)

# Generate a natural spline with 2 knots at selected quantiles
genspline(x, spline="ns", knots=c(0.1, 0.5))

# Generate a piecewise linear spline with 3 equally spaced knots
genspline(x, spline="ls", knots=3)

</code></pre>

<hr>
<h2 id='get.closest.time'>Create a dataset with a single time point from each study closest to specified time</h2><span id='topic+get.closest.time'></span>

<h3>Description</h3>

<p>Takes the closest time point from each arm in each study to a specified time (t) within an
<code>mb.network</code> object. Useful for network plots or exploring standard NMA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.closest.time(network, t = stats::median(network$data.ab$time))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.closest.time_+3A_network">network</code></td>
<td>
<p>An object of class <code>"mb.network"</code>.</p>
</td></tr>
<tr><td><code id="get.closest.time_+3A_t">t</code></td>
<td>
<p>The time point at which</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in long format of responses at the closest time point to t in
each arm of each study.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the alogliptin dataset
network &lt;- mb.network(alog_pcfb)

# Take a single follow-up time from each study...
# ...closest to 7
get.closest.time(network, t=7)

# ...closest to 20
get.closest.time(network, t=7)

# ...closest to the median follow-up across all studies
get.closest.time(network, t=26)

</code></pre>

<hr>
<h2 id='get.earliest.time'>Create a dataset with the earliest time point only</h2><span id='topic+get.earliest.time'></span>

<h3>Description</h3>

<p>Takes the earliest time point from each arm in each study within an
<code>mb.network</code> object. Useful for network plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.earliest.time(network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.earliest.time_+3A_network">network</code></td>
<td>
<p>An object of class <code>"mb.network"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> a data frame in long format of responses at the earliest time point in
each arm of each study
</p>
</li>
<li><p> a vector of studyIDs
</p>
</li>
<li><p> a vector of treatment names
</p>
</li>
<li><p> a vector of class names (if included in <code>network</code>)
</p>
</li>
<li><p> a data frame of treatment -&gt; class codings (if included in <code>network</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Using the alogliptin dataset
network &lt;- mb.network(alog_pcfb)

# Generate a data set with only the earliest time point included in each study
get.earliest.time(network)

</code></pre>

<hr>
<h2 id='get.latest.time'>Create a dataset with the latest time point only</h2><span id='topic+get.latest.time'></span>

<h3>Description</h3>

<p>Takes the latest time point from each arm in each study within an
<code>mb.network</code> object. Useful for network plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.latest.time(network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.latest.time_+3A_network">network</code></td>
<td>
<p>An object of class <code>"mb.network"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> a data frame in long format of responses at the latest time point in
each arm of each study
</p>
</li>
<li><p> a vector of studyIDs
</p>
</li>
<li><p> a vector of treatment names
</p>
</li>
<li><p> a vector of class names (if included in <code>network</code>)
</p>
</li>
<li><p> a data frame of treatment -&gt; class codings (if included in <code>network</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Using the alogliptin dataset
network &lt;- mb.network(alog_pcfb)

# Generate a data frame with only the latest time point included in each study
get.latest.time(network)

</code></pre>

<hr>
<h2 id='get.model.vals'>Get MBNMA model values</h2><span id='topic+get.model.vals'></span>

<h3>Description</h3>

<p>Extracts specific information required for prediction from a time-course
MBNMA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.model.vals(
  mbnma,
  E0 = 0,
  level = "treatments",
  lim = "cred",
  link = "identity"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.model.vals_+3A_mbnma">mbnma</code></td>
<td>
<p>An S3 object of class <code>"mbnma"</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="get.model.vals_+3A_e0">E0</code></td>
<td>
<p>An object to indicate the value(s) to use for the response at time = 0
in the prediction. This can take a number of different formats depending
on how it will be used/calculated. The default is 0 but this may lead
to non-sensical predictions if Ratio of Means are modeled.
</p>

<ul>
<li> <p><code>numeric()</code> A single numeric value representing the deterministic response at time = 0
</p>
</li>
<li> <p><code>formula()</code> A formula representing a stochastic distribution for the response
at time = 0. This is specified as a random number generator
(RNG) given as a string, and can take any RNG distribution for which a function exists
in R. For example: <code>~rnorm(n, 7, 0.5)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get.model.vals_+3A_level">level</code></td>
<td>
<p>Can take either <code>"treatment"</code> to make predictions for treatments, or <code>"class"</code> to make predictions for classes (in
which case <code>object</code> must be a class effect model).</p>
</td></tr>
<tr><td><code id="get.model.vals_+3A_lim">lim</code></td>
<td>
<p>Specifies calculation of either 95% credible intervals (<code>lim="cred"</code>) or 95% prediction intervals (<code>lim="pred"</code>).</p>
</td></tr>
<tr><td><code id="get.model.vals_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing named elements that correspond to different
time-course parameters in <code>mbnma</code>. These elements contain MCMC results
either taken directly from <code>mbnma</code> or (in the case of random time-course
parameters specified as <code>method="random"</code>) randomly
generated using parameter values estimated in <code>mbnma</code>.
</p>
<p>Additional elements contain the following values:
</p>

<ul>
<li> <p><code>timecourse</code> A character object that specifies the time-course used in <code>mbnma</code> in terms of
alpha, beta, mu, d and time. Consistency relative time-course parameters
are specified in terms of mu and d.
</p>
</li>
<li> <p><code>time.params</code> A character vector
that indicates the different time-course parameters that are required for
the prediction
</p>
</li></ul>

<p>@noRd
</p>

<hr>
<h2 id='get.prior'>Get current priors from JAGS model code</h2><span id='topic+get.prior'></span>

<h3>Description</h3>

<p>Identical to <code>get.prior()</code> in MBNMAdose.
This function takes JAGS model presented as a string and identifies what
prior values have been used for calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.prior(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.prior_+3A_model">model</code></td>
<td>
<p>A character object of JAGS MBNMA model code</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Even if an MBNMA model that has not initialised successfully and
results have not been calculated, the JAGS model for it is saved in
<code>MBNMA$model.arg$jagscode</code> and therefore priors can still be obtained.
This allows for priors to be changed even in failing models, which may help
solve issues with initialisation.
</p>


<h3>Value</h3>

<p>A character vector, each element of which is a line of JAGS code
corresponding to a prior in the JAGS code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create mb.network object using an MBNMAtime dataset
network &lt;- mb.network(osteopain)

# Create mb.network object using an MBNMAdose dataset

# Run linear MBNMA
result &lt;- mb.run(network, fun=tpoly(degree=1,
    pool.1="rel", method.1="random"))

# Obtain model prior values
get.prior(result$model.arg$jagscode)

# ...also equivalent to
print(result$model.arg$priors)


</code></pre>

<hr>
<h2 id='get.relative'>Calculates relative effects/mean differences at a particular time-point</h2><span id='topic+get.relative'></span>

<h3>Description</h3>

<p>Uses mbnma time-course parameter estimates to calculate treatment
differences between treatments or classes at a particular time-point.
Can be used to compare treatments evaluated in studies at different follow-up times, or even
to compare treatments in different MBNMA models via a common comparator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.relative(
  mbnma,
  mbnma.add = NULL,
  time = max(mbnma$model.arg$jagsdata$time, na.rm = TRUE),
  treats = unique(c(mbnma$network$treatments, mbnma.add$network$treatments)),
  classes = NULL,
  lim = "cred"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.relative_+3A_mbnma">mbnma</code></td>
<td>
<p>An S3 object of class <code>"mbnma"</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="get.relative_+3A_mbnma.add">mbnma.add</code></td>
<td>
<p>An S3 object of <code>class("mbnma")</code> generated by running
a time-course MBNMA model. This should only be specified if results from two different MBNMA models
are to be combined to perform a 2-stage MBNMA (see Details).</p>
</td></tr>
<tr><td><code id="get.relative_+3A_time">time</code></td>
<td>
<p>A numeric value for the time at which to estimate relative effects/mean differences.</p>
</td></tr>
<tr><td><code id="get.relative_+3A_treats">treats</code></td>
<td>
<p>A character vector of treatment names for which to calculate relative effects/mean
differences. Must be a subset of <code>mbnma$network$treatments</code>.</p>
</td></tr>
<tr><td><code id="get.relative_+3A_classes">classes</code></td>
<td>
<p>A character vector of class names for which to calculate relative effects/mean
differences. Must be a subset of <code>mbnma$network$classes</code>. Only works for class effect models.</p>
</td></tr>
<tr><td><code id="get.relative_+3A_lim">lim</code></td>
<td>
<p>Specifies calculation of either 95% credible intervals (<code>lim="cred"</code>) or 95% prediction intervals (<code>lim="pred"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get.relative()</code> can also be used to perform a 2-stage MBNMA that allows synthesis of results
from two different MBNMA models via a single common comparator.
In an MBNMA model, all treatments must share the same time-course function. However, a 2-stage
approach can enable fitting of different time-course functions to different sets (&quot;subnetworks&quot;) of
treatments. For example, some treatments may have rich time-course information,
allowing for a more complex time-course function to be used, whereas others may be sparse,
requiring a simpler time-course function.
</p>
<p>Relative comparisons between treatments in the two datasets at specific follow-up times
can then be estimated from MBNMA predicted effects versus a common comparator
using the Bucher method and assuming consistency. See the MBNMAtime vignette for further details.
</p>


<h3>Value</h3>

<p>An object of class <code>"relative.array"</code> list containing:
</p>

<ul>
<li><p> The time-point for which results are estimated
</p>
</li>
<li><p> Matrices of posterior means, medians, SDs and upper and lower 95% credible intervals for the
differences between each treatment
</p>
</li>
<li><p> An array containing MCMC results for the differences between all treatments specified in <code>treats</code>
or all classes specified in <code>classes</code>.
</p>
</li></ul>

<p>Results are reported in tables as the row-defined treatment minus the column-defined treatment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an mb.network object from a dataset
alognet &lt;- mb.network(alog_pcfb)

# Run a quadratic time-course MBNMA using the alogliptin dataset
mbnma &lt;- mb.run(alognet,
  fun=tpoly(degree=2,
  pool.1="rel", method.1="random",
  pool.2="rel", method.2="common"
  )
)

# Calculate differences between all treatments at 20 weeks follow-up
allres &lt;- get.relative(mbnma, time=20)

# Calculate difference between a subset of treatments at 10 weeks follow-up
subres &lt;- get.relative(mbnma, time=10,
  treats=c("alog_50", "alog_25", "placebo"))



###########################
##### 2-stage MBNMA #####
###########################

# Using the osteoarthritis dataset
# With placebo (Pl_0) as common comparator between subnetworks

#### Sparse model ####

# Treatments on which time-course data is limited
sparse.trt &lt;- c("Ce_100", "Ce_400", "Du_90", "Lu_200", "Lu_400",
  "Lu_NA", "Et_5", "Ox_44")

# Create a subnetwork of studies comparing these treatments
sparse.df &lt;- osteopain %&gt;% dplyr::group_by(studyID) %&gt;%
  dplyr::filter(any(treatment %in% sparse.trt)) %&gt;%
  dplyr::ungroup() %&gt;%
  subset(treatment %in% c("Pl_0", sparse.trt))

sparse.net &lt;- mb.network(sparse.df)

# Run a ITP MBNMA with a known rate
sparse.mbnma &lt;- mb.run(sparse.net, fun=titp(method.rate=0.8, pool.rate="abs"))


#### Complex model ####

# Treatments on which time-course data is rich
rich.trt &lt;- levels(osteopain$treatment)[!levels(osteopain$treatment) %in%
  c("Pl_0", "Ce_100", "Ce_400", "Du_90", "Lu_200",
    "Lu_400", "Lu_NA", "Et_5", "Ox_44")]

# Create a subnetwork of studies comparing these treatments
rich.df &lt;- osteopain %&gt;% dplyr::group_by(studyID) %&gt;%
  dplyr::filter(any(treatment %in% rich.trt)) %&gt;%
  dplyr::ungroup() %&gt;%
  subset(treatment %in% c("Pl_0", rich.trt))

rich.net &lt;- mb.network(rich.df)

# Run a Emax MBNMA
rich.mbnma &lt;- mb.run(rich.net, temax(p.expon = FALSE))


#### Calculate relative effects between models ####

# At 10 weeks follow-up
rels.sparse &lt;- get.relative(sparse.mbnma, time=10)
rels.rich &lt;- get.relative(rich.mbnma, time=10)

rels.all &lt;- get.relative(mbnma=rich.mbnma,
  mbnma.add=sparse.mbnma, time=10)

print(rels.all$median)



</code></pre>

<hr>
<h2 id='getjagsdata'>Prepares data for JAGS</h2><span id='topic+getjagsdata'></span>

<h3>Description</h3>

<p>Converts MBNMA data frame to a list for use in JAGS model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getjagsdata(
  data.ab,
  fun = NULL,
  class = FALSE,
  rho = NULL,
  covstruct = "CS",
  link = "identity",
  sdscale = FALSE,
  cfb = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getjagsdata_+3A_data.ab">data.ab</code></td>
<td>
<p>A data frame of arm-level data in &quot;long&quot; format containing the columns:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the aggregate response for a given observation (e.g. mean)
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers (can be numeric, factor or character)
</p>
</li>
<li> <p><code>class</code> An optional column indicating a particular class identifier. Observations with the same treatment
identifier must also have the same class identifier.
</p>
</li>
<li> <p><code>n</code> An optional column indicating the number of participants used to calculate the
response at a given observation (required if modelling using Standardised Mean Differences)
</p>
</li>
<li> <p><code>standsd</code> An optional column of numeric data indicating reference SDs used to standardise
treatment effects when modelling using Standardised Mean Differences (SMD).
</p>
</li></ul>
</td></tr>
<tr><td><code id="getjagsdata_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="getjagsdata_+3A_class">class</code></td>
<td>
<p>A boolean object indicating whether or not <code>data.ab</code> contains
information on different classes of treatments</p>
</td></tr>
<tr><td><code id="getjagsdata_+3A_rho">rho</code></td>
<td>
<p>The correlation coefficient when modelling within-study correlation between time points. The default is a string representing a
prior distribution in JAGS, indicating that it be estimated from the data (e.g. <code>rho="dunif(0,1)"</code>). <code>rho</code> also be assigned a
numeric value (e.g. <code>rho=0.7</code>), which fixes <code>rho</code> in the model to this value (e.g. for use in a deterministic sensitivity analysis).
If set to <code>rho=0</code> (the default) then this implies modelling no correlation between time points.</p>
</td></tr>
<tr><td><code id="getjagsdata_+3A_covstruct">covstruct</code></td>
<td>
<p>A character to indicate the covariance structure required for modelling correlation between
time points (if any), since
this determines some of the data. Can be either <code>"CS"</code> (compound symmetry), <code>"AR1"</code> (autoregressive AR1) or
<code>"varadj"</code> (variance-adjustment).</p>
</td></tr>
<tr><td><code id="getjagsdata_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="getjagsdata_+3A_sdscale">sdscale</code></td>
<td>
<p>Logical object to indicate whether to write a model that specifies a reference SD
for standardising when modelling using Standardised Mean Differences. Specifying <code>sdscale=TRUE</code>
will therefore only modify the model if link function is set to SMD (<code>link="smd"</code>).</p>
</td></tr>
<tr><td><code id="getjagsdata_+3A_cfb">cfb</code></td>
<td>
<p>A logical vector whose length is equal to the unique number of studies in <code>data.ab</code>, where each
element is <code>TRUE</code> if the study data reported is change-from-baseline and <code>FALSE</code> otherwise. If left as <code>NULL</code>
(the default) then this will be identified from the data by assuming any study for which there is no data
at <code>time=0</code> reports change-from-baseline.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of numbers, vector, matrices and arrays to be sent to
JAGS. List elements are:
</p>

<ul>
<li> <p><code>y</code> An array of mean responses for each observation in each arm within each study
</p>
</li>
<li> <p><code>se</code> An array of standard errors for each observation in each arm within each study
</p>
</li>
<li> <p><code>time</code> A matrix of follow-up times within each study
</p>
</li>
<li> <p><code>fups</code> A numeric vector with the number of follow-up measurements per study
</p>
</li>
<li> <p><code>narm</code> A numeric vector with the number of arms per study
</p>
</li>
<li> <p><code>NS</code> The total number of studies in the dataset
</p>
</li>
<li> <p><code>NT</code> The total number of treatments in the dataset
</p>
</li>
<li> <p><code>treat</code> A matrix of treatment codes within each study
</p>
</li>
<li> <p><code>Nclass</code> Optional. The total number of classes in the dataset
</p>
</li>
<li> <p><code>class</code> Optional. A matrix of class codes within each study
</p>
</li>
<li> <p><code>classkey</code> Optional. A vector of class codes that correspond to treatment codes.
Same length as the number of treatment codes.
</p>
</li>
<li> <p><code>mat.triangle</code> Optional. A matrix with number indicating how to fill covariance
matrices within the JAGS code.
</p>
</li>
<li> <p><code>mat.order</code> Optional. A matrix with number indicating what order to fill
covariance matrices within the JAGS code.
</p>
</li>
<li> <p><code>timedif.0</code> Optional. A vector of the difference in times between the first and second
follow-up time in each study.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Using the alogliptin dataset
network &lt;- mb.network(alog_pcfb)
jagsdat &lt;- getjagsdata(network$data.ab)


# Get JAGS data with class
netclass &lt;- mb.network(goutSUA_CFBcomb)
jagsdat &lt;- getjagsdata(netclass$data.ab, class=TRUE)


# Get JAGS data that allows for modelling correlation between time points
painnet &lt;- mb.network(osteopain)
jagsdat &lt;- getjagsdata(painnet$data.ab, rho="dunif(0,1)", covstruct="AR1")

</code></pre>

<hr>
<h2 id='getnmadata'>Prepares NMA data for JAGS</h2><span id='topic+getnmadata'></span>

<h3>Description</h3>

<p>Converts data frame to a list for use in JAGS NMA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getnmadata(data.ab, link = "identity", sdscale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getnmadata_+3A_data.ab">data.ab</code></td>
<td>
<p>A data frame of arm-level data in &quot;long&quot; format containing the columns:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the aggregate response for a given observation (e.g. mean)
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers (can be numeric, factor or character)
</p>
</li>
<li> <p><code>class</code> An optional column indicating a particular class identifier. Observations with the same treatment
identifier must also have the same class identifier.
</p>
</li>
<li> <p><code>n</code> An optional column indicating the number of participants used to calculate the
response at a given observation (required if modelling using Standardised Mean Differences)
</p>
</li>
<li> <p><code>standsd</code> An optional column of numeric data indicating reference SDs used to standardise
treatment effects when modelling using Standardised Mean Differences (SMD).
</p>
</li></ul>
</td></tr>
<tr><td><code id="getnmadata_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="getnmadata_+3A_sdscale">sdscale</code></td>
<td>
<p>Logical object to indicate whether to write a model that specifies a reference SD
for standardising when modelling using Standardised Mean Differences. Specifying <code>sdscale=TRUE</code>
will therefore only modify the model if link function is set to SMD (<code>link="smd"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of numbers, vector, matrices and arrays to be sent to
JAGS. List elements are:
</p>

<ul>
<li> <p><code>y</code> An array of mean responses for each observation in each arm within each study
</p>
</li>
<li> <p><code>se</code> An array of standard errors for each observation in each arm within each study
</p>
</li>
<li> <p><code>narm</code> A numeric vector with the number of arms per study
</p>
</li>
<li> <p><code>NS</code> The total number of studies in the dataset
</p>
</li>
<li> <p><code>NT</code> The total number of treatments in the dataset
</p>
</li>
<li> <p><code>treat</code> A matrix of treatment codes within each study
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Using the alogliptin dataset
network &lt;- mb.network(alog_pcfb)

# Construct a dataset with the latest time point in each study
data.ab &lt;- get.latest.time(network)$data.ab
getnmadata(data.ab)

</code></pre>

<hr>
<h2 id='goutSUA_CFB'>Studies of treatments for reducing serum uric acid in patients with gout</h2><span id='topic+goutSUA_CFB'></span>

<h3>Description</h3>

<p>A dataset from a systematic review of interventions for lowering Serum Uric Acid (SUA) concentration in
patients with gout <strong>(not published previously)</strong>. The outcome is continuous, and aggregate data responses
correspond to the mean change from baseline in SUA in mg/dL.
Overall there are 41 treatments of 8 agents in the network. Standard
deviations have been imputed for 181 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goutSUA_CFB
</code></pre>


<h3>Format</h3>

<p>A data frame with 224 rows and 7 variables:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean response for a given observation
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers as factors. Labels are shortened treatment names.
</p>
</li>
<li> <p><code>treatname</code> Character data giving the full names of each treatment in the format agent_dose
</p>
</li>
<li> <p><code>class</code> Shortened agent names stored as factors.
</p>
</li></ul>



<h3>Details</h3>

<p><code>goutSUA_CFB</code> is a data frame in long format (one row per observation, arm and study),
with the variables <code>studyID</code>, <code>time</code>, <code>y</code>, <code>se</code>, <code>treatment</code>, <code>treatname</code> and <code>class</code>.
</p>


<h3>Source</h3>

<p>Pfizer Ltd.
</p>

<hr>
<h2 id='goutSUA_CFBcomb'>Studies of combined treatments for reducing serum uric acid in patients with gout</h2><span id='topic+goutSUA_CFBcomb'></span>

<h3>Description</h3>

<p>A dataset from a systematic review of interventions for lowering Serum Uric Acid (SUA) concentration in
patients with gout <strong>(not published previously)</strong>. The outcome is continuous, and aggregate data responses
correspond to the mean change from baseline in SUA in mg/dL.
Treatments with similar doses have been pooled together to improve
network connectivity and facilitate evidence synthesis, resulting in 19 treatments of 7 agents included
in the network. Standard deviations have been imputed for 181 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goutSUA_CFBcomb
</code></pre>


<h3>Format</h3>

<p>A data frame with 224 rows and 7 variables:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean response for a given observation
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers as factors. Labels are shortened treatment names.
</p>
</li>
<li> <p><code>treatname</code> Character data giving the full names of each treatment in the format agent_dose
</p>
</li>
<li> <p><code>class</code> Shortened agent names stored as factors.
</p>
</li></ul>



<h3>Details</h3>

<p><code>goutSUA_CFBcomb</code> is a data frame in long format (one row per observation, arm and study),
with the variables <code>studyID</code>, <code>time</code>, <code>y</code>, <code>se</code>, <code>treatment</code>, <code>treatname</code> and <code>class</code>.
</p>


<h3>Source</h3>

<p>Pfizer Ltd.
</p>

<hr>
<h2 id='hyalarthritis'>Studies comparing hyaluronan (HA)â€“based viscosupplements for osteoarthritis</h2><span id='topic+hyalarthritis'></span>

<h3>Description</h3>

<p>A dataset from of trials for pain reduction for patients with
osteoarthritis treated with HA-based viscosupplements(Jansen et al. 2015).
Data are reported in each study arm as mean change from baseline to follow-up
on a visual analogue scale (0-100).
The dataset includes 16 Randomised-Controlled Trials (RCTs), comparing 6 treatments
and placebo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyalarthritis
</code></pre>


<h3>Format</h3>

<p>A data frame in long format (one row per arm and study), with 150 rows and 6 variables:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating the time at which the observation was measured (given in weeks)
</p>
</li>
<li> <p><code>treatment</code> Factor data indicating the treatment to which participants were randomised
</p>
</li>
<li> <p><code>n</code> Numeric data indicating the number of participants randomised to each arm
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean change from baseline in HbA1c in a study arm
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for the mean change from baseline in HbA1c in a study arm
</p>
</li></ul>



<h3>Details</h3>

<p><code>hyalarthritis</code> is a data frame in long format (one row per observation, arm and study),
with the variables <code>studyID</code>, <code>time</code>, <code>treatment</code>, <code>n</code>, <code>y</code>, and <code>se</code>.
</p>


<h3>References</h3>

<p>Jansen JP, Vieira MC, Cope S (2015).
&ldquo;Network meta-analysis of longitudinal data using fractional polynomials.&rdquo;
<em>Stat Med</em>, <b>34</b>(15), 2294-311.
ISSN 1097-0258 (Electronic) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.6492">doi:10.1002/sim.6492</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/25877808/">https://pubmed.ncbi.nlm.nih.gov/25877808/</a>.
</p>

<hr>
<h2 id='inconsistency.loops'>Identify comparisons in loops that fulfil criteria for node-splitting</h2><span id='topic+inconsistency.loops'></span>

<h3>Description</h3>

<p>Identify comparisons informed by both direct and indirect evidence from
independent sources, which therefore fulfil the criteria for testing for
inconsistency via node-splitting. Follows the method of van Valkenhoef van Valkenhoef et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inconsistency.loops(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inconsistency.loops_+3A_data">data</code></td>
<td>
<p>A data frame containing variables <code>studyID</code> and <code>treatment</code> (as
numeric codes) that indicate which treatments are used in which studies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to <code>gemtc::mtc.nodesplit()</code> but uses a fixed
reference treatment and therefore suggests fewer loops in which to test for
inconsistency. Heterogeneity can also be parameterised as inconsistency and
so testing for inconsistency in additional loops whilst changing the
reference treatment would also be identifying heterogeneity. Depends on <code><a href="igraph.html#topic+igraph">igraph</a></code>.
</p>


<h3>Value</h3>

<p>A data frame of comparisons that are informed by direct and indirect
evidence from independent sources. Each row of the data frame is a
different treatment comparison. Numerical codes in <code>t1</code> and <code>t2</code> correspond
to treatment codes.
</p>


<h3>References</h3>

<p>van Valkenhoef G, Dias S, Ades AE, Welton NJ (2016).
&ldquo;Automated generation of node-splitting models for assessment of inconsistency in network meta-analysis.&rdquo;
<em>Res Synth Methods</em>, <b>7</b>(1), 80-93.
ISSN 1759-2887 (Electronic) 1759-2879 (Linking), <a href="https://doi.org/10.1002/jrsm.1167">doi:10.1002/jrsm.1167</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/26461181/">https://pubmed.ncbi.nlm.nih.gov/26461181/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(studyID=c(1,1,2,2,3,3,4,4,5,5,5),
  treatment=c(1,2,1,3,2,3,3,4,1,2,4)
  )

# Identify comparisons informed by direct and indirect evidence
inconsistency.loops(data)
</code></pre>

<hr>
<h2 id='mb.comparisons'>Identify unique comparisons within a network (identical to MBNMAdose)</h2><span id='topic+mb.comparisons'></span>

<h3>Description</h3>

<p>Identify unique contrasts within a network that make up all the head-to-head comparisons. Repetitions
of the same treatment comparison are grouped together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb.comparisons(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb.comparisons_+3A_data">data</code></td>
<td>
<p>A data frame containing variables <code>studyID</code> and <code>treatment</code> (as numeric codes) that
indicate which treatments are used in which studies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of unique comparisons in which each row represents a different comparison.
<code>t1</code> and <code>t2</code> indicate the treatment codes that make up the comparison. <code>nr</code> indicates the number
of times the given comparison is made within the network.
</p>
<p>If there is only a single observation for each study within the dataset (i.e. as for standard
network meta-analysis) <code>nr</code> will represent the number of studies that compare treatments <code>t1</code> and
<code>t2</code>.
</p>
<p>If there are multiple observations for each study within the dataset (as in time-course MBNMA)
<code>nr</code> will represent the number of time points in the dataset in which treatments <code>t1</code> and <code>t2</code> are
compared.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(studyID=c(1,1,2,2,3,3,4,4,5,5,5),
  treatment=c(1,2,1,3,2,3,3,4,1,2,4)
  )

# Identify comparisons informed by direct and indirect evidence
mb.comparisons(data)
</code></pre>

<hr>
<h2 id='mb.make.contrast'>Convert arm-based MBNMA data to contrast data</h2><span id='topic+mb.make.contrast'></span>

<h3>Description</h3>

<p>Converts an object of class <code>mb.network</code> from arm-based long MBNMA data to a data frame with
contrast data (a separate contrast for each treatment comparison at each time point within each
study). Data can be either long or wide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb.make.contrast(network, datatype = NULL, format = "wide")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb.make.contrast_+3A_network">network</code></td>
<td>
<p>An object of class <code>mb.network</code></p>
</td></tr>
<tr><td><code id="mb.make.contrast_+3A_datatype">datatype</code></td>
<td>
<p>A string indicating the data type. Can be <code>binomial</code> or <code>normal</code></p>
</td></tr>
<tr><td><code id="mb.make.contrast_+3A_format">format</code></td>
<td>
<p>A string indicating the data format. Can be <code>wide</code> (two additional columns for each
variable - contrast arms) or <code>long</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns. In <code>wide</code> format, some columns are given the indices
1 and 2 to indicate each arm in a given treatment comparison.:
</p>

<ul>
<li> <p><code>t</code> The treatment in each arm
</p>
</li>
<li> <p><code>TE</code> The treatment effect (mean difference, log-odds) for the treatment in arm 1 versus the treatment
in arm 2
</p>
</li>
<li> <p><code>seTE</code> The standard error for the treatment effect (mean difference, log-odds) for the treatment in
arm 1 versus the treatment in arm 2
</p>
</li>
<li> <p><code>y</code> The mean response in each arm
</p>
</li>
<li> <p><code>se</code> The standard error of the mean in each arm
</p>
</li>
<li> <p><code>r</code> The number of responders in each arm
</p>
</li>
<li> <p><code>n</code> The total number of participants in each arm
</p>
</li>
<li> <p><code>fupcount</code> Follow-up identifier
</p>
</li>
<li> <p><code>time</code> The time the data are reported
</p>
</li>
<li> <p><code>studyID</code> Study identifier
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create mb.network
network &lt;- mb.network(osteopain)

# Convert to wide contrast data
mb.make.contrast(network, format="wide")

# Convert to long contrast data
mb.make.contrast(network, format="long")
</code></pre>

<hr>
<h2 id='mb.nodesplit.comparisons'>Identify comparisons in time-course MBNMA datasets that fulfil criteria for node-splitting</h2><span id='topic+mb.nodesplit.comparisons'></span>

<h3>Description</h3>

<p>Identify comparisons informed by both direct and indirect evidence from independent sources in MBNMA
datasets with repeated measurements in each study. These comparisons are therefore those which
fulfil the criteria for testing for inconsistency via node-splitting, following the method of van
Valkenhoef van Valkenhoef et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb.nodesplit.comparisons(network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb.nodesplit.comparisons_+3A_network">network</code></td>
<td>
<p>An object of class <code>"mb.network"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to <code>gemtc::mtc.nodesplit()</code> but uses a fixed
reference treatment and therefore suggests fewer loops in which to test for
inconsistency. Heterogeneity can also be parameterised as inconsistency and
so testing for inconsistency in additional loops whilst changing the
reference treatment would also be identifying heterogeneity. Depends on <code><a href="igraph.html#topic+igraph">igraph</a></code>.
</p>


<h3>Value</h3>

<p>A data frame of comparisons that are informed by direct and indirect
evidence from independent sources. Each row of the data frame is a
different treatment comparison. Numerical codes in <code>t1</code> and <code>t2</code> correspond
to treatment codes.
</p>


<h3>References</h3>

<p>van Valkenhoef G, Dias S, Ades AE, Welton NJ (2016).
&ldquo;Automated generation of node-splitting models for assessment of inconsistency in network meta-analysis.&rdquo;
<em>Res Synth Methods</em>, <b>7</b>(1), 80-93.
ISSN 1759-2887 (Electronic) 1759-2879 (Linking), <a href="https://doi.org/10.1002/jrsm.1167">doi:10.1002/jrsm.1167</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/26461181/">https://pubmed.ncbi.nlm.nih.gov/26461181/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create mb.network object
network &lt;- mb.network(osteopain)

# Identify comparisons informed by direct and indirect evidence
mb.nodesplit.comparisons(network)
</code></pre>

<hr>
<h2 id='mb.run'>Run MBNMA time-course models</h2><span id='topic+mb.run'></span>

<h3>Description</h3>

<p>Fits a Bayesian time-course model for model-based network meta-analysis
(MBNMA) that can account for repeated measures over time within studies by
applying a desired time-course function. Follows the methods of Pedder et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb.run(
  network,
  fun = tpoly(degree = 1),
  positive.scale = FALSE,
  intercept = NULL,
  link = "identity",
  sdscale = FALSE,
  parameters.to.save = NULL,
  rho = 0,
  covar = "varadj",
  omega = NULL,
  corparam = FALSE,
  class.effect = list(),
  UME = FALSE,
  pd = "pv",
  parallel = FALSE,
  priors = NULL,
  n.iter = 20000,
  n.chains = 3,
  n.burnin = floor(n.iter/2),
  n.thin = max(1, floor((n.iter - n.burnin)/1000)),
  model.file = NULL,
  jagsdata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb.run_+3A_network">network</code></td>
<td>
<p>An object of class <code>"mb.network"</code>.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="mb.run_+3A_positive.scale">positive.scale</code></td>
<td>
<p>A boolean object that indicates whether all continuous
mean responses (y) are positive and therefore whether the baseline response
should be given a prior that constrains it to be positive (e.g. for scales that cannot be &lt;0).</p>
</td></tr>
<tr><td><code id="mb.run_+3A_intercept">intercept</code></td>
<td>
<p>A boolean object that indicates whether an intercept (written
as <code>alpha</code> in the model) is to be included. If left as <code>NULL</code> (the default), an intercept will
be included only for studies reporting absolute means, and will be excluded for
studies reporting change from baseline (as indicated in <code>network$cfb</code>).</p>
</td></tr>
<tr><td><code id="mb.run_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="mb.run_+3A_sdscale">sdscale</code></td>
<td>
<p>Logical object to indicate whether to write a model that specifies a reference SD
for standardising when modelling using Standardised Mean Differences. Specifying <code>sdscale=TRUE</code>
will therefore only modify the model if link function is set to SMD (<code>link="smd"</code>).</p>
</td></tr>
<tr><td><code id="mb.run_+3A_parameters.to.save">parameters.to.save</code></td>
<td>
<p>A character vector containing names of parameters
to monitor in JAGS</p>
</td></tr>
<tr><td><code id="mb.run_+3A_rho">rho</code></td>
<td>
<p>The correlation coefficient when modelling within-study correlation between time points. The default is a string representing a
prior distribution in JAGS, indicating that it be estimated from the data (e.g. <code>rho="dunif(0,1)"</code>). <code>rho</code> also be assigned a
numeric value (e.g. <code>rho=0.7</code>), which fixes <code>rho</code> in the model to this value (e.g. for use in a deterministic sensitivity analysis).
If set to <code>rho=0</code> (the default) then this implies modelling no correlation between time points.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_covar">covar</code></td>
<td>
<p>A character specifying the covariance structure to use for modelling within-study correlation between time-points. This can
be done by specifying one of the following:
</p>

<ul>
<li> <p><code>"varadj"</code> - a univariate likelihood with a variance adjustment to assume a constant correlation between subsequent
time points (Jansen et al. 2015). This is the default.
</p>
</li>
<li> <p><code>"CS"</code> - a multivariate normal likelihood with a
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">compound symmetry</a> structure
</p>
</li>
<li> <p><code>"AR1"</code> - a multivariate normal likelihood with an
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">autoregressive AR1</a> structure
</p>
</li></ul>
</td></tr>
<tr><td><code id="mb.run_+3A_omega">omega</code></td>
<td>
<p>DEPRECATED IN VERSION 0.2.3 ONWARDS (~uniform(-1,1) now used for correlation between parameters
rather than a Wishart prior).
A scale matrix for the inverse-Wishart prior for the covariance matrix used
to model the correlation between time-course parameters (see Details for time-course functions). <code>omega</code> must
be a symmetric positive definite matrix with dimensions equal to the number of time-course parameters modelled using
relative effects (<code>pool="rel"</code>). If left as <code>NULL</code> (the default) a diagonal matrix with elements equal to 1
is used.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_corparam">corparam</code></td>
<td>
<p>A boolean object that indicates whether correlation should be modeled
between relative effect time-course parameters. Default is <code>FALSE</code> and this is automatically set to <code>FALSE</code> if class effects are modeled.
Setting it to <code>TRUE</code> models correlation between time-course parameters. This can help identify parameters
that are estimated poorly for some treatments by allowing sharing of information between
parameters for different treatments in the network, but may also cause some shrinkage.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_class.effect">class.effect</code></td>
<td>
<p>A list of named strings that determines which time-course
parameters to model with a class effect and what that effect should be
(<code>"common"</code> or <code>"random"</code>). For example: <code>list(emax="common", et50="random")</code>.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_ume">UME</code></td>
<td>
<p>Can take either <code>TRUE</code> or <code>FALSE</code> (for an unrelated mean effects
model on all or no time-course parameters respectively) or can be a vector
of parameter name strings to model as UME. For example: <code>c("beta.1", "beta.2")</code>.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_pd">pd</code></td>
<td>
<p>Can take either:
</p>

<ul>
<li> <p><code>pv</code> only pV will be reported (as automatically outputted by R2jags).
</p>
</li>
<li> <p><code>plugin</code> calculates pD by the plug-in
method (Spiegelhalter et al. 2002). It is faster, but may output negative
non-sensical values, due to skewed deviances that can arise with non-linear models.
</p>
</li>
<li> <p><code>pd.kl</code> (the default) calculates pD by the Kullbackâ€“Leibler divergence (Plummer 2008). This
will require running the model for additional iterations but
will always produce a sensical result.
</p>
</li>
<li> <p><code>popt</code> calculates pD using an optimism adjustment which allows for calculation
of the penalized expected deviance (Plummer 2008)
</p>
</li></ul>
</td></tr>
<tr><td><code id="mb.run_+3A_parallel">parallel</code></td>
<td>
<p>A boolean value that indicates whether JAGS should be run in
parallel (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>TRUE</code> then the number of cores to
use is automatically calculated. Functions that involve updating the model (e.g. <code>devplot()</code>, <code>fitplot()</code>)
cannot be used with models implemented in parallel.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_priors">priors</code></td>
<td>
<p>A named list of parameter values (without indices) and
replacement prior distribution values given as strings
<strong>using distributions as specified in JAGS syntax</strong> (see Plummer (2017)).</p>
</td></tr>
<tr><td><code id="mb.run_+3A_n.iter">n.iter</code></td>
<td>
<p>number of total iterations per chain (including burn in; default: 20000)</p>
</td></tr>
<tr><td><code id="mb.run_+3A_n.chains">n.chains</code></td>
<td>
<p>number of Markov chains (default: 3)</p>
</td></tr>
<tr><td><code id="mb.run_+3A_n.burnin">n.burnin</code></td>
<td>
<p>length of burn in, i.e. number of iterations to discard at the
beginning. Default is <code style="white-space: pre;">&#8288;n.iter/2``, that is, discarding the first half of the simulations. If &#8288;</code>n.burnin' is 0, jags() will run 100 iterations for adaption.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_n.thin">n.thin</code></td>
<td>
<p>thinning rate. Must be a positive integer. Set <code style="white-space: pre;">&#8288;n.thin &gt; 1`` to save memory and computation time if &#8288;</code>n.iter<code style="white-space: pre;">&#8288;is large. Default is&#8288;</code>max(1, floor(n.chains * (n.iter-n.burnin) / 1000))&ldquo; which will only thin if there are at least 2000
simulations.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_model.file">model.file</code></td>
<td>
<p>The file path to a JAGS model (.jags file) that can be used
to overwrite the JAGS model that is automatically written based on the
specified options in <code>MBNMAtime</code>. Useful for adding further model flexibility.</p>
</td></tr>
<tr><td><code id="mb.run_+3A_jagsdata">jagsdata</code></td>
<td>
<p>A named list of the data objects to be used in the JAGS model. Only
required if users are defining their own JAGS model using <code>model.file</code>. Format
should match that of standard models fitted in <code>MBNMAtime</code>
(see <code>mbnma$model.arg$jagsdata</code>)</p>
</td></tr>
<tr><td><code id="mb.run_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to R2jags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S3 class <code style="white-space: pre;">&#8288;c("mbnma", "rjags")`` containing parameter results from the model. Can be summarized by &#8288;</code>print()<code style="white-space: pre;">&#8288;and can check traceplots using&#8288;</code>R2jags::traceplot()<code style="white-space: pre;">&#8288;or various functions from the package&#8288;</code>mcmcplots&lsquo;.#&rsquo;
</p>
<p>If there are errors in the JAGS model code then the object will be a list
consisting of two elements - an error message from JAGS that can help with
debugging and <code>model.arg</code>, a list of arguments provided to <code>mb.run()</code>
which includes <code>jagscode</code>, the JAGS code for the model that can help
users identify the source of the error.
</p>


<h3>Time-course parameters</h3>

<p>Nodes that are automatically monitored (if present in the model) have the
same name as in the time-course function for named time-course parameters (e.g. <code>emax</code>).
However, for named only as <code>beta.1</code>, <code>beta.2</code>, <code>beta.3</code> or <code>beta.4</code> parameters
may have an alternative interpretation.
</p>
<p>Details of the interpretation and model specification of different parameters can be shown by using the
<code>summary()</code> method on an <code>"mbnma"</code> object generated by <code>mb.run()</code>.
</p>
<p><em>Parameters modelled using relative effects</em>
</p>

<ul>
<li><p> If pooling is relative (e.g. <code>pool.1="rel"</code>) for a given parameter then the named parameter (e.g. <code>emax</code>) or a
numbered <code>d</code> parameter (e.g. <code>d.1</code>) corresponds to the pooled relative effect for a given
treatment compared to the network reference treatment for this time-course parameter.
</p>
</li>
<li> <p><code>sd.</code> followed by a named (e.g. <code>emax</code>, <code>beta.1</code>) is the between-study SD (heterogeneity)
for relative effects, reported if pooling for a time-course parameter is relative (e.g. <code>pool.1="rel"</code>) <em>and</em> the
method for synthesis is random (e.g. <code style="white-space: pre;">&#8288;method.1="random&#8288;</code>).
</p>
</li>
<li><p> If class effects are modelled, parameters for classes are represented by the upper case name of the time-course
parameter they correspond to. For example if <code>class.effect=list(emax="random")</code>, relative class effects will be
represented by <code>EMAX</code>. The SD of the class effect (e.g. <code>sd.EMAX</code>, <code>sd.BETA.1</code>) is the SD of treatments within a class for the
time-course parameter they correspond to.
</p>
</li></ul>

<p><em>Parameters modelled using absolute effects</em>
</p>

<ul>
<li><p> If pooling is absolute (e.g. <code>pool.1="abs"</code>) for a given parameter then the named parameter (e.g. <code>emax</code>) or a
numbered <code>beta</code> parameter (e.g. <code>beta.1</code>) corresponds to the estimated absolute effect for this time-course parameter.
</p>
</li>
<li><p> For an absolute time-course parameter if the corresponding method is common (e.g. <code>method.1="common"</code>) the parameter
corresponds to a single common parameter estimated across all studies and treatments. If the corresponding method is
random (e.g. <code>method.1="random"</code>) then parameter is a mean effect around which the study-level absolute effects vary
with SD corresponding to <code>sd.</code> followed by the named parameter (e.g. <code>sd.emax</code>, <code>sd.beta.1</code>) .
</p>
</li></ul>

<p><em>Other model parameters</em>
</p>

<ul>
<li> <p><code>rho</code> The correlation coefficient for correlation between time-points. Its
interpretation will differ depending on the covariance structure specified in <code>covar</code>
</p>
</li>
<li> <p><code>totresdev</code> The residual deviance of the model
</p>
</li>
<li> <p><code>deviance</code> The deviance of the model
</p>
</li></ul>



<h3>Time-course function</h3>

<p>Several general time-course functions with up to 4 time-course parameters are provided, but a
user-defined time-course relationship can instead be used. Details can be found in the respective
help files for each function.
</p>
<p>Available time-course functions are:
</p>

<ul>
<li><p> Log-linear: <code>tloglin()</code>
</p>
</li>
<li><p> Polynomial: <code>tpoly()</code>
</p>
</li>
<li><p> Integrated Two-Component Prediction (ITP): <code>titp()</code>
</p>
</li>
<li><p> Emax: <code>temax()</code>
</p>
</li>
<li><p> Fractional polynomial: <code>tfpoly()</code>
</p>
</li>
<li><p> Splines (various spline types can be used): <code>tspline()</code>
</p>
</li>
<li><p> User-defined: <code>tuser()</code>
</p>
</li></ul>



<h3>Correlation between observations</h3>

<p>When modelling correlation between observations using <code>rho</code>, values for <code>rho</code> must imply a
positive semidefinite covariance matrix.
</p>


<h3>Advanced options</h3>

<p><code>model.file</code> and <code>jagsdata</code> can be used to run an edited JAGS model and dataset. This allows
users considerably more modelling flexibility than is possible using the basic <code>MBNMAtime</code> syntax,
though requires strong understanding of JAGS and the MBNMA modelling framework. Treatment-specific
priors, meta-regression and bias-adjustment are all possible in this way, and it allows users to
make use of the subsequent functions in <code>MBNMAtime</code> (plotting, prediction, ranking) whilst fitting
these more complex models.
</p>


<h3>References</h3>

<p>Friedrich JO, Adhikari NKJ, Beyene J (2011).
&ldquo;Ratio of means for analyzing continuous outcomes in meta-analysis performed as well as mean difference methods.&rdquo;
<em>Journal of Clinical Epidemiology</em>, <b>64</b>(5), 556-564.
<a href="https://doi.org/10.1016/j.jclinepi.2010.09.016">doi:10.1016/j.jclinepi.2010.09.016</a>.<br /><br /> Jansen JP, Vieira MC, Cope S (2015).
&ldquo;Network meta-analysis of longitudinal data using fractional polynomials.&rdquo;
<em>Stat Med</em>, <b>34</b>(15), 2294-311.
ISSN 1097-0258 (Electronic) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.6492">doi:10.1002/sim.6492</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/25877808/">https://pubmed.ncbi.nlm.nih.gov/25877808/</a>.<br /><br /> Pedder H, Dias S, Bennetts M, Boucher M, Welton NJ (2019).
&ldquo;Modelling time-course relationships with multiple treatments: Model-Based Network Meta-Analysis for continuous summary outcomes.&rdquo;
<em>Res Synth Methods</em>, <b>10</b>(2), 267-286.<br /><br /> Plummer M (2008).
&ldquo;Penalized loss functions for Bayesian model comparison.&rdquo;
<em>Biostatistics</em>, <b>9</b>(3), 523-39.
ISSN 1468-4357 (Electronic) 1465-4644 (Linking), <a href="https://pubmed.ncbi.nlm.nih.gov/18209015/">https://pubmed.ncbi.nlm.nih.gov/18209015/</a>.<br /><br /> Plummer M (2017).
<em>JAGS user manual</em>.
<a href="https://people.stat.sc.edu/hansont/stat740/jags_user_manual.pdf">https://people.stat.sc.edu/hansont/stat740/jags_user_manual.pdf</a>.<br /><br /> Spiegelhalter DJ, Best NG, Carlin BP, van der Linde A (2002).
&ldquo;Bayesian measures of model complexity and fit.&rdquo;
<em>J R Statistic Soc B</em>, <b>64</b>(4), 583-639.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create mb.network object
network &lt;- mb.network(osteopain)

# Fit a linear time-course MBNMA with:
# random relative treatment effects on the slope
mb.run(network, fun=tpoly(degree=1, pool.1="rel", method.1="random"))

# Fit an emax time-course MBNMA with:
# fixed relative treatment effects on emax
# a common parameter estimated independently of treatment
# a common Hill parameter estimated independently of treatment
# a prior for the Hill parameter (normal with mean 0 and precision 0.1)
# data reported as change from baseline
result &lt;- mb.run(network, fun=temax(pool.emax="rel", method.emax="common",
                                    pool.et50="abs", method.et50="common",
                                    pool.hill="abs", method.hill="common"),
                 priors=list(hill="dunif(0.5, 2)"),
                 intercept=TRUE)


#### commented out to prevent errors from JAGS version in github actions build ####
# Fit a log-linear MBNMA with:
# random relative treatment effects on the rate
# an autoregressive AR1 covariance structure
# modelled as standardised mean differences
# copdnet &lt;- mb.network(copd)
# result &lt;- mb.run(copdnet, fun=tloglin(pool.rate="rel", method.rate="random"),
#                covar="AR1", rho="dunif(0,1)", link="smd")



####### Examine MCMC diagnostics (using mcmcplots package) #######

# Traceplots
# mcmcplots::traplot(result)

# Plots for assessing convergence
# mcmcplots::mcmcplot(result, c("rate", "sd.rate", "rho"))

########## Output ###########

# Print R2jags output and summary
print(result)
summary(result)

# Plot forest plot of results
plot(result)


###### Additional model arguments ######

# Use gout dataset
goutnet &lt;- mb.network(goutSUA_CFBcomb)

# Define a user-defined time-course relationship for use in mb.run
timecourse &lt;- ~ exp(beta.1 * time) + (time^beta.2)

# Run model with:
# user-defined time-course function
# random relative effects on beta.1
# default common effects on beta.2
# default relative pooling on beta.1 and beta.2
# common class effect on beta.2
mb.run(goutnet, fun=tuser(fun=timecourse, method.1="random"),
       class.effect=list(beta.1="common"))

# Fit a log-linear MBNMA
# with variance adjustment for correlation between time-points
result &lt;- mb.run(network, fun=tloglin(),
                 rho="dunif(0,1)", covar="varadj")

</code></pre>

<hr>
<h2 id='mb.update'>Update MBNMA to obtain deviance contributions or fitted values</h2><span id='topic+mb.update'></span>

<h3>Description</h3>

<p>Update MBNMA to obtain deviance contributions or fitted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb.update(
  mbnma,
  param = "theta",
  n.iter = mbnma$BUGSoutput$n.iter,
  n.thin = mbnma$BUGSoutput$n.thin
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb.update_+3A_mbnma">mbnma</code></td>
<td>
<p>An S3 object of class <code>"mbnma"</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="mb.update_+3A_param">param</code></td>
<td>
<p>A character object that represents the parameter within the model to monitor when updating. Can
currently only be used for monitoring fitted values and deviance contributions and so can take
either <code>"dev"</code> (for deviance contributions), <code>"resdev"</code> (for residual deviance contributions)
or <code>"theta"</code> (for fitted values).</p>
</td></tr>
<tr><td><code id="mb.update_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of iterations to update the model whilst monitoring additional parameters (if necessary).
Must be a positive integer. Default is the value used in <code>mbnma</code>.</p>
</td></tr>
<tr><td><code id="mb.update_+3A_n.thin">n.thin</code></td>
<td>
<p>The thinning rate. Must be a positive integer. Default is the value used in <code>mbnma</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing posterior means for the specified <code>param</code> at each observation, arm and study.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the alogliptin dataset
network &lt;- mb.network(alog_pcfb)

# Run Emax model
emax &lt;- mb.run(network, fun=temax())

# Update model for 500 iterations to monitor fitted values
mb.update(emax, param="theta", n.iter=500)

# Update model for 500 iterations to monitor residual deviance contributions
mb.update(emax, param="resdev", n.iter=500)

# Update model for 500 iterations to monitor deviance contributions
mb.update(emax, param="dev", n.iter=500)

</code></pre>

<hr>
<h2 id='mb.validate.data'>Validates that a dataset fulfils requirements for MBNMA</h2><span id='topic+mb.validate.data'></span>

<h3>Description</h3>

<p>Validates that a dataset fulfils requirements for MBNMA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb.validate.data(data.ab, single.arm = FALSE, CFB = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb.validate.data_+3A_data.ab">data.ab</code></td>
<td>
<p>A data frame of arm-level data in &quot;long&quot; format containing the columns:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the aggregate response for a given observation (e.g. mean)
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers (can be numeric, factor or character)
</p>
</li>
<li> <p><code>class</code> An optional column indicating a particular class identifier. Observations with the same treatment
identifier must also have the same class identifier.
</p>
</li>
<li> <p><code>n</code> An optional column indicating the number of participants used to calculate the
response at a given observation (required if modelling using Standardised Mean Differences)
</p>
</li>
<li> <p><code>standsd</code> An optional column of numeric data indicating reference SDs used to standardise
treatment effects when modelling using Standardised Mean Differences (SMD).
</p>
</li></ul>
</td></tr>
<tr><td><code id="mb.validate.data_+3A_single.arm">single.arm</code></td>
<td>
<p>A boolean object to indicate whether or not function should allow singe arm studies to
be allowed in the network without returning an error. Default is not to allow their inclusion (<code>single.arm=FALSE</code>)</p>
</td></tr>
<tr><td><code id="mb.validate.data_+3A_cfb">CFB</code></td>
<td>
<p>A boolean object to indicate if the dataset is composed of studies measuring change from
baseline (<code>TRUE</code>) or not (<code>FALSE</code>). It is not essential to specify this correctly but failing to do so
may lead to warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks done within the validation:
</p>

<ul>
<li><p> Checks data.ab has required column names
</p>
</li>
<li><p> Checks there are no NAs
</p>
</li>
<li><p> Checks that all SEs are positive
</p>
</li>
<li><p> Checks that studies have baseline measurement (unless change from baseline data is being used)
</p>
</li>
<li><p> Checks that arms are balanced at each time point
</p>
</li>
<li><p> Checks that class codes are consistent within each treatment
</p>
</li>
<li><p> Checks that treatment codes are consistent across different time points within a study
</p>
</li>
<li><p> Checks that studies have at least two arms (if <code>single.arm = FALSE</code>)
</p>
</li>
<li><p> Checks that standsd values are consistent within a study
</p>
</li></ul>



<h3>Value</h3>

<p>An error or warnings if checks are not passed. Runs silently if checks are passed
</p>

<hr>
<h2 id='mb.write'>Write MBNMA time-course models JAGS code</h2><span id='topic+mb.write'></span>

<h3>Description</h3>

<p>Writes JAGS code for a Bayesian time-course model for model-based network
meta-analysis (MBNMA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb.write(
  fun = tpoly(degree = 1),
  link = "identity",
  positive.scale = TRUE,
  intercept = NULL,
  rho = 0,
  covar = "varadj",
  omega = NULL,
  corparam = TRUE,
  sdscale = FALSE,
  class.effect = list(),
  UME = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb.write_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="mb.write_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="mb.write_+3A_positive.scale">positive.scale</code></td>
<td>
<p>A boolean object that indicates whether all continuous
mean responses (y) are positive and therefore whether the baseline response
should be given a prior that constrains it to be positive (e.g. for scales that cannot be &lt;0).</p>
</td></tr>
<tr><td><code id="mb.write_+3A_intercept">intercept</code></td>
<td>
<p>A boolean object that indicates whether an intercept (written
as <code>alpha</code> in the model) is to be included. If left as <code>NULL</code> (the default), an intercept will
be included only for studies reporting absolute means, and will be excluded for
studies reporting change from baseline (as indicated in <code>network$cfb</code>).</p>
</td></tr>
<tr><td><code id="mb.write_+3A_rho">rho</code></td>
<td>
<p>The correlation coefficient when modelling within-study correlation between time points. The default is a string representing a
prior distribution in JAGS, indicating that it be estimated from the data (e.g. <code>rho="dunif(0,1)"</code>). <code>rho</code> also be assigned a
numeric value (e.g. <code>rho=0.7</code>), which fixes <code>rho</code> in the model to this value (e.g. for use in a deterministic sensitivity analysis).
If set to <code>rho=0</code> (the default) then this implies modelling no correlation between time points.</p>
</td></tr>
<tr><td><code id="mb.write_+3A_covar">covar</code></td>
<td>
<p>A character specifying the covariance structure to use for modelling within-study correlation between time-points. This can
be done by specifying one of the following:
</p>

<ul>
<li> <p><code>"varadj"</code> - a univariate likelihood with a variance adjustment to assume a constant correlation between subsequent
time points (Jansen et al. 2015). This is the default.
</p>
</li>
<li> <p><code>"CS"</code> - a multivariate normal likelihood with a
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">compound symmetry</a> structure
</p>
</li>
<li> <p><code>"AR1"</code> - a multivariate normal likelihood with an
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">autoregressive AR1</a> structure
</p>
</li></ul>
</td></tr>
<tr><td><code id="mb.write_+3A_omega">omega</code></td>
<td>
<p>DEPRECATED IN VERSION 0.2.3 ONWARDS (~uniform(-1,1) now used for correlation between parameters
rather than a Wishart prior).
A scale matrix for the inverse-Wishart prior for the covariance matrix used
to model the correlation between time-course parameters (see Details for time-course functions). <code>omega</code> must
be a symmetric positive definite matrix with dimensions equal to the number of time-course parameters modelled using
relative effects (<code>pool="rel"</code>). If left as <code>NULL</code> (the default) a diagonal matrix with elements equal to 1
is used.</p>
</td></tr>
<tr><td><code id="mb.write_+3A_corparam">corparam</code></td>
<td>
<p>A boolean object that indicates whether correlation should be modeled
between relative effect time-course parameters. Default is <code>FALSE</code> and this is automatically set to <code>FALSE</code> if class effects are modeled.
Setting it to <code>TRUE</code> models correlation between time-course parameters. This can help identify parameters
that are estimated poorly for some treatments by allowing sharing of information between
parameters for different treatments in the network, but may also cause some shrinkage.</p>
</td></tr>
<tr><td><code id="mb.write_+3A_sdscale">sdscale</code></td>
<td>
<p>Logical object to indicate whether to write a model that specifies a reference SD
for standardising when modelling using Standardised Mean Differences. Specifying <code>sdscale=TRUE</code>
will therefore only modify the model if link function is set to SMD (<code>link="smd"</code>).</p>
</td></tr>
<tr><td><code id="mb.write_+3A_class.effect">class.effect</code></td>
<td>
<p>A list of named strings that determines which time-course
parameters to model with a class effect and what that effect should be
(<code>"common"</code> or <code>"random"</code>). For example: <code>list(emax="common", et50="random")</code>.</p>
</td></tr>
<tr><td><code id="mb.write_+3A_ume">UME</code></td>
<td>
<p>Can take either <code>TRUE</code> or <code>FALSE</code> (for an unrelated mean effects
model on all or no time-course parameters respectively) or can be a vector
of parameter name strings to model as UME. For example: <code>c("beta.1", "beta.2")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single long character string containing the JAGS model generated
based on the arguments passed to the function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Write a linear time-course MBNMA:
# random treatment effects on beta.1
# equal baselines in study arms
model &lt;- mb.write(fun=tpoly(degree=1, pool.1="rel", method.1="random"))

# Write an emax time-course MBNMA with:
# a Hill parameter
# no intercept
model &lt;- mb.write(fun=temax(pool.emax="rel", method.emax="common",
    pool.et50="abs", method.et50="common", pool.hill="abs", method.hill="common"),
  intercept=TRUE)

# Write a log-linear time-course MBNMA with:
# AR1 correlation between time points
model &lt;- mb.write(fun=tloglin(),
  rho="dunif(0,1)", covar="AR1")

# Define a user-defined time-course relationship for the MBNMA JAGS model
userfun &lt;- ~ (exp(beta.1 * time) / (beta.2 * time))
model &lt;- mb.write(fun=tuser(fun=userfun,
    pool.1="rel", method.1="random",
    pool.2="rel", method.2="common"))

</code></pre>

<hr>
<h2 id='MBNMAtime-package'>MBNMAtime for Model-Based Network Meta-Analysis of longitudinal (time-course) data</h2><span id='topic+MBNMAtime'></span><span id='topic+MBNMAtime-package'></span>

<h3>Description</h3>

<p>MBNMAtime provides a collection of useful commands that allow users to run time-course
Model-Based Network Meta-Analysis (MBNMA).
</p>


<h3>Introduction</h3>

<p>MBNMAtime allows meta-analysis of studies with multiple follow-up measurements that can
account for time-course for a single or multiple treatment comparisons.
</p>
<p>Including all available follow-up measurements within a study makes use of all the available
evidence in a way that maintains connectivity between treatments, and it does so in a way
that explains time-course, thus explaining heterogeneity and inconsistency that may be
present in a standard Network Meta-Analysis (NMA). All models and analyses are implemented
in a Bayesian framework, following an extension of the standard NMA methodology presented by
(Lu and Ades 2004) and are run in JAGS ( ). Correlation between
time-points can be accounted for in the modelling framework. For full details of time-course MBNMA
methodology see Pedder et al. (2019).
</p>


<h3>Workflow</h3>

<p>Functions within <code>MBNMAtime</code> follow a clear pattern of use:
</p>

<ol>
<li><p> Load your data into the correct format using <code><a href="#topic+mb.network">mb.network</a></code>
</p>
</li>
<li><p> Specify a suitable time-course function and analyse your data using <code><a href="#topic+mb.run">mb.run</a></code>
</p>
</li>
<li><p> Test for consistency using <code><a href="#topic+mb.nodesplit">mb.nodesplit</a></code> or by fitting Unrelated Mean Effects models
</p>
</li>
<li><p> Examine model results using forest plots and treatment rankings
</p>
</li>
<li><p> Use your model to predict responses or estimate treatment effects at specific time-points using <code><a href="#topic+predict.mbnma">predict.mbnma</a></code>
</p>
</li></ol>

<p>At each of these stages there are a number of informative plots that can be generated to help make sense of your data and the models that you are fitting.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hugo Pedder <a href="mailto:hugopedder@gmail.com">hugopedder@gmail.com</a> (<a href="https://orcid.org/0000-0002-7813-3749">ORCID</a>)
</p>


<h3>References</h3>

<p>(2017).
<a href="https://mcmc-jags.sourceforge.io/">https://mcmc-jags.sourceforge.io/</a>.<br /><br /> Lu G, Ades AE (2004).
&ldquo;Combination of direct and indirect evidence in mixed treatment comparisons.&rdquo;
<em>Stat Med</em>, <b>23</b>(20), 3105-24.
ISSN 0277-6715 (Print) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.1875">doi:10.1002/sim.1875</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/15449338/">https://pubmed.ncbi.nlm.nih.gov/15449338/</a>.<br /><br /> Pedder H, Dias S, Bennetts M, Boucher M, Welton NJ (2019).
&ldquo;Modelling time-course relationships with multiple treatments: Model-Based Network Meta-Analysis for continuous summary outcomes.&rdquo;
<em>Res Synth Methods</em>, <b>10</b>(2), 267-286.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://hugaped.github.io/MBNMAtime/">https://hugaped.github.io/MBNMAtime/</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Generate an "mb.network" object that stores data in the correct format
network &lt;- mb.network(osteopain)

# Generate a network plot
plot(network, label.distance=3)

# Analyse data using mb.run()
result &lt;- mb.run(network, fun=tloglin())

# Time-course parameters can be explicitly specified
# Correlation between time-points can be accounted for
result &lt;- mb.run(network,
  fun=temax(pool.emax="rel", method.emax="common",
    pool.et50="rel", method.et50="common"),
  rho="dunif(0,1)")

# Explore model fit statistics - plot residual deviances
devplot(result, n.iter=500)

# Generate a forest plot for model results
plot(result)

decision.treats &lt;- c("Pl_0", "Ce_100", "Lu_400", "Ro_125",
  "Na_1000", "Na_1500", "Et_10")

# Predict responses for selected treatments
pred &lt;- predict(result, time=c(0:10), E0=8,
  treats=decision.treats,
  ref.resp=subset(osteopain, treatment=="Pl_0"))

# Plot predicted response
plot(pred, disp.obs=TRUE)

# Rank by Area Under the time-course Curve
ranks &lt;- rank(result, param="auc", lower_better=TRUE, n.iter=500,
  treats=decision.treats)

plot(ranks) # Plot histogram of rankings
cumrank(ranks) # Plot cumulative rankograms


</code></pre>

<hr>
<h2 id='nma.run'>Run an NMA model</h2><span id='topic+nma.run'></span>

<h3>Description</h3>

<p>Run an NMA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nma.run(
  data.ab,
  treatments = NULL,
  method = "common",
  link = "identity",
  sdscale = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nma.run_+3A_data.ab">data.ab</code></td>
<td>
<p>A data frame of arm-level data in &quot;long&quot; format containing the columns:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the aggregate response for a given observation (e.g. mean)
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers (can be numeric, factor or character)
</p>
</li>
<li> <p><code>class</code> An optional column indicating a particular class identifier. Observations with the same treatment
identifier must also have the same class identifier.
</p>
</li>
<li> <p><code>n</code> An optional column indicating the number of participants used to calculate the
response at a given observation (required if modelling using Standardised Mean Differences)
</p>
</li>
<li> <p><code>standsd</code> An optional column of numeric data indicating reference SDs used to standardise
treatment effects when modelling using Standardised Mean Differences (SMD).
</p>
</li></ul>
</td></tr>
<tr><td><code id="nma.run_+3A_treatments">treatments</code></td>
<td>
<p>A vector of treatment names. If left as <code>NULL</code> it will use
the treatment coding given in <code>data.ab</code></p>
</td></tr>
<tr><td><code id="nma.run_+3A_method">method</code></td>
<td>
<p>Can take <code>"common"</code> or <code>"random"</code> to indicate the type of NMA model used to synthesise data points
given in <code>overlay.nma</code>. The default is <code>"random"</code> since this assumes different
time-points in <code>overlay.nma</code> have been lumped together to estimate the NMA.</p>
</td></tr>
<tr><td><code id="nma.run_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="nma.run_+3A_sdscale">sdscale</code></td>
<td>
<p>Logical object to indicate whether to write a model that specifies a reference SD
for standardising when modelling using Standardised Mean Differences. Specifying <code>sdscale=TRUE</code>
will therefore only modify the model if link function is set to SMD (<code>link="smd"</code>).</p>
</td></tr>
<tr><td><code id="nma.run_+3A_...">...</code></td>
<td>
<p>Options for plotting in <code>igraph</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code>class("nma", "rjags")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network &lt;- mb.network(osteopain)

# Get the latest time point
late.time &lt;- get.latest.time(network)

# Get the closest time point to a given value (t)
early.time &lt;- get.closest.time(network, t=7)

# Run NMA on the data
nma.run(late.time$data.ab, treatments=late.time$treatments,
  method="random")

</code></pre>

<hr>
<h2 id='obesityBW_CFB'>Studies of treatments for reducing body weight in patients with obesity</h2><span id='topic+obesityBW_CFB'></span>

<h3>Description</h3>

<p>A dataset from a systematic review of pharmacological treatments for reducing body weight in patients with
obesity. The outcome is continuous, and aggregate data responses are given as mean change from baseline in
body weight (KG). Overall there are 35 RCTs investigating
26 treatments of 16 agents (/combinations of agents) in the network. Standard
deviations have been imputed for 421 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obesityBW_CFB
</code></pre>


<h3>Format</h3>

<p>A data frame with 710 rows and 7 variables:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean response for a given observation
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li>
<li> <p><code>n</code> Numeric data indicating the number of participants used to calculate means for each observation
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers as factors. Labels are shortened treatment names.
</p>
</li>
<li> <p><code>treatname</code> Character data giving the full names of each treatment in the format agent_dose
</p>
</li>
<li> <p><code>agent</code> Agent (drug) names stored as characters
</p>
</li>
<li> <p><code>class</code> The drug class of the agent (a broader category than <code>agent</code>) stored as characters
</p>
</li></ul>



<h3>Details</h3>

<p><code>obesityBW_CFB</code> is a data frame in long format (one row per observation, arm and study),
with the variables <code>studyID</code>, <code>time</code>, <code>y</code>, <code>se</code>, <code>n</code>, <code>treatment</code>, <code>treatname</code>, <code>agent</code> and <code>class</code>.
</p>


<h3>Source</h3>

<p>Pfizer Ltd.
</p>

<hr>
<h2 id='osteopain'>Studies of pain relief medications for osteoarthritis</h2><span id='topic+osteopain'></span>

<h3>Description</h3>

<p>A dataset containing results on the WOMAC pain scale (0-10) over time for studies investigating 29
treatments for pain relief in patients with osteoarthritis. Standard deviations have been imputed for
269 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osteopain
</code></pre>


<h3>Format</h3>

<p>A data frame with 417 rows and 7 variables:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean response for a given observation
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers as factors. Labels are shortened treatment names.
</p>
</li>
<li> <p><code>arm</code> Arm identifiers coded for each study
</p>
</li>
<li> <p><code>treatname</code> Character data giving the full names of each treatment
</p>
</li></ul>



<h3>Details</h3>

<p><code>osteopain</code> is a data frame in long format (one row per observation, arm and study),
with the variables <code>studyID</code>, <code>time</code>, <code>y</code>, <code>se</code>, <code>treatment</code>, <code>arm</code> and <code>treatname</code>.
</p>


<h3>Source</h3>

<p>Pfizer Ltd.
</p>

<hr>
<h2 id='pDcalc'>Calculate plugin pD from a JAGS model with univariate likelihood for studies
with repeated measurements</h2><span id='topic+pDcalc'></span>

<h3>Description</h3>

<p>Uses results from MBNMA JAGS models to calculate pD via the
plugin method (Spiegelhalter et al. 2002). Can only be used for models with known
standard errors or covariance matrices (typically univariate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pDcalc(
  obs1,
  obs2,
  fups = NULL,
  narm,
  NS,
  theta.result,
  resdev.result,
  likelihood = "normal",
  type = "time"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pDcalc_+3A_obs1">obs1</code></td>
<td>
<p>A matrix (study x arm) or array (study x arm x time point) containing
observed data for <code>y</code> (normal likelihood) or <code>r</code> (binomial or Poisson likelihood)
in each arm of each study. This will be the same array
used as data for the JAGS model.</p>
</td></tr>
<tr><td><code id="pDcalc_+3A_obs2">obs2</code></td>
<td>
<p>A matrix (study x arm) or array (study x arm x time point) containing
observed data for <code>se</code> (normal likelihood), <code>N</code> (binomial likelihood) or <code>E</code> (Poisson likelihood)
in each arm of each study. This will be the same array
used as data for the JAGS model.</p>
</td></tr>
<tr><td><code id="pDcalc_+3A_fups">fups</code></td>
<td>
<p>A numeric vector of length equal to the number of studies,
containing the number of follow-up mean responses reported in each study. Required for
time-course MBNMA models (if <code>type="time"</code>)</p>
</td></tr>
<tr><td><code id="pDcalc_+3A_narm">narm</code></td>
<td>
<p>A numeric vector of length equal to the number of studies,
containing the number of arms in each study.</p>
</td></tr>
<tr><td><code id="pDcalc_+3A_ns">NS</code></td>
<td>
<p>A single number equal to the number of studies in the dataset.</p>
</td></tr>
<tr><td><code id="pDcalc_+3A_theta.result">theta.result</code></td>
<td>
<p>A matrix (study x arm) or array (study x arm x time point)
containing the posterior mean predicted means/probabilities/rate in each arm of each
study. This will be estimated by the JAGS model.</p>
</td></tr>
<tr><td><code id="pDcalc_+3A_resdev.result">resdev.result</code></td>
<td>
<p>A matrix (study x arm) or array (study x arm x time point)
containing the posterior mean residual deviance contributions in each arm of each
study. This will be estimated by the JAGS model.</p>
</td></tr>
<tr><td><code id="pDcalc_+3A_likelihood">likelihood</code></td>
<td>
<p>A character object of any of the following likelihoods:
</p>

<ul>
<li> <p><code>univariate</code>
</p>
</li>
<li> <p><code>binomial</code> (does not work with time-course MBNMA models)
</p>
</li>
<li> <p><code>multivar.normal</code> (does not work with time-course MBNMA models)
</p>
</li></ul>
</td></tr>
<tr><td><code id="pDcalc_+3A_type">type</code></td>
<td>
<p>The type of MBNMA model fitted. Can be either <code>"time"</code> or <code>"dose"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method for calculating pD via the plugin method proposed by
(Spiegelhalter et al. 2002). Standard errors / covariance matrices must be assumed
to be known. To obtain values for theta.result and resdev.result these
parameters must be monitored when running the JAGS model.
</p>
<p>For non-linear time-course MBNMA models residual deviance contributions may be skewed, which
can lead to non-sensical results when calculating pD via the plugin method.
Alternative approaches are to use pV (<code>pv</code>) as an approximation (Plummer 2008) or
pD calculated by Kullbackâ€“Leibler divergence (<code>pd.kl</code>) or using an optimism adjustment (<code>popt</code>) (Plummer 2008).
</p>


<h3>Value</h3>

<p>A numeric value for the effective number of parameters, pD, calculated via the plugin method
</p>


<h3>References</h3>

<p>TO ADD pV REF
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the alogliptin dataset
network &lt;- mb.network(alog_pcfb)

# Run Emax model saving predicted means and residual deviance contributions
emax &lt;- mb.run(network, fun=temax(),
  parameters.to.save=c("theta", "resdev"), intercept=FALSE)

# Get matrices of observed data
jagsdat &lt;- getjagsdata(network$data.ab)

# Plugin estimation of pD is problematic with non-linear models as it often leads to
#negative values, hence use of pV, pd.kl and popt as other measures for the effective
#number of parameters
pDcalc(obs1=jagsdat$y, obs2=jagsdat$se,
  fups=jagsdat$fups, narm=jagsdat$narm, NS=jagsdat$NS,
  theta.result = emax$BUGSoutput$mean$theta,
  resdev.result = emax$BUGSoutput$mean$resdev
  )

</code></pre>

<hr>
<h2 id='plot.mb.network'>Create an <code>mb.network</code> object</h2><span id='topic+plot.mb.network'></span><span id='topic+mb.network'></span>

<h3>Description</h3>

<p>Creates an object of <code>class("mb.network")</code>. Various MBNMA functions can subsequently be applied
to this object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mb.network'
plot(
  x,
  edge.scale = 1,
  label.distance = 0,
  level = "treatment",
  remove.loops = FALSE,
  v.color = "connect",
  v.scale = NULL,
  layout = igraph::in_circle(),
  legend = TRUE,
  legend.x = "bottomleft",
  legend.y = NULL,
  ...
)

mb.network(data.ab, reference = 1, cfb = NULL, description = "Network")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mb.network_+3A_x">x</code></td>
<td>
<p>An object of class <code>mb.network</code>.</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_edge.scale">edge.scale</code></td>
<td>
<p>A number to scale the thickness of connecting lines
(edges). Line thickness is proportional to the number of studies for a
given comparison. Set to <code>0</code> to make thickness equal for all comparisons.</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_label.distance">label.distance</code></td>
<td>
<p>A number scaling the distance of labels from the nodes
to improve readability. The labels will be directly on top of the nodes if
the default of <code>0</code> is used. Option only applicable if <code>layout_in_circle</code> is
set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_level">level</code></td>
<td>
<p>A string indicating whether nodes/facets should represent <code>treatment</code>
or <code>class</code> in the plot. Can be used to examine the expected impact of modelling
class/agent effects.</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_remove.loops">remove.loops</code></td>
<td>
<p>A boolean value indicating whether to include loops that
indicate comparisons within a node.</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_v.color">v.color</code></td>
<td>
<p>Can take either <code>"connect"</code> (the default) to indicate that nodes should
only be coloured if they are connected to the network reference treatment (indicates
network connectivity) or <code>"class"</code> to colour nodes by class (this requires that the
variable <code>class</code> be included in the dataset).</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_v.scale">v.scale</code></td>
<td>
<p>A number with which to scale the size of the nodes. If the variable <code>N</code>
(to indicate the numbers of participants at each observation) is included in the
dataset then the size of the nodes will be proportional to the number of participants
within a treatment/class in the network <em>at the earliest time point reported in each study</em>.</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_layout">layout</code></td>
<td>
<p>An igraph layout specification. This is a function specifying an igraph
layout that determines the arrangement of the vertices (nodes). The default
<code>igraph::as_circle()</code> arranged vertices in a circle. Two other useful layouts for
network plots are: <code>igraph::as_star()</code>, <code>igraph::with_fr()</code>. Others can be found
in <code><a href="igraph.html#topic+layout_">layout_</a></code></p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_legend">legend</code></td>
<td>
<p>A boolean value indicating whether or not to plot a legend with class names if <code>v.color="class"</code></p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_legend.x">legend.x</code></td>
<td>
<p>Can be either a string or a numerical x-coordinate indicating where the legend should be
plotted (see <code><a href="graphics.html#topic+legend">legend</a></code>).</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_legend.y">legend.y</code></td>
<td>
<p>A numerical y-coordinate indicating where the legend should be plotted - only required if <code>legend.x</code> is also
a numeric co-ordinate.</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_...">...</code></td>
<td>
<p>Options for plotting in <code>igraph</code>.</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_data.ab">data.ab</code></td>
<td>
<p>A data frame of arm-level data in &quot;long&quot; format containing the columns:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the aggregate response for a given observation (e.g. mean)
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li>
<li> <p><code>treatment</code> Treatment identifiers (can be numeric, factor or character)
</p>
</li>
<li> <p><code>class</code> An optional column indicating a particular class identifier. Observations with the same treatment
identifier must also have the same class identifier.
</p>
</li>
<li> <p><code>n</code> An optional column indicating the number of participants used to calculate the
response at a given observation (required if modelling using Standardised Mean Differences)
</p>
</li>
<li> <p><code>standsd</code> An optional column of numeric data indicating reference SDs used to standardise
treatment effects when modelling using Standardised Mean Differences (SMD).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_reference">reference</code></td>
<td>
<p>A number or character (depending on the format of <code>treatment</code> within <code>data.ab</code>)
indicating the reference treatment in the network (i.e. those for which estimated relative treatment
effects estimated by the model will be compared to).</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_cfb">cfb</code></td>
<td>
<p>A logical vector whose length is equal to the unique number of studies in <code>data.ab</code>, where each
element is <code>TRUE</code> if the study data reported is change-from-baseline and <code>FALSE</code> otherwise. If left as <code>NULL</code>
(the default) then this will be identified from the data by assuming any study for which there is no data
at <code>time=0</code> reports change-from-baseline.</p>
</td></tr>
<tr><td><code id="plot.mb.network_+3A_description">description</code></td>
<td>
<p>Optional. Short description of the network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The S3 method <code>plot()</code> on an <code>mb.network</code> object generates a
network plot that shows how different treatments are connected within the
network via study comparisons. This can be used to identify how direct and
indirect evidence are informing different treatment comparisons. Depends on
<code><a href="igraph.html#topic+igraph">igraph</a></code>.
</p>
<p>Missing values (<code>NA</code>) cannot be included in the dataset. Studies must have a baseline
measurement and more than a single follow-up time (unless change from baseline data are being used).
Data must be present for all arms within a study at each follow-up time.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"igraph"</code>, which can be modified by other
functions within the <code>igraph</code> package.
</p>
<p>An object of <code>class("mb.network")</code> which is a list containing:
</p>

<ul>
<li> <p><code>description</code> A short description of the network
</p>
</li>
<li> <p><code>data.ab</code> A data frame containing the arm-level network data (treatment identifiers will have
been recoded to a sequential numeric code)
</p>
</li>
<li> <p><code>studyID</code> A character vector with the IDs of included studies.
</p>
</li>
<li> <p><code>cfb</code> A logical vector indicating which studies report change from baseline data
</p>
</li>
<li> <p><code>treatments</code> A character vector indicating the treatment identifiers that correspond to the
new treatment codes.
</p>
</li>
<li> <p><code>classes</code> A character vector indicating the class identifiers (if included in the original data)
that correspond to the new class codes.
</p>
</li></ul>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>plot(mb.network)</code>: Generate a network plot
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>


# Create an mb.network object from the data
network &lt;- mb.network(osteopain)

# Arrange network plot in a star with the reference treatment in the centre
plot(network, layout=igraph::as_star())

# Generate a network plot at the class level that removes loops indicating comparisons
#within a node
goutnet &lt;- mb.network(goutSUA_CFB)
plot(goutnet, level="class", remove.loops=TRUE)

# Generate a network plot at the treatment level that colours nodes by class
plot(goutnet, v.color="class", remove.loops=TRUE)

# Plot network in which node size is proportional to number of participants
alognet &lt;- mb.network(alog_pcfb)
plot(alognet, v.scale=2)



# Using the osteoarthritis dataset
print(osteopain)

# Define network
network &lt;- mb.network(osteopain, description="Osteoarthritis Dataset")

# Define network with different network reference treatment
network &lt;- mb.network(osteopain, reference="Ce_200")


# Using the alogliptin dataset
network &lt;- mb.network(alog_pcfb, description="Alogliptin Dataset")

# Examine networks
print(network)
plot(network)

</code></pre>

<hr>
<h2 id='plot.mb.predict'>Plots predicted responses from a time-course MBNMA model</h2><span id='topic+plot.mb.predict'></span>

<h3>Description</h3>

<p>Plots predicted responses from a time-course MBNMA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mb.predict'
plot(
  x,
  disp.obs = FALSE,
  overlay.ref = TRUE,
  overlay.nma = NULL,
  method = "random",
  col = "blue",
  max.col.scale = NULL,
  treat.labs = NULL,
  plot.bins = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mb.predict_+3A_x">x</code></td>
<td>
<p>An object of class <code>"mb.predict"</code> generated by
<code>predict("mbnma")</code></p>
</td></tr>
<tr><td><code id="plot.mb.predict_+3A_disp.obs">disp.obs</code></td>
<td>
<p>A boolean object to indicate whether to show shaded sections
of the plot for where there is observed data (<code>TRUE</code>) or not (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot.mb.predict_+3A_overlay.ref">overlay.ref</code></td>
<td>
<p>A boolean object indicating whether to overlay a line
showing the median network reference treatment response over time on the
plot (<code>TRUE</code>) or not (<code>FALSE</code>). The network reference treatment (treatment
</p>

<ol>
<li><p> must be included in <code>predict</code> for this to display the network reference
treatment properly.
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.mb.predict_+3A_overlay.nma">overlay.nma</code></td>
<td>
<p>Numeric vector used to overlay the results from a standard NMA model that
&quot;lumps&quot; time-points together within the time bin ranges specified in <code>overlay.nma</code>.
The numbers in <code>overlay.nma</code> define the boundaries of the time bins within which to perform
a standard NMA. Length must be &gt;=2, or can be left as <code>NULL</code> (the default) to indicate that no NMA
should be perfomed. <code>overlay.nma</code> can only be specified if <code>overlay.ref==TRUE</code>.
See Details for further information.</p>
</td></tr>
<tr><td><code id="plot.mb.predict_+3A_method">method</code></td>
<td>
<p>Can take <code>"common"</code> or <code>"random"</code> to indicate the type of NMA model used to synthesise data points
given in <code>overlay.nma</code>. The default is <code>"random"</code> since this assumes different
time-points in <code>overlay.nma</code> have been lumped together to estimate the NMA.</p>
</td></tr>
<tr><td><code id="plot.mb.predict_+3A_col">col</code></td>
<td>
<p>A character indicating the colour to use for shading if <code>disp.obs</code>
is set to <code>TRUE</code>. Can be either <code>"blue"</code>, <code>"green"</code>, or <code>"red"</code></p>
</td></tr>
<tr><td><code id="plot.mb.predict_+3A_max.col.scale">max.col.scale</code></td>
<td>
<p>Rarely requires adjustment. The maximum count of
observations (therefore the darkest shaded color) only used if <code>disp.obs</code> is
used. This allows consistency of shading between multiple plotted graphs.
It should always be at least as high as the maximum count of observations
plotted</p>
</td></tr>
<tr><td><code id="plot.mb.predict_+3A_treat.labs">treat.labs</code></td>
<td>
<p>A vector of treatment labels in the same order as treatment codes.
Easiest to use treatment labels stored by <code>mb.network()</code></p>
</td></tr>
<tr><td><code id="plot.mb.predict_+3A_plot.bins">plot.bins</code></td>
<td>
<p>Plot time bin boundaries as vertical dashed lines. Setting <code>plot.bins=TRUE</code> if <code>overlay.nma</code>
is specified also sets x-axis ticks to time bin boundaries automatically.</p>
</td></tr>
<tr><td><code id="plot.mb.predict_+3A_...">...</code></td>
<td>
<p>Arguments for <code>ggplot()</code> or <code>R2jags()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the S3 method <code>plot()</code>, if <code>disp.obs</code> is set to <code>TRUE</code> it is
advisable to ensure predictions in <code>predict</code> are estimated using an even
sequence of time points to avoid misrepresentation of shaded densities.
Shaded counts of observations will be relative to the treatment plotted in
each panel rather than to the network reference treatment if <code>disp.obs</code> is
set to <code>TRUE</code>.
</p>


<h3>Overlaying NMA results</h3>

<p><code>overlay.nma</code> indicates regions of the data (defined as &quot;time bins&quot;) over which it may be reasonable to &quot;lump&quot; different
follow-up times from different studies together and assume a standard NMA model. For example:
</p>

<ul>
<li> <p><code>overlay.nma=c(5,10)</code> indicates a single NMA of studies with follow-up times <code style="white-space: pre;">&#8288;&gt;5&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;=10&#8288;</code>
</p>
</li>
<li> <p><code>overlay.nma=c(5,10,15)</code> indicates two NMAs should be performed of studies with follow-up times <code style="white-space: pre;">&#8288;&gt;5&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;=10&#8288;</code>
of studies with follow-up times <code style="white-space: pre;">&#8288;&gt;10&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;=15&#8288;</code>
</p>
</li></ul>

<p>When used with MBNMA (via <code>predict.mbnma()</code>) this allows comparison to MBNMA results over a specific range of time within each time bin.
It can be useful to assess which time-course function might be suitable when using <code>binplot()</code>, or to
to assess if the MBNMA predictions are in agreement with predictions from an NMA model when using <code>plot.mb.predict()</code>
for a specific range of time-points. This can be a general indicator of the fit of the time-course model.
</p>
<p>However, it is important to note that the wider the range specified in <code>overlay.nma</code>, the more likely it is that different time-points
are included, and therefore that there is greater heterogeneity/inconsistency in the NMA model. If <code>overlay.nma</code> includes
several follow-up times for any study then only a single time-point will be taken (the one closest to <code>mean(overlay.nma)</code>).
The NMA predictions are plotted over the range specified in <code>overlay.nma</code> as a horizontal line, with the 95%CrI shown by a grey
rectangle. The NMA predictions represent those for <em>any time-points within this range</em> since they lump together data at
all these time-points. Predictions for treatments that are disconnected from
the network reference treatment at data points specified within <code>overlay.nma</code> cannot be estimated so are not included.
</p>
<p>It is important to note that the NMA model is not necessarily the &quot;correct&quot; model, since it &quot;lumps&quot; different time-points
together and ignores potential differences in treatment effects that may arise from this. The wider the range specified in
<code>overlay.nma</code>, the greater the effect of &quot;lumping&quot; and the stronger the assumption of similarity between studies.
</p>
<p>For an NMA model to be estimated and a corresponding prediction to be made from it, <strong>each</strong> time bin
must include the network reference treatment (treatment=1) evaluated in at least 1 connected study in the time bin.
If a given time bin does not meet this criteria then an NMA will not be calculated for it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an mb.network object from a dataset
copdnet &lt;- mb.network(copd)

# Run an MBNMA model with a log-linear time-course
loglin &lt;- mb.run(copdnet,
  fun=tloglin(pool.rate="rel", method.rate="common"),
  rho="dunif(0,1)", covar="varadj")

# Predict responses using the original dataset to estimate the network reference
#treatment response
df.ref &lt;- copd[copd$treatment=="Placebo",]
predict &lt;- predict(loglin, times=c(0:20), E0=0, ref.resp=df.ref)

# Plot the predicted responses with observations displayed on plot as green shading
plot(predict, disp.obs=TRUE, overlay.ref=FALSE, col="green")

# Plot the predicted responses with the median network reference treatment response overlayed
#on the plot
plot(predict, disp.obs=FALSE, overlay.ref=TRUE)

# Plot predictions from NMAs calculated between different time-points
plot(predict, overlay.nma=c(5,10), n.iter=20000)
plot(predict, overlay.nma=c(5,10,15,20), n.iter=20000)
# Time-course fit may be less well at 15-20 weeks follow-up


</code></pre>

<hr>
<h2 id='plot.mb.rank'>Plot histograms of rankings from MBNMA models</h2><span id='topic+plot.mb.rank'></span>

<h3>Description</h3>

<p>Plot histograms of rankings from MBNMA models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mb.rank'
plot(x, treat.labs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mb.rank_+3A_x">x</code></td>
<td>
<p>An object of class <code>"mb.rank"</code> generated by <code>rank.mbnma()</code></p>
</td></tr>
<tr><td><code id="plot.mb.rank_+3A_treat.labs">treat.labs</code></td>
<td>
<p>A vector of treatment labels in the same order as treatment codes.
Easiest to use treatment labels stored by <code>mb.network()</code></p>
</td></tr>
<tr><td><code id="plot.mb.rank_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to <code>ggplot2::ggplot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A histogram that shows rankings for each treatment/agent/prediction.
The object returned is an object of class <code>c("gg", "ggplot")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an mb.network object from a dataset
painnet &lt;- mb.network(osteopain)

# Run an MBNMA model with an Emax time-course
emax &lt;- mb.run(painnet,
  fun=temax(pool.emax="rel", method.emax="common",
    pool.et50="abs", method.et50="random"),
  positive.scale=TRUE)

# Calculate treatment rankings for AUC and emax
ranks &lt;- rank(emax,
  param=c("auc"),
  int.range=c(0,15), n.iter=500)

# Plot histograms for ranking by AUC
plot(ranks)


</code></pre>

<hr>
<h2 id='plot.mbnma'>Forest plot for results from time-course MBNMA models</h2><span id='topic+plot.mbnma'></span>

<h3>Description</h3>

<p>Generates a forest plot for time-course parameters of interest from results from time-course MBNMA models.
Posterior densities are plotted above each result using <code>ggdist:stat_:halfeye()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbnma'
plot(x, params = NULL, treat.labs = NULL, class.labs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mbnma_+3A_x">x</code></td>
<td>
<p>An S3 object of class <code>"mbnma"</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="plot.mbnma_+3A_params">params</code></td>
<td>
<p>A character vector of time-course parameters to plot.
Parameters must be given the same name as monitored nodes in <code>mbnma</code> and must vary by treatment or class. Can be set to
<code>NULL</code> to include all available time-course parameters estimated by <code>mbnma</code>.</p>
</td></tr>
<tr><td><code id="plot.mbnma_+3A_treat.labs">treat.labs</code></td>
<td>
<p>A character vector of treatment labels. If left as <code>NULL</code> (the default) then
labels will be used as defined in the data.</p>
</td></tr>
<tr><td><code id="plot.mbnma_+3A_class.labs">class.labs</code></td>
<td>
<p>A character vector of class labels if <code>mbnma</code> was modelled using class effects
If left as <code>NULL</code> (the default) then labels will be used as defined in the data.</p>
</td></tr>
<tr><td><code id="plot.mbnma_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to <code>ggdist::stat_halfeye()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A forest plot of class <code>c("gg", "ggplot")</code> that has separate panels for different time-course parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an mb.network object from a dataset
alognet &lt;- mb.network(alog_pcfb)

# Run an MBNMA model with an Emax time-course
emax &lt;- mb.run(alognet,
  fun=temax(pool.emax="rel", method.emax="common",
    pool.et50="rel", method.et50="common"),
  intercept=FALSE)

# Generate forest plot
plot(emax)

# Plot results for only one time-course parameter
plot(emax, params="emax")

</code></pre>

<hr>
<h2 id='plot.nodesplit'>Perform node-splitting on a MBNMA time-course network</h2><span id='topic+plot.nodesplit'></span><span id='topic+mb.nodesplit'></span>

<h3>Description</h3>

<p>Within a MBNMA time-course network, split contributions into direct and indirect evidence and test
for consistency between them. Closed loops of treatments in which it is possible to test for
consistency are those in which direct and indirect evidence are available from independent sources
van Valkenhoef van Valkenhoef et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nodesplit'
plot(x, plot.type = NULL, params = NULL, ...)

mb.nodesplit(
  network,
  comparisons = mb.nodesplit.comparisons(network),
  nodesplit.parameters = "all",
  fun = tpoly(degree = 1),
  times = NULL,
  lim = "cred",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nodesplit_+3A_x">x</code></td>
<td>
<p>An object of <code>class("nodesplit")</code></p>
</td></tr>
<tr><td><code id="plot.nodesplit_+3A_plot.type">plot.type</code></td>
<td>
<p>A character string that can take the value of <code>"forest"</code> to plot
only forest plots, <code>"density"</code> to plot only density plots, or left as <code>NULL</code> (the
default) to plot both types of plot.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_+3A_params">params</code></td>
<td>
<p>A character vector corresponding to a time-course parameter(s) for which to plot results.
If left as <code>NULL</code> (the default), nodes-split results for all time-course parameters will be plotted.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to <code>mb.run()</code></p>
</td></tr>
<tr><td><code id="plot.nodesplit_+3A_network">network</code></td>
<td>
<p>An object of class <code>"mb.network"</code>.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_+3A_comparisons">comparisons</code></td>
<td>
<p>A data frame specifying the comparisons to be split (one row per comparison).
The frame has two columns indicating each treatment for each comparison: <code>t1</code> and <code>t2</code>.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_+3A_nodesplit.parameters">nodesplit.parameters</code></td>
<td>
<p>A character vector of named time-course parameters on which to
node-split (e.g. c(&quot;beta.1&quot;, &quot;beta.2&quot;)). Can use &quot;all&quot; to split on all time-course parameters.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="plot.nodesplit_+3A_times">times</code></td>
<td>
<p>A sequence of positive numbers indicating which time points to
predict mean responses for (or at which to conduct a node-split if used with <code>mb.nodesplit()</code>)</p>
</td></tr>
<tr><td><code id="plot.nodesplit_+3A_lim">lim</code></td>
<td>
<p>Specifies calculation of either 95% credible intervals (<code>lim="cred"</code>) or 95% prediction intervals (<code>lim="pred"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The S3 method <code>plot()</code> on an <code>mb.nodesplit</code> object generates either
forest plots of posterior medians and 95\% credible intervals, or density plots
of posterior densities for direct and indirect evidence.
</p>
<p>Note that by specifying the <code>times</code> argument a user can perform a node-split of treatment
effects at a specific time-point. This will give the treatment effect for both direct, indirect, and
MBNMA estimates at this time point.
</p>


<h3>Value</h3>

<p>Plots the desired graph(s) and returns an object (or list of objects if
<code>plot.type=NULL</code>) of <code>class(c("gg", "ggplot"))</code>, which can be edited using <code>ggplot</code> commands.
</p>
<p>A an object of <code>class("mb.nodesplit")</code> that is a list containing elements
<code>d.X.Y</code> (treatment 1 = <code>X</code>, treatment 2 = <code>Y</code>). Each element (corresponding to each
comparison) contains additional numbered elements corresponding to each parameter in the
time-course function on which node splitting was performed. These elements then contain:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;overlap matrix&#8288;</code> MCMC results for the difference between direct and indirect evidence
</p>
</li>
<li> <p><code>p.values</code> Bayesian p-value for the test of consistency between direct and indirect evidence
</p>
</li>
<li> <p><code>quantiles</code>
</p>
</li>
<li> <p><code>forest.plot</code>
</p>
</li>
<li> <p><code>density.plot</code>
</p>
</li>
<li> <p><code>direct</code> MCMC results for the direct evidence
</p>
</li>
<li> <p><code>indirect</code> MCMC results for the indirect evidence
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(nodesplit)</code>: Plot outputs from nodesplit models
</p>
</li></ul>


<h3>References</h3>

<p>van Valkenhoef G, Dias S, Ades AE, Welton NJ (2016).
&ldquo;Automated generation of node-splitting models for assessment of inconsistency in network meta-analysis.&rdquo;
<em>Res Synth Methods</em>, <b>7</b>(1), 80-93.
ISSN 1759-2887 (Electronic) 1759-2879 (Linking), <a href="https://doi.org/10.1002/jrsm.1167">doi:10.1002/jrsm.1167</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/26461181/">https://pubmed.ncbi.nlm.nih.gov/26461181/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create mb.network object
painnet &lt;- mb.network(osteopain)

# Identify comparisons informed by direct and indirect evidence
splits &lt;- mb.nodesplit.comparisons(painnet)

# Fit a log-linear time-course MBNMA (takes a while to run)
result &lt;- mb.nodesplit(painnet, comparisons=splits, nodesplit.parameters="all",
  fun=tloglin(pool.rate="rel", method.rate="common"),
  rho="dunif(0,1)", covar="varadj"
  )

# Fit an emax time-course MBNMA with a node-split on emax parameters only
result &lt;- mb.nodesplit(painnet, comparisons=splits, nodesplit.parameters="emax",
  fun=temax(pool.emax="rel", method.emax="common",
    pool.et50="rel", method.et50="common"))

# Inspect results
print(result)
summary(result)

# Plot results
plot(result)

</code></pre>

<hr>
<h2 id='predict.mbnma'>Predict effects over time in a given population based on MBNMA time-course
models</h2><span id='topic+predict.mbnma'></span>

<h3>Description</h3>

<p>Used to predict effects over time for different treatments or to predict
the results of a new study. For MBNMA models that include consistency
relative effects on time-course parameters, this is calculated by combining
relative treatment effects with a given reference treatment response
(specific to the population of interest).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbnma'
predict(
  object,
  times = seq(0, max(object$model.arg$jagsdata$time, na.rm = TRUE), length.out = 30),
  E0 = 0,
  treats = NULL,
  level = "treatment",
  ref.resp = NULL,
  synth = "common",
  lim = "cred",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mbnma_+3A_object">object</code></td>
<td>
<p>An S3 object of <code>class("mbnma")</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="predict.mbnma_+3A_times">times</code></td>
<td>
<p>A sequence of positive numbers indicating which time points to
predict mean responses for (or at which to conduct a node-split if used with <code>mb.nodesplit()</code>)</p>
</td></tr>
<tr><td><code id="predict.mbnma_+3A_e0">E0</code></td>
<td>
<p>An object to indicate the value(s) to use for the response at time = 0
in the prediction. This can take a number of different formats depending
on how it will be used/calculated. The default is 0 but this may lead
to non-sensical predictions if Ratio of Means are modeled.
</p>

<ul>
<li> <p><code>numeric()</code> A single numeric value representing the deterministic response at time = 0
</p>
</li>
<li> <p><code>formula()</code> A formula representing a stochastic distribution for the response
at time = 0. This is specified as a random number generator
(RNG) given as a string, and can take any RNG distribution for which a function exists
in R. For example: <code>~rnorm(n, 7, 0.5)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.mbnma_+3A_treats">treats</code></td>
<td>
<p>A character vector of treatment/class names or a numeric vector of treatment/class codes (as coded
in <code>mbnma</code>) that indicates which treatments/classes to calculate predictions for. If left as <code>NULL</code> then
predictions will be calculated for all treatments/classes. Whether the vector should correspond to treatments or
classes depends on the value of <code>level</code>.</p>
</td></tr>
<tr><td><code id="predict.mbnma_+3A_level">level</code></td>
<td>
<p>Can take either <code>"treatment"</code> to make predictions for treatments, or <code>"class"</code> to make predictions for classes (in
which case <code>object</code> must be a class effect model).</p>
</td></tr>
<tr><td><code id="predict.mbnma_+3A_ref.resp">ref.resp</code></td>
<td>
<p>An object to indicate the value(s) to use for the reference treatment response in MBNMA models
in which the reference treatment response is not estimated within the model (i.e. those that model any time-
course parameters using <code>pool="rel"</code>). This can take a number of different formats depending
on how it will be used/calculated. There are two approaches for this:
</p>

<ol>
<li><p> The reference response can be estimated from a dataset of studies investigating the reference
treatment using meta-analysis. This dataset could be a set of observational
studies that are specific to the population on which to make
predictions, or it could be a subset of the study arms within the MBNMA dataset
that investigate the reference treatment. The data should be provided to <code>ref.resp</code> as a
<code>data.frame()</code> containing the data in long format (one row per observation). See <code><a href="#topic+ref.synth">ref.synth()</a></code>
</p>
</li>
<li><p> Values for the reference treatment response can be assigned to different time-course parameters
within the model that have been modelled using consistency relative effects (<code>pool="rel"</code>).
These are given as a list, in which each named element corresponds to a time-course
parameter modelled in <code>mbnma</code>, specified on the corresponding scale (i.e. specified on the log scale if modelled
on the log scale using Ratios of Means). Their values can be either of the following:
</p>
</li></ol>


<ul>
<li> <p><code>numeric()</code> A numeric value representing the deterministic value of the time-course parameter in
question in individuals given the reference treatment. <code>0</code> is used as the default, which assumes no
effect of time on the reference treatment (i.e. mean differences / relative effects versus the
reference treatment are modeled).
</p>
</li>
<li> <p><code>formula()</code> A formula representing a stochastic distribution for the value of the time-course
parameter in question. This is specified as a random number generator (RNG) given as a formula,
and can take any RNG distribution for which a function exists in R. For example: <code>~rnorm(n, -3, 0.2)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.mbnma_+3A_synth">synth</code></td>
<td>
<p>A character object that can take the value <code>"common"</code> or <code>"random"</code> that
specifies the the type of pooling to use for synthesis of <code>ref.resp</code>. Using <code>"random"</code> rather
than <code>"common"</code> for <code>synth</code> will result in wider 95\% CrI for predictions.</p>
</td></tr>
<tr><td><code id="predict.mbnma_+3A_lim">lim</code></td>
<td>
<p>Specifies calculation of either 95% credible intervals (<code>lim="cred"</code>) or 95% prediction intervals (<code>lim="pred"</code>).</p>
</td></tr>
<tr><td><code id="predict.mbnma_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to R2jags for synthesis of the network
reference treatment effect (using <code><a href="#topic+ref.synth">ref.synth()</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the network reference treatment baseline (<code>E0</code>) and time-course
parameter values are set to zero so that <code>predict()</code> estimates mean differences
(/relative treatment effects) over time versus the network reference treatment.
</p>
<p><code>ref.resp</code> only needs to be specified if <code>mbnma</code> has
been estimated using consistency relative effects (<code>pool="rel"</code>) for
any time-course parameters, as these inform the absolute values of the
network reference treatment parameters which can then be added to the
relative effects to calculate specific predictions.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>mb.predict</code> that contains the following
elements:
</p>

<ul>
<li> <p><code>summary</code> A named list of data frames. Each data frame contains
a summary of predicted responses at follow-up times specified in <code>times</code>
for each treatment specified in <code>treats</code>
</p>
</li>
<li> <p><code>pred.mat</code> A named list of
matrices. Each matrix contains the MCMC results of predicted responses at
follow-up times specified in <code>times</code> for each treatment specified in
<code>treats</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Create an mb.network object from a dataset
network &lt;- mb.network(osteopain)

# Run an MBNMA model with an Emax time-course
emax &lt;- mb.run(network,
  fun=temax(pool.emax="rel", method.emax="common",
    pool.et50="abs", method.et50="common"))

# Predict responses using a stochastic baseline (E0) and a distribution for the
#network reference treatment
preds &lt;- predict(emax, times=c(0:10),
  E0=~rnorm(n, 7, 0.5),
  ref.resp=list(emax=~rnorm(n, -0.5, 0.05)))
summary(preds)

# Predict responses using the original dataset to estimate the network reference
#treatment response
paindata.ref &lt;- osteopain[osteopain$treatname=="Placebo_0",]
preds &lt;- predict(emax, times=c(5:15),
  E0=10,
  ref.resp=paindata.ref)
summary(preds)

# Repeat the above prediction but using a random effects meta-analysis of the
#network reference treatment response
preds &lt;- predict(emax, times=c(5:15),
  E0=10,
  ref.resp=paindata.ref,
  synth="random")
summary(preds)


</code></pre>

<hr>
<h2 id='print.mb.network'>Print mb.network information to the console</h2><span id='topic+print.mb.network'></span>

<h3>Description</h3>

<p>Print mb.network information to the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mb.network'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mb.network_+3A_x">x</code></td>
<td>
<p>An object of class <code>mb.network</code>.</p>
</td></tr>
<tr><td><code id="print.mb.network_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the contents of <code>x</code> to the console.
</p>

<hr>
<h2 id='print.mb.predict'>Print summary information from an mb.predict object</h2><span id='topic+print.mb.predict'></span>

<h3>Description</h3>

<p>Print summary information from an mb.predict object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mb.predict'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mb.predict_+3A_x">x</code></td>
<td>
<p>An object of <code>class("mb.predict")</code> generated by <code>predict.mbnma()</code></p>
</td></tr>
<tr><td><code id="print.mb.predict_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.mb.rank'>Prints a summary of rankings for each parameter</h2><span id='topic+print.mb.rank'></span>

<h3>Description</h3>

<p>Prints a summary of rankings for each parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mb.rank'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mb.rank_+3A_x">x</code></td>
<td>
<p>An object of class <code>"mb.rank"</code> generated by <code>rank.mbnma()</code></p>
</td></tr>
<tr><td><code id="print.mb.rank_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary details of treatment rankings to the console
</p>

<hr>
<h2 id='print.nodesplit'>Prints basic results from a node-split to the console</h2><span id='topic+print.nodesplit'></span>

<h3>Description</h3>

<p>Prints basic results from a node-split to the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nodesplit'
print(x, groupby = "time.param", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nodesplit_+3A_x">x</code></td>
<td>
<p>An object of class <code>"nodesplit"</code> generated by <code>mb.nodeplit()</code></p>
</td></tr>
<tr><td><code id="print.nodesplit_+3A_groupby">groupby</code></td>
<td>
<p>A character object that can take the value <code>"time.param"</code> to present
results grouped by time-course parameter (the default) or <code>"comparison"</code> to present
results grouped by treatment comparison.</p>
</td></tr>
<tr><td><code id="print.nodesplit_+3A_...">...</code></td>
<td>
<p>arguments to be sent to <code>knitr::kable()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary details of nodesplit results to the console
</p>

<hr>
<h2 id='print.relative.array'>Print posterior medians (95% credible intervals) for table of relative effects/mean
differences between treatments/classes</h2><span id='topic+print.relative.array'></span>

<h3>Description</h3>

<p>Print posterior medians (95% credible intervals) for table of relative effects/mean
differences between treatments/classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relative.array'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.relative.array_+3A_x">x</code></td>
<td>
<p>An object of class <code>"relative.array"</code> generated by <code>get.relative()</code></p>
</td></tr>
<tr><td><code id="print.relative.array_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of significant digits to be used.</p>
</td></tr>
<tr><td><code id="print.relative.array_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>knitr::kable</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a league table of treatment effects to the console
</p>

<hr>
<h2 id='radian.rescale'>Calculate position of label with respect to vertex location within a circle</h2><span id='topic+radian.rescale'></span>

<h3>Description</h3>

<p>Useful for graphs drawn using <code>igraph</code> to reposition labels relative to vertices when vertices
are laid out in a circle (as is common in network plots). <code>igraph</code> interprets position within
<code>vertex.label.degree</code> as radians, so it is necessary to convert locations into radian values. This
is the main role of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radian.rescale(x, start = 0, direction = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radian.rescale_+3A_x">x</code></td>
<td>
<p>A numeric vector of positions around a circle, typically sequentially numbered.</p>
</td></tr>
<tr><td><code id="radian.rescale_+3A_start">start</code></td>
<td>
<p>A number giving the offset from 12 o'clock in radians for the label locations.</p>
</td></tr>
<tr><td><code id="radian.rescale_+3A_direction">direction</code></td>
<td>
<p>Either <code>1</code> for clockwise numbering (based on the order of <code>x</code>) or <code>-1</code> for
anti-clockwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of rescaled values
</p>


<h3>References</h3>

<p>https://gist.github.com/kjhealy/834774/a4e677401fd6e4c319135dabeaf9894393f9392c
</p>

<hr>
<h2 id='rank'>Set rank as a method</h2><span id='topic+rank'></span>

<h3>Description</h3>

<p>Set rank as a method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_+3A_x">x</code></td>
<td>
<p>An object on which to apply the rank method</p>
</td></tr>
<tr><td><code id="rank_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Uses the rank method
</p>

<hr>
<h2 id='rank.mb.predict'>Rank predictions at a specific time point</h2><span id='topic+rank.mb.predict'></span>

<h3>Description</h3>

<p>Rank predictions at a specific time point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mb.predict'
rank(
  x,
  time = max(x$summary[[1]]$time),
  lower_better = FALSE,
  treats = names(x$summary),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank.mb.predict_+3A_x">x</code></td>
<td>
<p>an object of <code>class("mb.predict")</code> that contains predictions from an MBNMA model</p>
</td></tr>
<tr><td><code id="rank.mb.predict_+3A_time">time</code></td>
<td>
<p>a number indicating the time point at which predictions should be ranked. It must
be one of the time points for which predictions in <code>x</code> are available.</p>
</td></tr>
<tr><td><code id="rank.mb.predict_+3A_lower_better">lower_better</code></td>
<td>
<p>Indicates whether negative responses are better (<code>lower_better=TRUE</code>) or
positive responses are better (<code>lower_better=FALSE</code>)</p>
</td></tr>
<tr><td><code id="rank.mb.predict_+3A_treats">treats</code></td>
<td>
<p>A character vector of treatment/class names for which responses have been predicted
in <code>x</code> As default, rankings will be calculated for all treatments/classes in <code>x</code>.</p>
</td></tr>
<tr><td><code id="rank.mb.predict_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code>class("mb.rank")</code> containing ranked predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an mb.network object from a dataset
network &lt;- mb.network(osteopain)

# Run an MBNMA model with an Emax time-course
emax &lt;- mb.run(network,
  fun=temax(pool.emax="rel", method.emax="common",
    pool.et50="abs", method.et50="common"))

# Predict responses using a stochastic baseline (E0) and a distribution for the
#network reference treatment
preds &lt;- predict(emax, E0=7,
  ref.resp=list(emax=~rnorm(n, -0.5, 0.05)))

# Rank predictions at latest predicted time-point
rank(preds, lower_better=TRUE)


#### Rank predictions at 5 weeks follow-up ####

# First ensure responses are predicted at 5 weeks
preds &lt;- predict(emax, E0=7,
  ref.resp=list(emax=~rnorm(n, -0.5, 0.05)),
  times=c(0,5,10))

# Rank predictions at 5 weeks follow-up
ranks &lt;- rank(preds, lower_better=TRUE, time=5)

# Plot ranks
plot(ranks)


</code></pre>

<hr>
<h2 id='rank.mbnma'>Rank parameters from a time-course MBNMA</h2><span id='topic+rank.mbnma'></span>

<h3>Description</h3>

<p>Ranks desired parameters saved from a time-course MBNMA model from &quot;best&quot; to
&quot;worst&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbnma'
rank(
  x,
  param = "auc",
  lower_better = FALSE,
  treats = NULL,
  int.range = NULL,
  n.iter = x$BUGSoutput$n.sims,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank.mbnma_+3A_x">x</code></td>
<td>
<p>An S3 object of <code>class("mbnma")</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="rank.mbnma_+3A_param">param</code></td>
<td>
<p>A character object containing any model parameter monitored
in <code>mbnma</code> for which ranking is desired (e.g. <code>"beta.1"</code>, <code>"emax"</code>).
Parameters must vary by treatment for ranking to be possible. Can also be specified as
<code>"auc"</code> (see details).</p>
</td></tr>
<tr><td><code id="rank.mbnma_+3A_lower_better">lower_better</code></td>
<td>
<p>Indicates whether negative responses are better (<code>lower_better=TRUE</code>) or
positive responses are better (<code>lower_better=FALSE</code>)</p>
</td></tr>
<tr><td><code id="rank.mbnma_+3A_treats">treats</code></td>
<td>
<p>A character vector of treatment/class names (depending on the parameter to be ranked) or
a numeric vector of treatment/class codes (as coded in <code>mbnma</code>)
that indicate which treatments/classes to calculate rankings for. If left 'NULL&ldquo;
then rankings will be calculated for all treatments/classes.</p>
</td></tr>
<tr><td><code id="rank.mbnma_+3A_int.range">int.range</code></td>
<td>
<p>A numeric vector with two elements that indicates the range
over which to calculate AUC. Takes the form c(lower bound, upper bound). If left
as <code>NULL</code> (the default) then the range will be between zero and the maximum follow-up
time in the dataset.</p>
</td></tr>
<tr><td><code id="rank.mbnma_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of iterations for which to calculate AUC (if <code>"auc"</code> is included in <code>params</code>).
Must be a positive integer. Default is the value used in <code>mbnma</code>.</p>
</td></tr>
<tr><td><code id="rank.mbnma_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to <code>integrate()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"auc"</code> can be specified in <code>param</code> to rank treatments based on
Area Under the Curve (AUC). This accounts for the effect of multiple
time-course parameters simultaneously on the treatment response, but will
be impacted by the range of time over which AUC is calculated (<code>int.range</code>).
This requires integration over <code>int.range</code> and can take some time to run (particularly)
for spline functions as this uses the trapezoid method rather than adaptive quadrature).
Note that <code>"auc"</code> can only be calculated at the treatment-level in class effect models.
</p>
<p>As with other post-estimation functions, <code>rank()</code> should only be performed on
models which have successfully converged. Note that rankings can be very sensitive to
even small changes in treatment effects and therefore failure to converge in only
one parameter may have substantial impact on rankings.
</p>


<h3>Value</h3>

<p>A named list whose elements include:
</p>

<ul>
<li> <p><code>summary.rank</code> A data frame containing
mean, sd, and quantiles for the ranks of each treatment given in <code>treats</code>
</p>
</li>
<li> <p><code>prob.matrix</code> A matrix of the proportions of MCMC results for which each
treatment/class in <code>treats</code> ranked in which position for the given parameter
</p>
</li>
<li> <p><code>rank.matrix</code> A matrix of the ranks of MCMC results for each treatment/class in
<code>treats</code> for the given parameter.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Create an mb.network object from a dataset
network &lt;- mb.network(alog_pcfb)

# Run an MBNMA model with an Emax time-course
emax &lt;- mb.run(network,
  fun=temax(pool.emax="rel", method.emax="common",
            pool.et50="rel", method.et50="random"),
  intercept=FALSE)

# Rank treatments by time-course parameter from the model with lower scores being better
rank(emax, param=c("emax"), lower_better=TRUE)

# Rank treatments 1-3 by AUC
rank(emax, param="auc", treats=c(1:3), lower_better=TRUE,
  int.range=c(0,20))


</code></pre>

<hr>
<h2 id='rankauc'>Calculates ranking probabilities for AUC from a time-course MBNMA</h2><span id='topic+rankauc'></span>

<h3>Description</h3>

<p>Calculates ranking probabilities for AUC from a time-course MBNMA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankauc(
  mbnma,
  lower_better = FALSE,
  treats = NULL,
  level = "treatments",
  int.range = c(0, max(mbnma$network$data.ab$time)),
  n.iter = mbnma$BUGSoutput$n.sims,
  subdivisions = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankauc_+3A_mbnma">mbnma</code></td>
<td>
<p>An S3 object of class <code>"mbnma"</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="rankauc_+3A_lower_better">lower_better</code></td>
<td>
<p>Indicates whether negative responses are better (<code>lower_better=TRUE</code>) or
positive responses are better (<code>lower_better=FALSE</code>)</p>
</td></tr>
<tr><td><code id="rankauc_+3A_treats">treats</code></td>
<td>
<p>A character vector of treatment/class names (depending on the value of <code>level</code>). If left <code style="white-space: pre;">&#8288;NULL`` then rankings will be calculated for all treatments/classes. Note that unlike &#8288;</code>rank.mbnma()' this argument
cannot take a numeric vector.</p>
</td></tr>
<tr><td><code id="rankauc_+3A_level">level</code></td>
<td>
<p>Can take either <code>"treatment"</code> to make predictions for treatments, or <code>"class"</code> to make predictions for classes (in
which case <code>object</code> must be a class effect model).</p>
</td></tr>
<tr><td><code id="rankauc_+3A_int.range">int.range</code></td>
<td>
<p>A numeric vector with two elements that indicates the range
over which to calculate AUC. Takes the form c(lower bound, upper bound). If left
as <code>NULL</code> (the default) then the range will be between zero and the maximum follow-up
time in the dataset.</p>
</td></tr>
<tr><td><code id="rankauc_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of iterations for which to calculate AUC (if <code>"auc"</code> is included in <code>params</code>).
Must be a positive integer. Default is the value used in <code>mbnma</code>.</p>
</td></tr>
<tr><td><code id="rankauc_+3A_subdivisions">subdivisions</code></td>
<td>
<p>The number of subdivisions over which to integrate (see <code><a href="stats.html#topic+integrate">integrate</a></code>)</p>
</td></tr>
<tr><td><code id="rankauc_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to R2jags for synthesis of the network
reference treatment effect (using <code><a href="#topic+ref.synth">ref.synth()</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"auc"</code> can be specified in <code>param</code> to rank treatments based on
Area Under the Curve (AUC). This accounts for the effect of multiple
time-course parameters simultaneously on the treatment response, but will
be impacted by the range of time over which AUC is calculated (<code>int.range</code>).
This requires integration over <code>int.range</code> and can take some time to run (particularly)
for spline functions as this uses the trapezoid method rather than adaptive quadrature).
Note that <code>"auc"</code> can only be calculated at the treatment-level in class effect models.
</p>
<p>As with other post-estimation functions, <code>rank()</code> should only be performed on
models which have successfully converged. Note that rankings can be very sensitive to
even small changes in treatment effects and therefore failure to converge in only
one parameter may have substantial impact on rankings.
</p>


<h3>Value</h3>

<p>A named list whose elements include:
</p>

<ul>
<li> <p><code>summary.rank</code> A data frame containing
mean, sd, and quantiles for the ranks of each treatment given in <code>treats</code>
</p>
</li>
<li> <p><code>prob.matrix</code> A matrix of the proportions of MCMC results for which each
treatment/class in <code>treats</code> ranked in which position for the given parameter
</p>
</li>
<li> <p><code>rank.matrix</code> A matrix of the ranks of MCMC results for each treatment/class in
<code>treats</code> for the given parameter.
</p>
</li></ul>


<hr>
<h2 id='ref.comparisons'>Identify unique comparisons relative to study reference treatment within a
network</h2><span id='topic+ref.comparisons'></span>

<h3>Description</h3>

<p>Identify unique contrasts relative to each study reference within a network.
Repetitions of the same treatment comparison are grouped together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref.comparisons(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref.comparisons_+3A_data">data</code></td>
<td>
<p>A data frame containing variables <code>studyID</code> and <code>treatment</code> (as
numeric codes) that indicate which treatments are used in which studies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of unique comparisons in which each row represents a
different comparison. <code>t1</code> and <code>t2</code> indicate the treatment codes that make
up the comparison. <code>nr</code> indicates the number of times the given comparison
is made within the network.
</p>
<p>If there is only a single observation for each study within the dataset
(i.e. as for standard network meta-analysis) <code>nr</code> will represent the number
of studies that compare treatments <code>t1</code> and <code>t2</code>.
</p>
<p>If there are multiple observations for each study within the dataset (as in
MBNMAtime) <code>nr</code> will represent the number of time points in the
dataset in which treatments <code>t1</code> and <code>t2</code> are compared.
</p>

<hr>
<h2 id='ref.synth'>Synthesise single arm studies with repeated observations of the same
treatment over time</h2><span id='topic+ref.synth'></span>

<h3>Description</h3>

<p>Synthesises single arm studies with repeated measures by applying a
particular time-course function. Used in predicting mean responses from a
time-course MBNMA. The same parameterisation of the time course must be used
as in the MBNMA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref.synth(
  data.ab,
  mbnma,
  synth = "random",
  link = mbnma$model.arg$link,
  n.iter = mbnma$BUGSoutput$n.iter,
  n.burnin = mbnma$BUGSoutput$n.burnin,
  n.thin = mbnma$BUGSoutput$n.thin,
  n.chains = mbnma$BUGSoutput$n.chains,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref.synth_+3A_data.ab">data.ab</code></td>
<td>
<p>A data frame of arm-level data in &quot;long&quot; format containing the
columns:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean response for a given observation
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li></ul>
</td></tr>
<tr><td><code id="ref.synth_+3A_mbnma">mbnma</code></td>
<td>
<p>An S3 object of class <code>"mbnma"</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="ref.synth_+3A_synth">synth</code></td>
<td>
<p>A character object that can take the value <code>"common"</code> or <code>"random"</code> that
specifies the the type of pooling to use for synthesis of <code>ref.resp</code>. Using <code>"random"</code> rather
than <code>"common"</code> for <code>synth</code> will result in wider 95\% CrI for predictions.</p>
</td></tr>
<tr><td><code id="ref.synth_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="ref.synth_+3A_n.iter">n.iter</code></td>
<td>
<p>number of total iterations per chain (including burn in;
default: 2000)</p>
</td></tr>
<tr><td><code id="ref.synth_+3A_n.burnin">n.burnin</code></td>
<td>
<p>length of burn in, i.e. number of iterations to
discard at the beginning. Default is <code>n.iter/2</code>, that is,
discarding the first half of the simulations. If n.burnin is 0,
<code>jags()</code> will run 100 iterations for adaption.</p>
</td></tr>
<tr><td><code id="ref.synth_+3A_n.thin">n.thin</code></td>
<td>
<p>thinning rate. Must be a positive integer.  Set
<code>n.thin</code> &gt; 1 to save memory and computation time if
<code>n.iter</code> is large.  Default is <code>max(1, floor(n.chains *
    (n.iter-n.burnin) / 1000))</code> which will only thin if there are at
least 2000 simulations.</p>
</td></tr>
<tr><td><code id="ref.synth_+3A_n.chains">n.chains</code></td>
<td>
<p>number of Markov chains (default: 3)</p>
</td></tr>
<tr><td><code id="ref.synth_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to R2jags for synthesis of the network
reference treatment effect (using <code><a href="#topic+ref.synth">ref.synth()</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data.ab</code> can be a collection of studies that closely resemble the
population of interest intended for the prediction, which could be
different to those used to estimate the MBNMA model, and could be include
single arms of RCTs or observational studies. If other data is not
available, the data used to estimate the MBNMA model can be used by
selecting only the studies and arms that specify the network reference
treatment responses.
</p>


<h3>Value</h3>

<p>A list of named elements corresponding to each time-course parameter
within an MBNMA model that contain the median posterior value for the
network reference treatment response.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an mb.network object from a dataset
network &lt;- mb.network(osteopain)

# Run an MBNMA model with an Emax time-course
emax &lt;- mb.run(network,
  fun=temax(pool.emax="rel", method.emax="common",
    pool.et50="abs", method.et50="random"))

# Generate a set of studies with which to estimate the network reference treatment response
paindata.ref &lt;- osteopain[osteopain$treatname=="Placebo_0",]

# Estimate the network reference treatment effect using common effects meta-analysis
ref.synth(data.ab=paindata.ref, mbnma=emax, synth="common")

# Estimate the network reference treatment effect using random effects meta-analysis
ref.synth(data.ab=paindata.ref, mbnma=emax, synth="random")


</code></pre>

<hr>
<h2 id='ref.validate'>Checks the validity of ref.resp if given as data frame</h2><span id='topic+ref.validate'></span>

<h3>Description</h3>

<p>Ensures <code>ref.resp</code> takes the correct form to allow for synthesis of network
reference treatment effect if data is provided for meta-analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref.validate(data.ab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref.validate_+3A_data.ab">data.ab</code></td>
<td>
<p>A data frame of arm-level data in &quot;long&quot; format containing the
columns:
</p>

<ul>
<li> <p><code>studyID</code> Study identifiers
</p>
</li>
<li> <p><code>time</code> Numeric data indicating follow-up times
</p>
</li>
<li> <p><code>y</code> Numeric data indicating the mean response for a given observation
</p>
</li>
<li> <p><code>se</code> Numeric data indicating the standard error for a given observation
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>data.ab</code>, the data frame used to estimate the network reference treatment
time-course function, with additional required indices added.
</p>

<hr>
<h2 id='remove.loops'>Removes any loops from MBNMA model JAGS code that do not contain any
expressions</h2><span id='topic+remove.loops'></span>

<h3>Description</h3>

<p>Removes any loops from MBNMA model JAGS code that do not contain any
expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.loops(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.loops_+3A_model">model</code></td>
<td>
<p>A character object of JAGS MBNMA model code</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of JAGS MBNMA model code that has had empty loops
removed from it
</p>

<hr>
<h2 id='replace.prior'>Replace original priors in an MBNMA model with new priors</h2><span id='topic+replace.prior'></span>

<h3>Description</h3>

<p>Identical to <code>replace.prior()</code> in MBNMAdose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace.prior(priors, model = NULL, mbnma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace.prior_+3A_priors">priors</code></td>
<td>
<p>A named list of parameter values (without indices) and
replacement prior distribution values given as strings
<strong>using distributions as specified in JAGS syntax</strong> (see Plummer (2017)).</p>
</td></tr>
<tr><td><code id="replace.prior_+3A_model">model</code></td>
<td>
<p>A character object of JAGS MBNMA model code</p>
</td></tr>
<tr><td><code id="replace.prior_+3A_mbnma">mbnma</code></td>
<td>
<p>An S3 object of class <code>c("mbnma", "rjags")</code> generated by running a
time-course MBNMA model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes new priors, as specified by the user, and adds them to
the JAGS code from an MBNMA model. New priors replace old priors in the JAGS
model.
</p>
<p>Values in <code>priors</code> can include any JAGS functions/distributions
(e.g. censoring/truncation).
</p>


<h3>Value</h3>

<p>A character object of JAGS MBNMA model code that includes the new
priors in place of original priors
</p>

<hr>
<h2 id='summary.mb.network'>Print summary mb.network information to the console</h2><span id='topic+summary.mb.network'></span>

<h3>Description</h3>

<p>Print summary mb.network information to the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mb.network'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mb.network_+3A_object">object</code></td>
<td>
<p>An object of class <code>mb.network</code>.</p>
</td></tr>
<tr><td><code id="summary.mb.network_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary details of <code>x</code> to the console.
</p>

<hr>
<h2 id='summary.mb.predict'>Prints summary of mb.predict object</h2><span id='topic+summary.mb.predict'></span>

<h3>Description</h3>

<p>Prints a summary table of the mean of MCMC iterations at each time point
for each treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mb.predict'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mb.predict_+3A_object">object</code></td>
<td>
<p>An object of class <code>"mb.predict"</code></p>
</td></tr>
<tr><td><code id="summary.mb.predict_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing times at which responses have been predicted (<code>time</code>)
and an additional column for each treatment for which responses have been predicted.
Each row represents mean MCMC predicted responses for each treatment at a particular
time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define network
network &lt;- mb.network(obesityBW_CFB, reference="plac")

# Run an MBNMA with a quadratic time-course function
quad &lt;- mb.run(network,
  fun=tpoly(degree=2, pool.1="rel", method.1="common",
    pool.2="rel", method.2="common"),
  intercept=TRUE)

# Predict responses
pred &lt;- predict(quad, times=c(0:50), treats=c(1:5),
  ref.resp = network$data.ab[network$data.ab$treatment==1,],
  E0=10)

# Generate summary of predictions
summary(pred)

</code></pre>

<hr>
<h2 id='summary.mbnma'>Print summary MBNMA results to the console</h2><span id='topic+summary.mbnma'></span>

<h3>Description</h3>

<p>Print summary MBNMA results to the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbnma'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mbnma_+3A_object">object</code></td>
<td>
<p>An S3 object of <code>class("mbnma")</code> generated by running
a time-course MBNMA model</p>
</td></tr>
<tr><td><code id="summary.mbnma_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>knitr::kable</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary details of the model results to the console
</p>

<hr>
<h2 id='summary.nodesplit'>Takes node-split results and produces summary data frame</h2><span id='topic+summary.nodesplit'></span>

<h3>Description</h3>

<p>Takes node-split results and produces summary data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nodesplit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nodesplit_+3A_object">object</code></td>
<td>
<p>An object of class <code>"nodesplit"</code> generated by <code>mb.nodeplit()</code></p>
</td></tr>
<tr><td><code id="summary.nodesplit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of summary node-split results with the following variables:
</p>

<ul>
<li> <p><code>Comparison</code> The treatment comparison on which a node-split has been performed
</p>
</li>
<li> <p><code>Time.Param</code> The time-course parameter on which a node-split has been performed
</p>
</li>
<li> <p><code>Evidence</code> The evidence contribution for the given comparison (either &quot;Direct&quot; or &quot;Indirect&quot;)
</p>
</li>
<li> <p><code>Median</code> The posterior median
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;2.5%&#8288;</code> The lower 95% credible interval limit
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;97.5%&#8288;</code> The upper 95% credible interval limit
</p>
</li>
<li> <p><code>p.value</code> The Bayesian p-value for the overlap between direct and indirect evidence for
the given comparison (it will therefore have an identical value for direct and indirect evidence
within a particular comparison and time-course parameter)
</p>
</li></ul>


<hr>
<h2 id='temax'>Emax time-course function</h2><span id='topic+temax'></span>

<h3>Description</h3>

<p>** For version 0.2.3: to ensure positive posterior values, et50 and hill parameters are now
modeled on the natural scale using a half-normal prior rather than a symmetrical prior
on the exponential scale to improve model stability **
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temax(
  pool.emax = "rel",
  method.emax = "common",
  pool.et50 = "rel",
  method.et50 = "common",
  pool.hill = NULL,
  method.hill = NULL,
  p.expon = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temax_+3A_pool.emax">pool.emax</code></td>
<td>
<p>Pooling for Emax parameter. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="temax_+3A_method.emax">method.emax</code></td>
<td>
<p>Method for synthesis of Emax parameter. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="temax_+3A_pool.et50">pool.et50</code></td>
<td>
<p>Pooling for ET50 parameter. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="temax_+3A_method.et50">method.et50</code></td>
<td>
<p>Method for synthesis of ET50 parameter. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="temax_+3A_pool.hill">pool.hill</code></td>
<td>
<p>Pooling for Hill parameter. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="temax_+3A_method.hill">method.hill</code></td>
<td>
<p>Method for synthesis of Hill parameter. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="temax_+3A_p.expon">p.expon</code></td>
<td>
<p>Should parameters that can only take positive values be modeled on the exponential scale (<code>TRUE</code>)
or should they be assigned a prior that restricts the posterior to positive values (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Emax represents the maximum response.
</p>
</li>
<li><p> ET50 represents the time at which 50% of the maximum response is achieved. This can only take
positive values and so is modeled on the exponential scale and assigned a symmetrical normal prior
Alternatively it can be assigned a normal prior truncated at zero (half-normal) (this
will be the default in MBNMAtime version &gt;=0.2.3).
</p>
</li>
<li><p> Hill is the Hill parameter, which allows for a sigmoidal function. This can only take
positive values and so is modeled on the exponential scale and assigned a symmetrical normal prior
Alternatively it can be assigned a normal prior truncated at zero (half-normal) (this
will be the default in MBNMAtime version &gt;=0.2.3).
</p>
</li></ul>

<p>Without Hill parameter:
</p>
<p style="text-align: center;"><code class="reqn">\frac{E_{max}\times{x}}{ET_{50}+x}</code>
</p>

<p>With Hill parameter:
</p>
<p style="text-align: center;"><code class="reqn">\frac{E_{max}\times{x^{hill}}}{ET_{50}\times{hill}+x^{hill}}</code>
</p>



<h3>Value</h3>

<p>An object of <code>class("timefun")</code>
</p>


<h3>Time-course parameters</h3>

<p>Time-course parameters in the model must be specified using a <code>pool</code> and a <code>method</code> prefix.
</p>
<p><code>pool</code> is used to define the approach used for pooling of a given time-course parameter and
can take any of:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"rel"</code> </td><td style="text-align: left;"> Indicates that <em>relative</em> effects should be pooled for this time-course parameter. Relative effects preserve randomisation within included studies, are likely to vary less between studies (only due to effect modification), and allow for testing of consistency between direct and indirect evidence. Pooling follows the general approach for Network Meta-Analysis proposed by Lu and Ades (2004). </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"abs"</code> </td><td style="text-align: left;"> Indicates that study arms should be pooled across the whole network for this time-course parameter  <em>independently of assigned treatment</em> to estimate an <em>absolute</em> effect. This implies estimating a single value across the network for this time-course parameter, and may therefore be making strong assumptions of similarity. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>method</code> is used to define the model used for meta-analysis for a given time-course parameter
and can take any of the following values:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"common"</code> </td><td style="text-align: left;"> Implies that all studies estimate the same true effect (often called a "fixed effect" meta-analysis) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"random"</code> </td><td style="text-align: left;"> Implies that all studies estimate a separate true effect, but that each of these true effects vary randomly around a true mean effect. This approach allows for modelling of between-study heterogeneity. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>numeric()</code> </td><td style="text-align: left;"> Assigned a numeric value, indicating that this time-course parameter should not be estimated from the data but should be assigned the numeric value determined by the user. This can be useful for fixing specific time-course parameters (e.g. Hill parameters in Emax functions, power parameters in fractional polynomials) to a single value. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When relative effects are modelled on more than one time-course parameter,
correlation between them is automatically estimated using a vague inverse-Wishart prior.
This prior can be made slightly more informative by specifying the scale matrix <code>omega</code>
and by changing the degrees of freedom of the inverse-Wishart prior
using the <code>priors</code> argument in <code>mb.run()</code>.
</p>


<h3>References</h3>

<p>Lu G, Ades AE (2004).
&ldquo;Combination of direct and indirect evidence in mixed treatment comparisons.&rdquo;
<em>Stat Med</em>, <b>23</b>(20), 3105-24.
ISSN 0277-6715 (Print) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.1875">doi:10.1002/sim.1875</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/15449338/">https://pubmed.ncbi.nlm.nih.gov/15449338/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Model without a Hill parameter
temax(pool.emax="rel", method.emax="random", pool.et50="abs", method.et50="common")

# Model including a Hill parameter and defaults for Emax and ET50 parameters
temax(pool.hill="abs", method.hill="common")

</code></pre>

<hr>
<h2 id='tfpoly'>Fractional polynomial time-course function</h2><span id='topic+tfpoly'></span>

<h3>Description</h3>

<p>As first described for use in Network Meta-Analysis by Jansen et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfpoly(
  degree = 1,
  pool.1 = "rel",
  method.1 = "common",
  pool.2 = "rel",
  method.2 = "common",
  method.power1 = 0,
  method.power2 = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfpoly_+3A_degree">degree</code></td>
<td>
<p>The degree of the fractional polynomial as defined in  Royston and Altman (1994)</p>
</td></tr>
<tr><td><code id="tfpoly_+3A_pool.1">pool.1</code></td>
<td>
<p>Pooling for the 1st fractional polynomial coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tfpoly_+3A_method.1">method.1</code></td>
<td>
<p>Method for synthesis of the 1st fractional polynomial coefficient. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tfpoly_+3A_pool.2">pool.2</code></td>
<td>
<p>Pooling for the 2nd fractional polynomial coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tfpoly_+3A_method.2">method.2</code></td>
<td>
<p>Method for synthesis of the 2nd fractional polynomial coefficient. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tfpoly_+3A_method.power1">method.power1</code></td>
<td>
<p>Value for the 1st fractional polynomial power. Must take any numeric value in the set <code style="white-space: pre;">&#8288;-2, -1, -0.5, 0, 0.5, 1, 2, 3&#8288;</code>.
<code>pool</code> for this parameter is set to <code>"abs"</code>.</p>
</td></tr>
<tr><td><code id="tfpoly_+3A_method.power2">method.power2</code></td>
<td>
<p>Value for the 2nd fractional polynomial power. Must take any numeric value in the set <code style="white-space: pre;">&#8288;-2, -1, -0.5, 0, 0.5, 1, 2, 3&#8288;</code>.
<code>pool</code> for this parameter is set to <code>"abs"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code class="reqn">\beta_1</code> represents the 1st coefficient.
</p>
</li>
<li> <p><code class="reqn">\beta_2</code> represents the 2nd coefficient.
</p>
</li>
<li> <p><code class="reqn">p_1</code> represents the 1st power
</p>
</li>
<li> <p><code class="reqn">p_2</code> represents the 2nd power
</p>
</li></ul>

<p>For a polynomial of <code>degree=1</code>:
</p>
<p style="text-align: center;"><code class="reqn">{\beta_1}x^{p_1}</code>
</p>

<p>For a polynomial of <code>degree=2</code>:
</p>
<p style="text-align: center;"><code class="reqn">{\beta_1}x^{p_1}+{\beta_2}x^{p_2}</code>
</p>

<p><code class="reqn">x^{(p)}</code> is a regular power except where <code class="reqn">p=0</code>, where <code class="reqn">x^{(0)}=ln(x)</code>.
If a fractional polynomial power <code class="reqn">p_m</code> repeats within the function it is multiplied by another <code class="reqn">ln(x)</code>.
</p>


<h3>Value</h3>

<p>An object of <code>class("timefun")</code>
</p>


<h3>Time-course parameters</h3>

<p>Time-course parameters in the model must be specified using a <code>pool</code> and a <code>method</code> prefix.
</p>
<p><code>pool</code> is used to define the approach used for pooling of a given time-course parameter and
can take any of:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"rel"</code> </td><td style="text-align: left;"> Indicates that <em>relative</em> effects should be pooled for this time-course parameter. Relative effects preserve randomisation within included studies, are likely to vary less between studies (only due to effect modification), and allow for testing of consistency between direct and indirect evidence. Pooling follows the general approach for Network Meta-Analysis proposed by Lu and Ades (2004). </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"abs"</code> </td><td style="text-align: left;"> Indicates that study arms should be pooled across the whole network for this time-course parameter  <em>independently of assigned treatment</em> to estimate an <em>absolute</em> effect. This implies estimating a single value across the network for this time-course parameter, and may therefore be making strong assumptions of similarity. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>method</code> is used to define the model used for meta-analysis for a given time-course parameter
and can take any of the following values:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"common"</code> </td><td style="text-align: left;"> Implies that all studies estimate the same true effect (often called a "fixed effect" meta-analysis) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"random"</code> </td><td style="text-align: left;"> Implies that all studies estimate a separate true effect, but that each of these true effects vary randomly around a true mean effect. This approach allows for modelling of between-study heterogeneity. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>numeric()</code> </td><td style="text-align: left;"> Assigned a numeric value, indicating that this time-course parameter should not be estimated from the data but should be assigned the numeric value determined by the user. This can be useful for fixing specific time-course parameters (e.g. Hill parameters in Emax functions, power parameters in fractional polynomials) to a single value. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When relative effects are modelled on more than one time-course parameter,
correlation between them is automatically estimated using a vague inverse-Wishart prior.
This prior can be made slightly more informative by specifying the scale matrix <code>omega</code>
and by changing the degrees of freedom of the inverse-Wishart prior
using the <code>priors</code> argument in <code>mb.run()</code>.
</p>


<h3>References</h3>

<p>Jansen JP, Vieira MC, Cope S (2015).
&ldquo;Network meta-analysis of longitudinal data using fractional polynomials.&rdquo;
<em>Stat Med</em>, <b>34</b>(15), 2294-311.
ISSN 1097-0258 (Electronic) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.6492">doi:10.1002/sim.6492</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/25877808/">https://pubmed.ncbi.nlm.nih.gov/25877808/</a>.<br /><br /> Lu G, Ades AE (2004).
&ldquo;Combination of direct and indirect evidence in mixed treatment comparisons.&rdquo;
<em>Stat Med</em>, <b>23</b>(20), 3105-24.
ISSN 0277-6715 (Print) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.1875">doi:10.1002/sim.1875</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/15449338/">https://pubmed.ncbi.nlm.nih.gov/15449338/</a>.<br /><br /> Royston P, Altman D (1994).
&ldquo;Regression Using Fractional Polynomials of Continuous Covariates: Parsimonious Parametric Modelling.&rdquo;
<em>Journal of the Royal Statistical Society: Series C</em>, <b>43</b>(3), 429-467.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1st order fractional polynomial with random effects
tfpoly(pool.1="rel", method.1="random")

# 2nd order fractional polynomial
# with a single absolute parameter estimated for the 2nd coefficient
# 1st power equal to zero
tfpoly(degree=2, pool.1="rel", method.1="common",
  pool.2="abs", method.2="random",
  method.power1=0)

</code></pre>

<hr>
<h2 id='timeplot'>Plot raw responses over time by treatment or class</h2><span id='topic+timeplot'></span>

<h3>Description</h3>

<p>Plot raw responses over time by treatment or class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeplot(network, level = "treatment", plotby = "arm", link = "identity", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeplot_+3A_network">network</code></td>
<td>
<p>An object of class <code>"mb.network"</code>.</p>
</td></tr>
<tr><td><code id="timeplot_+3A_level">level</code></td>
<td>
<p>A string indicating whether nodes/facets should represent <code>treatment</code>
or <code>class</code> in the plot. Can be used to examine the expected impact of modelling
class/agent effects.</p>
</td></tr>
<tr><td><code id="timeplot_+3A_plotby">plotby</code></td>
<td>
<p>A character object that can take either <code>"arm"</code> to indicate that raw responses
should be plotted separately for each study arm, or <code>"rel"</code> to indicate that the within-study
relative effects/treatment differences should be plotted. In this way the time-course of both the absolute
effects and the relative effects can be examined.</p>
</td></tr>
<tr><td><code id="timeplot_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="timeplot_+3A_...">...</code></td>
<td>
<p>Arguments to be sent to <code>ggplot()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots can be faceted by either treatment (<code>level="treatment"</code>) or class
(<code>level="class"</code>) to investigate similarity of treatment responses within classes/agents.
Points represent observed responses and lines connect between observations within the
same study and arm.
</p>


<h3>Value</h3>

<p>The function returns an object of <code style="white-space: pre;">&#8288;class(c("gg", "ggplot")&#8288;</code>. Characteristics
of the object can therefore be amended as with other plots generated by <code>ggplot()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make network
goutnet &lt;- mb.network(goutSUA_CFB)

# Use timeplot to plot responses grouped by treatment
timeplot(goutnet)

# Use timeplot ot plot resposes grouped by class
timeplot(goutnet, level="class")

# Plot matrix of relative effects
timeplot(goutnet, level="class", plotby="rel")

# Plot using Standardised Mean Differences
copdnet &lt;- mb.network(copd)
timeplot(copdnet, plotby="rel", link="smd")



</code></pre>

<hr>
<h2 id='titp'>Integrated Two-Component Prediction (ITP) function</h2><span id='topic+titp'></span>

<h3>Description</h3>

<p>Similar parameterisation to the Emax model but with non-asymptotic maximal effect (Emax). Proposed
by proposed by Fu and Manner (2010)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>titp(
  pool.emax = "rel",
  method.emax = "common",
  pool.rate = "rel",
  method.rate = "common",
  p.expon = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="titp_+3A_pool.emax">pool.emax</code></td>
<td>
<p>Pooling for exponential Emax parameter. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="titp_+3A_method.emax">method.emax</code></td>
<td>
<p>Method for synthesis of exponential Emax parameter. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="titp_+3A_pool.rate">pool.rate</code></td>
<td>
<p>Pooling for parameter controlling rate of onset. Default is <code>NULL</code> which avoids including
this parameter (i.e. fixes it to 1 for all treatments). Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="titp_+3A_method.rate">method.rate</code></td>
<td>
<p>Method for synthesis of parameter controlling rate of onset. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="titp_+3A_p.expon">p.expon</code></td>
<td>
<p>Should parameters that can only take positive values be modeled on the exponential scale (<code>TRUE</code>)
or should they be assigned a prior that restricts the posterior to positive values (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">{E_{max}}\times\frac{(1-exp(-{rate}\times{x}))}{(1-exp(-{rate}\times{max(x)}))}</code>
</p>



<h3>Value</h3>

<p>An object of <code>class("timefun")</code>
</p>


<h3>Time-course parameters</h3>

<p>Time-course parameters in the model must be specified using a <code>pool</code> and a <code>method</code> prefix.
</p>
<p><code>pool</code> is used to define the approach used for pooling of a given time-course parameter and
can take any of:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"rel"</code> </td><td style="text-align: left;"> Indicates that <em>relative</em> effects should be pooled for this time-course parameter. Relative effects preserve randomisation within included studies, are likely to vary less between studies (only due to effect modification), and allow for testing of consistency between direct and indirect evidence. Pooling follows the general approach for Network Meta-Analysis proposed by Lu and Ades (2004). </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"abs"</code> </td><td style="text-align: left;"> Indicates that study arms should be pooled across the whole network for this time-course parameter  <em>independently of assigned treatment</em> to estimate an <em>absolute</em> effect. This implies estimating a single value across the network for this time-course parameter, and may therefore be making strong assumptions of similarity. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>method</code> is used to define the model used for meta-analysis for a given time-course parameter
and can take any of the following values:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"common"</code> </td><td style="text-align: left;"> Implies that all studies estimate the same true effect (often called a "fixed effect" meta-analysis) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"random"</code> </td><td style="text-align: left;"> Implies that all studies estimate a separate true effect, but that each of these true effects vary randomly around a true mean effect. This approach allows for modelling of between-study heterogeneity. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>numeric()</code> </td><td style="text-align: left;"> Assigned a numeric value, indicating that this time-course parameter should not be estimated from the data but should be assigned the numeric value determined by the user. This can be useful for fixing specific time-course parameters (e.g. Hill parameters in Emax functions, power parameters in fractional polynomials) to a single value. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Fu H, Manner D (2010).
&ldquo;Bayesian adaptive dose-finding studies with delayed responses.&rdquo;
<em>J Biopharm Stat</em>, <b>20</b>(5), 1055-1070.
<a href="https://doi.org/10.1080/10543400903315740">doi:10.1080/10543400903315740</a>.<br /><br /> Lu G, Ades AE (2004).
&ldquo;Combination of direct and indirect evidence in mixed treatment comparisons.&rdquo;
<em>Stat Med</em>, <b>23</b>(20), 3105-24.
ISSN 0277-6715 (Print) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.1875">doi:10.1002/sim.1875</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/15449338/">https://pubmed.ncbi.nlm.nih.gov/15449338/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>titp(pool.emax="rel", method.emax="random")
titp(pool.emax="abs")

</code></pre>

<hr>
<h2 id='tloglin'>Log-linear (exponential) time-course function</h2><span id='topic+tloglin'></span>

<h3>Description</h3>

<p><code class="reqn">rate\times{log(x + 1)}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tloglin(pool.rate = "rel", method.rate = "common")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tloglin_+3A_pool.rate">pool.rate</code></td>
<td>
<p>Pooling for rate parameter. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tloglin_+3A_method.rate">method.rate</code></td>
<td>
<p>Method for synthesis of rate parameter. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code>class("timefun")</code>
</p>


<h3>Time-course parameters</h3>

<p>Time-course parameters in the model must be specified using a <code>pool</code> and a <code>method</code> prefix.
</p>
<p><code>pool</code> is used to define the approach used for pooling of a given time-course parameter and
can take any of:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"rel"</code> </td><td style="text-align: left;"> Indicates that <em>relative</em> effects should be pooled for this time-course parameter. Relative effects preserve randomisation within included studies, are likely to vary less between studies (only due to effect modification), and allow for testing of consistency between direct and indirect evidence. Pooling follows the general approach for Network Meta-Analysis proposed by Lu and Ades (2004). </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"abs"</code> </td><td style="text-align: left;"> Indicates that study arms should be pooled across the whole network for this time-course parameter  <em>independently of assigned treatment</em> to estimate an <em>absolute</em> effect. This implies estimating a single value across the network for this time-course parameter, and may therefore be making strong assumptions of similarity. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>method</code> is used to define the model used for meta-analysis for a given time-course parameter
and can take any of the following values:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"common"</code> </td><td style="text-align: left;"> Implies that all studies estimate the same true effect (often called a "fixed effect" meta-analysis) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"random"</code> </td><td style="text-align: left;"> Implies that all studies estimate a separate true effect, but that each of these true effects vary randomly around a true mean effect. This approach allows for modelling of between-study heterogeneity. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>numeric()</code> </td><td style="text-align: left;"> Assigned a numeric value, indicating that this time-course parameter should not be estimated from the data but should be assigned the numeric value determined by the user. This can be useful for fixing specific time-course parameters (e.g. Hill parameters in Emax functions, power parameters in fractional polynomials) to a single value. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Lu G, Ades AE (2004).
&ldquo;Combination of direct and indirect evidence in mixed treatment comparisons.&rdquo;
<em>Stat Med</em>, <b>23</b>(20), 3105-24.
ISSN 0277-6715 (Print) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.1875">doi:10.1002/sim.1875</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/15449338/">https://pubmed.ncbi.nlm.nih.gov/15449338/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tloglin(pool.rate="rel", method.rate="random")
tloglin(pool.rate="abs")

</code></pre>

<hr>
<h2 id='tpoly'>Polynomial time-course function</h2><span id='topic+tpoly'></span>

<h3>Description</h3>

<p>Polynomial time-course function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpoly(
  degree = 1,
  pool.1 = "rel",
  method.1 = "common",
  pool.2 = "rel",
  method.2 = "common",
  pool.3 = "rel",
  method.3 = "common",
  pool.4 = "rel",
  method.4 = "common"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpoly_+3A_degree">degree</code></td>
<td>
<p>The degree of the polynomial - e.g. <code>degree=1</code> for linear, <code>degree=2</code> for quadratic, <code>degree=3</code> for cubic.</p>
</td></tr>
<tr><td><code id="tpoly_+3A_pool.1">pool.1</code></td>
<td>
<p>Pooling for the 1st polynomial coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tpoly_+3A_method.1">method.1</code></td>
<td>
<p>Method for synthesis of the 1st polynomial coefficient.Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tpoly_+3A_pool.2">pool.2</code></td>
<td>
<p>Pooling for the 2nd polynomial coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tpoly_+3A_method.2">method.2</code></td>
<td>
<p>Method for synthesis of the 2nd polynomial coefficient. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tpoly_+3A_pool.3">pool.3</code></td>
<td>
<p>Pooling for the 3rd polynomial coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tpoly_+3A_method.3">method.3</code></td>
<td>
<p>Method for synthesis of the 3rd polynomial coefficient. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tpoly_+3A_pool.4">pool.4</code></td>
<td>
<p>Pooling for the 4th polynomial coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tpoly_+3A_method.4">method.4</code></td>
<td>
<p>Method for synthesis of the 4th polynomial coefficient. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code class="reqn">\beta_1</code> represents the 1st coefficient.
</p>
</li>
<li> <p><code class="reqn">\beta_2</code> represents the 2nd coefficient.
</p>
</li>
<li> <p><code class="reqn">\beta_3</code> represents the 3rd coefficient.
</p>
</li>
<li> <p><code class="reqn">\beta_4</code> represents the 4th coefficient.
</p>
</li></ul>

<p>Linear model:
</p>
<p style="text-align: center;"><code class="reqn">\beta_1{x}</code>
</p>

<p>Quadratic model:
</p>
<p style="text-align: center;"><code class="reqn">\beta_1{x} + \beta_2{x^2}</code>
</p>

<p>Cubic model:
</p>
<p style="text-align: center;"><code class="reqn">\beta_1{x} + \beta_2{x^2} + \beta_3{x^3}</code>
</p>

<p>Quartic model:
</p>
<p style="text-align: center;"><code class="reqn">\beta_1{x} + \beta_2{x^2} + \beta_3{x^3} + \beta_4{x^4}</code>
</p>



<h3>Value</h3>

<p>An object of <code>class("timefun")</code>
</p>


<h3>Time-course parameters</h3>

<p>Time-course parameters in the model must be specified using a <code>pool</code> and a <code>method</code> prefix.
</p>
<p><code>pool</code> is used to define the approach used for pooling of a given time-course parameter and
can take any of:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"rel"</code> </td><td style="text-align: left;"> Indicates that <em>relative</em> effects should be pooled for this time-course parameter. Relative effects preserve randomisation within included studies, are likely to vary less between studies (only due to effect modification), and allow for testing of consistency between direct and indirect evidence. Pooling follows the general approach for Network Meta-Analysis proposed by Lu and Ades (2004). </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"abs"</code> </td><td style="text-align: left;"> Indicates that study arms should be pooled across the whole network for this time-course parameter  <em>independently of assigned treatment</em> to estimate an <em>absolute</em> effect. This implies estimating a single value across the network for this time-course parameter, and may therefore be making strong assumptions of similarity. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>method</code> is used to define the model used for meta-analysis for a given time-course parameter
and can take any of the following values:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"common"</code> </td><td style="text-align: left;"> Implies that all studies estimate the same true effect (often called a "fixed effect" meta-analysis) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"random"</code> </td><td style="text-align: left;"> Implies that all studies estimate a separate true effect, but that each of these true effects vary randomly around a true mean effect. This approach allows for modelling of between-study heterogeneity. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>numeric()</code> </td><td style="text-align: left;"> Assigned a numeric value, indicating that this time-course parameter should not be estimated from the data but should be assigned the numeric value determined by the user. This can be useful for fixing specific time-course parameters (e.g. Hill parameters in Emax functions, power parameters in fractional polynomials) to a single value. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When relative effects are modelled on more than one time-course parameter,
correlation between them is automatically estimated using a vague inverse-Wishart prior.
This prior can be made slightly more informative by specifying the scale matrix <code>omega</code>
and by changing the degrees of freedom of the inverse-Wishart prior
using the <code>priors</code> argument in <code>mb.run()</code>.
</p>


<h3>References</h3>

<p>Lu G, Ades AE (2004).
&ldquo;Combination of direct and indirect evidence in mixed treatment comparisons.&rdquo;
<em>Stat Med</em>, <b>23</b>(20), 3105-24.
ISSN 0277-6715 (Print) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.1875">doi:10.1002/sim.1875</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/15449338/">https://pubmed.ncbi.nlm.nih.gov/15449338/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Linear model with random effects
tpoly(pool.1="rel", method.1="random")

# Quadratic model with a single absolute parameter estimated for the 2nd coefficient
tpoly(pool.1="rel", method.1="common", pool.2="abs", method.2="random")

</code></pre>

<hr>
<h2 id='tspline'>Spline time-course functions</h2><span id='topic+tspline'></span>

<h3>Description</h3>

<p>Used to fit B-splines, natural cubic splines, and
piecewise linear splines(Perperoglu et al. 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tspline(
  type = "bs",
  knots = 1,
  degree = 1,
  pool.1 = "rel",
  method.1 = "common",
  pool.2 = "rel",
  method.2 = "common",
  pool.3 = "rel",
  method.3 = "common",
  pool.4 = "rel",
  method.4 = "common"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tspline_+3A_type">type</code></td>
<td>
<p>The type of spline. Can take <code>"bs"</code> (<a href="https://mathworld.wolfram.com/B-Spline.html">B-spline</a>),
<code>"ns"</code> (<a href="https://mathworld.wolfram.com/CubicSpline.html">natural cubic spline</a>) or <code>"ls"</code> (piecewise linear spline)</p>
</td></tr>
<tr><td><code id="tspline_+3A_knots">knots</code></td>
<td>
<p>The number/location of spline internal knots. If a single number is given it indicates the number of knots (they will
be equally spaced across the range of time points). If a numeric vector is given it indicates the location of the knots.</p>
</td></tr>
<tr><td><code id="tspline_+3A_degree">degree</code></td>
<td>
<p>The degree of the piecewise B-spline polynomial - e.g. <code>degree=1</code> for linear, <code>degree=2</code> for quadratic, <code>degree=3</code> for cubic.</p>
</td></tr>
<tr><td><code id="tspline_+3A_pool.1">pool.1</code></td>
<td>
<p>Pooling for the 1st coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tspline_+3A_method.1">method.1</code></td>
<td>
<p>Method for synthesis of the 1st coefficient. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tspline_+3A_pool.2">pool.2</code></td>
<td>
<p>Pooling for the 2nd coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tspline_+3A_method.2">method.2</code></td>
<td>
<p>Method for synthesis of the 2nd coefficient. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tspline_+3A_pool.3">pool.3</code></td>
<td>
<p>Pooling for the 3rd coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tspline_+3A_method.3">method.3</code></td>
<td>
<p>Method for synthesis of the 3rd coefficient. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tspline_+3A_pool.4">pool.4</code></td>
<td>
<p>Pooling for the 4th coefficient. Can take <code>"rel"</code> or <code>"abs"</code> (see details).</p>
</td></tr>
<tr><td><code id="tspline_+3A_method.4">method.4</code></td>
<td>
<p>Method for synthesis of the 4th coefficient. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code>class("timefun")</code>
</p>


<h3>Time-course parameters</h3>

<p>Time-course parameters in the model must be specified using a <code>pool</code> and a <code>method</code> prefix.
</p>
<p><code>pool</code> is used to define the approach used for pooling of a given time-course parameter and
can take any of:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"rel"</code> </td><td style="text-align: left;"> Indicates that <em>relative</em> effects should be pooled for this time-course parameter. Relative effects preserve randomisation within included studies, are likely to vary less between studies (only due to effect modification), and allow for testing of consistency between direct and indirect evidence. Pooling follows the general approach for Network Meta-Analysis proposed by Lu and Ades (2004). </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"abs"</code> </td><td style="text-align: left;"> Indicates that study arms should be pooled across the whole network for this time-course parameter  <em>independently of assigned treatment</em> to estimate an <em>absolute</em> effect. This implies estimating a single value across the network for this time-course parameter, and may therefore be making strong assumptions of similarity. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>method</code> is used to define the model used for meta-analysis for a given time-course parameter
and can take any of the following values:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"common"</code> </td><td style="text-align: left;"> Implies that all studies estimate the same true effect (often called a "fixed effect" meta-analysis) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"random"</code> </td><td style="text-align: left;"> Implies that all studies estimate a separate true effect, but that each of these true effects vary randomly around a true mean effect. This approach allows for modelling of between-study heterogeneity. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>numeric()</code> </td><td style="text-align: left;"> Assigned a numeric value, indicating that this time-course parameter should not be estimated from the data but should be assigned the numeric value determined by the user. This can be useful for fixing specific time-course parameters (e.g. Hill parameters in Emax functions, power parameters in fractional polynomials) to a single value. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When relative effects are modelled on more than one time-course parameter,
correlation between them is automatically estimated using a vague inverse-Wishart prior.
This prior can be made slightly more informative by specifying the scale matrix <code>omega</code>
and by changing the degrees of freedom of the inverse-Wishart prior
using the <code>priors</code> argument in <code>mb.run()</code>.
</p>


<h3>References</h3>

<p>Lu G, Ades AE (2004).
&ldquo;Combination of direct and indirect evidence in mixed treatment comparisons.&rdquo;
<em>Stat Med</em>, <b>23</b>(20), 3105-24.
ISSN 0277-6715 (Print) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.1875">doi:10.1002/sim.1875</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/15449338/">https://pubmed.ncbi.nlm.nih.gov/15449338/</a>.<br /><br /> Perperoglu A, Sauerbrei W, Abrahamowicz M, Schmid M (2019).
&ldquo;A review of spline function procedures in R.&rdquo;
<em>BMC Medical Research Methodology</em>, <b>19</b>(46), 1-16.
<a href="https://doi.org/10.1186/s12874-019-0666-3">doi:10.1186/s12874-019-0666-3</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Second order B spline with 2 knots and random effects on the 2nd coefficient
tspline(type="bs", knots=2, degree=2,
  pool.1="rel", method.1="common",
  pool.2="rel", method.2="random")

# Piecewise linear spline with knots at 0.1 and 0.5 quantiles
# Single parameter independent of treatment estimated for 1st coefficient
#with random effects
tspline(type="ls", knots=c(0.1,0.5),
  pool.1="abs", method.1="random",
  pool.2="rel", method.2="common")

</code></pre>

<hr>
<h2 id='tuser'>User-defined time-course function</h2><span id='topic+tuser'></span>

<h3>Description</h3>

<p>User-defined time-course function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuser(
  fun,
  pool.1 = "rel",
  method.1 = "common",
  pool.2 = "rel",
  method.2 = "common",
  pool.3 = "rel",
  method.3 = "common",
  pool.4 = "rel",
  method.4 = "common"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tuser_+3A_fun">fun</code></td>
<td>
<p>A formula specifying any relationship including <code>time</code> and
one/several of: <code>beta.1</code>, <code>beta.2</code>, <code>beta.3</code>, <code>beta.4</code>.</p>
</td></tr>
<tr><td><code id="tuser_+3A_pool.1">pool.1</code></td>
<td>
<p>Pooling for <code>beta.1</code>. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tuser_+3A_method.1">method.1</code></td>
<td>
<p>Method for synthesis of <code>beta.1</code>. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code> or <code>"random"</code> (see details).</p>
</td></tr>
<tr><td><code id="tuser_+3A_pool.2">pool.2</code></td>
<td>
<p>Pooling for <code>beta.2</code>. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tuser_+3A_method.2">method.2</code></td>
<td>
<p>Method for synthesis of <code style="white-space: pre;">&#8288;beta.2. Can take &#8288;</code>&quot;common<code>or</code>&quot;random&quot;' (see details).</p>
</td></tr>
<tr><td><code id="tuser_+3A_pool.3">pool.3</code></td>
<td>
<p>Pooling for <code>beta.3</code>. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tuser_+3A_method.3">method.3</code></td>
<td>
<p>Method for synthesis of <code style="white-space: pre;">&#8288;beta.3. Can take &#8288;</code>&quot;common<code>or</code>&quot;random&quot;' (see details).</p>
</td></tr>
<tr><td><code id="tuser_+3A_pool.4">pool.4</code></td>
<td>
<p>Pooling for <code>beta.4</code>. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
<tr><td><code id="tuser_+3A_method.4">method.4</code></td>
<td>
<p>Method for synthesis of <code>beta.4</code>. Can take <code style="white-space: pre;">&#8288;"common&#8288;</code>, <code>"random"</code>, or be assigned a numeric value (see details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code>class("timefun")</code>
</p>


<h3>Time-course parameters</h3>

<p>Time-course parameters in the model must be specified using a <code>pool</code> and a <code>method</code> prefix.
</p>
<p><code>pool</code> is used to define the approach used for pooling of a given time-course parameter and
can take any of:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"rel"</code> </td><td style="text-align: left;"> Indicates that <em>relative</em> effects should be pooled for this time-course parameter. Relative effects preserve randomisation within included studies, are likely to vary less between studies (only due to effect modification), and allow for testing of consistency between direct and indirect evidence. Pooling follows the general approach for Network Meta-Analysis proposed by Lu and Ades (2004). </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"abs"</code> </td><td style="text-align: left;"> Indicates that study arms should be pooled across the whole network for this time-course parameter  <em>independently of assigned treatment</em> to estimate an <em>absolute</em> effect. This implies estimating a single value across the network for this time-course parameter, and may therefore be making strong assumptions of similarity. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>method</code> is used to define the model used for meta-analysis for a given time-course parameter
and can take any of the following values:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Argument</strong> </td><td style="text-align: left;"> <strong>Model specification</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"common"</code> </td><td style="text-align: left;"> Implies that all studies estimate the same true effect (often called a "fixed effect" meta-analysis) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"random"</code> </td><td style="text-align: left;"> Implies that all studies estimate a separate true effect, but that each of these true effects vary randomly around a true mean effect. This approach allows for modelling of between-study heterogeneity. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>numeric()</code> </td><td style="text-align: left;"> Assigned a numeric value, indicating that this time-course parameter should not be estimated from the data but should be assigned the numeric value determined by the user. This can be useful for fixing specific time-course parameters (e.g. Hill parameters in Emax functions, power parameters in fractional polynomials) to a single value. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When relative effects are modelled on more than one time-course parameter,
correlation between them is automatically estimated using a vague inverse-Wishart prior.
This prior can be made slightly more informative by specifying the scale matrix <code>omega</code>
and by changing the degrees of freedom of the inverse-Wishart prior
using the <code>priors</code> argument in <code>mb.run()</code>.
</p>


<h3>References</h3>

<p>Lu G, Ades AE (2004).
&ldquo;Combination of direct and indirect evidence in mixed treatment comparisons.&rdquo;
<em>Stat Med</em>, <b>23</b>(20), 3105-24.
ISSN 0277-6715 (Print) 0277-6715 (Linking), <a href="https://doi.org/10.1002/sim.1875">doi:10.1002/sim.1875</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/15449338/">https://pubmed.ncbi.nlm.nih.gov/15449338/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
timecourse &lt;- ~ beta.1 * (1/(time+1)) + beta.2 * time^2
tuser(fun=timecourse,
  pool.1="abs", method.1="common",
  pool.2="rel", method.2="common")

</code></pre>

<hr>
<h2 id='write.beta'>Adds sections of JAGS code for an MBNMA model that correspond to beta
parameters</h2><span id='topic+write.beta'></span>

<h3>Description</h3>

<p>Adds sections of JAGS code for an MBNMA model that correspond to beta
parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.beta(model, timecourse, fun, UME, class.effect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.beta_+3A_model">model</code></td>
<td>
<p>A character object of JAGS MBNMA model code</p>
</td></tr>
<tr><td><code id="write.beta_+3A_timecourse">timecourse</code></td>
<td>
<p>A character object representing the time-course used in the MBNMA model</p>
</td></tr>
<tr><td><code id="write.beta_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="write.beta_+3A_ume">UME</code></td>
<td>
<p>Can take either <code>TRUE</code> or <code>FALSE</code> (for an unrelated mean effects
model on all or no time-course parameters respectively) or can be a vector
of parameter name strings to model as UME. For example: <code>c("beta.1", "beta.2")</code>.</p>
</td></tr>
<tr><td><code id="write.beta_+3A_class.effect">class.effect</code></td>
<td>
<p>A list of named strings that determines which time-course
parameters to model with a class effect and what that effect should be
(<code>"common"</code> or <code>"random"</code>). For example: <code>list(emax="common", et50="random")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of JAGS MBNMA model code that includes beta
parameter components of the model
</p>

<hr>
<h2 id='write.check'>Checks validity of arguments for mb.write</h2><span id='topic+write.check'></span>

<h3>Description</h3>

<p>Checks validity of arguments for mb.write
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.check(
  fun = tpoly(degree = 1),
  positive.scale = TRUE,
  intercept = NULL,
  rho = 0,
  covar = NULL,
  omega = NULL,
  link = "identity",
  sdscale = FALSE,
  class.effect = list(),
  UME = c()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.check_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="write.check_+3A_positive.scale">positive.scale</code></td>
<td>
<p>A boolean object that indicates whether all continuous
mean responses (y) are positive and therefore whether the baseline response
should be given a prior that constrains it to be positive (e.g. for scales that cannot be &lt;0).</p>
</td></tr>
<tr><td><code id="write.check_+3A_intercept">intercept</code></td>
<td>
<p>A boolean object that indicates whether an intercept (written
as <code>alpha</code> in the model) is to be included. If left as <code>NULL</code> (the default), an intercept will
be included only for studies reporting absolute means, and will be excluded for
studies reporting change from baseline (as indicated in <code>network$cfb</code>).</p>
</td></tr>
<tr><td><code id="write.check_+3A_rho">rho</code></td>
<td>
<p>The correlation coefficient when modelling within-study correlation between time points. The default is a string representing a
prior distribution in JAGS, indicating that it be estimated from the data (e.g. <code>rho="dunif(0,1)"</code>). <code>rho</code> also be assigned a
numeric value (e.g. <code>rho=0.7</code>), which fixes <code>rho</code> in the model to this value (e.g. for use in a deterministic sensitivity analysis).
If set to <code>rho=0</code> (the default) then this implies modelling no correlation between time points.</p>
</td></tr>
<tr><td><code id="write.check_+3A_covar">covar</code></td>
<td>
<p>A character specifying the covariance structure to use for modelling within-study correlation between time-points. This can
be done by specifying one of the following:
</p>

<ul>
<li> <p><code>"varadj"</code> - a univariate likelihood with a variance adjustment to assume a constant correlation between subsequent
time points (Jansen et al. 2015). This is the default.
</p>
</li>
<li> <p><code>"CS"</code> - a multivariate normal likelihood with a
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">compound symmetry</a> structure
</p>
</li>
<li> <p><code>"AR1"</code> - a multivariate normal likelihood with an
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">autoregressive AR1</a> structure
</p>
</li></ul>
</td></tr>
<tr><td><code id="write.check_+3A_omega">omega</code></td>
<td>
<p>DEPRECATED IN VERSION 0.2.3 ONWARDS (~uniform(-1,1) now used for correlation between parameters
rather than a Wishart prior).
A scale matrix for the inverse-Wishart prior for the covariance matrix used
to model the correlation between time-course parameters (see Details for time-course functions). <code>omega</code> must
be a symmetric positive definite matrix with dimensions equal to the number of time-course parameters modelled using
relative effects (<code>pool="rel"</code>). If left as <code>NULL</code> (the default) a diagonal matrix with elements equal to 1
is used.</p>
</td></tr>
<tr><td><code id="write.check_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="write.check_+3A_sdscale">sdscale</code></td>
<td>
<p>Logical object to indicate whether to write a model that specifies a reference SD
for standardising when modelling using Standardised Mean Differences. Specifying <code>sdscale=TRUE</code>
will therefore only modify the model if link function is set to SMD (<code>link="smd"</code>).</p>
</td></tr>
<tr><td><code id="write.check_+3A_class.effect">class.effect</code></td>
<td>
<p>A list of named strings that determines which time-course
parameters to model with a class effect and what that effect should be
(<code>"common"</code> or <code>"random"</code>). For example: <code>list(emax="common", et50="random")</code>.</p>
</td></tr>
<tr><td><code id="write.check_+3A_ume">UME</code></td>
<td>
<p>Can take either <code>TRUE</code> or <code>FALSE</code> (for an unrelated mean effects
model on all or no time-course parameters respectively) or can be a vector
of parameter name strings to model as UME. For example: <code>c("beta.1", "beta.2")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to check if the arguments given to mb.write are valid. The
function will return informative errors if arguments are mispecified and
will return an object that indicates whether the arguments imply modelling a
correlation between time points if it passes.
</p>


<h3>Value</h3>

<p>A boolean object that indicates whether the arguments imply modelling
correlation between time points.
</p>

<hr>
<h2 id='write.cor'>Adds correlation between time-course relative effects</h2><span id='topic+write.cor'></span>

<h3>Description</h3>

<p>This uses a Wishart prior as default for modelling the correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.cor(model, fun, omega = NULL, class.effect = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.cor_+3A_model">model</code></td>
<td>
<p>A character object of JAGS MBNMA model code</p>
</td></tr>
<tr><td><code id="write.cor_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="write.cor_+3A_omega">omega</code></td>
<td>
<p>DEPRECATED IN VERSION 0.2.3 ONWARDS (~uniform(-1,1) now used for correlation between parameters
rather than a Wishart prior).
A scale matrix for the inverse-Wishart prior for the covariance matrix used
to model the correlation between time-course parameters (see Details for time-course functions). <code>omega</code> must
be a symmetric positive definite matrix with dimensions equal to the number of time-course parameters modelled using
relative effects (<code>pool="rel"</code>). If left as <code>NULL</code> (the default) a diagonal matrix with elements equal to 1
is used.</p>
</td></tr>
<tr><td><code id="write.cor_+3A_class.effect">class.effect</code></td>
<td>
<p>A list of named strings that determines which time-course
parameters to model with a class effect and what that effect should be
(<code>"common"</code> or <code>"random"</code>). For example: <code>list(emax="common", et50="random")</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='write.likelihood'>Adds sections of JAGS code for an MBNMA model that correspond to the
likelihood</h2><span id='topic+write.likelihood'></span>

<h3>Description</h3>

<p>Adds sections of JAGS code for an MBNMA model that correspond to the
likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.likelihood(
  model,
  timecourse,
  rho = 0,
  covar = "varadj",
  link = "identity",
  sdscale = FALSE,
  fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.likelihood_+3A_model">model</code></td>
<td>
<p>A character object of JAGS MBNMA model code</p>
</td></tr>
<tr><td><code id="write.likelihood_+3A_timecourse">timecourse</code></td>
<td>
<p>A character object representing the time-course used in the MBNMA model</p>
</td></tr>
<tr><td><code id="write.likelihood_+3A_rho">rho</code></td>
<td>
<p>The correlation coefficient when modelling within-study correlation between time points. The default is a string representing a
prior distribution in JAGS, indicating that it be estimated from the data (e.g. <code>rho="dunif(0,1)"</code>). <code>rho</code> also be assigned a
numeric value (e.g. <code>rho=0.7</code>), which fixes <code>rho</code> in the model to this value (e.g. for use in a deterministic sensitivity analysis).
If set to <code>rho=0</code> (the default) then this implies modelling no correlation between time points.</p>
</td></tr>
<tr><td><code id="write.likelihood_+3A_covar">covar</code></td>
<td>
<p>A character specifying the covariance structure to use for modelling within-study correlation between time-points. This can
be done by specifying one of the following:
</p>

<ul>
<li> <p><code>"varadj"</code> - a univariate likelihood with a variance adjustment to assume a constant correlation between subsequent
time points (Jansen et al. 2015). This is the default.
</p>
</li>
<li> <p><code>"CS"</code> - a multivariate normal likelihood with a
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">compound symmetry</a> structure
</p>
</li>
<li> <p><code>"AR1"</code> - a multivariate normal likelihood with an
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">autoregressive AR1</a> structure
</p>
</li></ul>
</td></tr>
<tr><td><code id="write.likelihood_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="write.likelihood_+3A_sdscale">sdscale</code></td>
<td>
<p>Logical object to indicate whether to write a model that specifies a reference SD
for standardising when modelling using Standardised Mean Differences. Specifying <code>sdscale=TRUE</code>
will therefore only modify the model if link function is set to SMD (<code>link="smd"</code>).</p>
</td></tr>
<tr><td><code id="write.likelihood_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of JAGS MBNMA model code that includes likelihood
components of the model
</p>

<hr>
<h2 id='write.model'>Write the basic JAGS model code for MBNMA to which other lines of model
code can be added</h2><span id='topic+write.model'></span>

<h3>Description</h3>

<p>Write the basic JAGS model code for MBNMA to which other lines of model
code can be added
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.model()
</code></pre>


<h3>Value</h3>

<p>A character vector of JAGS model code
</p>

<hr>
<h2 id='write.ref.synth'>Write MBNMA time-course models JAGS code for synthesis of studies
investigating reference treatment</h2><span id='topic+write.ref.synth'></span>

<h3>Description</h3>

<p>Writes JAGS code for a Bayesian time-course model for model-based network
meta-analysis (MBNMA) that pools reference treatment effects from different
studies. This model only pools single study arms and therefore does not pool
relative effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.ref.synth(
  fun = tpoly(degree = 1),
  link = "identity",
  positive.scale = TRUE,
  intercept = TRUE,
  rho = 0,
  covar = "varadj",
  mu.synth = "random",
  priors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.ref.synth_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="write.ref.synth_+3A_link">link</code></td>
<td>
<p>Can take either <code>"identity"</code> (the default),
<code>"log"</code> (for modelling Ratios of Means (Friedrich et al. 2011)) or
<code>"smd"</code> (for modelling Standardised Mean Differences - although this also corresponds to an identity link function).</p>
</td></tr>
<tr><td><code id="write.ref.synth_+3A_positive.scale">positive.scale</code></td>
<td>
<p>A boolean object that indicates whether all continuous
mean responses (y) are positive and therefore whether the baseline response
should be given a prior that constrains it to be positive (e.g. for scales that cannot be &lt;0).</p>
</td></tr>
<tr><td><code id="write.ref.synth_+3A_intercept">intercept</code></td>
<td>
<p>A boolean object that indicates whether an intercept (written
as <code>alpha</code> in the model) is to be included. If left as <code>NULL</code> (the default), an intercept will
be included only for studies reporting absolute means, and will be excluded for
studies reporting change from baseline (as indicated in <code>network$cfb</code>).</p>
</td></tr>
<tr><td><code id="write.ref.synth_+3A_rho">rho</code></td>
<td>
<p>The correlation coefficient when modelling within-study correlation between time points. The default is a string representing a
prior distribution in JAGS, indicating that it be estimated from the data (e.g. <code>rho="dunif(0,1)"</code>). <code>rho</code> also be assigned a
numeric value (e.g. <code>rho=0.7</code>), which fixes <code>rho</code> in the model to this value (e.g. for use in a deterministic sensitivity analysis).
If set to <code>rho=0</code> (the default) then this implies modelling no correlation between time points.</p>
</td></tr>
<tr><td><code id="write.ref.synth_+3A_covar">covar</code></td>
<td>
<p>A character specifying the covariance structure to use for modelling within-study correlation between time-points. This can
be done by specifying one of the following:
</p>

<ul>
<li> <p><code>"varadj"</code> - a univariate likelihood with a variance adjustment to assume a constant correlation between subsequent
time points (Jansen et al. 2015). This is the default.
</p>
</li>
<li> <p><code>"CS"</code> - a multivariate normal likelihood with a
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">compound symmetry</a> structure
</p>
</li>
<li> <p><code>"AR1"</code> - a multivariate normal likelihood with an
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi30/198-30.pdf">autoregressive AR1</a> structure
</p>
</li></ul>
</td></tr>
<tr><td><code id="write.ref.synth_+3A_mu.synth">mu.synth</code></td>
<td>
<p>A string that takes the value <code>fixed</code> or <code>random</code>, indicating
the type of synthesis model to use</p>
</td></tr>
<tr><td><code id="write.ref.synth_+3A_priors">priors</code></td>
<td>
<p>A named list of parameter values (without indices) and
replacement prior distribution values given as strings
<strong>using distributions as specified in JAGS syntax</strong> (see Plummer (2017)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character object of JAGS MBNMA model code that includes beta
parameter components of the model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Write a log-linear time-course MBNMA synthesis model with:
# Common effects for synthesis of mu
# Modelled as ratio of means
model &lt;- write.ref.synth(fun=tloglin(pool.rate="rel", method.rate="common"),
  mu.synth="common", link="log")

cat(model) # Concatenates model representations making code more easily readable

</code></pre>

<hr>
<h2 id='write.timecourse'>Adds sections of JAGS code for an MBNMA model that correspond to alpha
parameters</h2><span id='topic+write.timecourse'></span>

<h3>Description</h3>

<p>Adds sections of JAGS code for an MBNMA model that correspond to alpha
parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.timecourse(model, fun, intercept, positive.scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.timecourse_+3A_model">model</code></td>
<td>
<p>A character string representing the MBNMA model in JAGS code</p>
</td></tr>
<tr><td><code id="write.timecourse_+3A_fun">fun</code></td>
<td>
<p>An object of class <code>"timefun"</code> generated (see Details) using any of
<code>tloglin()</code>, <code>tpoly()</code>, <code>titp()</code>, <code>temax()</code>, <code>tfpoly()</code>, <code>tspline()</code> or <code>tuser()</code></p>
</td></tr>
<tr><td><code id="write.timecourse_+3A_intercept">intercept</code></td>
<td>
<p>A boolean object that indicates whether an intercept (written
as <code>alpha</code> in the model) is to be included. If left as <code>NULL</code> (the default), an intercept will
be included only for studies reporting absolute means, and will be excluded for
studies reporting change from baseline (as indicated in <code>network$cfb</code>).</p>
</td></tr>
<tr><td><code id="write.timecourse_+3A_positive.scale">positive.scale</code></td>
<td>
<p>A boolean object that indicates whether all continuous
mean responses (y) are positive and therefore whether the baseline response
should be given a prior that constrains it to be positive (e.g. for scales that cannot be &lt;0).</p>
</td></tr>
<tr><td><code id="write.timecourse_+3A_timecourse">timecourse</code></td>
<td>
<p>A character object that contains JAGS code for the
time-course component of the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named elements: <code>model</code> is a character vector of JAGS MBNMA
model code that includes alpha parameter components of the model
<code>timecourse</code> is a character object that contains JAGS code for the
time-course component of the model, for which alpha will be indexed
correctly
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
