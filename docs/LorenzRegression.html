<!DOCTYPE html><html><head><title>Help for package LorenzRegression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LorenzRegression}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.Fitness_cpp'><p>Computes the fitness used in the GA</p></a></li>
<li><a href='#boot.confint'><p>Bootstrap confidence intervals</p></a></li>
<li><a href='#coef.LR'><p>Estimated coefficients for the Lorenz Regression</p></a></li>
<li><a href='#coef.PLR'><p>Estimated coefficients for the Penalized Lorenz Regression</p></a></li>
<li><a href='#confint.LR'><p>Confidence intervals for the Lorenz Regression</p></a></li>
<li><a href='#confint.PLR'><p>Confidence intervals for the Penalized Lorenz Regression</p></a></li>
<li><a href='#Data.Incomes'><p>Simulated income data</p></a></li>
<li><a href='#Gini.coef'><p>Concentration index of <em>y</em> wrt <em>x</em></p></a></li>
<li><a href='#Lorenz.boot'><p>Produces bootstrap-based inference for (penalized) Lorenz regression</p></a></li>
<li><a href='#Lorenz.curve'><p>Concentration curve of <em>y</em> with respect to <em>x</em></p></a></li>
<li><a href='#Lorenz.FABS'><p>Solves the Penalized Lorenz Regression with Lasso penalty</p></a></li>
<li><a href='#Lorenz.GA'><p>Estimates the parameter vector in Lorenz regression using a genetic algorithm</p></a></li>
<li><a href='#Lorenz.graphs'><p>Graphs of concentration curves</p></a></li>
<li><a href='#Lorenz.Population'><p>Defines the population used in the genetic algorithm</p></a></li>
<li><a href='#Lorenz.Reg'><p>Undertakes a Lorenz regression</p></a></li>
<li><a href='#Lorenz.SCADFABS'><p>Solves the Penalized Lorenz Regression with SCAD penalty</p></a></li>
<li><a href='#LorenzRegression'><p>LorenzRegression : A package to estimate and interpret Lorenz regressions</p></a></li>
<li><a href='#plot.LR'><p>Plots for the Unpenalized Lorenz Regression</p></a></li>
<li><a href='#plot.PLR'><p>Plots for the Penalized Lorenz Regression</p></a></li>
<li><a href='#PLR.BIC'><p>Determines the regularization parameter (lambda) in a PLR via optimization of an information criterion.</p></a></li>
<li><a href='#PLR.CV'><p>Determines the regularization parameter (lambda) in a PLR via cross-validation</p></a></li>
<li><a href='#PLR.normalize'><p>Re-normalizes the estimated coefficients of a penalized Lorenz regression</p></a></li>
<li><a href='#PLR.wrap'><p>Wrapper for the <code>Lorenz.SCADFABS</code> and <code>Lorenz.FABS</code> functions</p></a></li>
<li><a href='#print.LR'><p>Printing method for the Lorenz Regression</p></a></li>
<li><a href='#print.PLR'><p>Printing method for the Penalized Lorenz Regression</p></a></li>
<li><a href='#Rearrangement.estimation'><p>Estimates a monotonic regression curve via Chernozhukov et al (2009)</p></a></li>
<li><a href='#summary.LR'><p>Summary for the Lorenz Regression</p></a></li>
<li><a href='#summary.PLR'><p>Summary for the Penalized Lorenz Regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Lorenz and Penalized Lorenz Regressions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Inference for the Lorenz and penalized Lorenz regressions. More broadly, the package proposes functions to assess inequality and graphically represent it. The Lorenz Regression procedure is introduced in Heuchenne and Jacquemain (2022) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2021.107347">doi:10.1016/j.csda.2021.107347</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.1)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2, parallel, doParallel, foreach, MASS, GA,
locpol, Rearrangement, Rcpp (&ge; 0.11.0), knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-28 14:30:05 UTC; jacquemain</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexandre Jacquemain
    <a href="https://orcid.org/0000-0001-9349-780X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Xingjie Shi [ctb] (Author of an R implementation of the FABS algorithm
    available at https://github.com/shuanggema/Fabs, of which function
    Lorenz.FABS is derived)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexandre Jacquemain &lt;aljacquemain@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-28 17:32:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='.Fitness_cpp'>Computes the fitness used in the GA</h2><span id='topic+.Fitness_cpp'></span>

<h3>Description</h3>

<p>Computes the fitness of a candidate in the genetic algorithm displayed in function Lorenz.GA.cpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.Fitness_cpp(x, Y, X, Z, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".Fitness_cpp_+3A_x">x</code></td>
<td>
<p>vector of size (p-1) giving the proposed candidate, where p is the number of covariates</p>
</td></tr>
<tr><td><code id=".Fitness_cpp_+3A_y">Y</code></td>
<td>
<p>vector of size n gathering the response, where n is the sample size</p>
</td></tr>
<tr><td><code id=".Fitness_cpp_+3A_x">X</code></td>
<td>
<p>matrix of dimension (n*p) gathering the covariates</p>
</td></tr>
<tr><td><code id=".Fitness_cpp_+3A_z">Z</code></td>
<td>
<p>vector of size n gathering iid repetitions of a U[0,1]</p>
</td></tr>
<tr><td><code id=".Fitness_cpp_+3A_pi">pi</code></td>
<td>
<p>vector of size n gathering the observation weights (notice that sum(pi)=1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitness of candidate x
</p>

<hr>
<h2 id='boot.confint'>Bootstrap confidence intervals</h2><span id='topic+boot.confint'></span>

<h3>Description</h3>

<p><code>boot.confint</code> computes bootstrap confidence intervals given an estimation on the original sample and on the bootstrap samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.confint(x.hat, x.star, alpha, boot.method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.confint_+3A_x.hat">x.hat</code></td>
<td>
<p>estimator on the original sample.</p>
</td></tr>
<tr><td><code id="boot.confint_+3A_x.star">x.star</code></td>
<td>
<p>vector gathering the estimation on the bootstrapped sample.</p>
</td></tr>
<tr><td><code id="boot.confint_+3A_alpha">alpha</code></td>
<td>
<p>1-level of the confidence interval</p>
</td></tr>
<tr><td><code id="boot.confint_+3A_boot.method">boot.method</code></td>
<td>
<p>bootstrap method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of dimension two with the desired confidence interval
</p>

<hr>
<h2 id='coef.LR'>Estimated coefficients for the Lorenz Regression</h2><span id='topic+coef.LR'></span>

<h3>Description</h3>

<p><code>coef.LR</code> provides the estimated coefficients for an object of class <code>LR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.LR_+3A_object">object</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty="none"</code>.</p>
</td></tr>
<tr><td><code id="coef.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector gathering the estimated coefficients
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
NPLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "none")
coef(NPLR)

</code></pre>

<hr>
<h2 id='coef.PLR'>Estimated coefficients for the Penalized Lorenz Regression</h2><span id='topic+coef.PLR'></span>

<h3>Description</h3>

<p><code>coef.PLR</code> provides the estimated coefficients for an object of class <code>PLR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
coef(object, renormalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.PLR_+3A_object">object</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty!="none"</code>.</p>
</td></tr>
<tr><td><code id="coef.PLR_+3A_renormalize">renormalize</code></td>
<td>
<p>whether the coefficient vector should be re-normalized to match the representation where the first category of each categorical variable is omitted. Default value is TRUE</p>
</td></tr>
<tr><td><code id="coef.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the PLR was fitted with only one selection method, the output is a vector gathering the estimated coefficients.
If several selection methods were selected, it outputs a list of vectors, where each element of the list corresponds to a different selection method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "SCAD",
                  h.grid = nrow(Data.Incomes)^(-1/5.5), sel.choice = c("BIC","CV"),
                  eps = 0.01, seed.CV = 123, nfolds = 5)
coef(PLR)

</code></pre>

<hr>
<h2 id='confint.LR'>Confidence intervals for the Lorenz Regression</h2><span id='topic+confint.LR'></span>

<h3>Description</h3>

<p><code>confint.LR</code> provides confidence intervals for the explained Gini coefficient, Lorenz-R2 and theta vector for an object of class <code>LR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
confint(
  object,
  parm = c("Gini", "LR2", "theta"),
  level = 0.95,
  boot.method = c("Param", "Basic", "Perc"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.LR_+3A_object">object</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty="none"</code> and <code>Boot.inference=TRUE</code>.</p>
</td></tr>
<tr><td><code id="confint.LR_+3A_parm">parm</code></td>
<td>
<p>Determines whether the confidence interval is computed for the explained Gini coefficient, for the Lorenz-R2 or for the vector of theta coefficients. Possible values are &quot;Gini&quot; (default, for the explained Gini),&quot;LR2&quot; (for the Lorenz-R2) and &quot;theta&quot; (for the vector theta).</p>
</td></tr>
<tr><td><code id="confint.LR_+3A_level">level</code></td>
<td>
<p>level of the confidence interval</p>
</td></tr>
<tr><td><code id="confint.LR_+3A_boot.method">boot.method</code></td>
<td>
<p>What bootstrap method is used to construct the confidence interval. Default value is &quot;Param&quot;, which exploits the asymptotic normality and only bootstraps the variance.
Other possible values are &quot;Perc&quot; (percentile bootstrap) and &quot;Basic&quot; (basic bootstrap). Percentile bootstrap directly plugs the quantiles of the bootstrap distribution.
Basic bootstrap is based on bootstrapping the whole distribution of the estimator.</p>
</td></tr>
<tr><td><code id="confint.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function only if Boot.inference was set to TRUE in the call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>. Otherwise, bootstrap was not computed and the confidence intervals cannot be determined.
</p>


<h3>Value</h3>

<p>The desired confidence interval. If parm is set to either &quot;Gini&quot; or &quot;LR2&quot;, the output is a vector. If parm is set to &quot;theta&quot;, it is a matrix where each row corresponds to a different coefficient.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following piece of code might take several minutes
data(Data.Incomes)
set.seed(123)
Data &lt;- Data.Incomes[sample(1:nrow(Data.Incomes),50),]
NPLR &lt;- Lorenz.Reg(Income ~ ., data = Data, penalty = "none",
                   seed.boot = 123, B = 40, Boot.inference = TRUE)
confint(NPLR)


</code></pre>

<hr>
<h2 id='confint.PLR'>Confidence intervals for the Penalized Lorenz Regression</h2><span id='topic+confint.PLR'></span>

<h3>Description</h3>

<p><code>confint.PLR</code> provides confidence intervals for the explained Gini coefficient and Lorenz-R2 for an parm of class <code>PLR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
confint(
  object,
  parm = c("Gini", "LR2"),
  level = 0.95,
  boot.method = c("Param", "Basic", "Perc"),
  which.pars = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.PLR_+3A_object">object</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty!="none"</code> and <code>Boot.inference=TRUE</code>.</p>
</td></tr>
<tr><td><code id="confint.PLR_+3A_parm">parm</code></td>
<td>
<p>Determines whether the confidence interval is computed for the explained Gini coefficient or for the Lorenz-R2. Possible values are &quot;Gini&quot; (default, for the explained Gini) and &quot;LR2&quot; (for the Lorenz-R2).</p>
</td></tr>
<tr><td><code id="confint.PLR_+3A_level">level</code></td>
<td>
<p>level of the confidence interval</p>
</td></tr>
<tr><td><code id="confint.PLR_+3A_boot.method">boot.method</code></td>
<td>
<p>What bootstrap method is used to construct the confidence interval. Default value is &quot;Param&quot;, which exploits the asymptotic normality and only bootstraps the variance.
Other possible values are &quot;Perc&quot; (percentile bootstrap) and &quot;Basic&quot; (basic bootstrap). Percentile bootstrap directly plugs the quantiles of the bootstrap distribution.
Basic bootstrap is based on bootstrapping the whole distribution of the estimator.</p>
</td></tr>
<tr><td><code id="confint.PLR_+3A_which.pars">which.pars</code></td>
<td>
<p>Which values of the bandwidth h and the penalty parameter lambda should be used. Default is NULL, in which case the optimal values are used.</p>
</td></tr>
<tr><td><code id="confint.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function only if Boot.inference was set to TRUE in the call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>. Otherwise, bootstrap was not computed and the confidence intervals cannot be determined.
</p>


<h3>Value</h3>

<p>A matrix gathering the desired confidence intervals. Each row corresponds to a different selection method for the pair (h,lambda).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
set.seed(123)
Data &lt;- Data.Incomes[sample(1:nrow(Data.Incomes),50),]
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data, h.grid = nrow(Data)^(-1/5.5),
                  penalty = "SCAD", eps = 0.02, seed.boot = 123, B = 40, Boot.inference = TRUE)
confint(PLR)

</code></pre>

<hr>
<h2 id='Data.Incomes'>Simulated income data</h2><span id='topic+Data.Incomes'></span>

<h3>Description</h3>

<p>Fictitious cross-sectional dataset used to illustrate the Lorenz regression methodology. It covers 7 variables for 200 individuals aged between 25 and 30 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Data.Incomes)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 7 columns:
</p>

<dl>
<dt>Income</dt><dd><p>Individual's labor income</p>
</dd>
<dt>Sex</dt><dd><p>Sex (0=Female, 1=Male)</p>
</dd>
<dt>Health.level</dt><dd><p>Variable ranging from 0 to 10 indicating the individual health's level (0 is worst, 10 is best)</p>
</dd>
<dt>Age</dt><dd><p>Individual's age in years, ranging from 25 to 30</p>
</dd>
<dt>Work.Hours</dt><dd><p>Individual's weekly work hours</p>
</dd>
<dt>Education</dt><dd><p>Individual's highest grade completed in years</p>
</dd>
<dt>Seniority</dt><dd><p>Length of service in years with the individual's employer</p>
</dd>
</dl>


<hr>
<h2 id='Gini.coef'>Concentration index of <em>y</em> wrt <em>x</em></h2><span id='topic+Gini.coef'></span>

<h3>Description</h3>

<p><code>Gini.coef</code> computes the concentration index of a vector <em>y</em> with respect to another vector <em>x</em>.
If <em>y</em> and <em>x</em> are identical, the obtained concentration index boils down to the Gini coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gini.coef(
  y,
  x = y,
  na.rm = TRUE,
  ties.method = c("mean", "random"),
  seed = NULL,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gini.coef_+3A_y">y</code></td>
<td>
<p>variable of interest.</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_x">x</code></td>
<td>
<p>variable to use for the ranking. By default <code class="reqn">x=y</code>, and the obtained concentration index is the Gini coefficient of <em>y</em>.</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_na.rm">na.rm</code></td>
<td>
<p>should missing values be deleted. Default value is <code>TRUE</code>. If <code>FALSE</code> is selected, missing values generate an error message</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_ties.method">ties.method</code></td>
<td>
<p>What method should be used to break the ties in the rank index. Possible values are &quot;mean&quot; (default value) or &quot;random&quot;. If &quot;random&quot; is selected, the ties are broken by further ranking in terms of a uniformly distributed random variable. If &quot;mean&quot; is selected, the average rank method is used.</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_seed">seed</code></td>
<td>
<p>fixes what seed is imposed for the generation of the vector of uniform random variables used to break the ties. Default is NULL, in which case no seed is imposed.</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the concentration index (or Gini coefficient)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.curve">Lorenz.curve</a></code>, <code><a href="#topic+Lorenz.graphs">Lorenz.graphs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
# We first compute the Gini coefficient of Income
Y &lt;- Data.Incomes$Income
Gini.coef(y = Y)
# Then we compute the concentration index of Income with respect to Age
X &lt;- Data.Incomes$Age
Gini.coef(y = Y, x = X)

</code></pre>

<hr>
<h2 id='Lorenz.boot'>Produces bootstrap-based inference for (penalized) Lorenz regression</h2><span id='topic+Lorenz.boot'></span>

<h3>Description</h3>

<p><code>Lorenz.boot</code> determines bootstrap estimators for the weight vector, explained Gini coefficient and Lorenz-<code class="reqn">R^2</code> and, if applies, selects the regularization parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.boot(
  formula,
  data,
  standardize = TRUE,
  weights = NULL,
  LR.est = NULL,
  penalty = c("none", "SCAD", "LASSO"),
  h = NULL,
  eps = 0.005,
  B = 500,
  bootID = NULL,
  seed.boot = NULL,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lorenz.boot_+3A_formula">formula</code></td>
<td>
<p>A formula object of the form <em>response</em> ~ <em>other_variables</em>.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables displayed in the formula.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_standardize">standardize</code></td>
<td>
<p>Should the variables be standardized before the estimation process? Default value is TRUE.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_lr.est">LR.est</code></td>
<td>
<p>Estimation on the original sample. Output of a call to <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code> or <code><a href="#topic+PLR.wrap">PLR.wrap</a></code>.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_penalty">penalty</code></td>
<td>
<p>should the regression include a penalty on the coefficients size.
If &quot;none&quot; is chosen, a non-penalized Lorenz regression is computed using function <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>.
If &quot;SCAD&quot; is chosen, a penalized Lorenz regression with SCAD penalty is computed using function <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>.
IF &quot;LASSO&quot; is chosen, a penalized Lorenz regression with LASSO penalty is computed using function <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_h">h</code></td>
<td>
<p>Only used if penalty=&quot;SCAD&quot; or penalty=&quot;LASSO&quot;. Bandwidth of the kernel, determining the smoothness of the approximation of the indicator function. Default value is NULL (unpenalized case) but has to be specified if penalty=&quot;LASSO&quot; or penalty=&quot;SCAD&quot;.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_eps">eps</code></td>
<td>
<p>Only used if penalty=&quot;SCAD&quot; or penalty=&quot;LASSO&quot;. Step size in the FABS or SCADFABS algorithm. Default value is 0.005.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_b">B</code></td>
<td>
<p>Number of bootstrap resamples. Default is 500.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_bootid">bootID</code></td>
<td>
<p>matrix where each row provides the ID of the observations selected in each bootstrap resample. Default is NULL, in which case these are defined internally.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_seed.boot">seed.boot</code></td>
<td>
<p>Should a specific seed be used in the definition of the folds. Default value is NULL in which case no seed is imposed.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_parallel">parallel</code></td>
<td>
<p>Whether parallel computing should be used to distribute the <code>B</code> computations on different CPUs. Either a logical value determining whether parallel computing is used (TRUE) or not (FALSE, the default value). Or a numerical value determining the number of cores to use.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_...">...</code></td>
<td>
<p>Additional parameters corresponding to arguments passed in <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code> or <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code> depending on the argument chosen in penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with several components:
</p>

<dl>
<dt><code>LR.est</code></dt><dd><p>Estimation on the original sample.</p>
</dd>
<dt><code>Gi.star</code></dt><dd><p>In the unpenalized case, a vector gathering the bootstrap estimators of the explained Gini coefficient. In the penalized case, it becomes a list of vectors. Each element of the list corresponds to a different value of the penalization parameter</p>
</dd>
<dt><code>LR2.star</code></dt><dd><p>In the unpenalized case, a vector gathering the bootstrap estimators of the Lorenz-<code class="reqn">R^2</code>. In the penalized case, it becomes a list of vectors.</p>
</dd>
<dt><code>theta.star</code></dt><dd><p>In the unpenalized case, a matrix gathering the bootstrap estimators of theta (rows correspond to bootstrap iterations and columns refer to the different coefficients). In the penalized case, it becomes a list of matrices.</p>
</dd>
<dt><code>OOB.total</code></dt><dd><p>In the penalized case only. Vector gathering the OOB-score for each lambda value.</p>
</dd>
<dt><code>OOB.best</code></dt><dd><p>In the penalized case only. index of the lambda value attaining the highest OOB-score.</p>
</dd>
</dl>



<h3>References</h3>

<p>Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. <em>Computational Statistics &amp; Data Analysis 167(C)</em>.
Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2022). A penalised bootstrap estimation procedure for the explained Gini coefficient.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>, <code><a href="#topic+PLR.wrap">PLR.wrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
set.seed(123)
Data &lt;- Data.Incomes[sample(1:nrow(Data.Incomes),50),]
Lorenz.boot(Income ~ ., data = Data,
            penalty = "SCAD", h = nrow(Data)^(-1/5.5),
            eps = 0.02, B = 40, seed.boot = 123)


</code></pre>

<hr>
<h2 id='Lorenz.curve'>Concentration curve of <em>y</em> with respect to <em>x</em></h2><span id='topic+Lorenz.curve'></span>

<h3>Description</h3>

<p><code>Lorenz.curve</code> computes the concentration curve index of a vector <em>y</em> with respect to another vector <em>x</em>.
If <em>y</em> and <em>x</em> are identical, the obtained concentration curve boils down to the Lorenz curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.curve(
  y,
  x = y,
  graph = FALSE,
  na.rm = TRUE,
  ties.method = c("mean", "random"),
  seed = NULL,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lorenz.curve_+3A_y">y</code></td>
<td>
<p>variable of interest.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_x">x</code></td>
<td>
<p>variable to use for the ranking. By default <code class="reqn">x=y</code>, and the obtained concentration curve is the Lorenz curve of <em>y</em>.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_graph">graph</code></td>
<td>
<p>whether a graph of the obtained concentration curve should be traced. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_na.rm">na.rm</code></td>
<td>
<p>should missing values be deleted. Default value is <code>TRUE</code>. If <code>FALSE</code> is selected, missing values generate an error message</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_ties.method">ties.method</code></td>
<td>
<p>What method should be used to break the ties in the rank index. Possible values are &quot;mean&quot; (default value) or &quot;random&quot;. If &quot;random&quot; is selected, the ties are broken by further ranking in terms of a uniformly distributed random variable. If &quot;mean&quot; is selected, the average rank method is used.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_seed">seed</code></td>
<td>
<p>seed imposed for the generation of the vector of uniform random variables used to break the ties. Default is NULL, in which case no seed is imposed.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function corresponding to the estimated Lorenz or concentration curve. If <code>graph</code> is TRUE, the curve is also plotted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.graphs">Lorenz.graphs</a></code>, <code><a href="#topic+Gini.coef">Gini.coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
# We first compute the Lorenz curve of Income
Y &lt;- Data.Incomes$Income
Lorenz.curve(y = Y, graph = TRUE)
# Then we compute the concentration curve of Income with respect to Age
X &lt;- Data.Incomes$Age
Lorenz.curve(y = Y, x = X, graph = TRUE)

</code></pre>

<hr>
<h2 id='Lorenz.FABS'>Solves the Penalized Lorenz Regression with Lasso penalty</h2><span id='topic+Lorenz.FABS'></span>

<h3>Description</h3>

<p><code>Lorenz.FABS</code> solves the penalized Lorenz regression with (adaptive) Lasso penalty on a grid of lambda values.
For each value of lambda, the function returns estimates for the vector of parameters and for the estimated explained Gini coefficient, as well as the Lorenz-<code class="reqn">R^2</code> of the regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.FABS(
  YX_mat,
  weights = NULL,
  h,
  w.adaptive = NULL,
  eps,
  iter = 10^4,
  lambda = "Shi",
  lambda.min = 1e-07,
  gamma = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lorenz.FABS_+3A_yx_mat">YX_mat</code></td>
<td>
<p>a matrix with the first column corresponding to the response vector, the remaining ones being the explanatory variables.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel, determining the smoothness of the approximation of the indicator function.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_w.adaptive">w.adaptive</code></td>
<td>
<p>vector of size equal to the number of covariates where each entry indicates the weight in the adaptive Lasso. By default, each covariate is given the same weight (Lasso).</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_eps">eps</code></td>
<td>
<p>step size in the FABS algorithm.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations. Default value is 10^4.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_lambda">lambda</code></td>
<td>
<p>this parameter relates to the regularization parameter. Several options are available.
</p>

<dl>
<dt><code>grid</code></dt><dd><p>If lambda=&quot;grid&quot;, lambda is defined on a grid, equidistant in the logarithmic scale.</p>
</dd>
<dt><code>Shi</code></dt><dd><p>If lambda=&quot;Shi&quot;, lambda, is defined within the algorithm, as in Shi et al (2018).</p>
</dd>
<dt><code>supplied</code></dt><dd><p>If the user wants to supply the lambda vector himself</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_lambda.min">lambda.min</code></td>
<td>
<p>lower bound of the penalty parameter. Only used if lambda=&quot;Shi&quot;.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_gamma">gamma</code></td>
<td>
<p>value of the Lagrange multiplier in the loss function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regression is solved using the FABS algorithm developed by Shi et al (2018) and adapted to our case.
For a comprehensive explanation of the Penalized Lorenz Regression, see Jacquemain et al.
In order to ensure identifiability, theta is forced to have a L2-norm equal to one.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<dl>
<dt><code>iter</code></dt><dd><p>number of iterations attained by the algorithm.</p>
</dd>
<dt><code>direction</code></dt><dd><p>vector providing the direction (-1 = backward step, 1 = forward step) for each iteration.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>value of the regularization parameter for each iteration.</p>
</dd>
<dt><code>h</code></dt><dd><p>value of the bandwidth.</p>
</dd>
<dt><code>theta</code></dt><dd><p>matrix where column i provides the estimated parameter vector for iteration i.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>the Lorenz-<code class="reqn">R^2</code> of the regression.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>the estimated explained Gini coefficient.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2022). A penalised bootstrap estimation procedure for the explained Gini coefficient.
Shi, X., Y. Huang, J. Huang, and S. Ma (2018). A Forward and Backward Stagewise Algorithm for Nonconvex Loss Function with Adaptive Lasso, <em>Computational Statistics &amp; Data Analysis 124</em>, 235-251.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+PLR.wrap">PLR.wrap</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
YX_mat &lt;- Data.Incomes[,-2]
Lorenz.FABS(YX_mat, h = nrow(Data.Incomes)^(-1/5.5), eps = 0.005)

</code></pre>

<hr>
<h2 id='Lorenz.GA'>Estimates the parameter vector in Lorenz regression using a genetic algorithm</h2><span id='topic+Lorenz.GA'></span>

<h3>Description</h3>

<p><code>Lorenz.GA</code> estimates the vector of parameters in Lorenz regression using the unit-norm normalization
It also returns the Lorenz-<code class="reqn">R^2</code> of the regression as well as the estimated explained Gini coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.GA(
  YX_mat,
  standardize = TRUE,
  popSize = 50,
  maxiter = 1500,
  run = 150,
  ties.method = c("random", "mean"),
  ties.Gini = c("random", "mean"),
  seed.random = NULL,
  weights = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lorenz.GA_+3A_yx_mat">YX_mat</code></td>
<td>
<p>A matrix with the first column corresponding to the response vector, the remaining ones being the explanatory variables.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_standardize">standardize</code></td>
<td>
<p>Should the variables be standardized before the estimation process? Default value is TRUE.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_popsize">popSize</code></td>
<td>
<p>Size of the population of candidates in the genetic algorithm. Default value is 50.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number ot iterations in the genetic algorithm. Default value is 1500.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_run">run</code></td>
<td>
<p>Number of iterations without improvement in the best fitness necessary for the algorithm to stop. Default value is 150.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_ties.method">ties.method</code></td>
<td>
<p>What method should be used to break the ties in optimization program. Possible values are &quot;random&quot; (default value) or &quot;mean&quot;. If &quot;random&quot; is selected, the ties are broken by further ranking in terms of a uniformly distributed random variable. If &quot;mean&quot; is selected, the average rank method is used.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_ties.gini">ties.Gini</code></td>
<td>
<p>what method should be used to break the ties in the computation of the Gini coefficient at the end of the algorithm. Possible values and default choice are the same as above.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_seed.random">seed.random</code></td>
<td>
<p>seed.random imposed for the generation of the vector of uniform random variables used to break the ties. Default is NULL, in which case no seed.random is imposed.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_parallel">parallel</code></td>
<td>
<p>Whether parallel computing should be used to distribute the computations in the genetic algorithm. Either a logical value determining whether parallel computing is used (TRUE) or not (FALSE, the default value). Or a numerical value determining the number of cores to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genetic algorithm is solved using function <code><a href="GA.html#topic+ga">ga</a></code> from the <em>GA</em> package. The fitness function is coded in Rcpp to speed up computation time.
When discrete covariates are introduced and ties occur in the index, the default option randomly breaks them, as advised in Section 3 of Heuchenne and Jacquemain (2020)
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<dl>
<dt><code>theta</code></dt><dd><p>the estimated vector of parameters.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>the Lorenz-<code class="reqn">R^2</code> of the regression.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>the estimated explained Gini coefficient.</p>
</dd>
<dt><code>niter</code></dt><dd><p>number of iterations attained by the genetic algorithm.</p>
</dd>
<dt><code>fit</code></dt><dd><p>value attained by the fitness function at the optimum.</p>
</dd>
</dl>



<h3>References</h3>

<p>Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. <em>Computational Statistics &amp; Data Analysis 167(C)</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="GA.html#topic+ga">ga</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
YX_mat &lt;- cbind(Data.Incomes$Income, Data.Incomes$Age, Data.Incomes$Work.Hours)
Lorenz.GA(YX_mat, popSize = 40)

</code></pre>

<hr>
<h2 id='Lorenz.graphs'>Graphs of concentration curves</h2><span id='topic+Lorenz.graphs'></span>

<h3>Description</h3>

<p><code>Lorenz.graphs</code> traces the Lorenz curve of a response and the concentration curve of the response and each of a series of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.graphs(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lorenz.graphs_+3A_formula">formula</code></td>
<td>
<p>A formula object of the form <em>response</em> ~ <em>other_variables</em>.</p>
</td></tr>
<tr><td><code id="Lorenz.graphs_+3A_data">data</code></td>
<td>
<p>A dataframe containing the variables of interest</p>
</td></tr>
<tr><td><code id="Lorenz.graphs_+3A_...">...</code></td>
<td>
<p>other arguments (see Section 'Arguments' in <code><a href="#topic+Lorenz.curve">Lorenz.curve</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot comprising
</p>

<ul>
<li><p> The Lorenz curve of <em>response</em>
</p>
</li>
<li><p> The concentration curves of <em>response</em> with respect to each element of <em>other_variables</em>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.curve">Lorenz.curve</a></code>, <code><a href="#topic+Gini.coef">Gini.coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
Lorenz.graphs(Income ~ Age + Work.Hours, data = Data.Incomes)

</code></pre>

<hr>
<h2 id='Lorenz.Population'>Defines the population used in the genetic algorithm</h2><span id='topic+Lorenz.Population'></span>

<h3>Description</h3>

<p><code>Lorenz.Population</code> creates the initial population of the genetic algorithm used to solve the Lorenz regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.Population(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lorenz.Population_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>ga</code>&quot;, resulting from a call to function <code>ga</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this population produces an initial solution ensuring a unit norm.
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>object@popSize</code> times the number of explanatory variables minus one, gathering the initial population.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>
</p>

<hr>
<h2 id='Lorenz.Reg'>Undertakes a Lorenz regression</h2><span id='topic+Lorenz.Reg'></span>

<h3>Description</h3>

<p><code>Lorenz.Reg</code> performs the Lorenz regression of a response with respect to several covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.Reg(
  formula,
  data,
  standardize = TRUE,
  weights = NULL,
  parallel = FALSE,
  penalty = c("none", "SCAD", "LASSO"),
  h.grid = c(0.1, 0.2, 1, 2, 5) * nrow(data)^(-1/5.5),
  eps = 0.005,
  sel.choice = c("BIC", "CV", "Boot")[1],
  nfolds = 10,
  seed.CV = NULL,
  foldID = NULL,
  Boot.inference = FALSE,
  B = 500,
  bootID = NULL,
  seed.boot = NULL,
  LR = NULL,
  LR.boot = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lorenz.Reg_+3A_formula">formula</code></td>
<td>
<p>A formula object of the form <em>response</em> ~ <em>other_variables</em>.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables displayed in the formula.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_standardize">standardize</code></td>
<td>
<p>Should the variables be standardized before the estimation process? Default value is TRUE.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_parallel">parallel</code></td>
<td>
<p>Whether parallel computing should be used to distribute the computations on different CPUs. Either a logical value determining whether parallel computing is used (TRUE) or not (FALSE, the default value). Or a numerical value determining the number of cores to use.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_penalty">penalty</code></td>
<td>
<p>should the regression include a penalty on the coefficients size.
If &quot;none&quot; is chosen, a non-penalized Lorenz regression is computed using function <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>.
If &quot;SCAD&quot; is chosen, a penalized Lorenz regression with SCAD penalty is computed using function <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>.
IF &quot;LASSO&quot; is chosen, a penalized Lorenz regression with LASSO penalty is computed using function <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_h.grid">h.grid</code></td>
<td>
<p>Only used if penalty=&quot;SCAD&quot; or penalty=&quot;LASSO&quot;. Grid of values for the bandwidth of the kernel, determining the smoothness of the approximation of the indicator function. Default value is (0.1,0.2,1,2,5)*n^(-1/5.5), where n is sample size.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_eps">eps</code></td>
<td>
<p>Only used if penalty=&quot;SCAD&quot; or penalty=&quot;LASSO&quot;. Step size in the FABS or SCADFABS algorithm. Default value is 0.005.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_sel.choice">sel.choice</code></td>
<td>
<p>Only used if penalty=&quot;SCAD&quot; or penalty=&quot;LASSO&quot;. Determines what method is used to determine the optimal regularization parameter. Possibles values are any subvector of c(&quot;BIC&quot;,&quot;CV&quot;,&quot;Boot&quot;). Default is &quot;BIC&quot;. Notice that &quot;Boot&quot; is necessarily added if Boot.inference is set to TRUE.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_nfolds">nfolds</code></td>
<td>
<p>Only used if sel.choice contains &quot;CV&quot;. Number of folds in the cross-validation.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_seed.cv">seed.CV</code></td>
<td>
<p>Only used if sel.choice contains &quot;CV&quot;. Should a specific seed be used in the definition of the folds. Default value is NULL in which case no seed is imposed.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_foldid">foldID</code></td>
<td>
<p>vector taking value from 1 to nfolds specifying the fold index of each observation. Default value is NULL in which case the folds are defined internally.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_boot.inference">Boot.inference</code></td>
<td>
<p>should bootstrap inference be produced ? Default is FALSE. It is automatically turned to TRUE if sel.choice contains &quot;Boot&quot;.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_b">B</code></td>
<td>
<p>Only used if Boot.inference is TRUE. Number of bootstrap resamples. Default is 500.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_bootid">bootID</code></td>
<td>
<p>Only used if Boot.inference is TRUE. matrix where each row provides the ID of the observations selected in each bootstrap resample. Default is NULL, in which case these are defined internally.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_seed.boot">seed.boot</code></td>
<td>
<p>Only used if Boot.inference is TRUE. Should a specific seed be used in the definition of the folds. Default value is NULL in which case no seed is imposed.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_lr">LR</code></td>
<td>
<p>Estimation on the original sample. Output of a call to <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code> or <code><a href="#topic+PLR.wrap">PLR.wrap</a></code>.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_lr.boot">LR.boot</code></td>
<td>
<p>Estimation on the bootstrap resamples. In the non-penalized case, it is the output of a call to <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>. In the penalized case, it is a list of size length(h.grid), where each element is the output of a call to <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code> and uses a different value of the bandwidth.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_...">...</code></td>
<td>
<p>Additional parameters corresponding to arguments passed in <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code> or <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code> depending on the argument chosen in penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the Non-penalized Lorenz Regression, a list with the following elements :
</p>

<dl>
<dt><code>theta</code></dt><dd><p>the estimated vector of parameters.</p>
</dd>
<dt><code>pval.theta</code></dt><dd><p>Only returned if Boot.inference is TRUE. the pvalues associated to each element of the parameter vector.</p>
</dd>
<dt><code>summary</code></dt><dd><p>a vector including the estimated explained Gini coefficient and the Lorenz-<code class="reqn">R^2</code>.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>the estimated explained Gini coefficient</p>
</dd>
<dt><code>LR2</code></dt><dd><p>the Lorenz-<code class="reqn">R^2</code> of the regression.</p>
</dd>
<dt><code>MRS</code></dt><dd><p>the matrix of estimated marginal rates of substitution. More precisely, if we want the MRS of X1 (numerator) with respect to X2 (denominator),
we should look for row corresponding to X1 and column corresponding to X2.</p>
</dd>
<dt><code>Fit</code></dt><dd><p>A data frame containing the response (first column) and the estimated index (second column).</p>
</dd>
<dt><code>Gi.star</code></dt><dd><p>Only returned if Boot.inference is TRUE. A vector gathering the bootstrap estimators of the explained Gini coefficient.</p>
</dd>
<dt><code>LR2.star</code></dt><dd><p>Only returned if Boot.inference is TRUE. A vector gathering the bootstrap estimators of the Lorenz-<code class="reqn">R^2</code>.</p>
</dd>
<dt><code>theta.star</code></dt><dd><p>Only returned if Boot.inference is TRUE. A matrix gathering the bootstrap estimators of theta (rows refer to bootstrap iterations and columns refer to the different coefficients)</p>
</dd></dl>
<p>.

For the Penalized Lorenz Regression, a list with the following elements.
</p>

<dl>
<dt><code>path</code></dt><dd><p>a list where the different elements correspond to the values of h.grid. Each element is a matrix where the first line displays the path of regularization parameters. The second and third lines display the evolution of the Lorenz-<code class="reqn">R^2</code> and explained Gini coefficient along that path. The next lines display the evolution of the scores of the methods chosen in sel.choice. The remaining lines display the evolution of the estimated parameter vector.</p>
</dd>
<dt><code>theta</code></dt><dd><p>a matrix where the different lines correspond to the methods chosen in sel.choice. Each line provides the estimated vector of parameters at the optimal value of the regularization parameter.</p>
</dd>
<dt><code>summary</code></dt><dd><p>a matrix where the different lines correspond to the methods chosen in sel.choice. Each line provides the estimated explained Gini coefficient, the Lorenz-<code class="reqn">R^2</code>, the optimal lambda, the optimal bandwidth, the number of selected variables and the scores at the optimal value of the regularization parameter.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>a vector providing the estimated explained Gini coefficient at the optimal value of the regularization parameter for each method in sel.choice.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>a vector providing the Lorenz-<code class="reqn">R^2</code> at the optimal value of the regularization parameter for each method in sel.choice.</p>
</dd>
<dt><code>MRS</code></dt><dd><p>a list where the different elements correspond to a method in sel.choice. Each element is a matrix of estimated marginal rates of substitution for non-zero coefficients at the optimal value of the regularization parameter.</p>
</dd>
<dt><code>Fit</code></dt><dd><p>A data frame containing the response (first column). The remaining columns give the estimated index at the optimal value of the regularization parameter, for each method chosen in sel.choice.</p>
</dd>
<dt><code>which.h</code></dt><dd><p>a vector providing the index of the optimal bandwidth for each method in sel.choice.</p>
</dd>
<dt><code>which.lambda</code></dt><dd><p>a vector providing the index of the optimal lambda for each method in sel.choice.</p>
</dd>
<dt><code>Gi.star</code></dt><dd><p>Only returned if Boot.inference is TRUE. A list (each element a different value of the bandwidth h) of lists (each element a different value of the penalty parameter) of vectors (each element a bootstrap iteration) gathering the bootstrap estimators of the explained Gini coefficient.</p>
</dd>
<dt><code>LR2.star</code></dt><dd><p>Only returned if Boot.inference is TRUE. Similarly for the Lorenz-<code class="reqn">R^2</code></p>
</dd>
<dt><code>theta.star</code></dt><dd><p>Only returned if Boot.inference is TRUE. A list (each element a different value of the bandwidth h) of lists (each element a different value of the penalty parameter) of matrices (rows are bootstrap iterations and columns refer to the coefficients) gathering the bootstrap estimators of theta.</p>
</dd>
</dl>

<p>In both cases, the list also technical information, namely the formula, data, weights and call.
</p>


<h3>References</h3>

<p>Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. <em>Computational Statistics &amp; Data Analysis 167(C)</em>.
Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2022). A penalised bootstrap estimation procedure for the explained Gini coefficient.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>, <code><a href="#topic+PLR.wrap">PLR.wrap</a></code>, <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
set.seed(123)
Data &lt;- Data.Incomes[sample(1:nrow(Data.Incomes),50),]
# 1. Non-penalized regression
NPLR &lt;- Lorenz.Reg(Income ~ ., data = Data, penalty = "none",
                   popSize = 30)
# 2. Penalized regression
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data, penalty = "SCAD",
                  h.grid = nrow(Data.Incomes)^(-1/5.5),
                  sel.choice = c("BIC","CV"), eps = 0.01, nfolds = 5)
# Comparison
NPLR$theta;PLR$theta
NPLR$summary;PLR$summary

</code></pre>

<hr>
<h2 id='Lorenz.SCADFABS'>Solves the Penalized Lorenz Regression with SCAD penalty</h2><span id='topic+Lorenz.SCADFABS'></span>

<h3>Description</h3>

<p><code>Lorenz.SCADFABS</code> solves the penalized Lorenz regression with SCAD penalty on a grid of lambda values.
For each value of lambda, the function returns estimates for the vector of parameters and for the estimated explained Gini coefficient, as well as the Lorenz-<code class="reqn">R^2</code> of the regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.SCADFABS(
  YX_mat,
  weights = NULL,
  h,
  eps,
  a = 3.7,
  iter = 10^4,
  lambda = "Shi",
  lambda.min = 1e-07,
  gamma = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lorenz.SCADFABS_+3A_yx_mat">YX_mat</code></td>
<td>
<p>a matrix with the first column corresponding to the response vector, the remaining ones being the explanatory variables.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel, determining the smoothness of the approximation of the indicator function.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_eps">eps</code></td>
<td>
<p>step size in the FABS algorithm.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_a">a</code></td>
<td>
<p>parameter of the SCAD penalty. Default value is 3.7.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations. Default value is 10^4.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_lambda">lambda</code></td>
<td>
<p>this parameter relates to the regularization parameter. Several options are available.
</p>

<dl>
<dt><code>grid</code></dt><dd><p>If lambda=&quot;grid&quot;, lambda is defined on a grid, equidistant in the logarithmic scale.</p>
</dd>
<dt><code>Shi</code></dt><dd><p>If lambda=&quot;Shi&quot;, lambda, is defined within the algorithm, as in Shi et al (2018).</p>
</dd>
<dt><code>supplied</code></dt><dd><p>If the user wants to supply the lambda vector himself</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_lambda.min">lambda.min</code></td>
<td>
<p>lower bound of the penalty parameter. Only used if lambda=&quot;Shi&quot;.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_gamma">gamma</code></td>
<td>
<p>value of the Lagrange multiplier in the loss function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regression is solved using the SCAD-FABS algorithm developed by Jacquemain et al and adapted to our case.
For a comprehensive explanation of the Penalized Lorenz Regression, see Heuchenne et al.
In order to ensure identifiability, theta is forced to have a L2-norm equal to one.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<dl>
<dt><code>iter</code></dt><dd><p>number of iterations attained by the algorithm.</p>
</dd>
<dt><code>direction</code></dt><dd><p>vector providing the direction (-1 = backward step, 1 = forward step) for each iteration.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>value of the regularization parameter for each iteration.</p>
</dd>
<dt><code>h</code></dt><dd><p>value of the bandwidth.</p>
</dd>
<dt><code>theta</code></dt><dd><p>matrix where column i provides the non-normalized estimated parameter vector for iteration i.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>vector where element i provides the Lorenz-<code class="reqn">R^2</code> of the regression for iteration i.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>vector where element i provides the estimated explained Gini coefficient for iteration i.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2022). A penalised bootstrap estimation procedure for the explained Gini coefficient.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+PLR.wrap">PLR.wrap</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
YX_mat &lt;- Data.Incomes[,-2]
Lorenz.SCADFABS(YX_mat, h = nrow(Data.Incomes)^(-1/5.5), eps = 0.005)

</code></pre>

<hr>
<h2 id='LorenzRegression'>LorenzRegression : A package to estimate and interpret Lorenz regressions</h2><span id='topic+LorenzRegression'></span>

<h3>Description</h3>

<p>The <code>LorenzRegression</code> package proposes a toolbox to estimate, produce inference on and interpret Lorenz regressions.
As argued in Heuchenne and Jacquemain (2020), these regressions are used to determine the explanatory power of a set of covariates on the inequality of a response variable.
In a nutshell, each variable is given a weight in order to maximize the concentration index of the response with respect to a weighted sum of the covariates.
The obtained concentration index is called the explained Gini coefficient. If a single-index model with increasing link function is assumed, the explained Gini boils down to the Gini coefficient of the fitted part of the model.
This package rests on two main functions: <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code> for the estimation process and <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code> for more complete inference (tests and confidence intervals).
</p>


<h3>Details</h3>

<p>We direct the user to Heuchenne and Jacquemain (2020) for a rigorous exposition of the methodology and to the vignette <a href="../doc/Vignette.html">Learning Lorenz regressions with examples</a> for a motivational introduction of the <code>LorenzRegression</code> package.
</p>


<h3>References</h3>

<p>Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. <em>Computational Statistics &amp; Data Analysis 167(C)</em>.
</p>

<hr>
<h2 id='plot.LR'>Plots for the Unpenalized Lorenz Regression</h2><span id='topic+plot.LR'></span>

<h3>Description</h3>

<p><code>plot.LR</code> provides plots for an object of class <code>LR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.LR_+3A_x">x</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty=="none"</code>.</p>
</td></tr>
<tr><td><code id="plot.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Lorenz curve of the response and concentration curve of the response with respect to the estimated index
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
NPLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "none")
plot(NPLR)

</code></pre>

<hr>
<h2 id='plot.PLR'>Plots for the Penalized Lorenz Regression</h2><span id='topic+plot.PLR'></span>

<h3>Description</h3>

<p><code>plot.PLR</code> provides plots for an object of class <code>PLR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PLR_+3A_x">x</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty!="none"</code>.</p>
</td></tr>
<tr><td><code id="plot.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three types of plots
The first is the Lorenz curve of the response and concentration curves of the response with respect to the estimated index (obtained with each selection method).
In each of the remaining graphs, the horizontal axis is -log(lambda), lambda being the value of the regularization parameter.
The second type of plot is a traceplot, where the vertical axis gives the size of the coefficient attached to each covariate.
The third type of plot shows the evolution of the score(s) for each of the selection method chosen in the <code>PLR</code> object.
For comparability reasons, the scores are normalized such that  the larger the better and the optimum is attained in 1.
Since the whole path depends on the chosen bandwidth for the kernel, and the optimal bandwidth may depend on the selection method, the plots are produced for each selection method used in the PLR object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "SCAD",
                  sel.choice = c("BIC","CV"), h.grid = nrow(Data.Incomes)^(-1/5.5),
                  eps = 0.01, seed.CV = 123, nfolds = 5)
plot(PLR)

</code></pre>

<hr>
<h2 id='PLR.BIC'>Determines the regularization parameter (lambda) in a PLR via optimization of an information criterion.</h2><span id='topic+PLR.BIC'></span>

<h3>Description</h3>

<p><code>PLR.BIC</code> takes as input a matrix of estimated parameter vectors, where each row corresponds to a covariate and each column corresponds to a value of lambda,
and returns the index of the optimal column by optimizing an information criterion. By default the BIC is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR.BIC(YX_mat, theta, weights = NULL, IC = c("BIC", "AIC"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLR.BIC_+3A_yx_mat">YX_mat</code></td>
<td>
<p>A matrix with the first column corresponding to the response vector, the remaining ones being the explanatory variables.</p>
</td></tr>
<tr><td><code id="PLR.BIC_+3A_theta">theta</code></td>
<td>
<p>matrix gathering the path of estimated parameter vectors. Each row corresponds to a given covariate. Each column corresponds to a given value of lambda</p>
</td></tr>
<tr><td><code id="PLR.BIC_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="PLR.BIC_+3A_ic">IC</code></td>
<td>
<p>indicates which information criterion is used. Possibles values are &quot;BIC&quot; (default) or &quot;AIC&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components
</p>

<dl>
<dt><code>val</code></dt><dd><p>vector indicating the value attained by the information criterion for each value of lambda.</p>
</dd>
<dt><code>best</code></dt><dd><p>index of the value of lambda where the optimum is attained.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2022). A penalised bootstrap estimation procedure for the explained Gini coefficient.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+PLR.wrap">PLR.wrap</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
YX_mat &lt;- Data.Incomes[,-2]
PLR &lt;- PLR.wrap(YX_mat, h = nrow(YX_mat)^(-1/5.5), eps = 0.005)
PLR.BIC(YX_mat, PLR$theta)

</code></pre>

<hr>
<h2 id='PLR.CV'>Determines the regularization parameter (lambda) in a PLR via cross-validation</h2><span id='topic+PLR.CV'></span>

<h3>Description</h3>

<p><code>PLR.CV</code> undertakes k-fold cross-validation for a Penalized Lorenz Regression. It returns the CV-score associated to each value of the regularization parameter and the index of the optimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR.CV(
  formula,
  data,
  penalty = "SCAD",
  h,
  PLR.est = NULL,
  standardize = TRUE,
  weights = NULL,
  eps,
  nfolds = 10,
  foldID = NULL,
  seed.CV = NULL,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLR.CV_+3A_formula">formula</code></td>
<td>
<p>A formula object of the form <em>response</em> ~ <em>other_variables</em>.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables displayed in the formula.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_penalty">penalty</code></td>
<td>
<p>penalty used in the Penalized Lorenz Regression. Possible values are &quot;SCAD&quot; (default) or &quot;LASSO&quot;.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel, determining the smoothness of the approximation of the indicator function.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_plr.est">PLR.est</code></td>
<td>
<p>Output of a call to <code><a href="#topic+PLR.wrap">PLR.wrap</a></code> corresponding to the estimation of the Penalized Lorenz Regression on the full sample. Default value is NULL in which case the estimation on the full sample is run internally.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_standardize">standardize</code></td>
<td>
<p>Should the variables be standardized before the estimation process? Default value is TRUE.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_eps">eps</code></td>
<td>
<p>Step size in the FABS or SCADFABS algorithm. Default value is 0.005.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds. Default value is 10.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_foldid">foldID</code></td>
<td>
<p>vector taking value from 1 to nfolds specifying the fold index of each observation. Default value is NULL in which case the folds are defined internally.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_seed.cv">seed.CV</code></td>
<td>
<p>Should a specific seed be used in the definition of the folds. Default value is NULL in which case no seed is imposed.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_parallel">parallel</code></td>
<td>
<p>Whether parallel computing should be used to distribute the <code>nfolds</code> computations on different CPUs. Either a logical value determining whether parallel computing is used (TRUE) or not (FALSE, the default value). Or a numerical value determining the number of cores to use.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_...">...</code></td>
<td>
<p>Additional parameters corresponding to arguments passed in <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code> or <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code> depending on the argument chosen in penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components
</p>

<dl>
<dt><code>val</code></dt><dd><p>vector indicating the CV-score for each value of lambda.</p>
</dd>
<dt><code>best</code></dt><dd><p>index where the optimum is attained.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2022). A penalised bootstrap estimation procedure for the explained Gini coefficient.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+PLR.wrap">PLR.wrap</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>YX_mat &lt;- Data.Incomes[,-2]
PLR &lt;- PLR.wrap(YX_mat, h = nrow(YX_mat)^(-1/5.5), eps=0.01)
PLR.CV(Income ~ ., Data.Incomes, PLR.est = PLR,
       h = nrow(Data.Incomes)^(-1/5.5), eps = 0.01, nfolds = 5)

</code></pre>

<hr>
<h2 id='PLR.normalize'>Re-normalizes the estimated coefficients of a penalized Lorenz regression</h2><span id='topic+PLR.normalize'></span>

<h3>Description</h3>

<p><code>PLR.normalize</code> transforms the estimated coefficients of a penalized Lorenz regression to match the model where the first category of each categorical variable is omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR.normalize(PLR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLR.normalize_+3A_plr">PLR</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty!="none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of re-normalized coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "SCAD",
                  sel.choice = c("BIC","CV"), h.grid = nrow(Data.Incomes)^(-1/5.5),
                  eps = 0.01, seed.CV = 123, nfolds = 5)
PLR.normalize(PLR)

</code></pre>

<hr>
<h2 id='PLR.wrap'>Wrapper for the <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code> and <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code> functions</h2><span id='topic+PLR.wrap'></span>

<h3>Description</h3>

<p><code>PLR.wrap</code> standardizes the covariates, run the penalized regression and spits out the path of parameter vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR.wrap(
  YX_mat,
  standardize = TRUE,
  weights = NULL,
  penalty = c("SCAD", "LASSO"),
  h,
  eps = 0.005,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLR.wrap_+3A_yx_mat">YX_mat</code></td>
<td>
<p>a matrix with the first column corresponding to the response vector, the remaining ones being the explanatory variables.</p>
</td></tr>
<tr><td><code id="PLR.wrap_+3A_standardize">standardize</code></td>
<td>
<p>Should the variables be standardized before the estimation process? Default value is TRUE.</p>
</td></tr>
<tr><td><code id="PLR.wrap_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="PLR.wrap_+3A_penalty">penalty</code></td>
<td>
<p>penalty used in the Penalized Lorenz Regression. Possible values are &quot;SCAD&quot; (default) or &quot;LASSO&quot;.</p>
</td></tr>
<tr><td><code id="PLR.wrap_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel, determining the smoothness of the approximation of the indicator function.</p>
</td></tr>
<tr><td><code id="PLR.wrap_+3A_eps">eps</code></td>
<td>
<p>Only used if penalty=&quot;SCAD&quot; or penalty=&quot;LASSO&quot;. Step size in the FABS or SCADFABS algorithm. Default value is 0.005.</p>
</td></tr>
<tr><td><code id="PLR.wrap_+3A_...">...</code></td>
<td>
<p>Additional parameters corresponding to arguments passed in <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code> or <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code> depending on the argument chosen in penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with several components:
</p>

<dl>
<dt><code>lambda</code></dt><dd><p>vector gathering the different values of the regularization parameter</p>
</dd>
<dt><code>theta</code></dt><dd><p>matrix where column i provides the normalized estimated parameter vector corresponding to value lambda[i] of the regularization parameter.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>vector where element i provides the Lorenz-<code class="reqn">R^2</code> of the regression related to value lambda[i] of the regularization parameter.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>vector where element i provides the estimated explained Gini coefficient related to value lambda[i] of the regularization parameter.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
YX_mat &lt;- Data.Incomes[,-2]
PLR.wrap(YX_mat, h = nrow(Data.Incomes)^(-1/5.5), eps = 0.005)

</code></pre>

<hr>
<h2 id='print.LR'>Printing method for the Lorenz Regression</h2><span id='topic+print.LR'></span>

<h3>Description</h3>

<p><code>print.LR</code> prints the arguments and estimated coefficients of an object of class <code>LR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.LR_+3A_x">x</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty="none"</code>.</p>
</td></tr>
<tr><td><code id="print.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for printing an object of class <code>LR</code> to the console
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
NPLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "none")
print(NPLR)

</code></pre>

<hr>
<h2 id='print.PLR'>Printing method for the Penalized Lorenz Regression</h2><span id='topic+print.PLR'></span>

<h3>Description</h3>

<p><code>print.PLR</code> prints the arguments and estimated coefficients of an object of class <code>PLR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PLR_+3A_x">x</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty!="none"</code>.</p>
</td></tr>
<tr><td><code id="print.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for printing an object of class <code>PLR</code> to the console
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "SCAD",
                  sel.choice = c("BIC","CV"), h.grid = nrow(Data.Incomes)^(-1/5.5),
                  eps = 0.01, seed.CV = 123, nfolds = 5)
print(PLR)

</code></pre>

<hr>
<h2 id='Rearrangement.estimation'>Estimates a monotonic regression curve via Chernozhukov et al (2009)</h2><span id='topic+Rearrangement.estimation'></span>

<h3>Description</h3>

<p><code>Rearrangement.estimation</code> estimates the increasing link function of a single index model via the methodology proposed in Chernozhukov et al (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rearrangement.estimation(Y, Index, t = Index, weights = NULL, degree.pol = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rearrangement.estimation_+3A_y">Y</code></td>
<td>
<p>The response variable.</p>
</td></tr>
<tr><td><code id="Rearrangement.estimation_+3A_index">Index</code></td>
<td>
<p>The estimated index. The user may obtain it using function <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>.</p>
</td></tr>
<tr><td><code id="Rearrangement.estimation_+3A_t">t</code></td>
<td>
<p>A vector of points over which the link function <code class="reqn">H(.)</code> should be estimated. Default is the estimated index.</p>
</td></tr>
<tr><td><code id="Rearrangement.estimation_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Rearrangement.estimation_+3A_degree.pol">degree.pol</code></td>
<td>
<p>degree of the polynomial used in the local polynomial regression. Default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A first estimator of the link function, neglecting the assumption of monotonicity, is obtained with function <code><a href="locpol.html#topic+locpol">locpol</a></code> from the <em>locpol</em> package.
The final estimator is obtained through the rearrangement operation explained in Chernozhukov et al (2009). This operation is carried out with function <code><a href="Rearrangement.html#topic+rearrangement">rearrangement</a></code> from package <code>Rearrangement</code>.
</p>


<h3>Value</h3>

<p>A list with the following components
</p>

<dl>
<dt><code>t</code></dt><dd><p>the points over which the estimation has been undertaken.</p>
</dd>
<dt><code>H</code></dt><dd><p>the estimated link function evaluated at <em>t</em>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chernozhukov, V., I. Fernández-Val, and A. Galichon (2009). Improving Point and Interval Estimators of Monotone Functions by Rearrangement. <em>Biometrika 96 (3)</em>. 559–75.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="locpol.html#topic+locpol">locpol</a></code>, <code><a href="Rearrangement.html#topic+rearrangement">rearrangement</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "SCAD",
                  h.grid = nrow(Data.Incomes)^(-1/5.5), eps = 0.01)
Y &lt;- PLR$Fit[,1]
Index &lt;- PLR$Fit[,2]
Rearrangement.estimation(Y = Y, Index = Index)

</code></pre>

<hr>
<h2 id='summary.LR'>Summary for the Lorenz Regression</h2><span id='topic+summary.LR'></span>

<h3>Description</h3>

<p><code>summary.LR</code> provides a summary for an object of class <code>LR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.LR_+3A_object">object</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty=="none"</code>.</p>
</td></tr>
<tr><td><code id="summary.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary displaying the explained Gini coefficient, Lorenz-<code class="reqn">R^2</code> and a table gathering the estimated coefficients, including p-values if bootstrap was performed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
NPLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "none")
summary(NPLR)

</code></pre>

<hr>
<h2 id='summary.PLR'>Summary for the Penalized Lorenz Regression</h2><span id='topic+summary.PLR'></span>

<h3>Description</h3>

<p><code>summary.PLR</code> provides a summary for an object of class <code>PLR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
summary(object, renormalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PLR_+3A_object">object</code></td>
<td>
<p>Output of a call to <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, where <code>penalty!="none"</code>.</p>
</td></tr>
<tr><td><code id="summary.PLR_+3A_renormalize">renormalize</code></td>
<td>
<p>whether the coefficient vector should be re-normalized to match the representation where the first category of each categorical variable is omitted. Default value is TRUE</p>
</td></tr>
<tr><td><code id="summary.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary displaying two tables: a summary of the model and the estimated coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "SCAD",
                  sel.choice = c("BIC","CV"), h.grid = nrow(Data.Incomes)^(-1/5.5),
                  eps = 0.01, seed.CV = 123, nfolds = 5)
summary(PLR)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
