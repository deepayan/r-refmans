<!DOCTYPE html><html lang="en"><head><title>Help for package LorenzRegression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LorenzRegression}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LorenzRegression-package'><p>LorenzRegression : A package to estimate and interpret Lorenz regressions</p></a></li>
<li><a href='#.Fitness_cpp'><p>Computes the fitness used in the GA</p></a></li>
<li><a href='#autoplot.LR'><p>Plots for the Lorenz regression</p></a></li>
<li><a href='#autoplot.PLR'><p>Plots for the penalized Lorenz regression</p></a></li>
<li><a href='#coef.LR'><p>Estimated coefficients for the Lorenz regression</p></a></li>
<li><a href='#coef.PLR'><p>Estimated coefficients for the penalized Lorenz regression</p></a></li>
<li><a href='#confint.LR_boot'><p>Confidence intervals for the Lorenz regression</p></a></li>
<li><a href='#confint.PLR_boot'><p>Confidence intervals for the penalized Lorenz regression</p></a></li>
<li><a href='#Data.Incomes'><p>Simulated income data</p></a></li>
<li><a href='#diagnostic.PLR'><p>Diagnostic for the penalized Lorenz regression</p></a></li>
<li><a href='#Gini.coef'><p>Concentration index of <em>y</em> with respect to <em>x</em></p></a></li>
<li><a href='#ineqExplained'><p>Retrieve a measure of explained inequality from a model</p></a></li>
<li><a href='#ineqExplained.LR'><p>Explained inequality metrics for the Lorenz regression</p></a></li>
<li><a href='#ineqExplained.PLR'><p>Explained inequality metrics for the penalized Lorenz regression</p></a></li>
<li><a href='#Lorenz.boot'><p>Bootstrap for the (penalized) Lorenz regression</p></a></li>
<li><a href='#Lorenz.boot.combine'><p>Combines bootstrap Lorenz regressions</p></a></li>
<li><a href='#Lorenz.curve'><p>Concentration curve of <em>y</em> with respect to <em>x</em></p></a></li>
<li><a href='#Lorenz.FABS'><p>Estimates the parameter vector in a penalized Lorenz regression with lasso penalty</p></a></li>
<li><a href='#Lorenz.GA'><p>Estimates the parameter vector in Lorenz regression using a genetic algorithm</p></a></li>
<li><a href='#Lorenz.ga.call'><p>Call to the genetic algorithm for the Lorenz regression</p></a></li>
<li><a href='#Lorenz.graphs'><p>Graphs of concentration curves</p></a></li>
<li><a href='#Lorenz.Population'><p>Defines the population used in the genetic algorithm</p></a></li>
<li><a href='#Lorenz.Reg'><p>Fits a Lorenz regression</p></a></li>
<li><a href='#Lorenz.SCADFABS'><p>Estimates the parameter vector in a penalized Lorenz regression with SCAD penalty</p></a></li>
<li><a href='#model_matrix_PLR'><p>Design matrix in the Penalized Lorenz Regression</p></a></li>
<li><a href='#PLR.BIC'><p>Determines the regularization parameter (lambda) in a PLR via optimization of an information criterion.</p></a></li>
<li><a href='#PLR.CV'><p>Cross-validation for penalized Lorenz regression</p></a></li>
<li><a href='#PLR.normalize'><p>Re-normalizes the estimated coefficients of a penalized Lorenz regression</p></a></li>
<li><a href='#PLR.scores'><p>Computes Gini scores for the Penalized Lorenz Regression</p></a></li>
<li><a href='#predict.LR'><p>Prediction and fitted values for the Lorenz regression</p></a></li>
<li><a href='#predict.PLR'><p>Prediction and fitted values for the penalized Lorenz regression</p></a></li>
<li><a href='#print.LR'><p>Printing method for the Lorenz regression</p></a></li>
<li><a href='#print.PLR'><p>Printing method for the penalized Lorenz regression</p></a></li>
<li><a href='#print.summary.LR'><p>Printing method for the summary of a Lorenz regression</p></a></li>
<li><a href='#print.summary.PLR'><p>Printing method for the summary of a penalized Lorenz regression</p></a></li>
<li><a href='#Rearrangement.estimation'><p>Estimates a monotonic regression curve via Chernozhukov et al (2009)</p></a></li>
<li><a href='#runif_seed'><p>Generates a sample of uniform random variables with a specific seed</p></a></li>
<li><a href='#summary.LR'><p>Summary for the Lorenz regression</p></a></li>
<li><a href='#summary.PLR'><p>Summary for the penalized Lorenz regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Lorenz and Penalized Lorenz Regressions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Inference for the Lorenz and penalized Lorenz regressions. More broadly, the package proposes functions to assess inequality and graphically represent it. The Lorenz Regression procedure is introduced in Heuchenne and Jacquemain (2022) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2021.107347">doi:10.1016/j.csda.2021.107347</a>&gt; and in Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024) &lt;<a href="https://doi.org/10.1214%2F23-EJS2200">doi:10.1214/23-EJS2200</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.1)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2, scales, parsnip, boot, rsample, parallel,
doParallel, foreach, MASS, GA, locpol, Rearrangement, Rcpp (&ge;
0.11.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AlJacq/LorenzRegression">https://github.com/AlJacq/LorenzRegression</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AlJacq/LorenzRegression/issues">https://github.com/AlJacq/LorenzRegression/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-11 14:05:20 UTC; Jacquemain</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexandre Jacquemain
    <a href="https://orcid.org/0000-0001-9349-780X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Xingjie Shi [ctb] (Author of an R implementation of the FABS algorithm
    available at https://github.com/shuanggema/Fabs, of which function
    Lorenz.FABS is derived)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexandre Jacquemain &lt;aljacquemain@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-11 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='LorenzRegression-package'>LorenzRegression : A package to estimate and interpret Lorenz regressions</h2><span id='topic+LorenzRegression'></span><span id='topic+LorenzRegression-package'></span>

<h3>Description</h3>

<p>The <code>LorenzRegression</code> package proposes a toolbox to estimate, produce inference on and interpret Lorenz regressions.
As argued in Heuchenne and Jacquemain (2020) and Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024), these regressions are used to determine the explanatory power of a set of covariates on the inequality of a response variable.
In a nutshell, each variable is given a weight in order to maximize the concentration index of the response with respect to a weighted sum of the covariates.
The obtained concentration index is called the explained Gini coefficient. If a single-index model with increasing link function is assumed, the explained Gini boils down to the Gini coefficient of the fitted part of the model.
This package rests on two main functions: <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code> for the estimation process and <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code> for more complete inference (tests and confidence intervals).
</p>


<h3>Details</h3>

<p>We direct the user to Heuchenne and Jacquemain (2020) and Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024) for a rigorous exposition of the methodology and to the vignette <a href="../doc/Vignette.html">Learning Lorenz regressions with examples</a> for a motivational introduction of the <code>LorenzRegression</code> package.
</p>


<h3>References</h3>

<p>Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. <em>Computational Statistics &amp; Data Analysis 167(C)</em>.
Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024). A penalised bootstrap estimation procedure for the explained Gini coefficient. <em>Electronic Journal of Statistics 18(1) 247-300</em>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alexandre Jacquemain <a href="mailto:aljacquemain@gmail.com">aljacquemain@gmail.com</a> (<a href="https://orcid.org/0000-0001-9349-780X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Xingjie Shi <a href="mailto:xingjieshi@njue.edu.cn">xingjieshi@njue.edu.cn</a> (Author of an R implementation of the FABS algorithm available at https://github.com/shuanggema/Fabs, of which function Lorenz.FABS is derived) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/AlJacq/LorenzRegression">https://github.com/AlJacq/LorenzRegression</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/AlJacq/LorenzRegression/issues">https://github.com/AlJacq/LorenzRegression/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.Fitness_cpp'>Computes the fitness used in the GA</h2><span id='topic+.Fitness_cpp'></span>

<h3>Description</h3>

<p>Computes the fitness of a candidate in the genetic algorithm displayed in function Lorenz.GA.cpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.Fitness_cpp(x, Y, X, Z, pi, tolerance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".Fitness_cpp_+3A_x">x</code></td>
<td>
<p>vector of size (p-1) giving the proposed candidate, where p is the number of covariates</p>
</td></tr>
<tr><td><code id=".Fitness_cpp_+3A_y">Y</code></td>
<td>
<p>vector of size n gathering the response, where n is the sample size</p>
</td></tr>
<tr><td><code id=".Fitness_cpp_+3A_x">X</code></td>
<td>
<p>matrix of dimension (n*p) gathering the covariates</p>
</td></tr>
<tr><td><code id=".Fitness_cpp_+3A_z">Z</code></td>
<td>
<p>vector of size n gathering iid repetitions of a U[0,1]</p>
</td></tr>
<tr><td><code id=".Fitness_cpp_+3A_pi">pi</code></td>
<td>
<p>vector of size n gathering the observation weights (notice that sum(pi)=1)</p>
</td></tr>
<tr><td><code id=".Fitness_cpp_+3A_tolerance">tolerance</code></td>
<td>
<p>A small positive number used to determine the threshold for considering two floating-point numbers as equal. This is primarily used to
address issues with floating-point precision when comparing values that should theoretically be identical but may differ slightly due to numerical inaccuracies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitness of candidate x
</p>

<hr>
<h2 id='autoplot.LR'>Plots for the Lorenz regression</h2><span id='topic+autoplot.LR'></span><span id='topic+plot.LR'></span><span id='topic+autoplot.LR_boot'></span><span id='topic+plot.LR_boot'></span>

<h3>Description</h3>

<p><code>autoplot</code> generates a plot for an object of class <code>"LR"</code> and returns it as a <code>ggplot</code> object.
The <code>plot</code> method is a wrapper around <code>autoplot</code> that directly displays the plot,
providing a more familiar interface for users accustomed to base R plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
autoplot(object, ...)

## S3 method for class 'LR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.LR_+3A_object">object</code></td>
<td>
<p>An object of class <code>"LR"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+Lorenz.graphs">Lorenz.graphs</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.LR_+3A_x">x</code></td>
<td>
<p>An object of class <code>"LR"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>autoplot</code> returns a <code>ggplot</code> object representing the Lorenz curve of the response and the concentration curve of the response with respect to the estimated index. <code>plot</code> directly displays this plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg)

</code></pre>

<hr>
<h2 id='autoplot.PLR'>Plots for the penalized Lorenz regression</h2><span id='topic+autoplot.PLR'></span><span id='topic+plot.PLR'></span><span id='topic+autoplot.PLR_boot'></span><span id='topic+plot.PLR_boot'></span><span id='topic+autoplot.PLR_cv'></span><span id='topic+plot.PLR_cv'></span>

<h3>Description</h3>

<p><code>autoplot</code> generates summary plots for an object of class <code>"PLR"</code> and returns them as <code>ggplot</code> objects.
The <code>plot</code> method is a wrapper around <code>autoplot</code> that directly displays the plot,
providing a more familiar interface for users accustomed to base R plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
autoplot(
  object,
  type = c("explained", "traceplot", "diagnostic"),
  traceplot.which = "BIC",
  score.df = NULL,
  ...
)

## S3 method for class 'PLR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.PLR_+3A_object">object</code></td>
<td>
<p>An object of class <code>"PLR"</code>. The object might also have S3 classes <code>"PLR_boot"</code> and/or <code>"PLR_cv"</code> (both inherit from class <code>"PLR"</code>)</p>
</td></tr>
<tr><td><code id="autoplot.PLR_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of plot. Possible values are <code>"explained"</code>, <code>"traceplot"</code> and <code>"diagnostic"</code>.
</p>

<ul>
<li><p> If <code>"explained"</code> is selected, the graph displays the Lorenz curve of the response and concentration curve(s) of the response with respect to the estimated index. More specifically, there is one concentration curve per selection method available.
</p>
</li>
<li><p> If <code>"traceplot"</code> is selected, the graph displays a traceplot, where the horizontal axis is -log(lambda), lambda being the value of the penalty parameter. The vertical axis gives the value of the estimated coefficient attached to each covariate.
</p>
</li>
<li><p> If <code>"diagnostic"</code> is selected, the graph displays a faceted plot, where each facet corresponds to a different value of the grid parameter. Each plot shows the evolution of the scores of each available selection method. For comparability reasons, the scores are normalized such that the larger the better and the optimum is attained in 1.
</p>
</li></ul>
</td></tr>
<tr><td><code id="autoplot.PLR_+3A_traceplot.which">traceplot.which</code></td>
<td>
<p>This argument indicates the value of the grid parameter for which the traceplot should be produced (see arguments <code>grid.value</code> and <code>grid.arg</code> in function <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>).
It can be an integer indicating the index in the grid determined via <code>grid.value</code>.
Alternatively, it can be a character string indicating the selection method. In this case the index corresponds to the optimal value according to that selection method.</p>
</td></tr>
<tr><td><code id="autoplot.PLR_+3A_score.df">score.df</code></td>
<td>
<p>A data.frame providing the scores to be displayed if <code>type</code> is set to <code>"diagnostic"</code>. For internal use only.</p>
</td></tr>
<tr><td><code id="autoplot.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to function <code><a href="#topic+Lorenz.graphs">Lorenz.graphs</a></code></p>
</td></tr>
<tr><td><code id="autoplot.PLR_+3A_x">x</code></td>
<td>
<p>An object of class <code>"PLR"</code>. The object might also have S3 classes <code>"PLR_boot"</code> and/or <code>"PLR_cv"</code> (both inherit from class <code>"PLR"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available selection methods depend on the classes of the object: BIC is always available, bootstrap is available if <code>object</code> inherits from <code>"PLR_boot"</code>, cross-validation is available if <code>object</code> inherits from <code>"PLR_cv"</code>
</p>


<h3>Value</h3>

<p><code>autoplot</code> returns a <code>ggplot</code> object representing the desired graph. <code>plot</code> directly displays this plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg), example(Lorenz.boot) and example(PLR.CV)

</code></pre>

<hr>
<h2 id='coef.LR'>Estimated coefficients for the Lorenz regression</h2><span id='topic+coef.LR'></span><span id='topic+coef.LR_boot'></span>

<h3>Description</h3>

<p>Provides the estimated coefficients for an object of class <code>"LR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.LR_+3A_object">object</code></td>
<td>
<p>An object of S3 class <code>"LR"</code>.</p>
</td></tr>
<tr><td><code id="coef.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector gathering the estimated coefficients
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg)

</code></pre>

<hr>
<h2 id='coef.PLR'>Estimated coefficients for the penalized Lorenz regression</h2><span id='topic+coef.PLR'></span><span id='topic+coef.PLR_boot'></span><span id='topic+coef.PLR_cv'></span>

<h3>Description</h3>

<p>Provides the estimated coefficients for an object of class <code>"PLR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
coef(object, renormalize = TRUE, pars.idx = "BIC", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.PLR_+3A_object">object</code></td>
<td>
<p>An object of S3 class <code>"PLR"</code>. The object might also have S3 classes <code>"PLR_boot"</code> and/or <code>"PLR_cv"</code> (both inherit from class <code>"PLR"</code>)</p>
</td></tr>
<tr><td><code id="coef.PLR_+3A_renormalize">renormalize</code></td>
<td>
<p>A logical value determining whether the coefficient vector should be re-normalized to match the representation where the first category of each categorical variable is omitted. Default value is TRUE</p>
</td></tr>
<tr><td><code id="coef.PLR_+3A_pars.idx">pars.idx</code></td>
<td>
<p>What grid and penalty parameters should be used for parameter selection. Either a character string specifying the selection method, where the possible values are:
</p>

<ul>
<li> <p><code>"BIC"</code> (default) - Always available.
</p>
</li>
<li> <p><code>"Boot"</code> - Available if <code>object</code> inherits from <code>"PLR_boot"</code>.
</p>
</li>
<li> <p><code>"CV"</code> - Available if <code>object</code> inherits from <code>"PLR_cv"</code>.
</p>
</li></ul>

<p>Or a numeric vector of length 2, where the first element is the index of the grid parameter and the second is the index of the penalty parameter.</p>
</td></tr>
<tr><td><code id="coef.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector gathering the estimated coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg), example(Lorenz.boot) and example(PLR.CV)

</code></pre>

<hr>
<h2 id='confint.LR_boot'>Confidence intervals for the Lorenz regression</h2><span id='topic+confint.LR_boot'></span><span id='topic+confint.LR'></span>

<h3>Description</h3>

<p>Provides bootstrap confidence intervals for the explained Gini coefficient, Lorenz-R2 and theta vector for an object of class <code>"LR_boot"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR_boot'
confint(
  object,
  parm = c("Gini", "LR2", "theta"),
  level = 0.95,
  type = c("norm", "basic", "perc"),
  bias.corr = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.LR_boot_+3A_object">object</code></td>
<td>
<p>An object of class <code>"LR_boot"</code>. The current implementation requires bootstrap to construct confidence intervals. Hence, it is not sufficient that <code>object</code> inherits from <code>"LR"</code>.</p>
</td></tr>
<tr><td><code id="confint.LR_boot_+3A_parm">parm</code></td>
<td>
<p>A logical value determining whether the confidence interval is computed for the explained Gini coefficient, for the Lorenz-<code class="reqn">R^2</code> or for the vector of coefficients of the single-index model. Possible values are <code>"Gini"</code> (default, for the explained Gini),<code>"LR2"</code> (for the Lorenz-<code class="reqn">R^2</code>) and <code>"theta"</code> (for the index coefficients).</p>
</td></tr>
<tr><td><code id="confint.LR_boot_+3A_level">level</code></td>
<td>
<p>A numeric giving the level of the confidence interval. Default value is 0.95.</p>
</td></tr>
<tr><td><code id="confint.LR_boot_+3A_type">type</code></td>
<td>
<p>A character string specifying the bootstrap method. Possible values are <code>"norm"</code>, <code>"basic"</code> and <code>"perc"</code>. For more information, see the argument <code>type</code> of the function <code><a href="boot.html#topic+boot.ci">boot.ci</a></code> from the <em>boot</em> library.</p>
</td></tr>
<tr><td><code id="confint.LR_boot_+3A_bias.corr">bias.corr</code></td>
<td>
<p>A logical determining whether bias correction should be performed. Only used if <code>type="norm"</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="confint.LR_boot_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The desired confidence interval.
If <code>parm="Gini"</code> or <code>parm="LR2"</code>, the output is a vector.
If <code>parm="theta"</code>, it is a matrix where each row corresponds to a different coefficient.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>, <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.boot)

</code></pre>

<hr>
<h2 id='confint.PLR_boot'>Confidence intervals for the penalized Lorenz regression</h2><span id='topic+confint.PLR_boot'></span><span id='topic+confint.PLR'></span><span id='topic+confint.PLR_cv'></span>

<h3>Description</h3>

<p>Provides bootstrap confidence intervals for the explained Gini coefficient and Lorenz-<code class="reqn">R^2</code> for an object of class <code>"PLR_boot"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR_boot'
confint(
  object,
  parm = c("Gini", "LR2"),
  level = 0.95,
  type = c("norm", "basic", "perc"),
  pars.idx = "BIC",
  bias.corr = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.PLR_boot_+3A_object">object</code></td>
<td>
<p>An object of class <code>"PLR_boot"</code>. The object might also have S3 class <code>"PLR_cv"</code>. The current implementation requires bootstrap to construct confidence intervals. Hence, it is not sufficient that <code>object</code> inherits from <code>"PLR"</code>.</p>
</td></tr>
<tr><td><code id="confint.PLR_boot_+3A_parm">parm</code></td>
<td>
<p>A character string determining whether the confidence interval is computed for the explained Gini coefficient or for the Lorenz-<code class="reqn">R^2</code>. Possible values are <code>"Gini"</code> (default, for the explained Gini) and <code>"LR2"</code> (for the Lorenz-<code class="reqn">R^2</code>)</p>
</td></tr>
<tr><td><code id="confint.PLR_boot_+3A_level">level</code></td>
<td>
<p>A numeric giving the level of the confidence interval. Default value is 0.95.</p>
</td></tr>
<tr><td><code id="confint.PLR_boot_+3A_type">type</code></td>
<td>
<p>A character string specifying the bootstrap method. Possible values are <code>"norm"</code>, <code>"basic"</code> and <code>"perc"</code>. For more information, see the argument <code>type</code> of the function <code><a href="boot.html#topic+boot.ci">boot.ci</a></code> from the <em>boot</em> library.</p>
</td></tr>
<tr><td><code id="confint.PLR_boot_+3A_pars.idx">pars.idx</code></td>
<td>
<p>What grid and penalty parameters should be used for parameter selection. Either a character string specifying the selection method, where the possible values are:
</p>

<ul>
<li> <p><code>"BIC"</code> (default).
</p>
</li>
<li> <p><code>"Boot"</code>.
</p>
</li>
<li> <p><code>"CV"</code> - Available if <code>object</code> inherits from <code>"PLR_cv"</code>.
</p>
</li></ul>

<p>Or a numeric vector of length 2, where the first element is the index of the grid parameter and the second is the index of the penalty parameter.</p>
</td></tr>
<tr><td><code id="confint.PLR_boot_+3A_bias.corr">bias.corr</code></td>
<td>
<p>A logical determining whether bias correction should be performed. Only used if <code>type="norm"</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="confint.PLR_boot_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector providing the desired confidence interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>, <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.boot)

</code></pre>

<hr>
<h2 id='Data.Incomes'>Simulated income data</h2><span id='topic+Data.Incomes'></span>

<h3>Description</h3>

<p>Fictitious cross-sectional dataset used to illustrate the Lorenz regression methodology. It covers 7 variables for 200 individuals aged between 25 and 30 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Data.Incomes)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 7 columns:
</p>

<dl>
<dt>Income</dt><dd><p>Individual's labor income</p>
</dd>
<dt>Sex</dt><dd><p>Sex (0=Female, 1=Male)</p>
</dd>
<dt>Health.level</dt><dd><p>Variable ranging from 0 to 10 indicating the individual health's level (0 is worst, 10 is best)</p>
</dd>
<dt>Age</dt><dd><p>Individual's age in years, ranging from 25 to 30</p>
</dd>
<dt>Work.Hours</dt><dd><p>Individual's weekly work hours</p>
</dd>
<dt>Education</dt><dd><p>Individual's highest grade completed in years</p>
</dd>
<dt>Seniority</dt><dd><p>Length of service in years with the individual's employer</p>
</dd>
</dl>


<hr>
<h2 id='diagnostic.PLR'>Diagnostic for the penalized Lorenz regression</h2><span id='topic+diagnostic.PLR'></span>

<h3>Description</h3>

<p><code>diagnostic.PLR</code> provides diagnostic information for an object of class <code>"PLR"</code>
It restricts the path of the PLR to pairs of parameters (grid, lambda) that satisfy a threshold criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic.PLR(
  object,
  tol = 0.99,
  method = c("union", "intersect", "BIC", "Boot", "CV")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnostic.PLR_+3A_object">object</code></td>
<td>
<p>An object of class <code>"PLR"</code>.</p>
</td></tr>
<tr><td><code id="diagnostic.PLR_+3A_tol">tol</code></td>
<td>
<p>A numeric threshold value used to restrict the PLR path. More specifically, we restrict to pairs (grid,lambda) whose normalized score exceeds <code>tol</code>. Default value is 0.95.</p>
</td></tr>
<tr><td><code id="diagnostic.PLR_+3A_method">method</code></td>
<td>
<p>A character string specifying the method used to evaluate the scores.
Options are <code>"union"</code>, <code>"intersect"</code>, <code>"BIC"</code>, <code>"Boot"</code>, and <code>"CV"</code>.
</p>

<dl>
<dt>&quot;BIC&quot;</dt><dd><p>The score is the BIC-score.</p>
</dd>
<dt>&quot;Boot&quot;</dt><dd><p>The score is the OOB-score.</p>
</dd>
<dt>&quot;CV&quot;</dt><dd><p>The score is the CV-score.</p>
</dd>
<dt>&quot;union&quot;</dt><dd><p>The threshold requirement must be met for at least one of the selection methods available.</p>
</dd>
<dt>&quot;intersect&quot;</dt><dd><p>The threshold requirement must be met for all selection methods available.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<dl>
<dt><code>path</code></dt><dd><p>The restricted model path, containing only the values of the pair (grid, lambda) that satisfy the threshold criterion.</p>
</dd>
<dt><code>best</code></dt><dd><p>The best model. It is obtained by considering the pair (grid, lambda) in the restricted path that leads to the sparsest model.
If several pairs yield the same level of sparsity, we consider the pair that maximizes the minimum score across all selection methods available.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Continuing the  Lorenz.boot(.) example:
# The out-of-bag score seems to remain relatively flat when lambda is small enough
plot(PLR_boot, type = "diagnostic")
# What is the best pair (grid,penalty) parameter that is close enough to the highest OOB score
diagnostic.PLR(PLR_boot, tol = 0.99, method = "Boot")
# We want the solution to be close to the best, for both the BIC and OOB scores.
diagnostic.PLR(PLR_boot, method = "intersect")

</code></pre>

<hr>
<h2 id='Gini.coef'>Concentration index of <em>y</em> with respect to <em>x</em></h2><span id='topic+Gini.coef'></span>

<h3>Description</h3>

<p><code>Gini.coef</code> computes the concentration index of a vector <em>y</em> with respect to another vector <em>x</em>.
If <em>y</em> and <em>x</em> are identical, the obtained concentration index boils down to the Gini coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gini.coef(
  y,
  x = y,
  na.rm = TRUE,
  ties.method = c("mean", "random"),
  seed = NULL,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gini.coef_+3A_y">y</code></td>
<td>
<p>variable of interest.</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_x">x</code></td>
<td>
<p>variable to use for the ranking. By default <code class="reqn">x=y</code>, and the obtained concentration index is the Gini coefficient of <em>y</em>.</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_na.rm">na.rm</code></td>
<td>
<p>should missing values be deleted. Default value is <code>TRUE</code>. If <code>FALSE</code> is selected, missing values generate an error message</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_ties.method">ties.method</code></td>
<td>
<p>What method should be used to break the ties in the rank index. Possible values are &quot;mean&quot; (default value) or &quot;random&quot;. If &quot;random&quot; is selected, the ties are broken by further ranking in terms of a uniformly distributed random variable. If &quot;mean&quot; is selected, the average rank method is used.</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_seed">seed</code></td>
<td>
<p>fixes what seed is imposed for the generation of the vector of uniform random variables used to break the ties. Default is NULL, in which case no seed is imposed.</p>
</td></tr>
<tr><td><code id="Gini.coef_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>seed</code> allows for local seed setting to control randomness in the generation of the uniform random variables.
The specified seed is applied to the respective part of the computation, and the seed is reverted to its previous state after the operation.
This ensures that the seed settings do not interfere with the global random state or other parts of the code.
</p>


<h3>Value</h3>

<p>The value of the concentration index (or Gini coefficient)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.curve">Lorenz.curve</a></code>, <code><a href="#topic+Lorenz.graphs">Lorenz.graphs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
# We first compute the Gini coefficient of Income
Y &lt;- Data.Incomes$Income
Gini.coef(y = Y)
# Then we compute the concentration index of Income with respect to Age
X &lt;- Data.Incomes$Age
Gini.coef(y = Y, x = X)

</code></pre>

<hr>
<h2 id='ineqExplained'>Retrieve a measure of explained inequality from a model</h2><span id='topic+ineqExplained'></span>

<h3>Description</h3>

<p>This generic function extracts a measure of explained inequality, such as the explained Gini coefficient or the Lorenz-R2, from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ineqExplained(object, type = c("Gini.explained", "Lorenz-R2"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ineqExplained_+3A_object">object</code></td>
<td>
<p>An object for which the inequality metrics should be extracted.</p>
</td></tr>
<tr><td><code id="ineqExplained_+3A_type">type</code></td>
<td>
<p>Character string specifying the type of inequality metric to retrieve. Options are <code>"Gini.explained"</code> for the explained Gini coefficient or <code>"Lorenz-R2"</code> for the Lorenz-<code class="reqn">R^2</code>.</p>
</td></tr>
<tr><td><code id="ineqExplained_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The requested inequality metric.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg)

</code></pre>

<hr>
<h2 id='ineqExplained.LR'>Explained inequality metrics for the Lorenz regression</h2><span id='topic+ineqExplained.LR'></span><span id='topic+ineqExplained.LR_boot'></span>

<h3>Description</h3>

<p>Retrieves the explained Gini coefficient or the Lorenz-<code class="reqn">R^2</code> from an object of class <code>"LR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
ineqExplained(object, type = c("Gini.explained", "Lorenz-R2"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ineqExplained.LR_+3A_object">object</code></td>
<td>
<p>An object of S3 class <code>"LR"</code>.</p>
</td></tr>
<tr><td><code id="ineqExplained.LR_+3A_type">type</code></td>
<td>
<p>Character string specifying the type of inequality metric to retrieve. Options are <code>"Gini.explained"</code> (for the explained Gini coefficient) and <code>"Lorenz-R2"</code> (for the Lorenz-<code class="reqn">R^2</code>).</p>
</td></tr>
<tr><td><code id="ineqExplained.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the requested inequality metric.
</p>

<hr>
<h2 id='ineqExplained.PLR'>Explained inequality metrics for the penalized Lorenz regression</h2><span id='topic+ineqExplained.PLR'></span><span id='topic+ineqExplained.PLR_boot'></span><span id='topic+ineqExplained.PLR_cv'></span>

<h3>Description</h3>

<p>Retrieves the explained Gini coefficient or the Lorenz-<code class="reqn">R^2</code> from an object of class <code>"PLR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
ineqExplained(
  object,
  type = c("Gini.explained", "Lorenz-R2"),
  pars.idx = "BIC",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ineqExplained.PLR_+3A_object">object</code></td>
<td>
<p>An object of S3 class <code>"PLR"</code>. The object might also have S3 classes <code>"PLR_boot"</code> and/or <code>"PLR_cv"</code> (both inherit from class <code>"PLR"</code>)</p>
</td></tr>
<tr><td><code id="ineqExplained.PLR_+3A_type">type</code></td>
<td>
<p>Character string specifying the type of inequality metric to retrieve. Options are <code>"Gini.explained"</code> (for the explained Gini coefficient) and <code>"Lorenz-R2"</code> (for the Lorenz-<code class="reqn">R^2</code>).</p>
</td></tr>
<tr><td><code id="ineqExplained.PLR_+3A_pars.idx">pars.idx</code></td>
<td>
<p>What grid and penalty parameters should be used for parameter selection. Either a character string specifying the selection method, where the possible values are:
</p>

<ul>
<li> <p><code>"BIC"</code> (default) - Always available.
</p>
</li>
<li> <p><code>"Boot"</code> - Available if <code>object</code> inherits from <code>"PLR_boot"</code>.
</p>
</li>
<li> <p><code>"CV"</code> - Available if <code>object</code> inherits from <code>"PLR_cv"</code>.
</p>
</li></ul>

<p>Or a numeric vector of length 2, where the first element is the index of the grid parameter and the second is the index of the penalty parameter.</p>
</td></tr>
<tr><td><code id="ineqExplained.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the requested inequality metric.
</p>

<hr>
<h2 id='Lorenz.boot'>Bootstrap for the (penalized) Lorenz regression</h2><span id='topic+Lorenz.boot'></span>

<h3>Description</h3>

<p><code>Lorenz.boot</code> determines bootstrap estimators for the vector of coefficients of the single-index model, explained Gini coefficient and Lorenz-<code class="reqn">R^2</code>. In the penalized case, it also provides a selection method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.boot(object, R, boot_out_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.boot_+3A_object">object</code></td>
<td>
<p>An object with S3 class <code>"LR"</code> or <code>"PLR"</code>, i.e. the return of a call to the <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code> function.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_r">R</code></td>
<td>
<p>An integer indicating the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_boot_out_only">boot_out_only</code></td>
<td>
<p>A logical determining whether the function should return raw bootstrap results. This is an advanced feature that helps save computation time in certain instances. See Details.</p>
</td></tr>
<tr><td><code id="Lorenz.boot_+3A_...">...</code></td>
<td>
<p>Additional parameters corresponding to arguments passed to the function <code><a href="boot.html#topic+boot">boot</a></code> from the <em>boot</em> library.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users that want to perform parallel computing have two options. The first and most obvious option is to use the facilities provided by the function <code><a href="boot.html#topic+boot">boot</a></code>.
Indeed, arguments such as <code>parallel</code>, <code>ncpus</code> and <code>cl</code> can be passed through the <code>...</code>.
Alternatively, users might want to run different instances of the function, each taking care of a portion of the bootstrap samples.
The argument <code>boot_out_only</code> can be set to <code>TRUE</code> to avoid unnecessary computations. If so, the returned object does not inherit from the class <code>"LR_boot"</code> or <code>"PLR_boot"</code>. The function simply returns the original <code>object</code>, to which is added the <code>boot_out</code> object.
If this second option is chosen, the instances have to be combined using the function <code><a href="#topic+Lorenz.boot.combine">Lorenz.boot.combine</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>c("LR_boot", "LR")</code> or <code>c("PLR_boot", "PLR")</code>, depending on whether a non-penalized or penalized regression was fitted.
</p>
<p>The methods <code><a href="#topic+confint.LR">confint.LR</a></code> and <code><a href="#topic+confint.PLR">confint.PLR</a></code> are used on objects of class <code>"LR_boot"</code> or <code>"PLR_boot"</code> to construct confidence intervals for the model parameters.
</p>
<p>For the non-penalized Lorenz regression, the returned object is a list containing the following components:
</p>

<dl>
<dt><code>theta</code></dt><dd><p>The estimated vector of parameters. In the penalized case, it is a matrix where each row corresponds to a different selection method (e.g., BIC, bootstrap, cross-validation).</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>The estimated explained Gini coefficient. In the penalized case, it is a vector, where each element corresponds to a different selection method.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>The Lorenz-<code class="reqn">R^2</code> of the regression. In the penalized case, it is a vector, where each element corresponds to a different selection method.</p>
</dd>
<dt><code>boot_out</code></dt><dd><p>An object of class <code>"boot"</code> containing the output of the bootstrap calculation.</p>
</dd>
</dl>

<p>For the penalized Lorenz regression, the returned object is a list containing the following components:
</p>

<dl>
<dt><code>path</code></dt><dd><p>See <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code> for the original path. To this path is added the out-of-bag (OOB) score.</p>
</dd>
<dt><code>lambda.idx</code></dt><dd><p>A vector indicating the index of the optimal lambda obtained by each selection method.</p>
</dd>
<dt><code>grid.idx</code></dt><dd><p>A vector indicating the index of the optimal grid parameter obtained by each selection method.</p>
</dd>
</dl>

<p>Note: in the penalized case, the returned object may have additional classes such as <code>"PLR_cv"</code> if cross-validation was performed and used as a selection method.
</p>


<h3>References</h3>

<p>Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. <em>Computational Statistics &amp; Data Analysis 167(C)</em>.
</p>
<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024). A penalised bootstrap estimation procedure for the explained Gini coefficient. <em>Electronic Journal of Statistics 18(1) 247-300</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>, <code><a href="#topic+PLR.CV">PLR.CV</a></code>, <code><a href="boot.html#topic+boot">boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Continuing the Lorenz.Reg(.) example for the non-penalized regression:
# This example is not run as it takes &gt; 5 seconds to run.
## Not run: 
set.seed(123)
NPLR_boot &lt;- Lorenz.boot(NPLR, R = 30)
# The method confint() is available to objects of class "LR_boot".
confint(NPLR_boot)
summary(NPLR_boot)

## End(Not run)
# Continuing the Lorenz.Reg(.) example for the penalized regression:
set.seed(123)
PLR_boot &lt;- Lorenz.boot(PLR, R = 20)
# The object now inherits from the class "PLR_boot"
# Hence the methods (also) display the results obtained by bootstrap.
print(PLR_boot)
summary(PLR_boot)
coef(PLR_boot, pars.idx = "Boot")
predict(PLR_boot, pars.idx = "Boot")
plot(PLR_boot)
# Plot of the scores for each selection method depending on the grid and penalty parameters
plot(PLR_boot, type = "diagnostic")
# The method confint() is available to objects of class "PLR_boot".
confint(PLR_boot, pars.idx = "BIC") # Using the tuning parameters selected by BIC
confint(PLR_boot, pars.idx = "Boot") # Using the tuning parameters selected by bootstrap

</code></pre>

<hr>
<h2 id='Lorenz.boot.combine'>Combines bootstrap Lorenz regressions</h2><span id='topic+Lorenz.boot.combine'></span>

<h3>Description</h3>

<p><code>Lorenz.boot.combine</code> combine outputs of different instances of the <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.boot.combine(boot_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.boot.combine_+3A_boot_list">boot_list</code></td>
<td>
<p>list of objects, each element being the output of a call to the function <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("LR_boot", "LR")</code> or <code>c("PLR_boot", "PLR")</code>, depending on whether a non-penalized or penalized regression was fitted.
</p>
<p>The method <code>confint</code> is used on an object of class <code>"LR_boot"</code> or <code>"PLR_boot"</code> to obtain bootstrap inference on the model parameters.
</p>
<p>For the non-penalized Lorenz regression, the returned object is a list containing the following components:
</p>

<dl>
<dt><code>theta</code></dt><dd><p>The estimated vector of parameters. In the penalized case, it is a matrix where each row corresponds to a different selection method (e.g., BIC, bootstrap, cross-validation).</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>The estimated explained Gini coefficient. In the penalized case, it is a vector, where each element corresponds to a different selection method.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>The Lorenz-<code class="reqn">R^2</code> of the regression. In the penalized case, it is a vector, where each element corresponds to a different selection method.</p>
</dd>
<dt><code>boot_out</code></dt><dd><p>An object of class <code>"boot"</code> containing the output of the bootstrap calculation.</p>
</dd>
</dl>

<p>For the penalized Lorenz regression, the returned object is a list containing the following components:
</p>

<dl>
<dt><code>path</code></dt><dd><p>See <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code> for the original path. To this path is added the out-of-bag (OOB) score.</p>
</dd>
<dt><code>lambda.idx</code></dt><dd><p>A vector indicating the index of the optimal lambda obtained by each selection method.</p>
</dd>
<dt><code>grid.idx</code></dt><dd><p>A vector indicating the index of the optimal grid parameter obtained by each selection method.</p>
</dd>
</dl>

<p>Note: The returned object may have additional classes such as <code>"PLR_cv"</code> if cross-validation was performed and used as a selection method in the penalized case.
</p>


<h3>References</h3>

<p>Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. <em>Computational Statistics &amp; Data Analysis 167(C)</em>.
</p>
<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024). A penalised bootstrap estimation procedure for the explained Gini coefficient. <em>Electronic Journal of Statistics 18(1) 247-300</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Continuing the Lorenz.Reg(.) example for the penalized regression:
boot_list &lt;- list()
set.seed(123)
boot_list[[1]] &lt;- Lorenz.boot(PLR, R = 10, boot_out_only = TRUE)
set.seed(456)
boot_list[[2]] &lt;- Lorenz.boot(PLR, R = 10, boot_out_only = TRUE)
PLR_boot &lt;- Lorenz.boot.combine(boot_list)
summary(PLR_boot)

</code></pre>

<hr>
<h2 id='Lorenz.curve'>Concentration curve of <em>y</em> with respect to <em>x</em></h2><span id='topic+Lorenz.curve'></span>

<h3>Description</h3>

<p><code>Lorenz.curve</code> computes the concentration curve index of a vector <em>y</em> with respect to another vector <em>x</em>.
If <em>y</em> and <em>x</em> are identical, the obtained concentration curve boils down to the Lorenz curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.curve(
  y,
  x = y,
  graph = FALSE,
  na.rm = TRUE,
  ties.method = c("mean", "random"),
  seed = NULL,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.curve_+3A_y">y</code></td>
<td>
<p>variable of interest.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_x">x</code></td>
<td>
<p>variable to use for the ranking. By default <code class="reqn">x=y</code>, and the obtained concentration curve is the Lorenz curve of <em>y</em>.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_graph">graph</code></td>
<td>
<p>whether a graph of the obtained concentration curve should be traced. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_na.rm">na.rm</code></td>
<td>
<p>should missing values be deleted. Default value is <code>TRUE</code>. If <code>FALSE</code> is selected, missing values generate an error message</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_ties.method">ties.method</code></td>
<td>
<p>What method should be used to break the ties in the rank index. Possible values are &quot;mean&quot; (default value) or &quot;random&quot;. If &quot;random&quot; is selected, the ties are broken by further ranking in terms of a uniformly distributed random variable. If &quot;mean&quot; is selected, the average rank method is used.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_seed">seed</code></td>
<td>
<p>seed imposed for the generation of the vector of uniform random variables used to break the ties. Default is NULL, in which case no seed is imposed.</p>
</td></tr>
<tr><td><code id="Lorenz.curve_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>seed</code> allows for local seed setting to control randomness in the generation of the uniform random variables.
The specified seed is applied to the respective part of the computation, and the seed is reverted to its previous state after the operation.
This ensures that the seed settings do not interfere with the global random state or other parts of the code.
</p>


<h3>Value</h3>

<p>A function corresponding to the estimated Lorenz or concentration curve. If <code>graph</code> is TRUE, the curve is also plotted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.graphs">Lorenz.graphs</a></code>, <code><a href="#topic+Gini.coef">Gini.coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
# We first compute the Lorenz curve of Income
Y &lt;- Data.Incomes$Income
Lorenz.curve(y = Y, graph = TRUE)
# Then we compute the concentration curve of Income with respect to Age
X &lt;- Data.Incomes$Age
Lorenz.curve(y = Y, x = X, graph = TRUE)

</code></pre>

<hr>
<h2 id='Lorenz.FABS'>Estimates the parameter vector in a penalized Lorenz regression with lasso penalty</h2><span id='topic+Lorenz.FABS'></span>

<h3>Description</h3>

<p><code>Lorenz.FABS</code> solves the penalized Lorenz regression with (adaptive) Lasso penalty on a grid of lambda values.
For each value of lambda, the function returns estimates for the vector of parameters and for the estimated explained Gini coefficient, as well as the Lorenz-<code class="reqn">R^2</code> of the regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.FABS(
  y,
  x,
  standardize = TRUE,
  weights = NULL,
  kernel = 1,
  h = length(y)^(-1/5.5),
  gamma = 0.05,
  lambda = "Shi",
  w.adaptive = NULL,
  eps = 0.005,
  iter = 10^4,
  lambda.min = 1e-07
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.FABS_+3A_y">y</code></td>
<td>
<p>a vector of responses</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_x">x</code></td>
<td>
<p>a matrix of explanatory variables</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_standardize">standardize</code></td>
<td>
<p>Should the variables be standardized before the estimation process? Default value is TRUE.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_kernel">kernel</code></td>
<td>
<p>integer indicating what kernel function to use. The value 1 is the default and implies the use of an Epanechnikov kernel while the value of 2 implies the use of a biweight kernel.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel, determining the smoothness of the approximation of the indicator function. Default value is n^(-1/5.5) where n is the sample size.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_gamma">gamma</code></td>
<td>
<p>value of the Lagrange multiplier in the loss function</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_lambda">lambda</code></td>
<td>
<p>this parameter relates to the regularization parameter. Several options are available.
</p>

<dl>
<dt><code>grid</code></dt><dd><p>If <code>lambda="grid"</code>, lambda is defined on a grid, equidistant in the logarithmic scale.</p>
</dd>
<dt><code>Shi</code></dt><dd><p>If <code>lambda="Shi"</code>, lambda, is defined within the algorithm, as in Shi et al (2018).</p>
</dd>
<dt><code>supplied</code></dt><dd><p>If the user wants to supply the lambda vector himself</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_w.adaptive">w.adaptive</code></td>
<td>
<p>vector of size equal to the number of covariates where each entry indicates the weight in the adaptive Lasso. By default, each covariate is given the same weight (Lasso).</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_eps">eps</code></td>
<td>
<p>step size in the FABS algorithm. Default value is 0.005.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations. Default value is 10^4.</p>
</td></tr>
<tr><td><code id="Lorenz.FABS_+3A_lambda.min">lambda.min</code></td>
<td>
<p>lower bound of the penalty parameter. Only used if <code>lambda="Shi"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regression is solved using the FABS algorithm developed by Shi et al (2018) and adapted to our case.
For a comprehensive explanation of the Penalized Lorenz Regression, see Jacquemain et al.
In order to ensure identifiability, theta is forced to have a L2-norm equal to one.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<dl>
<dt><code>lambda</code></dt><dd><p>vector gathering the different values of the regularization parameter</p>
</dd>
<dt><code>theta</code></dt><dd><p>matrix where column i provides the vector of estimated coefficients corresponding to the value <code>lambda[i]</code> of the regularization parameter.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>vector where element i provides the Lorenz-<code class="reqn">R^2</code> attached to the value <code>lambda[i]</code> of the regularization parameter.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>vector where element i provides the estimated explained Gini coefficient related to the value <code>lambda[i]</code> of the regularization parameter.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024). A penalised bootstrap estimation procedure for the explained Gini coefficient. <em>Electronic Journal of Statistics 18(1) 247-300</em>.
</p>
<p>Shi, X., Y. Huang, J. Huang, and S. Ma (2018). A Forward and Backward Stagewise Algorithm for Nonconvex Loss Function with Adaptive Lasso, <em>Computational Statistics &amp; Data Analysis 124</em>, 235-251.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
y &lt;- Data.Incomes[,1]
x &lt;- as.matrix(Data.Incomes[,-c(1,2)])
Lorenz.FABS(y, x)

</code></pre>

<hr>
<h2 id='Lorenz.GA'>Estimates the parameter vector in Lorenz regression using a genetic algorithm</h2><span id='topic+Lorenz.GA'></span>

<h3>Description</h3>

<p><code>Lorenz.GA</code> estimates the coefficient vector of the single-index model.
It also returns the Lorenz-<code class="reqn">R^2</code> of the regression as well as the estimated explained Gini coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.GA(
  y,
  x,
  standardize = TRUE,
  weights = NULL,
  popSize = 50,
  maxiter = 1500,
  run = 150,
  ties.method = c("random", "mean"),
  ties.Gini = c("random", "mean"),
  seed.random = NULL,
  seed.Gini = NULL,
  seed.GA = NULL,
  parallel.GA = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.GA_+3A_y">y</code></td>
<td>
<p>a vector of responses</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_x">x</code></td>
<td>
<p>a matrix of explanatory variables</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_standardize">standardize</code></td>
<td>
<p>Should the variables be standardized before the estimation process? Default value is TRUE.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_popsize">popSize</code></td>
<td>
<p>Size of the population of candidates in the genetic algorithm. Default value is 50.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number ot iterations in the genetic algorithm. Default value is 1500.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_run">run</code></td>
<td>
<p>Number of iterations without improvement in the best fitness necessary for the algorithm to stop. Default value is 150.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_ties.method">ties.method</code></td>
<td>
<p>What method should be used to break the ties in optimization program. Possible values are &quot;random&quot; (default value) or &quot;mean&quot;. If &quot;random&quot; is selected, the ties are broken by further ranking in terms of a uniformly distributed random variable. If &quot;mean&quot; is selected, the average rank method is used.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_ties.gini">ties.Gini</code></td>
<td>
<p>what method should be used to break the ties in the computation of the Gini coefficient at the end of the algorithm. Possible values and default choice are the same as above.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_seed.random">seed.random</code></td>
<td>
<p>An optional seed for generating the vector of uniform random variables used to break ties in the genetic algorithm. Defaults to <code>NULL</code>, which means no specific seed is set.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_seed.gini">seed.Gini</code></td>
<td>
<p>An optional seed for generating the vector of uniform random variables used to break ties in the computation of the Gini coefficient. Defaults to <code>NULL</code>, meaning no specific seed is applied.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_seed.ga">seed.GA</code></td>
<td>
<p>An optional seed for <code><a href="GA.html#topic+ga">ga</a></code>, used during the fitting of the genetic algorithm. Defaults to <code>NULL</code>, implying that no specific seed is set.</p>
</td></tr>
<tr><td><code id="Lorenz.GA_+3A_parallel.ga">parallel.GA</code></td>
<td>
<p>Whether parallel computing should be used to distribute the computations in the genetic algorithm. Either a logical value determining whether parallel computing is used (TRUE) or not (FALSE, the default value). Or a numerical value determining the number of cores to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genetic algorithm is solved using function <code><a href="GA.html#topic+ga">ga</a></code> from the <em>GA</em> package. The fitness function is coded in Rcpp to speed up computation time.
When discrete covariates are introduced and ties occur in the index, the default option randomly breaks them, as advised in Section 3 of Heuchenne and Jacquemain (2022)
</p>
<p>The parameters <code>seed.random</code>, <code>seed.Gini</code>, and <code>seed.GA</code> allow for local seed setting to control randomness in specific parts of the function.
Each seed is applied to the respective part of the computation, and the seed is reverted to its previous state after the operation.
This ensures that the seed settings do not interfere with the global random state or other parts of the code.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<dl>
<dt><code>theta</code></dt><dd><p>the estimated vector of parameters.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>the Lorenz-<code class="reqn">R^2</code> of the regression.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>the estimated explained Gini coefficient.</p>
</dd>
<dt><code>niter</code></dt><dd><p>number of iterations attained by the genetic algorithm.</p>
</dd>
<dt><code>fit</code></dt><dd><p>value attained by the fitness function at the optimum.</p>
</dd>
</dl>



<h3>References</h3>

<p>Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. <em>Computational Statistics &amp; Data Analysis 167(C)</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="GA.html#topic+ga">ga</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
y &lt;- Data.Incomes$Income
x &lt;- cbind(Data.Incomes$Age, Data.Incomes$Work.Hours)
Lorenz.GA(y, x, popSize = 40)

</code></pre>

<hr>
<h2 id='Lorenz.ga.call'>Call to the genetic algorithm for the Lorenz regression</h2><span id='topic+Lorenz.ga.call'></span>

<h3>Description</h3>

<p><code>Lorenz.ga.call</code> encapsulates the call to ga for a local management of seed setting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.ga.call(
  ties.method,
  y,
  x,
  pi,
  V,
  popSize,
  maxiter,
  run,
  parallel.GA,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.ga.call_+3A_ties.method">ties.method</code></td>
<td>
<p>Either <code>"mean"</code> or <code>"random"</code>.</p>
</td></tr>
<tr><td><code id="Lorenz.ga.call_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Lorenz.ga.call_+3A_x">x</code></td>
<td>
<p>matrix of covariates.</p>
</td></tr>
<tr><td><code id="Lorenz.ga.call_+3A_pi">pi</code></td>
<td>
<p>sample weights (normalized).</p>
</td></tr>
<tr><td><code id="Lorenz.ga.call_+3A_v">V</code></td>
<td>
<p>vector of uniformly distributed rvs.</p>
</td></tr>
<tr><td><code id="Lorenz.ga.call_+3A_popsize">popSize</code></td>
<td>
<p>passed to <code>ga</code>.</p>
</td></tr>
<tr><td><code id="Lorenz.ga.call_+3A_maxiter">maxiter</code></td>
<td>
<p>passed to <code>ga</code>.</p>
</td></tr>
<tr><td><code id="Lorenz.ga.call_+3A_run">run</code></td>
<td>
<p>passed to <code>ga</code>.</p>
</td></tr>
<tr><td><code id="Lorenz.ga.call_+3A_parallel.ga">parallel.GA</code></td>
<td>
<p>passed to <code>ga</code>.</p>
</td></tr>
<tr><td><code id="Lorenz.ga.call_+3A_seed">seed</code></td>
<td>
<p>An optional integer for setting the seed for random number generation. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The fitted genetic algorithm
</p>

<hr>
<h2 id='Lorenz.graphs'>Graphs of concentration curves</h2><span id='topic+Lorenz.graphs'></span>

<h3>Description</h3>

<p><code>Lorenz.graphs</code> traces the Lorenz curve of a response and the concentration curve of the response and each of a series of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.graphs(formula, data, difference = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.graphs_+3A_formula">formula</code></td>
<td>
<p>A formula object of the form <em>response</em> ~ <em>other_variables</em>.</p>
</td></tr>
<tr><td><code id="Lorenz.graphs_+3A_data">data</code></td>
<td>
<p>A dataframe containing the variables of interest</p>
</td></tr>
<tr><td><code id="Lorenz.graphs_+3A_difference">difference</code></td>
<td>
<p>A logical determining whether the vertical axis should be expressed in terms of deviation from perfect equality. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Lorenz.graphs_+3A_...">...</code></td>
<td>
<p>Further arguments (see Section 'Arguments' in <code><a href="#topic+Lorenz.curve">Lorenz.curve</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot comprising
</p>

<ul>
<li><p> The Lorenz curve of <em>response</em>
</p>
</li>
<li><p> The concentration curves of <em>response</em> with respect to each element of <em>other_variables</em>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.curve">Lorenz.curve</a></code>, <code><a href="#topic+Gini.coef">Gini.coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
Lorenz.graphs(Income ~ Age + Work.Hours, data = Data.Incomes)
# Expressing now the vertical axis as the deviation from perfect equality
Lorenz.graphs(Income ~ Age + Work.Hours, data = Data.Incomes, difference = TRUE)

</code></pre>

<hr>
<h2 id='Lorenz.Population'>Defines the population used in the genetic algorithm</h2><span id='topic+Lorenz.Population'></span>

<h3>Description</h3>

<p><code>Lorenz.Population</code> creates the initial population of the genetic algorithm used to solve the Lorenz regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.Population(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.Population_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>ga</code>&quot;, resulting from a call to function <code>ga</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this population produces an initial solution ensuring a unit norm.
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>object@popSize</code> times the number of explanatory variables minus one, gathering the initial population.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>
</p>

<hr>
<h2 id='Lorenz.Reg'>Fits a Lorenz regression</h2><span id='topic+Lorenz.Reg'></span>

<h3>Description</h3>

<p><code>Lorenz.Reg</code> fits the Lorenz regression of a response with respect to several covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.Reg(
  formula,
  data,
  weights,
  na.action,
  penalty = c("none", "SCAD", "LASSO"),
  grid.arg = c("h", "SCAD.nfwd", "eps", "kernel", "a", "gamma"),
  grid.value = NULL,
  lambda.list = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.Reg_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>Lorenz.Reg</code> is called.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_weights">weights</code></td>
<td>
<p>An optional vector of sample weights to be used in the fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The 'factory-fresh' default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>. Another possible value is <code>NULL</code>, no action. Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_penalty">penalty</code></td>
<td>
<p>A character string specifying the type of penalty on the size of the estimated coefficients of the single-index model.
The default value is <code>"none"</code>, in which case a non-penalized Lorenz regression is fitted using <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>.
Other possible values are <code>"LASSO"</code> and <code>"SCAD"</code>, in which case a penalized Lorenz regression is fitted using <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code> or <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code> respectively.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_grid.arg">grid.arg</code></td>
<td>
<p>A character string specifying the tuning parameter for which a grid is to be constructed, see Details.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_grid.value">grid.value</code></td>
<td>
<p>A numeric vector specifying the grid values, see Details.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_lambda.list">lambda.list</code></td>
<td>
<p>Technical argument used inside the function <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>.</p>
</td></tr>
<tr><td><code id="Lorenz.Reg_+3A_...">...</code></td>
<td>
<p>Additional parameters corresponding to arguments passed in <code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code> or <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>, depending on the argument chosen in <code>penalty</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the penalized case, the model is fitted for a grid of values of two parameters : the penalty parameter (lambda) and one tuning parameter specified by the arguments <code>grid.arg</code> and <code>grid.value</code>.
The possibles values for <code>grid.arg</code> are tuning parameters of the functions <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code> and <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code> : <code>''h''</code> (the default), <code>''SCAD.nfwd''</code>,<code>''eps''</code>, <code>''kernel''</code>, <code>''a''</code> and <code>''gamma''</code>.
The values for the grid are specified with <code>grid.value</code>. The default is <code>NULL</code>, in which case no grid is constructed
</p>


<h3>Value</h3>

<p>An object of class <code>"LR"</code> for the non-penalized Lorenz regression or of class <code>"PLR"</code> for a penalized Lorenz regression.
</p>
<p>Several methods are available for both classes to facilitate model analysis.
Use <code><a href="#topic+summary.LR">summary.LR</a></code> or <code><a href="#topic+summary.PLR">summary.PLR</a></code> to summarize the model fits.
Extract the coefficients of the single-index model using <code><a href="#topic+coef.LR">coef.LR</a></code> or <code><a href="#topic+coef.PLR">coef.PLR</a></code>.
Measures of explained inequality (Gini coefficient and Lorenz-<code class="reqn">R^2</code>) are retrieved using <code><a href="#topic+ineqExplained.LR">ineqExplained.LR</a></code> or <code><a href="#topic+ineqExplained.PLR">ineqExplained.PLR</a></code>.
Obtain predictions with <code><a href="#topic+predict.LR">predict.LR</a></code> or <code><a href="#topic+predict.PLR">predict.PLR</a></code>, and fitted values with <code><a href="#topic+fitted.LR">fitted.LR</a></code> or <code><a href="#topic+fitted.PLR">fitted.PLR</a></code>.
For visual representations of explained inequality, use <code><a href="#topic+autoplot.LR">autoplot.LR</a></code> and <code><a href="#topic+plot.LR">plot.LR</a></code>, or <code><a href="#topic+autoplot.PLR">autoplot.PLR</a></code> and <code><a href="#topic+plot.PLR">plot.PLR</a></code>.
</p>
<p>The object of class <code>"LR"</code> is a list containing the following components:
</p>

<dl>
<dt><code>theta</code></dt><dd><p>The estimated vector of parameters.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>The estimated explained Gini coefficient.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>The Lorenz-<code class="reqn">R^2</code> of the regression.</p>
</dd>
</dl>

<p>The object of class <code>"PLR"</code> is a list containing the following components:
</p>

<dl>
<dt><code>path</code></dt><dd><p>A list where the different elements correspond to the values of the grid parameter. Each element is a matrix where the first line displays the vector of lambda values. The second and third lines display the evolution of the Lorenz-<code class="reqn">R^2</code> and explained Gini coefficient along that vector. The next lines display the evolution of the BIC score. The remaining lines display the evolution of the estimated coefficients of the single-index model.</p>
</dd>
<dt><code>lambda.idx</code></dt><dd><p>the index of the optimal lambda obtained by the BIC method</p>
</dd>
<dt><code>grid.idx</code></dt><dd><p>the index of the optimal grid parameter obtained by the BIC method.</p>
</dd>
</dl>

<p>In both cases, the list also provides technical information, such as the specified <code>formula</code>, <code>weights</code> and <code>call</code>, as well as the design matrix <code>x</code> and the response vector <code>y</code>.
</p>


<h3>References</h3>

<p>Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. <em>Computational Statistics &amp; Data Analysis 167(C)</em>.
</p>
<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024). A penalised bootstrap estimation procedure for the explained Gini coefficient. <em>Electronic Journal of Statistics 18(1) 247-300</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.GA">Lorenz.GA</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>, <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
set.seed(123)
data &lt;- Data.Incomes[sample(1:200,40),]
# 1. Non-penalized regression
NPLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "none", popSize = 15)
# 2. Penalized regression
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes, penalty = "SCAD",
                  eps = 0.06, grid.arg = "h",
                  grid.value=c(0.5,1,2)*nrow(Data.Incomes)^(-1/5.5))
# Print method
print(NPLR)
print(PLR)
# Summary method
summary(NPLR)
summary(PLR)
# Coef method
coef(NPLR)
coef(PLR)
# ineqExplained method
ineqExplained(NPLR)
ineqExplained(PLR)
# Predict method
## One can predict either the index or the response
predict(NPLR,type="response")
predict(PLR,type="response")
# Plot method
plot(NPLR)
plot(PLR)
## Traceplot of the penalized coefficients
plot(PLR,type="traceplot")

</code></pre>

<hr>
<h2 id='Lorenz.SCADFABS'>Estimates the parameter vector in a penalized Lorenz regression with SCAD penalty</h2><span id='topic+Lorenz.SCADFABS'></span>

<h3>Description</h3>

<p><code>Lorenz.SCADFABS</code> solves the penalized Lorenz regression with SCAD penalty on a grid of lambda values.
For each value of lambda, the function returns estimates for the vector of parameters and for the estimated explained Gini coefficient, as well as the Lorenz-<code class="reqn">R^2</code> of the regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lorenz.SCADFABS(
  y,
  x,
  standardize = TRUE,
  weights = NULL,
  kernel = 1,
  h = length(y)^(-1/5.5),
  gamma = 0.05,
  a = 3.7,
  lambda = "Shi",
  eps = 0.005,
  SCAD.nfwd = NULL,
  iter = 10^4,
  lambda.min = 1e-07
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lorenz.SCADFABS_+3A_y">y</code></td>
<td>
<p>a vector of responses</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_x">x</code></td>
<td>
<p>a matrix of explanatory variables</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_standardize">standardize</code></td>
<td>
<p>Should the variables be standardized before the estimation process? Default value is TRUE.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_kernel">kernel</code></td>
<td>
<p>integer indicating what kernel function to use. The value 1 is the default and implies the use of an Epanechnikov kernel while the value of 2 implies the use of a biweight kernel.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel, determining the smoothness of the approximation of the indicator function. Default value is n^(-1/5.5) where n is the sample size.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_gamma">gamma</code></td>
<td>
<p>value of the Lagrange multiplier in the loss function</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_a">a</code></td>
<td>
<p>parameter of the SCAD penalty. Default value is 3.7.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_lambda">lambda</code></td>
<td>
<p>this parameter relates to the regularization parameter. Several options are available.
</p>

<dl>
<dt><code>grid</code></dt><dd><p>If lambda=&quot;grid&quot;, lambda is defined on a grid, equidistant in the logarithmic scale.</p>
</dd>
<dt><code>Shi</code></dt><dd><p>If lambda=&quot;Shi&quot;, lambda, is defined within the algorithm, as in Shi et al (2018).</p>
</dd>
<dt><code>supplied</code></dt><dd><p>If the user wants to supply the lambda vector himself</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_eps">eps</code></td>
<td>
<p>step size in the FABS algorithm. Default value is 0.005.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_scad.nfwd">SCAD.nfwd</code></td>
<td>
<p>optional tuning parameter used if penalty=&quot;SCAD&quot;. Default value is NULL. The larger the value of this parameter, the sooner the path produced by the SCAD will differ from the path produced by the LASSO.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations. Default value is 10^4.</p>
</td></tr>
<tr><td><code id="Lorenz.SCADFABS_+3A_lambda.min">lambda.min</code></td>
<td>
<p>lower bound of the penalty parameter. Only used if lambda=&quot;Shi&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regression is solved using the SCAD-FABS algorithm developed by Jacquemain et al and adapted to our case.
For a comprehensive explanation of the Penalized Lorenz Regression, see Heuchenne et al.
In order to ensure identifiability, theta is forced to have a L2-norm equal to one.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>

<dl>
<dt><code>lambda</code></dt><dd><p>vector gathering the different values of the regularization parameter</p>
</dd>
<dt><code>theta</code></dt><dd><p>matrix where column i provides the vector of estimated coefficients corresponding to the value <code>lambda[i]</code> of the regularization parameter.</p>
</dd>
<dt><code>LR2</code></dt><dd><p>vector where element i provides the Lorenz-<code class="reqn">R^2</code> attached to the value <code>lambda[i]</code> of the regularization parameter.</p>
</dd>
<dt><code>Gi.expl</code></dt><dd><p>vector where element i provides the estimated explained Gini coefficient related to the value <code>lambda[i]</code> of the regularization parameter.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024). A penalised bootstrap estimation procedure for the explained Gini coefficient. <em>Electronic Journal of Statistics 18(1) 247-300</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
y &lt;- Data.Incomes[,1]
x &lt;- as.matrix(Data.Incomes[,-c(1,2)])
Lorenz.SCADFABS(y, x)

</code></pre>

<hr>
<h2 id='model_matrix_PLR'>Design matrix in the Penalized Lorenz Regression</h2><span id='topic+model_matrix_PLR'></span>

<h3>Description</h3>

<p><code>model_matrix_PLR</code> is a utilitary function that provides the design matrix for the Penalized Lorenz Regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_matrix_PLR(mt, mf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_matrix_PLR_+3A_mt">mt</code></td>
<td>
<p>Model terms</p>
</td></tr>
<tr><td><code id="model_matrix_PLR_+3A_mf">mf</code></td>
<td>
<p>Model frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function ensures that the design matrix is constructed according to the requirements of the PLR.
In PLR, one must exclude the intercept and use one-hot encoding for all variables, except when binary
</p>


<h3>Value</h3>

<p>The design matrix
</p>

<hr>
<h2 id='PLR.BIC'>Determines the regularization parameter (lambda) in a PLR via optimization of an information criterion.</h2><span id='topic+PLR.BIC'></span>

<h3>Description</h3>

<p><code>PLR.BIC</code> takes as input a matrix of estimated parameter vectors, where each row corresponds to a covariate and each column corresponds to a value of lambda,
and returns the index of the optimal column by optimizing an information criterion. By default the BIC is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR.BIC(y, x, theta, weights = NULL, IC = c("BIC", "AIC"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PLR.BIC_+3A_y">y</code></td>
<td>
<p>a vector of responses</p>
</td></tr>
<tr><td><code id="PLR.BIC_+3A_x">x</code></td>
<td>
<p>a matrix of explanatory variables</p>
</td></tr>
<tr><td><code id="PLR.BIC_+3A_theta">theta</code></td>
<td>
<p>matrix gathering the path of estimated parameter vectors. Each row corresponds to a given covariate. Each column corresponds to a given value of lambda</p>
</td></tr>
<tr><td><code id="PLR.BIC_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="PLR.BIC_+3A_ic">IC</code></td>
<td>
<p>indicates which information criterion is used. Possibles values are &quot;BIC&quot; (default) or &quot;AIC&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components
</p>

<dl>
<dt><code>val</code></dt><dd><p>vector indicating the value attained by the information criterion for each value of lambda.</p>
</dd>
<dt><code>best</code></dt><dd><p>index of the value of lambda where the optimum is attained.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024). A penalised bootstrap estimation procedure for the explained Gini coefficient. <em>Electronic Journal of Statistics 18(1) 247-300</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>
</p>

<hr>
<h2 id='PLR.CV'>Cross-validation for penalized Lorenz regression</h2><span id='topic+PLR.CV'></span>

<h3>Description</h3>

<p><code>PLR.CV</code> selects the grid and penalization parameters of the penalized Lorenz regression by cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR.CV(object, k, seed.CV = NULL, parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PLR.CV_+3A_object">object</code></td>
<td>
<p>An object with S3 class <code>"PLR"</code>, i.e. the return of a call to the <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code> function where <code>penalty=="SCAD"</code> or <code>penalty=="LASSO"</code>.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_k">k</code></td>
<td>
<p>An integer indicating the number of folds in the k-fold cross-validation</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_seed.cv">seed.CV</code></td>
<td>
<p>An optional seed that is used internally for the creation of the folds. Default is <code>NULL</code>, in which case no seed is imposed.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_parallel">parallel</code></td>
<td>
<p>Whether parallel computing should be used to distribute the cross-validation computations. Either a logical value determining whether parallel computing is used (TRUE) or not (FALSE, the default value). Or a numerical value determining the number of cores to use.</p>
</td></tr>
<tr><td><code id="PLR.CV_+3A_...">...</code></td>
<td>
<p>Additional parameters corresponding to arguments passed to the function <code><a href="rsample.html#topic+vfold_cv">vfold_cv</a></code> from the <em>rsample</em> library.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>seed.CV</code> allows for local seed setting to control randomness in the generation of the folds.
The specified seed is applied to the respective part of the computation, and the seed is reverted to its previous state after the operation.
This ensures that the seed settings do not interfere with the global random state or other parts of the code.
</p>


<h3>Value</h3>

<p>An object of class <code>c("PLR_cv", "PLR")</code>. The object is a list containing the following components:
</p>

<dl>
<dt><code>path</code></dt><dd><p>See the <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code> function for the documentation of the original path. To this path is added the CV-score.</p>
</dd>
<dt><code>lambda.idx</code></dt><dd><p>A vector indicating the index of the optimal lambda obtained by each selection method.</p>
</dd>
<dt><code>grid.idx</code></dt><dd><p>A vector indicating the index of the optimal grid parameter obtained by each selection method.</p>
</dd>
</dl>

<p>Note: The returned object may have additional classes such as <code>"PLR_boot"</code> if bootstrap was performed.
</p>


<h3>References</h3>

<p>Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024). A penalised bootstrap estimation procedure for the explained Gini coefficient. <em>Electronic Journal of Statistics 18(1) 247-300</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Lorenz.SCADFABS">Lorenz.SCADFABS</a></code>, <code><a href="#topic+Lorenz.FABS">Lorenz.FABS</a></code>, <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Continuing the  Lorenz.Reg(.) example:
PLR_CV &lt;- PLR.CV(PLR, k = 5, seed.CV = 123)
# The object now inherits from the class "PLR_CV".
# Hence the methods (also) display the results obtained by cross-validation.
print(PLR_CV)
summary(PLR_CV)
coef(PLR_CV, pars.idx = "CV")
predict(PLR_CV, pars.idx = "CV")
plot(PLR_CV)
plot(PLR_CV, type = "diagnostic") # Plot of the scores depending on the grid and penalty parameters

</code></pre>

<hr>
<h2 id='PLR.normalize'>Re-normalizes the estimated coefficients of a penalized Lorenz regression</h2><span id='topic+PLR.normalize'></span>

<h3>Description</h3>

<p><code>PLR.normalize</code> transforms the estimated coefficients of a penalized Lorenz regression to match the model where the first category of each categorical variable is omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR.normalize(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PLR.normalize_+3A_object">object</code></td>
<td>
<p>An object of S3 class <code>"PLR"</code>. The object must also contain a <code>"theta"</code> slot with the estimated coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of re-normalized coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>

<hr>
<h2 id='PLR.scores'>Computes Gini scores for the Penalized Lorenz Regression</h2><span id='topic+PLR.scores'></span>

<h3>Description</h3>

<p><code>PLR.scores</code> computes the Gini scores (either OOB-scores or CV-scores) obtained for a specific validation sample and associated to a list of parameters obtained by the Penalized Lorenz Regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR.scores(y, x, weights, theta.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PLR.scores_+3A_y">y</code></td>
<td>
<p>the vector of responses</p>
</td></tr>
<tr><td><code id="PLR.scores_+3A_x">x</code></td>
<td>
<p>the design matrix (after data management steps, i.e. standardization and transformations of the categorical covariates into binaries)</p>
</td></tr>
<tr><td><code id="PLR.scores_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="PLR.scores_+3A_theta.list">theta.list</code></td>
<td>
<p>list of matrices. Each element of the list correspond to a value of the grid parameter. The columns of the matrices correspond to values of the penalty parameters. The rows correspond to the different covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors gathering the Gini scores. Each element of the list corresponds to a value of the grid parameter and each element of the vector corresponds to a value of the penalization parameter.
</p>

<hr>
<h2 id='predict.LR'>Prediction and fitted values for the Lorenz regression</h2><span id='topic+predict.LR'></span><span id='topic+predict.LR_boot'></span><span id='topic+fitted.LR'></span><span id='topic+fitted.LR_boot'></span>

<h3>Description</h3>

<p><code>prediction</code> provides predictions for an object of class <code>"LR"</code>,
while <code>fitted</code> extracts the fitted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
predict(object, newdata, type = c("index", "response"), ...)

## S3 method for class 'LR'
fitted(object, type = c("index", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.LR_+3A_object">object</code></td>
<td>
<p>An object of class <code>"LR"</code>.</p>
</td></tr>
<tr><td><code id="predict.LR_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with which to predict. If omitted, the original data are used.</p>
</td></tr>
<tr><td><code id="predict.LR_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of prediction or fitted values. Possible values are <code>"response"</code> and <code>"index"</code> (the default).
In the first case, the prediction estimates the conditional expectation of the response given the covariates.
In the second case, the prediction estimates only the index of the single-index model.</p>
</td></tr>
<tr><td><code id="predict.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function <code><a href="#topic+Rearrangement.estimation">Rearrangement.estimation</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type="response"</code>, the link function of the single-index model must be estimated. This is done via the function <code><a href="#topic+Rearrangement.estimation">Rearrangement.estimation</a></code>.
</p>


<h3>Value</h3>

<p>A vector of predictions for <code>predict</code>, or a vector of fitted values for <code>fitted</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Rearrangement.estimation">Rearrangement.estimation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg) and example(Lorenz.boot)

</code></pre>

<hr>
<h2 id='predict.PLR'>Prediction and fitted values for the penalized Lorenz regression</h2><span id='topic+predict.PLR'></span><span id='topic+predict.PLR_boot'></span><span id='topic+predict.PLR_cv'></span><span id='topic+fitted.PLR'></span><span id='topic+fitted.PLR_boot'></span><span id='topic+fitted.PLR_cv'></span>

<h3>Description</h3>

<p><code>prediction</code> provides predictions for an object of class <code>"PLR"</code>,
while <code>fitted</code> extracts the fitted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
predict(object, newdata, type = c("index", "response"), pars.idx = "BIC", ...)

## S3 method for class 'PLR'
fitted(object, type = c("index", "response"), pars.idx = "BIC", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.PLR_+3A_object">object</code></td>
<td>
<p>An object of S3 class <code>"PLR"</code>. The object might also have S3 classes <code>"PLR_boot"</code> and/or <code>"PLR_cv"</code> (both inherit from class <code>"PLR"</code>)</p>
</td></tr>
<tr><td><code id="predict.PLR_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with which to predict. If omitted, the original data are used.</p>
</td></tr>
<tr><td><code id="predict.PLR_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of prediction or fitted values. Possible values are <code>"response"</code> and <code>"index"</code> (the default).
In the first case, the conditional expectation of the response given the covariates is estimated.
In the second case, only the index of the single-index model is estimated.</p>
</td></tr>
<tr><td><code id="predict.PLR_+3A_pars.idx">pars.idx</code></td>
<td>
<p>What grid and penalty parameters should be used for parameter selection. Either a character string specifying the selection method, where the possible values are:
</p>

<ul>
<li> <p><code>"BIC"</code> (default) - Always available.
</p>
</li>
<li> <p><code>"Boot"</code> - Available if <code>object</code> inherits from <code>"PLR_boot"</code>.
</p>
</li>
<li> <p><code>"CV"</code> - Available if <code>object</code> inherits from <code>"PLR_cv"</code>.
</p>
</li></ul>

<p>Or a numeric vector of length 2, where the first element is the index of the grid parameter and the second is the index of the penalty parameter.</p>
</td></tr>
<tr><td><code id="predict.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function <code><a href="#topic+Rearrangement.estimation">Rearrangement.estimation</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type="response"</code>, the link function of the single-index model must be estimated. This is done via the function <code><a href="#topic+Rearrangement.estimation">Rearrangement.estimation</a></code>.
</p>


<h3>Value</h3>

<p>A vector of predictions for <code>predict</code>, or a vector of fitted values for <code>fitted</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Rearrangement.estimation">Rearrangement.estimation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg), example(Lorenz.boot) and example(PLR.CV)

</code></pre>

<hr>
<h2 id='print.LR'>Printing method for the Lorenz regression</h2><span id='topic+print.LR'></span><span id='topic+print.LR_boot'></span>

<h3>Description</h3>

<p>Prints the arguments, explained Gini coefficient and estimated coefficients of an object of class <code>"LR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.LR_+3A_x">x</code></td>
<td>
<p>An object of class <code>"LR"</code>.</p>
</td></tr>
<tr><td><code id="print.LR_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to be passed.</p>
</td></tr>
<tr><td><code id="print.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for printing an object of class <code>"LR"</code> to the console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg)

</code></pre>

<hr>
<h2 id='print.PLR'>Printing method for the penalized Lorenz regression</h2><span id='topic+print.PLR'></span><span id='topic+print.PLR_boot'></span><span id='topic+print.PLR_cv'></span>

<h3>Description</h3>

<p>Prints the arguments, explained Gini coefficient and estimated coefficients of an object of class <code>"PLR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PLR_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>"PLR"</code>. The object might also have S3 classes <code>"PLR_boot"</code> and/or <code>"PLR_cv"</code> (both inherit from class <code>"PLR"</code>)</p>
</td></tr>
<tr><td><code id="print.PLR_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to be passed.</p>
</td></tr>
<tr><td><code id="print.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The explained Gini coefficient and estimated coefficients are returned for each available selection method, depending on the class of <code>x</code>.
</p>


<h3>Value</h3>

<p>No return value, called for printing an object of class <code>"PLR"</code> to the console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg), example(Lorenz.boot) and example(PLR.CV)

</code></pre>

<hr>
<h2 id='print.summary.LR'>Printing method for the summary of a Lorenz regression</h2><span id='topic+print.summary.LR'></span><span id='topic+print.summary.LR_boot'></span>

<h3>Description</h3>

<p>Provides a printing method for an object of class <code>"summary.LR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.LR'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'summary.LR_boot'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.LR_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.LR"</code>. The object might also have S3 class <code>"summary.LR_boot"</code> (which inherits from class <code>"summary.LR"</code>)</p>
</td></tr>
<tr><td><code id="print.summary.LR_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to be passed.</p>
</td></tr>
<tr><td><code id="print.summary.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.LR_+3A_signif.stars">signif.stars</code></td>
<td>
<p>Logical determining whether p-values should be also encoded visually. See the help of the function <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code> for more information.
This is only relevant if <code>x</code> inherits from <code>"summary.LR_boot"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for printing an object of class <code>"LR"</code> to the console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.LR">summary.LR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg) and example(Lorenz.boot)

</code></pre>

<hr>
<h2 id='print.summary.PLR'>Printing method for the summary of a penalized Lorenz regression</h2><span id='topic+print.summary.PLR'></span><span id='topic+print.summary.PLR_boot'></span><span id='topic+print.summary.PLR_cv'></span>

<h3>Description</h3>

<p>Provides a printing method for an object of class <code>"summary.PLR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.PLR'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.PLR_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.PLR"</code>. The object might also have S3 class <code>"summary.PLR_boot"</code> and/or <code>"summary.PLR_cv"</code> (both inherit from class <code>"summary.LR"</code>)</p>
</td></tr>
<tr><td><code id="print.summary.PLR_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to be passed.</p>
</td></tr>
<tr><td><code id="print.summary.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for printing an object of class <code>"summary.PLR"</code> to the console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.PLR">summary.PLR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg), example(Lorenz.boot) and example(PLR.CV)

</code></pre>

<hr>
<h2 id='Rearrangement.estimation'>Estimates a monotonic regression curve via Chernozhukov et al (2009)</h2><span id='topic+Rearrangement.estimation'></span>

<h3>Description</h3>

<p><code>Rearrangement.estimation</code> estimates the increasing link function of a single index model via the methodology proposed in Chernozhukov et al (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rearrangement.estimation(Y, Index, t = Index, weights = NULL, degree.pol = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rearrangement.estimation_+3A_y">Y</code></td>
<td>
<p>The response variable.</p>
</td></tr>
<tr><td><code id="Rearrangement.estimation_+3A_index">Index</code></td>
<td>
<p>The estimated index. The user may obtain it using function <code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>.</p>
</td></tr>
<tr><td><code id="Rearrangement.estimation_+3A_t">t</code></td>
<td>
<p>A vector of points over which the link function <code class="reqn">H(.)</code> should be estimated. Default is the estimated index.</p>
</td></tr>
<tr><td><code id="Rearrangement.estimation_+3A_weights">weights</code></td>
<td>
<p>vector of sample weights. By default, each observation is given the same weight.</p>
</td></tr>
<tr><td><code id="Rearrangement.estimation_+3A_degree.pol">degree.pol</code></td>
<td>
<p>degree of the polynomial used in the local polynomial regression. Default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A first estimator of the link function, neglecting the assumption of monotonicity, is obtained with function <code><a href="locpol.html#topic+locpol">locpol</a></code> from the <em>locpol</em> package.
The final estimator is obtained through the rearrangement operation explained in Chernozhukov et al (2009). This operation is carried out with function <code><a href="Rearrangement.html#topic+rearrangement">rearrangement</a></code> from package <em>Rearrangement</em>.
</p>


<h3>Value</h3>

<p>A list with the following components
</p>

<dl>
<dt><code>t</code></dt><dd><p>the points over which the estimation has been undertaken.</p>
</dd>
<dt><code>H</code></dt><dd><p>the estimated link function evaluated at <em>t</em>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chernozhukov, V., I. Fernndez-Val, and A. Galichon (2009). Improving Point and Interval Estimators of Monotone Functions by Rearrangement. <em>Biometrika 96 (3)</em>. 55975.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="locpol.html#topic+locpol">locpol</a></code>, <code><a href="Rearrangement.html#topic+rearrangement">rearrangement</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Data.Incomes)
PLR &lt;- Lorenz.Reg(Income ~ ., data = Data.Incomes,
                  penalty = "SCAD", eps = 0.01)
Y &lt;- PLR$y
Index &lt;- predict(PLR)
Rearrangement.estimation(Y = Y, Index = Index)

</code></pre>

<hr>
<h2 id='runif_seed'>Generates a sample of uniform random variables with a specific seed</h2><span id='topic+runif_seed'></span>

<h3>Description</h3>

<p><code>runif_seed</code> generates a vector of uniform(0,1) random variables with a specific seed. The seed is only used locally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_seed(n, min = 0, max = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif_seed_+3A_n">n</code></td>
<td>
<p>the sample size</p>
</td></tr>
<tr><td><code id="runif_seed_+3A_seed">seed</code></td>
<td>
<p>the seed to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the generated random variables
</p>

<hr>
<h2 id='summary.LR'>Summary for the Lorenz regression</h2><span id='topic+summary.LR'></span><span id='topic+summary.LR_boot'></span>

<h3>Description</h3>

<p>Provides a summary for an object of class <code>"LR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.LR_+3A_object">object</code></td>
<td>
<p>An object of class <code>"LR"</code>. The object might also have S3 class <code>"LR_boot"</code> (which inherits from class <code>"PLR"</code>).</p>
</td></tr>
<tr><td><code id="summary.LR_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inference provided in the <code>coefficients</code> matrix is obtained by using the asymptotic normality and estimating the asymptotic variance via bootstrap.
</p>


<h3>Value</h3>

<p>An object of class <code>"summary.LR"</code>, containing the following elements:
</p>

<dl>
<dt><code>call</code></dt><dd><p>The matched call.</p>
</dd>
<dt><code>ineq</code></dt><dd><p>A matrix with one row and three columns providing information on explained inequality. The first column gives the explained Gini coefficient, the second column gives the Gini coefficient of the response. The third column gives the Lorenz-<code class="reqn">R^2</code>.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>A matrix providing information on the estimated coefficients. The first column gives the estimates.
If <code>object</code> inherits from <code>"LR_boot"</code>, bootstrap inference was performed and the matrix contains further information. The second column is the boostrap standard error. The third column is the z-value. Finally, the last column is the p-value.
In this case, the class <code>"summary.LR_boot"</code> is added to the output.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg) and example(Lorenz.boot)

</code></pre>

<hr>
<h2 id='summary.PLR'>Summary for the penalized Lorenz regression</h2><span id='topic+summary.PLR'></span><span id='topic+summary.PLR_boot'></span><span id='topic+summary.PLR_cv'></span>

<h3>Description</h3>

<p>Provides a summary for an object of class <code>"PLR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLR'
summary(object, renormalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PLR_+3A_object">object</code></td>
<td>
<p>An object of class <code>"PLR"</code>. The object might also have S3 classes <code>"PLR_boot"</code> and/or <code>"PLR_cv"</code> (both inherit from class <code>"PLR"</code>)</p>
</td></tr>
<tr><td><code id="summary.PLR_+3A_renormalize">renormalize</code></td>
<td>
<p>A logical value determining whether the coefficient vector should be re-normalized to match the representation where the first category of each categorical variable is omitted. Default value is TRUE</p>
</td></tr>
<tr><td><code id="summary.PLR_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"summary.PLR"</code>, which contains:
</p>

<dl>
<dt><code>call</code></dt><dd><p>The matched call.</p>
</dd>
<dt><code>ineq</code></dt><dd><p>A table of explained inequality metrics. The columns display the explained Gini coefficient, the Gini coefficient of the response, and the Lorenz-R2. The first row contains the results obtained by BIC.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>A matrix with estimated coefficients, each row corresponding to a specific coefficient. The first column contains the results obtained by BIC.</p>
</dd>
</dl>

<p>If the object inherits from <code>"PLR_boot"</code>, <code>ineq</code> and <code>coefficients</code> also include results from bootstrap, and the class <code>"summary.PLR_boot"</code> is added to the output.
Similarly, if the object inherits from <code>"PLR_cv"</code>, <code>ineq</code> and <code>coefficients</code> also include results from cross-validation, and the class <code>"summary.PLR_cv"</code> is added to the output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lorenz.Reg">Lorenz.Reg</a></code>, <code><a href="#topic+Lorenz.boot">Lorenz.boot</a></code>, <code><a href="#topic+PLR.CV">PLR.CV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(Lorenz.Reg), example(Lorenz.boot) and example(PLR.CV)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
