<!DOCTYPE html><html><head><title>Help for package MPSEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MPSEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MPSEM-package'><p>Modeling Phylogenetic Signals using Eigenvector Maps</p></a></li>
<li><a href='#graph-class'><p>Class and Method for Directed Graphs</p></a></li>
<li><a href='#graph-functions'><p>Graph Manipulation Functions</p></a></li>
<li><a href='#lm-utils'><p>Linear Modelling Utility Functions</p></a></li>
<li><a href='#PEM-class'><p>Class and Methods for Phylogenetic Eigenvector Maps (PEM)</p></a></li>
<li><a href='#PEM-functions'><p>Phylogenetic Eigenvector Maps</p></a></li>
<li><a href='#trait-simulator'><p>Simulates the Evolution of a Quantitative Trait.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-10</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling Phylogenetic Signals using Eigenvector Maps</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillaume Guenard, with contribution from Pierre Legendre</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computational tools to represent phylogenetic signals using adapted eigenvector maps.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), ape</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, caper, xtable</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-13 19:10:04 UTC; guenardg</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-13 20:52:47 UTC</td>
</tr>
</table>
<hr>
<h2 id='MPSEM-package'>Modeling Phylogenetic Signals using Eigenvector Maps</h2><span id='topic+MPSEM-package'></span>

<h3>Description</h3>

<p>Computational tools to represent phylogenetic signals using adapted eigenvector maps.
</p>


<h3>Details</h3>

<p>Phylogenetic eignevector maps (PEM) is a method for using phylogeny
to model features of organism, most notably quantitative traits. It consists
in calculating sets of explanatory variables (eigenvectors) that are meant to
represent different patters in trait values that are likely to have been
inducted by evolution. These patterns are used to model the data (using a
linear model for instance).
</p>
<p>If one gets a &lsquo;target&rsquo; species (i.e. a species for which the trait
value is unknown), and providing that we know the phylogenetic relationships
between that species and those of the model, the method allows to obtain the
scores of that new species on the phylogenetic eigenfunctions underlying a
PEM. These scores are used to make empirical predictions of trait values for
the target species on the basis of those observed for the species of the
model.
</p>
<p>Functions <code><a href="#topic+PEM.build">PEM.build</a></code>, <code><a href="#topic+PEM.updater">PEM.updater</a></code>,
<code><a href="#topic+PEM.fitSimple">PEM.fitSimple</a></code>, and <code><a href="#topic+PEM.forcedSimple">PEM.forcedSimple</a></code> allows one to
build, update (i.e. recalculate with alternate weighting parameters) as well
as to estimate or force arbitrary values for the weighting function
parameters.
</p>
<p>Functions <code><a href="#topic+getGraphLocations">getGraphLocations</a></code> and
<code><a href="#topic+Locations2PEMscores">Locations2PEMscores</a></code> allows one to make predictions using method
<code><a href="#topic+predict.PEM">predict.PEM</a></code> and a linear model. To obtain these linear model,
user can use function <code><a href="stats.html#topic+lm">lm</a></code> or auxiliary functions
<code><a href="#topic+lmforwardsequentialsidak">lmforwardsequentialsidak</a></code> or
<code><a href="#topic+lmforwardsequentialAICc">lmforwardsequentialAICc</a></code>, which perform forward-stepwise
variable addition on the basis of either familiwise type I error rate or the
Akaike Information Criterion (AIC), respectively.
</p>
<p>The package provides low-level utility function for performing operation on
graphs (see <a href="#topic+graph-functions">graph-functions</a>), calculate influence matrix
(<code><a href="#topic+PEMInfluence">PEMInfluence</a></code>), and simulate trait values (see
<a href="#topic+trait-simulator">trait-simulator</a>).
</p>
<p>A phylogenetic modeling tutorial using <code>MPSEM</code> is available as a
package vignette (see example below).
</p>
<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MPSEM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.4-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-01-10</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Modeling Phylogenetic Signals using Eigenvector Maps</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Guillaume Guenard, with contribution from Pierre Legendre</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Computational tools to represent phylogenetic signals using adapted eigenvector maps.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.0), ape</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, caper, xtable</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> MASS</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
MPSEM-package           Modeling Phylogenetic Signals using Eigenvector
                        Maps
PEM-class               Class and Methods for Phylogenetic Eigenvector
                        Maps (PEM)
PEM-functions           Phylogenetic Eigenvector Maps
graph-class             Class and Method for Directed Graphs
graph-functions         Graph Manipulation Functions
lm-utils                Linear Modelling Utility Functions
trait-simulator         Simulates the Evolution of a Quantitative
                        Trait.
</pre>


<h3>Author(s)</h3>

<p>Guillaume Guenard, with contribution from Pierre Legendre
Maintainer: Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu√©nard, G., Legendre, P., and Peres-Neto, P. 2013. Phylogenetic eigenvector
maps (PEM): a framework to model and predict species traits. Meth. Ecol.
Evol. 4: 1120&ndash;1131
</p>


<h3>See Also</h3>

<p>Makarenkov, V., Legendre, L. &amp; Desdevise, Y. 2004. Modelling phylogenetic
relationships using reticulated networks. Zool. Scr. 33: 89&ndash;96
</p>
<p>Blanchet, F. G., Legendre, P. &amp; Borcard, D. 2008. Modelling directional
spatial processes in ecological data. Ecol. Model. 215: 325-336
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## To view MPSEM tutorial
vignette("MPSEM", package="MPSEM")

</code></pre>

<hr>
<h2 id='graph-class'>Class and Method for Directed Graphs</h2><span id='topic+graph-class'></span><span id='topic+print.graph'></span>

<h3>Description</h3>

<p>Class and methods to handle graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graph'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-class_+3A_x">x</code></td>
<td>
<p>An object of <code><a href="#topic+graph-class">graph-class</a></code>.</p>
</td></tr>
<tr><td><code id="graph-class_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the method. Currently
ignored.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>A <code>graph-class</code> object contains:
</p>

<dl>
<dt> edge </dt><dd><p> A list whose first two unnamed members are the indices of
the origin and destination vertices. Additional members must be named and
are additional edge properties (e.g. length). </p>
</dd>
<dt> vertex </dt><dd><p> A list that optionally contain vertex properties, if any
(or an empty list if none). </p>
</dd>
</dl>



<h3>Details</h3>

<p>Prints user-relevant information about the graph: number of edges
and vertices, edge and vertex labels, addition edge properties and vertex
properties.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print.graph</code>: Print method for graph-class objects
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guenard, with contribution from Pierre Legendre
Maintainer: Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu√©nard, G., Legendre, P., and Peres-Neto, P. 2013. Phylogenetic eigenvector
maps (PEM): a framework to model and predict species traits. Meth. Ecol.
Evol. 4: 1120&ndash;1131
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEM.build">PEM.build</a></code>, <code><a href="#topic+PEM-class">PEM-class</a></code>
</p>

<hr>
<h2 id='graph-functions'>Graph Manipulation Functions</h2><span id='topic+graph-functions'></span><span id='topic+pop.graph'></span><span id='topic+add.vertex'></span><span id='topic+add.edge'></span><span id='topic+rm.edge'></span><span id='topic+rm.vertex'></span><span id='topic+collapse.vertex'></span><span id='topic+Phylo2DirectedGraph'></span>

<h3>Description</h3>

<p>A set of primitive functions for creating and munipulating
graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.graph(n, vertex = list(), label = NULL)

add.vertex(x, n, vertex = list(), label = NULL)

add.edge(x, from, to, edge = list(), label = NULL)

rm.edge(x, id)

rm.vertex(x, id)

collapse.vertex(x, id)

Phylo2DirectedGraph(tp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-functions_+3A_n">n</code></td>
<td>
<p>The number of vertex to populate a new graph (<code>pop.graph</code>) or
to add to an existing graph (<code>add.vertex</code>).</p>
</td></tr>
<tr><td><code id="graph-functions_+3A_vertex">vertex</code></td>
<td>
<p>A list of vertex properties.</p>
</td></tr>
<tr><td><code id="graph-functions_+3A_label">label</code></td>
<td>
<p>Labels to be given to edges or vertices.</p>
</td></tr>
<tr><td><code id="graph-functions_+3A_x">x</code></td>
<td>
<p>A <code>graph-class</code> object.</p>
</td></tr>
<tr><td><code id="graph-functions_+3A_from">from</code></td>
<td>
<p>The origins of the edge to be added (vertex labels or indices).</p>
</td></tr>
<tr><td><code id="graph-functions_+3A_to">to</code></td>
<td>
<p>The destinations of the edge to be added (vertex labels or
indices).</p>
</td></tr>
<tr><td><code id="graph-functions_+3A_edge">edge</code></td>
<td>
<p>A list of edge properties.</p>
</td></tr>
<tr><td><code id="graph-functions_+3A_id">id</code></td>
<td>
<p>Indentity (label or index) of vertex or edge to be removed.</p>
</td></tr>
<tr><td><code id="graph-functions_+3A_tp">tp</code></td>
<td>
<p>Phylogenetic tree object of class &lsquo;phylo&rsquo;, as defined in
<code><a href="ape.html#topic+ape-package">ape-package</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A new graph can be populated with <code>n</code> vertices using function
<code>pop.graph</code> and vertices can be added later with function
<code>add.vertex</code>. The graphs so created contain no edges; the latter are
added using function <code>add.edge</code>. Vertices and edges are removed using
functions <code>rm.vertex</code> and <code>rm.edge</code>, respectively.
</p>
<p>Function <code>collapse.vertex</code> allows one to remove a vertex while
reestablishing the connections between the vertices located above and below
that vertex using a new set of edges.
</p>
<p>Function <code>Phylo2DirectedGraph</code> uses the graph functions to convert a
rooted phylogenetic tree of class &lsquo;phylo&rsquo; (see
<code><a href="ape.html#topic+ape-package">ape-package</a></code>) to a <code><a href="#topic+graph-class">graph-class</a></code> object. It recycles
tip labels and creates default node labels, if they were absent from the
&lsquo;phylo&rsquo; object, and uses them as vertex labels. The resulting acyclic
graph can then be edited to represent cases that do not have a tree topology.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+graph-class">graph-class</a></code> object. Objects returned by
<code><a href="#topic+Phylo2DirectedGraph">Phylo2DirectedGraph</a></code> have a <code><a href="base.html#topic+numeric">numeric</a></code> edge property
called &lsquo;distance&rsquo; featuring branch lengths and a <code>link{logical}</code>
vertex property called &lsquo;species&rsquo; specifying whether a vertex is a tree
tip or an internal node.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pop.graph</code>: Creates a graph and populates it with vertices.
</p>
</li>
<li> <p><code>add.vertex</code>: Adds vertices to an existing graph.
</p>
</li>
<li> <p><code>add.edge</code>: Adds edges to a graph.
</p>
</li>
<li> <p><code>rm.edge</code>: Removes edges from a graph.
</p>
</li>
<li> <p><code>rm.vertex</code>: Removes vertices from a graph.
</p>
</li>
<li> <p><code>collapse.vertex</code>: Removes vertices from a graph while also removing their associated edges.
</p>
</li>
<li> <p><code>Phylo2DirectedGraph</code>: Transforms a phylogenetic tree into a directed graph.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guenard, with contribution from Pierre Legendre
Maintainer: Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu√©nard, G., Legendre, P., and Peres-Neto, P. 2013. Phylogenetic eigenvector
maps (PEM): a framework to model and predict species traits. Meth. Ecol.
Evol. 4: 1120&ndash;1131
</p>
<p>Makarenkov, V., Legendre, L. &amp; Desdevise, Y. 2004. Modelling phylogenetic
relationships using reticulated networks. Zool. Scr. 33: 89&ndash;96
</p>
<p>Blanchet, F. G., Legendre, P. &amp; Borcard, D. 2008. Modelling directional
spatial processes in ecological data. Ecol. Model. 215: 325&ndash;336
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph-class">graph-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Populate a graph with 7 vertices labeled A-G having properties x and y:
gr &lt;- pop.graph(n=7,
                vertex=list(x=rnorm(7,0,1),y=rnorm(7,0,1)),
                label=c("A","B","C","D","E","F","G"))
gr

## Adding 3 vertices H, I, and J with property x (y is absent) and a new
## property z (type character), which is unknown for A-G:
gr &lt;- add.vertex(x=gr,
                 n=3,
                 label=c("H","I","J"),
                 vertex=list(x=rnorm(3,0,1),z=c("A","B","C")))
gr
gr$vertex

## Adding 10 edges, labeled E1-E10 and with properties a and b, to the graph:
gr &lt;- add.edge(x=gr,
               from=c("A","B","B","C","C","D","D","E","E","F"),
               to=c("A","C","D","E","F","F","G","H","I","J"),
               edge=list(a=rnorm(10,0,1),b=rnorm(10,0,1)),
               label=paste("E",1:10,sep=""))
gr
gr$edge

## Removing edges 2, 4, and 7 from the graph:
print(rm.edge(gr,id=c(2,4,7)))

## Removing vertices 1, 3, 7, and 10 from the graph:
print(rm.vertex(gr,id=c(1,3,7,10)))
# Notice that the edges that had one of the removed vertex as their
# origin or destination are also removed:
print.default(rm.vertex(gr,id=c(1,3,7,10)))

## Vertex collapsing.
x &lt;- pop.graph(n=9,label=c("A","B","C","D","E","F","G","H","I"))
x &lt;- add.edge(x,from=c("A","A","B","B","C","C","D","D","E","E"),
              to=c("B","C","D","E","E","I","F","G","G","H"),
              label=paste("E",1:10,sep=""),
              edge=list(length=c(1,2,3,2,1,3,2,2,1,3)))
print.default(x)
for(i in c("A","B","C","D","E","F","G","H","I"))
  print(collapse.vertex(x,id=i))

if(require(ape)) {
  tree1 &lt;- read.tree(
    text=paste(
      "(((A:0.15,B:0.2)N4:0.15,C:0.35)N2:0.25,((D:0.25,E:0.1)N5:0.3,",
      "(F:0.15,G:0.2)N6:0.3)N3:0.1)N1;",sep=""))
  x &lt;- Phylo2DirectedGraph(tree1)
  print(x)
}

</code></pre>

<hr>
<h2 id='lm-utils'>Linear Modelling Utility Functions</h2><span id='topic+lm-utils'></span><span id='topic+lmforwardsequentialAICc'></span><span id='topic+lmforwardsequentialsidak'></span>

<h3>Description</h3>

<p>Utility functions to build linear models using Phylogenetic
Eigenvector Maps among their explanatory variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmforwardsequentialAICc(y, x, object)

lmforwardsequentialsidak(y, x, object, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm-utils_+3A_y">y</code></td>
<td>
<p>A response variable.</p>
</td></tr>
<tr><td><code id="lm-utils_+3A_x">x</code></td>
<td>
<p>Descriptors to be used as auxiliary traits.</p>
</td></tr>
<tr><td><code id="lm-utils_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+PEM-class">PEM-class</a></code> object.</p>
</td></tr>
<tr><td><code id="lm-utils_+3A_alpha">alpha</code></td>
<td>
<p>The threshold above which to stop adding variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+lmforwardsequentialsidak">lmforwardsequentialsidak</a></code>, performs a forward
stepwise selection of the PEM eigenvectors until the familywise test of
significance of the new variable to be included exceeds the
threshold <code>alpha</code>. The familiwise type I error probability is obtained
using the Holm-Sidak correction of the testwise probabilities, thereby
correcting for type I error rate inflation due to multiple testing.
<code>lmforwardsequentialAICc</code> carries out forward stepwise selection of the
eigenvectors as long as the candidate model features a lower
sample-size-corrected Akaike information criterion than the previous model.
The final model should be regarded as overfit from the Neyman-Pearson
(<em>i.e.</em> frequentist) point of view, but it is the model that minimizes
information loss from the standpoint of information theory.
</p>


<h3>Value</h3>

<p>An <code><a href="stats.html#topic+lm">lm</a>-class</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>lmforwardsequentialAICc</code>: Forward stepwise variable addition using the sample-size-corrected Akaike
Information Criterion.
</p>
</li>
<li> <p><code>lmforwardsequentialsidak</code>: Forward stepwise variable addition using a Sidak multiple testing
corrected alpha error threshold as the stopping criterion.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guenard, with contribution from Pierre Legendre
Maintainer: Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;
</p>


<h3>References</h3>

<p>Burnham, K. P. &amp; Anderson, D. R. 2002. Model selection and multimodel
inference: a practical information-theoretic approach, 2nd ed.
Springer-Verlag. xxvi + 488 pp.
</p>
<p>Holm, S. 1979. A simple sequentially rejective multiple test procedure.
Scand. J. Statist. 6: 65-70.
</p>
<p>Sidak, Z. 1967. Rectangular confidence regions for means of multivariate
normal distributions. J. Am. Stat. Ass. 62, 626-633.
</p>

<hr>
<h2 id='PEM-class'>Class and Methods for Phylogenetic Eigenvector Maps (PEM)</h2><span id='topic+PEM-class'></span><span id='topic+print.PEM'></span><span id='topic+as.data.frame.PEM'></span><span id='topic+predict.PEM'></span>

<h3>Description</h3>

<p>Class and methods to handle Phylogenetic Eigenvector Maps (PEM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PEM'
print(x, ...)

## S3 method for class 'PEM'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S3 method for class 'PEM'
predict(
  object,
  targets,
  lmobject,
  newdata,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEM-class_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PEM-class">PEM-class</a></code> object containing a Phylogenetic
Eigenvector Map.</p>
</td></tr>
<tr><td><code id="PEM-class_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the method. Currently
ignored.</p>
</td></tr>
<tr><td><code id="PEM-class_+3A_row.names">row.names</code></td>
<td>
<p>Included for method consistency reason; ignored.</p>
</td></tr>
<tr><td><code id="PEM-class_+3A_optional">optional</code></td>
<td>
<p>Included for method consistency reason; ignored.</p>
</td></tr>
<tr><td><code id="PEM-class_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+PEM-class">PEM-class</a></code> object.</p>
</td></tr>
<tr><td><code id="PEM-class_+3A_targets">targets</code></td>
<td>
<p>Output of <code><a href="#topic+getGraphLocations">getGraphLocations</a></code>.</p>
</td></tr>
<tr><td><code id="PEM-class_+3A_lmobject">lmobject</code></td>
<td>
<p>An object of class &lsquo;lm&rsquo; (see <code><a href="stats.html#topic+lm">lm</a></code> for
details).</p>
</td></tr>
<tr><td><code id="PEM-class_+3A_newdata">newdata</code></td>
<td>
<p>Auxiliary trait values.</p>
</td></tr>
<tr><td><code id="PEM-class_+3A_interval">interval</code></td>
<td>
<p>The kind of limits (confidence or prediction) to return with
the predictions; <code>interval="none"</code>: do not return a confidence interval.</p>
</td></tr>
<tr><td><code id="PEM-class_+3A_level">level</code></td>
<td>
<p>Probability of the confidence of prediction interval.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>A <code><a href="#topic+PEM-class">PEM-class</a></code> object contains:
</p>

<dl>
<dt> x </dt><dd><p> The <code><a href="#topic+graph-class">graph-class</a></code> object that was used to
build the PEM (see <code><a href="#topic+PEM.build">PEM.build</a></code>). </p>
</dd>
<dt> sp </dt><dd><p> A <code><a href="base.html#topic+logical">logical</a></code> vector specifying which vertex is
a tip. </p>
</dd>
<dt> B </dt><dd><p> The influence matrix for those vertices that are tips. </p>
</dd>
<dt> ne </dt><dd><p> The number of edges. </p>
</dd>
<dt> nsp </dt><dd><p> The number of species (tips). </p>
</dd>
<dt> Bc </dt><dd><p> The column-centred influence matrix. </p>
</dd>
<dt> means </dt><dd><p> The column means of <code>B</code>. </p>
</dd>
<dt> dist </dt><dd><p> Edge lengths. </p>
</dd>
<dt> a </dt><dd><p> The steepness parameter (see <code><a href="#topic+PEM.build">PEM.build</a></code> for
details). </p>
</dd>
<dt> psi </dt><dd><p> The relative evolution rate along the edges (see
<code><a href="#topic+PEM.build">PEM.build</a></code> for details). </p>
</dd>
<dt> w </dt><dd><p> Edge weights. </p>
</dd>
<dt> BcW </dt><dd><p> The weighted and column-centred influence matrix. </p>
</dd>
<dt> d </dt><dd><p> The singular values of <code>BcW</code>. </p>
</dd>
<dt> u </dt><dd><p> The eigenvectors (left singular vectors) of <code>BcW</code>. </p>
</dd>
<dt> vt </dt><dd><p> The right singular vectors of <code>BcW</code>. </p>
</dd>
</dl>

<p>In addition to these standard component, function,
<code><a href="#topic+PEM.fitSimple">PEM.fitSimple</a></code> and <code><a href="#topic+PEM.forcedSimple">PEM.forcedSimple</a></code> add the
following members, which are necessary to make predictions:
</p>

<dl>
<dt> S2 </dt><dd><p> The variances of responses (one value for each response).
</p>
</dd>
<dt> y </dt><dd><p> A copy of the responses. </p>
</dd>
<dt> opt </dt><dd><p> The list returned by <code><a href="stats.html#topic+optim">optim</a></code>. </p>
</dd>
</dl>

<p>The estimated weighting parameters are also given as an edge property.
</p>


<h3>Details</h3>

<p>The <code><a href="base.html#topic+print">print</a></code> method provides the number of eigenvectors,
the number of observations these vectors are spanning, and their associated
eigenvalues.
</p>
<p>The <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> method extracts the eigenvectors from the
object and allows one to use <code><a href="#topic+PEM-class">PEM-class</a></code> objects as <code>data</code>
parameter in function such as <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+glm">glm</a></code>.
</p>
<p>The <code><a href="stats.html#topic+predict">predict</a></code> object is a barebone interface meant to make
predictions. It must be given species locations with respect to the
phylogenetic graph (<code>target</code>), which are provided by function
<code><a href="#topic+getGraphLocations">getGraphLocations</a></code> and a linear model in the form of an object
from <code><a href="stats.html#topic+lm">lm</a></code>. The user must provide auxiliary trait values if
<code>lmobject</code> involves such trait.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print.PEM</code>: Print method for PEM-class objects
</p>
</li>
<li> <p><code>as.data.frame.PEM</code>: Method <code>as.data.frame</code> for PEM-class objects
</p>
</li>
<li> <p><code>predict.PEM</code>: Predict method for PEM-class objects
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guenard, with contribution from Pierre Legendre
Maintainer: Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu√©nard, G., Legendre, P., and Peres-Neto, P. 2013. Phylogenetic eigenvector
maps (PEM): a framework to model and predict species traits. Meth. Ecol.
Evol. 4: 1120&ndash;1131
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEM.build">PEM.build</a></code>, <code><a href="#topic+PEM-class">PEM-class</a></code>
</p>

<hr>
<h2 id='PEM-functions'>Phylogenetic Eigenvector Maps</h2><span id='topic+PEM-functions'></span><span id='topic+PEMInfluence'></span><span id='topic+PEMweights'></span><span id='topic+PEM.build'></span><span id='topic+PEM.updater'></span><span id='topic+PEM.fitSimple'></span><span id='topic+PEM.forcedSimple'></span><span id='topic+getGraphLocations'></span><span id='topic+getAncGraphLocations'></span><span id='topic+Locations2PEMscores'></span>

<h3>Description</h3>

<p>Functions to calculate and manipulate Phylogenetic Eigenvector
Maps (PEM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEMInfluence(x, mroot = TRUE)

PEMweights(d, a = 0, psi = 1)

PEM.build(
  x,
  d = "distance",
  sp = "species",
  a = 0,
  psi = 1,
  tol = .Machine$double.eps^0.5
)

PEM.updater(object, a, psi = 1, tol = .Machine$double.eps^0.5)

PEM.fitSimple(
  y,
  x,
  w,
  d = "distance",
  sp = "species",
  lower = 0,
  upper = 1,
  tol = .Machine$double.eps^0.5
)

PEM.forcedSimple(
  y,
  x,
  w,
  d = "distance",
  sp = "species",
  a = 0,
  psi = 1,
  tol = .Machine$double.eps^0.5
)

getGraphLocations(tpall, targets)

getAncGraphLocations(x, tpall)

Locations2PEMscores(object, gsc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEM-functions_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+graph-class">graph-class</a></code> object containing a phylogenetic graph.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_mroot">mroot</code></td>
<td>
<p>Boolean (TRUE or FALSE) specifying whether multiple rooting is
allowed.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_d">d</code></td>
<td>
<p>The name of the member of <code>x$edge</code> where the phylogenetic
distances (edge lengths) can be found.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_a">a</code></td>
<td>
<p>The steepness parameter describing whether changes occur, on
average, progressively long edges (a close to 0) or abruptly at vertices (a
close to 1).</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_psi">psi</code></td>
<td>
<p>Relative evolution rate along the edges (default: 1). This
parameter is only relevant when multiple values are assigned to different
portions of the phylogeny.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_sp">sp</code></td>
<td>
<p>Name of the member of <code>x$vertex</code> where a <code><a href="base.html#topic+logical">logical</a></code>
vertex property specifying which vertices are species can be found. (see
<code><a href="#topic+graph-class">graph-class</a></code>).</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_tol">tol</code></td>
<td>
<p>Eigenvalue threshold to regard eigenvectors as usable.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+PEM-class">PEM-class</a></code> object containing a Phylogenetic
Eigenvector Map.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_y">y</code></td>
<td>
<p>One or many response variable(s) in the form of a numeric vector or
a <code><a href="base.html#topic+matrix">matrix</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_w">w</code></td>
<td>
<p>A <code><a href="#topic+graph-class">graph-class</a></code> object containing a phylogenetic graph.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_lower">lower</code></td>
<td>
<p>Lower limit for the L-BFGS-B optimization algorithm as
implemented in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_upper">upper</code></td>
<td>
<p>Upper limit for the L-BFGS-B optimization algorithm as
implemented in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_tpall">tpall</code></td>
<td>
<p>Parameter of function <code>getGraphLocations</code>: Phylogenetic
tree object of class &lsquo;phylo&rsquo; (package <a href="ape.html#topic+ape">ape</a>) containing all
species (model and target) used in the study.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_targets">targets</code></td>
<td>
<p>Name of the target species to extract using the <code>tpall</code>.</p>
</td></tr>
<tr><td><code id="PEM-functions_+3A_gsc">gsc</code></td>
<td>
<p>The output of <code>getGraphLocations</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code><a href="#topic+PEMInfluence">PEMInfluence</a></code> and <code><a href="#topic+PEMweights">PEMweights</a></code>
are used internally by <code><a href="#topic+PEM.build">PEM.build</a></code> to create a binary matrix
referred to as an &lsquo;influence matrix&rsquo; and weight its columns. That
matrix has a row for each vertex of graph &lsquo;x&rsquo; and a column for each of
its edges. The elements of the influence matrix are 1 whenever the vertex
associated with a row is located in the tree either directly or indirectly
downward the edge associated with a column. That function is implemented in C
language using recursive function calls. Although <code><a href="#topic+PEMInfluence">PEMInfluence</a></code>
allows one to use multiple roots as its default parameter, it is called
within <code>PEM.build</code> with <code>mroot = FALSE</code>. User must therefore ensure
that the graph provided to <code>PEMap</code> is single-rooted.
</p>
<p>Function <code><a href="#topic+PEM.build">PEM.build</a></code> is used to produce a phylogenetic
eigenvector map, while function <code><a href="#topic+PEM.updater">PEM.updater</a></code> allows one to
re-calculate a <code><a href="#topic+PEM-class">PEM-class</a></code> object with new weighting function
parameters. Function <code><a href="#topic+PEM.fitSimple">PEM.fitSimple</a></code> performs a maximum
likelihood estimation of <code>a</code> and <code>psi</code> assuming single values for
the whole tree whereas function <code><a href="#topic+PEM.forcedSimple">PEM.forcedSimple</a></code> allows one the
force parameters <code>a</code> and <code>psi</code> to a <code><a href="#topic+PEM-class">PEM-class</a></code> object
while adding the same computational details as those
<code><a href="#topic+PEM.fitSimple">PEM.fitSimple</a></code> would have produced (and which are necessary to
make predictions).
</p>
<p>Functions <code><a href="#topic+getGraphLocations">getGraphLocations</a></code> returns the coordinates of a
species in terms of its position with respect to the influence matrix while
function <code><a href="#topic+Locations2PEMscores">Locations2PEMscores</a></code> transforms these coordinates into
sets of scores that can be used to make predictions. Function
<code><a href="#topic+getAncGraphLocations">getAncGraphLocations</a></code> produce the same output as
<code><a href="#topic+getGraphLocations">getGraphLocations</a></code>, but of the ancestral species (i.e. the nodes
of the phylogeny) in order to estimate ancestral trait values.
</p>


<h3>Value</h3>

<p>Function <code><a href="#topic+PEMInfluence">PEMInfluence</a></code> returns the influence matrix of
graph <code>x</code> and function <code><a href="#topic+PEMweights">PEMweights</a></code> returns weights
corresponding to the distances. Functions <code><a href="#topic+PEM.build">PEM.build</a></code>,
<code><a href="#topic+PEM.fitSimple">PEM.fitSimple</a></code>, <code><a href="#topic+PEM.forcedSimple">PEM.forcedSimple</a></code> returns a
<code><a href="#topic+PEM-class">PEM-class</a></code> object. Function <code><a href="#topic+getGraphLocations">getGraphLocations</a></code>
returns a list whose first member is an influence coordinates matrix whose
rows refer to the target species and columns refer to the edges and second
member is the lengths of the terminal edges connecting each target species to
the rest of the phylogeny. Function <code><a href="#topic+Locations2PEMscores">Locations2PEMscores</a></code> returns
a list whose first member is a PEM score matrix whose rows refer to the
target species and columns refer to the eigenvectors and second member is the
variance associated with the terminal edges connecting the target species to
the phylogeny.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>PEMInfluence</code>: Calculate the influence matrix of a phylogenetic graph.
</p>
</li>
<li> <p><code>PEMweights</code>: Calculates the edge weights to be used in PEM calculation.
</p>
</li>
<li> <p><code>PEM.build</code>: Calculates a PEM with parameters given by arguments a and psi.
</p>
</li>
<li> <p><code>PEM.updater</code>: Update a PEM with new parameters given by arguments a and psi.
</p>
</li>
<li> <p><code>PEM.fitSimple</code>: Fit a PEM with a single &ldquo;a&rdquo; parameter value for the whole phylogeny
(assumes psi = 1).
</p>
</li>
<li> <p><code>PEM.forcedSimple</code>: Calculates a PEM while forcing a single value for parameter &ldquo;a&rdquo; for the
whole phylogeny (assumes psi = 1).
</p>
</li>
<li> <p><code>getGraphLocations</code>: Get the location of species on a phylogenic graph.
</p>
</li>
<li> <p><code>getAncGraphLocations</code>: Get the location of an ancestral species on the phylogenetic graph.
</p>
</li>
<li> <p><code>Locations2PEMscores</code>: Calculates the PEM scores on phylogenetic graph locations.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guenard, with contribution from Pierre Legendre
Maintainer: Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;
</p>


<h3>References</h3>

<p>Gu√©nard, G., Legendre, P., and Peres-Neto, P. 2013. Phylogenetic eigenvector
maps (PEM): a framework to model and predict species traits. Meth. Ecol.
Evol. 4: 1120&ndash;1131
</p>
<p>Makarenkov, V., Legendre, L. &amp; Desdevise, Y. 2004. Modelling phylogenetic
relationships using reticulated networks. Zool. Scr. 33: 89&ndash;96
</p>
<p>Blanchet, F. G., Legendre, P. &amp; Borcard, D. 2008. Modelling directional
spatial processes in ecological data. Ecol. Model. 215: 325&ndash;336
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph-class">graph-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- read.tree(text=paste(
            "(((A:0.15,B:0.2)N4:0.15,C:0.35)N2:0.25,((D:0.25,E:0.1)N5:0.3,",
            "(F:0.15,G:0.2)N6:0.3)N3:0.1)N1;",sep=""))
x &lt;- Phylo2DirectedGraph(t1)

## Calculates the (binary) influence matrix
PEMInfluence(x)
PEMInfluence(x)[x$vertex$species,]

## Building phylogenetic eigenvector maps
PEM1 &lt;- PEM.build(x)
print(PEM1)
PEM2 &lt;- PEM.build(x, a = 0.2)
PEM3 &lt;- PEM.build(x, a = 1)
PEM4 &lt;- PEM.updater(PEM3,a=0.5)

## Extracts the eigenvectors
as.data.frame(PEM4)

## Example of an hypothetical set of trait values
y &lt;- c(A=-1.1436265,B=-0.3186166,C=1.9364105,D=1.7164079,E=1.0013993,
       F=-1.8586351,G=-2.0236371)

## Estimate single steepness parameter for the whole tree.
PEMfs1 &lt;- PEM.fitSimple(y=y,x=NULL,w=x,d="distance",sp="species",lower=0,upper=1)
PEMfs1$optim       # Results of the optimization.

## Force neutral evolution for the whole tree.
PEMfrc1 &lt;- PEM.forcedSimple(y=y,x=NULL,w=x,d="distance",sp="species",a=0)
PEMfrc1$x$edge$a   # Steepness parameter forced for each individual edge.

## Get graph locations for target species X, Y, and Z
tpAll &lt;- read.tree(text=paste("((X:0.45,((A:0.15,B:0.2)N4:0.15,",
                              "(C:0.25,Z:0.2)NZ:0.1)N2:0.05)NX:0.2,",
                              "(((D:0.25,E:0.1)N5:0.05,Y:0.25)NY:0.25,",
                              "(F:0.15,G:0.2)N6:0.3)N3:0.1)N1;",sep=""))
grloc &lt;- getGraphLocations(tpAll, c("X","Y","Z"))

PEMfs2 &lt;- PEM.fitSimple(y=y, x=NULL, w=grloc$x, d="distance", sp="species",
                        lower=0,upper=1)

## Same as for PEMfs1$optim
PEMfs2$optim

PEMsc1 &lt;- Locations2PEMscores(PEMfs2, grloc)
lm1 &lt;- lm(y~V_2+V_3+V_5,data=PEMfs2)

ypred &lt;- predict(object=PEMfs2,targets=grloc,lmobject=lm1,interval="none")

tpModel &lt;- drop.tip(tpAll,c("X","Y","Z"))

## Plotting the results:
layout(t(c(1,1,2)))
par(mar=c(6,2,2,0.5)+0.1)
plot(tpModel,show.tip.label=TRUE,show.node.label=TRUE,root.edge = TRUE,
     srt = 0,adj=0.5,label.offset=0.08,font=1,cex=1.5,xpd=TRUE)
edgelabels(paste("E",1:nrow(tpModel$edge),sep=""),
           edge=1:nrow(tpModel$edge),bg="white",font=1,cex=1)
points(x=0.20,y=2.25,pch=21,bg="black")
lines(x=c(0.20,0.20,0.65),y=c(2.25,0.55,0.55),xpd=TRUE,lty=2)
text("X",x=0.69,y=0.55,xpd=TRUE,font=1,cex=1.5)
points(x=0.35,y=4.5,pch=21,bg="black")
lines(x=c(0.35,0.35,0.6),y=c(4.5,5.47,5.47),xpd=TRUE,lty=2)
text("Y",x=0.64,y=5.47,xpd=TRUE,font=1,cex=1.5)
points(x=0.35,y=3,pch=21,bg="black")
lines(x=c(0.35,0.35,0.55),y=c(3,3.5,3.5),xpd=TRUE,lty=2)
text("Z",x=0.59,y=3.5,xpd=TRUE,font=1,cex=1.5)
text(c("NX","NY","NZ"),x=c(0.20,0.35,0.35),y=c(2.25,4.5,3)+0.3*c(1,-1,-1),
     font=1,cex=1)
add.scale.bar(length=0.1,cex=1.25)
par(mar=c(3.75,0,2,2)+0.1)
plot(x=y,y=1:7,ylim=c(0.45,7),xlim=c(-4,4), axes=FALSE, type="n", xlab="")
axis(1,label=c("-4","-2","0","2","4"),at=c(-4,-2,0,2,4))
abline(v=0)

## Observed values:
points(x=y,y=1:7,xlim=c(-2,2),pch=21,bg="black")
text("B)",x=-3.5,y=7,cex=1.5,xpd=TRUE) ; text("Trait value",x=0,y=-0.5,
     cex=1.25,xpd=TRUE)

## Predicted values:
points(x=ypred,y=c(0.5,5.5,3.5),pch=23,bg="white",cex=1.25)

## Estimating ancestral trait values:
ANCloc &lt;- getAncGraphLocations(x)
PEMfsAnc &lt;- PEM.fitSimple(y=y,x=NULL,w=ANCloc$x,d="distance",sp="species",
                          lower=0,upper=1)
PEMfsAnc$optim

PEManc1 &lt;- Locations2PEMscores(PEMfsAnc, ANCloc)
y_anc &lt;- predict(object=PEMfsAnc,targets=ANCloc,lmobject=lm1,
                 interval="confidence")

</code></pre>

<hr>
<h2 id='trait-simulator'>Simulates the Evolution of a Quantitative Trait.</h2><span id='topic+trait-simulator'></span><span id='topic+EvolveOptimMarkovTree'></span><span id='topic+TraitOUsimTree'></span><span id='topic+OUvar'></span><span id='topic+PEMvar'></span><span id='topic+TraitVarGraphSim'></span>

<h3>Description</h3>

<p>Functions to simulate the evolution of a quantitative trait
along a phylogenetic tree inputted as an object of class &lsquo;phylo&rsquo;
(package <a href="ape.html#topic+ape">ape</a>) or <code><a href="#topic+graph-class">graph-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvolveOptimMarkovTree(tp, tw, anc, p = 1, root = tp$edge[1, 1])

TraitOUsimTree(tp, a, sigma, opt, p = 1, root = tp$edge[1, 1])

OUvar(d, a = 0, theta = 1, sigma = 1)

PEMvar(d, a = 0, psi = 1)

TraitVarGraphSim(x, variance, distance = "distance", p = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trait-simulator_+3A_tp">tp</code></td>
<td>
<p>A rooted phylogenetic tree of class &lsquo;phylo&rsquo; (see package
<a href="ape.html#topic+ape">ape</a>).</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_tw">tw</code></td>
<td>
<p>Transition matrix giving the probability that the optimum trait
value changes from one state to another at vertices. All rows must sum to 1.</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_anc">anc</code></td>
<td>
<p>Ancestral state of a trait (at the root).</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_p">p</code></td>
<td>
<p>Number of variates to generate.</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_root">root</code></td>
<td>
<p>Root node of the tree.</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_a">a</code></td>
<td>
<p>Selection rate (<code><a href="#topic+OUvar">OUvar</a></code>) or steepness
(<code><a href="#topic+PEMvar">PEMvar</a></code>).</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_sigma">sigma</code></td>
<td>
<p>Neutral evolution rate, i.e. mean trait shift by drift.</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_opt">opt</code></td>
<td>
<p>An index vector of optima at the nodes.</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_d">d</code></td>
<td>
<p>Phylogenetic distances (edge lengths).</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_theta">theta</code></td>
<td>
<p>Adaptive evolution rate, i.e. mean trait shift by natural
selection.</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_psi">psi</code></td>
<td>
<p>Mean evolution rate.</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+graph-class">graph-class</a></code> object.</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_variance">variance</code></td>
<td>
<p>Variance function (<code><a href="#topic+OUvar">OUvar</a></code>, <code><a href="#topic+PEMvar">PEMvar</a></code>,
or any suitable user-defined function).</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_distance">distance</code></td>
<td>
<p>The name of the member of &lsquo;x$edge&rsquo; where edge lengths
can be found.</p>
</td></tr>
<tr><td><code id="trait-simulator_+3A_...">...</code></td>
<td>
<p>Additional parameters for the specified variance function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>EvolveOptimMarkovTree</code> allows one to simulate the
changes of optimum trait values as a Markov process. The index whereby the
process starts, at the tree root, is set by parameter <code>anc</code>; this is the
ancestral character state. From the root onwards to the tips, the optimum is
given the opportunity to change following a multinomial random draw with
transition probabilities given by the rows of matrix <code>tw</code>. The integers
thus obtained can be used as indices of a vector featuring the actual optimum
trait values corresponding to the simulated selection regimes. The resulting
optimum trait values at the nodes are used by <code><a href="#topic+TraitOUsimTree">TraitOUsimTree</a></code> as
its parameters <code>opt</code> to simulate trait values at nodes and tips.
Function <code><a href="#topic+TraitVarGraphSim">TraitVarGraphSim</a></code> uses a graph variance function
(either <code>OUvar</code> or <code>PEMvar</code>) to reconstruct a covariance matrix
that is used to generate covariates drawn from a multi-normal distribution.
</p>


<h3>Value</h3>

<p>Functions <code><a href="#topic+EvolveOptimMarkovTree">EvolveOptimMarkovTree</a></code> and
<code><a href="#topic+TraitOUsimTree">TraitOUsimTree</a></code> return a matrix whose rows represent the
vertices (nodes and tips) of the phylogenetic tree and whose columns stand
for the <code>n</code> different trials the function was asked to perform. For
<code>EvolveQTraitTree</code>, the elements of the matrix are integers,
representing the selection regimes prevailing at the nodes and tips, whereas
for <code><a href="#topic+TraitOUsimTree">TraitOUsimTree</a></code>, the elements are simulated quantitative
trait values at the nodes and tips. These functions are implemented in C
language and therefore run swiftly even for large (10000+ species) trees.
</p>
<p>Function <code><a href="#topic+TraitVarGraphSim">TraitVarGraphSim</a></code> returns <code>p</code> phylogenetic signals
and is implemented using a rotation of a matrix of standard normal random
(mean=0, variance=1) deviates. The rotation matrix is itself obtained by
Choleski factorization of the trait covariance matrix expected for a given
set of trees, variance function, and variance function parameters.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>EvolveOptimMarkovTree</code>: Simulates the evolution of trait optima along a phylogeny.
</p>
</li>
<li> <p><code>TraitOUsimTree</code>: Simulates the evolution of trait values along a phylogeny.
</p>
</li>
<li> <p><code>OUvar</code>: Describe here...
</p>
</li>
<li> <p><code>PEMvar</code>: Describe here...
</p>
</li>
<li> <p><code>TraitVarGraphSim</code>: Describe here...
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guenard, with contribution from Pierre Legendre
Maintainer: Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;
</p>


<h3>References</h3>

<p>Butler, M. A. &amp; King, A. A. 2004. Phylogenetic comparative analysis: a
modeling approach for adaptive evolution. Am. Nat. 164: 683-695.
</p>
<p>Gu√©nard, G., Legendre, P., and Peres-Neto, P. 2013. Phylogenetic eigenvector
maps (PEM): a framework to model and predict species traits. Meth. Ecol.
Evol. 4: 1120&ndash;1131
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opt &lt;- c(-2,0,2) # Three trait optima: -2, 0, and 2
## Transition probabilities:
transit &lt;- matrix(c(0.7,0.2,0.2,0.2,0.7,0.1,0.1,0.1,0.7),
                  length(opt),length(opt),dimnames=list(from=opt,to=opt))

## In this example, the trait has a probability of 0.7 to stay at a given
## optimum, a probability of 0.2 for the optimum to change from -2 to 0,
## from 0 to -2, and from 2 to -2, and a probability of 0.1 for the
## optimum to change from -2 to 2, from 0 to 2, and from 2 to 0.
nsp &lt;- 25  # A random tree for 25 species.
tree2 &lt;- rtree(nsp,tip.label=paste("Species",1:nsp,sep=""))
tree2$node.label=paste("N",1:tree2$Nnode,sep="")  # Node labels.

## Simulate 10 trials of optimum change.
reg &lt;- EvolveOptimMarkovTree(tp=tree2,tw=transit,p=10,anc=2)
y1 &lt;- TraitOUsimTree(tp=tree2,a=0,sigma=1,
                     opt=opt[reg[,1]],p=10)    ## Neutral
y2 &lt;- TraitOUsimTree(tp=tree2,a=1,sigma=1,
                     opt=opt[reg[,1]],p=10)    ## Few selection.
y3 &lt;- TraitOUsimTree(tp=tree2,a=10,sigma=1,
                     opt=opt[reg[,1]],p=10)    ## Strong selection.

## Display optimum change with colours.
displayOUprocess &lt;- function(tp,trait,regime,mvalue) {
  layout(matrix(1:2,1,2))
  n &lt;- length(tp$tip.label)
  ape::plot.phylo(tp,show.tip.label=TRUE,show.node.label=TRUE,root.edge=FALSE,
                  direction="rightwards",adj=0,
                  edge.color=rainbow(length(trait))[regime[tp$edge[,2]]])
  plot(y=1:n,x=mvalue[1:n],type="b",xlim=c(-5,5),ylab="",xlab="Trait value",yaxt="n",
       bg=rainbow(length(trait))[regime[1:n]],pch=21) 
  text(trait[regime[1:n]],y=1:n,x=5,col=rainbow(length(trait))[regime[1:n]])
  abline(v=0)
}

displayOUprocess(tree2,opt,reg[,1],y1[,1])  # Trait evolve neutrally,
displayOUprocess(tree2,opt,reg[,1],y2[,1])  # under weak selection,
displayOUprocess(tree2,opt,reg[,1],y3[,1])  # under strong selection.

x &lt;- Phylo2DirectedGraph(tree2)
y4 &lt;- TraitVarGraphSim(x, variance = OUvar, p=10, a=5)

DisplayTreeEvol &lt;- function(tp,mvalue) {
  layout(matrix(1:2,1,2))
  n &lt;- length(tp$tip.label)
  ape::plot.phylo(tp,show.tip.label = TRUE, show.node.label = TRUE,
                  root.edge = FALSE, direction = "rightwards", adj = 0)
  plot(y=1:n, x=mvalue[1:n], type="b", xlim=c(-5,5), ylab="",
       xlab="Trait value", yaxt="n", pch=21)
  abline(v=0)
}

## Recursively displays the simulated traits.
for(i in 1:10) {
  DisplayTreeEvol(tree2,y4[i,])
  if(is.null(locator(1)))
    break                  ## Stops recursive display on a mouse right-click.
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
