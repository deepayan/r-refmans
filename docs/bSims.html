<!DOCTYPE html><html><head><title>Help for package bSims</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bSims}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bsims_init'>
<p>bSims simulation functions</p></a></li>
<li><a href='#acceptreject'>
<p>Spatial point process simulator</p></a></li>
<li><a href='#dist_fun2'>
<p>Distance function with segmented attenuation</p></a></li>
<li><a href='#estimate'>
<p>Estimate basic parameters</p></a></li>
<li><a href='#events'>
<p>Event time simulator</p></a></li>
<li><a href='#expand_list'>
<p>Create a list from all combinations of arguments</p></a></li>
<li><a href='#get_nests'>
<p>Access nests, events, detections, and totals</p></a></li>
<li><a href='#internals'>
<p>Internal functions</p></a></li>
<li><a href='#plot.bsims_landscape'>
<p>Plot methods</p></a></li>
<li><a href='#rlnorm2'>
<p>Reparametrized lognormal distribution</p></a></li>
<li><a href='#rmvn'>
<p>Multivariate normal distribution</p></a></li>
<li><a href='#run_app'>
<p>Run Shiny apps</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bird Point Count Simulator</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Solymos [aut, cre] (&lt;https://orcid.org/0000-0001-7337-1740&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Solymos &lt;solymos@ualberta.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A highly scientific and utterly addictive 
  bird point count simulator 
  to test statistical assumptions, aid survey design,
  and have fun while doing it.
  The simulations follow time-removal and distance sampling models 
  based on Matsuoka et al. (2012) &lt;<a href="https://doi.org/10.1525%2Fauk.2012.11190">doi:10.1525/auk.2012.11190</a>&gt;,
  Solymos et al. (2013) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12106">doi:10.1111/2041-210X.12106</a>&gt;,
  and Solymos et al. (2018) &lt;<a href="https://doi.org/10.1650%2FCONDOR-18-32.1">doi:10.1650/CONDOR-18-32.1</a>&gt;,
  and sound attenuation experiments by 
  Yip et al. (2017) &lt;<a href="https://doi.org/10.1650%2FCONDOR-16-93.1">doi:10.1650/CONDOR-16-93.1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>intrval, mefa4, MASS, deldir (&ge; 1.0-2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, pbapply</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/psolymos/bSims">https://github.com/psolymos/bSims</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/psolymos/bSims/issues">https://github.com/psolymos/bSims/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, detect, shiny</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-06 18:15:35 UTC; PeterSolymos</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-07 07:40:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='bsims_init'>
bSims simulation functions
</h2><span id='topic+bSims-package'></span><span id='topic+bSims'></span><span id='topic+bsims_init'></span><span id='topic+bsims_populate'></span><span id='topic+bsims_animate'></span><span id='topic+bsims_detect'></span><span id='topic+bsims_transcribe'></span><span id='topic+print.bsims_landscape'></span><span id='topic+print.bsims_population'></span><span id='topic+print.bsims_events'></span><span id='topic+print.bsims_detections'></span><span id='topic+print.bsims_transcript'></span><span id='topic+bsims_all'></span><span id='topic+print.bsims_all'></span>

<h3>Description</h3>

<p>Functions to initialize, populate, animate, detect, and transcribe
simulated birds in a point count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsims_init(extent = 10, road = 0, edge = 0, offset = 0)

bsims_populate(x, density = 1, abund_fun = NULL, xy_fun = NULL,
  margin = 0, maxit = 100, fail = FALSE, ...)

bsims_animate(x, vocal_rate = 1, move_rate = 0, duration = 10,
  movement = 0, mixture = 1, avoid = c("none", "R", "ER"),
  initial_location=FALSE, allow_overlap=TRUE, ...)

bsims_detect(x, xy = c(0, 0), tau = 1, dist_fun = NULL,
  event_type = c("vocal", "move", "both"),
  sensitivity=1, direction=FALSE, ...)

bsims_transcribe(x, tint = NULL, rint = Inf,
  error = 0, bias = 1,
  condition=c("event1", "det1", "alldet"),
  event_type=NULL, perception=NULL, ...)

bsims_all(...)

## S3 method for class 'bsims_landscape'
print(x, ...)
## S3 method for class 'bsims_population'
print(x, ...)
## S3 method for class 'bsims_events'
print(x, ...)
## S3 method for class 'bsims_detections'
print(x, ...)
## S3 method for class 'bsims_transcript'
print(x, ...)
## S3 method for class 'bsims_all'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsims_init_+3A_extent">extent</code></td>
<td>

<p>extent of simulation area, an extent x extent square with (0,0) at the center.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_road">road</code></td>
<td>

<p>half width of the road stratum (perpendicular to the y axis).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_edge">edge</code></td>
<td>

<p>width of edge, same width on both sides of the road stratum.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_offset">offset</code></td>
<td>

<p>offset to apply to road and edge strata relative to the center in the x direction.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_x">x</code></td>
<td>

<p>a simulation object.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_density">density</code></td>
<td>

<p>population density, D, recycled 3x for the 3 strata
(H: habitat, E: edge, R: road).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_abund_fun">abund_fun</code></td>
<td>

<p>function to simulate abundance, N ~ Poisson(lambda), lambda=DA by default.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_xy_fun">xy_fun</code></td>
<td>

<p>function used to simulate nest locations, see <code><a href="#topic+acceptreject">acceptreject</a></code>.
The function should return probability (value between 0 and 1),
<code>NULL</code> means complete spatial randomness.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_margin">margin</code>, <code id="bsims_init_+3A_maxit">maxit</code>, <code id="bsims_init_+3A_fail">fail</code></td>
<td>

<p>arguments passed to <code><a href="#topic+acceptreject">acceptreject</a></code> when using <code>xy_fun</code>
to simulate nest locations.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_vocal_rate">vocal_rate</code>, <code id="bsims_init_+3A_move_rate">move_rate</code></td>
<td>

<p>Vocal and movement rates (see <code><a href="#topic+events">events</a></code>).
Both of these rates can be: a single number;
a vector of length <code>length(mixture)</code> (behavior based finite mixture groups);
a vector of length 3 with <code>mixture=1</code> (corresponding to HER strata);
or a matrix of dimension 3 x <code>length(mixture)</code>
(HER strata x number of behavior based groups).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_duration">duration</code></td>
<td>

<p>total time duration to consider (in minutes), passed to <code><a href="#topic+events">events</a></code>.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_movement">movement</code></td>
<td>

<p>standard deviation for a bivariate Normal kernel to simulate
locations centered at the nest location, passed to <code><a href="#topic+events">events</a></code>.
Can refer to the same stratum and behavior based groups as <code>move_rate</code>.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_mixture">mixture</code></td>
<td>

<p>behavior based finite mixture group proportions.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_avoid">avoid</code></td>
<td>

<p>range along the x axis to avoid with respect to movement locations,
passed to <code><a href="#topic+events">events</a></code>.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_initial_location">initial_location</code></td>
<td>

<p>logical, <code>move_rate</code> and <code>vocal_rate</code> are
silently ignored if <code>TRUE</code>
and nest locations are provided as part of the events table.
This renders all individuals equally available for detection.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_allow_overlap">allow_overlap</code></td>
<td>

<p>logical, allowing overlap between neighboring nests when movement is involved.
If <code>FALSE</code>, Voronoi tessellation is used to prevent overlap.
If <code>TRUE</code>, the unconstrained bivariate Normal kernel is used.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_xy">xy</code></td>
<td>

<p>a vector of x and y coordinates describing the position of the observer.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_tau">tau</code></td>
<td>

<p>parameter of the distance function.
Can be a single numeric value;
a vector of length 2 to provide parameters for
vocalization (1st value) and movement (2nd value) related events;
(H: habitat, E: edge, R: road, in this order);
a vector of length 3 to provide parameters for the 3 strata
(H: habitat, E: edge, R: road);
or a 3 x 2 matrix combining strata (rows) and
vocalization/movement (columns) related parameters.
Segmented sound attenuation is used when the values are different
in the 3 strata (see <code><a href="#topic+dist_fun2">dist_fun2</a></code>).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_dist_fun">dist_fun</code></td>
<td>

<p>distance function (1st argument is distance, second is <code>tau</code>).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_event_type">event_type</code></td>
<td>

<p>type of events to access (vocal, movement, or both).
Inherits value from input object when <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_tint">tint</code></td>
<td>

<p>time interval break points in minutes.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_rint">rint</code></td>
<td>

<p>distance interval break points in units of 100 meter.
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_condition">condition</code></td>
<td>

<p>conditioning type to define availability for each individual:
<code>"event1"</code>: the 1st event (detected or not);
<code>"det1"</code>: the 1st detection;
<code>"alldet"</code>: all detections (counting the same individual multiple times).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_error">error</code></td>
<td>

<p>log scale standard deviation (SD) for distance estimation error,
see <code><a href="#topic+rlnorm2">rlnorm2</a></code>.
When <code>direction=TRUE</code>, error changes based on the angle between the observer and the individual's (random) singing direction. When the bird faces the observer (0 degrees) SD is 0, when the bird is facing away (180 degrees) SD is <code>error</code>. In the range between 0-180 degrees the SD is changing according to the cosine of the degree: SD*(0.5-cos(degree*pi/180)/2).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_bias">bias</code></td>
<td>

<p>nonnegative numeric, the distance estimation bias. The default value (1) means no bias, &lt;1 indicates negative bias (perceived distance is less than true distance), &gt;1 indicates positive bias (perceived distance is higher than true distance). This acts as a multiplier and can be combined with <code>error</code>.
When <code>direction=TRUE</code>, bias changes based on the angle between the observer and the individual's (random) singing direction. When the bird faces the observer (0 degrees) perceived distance equals the true distance, when the bird is facing away (180 degrees) perceived distance is <code>bias</code> * true distance. In the range between 0-180 degrees the bias is changing according to the cosine of the degree: 1+(bias-1)*(0.5-cos(degree*pi/180)/2).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_perception">perception</code></td>
<td>

<p>perceived number of individuals relative to the actual number of individuals.
A non-negative number (&lt;1 values lead to under counting,
&gt;1 values lead to over counting),
or <code>NULL</code> (observer correctly identifies all individuals).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_sensitivity">sensitivity</code></td>
<td>

<p>non-negative numeric value indicating the sensitivity of the sensor
receiving the signal. Can be of length 1 (applies to both vocal and movement events)
or a named vector of length 2 (names should indicate which one
is <code>"vocal"</code> or <code>"move"</code>). Sensitivity of 1 means that
the process captured by <code>tau</code> is unaffected.
Less than 1 values indicate lower sensitivity (effectively decreasing tau),
larger than 1 values indicate higher sensitivity (effectively increasing tau).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_direction">direction</code></td>
<td>

<p>logical. When <code>TRUE</code>, tau for vocalizations (not for movement) changes based on the angle between the observer and the individual's (random) singing direction. When the bird faces the observer (0 degrees) tau is unaffected, when the bird is facing away (180 degrees) tau is <code>sensitivity * tau</code>. In the range between 0-180 degrees the effect is changing according to the cosine of the degree (0.5-cos(degree*pi/180)/2).
</p>
</td></tr>
<tr><td><code id="bsims_init_+3A_...">...</code></td>
<td>

<p>other arguments passed to underlying functions.
For the <code>bsims_all</code> wrapper, it means all
the arguments (except for <code>x</code>) that the underlying
<code>bsims_*</code> functions have. <code>bsims_all</code> can also take a single
list as its argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions capturing the simulation layers
are supposed to be called in sequence,
allowing to simulate multiple realities by keeping
preceding layers intact. Construction allows easy piping.
The <code>bsims_all</code> function is a wrapper for the <code>bsims_*</code>
layer functions.
</p>
<p>The simulations follow time-removal and distance sampling models based on
Matsuoka et al. (2012) &lt;doi:10.1525/auk.2012.11190&gt;,
Solymos et al. (2013) &lt;doi:10.1111/2041-210X.12106&gt;,
and Solymos et al. (2018) &lt;doi:10.1650/CONDOR-18-32.1&gt;,
and sound attenuation experiments by
Yip et al. (2017) &lt;doi:10.1650/CONDOR-16-93.1&gt;.
</p>


<h3>Value</h3>

<p><code>bsims_init</code> returns a landscape object.
</p>
<p><code>bsims_populate</code> returns a population object.
</p>
<p><code>bsims_animate</code> returns an events object.
</p>
<p><code>bsims_detect</code> returns a detections object.
</p>
<p><code>bsims_transcribe</code> returns a transcript object.
</p>
<p><code>get_table</code> returns the removal table.
</p>
<p><code>bsims_all</code> returns a closure with
<code>$settings()</code>, <code>$new(recover = FALSE)</code>,
and <code>$replicate(B, recover = FALSE, cl = NULL)</code>
functions. The settings function returns the input arguments as a list;
the new function returns a single transcript object;
the replicate function takes an argument for the
number of replicates (<code>B</code>) and returns a list of transcript objects
with B elements.
The <code>cl</code> argument is used to parallelize the work,
can be a numeric value on Unix/Linux/OSX, or a cluster object on any OS,
see examples.
The 'recover = TRUE' argument allows to run simulations with error
catching based on <code><a href="base.html#topic+try">try</a></code>.
</p>
<p>Note that simulated objects returned by <code>bsims_all</code>
will contain different realizations and all the conditionally
independent layers. Use a layered approach if former layers are meant
to be kept identical across runs.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>References</h3>

<p>Matsuoka, S. M., Bayne, E. M., Solymos, P., Fontaine, P.,
Cumming, S. G., Schmiegelow, F. K. A., &amp; Song, S. A., 2012.
Using binomial distance-sampling models to estimate the
effective detection radius of point-counts surveys across boreal Canada.
<em>Auk</em>, <strong>129</strong>: 268&ndash;282.
&lt;doi:10.1525/auk.2012.11190&gt;
</p>
<p>Solymos, P., Matsuoka, S. M., Bayne, E. M., Lele, S. R., Fontaine, P.,
Cumming, S. G., Stralberg, D., Schmiegelow, F. K. A. &amp; Song, S. J., 2013.
Calibrating indices of avian density from non-standardized survey data:
making the most of a messy situation.
<em>Methods in Ecology and Evolution</em>, <b>4</b>: 1047&ndash;1058.
&lt;doi:10.1111/2041-210X.12106&gt;
</p>
<p>Solymos, P., Matsuoka, S. M., Cumming, S. G., Stralberg, D., Fontaine, P.,
Schmiegelow, F. K. A., Song, S. J., and Bayne, E. M., 2018.
Evaluating time-removal models for estimating availability of boreal birds
during point-count surveys: sample size requirements and model complexity.
<em>Condor</em>, <b>120</b>: 765&ndash;786.
&lt;doi:10.1650/CONDOR-18-32.1&gt;
</p>
<p>Yip, D. A., Bayne, E. M., Solymos, P., Campbell, J.,
and Proppe, J. D., 2017.
Sound attenuation in forested and roadside environments:
implications for avian point count surveys.
<em>Condor</em>, <b>119</b>: 73&ndash;84.
&lt;doi:10.1650/CONDOR-16-93.1&gt;
</p>


<h3>See Also</h3>

<p>Plotting functions:
<code><a href="#topic+plot.bsims_landscape">plot.bsims_landscape</a></code>
</p>
<p>Getter functions:
<code><a href="#topic+get_nests">get_nests</a></code>,
<code><a href="#topic+get_events">get_events</a></code>,
<code><a href="#topic+get_detections">get_detections</a></code>,
<code><a href="#topic+get_abundance">get_abundance</a></code>,
<code><a href="#topic+get_density">get_density</a></code>
<code><a href="#topic+get_table">get_table</a></code>
</p>
<p>Shiny apps:
<code><a href="#topic+run_app">run_app</a></code>
</p>
<p><code><a href="#topic+acceptreject">acceptreject</a></code>,
<code><a href="#topic+events">events</a></code>,
<code><a href="#topic+estimate">estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- 0.5
tau &lt;- 1:3
dur &lt;- 10
rbr &lt;- c(0.5, 1, 1.5, Inf)
tbr &lt;- c(3, 5, 10)
(l &lt;- bsims_init(10, 0.5, 1))
(p &lt;- bsims_populate(l, 1))
(a &lt;- bsims_animate(p, vocal_rate=phi, duration=dur))
(o &lt;- bsims_detect(a, tau=tau))
(x &lt;- bsims_transcribe(o, tint=tbr, rint=rbr))

plot(x)
get_table(x, "removal")
get_table(x, "visits")

head(get_events(a))
plot(get_events(a))

head(get_detections(o))
plot(get_detections(o), "time")
plot(get_detections(o), "distance")

## wrapper function for all the bsims_* layers
b &lt;- bsims_all(road=1, density=0.5, tint=tbr, rint=rbr)
## alternatively: supply a list
#settings &lt;- list(road=1, density=0.5, tint=tbr, rint=rbr)
#b &lt;- bsims_all(settings)
b$settings()
b$new()
bb &lt;- b$replicate(3)
lapply(bb, get_table)


## parallel simulations
library(parallel)
b &lt;- bsims_all(density=0.5)
B &lt;- 4  # number of runs
nc &lt;- 2 # number of cores
## sequential
system.time(bb &lt;- b$replicate(B, cl=NULL))
## parallel clusters
cl &lt;- makeCluster(nc)
## note: loading the package is optional
system.time(clusterEvalQ(cl, library(bSims)))
system.time(bb &lt;- b$replicate(B, cl=cl))
stopCluster(cl)
## parallel forking
if (.Platform$OS.type != "windows") {
  system.time(bb &lt;- b$replicate(B, cl=nc))
}

</code></pre>

<hr>
<h2 id='acceptreject'>
Spatial point process simulator
</h2><span id='topic+acceptreject'></span>

<h3>Description</h3>

<p>Spatial point process simulator based on
accept/reject algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acceptreject(n, f = NULL, x0 = 0, x1 = 1, y0 = 0, y1 = 1,
  m = 0, maxit = 100, fail = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acceptreject_+3A_n">n</code></td>
<td>

<p>number of points to generate.
</p>
</td></tr>
<tr><td><code id="acceptreject_+3A_f">f</code></td>
<td>

<p>a function returning probability (value between 0 and 1) given distance as
the first and only argument. The function generates
spatially uniform Poisson point process (complete spatial randomness)
when <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="acceptreject_+3A_x0">x0</code>, <code id="acceptreject_+3A_x1">x1</code>, <code id="acceptreject_+3A_y0">y0</code>, <code id="acceptreject_+3A_y1">y1</code></td>
<td>

<p>x and y ranges (bounding box).
</p>
</td></tr>
<tr><td><code id="acceptreject_+3A_m">m</code></td>
<td>

<p>margin width for avoiding edge effects.
</p>
</td></tr>
<tr><td><code id="acceptreject_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations per point to try if no acceptance happens.
</p>
</td></tr>
<tr><td><code id="acceptreject_+3A_fail">fail</code></td>
<td>

<p>logical, what to do when there is a problem.
<code>TRUE</code> gives error, the default <code>FALSE</code> gives only a warning.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and 2 columns for x and y coordinates.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## complete spatial randomness
plot(acceptreject(100), asp=1)

## more systematic
distance &lt;- seq(0,1,0.01)
f &lt;- function(d)
  (1-exp(-d^2/0.1^2) + dlnorm(d, 0.2)/dlnorm(exp(0.2-1),0.2)) / 2
op &lt;- par(mfrow = c(1, 2))
plot(distance, f(distance), type="l")
plot(acceptreject(100, f, m=1), asp=1)
par(op)

## more clustered
f &lt;- function(d)
  exp(-d^2/0.1^2) + 0.5*(1-exp(-d^2/0.4^2))
op &lt;- par(mfrow = c(1, 2))
plot(distance, f(distance), type="l")
plot(acceptreject(100, f, m=1), asp=1)
par(op)
</code></pre>

<hr>
<h2 id='dist_fun2'>
Distance function with segmented attenuation
</h2><span id='topic+dist_fun2'></span>

<h3>Description</h3>

<p>Distance function with segmented attenuation
crossing a number of boundaries of strata
with different attenuation characteristics
following results in Yip et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_fun2(d, tau, dist_fun, breaks = numeric(0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_fun2_+3A_d">d</code></td>
<td>

<p>distance from observer.
</p>
</td></tr>
<tr><td><code id="dist_fun2_+3A_tau">tau</code></td>
<td>

<p>a parameter passed to the the distance function.
Length of <code>tau</code> must equal <code>length(b) + 1</code>
referring to distance function parameters in the different strata
(a stratum is defined by an interval surrounded by 1 or 2 boundaries).
</p>
</td></tr>
<tr><td><code id="dist_fun2_+3A_dist_fun">dist_fun</code></td>
<td>

<p>distance function taking two arguments: distance, and <code>tau</code>, see examples.
</p>
</td></tr>
<tr><td><code id="dist_fun2_+3A_breaks">breaks</code></td>
<td>

<p>distance breakpoints, must be <code>length(tau) - 1</code> in length.
These breakpoints represent the boundaries between the intervals
characterized by homogeneous attenuation characteristics.
</p>
</td></tr>
<tr><td><code id="dist_fun2_+3A_...">...</code></td>
<td>

<p>other arguments passed to <code>dist_fun</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability of detection given the distance, stratum specific parameters
and the arrangement of breakpoints.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>References</h3>

<p>Yip, D. A., Bayne, E. M., Solymos, P., Campbell, J.,
and Proppe, J. D., 2017.
Sound attenuation in forested and roadside environments:
implications for avian point count surveys.
<em>Condor</em>, <b>119</b>: 73&ndash;84.
&lt;doi:10.1650/CONDOR-16-93.1&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- c(1, 2, 3, 2, 1)
d &lt;- seq(0, 4, 0.01)
dist_fun &lt;- function(d, tau) exp(-(d/tau)^2) # half normal
#dist_fun &lt;- function(d, tau) exp(-d/tau) # exponential
#dist_fun &lt;- function(d, tau) 1-exp(-(d/tau)^-2) # hazard rate

b &lt;- c(0.5, 1, 1.5, 2) #  boundaries

op &lt;- par(mfrow=c(2, 1))
plot(d, dist_fun2(d, tau[1], dist_fun), type="n",
  ylab="P(detection)", xlab="Distance", axes=FALSE,
  main="Sound travels from left to right")
axis(1)
axis(2)
for (i in seq_len(length(b)+1)) {
  x1 &lt;- c(0, b, 4)[i]
  x2 &lt;- c(0, b, 4)[i+1]
  polygon(c(0, b, 4)[c(i, i, i+1, i+1)], c(0, 1, 1, 0),
    border=NA,
    col=c("darkolivegreen1", "burlywood1", "lightgrey",
    "burlywood1", "darkolivegreen1")[i])
}
lines(d, dist_fun2(d, tau[1], dist_fun))
lines(d, dist_fun2(d, tau[2], dist_fun))
lines(d, dist_fun2(d, tau[3], dist_fun))
lines(d, dist_fun2(d, tau, dist_fun, b), col=2, lwd=3)

plot(rev(d), dist_fun2(d, tau[1], dist_fun), type="n",
  ylab="P(detection)", xlab="Distance", axes=FALSE,
  main="Sound travels from right to left")
axis(1)
axis(2)
for (i in seq_len(length(b)+1)) {
  x1 &lt;- c(0, b, 4)[i]
  x2 &lt;- c(0, b, 4)[i+1]
  polygon(c(0, b, 4)[c(i, i, i+1, i+1)], c(0, 1, 1, 0),
    border=NA,
    col=c("darkolivegreen1", "burlywood1", "lightgrey",
    "burlywood1", "darkolivegreen1")[i])
}
lines(rev(d), dist_fun2(d, tau[1], dist_fun))
lines(rev(d), dist_fun2(d, tau[2], dist_fun))
lines(rev(d), dist_fun2(d, tau[3], dist_fun))
lines(rev(d), dist_fun2(d, tau, dist_fun, rev(4-b)), col=2, lwd=3)
par(op)
</code></pre>

<hr>
<h2 id='estimate'>
Estimate basic parameters
</h2><span id='topic+estimate'></span><span id='topic+estimate.bsims_transcript'></span>

<h3>Description</h3>

<p>Estimate singing rates, effective distances, and density
based on simulation objects
using the QPAD approach (Solymos et al. 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(object, ...)
## S3 method for class 'bsims_transcript'
estimate(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_+3A_object">object</code></td>
<td>

<p>simulation object.
</p>
</td></tr>
<tr><td><code id="estimate_+3A_...">...</code></td>
<td>

<p>other arguments passed to internal functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method evaluates removal design to estimate
model parameters and density using the QPAD methodology
using the 'detect' package.
</p>
<p>The function only works with multiple time and
distance intervals. It returns <code>NA</code> otherwise.
</p>


<h3>Value</h3>

<p>A vector with values for singing rate (phi),
effective detection distance (tau),
and density.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>References</h3>

<p>Solymos, P., Matsuoka, S. M., Bayne, E. M., Lele, S. R., Fontaine, P.,
Cumming, S. G., Stralberg, D., Schmiegelow, F. K. A. &amp; Song, S. J., 2013.
Calibrating indices of avian density from non-standardized survey data:
making the most of a messy situation.
<em>Methods in Ecology and Evolution</em>, <b>4</b>: 1047&ndash;1058.
&lt;doi:10.1111/2041-210X.12106&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsims_init">bsims_init</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
phi &lt;- 0.5                 # singing rate
tau &lt;- 1                   # EDR by strata
dur &lt;- 10                  # simulation duration
tbr &lt;- c(2, 4, 6, 8, 10)   # time intervals
rbr &lt;- c(0.5, 1, 1.5, Inf) # counting radii

l &lt;- bsims_init(10, 0.5, 1)# landscape
p &lt;- bsims_populate(l, 10)  # population
e &lt;- bsims_animate(p,      # events
  vocal_rate=phi, duration=dur)
d &lt;- bsims_detect(e,       # detections
  tau=tau)
x &lt;- bsims_transcribe(d,   # transcription
  tint=tbr, rint=rbr)

estimate(x)
</code></pre>

<hr>
<h2 id='events'>
Event time simulator
</h2><span id='topic+events'></span><span id='topic+timetoevent'></span>

<h3>Description</h3>

<p><code>timetoevent</code> turns exponential wait times to time-to-event data
within a desired duration, it handles 0 and infinite rates in a robust manner.
<code>events</code> simulates event times based on an exponential time-to-event
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timetoevent(rate, duration)

events(vocal_rate = 1, move_rate = 1, duration = 10,
  movement = 0, avoid = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="events_+3A_rate">rate</code></td>
<td>

<p>rate for the exponential distribution (<code><a href="stats.html#topic+rexp">rexp</a></code>).
</p>
</td></tr>
<tr><td><code id="events_+3A_duration">duration</code></td>
<td>

<p>total time duration to consider (in minutes).
</p>
</td></tr>
<tr><td><code id="events_+3A_vocal_rate">vocal_rate</code></td>
<td>

<p>vocal rate for exponential distribution (<code><a href="stats.html#topic+rexp">rexp</a></code>),
how often a vocal event happens per minute.
</p>
</td></tr>
<tr><td><code id="events_+3A_move_rate">move_rate</code></td>
<td>

<p>movement rate for exponential distribution (<code><a href="stats.html#topic+rexp">rexp</a></code>),
how often a movement event happens per minute.
</p>
</td></tr>
<tr><td><code id="events_+3A_movement">movement</code></td>
<td>

<p>standard deviation for a bivariate Normal kernel to simulate
locations centered at the nest location.
</p>
</td></tr>
<tr><td><code id="events_+3A_avoid">avoid</code></td>
<td>

<p>range along the x axis to avoid with respect to movement locations,
i.e. location for a movement event within this interval will be rejected
and a new location drawn.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An events object data frame with coordinates (x, y; centered at 0 that is nest
location), event times (t) and indicator for vocal events (v).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rexp">rexp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timetoevent(0, 10)
timetoevent(Inf, 10)

rr &lt;- 1
tt &lt;- timetoevent(rr, 10)
op &lt;- par(mfrow=c(1,2))
plot(ecdf(tt))
curve(1-exp(-rr*x), add=TRUE, col=2) # cdf

plot(stepfun(sort(tt), 0:length(tt)/length(tt)), ylab="F(x)")
curve(1-exp(-rr*x), add=TRUE, col=2) # cdf
par(op)

e &lt;- events(movement=1, duration=60)
mx &lt;- max(abs(e[,1:2]))
plot(e[,1:2], col="grey", type="l", asp=1,
  xlim=2*c(-mx, mx), ylim=2*c(-mx, mx))
points(e[,1:2], col=e$v+1)
abline(h=0, v=0, lty=2)
legend("topright", pch=21, col=1:2, horiz=TRUE,
  legend=c("movement", "vocalization"))
</code></pre>

<hr>
<h2 id='expand_list'>
Create a list from all combinations of arguments
</h2><span id='topic+expand_list'></span>

<h3>Description</h3>

<p>Create a list from all combinations of the supplied vectors or lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_list_+3A_...">...</code></td>
<td>

<p>vectors or lists. All arguments must be named.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing one element for each combination of the supplied vectors
and lists. The first factors vary fastest.
The nested elements are labeled by the factors.
</p>
<p>The function allows list elements to be vectors, functions, or <code>NULL</code>.
If a vector element is supposed to be kept as a vector, use <code>list()</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+expand.grid">expand.grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- expand_list(
  movement = c(0, 1, 2),
  rint = list(c(0.5, 1, 1.5, Inf)), # in a list to keep as one
  xy_fun = list(NULL, function(z) z))
b[[1]]
str(b)
</code></pre>

<hr>
<h2 id='get_nests'>
Access nests, events, detections, and totals
</h2><span id='topic+get_nests'></span><span id='topic+get_events'></span><span id='topic+get_detections'></span><span id='topic+get_abundance'></span><span id='topic+get_density'></span><span id='topic+get_nests.bsims_population'></span><span id='topic+get_abundance.bsims_population'></span><span id='topic+get_density.bsims_population'></span><span id='topic+get_events.bsims_events'></span><span id='topic+get_detections.bsims_detections'></span><span id='topic+get_table'></span><span id='topic+get_table.bsims_transcript'></span>

<h3>Description</h3>

<p>Access nests, events, detections,
abundance, and density from simulation objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nests(x, ...)
## S3 method for class 'bsims_population'
get_nests(x, ...)

get_events(x, ...)
## S3 method for class 'bsims_events'
get_events(x, ...)

get_detections(x, ...)
## S3 method for class 'bsims_detections'
get_detections(x, ...)

get_abundance(x, ...)
## S3 method for class 'bsims_population'
get_abundance(x, ...)

get_density(x, ...)
## S3 method for class 'bsims_population'
get_density(x, ...)

get_table(x, ...)
## S3 method for class 'bsims_transcript'
get_table(x,
  type = c("removal", "visits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nests_+3A_x">x</code></td>
<td>

<p>simulation object.
</p>
</td></tr>
<tr><td><code id="get_nests_+3A_type">type</code></td>
<td>

<p>character, the type of table to return:
<code>"removal"</code> includes only new individuals as time progresses,
<code>"visits"</code> counts individuals in each time interval independent
of each other.
</p>
</td></tr>
<tr><td><code id="get_nests_+3A_...">...</code></td>
<td>

<p>other arguments passed to internal functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_nests</code> extracts the next locations.
</p>
<p><code>get_events</code> extracts the events.
</p>
<p><code>get_detections</code> extracts the detections.
</p>
<p><code>get_abundance</code> gets the realized total abundance (N),
<code>get_density</code> gets the realized average density (abundance/area: N/A).
</p>
<p><code>get_table</code> returns the removal or visits table.
</p>


<h3>Value</h3>

<p><code>get_abundance</code> and <code>get_density</code>
returns a non-negative numeric value.
</p>
<p><code>get_nests</code> returns a data frame with the following columns:
<code>i</code> individual identifier,
<code>s</code> spatial stratum (H: habitat, E: edge, R: road)
<code>x</code> and <code>y</code> are coordinates of the nest locations,
<code>g</code> is behavioral (mixture) group or <code>NA</code>.
</p>
<p><code>get_events</code> returns a data frame with the following columns:
<code>x</code> and <code>y</code> are locations of the individual at the time of the event,
<code>t</code> time of the event within the duration interval,
<code>v</code> indicator variable for vocal (1) vs. movement (0) event,
<code>i</code> individual identifier.
</p>
<p><code>get_detections</code> returns a data frame with the following columns:
<code>x</code> and <code>y</code> are locations of the individual at the time of the event,
<code>t</code> time of the event within the duration interval,
<code>v</code> indicator variable for vocal (1) vs. movement (0) event,
<code>d</code> distance from observer when detected (otherwise <code>NA</code>).
<code>i</code> individual identifier,
<code>j</code> perceived individual identifier.
</p>
<p><code>get_table</code> returns a matrix with distance bands as rows
and time intervals as columns. The cell values are counts
if the individuals detected in a removal fashion (only new
individuals counter over the time periods) or in a multiple-visits
fashion (counting of individuals restarts in every time interval).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsims_init">bsims_init</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- 0.5                 # singing rate
tau &lt;- 1:3                 # EDR by strata
dur &lt;- 10                  # simulation duration
tbr &lt;- c(3, 5, 10)         # time intervals
rbr &lt;- c(0.5, 1, 1.5, Inf) # counting radii

l &lt;- bsims_init(10, 0.5, 1)# landscape
p &lt;- bsims_populate(l, 1)  # population
e &lt;- bsims_animate(p,      # events
  vocal_rate=phi, duration=dur)
d &lt;- bsims_detect(e,       # detections
  tau=tau)
x &lt;- bsims_transcribe(d,   # transcription
  tint=tbr, rint=rbr)

## next locations
head(get_nests(p))
head(get_nests(e))
head(get_nests(d))
head(get_nests(x))

## abundance
get_abundance(p)
get_abundance(e)
get_abundance(d)
get_abundance(x)

## density
get_density(p)
get_density(e)
get_density(d)
get_density(x)

## events
head(get_events(e))
head(get_events(d))
head(get_events(x))

## detections
head(get_detections(d))
head(get_detections(x))

get_table(x, "removal")
get_table(x, "visits")
</code></pre>

<hr>
<h2 id='internals'>
Internal functions
</h2><span id='topic+.bsims_all'></span><span id='topic+.get_events'></span><span id='topic+.get_detections'></span>

<h3>Description</h3>

<p>Internal functions are not intended to be used by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_events(x, event_type=c("vocal", "move", "both"), tlim = NULL)

.get_detections(x, condition = c("event1", "det1", "alldet"),
  event_type = c("vocal", "move", "both"), tlim = NULL,
  perception = NULL)

.bsims_all(Settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_+3A_x">x</code></td>
<td>

<p>simulation object.
</p>
</td></tr>
<tr><td><code id="internals_+3A_event_type">event_type</code></td>
<td>

<p>type of events to access.
</p>
</td></tr>
<tr><td><code id="internals_+3A_condition">condition</code></td>
<td>

<p>conditioning type to define availability for each individual:
<code>"event1"</code>: the 1st event (detected or not);
<code>"det1"</code>: the 1st detection;
<code>"alldet"</code>: all detections (counting the same individual multiple times).
</p>
</td></tr>
<tr><td><code id="internals_+3A_tlim">tlim</code></td>
<td>

<p>time intervals treated as [<code>min(tlim)</code>, <code>max(tlim)</code>).
</p>
</td></tr>
<tr><td><code id="internals_+3A_perception">perception</code></td>
<td>

<p>perceived number of individuals relative to the actual number of individuals.
A non-negative number (&lt;1 values lead to under counting,
&gt;1 values lead to over counting),
or <code>NULL</code> (observer correctly identifies all individuals).
</p>
</td></tr>
<tr><td><code id="internals_+3A_settings">Settings</code></td>
<td>

<p>a list of arguments.
</p>
</td></tr>
</table>

<hr>
<h2 id='plot.bsims_landscape'>
Plot methods
</h2><span id='topic+plot.bsims_landscape'></span><span id='topic+plot.bsims_population'></span><span id='topic+plot.bsims_events'></span><span id='topic+plot.bsims_detections'></span><span id='topic+plot.bsims_transcript'></span><span id='topic+lines.bsims_detections'></span><span id='topic+lines.bsims_events'></span><span id='topic+lines.bsims_transcript'></span><span id='topic+points.bsims_population'></span><span id='topic+points.bsims_events'></span><span id='topic+points.bsims_detections'></span><span id='topic+col2hex'></span><span id='topic+plot.bsims_events_table'></span><span id='topic+plot.bsims_detections_table'></span>

<h3>Description</h3>

<p>Plot methods for different bSims objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsims_landscape'
plot(x,
  col_H, col_E, col_R,
  xlim = NULL, ylim = NULL, ...)

## S3 method for class 'bsims_population'
plot(x,
  pch_nest, col_nest, cex_nest, ...)

## S3 method for class 'bsims_events'
plot(x,
  event_type=c("vocal", "move", "both"), tlim = NULL,
  pch_nest, col_nest, cex_nest,
  pch_vocal, col_vocal, cex_vocal,
  lty_move, col_move, lwd_move, ...)

## S3 method for class 'bsims_detections'
plot(x,
  event_type=NULL, tlim = NULL,
  pch_nest, col_nest, cex_nest,
  pch_vocal, col_vocal, cex_vocal,
  lty_move, col_move, lwd_move,
  lty_det_vocal, col_det_vocal, lwd_det_vocal,
  lty_det_move, col_det_move, lwd_det_move,
  condition = "event1", ...)

## S3 method for class 'bsims_transcript'
plot(x,
  pch_nest, col_nest, cex_nest,
  pch_vocal, col_vocal, cex_vocal,
  lty_move, col_move, lwd_move,
  lty_det_vocal, col_det_vocal, lwd_det_vocal,
  lty_det_move, col_det_move, lwd_det_move,
  show_tint=TRUE, show_rint=TRUE,
  col_tint, col_rint, ...)

## S3 method for class 'bsims_events'
lines(x, tlim = NULL, ...)
## S3 method for class 'bsims_detections'
lines(x,
  event_type=NULL, tlim=NULL, condition="event1", ...)
## S3 method for class 'bsims_transcript'
lines(x,
  event_type=NULL, tlim=NULL, ...)

## S3 method for class 'bsims_population'
points(x, ...)
## S3 method for class 'bsims_events'
points(x,
  event_type=c("vocal", "move", "both"), tlim = NULL, ...)
## S3 method for class 'bsims_detections'
points(x,
  event_type=NULL, tlim=NULL, condition="event1", ...)

col2hex(col, alpha = FALSE)

## S3 method for class 'bsims_events_table'
plot(x,
  xlab, ylab, xlim, ylim, col_det_vocal, col_det_move, ...)
## S3 method for class 'bsims_detections_table'
plot(x,
  type=c("time", "distance"), xlab, ylab, xlim, ylim,
  col_det_vocal, col_det_move, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bsims_landscape_+3A_x">x</code></td>
<td>

<p>simulation object.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_col">col</code></td>
<td>

<p>color values.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_col_h">col_H</code>, <code id="plot.bsims_landscape_+3A_col_e">col_E</code>, <code id="plot.bsims_landscape_+3A_col_r">col_R</code></td>
<td>

<p>color values for the Habitat, Edge, and Road strata.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_event_type">event_type</code></td>
<td>

<p>type of events to access.
The value is inferred from the input object when <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_xlim">xlim</code>, <code id="plot.bsims_landscape_+3A_ylim">ylim</code>, <code id="plot.bsims_landscape_+3A_tlim">tlim</code></td>
<td>

<p>x, y, time intervals.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_xlab">xlab</code>, <code id="plot.bsims_landscape_+3A_ylab">ylab</code></td>
<td>

<p>x and y axis labels.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_pch_nest">pch_nest</code>, <code id="plot.bsims_landscape_+3A_col_nest">col_nest</code>, <code id="plot.bsims_landscape_+3A_cex_nest">cex_nest</code></td>
<td>

<p>visual characteristics of nest locations.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_pch_vocal">pch_vocal</code>, <code id="plot.bsims_landscape_+3A_col_vocal">col_vocal</code>, <code id="plot.bsims_landscape_+3A_cex_vocal">cex_vocal</code></td>
<td>

<p>visual characteristics of vocalization events.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_lty_move">lty_move</code>, <code id="plot.bsims_landscape_+3A_col_move">col_move</code>, <code id="plot.bsims_landscape_+3A_lwd_move">lwd_move</code></td>
<td>

<p>visual characteristics of movement events.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_lty_det_vocal">lty_det_vocal</code>, <code id="plot.bsims_landscape_+3A_col_det_vocal">col_det_vocal</code>, <code id="plot.bsims_landscape_+3A_lwd_det_vocal">lwd_det_vocal</code></td>
<td>

<p>visual characteristics of detection events related to vocalizations.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_lty_det_move">lty_det_move</code>, <code id="plot.bsims_landscape_+3A_col_det_move">col_det_move</code>, <code id="plot.bsims_landscape_+3A_lwd_det_move">lwd_det_move</code></td>
<td>

<p>visual characteristics of detection events related to movements.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_alpha">alpha</code></td>
<td>

<p>alpha channel for colors.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_show_tint">show_tint</code>, <code id="plot.bsims_landscape_+3A_show_rint">show_rint</code></td>
<td>

<p>whether time and distance intervals should be displayed.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_col_tint">col_tint</code>, <code id="plot.bsims_landscape_+3A_col_rint">col_rint</code></td>
<td>

<p>colors for time and distance intervals.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_condition">condition</code></td>
<td>

<p>conditioning type to define availability for each individual,
see <code><a href="#topic+bsims_detect">bsims_detect</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_type">type</code></td>
<td>

<p>what the x axis should be: time or distance.
</p>
</td></tr>
<tr><td><code id="plot.bsims_landscape_+3A_...">...</code></td>
<td>

<p>other graphical arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main plotting functions use a theme defined in
the option <code>getOption("bsims_theme")</code>.
Overriding these default settings allows customization.
</p>


<h3>Value</h3>

<p>These plotting functions are called for their side effects
and silently return the input object.
</p>
<p><code>col2hex</code> is modeled after <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>
and returns a character vector giving hexadecimal color codes with
or without alpha channel values.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsims_init">bsims_init</a></code>, <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- bsims_all(road=1, edge=2, move_rate=1, movement=0.2)$new()
o &lt;- getOption("bsims_theme")
str(o)
n &lt;- o
n$col_H &lt;- "gold"
n$col_E &lt;- "magenta"
n$col_R &lt;- "black"
op &lt;- par(mfrow=c(1, 2))
plot(b)
options("bsims_theme" = n) # apply new theme
plot(b)
par(op)
options("bsims_theme" = o) # reset old theme

col2hex(c(blu = "royalblue", reddish = "tomato"), alpha = FALSE)
col2hex(c(blu = "royalblue", reddish = "tomato"), alpha = TRUE)
</code></pre>

<hr>
<h2 id='rlnorm2'>
Reparametrized lognormal distribution
</h2><span id='topic+rlnorm2'></span>

<h3>Description</h3>

<p>A lognormal distribution parametrized as mean (ybar) and SDlog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlnorm2(n, mean = exp(0.5), sdlog = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlnorm2_+3A_n">n</code></td>
<td>

<p>number of random numbers desired.
</p>
</td></tr>
<tr><td><code id="rlnorm2_+3A_mean">mean</code></td>
<td>

<p>mean.
</p>
</td></tr>
<tr><td><code id="rlnorm2_+3A_sdlog">sdlog</code></td>
<td>

<p>log scale standard deviation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Log scale mean is <code>log(mean) - sdlog^2/2</code>.
</p>


<h3>Value</h3>

<p>Vector of random numbers.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>See Also</h3>

<p><code>link{rlnorm}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(rlnorm2(10^6, 1.3, 0.5)) # mean ~ 1.3
exp(log(1.3) - 0.5^2/2) # ~ median
</code></pre>

<hr>
<h2 id='rmvn'>
Multivariate normal distribution
</h2><span id='topic+rmvn'></span>

<h3>Description</h3>

<p>A shim of <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code> to return matrix when n &lt; 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvn(n = 1L, mu, Sigma, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvn_+3A_n">n</code></td>
<td>

<p>number of random vectors desired (nonnegative integer, can be 0).
</p>
</td></tr>
<tr><td><code id="rmvn_+3A_mu">mu</code></td>
<td>

<p>mean vector.
</p>
</td></tr>
<tr><td><code id="rmvn_+3A_sigma">Sigma</code></td>
<td>

<p>variance-covariance matrix.
</p>
</td></tr>
<tr><td><code id="rmvn_+3A_...">...</code></td>
<td>

<p>other arguments passed to  <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>length(mu)</code> columns.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmvn(0, c(a=0, b=0), diag(1, 2, 2))
rmvn(1, c(a=0, b=0), diag(1, 2, 2))
rmvn(2, c(a=0, b=0), diag(1, 2, 2))

sapply(0:10, function(n) dim(rmvn(n, c(a=0, b=0), diag(1, 2, 2))))
</code></pre>

<hr>
<h2 id='run_app'>
Run Shiny apps
</h2><span id='topic+run_app'></span>

<h3>Description</h3>

<p>Run the Shiny apps that are included in the bSims package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_app(app = c("bsimsH", "bsimsHER", "distfunH", "distfunHER"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_app_+3A_app">app</code></td>
<td>

<p>character, which app to run.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"bsimsH"</code>: explore simulation settings in a single stratum.
</p>
<p><code>"bsimsHER"</code>: explore simulation settings in multiple strata.
</p>
<p><code>"distfunH"</code>: explore distance functions through a single stratum.
</p>
<p><code>"distfunHER"</code>: explore distance functions through multiple strata
with segmented sound attenuation (see <code><a href="#topic+dist_fun2">dist_fun2</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsims_init">bsims_init</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
