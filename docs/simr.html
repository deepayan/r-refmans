<!DOCTYPE html><html><head><title>Help for package simr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#doFit'><p>Fit model to a new response.</p></a></li>
<li><a href='#doSim'><p>Generate simulated response variables.</p></a></li>
<li><a href='#doTest'><p>Apply a hypothesis test to a fitted model.</p></a></li>
<li><a href='#extend'><p>Extend a longitudinal model.</p></a></li>
<li><a href='#getData'><p>Get an object's data.</p></a></li>
<li><a href='#lastResult'><p>Recover an unsaved simulation</p></a></li>
<li><a href='#makeGlmer'><p>Create an artificial mixed model object</p></a></li>
<li><a href='#modify'><p>Modifying model parameters.</p></a></li>
<li><a href='#powerCurve'><p>Estimate power at a range of sample sizes.</p></a></li>
<li><a href='#powerSim'><p>Estimate power by simulation.</p></a></li>
<li><a href='#print.powerSim'><p>Report simulation results</p></a></li>
<li><a href='#simdata'><p>Example dataset.</p></a></li>
<li><a href='#simr-package'><p>simr: Simulation-based power calculations for mixed models.</p></a></li>
<li><a href='#simrOptions'><p>Options Settings for <code>simr</code></p></a></li>
<li><a href='#tests'><p>Specify a statistical test to apply</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Power Analysis for Generalised Linear Mixed Models by Simulation</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate power for generalised linear mixed models, using
    simulation. Designed to work with models fit using the 'lme4' package.
    Described in Green and MacLeod, 2016 &lt;<a href="https://doi.org/10.1111%2F2041-210X.12504">doi:10.1111/2041-210X.12504</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pitakakariki/simr">https://github.com/pitakakariki/simr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pitakakariki/simr/issues">https://github.com/pitakakariki/simr/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>lme4 (&ge; 1.1-16)</td>
</tr>
<tr>
<td>Imports:</td>
<td>binom,iterators,pbkrtest,plotrix,plyr,RLRsim,stringr,stats,methods,utils,graphics,grDevices,car,lmerTest
(&ge; 3.0-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat,knitr,rmarkdown</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-13 19:33:42 UTC; User</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Green <a href="https://orcid.org/0000-0002-0238-9852"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Catriona MacLeod [aut],
  Phillip Alday [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Green &lt;simr.peter@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-13 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='doFit'>Fit model to a new response.</h2><span id='topic+doFit'></span>

<h3>Description</h3>

<p>This is normally an internal function, but it can be overloaded to extend <code>simr</code> to other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doFit(y, fit, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doFit_+3A_y">y</code></td>
<td>
<p>new values for the response variable (vector or matrix depending on the model).</p>
</td></tr>
<tr><td><code id="doFit_+3A_fit">fit</code></td>
<td>
<p>a previously fitted model object.</p>
</td></tr>
<tr><td><code id="doFit_+3A_subset">subset</code></td>
<td>
<p>boolean vector specifying how much of the data to use. If missing, the model is fit to all
the data. This argument needs to be implemented for <code><a href="#topic+powerCurve">powerCurve</a></code> to work.</p>
</td></tr>
<tr><td><code id="doFit_+3A_...">...</code></td>
<td>
<p>additional options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a fitted model object.
</p>

<hr>
<h2 id='doSim'>Generate simulated response variables.</h2><span id='topic+doSim'></span>

<h3>Description</h3>

<p>This is normally an internal function, but it can be overloaded to extend <code>simr</code> to other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doSim(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doSim_+3A_object">object</code></td>
<td>
<p>an object to simulate from, usually a fitted model.</p>
</td></tr>
<tr><td><code id="doSim_+3A_...">...</code></td>
<td>
<p>additional options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing simulated response values (or, for models  with a multivariate response such as
binomial gl(m)m's, a matrix of simulated response values). Suitable as input for <code><a href="#topic+doFit">doFit</a></code>.
</p>

<hr>
<h2 id='doTest'>Apply a hypothesis test to a fitted model.</h2><span id='topic+doTest'></span>

<h3>Description</h3>

<p>This is normally an internal function, but it can be overloaded to extend <code>simr</code> to other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doTest(object, test, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doTest_+3A_object">object</code></td>
<td>
<p>an object to apply a statistical test to, usually a fitted model.</p>
</td></tr>
<tr><td><code id="doTest_+3A_test">test</code></td>
<td>
<p>a test function, see <a href="#topic+tests">tests</a>.</p>
</td></tr>
<tr><td><code id="doTest_+3A_...">...</code></td>
<td>
<p>additional options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a p-value with attributes describing the test.
</p>

<hr>
<h2 id='extend'>Extend a longitudinal model.</h2><span id='topic+extend'></span>

<h3>Description</h3>

<p>This method increases the sample size for a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend(object, along, within, n, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_+3A_object">object</code></td>
<td>
<p>a fitted model object to extend.</p>
</td></tr>
<tr><td><code id="extend_+3A_along">along</code></td>
<td>
<p>the name of an explanatory variable. This variable will have its number of levels extended.</p>
</td></tr>
<tr><td><code id="extend_+3A_within">within</code></td>
<td>
<p>names of grouping variables, separated by &quot;+&quot; or &quot;,&quot;. Each combination of groups will be
extended to <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="extend_+3A_n">n</code></td>
<td>
<p>number of levels: the levels of the explanatory variable will be replaced by <code>1,2,3,..,n</code> for a
continuous variable or <code>a,b,c,...,n</code> for a factor.</p>
</td></tr>
<tr><td><code id="extend_+3A_values">values</code></td>
<td>
<p>alternatively, you can specify a new set of levels for the explanatory variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>extend</code> takes &quot;slices&quot; through the data for each unique value of the extended variable.
An extended dataset is built from <code>n</code> slices, with slices duplicated if necessary.
</p>


<h3>Value</h3>

<p>A copy of <code>object</code> suitable for <code><a href="#topic+doSim">doSim</a></code> with an extended dataset attached as
an attribute named <code>newData</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- lmer(y ~ x + (1|g), data=simdata)
nrow(example)
fmx1 &lt;- extend(fm, along="x", n=20)
nrow(getData(fmx1))
fmx2 &lt;- extend(fm, along="x", values=c(1,2,4,8,16))
nrow(getData(fmx2))

</code></pre>

<hr>
<h2 id='getData'>Get an object's data.</h2><span id='topic+getData'></span><span id='topic+getData+3C-'></span>

<h3>Description</h3>

<p>Get the data associated with a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getData(object)

getData(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getData_+3A_object">object</code></td>
<td>
<p>a fitted model object (e.g. an object of class <code>merMod</code> or <code>lm</code>).</p>
</td></tr>
<tr><td><code id="getData_+3A_value">value</code></td>
<td>
<p>a new <code>data.frame</code> to replace the old one.
The new data will be stored in the <code>newData</code> attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Looks for data in the following order:
</p>

<ol>
<li><p>The object's <code>newData</code> attribute, if it has been set by <code>simr</code>.
</p>
</li>
<li><p>The <code>data</code> argument of <code>getCall(object)</code>, in the environment of <code>formula(object)</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A <code>data.frame</code> with the required data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lm1 &lt;- lmer(y ~ x + (1|g), data=simdata)
X &lt;- getData(lm1)

</code></pre>

<hr>
<h2 id='lastResult'>Recover an unsaved simulation</h2><span id='topic+lastResult'></span>

<h3>Description</h3>

<p>Simulations can take a non-trivial time to run. If the user forgets to assign
the result to a variable this method can recover it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lastResult()
</code></pre>


<h3>See Also</h3>

<p><code><a href="base.html#topic+.Last.value">.Last.value</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmer(y ~ x + (1|g), data=simdata)
powerSim(fm1, nsim=10)
ps1 &lt;- lastResult()

</code></pre>

<hr>
<h2 id='makeGlmer'>Create an artificial mixed model object</h2><span id='topic+makeGlmer'></span><span id='topic+makeLmer'></span>

<h3>Description</h3>

<p>Make a <code><a href="lme4.html#topic+merMod">merMod</a></code> object with the specified structure and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGlmer(formula, family, fixef, VarCorr, data)

makeLmer(formula, fixef, VarCorr, sigma, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeGlmer_+3A_formula">formula</code></td>
<td>
<p>a formula describing the model (see <code><a href="lme4.html#topic+glmer">glmer</a></code>).</p>
</td></tr>
<tr><td><code id="makeGlmer_+3A_family">family</code></td>
<td>
<p>type of response variable (see <code><a href="stats.html#topic+family">family</a></code>).</p>
</td></tr>
<tr><td><code id="makeGlmer_+3A_fixef">fixef</code></td>
<td>
<p>vector of fixed effects</p>
</td></tr>
<tr><td><code id="makeGlmer_+3A_varcorr">VarCorr</code></td>
<td>
<p>variance and covariances for random effects.
If there are multiple random effects, supply their parameters as a list.</p>
</td></tr>
<tr><td><code id="makeGlmer_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> of explanatory variables.</p>
</td></tr>
<tr><td><code id="makeGlmer_+3A_sigma">sigma</code></td>
<td>
<p>residual standard deviation.</p>
</td></tr>
</table>

<hr>
<h2 id='modify'>Modifying model parameters.</h2><span id='topic+modify'></span><span id='topic+fixef+3C-'></span><span id='topic+coef+3C-'></span><span id='topic+VarCorr+3C-'></span><span id='topic+sigma+3C-'></span><span id='topic+scale+3C-'></span>

<h3>Description</h3>

<p>These functions can be used to change the size of a model's fixed effects,
its random effect variance/covariance matrices, or its residual variance.
This gives you more control over simulations from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixef(object) &lt;- value

coef(object) &lt;- value

VarCorr(object) &lt;- value

sigma(object) &lt;- value

scale(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="modify_+3A_value">value</code></td>
<td>
<p>new parameter values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New values for <code>VarCorr</code> are interpreted as variances and covariances, not standard deviations and
correlations. New values for <code>sigma</code> and <code>scale</code> are interpreted on the standard deviation scale.
This means that both <code>VarCorr(object)&lt;-VarCorr(object)</code> and <code>sigma(object)&lt;-sigma(object)</code>
leave <code>object</code> unchanged, as you would expect.
</p>
<p><code>sigma&lt;-</code> will only change the residual standard deviation,
whereas <code>scale&lt;-</code> will affect both <code>sigma</code> and <code>VarCorr</code>.
</p>
<p>These functions can be used to change the value of individual parameters, such as
a single fixed effect coefficient, using standard R subsetting commands.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getData">getData</a></code> if you want to modify the model's data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- lmer(y ~ x + (1|g), data=simdata)
fixef(fm)
fixef(fm)["x"] &lt;- -0.1
fixef(fm)

</code></pre>

<hr>
<h2 id='powerCurve'>Estimate power at a range of sample sizes.</h2><span id='topic+powerCurve'></span>

<h3>Description</h3>

<p>This function runs <code><a href="#topic+powerSim">powerSim</a></code> over a range of sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerCurve(
  fit,
  test = fixed(getDefaultXname(fit)),
  sim = fit,
  along = getDefaultXname(fit),
  within,
  breaks,
  seed,
  fitOpts = list(),
  testOpts = list(),
  simOpts = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerCurve_+3A_fit">fit</code></td>
<td>
<p>a fitted model object (see <code><a href="#topic+doFit">doFit</a></code>).</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_test">test</code></td>
<td>
<p>specify the test to perform. By default, the first fixed effect in <code>fit</code> will be tested.
(see: <a href="#topic+tests">tests</a>).</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_sim">sim</code></td>
<td>
<p>an object to simulate from. By default this is the same as <code>fit</code> (see <code><a href="#topic+doSim">doSim</a></code>).</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_along">along</code></td>
<td>
<p>the name of an explanatory variable. This variable will have its number of levels varied.</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_within">within</code></td>
<td>
<p>names of grouping variables, separated by &quot;+&quot; or &quot;,&quot;. Each combination of groups will be
extended to <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_breaks">breaks</code></td>
<td>
<p>number of levels of the variable specified by <code>along</code> at each point on the power curve.</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_seed">seed</code></td>
<td>
<p>specify a random number generator seed, for reproducible results.</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_fitopts">fitOpts</code></td>
<td>
<p>extra arguments for <code><a href="#topic+doFit">doFit</a></code>.</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_testopts">testOpts</code></td>
<td>
<p>extra arguments for <code><a href="#topic+doTest">doTest</a></code>.</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_simopts">simOpts</code></td>
<td>
<p>extra arguments for <code><a href="#topic+doSim">doSim</a></code>.</p>
</td></tr>
<tr><td><code id="powerCurve_+3A_...">...</code></td>
<td>
<p>any additional arguments are passed on to <code><a href="#topic+simrOptions">simrOptions</a></code>. Common options include:
</p>

<dl>
<dt><code>nsim</code>:</dt><dd><p>the number of simulations to run (default is <code>1000</code>).</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>the significance level for the statistical test (default is <code>0.05</code>).</p>
</dd>
<dt><code>progress</code>:</dt><dd><p>use progress bars during calculations (default is <code>TRUE</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+print.powerCurve">print.powerCurve</a></code>, <code><a href="#topic+summary.powerCurve">summary.powerCurve</a></code>, <code><a href="#topic+confint.powerCurve">confint.powerCurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fm &lt;- lmer(y ~ x + (1|g), data=simdata)
pc1 &lt;- powerCurve(fm)
pc2 &lt;- powerCurve(fm, breaks=c(4,6,8,10))
print(pc2)
plot(pc2)

## End(Not run)

</code></pre>

<hr>
<h2 id='powerSim'>Estimate power by simulation.</h2><span id='topic+powerSim'></span>

<h3>Description</h3>

<p>Perform a power analysis for a mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerSim(
  fit,
  test = fixed(getDefaultXname(fit)),
  sim = fit,
  fitOpts = list(),
  testOpts = list(),
  simOpts = list(),
  seed,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerSim_+3A_fit">fit</code></td>
<td>
<p>a fitted model object (see <code><a href="#topic+doFit">doFit</a></code>).</p>
</td></tr>
<tr><td><code id="powerSim_+3A_test">test</code></td>
<td>
<p>specify the test to perform. By default, the first fixed effect in <code>fit</code> will be tested.
(see: <a href="#topic+tests">tests</a>).</p>
</td></tr>
<tr><td><code id="powerSim_+3A_sim">sim</code></td>
<td>
<p>an object to simulate from. By default this is the same as <code>fit</code> (see <code><a href="#topic+doSim">doSim</a></code>).</p>
</td></tr>
<tr><td><code id="powerSim_+3A_fitopts">fitOpts</code></td>
<td>
<p>extra arguments for <code><a href="#topic+doFit">doFit</a></code>.</p>
</td></tr>
<tr><td><code id="powerSim_+3A_testopts">testOpts</code></td>
<td>
<p>extra arguments for <code><a href="#topic+doTest">doTest</a></code>.</p>
</td></tr>
<tr><td><code id="powerSim_+3A_simopts">simOpts</code></td>
<td>
<p>extra arguments for <code><a href="#topic+doSim">doSim</a></code>.</p>
</td></tr>
<tr><td><code id="powerSim_+3A_seed">seed</code></td>
<td>
<p>specify a random number generator seed, for reproducible results.</p>
</td></tr>
<tr><td><code id="powerSim_+3A_...">...</code></td>
<td>
<p>any additional arguments are passed on to <code><a href="#topic+simrOptions">simrOptions</a></code>. Common options include:
</p>

<dl>
<dt><code>nsim</code>:</dt><dd><p>the number of simulations to run (default is <code>1000</code>).</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>the significance level for the statistical test (default is <code>0.05</code>).</p>
</dd>
<dt><code>progress</code>:</dt><dd><p>use progress bars during calculations (default is <code>TRUE</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+print.powerSim">print.powerSim</a></code>, <code><a href="#topic+summary.powerSim">summary.powerSim</a></code>, <code><a href="#topic+confint.powerSim">confint.powerSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmer(y ~ x + (1|g), data=simdata)
powerSim(fm1, nsim=10)

</code></pre>

<hr>
<h2 id='print.powerSim'>Report simulation results</h2><span id='topic+print.powerSim'></span><span id='topic+print.powerCurve'></span><span id='topic+summary.powerSim'></span><span id='topic+summary.powerCurve'></span><span id='topic+confint.powerSim'></span><span id='topic+confint.powerCurve'></span>

<h3>Description</h3>

<p>Describe and extract power simulation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powerSim'
print(x, alpha = x$alpha, level = 0.95, ...)

## S3 method for class 'powerCurve'
print(x, ...)

## S3 method for class 'powerSim'
summary(
  object,
  alpha = object$alpha,
  level = 0.95,
  method = getSimrOption("binom"),
  ...
)

## S3 method for class 'powerCurve'
summary(
  object,
  alpha = object$alpha,
  level = 0.95,
  method = getSimrOption("binom"),
  ...
)

## S3 method for class 'powerSim'
confint(
  object,
  parm,
  level = 0.95,
  method = getSimrOption("binom"),
  alpha = object$alpha,
  ...
)

## S3 method for class 'powerCurve'
confint(object, parm, level = 0.95, method = getSimrOption("binom"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.powerSim_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+powerSim">powerSim</a></code> or <code><a href="#topic+powerCurve">powerCurve</a></code> object</p>
</td></tr>
<tr><td><code id="print.powerSim_+3A_alpha">alpha</code></td>
<td>
<p>the significance level for the statistical test (default is that used in the call to <code>powerSim</code>).</p>
</td></tr>
<tr><td><code id="print.powerSim_+3A_level">level</code></td>
<td>
<p>confidence level for power estimate</p>
</td></tr>
<tr><td><code id="print.powerSim_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="binom.html#topic+binom.confint">binom::binom.confint()</a></code>
</p>
<p><code>alpha</code> refers to the threshold for an effect being significant and
thus directly determines the point estimate for the power calculation.
<code>level</code> is the confidence level that is calculated for this point
evidence and determines the width/coverage of the confidence interval for
power.</p>
</td></tr>
<tr><td><code id="print.powerSim_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+powerSim">powerSim</a></code> or <code><a href="#topic+powerCurve">powerCurve</a></code> object</p>
</td></tr>
<tr><td><code id="print.powerSim_+3A_method">method</code></td>
<td>
<p>method to use for computing binomial confidence intervals (see <code><a href="binom.html#topic+binom.confint">binom::binom.confint()</a></code>)</p>
</td></tr>
<tr><td><code id="print.powerSim_+3A_parm">parm</code></td>
<td>
<p>currently ignored, included for S3 compatibility with <code><a href="stats.html#topic+confint">stats::confint</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="binom.html#topic+binom.confint">binom::binom.confint</a></code>, <code><a href="#topic+powerSim">powerSim</a></code>, <code><a href="#topic+powerCurve">powerCurve</a></code>
</p>

<hr>
<h2 id='simdata'>Example dataset.</h2><span id='topic+simdata'></span>

<h3>Description</h3>

<p>A simple artificial data set used in the tutorial. There are two response variables,
a Poisson count <code>z</code> and a Gaussian response <code>y</code>. There is a continuous predictor
<code>x</code> with ten values <code>{1,2,...,10}</code> and a categorical predictor <code>g</code> with
three levels <code>{a, b, c}</code>.
</p>

<hr>
<h2 id='simr-package'>simr: Simulation-based power calculations for mixed models.</h2><span id='topic+simr-package'></span>

<h3>Description</h3>

<p><code>simr</code> is a package that makes it easy to run simulation-based power analyses
with <code>lme4</code>.
</p>

<hr>
<h2 id='simrOptions'>Options Settings for <code>simr</code></h2><span id='topic+simrOptions'></span><span id='topic+getSimrOption'></span>

<h3>Description</h3>

<p>Control the default behaviour of <code>simr</code> analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simrOptions(...)

getSimrOption(opt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simrOptions_+3A_...">...</code></td>
<td>
<p>a list of names to get options, or a named list of new values to set options.</p>
</td></tr>
<tr><td><code id="simrOptions_+3A_opt">opt</code></td>
<td>
<p>option name (character string).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getSimrOption</code> returns the current value for the option <code>x</code>.
</p>
<p><code>simrOptions</code> returns
</p>

<ol>
<li><p> a named list of all options, if no arguments are given.
</p>
</li>
<li><p> a named list of specified options, if a list of option names is given.
</p>
</li>
<li><p> (invisibly) a named list of changed options with their previous values, if options are set.
</p>
</li></ol>



<h3>Options in <code>simr</code></h3>

<p>Options that can be set with this method (and their default values).
</p>

<dl>
<dt><code>nsim</code></dt><dd><p>default number of simulations (<code>1000</code>).</p>
</dd>
<dt><code>alpha</code></dt><dd><p>default confidence level (<code>0.05</code>).</p>
</dd>
<dt><code>progress</code></dt><dd><p>use progress bars during calculations (<code>TRUE</code>).</p>
</dd>
<dt><code>binom</code></dt><dd><p>method for calculating confidence intervals (<code>"exact"</code>).</p>
</dd>
<dt><code>pbnsim</code></dt><dd><p>number of simulations for parametric bootstrap tests using <code>pbkrtest</code> (<code>100</code>).</p>
</dd>
<dt><code>pcmin</code></dt><dd><p>minimum number of levels for the smallest point on a <code><a href="#topic+powerCurve">powerCurve</a></code> (3).</p>
</dd>
<dt><code>pcmax</code></dt><dd><p>maximum number of points on the default <code><a href="#topic+powerCurve">powerCurve</a></code> (10).</p>
</dd>
<dt><code>observedPowerWarning</code></dt><dd><p>warn if an unmodified fitted model is used (TRUE).</p>
</dd>
<dt><code>carTestType</code></dt><dd><p> type of test, i.e. type of sum of squares, for tests performed with <code><a href="car.html#topic+Anova">car::Anova</a></code> (<code>"II"</code>).</p>
</dd>
<dt><code>lmerTestDdf</code></dt><dd><p> approximation to use for denominator degrees of
freedom for tests performed with
<code><a href="lmerTest.html#topic+lmer">lmerTest</a></code>
(<code>"Satterthwaite"</code>). Note that setting this
option to <code>"lme4"</code> will reduce the
<code>lmerTest</code> model to an <code>lme4</code> model and
break functionality based on <code>lmerTest</code>.</p>
</dd>
<dt><code>lmerTestType</code></dt><dd><p> type of test, i.e. type of sum of squares, for
F-tests performed with
<code><a href="lmerTest.html#topic+anova.lmerModLmerTest">lmerTest::anova.lmerModLmerTest</a></code>
(<code>2</code>). Note that unlike the tests performed
with <code>car::Anova</code>, the test type must be
given as a number and not a character.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
getSimrOption("nsim")
oldopts &lt;- simrOptions(nsim=5)
getSimrOption("nsim")
simrOptions(oldopts)
getSimrOption("nsim")

</code></pre>

<hr>
<h2 id='tests'>Specify a statistical test to apply</h2><span id='topic+tests'></span><span id='topic+fixed'></span><span id='topic+compare'></span><span id='topic+fcompare'></span><span id='topic+rcompare'></span><span id='topic+random'></span>

<h3>Description</h3>

<p>Specify a statistical test to apply
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed(
  xname,
  method = c("z", "t", "f", "chisq", "anova", "lr", "sa", "kr", "pb")
)

compare(model, method = c("lr", "pb"))

fcompare(model, method = c("lr", "kr", "pb"))

rcompare(model, method = c("lr", "pb"))

random()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tests_+3A_xname">xname</code></td>
<td>
<p>an explanatory variable to test (character).</p>
</td></tr>
<tr><td><code id="tests_+3A_method">method</code></td>
<td>
<p>the type of test to apply (see Details).</p>
</td></tr>
<tr><td><code id="tests_+3A_model">model</code></td>
<td>
<p>a null model for comparison (formula).</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>fixed</code>:</dt><dd>
<p>Test a single fixed effect, specified by <code>xname</code>.</p>
</dd>
<dt><code>compare</code>:</dt><dd>
<p>Compare the current model to a smaller one specified by the formula <code>model</code>.</p>
</dd>
<dt><code>fcompare</code>, <code>rcompare</code>:</dt><dd>
<p>Similar to <code>compare</code>, but only the fixed/random part of the formula needs to be supplied.</p>
</dd>
<dt><code>random</code>:</dt><dd>
<p>Test the significance of a single random effect.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A function which takes a fitted model as an argument and returns a single p-value.
</p>


<h3>Methods</h3>

<p>The <code>method</code> argument can be used to specify one of the following tests.
Note that <code>"z"</code> is an asymptotic approximation for models not fitted
with <code><a href="lme4.html#topic+glmer">glmer</a></code> and <code>"kr"</code> will only work with models
fitted with <code><a href="lme4.html#topic+lmer">lmer</a></code>.
</p>

<dl>
<dt><code>z</code>:</dt><dd>
<p>Z-test for models fitted with <code><a href="lme4.html#topic+glmer">glmer</a></code> (or <code><a href="stats.html#topic+glm">glm</a></code>),
using the p-value from <code><a href="lme4.html#topic+summary.merMod">summary</a></code>.
For models fitted with <code><a href="lme4.html#topic+lmer">lmer</a></code>, this test can be used to
treat the t-values from <code><a href="lme4.html#topic+summary.merMod">summary</a></code> as
z-values, which is equivalent to assuming infinite degrees of freedom.
This asymptotic approximation seems to perform well for even medium-sized
data sets, as the denominator degrees of freedom are already quite large
(cf. Baayen et al. 2008) even if calculating their exact value is
analytically unsolved and computationally difficult (e.g. with
Satterthwaite or Kenward-Roger approximations). Setting
<code>alpha=0.045</code> is roughly equal to the t=2 threshold suggested by
Baayen et al. (2008) and helps compensate for the slightly
anti-conservative approximation.</p>
</dd>
<dt><code>t</code>:</dt><dd>
<p>T-test for models fitted with <code><a href="stats.html#topic+lm">lm</a></code>. Also available for mixed models
when <code><a href="lmerTest.html#topic+lmerTest">lmerTest</a></code> is installed, using the p-value calculated
using the Satterthwaite approximation for the denominator degrees of
freedom by default. This can be changed by setting <code>lmerTestDdf</code>,
see <code><a href="#topic+simrOptions">simrOptions</a></code>.</p>
</dd>
<dt><code>lr</code>:</dt><dd><p>Likelihood ratio test, using <code><a href="lme4.html#topic+anova.merMod">anova</a></code>.</p>
</dd>
<dt><code>f</code>:</dt><dd>
<p>Wald F-test, using <code><a href="car.html#topic+Anova">car::Anova</a></code>.
Useful for examining categorical terms. For models fitted with
<code><a href="lme4.html#topic+lmer">lmer</a></code>, this should yield equivalent results to
<code>method='kr'</code>. Uses Type-II tests by default, this can be changed
by setting <code>carTestType</code>, see <code><a href="#topic+simrOptions">simrOptions</a></code>.</p>
</dd>
<dt><code>chisq</code>:</dt><dd>
<p>Wald Chi-Square test, using <code><a href="car.html#topic+Anova">car::Anova</a></code>.
Please note that while this is much faster than the F-test computed with
Kenward-Roger, it is also known to be anti-conservative, especially for
small samples. Uses Type-II tests by default, this can be changed by
setting <code>carTestType</code>, see <code><a href="#topic+simrOptions">simrOptions</a></code>.</p>
</dd>
<dt><code>anova</code>:</dt><dd>
<p>ANOVA-style F-test, using <code><a href="stats.html#topic+anova">anova</a></code> and
<code><a href="lmerTest.html#topic+anova.lmerModLmerTest">lmerTest::anova.lmerModLmerTest</a></code>.
For 'lm', this yields a Type-I (sequential) test (see <code><a href="stats.html#topic+anova.lm">anova</a></code>);
to use other test types, use the F-tests provided by <code>car::Anova()</code>
(see above). For <code>lmer</code>, this generates Type-II tests with
Satterthwaite denominator degrees of freedom by default, this can be
changed by setting <code>lmerTestDdf</code> and <code>lmerTestType</code>, see
<code><a href="#topic+simrOptions">simrOptions</a></code>.</p>
</dd>
<dt><code>kr</code>:</dt><dd>
<p>Kenward-Roger test, using <code><a href="pbkrtest.html#topic+KRmodcomp">KRmodcomp</a></code>.
This only applies to models fitted with <code><a href="lme4.html#topic+lmer">lmer</a></code>, and compares models with
different fixed effect specifications but equivalent random effects.</p>
</dd>
<dt><code>pb</code>:</dt><dd>
<p>Parametric bootstrap test, using <code><a href="pbkrtest.html#topic+PBmodcomp">PBmodcomp</a></code>.
This test will be very accurate, but is also very computationally expensive.</p>
</dd>
</dl>

<p>Tests using <code>random</code> for a single random effect call <code><a href="RLRsim.html#topic+exactRLRT">exactRLRT</a></code>.
</p>


<h3>References</h3>

<p>Baayen, R. H., Davidson, D. J., and Bates, D. M. (2008). Mixed-effects modeling
with crossed random effects for subjects and items. Journal of Memory and Language, 59, 390&ndash;412.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lm1 &lt;- lmer(y ~ x + (x|g), data=simdata)
lm0 &lt;- lmer(y ~ x + (1|g), data=simdata)
anova(lm1, lm0)
compare(. ~ x + (1|g))(lm1)
rcompare(~ (1|g))(lm1)
## Not run: powerSim(fm1, compare(. ~ x + (1|g)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
