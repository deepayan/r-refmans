<!DOCTYPE html><html><head><title>Help for package Perc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Perc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.conflictmat'><p>convert to a matrix of <code>conf.mat</code> class</p></a></li>
<li><a href='#bradleyTerry'><p>Computes the MLE for the BT model using an MM algorithm</p></a></li>
<li><a href='#bt.test'><p>Systemic test for the assumptions of the Bradley-Terry model</p></a></li>
<li><a href='#conductance'><p>compute win-loss probabilities</p></a></li>
<li><a href='#countPaths'><p>count paths between all pairs</p></a></li>
<li><a href='#dyadicLongConverter'><p>dyadic long format converter</p></a></li>
<li><a href='#findAllPaths'><p>Identifies all paths between all pairs of less than or</p>
equal to a certain length</a></li>
<li><a href='#findIDpaths'><p>find all paths of a certain length for an individual</p></a></li>
<li><a href='#getAllCosts'><p>Associate each costs with its corresponding simulated annealing runs</p></a></li>
<li><a href='#getAllRankOrder'><p>assign IDs to all best rank orders</p></a></li>
<li><a href='#getBestRankOrder'><p>assign IDs to the best rank order</p></a></li>
<li><a href='#getSimOutput'><p>get useful outputs from simulated annealing processes</p></a></li>
<li><a href='#individualDomProb'><p>individual-level probability converter</p></a></li>
<li><a href='#Perc'><p>Perc.</p></a></li>
<li><a href='#plotConfmat'><p>generate heat map for a matrix</p></a></li>
<li><a href='#plotProbDiagnosis'><p>Diagnosis Plot</p>
<code>plotProbDiagnosis</code> generate heat map for dominance probability matrix</a></li>
<li><a href='#sampleEdgelist'><p>sampleEdgelist.</p>
social interactions among 11 monkeys</a></li>
<li><a href='#sampleRawMatrix'><p>sampleRawMatrix.</p>
dominance interactions between 39 monkeys</a></li>
<li><a href='#sampleWeightedEdgelist'><p>sampleWeightedEdgelist.</p>
dominance interactions among 29 monkeys</a></li>
<li><a href='#simRankOrder'><p>Find rank order using simulated annealing</p></a></li>
<li><a href='#transitivity'><p>calculate transitivity measurements for a matrix</p></a></li>
<li><a href='#valueConverter'><p>win-loss probability matrix value converter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Using Percolation and Conductance to Find Information Flow
Certainty in a Direct Network</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-11</td>
</tr>
<tr>
<td>Description:</td>
<td>To find the certainty of dominance interactions with indirect
    interactions being considered.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Fushing Lab &amp; McCowan Lab, University of California, Davis</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, devtools, reshape2, lattice</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-11 20:46:11 UTC; Jessica</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Fujii [aut],
  Jian Jin [aut],
  Jessica Vandeleest [aut, cre],
  Aaron Shev [aut],
  Brianne Beisner [aut],
  Brenda McCowan [aut, cph],
  Hsieh Fushing [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jessica Vandeleest &lt;vandelee@ucdavis.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-11 21:22:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.conflictmat'>convert to a matrix of <code>conf.mat</code> class</h2><span id='topic+as.conflictmat'></span>

<h3>Description</h3>

<p><code>as.conflictmat</code> convert an edgelist or a win-loss raw matrix to a matrix of <code>conf.mat</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.conflictmat(Data, weighted = FALSE, swap.order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.conflictmat_+3A_data">Data</code></td>
<td>
<p>either a dataframe or a matrix, representing raw win-loss interactions using either an edgelist or a matrix. 
By default, winners are represented by IDs in the 1st column for an edgelist, and by row IDs for a matrix. 
Frequency of interactions for each dyad can be represented either by multiple occurrences of the dyad for a 2-column edgelist, or
by a third column specifying the frequency of the interaction for a 3-column edgelist.</p>
</td></tr>
<tr><td><code id="as.conflictmat_+3A_weighted">weighted</code></td>
<td>
<p>If the edgelist is a 3-column edgelist in which weight was specified by frequency, use <code>weighted = TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.conflictmat_+3A_swap.order">swap.order</code></td>
<td>
<p>If the winner is placed in the 2nd column for an edgelist or as the column name for a matrix, specify as <code>TRUE</code>. By default, winners are placed in the first column of an edgelist or in the row names of a matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conf.mat</code> is short for &quot;Conflict Matrix&quot;. <code>conf.mat</code> is 
a class of R objects. It is required to use <code>as.conflictmat</code> to convert your
raw edgelist or raw win-loss matrix into a matrix of <code>conf.mat</code> object before
using other functions to find (in)direct pathways and computing dominance probabilities.
</p>
<p>Note, when using a 3-column edgelist (e.g. a weighted edgelist) to represent raw win-loss interactions, each dyad must be unique. If more than one rows are found with the same initiator and recipient,
sum of the frequencies will be taken to represent the freqency of interactions between this unique dyad. A warning message will prompt your attention to the accuracy of your raw data when duplicate dyads were found in a three-column edgelist.
</p>


<h3>Value</h3>

<p>a named matrix with the <code>[i,j]</code>th entry equal to the number of times <code>i</code> wins over <code>j</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findIDpaths">findIDpaths</a></code>, <code><a href="#topic+countPaths">countPaths</a></code>, <code><a href="#topic+transitivity">transitivity</a></code>, <code><a href="#topic+conductance">conductance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>confmatrix &lt;- as.conflictmat(sampleEdgelist, swap.order = FALSE)
confmatrix2 &lt;- as.conflictmat(sampleRawMatrix, swap.order = FALSE)
confmatrix3 &lt;- as.conflictmat(sampleWeightedEdgelist, weighted = TRUE, swap.order = FALSE)
</code></pre>

<hr>
<h2 id='bradleyTerry'>Computes the MLE for the BT model using an MM algorithm</h2><span id='topic+bradleyTerry'></span>

<h3>Description</h3>

<p><code>bradleyTerry</code> Computes the MLE for the BT model using an MM algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bradleyTerry(conf.mat, initial = NA, baseline = NA, stop.dif = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bradleyTerry_+3A_conf.mat">conf.mat</code></td>
<td>
<p>a matrix of conf.mat class. An N-by-N conflict matrix whose <code>(i,j)</code>th element is the number of times i defeated j.</p>
</td></tr>
<tr><td><code id="bradleyTerry_+3A_initial">initial</code></td>
<td>
<p>initial values of dominance indices for the MM algorithm, if not supplied, the 0 vector will be the inital value.</p>
</td></tr>
<tr><td><code id="bradleyTerry_+3A_baseline">baseline</code></td>
<td>
<p>index for agent to represent baseline dominance index set to 0.  If NA, the &quot;sum-to-one&quot; parameterization will be used.</p>
</td></tr>
<tr><td><code id="bradleyTerry_+3A_stop.dif">stop.dif</code></td>
<td>
<p>numeric value for difference in log likelihood value between iterations.  Used as the convergence criterion for the algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to meet Bradley-Terry assumption, each ID in <code>conf.mat</code> should have at least one win AND one loss.
<code>bradleyTerry</code> will return an error if no more than one win or loss was found.
</p>
<p>@references 
Shev, A., Hsieh, F., Beisner, B., &amp; McCowan, B. (2012). Using Markov chain Monte Carlo (MCMC) to visualize and test the linearity assumption of the Bradley-Terry class of models. Animal behaviour, 84(6), 1523-1531.
</p>
<p>Shev, A., Fujii, K., Hsieh, F., &amp; McCowan, B. (2014). Systemic Testing on Bradley-Terry Model against Nonlinear Ranking Hierarchy. PloS one, 9(12), e115367.
</p>


<h3>Value</h3>

<p>A list of length 3. 
</p>
<table>
<tr><td><code>domInds</code></td>
<td>
<p>a vector of length N consiting of the MLE values of the dominance indices. Lower values represent lower ranks.</p>
</td></tr>
<tr><td><code>probMat</code></td>
<td>
<p>an N-by-N numeric matrix of win-loss probabilities estimated by the BT model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the model fit.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># create an edgelist
edgelist1 &lt;- data.frame(col1 = sample(letters[1:15], 200, replace = TRUE),
                        col2 = sample(letters[1:15], 200, replace = TRUE),
                       stringsAsFactors = FALSE)
edgelist1 &lt;- edgelist1[-which(edgelist1$col1 == edgelist1$col2), ]
# convert an edgelist to conflict matrix
confmatrix_bt &lt;- as.conflictmat(edgelist1)
# Computes the MLE for the BT model
bt &lt;- bradleyTerry(confmatrix_bt)
</code></pre>

<hr>
<h2 id='bt.test'>Systemic test for the assumptions of the Bradley-Terry model</h2><span id='topic+bt.test'></span>

<h3>Description</h3>

<p><code>bt.test</code> Systemic test for the assumptions of the Bradley-Terry model,
transitivity and monotonic win-loss relationship. 
That is, if <code class="reqn">A &gt; B</code> and <code class="reqn">B &gt; C</code> then <code class="reqn">A &gt; C</code> and 
<code class="reqn">Pr(A beats C)</code> &gt; <code class="reqn">Pr(B beats C)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bt.test(conf.mat, baseline = 1, maxLength = 2, reps = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bt.test_+3A_conf.mat">conf.mat</code></td>
<td>
<p>an N-by-N matrix. The matrix should be a conflict matrix with element i,j
representing the number of times i has beaten j.</p>
</td></tr>
<tr><td><code id="bt.test_+3A_baseline">baseline</code></td>
<td>
<p>an integer between 1 and N inclusive identifying 
the agent with dominance index equal to zero.</p>
</td></tr>
<tr><td><code id="bt.test_+3A_maxlength">maxLength</code></td>
<td>
<p>an integer indicating maximum path length used
in <code>conductance</code></p>
</td></tr>
<tr><td><code id="bt.test_+3A_reps">reps</code></td>
<td>
<p>an integer indicating number of conflict matrices
simulated to estimate the sampling distribution under the BT model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of the test statistic should be within the estimated
sampling distribution of the test statistics under the BT model. 
The p-value of the test indicates the probability of statistics in the estimated sampling distribution
is larger than the test statistic. 
It is not appropriate to use Bradley-Terry model if value of the test statistic is higher than 
the estimated sampling distribution of the test statistics.
</p>


<h3>Value</h3>

<p>A list of 3 elements. 
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>value of the test statistic</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>estimated sampling distribution of the test statistics under the BT model.</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>p-value of the test</p>
</td></tr>
</table>


<h3>References</h3>

<p>Shev, A., Fujii, K., Hsieh, F., &amp; McCowan, B. (2014). Systemic Testing on Bradley-Terry Model against Nonlinear Ranking Hierarchy. PloS one, 9(12), e115367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an edgelist
edgelist1 &lt;- data.frame(col1 = sample(letters[1:15], 200, replace = TRUE),
                        col2 = sample(letters[1:15], 200, replace = TRUE),
                       stringsAsFactors = FALSE)
edgelist1 &lt;- edgelist1[-which(edgelist1$col1 == edgelist1$col2), ]
# convert an edgelist to conflict matrix
confmatrix_bt &lt;- as.conflictmat(edgelist1)
# test the assumptions of the Bradley-Terry model
# not run:
# condTestoutput &lt;- bt.test(confmatrix_bt)
</code></pre>

<hr>
<h2 id='conductance'>compute win-loss probabilities</h2><span id='topic+conductance'></span>

<h3>Description</h3>

<p><code>conductance</code> compute win-loss probabilities for all possible pairs
based upon the combined information from directed wins/losses and 
indirect win/loss pathways from the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conductance(conf, maxLength, alpha = NULL, beta = 1, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conductance_+3A_conf">conf</code></td>
<td>
<p>a matrix of conf.mat class. An N-by-N conflict matrix whose <code>(i,j)</code>th element is the number of times i defeated j.</p>
</td></tr>
<tr><td><code id="conductance_+3A_maxlength">maxLength</code></td>
<td>
<p>an integer greater than 1 and less than 7, indicating the maximum length of paths to identify.</p>
</td></tr>
<tr><td><code id="conductance_+3A_alpha">alpha</code></td>
<td>
<p>a positive integer that 
reflects the influence of an observed win/loss interaction 
on an underlying win-loss probability. 
It is used in the calculation of the posterior distribution 
for the win-loss probability of <code>i</code> over <code>j</code>: <code class="reqn">Beta(\alpha c_{i,j} +\beta, c_{i,j}+\beta)</code>. 
In the absence of expertise to accurately estimate alpha, 
it is estimated from the data.</p>
</td></tr>
<tr><td><code id="conductance_+3A_beta">beta</code></td>
<td>
<p>a positive numeric value that, like alpha, 
reflects the influence of an observed win/loss interaction 
on an underlying win-loss probability. 
Both <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are chosen such that <code class="reqn">((\alpha + \beta)/(\alpha + 2\beta))^2</code> is 
equal to the order-1 transitivity of the observed network. 
Therefore, <code class="reqn">\beta</code> is commonly set to 1.</p>
</td></tr>
<tr><td><code id="conductance_+3A_strict">strict</code></td>
<td>
<p>a logical vector of length 1. It is used in transitivity definition for alpha estimation. 
It should be set to TRUE when a transitive triangle is defined as all pathways in the triangle go to the same direction;
it should be set to FALSE when a transitive triangle is defined as PRIMARY pathways in the triangle go to the same direction.
Strict = FALSE by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs two major steps. 
First, repeated random walks through the empirical network 
identify all possible directed win-loss pathways 
between each pair of nodes in the network. 
Second, the information from both direct wins/losses and 
pathways of win/loss interactions are combined into an estimate of 
the underlying probability of <code>i</code> over <code>j</code>, for all <code>ij</code> pairs.
</p>


<h3>Value</h3>

<p>a list of two elements. 
</p>
<table>
<tr><td><code>imputed.conf</code></td>
<td>
<p>An N-by-N conflict matrix whose <code>(i,j)</code>th element is the 
'effective' number of wins of <code>i</code> over <code>j</code>.</p>
</td></tr>
<tr><td><code>p.hat</code></td>
<td>
<p>An N-by-N numeric matrix whose <code>(i,j)</code>th element is the estimated 
win-loss probability. 
Three functions (<code><a href="#topic+valueConverter">valueConverter</a></code>, <code><a href="#topic+individualDomProb">individualDomProb</a></code>, and <code><a href="#topic+dyadicLongConverter">dyadicLongConverter</a></code>) are provided to convert win-loss probability 
into other formats that are easier for further analysis of win-loss probability. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Fushing H, McAssey M, Beisner BA, McCowan B. 2011. 
Ranking network of a captive rhesus macaque society: a sophisticated corporative kingdom. 
PLoS ONE 6(3):e17817.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.conflictmat">as.conflictmat</a></code>, <code><a href="#topic+findIDpaths">findIDpaths</a></code>, <code><a href="#topic+transitivity">transitivity</a></code>, <code><a href="#topic+simRankOrder">simRankOrder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert an edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)
# find win-loss probability matrix
perm2 &lt;- conductance(confmatrix, 2, strict = FALSE)
perm2$imputed.conf
perm2$p.hat
</code></pre>

<hr>
<h2 id='countPaths'>count paths between all pairs</h2><span id='topic+countPaths'></span>

<h3>Description</h3>

<p><code>countPaths</code> Identifies the number of paths of length 
less than or equal to <code>maxLength</code> between all pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countPaths(conf, maxLength = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countPaths_+3A_conf">conf</code></td>
<td>
<p>a matrix of conf.mat class. 
An N-by-N conflict matrix whose <code>(i,j)</code>th element is the number of times i defeated j.</p>
</td></tr>
<tr><td><code id="countPaths_+3A_maxlength">maxLength</code></td>
<td>
<p>a positive numeric integer indicating the maximum length of paths to identify</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list in which elements are number of paths between all pairs of a given length.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.conflictmat">as.conflictmat</a></code>, <code><a href="#topic+findIDpaths">findIDpaths</a></code>, <code><a href="#topic+transitivity">transitivity</a></code>, <code><a href="#topic+conductance">conductance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert an edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)
# find number of paths of length 3 or less
npaths &lt;- countPaths(confmatrix, 3)
</code></pre>

<hr>
<h2 id='dyadicLongConverter'>dyadic long format converter</h2><span id='topic+dyadicLongConverter'></span>

<h3>Description</h3>

<p><code>dyadicLongConverter</code> convert win-loss probability matrix into long format for each dyad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyadicLongConverter(matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyadicLongConverter_+3A_matrix">matrix</code></td>
<td>
<p>the win-loss matrix which is the second output from <code>conductance</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>values on the diagonal of the matrix are not included in the converted long-format data.
</p>


<h3>Value</h3>

<p>a dataframe of dyadic level win-loss probability and ranking certainty.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conductance">conductance</a></code>, <code><a href="#topic+valueConverter">valueConverter</a></code>, <code><a href="#topic+individualDomProb">individualDomProb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert an edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)
# find win-loss probability matrix
perm2 &lt;- conductance(confmatrix, 2)
perm2$imputed.conf
perm2$p.hat
dl &lt;- dyadicLongConverter(perm2$p.hat)
</code></pre>

<hr>
<h2 id='findAllPaths'>Identifies all paths between all pairs of less than or 
equal to a certain length</h2><span id='topic+findAllPaths'></span>

<h3>Description</h3>

<p><code>findAllPaths</code> Identifies all paths length less than or equal 
to <code>maxLength</code> between all pairs of competitors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findAllPaths(conf, maxLength = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findAllPaths_+3A_conf">conf</code></td>
<td>
<p>a matrix of conf.mat class. An N-by-N conflict matrix whose <code>(i,j)</code>th element is the number of times i defeated j.</p>
</td></tr>
<tr><td><code id="findAllPaths_+3A_maxlength">maxLength</code></td>
<td>
<p>a positive numeric integer indicating the maximum length of paths to identify</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements. 
</p>
<table>
<tr><td><code>direct pathways</code></td>
<td>
<p>direct pathways found in original matrix</p>
</td></tr>
<tr><td><code>indirect pathways</code></td>
<td>
<p>a list of all paths from length 2 to the given length</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+countPaths">countPaths</a></code> <code><a href="#topic+findIDpaths">findIDpaths</a></code> <code><a href="#topic+transitivity">transitivity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert an edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)
# find all paths of legnth 3
allp.3 &lt;- findAllPaths(confmatrix, 3)
</code></pre>

<hr>
<h2 id='findIDpaths'>find all paths of a certain length for an individual</h2><span id='topic+findIDpaths'></span>

<h3>Description</h3>

<p><code>findIDpaths</code> identifies all unique win-loss pathways of order <code class="reqn">(len - 1)</code> beginning at selected <code>ID</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findIDpaths(conf, ID, len = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findIDpaths_+3A_conf">conf</code></td>
<td>
<p>a matrix of conf.mat class. An N-by-N conflict matrix whose <code>(i,j)</code>th element is the number of times i defeated j.</p>
</td></tr>
<tr><td><code id="findIDpaths_+3A_id">ID</code></td>
<td>
<p>a numeric or character vector of length 1. It specifys the subject at the beginning of each pathway.</p>
</td></tr>
<tr><td><code id="findIDpaths_+3A_len">len</code></td>
<td>
<p>a positive integer of length 1 greater than 2. the length of the win-loss paths to be identified (<code class="reqn">len = order + 1</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return all win-loss paths of <code>length(len)</code> beginning at <code>ID</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.conflictmat">as.conflictmat</a></code>, <code><a href="#topic+findAllPaths">findAllPaths</a></code>, <code><a href="#topic+countPaths">countPaths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>confmatrix &lt;- as.conflictmat(sampleEdgelist)
path38891 &lt;- findIDpaths(confmatrix, ID = "Kuai", len = 2)
</code></pre>

<hr>
<h2 id='getAllCosts'>Associate each costs with its corresponding simulated annealing runs</h2><span id='topic+getAllCosts'></span>

<h3>Description</h3>

<p>Associate each costs with its corresponding simulated annealing runs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAllCosts(costs_all, num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAllCosts_+3A_costs_all">costs_all</code></td>
<td>
<p>costs of all simAnnealing runs. It is the first element of the output from <code>getSimOutput</code>.</p>
</td></tr>
<tr><td><code id="getAllCosts_+3A_num">num</code></td>
<td>
<p>number of simulated annealing runs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of all costs.
</p>

<hr>
<h2 id='getAllRankOrder'>assign IDs to all best rank orders</h2><span id='topic+getAllRankOrder'></span>

<h3>Description</h3>

<p>assign IDs to all best rank orders
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAllRankOrder(ID_index, allRankOrder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAllRankOrder_+3A_id_index">ID_index</code></td>
<td>
<p>it depends on the inputed data from simRankOrder. It takes the colnames of data as ID, and index this ID by its position in the colname.</p>
</td></tr>
<tr><td><code id="getAllRankOrder_+3A_allrankorder">allRankOrder</code></td>
<td>
<p>all rank orders found in all simulated annealing runs. It is the third output from <code>getSimOutput</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of all costs.
</p>

<hr>
<h2 id='getBestRankOrder'>assign IDs to the best rank order</h2><span id='topic+getBestRankOrder'></span>

<h3>Description</h3>

<p>assign IDs to the best rank order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBestRankOrder(ID_index, bestRankOrder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBestRankOrder_+3A_id_index">ID_index</code></td>
<td>
<p>it depends on the inputed data from simRankOrder. It takes the colnames of data as ID, and index this ID by its position in the colname.</p>
</td></tr>
<tr><td><code id="getBestRankOrder_+3A_bestrankorder">bestRankOrder</code></td>
<td>
<p>the best rank order found in all simulated annealing runs. It is the second output from <code>getSimOutput</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of all costs.
</p>

<hr>
<h2 id='getSimOutput'>get useful outputs from simulated annealing processes</h2><span id='topic+getSimOutput'></span>

<h3>Description</h3>

<p>get useful outputs from simulated annealing processes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimOutput(simAnnealList, num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSimOutput_+3A_simanneallist">simAnnealList</code></td>
<td>
<p>the output from simAnnealing process</p>
</td></tr>
<tr><td><code id="getSimOutput_+3A_num">num</code></td>
<td>
<p>number of simulated annealing runs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of three elements
</p>
<table>
<tr><td><code>costs_all</code></td>
<td>
<p>costs of all simulated annealing runs.</p>
</td></tr>
<tr><td><code>bestRankOrder</code></td>
<td>
<p>best rank order found in all simulated annealing processes</p>
</td></tr>
<tr><td><code>allRankOrder</code></td>
<td>
<p>a dataframe, all best rank orders found in each simulated annealing processes</p>
</td></tr>
</table>

<hr>
<h2 id='individualDomProb'>individual-level probability converter</h2><span id='topic+individualDomProb'></span>

<h3>Description</h3>

<p><code>individualDomProb</code> convert win-loss probability matrix into long format for each dyad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>individualDomProb(matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="individualDomProb_+3A_matrix">matrix</code></td>
<td>
<p>the win-loss matrix which is the second output from <code>conductance</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe. Averaging probability of win-loss relationship with all other individuals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conductance">conductance</a></code>, <code><a href="#topic+valueConverter">valueConverter</a></code>, <code><a href="#topic+dyadicLongConverter">dyadicLongConverter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert an edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)
# find win-loss probability matrix
perm2 &lt;- conductance(confmatrix, 2)
perm2$imputed.conf
perm2$p.hat
individualLevelOutput &lt;- individualDomProb(perm2$p.hat)
</code></pre>

<hr>
<h2 id='Perc'>Perc.</h2><span id='topic+Perc'></span>

<h3>Description</h3>

<p>A package to measure information flow (e.g. dominance) through a network
</p>

<hr>
<h2 id='plotConfmat'>generate heat map for a matrix</h2><span id='topic+plotConfmat'></span>

<h3>Description</h3>

<p><code>plotConfmat</code> generate heat map for a matrix or a win-loss probability matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConfmat(conf.mat, ordering = NA, labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotConfmat_+3A_conf.mat">conf.mat</code></td>
<td>
<p>an N-by-N matrix. Either a conflict matrix or 
a win-loss probability matrix (the second element from <code>conductance</code> output)</p>
</td></tr>
<tr><td><code id="plotConfmat_+3A_ordering">ordering</code></td>
<td>
<p>a reordering of the rows/columns, specified by a permutation of 1:N</p>
</td></tr>
<tr><td><code id="plotConfmat_+3A_labels">labels</code></td>
<td>
<p>if TRUE, displaying the agent names as 
specified in the <code>rownames()</code> of <code>conf.mat()</code> on the heatmap</p>
</td></tr>
<tr><td><code id="plotConfmat_+3A_...">...</code></td>
<td>
<p>Further argument may be supplied and processed by <code>lattice::levelplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.conflictmat">as.conflictmat</a></code>, <code><a href="#topic+conductance">conductance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert an edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)
# find win-loss probability matrix
perm2 &lt;- conductance(confmatrix, 2)
# plotting
plotConfmat(perm2$p.hat)
</code></pre>

<hr>
<h2 id='plotProbDiagnosis'>Diagnosis Plot
<code>plotProbDiagnosis</code> generate heat map for dominance probability matrix</h2><span id='topic+plotProbDiagnosis'></span>

<h3>Description</h3>

<p>Diagnosis Plot
<code>plotProbDiagnosis</code> generate heat map for dominance probability matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotProbDiagnosis(prob.mat, cutoff = 0.75, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotProbDiagnosis_+3A_prob.mat">prob.mat</code></td>
<td>
<p>dominance probability matrix</p>
</td></tr>
<tr><td><code id="plotProbDiagnosis_+3A_cutoff">cutoff</code></td>
<td>
<p>a numeric value between 0.5 to 1. 
A value that is equal or greater than the cutoff is considered of high certainty.</p>
</td></tr>
<tr><td><code id="plotProbDiagnosis_+3A_...">...</code></td>
<td>
<p>Further argument may be supplied and processed by <code>levelplot</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plotConfmat">plotConfmat</a></code>
</p>

<hr>
<h2 id='sampleEdgelist'>sampleEdgelist.
social interactions among 11 monkeys</h2><span id='topic+sampleEdgelist'></span>

<h3>Description</h3>

<p>sampleEdgelist.
social interactions among 11 monkeys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleEdgelist
</code></pre>


<h3>Format</h3>

<p>A data frame of edgelist with 174 rows and 2 variables: <code>Iname</code>, <code>Rname</code>
</p>

<dl>
<dt>Iname</dt><dd><p>winner, animal ID</p>
</dd>
<dt>Rname</dt><dd><p>loser, animal ID</p>
</dd>
</dl>
<p>...

McCowan Lab sample data.
</p>

<hr>
<h2 id='sampleRawMatrix'>sampleRawMatrix.
dominance interactions between 39 monkeys</h2><span id='topic+sampleRawMatrix'></span>

<h3>Description</h3>

<p>sampleRawMatrix.
dominance interactions between 39 monkeys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleRawMatrix
</code></pre>


<h3>Format</h3>

<p>A 39 x 39 matrix representing number of times that a row wins over a column
</p>
<p>McCowan Lab sample data.
</p>

<hr>
<h2 id='sampleWeightedEdgelist'>sampleWeightedEdgelist.
dominance interactions among 29 monkeys</h2><span id='topic+sampleWeightedEdgelist'></span>

<h3>Description</h3>

<p>sampleWeightedEdgelist.
dominance interactions among 29 monkeys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleWeightedEdgelist
</code></pre>


<h3>Format</h3>

<p>A data frame of edgelist with 181 rows and 3 variables: <code>Initiator1</code>, <code>Recipient1</code>, <code>Freq</code>
</p>

<dl>
<dt>Initiator1</dt><dd><p>winner, monkey name</p>
</dd>
<dt>Recipient1</dt><dd><p>loser, monkey name</p>
</dd>
<dt>Freq</dt><dd><p>Frequency, count of interaction</p>
</dd>
</dl>
<p>...

McCowan Lab sample data.
</p>

<hr>
<h2 id='simRankOrder'>Find rank order using simulated annealing</h2><span id='topic+simRankOrder'></span>

<h3>Description</h3>

<p><code>simRankOrder</code> find the rank order for the win-loss relationship
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simRankOrder(data, num = 10, alpha = NULL, kmax = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simRankOrder_+3A_data">data</code></td>
<td>
<p>a matrix. the win-loss probability matrix 
which is the second element of the output from <code>conductance</code></p>
</td></tr>
<tr><td><code id="simRankOrder_+3A_num">num</code></td>
<td>
<p>number of SimAnnealing (default is set at 10)</p>
</td></tr>
<tr><td><code id="simRankOrder_+3A_alpha">alpha</code></td>
<td>
<p>a positive integer that 
reflects the influence of an observed win/loss interaction 
on an underlying win-loss probability. 
It is used in the calculation of the posterior distribution 
for the win-loss probability of <code>i</code> over <code>j</code>: <code class="reqn">Beta(\alpha c_{i,j} +\beta, c_{i,j}+\beta)</code>. 
In the absence of expertise to accurately estimate alpha, 
it is estimated from the data.</p>
</td></tr>
<tr><td><code id="simRankOrder_+3A_kmax">kmax</code></td>
<td>
<p>an integer between 2 to 1000, indicating the number of simulations in each SimAnnealing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two dataframes. 
</p>
<table>
<tr><td><code>BestSimulatedRankOrder</code></td>
<td>
<p>a dataframe representing the best simulated rank order.</p>
</td></tr>
<tr><td><code>Costs</code></td>
<td>
<p>the cost of each simulated annealing run</p>
</td></tr>
<tr><td><code>AllSimulatedRankOrder</code></td>
<td>
<p>a dataframe representing all simulated rank orders.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fushing, H., McAssey, M. P., Beisner, B., &amp; McCowan, B. (2011). Ranking network of a captive rhesus macaque society: a sophisticated corporative kingdom. PLoS One, 6(3), e17817-e17817.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conductance">conductance</a></code> <code><a href="#topic+transitivity">transitivity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert an edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)
# find dominance probability matrix
perm2 &lt;- conductance(confmatrix, maxLength = 2)
## Not run: 
# Note: It takes a while to run the simRankOrder example.
s.rank &lt;- simRankOrder(perm2$p.hat, num = 10, kmax = 1000)
s.rank$BestSimulatedRankOrder
s.rank$Costs
s.rank$AllSimulatedRankOrder

## End(Not run)

</code></pre>

<hr>
<h2 id='transitivity'>calculate transitivity measurements for a matrix</h2><span id='topic+transitivity'></span>

<h3>Description</h3>

<p><code>transitivity</code> calculate transitivity measurements for a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitivity(conf, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitivity_+3A_conf">conf</code></td>
<td>
<p>an N-by-N conflict matrix whose <code>(i,j)</code>th element is the number of times <code>i</code> defeated <code>j</code></p>
</td></tr>
<tr><td><code id="transitivity_+3A_strict">strict</code></td>
<td>
<p>a logical vector of length 1 (TRUE or FALSE). It is used in transitivity definition for alpha estimation. 
It should be set to TRUE when a transitive triangle is defined as all pathways in the triangle go to the same direction;
it should be set to FALSE when a transitive triangle is defined as PRIMARY pathways in the triangle go to the same direction.
Strict = FALSE by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>transitivity</code> is calculated as the proportion transitive triangles in the total of transitive and intransitive triangles.
transitivity is used to estimate alpha, which is used in turn in imputing information from indirect pathways as to what degree we can trust information from indirect pathways.
Greater transitivity is associated with assigning higher weight to information from indirect pathways.
</p>


<h3>Value</h3>

<p>A list of four elements.
</p>
<table>
<tr><td><code>transitive</code></td>
<td>
<p>The number of transitive triangles.</p>
</td></tr>
<tr><td><code>intransitive</code></td>
<td>
<p>The number of intransitive triangles.</p>
</td></tr>
<tr><td><code>transitivity</code></td>
<td>
<p>transitivity, the proportion of transitive triangles.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The value of alpha corresponding to this value of transitivity.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+countPaths">countPaths</a></code>, <code><a href="#topic+findIDpaths">findIDpaths</a></code>, <code><a href="#topic+conductance">conductance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert an edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)
# transitivity calculation
conftrans &lt;- transitivity(confmatrix, strict = FALSE)
conftrans$transitive
conftrans$intransitive
conftrans$transitivity
conftrans$alpha
</code></pre>

<hr>
<h2 id='valueConverter'>win-loss probability matrix value converter</h2><span id='topic+valueConverter'></span>

<h3>Description</h3>

<p><code>valueConverter</code> converts or transforms all values (which range from 0.0 to 1.0)
in the win-loss probability matrix into 0.5 - 1.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valueConverter(matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valueConverter_+3A_matrix">matrix</code></td>
<td>
<p>the win-loss matrix which is the second output from <code>conductance</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of win-loss probability ranging from 0.5 - 1.0.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conductance">conductance</a></code>, <code><a href="#topic+individualDomProb">individualDomProb</a></code>, <code><a href="#topic+dyadicLongConverter">dyadicLongConverter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert an edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)
# find win-loss probability matrix
perm2 &lt;- conductance(confmatrix, 2)
perm2$imputed.conf
perm2$p.hat
convertedValue &lt;- valueConverter(perm2$p.hat)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
