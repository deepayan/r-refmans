<!DOCTYPE html><html><head><title>Help for package aftgee</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aftgee}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aftgee-package'><p>aftgee: Accelerated Failure Time with Generalized Estimating Equation</p></a></li>
<li><a href='#aftgee'><p>Least-Squares Approach for Accelerated Failure Time with Generalized Estimating Equation</p></a></li>
<li><a href='#aftgee.control'><p>Auxiliary for Controlling AFTGEE Fitting</p></a></li>
<li><a href='#aftsrr'><p>Accelerated Failure Time with Smooth Rank Regression</p></a></li>
<li><a href='#export_is.Surv'><p><code>is.Surv</code> function imported from <code>survival</code></p></a></li>
<li><a href='#export_Surv'><p><code>Surv</code> function imported from <code>survival</code></p></a></li>
<li><a href='#QIC'><p>Quasi Information Criterion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Accelerated Failure Time Model with Generalized Estimating
Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of methods for both the rank-based estimates and least-square estimates to the Accelerated Failure Time (AFT) model. For rank-based estimation, it provides approaches that include the computationally efficient Gehan's weight and the general's weight such as the logrank weight. Details of the rank-based estimation can be found in Chiou et al. (2014) &lt;<a href="https://doi.org/10.1007%2Fs11222-013-9388-2">doi:10.1007/s11222-013-9388-2</a>&gt; and Chiou et al. (2015) &lt;<a href="https://doi.org/10.1002%2Fsim.6415">doi:10.1002/sim.6415</a>&gt;. For the least-square estimation, the estimating equation is solved with generalized estimating equations (GEE). Moreover, in multivariate cases, the dependence working correlation structure can be specified in GEE's setting. Details on the least-squares estimation can be found in Chiou et al. (2014) &lt;<a href="https://doi.org/10.1007%2Fs10985-014-9292-x">doi:10.1007/s10985-014-9292-x</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stc04003/aftgee">https://github.com/stc04003/aftgee</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stc04003/aftgee/issues">https://github.com/stc04003/aftgee/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, geepack, survival, BB, MASS, Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-27 15:18:40 UTC; chiou</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Author:</td>
<td>Sy Han Chiou [aut, cre],
  Sangwook Kang [aut],
  Jun Yan [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sy Han Chiou &lt;schiou@smu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-28 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aftgee-package'>aftgee: Accelerated Failure Time with Generalized Estimating Equation</h2><span id='topic+aftgee-package'></span><span id='topic+_PACKAGE'></span><span id='topic+aftgee-packages'></span>

<h3>Description</h3>

<p>A package that uses Generalized Estimating Equations (GEE) to estimate
Multivariate Accelerated Failure Time Model (AFT).
This package implements recently developed inference procedures for
AFT models with both the rank-based approach and the least squares approach.
For the rank-based approach, the package allows various weight choices
and uses an induced smoothing procedure that leads to much more
efficient computation than the linear programming method.
With the rank-based estimator as an initial value, the generalized
estimating equation approach is used as an extension of the least
squares approach to the multivariate case.
Additional sampling weights are incorporated to handle missing data
needed as in case-cohort studies or general sampling schemes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sy Han Chiou <a href="mailto:schiou@smu.edu">schiou@smu.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Sangwook Kang
</p>
</li>
<li><p> Jun Yan
</p>
</li></ul>



<h3>References</h3>

<p>Chiou, S., Kim, J. and Yan, J. (2014) Marginal Semiparametric Multivariate
Accelerated Failure Time Model with Generalized Estimating Equation.
<em>Life Time Data</em>, <b>20</b>(4): 599&ndash;618.
</p>
<p>Chiou, S., Kang, S. and Yan, J. (2014) Fast Accelerated Failure Time Modeling
for Case-Cohort Data. <em>Statistics and Computing</em>, <b>24</b>(4): 559&ndash;568.
</p>
<p>Chiou, S., Kang, S. and Yan, J. (2014) Fitting Accelerated Failure Time Model
in Routine Survival Analysis with R Package <span class="pkg">aftgee</span>.
<em>Journal of Statistical Software</em>, <b>61</b>(11): 1&ndash;23.
</p>
<p>Huang, Y. (2002) Calibration Regression of Censored Lifetime Medical Cost.
<em>Journal of American Statistical Association</em>, <b>97</b>, 318&ndash;327.
</p>
<p>Jin, Z. and Lin, D. Y. and Ying, Z. (2006)
On Least-squares Regression with Censored Data. <em>Biometrika</em>, <b>90</b>, 341&ndash;353.
</p>
<p>Johnson, L. M. and Strawderman, R. L. (2009)
Induced Smoothing for the Semiparametric Accelerated Failure Time Model:
Asymptotic and Extensions to Clustered Data. <em>Biometrika</em>, <b>96</b>, 577 &ndash; 590.
</p>
<p>Zeng, D. and Lin, D. Y. (2008)
Efficient Resampling Methods for Nonsmooth Estimating Functions.
<em>Biostatistics</em>, <b>9</b>, 355&ndash;363
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/stc04003/aftgee">https://github.com/stc04003/aftgee</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/stc04003/aftgee/issues">https://github.com/stc04003/aftgee/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aftgee'>Least-Squares Approach for Accelerated Failure Time with Generalized Estimating Equation</h2><span id='topic+aftgee'></span>

<h3>Description</h3>

<p>Fits a semiparametric accelerated failure time (AFT) model with least-squares approach.
Generalized estimating equation is generalized to multivariate AFT modeling to account
for multivariate dependence through working correlation structures to improve efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aftgee(
  formula,
  data,
  subset,
  id = NULL,
  contrasts = NULL,
  weights = NULL,
  margin = NULL,
  corstr = c("independence", "exchangeable", "ar1", "unstructured", "userdefined",
    "fixed"),
  binit = "srrgehan",
  B = 100,
  control = aftgee.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aftgee_+3A_formula">formula</code></td>
<td>
<p>a formula expression, of the form <code>response ~ predictors</code>.
The <code>response</code> is a <code>Surv</code> object with right censoring.
In the case of no censoring, <code>aftgee</code> will return an ordinary
least estimate when <code>corstr = "independence"</code>.
See the documentation of <code>lm</code>, <code>coxph</code> and <code>formula</code> for details.</p>
</td></tr>
<tr><td><code id="aftgee_+3A_data">data</code></td>
<td>
<p>an optional data.frame in which to interpret the variables occurring
in the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="aftgee_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="aftgee_+3A_id">id</code></td>
<td>
<p>an optional vector used to identify the clusters.
If missing, then each individual row of <code>data</code> is presumed to
represent a distinct subject.
The length of <code>id</code> should be the same as the number of observations.</p>
</td></tr>
<tr><td><code id="aftgee_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list.</p>
</td></tr>
<tr><td><code id="aftgee_+3A_weights">weights</code></td>
<td>
<p>an optional vector of observation weights.</p>
</td></tr>
<tr><td><code id="aftgee_+3A_margin">margin</code></td>
<td>
<p>a <code>sformula</code> vector; default at 1.</p>
</td></tr>
<tr><td><code id="aftgee_+3A_corstr">corstr</code></td>
<td>
<p>a character string specifying the correlation structure.
The following are permitted:
</p>

<ul>
<li> <p><code>independence</code>
</p>
</li>
<li> <p><code>exchangeable</code>
</p>
</li>
<li> <p><code>ar1</code>
</p>
</li>
<li> <p><code>unstructured</code>
</p>
</li>
<li> <p><code>userdefined</code>
</p>
</li>
<li> <p><code>fixed</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="aftgee_+3A_binit">binit</code></td>
<td>
<p>an optional vector can be either a numeric vector or a character string
specifying the initial slope estimator.
</p>

<ul>
<li><p> When <code>binit</code> is a vector, its length should be the same as the
dimension of covariates.
</p>
</li>
<li><p> When <code>binit</code> is a character string, it should be either <code>lm</code> for simple linear
regression, or <code>srrgehan</code> for smoothed Gehan weight estimator.
</p>
</li></ul>
<p> The default value is &quot;srrgehan&quot;.</p>
</td></tr>
<tr><td><code id="aftgee_+3A_b">B</code></td>
<td>
<p>a numeric value specifies the resampling number.
When B = 0, only the beta estimate will be displayed.</p>
</td></tr>
<tr><td><code id="aftgee_+3A_control">control</code></td>
<td>
<p>controls maxiter and tolerance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code>aftgee</code>&quot; representing the fit.
The <code>aftgee</code> object is a list containing at least the following components:
</p>

<dl>
<dt>coefficients</dt><dd><p>a vector of initial value and a vector of point estimates</p>
</dd>
<dt>coef.res</dt><dd><p>a vector of point estimates</p>
</dd>
<dt>var.res</dt><dd><p>estimated covariance matrix</p>
</dd>
<dt>coef.init</dt><dd><p>a vector of initial value</p>
</dd>
<dt>var.init.mat</dt><dd><p>estimated initial covariance matrix</p>
</dd>
<dt>binit</dt><dd><p>a character string specifying the initial estimator.</p>
</dd>
<dt>conv</dt><dd><p>An integer code indicating type of convergence after GEE
iteration. 0 indicates successful convergence; 1 indicates that the
iteration limit <code>maxit</code> has been reached</p>
</dd>
<dt>ini.conv</dt><dd><p>An integer code indicating type of convergence for
initial value. 0 indicates successful convergence; 1 indicates that the
iteration limit <code>maxit</code> has been reached</p>
</dd>
<dt>conv.step</dt><dd><p>An integer code indicating the step until convergence</p>
</dd>
</dl>



<h3>References</h3>

<p>Chiou, S., Kim, J. and Yan, J. (2014) Marginal Semiparametric Multivariate
Accelerated Failure Time Model with Generalized Estimating Equation.
<em>Lifetime Data Analysis</em>, <b>20</b>(4): 599&ndash;618.
</p>
<p>Jin, Z. and Lin, D. Y. and Ying, Z. (2006)
On Least-squares Regression with Censored Data. <em>Biometrika</em>, <b>90</b>, 341&ndash;353.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data from an AFT model with possible depended response
datgen &lt;- function(n = 100, tau = 0.3, dim = 2) {
    x1 &lt;- rbinom(dim * n, 1, 0.5)
    x2 &lt;- rnorm(dim * n)
    e &lt;- c(t(exp(MASS::mvrnorm(n = n, mu = rep(0, dim), Sigma = tau + (1 - tau) * diag(dim)))))
    tt &lt;- exp(2 + x1 + x2 + e)
    cen &lt;- runif(n, 0, 100)
    data.frame(Time = pmin(tt, cen), status = 1 * (tt &lt; cen),
               x1 = x1, x2 = x2, id = rep(1:n, each = dim))
}
set.seed(1); dat &lt;- datgen(n = 50, dim = 2)
fm &lt;- Surv(Time, status) ~ x1 + x2
fit1 &lt;- aftgee(fm, data = dat, id = id, corstr = "ind")
fit2 &lt;- aftgee(fm, data = dat, id = id, corstr = "ex")
summary(fit1)
summary(fit2)

confint(fit1)
confint(fit2)
</code></pre>

<hr>
<h2 id='aftgee.control'>Auxiliary for Controlling AFTGEE Fitting</h2><span id='topic+aftgee.control'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for <code>aftgee</code> and <code>aftsrr</code> fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aftgee.control(
  maxiter = 50,
  reltol = 0.001,
  trace = FALSE,
  seIni = FALSE,
  parallel = FALSE,
  parCl = parallel::detectCores()/2,
  gp.pwr = -999
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aftgee.control_+3A_maxiter">maxiter</code></td>
<td>
<p>max number of iteration.</p>
</td></tr>
<tr><td><code id="aftgee.control_+3A_reltol">reltol</code></td>
<td>
<p>relative error tolerance.</p>
</td></tr>
<tr><td><code id="aftgee.control_+3A_trace">trace</code></td>
<td>
<p>a binary variable, determine whether to display output for each iteration.</p>
</td></tr>
<tr><td><code id="aftgee.control_+3A_seini">seIni</code></td>
<td>
<p>a logical value indicating whether a new rank-based initial value is computed
for each resampling sample in variance estimation.</p>
</td></tr>
<tr><td><code id="aftgee.control_+3A_parallel">parallel</code></td>
<td>
<p>an logical value indicating whether parallel computing is used for resampling and bootstrap.</p>
</td></tr>
<tr><td><code id="aftgee.control_+3A_parcl">parCl</code></td>
<td>
<p>an integer value indicating the number of CPU cores used when <code>parallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="aftgee.control_+3A_gp.pwr">gp.pwr</code></td>
<td>
<p>an numerical value indicating the GP parameter when <code>rankWeights = GP</code>.
The default value is half the CPU cores on the current host.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>trace</code> is TRUE, output for each iteration is printed to the screen.
</p>


<h3>Value</h3>

<p>A list with the arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aftgee">aftgee</a></code>
</p>

<hr>
<h2 id='aftsrr'>Accelerated Failure Time with Smooth Rank Regression</h2><span id='topic+aftsrr'></span>

<h3>Description</h3>

<p>Fits a semiparametric accelerated failure time (AFT) model with rank-based approach.
General weights, additional sampling weights and fast sandwich variance estimations
are also incorporated.
Estimating equations are solved with Barzilar-Borwein spectral method implemented as
<code>BBsolve</code> in package <span class="pkg">BB</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aftsrr(
  formula,
  data,
  subset,
  id = NULL,
  contrasts = NULL,
  weights = NULL,
  B = 100,
  rankWeights = c("gehan", "logrank", "PW", "GP", "userdefined"),
  eqType = c("is", "ns", "mis", "mns"),
  se = c("NULL", "bootstrap", "MB", "ZLCF", "ZLMB", "sHCF", "sHMB", "ISCF", "ISMB"),
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aftsrr_+3A_formula">formula</code></td>
<td>
<p>a formula expression, of the form <code>response ~ predictors</code>.
The <code>response</code> is a <code>Surv</code> object object with right censoring.
See the documentation of <code>lm</code>, <code>coxph</code> and <code>formula</code> for details.</p>
</td></tr>
<tr><td><code id="aftsrr_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to interpret the variables
occurring in the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="aftsrr_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="aftsrr_+3A_id">id</code></td>
<td>
<p>an optional vector used to identify the clusters.
If missing, then each individual row of <code>data</code> is presumed to
represent a distinct subject.
The length of <code>id</code> should be the same as the number of observation.</p>
</td></tr>
<tr><td><code id="aftsrr_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list.</p>
</td></tr>
<tr><td><code id="aftsrr_+3A_weights">weights</code></td>
<td>
<p>an optional vector of observation weights.</p>
</td></tr>
<tr><td><code id="aftsrr_+3A_b">B</code></td>
<td>
<p>a numeric value specifies the resampling number.
When <code>B = 0</code> or <code>se = NULL</code>, only the beta estimate will be displayed.</p>
</td></tr>
<tr><td><code id="aftsrr_+3A_rankweights">rankWeights</code></td>
<td>
<p>a character string specifying the type of general weights.
The following are permitted:
</p>

<dl>
<dt><code>logrank</code></dt><dd><p>logrank weight</p>
</dd>
<dt><code>gehan</code></dt><dd><p>Gehan's weight</p>
</dd>
<dt><code>PW</code></dt><dd><p>Prentice-Wilcoxon weight</p>
</dd>
<dt><code>GP</code></dt><dd><p>GP class weight</p>
</dd>
<dt><code>userdefined</code></dt><dd><p>a user defined weight provided as a vector
with length equal to the number of subject. This argument is still under-development.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="aftsrr_+3A_eqtype">eqType</code></td>
<td>
<p>a character string specifying the type of the
estimating equation used to obtain the regression parameters.
The following are permitted:
</p>

<dl>
<dt><code>is</code></dt><dd><p>Regression parameters are estimated by directly solving the
induced-smoothing estimating equations. This is the default and recommended method.</p>
</dd>
<dt><code>ns</code></dt><dd><p>Regression parameters are estimated by directly solving the nonsmooth
estimating equations.</p>
</dd>
<dt><code>mis</code></dt><dd><p>Regression parameters are estimated by iterating the
monotonic smoothed Gehan-based estimating equations. This is typical when
<code>rankWeights = "PW"</code> and <code>rankWeights = "GP"</code>.</p>
</dd>
<dt><code>mns</code></dt><dd><p>Regression parameters are estimated by iterating the
monotonic non-smoothed Gehan-based estimating equations. This is typical when
<code>rankWeights = "PW"</code> and <code>rankWeights = "GP"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="aftsrr_+3A_se">se</code></td>
<td>
<p>a character string specifying the estimating method for the variance-covariance matrix.
The following are permitted:
</p>

<dl>
<dt><code>NULL</code></dt><dd><p>if <code>se</code> is specified as <code>NULL</code>,
the variance-covariance matrix will not be computed.</p>
</dd>
<dt><code>bootstrap</code></dt><dd><p>nonparametric bootstrap.</p>
</dd>
<dt><code>MB</code></dt><dd><p>multiplier resampling.</p>
</dd>
<dt><code>ZLCF</code></dt><dd><p>Zeng and Lin's approach with closed form <code class="reqn">V</code>, see <b>Details</b>.</p>
</dd>
<dt><code>ZLMB</code></dt><dd><p>Zeng and Lin's approach with empirical <code class="reqn">V</code>, see <b>Details</b>.</p>
</dd>
<dt><code>sHCF</code></dt><dd><p>Huang's approach with closed form <code class="reqn">V</code>, see <b>Details</b>.</p>
</dd>
<dt><code>sHMB</code></dt><dd><p>Huang's approach with empirical <code class="reqn">V</code>, see <b>Details</b>.</p>
</dd>
<dt><code>ISCF</code></dt><dd><p>Johnson and Strawderman's sandwich variance estimates with closed form <code class="reqn">V</code>, see <b>Details</b>.</p>
</dd>
<dt><code>ISMB</code></dt><dd><p>Johnson and Strawderman's sandwich variance estimates with empirical <code class="reqn">V</code>, see <b>Details</b>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="aftsrr_+3A_control">control</code></td>
<td>
<p>controls equation solver, maxiter, tolerance, and resampling variance estimation.
The available equation solvers are <code>BBsolve</code> and <code>dfsane</code> of the <span class="pkg">BB</span> package.
The default algorithm control parameters are used when these functions are called.
However, the monotonicity parameter, <code>M</code>, can be specified by users via the control list.
When <code>M</code> is specified, the merit parameter, <code>noimp</code>, is set at </p>
<p style="text-align: center;"><code class="reqn">10 * M</code>
</p>
<p>.
The readers are refered to the <span class="pkg">BB</span> package for details.
Instead of searching for the zero crossing, options including <code>BBoptim</code> and <code>optim</code>
will return solution from maximizing the corresponding objective function.
When <code>se = "bootstrap"</code> or <code>se = "MB"</code>,
an additional argument <code>parallel = TRUE</code> can be specified to
enable parallel computation.
The number of CPU cores can be specified with <code>parCl</code>,
the default number of CPU cores is the integer value of <code>detectCores() / 2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>se = "bootstrap"</code> or <code>se = "MB"</code>, the variance-covariance matrix
is estimated through a bootstrap fashion.
Bootstrap samples that failed to converge are removed when computing the empirical variance matrix.
When bootstrap is not called, we assume the variance-covariance matrix has a sandwich form
</p>
<p style="text-align: center;"><code class="reqn">\Sigma = A^{-1}V(A^{-1})^T,</code>
</p>

<p>where <code class="reqn">V</code> is the asymptotic variance of the estimating function and
<code class="reqn">A</code> is the slope matrix.
In this package, we provide seveal methods to estimate the variance-covariance
matrix via this sandwich form, depending on how <code class="reqn">V</code> and <code class="reqn">A</code> are estimated.
Specifically, the asymptotic variance, <code class="reqn">V</code>, can be estimated by either a
closed-form formulation (<code>CF</code>) or through bootstrap the estimating equations (<code>MB</code>).
On the other hand, the methods to estimate the slope matrix <code class="reqn">A</code> are
the inducing smoothing approach (<code>IS</code>), Zeng and Lin's approach (<code>ZL</code>),
and the smoothed Huang's approach (<code>sH</code>).
</p>


<h3>Value</h3>

<p><code>aftsrr</code> returns an object of class &quot;<code>aftsrr</code>&quot; representing the fit.
An object of class &quot;<code>aftsrr</code>&quot; is a list containing at least the following components:
</p>

<dl>
<dt>beta</dt><dd><p>A vector of beta estimates</p>
</dd>
<dt>covmat</dt><dd><p>A list of covariance estimates</p>
</dd>
<dt>convergence</dt><dd><p>An integer code indicating type of convergence.</p>
</dd>
</dl>

<dl>
<dt>0</dt><dd><p>indicates successful convergence.</p>
</dd>
<dt>1</dt><dd><p>indicates that the iteration limit <code>maxit</code> has been reached.</p>
</dd>
<dt>2</dt><dd><p>indicates failure due to stagnation.</p>
</dd>
<dt>3</dt><dd><p>indicates error in function evaluation.</p>
</dd>
<dt>4</dt><dd><p>is failure due to exceeding 100 step length reductions in line-search.</p>
</dd>
<dt>5</dt><dd><p>indicates lack of improvement in objective function.</p>
</dd>
</dl>

<dl>
<dt>bhist</dt><dd><p>When <code>variance = "MB"</code>, <code>bhist</code> gives the bootstrap samples.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chiou, S., Kang, S. and Yan, J. (2014)
Fast Accelerated Failure Time Modeling for Case-Cohort Data. <em>Statistics and Computing</em>,
<b>24</b>(4): 559&ndash;568.
</p>
<p>Chiou, S., Kang, S. and Yan, J. (2014)
Fitting Accelerated Failure Time Model in Routine Survival Analysis with R Package <span class="pkg">Aftgee</span>.
<em>Journal of Statistical Software</em>, <b>61</b>(11): 1&ndash;23.
</p>
<p>Huang, Y. (2002) Calibration Regression of Censored Lifetime Medical Cost.
<em>Journal of American Statistical Association</em>, <b>97</b>, 318&ndash;327.
</p>
<p>Johnson, L. M. and Strawderman, R. L. (2009)
Induced Smoothing for the Semiparametric Accelerated Failure Time Model:
Asymptotic and Extensions to Clustered Data. <em>Biometrika</em>, <b>96</b>, 577 &ndash; 590.
</p>
<p>Varadhan, R. and Gilbert, P. (2009)
BB: An R Package for Solving a Large System of Nonlinear Equations and
for Optimizing a High-Dimensional Nonlinear Objective Function.
<em>Journal of Statistical Software</em>, <b>32</b>(4): 1&ndash;26
</p>
<p>Zeng, D. and Lin, D. Y. (2008)
Efficient Resampling Methods for Nonsmooth Estimating Functions.
<em>Biostatistics</em>, <b>9</b>, 355&ndash;363
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data from an AFT model
datgen &lt;- function(n = 100) {
    x1 &lt;- rbinom(n, 1, 0.5)
    x2 &lt;- rnorm(n)
    e &lt;- rnorm(n)
    tt &lt;- exp(2 + x1 + x2 + e)
    cen &lt;- runif(n, 0, 100)
    data.frame(Time = pmin(tt, cen), status = 1 * (tt &lt; cen),
               x1 = x1, x2 = x2, id = 1:n)
}
set.seed(1); dat &lt;- datgen(n = 50)
summary(aftsrr(Surv(Time, status) ~ x1 + x2, data = dat, se = c("ISMB", "ZLMB"), B = 10))

## Data set with sampling weights
data(nwtco, package = "survival")
subinx &lt;- sample(1:nrow(nwtco), 668, replace = FALSE)
nwtco$subcohort &lt;- 0
nwtco$subcohort[subinx] &lt;- 1
pn &lt;- mean(nwtco$subcohort)
nwtco$hi &lt;- nwtco$rel + ( 1 - nwtco$rel) * nwtco$subcohort / pn
nwtco$age12 &lt;- nwtco$age / 12
nwtco$study &lt;- factor(nwtco$study)
nwtco$histol &lt;- factor(nwtco$histol)
sub &lt;- nwtco[subinx,]
fit &lt;- aftsrr(Surv(edrel, rel) ~ histol + age12 + study, id = seqno,
              weights = hi, data = sub, B = 10, se = c("ISMB", "ZLMB"),
              subset = stage == 4)
summary(fit)
confint(fit)
</code></pre>

<hr>
<h2 id='export_is.Surv'><code>is.Surv</code> function imported from <code>survival</code></h2><span id='topic+export_is.Surv'></span><span id='topic+is.Surv'></span>

<h3>Description</h3>

<p>This function is imported from the <code>survival</code> package. See
<code><a href="survival.html#topic+is.Surv">is.Surv</a></code>.
</p>

<hr>
<h2 id='export_Surv'><code>Surv</code> function imported from <code>survival</code></h2><span id='topic+export_Surv'></span><span id='topic+Surv'></span>

<h3>Description</h3>

<p>This function is imported from the <code>survival</code> package. See
<code><a href="survival.html#topic+Surv">Surv</a></code>.
</p>

<hr>
<h2 id='QIC'>Quasi Information Criterion</h2><span id='topic+QIC'></span>

<h3>Description</h3>

<p>Implementation based on MES::QIC.geeglm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QIC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QIC_+3A_object">object</code></td>
<td>
<p>is a <code>aftgee</code> fit</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data from an AFT model with possible depended response
datgen &lt;- function(n = 100, tau = 0.3, dim = 2) {
    x1 &lt;- rbinom(dim * n, 1, 0.5)
    x2 &lt;- rnorm(dim * n)
    e &lt;- c(t(exp(MASS::mvrnorm(n = n, mu = rep(0, dim), Sigma = tau + (1 - tau) * diag(dim)))))
    tt &lt;- exp(2 + x1 + x2 + e)
    cen &lt;- runif(n, 0, 100)
    data.frame(Time = pmin(tt, cen), status = 1 * (tt &lt; cen),
               x1 = x1, x2 = x2, id = rep(1:n, each = dim))
}
set.seed(1); dat &lt;- datgen(n = 50, dim = 2)
fm &lt;- Surv(Time, status) ~ x1 + x2
fit1 &lt;- aftgee(fm, data = dat, id = id, corstr = "ind")
fit2 &lt;- aftgee(fm, data = dat, id = id, corstr = "ex")

QIC(fit1)
QIC(fit2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
