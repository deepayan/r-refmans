<!DOCTYPE html><html><head><title>Help for package IPEC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IPEC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IPEC-package'>
<p>Root Mean Square Curvature Calculation</p></a></li>
<li><a href='#aic'>
<p>Akaike Information Criterion (AIC) Calculation Function</p></a></li>
<li><a href='#biasIPEC'>
<p>Bias Calculation Function</p></a></li>
<li><a href='#bic'>
<p>Bayesian Information Criterion (BIC) Calculation Function</p></a></li>
<li><a href='#bootIPEC'><p>Bootstrap Function for Nonlinear Regression</p></a></li>
<li><a href='#confcurves'>
<p>Wald Confidence Curves and the Likelihood Confidence Curves</p></a></li>
<li><a href='#crops'>
<p>Whole-plant biomass Data of 12 Species of Crops</p></a></li>
<li><a href='#curvIPEC'>
<p>RMS Curvature Calculation Function</p></a></li>
<li><a href='#derivIPEC'>
<p>Derivative Calculation Function</p></a></li>
<li><a href='#fitIPEC'>
<p>Nonlinear Fitting Function</p></a></li>
<li><a href='#isom'>
<p>Data on Biochemical Oxygen Demand</p></a></li>
<li><a href='#leaves'>
<p>Leaf Data of <em>Parrotia subaequalis</em> (Hamamelidaceae)</p></a></li>
<li><a href='#parinfo'>
<p>Detailed Information of Estimated Model Parameters</p></a></li>
<li><a href='#shoots'>
<p>Height Growth Data of Bamboo Shoots</p></a></li>
<li><a href='#skewIPEC'>
<p>Skewness Calculation Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Root Mean Square Curvature Calculation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Peijian Shi [aut, cre],
  Peter M. Ridland [aut],
  David A. Ratkowsky [aut],
  Yang Li [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peijian Shi &lt;pjshi@njfu.edu.cn&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>numDeriv (&ge; 2016.8-1.1), MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates the RMS intrinsic and parameter-effects curvatures of a nonlinear regression model. The curvatures are global measures of assessing whether a model/data set combination is close-to-linear or not. See Bates and Watts (1980) &lt;<a href="https://doi.org/10.1002%2F9780470316757">doi:10.1002/9780470316757</a>&gt; and Ratkowsky and Reddy (2017) &lt;<a href="https://doi.org/10.1093%2Faesa%2Fsaw098">doi:10.1093/aesa/saw098</a>&gt; for details.  </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-13 16:32:45 UTC; PEIJIAN SHI</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='IPEC-package'>
Root Mean Square Curvature Calculation
</h2><span id='topic+IPEC-package'></span><span id='topic+IPEC'></span>

<h3>Description</h3>

<p>Calculates the RMS intrinsic and parameter-effects curvatures of a nonlinear regression model. 
The curvatures are global measures of assessing whether a model/data set combination 
is close-to-linear or not. See Bates and Watts (1980) and Ratkowsky and Reddy (2017) for details. 
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> IPEC</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Root Mean Square Curvature Calculation</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-13</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person(given="Peijian", family="Shi", email="pjshi@njfu.edu.cn", role=c("aut", "cre")),
        person(given=c("Peter M."), family="Ridland", email="p.ridland@unimelb.edu.au", role=c("aut")),
        person(given=c("David A."), family="Ratkowsky", email="d.ratkowsky@utas.edu.au", role=c("aut")),
        person(given=c("Yang"), family="Li", email="yangli@fau.edu", role=c("aut")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Peijian Shi [aut, cre], Peter M. Ridland [aut], David A. Ratkowsky [aut], Yang Li [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Peijian Shi &lt;pjshi@njfu.edu.cn&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> numDeriv (&gt;= 2016.8-1.1), MASS</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Calculates the RMS intrinsic and parameter-effects curvatures of a nonlinear regression model. The curvatures are global measures of assessing whether a model/data set combination is close-to-linear or not. See Bates and Watts (1980) &lt;doi:10.1002/9780470316757&gt; and Ratkowsky and Reddy (2017) &lt;doi:10.1093/aesa/saw098&gt; for details.  </td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 4.2.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
IPEC-package            Root Mean Square Curvature Calculation
aic                     Akaike Information Criterion (AIC) Calculation
                        Function
biasIPEC                Bias Calculation Function
bic                     Bayesian Information Criterion (BIC)
                        Calculation Function
bootIPEC                Bootstrap Function for Nonlinear Regression
confcurves              Wald Confidence Curves and the Likelihood
                        Confidence Curves
crops                   Whole-plant biomass Data of 12 Species of Crops
curvIPEC                RMS Curvature Calculation Function
derivIPEC               Derivative Calculation Function
fitIPEC                 Nonlinear Fitting Function
isom                    Data on Biochemical Oxygen Demand
leaves                  Leaf Data of _Parrotia subaequalis_
                        (Hamamelidaceae)
parinfo                 Detailed Information of Estimated Model
                        Parameters
shoots                  Height Growth Data of Bamboo Shoots
skewIPEC                Skewness Calculation Function
</pre>


<h3>Note</h3>

<p>We are deeply thankful to Paul Gilbert and Jinlong Zhang for their invaluable help 
during creating this package. We also thank Linli Deng, Kurt Hornik and Lin Wang for 
their statistical and technical guidance in updating the package.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi [aut, cre], Peter Ridland [aut], David A. Ratkowsky [aut], Yang Li [aut]
</p>
<p>Maintainer: Peijian Shi &lt;pjshi@njfu.edu.cn&gt;
</p>


<h3>References</h3>

<p>Bates, D.M and Watts, D.G. (1988) <em>Nonlinear Regression Analysis and its Applications</em>. Wiley, New York. <a href="https://doi.org/10.1002/9780470316757">doi:10.1002/9780470316757</a>
</p>
<p>Ratkowsky, D.A. (1983) <em>Nonlinear Regression Modeling: A Unified Practical Approach</em>. Marcel Dekker, New York.
</p>
<p>Ratkowsky, D.A. (1990) <em>Handbook of Nonlinear Regression Models</em>, Marcel Dekker, New York.
</p>
<p>Ratkowsky, D.A. &amp; Reddy, G.V.P. (2017) Empirical model with excellent statistical properties for describing temperature-dependent 
developmental rates of insects and mites. <em>Ann. Entomol. Soc. Am.</em> 110, 302<code class="reqn">-</code>309. <a href="https://doi.org/10.1093/aesa/saw098">doi:10.1093/aesa/saw098</a>
</p>


<h3>See Also</h3>

 <p><code><a href="numDeriv.html#topic+hessian">hessian</a></code> in package <span class="pkg">numDeriv</span>, <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> 
in package <span class="pkg">numDeriv</span>, <code><a href="MASS.html#topic+rms.curv">rms.curv</a></code> in package <span class="pkg">MASS</span></p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example 1 ##################################################################################
graphics.off()
# The velocity of the reaction (counts/min^2) under different substrate concentrations 
#   in parts per million (ppm) (Page 269 of Bates and Watts 1988)

x1 &lt;- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56, 1.10, 1.10)
y1 &lt;- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)

# Define the Michaelis-Menten model
MM &lt;- function(theta, x){
    theta[1]*x / ( theta[2] + x )    
}

res0 &lt;- fitIPEC( MM, x=x1, y=y1, ini.val=c(200, 0.05), 
                 xlim=c( 0, 1.5 ), ylim=c(0, 250), fig.opt=TRUE )
par1 &lt;- res0$par
par1

res1 &lt;- derivIPEC( MM, theta=par1, z=x1[1], method="Richardson",
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) )
res1

# To calculate curvatures
res2 &lt;- curvIPEC( MM, theta=par1, x=x1, y=y1, alpha=0.05, method="Richardson",
                  method.args=list(eps=1e-4, d=0.11, 
                  zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
res2

# To calculate bias
res3 &lt;- biasIPEC(MM, theta=par1, x=x1, y=y1, tol= 1e-20)
res3


  set.seed(123)  
  res4 &lt;- bootIPEC( MM, x=x1, y=y1, ini.val=par1,  
                    control=list(reltol=1e-20, maxit=40000), 
                    nboot=2000, CI=0.95, fig.opt=TRUE )
  res4
  set.seed(NULL)


# To calculate skewness
res5 &lt;- skewIPEC(MM, theta=par1, x=x1, y=y1, tol= 1e-20)
res5
#################################################################################################


#### Example 2 ##################################################################################
graphics.off()
# Development data of female pupae of cotton bollworm (Wu et al. 2009)
# References:
#   Ratkowsky, D.A. and Reddy, G.V.P. (2017) Empirical model with excellent statistical 
#       properties for describing temperature-dependent developmental rates of insects  
#       and mites. Ann. Entomol. Soc. Am. 110, 302-309.
#   Wu, K., Gong, P. and Ruan, Y. (2009) Estimating developmental rates of 
#       Helicoverpa armigera (Lepidoptera: Noctuidae) pupae at constant and
#       alternating temperature by nonlinear models. Acta Entomol. Sin. 52, 640-650.

# 'x2' is the vector of temperature (in degrees Celsius)
# 'D2' is the vector of developmental duration (in d)
# 'y2' is the vector of the square root of developmental rate (in 1/d)

x2 &lt;- seq(15, 37, by=1)
D2 &lt;- c(41.24,37.16,32.47,26.22,22.71,19.01,16.79,15.63,14.27,12.48,
       11.3,10.56,9.69,9.14,8.24,8.02,7.43,7.27,7.35,7.49,7.63,7.9,10.03)
y2 &lt;- 1/D2
y2 &lt;- sqrt( y2 )

ini.val1 &lt;- c(0.14, 30, 10, 40)

# Define the square root function of the Lobry-Rosso-Flandrois (LRF) model
sqrt.LRF &lt;- function(P, x){
  ropt &lt;- P[1]
  Topt &lt;- P[2]
  Tmin &lt;- P[3]
  Tmax &lt;- P[4]
  fun0 &lt;- function(z){
    z[z &lt; Tmin] &lt;- Tmin
    z[z &gt; Tmax] &lt;- Tmax
    return(z)
  }
  x &lt;- fun0(x)
  if (Tmin &gt;= Tmax | ropt &lt;= 0 | Topt &lt;= Tmin | Topt &gt;= Tmax) 
    temp &lt;- Inf
  if (Tmax &gt; Tmin &amp; ropt &gt; 0 &amp; Topt &gt; Tmin &amp; Topt &lt; Tmax){
    temp &lt;- sqrt( ropt*(x-Tmax)*(x-Tmin)^2/((Topt-Tmin)*((Topt-Tmin
      )*(x-Topt)-(Topt-Tmax)*(Topt+Tmin-2*x))) )  
  }
  return( temp )
}

myfun &lt;- sqrt.LRF
xlab1 &lt;- expression( paste("Temperature (", degree, "C)", sep="" ) )
ylab1 &lt;- expression( paste("Developmental rate"^{1/2}, " (", d^{"-1"}, ")", sep="") )
resu0 &lt;- fitIPEC( myfun, x=x2, y=y2, ini.val=ini.val1, xlim=NULL, ylim=NULL, 
                  xlab=xlab1, ylab=ylab1, fig.opt=TRUE, 
                  control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
par2  &lt;- resu0$par
par2

resu1 &lt;- derivIPEC( myfun, theta=par2, z=x2[1], method="Richardson", 
                    method.args=list(eps=1e-4, d=0.11, 
                    zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) )
resu1

# To calculate curvatures
resu2 &lt;- curvIPEC( myfun, theta=par2, x=x2, y=y2, alpha=0.05, method="Richardson", 
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
resu2

# To calculate bias
resu3 &lt;- biasIPEC(myfun, theta=par2, x=x2, y=y2, tol= 1e-20)
resu3


  set.seed(123)
  resu4 &lt;- bootIPEC( myfun, x=x2, y=y2, ini.val=ini.val1,  
                     nboot=2000, CI=0.95, fig.opt=TRUE )
  resu4
  set.seed(NULL)


# To calculate skewness
resu5 &lt;- skewIPEC(myfun, theta=par2, x=x2, y=y2, tol= 1e-20)
resu5
#################################################################################################


#### Example 3 ##################################################################################
graphics.off()
# Height growth data of four species of bamboo (Gramineae: Bambusoideae)
# Reference(s):
# Shi, P., Fan, M., Ratkowsky, D.A., Huang, J., Wu, H., Chen, L., Fang, S. and 
#     Zhang, C. (2017) Comparison of two ontogenetic growth equations for animals and plants. 
#     Ecol. Model. 349, 1-10.

data(shoots)
# Choose a species
# 1: Phyllostachys iridescens; 2: Phyllostachys mannii; 
# 3: Pleioblastus maculatus; 4: Sinobambusa tootsik.
# 'x3' is the vector of the investigation times from a specific starting time of growth
# 'y3' is the vector of the aboveground height values of bamboo shoots at 'x3' 

ind &lt;- 4
x3  &lt;- shoots$x[shoots$Code == ind]
y3  &lt;- shoots$y[shoots$Code == ind] 

# Define the beta sigmoid model (bsm)
bsm &lt;- function(P, x){
  P  &lt;- cbind(P)
  if(length(P) !=4 ) {stop("The number of parameters should be 4!")}
  ropt &lt;- P[1]
  topt &lt;- P[2]
  tmin &lt;- P[3]
  tmax &lt;- P[4]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   

  ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-2*tmax)*(
    (x-tmin)/(topt-tmin) )^((topt-tmin)/(tmax-topt)) 
}

# Define the simplified beta sigmoid model (simp.bsm)
simp.bsm &lt;- function(P, x, tmin=0){
  P  &lt;- cbind(P)  
  ropt  &lt;- P[1]
  topt  &lt;- P[2]
  tmax  &lt;- P[3]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   
  ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-2*tmax)*
       ((x-tmin)/(topt-tmin))^((topt-tmin)/(tmax-topt))   
}

# For the original beta sigmoid model
ini.val2 &lt;- c(40, 30, 5, 50)
xlab2    &lt;- "Time (d)"
ylab2    &lt;- "Height (cm)"

re0 &lt;- fitIPEC( bsm, x=x3, y=y3, ini.val=ini.val2, xlim=NULL, ylim=NULL, 
                xlab=xlab2, ylab=ylab2, fig.opt=TRUE, 
                control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
par3 &lt;- re0$par
par3

re1 &lt;- derivIPEC( bsm, theta=par3, x3[15], method="Richardson", 
                  method.args=list(eps=1e-4, d=0.11, zero.tol=
                  sqrt(.Machine$double.eps/7e-7), r=6, v=2) )
re1

re2 &lt;- curvIPEC( bsm, theta=par3, x=x3, y=y3, alpha=0.05, method="Richardson", 
                 method.args=list(eps=1e-4, d=0.11, zero.tol=
                 sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
re2

re3 &lt;- biasIPEC( bsm, theta=par3, x=x3, y=y3, tol= 1e-20 )
re3


  re4 &lt;- bootIPEC( bsm, x=x3, y=y3, ini.val=ini.val2,  
                   control=list(trace=FALSE, reltol=1e-20, maxit=50000),
                   nboot=2000, CI=0.95, fig.opt=TRUE, fold=3.5 )
  re4


re5 &lt;- skewIPEC( bsm, theta=par3, x=x3, y=y3, tol= 1e-20 )
re5

# For the simplified beta sigmoid model 
#  (in comparison with the original beta sigmoid model)
ini.val7 &lt;- c(40, 30, 50)

RESU0 &lt;- fitIPEC( simp.bsm, x=x3, y=y3, ini.val=ini.val7, 
                  xlim=NULL, ylim=NULL, xlab=xlab2, ylab=ylab2, 
                  fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
par7  &lt;- RESU0$par
par7

RESU1 &lt;- derivIPEC( simp.bsm, theta=par7, x3[15], method="Richardson", 
                    method.args=list(eps=1e-4, d=0.11, 
                    zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) )
RESU1

RESU2 &lt;- curvIPEC( simp.bsm, theta=par7, x=x3, y=y3, alpha=0.05, method="Richardson", 
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
RESU2

RESU3 &lt;- biasIPEC( simp.bsm, theta=par7, x=x3, y=y3, tol= 1e-20 )
RESU3


  set.seed(123)
  RESU4 &lt;- bootIPEC( simp.bsm, x=x3, y=y3, ini.val=ini.val7,  
                     control=list(trace=FALSE, reltol=1e-20, maxit=50000),
                     nboot=2000, CI=0.95, fig.opt=TRUE, fold=3.5 )
  RESU4
  set.seed(NULL)


RESU5 &lt;- skewIPEC( simp.bsm, theta=par7, x=x3, y=y3, tol= 1e-20 )
RESU5
##################################################################################################


#### Example 4 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References:
# Pages 56, 255 and 271 in Bates and Watts (1988)
# Carr, N.L. (1960) Kinetics of catalytic isomerization of n-pentane. Ind. Eng. Chem.
#     52, 391-396.   

graphics.off()
data(isom)
Y &lt;- isom[,1]
X &lt;- isom[,2:4]

# There are three independent variables saved in matrix 'X' and one response variable (Y)
# The first column of 'X' is the vector of partial pressure of hydrogen
# The second column of 'X' is the vector of partial pressure of n-pentane
# The third column of 'X' is the vector of partial pressure of isopentane
# Y is the vector of experimental reaction rate (in 1/hr)

isom.fun &lt;- function(theta, x){
  x1     &lt;- x[,1]
  x2     &lt;- x[,2]
  x3     &lt;- x[,3]
  theta1 &lt;- theta[1]
  theta2 &lt;- theta[2]
  theta3 &lt;- theta[3]
  theta4 &lt;- theta[4]
  theta1*theta3*(x2-x3/1.632) / ( 1 + theta2*x1 + theta3*x2 + theta4*x3 )
}

ini.val8 &lt;- c(35, 0.1, 0.05, 0.2)
cons1    &lt;- fitIPEC( isom.fun, x=X, y=Y, ini.val=ini.val8, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
par8     &lt;- cons1$par 
cons2    &lt;- curvIPEC( isom.fun, theta=par8, x=X, y=Y, alpha=0.05, method="Richardson", 
                      method.args=list(eps=1e-4, d=0.11, 
                      zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2)) 
cons2
cons3    &lt;- biasIPEC( isom.fun, theta=par8, x=X, y=Y, tol= 1e-20 )
cons3


  set.seed(123)
  cons4 &lt;- bootIPEC( isom.fun, x=X, y=Y, ini.val=ini.val8,  
                     control=list(trace=FALSE, reltol=1e-20, maxit=50000),
                     nboot=2000, CI=0.95, fig.opt=TRUE, fold=10000 )
  cons4
  set.seed(NULL)


cons5    &lt;- skewIPEC( isom.fun, theta=par8, x=X, y=Y, tol= 1e-20 )
cons5
##################################################################################################
</code></pre>

<hr>
<h2 id='aic'>
Akaike Information Criterion (AIC) Calculation Function
</h2><span id='topic+aic'></span>

<h3>Description</h3>

<p>Calculates the AIC value(s) of the object(s) obtained from 
using the <code><a href="#topic+fitIPEC">fitIPEC</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic( object, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic_+3A_object">object</code></td>
<td>
<p>A fitted model object for which there exists the sample size (<code>sample.size</code> or <code>n</code>), 
estimate(s) of model parameter(s) (<code>par</code>), and residual sum of squares (<code>RSS</code>)</p>
</td></tr>
<tr><td><code id="aic_+3A_...">...</code></td>
<td>
<p>Optionally more fitted model objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AIC = 2 <em>p</em> - 2 ln(<em>L</em>), where <em>p</em> represents 
the number of model parameter(s) plus 1 for the error, 
and ln(<em>L</em>) represents the maximum log-likelihood of the estimated model (Spiess and Neumeyer, 2010).
</p>


<h3>Value</h3>

<p>There is an AIC value corresponding to one object, 
and there is a vector of AIC values corresponding to the multiple objects.
</p>


<h3>Note</h3>

<p>When there are <code>sample.size</code> and <code>n</code> in <code>object</code> at the same time, the default of 
the sample size is <code>sample.size</code>, which is superior to <code>n</code>. 
With the sample size increasing, the number of model parameter(s) has a weaker 
influence on the value of AIC assuming that ln(<code>RSS/n</code>) is a constant.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Spiess, A-N and Neumeyer, N. (2010) An evaluation of R squared as an inadequate measure 
for nonlinear models in pharmacological and biochemical research: a Monte Carlo approach. 
<em>BMC Pharmacol.</em> 10, 6. <a href="https://doi.org/10.1186/1471-2210-10-6">doi:10.1186/1471-2210-10-6</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bic">bic</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code> in package <span class="pkg">stats</span>, and <code><a href="stats.html#topic+BIC">BIC</a></code> in package <span class="pkg">stats</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example #####################################################################################
data(leaves)
attach(leaves)
# Choose a geographical population (see Table S1 in Wang et al. [2018] for details)
# Wang, P., Ratkowsky, D.A., Xiao, X., Yu, X., Su, J., Zhang, L. and Shi, P. 
#   (2018) Taylor's power law for leaf bilateral symmetry. Forests 9, 500. doi: 10.3390/f9080500 
# 1: AJ; 2: HN; 3: HW; 4: HZ; 5: JD; 
# 6: JS; 7: SC; 8: TC; 9: TT; 10: TX
ind &lt;- 1
L   &lt;- Length[PopuCode == ind]
W   &lt;- Width[PopuCode == ind] 
A   &lt;- Area[PopuCode == ind]

# Define a model y = a*(x1*x2), where a is a parameter to be estimated
propor &lt;- function(theta, x){
    a  &lt;- theta[1]
    x1 &lt;- x[,1]
    x2 &lt;- x[,2]
    a*x1*x2
}

# Define a model y = a*(x1^b)*(x2^c), where a, b and c are parameters to be estimated    
threepar &lt;- function(theta, x){
    a  &lt;- theta[1]
    b  &lt;- theta[2]
    c  &lt;- theta[3]
    x1 &lt;- x[,1]
    x2 &lt;- x[,2]
    a*x1^b*x2^c
}

# Define a model y = a*x^b, where a and b are parameters to be estimated    
twopar &lt;- function(theta, x){
    a  &lt;- theta[1]
    b  &lt;- theta[2]
    a*x^b
}


  A1 &lt;- fitIPEC(propor, x=cbind(L, W), y=A, fig.opt=FALSE,
            ini.val=list(seq(0.1, 1.5, by=0.1)))
  B1 &lt;- curvIPEC(propor, theta=A1$par, x=cbind(L, W), y=A)    
  A2 &lt;- fitIPEC(threepar, x=cbind(L, W), y=A, fig.opt=FALSE,
            ini.val=list(A1$par, seq(0.5, 1.5, by=0.1), seq(0.5, 1.5, by=0.1)))    
  B2 &lt;- curvIPEC(threepar, theta=A2$par, x=cbind(L, W), y=A)
  A3 &lt;- fitIPEC(twopar, x=L, y=A, fig.opt=FALSE,
                ini.val=list(1, seq(0.5, 1.5, by=0.05)))    
  B3 &lt;- curvIPEC(twopar, theta=A3$par, x=L, y=A)
  A4 &lt;- fitIPEC(twopar, x=W, y=A, fig.opt=FALSE,
                ini.val=list(1, seq(0.5, 1.5, by=0.05)))    
  B4 &lt;- curvIPEC(twopar, theta=A4$par, x=W, y=A)
  aic(A1, A2, A3, A4)
  bic(A1, A2, A3, A4)

##################################################################################################
</code></pre>

<hr>
<h2 id='biasIPEC'>
Bias Calculation Function
</h2><span id='topic+biasIPEC'></span>

<h3>Description</h3>

<p>Calculates the bias in the estimates of the parameters of a given nonlinear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biasIPEC(expr, theta, x, y, tol = 1e-16, method = "Richardson", 
         method.args = list(eps = 1e-04, d = 0.11, 
         zero.tol = sqrt(.Machine$double.eps/7e-07), r = 6, v = 2, 
         show.details = FALSE), side = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biasIPEC_+3A_expr">expr</code></td>
<td>
<p>A given nonlinear regression model</p>
</td></tr>
<tr><td><code id="biasIPEC_+3A_theta">theta</code></td>
<td>
<p>A vector of parameters of the model</p>
</td></tr>
<tr><td><code id="biasIPEC_+3A_x">x</code></td>
<td>
<p>A vector or matrix of observations of independent variable(s)</p>
</td></tr>
<tr><td><code id="biasIPEC_+3A_y">y</code></td>
<td>
<p>A vector of observations of response variable</p>
</td></tr>
<tr><td><code id="biasIPEC_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of a matrix for calculating its inverse. 
See the input argument of <code>tol</code> of the <code><a href="Matrix.html#topic+solve">solve</a></code> function in package <span class="pkg">base</span> </p>
</td></tr>
<tr><td><code id="biasIPEC_+3A_method">method</code></td>
<td>
<p>It is the same as the input argument of <code>method</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="biasIPEC_+3A_method.args">method.args</code></td>
<td>
<p>It is the same as the input argument of <code>method.args</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="biasIPEC_+3A_side">side</code></td>
<td>
<p>It is the same as the input argument of <code>side</code> of the <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The defined model should have two input arguments: a parameter vector and an independent variable vector or matrix, 
e.g. <code>myfun &lt;- function(P, x){...}</code>, where <code>P</code> represents the parameter vector and <code>x</code> represents the independent variable vector or matrix. 
</p>
<p>An absolute value of <code>percent.bias</code> (see below) in excess of <strong>1%</strong> appears to be a good rule of thumb for indicating nonlinear behavior (Ratkowsky 1983).
</p>


<h3>Value</h3>

<table>
<tr><td><code>bias</code></td>
<td>
<p>The bias</p>
</td></tr>
<tr><td><code>percent.bias</code></td>
<td>
<p>The percentage bias that is equal to <code>bias/estimate * 100%</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The current function can be applicable to nonlinear models with multiple independent variables.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Box, M.J. (1971) Bias in nonlinear estimation. <em>J. R. Statist. Soc., Ser. B</em> 33, 171<code class="reqn">-</code>201. 
<a href="https://doi.org/10.1111/j.2517-6161.1971.tb00871.x">doi:10.1111/j.2517-6161.1971.tb00871.x</a>
</p>
<p>Ratkowsky, D.A. (1983) <em>Nonlinear Regression Modeling: A Unified Practical Approach</em>. Marcel Dekker, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivIPEC">derivIPEC</a></code>, <code><a href="numDeriv.html#topic+hessian">hessian</a></code> 
in package <span class="pkg">numDeriv</span>, <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> in package <span class="pkg">numDeriv</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example 1 #################################################################################
# The velocity of the reaction (counts/min^2) under different substrate concentrations 
#   in parts per million (ppm) (Page 269 of Bates and Watts 1988)
x1 &lt;- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56, 1.10, 1.10)
y1 &lt;- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)

# Define the Michaelis-Menten (MM) model
MM &lt;- function(theta, x){
    theta[1]*x / ( theta[2] + x )    
}

par1 &lt;- c(212.68490865, 0.06412421)
res3 &lt;- biasIPEC(MM, theta=par1, x=x1, y=y1, tol= 1e-20)
res3
#################################################################################################


#### Example 2 ##################################################################################
# Development data of female pupae of cotton bollworm (Wu et al. 2009)
# References:
#   Ratkowsky, D.A. and Reddy, G.V.P. (2017) Empirical model with excellent statistical 
#       properties for describing temperature-dependent developmental rates of insects  
#       and mites. Ann. Entomol. Soc. Am. 110, 302-309.
#   Wu, K., Gong, P. and Ruan, Y. (2009) Estimating developmental rates of 
#       Helicoverpa armigera (Lepidoptera: Noctuidae) pupae at constant and
#       alternating temperature by nonlinear models. Acta Entomol. Sin. 52, 640-650.

# 'x2' is the vector of temperature (in degrees Celsius)
# 'D2' is the vector of developmental duration (in d)
# 'y2' is the vector of the square root of developmental rate (in 1/d)

x2 &lt;- seq(15, 37, by=1)
D2 &lt;- c(41.24,37.16,32.47,26.22,22.71,19.01,16.79,15.63,14.27,12.48,
       11.3,10.56,9.69,9.14,8.24,8.02,7.43,7.27,7.35,7.49,7.63,7.9,10.03)
y2 &lt;- 1/D2
y2 &lt;- sqrt( y2 )

# Define the square root function of the Lobry-Rosso-Flandrois (LRF) model
sqrt.LRF &lt;- function(P, x){
  ropt &lt;- P[1]
  Topt &lt;- P[2]
  Tmin &lt;- P[3]
  Tmax &lt;- P[4]
  fun0 &lt;- function(z){
    z[z &lt; Tmin] &lt;- Tmin
    z[z &gt; Tmax] &lt;- Tmax
    return(z)
  }
  x &lt;- fun0(x)
  if (Tmin &gt;= Tmax | ropt &lt;= 0 | Topt &lt;= Tmin | Topt &gt;= Tmax) 
    temp &lt;- Inf
  if (Tmax &gt; Tmin &amp; ropt &gt; 0 &amp; Topt &gt; Tmin &amp; Topt &lt; Tmax){
    temp &lt;- sqrt( ropt*(x-Tmax)*(x-Tmin)^2/((Topt-Tmin)*((Topt-Tmin
      )*(x-Topt)-(Topt-Tmax)*(Topt+Tmin-2*x))) )  
  }
  return( temp )
}

myfun &lt;- sqrt.LRF
par2  &lt;- c(0.1382926, 33.4575663, 5.5841244, 38.8282021)

# To calculate bias
resu3 &lt;- biasIPEC(myfun, theta=par2, x=x2, y=y2, tol= 1e-20)
resu3
#################################################################################################


#### Example 3 ##################################################################################
# Weight of cut grass data (Pattinson 1981)
# References:
#   Clarke, G.P.Y. (1987) Approximate confidence limits for a parameter function in nonlinear 
#       regression. J. Am. Stat. Assoc. 82, 221-230.
#   Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? 
#       New diagnostic and inference tools in the NLIN Procedure. Paper SAS384-2014.
#       http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf
#   Pattinson, N.B. (1981) Dry Matter Intake: An Estimate of the Animal
#       Response to Herbage on Offer. unpublished M.Sc. thesis, University
#       of Natal, Pietermaritzburg, South Africa, Department of Grassland Science.

# 'x4' is the vector of weeks after commencement of grazing in a pasture
# 'y4' is the vector of weight of cut grass from 10 randomly sited quadrants

x4 &lt;- 1:13
y4 &lt;- c(3.183, 3.059, 2.871, 2.622, 2.541, 2.184, 2.110, 2.075, 2.018, 1.903, 1.770, 1.762, 1.550)

# Define the first case of Mitscherlich equation
MitA &lt;- function(P1, x){
    P1[3] + P1[2]*exp(P1[1]*x)
}

# Define the second case of Mitscherlich equation
MitB &lt;- function(P2, x){
    log( P2[3] ) + exp(P2[2] + P2[1]*x)
}

# Define the third case of Mitscherlich equation
MitC &lt;- function(P3, x, x1=1, x2=13){
    theta1 &lt;- P3[1]
    beta2  &lt;- P3[2]
    beta3  &lt;- P3[3]
    theta2 &lt;- (beta3 - beta2)/(exp(theta1*x2)-exp(theta1*x1))
    theta3 &lt;- beta2/(1-exp(theta1*(x1-x2))) - beta3/(exp(theta1*(x2-x1))-1)
    theta3 + theta2*exp(theta1*x)
}

ini.val3 &lt;- c(-0.1, 2.5, 1)
r0       &lt;- fitIPEC( MitA, x=x4, y=y4, ini.val=ini.val3, xlim=NULL, ylim=NULL,
                     fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
parA     &lt;- r0$par
parA
r3       &lt;- biasIPEC( MitA, theta=parA, x=x4, y=y4, tol=1e-20 ) 
r3

ini.val4 &lt;- c(exp(-0.1), log(2.5), 1)
R0       &lt;- fitIPEC( MitB, x=x4, y=y4, ini.val=ini.val3, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
parB     &lt;- R0$par
parB
R3       &lt;- biasIPEC( MitB, theta=parB, x=x4, y=y4, tol=1e-20 ) 
R3

ini.val6 &lt;- c(-0.15, 2.52, 1.09)
RES0     &lt;- fitIPEC( MitC, x=x4, y=y4, ini.val=ini.val6, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
parC     &lt;- RES0$par
parC
RES3     &lt;- biasIPEC(MitC, theta=parC, x=x4, y=y4, tol=1e-20) 
RES3
#################################################################################################


#### Example 4 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References
# Pages 56, 255 and 271 in Bates and Watts (1988)
# Carr, N.L. (1960) Kinetics of catalytic isomerization of n-pentane. Ind. Eng. Chem.
#     52, 391-396.   

data(isom)
Y &lt;- isom[,1]
X &lt;- isom[,2:4]

# There are three independent variables saved in matrix 'X' and one response variable (Y)
# The first column of 'X' is the vector of partial pressure of hydrogen
# The second column of 'X' is the vector of partial pressure of n-pentane
# The third column of 'X' is the vector of partial pressure of isopentane
# Y is the vector of experimental reaction rate (in 1/hr)

isom.fun &lt;- function(theta, x){
  x1     &lt;- x[,1]
  x2     &lt;- x[,2]
  x3     &lt;- x[,3]
  theta1 &lt;- theta[1]
  theta2 &lt;- theta[2]
  theta3 &lt;- theta[3]
  theta4 &lt;- theta[4]
  theta1*theta3*(x2-x3/1.632) / ( 1 + theta2*x1 + theta3*x2 + theta4*x3 )
}

par8  &lt;- c(35.92831619, 0.07084811, 0.03772270, 0.16718384) 
cons3 &lt;- biasIPEC( isom.fun, theta=par8, x=X, y=Y, tol= 1e-20 )
cons3
#################################################################################################
</code></pre>

<hr>
<h2 id='bic'>
Bayesian Information Criterion (BIC) Calculation Function
</h2><span id='topic+bic'></span>

<h3>Description</h3>

<p>Calculates the BIC value(s) of the object(s) obtained from 
using the <code><a href="#topic+fitIPEC">fitIPEC</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bic( object, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bic_+3A_object">object</code></td>
<td>
<p>A fitted model object for which there exists the sample size (<code>sample.size</code> or <code>n</code>), 
estimate(s) of model parameter(s) (<code>par</code>), and residual sum of squares (<code>RSS</code>)</p>
</td></tr>
<tr><td><code id="bic_+3A_...">...</code></td>
<td>
<p>Optionally more fitted model objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BIC = <em>p</em> ln(<em>n</em>) - 2 ln(<em>L</em>), where <em>p</em> represents 
the number of model parameter(s) plus 1 for the error, <em>n</em> represents the sample size, 
and ln(<em>L</em>) represents the maximum log-likelihood of the estimated model (Spiess and Neumeyer, 2010).
</p>


<h3>Value</h3>

<p>There is a BIC value corresponding to one object, 
and there is a vector of BIC values corresponding to the multiple objects.
</p>


<h3>Note</h3>

<p>When there are <code>sample.size</code> and <code>n</code> in <code>object</code> at the same time, the default of 
the sample size is <code>sample.size</code>, which is superior to <code>n</code>. 
The BIC gives a higher penalty on the number of model parameters than the AIC.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Spiess, A-N and Neumeyer, N. (2010) An evaluation of R squared as an inadequate measure 
for nonlinear models in pharmacological and biochemical research: a Monte Carlo approach. 
<em>BMC Pharmacol.</em> 10, 6. <a href="https://doi.org/10.1186/1471-2210-10-6">doi:10.1186/1471-2210-10-6</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aic">aic</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code> in package <span class="pkg">stats</span>, and <code><a href="stats.html#topic+BIC">BIC</a></code> in package <span class="pkg">stats</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example #####################################################################################
data(leaves)
attach(leaves)
# Choose a geographical population (see Table S1 in Wang et al. [2018] for details)
# Wang, P., Ratkowsky, D.A., Xiao, X., Yu, X., Su, J., Zhang, L. and Shi, P. 
#   (2018) Taylor's power law for leaf bilateral symmetry. Forests 9, 500. doi: 10.3390/f9080500
# 1: AJ; 2: HN; 3: HW; 4: HZ; 5: JD; 
# 6: JS; 7: SC; 8: TC; 9: TT; 10: TX
ind &lt;- 1
L   &lt;- Length[PopuCode == ind]
W   &lt;- Width[PopuCode == ind] 
A   &lt;- Area[PopuCode == ind]

# Define a model y = a*(x1*x2), where a is a parameter to be estimated
propor &lt;- function(theta, x){
    a  &lt;- theta[1]
    x1 &lt;- x[,1]
    x2 &lt;- x[,2]
    a*x1*x2
}

# Define a model y = a*(x1^b)*(x2^c), where a, b and c are parameters to be estimated    
threepar &lt;- function(theta, x){
    a  &lt;- theta[1]
    b  &lt;- theta[2]
    c  &lt;- theta[3]
    x1 &lt;- x[,1]
    x2 &lt;- x[,2]
    a*x1^b*x2^c
}

# Define a model y = a*x^b, where a and b are parameters to be estimated    
twopar &lt;- function(theta, x){
    a  &lt;- theta[1]
    b  &lt;- theta[2]
    a*x^b
}


  A1 &lt;- fitIPEC(propor, x=cbind(L, W), y=A, fig.opt=FALSE,
            ini.val=list(seq(0.1, 1.5, by=0.1)))
  B1 &lt;- curvIPEC(propor, theta=A1$par, x=cbind(L, W), y=A)    
  A2 &lt;- fitIPEC(threepar, x=cbind(L, W), y=A, fig.opt=FALSE,
            ini.val=list(A1$par, seq(0.5, 1.5, by=0.1), seq(0.5, 1.5, by=0.1)))    
  B2 &lt;- curvIPEC(threepar, theta=A2$par, x=cbind(L, W), y=A)
  A3 &lt;- fitIPEC(twopar, x=L, y=A, fig.opt=FALSE,
                ini.val=list(1, seq(0.5, 1.5, by=0.05)))    
  B3 &lt;- curvIPEC(twopar, theta=A3$par, x=L, y=A)
  A4 &lt;- fitIPEC(twopar, x=W, y=A, fig.opt=FALSE,
                ini.val=list(1, seq(0.5, 1.5, by=0.05)))    
  B4 &lt;- curvIPEC(twopar, theta=A4$par, x=W, y=A)
  aic(A1, A2, A3, A4)
  bic(A1, A2, A3, A4)

##################################################################################################
</code></pre>

<hr>
<h2 id='bootIPEC'>Bootstrap Function for Nonlinear Regression</h2><span id='topic+bootIPEC'></span>

<h3>Description</h3>

<p>Generates the density distributions, standard errors, confidence intervals, 
covariance matrices and correlation matrices of parameters 
based on bootstrap replications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootIPEC( expr, x, y, ini.val, weights = NULL, control = list(), 
          nboot = 200, CI = 0.95, fig.opt = TRUE, fold = 3.5, 
          unique.num = 2, prog.opt = TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootIPEC_+3A_expr">expr</code></td>
<td>
<p>A given parametric model</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_x">x</code></td>
<td>
<p>A vector or matrix of observations of independent variable(s)</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_y">y</code></td>
<td>
<p>A vector of observations of response variable</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_ini.val">ini.val</code></td>
<td>
<p>A vector or list of initial values of model parameters</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights to be used in the fitting process. 
<code>weights</code> should be NULL or a numeric vector. If non-NULL, weighted least squares is used with weights <code>weights</code>; 
otherwise ordinary least squares is used.</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_control">control</code></td>
<td>
<p>A list of control parameters for using the <code><a href="stats.html#topic+optim">optim</a></code> 
function in package <span class="pkg">stats</span></p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap replications</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_ci">CI</code></td>
<td>
<p>The confidence level(s) of the required interval(s)</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_fig.opt">fig.opt</code></td>
<td>
<p>An option of drawing figures of the distributions of bootstrap values of 
parameters and figures of pairwise comparisons of bootstrap values</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_fold">fold</code></td>
<td>
<p>A parameter removing the extreme bootstrap values of parameters</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_unique.num">unique.num</code></td>
<td>
<p>The least number of sampled non-overlapping data points 
for carrying out a bootstrap nonlinear regression</p>
</td></tr>
<tr><td><code id="bootIPEC_+3A_prog.opt">prog.opt</code></td>
<td>
<p>An option of showing the running progress of bootstrap</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ini.val</code> can be a vector or a list that has saved initial values for model parameters, 
</p>
<p>e.g. <code>y = beta0 + beta1 * x + beta2 * x^2</code>, 
</p>
<p><code>ini.val = list(beta0=seq(5, 15, len=2), beta1=seq(0.1, 1, len=9), 
beta2=seq(0.01, 0.05, len=5))</code>, which is similar to the usage of the 
input argument of <code>start</code> of <code><a href="stats.html#topic+nls">nls</a></code> in package <span class="pkg">stats</span>. 
</p>
<p>In the <code>weights</code> argument option, the default is <code>weights = NULL</code>. 
In that case, ordinary least squares is used. 
The residual sum of squares (RSS) between the observed and predicted <code class="reqn">y</code> values 
is minimized to estimate a model's parameters, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{RSS} = \sum_{i=1}^{n}\left(y_i-\hat{y}_i\right)^{2}</code>
</p>

<p>where <code class="reqn">y_i</code> and <code class="reqn">\hat{y}_i</code> represent the observed and predicted <code class="reqn">y</code> values, respectively; 
and <code class="reqn">n</code> represents the sample size. If <code>weights</code> is a numeric vector, 
the weighted residual sum of squares is minimized, i.e.,   
</p>
<p style="text-align: center;"><code class="reqn">\mbox{RSS} = \sum_{i=1}^{n}w_i\left(y_i-\hat{y}_i\right)^{2}</code>
</p>
 
<p>where <code class="reqn">w_i</code> is the <code class="reqn">i</code> elements of <code>weights</code>.
</p>
<p><code>CI</code> determines the width of confidence intervals. 
</p>
<p><code>fold</code> is used to delete the data whose differences from the median exceed 
a certain <code>fold</code> of the difference between 3/4 and 1/4 quantiles of the 
bootstrap values of a model parameter. 
</p>
<p>The default of <code>unique.num</code> is 2. That is, at least two non-overlapping data 
points randomly sampled from <code class="reqn">\left(x, y\right)</code> are needed for carrying out 
a bootstrap nonlinear regression.
</p>


<h3>Value</h3>

<table>
<tr><td><code>M</code></td>
<td>
<p>The matrix saving the fitted results of all <code>nboot</code> bootstrap 
values of model parameters and goodness of fit</p>
</td></tr>
<tr><td><code>perc.ci.mat</code></td>
<td>
<p>The matrix saving the estimate, standard error, median, mean, 
and the calculated lower and upper limits of confidence interval based on 
the bootstrap percentile method</p>
</td></tr>
<tr><td><code>bca.ci.mat</code></td>
<td>
<p>The matrix saving the estimate, standard error, median, mean, 
and the calculated lower and upper limits of confidence interval based on 
the bootstrap <code class="reqn">BC_a</code> method</p>
</td></tr>
<tr><td><code>covar.mat</code></td>
<td>
<p>The covariance matrix of parameters based on the bootstrap 
values when <code>nboot &gt; 1</code></p>
</td></tr>
<tr><td><code>cor.mat</code></td>
<td>
<p>The correlation matrix of parameters based on the bootstrap 
values when <code>nboot &gt; 1</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>To obtain reliable confidence intervals of model parameters, more than <strong>2000</strong> 
bootstrap replications are recommended; whereas to obtain a reliable standard error of the estimate 
of a parameter, more than <strong>30</strong> bootstrap replications are sufficient (Efron and Tibshirani 1993). 
<code>bca.ci.mat</code> is recommended to show better confidence intervals of parameters than 
those in <code>perc.ci.mat</code>. 
</p>
<p>The outputs of model parameters will all be represented by <code class="reqn">\theta_i</code>, <code class="reqn">i</code> from 1 
to <code class="reqn">p</code>, where <code class="reqn">p</code> represents the number of model parameters. The letters of model 
parameters defined by users such as <code class="reqn">\beta_i</code> will be automatically replaced by <code class="reqn">\theta_i</code>.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Efron, B. and Tibshirani, R.J. (1993) <em>An Introduction to the Bootstrap</em>. 
Chapman and Hall (CRC), New York. <a href="https://doi.org/10.2307/2532810">doi:10.2307/2532810</a>
</p>
<p>Sandhu, H.S., Shi, P., Kuang, X., Xue, F. and Ge, F. (2011) Applications of the bootstrap to 
insect physiology. <em>Fla. Entomol.</em> 94, 1036<code class="reqn">-</code>1041. <a href="https://doi.org/10.1653/024.094.0442">doi:10.1653/024.094.0442</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitIPEC">fitIPEC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example 1 #################################################################################
graphics.off()
# The velocity of the reaction (counts/min^2) under different substrate concentrations 
#   in parts per million (ppm) (Page 269 of Bates and Watts 1988)

x1 &lt;- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56, 1.10, 1.10)
y1 &lt;- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)

# Define the Michaelis-Menten (MM) model
MM &lt;- function(theta, x){
    theta[1]*x / ( theta[2] + x )    
}


  set.seed(123)
  res4 &lt;- bootIPEC( MM, x=x1, y=y1, ini.val=c(200, 0.05), 
                    control=list(reltol=1e-20, maxit=40000), nboot=2000, CI=0.95, 
                    fig.opt=TRUE )
  res4
  set.seed(NULL)

#################################################################################################


#### Example 2 ##################################################################################
graphics.off()
# Development data of female pupae of cotton bollworm (Wu et al. 2009)
# References:
#   Ratkowsky, D.A. and Reddy, G.V.P. (2017) Empirical model with excellent statistical 
#       properties for describing temperature-dependent developmental rates of insects  
#       and mites. Ann. Entomol. Soc. Am. 110, 302-309.
#   Wu, K., Gong, P. and Ruan, Y. (2009) Estimating developmental rates of 
#       Helicoverpa armigera (Lepidoptera: Noctuidae) pupae at constant and
#       alternating temperature by nonlinear models. Acta Entomol. Sin. 52, 640-650.

# 'x2' is the vector of temperature (in degrees Celsius)
# 'D2' is the vector of developmental duration (in d)
# 'y2' is the vector of the square root of developmental rate (in 1/d)

x2 &lt;- seq(15, 37, by=1)
D2 &lt;- c(41.24,37.16,32.47,26.22,22.71,19.01,16.79,15.63,14.27,12.48,
       11.3,10.56,9.69,9.14,8.24,8.02,7.43,7.27,7.35,7.49,7.63,7.9,10.03)
y2 &lt;- 1/D2
y2 &lt;- sqrt( y2 )
ini.val1 &lt;- c(0.14, 30, 10, 40)

# Define the square root function of the Lobry-Rosso-Flandrois (LRF) model
sqrt.LRF &lt;- function(P, x){
  ropt &lt;- P[1]
  Topt &lt;- P[2]
  Tmin &lt;- P[3]
  Tmax &lt;- P[4]
  fun0 &lt;- function(z){
    z[z &lt; Tmin] &lt;- Tmin
    z[z &gt; Tmax] &lt;- Tmax
    return(z)
  }
  x &lt;- fun0(x)
  if (Tmin &gt;= Tmax | ropt &lt;= 0 | Topt &lt;= Tmin | Topt &gt;= Tmax) 
    temp &lt;- Inf
  if (Tmax &gt; Tmin &amp; ropt &gt; 0 &amp; Topt &gt; Tmin &amp; Topt &lt; Tmax){
    temp &lt;- sqrt( ropt*(x-Tmax)*(x-Tmin)^2/((Topt-Tmin)*((Topt-Tmin
      )*(x-Topt)-(Topt-Tmax)*(Topt+Tmin-2*x))) )  
  }
  return( temp )
}

myfun &lt;- sqrt.LRF

  set.seed(123)
  resu4 &lt;- bootIPEC( myfun, x=x2, y=y2, ini.val=ini.val1, 
                     nboot=2000, CI=0.95, fig.opt=TRUE )
  resu4
  set.seed(NULL)

#################################################################################################


#### Example 3 ##################################################################################
graphics.off()
# Height growth data of four species of bamboo (Gramineae: Bambusoideae)
# Reference(s):
# Shi, P., Fan, M., Ratkowsky, D.A., Huang, J., Wu, H., Chen, L., Fang, S. and  
#     Zhang, C. (2017) Comparison of two ontogenetic growth equations for animals and plants. 
#     Ecol. Model. 349, 1-10.

data(shoots)
# Choose a species
# 1: Phyllostachys iridescens; 2: Phyllostachys mannii; 
# 3: Pleioblastus maculatus; 4: Sinobambusa tootsik.
# 'x3' is the vector of the observation times from a specific starting time of growth
# 'y3' is the vector of the aboveground height values of bamboo shoots at 'x3' 

ind &lt;- 4
x3  &lt;- shoots$x[shoots$Code == ind]
y3  &lt;- shoots$y[shoots$Code == ind] 

# Define the beta sigmoid model (bsm)
bsm &lt;- function(P, x){
  P  &lt;- cbind(P)
  if(length(P) !=4 ) {stop(" The number of parameters should be 4!")}
  ropt &lt;- P[1]
  topt &lt;- P[2]
  tmin &lt;- P[3]
  tmax &lt;- P[4]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   
  return(ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-
         2*tmax)*( (x-tmin)/(topt-tmin) )^((topt-tmin)/(tmax-topt)))   
}

# Define the simplified beta sigmoid model (simp.bsm)
simp.bsm &lt;- function(P, x, tmin=0){
  P  &lt;- cbind(P)  
  ropt  &lt;- P[1]
  topt  &lt;- P[2]
  tmax  &lt;- P[3]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   
  return(ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-
         2*tmax)*((x-tmin)/(topt-tmin) )^((topt-tmin)/(tmax-topt)))   
}

# For the original beta sigmoid model
ini.val2 &lt;- c(40, 30, 5, 50)
xlab2    &lt;- "Time (d)"
ylab2    &lt;- "Height (cm)"


  set.seed(123)
  re4 &lt;- bootIPEC( bsm, x=x3, y=y3, ini.val=ini.val2,    
                   control=list(trace=FALSE, reltol=1e-20, maxit=50000),
                   nboot=2000, CI=0.95, fig.opt=TRUE, fold=10 )
  re4
  set.seed(NULL)


# For the simplified beta sigmoid model (in comparison with the original beta sigmoid model)
ini.val7 &lt;- c(40, 30, 50)


  set.seed(123)
  RESU4 &lt;- bootIPEC( simp.bsm, x=x3, y=y3, ini.val=ini.val7,   
                     control=list(trace=FALSE, reltol=1e-20, maxit=50000),
                     nboot=2000, CI=0.95, fig.opt=TRUE, fold=10 )
  RESU4
  set.seed(NULL)

#################################################################################################


#### Example 4 ##################################################################################
graphics.off()
# Weight of cut grass data (Pattinson 1981)
# References:
#   Clarke, G.P.Y. (1987) Approximate confidence limits for a parameter function in nonlinear 
#       regression. J. Am. Stat. Assoc. 82, 221-230.
#   Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? 
#       New diagnostic and inference tools in the NLIN Procedure. Paper SAS384-2014. 
#       http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf
#   Pattinson, N.B. (1981) Dry Matter Intake: An Estimate of the Animal
#       Response to Herbage on Offer. unpublished M.Sc. thesis, University
#       of Natal, Pietermaritzburg, South Africa, Department of Grassland Science.

# 'x4' is the vector of weeks after commencement of grazing in a pasture
# 'y4' is the vector of weight of cut grass from 10 randomly sited quadrants

x4 &lt;- 1:13
y4 &lt;- c( 3.183, 3.059, 2.871, 2.622, 2.541, 2.184, 
         2.110, 2.075, 2.018, 1.903, 1.770, 1.762, 1.550 )

# Define the first case of Mitscherlich equation
MitA &lt;- function(P1, x){
    P1[3] + P1[2]*exp(P1[1]*x)
}

# Define the second case of Mitscherlich equation
MitB &lt;- function(P2, x){
    log( P2[3] ) + exp(P2[2] + P2[1]*x)
}

# Define the third case of Mitscherlich equation
MitC &lt;- function(P3, x, x1=1, x2=13){
    theta1 &lt;- P3[1]
    beta2  &lt;- P3[2]
    beta3  &lt;- P3[3]
    theta2 &lt;- (beta3 - beta2)/(exp(theta1*x2)-exp(theta1*x1))
    theta3 &lt;- beta2/(1-exp(theta1*(x1-x2))) - beta3/(exp(theta1*(x2-x1))-1)
    theta3 + theta2*exp(theta1*x)
}


  set.seed(123)
  ini.val3 &lt;- c(-0.1, 2.5, 1.0)
  r4       &lt;- bootIPEC( MitA, x=x4, y=y4, ini.val=ini.val3,    
                        nboot=2000, CI=0.95, fig.opt=TRUE )
  r4

  ini.val4 &lt;- c(exp(-0.1), log(2.5), 1)
  R4       &lt;- bootIPEC( MitB, x=x4, y=y4, ini.val=ini.val4, 
                        nboot=2000, CI=0.95, fig.opt=TRUE )
  R4

  # ini.val6 &lt;- c(-0.15, 2.52, 1.09)
  iv.list2 &lt;- list(seq(-2, -0.05, len=5), seq(1, 4, len=8), seq(0.05, 3, by=0.5))
  RES0 &lt;- fitIPEC( MitC, x=x4, y=y4, ini.val=iv.list2,    
                   control=list(trace=FALSE, reltol=1e-10, maxit=5000) )
  RES0$par
  RES4 &lt;- bootIPEC( MitC, x=x4, y=y4, ini.val=iv.list2, 
                    control=list(trace=FALSE, reltol=1e-10, maxit=5000), 
                    nboot=5000, CI=0.95, fig.opt=TRUE, fold=3.5, unique.num=2 )
  RES4
  set.seed(NULL)

#################################################################################################
</code></pre>

<hr>
<h2 id='confcurves'>
Wald Confidence Curves and the Likelihood Confidence Curves
</h2><span id='topic+confcurves'></span>

<h3>Description</h3>

<p>Calculates the Wald confidence curves and the likelihood confidence curves of model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confcurves( expr, x, y, ini.val, weights = NULL, control=list(), 
            fig.opt = TRUE, fold = 5, np = 20, alpha = seq(1, 0.001, by=-0.001), 
            show.CI = NULL, method = "Richardson", method.args = 
            list(eps = 1e-04, d = 0.11, zero.tol = sqrt(.Machine$double.eps/7e-07), 
            r = 6, v = 2, show.details = FALSE), side = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confcurves_+3A_expr">expr</code></td>
<td>
<p>A given parametric model</p>
</td></tr>
<tr><td><code id="confcurves_+3A_x">x</code></td>
<td>
<p>A vector or matrix of observations of independent variable(s)</p>
</td></tr>
<tr><td><code id="confcurves_+3A_y">y</code></td>
<td>
<p>A vector of observations of response variable</p>
</td></tr>
<tr><td><code id="confcurves_+3A_ini.val">ini.val</code></td>
<td>
<p>A vector or list of initial values of model parameters</p>
</td></tr>
<tr><td><code id="confcurves_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights to be used in the fitting process. 
<code>weights</code> should be NULL or a numeric vector. If non-NULL, weighted least squares is used with weights <code>weights</code>; 
otherwise ordinary least squares is used.</p>
</td></tr>
<tr><td><code id="confcurves_+3A_control">control</code></td>
<td>
<p>A list of control parameters for using 
the <code><a href="stats.html#topic+optim">optim</a></code> function in package <span class="pkg">stats</span></p>
</td></tr>
<tr><td><code id="confcurves_+3A_fig.opt">fig.opt</code></td>
<td>
<p>An option to determine whether to draw the confidence curves of each parameter</p>
</td></tr>
<tr><td><code id="confcurves_+3A_fold">fold</code></td>
<td>
<p>The fold of <code class="reqn"> \mbox{SE}\left(\hat{\theta_{i}}\right) </code> for controlling the width of the confidence interval of <code class="reqn">\hat{\theta_{i}}</code> that represents the estimate of the <code class="reqn">i</code>th parameter</p>
</td></tr>
<tr><td><code id="confcurves_+3A_np">np</code></td>
<td>
<p>The number of data points for forming the lower or upper bounds of a likelihood confidence interval of <code class="reqn"> \hat{\theta_{i}} </code>, which controlls the step size (i.e., <code class="reqn">\delta</code>) in the <code class="reqn">y</code> coordinates of the likelihood confidence curves</p>
</td></tr>
<tr><td><code id="confcurves_+3A_alpha">alpha</code></td>
<td>
<p>The significance level(s) for calculating the <code class="reqn">x</code> coordinate(s) of the <code class="reqn">(1-\alpha)100\%</code> Wald confidence curves, which equals to 
<code class="reqn"> t_{\alpha/2}\left(n-p\right) </code></p>
</td></tr>
<tr><td><code id="confcurves_+3A_show.ci">show.CI</code></td>
<td>
<p>The <code class="reqn"> t_{\alpha/2}\left(n-p\right) </code> value(s) associated with the confidence level(s) of each parameter to be showed, i.e., <code>c(0.80, 0.90, 0.95, 0.99)</code></p>
</td></tr>
<tr><td><code id="confcurves_+3A_method">method</code></td>
<td>
<p>It is the same as the input argument of <code>method</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="confcurves_+3A_method.args">method.args</code></td>
<td>
<p>It is the same as the input argument of <code>method.args</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="confcurves_+3A_side">side</code></td>
<td>
<p>It is the same as the input argument of <code>side</code> of the <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code class="reqn">(1-\alpha)100\%</code> Wald confidence curves, the corresponding <code class="reqn">x</code> and <code class="reqn">y</code> coordinates are:
</p>
<p style="text-align: center;"><code class="reqn"> x = t_{\alpha/2}\left(n-p\right), </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn"> y = \hat{\theta_{i}} \pm t_{\alpha/2}\left(n-p\right)\,\mbox{SE}\left(\hat{\theta_{i}}\right), </code>
</p>

<p>where <code class="reqn">n</code> denotes the number of the observations, <code class="reqn">p</code> denotes the number of model parameters, and 
<code class="reqn">\mbox{SE}\left(\hat{\theta_{i}}\right)</code> denotes the standard error of the <code class="reqn">i</code>th model parameter's estimate. 
</p>
<p><code class="reqn">\quad</code> For the likelihood confidence curves (Cook and Weisberg, 1990), the corresponding <code class="reqn">x</code> and <code class="reqn">y</code> coordinates are:
</p>
<p style="text-align: center;"><code class="reqn"> x = \sqrt{\frac{\mbox{RSS}\left(\hat{\theta}^{\,\left(-i\right)}\right)-\mbox{RSS}\left(\hat{\theta}\right)}{\mbox{RSS}\left(\hat{\theta}\right)/(n-p)}}, </code>
</p>

<p>where <code class="reqn">\mbox{RSS}\left(\hat{\theta}\right)</code> represents the residual sum of squares for fitting the model with all model parameters; 
<code class="reqn">\mbox{RSS}\left(\hat{\theta}^{\,\left(-i\right)}\right)</code> represents the residual sum of squares for fitting the model with the <code class="reqn">i</code>th model parameter 
being fixed to be <code class="reqn">\hat{\theta_{i}} \pm k\,\delta</code>. Here, <code class="reqn">k</code> denotes the <code class="reqn">k</code>th iteration, and <code class="reqn">\delta</code> denotes the step size, 
which equals  
</p>
<p style="text-align: center;"><code class="reqn"> \delta = \frac{\hat{\theta_{i}} \pm \mbox{fold}\,\mbox{SE}\left(\hat{\theta_{i}}\right)}{\mbox{np}}. </code>
</p>

<p style="text-align: center;"><code class="reqn"> y = \hat{\theta_{i}} \pm k\,\delta. </code>
</p>

<p>Here, <code>fold</code> and <code>np</code> are defined by the user in the arguments. 
</p>
<p><code class="reqn">\quad</code> For other arguments, please see the <code><a href="#topic+fitIPEC">fitIPEC</a></code> and <code><a href="#topic+parinfo">parinfo</a></code> functions for details.
</p>


<h3>Value</h3>

<table>
<tr><td><code>partab</code></td>
<td>
<p>The estimates, standard errors and confidence intervals of model parameters; also see the <code><a href="#topic+parinfo">parinfo</a></code> function</p>
</td></tr>
<tr><td><code>parlist</code></td>
<td>
<p>A list for the estimate, Wald interval curves and likelihood interval curves of each model parameter.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the value of <code>parlist</code>, there are the estimate (<code>pari</code>), the Wald interval curves 
(<code>WaldCI</code>), and the likelihood interval curves (<code>lhCI</code>) of the <code class="reqn">i</code>th model parameter. 
In <code>WaldCI</code>, there are three columns. The first column, <code>tc</code>, 
represents <code class="reqn"> t_{\alpha/2}\left(n-p\right) </code>, the second and third columns, <code>LCI</code> and <code>UCI</code>, 
represent the lower and upper bounds of the <code class="reqn">(1-\alpha)100\%</code> Wald confidence intervals, respectively. 
In <code>lhCI</code>, there are six columns. The first and second columns, <code>x.lower</code> and <code>lhLCI</code>, 
represent the lower bounds of the likelihood confidence intervals the and corresponding <code class="reqn">x</code> values, 
respectively; the third and fourth columns, <code>x.upper</code> and <code>lhUCI</code>, represent the upper 
bounds of the likelihood confidence intervals and the corresponding <code class="reqn">x</code> values, respectively; 
the fifth and sixth columns, <code>RSS.lower</code> and <code>RSS.upper</code>, represent 
the values of the residual sum of squares of the lower bounds 
and those of the upper bounds, respectively. Please see Cook and Weisberg (1990) for details.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Cook, R.D. and Weisberg, S. (1990) Confidence curves in nonlinear regression. 
<em>J. Am. Statist. Assoc.</em> 82, 221<code class="reqn">-</code>230. <a href="https://doi.org/10.1080/01621459.1990.10476233">doi:10.1080/01621459.1990.10476233</a>
</p>
<p>Nelder, J.A. and Mead, R. (1965) A simplex method for function minimization. 
<em>Comput. J.</em> 7, 308<code class="reqn">-</code>313. <a href="https://doi.org/10.1093/comjnl/7.4.308">doi:10.1093/comjnl/7.4.308</a>
</p>
<p>Ratkowsky, D.A. (1990) <em>Handbook of Nonlinear Regression Models</em>, Marcel Dekker, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parinfo">parinfo</a></code>, <code><a href="#topic+fitIPEC">fitIPEC</a></code>, <code><a href="stats.html#topic+optim">optim</a></code> in package <span class="pkg">stats</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example 1 ###################################################################################
# Weight of cut grass data (Pattinson 1981)
# References:
#   Clarke, G.P.Y. (1987) Approximate confidence limits for a parameter function in nonlinear 
#       regression. J. Am. Stat. Assoc. 82, 221-230.
#   Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? 
#       New diagnostic and inference tools in the NLIN Procedure. Paper SAS384-2014.
#       http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf
#   Pattinson, N.B. (1981) Dry Matter Intake: An Estimate of the Animal
#       Response to Herbage on Offer. unpublished M.Sc. thesis, University
#       of Natal, Pietermaritzburg, South Africa, Department of Grassland Science.

# 'x4' is the vector of weeks after commencement of grazing in a pasture
# 'y4' is the vector of weight of cut grass from 10 randomly sited quadrants

x4 &lt;- 1:13
y4 &lt;- c(3.183, 3.059, 2.871, 2.622, 2.541, 2.184, 
        2.110, 2.075, 2.018, 1.903, 1.770, 1.762, 1.550)

# Define the first case of Mitscherlich equation
MitA &lt;- function(P, x){    
    P[3] + P[2]*exp(P[1]*x)
}

# Define the second case of Mitscherlich equation
MitB &lt;- function(P2, x){
    if(P2[3] &lt;= 0)
        temp &lt;- mean(y4)
    if(P2[3] &gt; 0)
       temp &lt;- log(P2[3]) + exp(P2[2] + P2[1]*x)
    return( temp )
}

# Define the third case of Mitscherlich equation
MitC &lt;- function(P3, x, x1=1, x2=13){
    theta1 &lt;- P3[1]
    beta2  &lt;- P3[2]
    beta3  &lt;- P3[3]
    theta2 &lt;- (beta3 - beta2)/(exp(theta1*x2)-exp(theta1*x1))
    theta3 &lt;- beta2/(1-exp(theta1*(x1-x2))) - beta3/(exp(theta1*(x2-x1))-1)
    theta3 + theta2*exp(theta1*x)
}

ini.val3 &lt;- c(-0.1, 2.5, 1)
RESU1    &lt;- confcurves( MitA, x=x4, y=y4, ini.val=ini.val3, fig.opt = TRUE, 
                        fold=5, np=20, alpha=seq(1, 0.001, by=-0.001), 
                        show.CI=c(0.8, 0.9, 0.95, 0.99) )

ini.val4 &lt;- c(-0.10, 0.90, 2.5)
RESU2    &lt;- confcurves( MitB, x=x4, y=y4, ini.val=ini.val4, fig.opt = TRUE, 
                        fold=5, np=200, alpha=seq(1, 0.001, by=-0.001), 
                        show.CI=c(0.8, 0.9, 0.95, 0.99) )

ini.val6 &lt;- c(-0.15, 2.5, 1)
RESU3    &lt;- confcurves( MitC, x=x4, y=y4, ini.val=ini.val6, fig.opt = TRUE, 
                        fold=5, np=20, alpha=seq(1, 0.001, by=-0.001), 
                        show.CI=c(0.8, 0.9, 0.95, 0.99) )
##################################################################################################

graphics.off()
</code></pre>

<hr>
<h2 id='crops'>
Whole-plant biomass Data of 12 Species of Crops
</h2><span id='topic+crops'></span>

<h3>Description</h3>

<p>The whole-plant biomass data of 12 species of crops growing in northern China in 2011.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(crops)
</code></pre>


<h3>Details</h3>

<p>In the data set, there are six columns: <code>Code</code>, <code>CommonName</code>, <code>Date</code>,  
<code>Time</code>, <code>FM</code>, and <code>DM</code>. 
<code>Code</code> is used to save the codes of crops; 
<code>CommonName</code> is used to save the common names of crops; 
<code>Date</code> is used to save the investigation date; 
<code>Time </code> is used to save the ages of crops from the sowing date (27 June, 2011) in days; 
<code>FM</code> is used to save the whole-plant fresh mass of crops in g; 
<code>DM</code> is used to save the whole-plant dry mass of crops in g. 
</p>
<p><code>Code = 1</code> represents sunflowers; 
</p>
<p><code>Code = 2</code> represents peanuts; 
</p>
<p><code>Code = 3</code> represents black soybeans; 
</p>
<p><code>Code = 4</code> represents soybeans; 
</p>
<p><code>Code = 5</code> represents kidney beans; 
</p>
<p><code>Code = 6</code> represents garden peas; 
</p>
<p><code>Code = 7</code> represents adzuki beans; 
</p>
<p><code>Code = 8</code> represents mungbeans; 
</p>
<p><code>Code = 9</code> represents cottons; 
</p>
<p><code>Code = 10</code> represents sweet sorghums; 
</p>
<p><code>Code = 11</code> represents corns; 
</p>
<p><code>Code = 12</code> represents Mexican corns. 
</p>


<h3>References</h3>

<p>Shi, P., Fan, M., Ratkowsky, D.A., Huang, J., Wu, H., Chen, L., Fang, S. and 
Zhang, C. (2017) Comparison of two ontogenetic growth equations for animals and plants. 
<em>Ecol. Model.</em> 349, 1<code class="reqn">-</code>10. <a href="https://doi.org/10.1016/j.ecolmodel.2017.01.012">doi:10.1016/j.ecolmodel.2017.01.012</a>
</p>
<p>Shi, P., Men, X., Sandhu, H.S., Chakraborty, A., Li, B., Ouyang, F., Sun, Y., Ge, F. 
(2013) The &quot;general&quot; ontogenetic growth model is inapplicable to crop growth. 
<em>Ecol. Model.</em> 266, 1<code class="reqn">-</code>9. <a href="https://doi.org/10.1016/j.ecolmodel.2013.06.025">doi:10.1016/j.ecolmodel.2013.06.025</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crops)
ind   &lt;- 6
xv    &lt;- crops$Time[crops$Code == ind]
yv    &lt;- crops$DM[crops$Code == ind] 
xlab0 &lt;- "Time (d)"
ylab0 &lt;- "Dry mass (g)"

dev.new()
plot(xv, yv, cex=1.5, cex.lab=1.5, cex.axis=1.5, xlab=xlab0, ylab=ylab0)

# Define the beta sigmoid model (bsm)
bsm &lt;- function(P, x){
  P  &lt;- cbind(P)
  if(length(P) !=4 ) {stop("The number of parameters should be 4!")}
  ropt &lt;- P[1]
  topt &lt;- P[2]
  tmin &lt;- P[3]
  tmax &lt;- P[4]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   
  ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-2*tmax)*(
       (x-tmin)/(topt-tmin) )^((topt-tmin)/(tmax-topt))   
}

# For the original beta sigmoid model
ini.val0  &lt;- c(60, 30, seq(0, 10, 20), 100)
fit1 &lt;- fitIPEC( bsm, x=xv, y=yv, ini.val=ini.val0, xlim=NULL, ylim=NULL, 
                 xlab=xlab0, ylab=ylab0, fig.opt=TRUE, 
                 control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
fit1$par

w    &lt;- rep(1/as.numeric(tapply(yv, xv, var)), tapply(yv, xv, length))
fit2 &lt;- fitIPEC( bsm, x=xv, y=yv, ini.val=ini.val0, weights=w, xlim=NULL,  
                 ylim=NULL, xlab=xlab0, ylab=ylab0, fig.opt=TRUE, 
                 control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
fit2$par

dev.new()
xp  &lt;- seq(0, 120, len=2000)
yp  &lt;- bsm(P=fit2$par, x=xp)
xv2 &lt;- as.numeric(tapply(xv, xv, mean))
yv2 &lt;- as.numeric(tapply(yv, xv, mean))
sd2 &lt;- as.numeric(tapply(yv, xv, sd))
Up  &lt;- yv2+sd2
Low &lt;- yv2-sd2
plot( xv2, yv2, xlab=xlab0, ylab=ylab0, cex.lab=1.5, 
      cex.axis=1.5, xlim=c(0,120), ylim=c(-5, 100), type="n" )
lines( xp, yp, col=4 )
points( xv2, yv2, pch=1, cex=1.5, col=2 )
for(i in 1:length(Up)){
  lines(c(xv2[i], xv2[i]), c(Low[i], Up[i]), col=6)
}  
</code></pre>

<hr>
<h2 id='curvIPEC'>
RMS Curvature Calculation Function
</h2><span id='topic+curvIPEC'></span>

<h3>Description</h3>

<p>Calculates the root mean square curvatures (intrinsic and parameter-effects curvatures) 
of a nonlinear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curvIPEC(expr, theta, x, y, tol = 1e-16, alpha = 0.05, method = "Richardson", 
         method.args = list(eps = 1e-04, d = 0.11, 
         zero.tol = sqrt(.Machine$double.eps/7e-07), 
         r = 6, v = 2, show.details = FALSE), side = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvIPEC_+3A_expr">expr</code></td>
<td>
<p>A given parametric model</p>
</td></tr>
<tr><td><code id="curvIPEC_+3A_theta">theta</code></td>
<td>
<p>A vector of parameters of the model</p>
</td></tr>
<tr><td><code id="curvIPEC_+3A_x">x</code></td>
<td>
<p>A vector or matrix of observations of independent variable(s)</p>
</td></tr>
<tr><td><code id="curvIPEC_+3A_y">y</code></td>
<td>
<p>A vector of observations of response variable</p>
</td></tr>
<tr><td><code id="curvIPEC_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of a matrix in the QR decomposition. 
See the input argument of <code>tol</code> of the <code><a href="Matrix.html#topic+qr">qr</a></code> function in package <span class="pkg">base</span> </p>
</td></tr>
<tr><td><code id="curvIPEC_+3A_alpha">alpha</code></td>
<td>
<p>Parameter controlling the significance level for testing the significance of a curvature</p>
</td></tr>
<tr><td><code id="curvIPEC_+3A_method">method</code></td>
<td>
<p>It is the same as the input argument of <code>method</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="curvIPEC_+3A_method.args">method.args</code></td>
<td>
<p>It is the same as the input argument of <code>method.args</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="curvIPEC_+3A_side">side</code></td>
<td>
<p>It is the same as the input argument of <code>side</code> of the <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was built based on the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> functions in package <span class="pkg">numDeriv</span>, 
with reference to the <code><a href="MASS.html#topic+rms.curv">rms.curv</a></code> function in package <span class="pkg">MASS</span>. 
However, it is more general without being limited by the <code><a href="stats.html#topic+deriv3">deriv3</a></code> function in package <span class="pkg">stats</span> 
and <code><a href="stats.html#topic+nls">nls</a></code> class like the <code><a href="MASS.html#topic+rms.curv">rms.curv</a></code> function in package <span class="pkg">MASS</span>. It mainly relies on package <span class="pkg">numDeriv</span>.
The users only need provide the defined model, the fitted parameter vector, and the observations 
of independent and response variables, they will obtain the curvatures. The input argument <code>theta</code> can be obtained using the <code><a href="#topic+fitIPEC">fitIPEC</a></code> 
function in the current package, and it also can be obtained using the other nonlinear regression functions.
</p>


<h3>Value</h3>

<table>
<tr><td><code>rms.ic</code></td>
<td>
<p>The root mean square intrinsic curvature</p>
</td></tr>
<tr><td><code>rms.pec</code></td>
<td>
<p>The root mean square parameter-effects curvature</p>
</td></tr>
<tr><td><code>critical.c</code></td>
<td>
<p>The critical curvature value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The calculation precision of curvature mainly depends on the setting of <code>method.args</code>. 
The two important default values in the list of <code>method.args</code> are <code>d = 0.11</code>, and <code>r = 6</code>.
</p>
<p>This function cannot be used to calculate the maximum intrinsic and parameter-effects curvatures.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Bates, D.M and Watts, D.G. (1988) <em>Nonlinear Regression Analysis and its Applications</em>. Wiley, New York. <a href="https://doi.org/10.1002/9780470316757">doi:10.1002/9780470316757</a>
</p>
<p>Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? New diagnostic and inference tools in the NLIN Procedure. 
Paper SAS384-2014. <a href="http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf">http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf</a>
</p>
<p>Ratkowsky, D.A. (1983) <em>Nonlinear Regression Modeling: A Unified Practical Approach</em>. Marcel Dekker, New York.
</p>
<p>Ratkowsky, D.A. (1990) <em>Handbook of Nonlinear Regression Models</em>, Marcel Dekker, New York.
</p>
<p>Ratkowsky, D.A. &amp; Reddy, G.V.P. (2017) Empirical model with excellent statistical properties for describing temperature-dependent 
developmental rates of insects and mites. <em>Ann. Entomol. Soc. Am.</em> 110, 302<code class="reqn">-</code>309. <a href="https://doi.org/10.1093/aesa/saw098">doi:10.1093/aesa/saw098</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivIPEC">derivIPEC</a></code>, <code><a href="numDeriv.html#topic+hessian">hessian</a></code> in package <span class="pkg">numDeriv</span>, 
<code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> in package <span class="pkg">numDeriv</span>, <code><a href="MASS.html#topic+rms.curv">rms.curv</a></code> in package <span class="pkg">MASS</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example 1 ##################################################################################
# The velocity of the reaction (counts/min^2) under different substrate concentrations 
#   in parts per million (ppm) (Pages 255 and 269 of Bates and Watts 1988)

x1 &lt;- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56, 1.10, 1.10)
y1 &lt;- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)

# Define the Michaelis-Menten model
MM &lt;- function(theta, x){
    theta[1]*x / ( theta[2] + x )    
}

par1 &lt;- c(212.68490865, 0.06412421)
# To calculate curvatures
res2 &lt;- curvIPEC(MM, theta=par1, x=x1, y=y1, alpha=0.05, method="Richardson",
            method.args=list(eps=1e-4, d=0.11, zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2)) 
res2
##################################################################################################


#### Example 2 ###################################################################################
# Development data of female pupae of cotton bollworm (Wu et al. 2009)
# References:
#   Ratkowsky, D.A. and Reddy, G.V.P. (2017) Empirical model with excellent statistical 
#       properties for describing temperature-dependent developmental rates of insects  
#       and mites. Ann. Entomol. Soc. Am. 110, 302-309.
#   Wu, K., Gong, P. and Ruan, Y. (2009) Estimating developmental rates of 
#       Helicoverpa armigera (Lepidoptera: Noctuidae) pupae at constant and
#       alternating temperature by nonlinear models. Acta Entomol. Sin. 52, 640-650.

# 'x2' is the vector of temperature (in degrees Celsius)
# 'D2' is the vector of developmental duration (in d)
# 'y2' is the vector of the square root of developmental rate (in 1/d)

x2 &lt;- seq(15, 37, by=1)
D2 &lt;- c( 41.24,37.16,32.47,26.22,22.71,19.01,16.79,15.63,14.27,12.48,
         11.3,10.56,9.69,9.14,8.24,8.02,7.43,7.27,7.35,7.49,7.63,7.9,10.03 )
y2 &lt;- 1/D2
y2 &lt;- sqrt( y2 )

# Define the square root function of the Lobry-Rosso-Flandrois (LRF) model
sqrt.LRF &lt;- function(P, x){
  ropt &lt;- P[1]
  Topt &lt;- P[2]
  Tmin &lt;- P[3]
  Tmax &lt;- P[4]
  fun0 &lt;- function(z){
    z[z &lt; Tmin] &lt;- Tmin
    z[z &gt; Tmax] &lt;- Tmax
    return(z)
  }
  x &lt;- fun0(x)
  if (Tmin &gt;= Tmax | ropt &lt;= 0 | Topt &lt;= Tmin | Topt &gt;= Tmax) 
    temp &lt;- Inf
  if (Tmax &gt; Tmin &amp; ropt &gt; 0 &amp; Topt &gt; Tmin &amp; Topt &lt; Tmax){
    temp &lt;- sqrt( ropt*(x-Tmax)*(x-Tmin)^2/((Topt-Tmin)*((Topt-Tmin
      )*(x-Topt)-(Topt-Tmax)*(Topt+Tmin-2*x))) )  
  }
  return( temp )
}

myfun &lt;- sqrt.LRF
par2  &lt;- c(0.1382926, 33.4575663, 5.5841244, 38.8282021)

# To calculate curvatures
resu2 &lt;- curvIPEC( myfun, theta=par2, x=x2, y=y2, alpha=0.05, method="Richardson", 
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
resu2
##################################################################################################


#### Example 3 ###################################################################################
# Height growth data of four species of bamboo (Gramineae: Bambusoideae)
# Reference(s):
# Shi, P., Fan, M., Ratkowsky, D.A., Huang, J., Wu, H., Chen, L., Fang, S. and  
#     Zhang, C. (2017) Comparison of two ontogenetic growth equations for animals and plants. 
#     Ecol. Model. 349, 1-10.

data(shoots)
# Choose a species
# 1: Phyllostachys iridescens; 2: Phyllostachys mannii; 
# 3: Pleioblastus maculatus; 4: Sinobambusa tootsik. 
# 'x3' is the vector of the investigation times (in d) from a specific starting time of growth
# 'y3' is the vector of the aboveground height values (in cm) of bamboo shoots at 'x3' 

ind &lt;- 4
x3  &lt;- shoots$x[shoots$Code == ind]
y3  &lt;- shoots$y[shoots$Code == ind] 

# Define the beta sigmoid model (bsm)
bsm &lt;- function(P, x){
  P  &lt;- cbind(P)
  if(length(P) !=4 ) {stop("The number of parameters should be 4!")}
  ropt &lt;- P[1]
  topt &lt;- P[2]
  tmin &lt;- P[3]
  tmax &lt;- P[4]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   
  ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-2*tmax)*(
     (x-tmin)/(topt-tmin))^((topt-tmin)/(tmax-topt))   
}

# Define the simplified beta sigmoid model (simp.bsm)
simp.bsm &lt;- function(P, x, tmin=0){
  P  &lt;- cbind(P)  
  ropt  &lt;- P[1]
  topt  &lt;- P[2]
  tmax  &lt;- P[3]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   
  ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-2*tmax)*(
  (x-tmin)/(topt-tmin))^((topt-tmin)/(tmax-topt))   
}

# For the original beta sigmoid model 
ini.val2 &lt;- c(40, 30, 5, 50)
xlab2    &lt;- "Time (d)"
ylab2    &lt;- "Height (cm)"
re0      &lt;- fitIPEC( bsm, x=x3, y=y3, ini.val=ini.val2, 
                     xlim=NULL, ylim=NULL, xlab=xlab2, ylab=ylab2, 
                     fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
par3  &lt;- re0$par
par3
re1   &lt;- derivIPEC( bsm, theta=par3, x3[20], method="Richardson", 
                    method.args=list(eps=1e-4, d=0.11, 
                    zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) )
re1
re2   &lt;- curvIPEC( bsm, theta=par3, x=x3, y=y3, alpha=0.05, method="Richardson",                    
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
re2

# For the simplified beta sigmoid model (in comparison with the original beta sigmoid model)
ini.val7 &lt;- c(40, 30, 50)

RESU0 &lt;- fitIPEC( simp.bsm, x=x3, y=y3, ini.val=ini.val7, 
                  xlim=NULL, ylim=NULL, xlab=xlab2, ylab=ylab2, 
                  fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
par7  &lt;- RESU0$par
par7

RESU2 &lt;- curvIPEC( simp.bsm, theta=par7, x=x3, y=y3, alpha=0.05, method="Richardson",             
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
RESU2
##################################################################################################


#### Example 4 ###################################################################################
# Weight of cut grass data (Pattinson 1981)
# References:
#   Clarke, G.P.Y. (1987) Approximate confidence limits for a parameter function in nonlinear 
#       regression. J. Am. Stat. Assoc. 82, 221-230.
#   Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? 
#       New diagnostic and inference tools in the NLIN Procedure. Paper SAS384-2014.
#       http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf
#   Pattinson, N.B. (1981) Dry Matter Intake: An Estimate of the Animal
#       Response to Herbage on Offer. unpublished M.Sc. thesis, University
#       of Natal, Pietermaritzburg, South Africa, Department of Grassland Science.

# 'x4' is the vector of weeks after commencement of grazing in a pasture
# 'y4' is the vector of weight of cut grass from 10 randomly sited quadrants

x4 &lt;- 1:13
y4 &lt;- c(3.183, 3.059, 2.871, 2.622, 2.541, 2.184, 
        2.110, 2.075, 2.018, 1.903, 1.770, 1.762, 1.550)

# Define the first case of Mitscherlich equation
MitA &lt;- function(P1, x){
    P1[3] + P1[2]*exp(P1[1]*x)
}

# Define the second case of Mitscherlich equation
MitB &lt;- function(P2, x){
    log( P2[3] ) + exp(P2[2] + P2[1]*x)
}

# Define the third case of Mitscherlich equation
MitC &lt;- function(P3, x, x1=1, x2=13){
    theta1 &lt;- P3[1]
    beta2  &lt;- P3[2]
    beta3  &lt;- P3[3]
    theta2 &lt;- (beta3 - beta2)/(exp(theta1*x2)-exp(theta1*x1))
    theta3 &lt;- beta2/(1-exp(theta1*(x1-x2))) - beta3/(exp(theta1*(x2-x1))-1)
    theta3 + theta2*exp(theta1*x)
}

ini.val3 &lt;- c(-0.1, 2.5, 1)
r0       &lt;- fitIPEC( MitA, x=x4, y=y4, ini.val=ini.val3, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
parA     &lt;- r0$par
parA
r2 &lt;- curvIPEC( MitA, theta=parA, x=x4, y=y4, alpha=0.05, method="Richardson", 
                method.args=list(eps=1e-4, d=0.11, 
                zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
r2

ini.val4 &lt;- c(exp(-0.1), log(2.5), 1)

R0       &lt;- fitIPEC( MitB, x=x4, y=y4, ini.val=ini.val3, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
parB     &lt;- R0$par
parB
R2       &lt;- curvIPEC( MitB, theta=parB, x=x4, y=y4, alpha=0.05, method="Richardson", 
                      method.args=list(eps=1e-4, d=0.11, 
                      zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
R2

ini.val6 &lt;- c(-0.15, 2.52, 1.09)
RES0     &lt;- fitIPEC( MitC, x=x4, y=y4, ini.val=ini.val6, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(trace=FALSE, 
                     reltol=1e-20, maxit=50000) )
parC     &lt;- RES0$par
parC
RES2     &lt;- curvIPEC( MitC, theta=parC, x=x4, y=y4, 
                      tol=1e-20, alpha=0.05, method="Richardson", 
                      method.args=list(eps=1e-4, d=0.11, 
                      zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
RES2
##################################################################################################


#### Example 5 ###################################################################################
# Conductance of a thermistor (y5) as a function of temperature (x5) (Meyer and Roth, 1972)
# References:
#   Page 120 in Ratkowsky (1983)
#   Meyer, R.R. and Roth P.M. (1972) Modified damped least squares:
#       A algorithm for non-linear estimation. J. Inst. Math. Appl. 9, 218-233.

x5 &lt;- seq(50, 125, by=5)
y5 &lt;- c( 34780, 28610, 23650, 19630, 16370, 13720, 11540, 9744, 
         8261, 7030, 6005, 5147, 4427, 3820, 3307, 2872 )
y5 &lt;- log(y5)

conduct.fun &lt;- function(P, x){
-P[1]+P[2]/(x+P[3])
}

ini.val5 &lt;- c(5, 10^4, 0.5*10^3)
RE0      &lt;- fitIPEC( conduct.fun, x=x5, y=y5, ini.val=ini.val5, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
par5     &lt;- RE0$par
par5
RE2      &lt;- curvIPEC( conduct.fun, theta=par5, x=x5, y=y5, alpha=0.05, method="Richardson", 
                      method.args=list(eps=1e-4, d=0.11, 
                      zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
RE2
##################################################################################################


#### Example 6 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References
# Pages 255 and 270 in Bates and Watts (1988)
# Marske, D. (1967) Biochemical oxygen demand data interpretation using sum of squares surface.
#     M.Sc. Thesis, University of Wisconsin-Madison.

# 'x6' is a vector of time (in d)
# 'y6' is a vector of biochemical oxygen demand (mg/l)

x6 &lt;- c(1, 2, 3, 4, 5, 7)
y6 &lt;- c(8.3, 10.3, 19.0, 16.0, 15.6, 19.8)

BOD.fun &lt;- function(P, x){
  P[1]*(1-exp(P[2]*x))
}

ini.val7 &lt;- c(210, 0.06)
consq0   &lt;- fitIPEC( BOD.fun, x=x6, y=y6, ini.val=ini.val7, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
par7     &lt;- consq0$par
par7
consq2   &lt;- curvIPEC( BOD.fun, theta=par7, x=x6, y=y6, alpha=0.05, method="Richardson", 
                      method.args=list(eps=1e-4, d=0.11, 
                      zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
consq2
##################################################################################################


#### Example 7 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References:
# Pages 56, 255 and 271 in Bates and Watts (1988)
# Carr, N.L. (1960) Kinetics of catalytic isomerization of n-pentane. Ind. Eng. Chem.
#     52, 391-396.   

data(isom)
Y &lt;- isom[,1]
X &lt;- isom[,2:4]

# There are three independent variables saved in matrix 'X' and one response variable (Y)
# The first column of 'X' is the vector of partial pressure of hydrogen
# The second column of 'X' is the vector of partial pressure of n-pentane
# The third column of 'X' is the vector of partial pressure of isopentane
# Y is the vector of experimental reaction rate (in 1/hr)

isom.fun &lt;- function(theta, x){
  x1     &lt;- x[,1]
  x2     &lt;- x[,2]
  x3     &lt;- x[,3]
  theta1 &lt;- theta[1]
  theta2 &lt;- theta[2]
  theta3 &lt;- theta[3]
  theta4 &lt;- theta[4]
  theta1*theta3*(x2-x3/1.632) / ( 1 + theta2*x1 + theta3*x2 + theta4*x3 )
}

par8  &lt;- c(35.92831619, 0.07084811, 0.03772270, 0.16718384) 
cons2 &lt;- curvIPEC( isom.fun, theta=par8, x=X, y=Y, alpha=0.05, method="Richardson", 
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
cons2
##################################################################################################
</code></pre>

<hr>
<h2 id='derivIPEC'>
Derivative Calculation Function
</h2><span id='topic+derivIPEC'></span>

<h3>Description</h3>

<p>Calculates the Jacobian and Hessian matrices of model parameters at a number or a vector <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivIPEC(expr, theta, z, method = "Richardson", 
          method.args = list(eps = 1e-04, d = 0.11, 
          zero.tol = sqrt(.Machine$double.eps/7e-07), r = 6, v = 2, 
          show.details = FALSE), side = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivIPEC_+3A_expr">expr</code></td>
<td>
<p>A given parametric model</p>
</td></tr>
<tr><td><code id="derivIPEC_+3A_theta">theta</code></td>
<td>
<p>A vector of parameters of the model</p>
</td></tr>
<tr><td><code id="derivIPEC_+3A_z">z</code></td>
<td>
<p>A number or a vector where the derivatives are calculated</p>
</td></tr>
<tr><td><code id="derivIPEC_+3A_method">method</code></td>
<td>
<p>It is the same as the input argument of <code>method</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="derivIPEC_+3A_method.args">method.args</code></td>
<td>
<p>It is the same as the input argument of <code>method.args</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="derivIPEC_+3A_side">side</code></td>
<td>
<p>It is the same as the input argument of <code>side</code> of the <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hessian and Jacobian matrices are calculated at a number or a vector <code>z</code>, 
which represents a value of a single independent variable 
or a combination of different values of multiple independent variables. 
Note: <code>z</code> actually corresponds to a combination observation of <code class="reqn">x</code> rather 
than all <code class="reqn">n</code> observations. If there is only a preditor, <code>z</code> is a numerical value; 
there are several predictors, 
then <code>z</code> is a vector corresponding to one combination observation of those predictors.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Jacobian</code></td>
<td>
<p>The Jacobian matrix of parameters at <code>z</code></p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>The Hessian matrix of parameters at <code>z</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Bates, D.M and Watts, D.G. (1988) <em>Nonlinear Regression Analysis and its Applications</em>. Wiley, New York. <a href="https://doi.org/10.1002/9780470316757">doi:10.1002/9780470316757</a>
</p>
<p>Ratkowsky, D.A. (1983) <em>Nonlinear Regression Modeling: A Unified Practical Approach</em>. Marcel Dekker, New York.
</p>
<p>Ratkowsky, D.A. (1990) <em>Handbook of Nonlinear Regression Models</em>, Marcel Dekker, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biasIPEC">biasIPEC</a></code>, <code><a href="#topic+skewIPEC">skewIPEC</a></code>, <code><a href="#topic+curvIPEC">curvIPEC</a></code>, <code><a href="#topic+parinfo">parinfo</a></code>, 
<code><a href="numDeriv.html#topic+hessian">hessian</a></code> in package <span class="pkg">numDeriv</span>, 
<code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> in package <span class="pkg">numDeriv</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example 1 #####################################################################################
# Define the Michaelis-Menten model
MM &lt;- function(theta, x){
    theta[1]*x / ( theta[2] + x )    
}

par1 &lt;- c(212.68490865, 0.06412421)
res1 &lt;- derivIPEC(MM, theta=par1, z=0.02, method="Richardson",
            method.args=list(eps=1e-4, d=0.11, 
            zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2))
res1
####################################################################################################


#### Example 2 #####################################################################################
# Define the square root function of the Lobry-Rosso-Flandrois (LRF) model
sqrt.LRF &lt;- function(P, x){
  ropt &lt;- P[1]
  Topt &lt;- P[2]
  Tmin &lt;- P[3]
  Tmax &lt;- P[4]
  fun0 &lt;- function(z){
    z[z &lt; Tmin] &lt;- Tmin
    z[z &gt; Tmax] &lt;- Tmax
    return(z)
  }
  x &lt;- fun0(x)
  if (Tmin &gt;= Tmax | ropt &lt;= 0 | Topt &lt;= Tmin | Topt &gt;= Tmax) 
    temp &lt;- Inf
  if (Tmax &gt; Tmin &amp; ropt &gt; 0 &amp; Topt &gt; Tmin &amp; Topt &lt; Tmax){
    temp &lt;- sqrt( ropt*(x-Tmax)*(x-Tmin)^2/((Topt-Tmin)*((Topt-Tmin
      )*(x-Topt)-(Topt-Tmax)*(Topt+Tmin-2*x))) )  
  }
  return( temp )
}

myfun &lt;- sqrt.LRF
par2  &lt;- c(0.1382926, 33.4575663, 5.5841244, 38.8282021)
resu1 &lt;- derivIPEC( myfun, theta=par2, z=15, method="Richardson", 
            method.args=list(eps=1e-4, d=0.11, 
            zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) )
resu1
####################################################################################################


#### Example 3 #####################################################################################
# Weight of cut grass data (Pattinson 1981)
# References:
#   Clarke, G.P.Y. (1987) Approximate confidence limits for a parameter function in nonlinear 
#       regression. J. Am. Stat. Assoc. 82, 221-230.
#   Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? 
#       New diagnostic and inference tools in the NLIN Procedure. Paper SAS384-2014.
#       http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf
#   Pattinson, N.B. (1981) Dry Matter Intake: An Estimate of the Animal
#       Response to Herbage on Offer. unpublished M.Sc. thesis, University
#       of Natal, Pietermaritzburg, South Africa, Department of Grassland Science.

# 'x4' is the vector of weeks after commencement of grazing in a pasture
# 'y4' is the vector of weight of cut grass from 10 randomly sited quadrants

x4 &lt;- 1:13
y4 &lt;- c(3.183, 3.059, 2.871, 2.622, 2.541, 2.184, 2.110, 2.075, 2.018, 1.903, 1.770, 1.762, 1.550)

# Define the third case of Mitscherlich equation
MitC &lt;- function(P3, x){
    theta1 &lt;- P3[1]
    beta2  &lt;- P3[2]
    beta3  &lt;- P3[3]
    x1     &lt;- 1
    x2     &lt;- 13
    theta2 &lt;- (beta3 - beta2)/(exp(theta1*x2)-exp(theta1*x1))
    theta3 &lt;- beta2/(1-exp(theta1*(x1-x2))) - beta3/(exp(theta1*(x2-x1))-1)
    theta3 + theta2*exp(theta1*x)
}

ini.val6 &lt;- c(-0.15, 2.52, 1.09)
RES0     &lt;- fitIPEC( MitC, x=x4, y=y4, ini.val=ini.val6, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
parC     &lt;- RES0$par
parC
RES1     &lt;- derivIPEC( MitC, theta=parC, z=2, method="Richardson", 
                       method.args=list(eps=1e-4, d=0.11, 
                       zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) )
RES1
#################################################################################################


#### Example 4 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References:
# Pages 56, 255 and 271 in Bates and Watts (1988)
# Carr, N.L. (1960) Kinetics of catalytic isomerization of n-pentane. Ind. Eng. Chem.
#     52, 391-396.   

data(isom)
Y &lt;- isom[,1]
X &lt;- isom[,2:4]

# There are three independent variables saved in matrix 'X' and one response variable (Y)
# The first column of 'X' is the vector of partial pressure of hydrogen
# The second column of 'X' is the vector of partial pressure of n-pentane
# The third column of 'X' is the vector of partial pressure of isopentane
# Y is the vector of experimental reaction rate (in 1/hr)

isom.fun &lt;- function(theta, x){
  x1     &lt;- x[,1]
  x2     &lt;- x[,2]
  x3     &lt;- x[,3]
  theta1 &lt;- theta[1]
  theta2 &lt;- theta[2]
  theta3 &lt;- theta[3]
  theta4 &lt;- theta[4]
  theta1*theta3*(x2-x3/1.632) / ( 1 + theta2*x1 + theta3*x2 + theta4*x3 )
}

ini.val8 &lt;- c(35, 0.1, 0.05, 0.2)
cons1    &lt;- fitIPEC( isom.fun, x=X, y=Y, ini.val=ini.val8, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
par8     &lt;- cons1$par 
Resul1   &lt;- derivIPEC( isom.fun, theta=par8, z=X[1, ], method="Richardson", 
                       method.args=list(eps=1e-4, d=0.11, 
                       zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) )
Resul1
##################################################################################################
</code></pre>

<hr>
<h2 id='fitIPEC'>
Nonlinear Fitting Function
</h2><span id='topic+fitIPEC'></span>

<h3>Description</h3>

<p>Estimates the parameters of a given parametric model 
using the <code><a href="stats.html#topic+optim">optim</a></code> function in package <span class="pkg">stats</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitIPEC( expr, x, y, ini.val, weights = NULL, control = list(), 
         fig.opt = TRUE, xlim = NULL, ylim = NULL, xlab = NULL, ylab = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitIPEC_+3A_expr">expr</code></td>
<td>
<p>A given parametric model</p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_x">x</code></td>
<td>
<p>A vector or matrix of observations of independent variable(s)</p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_y">y</code></td>
<td>
<p>A vector of observations of response variable</p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_ini.val">ini.val</code></td>
<td>
<p>A vector or list of initial values of model parameters</p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights to be used in the fitting process. 
<code>weights</code> should be NULL or a numeric vector. If non-NULL, weighted least squares is used with weights <code>weights</code>; 
otherwise ordinary least squares is used.</p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_control">control</code></td>
<td>
<p>A list of control parameters for using 
the <code><a href="stats.html#topic+optim">optim</a></code> function in package <span class="pkg">stats</span></p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_fig.opt">fig.opt</code></td>
<td>
<p>An option to determine whether to draw the fitted curve</p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_xlim">xlim</code></td>
<td>
<p>The shown range of the <em>x</em>-axis</p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_ylim">ylim</code></td>
<td>
<p>The shown range of the <em>y</em>-axis</p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_xlab">xlab</code></td>
<td>
<p>The label of the <em>x</em>-axis</p>
</td></tr>
<tr><td><code id="fitIPEC_+3A_ylab">ylab</code></td>
<td>
<p>The label of the <em>y</em>-axis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Nelder-Mead algorithm is the default in the <code><a href="stats.html#topic+optim">optim</a></code> function in package <span class="pkg">stats</span>. 
The user can accurately estimate the model parameters by setting smaller relative convergence 
tolerance and larger maximum number of iterations in the input argument of <code>control</code>, 
</p>
<p>e.g. <code>control=list(trace=FALSE, reltol=1e-20, maxit=50000)</code>, 
</p>
<p>at the expense of the running speed.
</p>
<p><code>ini.val</code> can be a vector or a list that has saved initial values for model parameters, 
</p>
<p>e.g. <code>y = beta0 + beta1 * x + beta2 * x^2</code>, 
</p>
<p><code>ini.val = list(beta0=seq(5, 15, len=2), beta1=seq(0.1, 1, len=9), 
beta2=seq(0.01, 0.05, len=5))</code>, which is similar to the usage of the 
input argument of <code>start</code> of <code><a href="stats.html#topic+nls">nls</a></code> in package <span class="pkg">stats</span>. 
</p>
<p>In the <code>weights</code> argument option, the default is <code>weights = NULL</code>. 
In that case, ordinary least squares is used. 
The residual sum of squares (RSS) between the observed and predicted <code class="reqn">y</code> values 
is minimized to estimate a model's parameters, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{RSS} = \sum_{i=1}^{n}\left(y_i-\hat{y}_i\right)^{2}</code>
</p>

<p>where <code class="reqn">y_i</code> and <code class="reqn">\hat{y}_i</code> represent the observed and predicted <code class="reqn">y</code> values, respectively; 
and <code class="reqn">n</code> represents the sample size. If <code>weights</code> is a numeric vector, 
the weighted residual sum of squares is minimized, i.e.,   
</p>
<p style="text-align: center;"><code class="reqn">\mbox{RSS} = \sum_{i=1}^{n}w_i\left(y_i-\hat{y}_i\right)^{2}</code>
</p>
 
<p>where <code class="reqn">w_i</code> is the <code class="reqn">i</code> elements of <code>weights</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>expr</code></td>
<td>
<p>The formula used</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>The vector of estimates of parameters</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>The residual sum of squares or the weighted residual sum of squares</p>
</td></tr>
<tr><td><code>R.sq</code></td>
<td>
<p>The coefficient of determination or the weighted coefficient of determination</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of data points, namely the sample size</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function can be applicable to a nonlinear parametric model with 
a single independent variable or with multiple independent variables. 
</p>
<p><code>R.sq</code> is only used to help users intuitively judge whether the fitted curve seriously 
deviates from the actual observations. However, it should NOT be used to decide which of 
several competing models is the most appropriate (Pages 44<code class="reqn">-</code>45 in Ratkowsky 1990). 
<code>RSS</code> and curvatures are among the suitable candidates to answer such a question.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Nelder, J.A. and Mead, R. (1965) A simplex method for function minimization. 
<em>Comput. J.</em> 7, 308<code class="reqn">-</code>313. <a href="https://doi.org/10.1093/comjnl/7.4.308">doi:10.1093/comjnl/7.4.308</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootIPEC">bootIPEC</a></code>, <code><a href="stats.html#topic+optim">optim</a></code> in package <span class="pkg">stats</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example 1 ###################################################################################
graphics.off()
# The velocity of the reaction (counts/min^2) under different substrate concentrations 
#   in parts per million (ppm) (Page 269 of Bates and Watts 1988)

x1 &lt;- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56, 1.10, 1.10)
y1 &lt;- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)

# Define the Michaelis-Menten model
MM &lt;- function(theta, x){
    theta[1]*x / ( theta[2] + x )    
}

res0 &lt;- fitIPEC(MM, x=x1, y=y1, ini.val=c(200, 0.05), 
                xlim=c(0, 1.5), ylim=c(0, 250), fig.opt=TRUE)
par1 &lt;- res0$par
par1
res0

# The input names of parameters will not affect the fitted results.
# We can use other names to replace theta1 and theta2.   
iv.list1 &lt;- list( theta1=seq(100, 300, by=50), theta2=seq(10, 100, by=10) )  
result0  &lt;- fitIPEC( MM, x=x1, y=y1, ini.val=iv.list1, xlim=c(0, 1.5), ylim=c(0, 250), 
                     fig.opt=FALSE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
param1   &lt;- result0$par
param1
##################################################################################################


#### Example 2 ###################################################################################
graphics.off()
# Development data of female pupae of cotton bollworm (Wu et al. 2009)
# References:
#   Ratkowsky, D.A. and Reddy, G.V.P. (2017) Empirical model with excellent statistical 
#       properties for describing temperature-dependent developmental rates of insects  
#       and mites. Ann. Entomol. Soc. Am. 110, 302-309.
#   Wu, K., Gong, P. and Ruan, Y. (2009) Estimating developmental rates of 
#       Helicoverpa armigera (Lepidoptera: Noctuidae) pupae at constant and
#       alternating temperature by nonlinear models. Acta Entomol. Sin. 52, 640-650.

# 'x2' is the vector of temperature (in degrees Celsius)
# 'D2' is the vector of developmental duration (in d)
# 'y2' is the vector of the square root of developmental rate (in 1/d)

x2 &lt;- seq(15, 37, by=1)
D2 &lt;- c(41.24,37.16,32.47,26.22,22.71,19.01,16.79,15.63,14.27,12.48,
       11.3,10.56,9.69,9.14,8.24,8.02,7.43,7.27,7.35,7.49,7.63,7.9,10.03)
y2 &lt;- 1/D2
y2 &lt;- sqrt( y2 )

ini.val1 &lt;- c(0.14, 30, 10, 40)

# Define the square root function of the Lobry-Rosso-Flandrois (LRF) model
sqrt.LRF &lt;- function(P, x){
  ropt &lt;- P[1]
  Topt &lt;- P[2]
  Tmin &lt;- P[3]
  Tmax &lt;- P[4]
  fun0 &lt;- function(z){
    z[z &lt; Tmin] &lt;- Tmin
    z[z &gt; Tmax] &lt;- Tmax
    return(z)
  }
  x &lt;- fun0(x)
  if (Tmin &gt;= Tmax | ropt &lt;= 0 | Topt &lt;= Tmin | Topt &gt;= Tmax) 
    temp &lt;- Inf
  if (Tmax &gt; Tmin &amp; ropt &gt; 0 &amp; Topt &gt; Tmin &amp; Topt &lt; Tmax){
    temp &lt;- sqrt( ropt*(x-Tmax)*(x-Tmin)^2/((Topt-Tmin)*((Topt-Tmin
      )*(x-Topt)-(Topt-Tmax)*(Topt+Tmin-2*x))) )  
  }
  return( temp )
}

myfun &lt;- sqrt.LRF
xlab1 &lt;- expression( paste("Temperature (", degree, "C)", sep="" ) )
ylab1 &lt;- expression( paste("Developmental rate"^{1/2}, 
                     " (", d^{"-1"}, ")", sep="") )
resu0 &lt;- fitIPEC( myfun, x=x2, y=y2, ini.val=ini.val1, xlim=NULL, 
                  ylim=NULL, xlab=xlab1, ylab=ylab1, fig.opt=TRUE, 
	          control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
par2  &lt;- resu0$par
par2
resu0
##################################################################################################


#### Example 3 ###################################################################################
graphics.off()
# Height growth data of four species of bamboo (Gramineae: Bambusoideae)
# Reference(s):
# Shi, P., Fan, M., Ratkowsky, D.A., Huang, J., Wu, H., Chen, L.,   
#     Fang, S. and Zhang, C. (2017) Comparison of two ontogenetic  
#     growth equations for animals and plants. Ecol. Model. 349, 1-10.

data(shoots)
# Choose a species
# 1: Phyllostachys iridescens; 2: Phyllostachys mannii; 
# 3: Pleioblastus maculatus; 4: Sinobambusa tootsik
# 'x3' is the vector of the investigation times from a specific starting time of growth
# 'y3' is the vector of the aboveground height values of bamboo shoots at 'x3' 
ind &lt;- 4
x3  &lt;- shoots$x[shoots$Code == ind]
y3  &lt;- shoots$y[shoots$Code == ind] 

# Define the beta sigmoid model (bsm)
bsm &lt;- function(P, x){
  P  &lt;- cbind(P)
  if(length(P) !=4 ) {stop(" The number of parameters should be 4!")}
  ropt &lt;- P[1]
  topt &lt;- P[2]
  tmin &lt;- P[3]
  tmax &lt;- P[4]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   
  ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-2*tmax)*(
        (x-tmin)/(topt-tmin))^((topt-tmin)/(tmax-topt))   
}

ini.val2 &lt;- c(40, 30, 5, 50)
xlab2    &lt;- "Time (d)"
ylab2    &lt;- "Height (cm)"

re0  &lt;- fitIPEC( bsm, x=x3, y=y3, ini.val=ini.val2, 
                 xlim=NULL, ylim=NULL, xlab=xlab2, ylab=ylab2, 
                 fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
par3 &lt;- re0$par
par3
##################################################################################################


#### Example 4 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References:
# Pages 56, 255 and 271 in Bates and Watts (1988)
# Carr, N.L. (1960) Kinetics of catalytic isomerization of n-pentane. Ind. Eng. Chem.
#     52, 391-396.   

data(isom)
Y &lt;- isom[,1]
X &lt;- isom[,2:4]

# There are three independent variables saved in matrix 'X' and one response variable (Y)
# The first column of 'X' is the vector of partial pressure of hydrogen
# The second column of 'X' is the vector of partial pressure of n-pentane
# The third column of 'X' is the vector of partial pressure of isopentane
# Y is the vector of experimental reaction rate (in 1/hr)

isom.fun &lt;- function(theta, x){
  x1     &lt;- x[,1]
  x2     &lt;- x[,2]
  x3     &lt;- x[,3]
  theta1 &lt;- theta[1]
  theta2 &lt;- theta[2]
  theta3 &lt;- theta[3]
  theta4 &lt;- theta[4]
  theta1*theta3*(x2-x3/1.632) / ( 1 + theta2*x1 + theta3*x2 + theta4*x3 )
}

ini.val8 &lt;- c(35, 0.1, 0.05, 0.2)
cons1    &lt;- fitIPEC( isom.fun, x=X, y=Y, ini.val=ini.val8, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
par8     &lt;- cons1$par 
##################################################################################################
</code></pre>

<hr>
<h2 id='isom'>
Data on Biochemical Oxygen Demand
</h2><span id='topic+isom'></span>

<h3>Description</h3>

<p>Data on the reaction rate of the catalytic isomerization of <em>n</em>-pentane to isopentane 
versus the partial pressures of hydrogen, <em>n</em>-pentane, and isopentane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(isom)
</code></pre>


<h3>Details</h3>

<p>There are four columns in the data set:
</p>
<p>'y' is the vector of experimental reaction rate (in 1/hr);
</p>
<p>'x1' is the vector of partial pressure of hydrogen;
</p>
<p>'x2' is the vector of partial pressure of <em>n</em>-pentane;
</p>
<p>'x3' is the vector of partial pressure of isopentane.
</p>


<h3>Note</h3>

<p>There were errors about the definitions of 'x2' and 'x3' in page 272 in Bates and Watts (1988). 
Here, we redefined them according to the paper of Carr (1960).
</p>


<h3>References</h3>

<p>Bates, D.M and Watts, D.G. (1988) <em>Nonlinear Regression Analysis and its Applications</em>. Wiley, New York. 
<a href="https://doi.org/10.1002/9780470316757">doi:10.1002/9780470316757</a>
</p>
<p>Carr, N.L. (1960) Kinetics of catalytic isomerization of <em>n</em>-pentane. <em>Ind. Eng. Chem.</em> 52, 391<code class="reqn">-</code>396. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(isom)
isom
Y &lt;- isom[,1]
X &lt;- isom[,2:4]
X
Y
</code></pre>

<hr>
<h2 id='leaves'>
Leaf Data of <em>Parrotia subaequalis</em> (Hamamelidaceae)
</h2><span id='topic+leaves'></span>

<h3>Description</h3>

<p>The data consist of the area, length and width of the leaves of 10 geographical populations of <em>P. subaequalis</em> 
collected in Southern China from July to September, 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(leaves)
</code></pre>


<h3>Details</h3>

<p>In the data set, there are four variables: <code>PopuCode</code>, <code>Length</code>, <code>Width</code> and <code>Area</code>. 
<code>PopuCode</code> is used to save the number codes of different geographical populations; 
<code>Length</code> is used to save the scanned leaf length data (cm);
<code>Width</code> is used to save the scanned leaf width data (cm);   
<code>Area</code> is used to save the scanned leaf area data (cm squared). 
</p>


<h3>References</h3>

<p>Wang, P., Ratkowsky, D.A., Xiao, X., Yu, X., Su, J., Zhang, L. and Shi, P. 
(2018) Taylor's power law for leaf bilateral symmetry. <em>Forests</em> 9, 500. <a href="https://doi.org/10.3390/f9080500">doi:10.3390/f9080500</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leaves)
attach(leaves)
# Choose a geographical population (see Table S1 in Wang et al. [2018] for details)
# 1: AJ; 2: HN; 3: HW; 4: HZ; 5: JD; 
# 6: JS; 7: SC; 8: TC; 9: TT; 10: TX
ind &lt;- 1
L   &lt;- Length[PopuCode == ind]
W   &lt;- Width[PopuCode == ind] 
A   &lt;- Area[PopuCode == ind]
x   &lt;- L*W
fit &lt;- lm(A ~ x-1)
summary(fit)

# Show the leaf areas of the 10 geographical populations
dev.new()
boxplot(Area~PopuCode, cex=1.5, cex.lab=1.5, cex.axis=1.5, 
        col="grey70", xlab=expression(bold("Population code")), 
        ylab=expression(bold(paste("Leaf area (cm", ""^{"2"}, ")", sep=""))),
        ylim=c(0, 50), xaxs="i", yaxs="i", las=1)
</code></pre>

<hr>
<h2 id='parinfo'>
Detailed Information of Estimated Model Parameters 
</h2><span id='topic+parinfo'></span>

<h3>Description</h3>

<p>Provides the estimates, standard errors, confidence intervals, 
Jacobian matrix, and the covariance matrix of model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parinfo(object, x, CI = 0.95, method = "Richardson", 
        method.args = list(eps = 1e-04, d = 0.11, 
        zero.tol = sqrt(.Machine$double.eps/7e-07), r = 6, 
        v = 2, show.details = FALSE), side = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parinfo_+3A_object">object</code></td>
<td>
<p>A fitted model object for which there exist the model expression(<code>expr</code>), the sample size (<code>sample.size</code> or <code>n</code>), estimate(s) of model parameter(s) (<code>par</code>), and residual sum of squares (<code>RSS</code>)</p>
</td></tr>
<tr><td><code id="parinfo_+3A_x">x</code></td>
<td>
<p>A vector or a matrix of observations of independent variable(s)</p>
</td></tr>
<tr><td><code id="parinfo_+3A_ci">CI</code></td>
<td>
<p>The confidence level(s) of the required interval(s)</p>
</td></tr>
<tr><td><code id="parinfo_+3A_method">method</code></td>
<td>
<p>It is the same as the input argument of <code>method</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="parinfo_+3A_method.args">method.args</code></td>
<td>
<p>It is the same as the input argument of <code>method.args</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="parinfo_+3A_side">side</code></td>
<td>
<p>It is the same as the input argument of <code>side</code> of the <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>object</code> argument cannot be a list. It is a fitted model object from using the <code><a href="#topic+fitIPEC">fitIPEC</a></code> function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p>The Jacobian matrix of model parameters at all the <code class="reqn">x</code> observations</p>
</td></tr>
<tr><td><code>partab</code></td>
<td>
<p>The estimates, standard errors and confidence intervals of model parameters</p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p>The covariance matrix of model parameters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When there are <code>sample.size</code> and <code>n</code> in <code>object</code> at the same time, the default of 
the sample size is <code>sample.size</code>, which is superior to <code>n</code>. 
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Bates, D.M and Watts, D.G. (1988) <em>Nonlinear Regression Analysis and its Applications</em>. Wiley, New York. <a href="https://doi.org/10.1002/9780470316757">doi:10.1002/9780470316757</a>
</p>
<p>Ratkowsky, D.A. (1983) <em>Nonlinear Regression Modeling: A Unified Practical Approach</em>. Marcel Dekker, New York.
</p>
<p>Ratkowsky, D.A. (1990) <em>Handbook of Nonlinear Regression Models</em>, Marcel Dekker, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biasIPEC">biasIPEC</a></code>, <code><a href="#topic+confcurves">confcurves</a></code>, <code><a href="#topic+curvIPEC">curvIPEC</a></code>, <code><a href="#topic+skewIPEC">skewIPEC</a></code>, 
<code><a href="numDeriv.html#topic+hessian">hessian</a></code> in package <span class="pkg">numDeriv</span>, 
<code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> in package <span class="pkg">numDeriv</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example 1 ###################################################################################
# Weight of cut grass data (Pattinson 1981)
# References:
#   Clarke, G.P.Y. (1987) Approximate confidence limits for a parameter function in nonlinear 
#       regression. J. Am. Stat. Assoc. 82, 221-230.
#   Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? 
#       New diagnostic and inference tools in the NLIN Procedure. Paper SAS384-2014.
#       http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf
#   Pattinson, N.B. (1981) Dry Matter Intake: An Estimate of the Animal
#       Response to Herbage on Offer. unpublished M.Sc. thesis, University
#       of Natal, Pietermaritzburg, South Africa, Department of Grassland Science.

# 'x4' is the vector of weeks after commencement of grazing in a pasture
# 'y4' is the vector of weight of cut grass from 10 randomly sited quadrants

x4 &lt;- 1:13
y4 &lt;- c(3.183, 3.059, 2.871, 2.622, 2.541, 2.184, 
        2.110, 2.075, 2.018, 1.903, 1.770, 1.762, 1.550)

# Define the first case of Mitscherlich equation
MitA &lt;- function(P1, x){
    P1[3] + P1[2]*exp(P1[1]*x)
}

# Define the second case of Mitscherlich equation
MitB &lt;- function(P2, x){
    log( P2[3] ) + exp(P2[2] + P2[1]*x)
}

# Define the third case of Mitscherlich equation
MitC &lt;- function(P3, x, x1=1, x2=13){
    theta1 &lt;- P3[1]
    beta2  &lt;- P3[2]
    beta3  &lt;- P3[3]
    theta2 &lt;- (beta3 - beta2)/(exp(theta1*x2)-exp(theta1*x1))
    theta3 &lt;- beta2/(1-exp(theta1*(x1-x2))) - beta3/(exp(theta1*(x2-x1))-1)
    theta3 + theta2*exp(theta1*x)
}

ini.val3 &lt;- c(-0.1, 2.5, 1)
r1       &lt;- fitIPEC( MitA, x=x4, y=y4, ini.val=ini.val3, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
parA     &lt;- r1$par
parA
result1  &lt;- parinfo(r1, x=x4, CI=0.95)
result1

ini.val4 &lt;- c(-0.10, 0.90, 2.5)
R0       &lt;- fitIPEC( MitB, x=x4, y=y4, ini.val=ini.val4, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
parB     &lt;- R0$par
parB
result2  &lt;- parinfo(R0, x=x4, CI=0.95)
result2

ini.val6 &lt;- c(-0.15, 2.52, 1.09)
RES0     &lt;- fitIPEC( MitC, x=x4, y=y4, ini.val=ini.val6, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(trace=FALSE, 
                     reltol=1e-20, maxit=50000) )
parC     &lt;- RES0$par
parC
result3  &lt;- parinfo(RES0, x=x4, CI=0.95)
result3
##################################################################################################


#### Example 2 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References:
# Pages 56, 255 and 271 in Bates and Watts (1988)
# Carr, N.L. (1960) Kinetics of catalytic isomerization of n-pentane. Ind. Eng. Chem.
#     52, 391-396.   

data(isom)
Y &lt;- isom[,1]
X &lt;- isom[,2:4]

# There are three independent variables saved in matrix 'X' and one response variable (Y)
# The first column of 'X' is the vector of partial pressure of hydrogen
# The second column of 'X' is the vector of partial pressure of n-pentane
# The third column of 'X' is the vector of partial pressure of isopentane
# Y is the vector of experimental reaction rate (in 1/hr)

isom.fun &lt;- function(theta, x){
  x1     &lt;- x[,1]
  x2     &lt;- x[,2]
  x3     &lt;- x[,3]
  theta1 &lt;- theta[1]
  theta2 &lt;- theta[2]
  theta3 &lt;- theta[3]
  theta4 &lt;- theta[4]
  theta1*theta3*(x2-x3/1.632) / ( 1 + theta2*x1 + theta3*x2 + theta4*x3 )
}

ini.val8 &lt;- c(35, 0.1, 0.05, 0.2)
cons1    &lt;- fitIPEC( isom.fun, x=X, y=Y, ini.val=ini.val8, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
par8     &lt;- cons1$par 
result2  &lt;- parinfo(cons1, x=X, CI=0.95)
result2
##################################################################################################

graphics.off()
</code></pre>

<hr>
<h2 id='shoots'>
Height Growth Data of Bamboo Shoots
</h2><span id='topic+shoots'></span>

<h3>Description</h3>

<p>The height growth data of four species of bamboo at the Nanjing Forestry University campus in 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shoots)
</code></pre>


<h3>Details</h3>

<p>In the data set, there are four variables: <code>Code</code>, <code>LatinName</code>, <code>x</code> and <code>y</code>. 
<code>Code</code> is used to save the number codes of different bamboo species; 
<code>LatinName</code> is used to save the Latin names of different bamboo species; 
<code>x</code> is used to save the investigation times (d) from a specific starting time of growth, 
and every bamboo has a different starting time of growth;  
<code>y</code> is used to save the measured aboveground height values (cm).
</p>
<p><code>Code = 1</code> represents <em>Phyllostachys iridescens</em>, and the starting time (namely <code>x = 0</code>) was defined as 12:00, 3rd April, 2016; 
</p>
<p><code>Code = 2</code> represents <em>Phyllostachys mannii</em>, and the starting time (namely <code>x = 0</code>) was defined as 12:00, 4th April, 2016; 
</p>
<p><code>Code = 3</code> represents <em>Pleioblastus maculatus</em>, and the starting time (namely <code>x = 0</code>) was defined as 12:00, 29th April, 2016; 
</p>
<p><code>Code = 4</code> represents <em>Sinobambusa tootsik</em>, and the starting time (namely <code>x = 0</code>) was defined as 12:00, 18th April, 2016.
</p>


<h3>References</h3>

<p>Shi, P., Fan, M., Ratkowsky, D.A., Huang, J., Wu, H., Chen, L., Fang, S. and 
Zhang, C. (2017) Comparison of two ontogenetic growth equations for animals and plants. 
<em>Ecol. Model.</em> 349, 1<code class="reqn">-</code>10. <a href="https://doi.org/10.1016/j.ecolmodel.2017.01.012">doi:10.1016/j.ecolmodel.2017.01.012</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoots)
# Choose a species
# 1: Phyllostachys iridescens; 2: Phyllostachys mannii; 
# 3: Pleioblastus maculatus; 4: Sinobambusa tootsik.
ind &lt;- 4
x3  &lt;- shoots$x[shoots$Code == ind]
y3  &lt;- shoots$y[shoots$Code == ind] 
dev.new()
plot(x3, y3, cex=1.5, cex.lab=1.5, cex.axis=1.5, xlab="Time (d)", ylab="Height (cm)")
</code></pre>

<hr>
<h2 id='skewIPEC'>
Skewness Calculation Function
</h2><span id='topic+skewIPEC'></span>

<h3>Description</h3>

<p>Calculates the skewness in the estimates of the parameters of a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewIPEC( expr, theta, x, y, tol = sqrt(.Machine$double.eps), method = "Richardson", 
              method.args = list(eps = 1e-04, d = 0.11, 
              zero.tol = sqrt(.Machine$double.eps/7e-07), r = 6, v = 2, 
              show.details = FALSE), side = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewIPEC_+3A_expr">expr</code></td>
<td>
<p>A given parametric model</p>
</td></tr>
<tr><td><code id="skewIPEC_+3A_theta">theta</code></td>
<td>
<p>A vector of parameters of the model</p>
</td></tr>
<tr><td><code id="skewIPEC_+3A_x">x</code></td>
<td>
<p>A vector or matrix of observations of independent variable(s)</p>
</td></tr>
<tr><td><code id="skewIPEC_+3A_y">y</code></td>
<td>
<p>A vector of observations of response variable</p>
</td></tr>
<tr><td><code id="skewIPEC_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of a matrix for calculating its inverse. 
See the input argument of <code>tol</code> of the <code><a href="MASS.html#topic+ginv">ginv</a></code> function in package <span class="pkg">MASS</span> </p>
</td></tr>
<tr><td><code id="skewIPEC_+3A_method">method</code></td>
<td>
<p>It is the same as the input argument of <code>method</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="skewIPEC_+3A_method.args">method.args</code></td>
<td>
<p>It is the same as the input argument of <code>method.args</code> of the <code><a href="numDeriv.html#topic+hessian">hessian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
<tr><td><code id="skewIPEC_+3A_side">side</code></td>
<td>
<p>It is the same as the input argument of <code>side</code> of the <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> function in package <span class="pkg">numDeriv</span></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The defined model should have two input arguments: a parameter vector and an independent variable vector or matrix, 
e.g. <code>myfun &lt;- function(P, x){...}</code>, where <code>P</code> represents the parameter vector and <code>x</code> represents the independent variable vector or matrix. 
</p>
<p>Let <code class="reqn">|g_{1i}|</code> be a measure of the skewness of the estimate of the <em>i</em>-th parameter. If <code class="reqn">|g_{1i}| &lt;</code> <b>0.1</b>, 
the estimator <code class="reqn">\hat \theta_i</code> of parameter <code class="reqn">\theta_i</code> is very close-to-linear in behavior; 
if <b>0.1</b> <code class="reqn">\le</code> <code class="reqn">|g_{1i}| &lt;</code> <b>0.25</b>, the estimator is reasonably close-to-linear; if <code class="reqn">|g_{1i}|</code> <code class="reqn">\ge</code> <b>0.25</b>, 
the skewness is very apparent; if <code class="reqn">|g_{1i}| &gt;</code> <b>1</b>, the estimator is considerably nonlinear in behavior (Pages 27-28 in Ratkowsky 1990).
</p>


<h3>Value</h3>

<table>
<tr><td><code>skewness</code></td>
<td>
<p>The skewness</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The current function can be applicable to nonlinear models with multiple independent variables.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Hougaard, P. (1985) The appropriateness of the asymptotic distribution in a nonlinear regression model in relation to curvature. 
<em>J. R. Statist. Soc., Ser. B</em> 47, 103<code class="reqn">-</code>114.
</p>
<p>Ratkowsky, D.A. (1990) <em>Handbook of Nonlinear Regression Models</em>, Marcel Dekker, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivIPEC">derivIPEC</a></code>, <code><a href="numDeriv.html#topic+hessian">hessian</a></code> 
in package <span class="pkg">numDeriv</span>, <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> in package <span class="pkg">numDeriv</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example 1 #################################################################################
# The velocity of the reaction (counts/min^2) under different substrate concentrations 
#   in parts per million (ppm) (Page 269 of Bates and Watts 1988)
x1 &lt;- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56, 1.10, 1.10)
y1 &lt;- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)

# Define the Michaelis-Menten (MM) model
MM &lt;- function(theta, x){
    theta[1]*x / ( theta[2] + x )    
}

par1 &lt;- c(212.68490865, 0.06412421)
res5 &lt;- skewIPEC( MM, theta=par1, x=x1, y=y1, tol= 1e-20 )
res5
#################################################################################################


#### Example 2 ##################################################################################
# Development data of female pupae of cotton bollworm (Wu et al. 2009)
# References:
#   Ratkowsky, D.A. and Reddy, G.V.P. (2017) Empirical model with excellent statistical 
#       properties for describing temperature-dependent developmental rates of insects  
#       and mites. Ann. Entomol. Soc. Am. 110, 302-309.
#   Wu, K., Gong, P. and Ruan, Y. (2009) Estimating developmental rates of 
#       Helicoverpa armigera (Lepidoptera: Noctuidae) pupae at constant and
#       alternating temperature by nonlinear models. Acta Entomol. Sin. 52, 640-650.

# 'x2' is the vector of temperature (in degrees Celsius)
# 'D2' is the vector of developmental duration (in d)
# 'y2' is the vector of the square root of developmental rate (in 1/d)

x2 &lt;- seq(15, 37, by=1)
D2 &lt;- c(41.24,37.16,32.47,26.22,22.71,19.01,16.79,15.63,14.27,12.48,
       11.3,10.56,9.69,9.14,8.24,8.02,7.43,7.27,7.35,7.49,7.63,7.9,10.03)
y2 &lt;- 1/D2
y2 &lt;- sqrt( y2 )

# Define the square root function of the Lobry-Rosso-Flandrois (LRF) model
sqrt.LRF &lt;- function(P, x){
  ropt &lt;- P[1]
  Topt &lt;- P[2]
  Tmin &lt;- P[3]
  Tmax &lt;- P[4]
  fun0 &lt;- function(z){
    z[z &lt; Tmin] &lt;- Tmin
    z[z &gt; Tmax] &lt;- Tmax
    return(z)
  }
  x &lt;- fun0(x)
  if (Tmin &gt;= Tmax | ropt &lt;= 0 | Topt &lt;= Tmin | Topt &gt;= Tmax) 
    temp &lt;- Inf
  if (Tmax &gt; Tmin &amp; ropt &gt; 0 &amp; Topt &gt; Tmin &amp; Topt &lt; Tmax){
    temp &lt;- sqrt( ropt*(x-Tmax)*(x-Tmin)^2/((Topt-Tmin)*((Topt-Tmin
      )*(x-Topt)-(Topt-Tmax)*(Topt+Tmin-2*x))) )  
  }
  return( temp )
}

myfun &lt;- sqrt.LRF
par2  &lt;- c(0.1382926, 33.4575663, 5.5841244, 38.8282021)

# To calculate bias
resu5 &lt;- skewIPEC( myfun, theta=par2, x=x2, y=y2, tol= 1e-20 )
resu5
#################################################################################################


#### Example 3 ##################################################################################
# Weight of cut grass data (Pattinson 1981)
# References:
#   Clarke, G.P.Y. (1987) Approximate confidence limits for a parameter function in nonlinear 
#       regression. J. Am. Stat. Assoc. 82, 221-230.
#   Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? 
#       New diagnostic and inference tools in the NLIN Procedure. Paper SAS384-2014.
#       http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf
#   Pattinson, N.B. (1981) Dry Matter Intake: An Estimate of the Animal
#       Response to Herbage on Offer. unpublished M.Sc. thesis, University
#       of Natal, Pietermaritzburg, South Africa, Department of Grassland Science.

# 'x4' is the vector of weeks after commencement of grazing in a pasture
# 'y4' is the vector of weight of cut grass from 10 randomly sited quadrants

x4 &lt;- 1:13
y4 &lt;- c(3.183, 3.059, 2.871, 2.622, 2.541, 2.184, 2.110, 2.075, 2.018, 1.903, 1.770, 1.762, 1.550)

# Define the first case of Mitscherlich equation
MitA &lt;- function(P1, x){
    P1[3] + P1[2]*exp(P1[1]*x)
}

# Define the second case of Mitscherlich equation
MitB &lt;- function(P2, x){
    log( P2[3] ) + exp(P2[2] + P2[1]*x)
}

# Define the third case of Mitscherlich equation
MitC &lt;- function(P3, x, x1=1, x2=13){
    theta1 &lt;- P3[1]
    beta2  &lt;- P3[2]
    beta3  &lt;- P3[3]
    theta2 &lt;- (beta3 - beta2)/(exp(theta1*x2)-exp(theta1*x1))
    theta3 &lt;- beta2/(1-exp(theta1*(x1-x2))) - beta3/(exp(theta1*(x2-x1))-1)
    theta3 + theta2*exp(theta1*x)
}

ini.val3 &lt;- c(-0.1, 2.5, 1)
r0       &lt;- fitIPEC( MitA, x=x4, y=y4, ini.val=ini.val3, xlim=NULL, ylim=NULL,
                     fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
parA     &lt;- r0$par
parA
r5       &lt;- skewIPEC(MitA, theta=parA, x=x4, y=y4, tol=1e-20) 
r5

ini.val4 &lt;- c(exp(-0.1), log(2.5), 1)
R0       &lt;- fitIPEC( MitB, x=x4, y=y4, ini.val=ini.val3, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
parB     &lt;- R0$par
parB
R5       &lt;- skewIPEC( MitB, theta=parB, x=x4, y=y4, tol=1e-20 ) 
R5

ini.val6 &lt;- c(-0.15, 2.52, 1.09)
RES0     &lt;- fitIPEC( MitC, x=x4, y=y4, ini.val=ini.val6, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
parC     &lt;- RES0$par
parC
RES5     &lt;- skewIPEC( MitC, theta=parC, x=x4, y=y4, tol=1e-20 ) 
RES5
#################################################################################################


#### Example 4 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References
# Pages 56, 255 and 271 in Bates and Watts (1988)
# Carr, N.L. (1960) Kinetics of catalytic isomerization of n-pentane. Ind. Eng. Chem.
#     52, 391-396.   

data(isom)
Y &lt;- isom[,1]
X &lt;- isom[,2:4]

# There are three independent variables saved in matrix 'X' and one response variable (Y)
# The first column of 'X' is the vector of partial pressure of hydrogen
# The second column of 'X' is the vector of partial pressure of n-pentane
# The third column of 'X' is the vector of partial pressure of isopentane
# Y is the vector of experimental reaction rate (in 1/hr)

isom.fun &lt;- function(theta, x){
  x1     &lt;- x[,1]
  x2     &lt;- x[,2]
  x3     &lt;- x[,3]
  theta1 &lt;- theta[1]
  theta2 &lt;- theta[2]
  theta3 &lt;- theta[3]
  theta4 &lt;- theta[4]
  theta1*theta3*(x2-x3/1.632) / ( 1 + theta2*x1 + theta3*x2 + theta4*x3 )
}

par8  &lt;- c(35.92831619, 0.07084811, 0.03772270, 0.16718384) 
cons5 &lt;- skewIPEC( isom.fun, theta=par8, x=X, y=Y, tol= 1e-20 )
cons5
#################################################################################################
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
