<!DOCTYPE html><html><head><title>Help for package ghypernet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ghypernet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adj_karate'><p>Zachary's Karate Club graph</p></a></li>
<li><a href='#adj2el'><p>Maps adjacency matrix to edgelist</p></a></li>
<li><a href='#as.ghype'><p>Map list to ghype object</p></a></li>
<li><a href='#bccm'><p>Fitting bccm models</p></a></li>
<li><a href='#BootstrapProperty'><p>BootstrapProperty computes igraph analytics function on ensemble</p></a></li>
<li><a href='#checkGraphtype'><p>Check graph input type (for whether it's a graph or a edgelist).</p></a></li>
<li><a href='#coef.nrm'><p>Extraction method for coefficients of models of class <code>'nrm'</code>.</p></a></li>
<li><a href='#compute_xi'><p>Auxiliary function. Computes combinatorial matrix.</p></a></li>
<li><a href='#conf.test'><p>Test regular (gnp) vs configuration model</p></a></li>
<li><a href='#contacts.adj'><p>Highschool contact network adjacency matrix</p></a></li>
<li><a href='#cospons_mat'><p>Swiss MPs network adjacency matrix</p></a></li>
<li><a href='#coxsnellR2'><p>Computes Cox and Snell pseudo R-squared for nrm models.</p></a></li>
<li><a href='#create_predictors'><p>Create a nrmpredictor object from passed argument</p></a></li>
<li><a href='#create_predictors.list'><p>Create a nrmpredictor object from list</p></a></li>
<li><a href='#CreateIgGraphs'><p>Convert a list of adjacency matrices to a list of igraph graphs.</p></a></li>
<li><a href='#dt'><p>Swiss MPs attribute data frame.</p></a></li>
<li><a href='#dtcommittee'><p>Swiss MPs committee affiliation data frame.</p></a></li>
<li><a href='#el2adj'><p>Maps edgelist to adjacency matrix</p></a></li>
<li><a href='#extract.nrm.cluster'><p>Extract details from statistical models for table construction. The function has methods for a range of statistical models.</p></a></li>
<li><a href='#FitOmega'><p>Fit propensity matrix for full model</p></a></li>
<li><a href='#get_zero_dummy'><p>Create a dummy variable to encode zero values of another variable.</p></a></li>
<li><a href='#ghype'><p>Fitting gHypEG models</p></a></li>
<li><a href='#gof.test'><p>Perform a goodness-of-fit test</p></a></li>
<li><a href='#highschool.multiplex'><p>Highschool contact network multiplex representation</p></a></li>
<li><a href='#highschool.predictors'><p>Highschool contact network predictors</p></a></li>
<li><a href='#homophily_stat'><p>Calculate homophily in multi-edge graphs.</p></a></li>
<li><a href='#isNetwork'><p>Test null model vs full ghype.</p></a></li>
<li><a href='#JnBlock'><p>Fisher Information matrix for estimators in block models.</p></a></li>
<li><a href='#linkSignificance'><p>Estimate statistical deviations from ghype model</p></a></li>
<li><a href='#logl'><p>General method to compute log-likelihood for ghype models.</p></a></li>
<li><a href='#logLik.ghype'><p>Extract Log-Likelihood</p></a></li>
<li><a href='#loglratio'><p>Compute log-likelihood ratio for ghype models.</p></a></li>
<li><a href='#lr.test'><p>Perform likelihood ratio test between two ghype models.</p></a></li>
<li><a href='#mat2vec.ix'><p>Auxiliary function, gives mask for matrix for directed,</p>
undirected etc.</a></li>
<li><a href='#mcfaddenR2'><p>Computes Mc Fadden pseudo R-squared.</p></a></li>
<li><a href='#nr.ci'><p>Confidence intervals for nrm models.</p></a></li>
<li><a href='#nr.significance'><p>Computes the significance of more complex model against a simpler model by</p>
means of a likelihood ratio test.</a></li>
<li><a href='#nrm'><p>Fitting gHypEG regression models for multi-edge networks.</p></a></li>
<li><a href='#nrmChoose'><p>Selects the best set of predictors among the given sets by means of AIC.</p></a></li>
<li><a href='#nrmSelection'><p>Perform AIC forward selection for nrm.</p></a></li>
<li><a href='#onlinesim_mat'><p>Swiss MPs committee similarity matrix.</p></a></li>
<li><a href='#predict.nrm'><p>Method to predict the expected values of a nrm model</p></a></li>
<li><a href='#reciprocity_stat'><p>Calculate weighted reciprocity change statistics for multi-edge graphs.</p></a></li>
<li><a href='#regularm'><p>Fit the gnm model</p></a></li>
<li><a href='#residuals.nrm'><p>Method to compute residuals of nrm models</p></a></li>
<li><a href='#rghype'><p>Generate random realisations from ghype model.</p></a></li>
<li><a href='#RMSE'><p>Computes the Root Mean Squared Error</p></a></li>
<li><a href='#RMSLE'><p>Computes the Root Mean Squared Logged Error</p></a></li>
<li><a href='#scm'><p>Fit the Soft-Configuration Model</p></a></li>
<li><a href='#sharedPartner_stat'><p>Calculate (un-)weighted shared partner change statistics for multi-edge graphs.</p></a></li>
<li><a href='#summary.nrm'><p>Summary method for elements of class <code>'nrm'</code>.</p></a></li>
<li><a href='#summary.nrm_selection'><p>Summary method for elements of class <code>'nrm_selection'</code>.</p></a></li>
<li><a href='#vec2mat'><p>Auxiliary function, produces matrix from vector</p></a></li>
<li><a href='#vertexlabels'><p>Zachary's Karate Club vertex faction assignment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit and Simulate Generalised Hypergeometric Ensembles of Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-13</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ghyper.net">https://ghyper.net</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for model fitting and selection of generalised hypergeometric ensembles of random graphs (gHypEG).
    To learn how to use it, check the vignettes for a quick tutorial.
    Please reference its use as Casiraghi, G., Nanumyan, V. (2019) &lt;<a href="https://doi.org/10.5281%2Fzenodo.2555300">doi:10.5281/zenodo.2555300</a>&gt;
    together with those relevant references from the one listed below.
    The package is based on the research developed at the Chair of Systems Design, ETH Zurich.
    Casiraghi, G., Nanumyan, V., Scholtes, I., Schweitzer, F. (2016) &lt;<a href="https://arxiv.org/abs/1607.02441">arXiv:1607.02441</a>&gt;.
    Casiraghi, G., Nanumyan, V., Scholtes, I., Schweitzer, F. (2017) &lt;<a href="https://doi.org/10.1007%2F978-3-319-67256-4_11">doi:10.1007/978-3-319-67256-4_11</a>&gt;.
    Casiraghi, G., (2017) &lt;<a href="https://arxiv.org/abs/1702.02048">arXiv:1702.02048</a>&gt;
    Brandenberger, L., Casiraghi, G., Nanumyan, V., Schweitzer, F. (2019) &lt;<a href="https://doi.org/10.1145%2F3341161.3342926">doi:10.1145/3341161.3342926</a>&gt;
    Casiraghi, G. (2019) &lt;<a href="https://doi.org/10.1007%2Fs41109-019-0241-1">doi:10.1007/s41109-019-0241-1</a>&gt;.
    Casiraghi, G., Nanumyan, V. (2021) &lt;<a href="https://doi.org/10.1038%2Fs41598-021-92519-y">doi:10.1038/s41598-021-92519-y</a>&gt;.
    Casiraghi, G. (2021) &lt;<a href="https://doi.org/10.1088%2F2632-072X%2Fac0493">doi:10.1088/2632-072X/ac0493</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>pbmcapply, plyr, numbers, purrr, extraDistr, dplyr, rlang,
reshape2, rootSolve, methods, texreg</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiasedUrn, igraph, knitr, rmarkdown, ggplot2, ggraph,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-15 13:01:36 UTC; giona</td>
</tr>
<tr>
<td>Author:</td>
<td>Giona Casiraghi <a href="https://orcid.org/0000-0003-0233-5747"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Vahan Nanumyan <a href="https://orcid.org/0000-0001-9054-3217"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Laurence Brandenberger [ctb],
  Giacomo Vaccario [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giona Casiraghi &lt;giona@ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-15 13:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='adj_karate'>Zachary's Karate Club graph</h2><span id='topic+adj_karate'></span>

<h3>Description</h3>

<p>Weighted adjacency matrix reporting interactions among
34 nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_karate
</code></pre>


<h3>Format</h3>

<p>a 34x34 matrix
</p>


<h3>Source</h3>

<p>package 'igraphdata'
</p>

<hr>
<h2 id='adj2el'>Maps adjacency matrix to edgelist</h2><span id='topic+adj2el'></span>

<h3>Description</h3>

<p>Maps adjacency matrix to edgelist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj2el(adj, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj2el_+3A_adj">adj</code></td>
<td>
<p>matrix, the adjacency matrix</p>
</td></tr>
<tr><td><code id="adj2el_+3A_directed">directed</code></td>
<td>
<p>boolean, is the graph directed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the edgelist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(contacts.adj)
el &lt;- adj2el(contacts.adj)

</code></pre>

<hr>
<h2 id='as.ghype'>Map list to ghype object</h2><span id='topic+as.ghype'></span><span id='topic+as.ghype.list'></span><span id='topic+as.ghype.nrm'></span>

<h3>Description</h3>

<p>Manually map a list to a ghype object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ghype(object, ...)

## S3 method for class 'list'
as.ghype(object, ...)

## S3 method for class 'nrm'
as.ghype(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ghype_+3A_object">object</code></td>
<td>
<p>list object to map to ghype.</p>
</td></tr>
<tr><td><code id="as.ghype_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to logl function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;ghype&quot;
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>list</code>: Map list to ghype
</p>
</li>
<li> <p><code>nrm</code>: Map list to ghype
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>ll &lt;- list(call = NULL, 'adj' = NULL, 'xi'= matrix(36,4,4), 'omega' = matrix(1,4,4), 
     'n' = 4, 'm' = 12, 'directed' = TRUE, 'selfloops' = TRUE,
     'regular' = TRUE, 'unbiased' = TRUE, 'df' = 1)
model &lt;- as.ghype(ll)

</code></pre>

<hr>
<h2 id='bccm'>Fitting bccm models</h2><span id='topic+bccm'></span><span id='topic+print.bccm'></span>

<h3>Description</h3>

<p>bccm is used to fit a block-constrained configuration model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bccm(
  adj,
  labels,
  directed = NULL,
  selfloops = NULL,
  directedBlocks = FALSE,
  homophily = FALSE,
  inBlockOnly = FALSE,
  xi = NULL,
  regular = FALSE,
  ...
)

## S3 method for class 'bccm'
print(x, suppressCall = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bccm_+3A_adj">adj</code></td>
<td>
<p>the adjacency matrix of the graph.</p>
</td></tr>
<tr><td><code id="bccm_+3A_labels">labels</code></td>
<td>
<p>vector or list. contains the vertex labels to generate the blocks in the bccm. In the case of bipartite graphs should be a list of two vectors, the first one with row labels and the second one with column labels.</p>
</td></tr>
<tr><td><code id="bccm_+3A_directed">directed</code></td>
<td>
<p>a boolean argument specifying whether the graph is directed or not.</p>
</td></tr>
<tr><td><code id="bccm_+3A_selfloops">selfloops</code></td>
<td>
<p>boolean argument specifying whether the model should incorporate selfloops.</p>
</td></tr>
<tr><td><code id="bccm_+3A_directedblocks">directedBlocks</code></td>
<td>
<p>boolean argument specifying whether the model should incorporate directed blocks. Default to FALSE.</p>
</td></tr>
<tr><td><code id="bccm_+3A_homophily">homophily</code></td>
<td>
<p>boolean argument specifying whether the model should fit only homophily blocks. Default to FALSE.</p>
</td></tr>
<tr><td><code id="bccm_+3A_inblockonly">inBlockOnly</code></td>
<td>
<p>boolean argument specifying whether the model should fit only blocks over the diagonal. Default to FALSE.</p>
</td></tr>
<tr><td><code id="bccm_+3A_xi">xi</code></td>
<td>
<p>an optional matrix defining the combinatorial matrix of the model.</p>
</td></tr>
<tr><td><code id="bccm_+3A_regular">regular</code></td>
<td>
<p>optional boolean, fit regular gnp model? if not specified chosen through lr.test.</p>
</td></tr>
<tr><td><code id="bccm_+3A_...">...</code></td>
<td>
<p>optional arguments to print or plot methods.</p>
</td></tr>
<tr><td><code id="bccm_+3A_x">x</code></td>
<td>
<p>object of class <code>'bccm'</code></p>
</td></tr>
<tr><td><code id="bccm_+3A_suppresscall">suppressCall</code></td>
<td>
<p>logical, indicating whether to print the call that generated x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bccm returns an object of class 'bccm' and 'ghype'.
'bccm' objects expand 'ghype' objects incorporating the parameter estimates.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print</code>: Print method for elements of class <code>'bccm'</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+bccm">bccm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("vertexlabels","adj_karate")
blockmodel &lt;- bccm(adj = adj_karate, labels = vertexlabels, directed = FALSE, selfloops = FALSE)

data('adj_karate')
data('vertexlabels')
bcc.model &lt;- bccm(adj_karate, labels=vertexlabels, directed=FALSE, selfloops=FALSE)
print(bcc.model)

</code></pre>

<hr>
<h2 id='BootstrapProperty'>BootstrapProperty computes igraph analytics function on ensemble</h2><span id='topic+BootstrapProperty'></span>

<h3>Description</h3>

<p>BootstrapProperty computes igraph analytics function on ensemble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootstrapProperty(
  graph,
  property,
  directed,
  selfloops,
  nsamples = 1000,
  xi = NULL,
  omega = NULL,
  model = NULL,
  m = NULL,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootstrapProperty_+3A_graph">graph</code></td>
<td>
<p>igraph graph</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_property">property</code></td>
<td>
<p>igraph function that can be applied to a graph</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_directed">directed</code></td>
<td>
<p>boolean</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_selfloops">selfloops</code></td>
<td>
<p>boolean</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_nsamples">nsamples</code></td>
<td>
<p>number of samples from ensemble. defaults to 1000</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_xi">xi</code></td>
<td>
<p>matrix, default null</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_omega">omega</code></td>
<td>
<p>matrix, default null</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_model">model</code></td>
<td>
<p>ghype model from which to extract xi and omega, default to null</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_m">m</code></td>
<td>
<p>int, number of edges to sample from model</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_seed">seed</code></td>
<td>
<p>seed</p>
</td></tr>
<tr><td><code id="BootstrapProperty_+3A_...">...</code></td>
<td>
<p>other parameters to pass to 'property'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of length nsamples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
data('adj_karate')
result &lt;- BootstrapProperty(adj_karate, page_rank, FALSE, FALSE, nsamples=10)


</code></pre>

<hr>
<h2 id='checkGraphtype'>Check graph input type (for whether it's a graph or a edgelist).</h2><span id='topic+checkGraphtype'></span>

<h3>Description</h3>

<p>Returns TRUE if the supplied object <code>graph</code> is an adjacency matrix. Returns FALSE if the provided object is an edgelist. The function checks whether the edgelist conforms to our standards (sender, target, edgecount).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkGraphtype(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkGraphtype_+3A_graph">graph</code></td>
<td>
<p>A graph adjacency matrix or an edgelist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE. Returns TRUE if the provided object <code>graph</code> is an adjacency matrix.
</p>

<hr>
<h2 id='coef.nrm'>Extraction method for coefficients of models of class <code>'nrm'</code>.</h2><span id='topic+coef.nrm'></span>

<h3>Description</h3>

<p>Extraction method for coefficients of models of class <code>'nrm'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nrm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.nrm_+3A_object">object</code></td>
<td>
<p>object of class <code>'nrm'</code>.</p>
</td></tr>
<tr><td><code id="coef.nrm_+3A_...">...</code></td>
<td>
<p>optional arguments to print methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coefficients of nrm model.
</p>


<h3>Author(s)</h3>

<p>Giona Casiraghi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nrm">nrm</a></code>
</p>

<hr>
<h2 id='compute_xi'>Auxiliary function. Computes combinatorial matrix.</h2><span id='topic+compute_xi'></span><span id='topic+ComputeXi'></span>

<h3>Description</h3>

<p>Combinatorial matrix computed according to soft
configuration model or 'regular' gnp model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_xi(adj, directed, selfloops, regular = FALSE)

ComputeXi(adj, directed, selfloops, regular = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_xi_+3A_adj">adj</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="compute_xi_+3A_directed">directed</code></td>
<td>
<p>boolean, whether the model is for a directed network</p>
</td></tr>
<tr><td><code id="compute_xi_+3A_selfloops">selfloops</code></td>
<td>
<p>boolean, whether the model contains selfloops</p>
</td></tr>
<tr><td><code id="compute_xi_+3A_regular">regular</code></td>
<td>
<p>boolean. Is the combinatorial matrix computed for configuration model or for regular gnp model? default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combinatorial matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('adj_karate')
xi = compute_xi(adj_karate, directed = FALSE, selfloops = FALSE)

</code></pre>

<hr>
<h2 id='conf.test'>Test regular (gnp) vs configuration model</h2><span id='topic+conf.test'></span>

<h3>Description</h3>

<p>Likelihood ratio test for gnp vs configuration model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conf.test(
  graph,
  directed,
  selfloops,
  nempirical = NULL,
  parallel = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conf.test_+3A_graph">graph</code></td>
<td>
<p>adjacency matrix or igraph graph</p>
</td></tr>
<tr><td><code id="conf.test_+3A_directed">directed</code></td>
<td>
<p>a boolean argument specifying whether object is directed or not.</p>
</td></tr>
<tr><td><code id="conf.test_+3A_selfloops">selfloops</code></td>
<td>
<p>a boolean argument specifying whether the model should incorporate selfloops.</p>
</td></tr>
<tr><td><code id="conf.test_+3A_nempirical">nempirical</code></td>
<td>
<p>optional, number of graphs to sample from null distribution for empirical distribution.</p>
</td></tr>
<tr><td><code id="conf.test_+3A_parallel">parallel</code></td>
<td>
<p>optional, number of cores to use or boolean for parallel computation.
If passed TRUE uses all cores-1, else uses the number of cores passed. If none passed
performed not in parallel.</p>
</td></tr>
<tr><td><code id="conf.test_+3A_seed">seed</code></td>
<td>
<p>optional integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value of test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("adj_karate")
conf.test(graph = adj_karate, directed = FALSE, selfloops = FALSE, seed=123)

</code></pre>

<hr>
<h2 id='contacts.adj'>Highschool contact network adjacency matrix</h2><span id='topic+contacts.adj'></span>

<h3>Description</h3>

<p>**contacts.adj**: contains the adjacency matrix of 327 x 327 highschool
students.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(highschool.predictors)
</code></pre>


<h3>Format</h3>

<p>327x327 adjacency matrix
</p>


<h3>Source</h3>

<p><a href="http://www.sociopatterns.org">http://www.sociopatterns.org</a>
</p>


<h3>References</h3>

<p>Casiraghi, G. Multiplex Network Regression: How do relations
drive interactions? 15 (2017).
</p>
<p>Mastrandrea, R., Fournet, J. &amp; Barrat, A. Contact patterns in a high school:
A comparison between data collected using wearable sensors, contact diaries
and friendship surveys. PLoS One 10, 1–26 (2015).
</p>

<hr>
<h2 id='cospons_mat'>Swiss MPs network adjacency matrix</h2><span id='topic+cospons_mat'></span>

<h3>Description</h3>

<p>**cospons_mat**: contains the adjacency matrix of 163 x 163 MPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cospons_mat)
</code></pre>


<h3>Format</h3>

<p>163x163 adjacency matrix
</p>

<hr>
<h2 id='coxsnellR2'>Computes Cox and Snell pseudo R-squared for nrm models.</h2><span id='topic+coxsnellR2'></span>

<h3>Description</h3>

<p>Computes Cox and Snell pseudo R-squared for nrm models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxsnellR2(mod0, mod1, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxsnellR2_+3A_mod0">mod0</code></td>
<td>
<p>nrm null model</p>
</td></tr>
<tr><td><code id="coxsnellR2_+3A_mod1">mod1</code></td>
<td>
<p>nrm alternative model</p>
</td></tr>
<tr><td><code id="coxsnellR2_+3A_m">m</code></td>
<td>
<p>number of edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cox and Snell pseudo R-squared
</p>


<h3>Author(s)</h3>

<p>GC
</p>

<hr>
<h2 id='create_predictors'>Create a nrmpredictor object from passed argument</h2><span id='topic+create_predictors'></span><span id='topic+createPredictors'></span>

<h3>Description</h3>

<p>Create a nrmpredictor object from passed argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_predictors(predictors, ...)

createPredictors(predictors, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_predictors_+3A_predictors">predictors</code></td>
<td>
<p>the dataframe or list of predictors for to apply nrm model selection</p>
</td></tr>
<tr><td><code id="create_predictors_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the different methods (currently disabled)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nested list of nrmpredictor class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('highschool.predictors')
predictors &lt;- create_predictors(highschool.predictors)

</code></pre>

<hr>
<h2 id='create_predictors.list'>Create a nrmpredictor object from list</h2><span id='topic+create_predictors.list'></span>

<h3>Description</h3>

<p>Create a nrmpredictor object from list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
create_predictors(predictors, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_predictors.list_+3A_predictors">predictors</code></td>
<td>
<p>the dataframe or list of predictors for to apply nrm model selection</p>
</td></tr>
<tr><td><code id="create_predictors.list_+3A_...">...</code></td>
<td>
<p>additional parameters used to creating the predictor object (currently disabled)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nested list of nrmpredictor class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('highschool.predictors')
predictors &lt;- create_predictors(highschool.predictors)

</code></pre>

<hr>
<h2 id='CreateIgGraphs'>Convert a list of adjacency matrices to a list of igraph graphs.</h2><span id='topic+CreateIgGraphs'></span>

<h3>Description</h3>

<p>Convert a list of adjacency matrices to a list of igraph graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateIgGraphs(adjlist, directed, selfloops, weighted = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateIgGraphs_+3A_adjlist">adjlist</code></td>
<td>
<p>a list of adjacency matrices</p>
</td></tr>
<tr><td><code id="CreateIgGraphs_+3A_directed">directed</code></td>
<td>
<p>a boolean argument specifying whether object is directed or not.</p>
</td></tr>
<tr><td><code id="CreateIgGraphs_+3A_selfloops">selfloops</code></td>
<td>
<p>a boolean argument specifying whether the model should incorporate selfloops.</p>
</td></tr>
<tr><td><code id="CreateIgGraphs_+3A_weighted">weighted</code></td>
<td>
<p>boolean, generate weighted graphs?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of igraph graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('adj_karate')
adj_list &lt;- list(adj_karate)
glist &lt;- CreateIgGraphs(adj_list, FALSE, FALSE)

</code></pre>

<hr>
<h2 id='dt'>Swiss MPs attribute data frame.</h2><span id='topic+dt'></span>

<h3>Description</h3>

<p>**dt**: contains different attributes of the 163 MPs, such as their names, 
their party affiliation (variable: *party*), their parliamentary group
affiliation (variable: *parlGroup*), the Canton (or state) they represent
(variable: *canton*), their gender  (variable: *gender*)
and date of birth  (variable: *birthdate*).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dt)
</code></pre>


<h3>Format</h3>

<p>163x8 data.frame
</p>

<hr>
<h2 id='dtcommittee'>Swiss MPs committee affiliation data frame.</h2><span id='topic+dtcommittee'></span>

<h3>Description</h3>

<p>**dtcommittee**: a list of committees each MP was part of during their stay in 
parliament
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dtcommittee)
</code></pre>


<h3>Format</h3>

<p>163x2 data.frame
</p>

<hr>
<h2 id='el2adj'>Maps edgelist to adjacency matrix</h2><span id='topic+el2adj'></span>

<h3>Description</h3>

<p>Maps edgelist to adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>el2adj(el, nodes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="el2adj_+3A_el">el</code></td>
<td>
<p>dataframe containing a (weighted) edgelist. Column 1 is the sender, column 2 is the receiver, column 3 the number of edges.</p>
</td></tr>
<tr><td><code id="el2adj_+3A_nodes">nodes</code></td>
<td>
<p>optional vector containing all node names in case disconnected nodes should be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the (weighted) adjacency matrix corresponding the edgelist passed
</p>

<hr>
<h2 id='extract.nrm.cluster'>Extract details from statistical models for table construction. The function has methods for a range of statistical models.</h2><span id='topic+extract.nrm.cluster'></span>

<h3>Description</h3>

<p>Extract details from statistical models for table construction. The function has methods for a range of statistical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.nrm.cluster(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.nrm.cluster_+3A_model">model</code></td>
<td>
<p>A statistical model object.</p>
</td></tr>
<tr><td><code id="extract.nrm.cluster_+3A_...">...</code></td>
<td>
<p>Custom parameters, which are handed over to subroutines. The arguments are usually passed to the summary function, but in some cases to other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a texreg object.
</p>


<h3>Author(s)</h3>

<p>L. Brandenberger, G. Casiraghi
</p>

<hr>
<h2 id='FitOmega'>Fit propensity matrix for full model</h2><span id='topic+FitOmega'></span>

<h3>Description</h3>

<p>(auxiliary function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitOmega(adj, xi, directed, selfloops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitOmega_+3A_adj">adj</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="FitOmega_+3A_xi">xi</code></td>
<td>
<p>combinatorial matrix</p>
</td></tr>
<tr><td><code id="FitOmega_+3A_directed">directed</code></td>
<td>
<p>boolean</p>
</td></tr>
<tr><td><code id="FitOmega_+3A_selfloops">selfloops</code></td>
<td>
<p>boolean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>propensity matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adj_karate)
xi &lt;- compute_xi(adj_karate, FALSE, FALSE)
FitOmega(adj_karate, xi, FALSE, FALSE)

</code></pre>

<hr>
<h2 id='get_zero_dummy'>Create a dummy variable to encode zero values of another variable.</h2><span id='topic+get_zero_dummy'></span>

<h3>Description</h3>

<p>Use this to substitute zero-values in your nrm values. Zero values in the predictors
are recognized in the gHypEG regression as structural zeroes. To ensure this
does not happen, please recode your zero-values in all your predictors,
ideally using a dummy variable fitting an optimal value for the zeroes.
This function takes a predictor that needs to be recoded and returns a list
containing two matrices. The first one contains the original predictor
recoded such that all zero values are 1 (and thus do not impact the model).
The second one consist of a matrix with 1 where the original predictor was
different from 0, and 'zero_values' where the original predictor was 0.
If 'zero_values' is not specified, it is fixed to e to simplify the interpretation
of the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_zero_dummy(dat, name = NULL, zero_values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_zero_dummy_+3A_dat">dat</code></td>
<td>
<p>matrix, the predictor for which the zero values should be recoded.</p>
</td></tr>
<tr><td><code id="get_zero_dummy_+3A_name">name</code></td>
<td>
<p>optional character, the name of the predictor to create a named list</p>
</td></tr>
<tr><td><code id="get_zero_dummy_+3A_zero_values">zero_values</code></td>
<td>
<p>optional numeric, the value to assign to the zero values of 'dat'
in the dummy variable. It defaults to e to simplify the interpretation of the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a possibly named list of two matrices. The first one is the recoded version of 'dat' where all zeroes
are changed to 1. The second is the dummy variable such that dummy[dat==0] &lt;- zero_values and 1
otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reciprocity_stat">reciprocity_stat</a></code> or <code><a href="#topic+sharedPartner_stat">sharedPartner_stat</a></code>
</p>

<hr>
<h2 id='ghype'>Fitting gHypEG models</h2><span id='topic+ghype'></span><span id='topic+ghype.matrix'></span><span id='topic+ghype.default'></span><span id='topic+ghype.igraph'></span><span id='topic+print.ghype'></span>

<h3>Description</h3>

<p>ghype is used to fit gHypEG models when the propensity matrix is known.
It can be used to estimate a null model (soft configuration model), or
the benchmark 'full-model', where the propensity matrix is fitted such
that the expected graph from the fitted model is the one passed to the
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghype(
  graph,
  directed,
  selfloops,
  xi = NULL,
  omega = NULL,
  unbiased = FALSE,
  regular = FALSE,
  ...
)

## S3 method for class 'matrix'
ghype(
  graph,
  directed,
  selfloops,
  xi = NULL,
  omega = NULL,
  unbiased = FALSE,
  regular = FALSE,
  ...
)

## Default S3 method:
ghype(
  graph,
  directed,
  selfloops,
  xi = NULL,
  omega = NULL,
  unbiased = FALSE,
  regular = FALSE,
  ...
)

## S3 method for class 'igraph'
ghype(
  graph,
  directed,
  selfloops,
  xi = NULL,
  omega = NULL,
  unbiased = FALSE,
  regular = FALSE,
  ...
)

## S3 method for class 'ghype'
print(x, suppressCall = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghype_+3A_graph">graph</code></td>
<td>
<p>either an adjacency matrix or an igraph graph.</p>
</td></tr>
<tr><td><code id="ghype_+3A_directed">directed</code></td>
<td>
<p>a boolean argument specifying whether graph is directed or not.</p>
</td></tr>
<tr><td><code id="ghype_+3A_selfloops">selfloops</code></td>
<td>
<p>a boolean argument specifying whether the model should incorporate selfloops.</p>
</td></tr>
<tr><td><code id="ghype_+3A_xi">xi</code></td>
<td>
<p>an optional matrix defining the combinatorial matrix of the model.</p>
</td></tr>
<tr><td><code id="ghype_+3A_omega">omega</code></td>
<td>
<p>an optional matrix defining the propensity matrix of the model.</p>
</td></tr>
<tr><td><code id="ghype_+3A_unbiased">unbiased</code></td>
<td>
<p>a boolean argument specifying whether to model the hypergeometric ensemble (no propensity), defaults to FALSE.</p>
</td></tr>
<tr><td><code id="ghype_+3A_regular">regular</code></td>
<td>
<p>a boolean argument specifying whether to model the 'gnp' ensemble (no xi), defaults to FALSE.</p>
</td></tr>
<tr><td><code id="ghype_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="ghype_+3A_x">x</code></td>
<td>
<p>ghype model</p>
</td></tr>
<tr><td><code id="ghype_+3A_suppresscall">suppressCall</code></td>
<td>
<p>boolean, suppress print of the call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ghype return an object of class &quot;ghype&quot;.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>matrix</code>: Fitting ghype models from an adjacency matrix
</p>
</li>
<li> <p><code>default</code>: Generating a ghype model from given xi and omega
</p>
</li>
<li> <p><code>igraph</code>: Fitting ghype models from an igraph graph
</p>
</li>
<li> <p><code>ghype</code>: Print method for ghype object.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data("adj_karate")
fullmodel &lt;- ghype(graph = adj_karate, directed = FALSE, selfloops = FALSE, unbiased = FALSE)

data('adj_karate')
model &lt;- scm(adj_karate, FALSE, FALSE)
print(model)

</code></pre>

<hr>
<h2 id='gof.test'>Perform a goodness-of-fit test</h2><span id='topic+gof.test'></span>

<h3>Description</h3>

<p>Perform a goodness-of-fit test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof.test(
  model,
  Beta = TRUE,
  nempirical = NULL,
  parallel = NULL,
  returnBeta = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof.test_+3A_model">model</code></td>
<td>
<p>ghype model to test</p>
</td></tr>
<tr><td><code id="gof.test_+3A_beta">Beta</code></td>
<td>
<p>boolean, whether to use empirical Beta distribution approximation. Default TRUE</p>
</td></tr>
<tr><td><code id="gof.test_+3A_nempirical">nempirical</code></td>
<td>
<p>optional scalar, number of replicates for empirical beta distribution.</p>
</td></tr>
<tr><td><code id="gof.test_+3A_parallel">parallel</code></td>
<td>
<p>optional, number of cores to use or boolean for parallel computation.
If passed TRUE uses all cores-1, else uses the number of cores passed. If none passed
performed not in parallel.</p>
</td></tr>
<tr><td><code id="gof.test_+3A_returnbeta">returnBeta</code></td>
<td>
<p>boolean, return estimated parameters of Beta distribution? Default FALSE.</p>
</td></tr>
<tr><td><code id="gof.test_+3A_seed">seed</code></td>
<td>
<p>scalar, seed for the empirical distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value of test. If returnBeta=TRUE returns the p-value together with the parameters
of the beta distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("adj_karate")
confmodel &lt;- scm(graph = adj_karate, directed = FALSE, selfloops = FALSE)
gof.test(model = confmodel, seed = 123)

</code></pre>

<hr>
<h2 id='highschool.multiplex'>Highschool contact network multiplex representation</h2><span id='topic+highschool.multiplex'></span>

<h3>Description</h3>

<p>**highschool.multiplex**: list containing the adjacency matrix of 327 x 327
highschool students, and the adjacency matrices corresponding to the 5
predictors used in Casiraghi2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(highschool.multiplex)
</code></pre>


<h3>Format</h3>

<p>6x327x327 list of adjacency matrices
</p>


<h3>Source</h3>

<p><a href="http://www.sociopatterns.org">http://www.sociopatterns.org</a>
</p>


<h3>References</h3>

<p>Casiraghi, G. Multiplex Network Regression: How do relations
drive interactions? 15 (2017).
</p>
<p>Mastrandrea, R., Fournet, J. &amp; Barrat, A. Contact patterns in a high
school: A comparison between data collected using wearable sensors, contact
diaries and friendship surveys. PLoS One 10, 1–26 (2015).
</p>

<hr>
<h2 id='highschool.predictors'>Highschool contact network predictors</h2><span id='topic+highschool.predictors'></span>

<h3>Description</h3>

<p>**highschool.predictors**: list containing the adjacency matrices
corresponding to the 5 predictors used in Casiraghi2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(highschool.predictors)
</code></pre>


<h3>Format</h3>

<p>5x327x327 list of adjacency matrices
</p>


<h3>Source</h3>

<p><a href="http://www.sociopatterns.org">http://www.sociopatterns.org</a>
</p>


<h3>References</h3>

<p>Casiraghi, G. Multiplex Network Regression: How do relations
drive interactions? 15 (2017).
</p>
<p>Mastrandrea, R., Fournet, J. &amp; Barrat, A. Contact patterns in a high
school: A comparison between data collected using wearable sensors, contact
diaries and friendship surveys. PLoS One 10, 1–26 (2015).
</p>

<hr>
<h2 id='homophily_stat'>Calculate homophily in multi-edge graphs.</h2><span id='topic+homophily_stat'></span>

<h3>Description</h3>

<p>The function calculates homophily matrices. If you supply a categorical
variable (factor, character), the function returns attribute matches for
dyads from the same group. If you supply a continuous variable (numeric,
integers), the function returns absolute difference effects for each dyad in
the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophily_stat(
  variable = variable,
  type = "categorical",
  nodes = nodes,
  these.categories.only = NULL,
  zero_values = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homophily_stat_+3A_variable">variable</code></td>
<td>
<p>A attribute variable. Can be categorical (attribute matches)
or continuous (absolute difference effects).</p>
</td></tr>
<tr><td><code id="homophily_stat_+3A_type">type</code></td>
<td>
<p>set to <code>categorical</code>. Can be set to <code>absdiff</code> instead.
If set to <code>categorical</code>, the homophily statistic calculates matches
between dyads from the same group (analogous to dummy variables measuring
attribute match between two nodes (=10) and attribute mismatch (=1)). If
set to <code>absdiff</code> it calculates the difference in values from variable
for each dyad in the graph.</p>
</td></tr>
<tr><td><code id="homophily_stat_+3A_nodes">nodes</code></td>
<td>
<p>optional character/factor vector. If an edgelist is provided, you
have to provide a list of unique identifiers of your nodes in the graph.
This is because in the edgelist, isolates are usually not recorded. If you
do not specify isolates in your nodes object, they are excluded from the
analysis (falsifies data).</p>
</td></tr>
<tr><td><code id="homophily_stat_+3A_these.categories.only">these.categories.only</code></td>
<td>
<p>optional vector specifying the categories to be
used, if only a subset of factor(variable) is needed.</p>
</td></tr>
<tr><td><code id="homophily_stat_+3A_zero_values">zero_values</code></td>
<td>
<p>optional numeric value. Use this to substitute zero-values
in your homophily change statistic matrix. Zero values in the predictors
are recognized in the gHypEG regression as structural zeroes. To ensure this
does not happen, please recode your zero-values in all your predictors,
ideally using a dummy variable fitting an optimal value for the zeroes.
Only useful with absdiff type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Homophily change statistic matrix.
</p>


<h3>Author(s)</h3>

<p>LB, GC
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reciprocity_stat">reciprocity_stat</a></code> or <code><a href="#topic+sharedPartner_stat">sharedPartner_stat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>homop_stat &lt;- homophily_stat(variable = vertexlabels, nodes = rownames(adj_karate))
nrm(w=list('homophily'= homop_stat), adj_karate, directed = FALSE, selfloops = FALSE)
</code></pre>

<hr>
<h2 id='isNetwork'>Test null model vs full ghype.</h2><span id='topic+isNetwork'></span>

<h3>Description</h3>

<p>isNetwork tests a graph for the SCM vs the full ghype model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNetwork(
  graph,
  directed,
  selfloops,
  Beta = TRUE,
  nempirical = NULL,
  parallel = FALSE,
  returnBeta = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNetwork_+3A_graph">graph</code></td>
<td>
<p>adjacency matrix or igraph graph</p>
</td></tr>
<tr><td><code id="isNetwork_+3A_directed">directed</code></td>
<td>
<p>a boolean argument specifying whether object is directed or not.</p>
</td></tr>
<tr><td><code id="isNetwork_+3A_selfloops">selfloops</code></td>
<td>
<p>a boolean argument specifying whether the model should incorporate selfloops.</p>
</td></tr>
<tr><td><code id="isNetwork_+3A_beta">Beta</code></td>
<td>
<p>boolean, use Beta test? default TRUE</p>
</td></tr>
<tr><td><code id="isNetwork_+3A_nempirical">nempirical</code></td>
<td>
<p>optional, number of graphs to sample from null distribution for empirical distribution.</p>
</td></tr>
<tr><td><code id="isNetwork_+3A_parallel">parallel</code></td>
<td>
<p>optional, number of cores to use or boolean for parallel computation.
If passed TRUE uses all cores-1, else uses the number of cores passed. If none passed
performed not in parallel.</p>
</td></tr>
<tr><td><code id="isNetwork_+3A_returnbeta">returnBeta</code></td>
<td>
<p>boolean, return estimated parameters of Beta distribution? Default FALSE.</p>
</td></tr>
<tr><td><code id="isNetwork_+3A_seed">seed</code></td>
<td>
<p>optional integer, seed for empirical lr.test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value of test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("adj_karate")
isNetwork(graph = adj_karate, directed = FALSE, selfloops = FALSE, seed=123)

</code></pre>

<hr>
<h2 id='JnBlock'>Fisher Information matrix for estimators in block models.</h2><span id='topic+JnBlock'></span>

<h3>Description</h3>

<p>Fisher Information matrix for estimators in block models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JnBlock(omegaBlocks, xiBlocks, mBlocks, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JnBlock_+3A_omegablocks">omegaBlocks</code></td>
<td>
<p>the block parameters (vector)</p>
</td></tr>
<tr><td><code id="JnBlock_+3A_xiblocks">xiBlocks</code></td>
<td>
<p>the xi-block (vector)</p>
</td></tr>
<tr><td><code id="JnBlock_+3A_mblocks">mBlocks</code></td>
<td>
<p>the adj-block (vector)</p>
</td></tr>
<tr><td><code id="JnBlock_+3A_m">m</code></td>
<td>
<p>the number of edges (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fisher Information matrix
</p>

<hr>
<h2 id='linkSignificance'>Estimate statistical deviations from ghype model</h2><span id='topic+linkSignificance'></span><span id='topic+link_significance'></span>

<h3>Description</h3>

<p>linkSignificance allows to estimate the statistical deviations of an observed
graph from a ghype model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkSignificance(
  graph,
  model,
  under = FALSE,
  log.p = FALSE,
  binomial.approximation = FALSE,
  give_pvals = FALSE
)

link_significance(
  graph,
  model,
  under = FALSE,
  log.p = FALSE,
  binomial.approximation = FALSE,
  give_pvals = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkSignificance_+3A_graph">graph</code></td>
<td>
<p>an adjacency matrix or a igraph object.</p>
</td></tr>
<tr><td><code id="linkSignificance_+3A_model">model</code></td>
<td>
<p>a ghype model</p>
</td></tr>
<tr><td><code id="linkSignificance_+3A_under">under</code></td>
<td>
<p>boolean, estimate under-represented deviations? Default FALSE.</p>
</td></tr>
<tr><td><code id="linkSignificance_+3A_log.p">log.p</code></td>
<td>
<p>boolean, return log values of probabilities</p>
</td></tr>
<tr><td><code id="linkSignificance_+3A_binomial.approximation">binomial.approximation</code></td>
<td>
<p>boolean, force binomial? default FALSE</p>
</td></tr>
<tr><td><code id="linkSignificance_+3A_give_pvals">give_pvals</code></td>
<td>
<p>boolean, return p-values for both under and over significance?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of probabilities with same size as adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("adj_karate")
fullmodel &lt;- ghype(graph = adj_karate, directed = FALSE, selfloops = FALSE)
link_significance(graph = adj_karate, model = fullmodel, under=FALSE)

</code></pre>

<hr>
<h2 id='logl'>General method to compute log-likelihood for ghype models.</h2><span id='topic+logl'></span><span id='topic+logl.ghype'></span><span id='topic+logl.matrix'></span>

<h3>Description</h3>

<p>General method to compute log-likelihood for ghype models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logl(
  object,
  xi = NULL,
  omega = NULL,
  directed = NULL,
  selfloops = NULL,
  adj = NULL,
  multinomial = NULL,
  ...
)

## S3 method for class 'ghype'
logl(
  object,
  xi = NULL,
  omega = NULL,
  directed = NULL,
  selfloops = NULL,
  adj = NULL,
  multinomial = NULL,
  ...
)

## S3 method for class 'matrix'
logl(
  object,
  xi = NULL,
  omega = NULL,
  directed = NULL,
  selfloops = NULL,
  adj = NULL,
  multinomial = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logl_+3A_object">object</code></td>
<td>
<p>either an adjacency matrix or ghype model If a ghype model is
passed, then 'xi', 'omega', 'directed', 'selfloops' are ignored If an
adjacency matrix is passed, then 'adj' is ignored</p>
</td></tr>
<tr><td><code id="logl_+3A_xi">xi</code></td>
<td>
<p>matrix, combinatorial matrix to build ghype model, considered only
if object is an adjacency matrix</p>
</td></tr>
<tr><td><code id="logl_+3A_omega">omega</code></td>
<td>
<p>matrix, propensity matrix to build ghype model, considered only
if object is an adjacency matrix</p>
</td></tr>
<tr><td><code id="logl_+3A_directed">directed</code></td>
<td>
<p>boolean, is ghype model directed? considered only if object
is an adjacency matrix</p>
</td></tr>
<tr><td><code id="logl_+3A_selfloops">selfloops</code></td>
<td>
<p>boolean, has ghype model selfloops? considered only if
object is an adjacency matrix</p>
</td></tr>
<tr><td><code id="logl_+3A_adj">adj</code></td>
<td>
<p>optional matrix, adjacency matrix of which to compute
log-likelihood, considered only if object is ghype model If adj is not
passed, and object is a ghype model, the log-likelihood is computed for the
original adjacency matrix stored in object.</p>
</td></tr>
<tr><td><code id="logl_+3A_multinomial">multinomial</code></td>
<td>
<p>optional boolean. Force multinomial approximation? If not
chosen, multinomial chosen for large graphs.</p>
</td></tr>
<tr><td><code id="logl_+3A_...">...</code></td>
<td>
<p>additional parameters passed to and from internal methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>loglikelihood value
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ghype</code>: Computes log-likelihood for ghype models from model object
</p>
</li>
<li> <p><code>matrix</code>: Computes log-likelihood for ghype models from adjacency.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data('adj_karate')
model &lt;- scm(adj_karate, FALSE, FALSE)
logl(object = model)
new_adj &lt;- adj_karate
new_adj[3,4] &lt;- 10
logl(object=model, adj=new_adj)

</code></pre>

<hr>
<h2 id='logLik.ghype'>Extract Log-Likelihood</h2><span id='topic+logLik.ghype'></span>

<h3>Description</h3>

<p>Extract Log-Likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ghype'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.ghype_+3A_object">object</code></td>
<td>
<p>ghype model.</p>
</td></tr>
<tr><td><code id="logLik.ghype_+3A_...">...</code></td>
<td>
<p>additional arguments passed to and from internal methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class logLik. This is a number with at least one
attribute, &quot;df&quot; (degrees of freedom), giving the number of (estimated) parameters
in the model.
</p>

<hr>
<h2 id='loglratio'>Compute log-likelihood ratio for ghype models.</h2><span id='topic+loglratio'></span>

<h3>Description</h3>

<p>Compute log-likelihood ratio for ghype models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglratio(mod0, mod1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglratio_+3A_mod0">mod0</code></td>
<td>
<p>ghype, null model</p>
</td></tr>
<tr><td><code id="loglratio_+3A_mod1">mod1</code></td>
<td>
<p>ghype, alternative model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar, log-likelihood ratio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('adj_karate')
sc.model &lt;- scm(adj_karate, FALSE, FALSE)
full.model &lt;- ghype(adj_karate, FALSE, FALSE)
loglratio(sc.model,full.model)

</code></pre>

<hr>
<h2 id='lr.test'>Perform likelihood ratio test between two ghype models.</h2><span id='topic+lr.test'></span>

<h3>Description</h3>

<p>lr.test allows to test between two nested ghype models whether there is
enough evidence for the alternative (more complex) model compared to the null model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr.test(
  nullmodel,
  altmodel,
  df = NULL,
  Beta = TRUE,
  seed = NULL,
  nempirical = NULL,
  parallel = FALSE,
  returnBeta = FALSE,
  method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lr.test_+3A_nullmodel">nullmodel</code></td>
<td>
<p>ghype object. The null model</p>
</td></tr>
<tr><td><code id="lr.test_+3A_altmodel">altmodel</code></td>
<td>
<p>ghype object. The alternative model</p>
</td></tr>
<tr><td><code id="lr.test_+3A_df">df</code></td>
<td>
<p>optional scalar. the number of degrees of freedom.</p>
</td></tr>
<tr><td><code id="lr.test_+3A_beta">Beta</code></td>
<td>
<p>boolean, whether to use empirical Beta distribution approximation. Default TRUE</p>
</td></tr>
<tr><td><code id="lr.test_+3A_seed">seed</code></td>
<td>
<p>scalar, seed for the empirical distribution.</p>
</td></tr>
<tr><td><code id="lr.test_+3A_nempirical">nempirical</code></td>
<td>
<p>optional scalar, number of replicates for empirical beta distribution.</p>
</td></tr>
<tr><td><code id="lr.test_+3A_parallel">parallel</code></td>
<td>
<p>optional, number of cores to use or boolean for parallel computation.
If passed TRUE uses all cores-1, else uses the number of cores passed. If none passed
performed not in parallel.</p>
</td></tr>
<tr><td><code id="lr.test_+3A_returnbeta">returnBeta</code></td>
<td>
<p>boolean, return estimated parameters of Beta distribution? Default FALSE.</p>
</td></tr>
<tr><td><code id="lr.test_+3A_method">method</code></td>
<td>
<p>string, for internal use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value of test. If returnBeta=TRUE returns the p-value together with the parameters
of the beta distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("adj_karate")
regularmodel &lt;- regularm(graph = adj_karate, directed = FALSE, selfloops = FALSE)
confmodel &lt;- scm(graph = adj_karate, directed = FALSE, selfloops = FALSE)
lr.test(nullmodel = regularmodel, altmodel = confmodel, seed = 123)

</code></pre>

<hr>
<h2 id='mat2vec.ix'>Auxiliary function, gives mask for matrix for directed,
undirected etc.</h2><span id='topic+mat2vec.ix'></span>

<h3>Description</h3>

<p>Auxiliary function, gives mask for matrix for directed,
undirected etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2vec.ix(mat, directed, selfloops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2vec.ix_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="mat2vec.ix_+3A_directed">directed</code></td>
<td>
<p>a boolean argument specifying whether object is directed or not.</p>
</td></tr>
<tr><td><code id="mat2vec.ix_+3A_selfloops">selfloops</code></td>
<td>
<p>a boolean argument specifying whether the model should incorporate selfloops.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean matrix that can be used to mask adjacency matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('adj_karate')
mat2vec.ix(adj_karate, FALSE, FALSE)

</code></pre>

<hr>
<h2 id='mcfaddenR2'>Computes Mc Fadden pseudo R-squared.</h2><span id='topic+mcfaddenR2'></span>

<h3>Description</h3>

<p>Pass either the models or the model parameters as arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcfaddenR2(
  adj = NULL,
  xi = NULL,
  omega0 = NULL,
  omega1 = NULL,
  directed,
  selfloops,
  mod0 = NULL,
  mod1 = NULL,
  nparam
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcfaddenR2_+3A_adj">adj</code></td>
<td>
<p>optimal adjacency matrix</p>
</td></tr>
<tr><td><code id="mcfaddenR2_+3A_xi">xi</code></td>
<td>
<p>optional xi matrix</p>
</td></tr>
<tr><td><code id="mcfaddenR2_+3A_omega0">omega0</code></td>
<td>
<p>optional propensity matrix of null model</p>
</td></tr>
<tr><td><code id="mcfaddenR2_+3A_omega1">omega1</code></td>
<td>
<p>optional propensity matrix of alternative model</p>
</td></tr>
<tr><td><code id="mcfaddenR2_+3A_directed">directed</code></td>
<td>
<p>boolean, is the model directed?</p>
</td></tr>
<tr><td><code id="mcfaddenR2_+3A_selfloops">selfloops</code></td>
<td>
<p>boolean, are there selfloops?</p>
</td></tr>
<tr><td><code id="mcfaddenR2_+3A_mod0">mod0</code></td>
<td>
<p>nrm null model</p>
</td></tr>
<tr><td><code id="mcfaddenR2_+3A_mod1">mod1</code></td>
<td>
<p>nrm alternative model</p>
</td></tr>
<tr><td><code id="mcfaddenR2_+3A_nparam">nparam</code></td>
<td>
<p>integer, number of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mc Fadden pseudo R-squared.
</p>

<hr>
<h2 id='nr.ci'>Confidence intervals for nrm models.</h2><span id='topic+nr.ci'></span>

<h3>Description</h3>

<p>Internal function to compute confidence intervals for estimated parameters of nrm model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nr.ci(nr.m, w, adj, pval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nr.ci_+3A_nr.m">nr.m</code></td>
<td>
<p>nrm model from which getting coefficients</p>
</td></tr>
<tr><td><code id="nr.ci_+3A_w">w</code></td>
<td>
<p>list of predictors</p>
</td></tr>
<tr><td><code id="nr.ci_+3A_adj">adj</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="nr.ci_+3A_pval">pval</code></td>
<td>
<p>numeric. confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix reporting values of predictors and confidence bounds
</p>

<hr>
<h2 id='nr.significance'>Computes the significance of more complex model against a simpler model by
means of a likelihood ratio test.</h2><span id='topic+nr.significance'></span>

<h3>Description</h3>

<p>Computes the significance of more complex model against a simpler model by
means of a likelihood ratio test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nr.significance(mod0 = NULL, mod1, adj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nr.significance_+3A_mod0">mod0</code></td>
<td>
<p>null nrm model (optional). defaults to the scm model.</p>
</td></tr>
<tr><td><code id="nr.significance_+3A_mod1">mod1</code></td>
<td>
<p>alternative nrm model, the model to test</p>
</td></tr>
<tr><td><code id="nr.significance_+3A_adj">adj</code></td>
<td>
<p>adjacency matrix for which performing the test. (optional) defaults to the matrix used for <code>mod1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value of the lr test mod0 vs mod1
</p>

<hr>
<h2 id='nrm'>Fitting gHypEG regression models for multi-edge networks.</h2><span id='topic+nrm'></span><span id='topic+nrm.default'></span><span id='topic+print.nrm'></span>

<h3>Description</h3>

<p>nrm is used to fit multi-edge network regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrm(
  w,
  adj,
  xi = NULL,
  pval = 0.01,
  directed = TRUE,
  selfloops = TRUE,
  regular = FALSE,
  ...
)

## Default S3 method:
nrm(
  w,
  adj,
  xi = NULL,
  pval = 0.01,
  directed = FALSE,
  selfloops = FALSE,
  regular = FALSE,
  ci = TRUE,
  significance = FALSE,
  null = FALSE,
  init = NULL,
  ...
)

## S3 method for class 'nrm'
print(x, suppressCall = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrm_+3A_w">w</code></td>
<td>
<p>an object of class <code>'list'</code> containing the predictors layers
(explanatory variables/covariates) of the multiplex, passed as adjacency
matrices. The entries of the list can be named.</p>
</td></tr>
<tr><td><code id="nrm_+3A_adj">adj</code></td>
<td>
<p>matrix. The adjacency matrix of the response network (dependent
variable).</p>
</td></tr>
<tr><td><code id="nrm_+3A_xi">xi</code></td>
<td>
<p>optional matrix. Passes a non-standard <code class="reqn">\Xi</code> matrix.</p>
</td></tr>
<tr><td><code id="nrm_+3A_pval">pval</code></td>
<td>
<p>the significance level used to compute confidence intervals of
the parameters. Per default, set to 0.01.</p>
</td></tr>
<tr><td><code id="nrm_+3A_directed">directed</code></td>
<td>
<p>logical. If <code>TRUE</code> the response variable is considered
the adjacency matrix of directed graph.  If <code>FALSE</code> only the upper
triangular of <code>adj</code> is considered. Default set to FALSE.</p>
</td></tr>
<tr><td><code id="nrm_+3A_selfloops">selfloops</code></td>
<td>
<p>logical. Whether selfloops are allowed. Default set to
FALSE.</p>
</td></tr>
<tr><td><code id="nrm_+3A_regular">regular</code></td>
<td>
<p>logical. Whether the gHypEG regression should be performed
with correction of combinatorial effects (<code>TRUE</code>) or without
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="nrm_+3A_...">...</code></td>
<td>
<p>optional arguments to print or plot methods.</p>
</td></tr>
<tr><td><code id="nrm_+3A_ci">ci</code></td>
<td>
<p>logical. Whether to compute confidences for the parameters.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nrm_+3A_significance">significance</code></td>
<td>
<p>logical. Whether to test the model significance against
the null by means of lr-test.</p>
</td></tr>
<tr><td><code id="nrm_+3A_null">null</code></td>
<td>
<p>logical. Is this a null model? Used for internal routines.</p>
</td></tr>
<tr><td><code id="nrm_+3A_init">init</code></td>
<td>
<p>numeric. Vector of initial values used for numerical MLE. If only
a single value is passed, this is repeated to match the number of
predictors in <code>w</code>.</p>
</td></tr>
<tr><td><code id="nrm_+3A_x">x</code></td>
<td>
<p>object of class <code>'nrm'</code></p>
</td></tr>
<tr><td><code id="nrm_+3A_suppresscall">suppressCall</code></td>
<td>
<p>logical, indicating whether to print the call that generated x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nrm returns an object of class 'nrm'.
</p>
<p>The function summary is used to obtain and print a summary and analysis of
the results. The generic accessory functions coefficients, etc, extract
various useful features of the value returned by nrm.
</p>
<p>An object of class 'nrm' is a list containing at least the following
components:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>a named vector of coefficients.</p>
</td></tr> <tr><td><code>confint</code></td>
<td>
<p>a named
matrix with confidence intervals and standard deviation for each
coefficient.</p>
</td></tr> <tr><td><code>omega</code></td>
<td>
<p>the estimated propensity matrix.</p>
</td></tr> <tr><td><code>xi</code></td>
<td>
<p>the matrix of possibilities.</p>
</td></tr> <tr><td><code>loglikelihood</code></td>
<td>
<p>log-likelihood of the
estimated model.</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>AIC of the estimated model.</p>
</td></tr> <tr><td><code>R2</code></td>
<td>
<p>Mc
Fadden pseudo R-squared</p>
</td></tr> <tr><td><code>csR2</code></td>
<td>
<p>Cox and Snells pseudo R-squared</p>
</td></tr>
<tr><td><code>significance</code></td>
<td>
<p>the p-value of the likelihood-ratio test for the
estimated model against the null.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Default method for nrm
</p>
</li>
<li> <p><code>nrm</code>: Print method for elements of class <code>'nrm'</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Giona Casiraghi
</p>
<p>Giona Casiraghi
</p>


<h3>References</h3>

<p>Casiraghi, Giona. 'Multiplex Network Regression: How do relations
drive interactions?.' arXiv preprint arXiv:1702.02048 (2017).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nrm">nrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## For a complete example see the vignette

data('highschool.predictors')

highschool.m &lt;- nrm(w=highschool.predictors[1], adj=contacts.adj, directed=FALSE,
  selfloops=FALSE)

highschool.m


data('highschool.predictors')

highschool.m &lt;- nrm(w=highschool.predictors, adj=contacts.adj, directed=FALSE,
  selfloops=FALSE)

highschool.m


</code></pre>

<hr>
<h2 id='nrmChoose'>Selects the best set of predictors among the given sets by means of AIC.</h2><span id='topic+nrmChoose'></span><span id='topic+nrm_choose'></span>

<h3>Description</h3>

<p>Computes all the models defined by a list of groups of predictors Returns the
best model according to AIC and id of the corresponding predictors in the
list The different models are computed in parallel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrmChoose(
  adj,
  w.list,
  xi = NULL,
  directed,
  selfloops,
  pval = 0.05,
  init = NULL,
  ncores = NULL
)

nrm_choose(
  adj,
  w.list,
  xi = NULL,
  directed,
  selfloops,
  pval = 0.05,
  init = NULL,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrmChoose_+3A_adj">adj</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="nrmChoose_+3A_w.list">w.list</code></td>
<td>
<p>nrmPredictor object. Nested list of predictors to be selected.</p>
</td></tr>
<tr><td><code id="nrmChoose_+3A_xi">xi</code></td>
<td>
<p>Xi matrix (optional). defaults to scm Xi matrix.</p>
</td></tr>
<tr><td><code id="nrmChoose_+3A_directed">directed</code></td>
<td>
<p>logical. Is the network directed?</p>
</td></tr>
<tr><td><code id="nrmChoose_+3A_selfloops">selfloops</code></td>
<td>
<p>logical. Does the network contain selfloops?</p>
</td></tr>
<tr><td><code id="nrmChoose_+3A_pval">pval</code></td>
<td>
<p>numeric. the significance at which computing confidence
intervals. defaults to 0.05</p>
</td></tr>
<tr><td><code id="nrmChoose_+3A_init">init</code></td>
<td>
<p>initial values for the MLE numerical maximisation. (See
<code>nrm</code>.)</p>
</td></tr>
<tr><td><code id="nrmChoose_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for parallelisation of selection process.
(optional) Defaults to number of available cores - 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the best model according to AIC and id of the
corresponding predictors in the list
</p>

<hr>
<h2 id='nrmSelection'>Perform AIC forward selection for nrm.</h2><span id='topic+nrmSelection'></span><span id='topic+nrm_selection'></span><span id='topic+nrm_selection.default'></span><span id='topic+nrm_selection.nrmpredictor'></span><span id='topic+print.nrm_selection'></span>

<h3>Description</h3>

<p>Perform AIC forward selection for nrm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrmSelection(
  adj,
  predictors,
  directed,
  selfloops,
  pval = 0.05,
  xi = NULL,
  init = NULL,
  ncores = NULL,
  ...
)

nrm_selection(
  adj,
  predictors,
  directed,
  selfloops,
  pval = 0.05,
  xi = NULL,
  init = NULL,
  ncores = NULL,
  ...
)

## Default S3 method:
nrm_selection(
  adj,
  predictors,
  directed,
  selfloops,
  pval = 0.05,
  xi = NULL,
  init = NULL,
  ncores = NULL,
  ...
)

## S3 method for class 'nrmpredictor'
nrm_selection(
  adj,
  predictors,
  directed,
  selfloops,
  pval = 0.05,
  xi = NULL,
  init = NULL,
  ncores = NULL,
  ...
)

## S3 method for class 'nrm_selection'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrmSelection_+3A_adj">adj</code></td>
<td>
<p>the adjacency matrix of the response network</p>
</td></tr>
<tr><td><code id="nrmSelection_+3A_predictors">predictors</code></td>
<td>
<p>list containing the set of predictors as sublists.</p>
</td></tr>
<tr><td><code id="nrmSelection_+3A_directed">directed</code></td>
<td>
<p>logical, is the response network directed?</p>
</td></tr>
<tr><td><code id="nrmSelection_+3A_selfloops">selfloops</code></td>
<td>
<p>logical, do the response network allows selfloops?</p>
</td></tr>
<tr><td><code id="nrmSelection_+3A_pval">pval</code></td>
<td>
<p>the significance at which computing confidence intervals.</p>
</td></tr>
<tr><td><code id="nrmSelection_+3A_xi">xi</code></td>
<td>
<p>optional, the possibility matrix <code class="reqn">\Xi</code>.</p>
</td></tr>
<tr><td><code id="nrmSelection_+3A_init">init</code></td>
<td>
<p>optional, initial values passed to the solver to estimate the MLE.</p>
</td></tr>
<tr><td><code id="nrmSelection_+3A_ncores">ncores</code></td>
<td>
<p>optional, number of cores over which parallelise the task.</p>
</td></tr>
<tr><td><code id="nrmSelection_+3A_...">...</code></td>
<td>
<p>optional arguments to print or plot methods.</p>
</td></tr>
<tr><td><code id="nrmSelection_+3A_x">x</code></td>
<td>
<p>object of class <code>'nrm_selection'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nrm object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Default method for the nrm stepwise selection.
</p>
</li>
<li> <p><code>nrmpredictor</code>: Method for the nrm stepwise selection when nrmpredictors are passed.
</p>
</li>
<li> <p><code>nrm_selection</code>: Print method for elements of class <code>'nrm_selection'</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Giona Casiraghi
</p>
<p>Giona Casiraghi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nrm">nrm</a></code>
</p>
<p><code>nrm_selection</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('highschool.predictors')
models &lt;- nrm_selection(adj=contacts.adj,predictors=create_predictors(highschool.predictors),
  ncores=1,directed=FALSE,selfloops=FALSE)
texreg::screenreg(models$models, digits=3)
 
</code></pre>

<hr>
<h2 id='onlinesim_mat'>Swiss MPs committee similarity matrix.</h2><span id='topic+onlinesim_mat'></span>

<h3>Description</h3>

<p>**onlinesim_mat**: a similarity matrix of how similar two MPs are in their online
social media presence (shared supportees).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(onlinesim_mat)
</code></pre>


<h3>Format</h3>

<p>163x163 similarity matrix
</p>

<hr>
<h2 id='predict.nrm'>Method to predict the expected values of a nrm model</h2><span id='topic+predict.nrm'></span>

<h3>Description</h3>

<p>Method to predict the expected values of a nrm model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nrm'
predict(object, m = NULL, adj = NULL, null = FALSE, multinomial = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.nrm_+3A_object">object</code></td>
<td>
<p>nrm object from which to predict</p>
</td></tr>
<tr><td><code id="predict.nrm_+3A_m">m</code></td>
<td>
<p>integer, the number of edges to be used</p>
</td></tr>
<tr><td><code id="predict.nrm_+3A_adj">adj</code></td>
<td>
<p>optional matrix, the adjacency matrix from which to get the number
of edges</p>
</td></tr>
<tr><td><code id="predict.nrm_+3A_null">null</code></td>
<td>
<p>optional boolean, is it a null model? default FALSE</p>
</td></tr>
<tr><td><code id="predict.nrm_+3A_multinomial">multinomial</code></td>
<td>
<p>logical. Optional argument. Whether to use multinomial
approximation. If left blank it is selected automatically based on network
size.</p>
</td></tr>
<tr><td><code id="predict.nrm_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, predicted values from nrm model. (If model is undirected,
only upper.tri of adjacency matrix is returned.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('highschool.predictors')
highschool.m &lt;- nrm(w=highschool.predictors[1], adj=contacts.adj, directed=FALSE, selfloops=FALSE)
predict(highschool.m, contacts.adj)

data('highschool.predictors')
highschool.m &lt;- nrm(w=highschool.predictors, adj=contacts.adj, directed=FALSE, selfloops=FALSE)
predict(highschool.m, contacts.adj)

</code></pre>

<hr>
<h2 id='reciprocity_stat'>Calculate weighted reciprocity change statistics for multi-edge graphs.</h2><span id='topic+reciprocity_stat'></span>

<h3>Description</h3>

<p>The function takes either an edgelist or an adjacency matrix and returns an
adjacency matrix with the reciprocity change statistic. This reciprocity
matrix can then be used as a predictor in the gHypEG regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity_stat(graph, nodes = NULL, zero_values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_stat_+3A_graph">graph</code></td>
<td>
<p>A graph adjacency matrix or an edgelist.  The edgelist needs to
have 3 columns: a sender vector, a target vector and an edgecount vector.</p>
</td></tr>
<tr><td><code id="reciprocity_stat_+3A_nodes">nodes</code></td>
<td>
<p>optional character/factor vector. If an edgelist is provided,
you have to provide a list of unique identifiers of your nodes in the graph.
This is because in the edgelist, isolates are usually not recorded.
If you do not specify isolates in your nodes object, they are excluded
from the analysis (falsifies data).</p>
</td></tr>
<tr><td><code id="reciprocity_stat_+3A_zero_values">zero_values</code></td>
<td>
<p>optional numeric value. Use this to substitute zero-values
in your reciprocity change statistic matrix. Zero values in the predictors
are recognized in the gHypEG regression as structural zeros. To ensure this
does not happen, please recode your zero-values in all your predictors,
ideally using a dummy variable fitting an optimal value for the zeroes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reciprocity change statistic matrix.
</p>


<h3>Author(s)</h3>

<p>LB, GC
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sharedPartner_stat">sharedPartner_stat</a></code> or <code><a href="#topic+homophily_stat">homophily_stat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recip_stat &lt;- reciprocity_stat(adj_karate)
recip_stat_dummy &lt;- get_zero_dummy(recip_stat, name = 'reciprocity')
nrm(w=recip_stat_dummy, adj_karate, directed = FALSE, selfloops = FALSE)

</code></pre>

<hr>
<h2 id='regularm'>Fit the gnm model</h2><span id='topic+regularm'></span>

<h3>Description</h3>

<p>regularm is wrapper for <a href="#topic+ghype">ghype</a> that allows to specify a gnm regular model.
i.e. where all entries of the combinatorial matrix Xi are the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regularm(graph, directed = NULL, selfloops = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regularm_+3A_graph">graph</code></td>
<td>
<p>either an adjacency matrix or an igraph graph</p>
</td></tr>
<tr><td><code id="regularm_+3A_directed">directed</code></td>
<td>
<p>optional boolean, if not specified detected from graph</p>
</td></tr>
<tr><td><code id="regularm_+3A_selfloops">selfloops</code></td>
<td>
<p>optional boolean, if not specified detected from graph</p>
</td></tr>
<tr><td><code id="regularm_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the ghype function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ghype object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("adj_karate")
regularmodel &lt;- regularm(graph = adj_karate, directed = FALSE, selfloops = FALSE)

</code></pre>

<hr>
<h2 id='residuals.nrm'>Method to compute residuals of nrm models</h2><span id='topic+residuals.nrm'></span>

<h3>Description</h3>

<p>Method to compute residuals of nrm models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nrm'
residuals(object, adj, RMSLE = FALSE, null = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.nrm_+3A_object">object</code></td>
<td>
<p>nrm object</p>
</td></tr>
<tr><td><code id="residuals.nrm_+3A_adj">adj</code></td>
<td>
<p>adjacency against which to compute residuals</p>
</td></tr>
<tr><td><code id="residuals.nrm_+3A_rmsle">RMSLE</code></td>
<td>
<p>logical, return log residuals? default FALSE</p>
</td></tr>
<tr><td><code id="residuals.nrm_+3A_null">null</code></td>
<td>
<p>logical. use null model?</p>
</td></tr>
<tr><td><code id="residuals.nrm_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to and from internal functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, residuals of nrm model fit against the original data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('highschool.predictors')
highschool.m &lt;- nrm(w=highschool.predictors[1], adj=contacts.adj, directed=FALSE, selfloops=FALSE)
residuals(highschool.m, contacts.adj)

</code></pre>

<hr>
<h2 id='rghype'>Generate random realisations from ghype model.</h2><span id='topic+rghype'></span>

<h3>Description</h3>

<p>Generate random realisations from ghype model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rghype(nsamples, model, m = NULL, multinomial = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rghype_+3A_nsamples">nsamples</code></td>
<td>
<p>scalar number of realisations</p>
</td></tr>
<tr><td><code id="rghype_+3A_model">model</code></td>
<td>
<p>ghype model</p>
</td></tr>
<tr><td><code id="rghype_+3A_m">m</code></td>
<td>
<p>optional scalar, number of edges to draw</p>
</td></tr>
<tr><td><code id="rghype_+3A_multinomial">multinomial</code></td>
<td>
<p>optional boolean, draw from multinomial?</p>
</td></tr>
<tr><td><code id="rghype_+3A_seed">seed</code></td>
<td>
<p>optional scalar, seed for random sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of adjacency matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('adj_karate')
model &lt;- scm(adj_karate, FALSE, FALSE)
rghype(1, model)

</code></pre>

<hr>
<h2 id='RMSE'>Computes the Root Mean Squared Error</h2><span id='topic+RMSE'></span>

<h3>Description</h3>

<p>Computes the Root Mean Squared Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMSE(model, adj, null = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMSE_+3A_model">model</code></td>
<td>
<p>nrm model estimate</p>
</td></tr>
<tr><td><code id="RMSE_+3A_adj">adj</code></td>
<td>
<p>original adjacency matrix</p>
</td></tr>
<tr><td><code id="RMSE_+3A_null">null</code></td>
<td>
<p>logical, whether to compute using null model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, root mean squared error of residuals of nrm model fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('highschool.predictors')
highschool.m &lt;- nrm(w=highschool.predictors[1], adj=contacts.adj, directed=FALSE, selfloops=FALSE)
RMSE(highschool.m, contacts.adj)

</code></pre>

<hr>
<h2 id='RMSLE'>Computes the Root Mean Squared Logged Error</h2><span id='topic+RMSLE'></span>

<h3>Description</h3>

<p>Computes the Root Mean Squared Logged Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMSLE(model, adj, null = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMSLE_+3A_model">model</code></td>
<td>
<p>nrm model estimate</p>
</td></tr>
<tr><td><code id="RMSLE_+3A_adj">adj</code></td>
<td>
<p>original adjacency matrix</p>
</td></tr>
<tr><td><code id="RMSLE_+3A_null">null</code></td>
<td>
<p>logical, whether to compute using null model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, root mean squared logged error of residuals of nrm model fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('highschool.predictors')
highschool.m &lt;- nrm(w=highschool.predictors[1], adj=contacts.adj, directed=FALSE, selfloops=FALSE)
RMSLE(highschool.m, contacts.adj)

</code></pre>

<hr>
<h2 id='scm'>Fit the Soft-Configuration Model</h2><span id='topic+scm'></span>

<h3>Description</h3>

<p>scm is wrapper for <a href="#topic+ghype">ghype</a> that allows to specify a soft-configuration model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scm(graph, directed = NULL, selfloops = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scm_+3A_graph">graph</code></td>
<td>
<p>either an adjacency matrix or an igraph graph</p>
</td></tr>
<tr><td><code id="scm_+3A_directed">directed</code></td>
<td>
<p>optional boolean, if not specified detected from graph</p>
</td></tr>
<tr><td><code id="scm_+3A_selfloops">selfloops</code></td>
<td>
<p>optional boolean, if not specified detected from graph</p>
</td></tr>
<tr><td><code id="scm_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the ghype function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ghype object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("adj_karate")
confmodel &lt;- scm(graph = adj_karate, directed = FALSE, selfloops = FALSE)

</code></pre>

<hr>
<h2 id='sharedPartner_stat'>Calculate (un-)weighted shared partner change statistics for multi-edge graphs.</h2><span id='topic+sharedPartner_stat'></span>

<h3>Description</h3>

<p>The function calculates the change statistic for shared partners for each
dyad in the graph. Shared partner statistics count for each dyad involving
nodes i and j in the graph, how many nodes k these two nodes have in common
(or share). The shared partner $k$ counts are weighted by their
interactions with the focal nodes $i$ and $j$. This is necessary in
dense multi-edge graphs to ensure that meaningful triadic closure is
detected. The statistic can be calculated in 3 different forms: undirected,
incoming shared partners (where shared partner k: k-&gt;i and k-&gt;j) and outgoing
shared partners (where shared partner k: k&lt;-i and k&lt;-j).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sharedPartner_stat(
  graph,
  directed,
  weighted = TRUE,
  triad.type = "undirected",
  nodes = NULL,
  zero_values = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sharedPartner_stat_+3A_graph">graph</code></td>
<td>
<p>A graph adjacency matrix or an edgelist. The edgelist needs to
have 3 columns: a sender vector, a target vector and an edgecount vector.</p>
</td></tr>
<tr><td><code id="sharedPartner_stat_+3A_directed">directed</code></td>
<td>
<p>boolean. Is the graph directed?</p>
</td></tr>
<tr><td><code id="sharedPartner_stat_+3A_weighted">weighted</code></td>
<td>
<p>set to TRUE.</p>
</td></tr>
<tr><td><code id="sharedPartner_stat_+3A_triad.type">triad.type</code></td>
<td>
<p>set to <code>undirected</code>. Can be set to <code>incoming</code>
or <code>outgoing</code> instead. This then corresponds to directed triadic closure
in the multi-edge graph.</p>
</td></tr>
<tr><td><code id="sharedPartner_stat_+3A_nodes">nodes</code></td>
<td>
<p>optional character/factor vector. If an edgelist is provided,
you have to provide a list of unique identifiers of your nodes in the graph.
This is because in the edgelist, isolates are usually not recorded.
If you do not specify isolates in your nodes object, they are excluded
from the analysis (falsifies data).</p>
</td></tr>
<tr><td><code id="sharedPartner_stat_+3A_zero_values">zero_values</code></td>
<td>
<p>optional numeric value. Use this to substitute zero-values
in your shared partner change statistic matrix. Zero values in the predictors
are recognized in the gHypEG regression as structural zeros. To ensure this
does not happen, please recode your zero-values in all your predictors,
ideally using a dummy variable fitting an optimal value for the zeroes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shared partner change statistic matrix.
</p>


<h3>Author(s)</h3>

<p>LB, GC, GV
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reciprocity_stat">reciprocity_stat</a></code> or <code><a href="#topic+homophily_stat">homophily_stat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tri_stat &lt;- sharedPartner_stat(adj_karate, directed = FALSE)
tri_stat_dummy &lt;- get_zero_dummy(tri_stat, name = 'shared_partners')
nrm(w=tri_stat_dummy, adj_karate, directed = FALSE, selfloops = FALSE)
</code></pre>

<hr>
<h2 id='summary.nrm'>Summary method for elements of class <code>'nrm'</code>.</h2><span id='topic+summary.nrm'></span><span id='topic+print.summary.nrm'></span>

<h3>Description</h3>

<p>Currently it provides the same output as <code>'print.nrm'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nrm'
summary(object, ...)

## S3 method for class 'summary.nrm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nrm_+3A_object">object</code></td>
<td>
<p>an object of class 'nrm', usually, a result of a call to <code>nrm</code>.</p>
</td></tr>
<tr><td><code id="summary.nrm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.nrm_+3A_x">x</code></td>
<td>
<p>object of class 'summary.nrm' returned by [summary.nrm()].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code><a href="#topic+summary.nrm">summary.nrm</a></code> computes and
returns a list of summary statistics of the fitted
<code><a href="#topic+nrm">nrm</a></code> model given in <code>object</code>.
</p>

<hr>
<h2 id='summary.nrm_selection'>Summary method for elements of class <code>'nrm_selection'</code>.</h2><span id='topic+summary.nrm_selection'></span><span id='topic+print.summary.nrm_selection'></span>

<h3>Description</h3>

<p>Summary method for elements of class <code>'nrm_selection'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nrm_selection'
summary(object, ...)

## S3 method for class 'summary.nrm_selection'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nrm_selection_+3A_object">object</code></td>
<td>
<p>an object of class 'nrm_selection', usually, a result of a call to <code>nrm_selection</code>.</p>
</td></tr>
<tr><td><code id="summary.nrm_selection_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.nrm_selection_+3A_x">x</code></td>
<td>
<p>object of class 'summary.nrm_selection' returned by [summary.nrm._selection()].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code><a href="#topic+summary.nrm_selection">summary.nrm_selection</a></code> computes and
returns a list of summary statistics of the fitted
<code><a href="#topic+nrm_selection">nrm_selection</a></code> model given in <code>object</code>.
</p>

<hr>
<h2 id='vec2mat'>Auxiliary function, produces matrix from vector</h2><span id='topic+vec2mat'></span>

<h3>Description</h3>

<p>The number of elements of vec are the number of non-zero elements in the
adjacency matrix.
It performs the opposite operation of 'mat2vec.ix'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2mat(vec, directed, selfloops, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2mat_+3A_vec">vec</code></td>
<td>
<p>vector to be put in matrix form</p>
</td></tr>
<tr><td><code id="vec2mat_+3A_directed">directed</code></td>
<td>
<p>a boolean argument specifying whether object is directed or not.</p>
</td></tr>
<tr><td><code id="vec2mat_+3A_selfloops">selfloops</code></td>
<td>
<p>a boolean argument specifying whether the model should
incorporate selfloops.</p>
</td></tr>
<tr><td><code id="vec2mat_+3A_n">n</code></td>
<td>
<p>vector. if length(n)==1, n is the number of vertices. If length(n)==3
first element is number of vertices, second and third elements are number of
vertices for row and column of bipartite matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix nxn generated from vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('adj_karate')
ix &lt;- mat2vec.ix(adj_karate, FALSE, FALSE)
vec &lt;- adj_karate[ix]
vec2mat(vec, FALSE, FALSE, nrow(adj_karate))

</code></pre>

<hr>
<h2 id='vertexlabels'>Zachary's Karate Club vertex faction assignment</h2><span id='topic+vertexlabels'></span>

<h3>Description</h3>

<p>Vector reporting the assignment of nodes to communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertexlabels
</code></pre>


<h3>Format</h3>

<p>a 34-vector with the assignment of nodes to faction 1 or 2
</p>


<h3>Source</h3>

<p>package 'igraphdata'
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
