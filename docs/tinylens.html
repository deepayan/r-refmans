<!DOCTYPE html><html lang="en"><head><title>Help for package tinylens</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tinylens}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tinylens-package'><p>tinylens: Minimal Implementation of Functional Lenses</p></a></li>
<li><a href='#+25.+25'><p>Compose two lenses</p></a></li>
<li><a href='#attr_l'><p>Attributes lens</p></a></li>
<li><a href='#c_l'><p>Lens for accessing and modifying nested elements of a list or vector</p></a></li>
<li><a href='#filter_il'><p>Filter ilens</p></a></li>
<li><a href='#id_l'><p>Identity lens</p></a></li>
<li><a href='#index_l'><p>Index lens</p></a></li>
<li><a href='#indices_l'><p>Subset lens</p></a></li>
<li><a href='#lens'><p>Create a lens</p></a></li>
<li><a href='#map_l'><p>Lens into a list or vector</p></a></li>
<li><a href='#names_l'><p>Names lens</p></a></li>
<li><a href='#over'><p>Modify the focused part of a data structure</p></a></li>
<li><a href='#over_map'><p>Map a function over a list lens</p></a></li>
<li><a href='#rows_l'><p>Rows lens</p></a></li>
<li><a href='#select_l'><p>include verbs.R</p>
include lens.R
Select lens</a></li>
<li><a href='#set'><p>Set the focused part of a data structure</p></a></li>
<li><a href='#slice_l'><p>Slice lens</p></a></li>
<li><a href='#vec_data_l'><p>Vector data lens</p></a></li>
<li><a href='#view'><p>View the focused part of a data structure</p></a></li>
<li><a href='#where_il'><p>Predicate ilens</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Minimal Implementation of Functional Lenses</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utilities to create and use lenses to simplify data
    manipulation. Lenses are composable getter/setter pairs that provide a
    functional approach to manipulating deeply nested data structures, e.g.,
    elements within list columns in data frames. The implementation is based on
    the earlier 'lenses' R package <a href="https://github.com/cfhammill/lenses">https://github.com/cfhammill/lenses</a>,
    which was inspired by the Haskell 'lens' package by Kmett (2012)
    <a href="https://github.com/ekmett/lens">https://github.com/ekmett/lens</a>, one of the most widely referenced
    implementations of lenses. For additional background and history on the
    theory of lenses, see the 'lens' package wiki:
    <a href="https://github.com/ekmett/lens/wiki/History-of-Lenses">https://github.com/ekmett/lens/wiki/History-of-Lenses</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, S7, vctrs</td>
</tr>
<tr>
<td>Collate:</td>
<td>'lens.R' 'verbs.R' 'base-lenses.R' 'dataframe-lenses.R'
'tinylens-package.R' 'zzz.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tidyselect, tinytest</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/arbelt/tinylens">https://github.com/arbelt/tinylens</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/arbelt/tinylens/issues">https://github.com/arbelt/tinylens/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-06 15:27:24 UTC; albert</td>
</tr>
<tr>
<td>Author:</td>
<td>Albert Wang [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Albert Wang &lt;albert_z_wang@harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-09 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tinylens-package'>tinylens: Minimal Implementation of Functional Lenses</h2><span id='topic+tinylens'></span><span id='topic+tinylens-package'></span>

<h3>Description</h3>

<p>Provides utilities to create and use lenses to simplify data manipulation. Lenses are composable getter/setter pairs that provide a functional approach to manipulating deeply nested data structures, e.g., elements within list columns in data frames. The implementation is based on the earlier 'lenses' R package <a href="https://github.com/cfhammill/lenses">https://github.com/cfhammill/lenses</a>, which was inspired by the Haskell 'lens' package by Kmett (2012) <a href="https://github.com/ekmett/lens">https://github.com/ekmett/lens</a>, one of the most widely referenced implementations of lenses. For additional background and history on the theory of lenses, see the 'lens' package wiki: <a href="https://github.com/ekmett/lens/wiki/History-of-Lenses">https://github.com/ekmett/lens/wiki/History-of-Lenses</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Albert Wang <a href="mailto:albert_z_wang@harvard.edu">albert_z_wang@harvard.edu</a> [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/arbelt/tinylens">https://github.com/arbelt/tinylens</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/arbelt/tinylens/issues">https://github.com/arbelt/tinylens/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25.+25'>Compose two lenses</h2><span id='topic++25.+25'></span>

<h3>Description</h3>

<p>The resulting lens first applies the <em>left</em> lens, then the right lens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l %.% m
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25.+2B25_+3A_l">l</code></td>
<td>
<p>First lens</p>
</td></tr>
<tr><td><code id="+2B25.+2B25_+3A_m">m</code></td>
<td>
<p>Second lens</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new lens
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- list(list(a = 1, b = 2), list(a = 4, b = 9))
l &lt;- index_l(1)
m &lt;- index_l("b")
view(d, l %.% m)
</code></pre>

<hr>
<h2 id='attr_l'>Attributes lens</h2><span id='topic+attr_l'></span>

<h3>Description</h3>

<p>Lens into a named attribute of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attr_l(name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attr_l_+3A_name">name</code></td>
<td>
<p>Name of the attribute to lens into</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lens that selects the specified attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
attr(x, "label") &lt;- "my_label"
l &lt;- attr_l("label")
view(x, l)
set(x, l, "new_label")
</code></pre>

<hr>
<h2 id='c_l'>Lens for accessing and modifying nested elements of a list or vector</h2><span id='topic+c_l'></span>

<h3>Description</h3>

<p>Convenience function that mirrors <code><a href="purrr.html#topic+pluck">purrr::pluck()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_l(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_l_+3A_...">...</code></td>
<td>
<p>A sequence of lenses and/or integers/logical vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lens that combines all specified lenses (left to right).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- list(a = list(b = 1, c = 2), b = list(b = 3, c = 4))
l &lt;- c_l("a", "b")
view(d, l)
</code></pre>

<hr>
<h2 id='filter_il'>Filter ilens</h2><span id='topic+filter_il'></span>

<h3>Description</h3>

<p>This function returns an illegal lens that filters according to the specified conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_il(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_il_+3A_...">...</code></td>
<td>
<p>Conditions to filter by</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conditions are evaluated in the context of the data frame.
</p>


<h3>Value</h3>

<p>A lens that filters the specified rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(x = 1:10, y = 11:20, z = 21:30)
l &lt;- filter_il(x &gt; 5)
# get the rows where x is greater than 5
view(d, l)
# set the rows where x is greater than 5 to 8
set(d, l, 8)
# set y value to 8 where x is greater than 5
set(d, l %.% select_l(y), 8)
</code></pre>

<hr>
<h2 id='id_l'>Identity lens</h2><span id='topic+id_l'></span>

<h3>Description</h3>

<p>Trivial identity lens: returns and sets the object itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_l
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tinylens::lens</code> (inherits from <code>S7_object</code>) of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
view(x, id_l)
</code></pre>

<hr>
<h2 id='index_l'>Index lens</h2><span id='topic+index_l'></span>

<h3>Description</h3>

<p>Lens into a single element of a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_l(i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index_l_+3A_i">i</code></td>
<td>
<p>Index of the element to lens into</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This lens performs indexing using double bracket notation, i.e., <code>x[[i]]</code>.
</p>


<h3>Value</h3>

<p>A lens that selects the specified element
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = 1, b = 2)
l &lt;- index_l("a")
view(x, l)
</code></pre>

<hr>
<h2 id='indices_l'>Subset lens</h2><span id='topic+indices_l'></span><span id='topic+i_l'></span>

<h3>Description</h3>

<p>This function returns a lens that subsets the object in a generalized way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indices_l(...)

i_l(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indices_l_+3A_...">...</code></td>
<td>
<p>Conditions to subset by. Unnamed arguments are used as indices.
Named arguments are passed along to <code>[</code> for viewing and are removed for
setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lens that subsets the object by the specified indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(x = 1:10, y = 11:20, z = 21:30)
l &lt;- indices_l(1, 1)
# get the first row of first column
view(d, l)
# set the first row of first column
set(d, l, 1)

# get the first row
l &lt;- indices_l(1,)
view(d, l)
# set the first row
set(d, l, 1)
</code></pre>

<hr>
<h2 id='lens'>Create a lens</h2><span id='topic+lens'></span>

<h3>Description</h3>

<p>A lens is a pair of functions that can be used to view and set a value in an object.
Lenses are implemented as S7 classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lens(view, set = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lens_+3A_view">view</code></td>
<td>
<p>A function that takes an object and returns a value</p>
</td></tr>
<tr><td><code id="lens_+3A_set">set</code></td>
<td>
<p>A function that takes an object and a value and returns a new object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &quot;proper&quot; lens should satisfy the following so-called &quot;lens laws&quot;:
</p>

<ul>
<li> <p><strong>View-Set</strong>: <code>set(d, l, view(d, l)) == d</code>
</p>
</li>
<li> <p><strong>Set-View</strong>: <code>view(set(d, l, x), l) == x</code>
</p>
</li>
<li> <p><strong>Set-Set</strong>: <code>set(set(d, l, x), l, y) == set(d, l, y)</code>
</p>
</li></ul>

<p>These laws are not enforced by <code>tinylens</code>, but you should strive to follow them
when creating your own lenses.
</p>
<p>A best effort has been made to ensure that these laws hold for the lenses
provided by <code>tinylens</code>, but this is trickier than it might seem because of
how R handles subset assignments.
</p>


<h3>Value</h3>

<p>A lens with the specified view and set functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a trivial identity lens
l &lt;- lens(view = function(x) x, set = function(x, value) value)
</code></pre>

<hr>
<h2 id='map_l'>Lens into a list or vector</h2><span id='topic+map_l'></span>

<h3>Description</h3>

<p>This lens allows you to access and modify elements of a list or vector
based on their position or a logical condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_l(l, .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_l_+3A_l">l</code></td>
<td>
<p>A lens that selects the elements to lens into</p>
</td></tr>
<tr><td><code id="map_l_+3A_.ptype">.ptype</code></td>
<td>
<p>The prototype of the data structure to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lens that selects the specified elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- list(list(a = 1, b = 2), list(a = 4, b = 9))
l &lt;- index_l("a")
view(d, map_l(l))
over_map(d, map_l(l), sqrt)
</code></pre>

<hr>
<h2 id='names_l'>Names lens</h2><span id='topic+names_l'></span>

<h3>Description</h3>

<p>Lens into the <code>names</code> attribute of an object. This uses <code>rlang::names2</code> to
better handle <code>NULL</code> names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>names_l
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tinylens::lens</code> (inherits from <code>S7_object</code>) of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- letters[1:10]
names(x) &lt;- letters[1:10]
view(x, names_l)
over(x, names_l, toupper)
</code></pre>

<hr>
<h2 id='over'>Modify the focused part of a data structure</h2><span id='topic+over'></span>

<h3>Description</h3>

<p>Modify the focused part of a data structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>over(d, l, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="over_+3A_d">d</code></td>
<td>
<p>The data structure to view</p>
</td></tr>
<tr><td><code id="over_+3A_l">l</code></td>
<td>
<p>The lens to apply</p>
</td></tr>
<tr><td><code id="over_+3A_f">f</code></td>
<td>
<p>The function to apply</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified data structure
</p>

<hr>
<h2 id='over_map'>Map a function over a list lens</h2><span id='topic+over_map'></span>

<h3>Description</h3>

<p>Apply a function to each element of a list returned by a lens. Using <code>over</code>
in such cases would require a &quot;lifted&quot; function, which is often unergonomic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>over_map(d, l, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="over_map_+3A_d">d</code></td>
<td>
<p>The data structure to modify</p>
</td></tr>
<tr><td><code id="over_map_+3A_l">l</code></td>
<td>
<p>The list-returning lens to apply</p>
</td></tr>
<tr><td><code id="over_map_+3A_f">f</code></td>
<td>
<p>The function to apply to each element of the list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified data structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- list(list(a = 1, b = 2), list(a = 4, b = 9))
l &lt;- map_l(index_l("a"))
over_map(d, l, sqrt)
</code></pre>

<hr>
<h2 id='rows_l'>Rows lens</h2><span id='topic+rows_l'></span>

<h3>Description</h3>

<p>This function returns a lens that selects the specified rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rows_l(idx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rows_l_+3A_idx">idx</code></td>
<td>
<p>The rows to select</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lens that selects the specified rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(x = 1:10, y = 11:20, z = 21:30)
l &lt;- rows_l(1:2)
# get the first two rows
view(d, l)
# set the first two rows
set(d, l, 1:2)
</code></pre>

<hr>
<h2 id='select_l'>include verbs.R
include lens.R
Select lens</h2><span id='topic+select_l'></span>

<h3>Description</h3>

<p>This function returns a lens that selects the specified columns. Requires
<code>tidyselect</code> to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_l(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_l_+3A_...">...</code></td>
<td>
<p>Columns to select</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lens that selects the specified columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(x = 1:10, y = 11:20, z = 21:30)
l &lt;- select_l(x, y)
# get the x and y columns
view(d, l)
# set the x and y columns
set(d, l, 1)
</code></pre>

<hr>
<h2 id='set'>Set the focused part of a data structure</h2><span id='topic+set'></span>

<h3>Description</h3>

<p>Set the focused part of a data structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set(d, l, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_+3A_d">d</code></td>
<td>
<p>The data structure to view</p>
</td></tr>
<tr><td><code id="set_+3A_l">l</code></td>
<td>
<p>The lens to apply</p>
</td></tr>
<tr><td><code id="set_+3A_x">x</code></td>
<td>
<p>The value to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified data structure
</p>

<hr>
<h2 id='slice_l'>Slice lens</h2><span id='topic+slice_l'></span>

<h3>Description</h3>

<p>Lens into a slice of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_l(idx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_l_+3A_idx">idx</code></td>
<td>
<p>Indices of the elements to lens into</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This lens performs indexing using single bracket notation, i.e., <code>x[idx]</code>.
</p>


<h3>Value</h3>

<p>A lens that selects the specified slice
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- letters[1:10]
l &lt;- slice_l(1:5)
view(x, l)
</code></pre>

<hr>
<h2 id='vec_data_l'>Vector data lens</h2><span id='topic+vec_data_l'></span>

<h3>Description</h3>

<p>Allows mutation of vector data while preserving attributes, e.g., labels or names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_data_l
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tinylens::lens</code> (inherits from <code>S7_object</code>) of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- letters[1:10]
names(x) &lt;- letters[1:10]
# toy function that strips names; most functions from `stringr` do this
f &lt;- function(x) toupper(unname(x))
# apply the function without losing attributes
over(x, vec_data_l, f)
</code></pre>

<hr>
<h2 id='view'>View the focused part of a data structure</h2><span id='topic+view'></span>

<h3>Description</h3>

<p><code>view()</code> applies a lens to a data structure and returns the focused part.
</p>
<p><code>set()</code> applies a lens to a data structure and sets the focused part.
</p>
<p><code>over()</code> applies a lens to a data structure and modifies the focused part using a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view(d, l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_+3A_d">d</code></td>
<td>
<p>The data structure to view</p>
</td></tr>
<tr><td><code id="view_+3A_l">l</code></td>
<td>
<p>The lens to apply</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The part of the data structure focused by the lens
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
names(x) &lt;- letters[1:10]
view(x, names_l)
set(x, names_l, LETTERS[1:10])
over(x, names_l, toupper)
</code></pre>

<hr>
<h2 id='where_il'>Predicate ilens</h2><span id='topic+where_il'></span>

<h3>Description</h3>

<p>Illegal lens into elements of a vector that satisfy a predicate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where_il(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="where_il_+3A_p">p</code></td>
<td>
<p>A predicate function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lens that selects the elements that satisfy the predicate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 1:10
l &lt;- where_il(\(x) x %% 2 == 0)
view(d, l)
over(d, l, \(x) x / 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
