<!DOCTYPE html><html><head><title>Help for package rivr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rivr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rivr-package'><p>Steady and Unsteady Open-Channel Flow Computation</p></a></li>
<li><a href='#channel_geom'><p>Channel geometry</p></a></li>
<li><a href='#compute_profile'><p>Gradually-varied flow profiles</p></a></li>
<li><a href='#conveyance'><p>Channel conveyance</p></a></li>
<li><a href='#critical_depth'><p>Critical depth</p></a></li>
<li><a href='#demo_shiny'><p>Shiny Demonstrations</p></a></li>
<li><a href='#froude'><p>Froude Number</p></a></li>
<li><a href='#normal_depth'><p>Normal depth</p></a></li>
<li><a href='#route_wave'><p>Flood wave routing</p></a></li>
<li><a href='#waterolympics'><p>California Water Olympics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Steady and Unsteady Open-Channel Flow Computation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-3</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool for undergraduate and graduate courses in open-channel
    hydraulics. Provides functions for computing normal and critical depths,
    steady-state water surface profiles (e.g. backwater curves) and unsteady flow
    computations (e.g. flood wave routing) as described in
    Koohafkan MC, Younis BA (2015). "Open-channel computation with R."
    The R Journal, 7(2), 249â€“262. &lt;<a href="https://doi.org/10.32614%2FRJ-2015-034">doi:10.32614/RJ-2015-034</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mkoohafkan/rivr">https://github.com/mkoohafkan/rivr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mkoohafkan/rivr/issues">https://github.com/mkoohafkan/rivr/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, graphics, Rcpp (&ge; 1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, ggplot2, knitr, rmarkdown, shiny</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-21 05:47:32 UTC; michael</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael C Koohafkan [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael C Koohafkan &lt;michael.koohafkan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-21 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rivr-package'>Steady and Unsteady Open-Channel Flow Computation</h2><span id='topic+rivr-package'></span><span id='topic+rivr'></span>

<h3>Description</h3>

<p>This package is designed as an educational tool for students and 
instructors of undergraduate courses in open channel hydraulics. 
Functions are provided for computing normal and critical depths, 
steady (e.g. backwater curves) and unsteady (flood wave routing) 
flow computations for prismatic trapezoidal channels. See the vignettes
to get started.
</p>

<hr>
<h2 id='channel_geom'>Channel geometry</h2><span id='topic+channel_geom'></span>

<h3>Description</h3>

<p>Compute geometry relations for trapezoidal channels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>channel_geom(y, B, SS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="channel_geom_+3A_y">y</code></td>
<td>
<p>Flow depth [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="channel_geom_+3A_b">B</code></td>
<td>
<p>Channel bottom width [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="channel_geom_+3A_ss">SS</code></td>
<td>
<p>Channel sideslope [<code class="reqn">L L^{-1}</code>]. For a rectangular channel, <code>SS = 0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Channel geometry relations are routinely calculated in numerical solutions of steady, 
gradually-varied and unsteady flows. This function is used extensively by internal 
procedures and is made accessible to the user for convenience.
</p>


<h3>Value</h3>

<p>Named vector:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Flow area [<code class="reqn">L^2</code>].</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>Wetted perimeter [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Hydraulic radius [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code>dAdy</code></td>
<td>
<p>Water surface width [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code>dPdy</code></td>
<td>
<p>First derivative of wetted perimeter w.r.t. flow depth.</p>
</td></tr>
<tr><td><code>dRdy</code></td>
<td>
<p>First derivative of hydraulic radius w.r.t. flow depth.</p>
</td></tr>
<tr><td><code>DH</code></td>
<td>
<p>Hydraulic depth [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code>ybar</code></td>
<td>
<p>Vertical distance from water surface to centroid of flow area [<code class="reqn">L</code>].</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>channel_geom(1.71, 100, 0) # rectangular channel
channel_geom(5.79, 6.1, 1.5) # trapezoidal channel with sideslope 3H:2V
</code></pre>

<hr>
<h2 id='compute_profile'>Gradually-varied flow profiles</h2><span id='topic+compute_profile'></span>

<h3>Description</h3>

<p>Compute the gradually-varied flow profile of a prismatic channel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_profile(
  So,
  n,
  Q,
  y0,
  Cm,
  g,
  B,
  SS,
  z0 = 0,
  x0 = 0,
  stepdist,
  totaldist
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_profile_+3A_so">So</code></td>
<td>
<p>Channel slope [<code class="reqn">L L^{-1}</code>].</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_n">n</code></td>
<td>
<p>Manning's roughness coefficient.</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_q">Q</code></td>
<td>
<p>Flow rate [<code class="reqn">L^3 T^{-1}</code>].</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_y0">y0</code></td>
<td>
<p>The water depth at the control section [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_cm">Cm</code></td>
<td>
<p>Unit conversion coefficient for Manning's equation. For SI units, Cm = 1.</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_g">g</code></td>
<td>
<p>Gravitational acceleration [<code class="reqn">L T^{-2}</code>].</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_b">B</code></td>
<td>
<p>Channel bottom width [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_ss">SS</code></td>
<td>
<p>Channel sideslope [<code class="reqn">L L^{-1}</code>].</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_z0">z0</code></td>
<td>
<p>Elevation reference datum at control section [<code class="reqn">L</code>]. Default is 0.</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_x0">x0</code></td>
<td>
<p>Distance reference at control section [<code class="reqn">L</code>]. Default is 0.</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_stepdist">stepdist</code></td>
<td>
<p>The spatial interval used in the Standard step method [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="compute_profile_+3A_totaldist">totaldist</code></td>
<td>
<p>The total distance upstream (or downstream) to compute the profile [<code class="reqn">L</code>].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the longitudinal water surface profile of a prismatic 
channel using the standard step method by solving the non-linear ODE 
</p>
<p style="text-align: center;"><code class="reqn">\frac{dy}{dx} = \frac{S_0 - S_f}{1 - Fr^2}</code>
</p>
<p> The standard-step 
method operates by stepping along the channel by a constant distance 
interval, starting from a cross-section where the flow depth is known 
(the control section). The flow depth is computed at the adjacent 
cross-section (target section). The computed value at the target is then 
used as the basis for computing flow depth at the next cross-section, i.e. 
the previous target section becomes the new control section for each step. 
A Newton-Raphson scheme is used each step to compute the flow depth and 
friction slope. Technically, the average friction slope of the control and
target section is used to compute the flow depth at the target section.
</p>


<h3>Value</h3>

<p>data.frame with columns:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Along-channel distance.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>Elevation.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Flow depth.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Flow velocity.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Flow area.</p>
</td></tr>
<tr><td><code>Sf</code></td>
<td>
<p>Friction slope.</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Total energy.</p>
</td></tr>
<tr><td><code>Fr</code></td>
<td>
<p>Froude Number.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># example M1 profile
compute_profile(0.001, 0.045, 250, 2.7, 1.486, 32.2, 100, 0, stepdist = 10, totaldist = 3000)
# example M2 profile
compute_profile(0.001, 0.045, 250, 0.64, 1.486, 32.2, 100, 0, stepdist = 10, totaldist = 3000)
# example S2 profile
compute_profile(0.005, 0.01, 250, 2.65, 1.486, 32.2, 10, 0, stepdist = 10, totaldist = 2000)
# example S3 profile
compute_profile(0.005, 0.01, 250, 0.5, 1.486, 32.2, 10, 0, stepdist = 10, totaldist = 2000)
</code></pre>

<hr>
<h2 id='conveyance'>Channel conveyance</h2><span id='topic+conveyance'></span>

<h3>Description</h3>

<p>Calculate the channel conveyance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conveyance(n, A, R, Cm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conveyance_+3A_n">n</code></td>
<td>
<p>Manning's roughness coefficient (dimensionless).</p>
</td></tr>
<tr><td><code id="conveyance_+3A_a">A</code></td>
<td>
<p>Flow area [<code class="reqn">L^2</code>].</p>
</td></tr>
<tr><td><code id="conveyance_+3A_r">R</code></td>
<td>
<p>Hydraulic radius [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="conveyance_+3A_cm">Cm</code></td>
<td>
<p>Unit conversion coefficient for Manning's equation. For SI units, Cm = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Channel conveyance is routinely calculated in numerical solutions of steady, 
gradually-varied and unsteady flows. This function is used extensively by internal 
procedures and is made accessible to the user for convenience.
</p>


<h3>Value</h3>

<p>The channel conveyance.
</p>

<hr>
<h2 id='critical_depth'>Critical depth</h2><span id='topic+critical_depth'></span>

<h3>Description</h3>

<p>Calculate the critical depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critical_depth(Q, yopt, g, B, SS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="critical_depth_+3A_q">Q</code></td>
<td>
<p>Flow rate [<code class="reqn">L^3 T^{-1}</code>].</p>
</td></tr>
<tr><td><code id="critical_depth_+3A_yopt">yopt</code></td>
<td>
<p>Initial guess for normal depth [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="critical_depth_+3A_g">g</code></td>
<td>
<p>Gravitational acceleration [<code class="reqn">L T^{-2}</code>].</p>
</td></tr>
<tr><td><code id="critical_depth_+3A_b">B</code></td>
<td>
<p>Channel bottom width [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="critical_depth_+3A_ss">SS</code></td>
<td>
<p>Channel sideslope [<code class="reqn">L L^{-1}</code>].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The critical depth is the water depth at which a channel 
flow regime will transition from supercritical to subcritical (or vice versa).
Calculation of the critical depth is based on a specific energy formulation, 
i.e. </p>
<p style="text-align: center;"><code class="reqn">E = y + z + \frac{Q^2}{2gB^2y^2}</code>
</p>
<p> where <code class="reqn">y</code> is the flow depth, <code class="reqn">z</code> is 
the elevation relative to some datum (assumed to be 0), and the last term 
represents kinetic energy. More specifically, the function operates
by finding the point where the derivative of specific energy w.r.t. <code class="reqn">y</code> is zero, i.e.
<code class="reqn">y = y_c</code> when </p>
<p style="text-align: center;"><code class="reqn">\frac{dE}{dy} = 1 - \frac{Q^2}{gA^3}\frac{dA}{dy} = 0</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>The critical depth <code class="reqn">y_c</code> [<code class="reqn">L</code>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>critical_depth(250, 2, 32.2, 100, 0) # rectangular channel
critical_depth(126, 1, 9.81, 6.1, 1.5) # trapezoidal channel with sideslope 3H:2V
</code></pre>

<hr>
<h2 id='demo_shiny'>Shiny Demonstrations</h2><span id='topic+demo_shiny'></span>

<h3>Description</h3>

<p>Demonstrate package functionality via Shiny apps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo_shiny(ex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demo_shiny_+3A_ex">ex</code></td>
<td>
<p>Example to run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Demonstrations available:
<code>"gvf"</code> Gradually-varied flow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get list of available demos
demo_shiny()
# run the gradually-varied flow demo
demo_shiny("gvf")

## End(Not run)

</code></pre>

<hr>
<h2 id='froude'>Froude Number</h2><span id='topic+froude'></span>

<h3>Description</h3>

<p>Calculate the Froude Number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>froude(Q, g, A, DH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="froude_+3A_q">Q</code></td>
<td>
<p>Flow rate [<code class="reqn">L^3 T^{-1}</code>].</p>
</td></tr>
<tr><td><code id="froude_+3A_g">g</code></td>
<td>
<p>Gravitational acceleration [<code class="reqn">L T^{-2}</code>].</p>
</td></tr>
<tr><td><code id="froude_+3A_a">A</code></td>
<td>
<p>Flow area [<code class="reqn">L^2</code>].</p>
</td></tr>
<tr><td><code id="froude_+3A_dh">DH</code></td>
<td>
<p>Hydraulic depth [<code class="reqn">L</code>].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Froude number is a dimensionless measure of bulk flow 
characteristics that represents the relative importance of inertial 
forces and gravitational forces. For open channel flow, the Froude 
number of open channel flow is defined as </p>
<p style="text-align: center;"><code class="reqn">Fr = \frac{v}{\sqrt{gD_H}}</code>
</p>
 
<p>where <code class="reqn">v = \frac{Q}{A}</code> is the flow velocity, <code class="reqn">g</code> is the gravitational 
acceleration and <code class="reqn">D_H</code> is the hydraulic depth. The Froude number is related
to the energy state of the flow and can be used to identify flows as
either supercritical (<code class="reqn">Fr &lt; 1</code>) or subcritical (<code class="reqn">Fr &gt; 1</code>).
</p>


<h3>Value</h3>

<p>The Froude Number (dimensionless).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>froude(250, 32.2, 171, 1.71) # subcritical flow
froude(250, 32.2, 57.9, 0.579) # critical flow
froude(250, 32.2, 45, 0.45) # supercritical flow
</code></pre>

<hr>
<h2 id='normal_depth'>Normal depth</h2><span id='topic+normal_depth'></span>

<h3>Description</h3>

<p>Calculate the normal (equilibrium) depth using Manning's equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_depth(So, n, Q, yopt, Cm, B, SS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_depth_+3A_so">So</code></td>
<td>
<p>Channel slope [<code class="reqn">L L^{-1}</code>].</p>
</td></tr>
<tr><td><code id="normal_depth_+3A_n">n</code></td>
<td>
<p>Manning's roughness coefficient.</p>
</td></tr>
<tr><td><code id="normal_depth_+3A_q">Q</code></td>
<td>
<p>Flow rate [<code class="reqn">L^3 T^{-1}</code>].</p>
</td></tr>
<tr><td><code id="normal_depth_+3A_yopt">yopt</code></td>
<td>
<p>Initial guess for normal depth [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="normal_depth_+3A_cm">Cm</code></td>
<td>
<p>Unit conversion coefficient for Manning's equation. For SI units, Cm = 1.</p>
</td></tr>
<tr><td><code id="normal_depth_+3A_b">B</code></td>
<td>
<p>Channel bottom width [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="normal_depth_+3A_ss">SS</code></td>
<td>
<p>Channel sideslope [<code class="reqn">L L^{-1}</code>].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normal depth is the equilibrium depth of a channel for a given 
flow rate, channel slope, geometry and roughness.
Manning's equation is used to calculate the equilibrium depth. Manning's 
equation for normal flow is defined as </p>
<p style="text-align: center;"><code class="reqn">Q = \frac{C_m}{n} AR^{2/3}S_0^{1/2}</code>
</p>

<p>where <code class="reqn">Q</code> is the channel flow, <code class="reqn">S_0</code> is the channel slope, <code class="reqn">A</code> is the 
cross-sectional flow area, <code class="reqn">R</code> is the hydraulic depth and <code class="reqn">C_m</code> is a conversion factor
based on the unit system used. This function uses a Newton-Raphson root-finding approach 
to calculate the normal depth, i.e.
<code class="reqn">y = y_n</code> when </p>
<p style="text-align: center;"><code class="reqn">f(y) = \frac{A^{5/3}}{P^{2/3}} - \frac{nQ}{C_mS_0^{1/2}} = 0</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>The normal depth <code class="reqn">y_n</code> [<code class="reqn">L</code>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal_depth(0.001, 0.045, 250, 3, 1.486, 100, 0) # rectangular channel
normal_depth(0.0008, 0.013, 126, 5, 1, 6.1, 1.5) # trapezoidal channel with sideslope 3H:2V
</code></pre>

<hr>
<h2 id='route_wave'>Flood wave routing</h2><span id='topic+route_wave'></span>

<h3>Description</h3>

<p>Route a flood wave down a prismatic channel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_wave(
  So,
  n,
  Cm,
  g,
  B,
  SS,
  initial.condition,
  boundary.condition,
  downstream.condition,
  timestep,
  spacestep,
  numnodes,
  monitor.nodes,
  monitor.times,
  engine = c("Dynamic", "Kinematic"),
  scheme = c("MacCormack", "Lax"),
  boundary.type = c("QQ", "Qy", "yQ", "yy")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_wave_+3A_so">So</code></td>
<td>
<p>Channel slope [<code class="reqn">L L^{-1}</code>].</p>
</td></tr>
<tr><td><code id="route_wave_+3A_n">n</code></td>
<td>
<p>Manning's roughness coefficient.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_cm">Cm</code></td>
<td>
<p>Unit conversion coefficient for Manning's equation. For SI units, Cm = 1.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_g">g</code></td>
<td>
<p>Gravitational acceleration [<code class="reqn">L T^{-2}</code>].</p>
</td></tr>
<tr><td><code id="route_wave_+3A_b">B</code></td>
<td>
<p>Channel bottom width [<code class="reqn">L</code>].</p>
</td></tr>
<tr><td><code id="route_wave_+3A_ss">SS</code></td>
<td>
<p>Channel sideslope [<code class="reqn">L L^{-1}</code>].</p>
</td></tr>
<tr><td><code id="route_wave_+3A_initial.condition">initial.condition</code></td>
<td>
<p>The initial flow rate [<code class="reqn">L^3 T^{-1}</code>], assumed constant 
throughout the channel.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_boundary.condition">boundary.condition</code></td>
<td>
<p>Vector specifying the upstream boundary condition 
for the full duration of the model. If <code>engine = "Kinematic"</code>, values are 
assumed to be flow [<code class="reqn">L^3 T^{-1}</code>]. If <code>engine = "Dynamic"</code>, the form of the 
boundary condition is determined by the argument <code>boundary.type</code>.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_downstream.condition">downstream.condition</code></td>
<td>
<p>Only used if <code>engine = "Dynamic"</code>. Vector specifying 
the upstream boundary condition for the full duration of the model. Must be the same
length as <code>boundary.condition</code>.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_timestep">timestep</code></td>
<td>
<p>Temporal resolution of the model. Also the assumed time interval [<code class="reqn">T</code>] 
between elements of <code>boundary.condition</code> and <code>downstream.condition</code>. 
The user is responsible for ensuring numerical stability.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_spacestep">spacestep</code></td>
<td>
<p>the spatial resolution of the model, interpreted as the distance [<code class="reqn">L</code>]
between nodes in the model domain. The user is responsible for ensuring numerical stability.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_numnodes">numnodes</code></td>
<td>
<p>The number of nodes used to discretize the channel. The total channel extent is
computed as <code>spacestep*(numnodes - 1)</code>.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_monitor.nodes">monitor.nodes</code></td>
<td>
<p>the nodes to be monitored every time step. Specified as a vector of node 
indices, with 1 being the upstream boundary and <code>numnodes</code> being the downstream boundary.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_monitor.times">monitor.times</code></td>
<td>
<p>the time steps at which to monitor every node. Specified as a vector of 
indices of <code>boundary.condition</code>. Defaults to five equally-spaced time steps including 
the first and last time steps.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_engine">engine</code></td>
<td>
<p>The engine to be used for routing the flood wave. 
May be either &quot;Kinematic&quot; or &quot;Dynamic&quot;.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_scheme">scheme</code></td>
<td>
<p>Only used if <code>engine = "Dynamic"</code>. Specifies whether to use the 
Lax Diffusive scheme or the MacCormack predictor-corrector scheme.</p>
</td></tr>
<tr><td><code id="route_wave_+3A_boundary.type">boundary.type</code></td>
<td>
<p>Only used if <code>engine = "Dynamic"</code>. Specifies what boundary data
is supplied. Possible characters are If <code>boundary.type = "QQ"</code>, both <code>boundary.condition</code>
and <code>downstream.condition</code> are assumed to be flows [<code class="reqn">L^3 T^{-1}</code>]. If 
<code>boundary.type = "Qy"</code> the upstream boundary is assumed to be flow
while the downstream boundary is assumed to be depth [<code class="reqn">L</code>]. Other possibilities
are <code>"yQ"</code> and <code>"yy"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides implementations of a Kinematic Wave Model (KWM) and 
a Dynamic Wave Model (DWM) with the choice of two numerical schemes. The MacCormack 
scheme is a second-order accurate predictor-corrector scheme that provides efficient 
flood wave routing. The Lax diffusive scheme can be used to obtain smooth solutions for
problems with discontinuities in the boundary conditions, e.g. sudden gate closures.
The DWM implementation uses the Method of Characteristics (MOC) to compute the flow 
regime at the model boundaries, and allows the user to specify boundaries in terms of 
depths and/or flows. the KWM implementation assumes the normal depth at the upstream
boundary and is only first-order accurate.
</p>


<h3>Value</h3>

<p>data.frame with columns:
</p>
<table>
<tr><td><code>step</code></td>
<td>
<p>Time step.</p>
</td></tr>
<tr><td><code>node</code></td>
<td>
<p>Node index.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Time since start.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>Downstream distance.</p>
</td></tr>
<tr><td><code>flow</code></td>
<td>
<p>Flow rate.</p>
</td></tr>
<tr><td><code>depth</code></td>
<td>
<p>Flow depth.</p>
</td></tr>
<tr><td><code>velocity</code></td>
<td>
<p>Flow velocity.</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>Flow area.</p>
</td></tr>
<tr><td><code>monitor.type</code></td>
<td>
<p>Row refers to a monitored node (&quot;node&quot;) or timestep (&quot;timestep&quot;).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
# kinematic wave routing
times = seq(0, 30000, by = 25)
floodwave = ifelse(times &gt;= 9000, 250,
  250 + (750/pi)*(1 - cos(pi*times/(60*75))))
route_wave(0.001, 0.045, 1.486, 32.2, 100, 0, initial.condition = 250, 
  boundary.condition = floodwave, timestep = 25, spacestep = 50, 
  numnodes=301, monitor.nodes = c(1, 101, 201, 301), 
  monitor.times = seq(1, length(times), by = 10), engine = "Kinematic")
# dynamic wave routing with zero-gradient downstream condition using MacCormack scheme
route_wave(0.001, 0.045, 1.486, 32.2, 100, 0, initial.condition = 250, 
  boundary.condition = floodwave, downstream.condition = rep(-1, length(times)), 
  timestep = 25, spacestep = 500, numnodes = 31, engine = "Dynamic", 
  scheme = "MacCormack", monitor.nodes = c(1, 11, 21, 31), 
  monitor.times = seq(1, length(times), by = 10))
# mixed boundary conditions (sudden gate closure) using Lax scheme
lax = route_wave(0.00008, 0.013, 1, 9.81, 6.1, 1.5, 
  initial.condition = 126, boundary.condition = rep(5.79, 2001), 
  downstream.condition = rep(0, 2001), timestep = 1, spacestep = 10, 
  numnodes = 501, monitor.nodes = c(1, 151, 251, 301, 501), 
  monitor.times = c(1, 501, 1001, 1501, 2001), 
  engine="Dynamic", scheme="Lax", boundary.type="yQ")
# extract data for a monitored point
require(dplyr)
filter(lax, monitor.type == "node", node == 151)

## End(Not run)
</code></pre>

<hr>
<h2 id='waterolympics'>California Water Olympics</h2><span id='topic+waterolympics'></span>

<h3>Description</h3>

<p>Digitized results from the California Water Olympics. The variables are as follows:
</p>

<ul>
<li><p> t The time (in seconds) since the start of the model run.
</p>
</li>
<li><p> Q The flow rate [<code class="reqn">ft^3 s^{-1}</code>].
</p>
</li>
<li><p> x The distance downstream [<code class="reqn">ft</code>] at which the hydrograph was recorded.
</p>
</li></ul>

<p>The data can be used to validate numerical solutions to flood wave routing for a channel 
under the following conditions:
</p>

<ul>
<li><p> Channel width is 100 feet.
</p>
</li>
<li><p> Channel slope is 0.001.
</p>
</li>
<li><p> Channel extent is 150,000 feet.
</p>
</li>
<li><p> Channel roughness (Manning's n) is 0.045.
</p>
</li>
<li><p> Channel sideslope is 0 (rectangular channel).
</p>
</li>
<li><p> Initial flow rate is 250 cfs.
</p>
</li>
<li><p> Upstream boundary condition is defined as 
</p>
<p style="text-align: center;"><code class="reqn">Q(t &lt; 9000) = 250 + \frac{750}{\pi}(1 - \cos{\frac{\pi t}{4500}})</code>
</p>
 
<p style="text-align: center;"><code class="reqn">Q(t &gt;= 9000) = 250</code>
</p>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(waterolympics)
</code></pre>


<h3>Format</h3>

<p>A data frame with 40 rows and 3 variables
</p>


<h3>References</h3>

<p>Sobey, Rodney. &quot;H11: Hydrograph Routing.&quot; 
Review of One-Dimensional Hydrodynamic and Transport Models. Bay-Delta 
Modeling Forum, 15 June 2001. Web. 13 Mar. 2015. 
&lt;http://www.cwemf.org/1-DReview/&gt;.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
