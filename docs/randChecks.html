<!DOCTYPE html><html><head><title>Help for package randChecks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {randChecks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asIfRandPlot'><p>Graphical Diagnostic of As-If Randomization for Different Assignment Mechanisms</p></a></li>
<li><a href='#asIfRandTest'><p>As-If Randomization Test for Different Assignment Mechanisms: Global Tests and Covariate-by-Covariate Tests</p></a></li>
<li><a href='#getCovMeanDiffs'><p>Covariate Mean Differences</p></a></li>
<li><a href='#getMD'><p>Mahalanobis Distance</p></a></li>
<li><a href='#getStandardizedCovMeanDiffs'><p>Standardized Covariate Mean Differences</p></a></li>
<li><a href='#lalonde'><p>Lalonde (1986) Data</p></a></li>
<li><a href='#lalonde.matched.card'><p>A Cardinality Matched Dataset for the Lalonde (1986) Data</p></a></li>
<li><a href='#lalonde.matched.ps'><p>A 1:1 Propensity Score Matched Dataset for the Lalonde (1986) Data</p></a></li>
<li><a href='#lalondeMatches'><p>Lalonde (1986) Data and Two Matched Datasets</p></a></li>
<li><a href='#lovePlot'><p>Love Plot of Standardized Covariate Mean Differences (along with Permutation Quantiles)</p></a></li>
<li><a href='#lovePlotCompare'><p>Love Plot of Standardized Covariate Mean Differences (along with Permutation Quantiles)</p></a></li>
<li><a href='#randChecks-internal'><p>Internal <code>randChecks</code> functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Covariate Balance Checks: Randomization Tests and Graphical
Diagnostics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Zach Branson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zach Branson &lt;zach@stat.cmu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides randomization tests and graphical diagnostics for assessing randomized assignment and covariate balance for a binary treatment variable. See Branson (2021) &lt;<a href="https://doi.org/10.48550/arXiv.1804.08760">doi:10.48550/arXiv.1804.08760</a>&gt; for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-18 18:59:02 UTC; zjbranson</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-18 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='asIfRandPlot'>Graphical Diagnostic of As-If Randomization for Different Assignment Mechanisms</h2><span id='topic+asIfRandPlot'></span>

<h3>Description</h3>

<p><code>asIfRandPlot</code> produces a plot showing the distribution of the Mahalanobis distance for different assignment mechanisms, along with the observed Mahalanobis distance. If the observed Mahalanobis distance is well within the range of a particular distribution, then that suggests that a particular assignment mechanism holds. This function supports the following assignment mechanisms:
</p>

<ul>
<li><p> Complete randomization (&quot;complete&quot;): Corresponds to random permutations of the indicator across units.
</p>
</li>
<li><p> Block randomization (&quot;blocked&quot;): Corresponds to random permutations of the indicator within blocks of units.
</p>
</li>
<li><p> Constrained-differences randomization (&quot;constrained diffs&quot;): Corresponds to random permutations of the indicator across units, conditional on the standardized covariate mean differences being below some threshold.
</p>
</li>
<li><p> Constrained-Mahalanobis randomization (&quot;constrained md&quot;): Corresponds to random permutations of the indicator across units, conditional on the Mahalanobis being below some threshold.
</p>
</li>
<li><p> Blocked Constrained-differences randomization (&quot;blocked constrained diffs&quot;): Corresponds to random permutations of the indicator within blocks of units, conditional on the standardized covariate mean differences being below some threshold.
</p>
</li>
<li><p> Blocked Constrained-Mahalanobis randomization (&quot;blocked constrained md&quot;): Corresponds to random permutations of the indicator within blocks of units, conditional on the Mahalanobis being below some threshold.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>asIfRandPlot(X.matched, indicator.matched,
  assignment = c("complete"),
  subclass = NULL, threshold = NULL,
  perms = 1000,
  X.full = NULL, indicator.full = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asIfRandPlot_+3A_x.matched">X.matched</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the matched dataset.</p>
</td></tr>
<tr><td><code id="asIfRandPlot_+3A_indicator.matched">indicator.matched</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the matched dataset.</p>
</td></tr>
<tr><td><code id="asIfRandPlot_+3A_assignment">assignment</code></td>
<td>
<p>A vector of assignment mechanisms that the user wants to visualize; the user can test one assignment mechanism or multiple. The possible choices are &quot;complete&quot;, &quot;blocked&quot;, &quot;constrained diffs&quot;, &quot;constrained md&quot;, &quot;blocked constrained diffs&quot;, and &quot;blocked constrained md&quot;. See Description for more details on these assignment mechanisms.</p>
</td></tr>
<tr><td><code id="asIfRandPlot_+3A_subclass">subclass</code></td>
<td>
<p>A vector denoting the subclass/block for each subject/unit. This must be specified only if one of the blocked assignment mechanisms are used.</p>
</td></tr>
<tr><td><code id="asIfRandPlot_+3A_threshold">threshold</code></td>
<td>
<p>The threshold used within the constrained assignment mechanisms; thus, this must be specified only if one of the constrained assignment mechanisms are used. This can be a single number or a vector of numbers (e.g., if one wants to use a different threshold for each covariate when testing constrained-differences randomization).</p>
</td></tr>
<tr><td><code id="asIfRandPlot_+3A_perms">perms</code></td>
<td>
<p>The number of permutations used within the randomization test. A larger number requires more computation time but results in a more consistent p-value.</p>
</td></tr>
<tr><td><code id="asIfRandPlot_+3A_x.full">X.full</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the full, unmatched dataset if available.</p>
</td></tr>
<tr><td><code id="asIfRandPlot_+3A_indicator.full">indicator.full</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the full, unmatched dataset if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments X.full and indicator.full (i.e., the covariate matrix and indicator for the full, unmatched dataset) are only used to correctly define the standardized covariate mean differences and Mahalanobis distance. Technically, the covariate mean differences should be standardized by the pooled variance within the full, unmatched dataset, instead of within the matched dataset. If X.full and indicator.full are unspecified, the pooled variance within the matched dataset is used for standardization instead. This distinction rarely leads to large differences in the resulting standardized covariate mean differences, and so researchers should feel comfortable only specifying X.matched and indicator.matched if only a matched dataset is available. Furthermore, if one wants to make this plot for a full, unmatched dataset, then they should only specify X.matched and indicator.matched.
</p>


<h3>Value</h3>

<p>A plot showing the distribution of the Mahalanobis distance for different assignment mechanisms, along with the observed Mahalanobis distance. Also returns a p-value for each assignment mechanism - this is simply the area of the distribution more extreme than the observed Mahalanobis distance. This is the same as <code>asIfRandTest()</code> using the Mahalanobis distance as a test statistic.
</p>


<h3>Author(s)</h3>

<p>Zach Branson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#This loads the classic Lalonde (1986) dataset,
	#as well as two matched datasets:
	#one from 1:1 propensity score matching,
	#and one from cardinality matching, where
	#the standardized covariate mean differences are all below 0.1.
	data("lalondeMatches")
	
	#obtain the covariates for these datasets
	X.lalonde = subset(lalonde, select = -c(treat))
	X.matched.ps = subset(lalonde.matched.ps, select = -c(treat,subclass))
	X.matched.card = subset(lalonde.matched.card, select = -c(treat,subclass))
	#the treatment indicators are
	indicator.lalonde = lalonde$treat
	indicator.matched.ps = lalonde.matched.ps$treat
	indicator.matched.card = lalonde.matched.card$treat

	#the subclass for the matched datasets are
	subclass.matched.ps = lalonde.matched.ps$subclass
	subclass.matched.card = lalonde.matched.card$subclass
	

	#The following lines of code create diagnostic plots assessing
	#whether the treatment follows different assignment mechanisms.
	
	#Note that the following examples only use 100 permutations
	#to approximate the randomization distribution.
	#In practice, we recommend setting perms = 1000 or more;
	#in these examples we use perms = 50 to save computation time.
	
	#Assessing complete randomization for the full dataset
	#Here, complete randomization clearly does not hold,
	#because the observed Mahalanobis distance is far outside
	#the complete randomization distribution.
	asIfRandPlot(X.matched = X.lalonde, indicator.matched = indicator.lalonde, perms = 50)

	#Assessing complete and block (paired) randomization for
	#the propensity score matched dataset
	#Again, complete and block randomization appear to not hold
	#because the observed Mahalanobis distance is far outside
	#the randomization distributions.
	asIfRandPlot(X.matched = X.matched.ps, indicator.matched = indicator.matched.ps,
		X.full = X.lalonde, indicator.full = indicator,
  		assignment = c("complete", "blocked"),
  		subclass = lalonde.matched.ps$subclass,
  		perms = 50)
	
	#Assessing three assignment mechanisms for the
	#cardinality matched dataset:
	# 1) complete randomization
	# 2) blocked (paired) randomization
	# 3) constrained-MD randomization
	#Note that the Mahalanobis distance is approximately a chi^2_K distribution,
	#where K is the number of covariates. In the Lalonde data, K = 8.
	#Thus, the threshold can be chosen as the quantile of the chi^2_8 distribution.
	#This threshold constrains the Mahalanobis distance to be below the 25-percent quantile:
	a = qchisq(p = 0.25, df = 8)
	#Then, we can assess these three assignment mechanisms with the plot below.
	#Here, these assignment mechanisms seem plausible,
	#because the observed Mahalanobis distance is well
	#within the randomization distributions.
	asIfRandPlot(X.matched = X.matched.card, indicator.matched = indicator.matched.card,
		X.full = X.lalonde, indicator.full = indicator,
  		assignment = c("complete", "blocked", "constrained md"),
  		subclass = lalonde.matched.card$subclass,
  		threshold = a,
  		perms = 50)
</code></pre>

<hr>
<h2 id='asIfRandTest'>As-If Randomization Test for Different Assignment Mechanisms: Global Tests and Covariate-by-Covariate Tests</h2><span id='topic+asIfRandTest'></span>

<h3>Description</h3>

<p><code>asIfRandTest</code> computes p-values testing whether an indicator follows a given assignment mechanism, based on observed covariates. This function supports the following assignment mechanisms:
</p>

<ul>
<li><p> Complete randomization (&quot;complete&quot;): Corresponds to random permutations of the indicator across units.
</p>
</li>
<li><p> Block randomization (&quot;blocked&quot;): Corresponds to random permutations of the indicator within blocks of units.
</p>
</li>
<li><p> Constrained-differences randomization (&quot;constrained diffs&quot;): Corresponds to random permutations of the indicator across units, conditional on the standardized covariate mean differences being below some threshold.
</p>
</li>
<li><p> Constrained-Mahalanobis randomization (&quot;constrained md&quot;): Corresponds to random permutations of the indicator across units, conditional on the Mahalanobis being below some threshold.
</p>
</li>
<li><p> Blocked Constrained-differences randomization (&quot;blocked constrained diffs&quot;): Corresponds to random permutations of the indicator within blocks of units, conditional on the standardized covariate mean differences being below some threshold.
</p>
</li>
<li><p> Blocked Constrained-Mahalanobis randomization (&quot;blocked constrained md&quot;): Corresponds to random permutations of the indicator within blocks of units, conditional on the Mahalanobis being below some threshold.
</p>
</li></ul>

<p>The null hypothesis is that the assignment mechanism holds. A large p-value does not prove that the assumption holds, but a small p-value implies that the assumption doesn't hold. These p-values are exact, in the sense that they only rely on permutations within the data and not asymptotic approximations.
</p>
<p>In addition to specifying different assignment mechanisms, the user can specify two different test statistics:
</p>

<ul>
<li><p> The Mahalanobis distance (&quot;mahalanobis&quot;). This acts as a global test statistic, and thus only one p-value is computed.
</p>
</li>
<li><p> The standardized covariate mean differences (&quot;diffs&quot;). This acts as a covariate-by-covariate test statistic, and thus a p-value for each covariate is computed.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>asIfRandTest(X.matched, indicator.matched,
  assignment = c("complete"),
  statistic = "mahalanobis",
  subclass = NULL, threshold = NULL,
  perms = 1000,
  X.full = NULL, indicator.full = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asIfRandTest_+3A_x.matched">X.matched</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the matched dataset.</p>
</td></tr>
<tr><td><code id="asIfRandTest_+3A_indicator.matched">indicator.matched</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the matched dataset.</p>
</td></tr>
<tr><td><code id="asIfRandTest_+3A_assignment">assignment</code></td>
<td>
<p>A vector of assignment mechanisms that the user wants to test; the user can test one assignment mechanism or multiple. The possible choices are &quot;complete&quot;, &quot;blocked&quot;, &quot;constrained diffs&quot;, &quot;constrained md&quot;, &quot;blocked constrained diffs&quot;, and &quot;blocked constrained md&quot;. See Description for more details on these assignment mechanisms.</p>
</td></tr>
<tr><td><code id="asIfRandTest_+3A_statistic">statistic</code></td>
<td>
<p>The test statistic used in the randomization test. The choices are either &quot;mahalanobis&quot; (the Mahalanobis distance) or &quot;diffs&quot; (the standardized covariate mean differences). The former runs a global test and provides one p-value; the latter runs covariate-by-covariate tests and provides a p-value for each covariate.</p>
</td></tr>
<tr><td><code id="asIfRandTest_+3A_subclass">subclass</code></td>
<td>
<p>A vector denoting the subclass/block for each subject/unit. This must be specified only if one of the blocked assignment mechanisms are used.</p>
</td></tr>
<tr><td><code id="asIfRandTest_+3A_threshold">threshold</code></td>
<td>
<p>The threshold used within the constrained assignment mechanisms; thus, this must be specified only if one of the constrained assignment mechanisms are used. This can be a single number or a vector of numbers (e.g., if one wants to use a different threshold for each covariate when testing constrained-differences randomization).</p>
</td></tr>
<tr><td><code id="asIfRandTest_+3A_perms">perms</code></td>
<td>
<p>The number of permutations used within the randomization test. A larger number requires more computation time but results in a more consistent p-value.</p>
</td></tr>
<tr><td><code id="asIfRandTest_+3A_x.full">X.full</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the full, unmatched dataset if available.</p>
</td></tr>
<tr><td><code id="asIfRandTest_+3A_indicator.full">indicator.full</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the full, unmatched dataset if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments X.full and indicator.full (i.e., the covariate matrix and indicator for the full, unmatched dataset) are only used to correctly define the standardized covariate mean differences and Mahalanobis distance. Technically, the covariate mean differences should be standardized by the pooled variance within the full, unmatched dataset, instead of within the matched dataset. If X.full and indicator.full are unspecified, the pooled variance within the matched dataset is used for standardization instead. This distinction rarely leads to large differences in the resulting standardized covariate mean differences, and so researchers should feel comfortable only specifying X.matched and indicator.matched if only a matched dataset is available. Furthermore, if one wants to run this test for a full, unmatched dataset, then they should only specify X.matched and indicator.matched.
</p>


<h3>Value</h3>

<p>p-values assessing as-if randomization of an indicator for different assignment mechanisms. If the Mahalanobis distance is used as a test statistic, then a vector of p-values is reported is reported (one for each assignment mechanism). If the standardized covariate mean differences are used as a test statistic, then a table of p-values is reported, where the rows correspond to assignment mechanisms and the columns correspond to covariates.
</p>


<h3>Author(s)</h3>

<p>Zach Branson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#This loads the classic Lalonde (1986) dataset,
	#as well as two matched datasets:
	#one from 1:1 propensity score matching,
	#and one from cardinality matching, where
	#the standardized covariate mean differences are all below 0.1.
	data("lalondeMatches")
	
	#obtain the covariates for these datasets
	X.lalonde = subset(lalonde, select = -c(treat))
	X.matched.ps = subset(lalonde.matched.ps, select = -c(treat,subclass))
	X.matched.card = subset(lalonde.matched.card, select = -c(treat,subclass))
	#the treatment indicators are
	indicator.lalonde = lalonde$treat
	indicator.matched.ps = lalonde.matched.ps$treat
	indicator.matched.card = lalonde.matched.card$treat

	#the subclass for the matched datasets are
	subclass.matched.ps = lalonde.matched.ps$subclass
	subclass.matched.card = lalonde.matched.card$subclass
	
	#Note that the following examples only use 100 permutations
	#to approximate the randomization distribution.
	#In practice, we recommend setting perms = 1000 or more;
	#in these examples we use perms = 50 to save computation time.

	#testing complete randomization for the full dataset
	#using the Mahalanobis distance.
	#We reject complete randomization in this test.
	asIfRandTest(X.matched = X.lalonde, indicator.matched = indicator.lalonde, perms = 50)
	#testing complete randomization for the full dataset
	#using standardized covariate mean differences.
	#We reject complete randomization for most covariates:
	asIfRandTest(X.matched = X.lalonde, indicator.matched = indicator.lalonde,
  		statistic = "diffs",
  		perms = 50)

	#testing complete randomization and block (paired) randomization
	#for the propensity score matched dataset
	#using the Mahalanobis distance.
	#We reject both assignment mechanisms in this test.
	asIfRandTest(X.matched = X.matched.ps, indicator.matched = indicator.matched.ps,
		X.full = X.lalonde, indicator.full = indicator.lalonde,
  		assignment = c("complete", "blocked"),
		subclass = lalonde.matched.ps$subclass,
		perms = 50)
	#testing complete randomization and block (paired) randomization
	#for the propensity score matched dataset
	#using the standardized covariate mean differences.
	#We reject these assignment mechanisms for
	#the race covariates (hispan and black):
	asIfRandTest(X.matched = X.matched.ps, indicator.matched = indicator.matched.ps,
		X.full = X.lalonde, indicator.full = indicator.lalonde,
  		assignment = c("complete", "blocked"),
  		subclass = lalonde.matched.ps$subclass,
		statistic = "diffs",
		perms = 50)

	#testing three assignment mechanisms for
	#the cardinality matched dataset:
	# 1) complete randomization
	# 2) blocked (paired) randomization
	# 3) constrained-MD randomization
	#Note that the Mahalanobis distance is approximately a chi^2_K distribution,
	#where K is the number of covariates. In the Lalonde data, K = 8.
	#Thus, the threshold can be chosen as the quantile of the chi^2_8 distribution.
	#This threshold constrains the Mahalanobis distance to be below the 25-percent quantile:
	a = qchisq(p = 0.25, df = 8)
	#First we'll run the test using the Mahalanobis distance.
	#We fail to reject for the first two assignment mechanisms,
	#but reject the third.
	asIfRandTest(X.matched = X.matched.card, indicator.matched = indicator.matched.card,
		X.full = X.lalonde, indicator.full = indicator.lalonde,
  		assignment = c("complete", "blocked", "constrained md"),
  		subclass = lalonde.matched.card$subclass,
  		threshold = a,
  		perms = 50)
  	#Now we'll run the test using the standardized covariate mean differences.
  	#Interestingly, you fail to reject for all three assignment mechanisms
  	#for all covariates:
  	asIfRandTest(X.matched = X.matched.card, indicator.matched = indicator.matched.card,
  		X.full = X.lalonde, indicator.full = indicator.lalonde,
  		assignment = c("complete", "blocked", "constrained md"),
  		subclass = lalonde.matched.card$subclass,
  		threshold = a,
  		statistic = "diffs",
  		perms = 50)
</code></pre>

<hr>
<h2 id='getCovMeanDiffs'>Covariate Mean Differences</h2><span id='topic+getCovMeanDiffs'></span>

<h3>Description</h3>

<p><code>getCovMeanDiffs</code> computes the covariate mean differences between a treatment and control group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCovMeanDiffs(X, indicator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovMeanDiffs_+3A_x">X</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates).</p>
</td></tr>
<tr><td><code id="getCovMeanDiffs_+3A_indicator">indicator</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariate mean differences between a treatment and control group, defined as treatment minus control.
</p>


<h3>Author(s)</h3>

<p>Zach Branson
</p>


<h3>See Also</h3>

<p>See also <code>lalondeMatches</code> for details about the Lalonde and matched datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#This loads the classic Lalonde (1986) dataset,
	#as well as two matched datasets:
	#one from 1:1 propensity score matching,
	#and one from cardinality matching, where
	#the standardized covariate mean differences are all below 0.1.
	data("lalondeMatches")

	#obtain the covariates for these datasets
	X.lalonde = subset(lalonde, select = -c(treat))
	X.matched.ps = subset(lalonde.matched.ps, select = -c(treat,subclass))
	X.matched.card = subset(lalonde.matched.card, select = -c(treat,subclass))
	#the treatment indicators are
	indicator.lalonde = lalonde$treat
	indicator.matched.ps = lalonde.matched.ps$treat
	indicator.matched.card = lalonde.matched.card$treat
	
	#the covariate mean differences are:
	getCovMeanDiffs(X = X.lalonde, indicator = indicator.lalonde)
	getCovMeanDiffs(X = X.matched.ps, indicator = indicator.matched.ps)
	getCovMeanDiffs(X = X.matched.card, indicator = indicator.matched.card)
</code></pre>

<hr>
<h2 id='getMD'>Mahalanobis Distance</h2><span id='topic+getMD'></span>

<h3>Description</h3>

<p><code>getMD</code> computes the Mahalanobis distance of the covariate means between a treatment and control group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMD(X.matched, indicator.matched,
	covX.inv = NULL,
	X.full = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMD_+3A_x.matched">X.matched</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the matched dataset.</p>
</td></tr>
<tr><td><code id="getMD_+3A_indicator.matched">indicator.matched</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the matched dataset.</p>
</td></tr>
<tr><td><code id="getMD_+3A_covx.inv">covX.inv</code></td>
<td>
<p>The inverse of X's covariance matrix. Almost always this should be set to NULL, and <code>getMD</code> will compute the inverse of the covariance matrix automatically.</p>
</td></tr>
<tr><td><code id="getMD_+3A_x.full">X.full</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the full, unmatched dataset if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument X.full (i.e., the covariate matrix for the full, unmatched dataset) is only used to correctly define the Mahalanobis distance after matching. Technically, the Mahalanobis distance should be standardized by the covariance matrix within the full, unmatched dataset, instead of within the matched dataset. If X.full is unspecified, the covariance matrix within the matched dataset is used instead. This distinction rarely leads to large differences in the resulting distance, and so researchers should feel comfortable only specifying X.matched and indicator.matched if only a matched dataset is available. Furthermore, if one wants to compute the Mahalanobis distance for a full, unmatched dataset, then they should only specify X.matched and indicator.matched.
</p>


<h3>Value</h3>

<p>The Mahalanobis distance of the covariate means between a treatment and control group.
</p>


<h3>Author(s)</h3>

<p>Zach Branson
</p>


<h3>References</h3>

<p>Mahalanobis, P. C. (1936). On the generalized distance in statistics. National Institute of Science of India, 1936.
</p>


<h3>See Also</h3>

<p>See also <code>lalondeMatches</code> for details about the Lalonde and matched datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#This loads the classic Lalonde (1986) dataset,
	#as well as two matched datasets:
	#one from 1:1 propensity score matching,
	#and one from cardinality matching, where
	#the standardized covariate mean differences are all below 0.1.
	data("lalondeMatches")

	#obtain the covariates for these datasets
	X.lalonde = subset(lalonde, select = -c(treat))
	X.matched.ps = subset(lalonde.matched.ps, select = -c(treat,subclass))
	X.matched.card = subset(lalonde.matched.card, select = -c(treat,subclass))
	#the treatment indicators are
	indicator.lalonde = lalonde$treat
	indicator.matched.ps = lalonde.matched.ps$treat
	indicator.matched.card = lalonde.matched.card$treat
	
	#the Mahalanobis distance for each dataset is:
	getMD(X.matched = X.lalonde, indicator.matched = indicator.lalonde)
	getMD(X.matched = X.matched.ps, indicator.matched = indicator.matched.ps,
		X.full = X.lalonde)
	getMD(X.matched = X.matched.card, indicator.matched = indicator.matched.card,
		X.full = X.lalonde)
</code></pre>

<hr>
<h2 id='getStandardizedCovMeanDiffs'>Standardized Covariate Mean Differences</h2><span id='topic+getStandardizedCovMeanDiffs'></span>

<h3>Description</h3>

<p><code>getStandardizedCovMeanDiffs</code> computes the standardized covariate mean differences between a treatment and control group, defined as treatment minus control. The standardized covariate mean differences are defined as the covariate mean differences divided by the square-root of the pooled variance between groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStandardizedCovMeanDiffs(X.matched, indicator.matched,
	X.full = NULL, indicator.full = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStandardizedCovMeanDiffs_+3A_x.matched">X.matched</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the matched dataset.</p>
</td></tr>
<tr><td><code id="getStandardizedCovMeanDiffs_+3A_indicator.matched">indicator.matched</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the matched dataset.</p>
</td></tr>
<tr><td><code id="getStandardizedCovMeanDiffs_+3A_x.full">X.full</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the full, unmatched dataset if available.</p>
</td></tr>
<tr><td><code id="getStandardizedCovMeanDiffs_+3A_indicator.full">indicator.full</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the full, unmatched dataset if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments X.full and indicator.full (i.e., the covariate matrix and indicator for the full, unmatched dataset) are only used to correctly define the standardized covariate mean differences. Technically, the covariate mean differences should be standardized by the pooled variance within the full, unmatched dataset, instead of within the matched dataset. If X.full and indicator.full are unspecified, the pooled variance within the matched dataset is used for standardization instead. This distinction rarely leads to large differences in the resulting standardized covariate mean differences, and so researchers should feel comfortable only specifying X.matched and indicator.matched if only a matched dataset is available. Furthermore, if one wants to compute the standardized mean differences for a full, unmatched dataset, then they should only specify X.matched and indicator.matched.
</p>


<h3>Value</h3>

<p>The standardized covariate mean differences between a treatment and control group, defined as treatment minus control.
</p>


<h3>Author(s)</h3>

<p>Zach Branson
</p>


<h3>See Also</h3>

<p>See also <code>lalondeMatches</code> for details about the Lalonde and matched datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#This loads the classic Lalonde (1986) dataset,
	#as well as two matched datasets:
	#one from 1:1 propensity score matching,
	#and one from cardinality matching, where
	#the standardized covariate mean differences are all below 0.1.
	data("lalondeMatches")
	
	#obtain the covariates for these datasets
	X.lalonde = subset(lalonde, select = -c(treat))
	X.matched.ps = subset(lalonde.matched.ps, select = -c(treat,subclass))
	X.matched.card = subset(lalonde.matched.card, select = -c(treat,subclass))
	#the treatment indicators are
	indicator.lalonde = lalonde$treat
	indicator.matched.ps = lalonde.matched.ps$treat
	indicator.matched.card = lalonde.matched.card$treat
	
	#the standardized covariate mean differences
	#for these three datasets are:
	getStandardizedCovMeanDiffs(
		X.matched = X.lalonde,
		indicator.matched = indicator.lalonde)
	getStandardizedCovMeanDiffs(
		X.matched = X.matched.ps,
		indicator.matched = indicator.matched.ps,
		X.full = X.lalonde,
		indicator.full = indicator.lalonde)
	getStandardizedCovMeanDiffs(
		X.matched = X.matched.card,
		indicator.matched = indicator.matched.card,
		X.full = X.lalonde,
		indicator.full = indicator.lalonde)
</code></pre>

<hr>
<h2 id='lalonde'>Lalonde (1986) Data</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p>Data from Lalonde (1986).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalondeMatches)</code></pre>


<h3>Format</h3>

<p>The full Lalonde (1986) dataset, containing 614 units (rows) and 9 variables (columns). The columns are:
</p>

<ul>
<li> <p><code>treat</code>: A binary treatment variable. Equal to 1 if treated in the National Supported Work Demonstration; equal to 0 otherwise.
</p>
</li>
<li> <p><code>age</code>: age in years.
</p>
</li>
<li> <p><code>educ</code>: years of education.
</p>
</li>
<li> <p><code>black</code>: an indicator variable, equal to 1 only if the subject is black.
</p>
</li>
<li> <p><code>hispan</code>: an indicator variable, equal to 1 only if the subject is hispanic.
</p>
</li>
<li> <p><code>married</code>: an indicator variable, equal to 1 only if the subject is married.
</p>
</li>
<li> <p><code>nodegree</code>: an indicator variable, equal to 1 only if the subject does not have a degree.
</p>
</li>
<li> <p><code>re74</code>: earnings in 1974.
</p>
</li>
<li> <p><code>re75</code>: earnings in 1975.
</p>
</li></ul>

<p>All of the columns except <code>treat</code> are covariates; in these datasets, the outcome variable is not provided.
</p>


<h3>References</h3>

	
<p>LaLonde, R. J. (1986). Evaluating the econometric evaluations of training programs with experimental data. The American Economic Review, 604-620.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lalonde)
lalonde
</code></pre>

<hr>
<h2 id='lalonde.matched.card'>A Cardinality Matched Dataset for the Lalonde (1986) Data</h2><span id='topic+lalonde.matched.card'></span>

<h3>Description</h3>

<p>Data from Lalonde (1986) and two matched datasets: One where optimal 1:1 propensity score matching was used, and one where cardinality matching was used, with the balance constraint that all standardized covariate mean differences be below 0.1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalondeMatches)</code></pre>


<h3>Format</h3>

<p>240 units (rows) and 10 variables (columns). The columns are:
</p>

<ul>
<li> <p><code>treat</code>: A binary treatment variable. Equal to 1 if treated in the National Supported Work Demonstration; equal to 0 otherwise.
</p>
</li>
<li> <p><code>age</code>: age in years.
</p>
</li>
<li> <p><code>educ</code>: years of education.
</p>
</li>
<li> <p><code>black</code>: an indicator variable, equal to 1 only if the subject is black.
</p>
</li>
<li> <p><code>hispan</code>: an indicator variable, equal to 1 only if the subject is hispanic.
</p>
</li>
<li> <p><code>married</code>: an indicator variable, equal to 1 only if the subject is married.
</p>
</li>
<li> <p><code>nodegree</code>: an indicator variable, equal to 1 only if the subject does not have a degree.
</p>
</li>
<li> <p><code>re74</code>: earnings in 1974.
</p>
</li>
<li> <p><code>re75</code>: earnings in 1975.
</p>
</li>
<li> <p><code>subclass</code>: The subclass denoting the pairs within the matched dataset.
</p>
</li></ul>



<h3>Details</h3>

<p>The cardinality matched datset was produced using the <code>designmatch</code> <code>R</code> package.
</p>


<h3>References</h3>

	
<p>LaLonde, R. J. (1986). Evaluating the econometric evaluations of training programs with experimental data. The American Economic Review, 604-620.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(lalondeMatches)
	lalonde.matched.card
</code></pre>

<hr>
<h2 id='lalonde.matched.ps'>A 1:1 Propensity Score Matched Dataset for the Lalonde (1986) Data</h2><span id='topic+lalonde.matched.ps'></span>

<h3>Description</h3>

<p>A optimal 1:1 propensity score matched dataset for the Lalonde (1986) dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalondeMatches)</code></pre>


<h3>Format</h3>

<p>370 units (rows) and 10 variables (columns). The columns are:
</p>

<ul>
<li> <p><code>treat</code>: A binary treatment variable. Equal to 1 if treated in the National Supported Work Demonstration; equal to 0 otherwise.
</p>
</li>
<li> <p><code>age</code>: age in years.
</p>
</li>
<li> <p><code>educ</code>: years of education.
</p>
</li>
<li> <p><code>black</code>: an indicator variable, equal to 1 only if the subject is black.
</p>
</li>
<li> <p><code>hispan</code>: an indicator variable, equal to 1 only if the subject is hispanic.
</p>
</li>
<li> <p><code>married</code>: an indicator variable, equal to 1 only if the subject is married.
</p>
</li>
<li> <p><code>nodegree</code>: an indicator variable, equal to 1 only if the subject does not have a degree.
</p>
</li>
<li> <p><code>re74</code>: earnings in 1974.
</p>
</li>
<li> <p><code>re75</code>: earnings in 1975.
</p>
</li>
<li> <p><code>subclass</code>: The subclass denoting the pairs within the matched dataset.
</p>
</li></ul>



<h3>Details</h3>

<p>The optimal 1:1 propensity score matched dataset was produced using the <code>MatchIt</code> <code>R</code> package. The propensity scores were estimated using logistic regression, where <code>treat</code> was the outcome and the other variables were the covariates (within no interactions included).
</p>


<h3>References</h3>

	
<p>LaLonde, R. J. (1986). Evaluating the econometric evaluations of training programs with experimental data. The American Economic Review, 604-620.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(lalondeMatches)
	lalonde.matched.ps
</code></pre>

<hr>
<h2 id='lalondeMatches'>Lalonde (1986) Data and Two Matched Datasets</h2><span id='topic+lalondeMatches'></span>

<h3>Description</h3>

<p>Data from Lalonde (1986) and two matched datasets: One where optimal 1:1 propensity score matching was used, and one where cardinality matching was used, with the balance constraint that all standardized covariate mean differences be below 0.1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalondeMatches)</code></pre>


<h3>Format</h3>

<p>Three data frames:
</p>

<ul>
<li> <p><code>lalonde</code>: 614 units (rows) and 9 variables (columns). This is the full Lalonde (1986) dataset.
</p>
</li>
<li> <p><code>lalonde.matched.ps</code>: 370 units (rows) and 10 variables (columns). This is the 1:1 propensity score matched dataset.
</p>
</li>
<li> <p><code>lalonde.matched.card</code>: 240 units (rows) and 10 variables (columns). This is the cardinality matched dataset.
</p>
</li></ul>

<p>All three data frames have these 9 columns:
</p>

<ul>
<li> <p><code>treat</code>: A binary treatment variable. Equal to 1 if treated in the National Supported Work Demonstration; equal to 0 otherwise.
</p>
</li>
<li> <p><code>age</code>: age in years.
</p>
</li>
<li> <p><code>educ</code>: years of education.
</p>
</li>
<li> <p><code>black</code>: an indicator variable, equal to 1 only if the subject is black.
</p>
</li>
<li> <p><code>hispan</code>: an indicator variable, equal to 1 only if the subject is hispanic.
</p>
</li>
<li> <p><code>married</code>: an indicator variable, equal to 1 only if the subject is married.
</p>
</li>
<li> <p><code>nodegree</code>: an indicator variable, equal to 1 only if the subject does not have a degree.
</p>
</li>
<li> <p><code>re74</code>: earnings in 1974.
</p>
</li>
<li> <p><code>re75</code>: earnings in 1975.
</p>
</li></ul>

<p>All of the columns except <code>treat</code> are covariates; in these datasets, the outcome variable is not provided.
</p>
<p>Meanwhile, <code>lalonde.matched.ps</code> and <code>lalonde.matched.card</code> have one additional column, <code>subclass</code>, denoting the pairs for those matched datasets.
</p>


<h3>Details</h3>

<p>The optimal 1:1 propensity score matched dataset was produced using the <code>MatchIt</code> <code>R</code> package. The propensity scores were estimated using logistic regression, where <code>treat</code> was the outcome and the other variables were the covariates (within no interactions included).
</p>
<p>The cardinality matched datset was produced using the <code>designmatch</code> <code>R</code> package.
</p>


<h3>References</h3>

	
<p>LaLonde, R. J. (1986). Evaluating the econometric evaluations of training programs with experimental data. The American Economic Review, 604-620.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lalondeMatches)
</code></pre>

<hr>
<h2 id='lovePlot'>Love Plot of Standardized Covariate Mean Differences (along with Permutation Quantiles)</h2><span id='topic+lovePlot'></span>

<h3>Description</h3>

<p><code>lovePlot</code> produces a Love plot displaying the standardized covariate mean differences (produced by <code>getStandardizedCovMeanDiffs()</code>). This function can also produce permutation quantiles for different assignment mechanisms - if a standardized covariate mean difference is outside these quantiles, then that is evidence that the assignment mechanism does not hold. This function supports the following assignment mechanisms:
</p>

<ul>
<li><p> Complete randomization (&quot;complete&quot;): Corresponds to random permutations of the indicator across units.
</p>
</li>
<li><p> Block randomization (&quot;blocked&quot;): Corresponds to random permutations of the indicator within blocks of units.
</p>
</li>
<li><p> Constrained-differences randomization (&quot;constrained diffs&quot;): Corresponds to random permutations of the indicator across units, conditional on the standardized covariate mean differences being below some threshold.
</p>
</li>
<li><p> Constrained-Mahalanobis randomization (&quot;constrained md&quot;): Corresponds to random permutations of the indicator across units, conditional on the Mahalanobis being below some threshold.
</p>
</li>
<li><p> Blocked Constrained-differences randomization (&quot;blocked constrained diffs&quot;): Corresponds to random permutations of the indicator within blocks of units, conditional on the standardized covariate mean differences being below some threshold.
</p>
</li>
<li><p> Blocked Constrained-Mahalanobis randomization (&quot;blocked constrained md&quot;): Corresponds to random permutations of the indicator within blocks of units, conditional on the Mahalanobis being below some threshold.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>lovePlot(X.matched, indicator.matched,
  permQuantiles = FALSE,
  assignment = "complete",
  subclass = NULL, threshold = NULL,
  alpha = 0.15, perms = 1000,
  X.full = NULL, indicator.full = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lovePlot_+3A_x.matched">X.matched</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the matched dataset.</p>
</td></tr>
<tr><td><code id="lovePlot_+3A_indicator.matched">indicator.matched</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the matched dataset.</p>
</td></tr>
<tr><td><code id="lovePlot_+3A_permquantiles">permQuantiles</code></td>
<td>
<p>Display permutation quantiles? TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="lovePlot_+3A_assignment">assignment</code></td>
<td>
<p>An assignment mechanism that the user wants to visualize. The possible choices are &quot;complete&quot;, &quot;blocked&quot;, &quot;constrained diffs&quot;, &quot;constrained md&quot;, &quot;blocked constrained diffs&quot;, and &quot;blocked constrained md&quot;. See Description for more details on these assignment mechanisms.</p>
</td></tr>
<tr><td><code id="lovePlot_+3A_subclass">subclass</code></td>
<td>
<p>A vector denoting the subclass/block for each subject/unit. This must be specified only if one of the blocked assignment mechanisms are used.</p>
</td></tr>
<tr><td><code id="lovePlot_+3A_threshold">threshold</code></td>
<td>
<p>The threshold used within the constrained assignment mechanisms; thus, this must be specified only if one of the constrained assignment mechanisms are used. This can be a single number or a vector of numbers (e.g., if one wants to use a different threshold for each covariate when testing constrained-differences randomization).</p>
</td></tr>
<tr><td><code id="lovePlot_+3A_alpha">alpha</code></td>
<td>
<p>The alpha-level of the permutation quantiles, where the lower quantile is the alpha/2 quantile and the upper quantile is the 1-alpha/2 quantile. For example, if alpha = 0.15 (the default), then <code>lovePlot()</code> will display the 7.5-percent and 92.5-percent quantiles of the standardized covariate mean differences.</p>
</td></tr>
<tr><td><code id="lovePlot_+3A_perms">perms</code></td>
<td>
<p>The number of permutations used to compute the permutation quantiles. A larger number requires more computation time but results in a more consistent p-value.</p>
</td></tr>
<tr><td><code id="lovePlot_+3A_x.full">X.full</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the full, unmatched dataset if available.</p>
</td></tr>
<tr><td><code id="lovePlot_+3A_indicator.full">indicator.full</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the full, unmatched dataset if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments X.full and indicator.full (i.e., the covariate matrix and indicator for the full, unmatched dataset) are only used to correctly define the standardized covariate mean differences. Technically, the covariate mean differences should be standardized by the pooled variance within the full, unmatched dataset, instead of within the matched dataset. If X.full and indicator.full are unspecified, the pooled variance within the matched dataset is used for standardization instead. This distinction rarely leads to large differences in the resulting standardized covariate mean differences, and so researchers should feel comfortable only specifying X.matched and indicator.matched if only a matched dataset is available. Furthermore, if one wants to make a Love plot for a full, unmatched dataset, then they should only specify X.matched and indicator.matched.
</p>


<h3>Value</h3>

<p>A Love plot displaying the standardized covariate mean differences. Can also produce permutation quantiles for different assignment mechanisms.
</p>


<h3>Author(s)</h3>

<p>Zach Branson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#This loads the classic Lalonde (1986) dataset,
	#as well as two matched datasets:
	#one from 1:1 propensity score matching,
	#and one from cardinality matching, where
	#the standardized covariate mean differences are all below 0.1.
	data("lalondeMatches")
	
	#obtain the covariates for these datasets
	X.lalonde = subset(lalonde, select = -c(treat))
	X.matched.ps = subset(lalonde.matched.ps, select = -c(treat,subclass))
	X.matched.card = subset(lalonde.matched.card, select = -c(treat,subclass))
	#the treatment indicators are
	indicator.lalonde = lalonde$treat
	indicator.matched.ps = lalonde.matched.ps$treat
	indicator.matched.card = lalonde.matched.card$treat

	#the subclass for the matched datasets are
	subclass.matched.ps = lalonde.matched.ps$subclass
	subclass.matched.card = lalonde.matched.card$subclass

	#The following code will display a classic Love plot
	#(with a dot for each standardized covariate mean difference).
	#Note that, for the full dataset, we only specify X.matched and indicator.matched.
	lovePlot(X.matched = X.lalonde, indicator.matched = indicator.lalonde)
	lovePlot(X.matched = X.matched.ps, indicator.matched = indicator.matched.ps,
	X.full = X.lalonde, indicator.full = indicator.lalonde)
	lovePlot(X.matched = X.matched.card, indicator.matched = indicator.matched.card,
	X.full = X.lalonde, indicator.full = indicator.lalonde)
	
	#The following lines of code create Love plots assessing
	#whether indicator.data follows different assignment mechanisms by
	#plotting the permutation quantiles
	
	#Note that the following examples only use 100 permutations
	#to approximate the randomization distribution.
	#In practice, we recommend setting perms = 1000 or more;
	#in these examples we use perms = 50 to save computation time.
	
	#Assessing complete randomization for the full dataset
	#Here we conclude complete randomization doesn't hold
	#because the standardized covariate mean differences
	#are almost all outside the quantiles.
	lovePlot(X.matched = X.lalonde, indicator.matched = indicator.lalonde,
		permQuantiles = TRUE,
		perms = 50)

	#assessing block (paired) randomization for
	#the 1:1 propensity score matched dataset
	#Many of the standardized covariate mean differences
	#are within the permutation quantiles,
	#but the race covariates (hispan and black)
	#are outside these quantiles.
	lovePlot(X.matched = X.matched.ps, indicator.matched = indicator.matched.ps,
	X.full = X.lalonde, indicator.full = indicator.lalonde,
  		permQuantiles = TRUE,
  		perms = 50,
  		assignment = "blocked", subclass = subclass.matched.ps)

	#assessing block (paired) randomization for
	#the cardinality matched dataset
	#All of the standardized covariate mean differences
	#are within the permutation quantiles
	lovePlot(X.matched = X.matched.card, indicator.matched = indicator.matched.card,
	X.full = X.lalonde, indicator.full = indicator.lalonde,
  		permQuantiles = TRUE,
  		perms = 50,
  		assignment = "blocked", subclass = subclass.matched.card)

	#assessing constrained randomization,
	#where the Mahalanobis distance is constrained.
	#Note that the Mahalanobis distance is approximately
	#a chi^2_K distribution, where K is the number of covariates.
	#In the Lalonde data, K = 8.
	#Thus, the threshold can be chosen as the quantile of the chi^2_8 distribution.
	#This threshold constrains the Mahalanobis distance to be below the 25-percent quantile:
	a = qchisq(p = 0.25, df = 8)
	#Then, the corresponding Love plot and permutation quantiles are:
	lovePlot(X.matched = X.matched.card, indicator.matched = indicator.matched.card,
	X.full = X.lalonde, indicator.full = indicator.lalonde,
  		permQuantiles = TRUE,
  		perms = 50,
  		assignment = "constrained md",
  		threshold = a)
</code></pre>

<hr>
<h2 id='lovePlotCompare'>Love Plot of Standardized Covariate Mean Differences (along with Permutation Quantiles)</h2><span id='topic+lovePlotCompare'></span>

<h3>Description</h3>

<p><code>lovePlotCompare</code> produces a Love plot displaying the standardized covariate mean differences (produced by <code>getStandardizedCovMeanDiffs()</code>) for two different datasets. The dataset with smaller covariate mean differences is deemed the &quot;more balanced&quot; dataset; this is particularly useful when comparing a full dataset to a matched dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lovePlotCompare(X1, indicator1, X2, indicator2, dataNames = c("Dataset1", "Dataset2"),
	X.full = NULL, indicator.full = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lovePlotCompare_+3A_x1">X1</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for one dataset.</p>
</td></tr>
<tr><td><code id="lovePlotCompare_+3A_indicator1">indicator1</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for one dataset.</p>
</td></tr>
<tr><td><code id="lovePlotCompare_+3A_x2">X2</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for another dataset.</p>
</td></tr>
<tr><td><code id="lovePlotCompare_+3A_indicator2">indicator2</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for another dataset.</p>
</td></tr>
<tr><td><code id="lovePlotCompare_+3A_datanames">dataNames</code></td>
<td>
<p>A two-length vector denoting the names of the datasets (used in the legend of the plot).</p>
</td></tr>
<tr><td><code id="lovePlotCompare_+3A_x.full">X.full</code></td>
<td>
<p>A covariate matrix (rows correspond to subjects/units; columns correspond to covariates) for the full, unmatched dataset if available.</p>
</td></tr>
<tr><td><code id="lovePlotCompare_+3A_indicator.full">indicator.full</code></td>
<td>
<p>A vector of 1s and 0s (e.g., denoting treatment and control) for the full, unmatched dataset if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the covariate matrices X1 and X2 have to have the same number of columns and should correspond to the same covariates. However, they do not have to have the same number of rows (i.e., the same number of subjects/units).
</p>
<p>Furthermore, the arguments X.full and indicator.full (i.e., the covariate matrix and indicator for the full, unmatched dataset) are only used to correctly define the standardized covariate mean differences. Technically, the covariate mean differences should be standardized by the pooled variance within the full, unmatched dataset, instead of within the matched dataset. If X.full and indicator.full are unspecified, the pooled variance within the matched dataset is used for standardization instead. This distinction rarely leads to large differences in the resulting standardized covariate mean differences, and so researchers should feel comfortable only specifying X1, X2, indicator1, and indicator2 if a full, unmatched dataset is not available.
</p>


<h3>Value</h3>

<p>A Love plot displaying the standardized covariate mean differences for two datasets.
</p>


<h3>Author(s)</h3>

<p>Zach Branson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#This loads the classic Lalonde (1986) dataset,
	#as well as two matched datasets:
	#one from 1:1 propensity score matching,
	#and one from cardinality matching, where
	#the standardized covariate mean differences are all below 0.1.
	data("lalondeMatches")
	
	#obtain the covariates for these datasets
	X.lalonde = subset(lalonde, select = -c(treat))
	X.matched.ps = subset(lalonde.matched.ps, select = -c(treat,subclass))
	X.matched.card = subset(lalonde.matched.card, select = -c(treat,subclass))
	#the treatment indicators are
	indicator.lalonde = lalonde$treat
	indicator.matched.ps = lalonde.matched.ps$treat
	indicator.matched.card = lalonde.matched.card$treat

	#The following code will display a classic Love plot
	#(with a dot for each standardized covariate mean difference),
	#where there are differently-colored dots for each dataset.
	
	#full lalonde dataset vs ps matched dataset
	lovePlotCompare(X1 = X.lalonde, indicator1 = indicator.lalonde,
	  X2 = X.matched.ps, indicator2 = indicator.matched.ps,
	  X.full = X.lalonde, indicator.full = indicator.lalonde,
	  dataNames = c("unmatched", "ps matched"))
	  
	#ps vs card
	lovePlotCompare(X1 = X.matched.ps, indicator1 = indicator.matched.ps,
	  X2 = X.matched.card, indicator2 = indicator.matched.card,
	  X.full = X.lalonde, indicator.full = indicator.lalonde,
	  dataNames = c("ps matched", "card matched"))
</code></pre>

<hr>
<h2 id='randChecks-internal'>Internal <code>randChecks</code> functions</h2><span id='topic+getBlockPerm'></span><span id='topic+permuteData.constrainedStandardizedCovMeanDiffs'></span><span id='topic+permuteData.blocked.constrainedStandardizedCovMeanDiffs'></span><span id='topic+permuteData.constrainedMD'></span><span id='topic+permuteData.blocked.constrainedMD'></span><span id='topic+getCompletePerms.balance'></span><span id='topic+getBlockPerms.balance'></span><span id='topic+getConstrainedDiffsPerms.balance'></span><span id='topic+getConstrainedDiffsBlockedPerms.balance'></span><span id='topic+getConstrainedMDPerms.balance'></span><span id='topic+getConstrainedMDBlockedPerms.balance'></span><span id='topic+getCompletePerms.md'></span><span id='topic+getBlockPerms.md'></span><span id='topic+getConstrainedDiffsPerms.md'></span><span id='topic+getConstrainedMDPerms.md'></span><span id='topic+getConstrainedDiffsBlockedPerms.md'></span><span id='topic+getConstrainedMDBlockedPerms.md'></span><span id='topic+getAssignmentColor'></span>

<h3>Description</h3>

<p>Internal <code>randChecks</code> functions</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getBlockPerm(subclassIndicatorTable)
  permuteData.constrainedStandardizedCovMeanDiffs(X.matched, indicator.matched,
  threshold, X.full = NULL, indicator.full = NULL)
  permuteData.blocked.constrainedStandardizedCovMeanDiffs(X.matched, indicator.matched,
  subclass, threshold, X.full = NULL, indicator.full = NULL)
  permuteData.constrainedMD(X.matched, indicator.matched, threshold, X.full = NULL)
  permuteData.blocked.constrainedMD(X.matched, indicator.matched,
  subclass, threshold, X.full = NULL)
  getCompletePerms.balance(X.matched, indicator.matched,
  perms = 1000, X.full = NULL, indicator.full = NULL)
  getBlockPerms.balance(X.matched, indicator.matched,
  subclass, perms = 1000, X.full = NULL, indicator.full = NULL)
  getConstrainedDiffsPerms.balance(X.matched, indicator.matched,
  threshold, perms = 1000, X.full = NULL, indicator.full = NULL)
  getConstrainedDiffsBlockedPerms.balance(X.matched, indicator.matched,
  subclass, threshold, perms = 1000, X.full = NULL, indicator.full = NULL)
  getConstrainedMDPerms.balance(X.matched, indicator.matched,
  threshold, perms = 1000, X.full = NULL, indicator.full = NULL)
  getConstrainedMDBlockedPerms.balance(X.matched, indicator.matched,
  subclass, threshold, perms = 1000, X.full = NULL, indicator.full = NULL)
  getCompletePerms.md(X.matched, indicator.matched,
  perms = 1000, X.full = NULL)
  getBlockPerms.md(X.matched, indicator.matched,
  subclass, perms = 1000, X.full = NULL)
  getConstrainedDiffsPerms.md(X.matched, indicator.matched,
  threshold, perms = 1000, X.full = NULL, indicator.full = NULL)
  getConstrainedMDPerms.md(X.matched, indicator.matched,
  threshold, perms = 1000, X.full = NULL)
  getConstrainedDiffsBlockedPerms.md(X.matched, indicator.matched,
  subclass, threshold, perms = 1000,
  	X.full = NULL, indicator.full = NULL)
  getConstrainedMDBlockedPerms.md(X.matched, indicator.matched,
  subclass, threshold, perms = 1000, X.full = NULL)
  getAssignmentColor(assignment)
</code></pre>


<h3>Details</h3>

<p><code>getBlockPerm</code> is a helper function to permute an indicator within blocks (defined by a subclass). 
</p>
<p><code>permuteData.constrainedStandardizedCovMeanDiffs</code> permutes an indicator given a constraint on standardized covariate mean differences.
</p>
<p><code>permuteData.blocked.constrainedStandardizedCovMeanDiffs</code> permutes an indicator within blocks given a constraint on standardized covariate mean differences.
</p>
<p><code>permuteData.constrainedMD</code> permutes an indicator given a constraint on the Mahalanobis distance.
</p>
<p><code>permuteData.blocked.constrainedMD</code> permutes an indicator within blocks given a constraint on the Mahalanobis distance.
</p>
<p><code>getCompletePerms.balance</code> returns standardized covariate mean differences across many permutations.
</p>
<p><code>getBlockPerms.balance</code> returns standardized covariate mean differences across many permutations within blocks.
</p>
<p><code>getConstrainedDiffsPerms.balance</code> returns standardized covariate mean differences across many permutations, conditional on a constraint on the standardized covariate mean differences.
</p>
<p><code>getConstrainedDiffsBlockedPerms.balance</code> returns standardized covariate mean differences across many permutations within blocks, conditional on a constraint on the standardized covariate mean differences.
</p>
<p><code>getConstrainedMDPerms.balance</code> returns standardized covariate mean differences across many permutations, conditional on a constraint on the Mahalanobis distance.
</p>
<p><code>getConstrainedMDBlockedPerms.balance</code> returns standardized covariate mean differences across many permutations within blcoks, conditional on a constraint on the Mahalanobis distance.
</p>
<p><code>getCompletePerms.md</code> returns the Mahalanobis distance across many permutations.
</p>
<p><code>getBlockPerms.md</code> returns the Mahalanobis distance across many permutations within blocks.
</p>
<p><code>getConstrainedDiffsPerms.md</code> returns the Mahalanobis distance across many permutations, conditional on a constraint on the standardized covariate mean differences.
</p>
<p><code>getConstrainedMDPerms.md</code> returns the Mahalanobis distance across many permutations, conditional on a constraint on the Mahalanobis distance.
</p>
<p><code>getConstrainedDiffsBlockedPerms.md</code> returns the Mahalanobis distance across many permutations within blocks, conditional on a constraint on the standardized covariate mean differences.
</p>
<p><code>getConstrainedMDBlockedPerms.md</code> returns the Mahalanobis distance across many permutations within blocks, conditional on a constraint on the Mahalanobis distance.
</p>
<p><code>getAssignmentColor</code> is a helper function that pairs different assignment mechanisms with different colors to be used in plots within <code>randChecks</code>.
</p>


<h3>Author(s)</h3>

<p>Zach Branson</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
