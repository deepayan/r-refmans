<!DOCTYPE html><html><head><title>Help for package plumbr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plumbr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#$.mutaframe'><p>Extraction and Replacement</p></a></li>
<li><a href='#add_listener'><p>Plumbr events</p></a></li>
<li><a href='#as.data.frame.mutaframe'><p>Coercion to data.frame</p></a></li>
<li><a href='#as.list.mutaframe'><p>Coercion to list</p></a></li>
<li><a href='#as.mutaframe'><p>Coercion to mutaframe</p></a></li>
<li><a href='#changed'><p>Get the 'changed' signal</p></a></li>
<li><a href='#combine_data_events'><p>Combine list of events into single event.</p></a></li>
<li><a href='#DataSelection'><p>Selection in Data</p></a></li>
<li><a href='#duplex_data_linker'><p>Duplex linking</p></a></li>
<li><a href='#is_paused'><p>Is a mutaframe currently paused?</p></a></li>
<li><a href='#is.mutaframe'><p>Test for mutaframes</p></a></li>
<li><a href='#ItemSelection-class'>
<p>The <code>ItemSelection</code> class implements</p>
<code>Selection</code> for the very common case of selecting
items in a dataset, optionally with weights.</a></li>
<li><a href='#match_any_linker'><p>match_any_linker</p></a></li>
<li><a href='#mutaframe'><p>Create a mutaframe, a mutable data.frame</p></a></li>
<li><a href='#mutalist'><p>mutalist</p></a></li>
<li><a href='#notify_listeners'><p>Notify listeners that data has changed.</p></a></li>
<li><a href='#pause'><p>Pause (cache) events.</p></a></li>
<li><a href='#proxy_bindings'><p>Generate binding for proxies.</p></a></li>
<li><a href='#raw_binding'><p>Generate binding for raw values</p></a></li>
<li><a href='#raw_bindings'><p>Generate binding for raw values</p></a></li>
<li><a href='#RegionSelection-class'>
<p>The <code>ItemSelection</code> class implements</p>
<code>Selection</code> for the selection of 1D and 2D regions
in plot/data space.</a></li>
<li><a href='#remove_listener'><p>Remove a listener, identified by the ID returned by</p>
<code>add_listener</code>.</a></li>
<li><a href='#Selection-class'><p>Selection</p></a></li>
<li><a href='#shape_changed'><p>Is the event a shape changed event?</p></a></li>
<li><a href='#unpause'><p>Unpause (reply) events.</p></a></li>
<li><a href='#variable_names'><p>Make valid variable names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6.10</td>
</tr>
<tr>
<td>Title:</td>
<td>Mutable and Dynamic Data Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Lawrence, Hadley Wickham</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, methods, objectSignals (&ge; 0.10.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plyr, testthat, MASS</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ggobi/plumbr/wiki">https://github.com/ggobi/plumbr/wiki</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Lawrence &lt;michafla@gene.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The base R data.frame, like any vector, is
    copied upon modification. This behavior is at odds with
    that of GUIs and interactive graphics. To rectify this,
    plumbr provides a mutable, dynamic tabular data model.
    Models may be chained together to form the complex
    plumbing necessary for sophisticated graphical
    interfaces. Also included is a
    general framework for linking datasets; an typical
    use case would be a linked brush.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>'accessors.r' 'bindings.r' 'coercion.r' 'constructor.r'
'dimensions.r' 'events.r' 'linking.r' 'mutalist.R' 'names.r'
'print.r' 'proxy-filter.r' 'selection.r' 'utils.r' 's4.r'
'import.r' 'globals.r'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-06 18:12:20 UTC; michafla</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-06 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+24.mutaframe'>Extraction and Replacement</h2><span id='topic++5B+3C-.mutaframe'></span><span id='topic++5B.mutaframe'></span><span id='topic++5B+5B+3C-.mutaframe'></span><span id='topic++5B+5B.mutaframe'></span><span id='topic++24+3C-.mutaframe'></span><span id='topic++24.mutaframe'></span>

<h3>Description</h3>

<p>These functions extract, subset and replace data in a
mutaframe. For the most part, these behave much like
those for <code>data.frame</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24.mutaframe_+3A_x">x</code></td>
<td>
<p>A mutaframe</p>
</td></tr>
<tr><td><code id="+2B24.mutaframe_+3A_name">name</code></td>
<td>
<p>Name of the column to extract</p>
</td></tr>
<tr><td><code id="+2B24.mutaframe_+3A_i">i</code></td>
<td>
<p>The row indices</p>
</td></tr>
<tr><td><code id="+2B24.mutaframe_+3A_j">j</code></td>
<td>
<p>The column indices</p>
</td></tr>
<tr><td><code id="+2B24.mutaframe_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods</p>
</td></tr>
<tr><td><code id="+2B24.mutaframe_+3A_value">value</code></td>
<td>
<p>The replacement column</p>
</td></tr>
<tr><td><code id="+2B24.mutaframe_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> and the result of subsetting
is a single column or row, that column or row is
extracted as the result. By default, this is <code>TRUE</code>
if the result has one column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subset function, <code>[</code>, does not copy the data; it
establishes a dynamic filter.
</p>
<p>Replacing an existing variable will pass the replacement
data up the reverse pipeline, towards the root. When
defining a new variable, the variable is stored in the
current mutaframe; not at the root.
</p>


<h3>Value</h3>

<p>The selected column
</p>
<p>The selected column
</p>
<p>A dynamic, filtering mutaframe
</p>

<hr>
<h2 id='add_listener'>Plumbr events</h2><span id='topic+add_listener'></span>

<h3>Description</h3>

<p>Plumbr data structures send only single event for data
changes: data_changed.  This has a two arguments, i and
j.  Either both are NULL, indicating a change in the
shape of the underlying data, or they give the the
locations of changed data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  add_listener(mf, callback)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_listener_+3A_mf">mf</code></td>
<td>
<p>muta frame</p>
</td></tr>
<tr><td><code id="add_listener_+3A_callback">callback</code></td>
<td>
<p>function with arguments i and j</p>
</td></tr>
</table>

<hr>
<h2 id='as.data.frame.mutaframe'>Coercion to data.frame</h2><span id='topic+as.data.frame.mutaframe'></span>

<h3>Description</h3>

<p>Coerces a mutaframe to a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mutaframe'
 as.data.frame(x, row.names =
  rownames(x), optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.mutaframe_+3A_x">x</code></td>
<td>
<p>a mutaframe</p>
</td></tr>
<tr><td><code id="as.data.frame.mutaframe_+3A_row.names">row.names</code></td>
<td>
<p>character vector of rownames, defaults
to rownames of <code>x</code></p>
</td></tr>
<tr><td><code id="as.data.frame.mutaframe_+3A_optional">optional</code></td>
<td>
<p>see <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
<tr><td><code id="as.data.frame.mutaframe_+3A_...">...</code></td>
<td>
<p>see <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>

<hr>
<h2 id='as.list.mutaframe'>Coercion to list</h2><span id='topic+as.list.mutaframe'></span>

<h3>Description</h3>

<p>Coerces a mutaframe to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mutaframe'
 as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.mutaframe_+3A_x">x</code></td>
<td>
<p>a mutaframe</p>
</td></tr>
<tr><td><code id="as.list.mutaframe_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, with one element for each mutaframe column
</p>

<hr>
<h2 id='as.mutaframe'>Coercion to mutaframe</h2><span id='topic+as.mutaframe'></span><span id='topic+as.mutaframe.data.frame'></span><span id='topic+as.mutaframe.default'></span><span id='topic+as.mutaframe.mutaframe'></span>

<h3>Description</h3>

<p>Coerce an object to a mutaframe. Supported types include
<code>data.frame</code>, or anything coercible to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.mutaframe(x, ...)

  ## S3 method for class 'mutaframe'
 as.mutaframe(x, ...)

  ## S3 method for class 'data.frame'
 as.mutaframe(x, ...)

  ## Default S3 method:
 as.mutaframe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mutaframe_+3A_x">x</code></td>
<td>
<p>the object to coerce</p>
</td></tr>
<tr><td><code id="as.mutaframe_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mutaframe
</p>

<hr>
<h2 id='changed'>Get the 'changed' signal</h2><span id='topic+changed'></span>

<h3>Description</h3>

<p>Get the 'changed' signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  changed(mf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="changed_+3A_mf">mf</code></td>
<td>
<p>a mutaframe</p>
</td></tr>
</table>

<hr>
<h2 id='combine_data_events'>Combine list of events into single event.</h2><span id='topic+combine_data_events'></span>

<h3>Description</h3>

<p>If any event is a <code>shape_changed</code> event, return it.
Otherwise, take the unique elements of the union of all
element changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  combine_data_events(events)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_data_events_+3A_events">events</code></td>
<td>
<p>a list of event parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a unified event
</p>

<hr>
<h2 id='DataSelection'>Selection in Data</h2><span id='topic+DataSelection'></span>

<h3>Description</h3>

<p>Implement a selection model against a dataset/pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  DataSelection(data, column = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataSelection_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+mutaframe">mutaframe</a></code> of the
dataset/pipeline</p>
</td></tr>
<tr><td><code id="DataSelection_+3A_column">column</code></td>
<td>
<p>Column index of selection variable in data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+ItemSelection">ItemSelection</a></code> reflecting the selection
in the data
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence
</p>

<hr>
<h2 id='duplex_data_linker'>Duplex linking</h2><span id='topic+duplex_data_linker'></span>

<h3>Description</h3>

<p>A utility for creating linking functions that operate in
both directions (full duplex).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  duplex_data_linker(delegate, from_data, to_data =
  from_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplex_data_linker_+3A_delegate">delegate</code></td>
<td>
<p>The linking function that performs the
mapping, such as <code><a href="#topic+match_any_linker">match_any_linker</a></code>.</p>
</td></tr>
<tr><td><code id="duplex_data_linker_+3A_from_data">from_data</code></td>
<td>
<p>A <code>data.frame</code> of keys</p>
</td></tr>
<tr><td><code id="duplex_data_linker_+3A_to_data">to_data</code></td>
<td>
<p>A <code>data.frame</code> of keys</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generated linker function takes two arguments:
<code>from_selection</code> and <code>new_selection</code>. If
<code>new_selection</code> is specified, <code>new_selection</code>
is mapped from <code>to_data</code> to <code>from_data</code>.
Otherwise, <code>from_selection</code> is mapped from
<code>from_data</code> to <code>to_data</code>.
</p>


<h3>Value</h3>

<p>A two-way linking function as described in the details.
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence
</p>

<hr>
<h2 id='is_paused'>Is a mutaframe currently paused?</h2><span id='topic+is_paused'></span>

<h3>Description</h3>

<p>Is a mutaframe currently paused?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is_paused(mf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_paused_+3A_mf">mf</code></td>
<td>
<p>a mutaframe</p>
</td></tr>
</table>

<hr>
<h2 id='is.mutaframe'>Test for mutaframes</h2><span id='topic+is.mutaframe'></span>

<h3>Description</h3>

<p>Tests whether an object is a <code>mutaframe</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.mutaframe(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mutaframe_+3A_x">x</code></td>
<td>
<p>an object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is an instance of a class that
inherits from <code>mutaframe</code>; otherwise, <code>FALSE</code>
</p>

<hr>
<h2 id='ItemSelection-class'>
The <code>ItemSelection</code> class implements
<code><a href="#topic+Selection-class">Selection</a></code> for the very common case of selecting
items in a dataset, optionally with weights.
</h2><span id='topic+class+3AItemSelection'></span><span id='topic+ItemSelection-class'></span><span id='topic+ItemSelection'></span><span id='topic+coerce+2CItemSelection+2Cvector-method'></span><span id='topic+as.vector+2CItemSelection-method'></span><span id='topic+coerce+2CItemSelection+2Cinteger-method'></span><span id='topic+as.integer+2CItemSelection-method'></span><span id='topic+coerce+2CItemSelection+2Cnumeric-method'></span><span id='topic+as.numeric+2CItemSelection-method'></span><span id='topic+coerce+2CItemSelection+2Clogical-method'></span><span id='topic+as.logical+2CItemSelection-method'></span><span id='topic+coerce+2CItemSelection+2Cfactor-method'></span><span id='topic+as.factor+2CItemSelection-method'></span><span id='topic+which+2CItemSelection-method'></span>

<h3>Description</h3>

<p>The <code>ItemSelection</code> class implements
<code><a href="#topic+Selection-class">Selection</a></code> for the very common case of selecting
items in a dataset, optionally with weights.
</p>


<h3>Constructor</h3>

<ul>
<li><p><code>ItemSelection(delegate = NULL)</code>: Constructs an
<code>ItemSelection</code> object with the underlying selection provided
by <code>delegate</code>, which may be a function or any other R
object. If it is not a function, <code>delegate</code> must support the
coercions described in the next section. A good example would be a
logical vector. However, <code>delegate</code> is usually a function
that is invoked whenever the selection is stored or retrieved. If
the function is called with no arguments, it should return the
selection. Otherwise, the argument is the new selection status,
and the function should store it. This is the same semantic as
<a href="base.html#topic+makeActiveBinding">active bindings</a>. This dynamic
functionality allows proxying of other <code>Selection</code> objects or
external sources, such as a selection model from a GUI toolkit.

</p>
</li></ul>



<h3>Interpreting the Selection</h3>

<p>Any R object can represent the underlying selection, so for simplicity
we recommend that the client interpret the selection through
coercion. Each of these simply delegate to the underlying
selection object, which will need to support all of them for
consistency. The following coercions are supported, where <code>x</code> is
a <code>ItemSelection</code> instance:
</p>

<ul>
<li><p><code>which(x)</code>: integer indices of the selected items.
</p>
</li>
<li><p><code>as.logical(x)</code>: <code>TRUE</code> where selected.
</p>
</li>
<li><p><code>as.integer(x)</code>: usually 0L (unselected) or 1L
(selected), but in general it is a weighting of the selection.
</p>
</li>
<li><p><code>as.numeric(x)</code>: similar to <code>as.integer</code>, except
with real values.
</p>
</li>
<li><p><code>as.factor(x)</code>: ordinarily this will have two
levels, <code>FALSE</code> and <code>TRUE</code>, although it could have more,
which confers support for multinary selections.
</p>
</li></ul>



<h3>Supported Selection Calculus</h3>

<p>All operations mentioned in <code><a href="#topic+Selection-class">Selection</a></code> are
supported: <code>add</code>, <code>subtract</code>, <code>toggle</code>, <code>intersect</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence</p>


<h3>See Also</h3>

<p><code><a href="#topic+Selection-class">Selection</a></code> for the rest of the details.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Assume we have a dataset:
  data(Cars93, package="MASS")
  mf &lt;- mutaframe(Cars93)
  mf$.color &lt;- "gray"
  ## First step is to create a base selection
  sel &lt;- ItemSelection()
  ## Now, link that selection to other cases in same dataset by some variable
  linked_sel &lt;- sel$link(match_any_linker(Cars93["Manufacturer"]))
  ## Finally, scale that linked selection to the data
  linked_sel$scale(function(x, d) {
    d[as.logical(x), ".color"] &lt;- "red"
  }, mf)
  ## To test, select some cases
  cases &lt;- rep(FALSE, nrow(mf))
  cases[seq(1, 10, 2)] &lt;- TRUE
  sel$replace(cases)
</code></pre>

<hr>
<h2 id='match_any_linker'>match_any_linker</h2><span id='topic+match_any_linker'></span>

<h3>Description</h3>

<p>Linking functions return a logical vector, with the
<code>TRUE</code> elements indicating rows in the data that are
linked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  match_any_linker(from_data, to_data = from_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_any_linker_+3A_from_data">from_data</code></td>
<td>
<p>A <code>data.frame</code>-like object
containing the keys for linking the corresponding rows to
rows in <code>to_data</code></p>
</td></tr>
<tr><td><code id="match_any_linker_+3A_to_data">to_data</code></td>
<td>
<p>A <code>data.frame</code>-like object containing
the keys that will be matched against the keys in
<code>from_data</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>match_any_linker</code> function links rows in
<code>from_data</code> to rows in <code>to_data</code> that share the
same key.
</p>
<p>By convention, a key is defined as the combination of the
values in every column of <code>from_data</code> and
<code>to_data</code>. Thus, <code>from_data</code> and <code>to_data</code>
should contain only the columns necessary for key
generation. They should not be an entire dataset.
</p>


<h3>Value</h3>

<p>a logical vector, indicating which <code>from_data</code> rows
are linked
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence
</p>

<hr>
<h2 id='mutaframe'>Create a mutaframe, a mutable data.frame</h2><span id='topic+mutaframe'></span><span id='topic+mutaframe-class'></span>

<h3>Description</h3>

<p>Create a mutaframe, a mutable data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mutaframe(..., row.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutaframe_+3A_...">...</code></td>
<td>
<p>Objects to coerce to a mutaframe and combine
column-wise</p>
</td></tr>
<tr><td><code id="mutaframe_+3A_row.names">row.names</code></td>
<td>
<p>optional, the character vector of row
names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mutaframe
</p>

<hr>
<h2 id='mutalist'>mutalist</h2><span id='topic+as.data.frame.mutalist'></span><span id='topic+as.list.mutalist'></span><span id='topic+c.mutalist'></span><span id='topic+head.mutalist'></span><span id='topic+lapply.mutalist'></span><span id='topic+length.mutalist'></span><span id='topic+mutalist'></span><span id='topic++5B+3C-.mutalist'></span><span id='topic++5B.mutalist'></span><span id='topic++5B+5B+3C-.mutalist'></span><span id='topic++5B+5B.mutalist'></span><span id='topic++24+3C-.mutalist'></span><span id='topic++24.mutalist'></span><span id='topic+mutalist2env'></span><span id='topic+mutalist-class'></span><span id='topic+names+3C-.mutalist'></span><span id='topic+names.mutalist'></span><span id='topic+print.mutalist'></span><span id='topic+rep.mutalist'></span><span id='topic+rev.mutalist'></span><span id='topic+tail.mutalist'></span><span id='topic+unlist.mutalist'></span>

<h3>Description</h3>

<p>The mutalist is a mutable list. Modifications to a
mutalist occur by a reference semantic. Otherwise, it
should act like an ordinary R list and provides a similar
API. If anything is found missing, please inform the
authors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mutalist(...)

  ## S3 method for class 'mutalist'
 length(x)

  ## S3 replacement method for class 'mutalist'
names(x, ...) &lt;- value

  ## S3 method for class 'mutalist'
 names(x)

  ## S3 method for class 'mutalist'
x[[i, j, ...]]

  ## S3 replacement method for class 'mutalist'
x[[i, j, ...]] &lt;- value

  ## S3 replacement method for class 'mutalist'
x$name &lt;- value

  ## S3 method for class 'mutalist'
x[i, j, ..., drop]

  ## S3 replacement method for class 'mutalist'
x[i, j, ...] &lt;- value

  ## S3 method for class 'mutalist'
 head(x, n = 6L, ...)

  ## S3 method for class 'mutalist'
 tail(x, n = 6L, ...)

  ## S3 method for class 'mutalist'
 c(x, ..., recursive = FALSE)

  ## S3 method for class 'mutalist'
 lapply(X, FUN, ...)

  ## S3 method for class 'mutalist'
 as.list(x, ...)

  ## S3 method for class 'mutalist'
 as.data.frame(x, ...)

  ## S3 method for class 'mutalist'
 unlist(x, recursive = TRUE, use.names
  = TRUE)

  mutalist2env(x, envir = new.env(hash, parent, size),
  parent = parent.frame(), hash = FALSE, size = 29L)

  ## S3 method for class 'mutalist'
 rev(x)

  ## S3 method for class 'mutalist'
 rep(x, ...)

  ## S3 method for class 'mutalist'
 print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutalist_+3A_...">...</code></td>
<td>
<p>elements to include in the list or arguments
passed to methods</p>
</td></tr>
<tr><td><code id="mutalist_+3A_x">x</code></td>
<td>
<p>a mutalist</p>
</td></tr>
<tr><td><code id="mutalist_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr><td><code id="mutalist_+3A_i">i</code></td>
<td>
<p>element indices</p>
</td></tr>
<tr><td><code id="mutalist_+3A_j">j</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="mutalist_+3A_name">name</code></td>
<td>
<p>element name</p>
</td></tr>
<tr><td><code id="mutalist_+3A_drop">drop</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="mutalist_+3A_n">n</code></td>
<td>
<p>number of elements in subset</p>
</td></tr>
<tr><td><code id="mutalist_+3A_recursive">recursive</code></td>
<td>
<p>whether to perform recursively</p>
</td></tr>
<tr><td><code id="mutalist_+3A_x">X</code></td>
<td>
<p>a mutalist</p>
</td></tr>
<tr><td><code id="mutalist_+3A_fun">FUN</code></td>
<td>
<p>a function to apply over the elements</p>
</td></tr>
<tr><td><code id="mutalist_+3A_use.names">use.names</code></td>
<td>
<p>whether to preserve the names</p>
</td></tr>
<tr><td><code id="mutalist_+3A_envir">envir</code></td>
<td>
<p>environment to populate</p>
</td></tr>
<tr><td><code id="mutalist_+3A_parent">parent</code></td>
<td>
<p>parent for new environment, if created</p>
</td></tr>
<tr><td><code id="mutalist_+3A_hash">hash</code></td>
<td>
<p>whether to hash the new environment</p>
</td></tr>
<tr><td><code id="mutalist_+3A_size">size</code></td>
<td>
<p>initial size of hash table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new mutalist
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence
</p>

<hr>
<h2 id='notify_listeners'>Notify listeners that data has changed.</h2><span id='topic+notify_listeners'></span>

<h3>Description</h3>

<p>Notify listeners that data has changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  notify_listeners(mf, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="notify_listeners_+3A_mf">mf</code></td>
<td>
<p>mutaframe</p>
</td></tr>
<tr><td><code id="notify_listeners_+3A_i">i</code>, <code id="notify_listeners_+3A_j">j</code></td>
<td>
<p>row and column indices</p>
</td></tr>
</table>

<hr>
<h2 id='pause'>Pause (cache) events.</h2><span id='topic+pause'></span>

<h3>Description</h3>

<p>When a mutaframe is paused, it accumulates events without
passing them on. When unpaused, it accumulates all events
into a single event and passes it on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pause(mf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pause_+3A_mf">mf</code></td>
<td>
<p>mutaframe</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a performance optimisation for when you expect
many changes: pause the mutaframe, perform all the
changes and then unpause.
</p>

<hr>
<h2 id='proxy_bindings'>Generate binding for proxies.</h2><span id='topic+proxy_bindings'></span>

<h3>Description</h3>

<p>Generate binding for proxies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  proxy_bindings(mf, j = names(mf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proxy_bindings_+3A_mf">mf</code></td>
<td>
<p>mutaframe to inherit from</p>
</td></tr>
<tr><td><code id="proxy_bindings_+3A_j">j</code></td>
<td>
<p>columns to generate bindings for</p>
</td></tr>
</table>

<hr>
<h2 id='raw_binding'>Generate binding for raw values</h2><span id='topic+raw_binding'></span>

<h3>Description</h3>

<p>Generate binding for raw values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  raw_binding(mf, name, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_binding_+3A_mf">mf</code></td>
<td>
<p>mutaframe</p>
</td></tr>
<tr><td><code id="raw_binding_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
<tr><td><code id="raw_binding_+3A_data">data</code></td>
<td>
<p>vector to store</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of binding functions
</p>

<hr>
<h2 id='raw_bindings'>Generate binding for raw values</h2><span id='topic+raw_bindings'></span>

<h3>Description</h3>

<p>Generate binding for raw values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  raw_bindings(mf, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_bindings_+3A_mf">mf</code></td>
<td>
<p>mutaframe</p>
</td></tr>
<tr><td><code id="raw_bindings_+3A_data">data</code></td>
<td>
<p>list of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of binding functions
</p>

<hr>
<h2 id='RegionSelection-class'>
The <code>ItemSelection</code> class implements
<code><a href="#topic+Selection-class">Selection</a></code> for the selection of 1D and 2D regions
in plot/data space.
</h2><span id='topic+class+3ARegionSelection'></span><span id='topic+RegionSelection-class'></span><span id='topic+RegionSelection'></span><span id='topic+as.matrix+2CRegionSelection-method'></span><span id='topic+coerce+2CRegionSelection+2Cmatrix-method'></span>

<h3>Description</h3>

<p>The <code>ItemSelection</code> class implements
<code><a href="#topic+Selection-class">Selection</a></code> for the selection of 1D and 2D regions
in plot/data space.
</p>


<h3>Constructor</h3>

<ul>
<li><p><code>RegionSelection(delegate = NULL)</code>: Constructs
an <code>RegionSelection</code> object with the underlying selection
provided by <code>delegate</code>, which may be a function or any other
R object. If it is not a function, <code>delegate</code> must support
coercion to a <code>matrix</code> as described in the next section.
However, <code>delegate</code> is usually a function that is invoked
whenever the selection is stored or retrieved. If the function is
called with no arguments, it should return the
selection. Otherwise, the argument is the new selection status,
and the function should store it. This is the same semantic as
<a href="base.html#topic+makeActiveBinding">active bindings</a>. This dynamic
functionality allows proxying of other <code>Selection</code> objects or
external sources, such as a selection model from a GUI toolkit.

</p>
</li></ul>



<h3>Interpreting the Selection</h3>

<p>Any R object can represent the underlying selection, so for simplicity
we recommend that the client interpret the selection through
coercion. Currently, there is only one supported coercion of
<code>RegionSelection</code>:
</p>

<ul>
<li><p><code>as.matrix(x)</code>: returns a matrix with a column for each
dimension and a row for each point. In the 2D case, the points
describe one or more polygons. As with the <code><a href="graphics.html#topic+polygon">polygon</a></code>
function, polygons are separated by rows of <code>NA</code>, and the last
point is connected with the first. In the 1D case, the single column
might encode, for example, selections of factor levels in an area
plot.

</p>
</li></ul>

<p>We will probably need to add more coercions as use cases arise. This
is still very preliminary.
</p>


<h3>Supported Selection Calculus</h3>

<p>For now, <code>RegionSelection</code> only supports the <code>add</code> operation
described in the documentation for <code><a href="#topic+Selection-class">Selection</a></code>.
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence</p>


<h3>See Also</h3>

<p><code><a href="#topic+Selection-class">Selection</a></code> for the rest of the details.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## forthcoming
</code></pre>

<hr>
<h2 id='remove_listener'>Remove a listener, identified by the ID returned by
<code><a href="#topic+add_listener">add_listener</a></code>.</h2><span id='topic+remove_listener'></span>

<h3>Description</h3>

<p>Remove a listener, identified by the ID returned by
<code><a href="#topic+add_listener">add_listener</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  remove_listener(mf, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_listener_+3A_mf">mf</code></td>
<td>
<p>mutaframe</p>
</td></tr>
<tr><td><code id="remove_listener_+3A_id">id</code></td>
<td>
<p>value returned by <code>add_listener</code> when
originally connecting the handler</p>
</td></tr>
</table>

<hr>
<h2 id='Selection-class'>Selection</h2><span id='topic+class+3ASelection'></span><span id='topic+Selection-class'></span>

<h3>Description</h3>

<p>A virtual base class for data models that store a selection, which
might be of items, regions, or whatever.  Clients can register
handlers for selection changes and can create proxy models to
transform selections, link across datasets and map selections to
actions on the data.
</p>
<p><strong>This design is preliminary and subject to change.</strong>
</p>


<h3>Interpreting The Selection</h3>

<p>Internally, the selection may be stored as any object, including as a
function that is invoked whenever the selection is stored or
retrieved. The function allows dynamic mapping of selections. Due to
this generality, the client should not access the selection
directly. Instead, it should explicitly coerce the selection object to
an interpretable representation. The set of supported coercions
depends on the subclass.  For example,
<code><a href="#topic+ItemSelection-class">ItemSelection</a></code> has a <code>as.logical</code> method that
coerces it to a logical vector, where an element is <code>TRUE</code> if the
corresponding element in the dataset is selected.
</p>


<h3>Responding to Selection Changes</h3>

<p>Whenever the selection is changed, the <code>changed</code> signal is
emitted. The signal has zero arguments. See the <code>objectSignals</code>
package for details on using signals.
</p>
<p>Eventually, a selection leads to the execution of some action by the
application. In interactive graphics, that action usually involves
scaling/transforming the selection to a modification on the data. The
<code>x$scale(scaler, data)</code> method tries to facilitate these
operaitons. All it does is create a handler for the <code>changed</code>
signal on <code>x</code> that passes <code>x</code> and <code>data</code> to the function
<code>scaler</code>, which implements the change.
</p>


<h3>The Selection Calculus</h3>

<p>Since any type of object can represent a selection, setting the
selection has very few constraints. There are several ways to modify
the selection. Not all of them will be supported by every subclass. In
the code snippets below, <code>x</code> represents a <code>Selection</code> object
and <code>selection</code> represents the primary representation of a
selection, like a logical vector.
</p>

<dl>
<dt>Replacement</dt><dd><p><code>x$replace(selection)</code>: this is supported by all
implementations.</p>
</dd>
<dt>Or/Addition</dt><dd><p><code>x$add(selection)</code>: the result contains the
union of the original selection and <code>selection</code>.</p>
</dd>
<dt>Setdiff/Subtract</dt><dd><p><code>x$subtract(selection)</code>: the result
contains the original selection except that indicated
by <code>selection</code>.</p>
</dd>
<dt>And/Intersect</dt><dd><p><code>x$intersect(selection)</code>: the result
contains the intersection of the original selection and
<code>selection</code>.</p>
</dd>
<dt>Xor/Toggle</dt><dd><p><code>x$toggle(selection)</code>: 
The intersection of the original selection and <code>selection</code> is
deselected, that only in <code>selection</code> is selected.</p>
</dd>
</dl>



<h3>Linking Selections</h3>

<p>In interactive graphics, it is often necessary to link selections
within and across datasets. The <code>x$link(linker)</code> method creates a
new <code>Selection</code> object that proxies <code>x</code> and maps the
selection in <code>x</code> through <code>linker</code>. Changes to the selection
in <code>x</code> will propagate via <code>linker</code> to changes in the
proxy. Analogously, the <code>linker</code> will pass modifications to the
proxy down to <code>x</code>.
</p>
<p>The <code>linker</code> may be provided as an integer vector, like that
returned by <code><a href="base.html#topic+match">match</a></code>, but it is usually a function, as that
allows very general linking strategies. As an example, let us consider
a simple linker between two datasets based on key matching. We assume
that the keys, <code>source_keys</code> and <code>dest_keys</code>, are in the
enclosure of our linker function.
</p>
<pre>
    function(source_selection, new_dest_value) {
      if (missing(new_dest_value))
        dest_keys 
      else source_keys 
    }
  </pre>
<p>The <code>linker</code> function takes one or two arguments, depending on
whether the selection is being retrieved or stored. When the selection
is being retrieved, <code>source_selection</code> is passed as the only
argument. The duty of the <code>linker</code> is then to retrieve the
underlying selection from <code>source_selection</code> (through coercion,
see above) and figure out which keys in the destination selection
match the selected source keys. The <code>new_dest_value</code> argument is
provided whenever the selection is being stored/set. In that case, the
analogous operation is performed, in the opposite direction. The
symmetry here is fairly obvious, and <code><a href="#topic+duplex_data_linker">duplex_data_linker</a></code>
is a utility for facilitating the implementation of such two-way
linking functions.
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+ItemSelection">ItemSelection</a></code> and <code><a href="#topic+RegionSelection">RegionSelection</a></code>
subclasses, which have examples.</p>

<hr>
<h2 id='shape_changed'>Is the event a shape changed event?</h2><span id='topic+shape_changed'></span>

<h3>Description</h3>

<p>Is the event a shape changed event?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  shape_changed(i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape_changed_+3A_i">i</code></td>
<td>
<p>col index</p>
</td></tr>
<tr><td><code id="shape_changed_+3A_j">j</code></td>
<td>
<p>row index</p>
</td></tr>
</table>

<hr>
<h2 id='unpause'>Unpause (reply) events.</h2><span id='topic+unpause'></span>

<h3>Description</h3>

<p>Unpause (reply) events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  unpause(mf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpause_+3A_mf">mf</code></td>
<td>
<p>mutaframe</p>
</td></tr>
</table>

<hr>
<h2 id='variable_names'>Make valid variable names</h2><span id='topic+variable_names'></span>

<h3>Description</h3>

<p>Make valid variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  variable_names(var_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable_names_+3A_var_names">var_names</code></td>
<td>
<p>variable names</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
