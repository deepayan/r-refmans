<!DOCTYPE html><html><head><title>Help for package makepipe</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {makepipe}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#make_params'><p>Parameters for make-like functions</p></a></li>
<li><a href='#make_register'><p>Register objects to be returned from <code>make_with_source</code></p></a></li>
<li><a href='#make_with_dir'><p>Create a pipeline using roxygen tags</p></a></li>
<li><a href='#make_with_recipe'><p>Make targets out of dependencies using a recipe</p></a></li>
<li><a href='#make_with_source'><p>Make targets out of dependencies using a source file</p></a></li>
<li><a href='#out_of_date'><p>Check if targets are out-of-date vis-a-vis their dependencies</p></a></li>
<li><a href='#Pipeline'><p>Pipeline visualisations</p></a></li>
<li><a href='#pipeline-accessors'><p>Access and interface with Pipeline.</p></a></li>
<li><a href='#pipeline-vis'><p>Visualise the Pipeline.</p></a></li>
<li><a href='#Segment'><p>Segment</p></a></li>
<li><a href='#SegmentRecipe'><p>Segment</p></a></li>
<li><a href='#SegmentSource'><p>Segment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Pipeline Tools Inspired by 'GNU Make'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of tools for transforming an existing workflow into a
    self-documenting pipeline with very minimal upfront costs. Segments of
    the pipeline are specified in much the same way a 'Make' rule is, by
    declaring an executable recipe (which might be an R script), along
    with the corresponding targets and dependencies. When the entire
    pipeline is run through, only those recipes that need to be executed
    will be. Meanwhile, execution metadata is captured behind the scenes
    for later inspection.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kinto-b.github.io/makepipe/">https://kinto-b.github.io/makepipe/</a>,
<a href="https://github.com/kinto-b/makepipe">https://github.com/kinto-b/makepipe</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kinto-b/makepipe/issues">https://github.com/kinto-b/makepipe/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, nomnoml, R6, utils, roxygen2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, covr, testthat (&ge; 3.0.0), withr, rmarkdown, webshot,
visNetwork,</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-07 09:14:17 UTC; kinto</td>
</tr>
<tr>
<td>Author:</td>
<td>Kinto Behr [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kinto Behr &lt;kinto.behr@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-07 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='make_params'>Parameters for make-like functions</h2><span id='topic+make_params'></span>

<h3>Description</h3>

<p>Parameters for make-like functions
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_params_+3A_source">source</code></td>
<td>
<p>The path to an R script which makes the <code>targets</code></p>
</td></tr>
<tr><td><code id="make_params_+3A_recipe">recipe</code></td>
<td>
<p>A chunk of R code which makes the <code>targets</code></p>
</td></tr>
<tr><td><code id="make_params_+3A_targets">targets</code></td>
<td>
<p>A character vector of paths to files</p>
</td></tr>
<tr><td><code id="make_params_+3A_dependencies">dependencies</code></td>
<td>
<p>A character vector of paths to files which the <code>targets</code>
depend on</p>
</td></tr>
<tr><td><code id="make_params_+3A_packages">packages</code></td>
<td>
<p>A character vector of names of packages which <code>targets</code>
depend on</p>
</td></tr>
<tr><td><code id="make_params_+3A_envir">envir</code></td>
<td>
<p>The environment in which to execute the <code>source</code> or <code>recipe</code>. By
default, execution will take place in a fresh environment whose parent is
the calling environment.</p>
</td></tr>
<tr><td><code id="make_params_+3A_quiet">quiet</code></td>
<td>
<p>A logical determining whether or not messages are signaled</p>
</td></tr>
<tr><td><code id="make_params_+3A_force">force</code></td>
<td>
<p>A logical determining whether or not execution of the <code>source</code>
or <code>recipe</code> will be forced (i.e. happen whether or not the targets are
out-of-date)</p>
</td></tr>
<tr><td><code id="make_params_+3A_label">label</code></td>
<td>
<p>A short label for the <code>source</code> or <code>recipe</code>, displayed in pipeline
visualisations. If <code>NULL</code>, the <code>basename(source)</code> or 'Recipe' will be used.</p>
</td></tr>
</table>

<hr>
<h2 id='make_register'>Register objects to be returned from <code>make_with_source</code></h2><span id='topic+make_register'></span>

<h3>Description</h3>

<p>It is sometimes useful to have access to certain objects which are generated as
side-products in a source script which yields as a main-product one or more
targets. Typically these objects are used for checking that the targets were
produced as expected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_register(value, name, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_register_+3A_value">value</code></td>
<td>
<p>A value to be registered in a source script and returned as part
of the <code>Segment</code></p>
</td></tr>
<tr><td><code id="make_register_+3A_name">name</code></td>
<td>
<p>A variable name, given as a character string. No coercion is
done, and the first element of a character vector of length greater than
one will be used, with a warning.</p>
</td></tr>
<tr><td><code id="make_register_+3A_quiet">quiet</code></td>
<td>
<p>A logical determining whether or not warnings are signaled when
<code>make_register()</code> is called outside of a 'makepipe' pipeline</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>value</code> invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  # Imagine this is part of your source script:
  x &lt;- readRDS("input.Rds")
  x &lt;- do_stuff(x)
  chk &lt;- do_check(x)
  make_register(chk, "x_check")
  saveRDS(x, "output.Rds")

  # You will have access to `chk` in your pipeline script:
  step_one &lt;- make_with_source(
    "source.R",
    "output.Rds",
    "input.Rds",
  )
  step_one$result$chk

## End(Not run)
</code></pre>

<hr>
<h2 id='make_with_dir'>Create a pipeline using roxygen tags</h2><span id='topic+make_with_dir'></span><span id='topic+make_with_roxy'></span>

<h3>Description</h3>

<p>Instead of maintaining a separate pipeline script containing calls to
<code>make_with_source()</code>, you can add roxygen-like headers to the .R files in
your pipeline containing the <code style="white-space: pre;">&#8288;@makepipe&#8288;</code> tag along with <code style="white-space: pre;">&#8288;@targets&#8288;</code>,
<code style="white-space: pre;">&#8288;@dependencies&#8288;</code>, and so on. These tags will be parsed by <code>make_with_dir()</code>
and used to construct a pipeline. You can call a specific part of the
pipeline that has been documented in this way using <code>make_with_roxy()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_with_dir(
  dir = ".",
  recursive = FALSE,
  build = TRUE,
  envir = new.env(parent = parent.frame()),
  quiet = getOption("makepipe.quiet")
)

make_with_roxy(
  source,
  envir = new.env(parent = parent.frame()),
  quiet = getOption("makepipe.quiet")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_with_dir_+3A_dir">dir</code></td>
<td>
<p>A character vector of full path names; the default corresponds to the working directory</p>
</td></tr>
<tr><td><code id="make_with_dir_+3A_recursive">recursive</code></td>
<td>
<p>A logical determining whether or not to recurse into
subdirectories</p>
</td></tr>
<tr><td><code id="make_with_dir_+3A_build">build</code></td>
<td>
<p>A logical determining whether or not the pipeline will be built
immediately or simply returned to the user</p>
</td></tr>
<tr><td><code id="make_with_dir_+3A_envir">envir</code></td>
<td>
<p>The environment in which to execute the <code>source</code> or <code>recipe</code>. By
default, execution will take place in a fresh environment whose parent is
the calling environment.</p>
</td></tr>
<tr><td><code id="make_with_dir_+3A_quiet">quiet</code></td>
<td>
<p>A logical determining whether or not messages are signaled</p>
</td></tr>
<tr><td><code id="make_with_dir_+3A_source">source</code></td>
<td>
<p>The path to an R script which makes the <code>targets</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other than <code style="white-space: pre;">&#8288;@makepipe&#8288;</code>, which is used to tell whether a given script should
be included in the pipeline, the tags recognised mirror the arguments to
<code>make_with_source()</code>. In particular,
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;@targets&#8288;</code> and <code style="white-space: pre;">&#8288;@dependencies&#8288;</code> are for declaring inputs and outputs, the
expected format is a comma separated list of strings like
<code style="white-space: pre;">&#8288;@targets "out1.Rds", "out2.Rds"&#8288;</code> but R code like <code style="white-space: pre;">&#8288;@targets file.path(DIR, "out.Rds")&#8288;</code>
(evaluated in <code>envir</code>) works too
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;@packages&#8288;</code> is for declaring the packages that the targets depend on, the
expected format is <code style="white-space: pre;">&#8288;@packages pkg1 pkg2 etc&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;@force&#8288;</code> is for declaring whether or not execution should be forced, the
expected format is a logical like <code>TRUE</code> or <code>FALSE</code>
</p>
</li></ul>

<p>See the getting started vignette for more information.
</p>


<h3>Value</h3>

<p>A <code>Pipeline</code> object
</p>


<h3>See Also</h3>

<p>Other make: 
<code><a href="#topic+make_with_recipe">make_with_recipe</a>()</code>,
<code><a href="#topic+make_with_source">make_with_source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a pipeline from scripts in the working dir without executing it
p &lt;- make_with_dir(build = FALSE)
p$build() # Then execute it yourself

## End(Not run)
</code></pre>

<hr>
<h2 id='make_with_recipe'>Make targets out of dependencies using a recipe</h2><span id='topic+make_with_recipe'></span>

<h3>Description</h3>

<p>Make targets out of dependencies using a recipe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_with_recipe(
  recipe,
  targets,
  dependencies = NULL,
  packages = NULL,
  envir = new.env(parent = parent.frame()),
  quiet = getOption("makepipe.quiet"),
  force = FALSE,
  label = NULL,
  note = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_with_recipe_+3A_recipe">recipe</code></td>
<td>
<p>A chunk of R code which makes the <code>targets</code></p>
</td></tr>
<tr><td><code id="make_with_recipe_+3A_targets">targets</code></td>
<td>
<p>A character vector of paths to files</p>
</td></tr>
<tr><td><code id="make_with_recipe_+3A_dependencies">dependencies</code></td>
<td>
<p>A character vector of paths to files which the <code>targets</code>
depend on</p>
</td></tr>
<tr><td><code id="make_with_recipe_+3A_packages">packages</code></td>
<td>
<p>A character vector of names of packages which <code>targets</code>
depend on</p>
</td></tr>
<tr><td><code id="make_with_recipe_+3A_envir">envir</code></td>
<td>
<p>The environment in which to execute the <code>source</code> or <code>recipe</code>. By
default, execution will take place in a fresh environment whose parent is
the calling environment.</p>
</td></tr>
<tr><td><code id="make_with_recipe_+3A_quiet">quiet</code></td>
<td>
<p>A logical determining whether or not messages are signaled</p>
</td></tr>
<tr><td><code id="make_with_recipe_+3A_force">force</code></td>
<td>
<p>A logical determining whether or not execution of the <code>source</code>
or <code>recipe</code> will be forced (i.e. happen whether or not the targets are
out-of-date)</p>
</td></tr>
<tr><td><code id="make_with_recipe_+3A_label">label</code></td>
<td>
<p>A short label for the <code>source</code> or <code>recipe</code>, displayed in pipeline
visualisations. If <code>NULL</code>, the <code>basename(source)</code> or 'Recipe' will be used.</p>
</td></tr>
<tr><td><code id="make_with_recipe_+3A_note">note</code></td>
<td>
<p>A description of what the <code>recipe</code> does, displayed in pipeline
visualisations. If <code>NULL</code>, the <code>recipe</code> code is used.</p>
</td></tr>
<tr><td><code id="make_with_recipe_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>base::eval()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Segment</code> object containing execution metadata.
</p>


<h3>See Also</h3>

<p>Other make: 
<code><a href="#topic+make_with_dir">make_with_dir</a>()</code>,
<code><a href="#topic+make_with_source">make_with_source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Merge files in fresh environment if raw data has been updated since last
# merged
make_with_recipe(
  recipe = {
    dat &lt;- readRDS("data/raw_data.Rds")
    pop &lt;- readRDS("data/pop_data.Rds")
    merged_dat &lt;- merge(dat, pop, by = "id")
    saveRDS(merged_dat, "data/merged_data.Rds")
  },
  targets = "data/merged_data.Rds",
  dependencies = c("data/raw_data.Rds", "data/raw_pop.Rds")
)

# Merge files in current environment if raw data has been updated since last
# merged. (If recipe executed, all objects bound in source will be available
# in current env).
make_with_recipe(
  recipe = {
    dat &lt;- readRDS("data/raw_data.Rds")
    pop &lt;- readRDS("data/pop_data.Rds")
    merged_dat &lt;- merge(dat, pop, by = "id")
    saveRDS(merged_dat, "data/merged_data.Rds")
  },
  targets = "data/merged_data.Rds",
  dependencies = c("data/raw_data.Rds", "data/raw_pop.Rds"),
  envir = environment()
)

# Merge files in global environment if raw data has been updated since last
# merged. (If source executed, all objects bound in source will be available
# in global env).
make_with_recipe(
  recipe = {
    dat &lt;- readRDS("data/raw_data.Rds")
    pop &lt;- readRDS("data/pop_data.Rds")
    merged_dat &lt;- merge(dat, pop, by = "id")
    saveRDS(merged_dat, "data/merged_data.Rds")
  },
  targets = "data/merged_data.Rds",
  dependencies = c("data/raw_data.Rds", "data/raw_pop.Rds"),
  envir = globalenv()
)

## End(Not run)
</code></pre>

<hr>
<h2 id='make_with_source'>Make targets out of dependencies using a source file</h2><span id='topic+make_with_source'></span>

<h3>Description</h3>

<p>Make targets out of dependencies using a source file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_with_source(
  source,
  targets,
  dependencies = NULL,
  packages = NULL,
  envir = new.env(parent = parent.frame()),
  quiet = getOption("makepipe.quiet"),
  force = FALSE,
  label = NULL,
  note = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_with_source_+3A_source">source</code></td>
<td>
<p>The path to an R script which makes the <code>targets</code></p>
</td></tr>
<tr><td><code id="make_with_source_+3A_targets">targets</code></td>
<td>
<p>A character vector of paths to files</p>
</td></tr>
<tr><td><code id="make_with_source_+3A_dependencies">dependencies</code></td>
<td>
<p>A character vector of paths to files which the <code>targets</code>
depend on</p>
</td></tr>
<tr><td><code id="make_with_source_+3A_packages">packages</code></td>
<td>
<p>A character vector of names of packages which <code>targets</code>
depend on</p>
</td></tr>
<tr><td><code id="make_with_source_+3A_envir">envir</code></td>
<td>
<p>The environment in which to execute the <code>source</code> or <code>recipe</code>. By
default, execution will take place in a fresh environment whose parent is
the calling environment.</p>
</td></tr>
<tr><td><code id="make_with_source_+3A_quiet">quiet</code></td>
<td>
<p>A logical determining whether or not messages are signaled</p>
</td></tr>
<tr><td><code id="make_with_source_+3A_force">force</code></td>
<td>
<p>A logical determining whether or not execution of the <code>source</code>
or <code>recipe</code> will be forced (i.e. happen whether or not the targets are
out-of-date)</p>
</td></tr>
<tr><td><code id="make_with_source_+3A_label">label</code></td>
<td>
<p>A short label for the <code>source</code> or <code>recipe</code>, displayed in pipeline
visualisations. If <code>NULL</code>, the <code>basename(source)</code> or 'Recipe' will be used.</p>
</td></tr>
<tr><td><code id="make_with_source_+3A_note">note</code></td>
<td>
<p>A description of what the <code>source</code> does, displayed in pipeline
visualisations</p>
</td></tr>
<tr><td><code id="make_with_source_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>base::source()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Segment</code> object containing execution metadata.
</p>


<h3>See Also</h3>

<p>Other make: 
<code><a href="#topic+make_with_dir">make_with_dir</a>()</code>,
<code><a href="#topic+make_with_recipe">make_with_recipe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Merge files in fresh environment if raw data has been updated since last
# merged
make_with_source(
  source = "merge_data.R",
  targets = "data/merged_data.Rds",
  dependencies = c("data/raw_data.Rds", "data/raw_pop.Rds")
)


# Merge files in current environment if raw data has been updated since last
# merged. (If source executed, all objects bound in source will be available
# in current env).
make_with_source(
  source = "merge_data.R",
  targets = "data/merged_data.Rds",
  dependencies = c("data/raw_data.Rds", "data/raw_pop.Rds"),
  envir = environment()
)


# Merge files in global environment if raw data has been updated since last
# merged. (If source executed, all objects bound in source will be available
# in global env).
make_with_source(
  source = "merge_data.R",
  targets = "data/merged_data.Rds",
  dependencies = c("data/raw_data.Rds", "data/raw_pop.Rds"),
  envir = globalenv()
)

## End(Not run)

</code></pre>

<hr>
<h2 id='out_of_date'>Check if targets are out-of-date vis-a-vis their dependencies</h2><span id='topic+out_of_date'></span>

<h3>Description</h3>

<p>Check if targets are out-of-date vis-a-vis their dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>out_of_date(targets, dependencies, packages = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="out_of_date_+3A_targets">targets</code></td>
<td>
<p>A character vector of paths to files</p>
</td></tr>
<tr><td><code id="out_of_date_+3A_dependencies">dependencies</code></td>
<td>
<p>A character vector of paths to files which the <code>targets</code>
depend on</p>
</td></tr>
<tr><td><code id="out_of_date_+3A_packages">packages</code></td>
<td>
<p>A character vector of names of packages which <code>targets</code>
depend on</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if any of <code>targets</code> are older than any of <code>dependencies</code> or if
any of <code>targets</code> do not exist; <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out_of_date("data/processed_data.Rds", "data/raw_data.Rds")

## End(Not run)
</code></pre>

<hr>
<h2 id='Pipeline'>Pipeline visualisations</h2><span id='topic+Pipeline'></span>

<h3>Description</h3>

<p>A Pipeline object is automatically constructed as calls to
<code style="white-space: pre;">&#8288;make_*()&#8288;</code> are made. It stores the relationships between targets,
dependencies, and sources.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>segments</code></dt><dd><p>A list of <code>Segment</code> objects</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Pipeline-add_source_segment"><code>Pipeline$add_source_segment()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-add_recipe_segment"><code>Pipeline$add_recipe_segment()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-build"><code>Pipeline$build()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-clean"><code>Pipeline$clean()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-annotate"><code>Pipeline$annotate()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-refresh"><code>Pipeline$refresh()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-nomnoml"><code>Pipeline$nomnoml()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-visnetwork"><code>Pipeline$visnetwork()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-text_summary"><code>Pipeline$text_summary()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-print"><code>Pipeline$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-save_visnetwork"><code>Pipeline$save_visnetwork()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-save_nomnoml"><code>Pipeline$save_nomnoml()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-save_text_summary"><code>Pipeline$save_text_summary()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-clone"><code>Pipeline$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Pipeline-add_source_segment"></a>



<h4>Method <code>add_source_segment()</code></h4>

<p>Add an edge to <code>edges</code>
</p>
<p>Add any nodes in <code>private$edges</code> that are missing from
<code>private$nodes</code> into <code>private$nodes</code>
</p>
<p>Reconstruct Pipeline edges from Segment edges. Called
primarily to update outofdateness
</p>
<p>Add a pipeline segment corresponding to a <code>make_with_source()</code>
call
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$add_source_segment(
  source,
  targets,
  dependencies,
  packages,
  envir,
  force
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>source</code></dt><dd><p>The path to an R script which makes the <code>targets</code></p>
</dd>
<dt><code>targets</code></dt><dd><p>A character vector of paths to files</p>
</dd>
<dt><code>dependencies</code></dt><dd><p>A character vector of paths to files which the
<code>targets</code> depend on</p>
</dd>
<dt><code>packages</code></dt><dd><p>A character vector of names of packages which <code>targets</code>
depend on</p>
</dd>
<dt><code>envir</code></dt><dd><p>The environment in which to execute the <code>source</code> or <code>recipe</code>.</p>
</dd>
<dt><code>force</code></dt><dd><p>A logical determining whether or not execution of the <code>source</code>
or <code>recipe</code> will be forced (i.e. happen whether or not the targets are
out-of-date)</p>
</dd>
<dt><code>new_edge</code></dt><dd><p>An data.frame constructed with <code>new_edge()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The <code>SegmentSource</code> added to the <code>Pipeline</code>
</p>


<hr>
<a id="method-Pipeline-add_recipe_segment"></a>



<h4>Method <code>add_recipe_segment()</code></h4>

<p>Add a pipeline segment corresponding to a <code>make_with_recipe()</code>
call
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$add_recipe_segment(
  recipe,
  targets,
  dependencies,
  packages,
  envir,
  force
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recipe</code></dt><dd><p>A language object which, when evaluated, makes the <code>targets</code></p>
</dd>
<dt><code>targets</code></dt><dd><p>A character vector of paths to files</p>
</dd>
<dt><code>dependencies</code></dt><dd><p>A character vector of paths to files which the
<code>targets</code> depend on</p>
</dd>
<dt><code>packages</code></dt><dd><p>A character vector of names of packages which <code>targets</code>
depend on</p>
</dd>
<dt><code>envir</code></dt><dd><p>The environment in which to execute the <code>source</code> or <code>recipe</code>.</p>
</dd>
<dt><code>force</code></dt><dd><p>A logical determining whether or not execution of the <code>source</code>
or <code>recipe</code> will be forced (i.e. happen whether or not the targets are
out-of-date)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The <code>SegmentRecipe</code> added to the <code>Pipeline</code>
</p>


<hr>
<a id="method-Pipeline-build"></a>



<h4>Method <code>build()</code></h4>

<p>Build all targets
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$build(quiet = getOption("makepipe.quiet"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>quiet</code></dt><dd><p>A logical determining whether or not messages are signaled</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>
</p>


<hr>
<a id="method-Pipeline-clean"></a>



<h4>Method <code>clean()</code></h4>

<p>Clean all targets
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$clean()</pre></div>



<h5>Returns</h5>

<p><code>self</code>
</p>


<hr>
<a id="method-Pipeline-annotate"></a>



<h4>Method <code>annotate()</code></h4>

<p>Apply annotations to Pipeline
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$annotate(labels = NULL, notes = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>labels</code></dt><dd><p>A named character vector mapping nodes in the <code>Pipeline</code> onto
labels to display beside them.</p>
</dd>
<dt><code>notes</code></dt><dd><p>A named character vector mapping nodes in the <code>Pipeline</code> onto
notes to display on beside the labels (nomnoml) or as tooltips (visNetwork).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Pipeline-refresh"></a>



<h4>Method <code>refresh()</code></h4>

<p>Refresh Pipeline to check outofdateness
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$refresh()</pre></div>


<hr>
<a id="method-Pipeline-nomnoml"></a>



<h4>Method <code>nomnoml()</code></h4>

<p>Display the pipeline with nomnoml
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$nomnoml(
  direction = c("down", "right"),
  arrow_size = 1,
  edge_style = c("hard", "rounded"),
  bend_size = 0.3,
  font = "Courier",
  font_size = 12,
  line_width = 3,
  padding = 16,
  spacing = 40,
  leading = 1.25,
  stroke = "#33322E",
  fill_arrows = FALSE,
  gutter = 5,
  edge_margin = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>direction</code></dt><dd><p>The direction the flowchart should go in</p>
</dd>
<dt><code>arrow_size</code></dt><dd><p>The arrowhead size</p>
</dd>
<dt><code>edge_style</code></dt><dd><p>The arrow edge style</p>
</dd>
<dt><code>bend_size</code></dt><dd><p>The degree of rounding in the arrows (requires
<code>edge_style=rounded</code>)</p>
</dd>
<dt><code>font</code></dt><dd><p>The name of a font to use</p>
</dd>
<dt><code>font_size</code></dt><dd><p>The font size</p>
</dd>
<dt><code>line_width</code></dt><dd><p>The line width for arrows and box outlines</p>
</dd>
<dt><code>padding</code></dt><dd><p>The amount of padding <em>within</em> boxes</p>
</dd>
<dt><code>spacing</code></dt><dd><p>The amount of spacing <em>between</em> boxes,</p>
</dd>
<dt><code>leading</code></dt><dd><p>The amount of spacing between lines of text</p>
</dd>
<dt><code>stroke</code></dt><dd><p>The color of arrows, text, and box outlines</p>
</dd>
<dt><code>fill_arrows</code></dt><dd><p>Whether arrow heads are full triangles (<code>TRUE</code>) or
angled (<code>FALSE</code>)</p>
</dd>
<dt><code>gutter</code></dt><dd><p>The amount space to leave around the flowchart</p>
</dd>
<dt><code>edge_margin</code></dt><dd><p>The amount of space to leave between boxes and arrows</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>
</p>


<hr>
<a id="method-Pipeline-visnetwork"></a>



<h4>Method <code>visnetwork()</code></h4>

<p>Display the pipeline with nomnoml
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$visnetwork(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments (other than <code>nodes</code> and <code>edges</code>) to pass to
<code>visNetwork::visNetwork()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>
</p>


<hr>
<a id="method-Pipeline-text_summary"></a>



<h4>Method <code>text_summary()</code></h4>

<p>Display a text summary of the pipeline
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$text_summary()</pre></div>



<h5>Returns</h5>

<p><code>self</code>
</p>


<hr>
<a id="method-Pipeline-print"></a>



<h4>Method <code>print()</code></h4>

<p>Display
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments (other than <code>nodes</code> and <code>edges</code>) to pass to
<code>visNetwork::visNetwork()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>
</p>


<hr>
<a id="method-Pipeline-save_visnetwork"></a>



<h4>Method <code>save_visnetwork()</code></h4>

<p>Save pipeline visNetwork
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$save_visnetwork(file, selfcontained = TRUE, background = "white", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file</code></dt><dd><p>File to save HTML into</p>
</dd>
<dt><code>selfcontained</code></dt><dd><p>Whether to save the HTML as a single self-contained
file (with external resources base64 encoded) or a file with external
resources placed in an adjacent directory.</p>
</dd>
<dt><code>background</code></dt><dd><p>Text string giving the html background color of the
widget. Defaults to white.</p>
</dd>
<dt><code>...</code></dt><dd><p>Arguments (other than <code>nodes</code> and <code>edges</code>) to pass to
<code>visNetwork::visNetwork()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>
</p>


<hr>
<a id="method-Pipeline-save_nomnoml"></a>



<h4>Method <code>save_nomnoml()</code></h4>

<p>Save pipeline nomnoml
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$save_nomnoml(file, width = NULL, height = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file</code></dt><dd><p>File to save the png into</p>
</dd>
<dt><code>width</code></dt><dd><p>Image width</p>
</dd>
<dt><code>height</code></dt><dd><p>Image height</p>
</dd>
<dt><code>...</code></dt><dd><p>Arguments to pass to <code>self$nomnoml()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>
</p>


<hr>
<a id="method-Pipeline-save_text_summary"></a>



<h4>Method <code>save_text_summary()</code></h4>

<p>Save a text summary of the pipeline
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$save_text_summary(file)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file</code></dt><dd><p>File to save text summary into</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>
</p>


<hr>
<a id="method-Pipeline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other pipeline: 
<code><a href="#topic+pipeline-accessors">pipeline-accessors</a></code>,
<code><a href="#topic+pipeline-vis">pipeline-vis</a></code>
</p>

<hr>
<h2 id='pipeline-accessors'>Access and interface with Pipeline.</h2><span id='topic+pipeline-accessors'></span><span id='topic+is_pipeline'></span><span id='topic+set_pipeline'></span><span id='topic+get_pipeline'></span><span id='topic+reset_pipeline'></span>

<h3>Description</h3>

<p><code>get_pipeline()</code>, <code>set_pipeline()</code> and <code>reset_pipeline()</code> access and modify
the current <em>active</em> pipeline, while all other helper functions do not affect
the active pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_pipeline(pipeline)

set_pipeline(pipeline)

get_pipeline()

reset_pipeline()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pipeline-accessors_+3A_pipeline">pipeline</code></td>
<td>
<p>A pipeline. See <a href="#topic+Pipeline">Pipeline</a> for more details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other pipeline: 
<code><a href="#topic+Pipeline">Pipeline</a></code>,
<code><a href="#topic+pipeline-vis">pipeline-vis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Build up a pipeline from scratch and save it out
reset_pipeline()
# A series of `make_with_*()` blocks go here...
saveRDS(get_pipeline(), "data/my_pipeline.Rds")

# ... Later on we can read in and set the pipeline
p &lt;- readRDS("data/my_pipeline.Rds")
set_pipeline(p)

## End(Not run)
</code></pre>

<hr>
<h2 id='pipeline-vis'>Visualise the Pipeline.</h2><span id='topic+pipeline-vis'></span><span id='topic+show_pipeline'></span><span id='topic+save_pipeline'></span>

<h3>Description</h3>

<p>Produce a flowchart visualisation of the pipeline. Out-of-date targets will
be coloured red, up-to-date targets will be coloured green, and everything
else will be blue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_pipeline(
  pipeline = get_pipeline(),
  as = c("nomnoml", "visnetwork", "text"),
  labels = NULL,
  notes = NULL,
  ...
)

save_pipeline(
  file,
  pipeline = get_pipeline(),
  as = c("nomnoml", "visnetwork", "text"),
  labels = NULL,
  notes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pipeline-vis_+3A_pipeline">pipeline</code></td>
<td>
<p>A pipeline. See <a href="#topic+Pipeline">Pipeline</a> for more details.</p>
</td></tr>
<tr><td><code id="pipeline-vis_+3A_as">as</code></td>
<td>
<p>A string determining whether to use <code>nomnoml</code> or <code>visNetwork</code></p>
</td></tr>
<tr><td><code id="pipeline-vis_+3A_labels">labels</code></td>
<td>
<p>A named character vector mapping nodes in the <code>pipeline</code> onto
labels to display beside them.</p>
</td></tr>
<tr><td><code id="pipeline-vis_+3A_notes">notes</code></td>
<td>
<p>A named character vector mapping nodes in the <code>Pipeline</code> onto
notes to display on beside the labels (nomnoml) or as tooltips (visNetwork).</p>
</td></tr>
<tr><td><code id="pipeline-vis_+3A_...">...</code></td>
<td>
<p>Arguments passed onto <code>Pipeline$nomnoml()</code> or <code>Pipeline$visnetwork</code></p>
</td></tr>
<tr><td><code id="pipeline-vis_+3A_file">file</code></td>
<td>
<p>File to save png (nomnoml) or html (visnetwork) into</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Labels and notes must be supplied as named character vector where the
names correspond to the filepaths of nodes (i.e. <code>targets</code>, <code>dependencies</code>,
or <code>source</code> scripts)
</p>


<h3>See Also</h3>

<p>Other pipeline: 
<code><a href="#topic+Pipeline">Pipeline</a></code>,
<code><a href="#topic+pipeline-accessors">pipeline-accessors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Run pipeline
make_with_source(
  "recode.R",
  "data/0 raw_data.R",
  "data/1 data.R"
)
make_with_source(
  "merge.R",
  c("data/1 data.R", "data/0 raw_pop.R"),
  "data/2 data.R"
)

# Visualise pipeline with custom notes
show_pipeline(notes = c(
  "data/0 raw_data.R" = "Raw survey data",
  "data/0 raw_pop.R" = "Raw population data",
  "data/1 data.R" = "Survey data with recodes applied",
  "data/2 data.R" = "Survey data with demographic variables merged in"
))

## End(Not run)
</code></pre>

<hr>
<h2 id='Segment'>Segment</h2><span id='topic+Segment'></span>

<h3>Description</h3>

<p>A Segment object is automatically constructed and attached to
the Pipeline when a call to <code style="white-space: pre;">&#8288;make_*()&#8288;</code> is made. It stores the relationships
between targets, dependencies, and sources.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>targets</code></dt><dd><p>A character vector of paths to files</p>
</dd>
<dt><code>dependencies</code></dt><dd><p>A character vector of paths to files which the <code>targets</code>
depend on</p>
</dd>
<dt><code>packages</code></dt><dd><p>A character vector of names of packages which <code>targets</code>
depend on</p>
</dd>
<dt><code>force</code></dt><dd><p>A logical determining whether or not execution of the <code>source</code>
or <code>recipe</code> will be forced (i.e. happen whether or not the targets are
out-of-date)</p>
</dd>
<dt><code>envir</code></dt><dd><p>The environment in which to execute the instructions.</p>
</dd>
<dt><code>result</code></dt><dd><p>An object, whatever is returned by executing the instructions</p>
</dd>
<dt><code>executed</code></dt><dd><p>A logical, whether or not the instructions were executed</p>
</dd>
<dt><code>execution_time</code></dt><dd><p>A difftime, the time taken to execute the instructions</p>
</dd>
<dt><code>label</code></dt><dd><p>A short label for the segment</p>
</dd>
<dt><code>note</code></dt><dd><p>A description of what the segment does</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>edges</code></dt><dd><p>Get edges connecting the dependencies, instructions, and targets</p>
</dd>
<dt><code>nodes</code></dt><dd><p>Get nodes corresponding to  dependencies, instructions, and targets</p>
</dd>
<dt><code>text_summary</code></dt><dd><p>A plain text summary of the Segment</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Segment-new"><code>Segment$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Segment-print"><code>Segment$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Segment-update_result"><code>Segment$update_result()</code></a>
</p>
</li>
<li> <p><a href="#method-Segment-annotate"><code>Segment$annotate()</code></a>
</p>
</li>
<li> <p><a href="#method-Segment-clone"><code>Segment$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Segment-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialise a new Segment
</p>


<h5>Usage</h5>

<div class="r"><pre>Segment$new(
  id,
  targets,
  dependencies,
  packages,
  envir,
  force,
  executed,
  result,
  execution_time
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>An integer that uniquely identifies the segment</p>
</dd>
<dt><code>targets</code></dt><dd><p>A character vector of paths to files</p>
</dd>
<dt><code>dependencies</code></dt><dd><p>A character vector of paths to files which the <code>targets</code>
depend on</p>
</dd>
<dt><code>packages</code></dt><dd><p>A character vector of names of packages which <code>targets</code>
depend on</p>
</dd>
<dt><code>envir</code></dt><dd><p>The environment in which to execute the instructions.</p>
</dd>
<dt><code>force</code></dt><dd><p>A logical determining whether or not execution of the <code>source</code>
or <code>recipe</code> will be forced (i.e. happen whether or not the targets are
out-of-date)</p>
</dd>
<dt><code>executed</code></dt><dd><p>A logical, whether or not the instructions were executed</p>
</dd>
<dt><code>result</code></dt><dd><p>An object, whatever is returned by executing the instructions</p>
</dd>
<dt><code>execution_time</code></dt><dd><p>A difftime, the time taken to execute the instructions</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Segment-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printing method
</p>


<h5>Usage</h5>

<div class="r"><pre>Segment$print()</pre></div>


<hr>
<a id="method-Segment-update_result"></a>



<h4>Method <code>update_result()</code></h4>

<p>Update the Segment with new execution information
</p>


<h5>Usage</h5>

<div class="r"><pre>Segment$update_result(executed, execution_time, result)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>executed</code></dt><dd><p>A logical, whether or not the instructions were executed</p>
</dd>
<dt><code>execution_time</code></dt><dd><p>A difftime, the time taken to execute the instructions</p>
</dd>
<dt><code>result</code></dt><dd><p>An object, whatever is returned by executing the instructions</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Segment-annotate"></a>



<h4>Method <code>annotate()</code></h4>

<p>Apply annotations to Segment
</p>


<h5>Usage</h5>

<div class="r"><pre>Segment$annotate(label = NULL, note = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>label</code></dt><dd><p>A short label for the segment</p>
</dd>
<dt><code>note</code></dt><dd><p>A description of what the segment does</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Segment-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Segment$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other segment: 
<code><a href="#topic+SegmentRecipe">SegmentRecipe</a></code>,
<code><a href="#topic+SegmentSource">SegmentSource</a></code>
</p>

<hr>
<h2 id='SegmentRecipe'>Segment</h2><span id='topic+SegmentRecipe'></span>

<h3>Description</h3>

<p>A Segment object is automatically constructed and attached to
the Pipeline when a call to <code style="white-space: pre;">&#8288;make_*()&#8288;</code> is made. It stores the relationships
between targets, dependencies, and sources.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Segment">makepipe::Segment</a></code> -&gt; <code>SegmentRecipe</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>recipe</code></dt><dd><p>A chunk of R code which makes the <code>targets</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SegmentRecipe-new"><code>SegmentRecipe$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SegmentRecipe-update_result"><code>SegmentRecipe$update_result()</code></a>
</p>
</li>
<li> <p><a href="#method-SegmentRecipe-execute"><code>SegmentRecipe$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-SegmentRecipe-clone"><code>SegmentRecipe$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="makepipe" data-topic="Segment" data-id="annotate"><a href='../../makepipe/html/Segment.html#method-Segment-annotate'><code>makepipe::Segment$annotate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="makepipe" data-topic="Segment" data-id="print"><a href='../../makepipe/html/Segment.html#method-Segment-print'><code>makepipe::Segment$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SegmentRecipe-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialise a new Segment
</p>


<h5>Usage</h5>

<div class="r"><pre>SegmentRecipe$new(
  id,
  recipe,
  targets,
  dependencies,
  packages,
  envir,
  force,
  executed,
  result,
  execution_time
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>An integer that uniquely identifies the segment</p>
</dd>
<dt><code>recipe</code></dt><dd><p>A chunk of R code which makes the <code>targets</code></p>
</dd>
<dt><code>targets</code></dt><dd><p>A character vector of paths to files</p>
</dd>
<dt><code>dependencies</code></dt><dd><p>A character vector of paths to files which the <code>targets</code>
depend on</p>
</dd>
<dt><code>packages</code></dt><dd><p>A character vector of names of packages which <code>targets</code>
depend on</p>
</dd>
<dt><code>envir</code></dt><dd><p>The environment in which to execute the instructions.</p>
</dd>
<dt><code>force</code></dt><dd><p>A logical determining whether or not execution of the <code>source</code>
or <code>recipe</code> will be forced (i.e. happen whether or not the targets are
out-of-date)</p>
</dd>
<dt><code>executed</code></dt><dd><p>A logical, whether or not the instructions were executed</p>
</dd>
<dt><code>result</code></dt><dd><p>An object, whatever is returned by executing the instructions</p>
</dd>
<dt><code>execution_time</code></dt><dd><p>A difftime, the time taken to execute the instructions</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SegmentRecipe-update_result"></a>



<h4>Method <code>update_result()</code></h4>

<p>Update the Segment with new execution information
</p>


<h5>Usage</h5>

<div class="r"><pre>SegmentRecipe$update_result(executed, execution_time, result)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>executed</code></dt><dd><p>A logical, whether or not the instructions were executed</p>
</dd>
<dt><code>execution_time</code></dt><dd><p>A difftime, the time taken to execute the instructions</p>
</dd>
<dt><code>result</code></dt><dd><p>An object, whatever is returned by executing the instructions</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SegmentRecipe-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Execute the Segment
</p>


<h5>Usage</h5>

<div class="r"><pre>SegmentRecipe$execute(envir = NULL, quiet = getOption("makepipe.quiet"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>envir</code></dt><dd><p>The environment in which to execute the instructions.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>A logical determining whether or not messages are signaled</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters to pass to <code>base::eval()</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-SegmentRecipe-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SegmentRecipe$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other segment: 
<code><a href="#topic+SegmentSource">SegmentSource</a></code>,
<code><a href="#topic+Segment">Segment</a></code>
</p>

<hr>
<h2 id='SegmentSource'>Segment</h2><span id='topic+SegmentSource'></span>

<h3>Description</h3>

<p>A Segment object is automatically constructed and attached to
the Pipeline when a call to <code style="white-space: pre;">&#8288;make_*()&#8288;</code> is made. It stores the relationships
between targets, dependencies, and sources.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Segment">makepipe::Segment</a></code> -&gt; <code>SegmentSource</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>source</code></dt><dd><p>The path to an R script which makes the <code>targets</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SegmentSource-new"><code>SegmentSource$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SegmentSource-update_result"><code>SegmentSource$update_result()</code></a>
</p>
</li>
<li> <p><a href="#method-SegmentSource-execute"><code>SegmentSource$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-SegmentSource-clone"><code>SegmentSource$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="makepipe" data-topic="Segment" data-id="annotate"><a href='../../makepipe/html/Segment.html#method-Segment-annotate'><code>makepipe::Segment$annotate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="makepipe" data-topic="Segment" data-id="print"><a href='../../makepipe/html/Segment.html#method-Segment-print'><code>makepipe::Segment$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SegmentSource-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialise a new Segment
</p>


<h5>Usage</h5>

<div class="r"><pre>SegmentSource$new(
  id,
  source,
  targets,
  dependencies,
  packages,
  envir,
  force,
  executed,
  result,
  execution_time
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>An integer that uniquely identifies the segment</p>
</dd>
<dt><code>source</code></dt><dd><p>The path to an R script which makes the <code>targets</code></p>
</dd>
<dt><code>targets</code></dt><dd><p>A character vector of paths to files</p>
</dd>
<dt><code>dependencies</code></dt><dd><p>A character vector of paths to files which the <code>targets</code>
depend on</p>
</dd>
<dt><code>packages</code></dt><dd><p>A character vector of names of packages which <code>targets</code>
depend on</p>
</dd>
<dt><code>envir</code></dt><dd><p>The environment in which to execute the instructions.</p>
</dd>
<dt><code>force</code></dt><dd><p>A logical determining whether or not execution of the <code>source</code>
or <code>recipe</code> will be forced (i.e. happen whether or not the targets are
out-of-date)</p>
</dd>
<dt><code>executed</code></dt><dd><p>A logical, whether or not the instructions were executed</p>
</dd>
<dt><code>result</code></dt><dd><p>An object, whatever is returned by executing the instructions</p>
</dd>
<dt><code>execution_time</code></dt><dd><p>A difftime, the time taken to execute the instructions</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SegmentSource-update_result"></a>



<h4>Method <code>update_result()</code></h4>

<p>Update the Segment with new execution information
</p>


<h5>Usage</h5>

<div class="r"><pre>SegmentSource$update_result(executed, execution_time, result)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>executed</code></dt><dd><p>A logical, whether or not the instructions were executed</p>
</dd>
<dt><code>execution_time</code></dt><dd><p>A difftime, the time taken to execute the instructions</p>
</dd>
<dt><code>result</code></dt><dd><p>An object, whatever is returned by executing the instructions</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SegmentSource-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Execute the Segment
</p>


<h5>Usage</h5>

<div class="r"><pre>SegmentSource$execute(envir = NULL, quiet = getOption("makepipe.quiet"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>envir</code></dt><dd><p>The environment in which to execute the instructions.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>A logical determining whether or not messages are signaled</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters to pass to <code>base::source()</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-SegmentSource-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SegmentSource$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other segment: 
<code><a href="#topic+SegmentRecipe">SegmentRecipe</a></code>,
<code><a href="#topic+Segment">Segment</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
