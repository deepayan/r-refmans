<!DOCTYPE html><html><head><title>Help for package pbkrtest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pbkrtest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compare_column_space'><p>Compare column spaces</p></a></li>
<li><a href='#compute_auxiliary'><p>Compute_auxiliary quantities needed for the Satterthwaite</p>
approximation.</a></li>
<li><a href='#data-beets'><p>Sugar beets data</p></a></li>
<li><a href='#data-budworm'><p>Budworm data</p></a></li>
<li><a href='#devfun_vp'><p>Compute deviance of a linear mixed model as a function of variance parameters</p></a></li>
<li><a href='#get_covbeta'><p>Compute covariance of fixed effect parameters as a function of variance parameters of a linear mixed model</p></a></li>
<li><a href='#get_ddf_Lb'><p>Adjusted denominator degrees of freedom for linear estimate for linear</p>
mixed model.</a></li>
<li><a href='#get_Fstat_ddf'><p>Compute denominator degrees of freedom for F-test</p></a></li>
<li><a href='#get_modcomp'><p>Extract (or &quot;get&quot;) components from a <code>KRmodcomp</code> object.</p></a></li>
<li><a href='#internal'><p>Internal functions for the pbkrtest package</p></a></li>
<li><a href='#internal-pbkrtest'><p>pbkrtest internal</p></a></li>
<li><a href='#kr-modcomp'><p>F-test and degrees of freedom based on Kenward-Roger approximation</p></a></li>
<li><a href='#kr-vcovAdj'><p>Adjusted covariance matrix for linear mixed models according</p>
to Kenward and Roger</a></li>
<li><a href='#model-coerce'><p>Conversion between a model object and a restriction matrix</p></a></li>
<li><a href='#pb-modcomp'><p>Model comparison using parametric bootstrap methods.</p></a></li>
<li><a href='#pb-refdist'><p>Calculate reference distribution using parametric bootstrap</p></a></li>
<li><a href='#sat-modcomp'><p>F-test and degrees of freedom based on Satterthwaite approximation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.5.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Parametric Bootstrap, Kenward-Roger and Satterthwaite Based
Methods for Test in Mixed Models</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes p-values based on (a) Satterthwaite or
    Kenward-Rogers degree of freedom methods and (b) parametric bootstrap
    for mixed effects models as implemented in the 'lme4'
    package. Implements parametric bootstrap test for generalized linear
    mixed models as implemented in 'lme4' and generalized linear
    models. The package is documented in the paper by Halekoh and
    Højsgaard, (2012, &lt;<a href="https://doi.org/10.18637%2Fjss.v059.i09">doi:10.18637/jss.v059.i09</a>&gt;).  Please see
    'citation("pbkrtest")' for citation details.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://people.math.aau.dk/~sorenh/software/pbkrtest/">https://people.math.aau.dk/~sorenh/software/pbkrtest/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), lme4 (&ge; 1.1.31)</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, dplyr, MASS, Matrix (&ge; 1.2.3), methods, numDeriv,
parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>Yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-19 07:09:26 UTC; sorenh</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrich Halekoh [aut, cph],
  Søren Højsgaard [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-19 18:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='compare_column_space'>Compare column spaces</h2><span id='topic+compare_column_space'></span>

<h3>Description</h3>

<p>Compare column spaces of two matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_column_space(X1, X2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_column_space_+3A_x1">X1</code>, <code id="compare_column_space_+3A_x2">X2</code></td>
<td>
<p>matrices with the same number of rows</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> -1 : Either C(X1)=C(X2), or the spaces are not nested.
</p>
</li>
<li><p> 0 : C(X1) is contained in C(X2)
</p>
</li>
<li><p> 1 : C(X2) is contained in C(X1)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
A1 &lt;- matrix(c(1,1,1,1,2,3), nrow=3)
A2 &lt;- A1[, 1, drop=FALSE]

compare_column_space(A1, A2)
compare_column_space(A2, A1)
compare_column_space(A1, A1)

</code></pre>

<hr>
<h2 id='compute_auxiliary'>Compute_auxiliary quantities needed for the Satterthwaite
approximation.</h2><span id='topic+compute_auxiliary'></span>

<h3>Description</h3>

<p>Computes variance-covariance matrix of variance parameters (theta, sigma), the Jacobian of
each variance parameter etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_auxiliary(model, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_auxiliary_+3A_model">model</code></td>
<td>
<p>A linear mixed model object</p>
</td></tr>
<tr><td><code id="compute_auxiliary_+3A_tol">tol</code></td>
<td>
<p>A tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard
</p>

<hr>
<h2 id='data-beets'>Sugar beets data</h2><span id='topic+data-beets'></span><span id='topic+beets'></span>

<h3>Description</h3>

<p>Yield and sugar percentage in sugar beets from a split plot
experiment.  The experimental layout was as follows: There were
three blocks. In each block, the harvest time defines the
&quot;whole plot&quot; and the sowing time defines the &quot;split plot&quot;. Each
plot was <code class="reqn">25 m^2</code> and the yield is recorded in kg. See
'details' for the experimental layout. The data originates from
a study carried out at The Danish Institute for Agricultural
Sciences (the institute does not exist any longer; it became
integrated in a Danish university).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beets
</code></pre>


<h3>Format</h3>

<p>A dataframe with 5 columns and 30 rows.
</p>


<h3>Details</h3>

<pre>  
Experimental plan
Sowing times            1        4. april
                        2       12. april
                        3       21. april
                        4       29. april
                        5       18. may
Harvest times           1        2. october
                        2       21. october
Plot allocation:
               Block 1     Block 2     Block 3
            +-----------|-----------|-----------+
      Plot  | 1 1 1 1 1 | 2 2 2 2 2 | 1 1 1 1 1 | Harvest time
       1-15 | 3 4 5 2 1 | 3 2 4 5 1 | 5 2 3 4 1 | Sowing time
            |-----------|-----------|-----------|
      Plot  | 2 2 2 2 2 | 1 1 1 1 1 | 2 2 2 2 2 | Harvest time
      16-30 | 2 1 5 4 3 | 4 1 3 2 5 | 1 4 3 2 5 | Sowing time
            +-----------|-----------|-----------+  
</pre>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beets)

beets$bh &lt;- with(beets, interaction(block, harvest))
summary(aov(yield ~ block + sow + harvest + Error(bh), beets))
summary(aov(sugpct ~ block + sow + harvest + Error(bh), beets))

</code></pre>

<hr>
<h2 id='data-budworm'>Budworm data</h2><span id='topic+data-budworm'></span><span id='topic+budworm'></span>

<h3>Description</h3>

<p>Experiment on the toxicity to the tobacco budworm
Heliothis virescens of doses of the pyrethroid
trans-cypermethrin to which the moths were beginning to show
resistance. Batches of 20 moths of each sex were exposed for
three days to the pyrethroid and the number in each batch that
were dead or knocked down was recorded. Data is reported in
Collett (1991, p. 75).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>budworm
</code></pre>


<h3>Format</h3>

<p>This data frame contains 12 rows and 4 columns:
</p>

<dl>
<dt>sex:</dt><dd><p>sex of the budworm.</p>
</dd>
<dt>dose:</dt><dd><p>dose of the insecticide trans-cypermethrin (in micro grams)</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>ndead:</dt><dd><p>budworms killed in a trial.</p>
</dd>
<dt>ntotal:</dt><dd><p>total number of budworms exposed per trial.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Collett, D. (1991) Modelling Binary Data, Chapman &amp; Hall, London,
Example 3.7
</p>


<h3>References</h3>

<p>Venables, W.N; Ripley, B.D.(1999) Modern Applied Statistics with
S-Plus, Heidelberg, Springer, 3rd edition, chapter 7.2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(budworm)

## function to caclulate the empirical logits
empirical.logit&lt;- function(nevent,ntotal) {
   y &lt;- log((nevent + 0.5) / (ntotal - nevent + 0.5))
   y
}


# plot the empirical logits against log-dose

log.dose &lt;- log(budworm$dose)
emp.logit &lt;- empirical.logit(budworm$ndead, budworm$ntotal)
plot(log.dose, emp.logit, type='n', xlab='log-dose',ylab='emprirical logit')
title('budworm: emprirical logits of probability to die ')
male &lt;- budworm$sex=='male'
female &lt;- budworm$sex=='female'
lines(log.dose[male], emp.logit[male], type='b', lty=1, col=1)
lines(log.dose[female], emp.logit[female], type='b', lty=2, col=2)
legend(0.5, 2, legend=c('male', 'female'), lty=c(1,2), col=c(1,2))

## Not run: 
* SAS example;
data budworm;
infile 'budworm.txt' firstobs=2;
input sex dose ndead ntotal;
run;

## End(Not run)


</code></pre>

<hr>
<h2 id='devfun_vp'>Compute deviance of a linear mixed model as a function of variance parameters</h2><span id='topic+devfun_vp'></span>

<h3>Description</h3>

<p>This function is used for extracting the asymptotic variance-covariance matrix
of the variance parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>devfun_vp(varpar, devfun, reml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="devfun_vp_+3A_varpar">varpar</code></td>
<td>
<p>variance parameters; <code>varpar = c(theta, sigma)</code>.</p>
</td></tr>
<tr><td><code id="devfun_vp_+3A_devfun">devfun</code></td>
<td>
<p>deviance function as a function of theta only.</p>
</td></tr>
<tr><td><code id="devfun_vp_+3A_reml">reml</code></td>
<td>
<p>if <code>TRUE</code> the REML deviance is computed;
if <code>FALSE</code>, the ML deviance is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the REML or ML deviance.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen. Adapted to pbkrtest by Søren Højsgaard.
</p>

<hr>
<h2 id='get_covbeta'>Compute covariance of fixed effect parameters as a function of variance parameters of a linear mixed model</h2><span id='topic+get_covbeta'></span>

<h3>Description</h3>

<p>At the optimum the covariance is available as <code>vcov(lmer-model)</code>. This function
computes <code>cov(beta)</code> at non (RE)ML estimates of <code>varpar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_covbeta(varpar, devfun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_covbeta_+3A_varpar">varpar</code></td>
<td>
<p>variance parameters; <code>varpar = c(theta, sigma)</code>.</p>
</td></tr>
<tr><td><code id="get_covbeta_+3A_devfun">devfun</code></td>
<td>
<p>deviance function as a function of theta only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariances matrix of the fixed effects at supplied <code>varpar</code> values.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen. Adapted to pbkrtest by Søren Højsgaard.
</p>

<hr>
<h2 id='get_ddf_Lb'>Adjusted denominator degrees of freedom for linear estimate for linear
mixed model.</h2><span id='topic+get_ddf_Lb'></span><span id='topic+get_Lb_ddf'></span><span id='topic+get_Lb_ddf.lmerMod'></span><span id='topic+Lb_ddf'></span><span id='topic+get_ddf_Lb.lmerMod'></span><span id='topic+ddf_Lb'></span>

<h3>Description</h3>

<p>Get adjusted denominator degrees freedom for testing Lb=0 in a
linear mixed model where L is a restriction matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Lb_ddf(object, L)

## S3 method for class 'lmerMod'
get_Lb_ddf(object, L)

get_ddf_Lb(object, Lcoef)

## S3 method for class 'lmerMod'
get_ddf_Lb(object, Lcoef)

Lb_ddf(L, V0, Vadj)

ddf_Lb(VVa, Lcoef, VV0 = VVa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ddf_Lb_+3A_object">object</code></td>
<td>
<p>A linear mixed model object.</p>
</td></tr>
<tr><td><code id="get_ddf_Lb_+3A_l">L</code></td>
<td>
<p>A vector with the same length as <code>fixef(object)</code> or a matrix
with the same number of columns as the length of <code>fixef(object)</code></p>
</td></tr>
<tr><td><code id="get_ddf_Lb_+3A_lcoef">Lcoef</code></td>
<td>
<p>Linear contrast matrix</p>
</td></tr>
<tr><td><code id="get_ddf_Lb_+3A_v0">V0</code>, <code id="get_ddf_Lb_+3A_vadj">Vadj</code></td>
<td>
<p>The unadjusted and the adjusted covariance matrices for the fixed
effects parameters. The unadjusted covariance matrix is obtained with
<code>vcov()</code> and adjusted with <code>vcovAdj()</code>.</p>
</td></tr>
<tr><td><code id="get_ddf_Lb_+3A_vva">VVa</code></td>
<td>
<p>Adjusted covariance matrix</p>
</td></tr>
<tr><td><code id="get_ddf_Lb_+3A_vv0">VV0</code></td>
<td>
<p>Unadjusted covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjusted degrees of freedom (adjustment made by a Kenward-Roger
approximation).
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KRmodcomp">KRmodcomp</a></code>, <code><a href="#topic+vcovAdj">vcovAdj</a></code>,
<code><a href="#topic+model2restriction_matrix">model2restriction_matrix</a></code>,
<code><a href="#topic+restriction_matrix2model">restriction_matrix2model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(fmLarge &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
## removing Days
(fmSmall &lt;- lmer(Reaction ~ 1 + (Days|Subject), sleepstudy))
anova(fmLarge, fmSmall)

KRmodcomp(fmLarge, fmSmall)  ## 17 denominator df's
get_Lb_ddf(fmLarge, c(0, 1)) ## 17 denominator df's

# Notice: The restriction matrix L corresponding to the test above
# can be found with
L &lt;- model2restriction_matrix(fmLarge, fmSmall)
L

</code></pre>

<hr>
<h2 id='get_Fstat_ddf'>Compute denominator degrees of freedom for F-test</h2><span id='topic+get_Fstat_ddf'></span>

<h3>Description</h3>

<p>From a vector of denominator degrees of freedom from independent t-statistics (<code>nu</code>),
the denominator degrees of freedom for the corresponding F-test is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Fstat_ddf(nu, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Fstat_ddf_+3A_nu">nu</code></td>
<td>
<p>vector of denominator degrees of freedom for the
t-statistics</p>
</td></tr>
<tr><td><code id="get_Fstat_ddf_+3A_tol">tol</code></td>
<td>
<p>tolerance on the consecutive differences between
elements of nu to determine if mean(nu) should be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if any <code>nu &lt;= 2</code> then <code>2</code> is returned. Also, if all nu
are within <code>tol</code> of each other the simple average of the nu-vector is returned.
This is to avoid downward bias.
</p>


<h3>Value</h3>

<p>the denominator degrees of freedom; a numerical scalar
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen. Adapted to pbkrtest by Søren Højsgaard.
</p>

<hr>
<h2 id='get_modcomp'>Extract (or &quot;get&quot;) components from a <code>KRmodcomp</code> object.</h2><span id='topic+get_modcomp'></span><span id='topic+getKR'></span><span id='topic+getSAT'></span>

<h3>Description</h3>

<p>Extract (or &quot;get&quot;) components from a <code>KRmodcomp</code> object,
which is the result of the <code>KRmodcomp</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKR(
  object,
  name = c("ndf", "ddf", "Fstat", "p.value", "F.scaling", "FstatU", "p.valueU", "aux")
)

getSAT(object, name = c("ndf", "ddf", "Fstat", "p.value"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_modcomp_+3A_object">object</code></td>
<td>
<p>A <code>KRmodcomp</code> object, which is the result of the
<code>KRmodcomp</code> function</p>
</td></tr>
<tr><td><code id="get_modcomp_+3A_name">name</code></td>
<td>
<p>The available slots. If <code>name</code> is missing or <code>NULL</code>
then everything is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KRmodcomp">KRmodcomp</a></code>, <code><a href="#topic+PBmodcomp">PBmodcomp</a></code>,
<code><a href="#topic+vcovAdj">vcovAdj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(beets, package='pbkrtest')
lg &lt;- lmer(sugpct ~ block + sow + harvest + (1|block:harvest), 
              data=beets, REML=FALSE)
sm &lt;- update(lg, .~. - harvest)
modcomp &lt;- KRmodcomp(lg, sm)
getKR(modcomp, "ddf") # get denominator degrees of freedom.


</code></pre>

<hr>
<h2 id='internal'>Internal functions for the pbkrtest package</h2><span id='topic+internal'></span><span id='topic+print.PBmodcomp'></span><span id='topic+print.summary_PBmodcomp'></span><span id='topic+summary.PBmodcomp'></span><span id='topic+plot.PBmodcomp'></span><span id='topic+summary.KRmodcomp'></span><span id='topic+print.KRmodcomp'></span><span id='topic+KRmodcomp_init'></span><span id='topic+KRmodcomp_init.lmerMod'></span><span id='topic+KRmodcomp_init.mer'></span><span id='topic+as.data.frame.XXmodcomp'></span><span id='topic+tidy'></span>

<h3>Description</h3>

<p>These functions are not intended to be called directly.
</p>

<hr>
<h2 id='internal-pbkrtest'>pbkrtest internal</h2><span id='topic+internal-pbkrtest'></span>

<h3>Description</h3>

<p>pbkrtest internal
</p>

<hr>
<h2 id='kr-modcomp'>F-test and degrees of freedom based on Kenward-Roger approximation</h2><span id='topic+kr-modcomp'></span><span id='topic+KRmodcomp'></span><span id='topic+KRmodcomp.lmerMod'></span><span id='topic+KRmodcomp_internal'></span><span id='topic+KRmodcomp.mer'></span>

<h3>Description</h3>

<p>An approximate F-test based on the Kenward-Roger approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KRmodcomp(largeModel, smallModel, betaH = 0, details = 0)

## S3 method for class 'lmerMod'
KRmodcomp(largeModel, smallModel, betaH = 0, details = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kr-modcomp_+3A_largemodel">largeModel</code></td>
<td>
<p>An <code>lmer</code> model</p>
</td></tr>
<tr><td><code id="kr-modcomp_+3A_smallmodel">smallModel</code></td>
<td>
<p>An <code>lmer</code> model or a restriction matrix</p>
</td></tr>
<tr><td><code id="kr-modcomp_+3A_betah">betaH</code></td>
<td>
<p>A number or a vector of the beta of the hypothesis, e.g. L
beta=L betaH. betaH=0 if <code>smallModel</code> is a model object and not a restriction matrix.</p>
</td></tr>
<tr><td><code id="kr-modcomp_+3A_details">details</code></td>
<td>
<p>If larger than 0 some timing details are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model <code>object</code> must be fitted with restricted maximum
likelihood (i.e. with <code>REML=TRUE</code>). If the object is fitted with
maximum likelihood (i.e. with <code>REML=FALSE</code>) then the model is
refitted with <code>REML=TRUE</code> before the p-values are calculated. Put
differently, the user needs not worry about this issue.
</p>
<p>An F test is calculated according to the approach of Kenward and Roger
(1997).  The function works for linear mixed models fitted with the
<code>lmer</code> function of the <span class="pkg">lme4</span> package. Only models where the
covariance structure is a sum of known matrices can be compared.
</p>
<p>The <code>largeModel</code> may be a model fitted with <code>lmer</code> either using
<code>REML=TRUE</code> or <code>REML=FALSE</code>.  The <code>smallModel</code> can be a model
fitted with <code>lmer</code>. It must have the same covariance structure as
<code>largeModel</code>. Furthermore, its linear space of expectation must be a
subspace of the space for <code>largeModel</code>.  The model <code>smallModel</code>
can also be a restriction matrix <code>L</code> specifying the hypothesis <code class="reqn">L
\beta = L \beta_H</code>, where <code class="reqn">L</code> is a <code class="reqn">k \times p</code> matrix and
<code class="reqn">\beta</code> is a <code class="reqn">p</code> column vector the same length as
<code>fixef(largeModel)</code>.
</p>
<p>The <code class="reqn">\beta_H</code> is a <code class="reqn">p</code> column vector.
</p>
<p>Notice: if you want to test a hypothesis <code class="reqn">L \beta = c</code> with a <code class="reqn">k</code>
vector <code class="reqn">c</code>, a suitable <code class="reqn">\beta_H</code> is obtained via <code class="reqn">\beta_H=L c</code>
where <code class="reqn">L_n</code> is a g-inverse of <code class="reqn">L</code>.
</p>
<p>Notice: It cannot be guaranteed that the results agree with other
implementations of the Kenward-Roger approach!
</p>


<h3>Note</h3>

<p>This functionality is not thoroughly tested and should be used with
care. Please do report bugs etc.
</p>


<h3>Author(s)</h3>

<p>Ulrich Halekoh <a href="mailto:uhalekoh@health.sdu.dk">uhalekoh@health.sdu.dk</a>, Søren Højsgaard
<a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>
<p>Kenward, M. G. and Roger, J. H. (1997), <em>Small Sample Inference for
Fixed Effects from Restricted Maximum Likelihood</em>, Biometrics 53: 983-997.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getKR">getKR</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>, <code><a href="#topic+vcovAdj">vcovAdj</a></code>,
<code><a href="#topic+PBmodcomp">PBmodcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(fmLarge &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
## removing Days
(fmSmall &lt;- lmer(Reaction ~ 1 + (Days|Subject), sleepstudy))
anova(fmLarge, fmSmall)
KRmodcomp(fmLarge, fmSmall)

## The same test using a restriction matrix
L &lt;- cbind(0, 1)
KRmodcomp(fmLarge, L)

## Same example, but with independent intercept and slope effects:
m.large  &lt;- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), data = sleepstudy)
m.small  &lt;- lmer(Reaction ~ 1 + (1|Subject) + (0+Days|Subject), data = sleepstudy)
anova(m.large, m.small)
KRmodcomp(m.large, m.small)


</code></pre>

<hr>
<h2 id='kr-vcovAdj'>Adjusted covariance matrix for linear mixed models according
to Kenward and Roger</h2><span id='topic+kr-vcovAdj'></span><span id='topic+vcovAdj'></span><span id='topic+vcovAdj.lmerMod'></span><span id='topic+vcovAdj_internal'></span><span id='topic+vcovAdj0'></span><span id='topic+vcovAdj2'></span><span id='topic+vcovAdj.mer'></span><span id='topic+LMM_Sigma_G'></span><span id='topic+get_SigmaG'></span><span id='topic+get_SigmaG.lmerMod'></span><span id='topic+get_SigmaG.mer'></span>

<h3>Description</h3>

<p>Kenward and Roger (1997) describe an improved small
sample approximation to the covariance matrix estimate of the
fixed parameters in a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcovAdj(object, details = 0)

## S3 method for class 'lmerMod'
vcovAdj(object, details = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kr-vcovAdj_+3A_object">object</code></td>
<td>
<p>An <code>lmer</code> model</p>
</td></tr>
<tr><td><code id="kr-vcovAdj_+3A_details">details</code></td>
<td>
<p>If larger than 0 some timing details are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>phiA</code></td>
<td>
<p>the estimated covariance matrix, this has attributed P, a
list of matrices used in <code>KR_adjust</code> and the estimated matrix W of
the variances of the covariance parameters of the random effects</p>
</td></tr>
<tr><td><code>SigmaG</code></td>
<td>
<p>list: Sigma: the covariance matrix of Y; G: the G matrices that
sum up to Sigma; <code>n.ggamma</code>: the number (called M in the article) of G
matrices) </p>
</td></tr>
</table>


<h3>Note</h3>

<p>If $N$ is the number of observations, then the <code>vcovAdj()</code>
function involves inversion of an $N x N$ matrix, so the computations can
be relatively slow.
</p>


<h3>Author(s)</h3>

<p>Ulrich Halekoh <a href="mailto:uhalekoh@health.sdu.dk">uhalekoh@health.sdu.dk</a>, Søren Højsgaard
<a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>
<p>Kenward, M. G. and Roger, J. H. (1997), <em>Small Sample Inference for
Fixed Effects from Restricted Maximum Likelihood</em>, Biometrics 53: 983-997.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getKR">getKR</a></code>, <code><a href="#topic+KRmodcomp">KRmodcomp</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>,
<code><a href="#topic+PBmodcomp">PBmodcomp</a></code>, <code><a href="#topic+vcovAdj">vcovAdj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
class(fm1)

## Here the adjusted and unadjusted covariance matrices are identical,
## but that is not generally the case:

v1 &lt;- vcov(fm1)
v2 &lt;- vcovAdj(fm1, details=0)
v2 / v1

## For comparison, an alternative estimate of the variance-covariance
## matrix is based on parametric bootstrap (and this is easily
## parallelized): 

## Not run: 
nsim &lt;- 100
sim &lt;- simulate(fm.ml, nsim)
B &lt;- lapply(sim, function(newy) try(fixef(refit(fm.ml, newresp=newy))))
B &lt;- do.call(rbind, B)
v3 &lt;- cov.wt(B)$cov
v2/v1
v3/v1

## End(Not run)



</code></pre>

<hr>
<h2 id='model-coerce'>Conversion between a model object and a restriction matrix</h2><span id='topic+model-coerce'></span><span id='topic+model2restriction_matrix'></span><span id='topic+restriction_matrix2model'></span><span id='topic+make_model_matrix'></span><span id='topic+make_restriction_matrix'></span>

<h3>Description</h3>

<p>Testing a small model under a large model corresponds
imposing restrictions on the model matrix of the larger model
and these restrictions come in the form of a restriction
matrix. These functions converts a model to a restriction
matrix and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model2restriction_matrix(largeModel, smallModel, sparse = FALSE)

restriction_matrix2model(largeModel, L, REML = TRUE, ...)

make_model_matrix(X, L)

make_restriction_matrix(X, X2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model-coerce_+3A_largemodel">largeModel</code>, <code id="model-coerce_+3A_smallmodel">smallModel</code></td>
<td>
<p>Model objects of the same &quot;type&quot;. Possible types
are linear mixed effects models and linear models (including generalized
linear models)</p>
</td></tr>
<tr><td><code id="model-coerce_+3A_sparse">sparse</code></td>
<td>
<p>Should the restriction matrix be sparse or dense?</p>
</td></tr>
<tr><td><code id="model-coerce_+3A_l">L</code></td>
<td>
<p>A restriction matrix; a full rank matrix with as many columns as <code>X</code> has.</p>
</td></tr>
<tr><td><code id="model-coerce_+3A_reml">REML</code></td>
<td>
<p>Controls if new model object should be fitted with REML or ML.</p>
</td></tr>
<tr><td><code id="model-coerce_+3A_...">...</code></td>
<td>
<p>Additional arguments; not used.</p>
</td></tr>
<tr><td><code id="model-coerce_+3A_x">X</code>, <code id="model-coerce_+3A_x2">X2</code></td>
<td>
<p>Model matrices. Must have same number of rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make_restriction_matrix</code> Make a restriction matrix. If span(X2) is in
span(X) then the corresponding restriction matrix <code>L</code> is
returned.
</p>


<h3>Value</h3>

<p><code>model2restriction_matrix</code>: A restriction matrix.
<code>restriction_matrix2model</code>: A model object.
</p>


<h3>Note</h3>

<p>That these functions are visible is a recent addition; minor changes
may occur.
</p>


<h3>Author(s)</h3>

<p>Ulrich Halekoh <a href="mailto:uhalekoh@health.sdu.dk">uhalekoh@health.sdu.dk</a>, Søren Højsgaard
<a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PBmodcomp">PBmodcomp</a></code>, <code><a href="#topic+PBrefdist">PBrefdist</a></code>,
<code><a href="#topic+KRmodcomp">KRmodcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pbkrtest)
data("beets", package = "pbkrtest")
sug &lt;- lm(sugpct ~ block + sow + harvest, data=beets)
sug.h &lt;- update(sug, .~. - harvest)
sug.s &lt;- update(sug, .~. - sow)

## Construct restriction matrices from models
L.h &lt;- model2restriction_matrix(sug, sug.h); L.h
L.s &lt;- model2restriction_matrix(sug, sug.s); L.s

## Construct submodels from restriction matrices
mod.h &lt;- restriction_matrix2model(sug, L.h); mod.h
mod.s &lt;- restriction_matrix2model(sug, L.s); mod.s

## Sanity check: The models have the same fitted values and log likelihood
plot(fitted(mod.h), fitted(sug.h))
plot(fitted(mod.s), fitted(sug.s))
logLik(mod.h)
logLik(sug.h)
logLik(mod.s)
logLik(sug.s)
</code></pre>

<hr>
<h2 id='pb-modcomp'>Model comparison using parametric bootstrap methods.</h2><span id='topic+pb-modcomp'></span><span id='topic+PBmodcomp'></span><span id='topic+PBmodcomp.lm'></span><span id='topic+PBmodcomp.merMod'></span><span id='topic+getLRT'></span><span id='topic+getLRT.lm'></span><span id='topic+getLRT.merMod'></span><span id='topic+plot.XXmodcomp'></span><span id='topic+PBmodcomp.mer'></span><span id='topic+getLRT.mer'></span><span id='topic+seqPBmodcomp'></span>

<h3>Description</h3>

<p>Model comparison of nested models using parametric bootstrap
methods.  Implemented for some commonly applied model types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PBmodcomp(
  largeModel,
  smallModel,
  nsim = 1000,
  ref = NULL,
  seed = NULL,
  cl = NULL,
  details = 0
)

## S3 method for class 'merMod'
PBmodcomp(
  largeModel,
  smallModel,
  nsim = 1000,
  ref = NULL,
  seed = NULL,
  cl = NULL,
  details = 0
)

## S3 method for class 'lm'
PBmodcomp(
  largeModel,
  smallModel,
  nsim = 1000,
  ref = NULL,
  seed = NULL,
  cl = NULL,
  details = 0
)

seqPBmodcomp(largeModel, smallModel, h = 20, nsim = 1000, cl = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pb-modcomp_+3A_largemodel">largeModel</code></td>
<td>
<p>A model object. Can be a linear mixed effects
model or generalized linear mixed effects model (as fitted with
<code>lmer()</code> and <code>glmer()</code> function in the <span class="pkg">lme4</span>
package) or a linear normal model or a generalized linear
model. The <code>largeModel</code> must be larger than
<code>smallModel</code> (see below).</p>
</td></tr>
<tr><td><code id="pb-modcomp_+3A_smallmodel">smallModel</code></td>
<td>
<p>A model of the same type as <code>largeModel</code> or
a restriction matrix.</p>
</td></tr>
<tr><td><code id="pb-modcomp_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to form the reference
distribution.</p>
</td></tr>
<tr><td><code id="pb-modcomp_+3A_ref">ref</code></td>
<td>
<p>Vector containing samples from the reference
distribution. If NULL, this vector will be generated using
<code>PBrefdist()</code>.</p>
</td></tr>
<tr><td><code id="pb-modcomp_+3A_seed">seed</code></td>
<td>
<p>A seed that will be passed to the simulation of new
datasets.</p>
</td></tr>
<tr><td><code id="pb-modcomp_+3A_cl">cl</code></td>
<td>
<p>A vector identifying a cluster; used for calculating the
reference distribution using several cores. See examples below.</p>
</td></tr>
<tr><td><code id="pb-modcomp_+3A_details">details</code></td>
<td>
<p>The amount of output produced. Mainly relevant for
debugging purposes.</p>
</td></tr>
<tr><td><code id="pb-modcomp_+3A_h">h</code></td>
<td>
<p>For sequential computing for bootstrap p-values: The
number of extreme cases needed to generate before the sampling
process stops.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model <code>object</code> must be fitted with maximum likelihood
(i.e. with <code>REML=FALSE</code>). If the object is fitted with
restricted maximum likelihood (i.e. with <code>REML=TRUE</code>) then
the model is refitted with <code>REML=FALSE</code> before the
p-values are calculated. Put differently, the user needs not
worry about this issue.
</p>
<p>Under the fitted hypothesis (i.e. under the fitted small model) <code>nsim</code>
samples of the likelihood ratio test statistic (LRT) are generated.
</p>
<p>Then p-values are calculated as follows:
</p>
<p>LRT: Assuming that LRT has a chi-square distribution.
</p>
<p>PBtest: The fraction of simulated LRT-values that are larger or equal to the
observed LRT value.
</p>
<p>Bartlett: A Bartlett correction is of LRT is calculated from the mean of the
simulated LRT-values
</p>
<p>Gamma: The reference distribution of LRT is assumed to be a gamma
distribution with mean and variance determined as the sample mean and sample
variance of the simulated LRT-values.
</p>
<p>F: The LRT divided by the number of degrees of freedom is assumed to be
F-distributed, where the denominator degrees of freedom are determined by
matching the first moment of the reference distribution.
</p>


<h3>Note</h3>

<p>It can happen that some values of the LRT statistic in the
reference distribution are negative. When this happens one will
see that the number of used samples (those where the LRT is
positive) are reported (this number is smaller than the
requested number of samples).
</p>
<p>In theory one can not have a negative value of the LRT statistic but in
practice on can: We speculate that the reason is as follows: We simulate data
under the small model and fit both the small and the large model to the
simulated data. Therefore the large model represents - by definition - an
over fit; the model has superfluous parameters in it. Therefore the fit of the
two models will for some simulated datasets be very similar resulting in
similar values of the log-likelihood. There is no guarantee that the the
log-likelihood for the large model in practice always will be larger than for
the small (convergence problems and other numerical issues can play a role
here).
</p>
<p>To look further into the problem, one can use the <code>PBrefdist()</code> function
for simulating the reference distribution (this reference distribution can be
provided as input to <code>PBmodcomp()</code>). Inspection sometimes reveals that
while many values are negative, they are numerically very small. In this case
one may try to replace the negative values by a small positive value and then
invoke <code>PBmodcomp()</code> to get some idea about how strong influence there
is on the resulting p-values. (The p-values get smaller this way compared to
the case when only the originally positive values are used).
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KRmodcomp">KRmodcomp</a></code>, <code><a href="#topic+PBrefdist">PBrefdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(beets, package="pbkrtest")
head(beets)

NSIM &lt;- 50 ## Simulations in parametric bootstrap

## Linear mixed effects model:
sug   &lt;- lmer(sugpct ~ block + sow + harvest + (1|block:harvest),
              data=beets, REML=FALSE)
sug.h &lt;- update(sug, .~. -harvest)
sug.s &lt;- update(sug, .~. -sow)

anova(sug, sug.h)
PBmodcomp(sug, sug.h, nsim=NSIM, cl=1)

anova(sug, sug.s)
PBmodcomp(sug, sug.s, nsim=NSIM, cl=1)

## Linear normal model:
sug &lt;- lm(sugpct ~ block + sow + harvest, data=beets)
sug.h &lt;- update(sug, .~. -harvest)
sug.s &lt;- update(sug, .~. -sow)

anova(sug, sug.h)
PBmodcomp(sug, sug.h, nsim=NSIM, cl=1)

anova(sug, sug.s)
PBmodcomp(sug, sug.s, nsim=NSIM, cl=1)

## Generalized linear model
counts    &lt;- c(18, 17, 15, 20, 10, 20, 25, 13, 12)
outcome   &lt;- gl(3, 1, 9)
treatment &lt;- gl(3, 3)
d.AD      &lt;- data.frame(treatment, outcome, counts)
head(d.AD)
glm.D93   &lt;- glm(counts ~ outcome + treatment, family = poisson())
glm.D93.o &lt;- update(glm.D93, .~. -outcome)
glm.D93.t &lt;- update(glm.D93, .~. -treatment)

anova(glm.D93, glm.D93.o, test="Chisq")
PBmodcomp(glm.D93, glm.D93.o, nsim=NSIM, cl=1)

anova(glm.D93, glm.D93.t, test="Chisq")
PBmodcomp(glm.D93, glm.D93.t, nsim=NSIM, cl=1)

## Generalized linear mixed model (it takes a while to fit these)

## Not run: 
(gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
              data = cbpp, family = binomial))
(gm2 &lt;- update(gm1, .~.-period))
anova(gm1, gm2)
PBmodcomp(gm1, gm2)

## End(Not run)


## Not run: 
(fmLarge &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
## removing Days
(fmSmall &lt;- lmer(Reaction ~ 1 + (Days|Subject), sleepstudy))
anova(fmLarge, fmSmall)
PBmodcomp(fmLarge, fmSmall, cl=1)

## The same test using a restriction matrix
L &lt;- cbind(0,1)
PBmodcomp(fmLarge, L, cl=1)

## Vanilla
PBmodcomp(beet0, beet_no.harv, nsim=NSIM, cl=1)

## Simulate reference distribution separately:
refdist &lt;- PBrefdist(beet0, beet_no.harv, nsim=1000)
PBmodcomp(beet0, beet_no.harv, ref=refdist, cl=1)

## Do computations with multiple processors:
## Number of cores:
(nc &lt;- detectCores())
## Create clusters
cl &lt;- makeCluster(rep("localhost", nc))

## Then do:
PBmodcomp(beet0, beet_no.harv, cl=cl)

## Or in two steps:
refdist &lt;- PBrefdist(beet0, beet_no.harv, nsim=NSIM, cl=cl)
PBmodcomp(beet0, beet_no.harv, ref=refdist)

## It is recommended to stop the clusters before quitting R:
stopCluster(cl)

## End(Not run)

## Linear and generalized linear models:

m11 &lt;- lm(dist ~ speed + I(speed^2), data=cars)
m10 &lt;- update(m11, ~.-I(speed^2))
anova(m11, m10)

PBmodcomp(m11, m10, cl=1, nsim=NSIM)
PBmodcomp(m11, ~.-I(speed^2), cl=1, nsim=NSIM)
PBmodcomp(m11, c(0, 0, 1), cl=1, nsim=NSIM)

m21 &lt;- glm(dist ~ speed + I(speed^2), family=Gamma("identity"), data=cars)
m20 &lt;- update(m21, ~.-I(speed^2))
anova(m21, m20, test="Chisq")

PBmodcomp(m21, m20, cl=1, nsim=NSIM)
PBmodcomp(m21, ~.-I(speed^2), cl=1, nsim=NSIM)
PBmodcomp(m21, c(0, 0, 1), cl=1, nsim=NSIM)

</code></pre>

<hr>
<h2 id='pb-refdist'>Calculate reference distribution using parametric bootstrap</h2><span id='topic+pb-refdist'></span><span id='topic+PBrefdist'></span><span id='topic+PBrefdist.merMod'></span><span id='topic+PBrefdist.lm'></span>

<h3>Description</h3>

<p>Calculate reference distribution of likelihood ratio statistic
in mixed effects models using parametric bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PBrefdist(
  largeModel,
  smallModel,
  nsim = 1000,
  seed = NULL,
  cl = NULL,
  details = 0
)

## S3 method for class 'lm'
PBrefdist(
  largeModel,
  smallModel,
  nsim = 1000,
  seed = NULL,
  cl = NULL,
  details = 0
)

## S3 method for class 'merMod'
PBrefdist(
  largeModel,
  smallModel,
  nsim = 1000,
  seed = NULL,
  cl = NULL,
  details = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pb-refdist_+3A_largemodel">largeModel</code></td>
<td>
<p>A linear mixed effects model as fitted with the
<code>lmer()</code> function in the <span class="pkg">lme4</span> package. This model muse be
larger than <code>smallModel</code> (see below).</p>
</td></tr>
<tr><td><code id="pb-refdist_+3A_smallmodel">smallModel</code></td>
<td>
<p>A linear mixed effects model as fitted with the
<code>lmer()</code> function in the <span class="pkg">lme4</span> package. This model muse be
smaller than <code>largeModel</code> (see above).</p>
</td></tr>
<tr><td><code id="pb-refdist_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to form the reference distribution.</p>
</td></tr>
<tr><td><code id="pb-refdist_+3A_seed">seed</code></td>
<td>
<p>Seed for the random number generation.</p>
</td></tr>
<tr><td><code id="pb-refdist_+3A_cl">cl</code></td>
<td>
<p>Used for controlling parallel computations. See sections
'details' and 'examples' below.</p>
</td></tr>
<tr><td><code id="pb-refdist_+3A_details">details</code></td>
<td>
<p>The amount of output produced. Mainly relevant for debugging
purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model <code>object</code> must be fitted with maximum likelihood
(i.e. with <code>REML=FALSE</code>). If the object is fitted with restricted
maximum likelihood (i.e. with <code>REML=TRUE</code>) then the model is
refitted with <code>REML=FALSE</code> before the p-values are calculated. Put
differently, the user needs not worry about this issue.
</p>
<div class="sourceCode"><pre>The argument 'cl' (originally short for 'cluster') is used for
controlling parallel computations. 'cl' can be NULL (default),
positive integer or a list of clusters.
</pre></div>
<p>Special care must be taken
on Windows platforms (described below) but the general picture
is this:
</p>
<div class="sourceCode"><pre>The recommended way of controlling cl is to specify the
component \code{pbcl} in options() with
e.g. \code{options("pbcl"=4)}.

If cl is NULL, the function will look at if the pbcl has been set
in the options list with \code{getOption("pbcl")}

If cl=N then N cores will be used in the computations. If cl is
NULL then the function will look for
</pre></div>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PBmodcomp">PBmodcomp</a></code>, <code><a href="#topic+KRmodcomp">KRmodcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(beets)
head(beets)
beet0 &lt;- lmer(sugpct ~ block + sow + harvest + (1|block:harvest), data=beets, REML=FALSE)
beet_no.harv &lt;- update(beet0, . ~ . -harvest)
rd &lt;- PBrefdist(beet0, beet_no.harv, nsim=20, cl=1)
rd
## Not run: 
## Note: Many more simulations must be made in practice.

# Computations can be made in parallel using several processors:

# 1: On OSs that fork processes (that is, not on windows):
# --------------------------------------------------------

if (Sys.info()["sysname"] != "Windows"){
  N &lt;- 2 ## Or N &lt;- parallel::detectCores()

# N cores used in all calls to function in a session
  options("mc.cores"=N)
  rd &lt;- PBrefdist(beet0, beet_no.harv, nsim=20)

# N cores used just in one specific call (when cl is set,
# options("mc.cores") is ignored):
  rd &lt;- PBrefdist(beet0, beet_no.harv, nsim=20, cl=N)
}

# In fact, on Windows, the approach above also work but only when setting the
# number of cores to 1 (so there is to parallel computing)

# In all calls:
# options("mc.cores"=1)
# rd &lt;- PBrefdist(beet0, beet_no.harv, nsim=20)
# Just once
# rd &lt;- PBrefdist(beet0, beet_no.harv, nsim=20, cl=1)

# 2. On all platforms (also on Windows) one can do
# ------------------------------------------------
library(parallel)
N &lt;- 2 ## Or N  &lt;- detectCores()
clus &lt;- makeCluster(rep("localhost", N))

# In all calls in a session
options("pb.cl"=clus)
rd &lt;- PBrefdist(beet0, beet_no.harv, nsim=20)

# Just once:
rd &lt;- PBrefdist(beet0, beet_no.harv, nsim=20, cl=clus)
stopCluster(clus)

## End(Not run)
</code></pre>

<hr>
<h2 id='sat-modcomp'>F-test and degrees of freedom based on Satterthwaite approximation</h2><span id='topic+sat-modcomp'></span><span id='topic+SATmodcomp'></span><span id='topic+SATmodcomp.lmerMod'></span>

<h3>Description</h3>

<p>An approximate F-test based on the Satterthwaite approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SATmodcomp(
  largeModel,
  smallModel,
  details = 0,
  eps = sqrt(.Machine$double.eps)
)

## S3 method for class 'lmerMod'
SATmodcomp(
  largeModel,
  smallModel,
  details = 0,
  eps = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sat-modcomp_+3A_largemodel">largeModel</code></td>
<td>
<p>An <code>lmerMod</code> model.</p>
</td></tr>
<tr><td><code id="sat-modcomp_+3A_smallmodel">smallModel</code></td>
<td>
<p>An <code>lmerMod</code> model, a restriction matrix or
a model formula. See example section.</p>
</td></tr>
<tr><td><code id="sat-modcomp_+3A_details">details</code></td>
<td>
<p>If larger than 0 some timing details are printed.</p>
</td></tr>
<tr><td><code id="sat-modcomp_+3A_eps">eps</code></td>
<td>
<p>A small number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notice: It cannot be guaranteed that the results agree with other
implementations of the Satterthwaite approach!
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getKR">getKR</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>, <code><a href="#topic+vcovAdj">vcovAdj</a></code>,
<code><a href="#topic+PBmodcomp">PBmodcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
L1 &lt;- cbind(0,1)
SATmodcomp(fm1, L1)

(fm2 &lt;- lmer(Reaction ~ Days + I(Days^2) + (Days|Subject), sleepstudy))

## Test for no effect of Days. There are three ways of using the function:

## 1) Define 2-df contrast - since L has 2 (linearly independent) rows
## the F-test is on 2 (numerator) df:
L2 &lt;- rbind(c(0, 1, 0), c(0, 0, 1))
SATmodcomp(fm2, L2)

## 2) Use two model objects 
fm3 &lt;- update(fm2, ~. - Days - I(Days^2))
SATmodcomp(fm2, fm3)

## 3) Specify restriction as formula
SATmodcomp(fm2, ~. - Days - I(Days^2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
