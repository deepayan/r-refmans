<!DOCTYPE html><html lang="en"><head><title>Help for package GECal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GECal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#estimate'><p>Performing statistical inference after calibration</p></a></li>
<li><a href='#g'><p>Debiasing covariate for GECalib</p></a></li>
<li><a href='#GEcalib'><p>Generalized Entropy Calibration</p></a></li>
<li><a href='#IAdata'><p>Synthetic pesticides data in Iowa</p></a></li>
<li><a href='#IApimat'><p>A matrix used for variance estimation in IAdata</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Entropy Calibration</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Generalized Entropy Calibration produces calibration weights 
    using generalized entropy as the objective function for optimization. 
    This approach, as implemented in the 'GECal' package, is based on 
    Kwon, Kim, and Qiu (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2404.01076">doi:10.48550/arXiv.2404.01076</a>&gt;. Unlike 
    traditional methods, 'GECal' incorporates design weights into the 
    constraints to maintain design consistency, rather than including 
    them in the objective function itself.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yonghyun-K/GECal">https://github.com/yonghyun-K/GECal</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yonghyun-K/GECal/issues">https://github.com/yonghyun-K/GECal/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>nleqslv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sampling</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-25 13:34:43 UTC; ghkfk</td>
</tr>
<tr>
<td>Author:</td>
<td>Yonghyun Kwon <a href="https://orcid.org/0000-0001-9923-6790"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jae Kwang Kim <a href="https://orcid.org/0000-0002-0246-6029"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Yumou Qiu <a href="https://orcid.org/0000-0003-4846-1263"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yonghyun Kwon &lt;yhkwon@kma.ac.kr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-25 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='estimate'>Performing statistical inference after calibration</h2><span id='topic+estimate'></span>

<h3>Description</h3>

<p><code>estimate</code> performs statistical inference after calibration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(formula, data = NULL, calibration, pimat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; specifying the calibration model.</p>
</td></tr>
<tr><td><code id="estimate_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the model (specified by <code>formula</code>).</p>
</td></tr>
<tr><td><code id="estimate_+3A_calibration">calibration</code></td>
<td>
<p>An object of class &quot;calibration&quot;, generated by <code>GECalib</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_pimat">pimat</code></td>
<td>
<p>An optional matrix contatining the joint inclusion probability matrix used for variance estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>estimation</code> including the point estimates and its standard error.
</p>


<h3>References</h3>

<p>Kwon, Y., Kim, J., &amp; Qiu, Y. (2024). Debiased calibration estimation using generalized entropy in survey sampling.
Arxiv preprint &lt;https://arxiv.org/abs/2404.01076&gt;
</p>
<p>Deville, J. C., and Särndal, C. E. (1992). Calibration estimators in survey sampling.
Journal of the American statistical Association, 87(418), 376-382.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
N = 10000
x = data.frame(x1 = rnorm(N, 2, 1), x2= runif(N, 0, 4))
pi = pt((-x[,1] / 2 - x[,2] / 2), 3);
pi = ifelse(pi &gt;.7, .7, pi)

delta = rbinom(N, 1, pi)
Index_S = (delta == 1)
pi_S = pi[Index_S]; d_S = 1 / pi_S
x_S = x[Index_S,,drop = FALSE]
# pimat = diag(d_S^2 - d_S) / N^2 # 1 / pi_i * (1 - 1 / pi_i)

e = rnorm(N, 0, 1)
y = x[,1] + x[,2] + e;
y_S = y[Index_S] # plot(x_S, y_S)

calibration0 &lt;- GECal::GEcalib(~ 1, dweight = d_S, data = x_S,
                               const = N,
                               entropy = "SL", method = "DS")
GECal::estimate(y_S ~ 1, calibration = calibration0)$estimate # Hajek estimator
# sum(y_S * d_S) * N / sum(d_S)

calibration &lt;- GECal::GEcalib(~ 0, dweight = d_S, data = x_S,
const = numeric(0),
entropy = "SL", method = "DS")
GECal::estimate(y_S ~ 1, calibration = calibration)$estimate # HT estimator

calibration1 &lt;- GECal::GEcalib(~ ., dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x)),
                               entropy = "ET", method = "DS")
GECal::estimate(y_S ~ 1, calibration = calibration1)$estimate

calibration2 &lt;- GECal::GEcalib(~ ., dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x)),
                               entropy = "ET", method = "GEC0")
GECal::estimate(y_S ~ 1, calibration = calibration2)$estimate

calibration3 &lt;- GECal::GEcalib(~ . + g(d_S), dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x, log(1 / pi))),
                               entropy = "ET", method = "GEC")
GECal::estimate(y_S ~ 1, calibration = calibration3)$estimate

calibration4 &lt;- GECal::GEcalib(~ . + g(d_S), dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x, NA)),
                               entropy = "ET", method = "GEC")
GECal::estimate(y_S ~ 1, calibration = calibration4)$estimate

calibration5 &lt;- GECal::GEcalib(~ . + g(d_S), dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x, NA)),
                               entropy = "ET", method = "GEC", K_alpha = "log")
GECal::estimate(y_S ~ 1, calibration = calibration5)$estimate

</code></pre>

<hr>
<h2 id='g'>Debiasing covariate for GECalib</h2><span id='topic+g'></span>

<h3>Description</h3>

<p>It returns the debiasing covariate, which is equivalent to the first order derivatie of
the generalized entropy <code class="reqn">G</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g(x, entropy = NULL, del = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g_+3A_x">x</code></td>
<td>
<p>A vector of design weights</p>
</td></tr>
<tr><td><code id="g_+3A_entropy">entropy</code></td>
<td>
<p>An optional data frame containing the variables in the model (specified by <code>formula</code>).</p>
</td></tr>
<tr><td><code id="g_+3A_del">del</code></td>
<td>
<p>The optional vector for threshold (<code class="reqn">\delta</code>) when <code>entropy == "PH"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of debiasing covariate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
N = 10000
x = data.frame(x1 = rnorm(N, 2, 1), x2= runif(N, 0, 4))
pi = pt((-x[,1] / 2 - x[,2] / 2), 3);
pi = ifelse(pi &gt;.7, .7, pi)

g_EL &lt;- g(1 / pi, entropy = 1)
g_ET &lt;- g(1 / pi, entropy = 0)
g_EL &lt;- g(1 / pi, entropy = -1)

</code></pre>

<hr>
<h2 id='GEcalib'>Generalized Entropy Calibration</h2><span id='topic+GEcalib'></span>

<h3>Description</h3>

<p><code>GEcalib</code> computes the calibration weights.
Generalized entropy calibration weights maximize the generalized entropy:
</p>
<p style="text-align: center;"><code class="reqn">H(\bm{\omega}) = -\sum_{i \in A} G(\omega_i),</code>
</p>

<p>subject to the calibration constraints <code class="reqn">\sum_{i \in A} \omega_i \bm{z}_i = \sum_{i \in U} \bm{z}_i</code>,
where <code class="reqn">A</code> denotes the sample index, and <code class="reqn">U</code> represents the population index. 
The auxiliary variables, whose population totals are known, are defined as <code class="reqn">\bm{z}_i^T = (\bm{x}_i^T, g(d_i))</code>, 
where <code class="reqn">g</code> is the first-order derivative of the gerenalized entropy <code class="reqn">G</code>, 
and <code class="reqn">d_i</code> is the design weight for each sampled unit <code class="reqn">i \in A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEcalib(
  formula,
  dweight,
  data = NULL,
  const,
  method = c("GEC", "GEC0", "DS"),
  entropy = c("SL", "EL", "ET", "CE", "HD", "PH"),
  weight.scale = 1,
  G.scale = 1,
  K_alpha = NULL,
  is.total = TRUE,
  del = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GEcalib_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; specifying the calibration model.</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_dweight">dweight</code></td>
<td>
<p>A vector of sampling weights.</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the model (specified by <code>formula</code>).</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_const">const</code></td>
<td>
<p>A vector used in the calibration constraint for population totals( or means).</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_method">method</code></td>
<td>
<p>The method to be used in calibration. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_entropy">entropy</code></td>
<td>
<p>The generalized entropy used in calibration, which can be either a numeric value or a string. 
If numeric, <code>entropy</code> represents the order of Renyi's entropy, where 
<code class="reqn">G(\omega) = r^{-1}(r+1)^{-1}\omega^{r+1}</code> if <code class="reqn">r \neq 0, -1</code>.
If a string, valid options include: 
&quot;SL&quot; (Squared-loss), &quot;EL&quot; (Empirical Likelihood), &quot;ET&quot; (Exponential Tilting), 
&quot;CE&quot; (Cross-Entropy), &quot;HD&quot; (Hellinger Distance), and &quot;PH&quot; (Pseudo-Huber). See &quot;Summary&quot; for details.</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_weight.scale">weight.scale</code></td>
<td>
<p>Positive scaling factor for the calibration weights <code class="reqn">\omega_i</code>. Asymptotics justify setting <code>weight.scale</code> 
to the finite population correction (<code class="reqn">fpc = n / N</code>).</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_g.scale">G.scale</code></td>
<td>
<p>Positive scaling factor for the generalized entropy function <code class="reqn">G</code>. Asymptotics justify setting 
<code>G.scale</code> to the variance of the error term in a linear super-population model.</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_k_alpha">K_alpha</code></td>
<td>
<p>The <code class="reqn">K</code> function used in joint optimization when the <code>const</code> of the debiasing covariate 
<code class="reqn">g(d_i)</code> is not available. <code>K_alpha</code> can be <code>NULL</code>, <code>"log"</code>, or custom functions. See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_is.total">is.total</code></td>
<td>
<p>Logical, <code>TRUE</code> if <code>sum(const[1])</code> equals the population size.</p>
</td></tr>
<tr><td><code id="GEcalib_+3A_del">del</code></td>
<td>
<p>The optional threshold (<code class="reqn">\delta</code>) used when Pseudo-Huber (PH) entropy is selected.
<code>del = quantile(dweight, 0.75)</code> if not specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>GEcal</code> object returns the calibration weights and necessary information for estimating population totals(or mean).
</p>
<p>The terms to the right of the ~ symbol in the <code>formula</code> argument define the calibration constraints.
When <code>method == "GEC"</code>, the debiasing covariate <code>g(dweight)</code> must be included in the <code>formula</code>.
If the population total(mean) of <code>g(dweight)</code> is unavailable, <code>const</code> that corresponds to <code>g(dweight)</code> can be set to <code>NA</code>.
In this case, <code>GECalib</code> performs joint optimization over
both the calibration weights <code class="reqn">\omega_i</code> and the missing value of <code>const</code>.
</p>
<p>The length of the <code>const</code> vector should match the number of columns in the <code>model.matrix</code> generated by <code>formula</code>.
Additionally, the condition number of the <code>model.matrix</code> must exceed <code>.Machine$double.eps</code> to ensure its invertibility.
</p>
<p>Both <code>weight.scale</code> and <code>G.scale</code> are positive scaling factors used for calibration.
Note that <code>weight.scale</code> is not supported when <code>method == "DS"</code>.
</p>
<p>Let <code class="reqn">q_i</code> be the scaling factor for the generalized entropy function <code class="reqn">G</code>, 
and <code class="reqn">\phi_i</code> be the scaling factor for the calibration weights <code class="reqn">\omega_i</code>.
</p>
<p>If <code>method == "GEC"</code>, <code>GEcalib</code> minimizes the negative entropy:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i \in A} q_iG(\phi_i\omega_i),</code>
</p>

<p>with respect to <code class="reqn">\bm \omega</code> subject to the calibration constraints <code class="reqn">\sum_{i \in A} \omega_i \bm{z}_i = \sum_{i \in U} \bm{z}_i</code>,
where <code class="reqn">\bm{z}_i^T = (\bm{x}_i^T, q_i \phi_i g(\phi_i d_i))</code>, <code class="reqn">A</code> denotes the sample index, and <code class="reqn">U</code> represents the population index. 
</p>
<p>If <code>method == "GEC"</code>, but an element of <code>const</code> corresponding to the debiasing covariate 
<code class="reqn">g(d_i)</code> is <code>NA</code>, <code>GEcalib</code> minimizes the negative adjusted entropy:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i \in A} q_iG(\phi_i\omega_i) - K(\alpha),</code>
</p>

<p>with respect to <code class="reqn">\bm \omega</code> and <code class="reqn">\alpha</code> subject to the calibration constraints 
<code class="reqn">\sum_{i \in A} \omega_i (\bm{x}_i^T, q_i \phi_i g(\phi_i d_i)) = \left(\sum_{i \in U} \bm x_i, \alpha \right)</code>,
where the solution <code class="reqn">\hat \alpha</code> is an estimate of population total for <code class="reqn">g(d_i)</code>.
Examples of <code class="reqn">K(\alpha)</code> includes <code class="reqn">K(\alpha) = \alpha</code> when <code>K_alpha == NULL</code>, and 
</p>
<p style="text-align: center;"><code class="reqn">K(\alpha) = \left(\sum_{i \in A} d_i g(d_i) + N \right) 
\log \left| \frac{1}{N}\sum_{i \in A}q_i \phi_i \omega_i g(\phi_i \omega_i) + 1  \right|</code>
</p>

<p>when <code>K_alpha == "log"</code>.
</p>
<p>If <code>method == "GEC0"</code>, <code>GEcalib</code> minimizes the negative adjusted entropy:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i \in A} q_iG(\phi_i\omega_i) - q_i\phi_i\omega_i g(\phi_i \omega_i)</code>
</p>

<p>with respect to <code class="reqn">\bm \omega</code> subject to the calibration constraints <code class="reqn">\sum_{i \in A} \omega_i \bm{x}_i = \sum_{i \in U} \bm{x}_i</code>.
</p>
<p>If <code>method == "DS"</code>, <code>GEcalib</code> minimizes the divergence between <code class="reqn">\bm \omega</code> and <code class="reqn">\bm d</code>:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i \in A} q_id_i \tilde G(\omega_i / d_i)</code>
</p>

<p>with respect to <code class="reqn">\bm \omega</code> subject to the calibration constraints <code class="reqn">\sum_{i \in A} \omega_i \bm{x}_i = \sum_{i \in U} \bm{x}_i</code>. 
When <code>method == "DS"</code>, <code>weight.scale</code>, the scaling factor for the calibration weights <code class="reqn">\phi_i</code>, is not applicable.
</p>
<p>Examples of <code class="reqn">G</code> and <code class="reqn">\tilde G</code> are given in &quot;Summary&quot;.
</p>


<h3>Value</h3>

<p>A list of class <code>calibration</code> including the calibration weights 
and data needed for estimation.
</p>


<h3>Summary</h3>

<p>The table below provides a comparison between the <strong>GEC</strong> and <strong>DS</strong> methods.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>GEC</strong> </td><td style="text-align: center;"> <strong>DS</strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;"> 
<code class="reqn">\min_{\bm \omega} \left(-H(\bm \omega)\right) = \sum_{i \in A}G(\omega_i) \quad</code> </td><td style="text-align: center;"> 
<code class="reqn">\quad \min_{\bm \omega} D(\bm \omega, \bm d) = \sum_{i \in A}d_i \tilde G(\omega_i / d_i)</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;"> 
s.t. <code class="reqn">\sum_{i \in A} \omega_i (\bm{x}_i^T, g(d_i)) = \sum_{i \in U} (\bm{x}_i^T, g(d_i))</code> </td><td style="text-align: center;">
s.t. <code class="reqn">\sum_{i \in A} \omega_i \bm{x}_i^T = \sum_{i \in U} \bm{x}_i^T</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;"> 
<code class="reqn">G(\omega) = \begin{cases} \frac{1}{r(r+1)} \omega^{r+1} &amp; r \neq 0, -1\\ 
\omega \log \omega - \omega &amp; r = 0\text{(ET)} \\ 
-\log \omega &amp; r = -1\text{(EL)} \end{cases}</code> 
</td><td style="text-align: center;"> <code class="reqn">\tilde G(\omega) = \begin{cases} \frac{1}{r(r+1)} \left(\omega^{r+1} - (r+1)\omega + r\right) &amp; r \neq 0, -1 \\
\omega \log \omega - \omega + 1 &amp; r = 0\text{(ET)} \\
-\log \omega + \omega - 1 &amp; r = -1\text{(EL)} \end{cases}</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>If <code>method == "GEC"</code>, further examples include
</p>
<p style="text-align: center;"><code class="reqn">G(\omega) = (\omega - 1) \log (\omega-1) - \omega \log \omega</code>
</p>

<p>when <code>entropy == "CE"</code>, and
</p>
<p style="text-align: center;"><code class="reqn">G(\omega) = \delta^2 \left(1 + (\omega / \delta)^2 \right)^{1/2}</code>
</p>

<p>for a threshold <code class="reqn">\delta</code> when <code>entropy == "PH"</code>.
</p>


<h3>Author(s)</h3>

<p>Yonghyun Kwon
</p>


<h3>References</h3>

<p>Kwon, Y., Kim, J., &amp; Qiu, Y. (2024). Debiased calibration estimation using generalized entropy in survey sampling.
Arxiv preprint &lt;<a href="https://arxiv.org/abs/2404.01076">https://arxiv.org/abs/2404.01076</a>&gt;
</p>
<p>Deville, J. C., and Särndal, C. E. (1992). Calibration estimators in survey sampling.
Journal of the American statistical Association, 87(418), 376-382.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
N = 10000
x = data.frame(x1 = rnorm(N, 2, 1), x2= runif(N, 0, 4))
pi = pt((-x[,1] / 2 - x[,2] / 2), 3);
pi = ifelse(pi &gt;.7, .7, pi)

delta = rbinom(N, 1, pi)
Index_S = (delta == 1)
pi_S = pi[Index_S]; d_S = 1 / pi_S
x_S = x[Index_S,]

# Deville &amp; Sarndal(1992)'s calibration using divergence
w1 &lt;- GECal::GEcalib(~ ., dweight = d_S, data = x_S,
                    const = colSums(cbind(1, x)),
                    entropy = "ET", method = "DS")$w

# Generalized entropy calibration without debiasing covariate 
w2 &lt;- GECal::GEcalib(~ ., dweight = d_S, data = x_S,
                    const = colSums(cbind(1, x)),
                    entropy = "ET", method = "GEC0")$w
all.equal(w1, w2)

# Generalized entropy calibration with debiasing covariate
w3 &lt;- GECal::GEcalib(~ . + g(d_S), dweight = d_S, data = x_S,
                    const = colSums(cbind(1, x, log(1 / pi))),
                    entropy = "ET", method = "GEC")$w
                    
# Generalized entropy calibration with debiasing covariate
# when its population total is unknown
w4 &lt;- GECal::GEcalib(~ . + g(d_S), dweight = d_S, data = x_S,
                    const = colSums(cbind(1, x, NA)),
                    entropy = "ET", method = "GEC")$w
all.equal(w1, w4)

w5 &lt;- GECal::GEcalib(~ . + g(d_S), dweight = d_S, data = x_S,
const = colSums(cbind(1, x, NA)),
entropy = "ET", method = "GEC", K_alpha = "log")$w 
</code></pre>

<hr>
<h2 id='IAdata'>Synthetic pesticides data in Iowa</h2><span id='topic+IAdata'></span>

<h3>Description</h3>

<p>A synthetic proprietary pesticide usage survey data in Iowa CRD(Crop Reporting District) collected from GfK Kynetec in 2020.
</p>


<h3>Format</h3>

<p>A data frame with 1197 rows on the following 32 variables:</p>

<dl>
<dt>Corn10, Corn20, Corn30, Corn40, Corn50, Corn60, Corn70</dt><dd><p>Haversted acres of corn in each CRD</p>
</dd>
<dt>Soybean10, Soybean20, Soybean30, Soybean40, Soybean50, Soybean60,
Soybean70, Soybean90</dt><dd><p>Haversted acres of soybean in each CRD</p>
</dd>
<dt>Alfalfa10, Alfalfa30, Alfalfa40, Alfalfa50, 
Alfalfa70, Alfalfa80</dt><dd><p>Haversted acres of alfalfa in each CRD</p>
</dd>
<dt>Pasture10, Pasture20, Pasture30, Pasture40,
Pasture50, Pasture60, Pasture70, Pasture80,
Pasture90</dt><dd><p>Acres of pasture in each CRD</p>
</dd>
<dt>d</dt><dd><p>Design weights, or inverse first-order inclusion probabilities of the sample</p>
</dd>
<dt>y</dt><dd><p>Pesticide usage($) which is of an interest.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The original data is contaminated by adding noise and creating missing values and imputation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IAdata)
data(IApimat)

total &lt;- c(
Corn10 = 2093000, Corn20 = 1993600, Corn30 = 1803200, Corn40 = 2084600, 
Corn50 = 2056600, Corn60 = 1429400, Corn70 = 2539600,
Soybean10 = 1472980, Soybean20 = 1192860, Soybean30 = 721920, 
Soybean40 = 1477680, Soybean50 = 1353600, Soybean60 = 918380,
Soybean70 = 1485200, Soybean90 = 777380, Alfalfa10 = 60590, 
Alfalfa30 = 154395, Alfalfa40 = 57816, Alfalfa50 = 150453,
Alfalfa70 = 66065, Alfalfa80 = 240681, Pasture10 = 141947, 
Pasture20 = 61476, Pasture30 = 188310, Pasture40 = 213635,
Pasture50 = 160737, Pasture60 = 222214, Pasture70 = 250807, 
Pasture80 = 570647, Pasture90 = 232630
)

calibration &lt;- GECal::GEcalib(~ 0, dweight = d, data = IAdata,
                              const = numeric(0),
                              entropy = "EL", method = "DS")
GECal::estimate(y ~ 1, data = IAdata, calibration = calibration, pimat = IApimat)$estimate


calibration &lt;- GECal::GEcalib(~ 0 + . -y -d, dweight = d, data = IAdata,
                              const = total,
                              entropy = "SL", method = "DS")
GECal::estimate(y ~ 1, data = IAdata, calibration = calibration, pimat = IApimat)$estimate

calibration &lt;- GECal::GEcalib(~ 0 + . -y -d, dweight = d, data = IAdata,
                              const = c(total),
                              entropy = "ET", method = "DS")
GECal::estimate(y ~ 1, data = IAdata, calibration = calibration, pimat = IApimat)$estimate


calibration &lt;- GECal::GEcalib(~ 0 + . -y -d + g(d), dweight = d, data = IAdata,
                              const = c(total, NA),
                              entropy = "HD", method = "GEC")
GECal::estimate(y ~ 1, data = IAdata, calibration = calibration, pimat = IApimat)$estimate

calibration &lt;- GECal::GEcalib(~ 0 + . -y -d, dweight = d, data = IAdata,
                              const = total,
                              entropy = "HD", method = "GEC0")
GECal::estimate(y ~ 1, data = IAdata, calibration = calibration, pimat = IApimat)$estimate
</code></pre>

<hr>
<h2 id='IApimat'>A matrix used for variance estimation in IAdata</h2><span id='topic+IApimat'></span>

<h3>Description</h3>

<p>The matrix that is used for variance estimation in IAdata. The sample is collected from a straitified random sampling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IApimat) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
