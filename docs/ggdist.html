<!DOCTYPE html><html><head><title>Help for package ggdist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggdist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggdist-package'><p>Visualizations of Distributions and Uncertainty</p></a></li>
<li><a href='#AbstractStatSlabinterval'><p>Base ggproto classes for ggdist</p></a></li>
<li><a href='#align'><p>Break (bin) alignment methods</p></a></li>
<li><a href='#auto_partial'><p>Automatic partial function application in ggdist</p></a></li>
<li><a href='#bandwidth'><p>Bandwidth estimators</p></a></li>
<li><a href='#bin_dots'><p>Bin data values using a dotplot algorithm</p></a></li>
<li><a href='#blur'><p>Blur functions for blurry dot plots</p></a></li>
<li><a href='#bounder_cdf'><p>Estimate bounds of a distribution using the CDF of its order statistics</p></a></li>
<li><a href='#bounder_cooke'><p>Estimate bounds of a distribution using Cooke's method</p></a></li>
<li><a href='#bounder_range'><p>Estimate bounds of a distribution using the range of the sample</p></a></li>
<li><a href='#breaks'><p>Break (bin) selection algorithms for histograms</p></a></li>
<li><a href='#curve_interval'><p>Curvewise point and interval summaries for tidy data frames of draws from distributions</p></a></li>
<li><a href='#cut_cdf_qi'><p>Categorize values from a CDF into quantile intervals</p></a></li>
<li><a href='#density_bounded'><p>Bounded density estimator using the reflection method</p></a></li>
<li><a href='#density_histogram'><p>Histogram density estimator</p></a></li>
<li><a href='#density_unbounded'><p>Unbounded density estimator</p></a></li>
<li><a href='#find_dotplot_binwidth'><p>Dynamically select a good bin width for a dotplot</p></a></li>
<li><a href='#geom_blur_dots'><p>Blurry dot plot (geom)</p></a></li>
<li><a href='#geom_dots'><p>Dot plot (shortcut geom)</p></a></li>
<li><a href='#geom_dotsinterval'><p>Automatic dotplot + point + interval meta-geom</p></a></li>
<li><a href='#geom_interval'><p>Multiple-interval plot (shortcut geom)</p></a></li>
<li><a href='#geom_lineribbon'><p>Line + multiple-ribbon plots (ggplot geom)</p></a></li>
<li><a href='#geom_pointinterval'><p>Point + multiple-interval plot (shortcut geom)</p></a></li>
<li><a href='#geom_slab'><p>Slab (ridge) plot (shortcut geom)</p></a></li>
<li><a href='#geom_slabinterval'><p>Slab + point + interval meta-geom</p></a></li>
<li><a href='#geom_spike'><p>Spike plot (ggplot2 geom)</p></a></li>
<li><a href='#geom_swarm'><p>Beeswarm plot (shortcut geom)</p></a></li>
<li><a href='#geom_weave'><p>Dot-weave plot (shortcut geom)</p></a></li>
<li><a href='#ggdist-deprecated'><p>Deprecated functions and arguments in ggdist</p></a></li>
<li><a href='#guide_rampbar'><p>Continuous guide for colour ramp scales (ggplot2 guide)</p></a></li>
<li><a href='#lkjcorr_marginal'><p>Marginal distribution of a single correlation from an LKJ distribution</p></a></li>
<li><a href='#marginalize_lkjcorr'><p>Turn spec for LKJ distribution into spec for marginal LKJ distribution</p></a></li>
<li><a href='#parse_dist'><p>Parse distribution specifications into columns of a data frame</p></a></li>
<li><a href='#partial_colour_ramp'><p>Partial colour ramp (datatype)</p></a></li>
<li><a href='#point_interval'><p>Point and interval summaries for tidy data frames of draws from distributions</p></a></li>
<li><a href='#position_dodgejust'><p>Dodge overlapping objects side-to-side, preserving justification</p></a></li>
<li><a href='#Pr_'><p>Probability expressions in ggdist aesthetics</p></a></li>
<li><a href='#ramp_colours'><p>Apply partial colour ramps</p></a></li>
<li><a href='#RankCorr'><p>Thinned subset of posterior sample from a Bayesian analysis of perception of correlation.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#scale_colour_ramp'><p>Secondary color scale that ramps from another color (ggplot2 scale)</p></a></li>
<li><a href='#scale_side_mirrored'><p>Side scale for mirrored slabs (ggplot2 scale)</p></a></li>
<li><a href='#scale_thickness'><p>Slab thickness scale (ggplot2 scale)</p></a></li>
<li><a href='#smooth_density'><p>Smooth dot positions in a dotplot using a kernel density estimator (&quot;density dotplots&quot;)</p></a></li>
<li><a href='#smooth_discrete'><p>Smooth dot positions in a dotplot of discrete values (&quot;bar dotplots&quot;)</p></a></li>
<li><a href='#smooth_none'><p>Apply no smooth to a dotplot</p></a></li>
<li><a href='#stat_ccdfinterval'><p>CCDF bar plot (shortcut stat)</p></a></li>
<li><a href='#stat_cdfinterval'><p>CDF bar plot (shortcut stat)</p></a></li>
<li><a href='#stat_dots'><p>Dot plot (shortcut stat)</p></a></li>
<li><a href='#stat_dotsinterval'><p>Dots + point + interval plot (shortcut stat)</p></a></li>
<li><a href='#stat_eye'><p>Eye (violin + interval) plot (shortcut stat)</p></a></li>
<li><a href='#stat_gradientinterval'><p>Gradient + interval plot (shortcut stat)</p></a></li>
<li><a href='#stat_halfeye'><p>Half-eye (density + interval) plot (shortcut stat)</p></a></li>
<li><a href='#stat_histinterval'><p>Histogram + interval plot (shortcut stat)</p></a></li>
<li><a href='#stat_interval'><p>Multiple-interval plot (shortcut stat)</p></a></li>
<li><a href='#stat_lineribbon'><p>Line + multiple-ribbon plot (shortcut stat)</p></a></li>
<li><a href='#stat_mcse_dots'><p>Blurry MCSE dot plot (stat)</p></a></li>
<li><a href='#stat_pointinterval'><p>Point + multiple-interval plot (shortcut stat)</p></a></li>
<li><a href='#stat_ribbon'><p>Multiple-ribbon plot (shortcut stat)</p></a></li>
<li><a href='#stat_slab'><p>Slab (ridge) plot (shortcut stat)</p></a></li>
<li><a href='#stat_slabinterval'><p>Slab + interval plots for sample data and analytical distributions (ggplot stat)</p></a></li>
<li><a href='#stat_spike'><p>Spike plot (ggplot2 stat)</p></a></li>
<li><a href='#student_t'><p>Scaled and shifted Student's t distribution</p></a></li>
<li><a href='#sub-geometry-scales'><p>Sub-geometry scales for geom_slabinterval (ggplot2 scales)</p></a></li>
<li><a href='#subguide_axis'><p>Axis sub-guide for thickness scales</p></a></li>
<li><a href='#subguide_none'><p>Empty sub-guide for thickness scales</p></a></li>
<li><a href='#theme_ggdist'><p>Simple, light ggplot2 theme for ggdist and tidybayes</p></a></li>
<li><a href='#tidy-format-translators'><p>Translate between different tidy data frame formats for draws from distributions</p></a></li>
<li><a href='#weighted_ecdf'><p>Weighted empirical cumulative distribution function</p></a></li>
<li><a href='#weighted_quantile'><p>Weighted sample quantiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Visualizations of Distributions and Uncertainty</td>
</tr>
<tr>
<td>Version:</td>
<td>3.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Kay &lt;mjskay@northwestern.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides primitives for visualizing distributions using 'ggplot2' that are particularly tuned for
    visualizing uncertainty in either a frequentist or Bayesian mode. Both analytical distributions (such as 
    frequentist confidence distributions or Bayesian priors) and distributions represented as samples (such as 
    bootstrap distributions or Bayesian posterior samples) are easily visualized. Visualization primitives include
    but are not limited to: points with multiple uncertainty intervals, 
    eye plots (Spiegelhalter D., 1999) <a href="https://ideas.repec.org/a/bla/jorssa/v162y1999i1p45-58.html">https://ideas.repec.org/a/bla/jorssa/v162y1999i1p45-58.html</a>,
    density plots, gradient plots, dot plots (Wilkinson L., 1999) &lt;<a href="https://doi.org/10.1080%2F00031305.1999.10474474">doi:10.1080/00031305.1999.10474474</a>&gt;,
    quantile dot plots (Kay M., Kola T., Hullman J., Munson S., 2016) &lt;<a href="https://doi.org/10.1145%2F2858036.2858558">doi:10.1145/2858036.2858558</a>&gt;,
    complementary cumulative distribution function 
    barplots (Fernandes M., Walls L., Munson S., Hullman J., Kay M., 2018) &lt;<a href="https://doi.org/10.1145%2F3173574.3173718">doi:10.1145/3173574.3173718</a>&gt;,
    and fit curves with multiple uncertainty ribbons.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.5.0), rlang (&ge; 0.3.0), cli, scales, grid,
tibble, vctrs, withr, distributional (&ge; 0.3.2), numDeriv,
glue, quadprog, gtable, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tidyselect, dplyr (&ge; 1.0.0), fda, posterior, beeswarm (&ge;
0.4.0), rmarkdown, knitr, testthat (&ge; 3.0.0), vdiffr (&ge;
1.0.0), svglite (&ge; 2.1.0), fontquiver, sysfonts, showtext,
mvtnorm, covr, broom (&ge; 0.5.6), patchwork, tidyr (&ge; 1.0.0),
ragg, pkgdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mjskay/ggdist/issues/new">https://github.com/mjskay/ggdist/issues/new</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mjskay.github.io/ggdist/">https://mjskay.github.io/ggdist/</a>,
<a href="https://github.com/mjskay/ggdist/">https://github.com/mjskay/ggdist/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>"ggdist-package.R" "util.R" "compat.R" "rd.R" "RcppExports.R"
"abstract_geom.R" "abstract_stat.R"
"abstract_stat_slabinterval.R" "auto_partial.R"
"binning_methods.R" "bounder.R" "curve_interval.R"
"cut_cdf_qi.R" "data.R" "density.R" "distributions.R"
"draw_key_slabinterval.R" "geom.R" "geom_slabinterval.R"
"geom_dotsinterval.R" "geom_blur_dots.R" "geom_interval.R"
"geom_lineribbon.R" "geom_pointinterval.R" "geom_slab.R"
"geom_spike.R" "geom_swarm.R" "guide_rampbar.R"
"lkjcorr_marginal.R" "parse_dist.R" "partial_colour_ramp.R"
"point_interval.R" "position_dodgejust.R" "pr.R"
"rd_dotsinterval.R" "rd_slabinterval.R" "rd_spike.R"
"rd_lineribbon.R" "scale_colour_ramp.R" "scale_thickness.R"
"scale_side_mirrored.R" "scale_.R" "smooth.R" "stat.R"
"stat_slabinterval.R" "stat_dotsinterval.R" "stat_mcse_dots.R"
"stat_pointinterval.R" "stat_interval.R" "stat_lineribbon.R"
"stat_spike.R" "student_t.R" "subguide.R" "testthat.R"
"theme_ggdist.R" "tidy_format_translators.R" "weighted_ecdf.R"
"weighted_hist.R" "weighted_quantile.R" "deprecated.R"</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 17:12:50 UTC; matth</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Kay [aut, cre],
  Brenton M. Wiernik [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 05:30:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggdist-package'>Visualizations of Distributions and Uncertainty</h2><span id='topic+ggdist-package'></span><span id='topic+ggdist'></span>

<h3>Description</h3>

<p><code>ggdist</code> is an R package that aims to make it easy to integrate
popular Bayesian modeling methods into a tidy data + ggplot workflow.
</p>


<h3>Details</h3>

<p><code>ggdist</code> is an R package that provides a flexible set of <code>ggplot2</code> geoms and stats designed
especially for visualizing distributions and uncertainty. It is designed for both
frequentist and Bayesian uncertainty visualization, taking the view that uncertainty
visualization can be unified through the perspective of distribution visualization:
for frequentist models, one visualizes confidence distributions or bootstrap distributions
(see <code>vignette("freq-uncertainty-vis")</code>); for Bayesian models, one visualizes probability
distributions (see <code>vignette("tidybayes", package = "tidybayes")</code>).
</p>
<p>The <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> / <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> family (see <code>vignette("slabinterval")</code>) makes it
easy to visualize point summaries and intervals, eye plots, half-eye plots, ridge plots,
CCDF bar plots, gradient plots, histograms, and more.
</p>
<p>The <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> / <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code> family (see <code>vignette("dotsinterval")</code>) makes
it easy to visualize dot+interval plots, Wilkinson dotplots, beeswarm plots, and quantile dotplots.
</p>
<p>The <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> / <code><a href="#topic+stat_lineribbon">stat_lineribbon()</a></code> family (see <code>vignette("lineribbon")</code>)
makes it easy to visualize fit lines with an arbitrary number of uncertainty bands.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matthew Kay <a href="mailto:mjskay@northwestern.edu">mjskay@northwestern.edu</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Brenton M. Wiernik <a href="mailto:brenton@wiernik.org">brenton@wiernik.org</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mjskay.github.io/ggdist/">https://mjskay.github.io/ggdist/</a>
</p>
</li>
<li> <p><a href="https://github.com/mjskay/ggdist/">https://github.com/mjskay/ggdist/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mjskay/ggdist/issues/new">https://github.com/mjskay/ggdist/issues/new</a>
</p>
</li></ul>


<hr>
<h2 id='AbstractStatSlabinterval'>Base ggproto classes for ggdist</h2><span id='topic+AbstractStatSlabinterval'></span><span id='topic+ggdist-ggproto'></span><span id='topic+GeomSlabinterval'></span><span id='topic+GeomDotsinterval'></span><span id='topic+GeomDots'></span><span id='topic+GeomBlurDots'></span><span id='topic+GeomInterval'></span><span id='topic+GeomLineribbon'></span><span id='topic+GeomPointinterval'></span><span id='topic+GeomSlab'></span><span id='topic+GeomSpike'></span><span id='topic+GeomSwarm'></span><span id='topic+GeomWeave'></span><span id='topic+PositionDodgejust'></span><span id='topic+StatSlabinterval'></span><span id='topic+StatPointinterval'></span><span id='topic+StatInterval'></span><span id='topic+StatSpike'></span>

<h3>Description</h3>

<p>Base ggproto classes for ggdist
</p>


<h3>See Also</h3>

<p><a href="ggplot2.html#topic+ggproto">ggproto</a>
</p>

<hr>
<h2 id='align'>Break (bin) alignment methods</h2><span id='topic+align'></span><span id='topic+align_none'></span><span id='topic+align_boundary'></span><span id='topic+align_center'></span>

<h3>Description</h3>

<p>Methods for aligning breaks (bins) in histograms, as used in the <code>align</code>
argument to <code><a href="#topic+density_histogram">density_histogram()</a></code>.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_none(breaks)

align_boundary(breaks, at = 0)

align_center(breaks, at = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_+3A_breaks">breaks</code></td>
<td>
<p>A sorted vector of breaks (bin edges).</p>
</td></tr>
<tr><td><code id="align_+3A_at">at</code></td>
<td>
<p>A scalar numeric giving an alignment point.
</p>

<ul>
<li><p> For <code><a href="#topic+align_boundary">align_boundary()</a></code>: align breaks so that a bin edge lines up with <code>at</code>.
</p>
</li>
<li><p> For <code><a href="#topic+align_center">align_center()</a></code>: align breaks so that the center of a bin lines up with <code>at</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions take a sorted vector of equally-spaced <code>breaks</code> giving
bin edges and return a numeric offset which, if subtracted from <code>breaks</code>,
will align them as desired:
</p>

<ul>
<li> <p><code><a href="#topic+align_none">align_none()</a></code> performs no alignment (it always returns <code>0</code>).
</p>
</li>
<li> <p><code><a href="#topic+align_boundary">align_boundary()</a></code> ensures that a bin edge lines up with <code>at</code>.
</p>
</li>
<li> <p><code><a href="#topic+align_center">align_center()</a></code> ensures that a bin center lines up with <code>at.</code>
</p>
</li></ul>

<p>For <code><a href="#topic+align_boundary">align_boundary()</a></code> (respectively <code><a href="#topic+align_center">align_center()</a></code>), if no bin edge (or center) in the
range of <code>breaks</code> would line up with <code>at</code>, it ensures that <code>at</code> is an integer
multiple of the bin width away from a bin edge (or center).
</p>


<h3>Value</h3>

<p>A scalar numeric returning an offset to be subtracted from <code>breaks</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density_histogram">density_histogram()</a></code>, <a href="#topic+breaks">breaks</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

set.seed(1234)
x = rnorm(200, 1, 2)

# If we manually specify a bin width using breaks_fixed(), the default
# alignment (align_none()) will not align bin edges to any "pretty" numbers.
# Here is a comparison of the three alignment methods on such a histogram:
ggplot(data.frame(x), aes(x)) +
  stat_slab(
    aes(y = "align_none()\nor 'none'"),
    density = "histogram",
    breaks = breaks_fixed(width = 1),
    outline_bars = TRUE,
    # no need to specify align; align_none() is the default
    color = "black",
  ) +
  stat_slab(
    aes(y = "align_center(at = 0)\nor 'center'"),
    density = "histogram",
    breaks = breaks_fixed(width = 1),
    align = align_center(at = 0),   # or align = "center"
    outline_bars = TRUE,
    color = "black",
  ) +
  stat_slab(
    aes(y = "align_boundary(at = 0)\nor 'boundary'"),
    density = "histogram",
    breaks = breaks_fixed(width = 1),
    align = align_boundary(at = 0), # or align = "boundary"
    outline_bars = TRUE,
    color = "black",
  ) +
  geom_point(aes(y = 0.7), alpha = 0.5) +
  labs(
    subtitle = "ggdist::stat_slab(density = 'histogram', ...)",
    y = "align =",
    x = NULL
  ) +
  geom_vline(xintercept = 0, linetype = "22", color = "red")
</code></pre>

<hr>
<h2 id='auto_partial'>Automatic partial function application in ggdist</h2><span id='topic+auto_partial'></span><span id='topic+automatic-partial-functions'></span>

<h3>Description</h3>

<p>Several <span class="pkg">ggdist</span> functions support <em>automatic partial application</em>: when called,
if all of their required arguments have not been provided, the function returns a
modified version of itself that uses the arguments passed to it so far as defaults.
Technically speaking, these functions are essentially &quot;Curried&quot; with respect to
their required arguments, but I think &quot;automatic partial application&quot; gets
the idea across more clearly.
</p>
<p>Functions supporting automatic partial application include:
</p>

<ul>
<li><p> The <code><a href="#topic+point_interval">point_interval()</a></code> family, such as <code><a href="#topic+median_qi">median_qi()</a></code>, <code><a href="#topic+mean_qi">mean_qi()</a></code>,
<code><a href="#topic+mode_hdi">mode_hdi()</a></code>, etc.
</p>
</li>
<li><p> The <code>smooth_</code> family, such as <code><a href="#topic+smooth_bounded">smooth_bounded()</a></code>, <code><a href="#topic+smooth_unbounded">smooth_unbounded()</a></code>,
<code><a href="#topic+smooth_discrete">smooth_discrete()</a></code>, and <code><a href="#topic+smooth_bar">smooth_bar()</a></code>.
</p>
</li>
<li><p> The <code>density_</code> family, such as <code><a href="#topic+density_bounded">density_bounded()</a></code>, <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_histogram">density_histogram()</a></code>.
</p>
</li>
<li><p> The <a href="#topic+align">align</a> family.
</p>
</li>
<li><p> The <a href="#topic+breaks">breaks</a> family.
</p>
</li>
<li><p> The <a href="#topic+bandwidth">bandwidth</a> family.
</p>
</li>
<li><p> The <a href="#topic+blur">blur</a> family.
</p>
</li></ul>

<p>Partial application makes it easier to supply custom parameters to these
functions when using them inside other functions, such as geoms and stats.
For example, smoothers for <code><a href="#topic+geom_dots">geom_dots()</a></code> can be supplied in one of three
ways:
</p>

<ul>
<li><p> as a suffix: <code>geom_dots(smooth = "bounded")</code>
</p>
</li>
<li><p> as a function: <code>geom_dots(smooth = smooth_bounded)</code>
</p>
</li>
<li><p> as a partially-applied function with options:
<code>geom_dots(smooth = smooth_bounded(kernel = "cosine"))</code>
</p>
</li></ul>

<p>Many other common arguments for <span class="pkg">ggdist</span> functions work similarly; e.g.
<code>density</code>, <code>align</code>, <code>breaks</code>, <code>bandwidth</code>, and <code>point_interval</code> arguments.
</p>
<p>These function families (except <code><a href="#topic+point_interval">point_interval()</a></code>) also support passing
<a href="#topic+waiver">waiver</a>s to their optional arguments: if <code><a href="#topic+waiver">waiver()</a></code> is passed to any
of these arguments, their default value (or the most
recently-partially-applied non-<code>waiver</code> value) is used instead.
</p>
<p>Use the <code><a href="#topic+auto_partial">auto_partial()</a></code> function to create new functions that support
automatic partial application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_partial(f, name = NULL, waivable = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_partial_+3A_f">f</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="auto_partial_+3A_name">name</code></td>
<td>
<p>A character string giving the name of the function, to be used
when printing.</p>
</td></tr>
<tr><td><code id="auto_partial_+3A_waivable">waivable</code></td>
<td>
<p>logical: if <code>TRUE</code>, optional arguments that get
passed a <code><a href="#topic+waiver">waiver()</a></code> will keep their default value (or whatever
non-<code>waiver</code> value has been most recently partially applied for that
argument).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of <code>f</code> that will automatically be partially
applied if all of its required arguments are not given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
x = rnorm(100)

# the first required argument, `x`, of the density_ family is the vector
# to calculate a kernel density estimate from. If it is not provided, the
# function is partially applied and returned as-is
density_unbounded()

# we could create a new function that uses half the default bandwidth
density_half_bw = density_unbounded(adjust = 0.5)
density_half_bw

# we can overwrite partially-applied arguments
density_quarter_bw_trimmed = density_half_bw(adjust = 0.25, trim = TRUE)
density_quarter_bw_trimmed

# when we eventually call the function and provide the required argument
# `x`, it is applied using the arguments we have "saved up" so far
density_quarter_bw_trimmed(x)

# create a custom automatically partially applied function
f = auto_partial(function(x, y, z = 3) (x + y) * z)
f()
f(1)
g = f(y = 2)(z = 4)
g
g(1)

# pass waiver() to optional arguments to use existing values
f(z = waiver())(1, 2)  # uses default z = 3
f(z = 4)(z = waiver())(1, 2)  # uses z = 4
</code></pre>

<hr>
<h2 id='bandwidth'>Bandwidth estimators</h2><span id='topic+bandwidth'></span><span id='topic+bandwidth_nrd0'></span><span id='topic+bandwidth_nrd'></span><span id='topic+bandwidth_ucv'></span><span id='topic+bandwidth_bcv'></span><span id='topic+bandwidth_SJ'></span><span id='topic+bandwidth_dpi'></span>

<h3>Description</h3>

<p>Bandwidth estimators for densities, used in the <code>bandwidth</code> argument
to density functions (e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code>, <code><a href="#topic+density_unbounded">density_unbounded()</a></code>).
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidth_nrd0(x, ...)

bandwidth_nrd(x, ...)

bandwidth_ucv(x, ...)

bandwidth_bcv(x, ...)

bandwidth_SJ(x, ...)

bandwidth_dpi(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidth_+3A_x">x</code></td>
<td>
<p>A numeric vector giving a sample.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="stats.html#topic+bandwidth">stats::bw.SJ</a></code>
</p>

<dl>
<dt><code>nb</code></dt><dd><p>number of bins to use.</p>
</dd>
<dt><code>lower,upper</code></dt><dd><p>range over which to minimize.  The default is
almost always satisfactory.  <code>hmax</code> is calculated internally
from a normal reference bandwidth.</p>
</dd>
<dt><code>method</code></dt><dd><p>either <code>"ste"</code> (&quot;solve-the-equation&quot;) or
<code>"dpi"</code> (&quot;direct plug-in&quot;).   Can be abbreviated.</p>
</dd>
<dt><code>tol</code></dt><dd><p>for method <code>"ste"</code>, the convergence tolerance for
<code><a href="stats.html#topic+uniroot">uniroot</a></code>.  The default leads to bandwidth estimates
with only slightly more than one digit accuracy, which is sufficient
for practical density estimation, but possibly not for theoretical
simulation studies.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>These are loose wrappers around the corresponding <code>bw.</code>-prefixed functions
in <span class="pkg">stats</span>. See, for example, <code><a href="stats.html#topic+bw.SJ">bw.SJ()</a></code>.
</p>
<p><code><a href="#topic+bandwidth_dpi">bandwidth_dpi()</a></code>, which is the default bandwidth estimator in <span class="pkg">ggdist</span>,
is the Sheather-Jones direct plug-in estimator, i.e. <code>bw.SJ(..., method = "dpi")</code>.
</p>


<h3>Value</h3>

<p>A single number giving the bandwidth
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density_bounded">density_bounded()</a></code>, <code><a href="#topic+density_unbounded">density_unbounded()</a></code>.
</p>

<hr>
<h2 id='bin_dots'>Bin data values using a dotplot algorithm</h2><span id='topic+bin_dots'></span>

<h3>Description</h3>

<p>Bins the provided data values using one of several dotplot algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_dots(
  x,
  y,
  binwidth,
  heightratio = 1,
  stackratio = 1,
  layout = c("bin", "weave", "hex", "swarm", "bar"),
  side = c("topright", "top", "right", "bottomleft", "bottom", "left", "topleft",
    "bottomright", "both"),
  orientation = c("horizontal", "vertical", "y", "x"),
  overlaps = "nudge"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_dots_+3A_x">x</code></td>
<td>
<p>numeric vector of x values</p>
</td></tr>
<tr><td><code id="bin_dots_+3A_y">y</code></td>
<td>
<p>numeric vector of y values</p>
</td></tr>
<tr><td><code id="bin_dots_+3A_binwidth">binwidth</code></td>
<td>
<p>bin width</p>
</td></tr>
<tr><td><code id="bin_dots_+3A_heightratio">heightratio</code></td>
<td>
<p>ratio of bin width to dot height</p>
</td></tr>
<tr><td><code id="bin_dots_+3A_stackratio">stackratio</code></td>
<td>
<p>ratio of dot height to vertical distance between dot
centers</p>
</td></tr>
<tr><td><code id="bin_dots_+3A_layout">layout</code></td>
<td>
<p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bin_dots_+3A_side">side</code></td>
<td>
<p>Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).</p>
</td></tr>
<tr><td><code id="bin_dots_+3A_orientation">orientation</code></td>
<td>
<p>Whether the dots are laid out horizontally or vertically.
Follows the naming scheme of <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>:
</p>

<ul>
<li> <p><code>"horizontal"</code> assumes the data values for the dotplot are in the <code>x</code>
variable and that dots will be stacked up in the <code>y</code> direction.
</p>
</li>
<li> <p><code>"vertical"</code> assumes the data values for the dotplot are in the <code>y</code>
variable and that dots will be stacked up in the <code>x</code> direction.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>,
<code>"x"</code> can be used as an alias for <code>"vertical"</code> and <code>"y"</code> as an alias for
<code>"horizontal"</code>.</p>
</td></tr>
<tr><td><code id="bin_dots_+3A_overlaps">overlaps</code></td>
<td>
<p>How to handle overlapping dots or bins in the <code>"bin"</code>,
<code>"weave"</code>, and <code>"hex"</code> layouts (dots never overlap in the <code>"swarm"</code> or <code>"bar"</code> layouts).
For the purposes of this argument, dots are only considered to be overlapping
if they would be overlapping when <code>dotsize = 1</code> and <code>stackratio = 1</code>; i.e.
if you set those arguments to other values, overlaps may still occur.
One of: </p>

<ul>
<li> <p><code>"keep"</code>: leave overlapping dots as they are. Dots may overlap
(usually only slightly) in the <code>"bin"</code>, <code>"weave"</code>, and <code>"hex"</code> layouts.
</p>
</li>
<li> <p><code>"nudge"</code>: nudge overlapping dots out of the way. Overlaps are avoided
using a constrained optimization which minimizes the squared distance of
dots to their desired positions, subject to the constraint that adjacent
dots do not overlap.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with three columns:
</p>

<ul>
<li> <p><code>x</code>: the x position of each dot
</p>
</li>
<li> <p><code>y</code>: the y position of each dot
</p>
</li>
<li> <p><code>bin</code>: a unique number associated with each bin
(supplied but not used when <code>layout = "swarm"</code>)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+find_dotplot_binwidth">find_dotplot_binwidth()</a></code> for an algorithm that finds good bin widths
to use with this function; <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for geometries that use
these algorithms to create dotplots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

x = qnorm(ppoints(20))
bin_df = bin_dots(x = x, y = 0, binwidth = 0.5, heightratio = 1)
bin_df

# we can manually plot the binning above, though this is only recommended
# if you are using find_dotplot_binwidth() and bin_dots() to build your own
# grob. For practical use it is much easier to use geom_dots(), which will
# automatically select good bin widths for you (and which uses
# find_dotplot_binwidth() and bin_dots() internally)
bin_df %&gt;%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 4) +
  coord_fixed()

</code></pre>

<hr>
<h2 id='blur'>Blur functions for blurry dot plots</h2><span id='topic+blur'></span><span id='topic+blur_gaussian'></span><span id='topic+blur_interval'></span>

<h3>Description</h3>

<p>Methods for constructing blurs, as used in the <code>blur</code> argument to
<code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code> or <code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code>.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blur_gaussian(x, r, sd)

blur_interval(x, r, sd, .width = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blur_+3A_x">x</code></td>
<td>
<p>numeric vector of positive distances from the center of the dot
(assumed to be 0) to evaluate blur function at.</p>
</td></tr>
<tr><td><code id="blur_+3A_r">r</code></td>
<td>
<p>radius of the dot that is being blurred.</p>
</td></tr>
<tr><td><code id="blur_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the dot that is being blurred.</p>
</td></tr>
<tr><td><code id="blur_+3A_.width">.width</code></td>
<td>
<p>for <code>blur_interval()</code>, a probability giving the width of
the interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are passed <code>x</code>, <code>r</code>, and <code>sd</code> when <code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>
draws in order to create a radial gradient representing each dot in the
dotplot. They return values between <code>0</code> and <code>1</code> giving the opacity of the
dot at each value of <code>x</code>.
</p>
<p><code>blur_gaussian()</code> creates a dot with radius <code>r</code> that has a Gaussian blur with
standard deviation <code>sd</code> applied to it. It does this by calculating
<code class="reqn">\alpha(x; r, \sigma)</code>, the opacity at distance <code class="reqn">x</code> from the center
of a dot with radius <code class="reqn">r</code> that has had a Gaussian blur with standard
deviation <code class="reqn">\sigma</code> = <code>sd</code> applied to it:
</p>
<p style="text-align: center;"><code class="reqn">
\alpha(x; r, \sigma) = \Phi \left(\frac{x + r}{\sigma} \right) -
  \Phi \left(\frac{x - r}{\sigma} \right)
</code>
</p>

<p><code>blur_interval()</code> creates an interval-type representation around the
dot at 50% opacity, where the interval is a Gaussian quantile interval with
mass equal to <code>.width</code> and standard deviation <code>sd</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>x</code> giving the opacity of the radial gradient representing
the dot at each <code>x</code> value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code> and <code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code> for geometries making use of
<code>blur</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples in geom_blur_dots()
</code></pre>

<hr>
<h2 id='bounder_cdf'>Estimate bounds of a distribution using the CDF of its order statistics</h2><span id='topic+bounder_cdf'></span>

<h3>Description</h3>

<p>Estimate the bounds of the distribution a sample came from using the CDF of
the order statistics of the sample. Use with the <code>bounder</code> argument to <code><a href="#topic+density_bounded">density_bounded()</a></code>.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounder_cdf(x, p = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounder_cdf_+3A_x">x</code></td>
<td>
<p>numeric vector containing a sample to estimate the bounds of.</p>
</td></tr>
<tr><td><code id="bounder_cdf_+3A_p">p</code></td>
<td>
<p>scalar in <code class="reqn">[0,1]</code>: percentile of the order statistic distribution to use
as the estimate. <code>p = 1</code> will return <code>range(x)</code>; <code>p = 0.5</code> will give the median
estimate, <code>p = 0</code> will give a very wide estimate (effectively treating the
distribution as unbounded when used with <code><a href="#topic+density_bounded">density_bounded()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+bounder_cdf">bounder_cdf()</a></code> uses the distribution of the order statistics of
<code class="reqn">X</code> to estimate where the first and last order statistics (i.e. the
min and max) of this distribution would be, assuming the sample <code>x</code> is the
distribution. Then, it adjusts the boundary outwards from <code>min(x)</code> (or <code>max(x)</code>)
by the distance between <code>min(x)</code> (or <code>max(x)</code>) and the nearest estimated
order statistic.
</p>
<p>Taking <code class="reqn">X</code> = <code>x</code>, the distributions of the first and last order statistics are:
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}
F_{X_{(1)}}(x) &amp;=&amp; 1 - \left[1 - F_X(x)\right]^n\\
F_{X_{(n)}}(x) &amp;=&amp; F_X(x)^n
\end{array}</code>
</p>

<p>Re-arranging, we can get the inverse CDFs (quantile functions) of each
order statistic in terms of the quantile function of <code class="reqn">X</code> (which we
can estimate from the data), giving us an estimate for the minimum
and maximum order statistic:
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcrcl}
\hat{x_1} &amp;=&amp; F_{X_{(1)}}^{-1}(p) &amp;=&amp; F_X^{-1}\left[1 - (1 - p)^{1/n}\right]\\
\hat{x_n} &amp;=&amp; F_{X_{(n)}}^{-1}(p) &amp;=&amp; F_X^{-1}\left[p^{1/n}\right]
\end{array}</code>
</p>

<p>Then the estimated bounds are:
</p>
<p style="text-align: center;"><code class="reqn">\left[2\min(x) - \hat{x_1}, 2\max(x) - \hat{x_n} \right]</code>
</p>

<p>These bounds depend on <code class="reqn">p</code>, the percentile of the distribution of the order
statistic used to form the estimate. While <code class="reqn">p = 0.5</code> (the median) might be
a reasonable choice (and gives results similar to <code><a href="#topic+bounder_cooke">bounder_cooke()</a></code>), this tends
to be a bit too aggressive in &quot;detecting&quot; bounded distributions, especially in
small sample sizes. Thus, we use a default of <code class="reqn">p = 0.01</code>, which tends to
be very conservative in small samples (in that it usually gives results
roughly equivalent to an unbounded distribution), but which still performs
well on bounded distributions when sample sizes are larger (in the thousands).
</p>


<h3>Value</h3>

<p>A length-2 numeric vector giving an estimate of the minimum and maximum bounds
of the distribution that <code>x</code> came from.
</p>


<h3>See Also</h3>

<p>The <code>bounder</code> argument to <code><a href="#topic+density_bounded">density_bounded()</a></code>.
</p>
<p>Other bounds estimators: 
<code><a href="#topic+bounder_cooke">bounder_cooke</a>()</code>,
<code><a href="#topic+bounder_range">bounder_range</a>()</code>
</p>

<hr>
<h2 id='bounder_cooke'>Estimate bounds of a distribution using Cooke's method</h2><span id='topic+bounder_cooke'></span>

<h3>Description</h3>

<p>Estimate the bounds of the distribution a sample came from using Cooke's method.
Use with the <code>bounder</code> argument to <code><a href="#topic+density_bounded">density_bounded()</a></code>.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounder_cooke(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounder_cooke_+3A_x">x</code></td>
<td>
<p>numeric vector containing a sample to estimate the bounds of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate the bounds of a distribution using the method from Cooke (1979);
i.e. method 2.3 from Loh (1984). These bounds are:
</p>
<p style="text-align: center;"><code class="reqn">\left[\begin{array}{l}
2X_{(1)} - \sum_{i = 1}^n \left[\left(1 - \frac{i - 1}{n}\right)^n -
  \left(1 - \frac{i}{n}\right)^n \right] X_{(i)}\\
2X_{(n)} - \sum_{i = 1}^n \left[\left(1 - \frac{n - i}{n}\right)^n -
  \left(1 - \frac{n + 1 - i}{n} \right)^n\right] X_{(i)}
\end{array}\right]</code>
</p>

<p>Where <code class="reqn">X_{(i)}</code> is the <code class="reqn">i</code>th order statistic of <code>x</code> (i.e. its
<code class="reqn">i</code>th-smallest value).
</p>


<h3>Value</h3>

<p>A length-2 numeric vector giving an estimate of the minimum and maximum bounds
of the distribution that <code>x</code> came from.
</p>


<h3>References</h3>

<p>Cooke, P. (1979). Statistical inference for bounds of random variables.
<em>Biometrika</em> 66(2), 367&ndash;374. <a href="https://doi.org/10.1093/biomet/66.2.367">doi:10.1093/biomet/66.2.367</a>.
</p>
<p>Loh, W. Y. (1984). Estimating an endpoint of a distribution with resampling
methods. <em>The Annals of Statistics</em> 12(4), 1543&ndash;1550. <a href="https://doi.org/10.1214/aos/1176346811">doi:10.1214/aos/1176346811</a>
</p>


<h3>See Also</h3>

<p>The <code>bounder</code> argument to <code><a href="#topic+density_bounded">density_bounded()</a></code>.
</p>
<p>Other bounds estimators: 
<code><a href="#topic+bounder_cdf">bounder_cdf</a>()</code>,
<code><a href="#topic+bounder_range">bounder_range</a>()</code>
</p>

<hr>
<h2 id='bounder_range'>Estimate bounds of a distribution using the range of the sample</h2><span id='topic+bounder_range'></span>

<h3>Description</h3>

<p>Estimate the bounds of the distribution a sample came from using the range of the sample.
Use with the <code>bounder</code> argument to <code><a href="#topic+density_bounded">density_bounded()</a></code>.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounder_range(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounder_range_+3A_x">x</code></td>
<td>
<p>numeric vector containing a sample to estimate the bounds of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate the bounds of a distribution using <code>range(x)</code>.
</p>


<h3>Value</h3>

<p>A length-2 numeric vector giving an estimate of the minimum and maximum bounds
of the distribution that <code>x</code> came from.
</p>


<h3>See Also</h3>

<p>The <code>bounder</code> argument to <code><a href="#topic+density_bounded">density_bounded()</a></code>.
</p>
<p>Other bounds estimators: 
<code><a href="#topic+bounder_cdf">bounder_cdf</a>()</code>,
<code><a href="#topic+bounder_cooke">bounder_cooke</a>()</code>
</p>

<hr>
<h2 id='breaks'>Break (bin) selection algorithms for histograms</h2><span id='topic+breaks'></span><span id='topic+breaks_fixed'></span><span id='topic+breaks_Sturges'></span><span id='topic+breaks_Scott'></span><span id='topic+breaks_FD'></span><span id='topic+breaks_quantiles'></span>

<h3>Description</h3>

<p>Methods for determining breaks (bins) in histograms, as used in the <code>breaks</code>
argument to <code><a href="#topic+density_histogram">density_histogram()</a></code>.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breaks_fixed(x, weights = NULL, width = 1)

breaks_Sturges(x, weights = NULL)

breaks_Scott(x, weights = NULL)

breaks_FD(x, weights = NULL, digits = 5)

breaks_quantiles(x, weights = NULL, max_n = "Scott", min_width = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breaks_+3A_x">x</code></td>
<td>
<p>A numeric vector giving a sample.</p>
</td></tr>
<tr><td><code id="breaks_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of <code>length(x)</code> giving sample weights.</p>
</td></tr>
<tr><td><code id="breaks_+3A_width">width</code></td>
<td>
<p>For <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code>, the desired bin width.</p>
</td></tr>
<tr><td><code id="breaks_+3A_digits">digits</code></td>
<td>
<p>For <code><a href="#topic+breaks_FD">breaks_FD()</a></code>, the number of significant digits to keep when
rounding in the Freedman-Diaconis algorithm. For an explanation of this
parameter, see the documentation of the corresponding parameter in
<code><a href="grDevices.html#topic+nclass">grDevices::nclass.FD()</a></code>.</p>
</td></tr>
<tr><td><code id="breaks_+3A_max_n">max_n</code></td>
<td>
<p>For <code><a href="#topic+breaks_quantiles">breaks_quantiles()</a></code>, either a scalar numeric giving the
maximum number of bins, or another breaks function (or string giving the
suffix of the name of a function prefixed with <code>"breaks_"</code>) that will
return the maximum number of bins. <code><a href="#topic+breaks_quantiles">breaks_quantiles()</a></code> will construct
<em>at most</em> <code>max_n</code> bins.</p>
</td></tr>
<tr><td><code id="breaks_+3A_min_width">min_width</code></td>
<td>
<p>For <code><a href="#topic+breaks_quantiles">breaks_quantiles()</a></code>, a scalar numeric between <code>0</code> and
<code>1</code> giving the minimum bin width as a proportion of <code>diff(range(x)) / max_n</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions take a sample and its weights and return a value suitable for
the <code>breaks</code> argument to <code><a href="#topic+density_histogram">density_histogram()</a></code> that will determine the histogram
breaks.
</p>

<ul>
<li> <p><code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> allows you to manually specify a fixed bin width.
</p>
</li>
<li> <p><code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code>, <code><a href="#topic+breaks_Scott">breaks_Scott()</a></code>, and <code><a href="#topic+breaks_FD">breaks_FD()</a></code> implement weighted
versions of their corresponding base functions. They return a scalar
numeric giving the number of bins. See <code><a href="grDevices.html#topic+nclass.Sturges">nclass.Sturges()</a></code>, <code><a href="grDevices.html#topic+nclass.scott">nclass.scott()</a></code>,
and <code><a href="grDevices.html#topic+nclass.FD">nclass.FD()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+breaks_quantiles">breaks_quantiles()</a></code> constructs irregularly-sized bins using <code>max_n + 1</code>
(possibly weighted) quantiles of <code>x</code>. The final number of bins is
<em>at most</em> <code>max_n</code>, as small bins (ones whose bin width is less than half
the range of the data divided by <code>max_n</code> times <code>min_width</code>) will be merged
into adjacent bins.
</p>
</li></ul>



<h3>Value</h3>

<p>Either a single number (giving the number of bins) or a vector
giving the edges between bins.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density_histogram">density_histogram()</a></code>, <a href="#topic+align">align</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

set.seed(1234)
x = rnorm(200, 1, 2)

# Let's compare the different break-selection algorithms on this data:
ggplot(data.frame(x), aes(x)) +
  stat_slab(
    aes(y = "breaks_fixed(width = 0.5)"),
    density = "histogram",
    breaks = breaks_fixed(width = 0.5),
    outline_bars = TRUE,
    color = "black",
  ) +
  stat_slab(
    aes(y = "breaks_Sturges()\nor 'Sturges'"),
    density = "histogram",
    breaks = "Sturges",
    outline_bars = TRUE,
    color = "black",
  ) +
  stat_slab(
    aes(y = "breaks_Scott()\nor 'Scott'"),
    density = "histogram",
    breaks = "Scott",
    outline_bars = TRUE,
    color = "black",
  ) +
  stat_slab(
    aes(y = "breaks_FD()\nor 'FD'"),
    density = "histogram",
    breaks = "FD",
    outline_bars = TRUE,
    color = "black",
  ) +
  geom_point(aes(y = 0.7), alpha = 0.5) +
  labs(
    subtitle = "ggdist::stat_slab(density = 'histogram', ...)",
    y = "breaks =",
    x = NULL
  )
</code></pre>

<hr>
<h2 id='curve_interval'>Curvewise point and interval summaries for tidy data frames of draws from distributions</h2><span id='topic+curve_interval'></span><span id='topic+curve_interval.matrix'></span><span id='topic+curve_interval.rvar'></span><span id='topic+curve_interval.data.frame'></span>

<h3>Description</h3>

<p>Translates draws from distributions in a grouped data frame into a set of point and
interval summaries using a curve boxplot-inspired approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_interval(
  .data,
  ...,
  .along = NULL,
  .width = 0.5,
  na.rm = FALSE,
  .interval = c("mhd", "mbd", "bd", "bd-mbd")
)

## S3 method for class 'matrix'
curve_interval(
  .data,
  ...,
  .along = NULL,
  .width = 0.5,
  na.rm = FALSE,
  .interval = c("mhd", "mbd", "bd", "bd-mbd")
)

## S3 method for class 'rvar'
curve_interval(
  .data,
  ...,
  .along = NULL,
  .width = 0.5,
  na.rm = FALSE,
  .interval = c("mhd", "mbd", "bd", "bd-mbd")
)

## S3 method for class 'data.frame'
curve_interval(
  .data,
  ...,
  .along = NULL,
  .width = 0.5,
  na.rm = FALSE,
  .interval = c("mhd", "mbd", "bd", "bd-mbd"),
  .simple_names = TRUE,
  .exclude = c(".chain", ".iteration", ".draw", ".row")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_interval_+3A_.data">.data</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> A data frame (or grouped data frame as returned by <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>)
that contains draws to summarize.
</p>
</li>
<li><p> A <a href="posterior.html#topic+rvar">posterior::rvar</a> vector.
</p>
</li>
<li><p> A matrix; in which case the first dimension should be draws and the second
dimension values of the curve.
</p>
</li></ul>
</td></tr>
<tr><td><code id="curve_interval_+3A_...">...</code></td>
<td>
<p>Bare column names or expressions that, when evaluated in the context of
<code>.data</code>, represent draws to summarize. If this is empty, then by default all
columns that are not group columns and which are not in <code>.exclude</code> (by default
<code>".chain"</code>, <code>".iteration"</code>, <code>".draw"</code>, and <code>".row"</code>) will be summarized.
This can be numeric columns, list columns containing numeric vectors, or
<code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s.</p>
</td></tr>
<tr><td><code id="curve_interval_+3A_.along">.along</code></td>
<td>
<p>Which columns are the input values to the function describing the curve (e.g., the &quot;x&quot;
values). Supports <a href="tidyselect.html#topic+language">tidyselect</a> syntax. Intervals are calculated jointly with
respect to these variables, conditional on all other grouping variables in the data frame. The default
(<code>NULL</code>) causes <code><a href="#topic+curve_interval">curve_interval()</a></code> to use all grouping variables in the input data frame as the value
for <code>.along</code>, which will generate the most conservative intervals. However, if you want to calculate
intervals for some function <code>y = f(x)</code> conditional on some other variable(s) (say, conditional on a
factor <code>g</code>), you would group by <code>g</code>, then use <code>.along = x</code> to calculate intervals jointly over <code>x</code>
conditional on <code>g</code>. To avoid selecting any variables as input values to the function describing the
curve, use <code>character()</code>; this will produce conditional intervals only (the result in this case should
be very similar to <code>median_qi()</code>). Currently only supported when <code>.data</code> is a data frame.</p>
</td></tr>
<tr><td><code id="curve_interval_+3A_.width">.width</code></td>
<td>
<p>vector of probabilities to use that determine the widths of the resulting intervals.
If multiple probabilities are provided, multiple rows per group are generated, each with
a different probability interval (and value of the corresponding <code>.width</code> column).</p>
</td></tr>
<tr><td><code id="curve_interval_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values should be stripped before the computation proceeds.
If <code>FALSE</code> (the default), the presence of <code>NA</code> values in the columns to be summarized will generally
result in an error. If <code>TRUE</code>, <code>NA</code> values will be removed in the calculation of intervals so long
as <code>.interval</code> is <code>"mhd"</code>; other methods do not currently support <code>na.rm</code>. Be cautious in applying
this parameter: in general, it is unclear what a joint interval should be when any of the values
are missing!</p>
</td></tr>
<tr><td><code id="curve_interval_+3A_.interval">.interval</code></td>
<td>
<p>The method used to calculate the intervals. Currently, all methods rank the curves
using some measure of <em>data depth</em>, then create envelopes containing the <code>.width</code>% &quot;deepest&quot; curves.
Available methods are:
</p>

<ul>
<li> <p><code>"mhd"</code>: mean halfspace depth (Fraiman and Muniz 2001).
</p>
</li>
<li> <p><code>"mbd"</code>: modified band depth (Sun and Genton 2011): calls <code><a href="fda.html#topic+fbplot">fda::fbplot()</a></code> with <code>method = "MBD"</code>.
</p>
</li>
<li> <p><code>"bd"</code>: band depth (Sun and Genton 2011): calls <code><a href="fda.html#topic+fbplot">fda::fbplot()</a></code> with <code>method = "BD2"</code>.
</p>
</li>
<li> <p><code>"bd-mbd"</code>: band depth, breaking ties with modified band depth (Sun and Genton 2011): calls
<code><a href="fda.html#topic+fbplot">fda::fbplot()</a></code> with <code>method = "Both"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="curve_interval_+3A_.simple_names">.simple_names</code></td>
<td>
<p>When <code>TRUE</code> and only a single column / vector is to be summarized, use the
name <code>.lower</code> for the lower end of the interval and <code>.upper</code> for the
upper end. When <code>FALSE</code> and <code>.data</code> is a data frame,
names the lower and upper intervals for each column <code>x</code> <code>x.lower</code> and <code>x.upper</code>.</p>
</td></tr>
<tr><td><code id="curve_interval_+3A_.exclude">.exclude</code></td>
<td>
<p>A character vector of names of columns to be excluded from summarization
if no column names are specified to be summarized. Default ignores several meta-data column
names used in <span class="pkg">ggdist</span> and <span class="pkg">tidybayes</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intervals are calculated by ranking the curves using some measure of <em>data depth</em>, then
using binary search to find a cutoff <code>k</code> such that an envelope containing the <code>k</code>% &quot;deepest&quot;
curves also contains <code>.width</code>% of the curves, for each value of <code>.width</code> (note that <code>k</code>
and <code>.width</code> are not necessarily the same). This is in contrast to most functional boxplot
or curve boxplot approaches, which tend to simply take the <code>.width</code>% deepest curves, and
are generally quite conservative (i.e. they may contain more than <code>.width</code>% of the curves).
</p>
<p>See Mirzargar <em>et al.</em> (2014) or Juul <em>et al.</em> (2020) for an accessible introduction
to data depth and curve boxplots / functional boxplots.
</p>


<h3>Value</h3>

<p>A data frame containing point summaries and intervals, with at least one column corresponding
to the point summary, one to the lower end of the interval, one to the upper end of the interval, the
width of the interval (<code>.width</code>), the type of point summary (<code>.point</code>), and the type of interval (<code>.interval</code>).
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>References</h3>

<p>Fraiman, Ricardo and Graciela Muniz. (2001).
&quot;Trimmed means for functional data&quot;.
<em>Test</em> 10: 419440.
<a href="https://doi.org/10.1007/BF02595706">doi:10.1007/BF02595706</a>.
</p>
<p>Sun, Ying and Marc G. Genton. (2011).
&quot;Functional Boxplots&quot;.
<em>Journal of Computational and Graphical Statistics</em>, 20(2): 316-334.
<a href="https://doi.org/10.1198/jcgs.2011.09224">doi:10.1198/jcgs.2011.09224</a>
</p>
<p>Mirzargar, Mahsa, Ross T Whitaker, and Robert M Kirby. (2014).
&quot;Curve Boxplot: Generalization of Boxplot for Ensembles of Curves&quot;.
<em>IEEE Transactions on Visualization and Computer Graphics</em>. 20(12): 2654-2663.
<a href="https://doi.org/10.1109/TVCG.2014.2346455">doi:10.1109/TVCG.2014.2346455</a>
</p>
<p>Juul Jonas, Kaare Grsbll, Lasse Engbo Christiansen, and Sune Lehmann. (2020).
&quot;Fixed-time descriptive statistics underestimate extremes of epidemic curve ensembles&quot;.
<em>arXiv e-print</em>.
<a href="https://arxiv.org/abs/2007.05035">arXiv:2007.05035</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+point_interval">point_interval()</a></code> for pointwise intervals. See <code>vignette("lineribbon")</code> for more examples
and discussion of the differences between pointwise and curvewise intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

# generate a set of curves
k = 11 # number of curves
n = 201
df = tibble(
    .draw = rep(1:k, n),
    mean = rep(seq(-5,5, length.out = k), n),
    x = rep(seq(-15,15,length.out = n), each = k),
    y = dnorm(x, mean, 3)
  )

# see pointwise intervals...
df %&gt;%
  group_by(x) %&gt;%
  median_qi(y, .width = c(.5)) %&gt;%
  ggplot(aes(x = x, y = y)) +
  geom_lineribbon(aes(ymin = .lower, ymax = .upper)) +
  geom_line(aes(group = .draw), alpha=0.15, data = df) +
  scale_fill_brewer() +
  ggtitle("50% pointwise intervals with point_interval()") +
  theme_ggdist()


# ... compare them to curvewise intervals
df %&gt;%
  group_by(x) %&gt;%
  curve_interval(y, .width = c(.5)) %&gt;%
  ggplot(aes(x = x, y = y)) +
  geom_lineribbon(aes(ymin = .lower, ymax = .upper)) +
  geom_line(aes(group = .draw), alpha=0.15, data = df) +
  scale_fill_brewer() +
  ggtitle("50% curvewise intervals with curve_interval()") +
  theme_ggdist()

</code></pre>

<hr>
<h2 id='cut_cdf_qi'>Categorize values from a CDF into quantile intervals</h2><span id='topic+cut_cdf_qi'></span>

<h3>Description</h3>

<p>Given a vector of probabilities from a cumulative distribution function (CDF)
and a list of desired quantile intervals, return a vector categorizing each
element of the input vector according to which quantile interval it falls into.
<strong>NOTE:</strong> While this function can be used for (and was originally designed for)
drawing slabs with intervals overlaid on the density, this is can now be
done more easily by mapping the <code>.width</code> or <code>level</code> computed variable to
slab fill or color. See <strong>Examples</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_cdf_qi(p, .width = c(0.66, 0.95, 1), labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_cdf_qi_+3A_p">p</code></td>
<td>
<p>A numeric vector of values from a cumulative distribution function,
such as values returned by <code>p</code>-prefixed distribution functions in base R (e.g. <code><a href="stats.html#topic+pnorm">pnorm()</a></code>),
the <code><a href="distributional.html#topic+cdf">cdf()</a></code> function, or values of the <code>cdf</code> computed aesthetic from the
<code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> family of stats.</p>
</td></tr>
<tr><td><code id="cut_cdf_qi_+3A_.width">.width</code></td>
<td>
<p>vector of probabilities to use that determine the widths of the resulting intervals.</p>
</td></tr>
<tr><td><code id="cut_cdf_qi_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default labels (<code>.width</code> converted to a character vector).
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>.width</code>)
</p>
</li>
<li><p> A function that takes numeric probabilities as input and returns labels as output
(a good candidate might be <code><a href="scales.html#topic+percent_format">scales::percent_format()</a></code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="base.html#topic+ordered">ordered</a> factor of the same length as <code>p</code> giving the quantile interval to
which each value of <code>p</code> belongs.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and
its shortcut stats, which generate <code>cdf</code> aesthetics that can be used with
<code><a href="#topic+cut_cdf_qi">cut_cdf_qi()</a></code> to draw slabs colored by their intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
library(dplyr)
library(scales)
library(distributional)

theme_set(theme_ggdist())

# NOTE: cut_cdf_qi() used to be the recommended way to do intervals overlaid
# on densities, like this...
tibble(x = dist_normal(0, 1)) %&gt;%
  ggplot(aes(xdist = x)) +
  stat_slab(
    aes(fill = after_stat(cut_cdf_qi(cdf)))
  ) +
  scale_fill_brewer(direction = -1)

# ... however this is now more easily and flexibly accomplished by directly
# mapping .width or level onto fill:
tibble(x = dist_normal(0, 1)) %&gt;%
  ggplot(aes(xdist = x)) +
  stat_slab(
    aes(fill = after_stat(level)),
    .width = c(.66, .95, 1)
  ) +
  scale_fill_brewer()

# See vignette("slabinterval") for more examples. The remaining examples
# below using cut_cdf_qi() are kept for posterity.

# With a halfeye (or other geom with slab and interval), NA values will
# show up in the fill scale from the CDF function applied to the internal
# interval geometry data and can be ignored, hence na.translate = FALSE
tibble(x = dist_normal(0, 1)) %&gt;%
  ggplot(aes(xdist = x)) +
  stat_halfeye(aes(
    fill = after_stat(cut_cdf_qi(cdf, .width = c(.5, .8, .95, 1)))
  )) +
  scale_fill_brewer(direction = -1, na.translate = FALSE)

# we could also use the labels parameter to apply nicer formatting
# and provide a better name for the legend, and omit the 100% interval
# if desired
tibble(x = dist_normal(0, 1)) %&gt;%
  ggplot(aes(xdist = x)) +
  stat_halfeye(aes(
    fill = after_stat(cut_cdf_qi(
      cdf,
      .width = c(.5, .8, .95),
      labels = percent_format(accuracy = 1)
    ))
  )) +
  labs(fill = "Interval") +
  scale_fill_brewer(direction = -1, na.translate = FALSE)

</code></pre>

<hr>
<h2 id='density_bounded'>Bounded density estimator using the reflection method</h2><span id='topic+density_bounded'></span>

<h3>Description</h3>

<p>Bounded density estimator using the reflection method.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_bounded(
  x,
  weights = NULL,
  n = 512,
  bandwidth = "dpi",
  adjust = 1,
  kernel = "gaussian",
  trim = FALSE,
  bounds = c(NA, NA),
  bounder = "cdf",
  adapt = 1,
  na.rm = FALSE,
  ...,
  range_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_bounded_+3A_x">x</code></td>
<td>
<p>numeric vector containing a sample to compute a density estimate for.</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights to apply to <code>x</code>.</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_n">n</code></td>
<td>
<p>numeric: the number of grid points to evaluate the density estimator at.</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_bandwidth">bandwidth</code></td>
<td>
<p>bandwidth of the density estimator. One of:
</p>

<ul>
<li><p> a numeric: the bandwidth, as the standard deviation of the kernel
</p>
</li>
<li><p> a function: a function taking <code>x</code> (the sample) and returning the bandwidth
</p>
</li>
<li><p> a string: the suffix of the name of a function starting with <code>"bandwidth_"</code> that
will be used to determine the bandwidth. See <a href="#topic+bandwidth">bandwidth</a> for a list.
</p>
</li></ul>
</td></tr>
<tr><td><code id="density_bounded_+3A_adjust">adjust</code></td>
<td>
<p>numeric: the bandwidth for the density estimator is multiplied
by this value. See <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_kernel">kernel</code></td>
<td>
<p>string: the smoothing kernel to be used. This must partially
match one of <code>"gaussian"</code>, <code>"rectangular"</code>, <code>"triangular"</code>, <code>"epanechnikov"</code>,
<code>"biweight"</code>, <code>"cosine"</code>, or <code>"optcosine"</code>. See <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_trim">trim</code></td>
<td>
<p>Should the density estimate be trimmed to the bounds of the data?</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_bounds">bounds</code></td>
<td>
<p>length-2 vector of min and max bounds. If a bound is <code>NA</code>, then
that bound is estimated from the data using the method specified by <code>bounder</code>.</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_bounder">bounder</code></td>
<td>
<p>Method to use to find missing (<code>NA</code>) <code>bounds</code>. A function that
takes a numeric vector of values and returns a length-2 vector of the estimated
lower and upper bound of the distribution. Can also be a string giving the
suffix of the name of such a function that starts with <code>"bounder_"</code>. Useful
values include:
</p>

<ul>
<li> <p><code>"cdf"</code>: Use the CDF of the the minimum and maximum order statistics of the
sample to estimate the bounds. See <code><a href="#topic+bounder_cdf">bounder_cdf()</a></code>.
</p>
</li>
<li> <p><code>"cooke"</code>: Use the method from Cooke (1979); i.e. method 2.3 from Loh (1984).
See <code><a href="#topic+bounder_cooke">bounder_cooke()</a></code>.
</p>
</li>
<li> <p><code>"range"</code>: Use the range of <code>x</code> (i.e the <code>min</code> or <code>max</code>). See <code><a href="#topic+bounder_range">bounder_range()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="density_bounded_+3A_adapt">adapt</code></td>
<td>
<p>(<strong>very experimental</strong>) The name and interpretation of this argument
are subject to change without notice. Positive integer. If <code>adapt &gt; 1</code>, uses
an adaptive approach to calculate the density. First, uses the
adaptive bandwidth algorithm of Abramson (1982) to determine local (pointwise)
bandwidths, then groups these bandwidths into <code>adapt</code> groups, then calculates
and sums the densities from each group. You can set this to a very large number
(e.g. <code>Inf</code>) for a fully adaptive approach, but this will be very slow; typically
something around 100 yields nearly identical results.</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing (<code>NA</code>) values in <code>x</code> be removed?</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
<tr><td><code id="density_bounded_+3A_range_only">range_only</code></td>
<td>
<p>If <code>TRUE</code>, the range of the output of this density estimator
is computed and is returned in the <code style="white-space: pre;">&#8288;$x&#8288;</code> element of the result, and <code>c(NA, NA)</code>
is returned in <code style="white-space: pre;">&#8288;$y&#8288;</code>. This gives a faster way to determine the range of the output
than <code>density_XXX(n = 2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"density"</code>, mimicking the output format of
<code><a href="stats.html#topic+density">stats::density()</a></code>, with the following components:
</p>

<ul>
<li> <p><code>x</code>: The grid of points at which the density was estimated.
</p>
</li>
<li> <p><code>y</code>: The estimated density values.
</p>
</li>
<li> <p><code>bw</code>: The bandwidth.
</p>
</li>
<li> <p><code>n</code>: The sample size of the <code>x</code> input argument.
</p>
</li>
<li> <p><code>call</code>: The call used to produce the result, as a quoted expression.
</p>
</li>
<li> <p><code>data.name</code>: The deparsed name of the <code>x</code> input argument.
</p>
</li>
<li> <p><code>has.na</code>: Always <code>FALSE</code> (for compatibility).
</p>
</li>
<li> <p><code>cdf</code>: Values of the (possibly weighted) empirical cumulative distribution
function at <code>x</code>. See <code><a href="#topic+weighted_ecdf">weighted_ecdf()</a></code>.
</p>
</li></ul>

<p>This allows existing methods for density objects, like <code><a href="base.html#topic+print">print()</a></code> and <code><a href="base.html#topic+plot">plot()</a></code>, to work if desired.
This output format (and in particular, the <code>x</code> and <code>y</code> components) is also
the format expected by the <code>density</code> argument of the <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code>
and the <code><a href="#topic+smooth_density">smooth_</a></code> family of functions.
</p>


<h3>References</h3>

<p>Cooke, P. (1979). Statistical inference for bounds of random variables.
<em>Biometrika</em> 66(2), 367&ndash;374. <a href="https://doi.org/10.1093/biomet/66.2.367">doi:10.1093/biomet/66.2.367</a>.
</p>
<p>Loh, W. Y. (1984). Estimating an endpoint of a distribution with resampling
methods. <em>The Annals of Statistics</em> 12(4), 1543&ndash;1550. <a href="https://doi.org/10.1214/aos/1176346811">doi:10.1214/aos/1176346811</a>
</p>


<h3>See Also</h3>

<p>Other density estimators: 
<code><a href="#topic+density_histogram">density_histogram</a>()</code>,
<code><a href="#topic+density_unbounded">density_unbounded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
library(ggplot2)

# For compatibility with existing code, the return type of density_bounded()
# is the same as stats::density(), ...
set.seed(123)
x = rbeta(5000, 1, 3)
d = density_bounded(x)
d

# ... thus, while designed for use with the `density` argument of
# stat_slabinterval(), output from density_bounded() can also be used with
# base::plot():
plot(d)

# here we'll use the same data as above, but pick either density_bounded()
# or density_unbounded() (which is equivalent to stats::density()). Notice
# how the bounded density (green) is biased near the boundary of the support,
# while the unbounded density is not.
data.frame(x) %&gt;%
  ggplot() +
  stat_slab(
    aes(xdist = dist), data = data.frame(dist = dist_beta(1, 3)),
    alpha = 0.25
  ) +
  stat_slab(aes(x), density = "bounded", fill = NA, color = "#d95f02", alpha = 0.5) +
  stat_slab(aes(x), density = "unbounded", fill = NA, color = "#1b9e77", alpha = 0.5) +
  scale_thickness_shared() +
  theme_ggdist()

# We can also supply arguments to the density estimators by using their
# full function names instead of the string suffix; e.g. we can supply
# the exact bounds of c(0,1) rather than using the bounds of the data.
data.frame(x) %&gt;%
  ggplot() +
  stat_slab(
    aes(xdist = dist), data = data.frame(dist = dist_beta(1, 3)),
    alpha = 0.25
  ) +
  stat_slab(
    aes(x), fill = NA, color = "#d95f02", alpha = 0.5,
    density = density_bounded(bounds = c(0,1))
  ) +
  scale_thickness_shared() +
  theme_ggdist()
</code></pre>

<hr>
<h2 id='density_histogram'>Histogram density estimator</h2><span id='topic+density_histogram'></span>

<h3>Description</h3>

<p>Histogram density estimator.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_histogram(
  x,
  weights = NULL,
  breaks = "Scott",
  align = "none",
  outline_bars = FALSE,
  na.rm = FALSE,
  ...,
  range_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_histogram_+3A_x">x</code></td>
<td>
<p>numeric vector containing a sample to compute a density estimate for.</p>
</td></tr>
<tr><td><code id="density_histogram_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights to apply to <code>x</code>.</p>
</td></tr>
<tr><td><code id="density_histogram_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="density_histogram_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="density_histogram_+3A_outline_bars">outline_bars</code></td>
<td>
<p>Should outlines in between the bars (i.e. density values of
0) be included?</p>
</td></tr>
<tr><td><code id="density_histogram_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing (<code>NA</code>) values in <code>x</code> be removed?</p>
</td></tr>
<tr><td><code id="density_histogram_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
<tr><td><code id="density_histogram_+3A_range_only">range_only</code></td>
<td>
<p>If <code>TRUE</code>, the range of the output of this density estimator
is computed and is returned in the <code style="white-space: pre;">&#8288;$x&#8288;</code> element of the result, and <code>c(NA, NA)</code>
is returned in <code style="white-space: pre;">&#8288;$y&#8288;</code>. This gives a faster way to determine the range of the output
than <code>density_XXX(n = 2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"density"</code>, mimicking the output format of
<code><a href="stats.html#topic+density">stats::density()</a></code>, with the following components:
</p>

<ul>
<li> <p><code>x</code>: The grid of points at which the density was estimated.
</p>
</li>
<li> <p><code>y</code>: The estimated density values.
</p>
</li>
<li> <p><code>bw</code>: The bandwidth.
</p>
</li>
<li> <p><code>n</code>: The sample size of the <code>x</code> input argument.
</p>
</li>
<li> <p><code>call</code>: The call used to produce the result, as a quoted expression.
</p>
</li>
<li> <p><code>data.name</code>: The deparsed name of the <code>x</code> input argument.
</p>
</li>
<li> <p><code>has.na</code>: Always <code>FALSE</code> (for compatibility).
</p>
</li>
<li> <p><code>cdf</code>: Values of the (possibly weighted) empirical cumulative distribution
function at <code>x</code>. See <code><a href="#topic+weighted_ecdf">weighted_ecdf()</a></code>.
</p>
</li></ul>

<p>This allows existing methods for density objects, like <code><a href="base.html#topic+print">print()</a></code> and <code><a href="base.html#topic+plot">plot()</a></code>, to work if desired.
This output format (and in particular, the <code>x</code> and <code>y</code> components) is also
the format expected by the <code>density</code> argument of the <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code>
and the <code><a href="#topic+smooth_density">smooth_</a></code> family of functions.
</p>


<h3>See Also</h3>

<p>Other density estimators: 
<code><a href="#topic+density_bounded">density_bounded</a>()</code>,
<code><a href="#topic+density_unbounded">density_unbounded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
library(ggplot2)

# For compatibility with existing code, the return type of density_unbounded()
# is the same as stats::density(), ...
set.seed(123)
x = rbeta(5000, 1, 3)
d = density_histogram(x)
d

# ... thus, while designed for use with the `density` argument of
# stat_slabinterval(), output from density_histogram() can also be used with
# base::plot():
plot(d)

# here we'll use the same data as above with stat_slab():
data.frame(x) %&gt;%
  ggplot() +
  stat_slab(
    aes(xdist = dist), data = data.frame(dist = dist_beta(1, 3)),
    alpha = 0.25
  ) +
  stat_slab(aes(x), density = "histogram", fill = NA, color = "#d95f02", alpha = 0.5) +
  scale_thickness_shared() +
  theme_ggdist()
</code></pre>

<hr>
<h2 id='density_unbounded'>Unbounded density estimator</h2><span id='topic+density_unbounded'></span>

<h3>Description</h3>

<p>Unbounded density estimator using <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_unbounded(
  x,
  weights = NULL,
  n = 512,
  bandwidth = "dpi",
  adjust = 1,
  kernel = "gaussian",
  trim = FALSE,
  adapt = 1,
  na.rm = FALSE,
  ...,
  range_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_unbounded_+3A_x">x</code></td>
<td>
<p>numeric vector containing a sample to compute a density estimate for.</p>
</td></tr>
<tr><td><code id="density_unbounded_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights to apply to <code>x</code>.</p>
</td></tr>
<tr><td><code id="density_unbounded_+3A_n">n</code></td>
<td>
<p>numeric: the number of grid points to evaluate the density estimator at.</p>
</td></tr>
<tr><td><code id="density_unbounded_+3A_bandwidth">bandwidth</code></td>
<td>
<p>bandwidth of the density estimator. One of:
</p>

<ul>
<li><p> a numeric: the bandwidth, as the standard deviation of the kernel
</p>
</li>
<li><p> a function: a function taking <code>x</code> (the sample) and returning the bandwidth
</p>
</li>
<li><p> a string: the suffix of the name of a function starting with <code>"bandwidth_"</code> that
will be used to determine the bandwidth. See <a href="#topic+bandwidth">bandwidth</a> for a list.
</p>
</li></ul>
</td></tr>
<tr><td><code id="density_unbounded_+3A_adjust">adjust</code></td>
<td>
<p>numeric: the bandwidth for the density estimator is multiplied
by this value. See <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="density_unbounded_+3A_kernel">kernel</code></td>
<td>
<p>string: the smoothing kernel to be used. This must partially
match one of <code>"gaussian"</code>, <code>"rectangular"</code>, <code>"triangular"</code>, <code>"epanechnikov"</code>,
<code>"biweight"</code>, <code>"cosine"</code>, or <code>"optcosine"</code>. See <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="density_unbounded_+3A_trim">trim</code></td>
<td>
<p>Should the density estimate be trimmed to the bounds of the data?</p>
</td></tr>
<tr><td><code id="density_unbounded_+3A_adapt">adapt</code></td>
<td>
<p>(<strong>very experimental</strong>) The name and interpretation of this argument
are subject to change without notice. Positive integer. If <code>adapt &gt; 1</code>, uses
an adaptive approach to calculate the density. First, uses the
adaptive bandwidth algorithm of Abramson (1982) to determine local (pointwise)
bandwidths, then groups these bandwidths into <code>adapt</code> groups, then calculates
and sums the densities from each group. You can set this to a very large number
(e.g. <code>Inf</code>) for a fully adaptive approach, but this will be very slow; typically
something around 100 yields nearly identical results.</p>
</td></tr>
<tr><td><code id="density_unbounded_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing (<code>NA</code>) values in <code>x</code> be removed?</p>
</td></tr>
<tr><td><code id="density_unbounded_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
<tr><td><code id="density_unbounded_+3A_range_only">range_only</code></td>
<td>
<p>If <code>TRUE</code>, the range of the output of this density estimator
is computed and is returned in the <code style="white-space: pre;">&#8288;$x&#8288;</code> element of the result, and <code>c(NA, NA)</code>
is returned in <code style="white-space: pre;">&#8288;$y&#8288;</code>. This gives a faster way to determine the range of the output
than <code>density_XXX(n = 2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"density"</code>, mimicking the output format of
<code><a href="stats.html#topic+density">stats::density()</a></code>, with the following components:
</p>

<ul>
<li> <p><code>x</code>: The grid of points at which the density was estimated.
</p>
</li>
<li> <p><code>y</code>: The estimated density values.
</p>
</li>
<li> <p><code>bw</code>: The bandwidth.
</p>
</li>
<li> <p><code>n</code>: The sample size of the <code>x</code> input argument.
</p>
</li>
<li> <p><code>call</code>: The call used to produce the result, as a quoted expression.
</p>
</li>
<li> <p><code>data.name</code>: The deparsed name of the <code>x</code> input argument.
</p>
</li>
<li> <p><code>has.na</code>: Always <code>FALSE</code> (for compatibility).
</p>
</li>
<li> <p><code>cdf</code>: Values of the (possibly weighted) empirical cumulative distribution
function at <code>x</code>. See <code><a href="#topic+weighted_ecdf">weighted_ecdf()</a></code>.
</p>
</li></ul>

<p>This allows existing methods for density objects, like <code><a href="base.html#topic+print">print()</a></code> and <code><a href="base.html#topic+plot">plot()</a></code>, to work if desired.
This output format (and in particular, the <code>x</code> and <code>y</code> components) is also
the format expected by the <code>density</code> argument of the <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code>
and the <code><a href="#topic+smooth_density">smooth_</a></code> family of functions.
</p>


<h3>See Also</h3>

<p>Other density estimators: 
<code><a href="#topic+density_bounded">density_bounded</a>()</code>,
<code><a href="#topic+density_histogram">density_histogram</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
library(ggplot2)

# For compatibility with existing code, the return type of density_unbounded()
# is the same as stats::density(), ...
set.seed(123)
x = rbeta(5000, 1, 3)
d = density_unbounded(x)
d

# ... thus, while designed for use with the `density` argument of
# stat_slabinterval(), output from density_unbounded() can also be used with
# base::plot():
plot(d)

# here we'll use the same data as above, but pick either density_bounded()
# or density_unbounded() (which is equivalent to stats::density()). Notice
# how the bounded density (green) is biased near the boundary of the support,
# while the unbounded density is not.
data.frame(x) %&gt;%
  ggplot() +
  stat_slab(
    aes(xdist = dist), data = data.frame(dist = dist_beta(1, 3)),
    alpha = 0.25
  ) +
  stat_slab(aes(x), density = "bounded", fill = NA, color = "#d95f02", alpha = 0.5) +
  stat_slab(aes(x), density = "unbounded", fill = NA, color = "#1b9e77", alpha = 0.5) +
  scale_thickness_shared() +
  theme_ggdist()
</code></pre>

<hr>
<h2 id='find_dotplot_binwidth'>Dynamically select a good bin width for a dotplot</h2><span id='topic+find_dotplot_binwidth'></span>

<h3>Description</h3>

<p>Searches for a nice-looking bin width to use to draw a dotplot such that
the height of the dotplot fits within a given space (<code>maxheight</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dotplot_binwidth(
  x,
  maxheight,
  heightratio = 1,
  stackratio = 1,
  layout = c("bin", "weave", "hex", "swarm", "bar")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_dotplot_binwidth_+3A_x">x</code></td>
<td>
<p>numeric vector of values</p>
</td></tr>
<tr><td><code id="find_dotplot_binwidth_+3A_maxheight">maxheight</code></td>
<td>
<p>maximum height of the dotplot</p>
</td></tr>
<tr><td><code id="find_dotplot_binwidth_+3A_heightratio">heightratio</code></td>
<td>
<p>ratio of bin width to dot height</p>
</td></tr>
<tr><td><code id="find_dotplot_binwidth_+3A_stackratio">stackratio</code></td>
<td>
<p>ratio of dot height to vertical distance between dot
centers</p>
</td></tr>
<tr><td><code id="find_dotplot_binwidth_+3A_layout">layout</code></td>
<td>
<p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This dynamic bin selection algorithm uses a binary search over the number of
bins to find a bin width such that if the input data (<code>x</code>) is binned
using a Wilkinson-style dotplot algorithm the height of the tallest bin
will be less than <code>maxheight</code>.
</p>
<p>This algorithm is used by <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> (and its variants) to automatically
select bin widths. Unless you are manually implementing you own dotplot <code><a href="grid.html#topic+grob">grob</a></code>
or <code>geom</code>, you probably do not need to use this function directly
</p>


<h3>Value</h3>

<p>A suitable bin width such that a dotplot created with this bin width
and <code>heightratio</code> should have its tallest bin be less than or equal to <code>maxheight</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bin_dots">bin_dots()</a></code> for an algorithm can bin dots using bin widths selected
by this function; <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for geometries that use
these algorithms to create dotplots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

x = qnorm(ppoints(20))
binwidth = find_dotplot_binwidth(x, maxheight = 4, heightratio = 1)
binwidth

bin_df = bin_dots(x = x, y = 0, binwidth = binwidth, heightratio = 1)
bin_df

# we can manually plot the binning above, though this is only recommended
# if you are using find_dotplot_binwidth() and bin_dots() to build your own
# grob. For practical use it is much easier to use geom_dots(), which will
# automatically select good bin widths for you (and which uses
# find_dotplot_binwidth() and bin_dots() internally)
bin_df %&gt;%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 4) +
  coord_fixed()

</code></pre>

<hr>
<h2 id='geom_blur_dots'>Blurry dot plot (geom)</h2><span id='topic+geom_blur_dots'></span>

<h3>Description</h3>

<p>Variant of <code><a href="#topic+geom_dots">geom_dots()</a></code> for creating blurry dotplots. Accepts an <code>sd</code>
aesthetic that gives the standard deviation of the blur applied to the dots.
Requires a graphics engine supporting radial gradients. Unlike <code><a href="#topic+geom_dots">geom_dots()</a></code>,
all dots must be circular, so this geom does not support the <code>shape</code> aesthetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_blur_dots(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  blur = "gaussian",
  binwidth = NA,
  dotsize = 1.07,
  stackratio = 1,
  layout = "bin",
  overlaps = "nudge",
  smooth = "none",
  overflow = "warn",
  verbose = FALSE,
  orientation = NA,
  subguide = "none",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_blur_dots_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_blur">blur</code></td>
<td>
<p>Blur function to apply to dots.
One of: </p>

<ul>
<li><p> A function that takes a numeric vector of distances from the dot
center, the dot radius, and the standard deviation of the blur and returns
a vector of opacities in <code class="reqn">[0, 1]</code>, such as <code><a href="#topic+blur_gaussian">blur_gaussian()</a></code>
or <code><a href="#topic+blur_interval">blur_interval()</a></code>.
</p>
</li>
<li><p> A string indicating what blur function to use, as the suffix to a
function name starting with <code>blur_</code>; e.g. <code>"gaussian"</code> (the default)
applies <code><a href="#topic+blur_gaussian">blur_gaussian()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_binwidth">binwidth</code></td>
<td>
<p>The bin width to use for laying out the dots.
One of:
</p>

<ul>
<li> <p><code>NA</code> (the default): Dynamically select the bin width based on the
size of the plot when drawn. This will pick a <code>binwidth</code> such that the
tallest stack of dots is at most <code>scale</code> in height (ideally exactly <code>scale</code>
in height, though this is not guaranteed).
</p>
</li>
<li><p> A length-1 (scalar) numeric or <a href="grid.html#topic+unit">unit</a> object giving the exact bin width.
</p>
</li>
<li><p> A length-2 (vector) numeric or <a href="grid.html#topic+unit">unit</a> object giving the minimum and maximum
desired bin width. The bin width will be dynamically selected within
these bounds.
</p>
</li></ul>

<p>If the value is numeric, it is assumed to be in units of data. The bin width
(or its bounds) can also be specified using <code><a href="grid.html#topic+unit">unit()</a></code>, which may be useful if
it is desired that the dots be a certain point size or a certain percentage of
the width/height of the viewport. For example, <code>unit(0.1, "npc")</code> would make
dots that are <em>exactly</em> 10% of the viewport size along whichever dimension the
dotplot is drawn; <code>unit(c(0, 0.1), "npc")</code> would make dots that are <em>at most</em>
10% of the viewport size (while still ensuring the tallest stack is less than
or equal to <code>scale</code>).</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_dotsize">dotsize</code></td>
<td>
<p>The width of the dots relative to the <code>binwidth</code>. The default,
<code>1.07</code>, makes dots be just a bit wider than the bin width, which is a
manually-tuned parameter that tends to work well with the default circular
shape, preventing gaps between bins from appearing to be too large visually
(as might arise from dots being <em>precisely</em> the <code>binwidth</code>). If it is desired
to have dots be precisely the <code>binwidth</code>, set <code>dotsize = 1</code>.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_stackratio">stackratio</code></td>
<td>
<p>The distance between the center of the dots in the same
stack relative to the dot height. The default, <code>1</code>, makes dots in the same
stack just touch each other.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_layout">layout</code></td>
<td>
<p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_overlaps">overlaps</code></td>
<td>
<p>How to handle overlapping dots or bins in the <code>"bin"</code>,
<code>"weave"</code>, and <code>"hex"</code> layouts (dots never overlap in the <code>"swarm"</code> or <code>"bar"</code> layouts).
For the purposes of this argument, dots are only considered to be overlapping
if they would be overlapping when <code>dotsize = 1</code> and <code>stackratio = 1</code>; i.e.
if you set those arguments to other values, overlaps may still occur.
One of: </p>

<ul>
<li> <p><code>"keep"</code>: leave overlapping dots as they are. Dots may overlap
(usually only slightly) in the <code>"bin"</code>, <code>"weave"</code>, and <code>"hex"</code> layouts.
</p>
</li>
<li> <p><code>"nudge"</code>: nudge overlapping dots out of the way. Overlaps are avoided
using a constrained optimization which minimizes the squared distance of
dots to their desired positions, subject to the constraint that adjacent
dots do not overlap.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_smooth">smooth</code></td>
<td>
<p>Smoother to apply to dot positions.
One of:
</p>

<ul>
<li><p> A function that takes a numeric vector of dot positions and returns a
smoothed version of that vector, such as <code>smooth_bounded()</code>,
<code>smooth_unbounded()</code>, smooth_discrete()<code style="white-space: pre;">&#8288;, or &#8288;</code>smooth_bar()'.
</p>
</li>
<li><p> A string indicating what smoother to use, as the suffix to a function
name starting with <code>smooth_</code>; e.g. <code>"none"</code> (the default) applies
<code>smooth_none()</code>, which simply returns the given vector without
applying smoothing.
</p>
</li></ul>

<p>Smoothing is most effective when the smoother is matched to the support of
the distribution; e.g. using <code>smooth_bounded(bounds = ...)</code>.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_overflow">overflow</code></td>
<td>
<p>How to handle overflow of dots beyond the extent of the geom
when a minimum <code>binwidth</code> (or an exact <code>binwidth</code>) is supplied.
One of:
</p>

<ul>
<li> <p><code>"keep"</code>: Keep the overflow, drawing dots outside the geom bounds.
</p>
</li>
<li> <p><code>"warn"</code>: Keep the overflow, but produce a warning suggesting solutions,
such as setting <code>binwidth = NA</code> or <code>overflow = "compress"</code>.
</p>
</li>
<li> <p><code>"compress"</code>: Compress the layout. Reduces the <code>binwidth</code> to the size necessary
to keep the dots within bounds, then adjusts <code>stackratio</code> and <code>dotsize</code> so that
the apparent dot size is the user-specified minimum <code>binwidth</code> times the
user-specified <code>dotsize</code>.
</p>
</li></ul>

<p>If you find the default layout has dots that are too small, and you are okay
with dots overlapping, consider setting <code>overflow = "compress"</code> and supplying
an exact or minimum dot size using <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print out the bin width of the dotplot. Can be useful
if you want to start from an automatically-selected bin width and then adjust it
manually. Bin width is printed both as data units and as normalized parent
coordinates or <code>"npc"</code>s (see <code><a href="grid.html#topic+unit">unit()</a></code>). Note that if you just want to scale the
selected bin width to fit within a desired area, it is probably easier to use
<code>scale</code> than to copy and scale <code>binwidth</code> manually, and if you just want to
provide constraints on the bin width, you can pass a length-2 vector to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_subguide">subguide</code></td>
<td>
<p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_blur_dots_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>dots</em> family of stats and geoms are similar to <code><a href="ggplot2.html#topic+geom_dotplot">geom_dotplot()</a></code> but with a number of differences:
</p>

<ul>
<li><p> Dots geoms act like slabs in <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and can be given x positions (or y positions when
in a horizontal orientation).
</p>
</li>
<li><p> Given the available space to lay out dots, the dots geoms will automatically determine how many bins to
use to fit the available space.
</p>
</li>
<li><p> Dots geoms use a dynamic layout algorithm that lays out dots from the center out if the input data are
symmetrical, guaranteeing that symmetrical data results in a symmetrical plot. The layout algorithm also prevents
dots from overlapping each other.
</p>
</li>
<li><p> The shape of the dots in these geoms can be changed using the <code>slab_shape</code> aesthetic (when using the
<code>dotsinterval</code> family) or the <code>shape</code> or <code>slab_shape</code> aesthetic (when using the <code>dots</code> family)
</p>
</li></ul>

<p>Stats and geoms in this family include:
</p>

<ul>
<li> <p><code><a href="#topic+geom_dots">geom_dots()</a></code>: dotplots on raw data. Ensures the dotplot fits within available space by reducing the size
of the dots automatically (may result in very small dots).
</p>
</li>
<li> <p><code><a href="#topic+geom_swarm">geom_swarm()</a></code> and <code><a href="#topic+geom_weave">geom_weave()</a></code>: dotplots on raw data with defaults intended to create &quot;beeswarm&quot; plots.
Used <code>side = "both"</code> by default, and sets the default dot size to the same size as <code><a href="ggplot2.html#topic+geom_point">geom_point()</a></code>
(<code>binwidth = unit(1.5, "mm")</code>), allowing dots to overlap instead of getting very small.
</p>
</li>
<li> <p><code><a href="#topic+stat_dots">stat_dots()</a></code>: dotplots on raw data, <span class="pkg">distributional</span> objects, and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s
</p>
</li>
<li> <p><code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>: dotplot + interval plots on raw data with already-calculated
intervals (rarely useful directly).
</p>
</li>
<li> <p><code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>: dotplot + interval plots on raw data, <span class="pkg">distributional</span> objects,
and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s (will calculate intervals for you).
</p>
</li>
<li> <p><code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>: blurry dotplots that allow the standard deviation of a blur applied to
each dot to be specified using the <code>sd</code> aesthetic.
</p>
</li>
<li> <p><code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code>: blurry dotplots of quantiles using the Monte Carlo Standard Error of each quantile.
</p>
</li></ul>

<p><code><a href="#topic+stat_dots">stat_dots()</a></code> and <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>, when used with the <code>quantiles</code> argument,
are particularly useful for constructing quantile dotplots, which can be an effective way to communicate uncertainty
using a frequency framing that may be easier for laypeople to understand (Kay et al. 2016, Fernandes et al. 2018).
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a blurry dot geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The dots+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>dots</strong> (aka the <strong>slab</strong>), the
<strong>point</strong>, and the <strong>interval</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Dots-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>sd</code>: The standard deviation (in data units) of the blur associated with each dot.
</p>
</li>
<li><p><code>order</code>: The order in which data points are stacked within bins. Can be used to create the effect of
&quot;stacked&quot; dots by ordering dots according to a discrete variable. If omitted (<code>NULL</code>), the
value of the data points themselves are used to determine stacking order. Only applies when
<code>layout</code> is <code>"bin"</code> or <code>"hex"</code>, as the other layout methods fully determine both <em>x</em> and <em>y</em> positions.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li>
<li><p><code>slab_shape</code>: Override for <code>shape</code>: the shape of the dots used to draw the dotplot slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("dotsinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>References</h3>

<p>Kay, M., Kola, T., Hullman, J. R., &amp; Munson, S. A. (2016). When (ish) is My Bus? User-centered Visualizations
of Uncertainty in Everyday, Mobile Predictive Systems. <em>Conference on Human Factors
in Computing Systems - CHI '16</em>, 5092&ndash;5103. <a href="https://doi.org/10.1145/2858036.2858558">doi:10.1145/2858036.2858558</a>.
</p>
<p>Fernandes, M., Walls, L., Munson, S., Hullman, J., &amp; Kay, M. (2018). Uncertainty Displays Using Quantile Dotplots
or CDFs Improve Transit Decision-Making. <em>Conference on Human Factors in Computing Systems - CHI '18</em>.
<a href="https://doi.org/10.1145/3173574.3173718">doi:10.1145/3173574.3173718</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for the geometry this shortcut is based on.
</p>
<p>See <code>vignette("dotsinterval")</code> for a variety of examples of use.
</p>
<p>Other dotsinterval geoms: 
<code><a href="#topic+geom_dots">geom_dots</a>()</code>,
<code><a href="#topic+geom_dotsinterval">geom_dotsinterval</a>()</code>,
<code><a href="#topic+geom_swarm">geom_swarm</a>()</code>,
<code><a href="#topic+geom_weave">geom_weave</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

set.seed(1234)
x = rnorm(1000)

# manually calculate quantiles and their MCSE
# this could also be done more succinctly with stat_mcse_dots()
p = ppoints(100)
df = data.frame(
  q = quantile(x, p),
  se = posterior::mcse_quantile(x, p)
)

df %&gt;%
  ggplot(aes(x = q, sd = se)) +
  geom_blur_dots()

df %&gt;%
  ggplot(aes(x = q, sd = se)) +
  # or blur = blur_interval(.width = .95) to set the interval width
  geom_blur_dots(blur = "interval")

</code></pre>

<hr>
<h2 id='geom_dots'>Dot plot (shortcut geom)</h2><span id='topic+geom_dots'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for creating dot plots.
Geoms based on <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> create dotplots that automatically
ensure the plot fits within the available space.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>geom_dotsinterval(
  show_point = FALSE,
  show_interval = FALSE
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dots(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  binwidth = NA,
  dotsize = 1.07,
  stackratio = 1,
  layout = "bin",
  overlaps = "nudge",
  smooth = "none",
  overflow = "warn",
  verbose = FALSE,
  orientation = NA,
  subguide = "none",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_dots_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_binwidth">binwidth</code></td>
<td>
<p>The bin width to use for laying out the dots.
One of:
</p>

<ul>
<li> <p><code>NA</code> (the default): Dynamically select the bin width based on the
size of the plot when drawn. This will pick a <code>binwidth</code> such that the
tallest stack of dots is at most <code>scale</code> in height (ideally exactly <code>scale</code>
in height, though this is not guaranteed).
</p>
</li>
<li><p> A length-1 (scalar) numeric or <a href="grid.html#topic+unit">unit</a> object giving the exact bin width.
</p>
</li>
<li><p> A length-2 (vector) numeric or <a href="grid.html#topic+unit">unit</a> object giving the minimum and maximum
desired bin width. The bin width will be dynamically selected within
these bounds.
</p>
</li></ul>

<p>If the value is numeric, it is assumed to be in units of data. The bin width
(or its bounds) can also be specified using <code><a href="grid.html#topic+unit">unit()</a></code>, which may be useful if
it is desired that the dots be a certain point size or a certain percentage of
the width/height of the viewport. For example, <code>unit(0.1, "npc")</code> would make
dots that are <em>exactly</em> 10% of the viewport size along whichever dimension the
dotplot is drawn; <code>unit(c(0, 0.1), "npc")</code> would make dots that are <em>at most</em>
10% of the viewport size (while still ensuring the tallest stack is less than
or equal to <code>scale</code>).</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_dotsize">dotsize</code></td>
<td>
<p>The width of the dots relative to the <code>binwidth</code>. The default,
<code>1.07</code>, makes dots be just a bit wider than the bin width, which is a
manually-tuned parameter that tends to work well with the default circular
shape, preventing gaps between bins from appearing to be too large visually
(as might arise from dots being <em>precisely</em> the <code>binwidth</code>). If it is desired
to have dots be precisely the <code>binwidth</code>, set <code>dotsize = 1</code>.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_stackratio">stackratio</code></td>
<td>
<p>The distance between the center of the dots in the same
stack relative to the dot height. The default, <code>1</code>, makes dots in the same
stack just touch each other.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_layout">layout</code></td>
<td>
<p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_dots_+3A_overlaps">overlaps</code></td>
<td>
<p>How to handle overlapping dots or bins in the <code>"bin"</code>,
<code>"weave"</code>, and <code>"hex"</code> layouts (dots never overlap in the <code>"swarm"</code> or <code>"bar"</code> layouts).
For the purposes of this argument, dots are only considered to be overlapping
if they would be overlapping when <code>dotsize = 1</code> and <code>stackratio = 1</code>; i.e.
if you set those arguments to other values, overlaps may still occur.
One of: </p>

<ul>
<li> <p><code>"keep"</code>: leave overlapping dots as they are. Dots may overlap
(usually only slightly) in the <code>"bin"</code>, <code>"weave"</code>, and <code>"hex"</code> layouts.
</p>
</li>
<li> <p><code>"nudge"</code>: nudge overlapping dots out of the way. Overlaps are avoided
using a constrained optimization which minimizes the squared distance of
dots to their desired positions, subject to the constraint that adjacent
dots do not overlap.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_dots_+3A_smooth">smooth</code></td>
<td>
<p>Smoother to apply to dot positions.
One of:
</p>

<ul>
<li><p> A function that takes a numeric vector of dot positions and returns a
smoothed version of that vector, such as <code>smooth_bounded()</code>,
<code>smooth_unbounded()</code>, smooth_discrete()<code style="white-space: pre;">&#8288;, or &#8288;</code>smooth_bar()'.
</p>
</li>
<li><p> A string indicating what smoother to use, as the suffix to a function
name starting with <code>smooth_</code>; e.g. <code>"none"</code> (the default) applies
<code>smooth_none()</code>, which simply returns the given vector without
applying smoothing.
</p>
</li></ul>

<p>Smoothing is most effective when the smoother is matched to the support of
the distribution; e.g. using <code>smooth_bounded(bounds = ...)</code>.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_overflow">overflow</code></td>
<td>
<p>How to handle overflow of dots beyond the extent of the geom
when a minimum <code>binwidth</code> (or an exact <code>binwidth</code>) is supplied.
One of:
</p>

<ul>
<li> <p><code>"keep"</code>: Keep the overflow, drawing dots outside the geom bounds.
</p>
</li>
<li> <p><code>"warn"</code>: Keep the overflow, but produce a warning suggesting solutions,
such as setting <code>binwidth = NA</code> or <code>overflow = "compress"</code>.
</p>
</li>
<li> <p><code>"compress"</code>: Compress the layout. Reduces the <code>binwidth</code> to the size necessary
to keep the dots within bounds, then adjusts <code>stackratio</code> and <code>dotsize</code> so that
the apparent dot size is the user-specified minimum <code>binwidth</code> times the
user-specified <code>dotsize</code>.
</p>
</li></ul>

<p>If you find the default layout has dots that are too small, and you are okay
with dots overlapping, consider setting <code>overflow = "compress"</code> and supplying
an exact or minimum dot size using <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print out the bin width of the dotplot. Can be useful
if you want to start from an automatically-selected bin width and then adjust it
manually. Bin width is printed both as data units and as normalized parent
coordinates or <code>"npc"</code>s (see <code><a href="grid.html#topic+unit">unit()</a></code>). Note that if you just want to scale the
selected bin width to fit within a desired area, it is probably easier to use
<code>scale</code> than to copy and scale <code>binwidth</code> manually, and if you just want to
provide constraints on the bin width, you can pass a length-2 vector to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_subguide">subguide</code></td>
<td>
<p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_dots_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_dots_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>dots</em> family of stats and geoms are similar to <code><a href="ggplot2.html#topic+geom_dotplot">geom_dotplot()</a></code> but with a number of differences:
</p>

<ul>
<li><p> Dots geoms act like slabs in <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and can be given x positions (or y positions when
in a horizontal orientation).
</p>
</li>
<li><p> Given the available space to lay out dots, the dots geoms will automatically determine how many bins to
use to fit the available space.
</p>
</li>
<li><p> Dots geoms use a dynamic layout algorithm that lays out dots from the center out if the input data are
symmetrical, guaranteeing that symmetrical data results in a symmetrical plot. The layout algorithm also prevents
dots from overlapping each other.
</p>
</li>
<li><p> The shape of the dots in these geoms can be changed using the <code>slab_shape</code> aesthetic (when using the
<code>dotsinterval</code> family) or the <code>shape</code> or <code>slab_shape</code> aesthetic (when using the <code>dots</code> family)
</p>
</li></ul>

<p>Stats and geoms in this family include:
</p>

<ul>
<li> <p><code><a href="#topic+geom_dots">geom_dots()</a></code>: dotplots on raw data. Ensures the dotplot fits within available space by reducing the size
of the dots automatically (may result in very small dots).
</p>
</li>
<li> <p><code><a href="#topic+geom_swarm">geom_swarm()</a></code> and <code><a href="#topic+geom_weave">geom_weave()</a></code>: dotplots on raw data with defaults intended to create &quot;beeswarm&quot; plots.
Used <code>side = "both"</code> by default, and sets the default dot size to the same size as <code><a href="ggplot2.html#topic+geom_point">geom_point()</a></code>
(<code>binwidth = unit(1.5, "mm")</code>), allowing dots to overlap instead of getting very small.
</p>
</li>
<li> <p><code><a href="#topic+stat_dots">stat_dots()</a></code>: dotplots on raw data, <span class="pkg">distributional</span> objects, and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s
</p>
</li>
<li> <p><code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>: dotplot + interval plots on raw data with already-calculated
intervals (rarely useful directly).
</p>
</li>
<li> <p><code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>: dotplot + interval plots on raw data, <span class="pkg">distributional</span> objects,
and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s (will calculate intervals for you).
</p>
</li>
<li> <p><code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>: blurry dotplots that allow the standard deviation of a blur applied to
each dot to be specified using the <code>sd</code> aesthetic.
</p>
</li>
<li> <p><code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code>: blurry dotplots of quantiles using the Monte Carlo Standard Error of each quantile.
</p>
</li></ul>

<p><code><a href="#topic+stat_dots">stat_dots()</a></code> and <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>, when used with the <code>quantiles</code> argument,
are particularly useful for constructing quantile dotplots, which can be an effective way to communicate uncertainty
using a frequency framing that may be easier for laypeople to understand (Kay et al. 2016, Fernandes et al. 2018).
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a dot geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The dots+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>dots</strong> (aka the <strong>slab</strong>), the
<strong>point</strong>, and the <strong>interval</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Dots-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>family</code>: The font family used to draw the dots.
</p>
</li>
<li><p><code>order</code>: The order in which data points are stacked within bins. Can be used to create the effect of
&quot;stacked&quot; dots by ordering dots according to a discrete variable. If omitted (<code>NULL</code>), the
value of the data points themselves are used to determine stacking order. Only applies when
<code>layout</code> is <code>"bin"</code> or <code>"hex"</code>, as the other layout methods fully determine both <em>x</em> and <em>y</em> positions.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li>
<li><p><code>slab_shape</code>: Override for <code>shape</code>: the shape of the dots used to draw the dotplot slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("dotsinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>References</h3>

<p>Kay, M., Kola, T., Hullman, J. R., &amp; Munson, S. A. (2016). When (ish) is My Bus? User-centered Visualizations
of Uncertainty in Everyday, Mobile Predictive Systems. <em>Conference on Human Factors
in Computing Systems - CHI '16</em>, 5092&ndash;5103. <a href="https://doi.org/10.1145/2858036.2858558">doi:10.1145/2858036.2858558</a>.
</p>
<p>Fernandes, M., Walls, L., Munson, S., Hullman, J., &amp; Kay, M. (2018). Uncertainty Displays Using Quantile Dotplots
or CDFs Improve Transit Decision-Making. <em>Conference on Human Factors in Computing Systems - CHI '18</em>.
<a href="https://doi.org/10.1145/3173574.3173718">doi:10.1145/3173574.3173718</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+stat_dots">stat_dots()</a></code> for the stat version, intended for
use on sample data or analytical distributions.
</p>
<p>See <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for the geometry this shortcut is based on.
</p>
<p>See <code>vignette("dotsinterval")</code> for a variety of examples of use.
</p>
<p>Other dotsinterval geoms: 
<code><a href="#topic+geom_blur_dots">geom_blur_dots</a>()</code>,
<code><a href="#topic+geom_dotsinterval">geom_dotsinterval</a>()</code>,
<code><a href="#topic+geom_swarm">geom_swarm</a>()</code>,
<code><a href="#topic+geom_weave">geom_weave</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

set.seed(12345)
df = tibble(
  g = rep(c("a", "b"), 200),
  value = rnorm(400, c(0, 3), c(0.75, 1))
)

# orientation is detected automatically based on
# which axis is discrete

df %&gt;%
  ggplot(aes(x = value, y = g)) +
  geom_dots()

df %&gt;%
  ggplot(aes(y = value, x = g)) +
  geom_dots()
</code></pre>

<hr>
<h2 id='geom_dotsinterval'>Automatic dotplot + point + interval meta-geom</h2><span id='topic+geom_dotsinterval'></span>

<h3>Description</h3>

<p>This meta-geom supports drawing combinations of dotplots, points, and intervals.
Geoms and stats based on <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> create dotplots that automatically determine a bin width that
ensures the plot fits within the available space. They also ensure dots do not overlap, and allow
the generation of quantile dotplots using the <code>quantiles</code> argument to <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>/<code><a href="#topic+stat_dots">stat_dots()</a></code>.
Generally follows the naming scheme and
arguments of the <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> family of
geoms and stats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dotsinterval(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  binwidth = NA,
  dotsize = 1.07,
  stackratio = 1,
  layout = "bin",
  overlaps = "nudge",
  smooth = "none",
  overflow = "warn",
  verbose = FALSE,
  orientation = NA,
  interval_size_domain = c(1, 6),
  interval_size_range = c(0.6, 1.4),
  fatten_point = 1.8,
  arrow = NULL,
  show_slab = TRUE,
  show_point = TRUE,
  show_interval = TRUE,
  subguide = "none",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_dotsinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_binwidth">binwidth</code></td>
<td>
<p>The bin width to use for laying out the dots.
One of:
</p>

<ul>
<li> <p><code>NA</code> (the default): Dynamically select the bin width based on the
size of the plot when drawn. This will pick a <code>binwidth</code> such that the
tallest stack of dots is at most <code>scale</code> in height (ideally exactly <code>scale</code>
in height, though this is not guaranteed).
</p>
</li>
<li><p> A length-1 (scalar) numeric or <a href="grid.html#topic+unit">unit</a> object giving the exact bin width.
</p>
</li>
<li><p> A length-2 (vector) numeric or <a href="grid.html#topic+unit">unit</a> object giving the minimum and maximum
desired bin width. The bin width will be dynamically selected within
these bounds.
</p>
</li></ul>

<p>If the value is numeric, it is assumed to be in units of data. The bin width
(or its bounds) can also be specified using <code><a href="grid.html#topic+unit">unit()</a></code>, which may be useful if
it is desired that the dots be a certain point size or a certain percentage of
the width/height of the viewport. For example, <code>unit(0.1, "npc")</code> would make
dots that are <em>exactly</em> 10% of the viewport size along whichever dimension the
dotplot is drawn; <code>unit(c(0, 0.1), "npc")</code> would make dots that are <em>at most</em>
10% of the viewport size (while still ensuring the tallest stack is less than
or equal to <code>scale</code>).</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_dotsize">dotsize</code></td>
<td>
<p>The width of the dots relative to the <code>binwidth</code>. The default,
<code>1.07</code>, makes dots be just a bit wider than the bin width, which is a
manually-tuned parameter that tends to work well with the default circular
shape, preventing gaps between bins from appearing to be too large visually
(as might arise from dots being <em>precisely</em> the <code>binwidth</code>). If it is desired
to have dots be precisely the <code>binwidth</code>, set <code>dotsize = 1</code>.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_stackratio">stackratio</code></td>
<td>
<p>The distance between the center of the dots in the same
stack relative to the dot height. The default, <code>1</code>, makes dots in the same
stack just touch each other.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_layout">layout</code></td>
<td>
<p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_overlaps">overlaps</code></td>
<td>
<p>How to handle overlapping dots or bins in the <code>"bin"</code>,
<code>"weave"</code>, and <code>"hex"</code> layouts (dots never overlap in the <code>"swarm"</code> or <code>"bar"</code> layouts).
For the purposes of this argument, dots are only considered to be overlapping
if they would be overlapping when <code>dotsize = 1</code> and <code>stackratio = 1</code>; i.e.
if you set those arguments to other values, overlaps may still occur.
One of: </p>

<ul>
<li> <p><code>"keep"</code>: leave overlapping dots as they are. Dots may overlap
(usually only slightly) in the <code>"bin"</code>, <code>"weave"</code>, and <code>"hex"</code> layouts.
</p>
</li>
<li> <p><code>"nudge"</code>: nudge overlapping dots out of the way. Overlaps are avoided
using a constrained optimization which minimizes the squared distance of
dots to their desired positions, subject to the constraint that adjacent
dots do not overlap.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_smooth">smooth</code></td>
<td>
<p>Smoother to apply to dot positions.
One of:
</p>

<ul>
<li><p> A function that takes a numeric vector of dot positions and returns a
smoothed version of that vector, such as <code>smooth_bounded()</code>,
<code>smooth_unbounded()</code>, smooth_discrete()<code style="white-space: pre;">&#8288;, or &#8288;</code>smooth_bar()'.
</p>
</li>
<li><p> A string indicating what smoother to use, as the suffix to a function
name starting with <code>smooth_</code>; e.g. <code>"none"</code> (the default) applies
<code>smooth_none()</code>, which simply returns the given vector without
applying smoothing.
</p>
</li></ul>

<p>Smoothing is most effective when the smoother is matched to the support of
the distribution; e.g. using <code>smooth_bounded(bounds = ...)</code>.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_overflow">overflow</code></td>
<td>
<p>How to handle overflow of dots beyond the extent of the geom
when a minimum <code>binwidth</code> (or an exact <code>binwidth</code>) is supplied.
One of:
</p>

<ul>
<li> <p><code>"keep"</code>: Keep the overflow, drawing dots outside the geom bounds.
</p>
</li>
<li> <p><code>"warn"</code>: Keep the overflow, but produce a warning suggesting solutions,
such as setting <code>binwidth = NA</code> or <code>overflow = "compress"</code>.
</p>
</li>
<li> <p><code>"compress"</code>: Compress the layout. Reduces the <code>binwidth</code> to the size necessary
to keep the dots within bounds, then adjusts <code>stackratio</code> and <code>dotsize</code> so that
the apparent dot size is the user-specified minimum <code>binwidth</code> times the
user-specified <code>dotsize</code>.
</p>
</li></ul>

<p>If you find the default layout has dots that are too small, and you are okay
with dots overlapping, consider setting <code>overflow = "compress"</code> and supplying
an exact or minimum dot size using <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print out the bin width of the dotplot. Can be useful
if you want to start from an automatically-selected bin width and then adjust it
manually. Bin width is printed both as data units and as normalized parent
coordinates or <code>"npc"</code>s (see <code><a href="grid.html#topic+unit">unit()</a></code>). Note that if you just want to scale the
selected bin width to fit within a desired area, it is probably easier to use
<code>scale</code> than to copy and scale <code>binwidth</code> manually, and if you just want to
provide constraints on the bin width, you can pass a length-2 vector to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_interval_size_domain">interval_size_domain</code></td>
<td>
<p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_interval_size_range">interval_size_range</code></td>
<td>
<p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_fatten_point">fatten_point</code></td>
<td>
<p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_arrow">arrow</code></td>
<td>
<p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_show_slab">show_slab</code></td>
<td>
<p>Should the slab portion of the geom be drawn?</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_show_point">show_point</code></td>
<td>
<p>Should the point portion of the geom be drawn?</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_show_interval">show_interval</code></td>
<td>
<p>Should the interval portion of the geom be drawn?</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_subguide">subguide</code></td>
<td>
<p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_dotsinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>dots</em> family of stats and geoms are similar to <code><a href="ggplot2.html#topic+geom_dotplot">geom_dotplot()</a></code> but with a number of differences:
</p>

<ul>
<li><p> Dots geoms act like slabs in <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and can be given x positions (or y positions when
in a horizontal orientation).
</p>
</li>
<li><p> Given the available space to lay out dots, the dots geoms will automatically determine how many bins to
use to fit the available space.
</p>
</li>
<li><p> Dots geoms use a dynamic layout algorithm that lays out dots from the center out if the input data are
symmetrical, guaranteeing that symmetrical data results in a symmetrical plot. The layout algorithm also prevents
dots from overlapping each other.
</p>
</li>
<li><p> The shape of the dots in these geoms can be changed using the <code>slab_shape</code> aesthetic (when using the
<code>dotsinterval</code> family) or the <code>shape</code> or <code>slab_shape</code> aesthetic (when using the <code>dots</code> family)
</p>
</li></ul>

<p>Stats and geoms in this family include:
</p>

<ul>
<li> <p><code><a href="#topic+geom_dots">geom_dots()</a></code>: dotplots on raw data. Ensures the dotplot fits within available space by reducing the size
of the dots automatically (may result in very small dots).
</p>
</li>
<li> <p><code><a href="#topic+geom_swarm">geom_swarm()</a></code> and <code><a href="#topic+geom_weave">geom_weave()</a></code>: dotplots on raw data with defaults intended to create &quot;beeswarm&quot; plots.
Used <code>side = "both"</code> by default, and sets the default dot size to the same size as <code><a href="ggplot2.html#topic+geom_point">geom_point()</a></code>
(<code>binwidth = unit(1.5, "mm")</code>), allowing dots to overlap instead of getting very small.
</p>
</li>
<li> <p><code><a href="#topic+stat_dots">stat_dots()</a></code>: dotplots on raw data, <span class="pkg">distributional</span> objects, and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s
</p>
</li>
<li> <p><code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>: dotplot + interval plots on raw data with already-calculated
intervals (rarely useful directly).
</p>
</li>
<li> <p><code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>: dotplot + interval plots on raw data, <span class="pkg">distributional</span> objects,
and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s (will calculate intervals for you).
</p>
</li>
<li> <p><code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>: blurry dotplots that allow the standard deviation of a blur applied to
each dot to be specified using the <code>sd</code> aesthetic.
</p>
</li>
<li> <p><code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code>: blurry dotplots of quantiles using the Monte Carlo Standard Error of each quantile.
</p>
</li></ul>

<p><code><a href="#topic+stat_dots">stat_dots()</a></code> and <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>, when used with the <code>quantiles</code> argument,
are particularly useful for constructing quantile dotplots, which can be an effective way to communicate uncertainty
using a frequency framing that may be easier for laypeople to understand (Kay et al. 2016, Fernandes et al. 2018).
</p>
<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> or <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a dotplot or combined dotplot+interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The dots+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>dots</strong> (aka the <strong>slab</strong>), the
<strong>point</strong>, and the <strong>interval</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Dots-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>family</code>: The font family used to draw the dots.
</p>
</li>
<li><p><code>order</code>: The order in which data points are stacked within bins. Can be used to create the effect of
&quot;stacked&quot; dots by ordering dots according to a discrete variable. If omitted (<code>NULL</code>), the
value of the data points themselves are used to determine stacking order. Only applies when
<code>layout</code> is <code>"bin"</code> or <code>"hex"</code>, as the other layout methods fully determine both <em>x</em> and <em>y</em> positions.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li>
<li><p><code>slab_shape</code>: Override for <code>shape</code>: the shape of the dots used to draw the dotplot slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("dotsinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>References</h3>

<p>Kay, M., Kola, T., Hullman, J. R., &amp; Munson, S. A. (2016). When (ish) is My Bus? User-centered Visualizations
of Uncertainty in Everyday, Mobile Predictive Systems. <em>Conference on Human Factors
in Computing Systems - CHI '16</em>, 5092&ndash;5103. <a href="https://doi.org/10.1145/2858036.2858558">doi:10.1145/2858036.2858558</a>.
</p>
<p>Fernandes, M., Walls, L., Munson, S., Hullman, J., &amp; Kay, M. (2018). Uncertainty Displays Using Quantile Dotplots
or CDFs Improve Transit Decision-Making. <em>Conference on Human Factors in Computing Systems - CHI '18</em>.
<a href="https://doi.org/10.1145/3173574.3173718">doi:10.1145/3173574.3173718</a>.
</p>


<h3>See Also</h3>

<p>See the <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> family for other
stats built on top of <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>.
See <code>vignette("dotsinterval")</code> for a variety of examples of use.
</p>
<p>Other dotsinterval geoms: 
<code><a href="#topic+geom_blur_dots">geom_blur_dots</a>()</code>,
<code><a href="#topic+geom_dots">geom_dots</a>()</code>,
<code><a href="#topic+geom_swarm">geom_swarm</a>()</code>,
<code><a href="#topic+geom_weave">geom_weave</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

set.seed(12345)
df = tibble(
  g = rep(c("a", "b"), 200),
  value = rnorm(400, c(0, 3), c(0.75, 1))
)


# orientation is detected automatically based on
# which axis is discrete

df %&gt;%
  ggplot(aes(x = value, y = g)) +
  geom_dotsinterval()

df %&gt;%
  ggplot(aes(y = value, x = g)) +
  geom_dotsinterval()


# stat_dots can summarize quantiles, creating quantile dotplots

data(RankCorr_u_tau, package = "ggdist")

RankCorr_u_tau %&gt;%
  ggplot(aes(x = u_tau, y = factor(i))) +
  stat_dots(quantiles = 100)

# color and fill aesthetics can be mapped within the geom
# dotsinterval adds an interval

RankCorr_u_tau %&gt;%
  ggplot(aes(x = u_tau, y = factor(i), fill = after_stat(x &gt; 6))) +
  stat_dotsinterval(quantiles = 100)

</code></pre>

<hr>
<h2 id='geom_interval'>Multiple-interval plot (shortcut geom)</h2><span id='topic+geom_interval'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for creating multiple-interval plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>geom_slabinterval(
  aes(
    datatype = "interval",
    side = "both"
  ),
  interval_size_range = c(1, 6),
  show_slab = FALSE,
  show_point = FALSE
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>geom_interval(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  orientation = NA,
  interval_size_range = c(1, 6),
  interval_size_domain = c(1, 6),
  arrow = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_interval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_interval_size_range">interval_size_range</code></td>
<td>
<p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_interval_size_domain">interval_size_domain</code></td>
<td>
<p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_arrow">arrow</code></td>
<td>
<p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_interval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This geom wraps <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> with defaults designed to produce
multiple-interval plots. Default aesthetic mappings are applied if the <code>.width</code> column
is present in the input data (e.g., as generated by the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions),
making this geom often more convenient than vanilla <a href="ggplot2.html#topic+ggplot2">ggplot2</a> geometries when used with
functions like <code><a href="#topic+median_qi">median_qi()</a></code>, <code><a href="#topic+mean_qi">mean_qi()</a></code>, <code><a href="#topic+mode_hdi">mode_hdi()</a></code>, etc.
</p>
<p>Specifically, if <code>.width</code> is present in the input, <code><a href="#topic+geom_interval">geom_interval()</a></code> acts
as if its default aesthetics are <code>aes(colour = forcats::fct_rev(ordered(.width)))</code>
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a multiple-interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+stat_interval">stat_interval()</a></code> for the stat version, intended for
use on sample data or analytical distributions.
See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for the geometry this shortcut is based on.
</p>
<p>Other slabinterval geoms: 
<code><a href="#topic+geom_pointinterval">geom_pointinterval</a>()</code>,
<code><a href="#topic+geom_slab">geom_slab</a>()</code>,
<code><a href="#topic+geom_spike">geom_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

data(RankCorr_u_tau, package = "ggdist")

# orientation is detected automatically based on
# use of xmin/xmax or ymin/ymax

RankCorr_u_tau %&gt;%
  group_by(i) %&gt;%
  median_qi(.width = c(.5, .8, .95, .99)) %&gt;%
  ggplot(aes(y = i, x = u_tau, xmin = .lower, xmax = .upper)) +
  geom_interval() +
  scale_color_brewer()

RankCorr_u_tau %&gt;%
  group_by(i) %&gt;%
  median_qi(.width = c(.5, .8, .95, .99)) %&gt;%
  ggplot(aes(x = i, y = u_tau, ymin = .lower, ymax = .upper)) +
  geom_interval() +
  scale_color_brewer()

</code></pre>

<hr>
<h2 id='geom_lineribbon'>Line + multiple-ribbon plots (ggplot geom)</h2><span id='topic+geom_lineribbon'></span>

<h3>Description</h3>

<p>A combination of <code><a href="ggplot2.html#topic+geom_line">geom_line()</a></code> and <code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon()</a></code> with default aesthetics
designed for use with output from <code><a href="#topic+point_interval">point_interval()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_lineribbon(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  step = FALSE,
  orientation = NA,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_lineribbon_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_lineribbon_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_lineribbon_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_lineribbon_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_lineribbon_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_lineribbon_+3A_step">step</code></td>
<td>
<p>Should the line/ribbon be drawn as a step function? One of:
</p>

<ul>
<li> <p><code>FALSE</code> (default): do not draw as a step function.
</p>
</li>
<li> <p><code>"mid"</code> (or <code>TRUE</code>): draw steps midway between adjacent x values.
</p>
</li>
<li> <p><code>"hv"</code>: draw horizontal-then-vertical steps.
</p>
</li>
<li> <p><code>"vh"</code>: draw as vertical-then-horizontal steps.
</p>
</li></ul>

<p><code>TRUE</code> is an alias for <code>"mid"</code> because for a step function with ribbons, <code>"mid"</code> is probably what you want
(for the other two step approaches the ribbons at either the very first or very last x value will not be
visible).</p>
</td></tr>
<tr><td><code id="geom_lineribbon_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_lineribbon_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_lineribbon_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_lineribbon_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> is a combination of a <code><a href="ggplot2.html#topic+geom_line">geom_line()</a></code> and <code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon()</a></code> designed for use
with output from <code><a href="#topic+point_interval">point_interval()</a></code>. This geom sets some default aesthetics equal to the <code>.width</code>
column generated by the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions, making them
often more convenient than a vanilla <code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon()</a></code> + <code><a href="ggplot2.html#topic+geom_line">geom_line()</a></code>.
</p>
<p>Specifically, <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> acts as if its default aesthetics are
<code>aes(fill = forcats::fct_rev(ordered(.width)))</code>.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a combined line + multiple-ribbon geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The line+ribbon <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their two sub-geometries: the <strong>line</strong> and the <strong>ribbon</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Ribbon-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left edge of the ribbon sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right edge of the ribbon sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower edge of the ribbon sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper edge of the ribbon sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>order</code>: The order in which ribbons are drawn. Ribbons with the smallest mean value of <code>order</code>
are drawn first (i.e., will be drawn below ribbons with larger mean values of <code>order</code>). If
<code>order</code> is not supplied to <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code>, <code>-abs(xmax - xmin)</code> or <code>-abs(ymax - ymax)</code>
(depending on <code>orientation</code>) is used, having the effect of drawing the widest (on average)
ribbons on the bottom. <code><a href="#topic+stat_lineribbon">stat_lineribbon()</a></code> uses <code>order = after_stat(level)</code> by default,
causing the ribbons generated from the largest <code>.width</code> to be drawn on the bottom.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>line</strong> sub-geometry.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>ribbon</strong> sub-geometry.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>line</strong> and <strong>ribbon</strong> sub-geometries.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of <strong>line</strong>. In <span class="pkg">ggplot2</span> &lt; 3.4, was called <code>size</code>.
</p>
</li>
<li><p><code>linetype</code>: Type of <strong>line</strong> (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc)
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("lineribbon")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+stat_lineribbon">stat_lineribbon()</a></code> for a version that does summarizing of samples into points and intervals
within ggplot. See <code><a href="#topic+geom_pointinterval">geom_pointinterval()</a></code> for a similar geom intended
for point summaries and intervals. See <code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon()</a></code> and <code><a href="ggplot2.html#topic+geom_line">geom_line()</a></code> for the geoms this is
based on.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

set.seed(12345)
tibble(
  x = rep(1:10, 100),
  y = rnorm(1000, x)
) %&gt;%
  group_by(x) %&gt;%
  median_qi(.width = c(.5, .8, .95)) %&gt;%
  ggplot(aes(x = x, y = y, ymin = .lower, ymax = .upper)) +
  # automatically uses aes(fill = forcats::fct_rev(ordered(.width)))
  geom_lineribbon() +
  scale_fill_brewer()

</code></pre>

<hr>
<h2 id='geom_pointinterval'>Point + multiple-interval plot (shortcut geom)</h2><span id='topic+geom_pointinterval'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for creating point + multiple-interval plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>geom_slabinterval(
  aes(
    datatype = "interval",
    side = "both"
  ),
  show_slab = FALSE,
  show.legend = c(size = FALSE)
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>geom_pointinterval(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  orientation = NA,
  interval_size_domain = c(1, 6),
  interval_size_range = c(0.6, 1.4),
  fatten_point = 1.8,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = c(size = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_pointinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_interval_size_domain">interval_size_domain</code></td>
<td>
<p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_interval_size_range">interval_size_range</code></td>
<td>
<p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_fatten_point">fatten_point</code></td>
<td>
<p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_arrow">arrow</code></td>
<td>
<p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="geom_pointinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This geom wraps <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> with defaults designed to produce
point + multiple-interval plots. Default aesthetic mappings are applied if the <code>.width</code> column
is present in the input data (e.g., as generated by the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions),
making this geom often more convenient than vanilla <a href="ggplot2.html#topic+ggplot2">ggplot2</a> geometries when used with
functions like <code><a href="#topic+median_qi">median_qi()</a></code>, <code><a href="#topic+mean_qi">mean_qi()</a></code>, <code><a href="#topic+mode_hdi">mode_hdi()</a></code>, etc.
</p>
<p>Specifically, if <code>.width</code> is present in the input, <code><a href="#topic+geom_pointinterval">geom_pointinterval()</a></code> acts
as if its default aesthetics are <code>aes(size = -.width)</code>
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a point + multiple-interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+stat_pointinterval">stat_pointinterval()</a></code> for the stat version, intended for
use on sample data or analytical distributions.
See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for the geometry this shortcut is based on.
</p>
<p>Other slabinterval geoms: 
<code><a href="#topic+geom_interval">geom_interval</a>()</code>,
<code><a href="#topic+geom_slab">geom_slab</a>()</code>,
<code><a href="#topic+geom_spike">geom_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

data(RankCorr_u_tau, package = "ggdist")

# orientation is detected automatically based on
# use of xmin/xmax or ymin/ymax

RankCorr_u_tau %&gt;%
  group_by(i) %&gt;%
  median_qi(.width = c(.8, .95)) %&gt;%
  ggplot(aes(y = i, x = u_tau, xmin = .lower, xmax = .upper)) +
  geom_pointinterval()

RankCorr_u_tau %&gt;%
  group_by(i) %&gt;%
  median_qi(.width = c(.8, .95)) %&gt;%
  ggplot(aes(x = i, y = u_tau, ymin = .lower, ymax = .upper)) +
  geom_pointinterval()

</code></pre>

<hr>
<h2 id='geom_slab'>Slab (ridge) plot (shortcut geom)</h2><span id='topic+geom_slab'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for creating slab (ridge) plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>geom_slabinterval(
  show_point = FALSE,
  show_interval = FALSE
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>geom_slab(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  orientation = NA,
  normalize = "all",
  fill_type = "segments",
  subguide = "none",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_slab_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_slab_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_slab_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_slab_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_slab_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_slab_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_slab_+3A_normalize">normalize</code></td>
<td>
<p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</td></tr>
<tr><td><code id="geom_slab_+3A_fill_type">fill_type</code></td>
<td>
<p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_slab_+3A_subguide">subguide</code></td>
<td>
<p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_slab_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_slab_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_slab_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a slab (ridge) geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+stat_slab">stat_slab()</a></code> for the stat version, intended for
use on sample data or analytical distributions.
See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for the geometry this shortcut is based on.
</p>
<p>Other slabinterval geoms: 
<code><a href="#topic+geom_interval">geom_interval</a>()</code>,
<code><a href="#topic+geom_pointinterval">geom_pointinterval</a>()</code>,
<code><a href="#topic+geom_spike">geom_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

# we will manually demonstrate plotting a density with geom_slab(),
# though generally speaking this is easier to do using stat_slab(), which
# will determine sensible limits automatically and correctly adjust
# densities when using scale transformations
df = expand.grid(
    mean = 1:3,
    input = seq(-2, 6, length.out = 100)
  ) %&gt;%
  mutate(
    group = letters[4 - mean],
    density = dnorm(input, mean, 1)
  )

# orientation is detected automatically based on
# use of x or y
df %&gt;%
  ggplot(aes(y = group, x = input, thickness = density)) +
  geom_slab()

df %&gt;%
  ggplot(aes(x = group, y = input, thickness = density)) +
  geom_slab()

# RIDGE PLOTS
# "ridge" plots can be created by increasing the slab height and
# setting the slab color
df %&gt;%
  ggplot(aes(y = group, x = input, thickness = density)) +
  geom_slab(height = 2, color = "black")

</code></pre>

<hr>
<h2 id='geom_slabinterval'>Slab + point + interval meta-geom</h2><span id='topic+geom_slabinterval'></span>

<h3>Description</h3>

<p>This meta-geom supports drawing combinations of functions (as slabs, aka ridge plots or joy plots), points, and
intervals. It acts as a meta-geom for many other <span class="pkg">ggdist</span> geoms that are wrappers around this geom, including
eye plots, half-eye plots, CCDF barplots, and point+multiple interval plots, and supports both horizontal and
vertical orientations, dodging (via the <code>position</code> argument), and relative justification of slabs with their
corresponding intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_slabinterval(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  orientation = NA,
  normalize = "all",
  fill_type = "segments",
  interval_size_domain = c(1, 6),
  interval_size_range = c(0.6, 1.4),
  fatten_point = 1.8,
  arrow = NULL,
  show_slab = TRUE,
  show_point = TRUE,
  show_interval = TRUE,
  subguide = "none",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_slabinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_normalize">normalize</code></td>
<td>
<p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_fill_type">fill_type</code></td>
<td>
<p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_interval_size_domain">interval_size_domain</code></td>
<td>
<p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_interval_size_range">interval_size_range</code></td>
<td>
<p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_fatten_point">fatten_point</code></td>
<td>
<p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_arrow">arrow</code></td>
<td>
<p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_show_slab">show_slab</code></td>
<td>
<p>Should the slab portion of the geom be drawn?</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_show_point">show_point</code></td>
<td>
<p>Should the point portion of the geom be drawn?</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_show_interval">show_interval</code></td>
<td>
<p>Should the interval portion of the geom be drawn?</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_subguide">subguide</code></td>
<td>
<p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_slabinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> is a flexible meta-geom that you can use directly or through a variety of &quot;shortcut&quot;
geoms that represent useful combinations of the various parameters of this geom. In many cases you will want to
use the shortcut geoms instead as they create more useful mnemonic primitives, such as eye plots,
half-eye plots, point+interval plots, or CCDF barplots.
</p>
<p>The <em>slab</em> portion of the geom is much like a ridge or &quot;joy&quot; plot: it represents the value of a function
scaled to fit between values on the <code>x</code> or <code>y</code> axis (depending on the value of <code>orientation</code>). Values of
the functions are specified using the <code>thickness</code> aesthetic and are scaled to fit into <code>scale</code>
times the distance between points on the relevant axis. E.g., if <code>orientation</code> is <code>"horizontal"</code>,
<code>scale</code> is <code>0.9</code>, and <code>y</code> is a discrete variable, then the <code>thickness</code> aesthetic specifies the
value of some function of <code>x</code> that is drawn for every <code>y</code> value and scaled to fit into <code>0.9</code> times
the distance between points on the <code>y</code> axis.
</p>
<p>For the <em>interval</em> portion of the geom, <code>x</code> and <code>y</code> aesthetics specify the location of the
point, and <code>ymin</code>/<code>ymax</code> or <code>xmin</code>/<code>xmax</code> (depending on the value of <code>orientation</code>)
specify the endpoints of the interval. A scaling factor for interval line width and point size is applied
through the <code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code> parameters.
These scaling factors are designed to give multiple uncertainty intervals reasonable
scaling at the default settings for <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>.
</p>
<p>As a combination geom, this geom expects a <code>datatype</code> aesthetic specifying which part of the geom a given
row in the input data corresponds to: <code>"slab"</code> or <code>"interval"</code>. However, specifying this aesthetic
manually is typically only necessary if you use this geom directly; the numerous wrapper geoms will
usually set this aesthetic for you as needed, and their use is recommended unless you have a very custom
use case.
</p>
<p>Wrapper geoms include:
</p>

<ul>
<li> <p><code><a href="#topic+geom_pointinterval">geom_pointinterval()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+geom_interval">geom_interval()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+geom_slab">geom_slab()</a></code>
</p>
</li></ul>

<p>In addition, the <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> family of stats uses geoms from the
<code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> family, and is often easier to use than using these geoms
directly. Typically, the <code style="white-space: pre;">&#8288;geom_*&#8288;</code> versions are meant for use with already-summarized data (such as intervals) and the
<code style="white-space: pre;">&#8288;stat_*&#8288;</code> versions are summarize the data themselves (usually draws from a distribution) to produce the geom.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a slab or combined slab+interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> for a combination geom designed for fit curves plus probability bands.
See <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for a combination geom designed for plotting dotplots with intervals.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for families of stats
built on top of this geom for common use cases (like <code><a href="#topic+stat_halfeye">stat_halfeye()</a></code>).
See <code>vignette("slabinterval")</code> for a variety of examples of use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# geom_slabinterval() is typically not that useful on its own.
# See vignette("slabinterval") for a variety of examples of the use of its
# shortcut geoms and stats, which are more useful than using
# geom_slabinterval() directly.

</code></pre>

<hr>
<h2 id='geom_spike'>Spike plot (ggplot2 geom)</h2><span id='topic+geom_spike'></span>

<h3>Description</h3>

<p>Geometry for drawing &quot;spikes&quot; (optionally with points on them) on top of
<code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> geometries: this geometry understands the scaling and
positioning of the <code>thickness</code> aesthetic from <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>, which
allows you to position spikes and points along a slab.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spike(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  orientation = NA,
  normalize = "all",
  arrow = NULL,
  subguide = "none",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_spike_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_normalize">normalize</code></td>
<td>
<p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_arrow">arrow</code></td>
<td>
<p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the spike, or <code>NULL</code> for no arrows.</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_subguide">subguide</code></td>
<td>
<p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_spike_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_spike_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This geometry consists of a &quot;spike&quot; (vertical/horizontal line segment) and a
&quot;point&quot; (at the end of the line segment). It uses the <code>thickness</code> aesthetic
to determine where the endpoint of the line is, which allows it to be used
with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> geometries for labeling specific values of the
thickness function.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a spike geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
rd_slabinterval_aesthetics(geom_name),
</p>


<h3>Aesthetics</h3>

<p>The spike <code>geom</code> has a wide variety of aesthetics that control
the appearance of its two sub-geometries: the <strong>spike</strong> and the <strong>point</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Spike-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>spike</strong> and <strong>point</strong> sub-geometries.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>spike</strong> and <strong>point</strong> sub-geometries.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>spike</strong> sub-geometry.
</p>
</li>
<li><p><code>size</code>: Size of the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>spike</strong>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+stat_spike">stat_spike()</a></code> for the stat version, intended for
use on sample data or analytical distributions.
</p>
<p>Other slabinterval geoms: 
<code><a href="#topic+geom_interval">geom_interval</a>()</code>,
<code><a href="#topic+geom_pointinterval">geom_pointinterval</a>()</code>,
<code><a href="#topic+geom_slab">geom_slab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(distributional)
library(dplyr)

# geom_spike is easiest to use with distributional or
# posterior::rvar objects
df = tibble(
  d = dist_normal(1:2, 1:2), g = c("a", "b")
)

# annotate the density at the mean of a distribution
df %&gt;% mutate(
  mean = mean(d),
  density(d, list(density_at_mean = mean))
) %&gt;%
  ggplot(aes(y = g)) +
  stat_slab(aes(xdist = d)) +
  geom_spike(aes(x = mean, thickness = density_at_mean)) +
  # need shared thickness scale so that stat_slab and geom_spike line up
  scale_thickness_shared()

# annotate the endpoints of intervals of a distribution
# here we'll use an arrow instead of a point by setting size = 0
arrow_spec = arrow(angle = 45, type = "closed", length = unit(4, "pt"))
df %&gt;% mutate(
  median_qi(d, .width = 0.9),
  density(d, list(density_lower = .lower, density_upper = .upper))
) %&gt;%
  ggplot(aes(y = g)) +
  stat_halfeye(aes(xdist = d), .width = 0.9, color = "gray35") +
  geom_spike(
    aes(x = .lower, thickness = density_lower),
    size = 0, arrow = arrow_spec, color = "blue", linewidth = 0.75
  ) +
  geom_spike(
    aes(x = .upper, thickness = density_upper),
    size = 0, arrow = arrow_spec, color = "red", linewidth = 0.75
  ) +
  scale_thickness_shared()

</code></pre>

<hr>
<h2 id='geom_swarm'>Beeswarm plot (shortcut geom)</h2><span id='topic+geom_swarm'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for creating beeswarm plots.
Geoms based on <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> create dotplots that automatically
ensure the plot fits within the available space.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>geom_dots(
  aes(side = "both"),
  overflow = "compress",
  binwidth = unit(1.5, "mm"),
  layout = "swarm"
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>geom_swarm(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  overflow = "compress",
  binwidth = unit(1.5, "mm"),
  layout = "swarm",
  dotsize = 1.07,
  stackratio = 1,
  overlaps = "nudge",
  smooth = "none",
  verbose = FALSE,
  orientation = NA,
  subguide = "none",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_swarm_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_overflow">overflow</code></td>
<td>
<p>How to handle overflow of dots beyond the extent of the geom
when a minimum <code>binwidth</code> (or an exact <code>binwidth</code>) is supplied.
One of:
</p>

<ul>
<li> <p><code>"keep"</code>: Keep the overflow, drawing dots outside the geom bounds.
</p>
</li>
<li> <p><code>"warn"</code>: Keep the overflow, but produce a warning suggesting solutions,
such as setting <code>binwidth = NA</code> or <code>overflow = "compress"</code>.
</p>
</li>
<li> <p><code>"compress"</code>: Compress the layout. Reduces the <code>binwidth</code> to the size necessary
to keep the dots within bounds, then adjusts <code>stackratio</code> and <code>dotsize</code> so that
the apparent dot size is the user-specified minimum <code>binwidth</code> times the
user-specified <code>dotsize</code>.
</p>
</li></ul>

<p>If you find the default layout has dots that are too small, and you are okay
with dots overlapping, consider setting <code>overflow = "compress"</code> and supplying
an exact or minimum dot size using <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_binwidth">binwidth</code></td>
<td>
<p>The bin width to use for laying out the dots.
One of:
</p>

<ul>
<li> <p><code>NA</code> (the default): Dynamically select the bin width based on the
size of the plot when drawn. This will pick a <code>binwidth</code> such that the
tallest stack of dots is at most <code>scale</code> in height (ideally exactly <code>scale</code>
in height, though this is not guaranteed).
</p>
</li>
<li><p> A length-1 (scalar) numeric or <a href="grid.html#topic+unit">unit</a> object giving the exact bin width.
</p>
</li>
<li><p> A length-2 (vector) numeric or <a href="grid.html#topic+unit">unit</a> object giving the minimum and maximum
desired bin width. The bin width will be dynamically selected within
these bounds.
</p>
</li></ul>

<p>If the value is numeric, it is assumed to be in units of data. The bin width
(or its bounds) can also be specified using <code><a href="grid.html#topic+unit">unit()</a></code>, which may be useful if
it is desired that the dots be a certain point size or a certain percentage of
the width/height of the viewport. For example, <code>unit(0.1, "npc")</code> would make
dots that are <em>exactly</em> 10% of the viewport size along whichever dimension the
dotplot is drawn; <code>unit(c(0, 0.1), "npc")</code> would make dots that are <em>at most</em>
10% of the viewport size (while still ensuring the tallest stack is less than
or equal to <code>scale</code>).</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_layout">layout</code></td>
<td>
<p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_swarm_+3A_dotsize">dotsize</code></td>
<td>
<p>The width of the dots relative to the <code>binwidth</code>. The default,
<code>1.07</code>, makes dots be just a bit wider than the bin width, which is a
manually-tuned parameter that tends to work well with the default circular
shape, preventing gaps between bins from appearing to be too large visually
(as might arise from dots being <em>precisely</em> the <code>binwidth</code>). If it is desired
to have dots be precisely the <code>binwidth</code>, set <code>dotsize = 1</code>.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_stackratio">stackratio</code></td>
<td>
<p>The distance between the center of the dots in the same
stack relative to the dot height. The default, <code>1</code>, makes dots in the same
stack just touch each other.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_overlaps">overlaps</code></td>
<td>
<p>How to handle overlapping dots or bins in the <code>"bin"</code>,
<code>"weave"</code>, and <code>"hex"</code> layouts (dots never overlap in the <code>"swarm"</code> or <code>"bar"</code> layouts).
For the purposes of this argument, dots are only considered to be overlapping
if they would be overlapping when <code>dotsize = 1</code> and <code>stackratio = 1</code>; i.e.
if you set those arguments to other values, overlaps may still occur.
One of: </p>

<ul>
<li> <p><code>"keep"</code>: leave overlapping dots as they are. Dots may overlap
(usually only slightly) in the <code>"bin"</code>, <code>"weave"</code>, and <code>"hex"</code> layouts.
</p>
</li>
<li> <p><code>"nudge"</code>: nudge overlapping dots out of the way. Overlaps are avoided
using a constrained optimization which minimizes the squared distance of
dots to their desired positions, subject to the constraint that adjacent
dots do not overlap.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_swarm_+3A_smooth">smooth</code></td>
<td>
<p>Smoother to apply to dot positions.
One of:
</p>

<ul>
<li><p> A function that takes a numeric vector of dot positions and returns a
smoothed version of that vector, such as <code>smooth_bounded()</code>,
<code>smooth_unbounded()</code>, smooth_discrete()<code style="white-space: pre;">&#8288;, or &#8288;</code>smooth_bar()'.
</p>
</li>
<li><p> A string indicating what smoother to use, as the suffix to a function
name starting with <code>smooth_</code>; e.g. <code>"none"</code> (the default) applies
<code>smooth_none()</code>, which simply returns the given vector without
applying smoothing.
</p>
</li></ul>

<p>Smoothing is most effective when the smoother is matched to the support of
the distribution; e.g. using <code>smooth_bounded(bounds = ...)</code>.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print out the bin width of the dotplot. Can be useful
if you want to start from an automatically-selected bin width and then adjust it
manually. Bin width is printed both as data units and as normalized parent
coordinates or <code>"npc"</code>s (see <code><a href="grid.html#topic+unit">unit()</a></code>). Note that if you just want to scale the
selected bin width to fit within a desired area, it is probably easier to use
<code>scale</code> than to copy and scale <code>binwidth</code> manually, and if you just want to
provide constraints on the bin width, you can pass a length-2 vector to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_subguide">subguide</code></td>
<td>
<p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_swarm_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_swarm_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>dots</em> family of stats and geoms are similar to <code><a href="ggplot2.html#topic+geom_dotplot">geom_dotplot()</a></code> but with a number of differences:
</p>

<ul>
<li><p> Dots geoms act like slabs in <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and can be given x positions (or y positions when
in a horizontal orientation).
</p>
</li>
<li><p> Given the available space to lay out dots, the dots geoms will automatically determine how many bins to
use to fit the available space.
</p>
</li>
<li><p> Dots geoms use a dynamic layout algorithm that lays out dots from the center out if the input data are
symmetrical, guaranteeing that symmetrical data results in a symmetrical plot. The layout algorithm also prevents
dots from overlapping each other.
</p>
</li>
<li><p> The shape of the dots in these geoms can be changed using the <code>slab_shape</code> aesthetic (when using the
<code>dotsinterval</code> family) or the <code>shape</code> or <code>slab_shape</code> aesthetic (when using the <code>dots</code> family)
</p>
</li></ul>

<p>Stats and geoms in this family include:
</p>

<ul>
<li> <p><code><a href="#topic+geom_dots">geom_dots()</a></code>: dotplots on raw data. Ensures the dotplot fits within available space by reducing the size
of the dots automatically (may result in very small dots).
</p>
</li>
<li> <p><code><a href="#topic+geom_swarm">geom_swarm()</a></code> and <code><a href="#topic+geom_weave">geom_weave()</a></code>: dotplots on raw data with defaults intended to create &quot;beeswarm&quot; plots.
Used <code>side = "both"</code> by default, and sets the default dot size to the same size as <code><a href="ggplot2.html#topic+geom_point">geom_point()</a></code>
(<code>binwidth = unit(1.5, "mm")</code>), allowing dots to overlap instead of getting very small.
</p>
</li>
<li> <p><code><a href="#topic+stat_dots">stat_dots()</a></code>: dotplots on raw data, <span class="pkg">distributional</span> objects, and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s
</p>
</li>
<li> <p><code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>: dotplot + interval plots on raw data with already-calculated
intervals (rarely useful directly).
</p>
</li>
<li> <p><code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>: dotplot + interval plots on raw data, <span class="pkg">distributional</span> objects,
and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s (will calculate intervals for you).
</p>
</li>
<li> <p><code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>: blurry dotplots that allow the standard deviation of a blur applied to
each dot to be specified using the <code>sd</code> aesthetic.
</p>
</li>
<li> <p><code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code>: blurry dotplots of quantiles using the Monte Carlo Standard Error of each quantile.
</p>
</li></ul>

<p><code><a href="#topic+stat_dots">stat_dots()</a></code> and <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>, when used with the <code>quantiles</code> argument,
are particularly useful for constructing quantile dotplots, which can be an effective way to communicate uncertainty
using a frequency framing that may be easier for laypeople to understand (Kay et al. 2016, Fernandes et al. 2018).
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a beeswarm geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The dots+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>dots</strong> (aka the <strong>slab</strong>), the
<strong>point</strong>, and the <strong>interval</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Dots-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>family</code>: The font family used to draw the dots.
</p>
</li>
<li><p><code>order</code>: The order in which data points are stacked within bins. Can be used to create the effect of
&quot;stacked&quot; dots by ordering dots according to a discrete variable. If omitted (<code>NULL</code>), the
value of the data points themselves are used to determine stacking order. Only applies when
<code>layout</code> is <code>"bin"</code> or <code>"hex"</code>, as the other layout methods fully determine both <em>x</em> and <em>y</em> positions.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li>
<li><p><code>slab_shape</code>: Override for <code>shape</code>: the shape of the dots used to draw the dotplot slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("dotsinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>References</h3>

<p>Kay, M., Kola, T., Hullman, J. R., &amp; Munson, S. A. (2016). When (ish) is My Bus? User-centered Visualizations
of Uncertainty in Everyday, Mobile Predictive Systems. <em>Conference on Human Factors
in Computing Systems - CHI '16</em>, 5092&ndash;5103. <a href="https://doi.org/10.1145/2858036.2858558">doi:10.1145/2858036.2858558</a>.
</p>
<p>Fernandes, M., Walls, L., Munson, S., Hullman, J., &amp; Kay, M. (2018). Uncertainty Displays Using Quantile Dotplots
or CDFs Improve Transit Decision-Making. <em>Conference on Human Factors in Computing Systems - CHI '18</em>.
<a href="https://doi.org/10.1145/3173574.3173718">doi:10.1145/3173574.3173718</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for the geometry this shortcut is based on.
</p>
<p>See <code>vignette("dotsinterval")</code> for a variety of examples of use.
</p>
<p>Other dotsinterval geoms: 
<code><a href="#topic+geom_blur_dots">geom_blur_dots</a>()</code>,
<code><a href="#topic+geom_dots">geom_dots</a>()</code>,
<code><a href="#topic+geom_dotsinterval">geom_dotsinterval</a>()</code>,
<code><a href="#topic+geom_weave">geom_weave</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

set.seed(12345)
df = tibble(
  g = rep(c("a", "b"), 200),
  value = rnorm(400, c(0, 3), c(0.75, 1))
)

# orientation is detected automatically based on
# which axis is discrete

df %&gt;%
  ggplot(aes(x = value, y = g)) +
  geom_swarm()

df %&gt;%
  ggplot(aes(y = value, x = g)) +
  geom_swarm()
</code></pre>

<hr>
<h2 id='geom_weave'>Dot-weave plot (shortcut geom)</h2><span id='topic+geom_weave'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for creating dot-weave plots.
Geoms based on <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> create dotplots that automatically
ensure the plot fits within the available space.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>geom_dots(
  aes(side = "both"),
  layout = "weave",
  overflow = "compress",
  binwidth = unit(1.5, "mm")
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>geom_weave(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  layout = "weave",
  overflow = "compress",
  binwidth = unit(1.5, "mm"),
  dotsize = 1.07,
  stackratio = 1,
  overlaps = "nudge",
  smooth = "none",
  verbose = FALSE,
  orientation = NA,
  subguide = "none",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_weave_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_layout">layout</code></td>
<td>
<p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_weave_+3A_overflow">overflow</code></td>
<td>
<p>How to handle overflow of dots beyond the extent of the geom
when a minimum <code>binwidth</code> (or an exact <code>binwidth</code>) is supplied.
One of:
</p>

<ul>
<li> <p><code>"keep"</code>: Keep the overflow, drawing dots outside the geom bounds.
</p>
</li>
<li> <p><code>"warn"</code>: Keep the overflow, but produce a warning suggesting solutions,
such as setting <code>binwidth = NA</code> or <code>overflow = "compress"</code>.
</p>
</li>
<li> <p><code>"compress"</code>: Compress the layout. Reduces the <code>binwidth</code> to the size necessary
to keep the dots within bounds, then adjusts <code>stackratio</code> and <code>dotsize</code> so that
the apparent dot size is the user-specified minimum <code>binwidth</code> times the
user-specified <code>dotsize</code>.
</p>
</li></ul>

<p>If you find the default layout has dots that are too small, and you are okay
with dots overlapping, consider setting <code>overflow = "compress"</code> and supplying
an exact or minimum dot size using <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_binwidth">binwidth</code></td>
<td>
<p>The bin width to use for laying out the dots.
One of:
</p>

<ul>
<li> <p><code>NA</code> (the default): Dynamically select the bin width based on the
size of the plot when drawn. This will pick a <code>binwidth</code> such that the
tallest stack of dots is at most <code>scale</code> in height (ideally exactly <code>scale</code>
in height, though this is not guaranteed).
</p>
</li>
<li><p> A length-1 (scalar) numeric or <a href="grid.html#topic+unit">unit</a> object giving the exact bin width.
</p>
</li>
<li><p> A length-2 (vector) numeric or <a href="grid.html#topic+unit">unit</a> object giving the minimum and maximum
desired bin width. The bin width will be dynamically selected within
these bounds.
</p>
</li></ul>

<p>If the value is numeric, it is assumed to be in units of data. The bin width
(or its bounds) can also be specified using <code><a href="grid.html#topic+unit">unit()</a></code>, which may be useful if
it is desired that the dots be a certain point size or a certain percentage of
the width/height of the viewport. For example, <code>unit(0.1, "npc")</code> would make
dots that are <em>exactly</em> 10% of the viewport size along whichever dimension the
dotplot is drawn; <code>unit(c(0, 0.1), "npc")</code> would make dots that are <em>at most</em>
10% of the viewport size (while still ensuring the tallest stack is less than
or equal to <code>scale</code>).</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_dotsize">dotsize</code></td>
<td>
<p>The width of the dots relative to the <code>binwidth</code>. The default,
<code>1.07</code>, makes dots be just a bit wider than the bin width, which is a
manually-tuned parameter that tends to work well with the default circular
shape, preventing gaps between bins from appearing to be too large visually
(as might arise from dots being <em>precisely</em> the <code>binwidth</code>). If it is desired
to have dots be precisely the <code>binwidth</code>, set <code>dotsize = 1</code>.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_stackratio">stackratio</code></td>
<td>
<p>The distance between the center of the dots in the same
stack relative to the dot height. The default, <code>1</code>, makes dots in the same
stack just touch each other.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_overlaps">overlaps</code></td>
<td>
<p>How to handle overlapping dots or bins in the <code>"bin"</code>,
<code>"weave"</code>, and <code>"hex"</code> layouts (dots never overlap in the <code>"swarm"</code> or <code>"bar"</code> layouts).
For the purposes of this argument, dots are only considered to be overlapping
if they would be overlapping when <code>dotsize = 1</code> and <code>stackratio = 1</code>; i.e.
if you set those arguments to other values, overlaps may still occur.
One of: </p>

<ul>
<li> <p><code>"keep"</code>: leave overlapping dots as they are. Dots may overlap
(usually only slightly) in the <code>"bin"</code>, <code>"weave"</code>, and <code>"hex"</code> layouts.
</p>
</li>
<li> <p><code>"nudge"</code>: nudge overlapping dots out of the way. Overlaps are avoided
using a constrained optimization which minimizes the squared distance of
dots to their desired positions, subject to the constraint that adjacent
dots do not overlap.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_weave_+3A_smooth">smooth</code></td>
<td>
<p>Smoother to apply to dot positions.
One of:
</p>

<ul>
<li><p> A function that takes a numeric vector of dot positions and returns a
smoothed version of that vector, such as <code>smooth_bounded()</code>,
<code>smooth_unbounded()</code>, smooth_discrete()<code style="white-space: pre;">&#8288;, or &#8288;</code>smooth_bar()'.
</p>
</li>
<li><p> A string indicating what smoother to use, as the suffix to a function
name starting with <code>smooth_</code>; e.g. <code>"none"</code> (the default) applies
<code>smooth_none()</code>, which simply returns the given vector without
applying smoothing.
</p>
</li></ul>

<p>Smoothing is most effective when the smoother is matched to the support of
the distribution; e.g. using <code>smooth_bounded(bounds = ...)</code>.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print out the bin width of the dotplot. Can be useful
if you want to start from an automatically-selected bin width and then adjust it
manually. Bin width is printed both as data units and as normalized parent
coordinates or <code>"npc"</code>s (see <code><a href="grid.html#topic+unit">unit()</a></code>). Note that if you just want to scale the
selected bin width to fit within a desired area, it is probably easier to use
<code>scale</code> than to copy and scale <code>binwidth</code> manually, and if you just want to
provide constraints on the bin width, you can pass a length-2 vector to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_subguide">subguide</code></td>
<td>
<p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_weave_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_weave_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>dots</em> family of stats and geoms are similar to <code><a href="ggplot2.html#topic+geom_dotplot">geom_dotplot()</a></code> but with a number of differences:
</p>

<ul>
<li><p> Dots geoms act like slabs in <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and can be given x positions (or y positions when
in a horizontal orientation).
</p>
</li>
<li><p> Given the available space to lay out dots, the dots geoms will automatically determine how many bins to
use to fit the available space.
</p>
</li>
<li><p> Dots geoms use a dynamic layout algorithm that lays out dots from the center out if the input data are
symmetrical, guaranteeing that symmetrical data results in a symmetrical plot. The layout algorithm also prevents
dots from overlapping each other.
</p>
</li>
<li><p> The shape of the dots in these geoms can be changed using the <code>slab_shape</code> aesthetic (when using the
<code>dotsinterval</code> family) or the <code>shape</code> or <code>slab_shape</code> aesthetic (when using the <code>dots</code> family)
</p>
</li></ul>

<p>Stats and geoms in this family include:
</p>

<ul>
<li> <p><code><a href="#topic+geom_dots">geom_dots()</a></code>: dotplots on raw data. Ensures the dotplot fits within available space by reducing the size
of the dots automatically (may result in very small dots).
</p>
</li>
<li> <p><code><a href="#topic+geom_swarm">geom_swarm()</a></code> and <code><a href="#topic+geom_weave">geom_weave()</a></code>: dotplots on raw data with defaults intended to create &quot;beeswarm&quot; plots.
Used <code>side = "both"</code> by default, and sets the default dot size to the same size as <code><a href="ggplot2.html#topic+geom_point">geom_point()</a></code>
(<code>binwidth = unit(1.5, "mm")</code>), allowing dots to overlap instead of getting very small.
</p>
</li>
<li> <p><code><a href="#topic+stat_dots">stat_dots()</a></code>: dotplots on raw data, <span class="pkg">distributional</span> objects, and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s
</p>
</li>
<li> <p><code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>: dotplot + interval plots on raw data with already-calculated
intervals (rarely useful directly).
</p>
</li>
<li> <p><code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>: dotplot + interval plots on raw data, <span class="pkg">distributional</span> objects,
and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s (will calculate intervals for you).
</p>
</li>
<li> <p><code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>: blurry dotplots that allow the standard deviation of a blur applied to
each dot to be specified using the <code>sd</code> aesthetic.
</p>
</li>
<li> <p><code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code>: blurry dotplots of quantiles using the Monte Carlo Standard Error of each quantile.
</p>
</li></ul>

<p><code><a href="#topic+stat_dots">stat_dots()</a></code> and <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>, when used with the <code>quantiles</code> argument,
are particularly useful for constructing quantile dotplots, which can be an effective way to communicate uncertainty
using a frequency framing that may be easier for laypeople to understand (Kay et al. 2016, Fernandes et al. 2018).
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Geom</a> representing a dot-weave geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The dots+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>dots</strong> (aka the <strong>slab</strong>), the
<strong>point</strong>, and the <strong>interval</strong>.
</p>
<p><strong>Positional aesthetics</strong>
</p>

<ul>
<li><p><code>x</code>: x position of the geometry
</p>
</li>
<li><p><code>y</code>: y position of the geometry
</p>
</li></ul>

<p><strong>Dots-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>family</code>: The font family used to draw the dots.
</p>
</li>
<li><p><code>order</code>: The order in which data points are stacked within bins. Can be used to create the effect of
&quot;stacked&quot; dots by ordering dots according to a discrete variable. If omitted (<code>NULL</code>), the
value of the data points themselves are used to determine stacking order. Only applies when
<code>layout</code> is <code>"bin"</code> or <code>"hex"</code>, as the other layout methods fully determine both <em>x</em> and <em>y</em> positions.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li>
<li><p><code>slab_shape</code>: Override for <code>shape</code>: the shape of the dots used to draw the dotplot slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("dotsinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>References</h3>

<p>Kay, M., Kola, T., Hullman, J. R., &amp; Munson, S. A. (2016). When (ish) is My Bus? User-centered Visualizations
of Uncertainty in Everyday, Mobile Predictive Systems. <em>Conference on Human Factors
in Computing Systems - CHI '16</em>, 5092&ndash;5103. <a href="https://doi.org/10.1145/2858036.2858558">doi:10.1145/2858036.2858558</a>.
</p>
<p>Fernandes, M., Walls, L., Munson, S., Hullman, J., &amp; Kay, M. (2018). Uncertainty Displays Using Quantile Dotplots
or CDFs Improve Transit Decision-Making. <em>Conference on Human Factors in Computing Systems - CHI '18</em>.
<a href="https://doi.org/10.1145/3173574.3173718">doi:10.1145/3173574.3173718</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for the geometry this shortcut is based on.
</p>
<p>See <code>vignette("dotsinterval")</code> for a variety of examples of use.
</p>
<p>Other dotsinterval geoms: 
<code><a href="#topic+geom_blur_dots">geom_blur_dots</a>()</code>,
<code><a href="#topic+geom_dots">geom_dots</a>()</code>,
<code><a href="#topic+geom_dotsinterval">geom_dotsinterval</a>()</code>,
<code><a href="#topic+geom_swarm">geom_swarm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

set.seed(12345)
df = tibble(
  g = rep(c("a", "b"), 200),
  value = rnorm(400, c(0, 3), c(0.75, 1))
)

# orientation is detected automatically based on
# which axis is discrete

df %&gt;%
  ggplot(aes(x = value, y = g)) +
  geom_weave()

df %&gt;%
  ggplot(aes(y = value, x = g)) +
  geom_weave()
</code></pre>

<hr>
<h2 id='ggdist-deprecated'>Deprecated functions and arguments in ggdist</h2><span id='topic+ggdist-deprecated'></span><span id='topic+StatSampleSlabinterval'></span><span id='topic+stat_sample_slabinterval'></span><span id='topic+StatDistSlabinterval'></span><span id='topic+stat_dist_slabinterval'></span><span id='topic+stat_dist_halfeye'></span><span id='topic+stat_dist_eye'></span><span id='topic+stat_dist_ccdfinterval'></span><span id='topic+stat_dist_cdfinterval'></span><span id='topic+stat_dist_gradientinterval'></span><span id='topic+stat_dist_slab'></span><span id='topic+stat_dist_pointinterval'></span><span id='topic+stat_dist_interval'></span><span id='topic+stat_dist_lineribbon'></span><span id='topic+stat_dist_dotsinterval'></span><span id='topic+stat_dist_dots'></span>

<h3>Description</h3>

<p>Deprecated functions and arguments and their alternatives are listed below.
</p>


<h3>Deprecated stats and geoms</h3>

<p>The <code>stat_sample_...</code> and <code>stat_dist_...</code> families of stats were merged in ggdist 3.1.
This means:
</p>

<ul>
<li> <p><code>stat_dist_...</code> is deprecated. For any code using <code>stat_dist_XXX()</code>, you should now
be able to use <code>stat_XXX()</code> instead without additional modifications in almost all cases.
</p>
</li>
<li> <p><code>stat_sample_slabinterval()</code> is deprecated. You should be able to use
<code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> instead without additional modifications in almost all cases.
</p>
</li></ul>

<p>The old <code>stat_dist_...</code> names are currently kept as aliases, but may be removed in the future.
</p>


<h3>Deprecated arguments</h3>

<p>Parameters for <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and family deprecated as of ggdist 3.1 are:
</p>

<ul>
<li><p> The <code>.prob</code> argument, which is a long-deprecated alias for <code>.width</code>, was
removed in ggdist 3.1.
</p>
</li>
<li><p> The <code>limits_function</code> argument: this was a parameter for determining the
function to compute limits of the slab in <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and its
derived stats. This function is really an internal function only needed by
subclasses of the base class, yet added a lot of noise to the documentation,
so it was replaced with <code>AbstractStatSlabInterval$compute_limits()</code>.
</p>
</li>
<li><p> The <code>limits_args</code> argument: extra stat parameters are now passed through to
the <code>...</code> arguments to <code>AbstractStatSlabInterval$compute_limits()</code>; use
these instead.
</p>
</li>
<li><p> The <code>slab_function</code> argument: this was a parameter for determining the
function to compute slabs in <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and its
derived stats. This function is really an internal function only needed by
subclasses of the base class, yet added a lot of noise to the documentation,
so it was replaced with <code>AbstractStatSlabInterval$compute_slab()</code>.
</p>
</li>
<li><p> The <code>slab_args</code> argument: extra stat parameters are now passed through to
the <code>...</code> arguments to <code>AbstractStatSlabInterval$compute_slab()</code>; use
these instead.
</p>
</li>
<li><p> The <code>interval_function</code> and <code>fun.data</code> arguments: these were parameters for determining the
function to compute intervals in <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and its
derived stats. This function is really an internal function only needed by
subclasses of the base class, yet added a lot of noise to the documentation,
so it was replaced with <code>AbstractStatSlabInterval$compute_interval()</code>.
</p>
</li>
<li><p> The <code>interval_args</code> and <code>fun.args</code> arguments: to pass extra arguments to
a <code>point_interval</code> replace the value of the <code>point_interval</code> argument with
a simple wrapper; e.g. <code style="white-space: pre;">&#8288;stat_halfeye(point_interval = \(...) point_interval(..., extra_arg = XXX))&#8288;</code>
</p>
</li></ul>

<p>Parameters for <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and family deprecated as of ggdist 3.1 are:
</p>

<ul>
<li><p> The <code>size_domain</code> and <code>size_range</code> arguments, which are long-deprecated aliases
for <code>interval_size_domain</code> and <code>interval_size_range</code>, were removed in ggdist 3.1.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Kay
</p>

<hr>
<h2 id='guide_rampbar'>Continuous guide for colour ramp scales (ggplot2 guide)</h2><span id='topic+guide_rampbar'></span>

<h3>Description</h3>

<p>A colour ramp bar guide that shows continuous colour ramp scales mapped onto
values as a smooth gradient. Designed for use with <code><a href="#topic+scale_fill_ramp_continuous">scale_fill_ramp_continuous()</a></code>
and <code><a href="#topic+scale_colour_ramp_continuous">scale_colour_ramp_continuous()</a></code>. Based on <code><a href="ggplot2.html#topic+guide_colourbar">guide_colourbar()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_rampbar(
  ...,
  to = "gray65",
  available_aes = c("fill_ramp", "colour_ramp")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_rampbar_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+guide_colourbar">ggplot2::guide_colourbar</a></code>
</p>

<dl>
<dt><code>title</code></dt><dd><p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="ggplot2.html#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="ggplot2.html#topic+labs">labs()</a></code> is used for the title.</p>
</dd>
<dt><code>theme</code></dt><dd><p>A <code><a href="ggplot2.html#topic+theme">theme</a></code> object to style the guide individually or
differently from the plot's theme settings. The <code>theme</code> argument in the
guide overrides, and is combined with, the plot's theme.</p>
</dd>
<dt><code>nbin</code></dt><dd><p>A numeric specifying the number of bins for drawing the
colourbar. A smoother colourbar results from a larger value.</p>
</dd>
<dt><code>display</code></dt><dd><p>A string indicating a method to display the colourbar. Can be
one of the following:
</p>

<ul>
<li> <p><code>"raster"</code> to display as a bitmap image.
</p>
</li>
<li> <p><code>"rectangles"</code> to display as a series of rectangles.
</p>
</li>
<li> <p><code>"gradient"</code> to display as a linear gradient.
</p>
</li></ul>

<p>Note that not all devices are able to render rasters and gradients.</p>
</dd>
<dt><code>raster</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>  A logical. If <code>TRUE</code> then
the colourbar is rendered as a raster object. If <code>FALSE</code> then the colourbar
is rendered as a set of rectangles. Note that not all graphics devices are
capable of rendering raster image.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric between 0 and 1 setting the colour transparency of
the bar. Use <code>NA</code> to preserve the alpha encoded in the colour itself
(default).</p>
</dd>
<dt><code>draw.ulim</code></dt><dd><p>A logical specifying if the upper limit tick marks should
be visible.</p>
</dd>
<dt><code>draw.llim</code></dt><dd><p>A logical specifying if the lower limit tick marks should
be visible.</p>
</dd>
<dt><code>position</code></dt><dd><p>A character string indicating where the legend should be
placed relative to the plot panels.</p>
</dd>
<dt><code>direction</code></dt><dd><p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</dd>
<dt><code>reverse</code></dt><dd><p>logical. If <code>TRUE</code> the colourbar is reversed. By default,
the highest value is on the top and the lowest value is on the bottom</p>
</dd>
<dt><code>order</code></dt><dd><p>positive integer less than 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="guide_rampbar_+3A_to">to</code></td>
<td>
<p>The color to ramp to in the guide. Corresponds to <code>1</code> on the scale.</p>
</td></tr>
<tr><td><code id="guide_rampbar_+3A_available_aes">available_aes</code></td>
<td>
<p>A vector of character strings listing the aesthetics for which a <code>guide_rampbar()</code> can be drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This guide creates smooth gradient color bars for use with <code><a href="#topic+scale_fill_ramp_continuous">scale_fill_ramp_continuous()</a></code>
and <code><a href="#topic+scale_colour_ramp_continuous">scale_colour_ramp_continuous()</a></code>. The color to ramp from is determined by the <code>from</code>
argument of the <code style="white-space: pre;">&#8288;scale_*&#8288;</code> function, and the color to ramp to is determined by the <code>to</code> argument
to <code><a href="#topic+guide_rampbar">guide_rampbar()</a></code>.
</p>
<p>Guides can be specified in each <code style="white-space: pre;">&#8288;scale_*&#8288;</code> function or in <code>guides()</code>.
<code>guide = "rampbar"</code> in <code style="white-space: pre;">&#8288;scale_*&#8288;</code> is syntactic sugar for <code>guide = guide_rampbar()</code>;
e.g. <code>scale_colour_ramp_continuous(guide = "rampbar")</code>. For how to specify
the guide for each scale in more detail, see <code>guides()</code>.
</p>


<h3>Value</h3>

<p>A guide object.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>Other colour ramp functions: 
<code><a href="#topic+partial_colour_ramp">partial_colour_ramp</a>()</code>,
<code><a href="#topic+ramp_colours">ramp_colours</a>()</code>,
<code><a href="#topic+scale_colour_ramp">scale_colour_ramp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)
library(distributional)

# The default guide for ramp scales is guide_legend(), which creates a
# discrete style scale:
tibble(d = dist_uniform(0, 1)) %&gt;%
  ggplot(aes(y = 0, xdist = d)) +
  stat_slab(aes(fill_ramp = after_stat(x)), fill = "blue") +
  scale_fill_ramp_continuous(from = "red")

# We can use guide_rampbar() to instead create a continuous guide, but
# it does not know what color to ramp to (defaults to "gray65"):
tibble(d = dist_uniform(0, 1)) %&gt;%
  ggplot(aes(y = 0, xdist = d)) +
  stat_slab(aes(fill_ramp = after_stat(x)), fill = "blue") +
  scale_fill_ramp_continuous(from = "red", guide = guide_rampbar())

# We can tell the guide what color to ramp to using the `to` argument:
tibble(d = dist_uniform(0, 1)) %&gt;%
  ggplot(aes(y = 0, xdist = d)) +
  stat_slab(aes(fill_ramp = after_stat(x)), fill = "blue") +
  scale_fill_ramp_continuous(from = "red", guide = guide_rampbar(to = "blue"))

</code></pre>

<hr>
<h2 id='lkjcorr_marginal'>Marginal distribution of a single correlation from an LKJ distribution</h2><span id='topic+lkjcorr_marginal'></span><span id='topic+dlkjcorr_marginal'></span><span id='topic+plkjcorr_marginal'></span><span id='topic+qlkjcorr_marginal'></span><span id='topic+rlkjcorr_marginal'></span>

<h3>Description</h3>

<p>Marginal distribution for the correlation in a single cell from a correlation
matrix distributed according to an LKJ distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlkjcorr_marginal(x, K, eta, log = FALSE)

plkjcorr_marginal(q, K, eta, lower.tail = TRUE, log.p = FALSE)

qlkjcorr_marginal(p, K, eta, lower.tail = TRUE, log.p = FALSE)

rlkjcorr_marginal(n, K, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lkjcorr_marginal_+3A_x">x</code>, <code id="lkjcorr_marginal_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="lkjcorr_marginal_+3A_k">K</code></td>
<td>
<p>Dimension of the correlation matrix. Must be greater than or equal to 2.</p>
</td></tr>
<tr><td><code id="lkjcorr_marginal_+3A_eta">eta</code></td>
<td>
<p>Parameter controlling the shape of the distribution</p>
</td></tr>
<tr><td><code id="lkjcorr_marginal_+3A_log">log</code>, <code id="lkjcorr_marginal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="lkjcorr_marginal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="lkjcorr_marginal_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="lkjcorr_marginal_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LKJ distribution is a distribution over correlation matrices with a single parameter, <code class="reqn">\eta</code>.
For a given <code class="reqn">\eta</code> and a <code class="reqn">K \times K</code> correlation matrix <code class="reqn">R</code>:
</p>
<p style="text-align: center;"><code class="reqn">R \sim \textrm{LKJ}(\eta)</code>
</p>

<p>Each off-diagonal entry of <code class="reqn">R</code>, <code class="reqn">r_{ij}: i \ne j</code>, has the
following marginal distribution (Lewandowski, Kurowicka, and Joe 2009):
</p>
<p style="text-align: center;"><code class="reqn">\frac{r_{ij} + 1}{2} \sim \textrm{Beta}\left(\eta - 1 + \frac{K}{2}, \eta - 1 + \frac{K}{2}\right)
</code>
</p>

<p>In other words, <code class="reqn">r_{ij}</code> is marginally distributed according to the above Beta
distribution scaled into <code class="reqn">(-1,1)</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>dlkjcorr_marginal</code> gives the density
</p>
</li>
<li> <p><code>plkjcorr_marginal</code> gives the cumulative distribution function (CDF)
</p>
</li>
<li> <p><code>qlkjcorr_marginal</code> gives the quantile function (inverse CDF)
</p>
</li>
<li> <p><code>rlkjcorr_marginal</code> generates random draws.
</p>
</li></ul>

<p>The length of the result is determined by <code>n</code> for <code>rlkjcorr_marginal</code>, and is the maximum of the lengths of
the numerical arguments for the other functions.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length of the result. Only the first elements
of the logical arguments are used.
</p>


<h3>References</h3>

<p>Lewandowski, D., Kurowicka, D., &amp; Joe, H. (2009). Generating random correlation matrices based on vines
and extended onion method. <em>Journal of Multivariate Analysis</em>, 100(9), 1989&ndash;2001.
<a href="https://doi.org/10.1016/j.jmva.2009.04.008">doi:10.1016/j.jmva.2009.04.008</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_dist">parse_dist()</a></code> and <code><a href="#topic+marginalize_lkjcorr">marginalize_lkjcorr()</a></code> for parsing specs that use the
LKJ correlation distribution and the <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> family of stats for visualizing them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

expand.grid(
  eta = 1:6,
  K = 2:6
) %&gt;%
  ggplot(aes(y = ordered(eta), dist = "lkjcorr_marginal", arg1 = K, arg2 = eta)) +
  stat_slab() +
  facet_grid(~ paste0(K, "x", K)) +
  scale_y_discrete(limits = rev) +
  labs(
    title = paste0(
      "Marginal correlation for LKJ(eta) prior on different matrix sizes:\n",
      "dlkjcorr_marginal(K, eta)"
    ),
    subtitle = "Correlation matrix size (KxK)",
    y = "eta",
    x = "Marginal correlation"
  ) +
  theme(axis.title = element_text(hjust = 0))

</code></pre>

<hr>
<h2 id='marginalize_lkjcorr'>Turn spec for LKJ distribution into spec for marginal LKJ distribution</h2><span id='topic+marginalize_lkjcorr'></span>

<h3>Description</h3>

<p>Turns specs for an LKJ correlation matrix distribution as returned by
<code><a href="#topic+parse_dist">parse_dist()</a></code> into specs for the marginal distribution of
a single cell in an LKJ-distributed correlation matrix (i.e., <code><a href="#topic+lkjcorr_marginal">lkjcorr_marginal()</a></code>).
Useful for visualizing prior correlations from LKJ distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalize_lkjcorr(
  data,
  K,
  predicate = NULL,
  dist = ".dist",
  args = ".args",
  dist_obj = ".dist_obj"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalize_lkjcorr_+3A_data">data</code></td>
<td>
<p>A data frame containing a column with distribution names (<code>".dist"</code> by default)
and a list column of distribution arguments (<code>".args"</code> by default), such as output by
<code><a href="#topic+parse_dist">parse_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="marginalize_lkjcorr_+3A_k">K</code></td>
<td>
<p>Dimension of the correlation matrix. Must be greater than or equal to 2.</p>
</td></tr>
<tr><td><code id="marginalize_lkjcorr_+3A_predicate">predicate</code></td>
<td>
<p>a bare expression for selecting the rows of <code>data</code> to modify. This is useful
if <code>data</code> contains more than one row with an LKJ prior in it and you only want to modify some
of the distributions; if this is the case, give row a predicate expression that evaluates to
<code>TRUE</code> on the rows you want to modify.
If <code>NULL</code> (the default), all <code>lkjcorr</code> distributions in <code>data</code> are modified.</p>
</td></tr>
<tr><td><code id="marginalize_lkjcorr_+3A_dist">dist</code></td>
<td>
<p>The name of the column containing distribution names. See <code><a href="#topic+parse_dist">parse_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="marginalize_lkjcorr_+3A_args">args</code></td>
<td>
<p>The name of the column containing distribution arguments. See <code><a href="#topic+parse_dist">parse_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="marginalize_lkjcorr_+3A_dist_obj">dist_obj</code></td>
<td>
<p>The name of the column to contain a <span class="pkg">distributional</span> object representing the
distribution. See <code><a href="#topic+parse_dist">parse_dist()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LKJ(eta) prior on a correlation matrix induces a marginal prior on each correlation
in the matrix that depends on both the value of <code>eta</code> <em>and</em> <code>K</code>, the dimension
of the <code class="reqn">K \times K</code> correlation matrix. Thus to visualize the marginal prior
on the correlations, it is necessary to specify the value of <code>K</code>, which depends
on what your model specification looks like.
</p>
<p>Given a data frame representing parsed distribution specifications (such
as returned by <code><a href="#topic+parse_dist">parse_dist()</a></code>), this function updates any rows with <code>.dist == "lkjcorr"</code>
so that the first argument to the distribution (stored in <code>.args</code>) is equal to the specified dimension
of the correlation matrix (<code>K</code>), changes the distribution name in <code>.dist</code> to <code>"lkjcorr_marginal"</code>,
and assigns a <span class="pkg">distributional</span> object representing this distribution to <code>.dist_obj</code>.
This allows the distribution to be easily visualized using the <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code>
family of ggplot2 stats.
</p>


<h3>Value</h3>

<p>A data frame of the same size and column names as the input, with the <code>dist</code>, and <code>args</code>,
and <code>dist_obj</code> columns modified on rows where <code>dist == "lkjcorr"</code> such that they represent a
marginal LKJ correlation distribution with name <code>lkjcorr_marginal</code> and <code>args</code> having
<code>K</code> equal to the input value of <code>K</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_dist">parse_dist()</a></code>, <code><a href="#topic+lkjcorr_marginal">lkjcorr_marginal()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

# Say we have an LKJ(3) prior on a 2x2 correlation matrix. We can visualize
# its marginal distribution as follows...
data.frame(prior = "lkjcorr(3)") %&gt;%
  parse_dist(prior) %&gt;%
  marginalize_lkjcorr(K = 2) %&gt;%
  ggplot(aes(y = prior, xdist = .dist_obj)) +
  stat_halfeye() +
  xlim(-1, 1) +
  xlab("Marginal correlation for LKJ(3) prior on 2x2 correlation matrix")

# Say our prior list has multiple LKJ priors on correlation matrices
# of different sizes, we can supply a predicate expression to select
# only those rows we want to modify
data.frame(coef = c("a", "b"), prior = "lkjcorr(3)") %&gt;%
  parse_dist(prior) %&gt;%
  marginalize_lkjcorr(K = 2, coef == "a") %&gt;%
  marginalize_lkjcorr(K = 4, coef == "b")

</code></pre>

<hr>
<h2 id='parse_dist'>Parse distribution specifications into columns of a data frame</h2><span id='topic+parse_dist'></span><span id='topic+parse_dist.default'></span><span id='topic+parse_dist.data.frame'></span><span id='topic+parse_dist.character'></span><span id='topic+parse_dist.factor'></span><span id='topic+parse_dist.brmsprior'></span><span id='topic+r_dist_name'></span>

<h3>Description</h3>

<p>Parses simple string distribution specifications, like <code>"normal(0, 1)"</code>, into two columns of
a data frame, suitable for use with the <code>dist</code> and <code>args</code> aesthetics of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code>
and its shortcut stats (like <code><a href="#topic+stat_halfeye">stat_halfeye()</a></code>). This format is output
by <code>brms::get_prior</code>, making it particularly useful for visualizing priors from
brms models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_dist(
  object,
  ...,
  dist = ".dist",
  args = ".args",
  dist_obj = ".dist_obj",
  package = NULL,
  to_r_names = TRUE
)

## Default S3 method:
parse_dist(object, ...)

## S3 method for class 'data.frame'
parse_dist(
  object,
  dist_col,
  ...,
  dist = ".dist",
  args = ".args",
  dist_obj = ".dist_obj",
  package = NULL,
  lb = "lb",
  ub = "ub",
  to_r_names = TRUE
)

## S3 method for class 'character'
parse_dist(
  object,
  ...,
  dist = ".dist",
  args = ".args",
  dist_obj = ".dist_obj",
  package = NULL,
  to_r_names = TRUE
)

## S3 method for class 'factor'
parse_dist(
  object,
  ...,
  dist = ".dist",
  args = ".args",
  dist_obj = ".dist_obj",
  package = NULL,
  to_r_names = TRUE
)

## S3 method for class 'brmsprior'
parse_dist(
  object,
  dist_col = prior,
  ...,
  dist = ".dist",
  args = ".args",
  dist_obj = ".dist_obj",
  package = NULL,
  to_r_names = TRUE
)

r_dist_name(dist_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_dist_+3A_object">object</code></td>
<td>
<p>A character vector containing distribution specifications or a data frame with a column
containing distribution specifications.</p>
</td></tr>
<tr><td><code id="parse_dist_+3A_...">...</code></td>
<td>
<p>Arguments passed to other implementations of <code>parse_dist</code>.</p>
</td></tr>
<tr><td><code id="parse_dist_+3A_dist">dist</code></td>
<td>
<p>The name of the output column to contain the distribution name</p>
</td></tr>
<tr><td><code id="parse_dist_+3A_args">args</code></td>
<td>
<p>The name of the output column to contain the arguments to the distribution</p>
</td></tr>
<tr><td><code id="parse_dist_+3A_dist_obj">dist_obj</code></td>
<td>
<p>The name of the output column to contain a <span class="pkg">distributional</span> object representing the distribution</p>
</td></tr>
<tr><td><code id="parse_dist_+3A_package">package</code></td>
<td>
<p>The package or environment to search for distribution functions in.
Passed to <code><a href="distributional.html#topic+dist_wrap">distributional::dist_wrap()</a></code>. One of:
</p>

<ul>
<li> <p><code>NULL</code>: use the calling environment
</p>
</li>
<li><p> a string: use the environment for the package with the given name
</p>
</li>
<li><p> an <a href="base.html#topic+environment">environment</a>: use the given environment
</p>
</li></ul>
</td></tr>
<tr><td><code id="parse_dist_+3A_to_r_names">to_r_names</code></td>
<td>
<p>If <code>TRUE</code> (the default), certain common aliases for distribution names are
automatically translated into names that R can recognize (i.e., names which have functions starting
with <code>r</code>, <code>p</code>, <code>q</code>, and <code>d</code> representing random number generators, distribution
functions, etc. for that distribution), using the <code>r_dist_name</code> function. For example,
<code>"normal"</code> is translated into <code>"norm"</code> and <code>"lognormal"</code> is translated into <code>"lnorm"</code>.</p>
</td></tr>
<tr><td><code id="parse_dist_+3A_dist_col">dist_col</code></td>
<td>
<p>A bare (unquoted) column or column expression that resolves to a character vector
of distribution specifications.</p>
</td></tr>
<tr><td><code id="parse_dist_+3A_lb">lb</code></td>
<td>
<p>The name of an input column (for <code>data.frame</code> and <code>brms::prior</code> objects) that contains
the lower bound of the distribution, which if present will produce a truncated distribution using
<code><a href="distributional.html#topic+dist_truncated">dist_truncated()</a></code>. Ignored if <code>lb</code> is <code>NULL</code> or if <code>object[[lb]]</code> is <code>NA</code> for the corresponding
input row.</p>
</td></tr>
<tr><td><code id="parse_dist_+3A_ub">ub</code></td>
<td>
<p>The name of an input column (for <code>data.frame</code> and <code>brms::prior</code> objects) that contains
the upper bound of the distribution, which if present will produce a truncated distribution using
<code><a href="distributional.html#topic+dist_truncated">dist_truncated()</a></code>. Ignored if <code>ub</code> is <code>NULL</code> or if <code>object[[ub]]</code> is <code>NA</code> for the corresponding
input row.</p>
</td></tr>
<tr><td><code id="parse_dist_+3A_dist_name">dist_name</code></td>
<td>
<p>For <code>r_dist_name</code>, a character vector of distribution names to be translated into
distribution names R recognizes. Unrecognized names are left as-is.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+parse_dist">parse_dist()</a></code> can be applied to character vectors or to a data frame + bare column name of the
column to parse, and returns a data frame with <code>".dist"</code> and <code>".args"</code> columns added.
<code><a href="#topic+parse_dist">parse_dist()</a></code> uses <code><a href="#topic+r_dist_name">r_dist_name()</a></code> to translate distribution names into names recognized
by R.
</p>
<p><code><a href="#topic+r_dist_name">r_dist_name()</a></code> takes a character vector of names and translates common names into R
distribution names. Names are first made into valid R names using <code><a href="base.html#topic+make.names">make.names()</a></code>,
then translated (ignoring character case, <code>"."</code>, and <code>"_"</code>). Thus, <code>"lognormal"</code>,
<code>"LogNormal"</code>, <code>"log_normal"</code>, <code>"log-Normal"</code>, and any number of other variants
all get translated into <code>"lnorm"</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>parse_dist</code> returns a data frame containing at least two columns named after the <code>dist</code> and <code>args</code>
parameters. If the input is a data frame, the output is a data frame of the same length with those
two columns added. If the input is a character vector or factor, the output is a two-column data frame
with the same number of rows as the length of the input.
</p>
</li>
<li> <p><code>r_dist_name</code> returns a character vector the same length as the input containing translations of the
input names into distribution names R can recognize.
</p>
</li></ul>



<h3>See Also</h3>

<p>See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and its shortcut stats, which can easily make use of
the output of this function using the <code>dist</code> and <code>args</code> aesthetics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# parse dist can operate on strings directly...
parse_dist(c("normal(0,1)", "student_t(3,0,1)"))

# ... or on columns of a data frame, where it adds the
# parsed specs back on as columns
data.frame(prior = c("normal(0,1)", "student_t(3,0,1)")) %&gt;%
  parse_dist(prior)

# parse_dist is particularly useful with the output of brms::prior(),
# which follows the same format as above

</code></pre>

<hr>
<h2 id='partial_colour_ramp'>Partial colour ramp (datatype)</h2><span id='topic+partial_colour_ramp'></span>

<h3>Description</h3>

<p>A representation of a partial ramp between two colours: the origin colour
(<code>from</code>) and the distance from the origin colour to the target colour
(<code>amount</code>, a value between <code>0</code> and <code>1</code>). The target colour of the ramp
can be filled in later using <code>ramp_colours()</code>, producing a colour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_colour_ramp(amount = double(), from = "white")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_colour_ramp_+3A_amount">amount</code></td>
<td>
<p>Numeric vector between <code>0</code> and <code>1</code> giving amounts to ramp
the colour. <code>0</code> corresponds to the colour <code>from</code>.</p>
</td></tr>
<tr><td><code id="partial_colour_ramp_+3A_from">from</code></td>
<td>
<p>Character vector giving colours to ramp from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This datatype is used by <a href="#topic+scale_colour_ramp">scale_colour_ramp</a> to create ramped colours in
<span class="pkg">ggdist</span> geoms. It is a <a href="vctrs.html#topic+new_rcrd">vctrs::rcrd</a> datatype with two fields:
<code>"amount"</code>, the amount to ramp, and <code>"from"</code>, the colour to ramp from.
</p>
<p>Colour ramps can be applied (i.e. translated into colours) using
<code><a href="#topic+ramp_colours">ramp_colours()</a></code>, which can be used with <code><a href="#topic+partial_colour_ramp">partial_colour_ramp()</a></code>
to implement geoms that make use of <code>colour_ramp</code> or <code>fill_ramp</code> scales.
</p>


<h3>Value</h3>

<p>A <a href="vctrs.html#topic+new_rcrd">vctrs::rcrd</a> of class <code>"ggdist_partial_colour_ramp"</code> with fields
<code>"amount"</code> and <code>"from"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>Other colour ramp functions: 
<code><a href="#topic+guide_rampbar">guide_rampbar</a>()</code>,
<code><a href="#topic+ramp_colours">ramp_colours</a>()</code>,
<code><a href="#topic+scale_colour_ramp">scale_colour_ramp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcr = partial_colour_ramp(c(0, 0.25, 0.75, 1), "red")
pcr

ramp_colours("blue", pcr)
</code></pre>

<hr>
<h2 id='point_interval'>Point and interval summaries for tidy data frames of draws from distributions</h2><span id='topic+point_interval'></span><span id='topic+point_interval.default'></span><span id='topic+point_interval.numeric'></span><span id='topic+point_interval.rvar'></span><span id='topic+point_interval.distribution'></span><span id='topic+qi'></span><span id='topic+ll'></span><span id='topic+ul'></span><span id='topic+hdi'></span><span id='topic+Mode'></span><span id='topic+Mode.default'></span><span id='topic+Mode.rvar'></span><span id='topic+Mode.distribution'></span><span id='topic+hdci'></span><span id='topic+mean_qi'></span><span id='topic+median_qi'></span><span id='topic+mode_qi'></span><span id='topic+mean_ll'></span><span id='topic+median_ll'></span><span id='topic+mode_ll'></span><span id='topic+mean_ul'></span><span id='topic+median_ul'></span><span id='topic+mode_ul'></span><span id='topic+mean_hdi'></span><span id='topic+median_hdi'></span><span id='topic+mode_hdi'></span><span id='topic+mean_hdci'></span><span id='topic+median_hdci'></span><span id='topic+mode_hdci'></span>

<h3>Description</h3>

<p>Translates draws from distributions in a (possibly grouped) data frame into point and
interval summaries (or set of point and interval summaries, if there are
multiple groups in a grouped data frame).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_interval(
  .data,
  ...,
  .width = 0.95,
  .point = median,
  .interval = qi,
  .simple_names = TRUE,
  na.rm = FALSE,
  .exclude = c(".chain", ".iteration", ".draw", ".row"),
  .prob
)

## Default S3 method:
point_interval(
  .data,
  ...,
  .width = 0.95,
  .point = median,
  .interval = qi,
  .simple_names = TRUE,
  na.rm = FALSE,
  .exclude = c(".chain", ".iteration", ".draw", ".row"),
  .prob
)

## S3 method for class 'numeric'
point_interval(
  .data,
  ...,
  .width = 0.95,
  .point = median,
  .interval = qi,
  .simple_names = FALSE,
  na.rm = FALSE,
  .exclude = c(".chain", ".iteration", ".draw", ".row"),
  .prob
)

## S3 method for class 'rvar'
point_interval(
  .data,
  ...,
  .width = 0.95,
  .point = median,
  .interval = qi,
  .simple_names = TRUE,
  na.rm = FALSE
)

## S3 method for class 'distribution'
point_interval(
  .data,
  ...,
  .width = 0.95,
  .point = median,
  .interval = qi,
  .simple_names = TRUE,
  na.rm = FALSE
)

qi(x, .width = 0.95, .prob, na.rm = FALSE)

ll(x, .width = 0.95, na.rm = FALSE)

ul(x, .width = 0.95, na.rm = FALSE)

hdi(
  x,
  .width = 0.95,
  na.rm = FALSE,
  ...,
  density = density_bounded(trim = TRUE),
  n = 4096,
  .prob
)

Mode(x, na.rm = FALSE, ...)

## Default S3 method:
Mode(
  x,
  na.rm = FALSE,
  ...,
  density = density_bounded(trim = TRUE),
  n = 2001,
  weights = NULL
)

## S3 method for class 'rvar'
Mode(x, na.rm = FALSE, ...)

## S3 method for class 'distribution'
Mode(x, na.rm = FALSE, ...)

hdci(x, .width = 0.95, na.rm = FALSE)

mean_qi(.data, ..., .width = 0.95)

median_qi(.data, ..., .width = 0.95)

mode_qi(.data, ..., .width = 0.95)

mean_ll(.data, ..., .width = 0.95)

median_ll(.data, ..., .width = 0.95)

mode_ll(.data, ..., .width = 0.95)

mean_ul(.data, ..., .width = 0.95)

median_ul(.data, ..., .width = 0.95)

mode_ul(.data, ..., .width = 0.95)

mean_hdi(.data, ..., .width = 0.95)

median_hdi(.data, ..., .width = 0.95)

mode_hdi(.data, ..., .width = 0.95)

mean_hdci(.data, ..., .width = 0.95)

median_hdci(.data, ..., .width = 0.95)

mode_hdci(.data, ..., .width = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point_interval_+3A_.data">.data</code></td>
<td>
<p>Data frame (or grouped data frame as returned by <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>)
that contains draws to summarize.</p>
</td></tr>
<tr><td><code id="point_interval_+3A_...">...</code></td>
<td>
<p>Bare column names or expressions that, when evaluated in the context of
<code>.data</code>, represent draws to summarize. If this is empty, then by default all
columns that are not group columns and which are not in <code>.exclude</code> (by default
<code>".chain"</code>, <code>".iteration"</code>, <code>".draw"</code>, and <code>".row"</code>) will be summarized.
These columns can be numeric, <span class="pkg">distributional</span> objects, <code>posterior::rvar</code>s,
or list columns of numeric values to summarise.</p>
</td></tr>
<tr><td><code id="point_interval_+3A_.width">.width</code></td>
<td>
<p>vector of probabilities to use that determine the widths of the resulting intervals.
If multiple probabilities are provided, multiple rows per group are generated, each with
a different probability interval (and value of the corresponding <code>.width</code> column).</p>
</td></tr>
<tr><td><code id="point_interval_+3A_.point">.point</code></td>
<td>
<p>Point summary function, which takes a vector and returns a single
value, e.g. <code><a href="base.html#topic+mean">mean()</a></code>, <code><a href="stats.html#topic+median">median()</a></code>, or <code><a href="#topic+Mode">Mode()</a></code>.</p>
</td></tr>
<tr><td><code id="point_interval_+3A_.interval">.interval</code></td>
<td>
<p>Interval function, which takes a vector and a probability
(<code>.width</code>) and returns a two-element vector representing the lower and upper
bound of an interval; e.g. <code><a href="#topic+qi">qi()</a></code>, <code><a href="#topic+hdi">hdi()</a></code></p>
</td></tr>
<tr><td><code id="point_interval_+3A_.simple_names">.simple_names</code></td>
<td>
<p>When <code>TRUE</code> and only a single column / vector is to be summarized, use the
name <code>.lower</code> for the lower end of the interval and <code>.upper</code> for the
upper end. If <code>.data</code> is a vector and this is <code>TRUE</code>, this will also set the column name
of the point summary to <code>.value</code>. When <code>FALSE</code> and <code>.data</code> is a data frame,
names the lower and upper intervals for each column <code>x</code> <code>x.lower</code> and <code>x.upper</code>.
When <code>FALSE</code> and <code>.data</code> is a vector, uses the naming scheme <code>y</code>, <code>ymin</code>
and <code>ymax</code> (for use with ggplot).</p>
</td></tr>
<tr><td><code id="point_interval_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values should be stripped before the computation proceeds.
If <code>FALSE</code> (the default), any vectors to be summarized that contain <code>NA</code> will result in
point and interval summaries equal to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="point_interval_+3A_.exclude">.exclude</code></td>
<td>
<p>A character vector of names of columns to be excluded from summarization
if no column names are specified to be summarized. Default ignores several meta-data column
names used in <span class="pkg">ggdist</span> and <span class="pkg">tidybayes</span>.</p>
</td></tr>
<tr><td><code id="point_interval_+3A_.prob">.prob</code></td>
<td>
<p>Deprecated. Use <code>.width</code> instead.</p>
</td></tr>
<tr><td><code id="point_interval_+3A_x">x</code></td>
<td>
<p>vector to summarize (for interval functions: <code>qi</code> and <code>hdi</code>)</p>
</td></tr>
<tr><td><code id="point_interval_+3A_density">density</code></td>
<td>
<p>For <code><a href="#topic+hdi">hdi()</a></code> and <code><a href="#topic+Mode">Mode()</a></code>, the kernel density estimator to use, either as
a function (e.g. <code><a href="#topic+density_bounded">density_bounded</a></code>, <code><a href="#topic+density_unbounded">density_unbounded</a></code>) or as a string giving the
suffix to a function that starts with <code>density_</code> (e.g. <code>"bounded"</code> or <code>"unbounded"</code>). The
default, <code>"bounded"</code>, uses the bounded density estimator of <code><a href="#topic+density_bounded">density_bounded()</a></code>, which
itself estimates the bounds of the distribution, and tends to work well on both bounded
and unbounded data.</p>
</td></tr>
<tr><td><code id="point_interval_+3A_n">n</code></td>
<td>
<p>For <code><a href="#topic+hdi">hdi()</a></code> and <code><a href="#topic+Mode">Mode()</a></code>, the number of points to use to estimate highest-density
intervals or modes.</p>
</td></tr>
<tr><td><code id="point_interval_+3A_weights">weights</code></td>
<td>
<p>For <code><a href="#topic+Mode">Mode()</a></code>, an optional vector, which (if not <code>NULL</code>) is of the same length
as <code>x</code> and provides weights for each element of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>.data</code> is a data frame, then <code>...</code> is a list of bare names of
columns (or expressions derived from columns) of <code>.data</code>, on which
the point and interval summaries are derived. Column expressions are processed
using the tidy evaluation framework (see <code><a href="rlang.html#topic+eval_tidy">rlang::eval_tidy()</a></code>).
</p>
<p>For a column named <code>x</code>, the resulting data frame will have a column
named <code>x</code> containing its point summary. If there is a single
column to be summarized and <code>.simple_names</code> is <code>TRUE</code>, the output will
also contain columns <code>.lower</code> (the lower end of the interval),
<code>.upper</code> (the upper end of the interval).
Otherwise, for every summarized column <code>x</code>, the output will contain
<code>x.lower</code> (the lower end of the interval) and <code>x.upper</code> (the upper
end of the interval). Finally, the output will have a <code>.width</code> column
containing the' probability for the interval on each output row.
</p>
<p>If <code>.data</code> includes groups (see e.g. <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>),
the points and intervals are calculated within the groups.
</p>
<p>If <code>.data</code> is a vector, <code>...</code> is ignored and the result is a
data frame with one row per value of <code>.width</code> and three columns:
<code>y</code> (the point summary), <code>ymin</code> (the lower end of the interval),
<code>ymax</code> (the upper end of the interval), and <code>.width</code>, the probability
corresponding to the interval. This behavior allows <code>point_interval</code>
and its derived functions (like <code>median_qi</code>, <code>mean_qi</code>, <code>mode_hdi</code>, etc)
to be easily used to plot intervals in ggplot stats using methods like
<code><a href="#topic+stat_eye">stat_eye()</a></code>, <code><a href="#topic+stat_halfeye">stat_halfeye()</a></code>, or <code><a href="ggplot2.html#topic+stat_summary">stat_summary()</a></code>.
</p>
<p><code>median_qi</code>, <code>mode_hdi</code>, etc are short forms for
<code>point_interval(..., .point = median, .interval = qi)</code>, etc.
</p>
<p><code>qi</code> yields the quantile interval (also known as the percentile interval or
equi-tailed interval) as a 1x2 matrix.
</p>
<p><code>hdi</code> yields the highest-density interval(s) (also known as the highest posterior
density interval). <strong>Note:</strong> If the distribution is multimodal, <code>hdi</code> may return multiple
intervals for each probability level (these will be spread over rows). You may wish to use
<code>hdci</code> (below) instead if you want a single highest-density interval, with the caveat that when
the distribution is multimodal <code>hdci</code> is not a highest-density interval.
</p>
<p><code>hdci</code> yields the highest-density <em>continuous</em> interval, also known as the shortest
probability interval. <strong>Note:</strong> If the distribution is multimodal, this may not actually
be the highest-density interval (there may be a higher-density
discontinuous interval, which can be found using <code>hdi</code>).
</p>
<p><code>ll</code> and <code>ul</code> yield lower limits and upper limits, respectively (where the opposite
limit is set to either <code>Inf</code> or <code>-Inf</code>).
</p>


<h3>Value</h3>

<p>A data frame containing point summaries and intervals, with at least one column corresponding
to the point summary, one to the lower end of the interval, one to the upper end of the interval, the
width of the interval (<code>.width</code>), the type of point summary (<code>.point</code>), and the type of interval (<code>.interval</code>).
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

set.seed(123)

rnorm(1000) %&gt;%
  median_qi()

data.frame(x = rnorm(1000)) %&gt;%
  median_qi(x, .width = c(.50, .80, .95))

data.frame(
    x = rnorm(1000),
    y = rnorm(1000, mean = 2, sd = 2)
  ) %&gt;%
  median_qi(x, y)

data.frame(
    x = rnorm(1000),
    group = "a"
  ) %&gt;%
  rbind(data.frame(
    x = rnorm(1000, mean = 2, sd = 2),
    group = "b")
  ) %&gt;%
  group_by(group) %&gt;%
  median_qi(.width = c(.50, .80, .95))

multimodal_draws = data.frame(
    x = c(rnorm(5000, 0, 1), rnorm(2500, 4, 1))
  )

multimodal_draws %&gt;%
  mode_hdi(.width = c(.66, .95))

multimodal_draws %&gt;%
  ggplot(aes(x = x, y = 0)) +
  stat_halfeye(point_interval = mode_hdi, .width = c(.66, .95))

</code></pre>

<hr>
<h2 id='position_dodgejust'>Dodge overlapping objects side-to-side, preserving justification</h2><span id='topic+position_dodgejust'></span>

<h3>Description</h3>

<p>A justification-preserving variant of <code><a href="ggplot2.html#topic+position_dodge">ggplot2::position_dodge()</a></code> which preserves the
vertical position of a geom while adjusting the horizontal position (or vice
versa when in a horizontal orientation). Unlike <code><a href="ggplot2.html#topic+position_dodge">ggplot2::position_dodge()</a></code>,
<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code> attempts to preserve the &quot;justification&quot; of <code>x</code>
positions relative to the bounds containing them (<code>xmin</code>/<code>xmax</code>) (or <code>y</code>
positions relative to <code>ymin</code>/<code>ymax</code> when in a horizontal orientation). This
makes it useful for dodging annotations to geoms and stats from the
<code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> family, which also preserve the justification of their
intervals relative to their slabs when dodging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_dodgejust(
  width = NULL,
  preserve = c("total", "single"),
  justification = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_dodgejust_+3A_width">width</code></td>
<td>
<p>Dodging width, when different to the width of the individual
elements. This is useful when you want to align narrow geoms with wider
geoms. See the examples.</p>
</td></tr>
<tr><td><code id="position_dodgejust_+3A_preserve">preserve</code></td>
<td>
<p>Should dodging preserve the <code>"total"</code> width of all elements
at a position, or the width of a <code>"single"</code> element?</p>
</td></tr>
<tr><td><code id="position_dodgejust_+3A_justification">justification</code></td>
<td>
<p>Justification of the point position (<code>x</code>/<code>y</code>) relative
to its bounds (<code>xmin</code>/<code>xmax</code> or <code>ymin</code>/<code>ymax</code>), where <code>0</code> indicates
bottom/left justification and <code>1</code> indicates top/right justification
(depending on <code>orientation</code>). This is only used if <code>xmin</code>/<code>xmax</code>/<code>ymin</code>/<code>ymax</code>
are not supplied; in that case, <code>justification</code> will be used along with
<code>width</code> to determine the bounds of the object prior to dodging.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)
library(distributional)

dist_df = tribble(
  ~group, ~subgroup, ~mean, ~sd,
  1,          "h",     5,   1,
  2,          "h",     7,   1.5,
  3,          "h",     8,   1,
  3,          "i",     9,   1,
  3,          "j",     7,   1
)

# An example with normal "dodge" positioning
# Notice how dodge points are placed in the center of their bounding boxes,
# which can cause slabs to be positioned outside their bounds.
dist_df %&gt;%
  ggplot(aes(
    x = factor(group), ydist = dist_normal(mean, sd),
    fill = subgroup
  )) +
  stat_halfeye(
    position = "dodge"
  ) +
  geom_rect(
    aes(xmin = group, xmax = group + 1, ymin = 2, ymax = 13, color = subgroup),
    position = "dodge",
    data = . %&gt;% filter(group == 3),
    alpha = 0.1
  ) +
  geom_point(
    aes(x = group, y = 7.5, color = subgroup),
    position = position_dodge(width = 1),
    data = . %&gt;% filter(group == 3),
    shape = 1,
    size = 4,
    stroke = 1.5
  ) +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Dark2")

# This same example with "dodgejust" positioning. For the points we
# supply a justification parameter to position_dodgejust which mimics the
# justification parameter of stat_halfeye, ensuring that they are
# placed appropriately. On slabinterval family geoms, position_dodgejust()
# will automatically detect the appropriate justification.
dist_df %&gt;%
  ggplot(aes(
    x = factor(group), ydist = dist_normal(mean, sd),
    fill = subgroup
  )) +
  stat_halfeye(
    position = "dodgejust"
  ) +
  geom_rect(
    aes(xmin = group, xmax = group + 1, ymin = 2, ymax = 13, color = subgroup),
    position = "dodgejust",
    data = . %&gt;% filter(group == 3),
    alpha = 0.1
  ) +
  geom_point(
    aes(x = group, y = 7.5, color = subgroup),
    position = position_dodgejust(width = 1, justification = 0),
    data = . %&gt;% filter(group == 3),
    shape = 1,
    size = 4,
    stroke = 1.5
  ) +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Dark2")



</code></pre>

<hr>
<h2 id='Pr_'>Probability expressions in ggdist aesthetics</h2><span id='topic+Pr_'></span><span id='topic+p_'></span>

<h3>Description</h3>

<p><strong>Experimental</strong> probability-like expressions that can be used in place of
some <code>after_stat()</code> expressions in aesthetic assignments in <span class="pkg">ggdist</span> stats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pr_(x)

p_(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pr__+3A_x">x</code></td>
<td>
<p>Bare (unevaluated) expressions. See <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+Pr_">Pr_()</a></code> and <code><a href="#topic+p_">p_()</a></code> are an <strong>experimental</strong> mini-language for specifying aesthetic values
based on probabilities and probability densities derived from distributions
supplied to <span class="pkg">ggdist</span> stats (e.g., in <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code>,
<code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>, etc.). They generate expressions that use <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
and the computed variables of the stat (such as <code>cdf</code> and <code>pdf</code>; see e.g.
the <strong>Computed Variables</strong> section of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code>) to compute
the desired probabilities or densities.
</p>
<p>For example, one way to map the density of a distribution onto the <code>alpha</code>
aesthetic of a slab is to use <code>after_stat(pdf)</code>:
</p>
<div class="sourceCode"><pre>ggplot() +
  stat_slab(aes(xdist = distributional::dist_normal(), alpha = after_stat(pdf)))
</pre></div>
<p><span class="pkg">ggdist</span> probability expressions offer an alternative, equivalent syntax:
</p>
<div class="sourceCode"><pre>ggplot() +
  stat_slab(aes(xdist = distributional::dist_normal(), alpha = !!p_(x)))
</pre></div>
<p>Where <code>p_(x)</code> is the probability density function. The use of <code style="white-space: pre;">&#8288;!!&#8288;</code> is
necessary to splice the generated expression into the <code>aes()</code> call; for
more information, see <a href="rlang.html#topic+quasiquotation">quasiquotation</a>.
</p>


<h3>Probability expressions</h3>

<p>Probability expressions consist of a call to <code>Pr_()</code> or <code>p_()</code> containing
a small number of valid combinations of operators and variable names.
</p>
<p>Valid variables in probability expressions include:
</p>

<ul>
<li> <p><code>x</code>, <code>y</code>, or <code>value</code>: values along the <code>x</code> or <code>y</code> axis. <code>value</code> is the
orientation-neutral form.
</p>
</li>
<li> <p><code>xdist</code>, <code>ydist</code>, or <code>dist</code>: distributions mapped along the <code>x</code> or <code>y</code>
axis. <code>dist</code> is the orientation-neutral form. <code>X</code> and <code>Y</code> can also be
used as synonyms for <code>xdist</code> and <code>ydist</code>.
</p>
</li>
<li> <p><code>interval</code>: the smallest interval containing the current <code>x</code>/<code>y</code> value.
</p>
</li></ul>

<p><code>Pr_()</code> generates expressions for probabilities, e.g. cumulative distribution
functions (CDFs). Valid operators inside <code>Pr_()</code> are:
</p>

<ul>
<li> <p><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>: generates values of the cumulative distribution
function (CDF) or complementary CDF by comparing one of {<code>x</code>, <code>y</code>, <code>value</code>}
to one of {<code>xdist</code>, <code>ydist</code>, <code>dist</code>, <code>X</code>, <code>Y</code>}. For example, <code>Pr_(xdist &lt;= x)</code>
gives the CDF and <code>Pr_(xdist &gt; x)</code> gives the CCDF.
</p>
</li>
<li> <p><code>%in%</code>: currently can only be used with <code>interval</code> on the right-hand side:
gives the probability of {<code>x</code>, <code>y</code>, <code>value</code>} (left-hand side) being in the
smallest interval the stat generated that contains the value; e.g.
<code>Pr_(x %in% interval)</code>.
</p>
</li></ul>

<p><code>p_()</code> generates expressions for probability density functions or probability mass
functions (depending on if the underlying distribution is continuous or
discrete). It currently does not allow any operators in the expression, and
must be passed one of <code>x</code>, <code>y</code>, or <code>value</code>.
</p>


<h3>See Also</h3>

<p>The <em>Computed Variables</em> section of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> (especially
<code>cdf</code> and <code>pdf</code>) and the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(distributional)

df = data.frame(
  d = c(dist_normal(2.7, 1), dist_lognormal(1, 1/3)),
  name = c("normal", "lognormal")
)

# map density onto alpha of the fill
ggplot(df, aes(y = name, xdist = d)) +
  stat_slabinterval(aes(alpha = !!p_(x)))

# map CCDF onto thickness (like stat_ccdfinterval())
ggplot(df, aes(y = name, xdist = d)) +
  stat_slabinterval(aes(thickness = !!Pr_(xdist &gt; x)))

# map containing interval onto fill
ggplot(df, aes(y = name, xdist = d)) +
  stat_slabinterval(aes(fill = !!Pr_(x %in% interval)))

# the color scale in the previous example is not great, so turn the
# probability into an ordered factor and adjust the fill scale.
# Though, see also the `level` computed variable in `stat_slabinterval()`,
# which is probably easier to use to create this style of chart.
ggplot(df, aes(y = name, xdist = d)) +
  stat_slabinterval(aes(fill = ordered(!!Pr_(x %in% interval)))) +
  scale_fill_brewer(direction = -1)

</code></pre>

<hr>
<h2 id='ramp_colours'>Apply partial colour ramps</h2><span id='topic+ramp_colours'></span>

<h3>Description</h3>

<p>Given vectors of colours and <code><a href="#topic+partial_colour_ramp">partial_colour_ramp</a></code>s, ramps the colours
according to the parameters of the partial colour ramps, returning
a vector of the same length as the inputs giving the transformed
(ramped) colours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ramp_colours(colour, ramp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ramp_colours_+3A_colour">colour</code></td>
<td>
<p>character vector of colours.</p>
</td></tr>
<tr><td><code id="ramp_colours_+3A_ramp">ramp</code></td>
<td>
<p>a <code><a href="#topic+partial_colour_ramp">partial_colour_ramp</a></code> vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes vectors of colours and <code><a href="#topic+partial_colour_ramp">partial_colour_ramp</a></code>s and produces
colours by interpolating between each <code>from</code> colour and the target <code>colour</code>
the specified <code>amount</code> (where <code>amount</code> and <code>from</code> are the corresponding
fields of the <code>ramp</code>).
</p>
<p>For example, to add support for the <code>fill_ramp</code> aesthetic to a geometry,
this line could be used inside the <code>draw_group()</code> or <code>draw_panel()</code> method
of a geom:
</p>
<div class="sourceCode"><pre>data$fill = ramp_colours(data$fill, data$fill_ramp)
</pre></div>


<h3>Value</h3>

<p>A character vector of colours.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>Other colour ramp functions: 
<code><a href="#topic+guide_rampbar">guide_rampbar</a>()</code>,
<code><a href="#topic+partial_colour_ramp">partial_colour_ramp</a>()</code>,
<code><a href="#topic+scale_colour_ramp">scale_colour_ramp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcr = partial_colour_ramp(c(0, 0.25, 0.75, 1), "red")
pcr

ramp_colours("blue", pcr)
</code></pre>

<hr>
<h2 id='RankCorr'>Thinned subset of posterior sample from a Bayesian analysis of perception of correlation.</h2><span id='topic+RankCorr'></span><span id='topic+RankCorr_u_tau'></span>

<h3>Description</h3>

<p>Data from Kay and Heer (2016), primarily used for testing and examples.
</p>


<h3>Details</h3>

<p>For more details, see Kay and Heer (2016) or the Github repository describing the analysis:
<a href="https://github.com/mjskay/ranking-correlation">https://github.com/mjskay/ranking-correlation</a>. The original experiment (but not this analysis of it)
is described in Harrison <em>et al.</em> (2014).
</p>
<p><code>data("RankCorr")</code> is a substantially thinned version of the original posterior sample and has omitted several
parameters in order for it to be a more manageable size.
</p>
<p><code>data("RankCorr_u_tau")</code> is used for testing and examples and is roughly the equivalent of the following:
</p>
<div class="sourceCode"><pre>data("RankCorr")
RankCorr_u_tau = tidybayes::spread_draws(RankCorr, u_tau[i]))
</pre></div>


<h3>References</h3>

<p>Kay, Matthew, and Jeffrey Heer. (2016).
&quot;Beyond Weber's law: A second look at ranking visualizations of correlation.&quot;
<em>IEEE transactions on visualization and computer graphics</em> 22(1): 469-478.
<a href="https://doi.org/10.1109/TVCG.2015.2467671">doi:10.1109/TVCG.2015.2467671</a>
</p>
<p>Harrison, Lane, Fumeng Yang, Steven Franconeri, and Remco Chang. (2014).
&quot;Ranking visualizations of correlation using Weber's law.&quot;
<em>IEEE transactions on visualization and computer graphics</em> 20(12): 1943-1952.
<a href="https://doi.org/10.1109/TVCG.2014.2346979">doi:10.1109/TVCG.2014.2346979</a>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+waiver'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+waiver">waiver</a></code></p>
</dd>
</dl>

<hr>
<h2 id='scale_colour_ramp'>Secondary color scale that ramps from another color (ggplot2 scale)</h2><span id='topic+scale_colour_ramp'></span><span id='topic+scale_colour_ramp_continuous'></span><span id='topic+scale_color_ramp'></span><span id='topic+scale_fill_ramp'></span><span id='topic+scale_color_ramp_continuous'></span><span id='topic+scale_colour_ramp_discrete'></span><span id='topic+scale_color_ramp_discrete'></span><span id='topic+scale_fill_ramp_continuous'></span><span id='topic+scale_fill_ramp_discrete'></span>

<h3>Description</h3>

<p>This scale creates a secondary scale that modifies the <code>fill</code> or <code>color</code> scale of
geoms that support it (<code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> and <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>) to &quot;ramp&quot;
from a secondary color (by default white) to the primary fill color (determined
by the standard <code>color</code> or <code>fill</code> aesthetics). It uses the
<code><a href="#topic+partial_colour_ramp">partial_colour_ramp()</a></code> data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_ramp_continuous(
  from = "white",
  ...,
  limits = function(l) c(min(0, l[[1]]), l[[2]]),
  range = c(0, 1),
  guide = "legend",
  aesthetics = "colour_ramp"
)

scale_color_ramp_continuous(
  from = "white",
  ...,
  limits = function(l) c(min(0, l[[1]]), l[[2]]),
  range = c(0, 1),
  guide = "legend",
  aesthetics = "colour_ramp"
)

scale_colour_ramp_discrete(
  from = "white",
  ...,
  range = c(0.2, 1),
  aesthetics = "colour_ramp"
)

scale_color_ramp_discrete(
  from = "white",
  ...,
  range = c(0.2, 1),
  aesthetics = "colour_ramp"
)

scale_fill_ramp_continuous(..., aesthetics = "fill_ramp")

scale_fill_ramp_discrete(..., aesthetics = "fill_ramp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_ramp_+3A_from">from</code></td>
<td>
<p>The color to ramp from. Corresponds to <code>0</code> on the scale.</p>
</td></tr>
<tr><td><code id="scale_colour_ramp_+3A_...">...</code></td>
<td>
<p>Arguments passed to underlying scale or guide functions. E.g.
<code><a href="#topic+scale_colour_ramp_discrete">scale_colour_ramp_discrete()</a></code> passes arguments to <code><a href="ggplot2.html#topic+discrete_scale">discrete_scale()</a></code>,
<code><a href="#topic+scale_colour_ramp_continuous">scale_colour_ramp_continuous()</a></code> passes arguments to <code><a href="ggplot2.html#topic+continuous_scale">continuous_scale()</a></code>.
See those functions for more details.</p>
</td></tr>
<tr><td><code id="scale_colour_ramp_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_colour_ramp_+3A_range">range</code></td>
<td>
<p>a numeric vector of length 2 that specifies the minimum and maximum
values after the scale transformation. These values should be between <code>0</code>
(the <code>from</code> color) and <code>1</code> (the color determined by the <code>fill</code> aesthetic).</p>
</td></tr>
<tr><td><code id="scale_colour_ramp_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. For
<code><a href="#topic+scale_colour_ramp_continuous">scale_colour_ramp_continuous()</a></code> and <code><a href="#topic+scale_fill_ramp_continuous">scale_fill_ramp_continuous()</a></code>,
<code><a href="#topic+guide_rampbar">guide_rampbar()</a></code> can be used to create gradient color bars. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for information on other guides.</p>
</td></tr>
<tr><td><code id="scale_colour_ramp_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Names of aesthetics to set scales for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These scales transform data into <code><a href="#topic+partial_colour_ramp">partial_colour_ramp</a></code>s. Each <code><a href="#topic+partial_colour_ramp">partial_colour_ramp</a></code>
is a pair of two values: a <code>from</code> colour and a numeric <code>amount</code> between <code>0</code>
and <code>1</code> representing a distance between <code>from</code> and the target color (where <code>0</code>
indicates the <code>from</code> color and <code>1</code> the target color).
</p>
<p>The target color is determined by the corresponding aesthetic: for example,
the <code>colour_ramp</code> aesthetic creates ramps between <code>from</code> and whatever the
value of the <code>colour</code> aesthetic is; the <code>fill_ramp</code> aesthetic creates ramps
between <code>from</code> and whatever the value of the <code>fill</code> aesthetic is. When the
<code>colour_ramp</code> aesthetic is set, <span class="pkg">ggdist</span> geometries will modify their
<code>colour</code> by applying the colour ramp between <code>from</code> and <code>colour</code> (and
similarly for <code>fill_ramp</code> and <code>fill</code>).
</p>
<p>Colour ramps can be applied (i.e. translated into colours) using
<code><a href="#topic+ramp_colours">ramp_colours()</a></code>, which can be used with <code><a href="#topic+partial_colour_ramp">partial_colour_ramp()</a></code>
to implement geoms that make use of <code>colour_ramp</code> or <code>fill_ramp</code> scales.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a> representing a scale for the <code>colour_ramp</code> and/or <code>fill_ramp</code>
aesthetics for <code>ggdist</code> geoms. Can be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>Other ggdist scales: 
<code><a href="#topic+scale_side_mirrored">scale_side_mirrored</a>()</code>,
<code><a href="#topic+scale_thickness">scale_thickness</a></code>,
<code><a href="#topic+sub-geometry-scales">sub-geometry-scales</a></code>
</p>
<p>Other colour ramp functions: 
<code><a href="#topic+guide_rampbar">guide_rampbar</a>()</code>,
<code><a href="#topic+partial_colour_ramp">partial_colour_ramp</a>()</code>,
<code><a href="#topic+ramp_colours">ramp_colours</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)
library(distributional)

tibble(d = dist_uniform(0, 1)) %&gt;%
  ggplot(aes(y = 0, xdist = d)) +
  stat_slab(aes(fill_ramp = after_stat(x)))

tibble(d = dist_uniform(0, 1)) %&gt;%
  ggplot(aes(y = 0, xdist = d)) +
  stat_slab(aes(fill_ramp = after_stat(x)), fill = "blue") +
  scale_fill_ramp_continuous(from = "red")

# you can invert the order of `range` to change the order of the blend
tibble(d = dist_normal(0, 1)) %&gt;%
  ggplot(aes(y = 0, xdist = d)) +
  stat_slab(aes(fill_ramp = after_stat(cut_cdf_qi(cdf))), fill = "blue") +
  scale_fill_ramp_discrete(from = "red", range = c(1, 0))

</code></pre>

<hr>
<h2 id='scale_side_mirrored'>Side scale for mirrored slabs (ggplot2 scale)</h2><span id='topic+scale_side_mirrored'></span>

<h3>Description</h3>

<p>This scale creates mirrored slabs for the <code>side</code> aesthetic of the <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>
and <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> family of geoms and stats. It works on discrete variables
of two or three levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_side_mirrored(start = "topright", ..., aesthetics = "side")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_side_mirrored_+3A_start">start</code></td>
<td>
<p>The side to start from. Can be any valid value of the <code>side</code> aesthetic
except <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="scale_side_mirrored_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>
</p>

<dl>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take (e.g., <code><a href="scales.html#topic+pal_hue">scales::pal_hue()</a></code>).</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</dd>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>na.translate</code></dt><dd><p>Unlike continuous scales, discrete scales can easily show
missing values, and do so by default. If you want to remove missing values
from a discrete scale, specify <code>na.translate = FALSE</code>.</p>
</dd>
<dt><code>na.value</code></dt><dd><p>If <code>na.translate = TRUE</code>, what aesthetic value should the
missing values be displayed as? Does not apply to position scales
where <code>NA</code> is always placed at the far right.</p>
</dd>
<dt><code>drop</code></dt><dd><p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</dd>
<dt><code>guide</code></dt><dd><p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_side_mirrored_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Names of aesthetics to set scales for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a> representing a scale for the <code>side</code>
aesthetic for <span class="pkg">ggdist</span> geoms. Can be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>Other ggdist scales: 
<code><a href="#topic+scale_colour_ramp">scale_colour_ramp</a></code>,
<code><a href="#topic+scale_thickness">scale_thickness</a></code>,
<code><a href="#topic+sub-geometry-scales">sub-geometry-scales</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

set.seed(1234)
data.frame(
  x = rnorm(400, c(1,4)),
  g = c("a","b")
) %&gt;%
  ggplot(aes(x, fill = g, side = g)) +
  geom_weave(linewidth = 0, scale = 0.5) +
  scale_side_mirrored()

</code></pre>

<hr>
<h2 id='scale_thickness'>Slab thickness scale (ggplot2 scale)</h2><span id='topic+scale_thickness'></span><span id='topic+scale_thickness_shared'></span><span id='topic+scale_thickness_identity'></span><span id='topic+thickness'></span>

<h3>Description</h3>

<p>This <span class="pkg">ggplot2</span> scale linearly scales all <code>thickness</code> values of geoms
that support the <code>thickness</code> aesthetic (such as <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>). It
can be used to align the <code>thickness</code> scales across multiple geoms (by default,
<code>thickness</code> is normalized on a per-geom level instead of as a global scale).
For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_thickness_shared(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = function(l) c(min(0, l[[1]]), l[[2]]),
  renormalize = FALSE,
  oob = scales::oob_keep,
  guide = "none",
  ...
)

scale_thickness_identity(..., guide = "none")

thickness(x = double(), lower = NA_real_, upper = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_thickness_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_thickness_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_thickness_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_thickness_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_thickness_+3A_renormalize">renormalize</code></td>
<td>
<p>When mapping values to the <code>thickness</code> scale, should those
values be allowed to be renormalized by geoms (e.g. via the <code>normalize</code> parameter
to <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>)? The default is <code>FALSE</code>: if <code>scale_thickness_shared()</code>
is in use, the geom-specific <code>normalize</code> parameter is ignored (this is achieved
by flagging values as already normalized by wrapping them in <code>thickness()</code>).
Set this to <code>TRUE</code> to allow geoms to also apply their own normalization.
Note that if you set renormalize to <code>TRUE</code>, subguides created via the
<code>subguide</code> parameter to <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> will display the scaled values
output by this scale, not the original data values.</p>
</td></tr>
<tr><td><code id="scale_thickness_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_thickness_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_thickness_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>
</p>

<dl>
<dt><code>aesthetics</code></dt><dd><p>The names of the aesthetics that this scale works with.</p>
</dd>
<dt><code>scale_name</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</dd>
<dt><code>palette</code></dt><dd><p>A palette function that when called with a numeric vector with
values between 0 and 1 returns the corresponding output values
(e.g., <code><a href="scales.html#topic+pal_area">scales::pal_area()</a></code>).</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>rescaler</code></dt><dd><p>A function used to scale the input values to the
range [0, 1]. This is always <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>, except for
diverging and n colour gradients (i.e., <code><a href="ggplot2.html#topic+scale_colour_gradient2">scale_colour_gradient2()</a></code>,
<code><a href="ggplot2.html#topic+scale_colour_gradientn">scale_colour_gradientn()</a></code>). The <code>rescaler</code> is ignored by position
scales, which always use <code><a href="scales.html#topic+rescale">scales::rescale()</a></code>. Also accepts rlang
<a href="rlang.html#topic+as_function">lambda</a> function notation.</p>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>na.value</code></dt><dd><p>Missing values will be replaced with this value.</p>
</dd>
<dt><code>transform</code></dt><dd><p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</dd>
<dt><code>trans</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of
<code>transform</code>.</p>
</dd>
<dt><code>position</code></dt><dd><p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> used to construct the scale for reporting messages.</p>
</dd>
<dt><code>super</code></dt><dd><p>The super class to use for the constructed scale</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_thickness_+3A_x">x</code></td>
<td>
<p>An object (typically a <code>numeric()</code>) to be converted to a <code>thickness()</code>
object.</p>
</td></tr>
<tr><td><code id="scale_thickness_+3A_lower">lower</code></td>
<td>
<p>The original lower bounds of thickness values before scaling.</p>
</td></tr>
<tr><td><code id="scale_thickness_+3A_upper">upper</code></td>
<td>
<p>The original upper bounds of thickness values before scaling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, normalization/scaling of slab thicknesses is controlled by geometries,
not by a <span class="pkg">ggplot2</span> scale function. This allows various functionality not
otherwise possible, such as (1) allowing different geometries to have different
thickness scales and (2) allowing the user to control at what level of aggregation
(panels, groups, the entire plot, etc) thickness scaling is done via the <code>normalize</code>
parameter to <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>.
</p>
<p>However, this default approach has one drawback: two different geoms will always
have their own scaling of <code>thickness</code>. <code><a href="#topic+scale_thickness_shared">scale_thickness_shared()</a></code> offers an
alternative approach: when added to a chart, all geoms will use the same
<code>thickness</code> scale, and geom-level normalization (via their <code>normalize</code> parameters)
is ignored. This is achieved by &quot;marking&quot; thickness values as already
normalized by wrapping them in the <code><a href="#topic+thickness">thickness()</a></code> data type (this can be
disabled by setting <code>renormalize = TRUE</code>).
</p>
<p><code><a href="#topic+thickness">thickness()</a></code> is used by <code><a href="#topic+scale_thickness_shared">scale_thickness_shared()</a></code> to create <code>numeric()</code>-like
objects marked as being in units of slab &quot;thickness&quot;. Unlike regular <code>numeric()</code>s,
<code>thickness()</code> values mapped onto the <code>thickness</code> aesthetic are not rescaled by
<code><a href="#topic+scale_thickness_shared">scale_thickness_shared()</a></code> or <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>. In most cases <code>thickness()</code>
is not useful directly; though it can be used to mark values that should not be
rescaled&mdash;see the definitions of <code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval()</a></code> and <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>
for some usages.
</p>
<p>Note: while a slightly more typical name for <code>scale_thickness_shared()</code> might
be <code>scale_thickness_continuous()</code>, the latter name would cause this scale
to be applied to all <code>thickness</code> aesthetics by default according to the rules
<span class="pkg">ggplot2</span> uses to find default scales. Thus, to retain the usual behavior
of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> (per-geom normalization of <code>thickness</code>), this scale
is called <code>scale_thickness_shared()</code>.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a> representing a scale for the <code>thickness</code>
aesthetic for <code>ggdist</code> geoms. Can be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>The <code>thickness</code> aesthetic of <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>.
</p>
<p>Other ggdist scales: 
<code><a href="#topic+scale_colour_ramp">scale_colour_ramp</a></code>,
<code><a href="#topic+scale_side_mirrored">scale_side_mirrored</a>()</code>,
<code><a href="#topic+sub-geometry-scales">sub-geometry-scales</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(ggplot2)
library(dplyr)

prior_post = data.frame(
  prior = dist_normal(0, 1),
  posterior = dist_normal(0.1, 0.5)
)

# By default, separate geoms have their own thickness scales, which means
# distributions plotted using two separate geoms will not have their slab
# functions drawn on the same scale (thus here, the two distributions have
# different areas under their density curves):
prior_post %&gt;%
  ggplot() +
  stat_halfeye(aes(xdist = posterior)) +
  stat_slab(aes(xdist = prior), fill = NA, color = "red")

# For this kind of prior/posterior chart, it makes more sense to have the
# densities on the same scale; thus, the areas under both would be the same.
# We can do that using scale_thickness_shared():
prior_post %&gt;%
  ggplot() +
  stat_halfeye(aes(xdist = posterior)) +
  stat_slab(aes(xdist = prior), fill = NA, color = "#e41a1c") +
  scale_thickness_shared()

</code></pre>

<hr>
<h2 id='smooth_density'>Smooth dot positions in a dotplot using a kernel density estimator (&quot;density dotplots&quot;)</h2><span id='topic+smooth_density'></span><span id='topic+smooth_bounded'></span><span id='topic+smooth_unbounded'></span>

<h3>Description</h3>

<p>Smooths <code>x</code> values using a density estimator, returning new <code>x</code> of the same
length. Can be used with a dotplot (e.g. <code><a href="#topic+geom_dots">geom_dots</a></code><code>(smooth = ...)</code>) to create
&quot;density dotplots&quot;.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_bounded(
  x,
  density = "bounded",
  bounds = c(NA, NA),
  bounder = "cooke",
  trim = FALSE,
  ...
)

smooth_unbounded(x, density = "unbounded", trim = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_density_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="smooth_density_+3A_density">density</code></td>
<td>
<p>Density estimator to use for smoothing. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="smooth_density_+3A_bounds">bounds</code></td>
<td>
<p>length-2 vector of min and max bounds. If a bound is <code>NA</code>, then
that bound is estimated from the data using the method specified by <code>bounder</code>.</p>
</td></tr>
<tr><td><code id="smooth_density_+3A_bounder">bounder</code></td>
<td>
<p>Method to use to find missing (<code>NA</code>) <code>bounds</code>. A function that
takes a numeric vector of values and returns a length-2 vector of the estimated
lower and upper bound of the distribution. Can also be a string giving the
suffix of the name of such a function that starts with <code>"bounder_"</code>. Useful
values include:
</p>

<ul>
<li> <p><code>"cdf"</code>: Use the CDF of the the minimum and maximum order statistics of the
sample to estimate the bounds. See <code><a href="#topic+bounder_cdf">bounder_cdf()</a></code>.
</p>
</li>
<li> <p><code>"cooke"</code>: Use the method from Cooke (1979); i.e. method 2.3 from Loh (1984).
See <code><a href="#topic+bounder_cooke">bounder_cooke()</a></code>.
</p>
</li>
<li> <p><code>"range"</code>: Use the range of <code>x</code> (i.e the <code>min</code> or <code>max</code>). See <code><a href="#topic+bounder_range">bounder_range()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="smooth_density_+3A_trim">trim</code></td>
<td>
<p>Should the density estimate be trimmed to the bounds of the data?</p>
</td></tr>
<tr><td><code id="smooth_density_+3A_...">...</code></td>
<td>
<p>Arguments passed to the density estimator specified by <code>density</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies a kernel density estimator (KDE) to <code>x</code>, then uses weighted quantiles
of the KDE to generate a new set of <code>x</code> values with smoothed values. Plotted
using a dotplot (e.g. <code>geom_dots(smooth = "bounded")</code> or
<code style="white-space: pre;">&#8288;geom_dots(smooth = smooth_bounded(...)&#8288;</code>), these values create a variation on
a &quot;density dotplot&quot; (Zvinca 2018).
</p>
<p>Such plots are recommended <strong>only</strong> in very
large sample sizes where precise positions of individual values are not
particularly meaningful. In small samples, normal dotplots should generally
be used.
</p>
<p>Two variants are supplied by default:
</p>

<ul>
<li> <p><code>smooth_bounded()</code>, which uses <code><a href="#topic+density_bounded">density_bounded()</a></code>.
Passes the <code>bounds</code> arguments to the estimator.
</p>
</li>
<li> <p><code>smooth_unbounded()</code>, which uses <code><a href="#topic+density_unbounded">density_unbounded()</a></code>.
</p>
</li></ul>

<p>It is generally recommended to pick the smooth based on the known bounds of
your data, e.g. by using <code>smooth_bounded()</code> with the <code>bounds</code> parameter if
there are finite bounds, or <code>smooth_unbounded()</code> if both bounds are infinite.
</p>


<h3>Value</h3>

<p>A numeric vector of <code>length(x)</code>, where each entry is a smoothed version of
the corresponding entry in <code>x</code>.
</p>
<p>If <code>x</code> is missing, returns a partial application of itself. See <a href="#topic+automatic-partial-functions">automatic-partial-functions</a>.
</p>


<h3>References</h3>

<p>Zvinca, Daniel. &quot;In the pursuit of diversity in data visualization. Jittering data to access details.&quot;
<a href="https://www.linkedin.com/pulse/pursuit-diversity-data-visualization-jittering-access-daniel-zvinca/">https://www.linkedin.com/pulse/pursuit-diversity-data-visualization-jittering-access-daniel-zvinca/</a>.
</p>


<h3>See Also</h3>

<p>Other dotplot smooths: 
<code><a href="#topic+smooth_discrete">smooth_discrete</a>()</code>,
<code><a href="#topic+smooth_none">smooth_none</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)

set.seed(1234)
x = rnorm(1000)

# basic dotplot is noisy
ggplot(data.frame(x), aes(x)) +
  geom_dots()

# density dotplot is smoother, but does move points (most noticeable
# in areas of low density)
ggplot(data.frame(x), aes(x)) +
  geom_dots(smooth = "unbounded")

# you can adjust the kernel and bandwidth...
ggplot(data.frame(x), aes(x)) +
  geom_dots(smooth = smooth_unbounded(kernel = "triangular", adjust = 0.5))

# for bounded data, you should use the bounded smoother
x_beta = rbeta(1000, 0.5, 0.5)

ggplot(data.frame(x_beta), aes(x_beta)) +
  geom_dots(smooth = smooth_bounded(bounds = c(0, 1)))

</code></pre>

<hr>
<h2 id='smooth_discrete'>Smooth dot positions in a dotplot of discrete values (&quot;bar dotplots&quot;)</h2><span id='topic+smooth_discrete'></span><span id='topic+smooth_bar'></span>

<h3>Description</h3>

<p><strong>Note:</strong> Better-looking bar dotplots are typically easier to achieve using
<code>layout = "bar"</code> with the <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> family instead of
<code>smooth = "bar"</code> or <code>smooth = "discrete"</code>.
</p>
<p>Smooths <code>x</code> values where <code>x</code> is presumed to be discrete, returning a new <code>x</code>
of the same length. Both <code>smooth_discrete()</code> and <code>smooth_bar()</code> use the
<code><a href="ggplot2.html#topic+resolution">resolution()</a></code> of the data to apply smoothing around unique values in the
dataset; <code>smooth_discrete()</code> uses a kernel density estimator and <code>smooth_bar()</code>
places values in an evenly-spaced grid. Can be used with a dotplot
(e.g. <code><a href="#topic+geom_dots">geom_dots</a></code><code>(smooth = ...)</code>) to create &quot;bar dotplots&quot;.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_discrete(
  x,
  kernel = c("rectangular", "gaussian", "epanechnikov", "triangular", "biweight",
    "cosine", "optcosine"),
  width = 0.7,
  ...
)

smooth_bar(x, width = 0.7, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_discrete_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="smooth_discrete_+3A_kernel">kernel</code></td>
<td>
<p>string: the smoothing kernel to be used. This must partially
match one of <code>"gaussian"</code>, <code>"rectangular"</code>, <code>"triangular"</code>, <code>"epanechnikov"</code>,
<code>"biweight"</code>, <code>"cosine"</code>, or <code>"optcosine"</code>. See <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="smooth_discrete_+3A_width">width</code></td>
<td>
<p>approximate width of the bars as a fraction of data <code><a href="ggplot2.html#topic+resolution">resolution()</a></code>.</p>
</td></tr>
<tr><td><code id="smooth_discrete_+3A_...">...</code></td>
<td>
<p>additional parameters; <code><a href="#topic+smooth_discrete">smooth_discrete()</a></code> passes these to
<code><a href="#topic+smooth_unbounded">smooth_unbounded()</a></code> and thereby to <code><a href="#topic+density_unbounded">density_unbounded()</a></code>; <code><a href="#topic+smooth_bar">smooth_bar()</a></code>
ignores them.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>smooth_discrete()</code> applies a kernel density estimator (default: rectangular)
to <code>x</code>. It automatically sets the bandwidth to be such that the kernel's
width (for each kernel type) is approximately <code>width</code> times the <code><a href="ggplot2.html#topic+resolution">resolution()</a></code>
of the data. This means it essentially creates smoothed bins around each
unique value. It calls down to <code><a href="#topic+smooth_unbounded">smooth_unbounded()</a></code>.
</p>
<p><code>smooth_bar()</code> generates an evenly-spaced grid of values spanning <code style="white-space: pre;">&#8288;+/- width/2&#8288;</code>
around each unique value in <code>x</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of <code>length(x)</code>, where each entry is a smoothed version of
the corresponding entry in <code>x</code>.
</p>
<p>If <code>x</code> is missing, returns a partial application of itself. See <a href="#topic+automatic-partial-functions">automatic-partial-functions</a>.
</p>


<h3>See Also</h3>

<p>Other dotplot smooths: 
<code><a href="#topic+smooth_density">smooth_density</a></code>,
<code><a href="#topic+smooth_none">smooth_none</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)

set.seed(1234)
x = rpois(1000, 2)

# automatic binwidth in basic dotplot on large counts in discrete
# distributions is very small
ggplot(data.frame(x), aes(x)) +
  geom_dots()

# NOTE: It is now recommended to use layout = "bar" instead of
# smooth = "discrete" or smooth = "bar"; the latter are retained because
# they can sometimes be useful in combination with other layouts for
# more specialized (but finicky) applications.
ggplot(data.frame(x), aes(x)) +
  geom_dots(layout = "bar")

# smooth_discrete() constructs wider bins of dots
ggplot(data.frame(x), aes(x)) +
  geom_dots(smooth = "discrete")

# smooth_bar() is an alternative approach to rectangular layouts
ggplot(data.frame(x), aes(x)) +
  geom_dots(smooth = "bar")

# adjust the shape by changing the kernel or the width. epanechnikov
# works well with side = "both"
ggplot(data.frame(x), aes(x)) +
  geom_dots(smooth = smooth_discrete(kernel = "epanechnikov", width = 0.8), side = "both")


</code></pre>

<hr>
<h2 id='smooth_none'>Apply no smooth to a dotplot</h2><span id='topic+smooth_none'></span>

<h3>Description</h3>

<p>Default smooth for dotplots: no smooth. Simply returns the input values.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_none(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_none_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="smooth_none_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the default value for the <code>smooth</code> argument of <code>geom_dotsinterval()</code>.
</p>


<h3>Value</h3>

<p><code>x</code>
</p>
<p>If <code>x</code> is missing, returns a partial application of itself. See <a href="#topic+automatic-partial-functions">automatic-partial-functions</a>.
</p>


<h3>See Also</h3>

<p>Other dotplot smooths: 
<code><a href="#topic+smooth_density">smooth_density</a></code>,
<code><a href="#topic+smooth_discrete">smooth_discrete</a>()</code>
</p>

<hr>
<h2 id='stat_ccdfinterval'>CCDF bar plot (shortcut stat)</h2><span id='topic+stat_ccdfinterval'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for
creating CCDF bar plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_slabinterval(
  aes(
    thickness = after_stat(thickness(1 - cdf, 0, 1)),
    justification = after_stat(0.5),
    side = after_stat("topleft")
  ),
  normalize = "none",
  expand = TRUE
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ccdfinterval(
  mapping = NULL,
  data = NULL,
  geom = "slabinterval",
  position = "identity",
  ...,
  normalize = "none",
  expand = TRUE,
  p_limits = c(NA, NA),
  density = "bounded",
  adjust = waiver(),
  trim = TRUE,
  breaks = waiver(),
  align = "none",
  outline_bars = FALSE,
  point_interval = "median_qi",
  slab_type = NULL,
  limits = NULL,
  n = 501,
  .width = c(0.66, 0.95),
  orientation = NA,
  na.rm = FALSE,
  show.legend = c(size = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_ccdfinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval()</a></code> and <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code></p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>,
these include:
</p>

<dl>
<dt><code>fill_type</code></dt><dd><p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</dd>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>fatten_point</code></dt><dd><p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_normalize">normalize</code></td>
<td>
<p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_expand">expand</code></td>
<td>
<p>For sample data, should the slab be expanded to the limits of the scale? Default <code>FALSE</code>.
Can be length two to control expansion to the lower and upper limit respectively.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_p_limits">p_limits</code></td>
<td>
<p>Probability limits (as a vector of size 2) used to determine the lower and upper
limits of <em>theoretical</em> distributions (distributions from <em>samples</em> ignore this parameter and determine
their limits based on the limits of the sample). E.g., if this is <code>c(.001, .999)</code>, then a slab is drawn
for the distribution from the quantile at <code>p = .001</code> to the quantile at <code>p = .999</code>. If the lower
(respectively upper) limit is <code>NA</code>, then the lower (upper) limit will be the minimum (maximum) of the
distribution's support if it is finite, and <code>0.001</code> (<code>0.999</code>) if it is not finite. E.g., if
<code>p_limits</code> is <code>c(NA, NA)</code>, on a gamma distribution the effective value of <code>p_limits</code> would be
<code>c(0, .999)</code> since the gamma distribution is defined on <code style="white-space: pre;">&#8288;(0, Inf)&#8288;</code>; whereas on a normal distribution
it would be equivalent to <code>c(.001, .999)</code> since the normal distribution is defined on <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_density">density</code></td>
<td>
<p>Density estimator for sample data. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>. This format is also compatible with <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>, <code>"unbounded"</code> for <code style="white-space: pre;">&#8288;[density_unbounded()]&#8288;</code>,
or <code>"histogram"</code> for <code><a href="#topic+density_histogram">density_histogram()</a></code>.
Defaults to <code>"bounded"</code>, i.e. <code><a href="#topic+density_bounded">density_bounded()</a></code>, which estimates the bounds from
the data and then uses a bounded density estimator based on the reflection method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_adjust">adjust</code></td>
<td>
<p>Passed to <code>density</code>: the bandwidth for the density estimator for sample data
is adjusted by multiplying it by this value. See e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code> for more information.
Default (<code>waiver()</code>) defers to the default of the density estimator, which is usually <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_trim">trim</code></td>
<td>
<p>For sample data, should the density estimate be trimmed to the range of the
data? Passed on to the density estimator; see the <code>density</code> parameter. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_outline_bars">outline_bars</code></td>
<td>
<p>For sample data (if <code>density</code> is <code>"histogram"</code>) and for discrete analytical
distributions (whose slabs are drawn as histograms), determines
if outlines in between the bars are drawn when the <code>slab_color</code> aesthetic is used. If <code>FALSE</code>
(the default), the outline is drawn only along the tops of the bars; if <code>TRUE</code>, outlines in between
bars are also drawn. See <code><a href="#topic+density_histogram">density_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_slab_type">slab_type</code></td>
<td>
<p>(deprecated) The type of slab function to calculate: probability density (or mass) function
(<code>"pdf"</code>), cumulative distribution function (<code>"cdf"</code>), or complementary CDF (<code>"ccdf"</code>). Instead of using
<code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an aesthetic, it is now recommended to simply map the
corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or  <code>1 - cdf</code>) directly onto the desired aesthetic.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_limits">limits</code></td>
<td>
<p>Manually-specified limits for the slab, as a vector of length two. These limits are combined with those
computed based on <code>p_limits</code> as well as the limits defined by the scales of the plot to determine the
limits used to draw the slab functions: these limits specify the maximal limits; i.e., if specified, the limits
will not be wider than these (but may be narrower). Use <code>NA</code> to leave a limit alone; e.g.
<code>limits = c(0, NA)</code> will ensure that the lower limit does not go below 0, but let the upper limit
be determined by either <code>p_limits</code> or the scale settings.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate the function that defines the slab.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_ccdfinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a CCDF bar geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval</a>()</code>,
<code><a href="#topic+stat_eye">stat_eye</a>()</code>,
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval</a>()</code>,
<code><a href="#topic+stat_halfeye">stat_halfeye</a>()</code>,
<code><a href="#topic+stat_histinterval">stat_histinterval</a>()</code>,
<code><a href="#topic+stat_interval">stat_interval</a>()</code>,
<code><a href="#topic+stat_pointinterval">stat_pointinterval</a>()</code>,
<code><a href="#topic+stat_slab">stat_slab</a>()</code>,
<code><a href="#topic+stat_spike">stat_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c"),
  value = rnorm(1500, mean = c(5, 7, 9), sd = c(1, 1.5, 1))
)
df %&gt;%
  ggplot(aes(x = value, y = group)) +
  stat_ccdfinterval() +
  expand_limits(x = 0)

# ON ANALYTICAL DISTRIBUTIONS
dist_df = data.frame(
  group = c("a", "b", "c"),
  mean =  c(  5,   7,   8),
  sd =    c(  1, 1.5,   1)
)
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
dist_df %&gt;%
  ggplot(aes(y = group, xdist = dist_normal(mean, sd))) +
  stat_ccdfinterval() +
  expand_limits(x = 0)
</code></pre>

<hr>
<h2 id='stat_cdfinterval'>CDF bar plot (shortcut stat)</h2><span id='topic+stat_cdfinterval'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for
creating CDF bar plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_slabinterval(
  aes(
    thickness = after_stat(thickness(cdf, 0, 1)),
    justification = after_stat(0.5),
    side = after_stat("topleft")
  ),
  normalize = "none",
  expand = TRUE
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_cdfinterval(
  mapping = NULL,
  data = NULL,
  geom = "slabinterval",
  position = "identity",
  ...,
  normalize = "none",
  expand = TRUE,
  p_limits = c(NA, NA),
  density = "bounded",
  adjust = waiver(),
  trim = TRUE,
  breaks = waiver(),
  align = "none",
  outline_bars = FALSE,
  point_interval = "median_qi",
  slab_type = NULL,
  limits = NULL,
  n = 501,
  .width = c(0.66, 0.95),
  orientation = NA,
  na.rm = FALSE,
  show.legend = c(size = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_cdfinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval()</a></code> and <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code></p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>,
these include:
</p>

<dl>
<dt><code>fill_type</code></dt><dd><p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</dd>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>fatten_point</code></dt><dd><p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_normalize">normalize</code></td>
<td>
<p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_expand">expand</code></td>
<td>
<p>For sample data, should the slab be expanded to the limits of the scale? Default <code>FALSE</code>.
Can be length two to control expansion to the lower and upper limit respectively.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_p_limits">p_limits</code></td>
<td>
<p>Probability limits (as a vector of size 2) used to determine the lower and upper
limits of <em>theoretical</em> distributions (distributions from <em>samples</em> ignore this parameter and determine
their limits based on the limits of the sample). E.g., if this is <code>c(.001, .999)</code>, then a slab is drawn
for the distribution from the quantile at <code>p = .001</code> to the quantile at <code>p = .999</code>. If the lower
(respectively upper) limit is <code>NA</code>, then the lower (upper) limit will be the minimum (maximum) of the
distribution's support if it is finite, and <code>0.001</code> (<code>0.999</code>) if it is not finite. E.g., if
<code>p_limits</code> is <code>c(NA, NA)</code>, on a gamma distribution the effective value of <code>p_limits</code> would be
<code>c(0, .999)</code> since the gamma distribution is defined on <code style="white-space: pre;">&#8288;(0, Inf)&#8288;</code>; whereas on a normal distribution
it would be equivalent to <code>c(.001, .999)</code> since the normal distribution is defined on <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_density">density</code></td>
<td>
<p>Density estimator for sample data. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>. This format is also compatible with <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>, <code>"unbounded"</code> for <code style="white-space: pre;">&#8288;[density_unbounded()]&#8288;</code>,
or <code>"histogram"</code> for <code><a href="#topic+density_histogram">density_histogram()</a></code>.
Defaults to <code>"bounded"</code>, i.e. <code><a href="#topic+density_bounded">density_bounded()</a></code>, which estimates the bounds from
the data and then uses a bounded density estimator based on the reflection method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_adjust">adjust</code></td>
<td>
<p>Passed to <code>density</code>: the bandwidth for the density estimator for sample data
is adjusted by multiplying it by this value. See e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code> for more information.
Default (<code>waiver()</code>) defers to the default of the density estimator, which is usually <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_trim">trim</code></td>
<td>
<p>For sample data, should the density estimate be trimmed to the range of the
data? Passed on to the density estimator; see the <code>density</code> parameter. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_outline_bars">outline_bars</code></td>
<td>
<p>For sample data (if <code>density</code> is <code>"histogram"</code>) and for discrete analytical
distributions (whose slabs are drawn as histograms), determines
if outlines in between the bars are drawn when the <code>slab_color</code> aesthetic is used. If <code>FALSE</code>
(the default), the outline is drawn only along the tops of the bars; if <code>TRUE</code>, outlines in between
bars are also drawn. See <code><a href="#topic+density_histogram">density_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_slab_type">slab_type</code></td>
<td>
<p>(deprecated) The type of slab function to calculate: probability density (or mass) function
(<code>"pdf"</code>), cumulative distribution function (<code>"cdf"</code>), or complementary CDF (<code>"ccdf"</code>). Instead of using
<code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an aesthetic, it is now recommended to simply map the
corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or  <code>1 - cdf</code>) directly onto the desired aesthetic.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_limits">limits</code></td>
<td>
<p>Manually-specified limits for the slab, as a vector of length two. These limits are combined with those
computed based on <code>p_limits</code> as well as the limits defined by the scales of the plot to determine the
limits used to draw the slab functions: these limits specify the maximal limits; i.e., if specified, the limits
will not be wider than these (but may be narrower). Use <code>NA</code> to leave a limit alone; e.g.
<code>limits = c(0, NA)</code> will ensure that the lower limit does not go below 0, but let the upper limit
be determined by either <code>p_limits</code> or the scale settings.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate the function that defines the slab.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_cdfinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a CDF bar geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval</a>()</code>,
<code><a href="#topic+stat_eye">stat_eye</a>()</code>,
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval</a>()</code>,
<code><a href="#topic+stat_halfeye">stat_halfeye</a>()</code>,
<code><a href="#topic+stat_histinterval">stat_histinterval</a>()</code>,
<code><a href="#topic+stat_interval">stat_interval</a>()</code>,
<code><a href="#topic+stat_pointinterval">stat_pointinterval</a>()</code>,
<code><a href="#topic+stat_slab">stat_slab</a>()</code>,
<code><a href="#topic+stat_spike">stat_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c"),
  value = rnorm(1500, mean = c(5, 7, 9), sd = c(1, 1.5, 1))
)
df %&gt;%
  ggplot(aes(x = value, y = group)) +
  stat_cdfinterval()

# ON ANALYTICAL DISTRIBUTIONS
dist_df = data.frame(
  group = c("a", "b", "c"),
  mean =  c(  5,   7,   8),
  sd =    c(  1, 1.5,   1)
)
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
dist_df %&gt;%
  ggplot(aes(y = group, xdist = dist_normal(mean, sd))) +
  stat_cdfinterval()
</code></pre>

<hr>
<h2 id='stat_dots'>Dot plot (shortcut stat)</h2><span id='topic+stat_dots'></span>

<h3>Description</h3>

<p>A combination of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> with sensible defaults
for making dot plots. While <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> is intended for use on data
frames that have already been summarized using a <code><a href="#topic+point_interval">point_interval()</a></code> function,
<code><a href="#topic+stat_dots">stat_dots()</a></code> is intended for use directly on data frames of draws or of
analytical distributions, and will perform the summarization using a <code><a href="#topic+point_interval">point_interval()</a></code>
function. Geoms based on <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> create dotplots that automatically determine a bin width that
ensures the plot fits within the available space. They can also ensure dots do not overlap.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_dotsinterval(
  aes(size = NULL),
  geom = "dots",
  show_point = FALSE,
  show_interval = FALSE,
  show.legend = NA
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_dots(
  mapping = NULL,
  data = NULL,
  geom = "dots",
  position = "identity",
  ...,
  quantiles = NA,
  orientation = NA,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_dots_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_dots_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_dots_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_dots">stat_dots()</a></code> and <code><a href="#topic+geom_dots">geom_dots()</a></code></p>
</td></tr>
<tr><td><code id="stat_dots_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_dots_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_dots">geom_dots()</a></code>,
these include:
</p>

<dl>
<dt><code>binwidth</code></dt><dd><p>The bin width to use for laying out the dots.
One of:
</p>

<ul>
<li> <p><code>NA</code> (the default): Dynamically select the bin width based on the
size of the plot when drawn. This will pick a <code>binwidth</code> such that the
tallest stack of dots is at most <code>scale</code> in height (ideally exactly <code>scale</code>
in height, though this is not guaranteed).
</p>
</li>
<li><p> A length-1 (scalar) numeric or <a href="grid.html#topic+unit">unit</a> object giving the exact bin width.
</p>
</li>
<li><p> A length-2 (vector) numeric or <a href="grid.html#topic+unit">unit</a> object giving the minimum and maximum
desired bin width. The bin width will be dynamically selected within
these bounds.
</p>
</li></ul>

<p>If the value is numeric, it is assumed to be in units of data. The bin width
(or its bounds) can also be specified using <code><a href="grid.html#topic+unit">unit()</a></code>, which may be useful if
it is desired that the dots be a certain point size or a certain percentage of
the width/height of the viewport. For example, <code>unit(0.1, "npc")</code> would make
dots that are <em>exactly</em> 10% of the viewport size along whichever dimension the
dotplot is drawn; <code>unit(c(0, 0.1), "npc")</code> would make dots that are <em>at most</em>
10% of the viewport size (while still ensuring the tallest stack is less than
or equal to <code>scale</code>).</p>
</dd>
<dt><code>dotsize</code></dt><dd><p>The width of the dots relative to the <code>binwidth</code>. The default,
<code>1.07</code>, makes dots be just a bit wider than the bin width, which is a
manually-tuned parameter that tends to work well with the default circular
shape, preventing gaps between bins from appearing to be too large visually
(as might arise from dots being <em>precisely</em> the <code>binwidth</code>). If it is desired
to have dots be precisely the <code>binwidth</code>, set <code>dotsize = 1</code>.</p>
</dd>
<dt><code>stackratio</code></dt><dd><p>The distance between the center of the dots in the same
stack relative to the dot height. The default, <code>1</code>, makes dots in the same
stack just touch each other.</p>
</dd>
<dt><code>layout</code></dt><dd><p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</dd>
<dt><code>overlaps</code></dt><dd><p>How to handle overlapping dots or bins in the <code>"bin"</code>,
<code>"weave"</code>, and <code>"hex"</code> layouts (dots never overlap in the <code>"swarm"</code> or <code>"bar"</code> layouts).
For the purposes of this argument, dots are only considered to be overlapping
if they would be overlapping when <code>dotsize = 1</code> and <code>stackratio = 1</code>; i.e.
if you set those arguments to other values, overlaps may still occur.
One of: </p>

<ul>
<li> <p><code>"keep"</code>: leave overlapping dots as they are. Dots may overlap
(usually only slightly) in the <code>"bin"</code>, <code>"weave"</code>, and <code>"hex"</code> layouts.
</p>
</li>
<li> <p><code>"nudge"</code>: nudge overlapping dots out of the way. Overlaps are avoided
using a constrained optimization which minimizes the squared distance of
dots to their desired positions, subject to the constraint that adjacent
dots do not overlap.
</p>
</li></ul>
</dd>
<dt><code>smooth</code></dt><dd><p>Smoother to apply to dot positions.
One of:
</p>

<ul>
<li><p> A function that takes a numeric vector of dot positions and returns a
smoothed version of that vector, such as <code>smooth_bounded()</code>,
<code>smooth_unbounded()</code>, smooth_discrete()<code style="white-space: pre;">&#8288;, or &#8288;</code>smooth_bar()'.
</p>
</li>
<li><p> A string indicating what smoother to use, as the suffix to a function
name starting with <code>smooth_</code>; e.g. <code>"none"</code> (the default) applies
<code>smooth_none()</code>, which simply returns the given vector without
applying smoothing.
</p>
</li></ul>

<p>Smoothing is most effective when the smoother is matched to the support of
the distribution; e.g. using <code>smooth_bounded(bounds = ...)</code>.</p>
</dd>
<dt><code>overflow</code></dt><dd><p>How to handle overflow of dots beyond the extent of the geom
when a minimum <code>binwidth</code> (or an exact <code>binwidth</code>) is supplied.
One of:
</p>

<ul>
<li> <p><code>"keep"</code>: Keep the overflow, drawing dots outside the geom bounds.
</p>
</li>
<li> <p><code>"warn"</code>: Keep the overflow, but produce a warning suggesting solutions,
such as setting <code>binwidth = NA</code> or <code>overflow = "compress"</code>.
</p>
</li>
<li> <p><code>"compress"</code>: Compress the layout. Reduces the <code>binwidth</code> to the size necessary
to keep the dots within bounds, then adjusts <code>stackratio</code> and <code>dotsize</code> so that
the apparent dot size is the user-specified minimum <code>binwidth</code> times the
user-specified <code>dotsize</code>.
</p>
</li></ul>

<p>If you find the default layout has dots that are too small, and you are okay
with dots overlapping, consider setting <code>overflow = "compress"</code> and supplying
an exact or minimum dot size using <code>binwidth</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>If <code>TRUE</code>, print out the bin width of the dotplot. Can be useful
if you want to start from an automatically-selected bin width and then adjust it
manually. Bin width is printed both as data units and as normalized parent
coordinates or <code>"npc"</code>s (see <code><a href="grid.html#topic+unit">unit()</a></code>). Note that if you just want to scale the
selected bin width to fit within a desired area, it is probably easier to use
<code>scale</code> than to copy and scale <code>binwidth</code> manually, and if you just want to
provide constraints on the bin width, you can pass a length-2 vector to <code>binwidth</code>.
</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_dots_+3A_quantiles">quantiles</code></td>
<td>
<p>Setting this to a value other than <code>NA</code>
will produce a quantile dotplot: that is, a dotplot of quantiles from the sample or distribution
(for analytical distributions, the default of <code>NA</code> is taken to mean <code>100</code> quantiles). The value of
<code>quantiles</code> determines the number
of quantiles to plot. See Kay et al. (2016) and Fernandes et al. (2018) for more information on quantile dotplots.</p>
</td></tr>
<tr><td><code id="stat_dots_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_dots_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_dots_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_dots_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>dots</em> family of stats and geoms are similar to <code><a href="ggplot2.html#topic+geom_dotplot">geom_dotplot()</a></code> but with a number of differences:
</p>

<ul>
<li><p> Dots geoms act like slabs in <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and can be given x positions (or y positions when
in a horizontal orientation).
</p>
</li>
<li><p> Given the available space to lay out dots, the dots geoms will automatically determine how many bins to
use to fit the available space.
</p>
</li>
<li><p> Dots geoms use a dynamic layout algorithm that lays out dots from the center out if the input data are
symmetrical, guaranteeing that symmetrical data results in a symmetrical plot. The layout algorithm also prevents
dots from overlapping each other.
</p>
</li>
<li><p> The shape of the dots in these geoms can be changed using the <code>slab_shape</code> aesthetic (when using the
<code>dotsinterval</code> family) or the <code>shape</code> or <code>slab_shape</code> aesthetic (when using the <code>dots</code> family)
</p>
</li></ul>

<p>Stats and geoms in this family include:
</p>

<ul>
<li> <p><code><a href="#topic+geom_dots">geom_dots()</a></code>: dotplots on raw data. Ensures the dotplot fits within available space by reducing the size
of the dots automatically (may result in very small dots).
</p>
</li>
<li> <p><code><a href="#topic+geom_swarm">geom_swarm()</a></code> and <code><a href="#topic+geom_weave">geom_weave()</a></code>: dotplots on raw data with defaults intended to create &quot;beeswarm&quot; plots.
Used <code>side = "both"</code> by default, and sets the default dot size to the same size as <code><a href="ggplot2.html#topic+geom_point">geom_point()</a></code>
(<code>binwidth = unit(1.5, "mm")</code>), allowing dots to overlap instead of getting very small.
</p>
</li>
<li> <p><code><a href="#topic+stat_dots">stat_dots()</a></code>: dotplots on raw data, <span class="pkg">distributional</span> objects, and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s
</p>
</li>
<li> <p><code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>: dotplot + interval plots on raw data with already-calculated
intervals (rarely useful directly).
</p>
</li>
<li> <p><code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>: dotplot + interval plots on raw data, <span class="pkg">distributional</span> objects,
and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s (will calculate intervals for you).
</p>
</li>
<li> <p><code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>: blurry dotplots that allow the standard deviation of a blur applied to
each dot to be specified using the <code>sd</code> aesthetic.
</p>
</li>
<li> <p><code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code>: blurry dotplots of quantiles using the Monte Carlo Standard Error of each quantile.
</p>
</li></ul>

<p><code><a href="#topic+stat_dots">stat_dots()</a></code> and <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>, when used with the <code>quantiles</code> argument,
are particularly useful for constructing quantile dotplots, which can be an effective way to communicate uncertainty
using a frequency framing that may be easier for laypeople to understand (Kay et al. 2016, Fernandes et al. 2018).
</p>
<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a dot geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The dots+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>dots</strong> (aka the <strong>slab</strong>), the
<strong>point</strong>, and the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_dots">geom_dots()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Dots-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>family</code>: The font family used to draw the dots.
</p>
</li>
<li><p><code>order</code>: The order in which data points are stacked within bins. Can be used to create the effect of
&quot;stacked&quot; dots by ordering dots according to a discrete variable. If omitted (<code>NULL</code>), the
value of the data points themselves are used to determine stacking order. Only applies when
<code>layout</code> is <code>"bin"</code> or <code>"hex"</code>, as the other layout methods fully determine both <em>x</em> and <em>y</em> positions.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li>
<li><p><code>slab_shape</code>: Override for <code>shape</code>: the shape of the dots used to draw the dotplot slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("dotsinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>References</h3>

<p>Kay, M., Kola, T., Hullman, J. R., &amp; Munson, S. A. (2016). When (ish) is My Bus? User-centered Visualizations
of Uncertainty in Everyday, Mobile Predictive Systems. <em>Conference on Human Factors
in Computing Systems - CHI '16</em>, 5092&ndash;5103. <a href="https://doi.org/10.1145/2858036.2858558">doi:10.1145/2858036.2858558</a>.
</p>
<p>Fernandes, M., Walls, L., Munson, S., Hullman, J., &amp; Kay, M. (2018). Uncertainty Displays Using Quantile Dotplots
or CDFs Improve Transit Decision-Making. <em>Conference on Human Factors in Computing Systems - CHI '18</em>.
<a href="https://doi.org/10.1145/3173574.3173718">doi:10.1145/3173574.3173718</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_dots">geom_dots()</a></code> for the geom underlying this stat.
See <code>vignette("dotsinterval")</code> for a variety of examples of use.
</p>
<p>Other dotsinterval stats: 
<code><a href="#topic+stat_dotsinterval">stat_dotsinterval</a>()</code>,
<code><a href="#topic+stat_mcse_dots">stat_mcse_dots</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(12345)
tibble(
  x = rep(1:10, 100),
  y = rnorm(1000, x)
) %&gt;%
  ggplot(aes(x = x, y = y)) +
  stat_dots()

# ON ANALYTICAL DISTRIBUTIONS
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
tibble(
  x = 1:10,
  sd = seq(1, 3, length.out = 10)
) %&gt;%
  ggplot(aes(x = x, ydist = dist_normal(x, sd))) +
  stat_dots(quantiles = 50)
</code></pre>

<hr>
<h2 id='stat_dotsinterval'>Dots + point + interval plot (shortcut stat)</h2><span id='topic+stat_dotsinterval'></span>

<h3>Description</h3>

<p>A combination of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> with sensible defaults
for making dots + point + interval plots. While <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> is intended for use on data
frames that have already been summarized using a <code><a href="#topic+point_interval">point_interval()</a></code> function,
<code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code> is intended for use directly on data frames of draws or of
analytical distributions, and will perform the summarization using a <code><a href="#topic+point_interval">point_interval()</a></code>
function. Geoms based on <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> create dotplots that automatically determine a bin width that
ensures the plot fits within the available space. They can also ensure dots do not overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_dotsinterval(
  mapping = NULL,
  data = NULL,
  geom = "dotsinterval",
  position = "identity",
  ...,
  quantiles = NA,
  point_interval = "median_qi",
  .width = c(0.66, 0.95),
  orientation = NA,
  na.rm = FALSE,
  show.legend = c(size = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_dotsinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code> and <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code></p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>,
these include:
</p>

<dl>
<dt><code>binwidth</code></dt><dd><p>The bin width to use for laying out the dots.
One of:
</p>

<ul>
<li> <p><code>NA</code> (the default): Dynamically select the bin width based on the
size of the plot when drawn. This will pick a <code>binwidth</code> such that the
tallest stack of dots is at most <code>scale</code> in height (ideally exactly <code>scale</code>
in height, though this is not guaranteed).
</p>
</li>
<li><p> A length-1 (scalar) numeric or <a href="grid.html#topic+unit">unit</a> object giving the exact bin width.
</p>
</li>
<li><p> A length-2 (vector) numeric or <a href="grid.html#topic+unit">unit</a> object giving the minimum and maximum
desired bin width. The bin width will be dynamically selected within
these bounds.
</p>
</li></ul>

<p>If the value is numeric, it is assumed to be in units of data. The bin width
(or its bounds) can also be specified using <code><a href="grid.html#topic+unit">unit()</a></code>, which may be useful if
it is desired that the dots be a certain point size or a certain percentage of
the width/height of the viewport. For example, <code>unit(0.1, "npc")</code> would make
dots that are <em>exactly</em> 10% of the viewport size along whichever dimension the
dotplot is drawn; <code>unit(c(0, 0.1), "npc")</code> would make dots that are <em>at most</em>
10% of the viewport size (while still ensuring the tallest stack is less than
or equal to <code>scale</code>).</p>
</dd>
<dt><code>dotsize</code></dt><dd><p>The width of the dots relative to the <code>binwidth</code>. The default,
<code>1.07</code>, makes dots be just a bit wider than the bin width, which is a
manually-tuned parameter that tends to work well with the default circular
shape, preventing gaps between bins from appearing to be too large visually
(as might arise from dots being <em>precisely</em> the <code>binwidth</code>). If it is desired
to have dots be precisely the <code>binwidth</code>, set <code>dotsize = 1</code>.</p>
</dd>
<dt><code>stackratio</code></dt><dd><p>The distance between the center of the dots in the same
stack relative to the dot height. The default, <code>1</code>, makes dots in the same
stack just touch each other.</p>
</dd>
<dt><code>layout</code></dt><dd><p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</dd>
<dt><code>overlaps</code></dt><dd><p>How to handle overlapping dots or bins in the <code>"bin"</code>,
<code>"weave"</code>, and <code>"hex"</code> layouts (dots never overlap in the <code>"swarm"</code> or <code>"bar"</code> layouts).
For the purposes of this argument, dots are only considered to be overlapping
if they would be overlapping when <code>dotsize = 1</code> and <code>stackratio = 1</code>; i.e.
if you set those arguments to other values, overlaps may still occur.
One of: </p>

<ul>
<li> <p><code>"keep"</code>: leave overlapping dots as they are. Dots may overlap
(usually only slightly) in the <code>"bin"</code>, <code>"weave"</code>, and <code>"hex"</code> layouts.
</p>
</li>
<li> <p><code>"nudge"</code>: nudge overlapping dots out of the way. Overlaps are avoided
using a constrained optimization which minimizes the squared distance of
dots to their desired positions, subject to the constraint that adjacent
dots do not overlap.
</p>
</li></ul>
</dd>
<dt><code>smooth</code></dt><dd><p>Smoother to apply to dot positions.
One of:
</p>

<ul>
<li><p> A function that takes a numeric vector of dot positions and returns a
smoothed version of that vector, such as <code>smooth_bounded()</code>,
<code>smooth_unbounded()</code>, smooth_discrete()<code style="white-space: pre;">&#8288;, or &#8288;</code>smooth_bar()'.
</p>
</li>
<li><p> A string indicating what smoother to use, as the suffix to a function
name starting with <code>smooth_</code>; e.g. <code>"none"</code> (the default) applies
<code>smooth_none()</code>, which simply returns the given vector without
applying smoothing.
</p>
</li></ul>

<p>Smoothing is most effective when the smoother is matched to the support of
the distribution; e.g. using <code>smooth_bounded(bounds = ...)</code>.</p>
</dd>
<dt><code>overflow</code></dt><dd><p>How to handle overflow of dots beyond the extent of the geom
when a minimum <code>binwidth</code> (or an exact <code>binwidth</code>) is supplied.
One of:
</p>

<ul>
<li> <p><code>"keep"</code>: Keep the overflow, drawing dots outside the geom bounds.
</p>
</li>
<li> <p><code>"warn"</code>: Keep the overflow, but produce a warning suggesting solutions,
such as setting <code>binwidth = NA</code> or <code>overflow = "compress"</code>.
</p>
</li>
<li> <p><code>"compress"</code>: Compress the layout. Reduces the <code>binwidth</code> to the size necessary
to keep the dots within bounds, then adjusts <code>stackratio</code> and <code>dotsize</code> so that
the apparent dot size is the user-specified minimum <code>binwidth</code> times the
user-specified <code>dotsize</code>.
</p>
</li></ul>

<p>If you find the default layout has dots that are too small, and you are okay
with dots overlapping, consider setting <code>overflow = "compress"</code> and supplying
an exact or minimum dot size using <code>binwidth</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>If <code>TRUE</code>, print out the bin width of the dotplot. Can be useful
if you want to start from an automatically-selected bin width and then adjust it
manually. Bin width is printed both as data units and as normalized parent
coordinates or <code>"npc"</code>s (see <code><a href="grid.html#topic+unit">unit()</a></code>). Note that if you just want to scale the
selected bin width to fit within a desired area, it is probably easier to use
<code>scale</code> than to copy and scale <code>binwidth</code> manually, and if you just want to
provide constraints on the bin width, you can pass a length-2 vector to <code>binwidth</code>.
</p>
</dd>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>fatten_point</code></dt><dd><p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_quantiles">quantiles</code></td>
<td>
<p>Setting this to a value other than <code>NA</code>
will produce a quantile dotplot: that is, a dotplot of quantiles from the sample or distribution
(for analytical distributions, the default of <code>NA</code> is taken to mean <code>100</code> quantiles). The value of
<code>quantiles</code> determines the number
of quantiles to plot. See Kay et al. (2016) and Fernandes et al. (2018) for more information on quantile dotplots.</p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_dotsinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>dots</em> family of stats and geoms are similar to <code><a href="ggplot2.html#topic+geom_dotplot">geom_dotplot()</a></code> but with a number of differences:
</p>

<ul>
<li><p> Dots geoms act like slabs in <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and can be given x positions (or y positions when
in a horizontal orientation).
</p>
</li>
<li><p> Given the available space to lay out dots, the dots geoms will automatically determine how many bins to
use to fit the available space.
</p>
</li>
<li><p> Dots geoms use a dynamic layout algorithm that lays out dots from the center out if the input data are
symmetrical, guaranteeing that symmetrical data results in a symmetrical plot. The layout algorithm also prevents
dots from overlapping each other.
</p>
</li>
<li><p> The shape of the dots in these geoms can be changed using the <code>slab_shape</code> aesthetic (when using the
<code>dotsinterval</code> family) or the <code>shape</code> or <code>slab_shape</code> aesthetic (when using the <code>dots</code> family)
</p>
</li></ul>

<p>Stats and geoms in this family include:
</p>

<ul>
<li> <p><code><a href="#topic+geom_dots">geom_dots()</a></code>: dotplots on raw data. Ensures the dotplot fits within available space by reducing the size
of the dots automatically (may result in very small dots).
</p>
</li>
<li> <p><code><a href="#topic+geom_swarm">geom_swarm()</a></code> and <code><a href="#topic+geom_weave">geom_weave()</a></code>: dotplots on raw data with defaults intended to create &quot;beeswarm&quot; plots.
Used <code>side = "both"</code> by default, and sets the default dot size to the same size as <code><a href="ggplot2.html#topic+geom_point">geom_point()</a></code>
(<code>binwidth = unit(1.5, "mm")</code>), allowing dots to overlap instead of getting very small.
</p>
</li>
<li> <p><code><a href="#topic+stat_dots">stat_dots()</a></code>: dotplots on raw data, <span class="pkg">distributional</span> objects, and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s
</p>
</li>
<li> <p><code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>: dotplot + interval plots on raw data with already-calculated
intervals (rarely useful directly).
</p>
</li>
<li> <p><code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>: dotplot + interval plots on raw data, <span class="pkg">distributional</span> objects,
and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s (will calculate intervals for you).
</p>
</li>
<li> <p><code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>: blurry dotplots that allow the standard deviation of a blur applied to
each dot to be specified using the <code>sd</code> aesthetic.
</p>
</li>
<li> <p><code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code>: blurry dotplots of quantiles using the Monte Carlo Standard Error of each quantile.
</p>
</li></ul>

<p><code><a href="#topic+stat_dots">stat_dots()</a></code> and <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>, when used with the <code>quantiles</code> argument,
are particularly useful for constructing quantile dotplots, which can be an effective way to communicate uncertainty
using a frequency framing that may be easier for laypeople to understand (Kay et al. 2016, Fernandes et al. 2018).
</p>
<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a dots + point + interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The dots+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>dots</strong> (aka the <strong>slab</strong>), the
<strong>point</strong>, and the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Dots-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>family</code>: The font family used to draw the dots.
</p>
</li>
<li><p><code>order</code>: The order in which data points are stacked within bins. Can be used to create the effect of
&quot;stacked&quot; dots by ordering dots according to a discrete variable. If omitted (<code>NULL</code>), the
value of the data points themselves are used to determine stacking order. Only applies when
<code>layout</code> is <code>"bin"</code> or <code>"hex"</code>, as the other layout methods fully determine both <em>x</em> and <em>y</em> positions.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li>
<li><p><code>slab_shape</code>: Override for <code>shape</code>: the shape of the dots used to draw the dotplot slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("dotsinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>References</h3>

<p>Kay, M., Kola, T., Hullman, J. R., &amp; Munson, S. A. (2016). When (ish) is My Bus? User-centered Visualizations
of Uncertainty in Everyday, Mobile Predictive Systems. <em>Conference on Human Factors
in Computing Systems - CHI '16</em>, 5092&ndash;5103. <a href="https://doi.org/10.1145/2858036.2858558">doi:10.1145/2858036.2858558</a>.
</p>
<p>Fernandes, M., Walls, L., Munson, S., Hullman, J., &amp; Kay, M. (2018). Uncertainty Displays Using Quantile Dotplots
or CDFs Improve Transit Decision-Making. <em>Conference on Human Factors in Computing Systems - CHI '18</em>.
<a href="https://doi.org/10.1145/3173574.3173718">doi:10.1145/3173574.3173718</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code> for the geom underlying this stat.
See <code>vignette("dotsinterval")</code> for a variety of examples of use.
</p>
<p>Other dotsinterval stats: 
<code><a href="#topic+stat_dots">stat_dots</a>()</code>,
<code><a href="#topic+stat_mcse_dots">stat_mcse_dots</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(12345)
tibble(
  x = rep(1:10, 100),
  y = rnorm(1000, x)
) %&gt;%
  ggplot(aes(x = x, y = y)) +
  stat_dotsinterval()

# ON ANALYTICAL DISTRIBUTIONS
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
tibble(
  x = 1:10,
  sd = seq(1, 3, length.out = 10)
) %&gt;%
  ggplot(aes(x = x, ydist = dist_normal(x, sd))) +
  stat_dotsinterval(quantiles = 50)
</code></pre>

<hr>
<h2 id='stat_eye'>Eye (violin + interval) plot (shortcut stat)</h2><span id='topic+stat_eye'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for
creating eye (violin + interval) plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_slabinterval(
  aes(side = after_stat("both"))
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_eye(
  mapping = NULL,
  data = NULL,
  geom = "slabinterval",
  position = "identity",
  ...,
  p_limits = c(NA, NA),
  density = "bounded",
  adjust = waiver(),
  trim = TRUE,
  expand = FALSE,
  breaks = waiver(),
  align = "none",
  outline_bars = FALSE,
  point_interval = "median_qi",
  slab_type = NULL,
  limits = NULL,
  n = 501,
  .width = c(0.66, 0.95),
  orientation = NA,
  na.rm = FALSE,
  show.legend = c(size = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_eye_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_eye">stat_eye()</a></code> and <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code></p>
</td></tr>
<tr><td><code id="stat_eye_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>,
these include:
</p>

<dl>
<dt><code>normalize</code></dt><dd><p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</dd>
<dt><code>fill_type</code></dt><dd><p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</dd>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>fatten_point</code></dt><dd><p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_eye_+3A_p_limits">p_limits</code></td>
<td>
<p>Probability limits (as a vector of size 2) used to determine the lower and upper
limits of <em>theoretical</em> distributions (distributions from <em>samples</em> ignore this parameter and determine
their limits based on the limits of the sample). E.g., if this is <code>c(.001, .999)</code>, then a slab is drawn
for the distribution from the quantile at <code>p = .001</code> to the quantile at <code>p = .999</code>. If the lower
(respectively upper) limit is <code>NA</code>, then the lower (upper) limit will be the minimum (maximum) of the
distribution's support if it is finite, and <code>0.001</code> (<code>0.999</code>) if it is not finite. E.g., if
<code>p_limits</code> is <code>c(NA, NA)</code>, on a gamma distribution the effective value of <code>p_limits</code> would be
<code>c(0, .999)</code> since the gamma distribution is defined on <code style="white-space: pre;">&#8288;(0, Inf)&#8288;</code>; whereas on a normal distribution
it would be equivalent to <code>c(.001, .999)</code> since the normal distribution is defined on <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_density">density</code></td>
<td>
<p>Density estimator for sample data. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>. This format is also compatible with <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>, <code>"unbounded"</code> for <code style="white-space: pre;">&#8288;[density_unbounded()]&#8288;</code>,
or <code>"histogram"</code> for <code><a href="#topic+density_histogram">density_histogram()</a></code>.
Defaults to <code>"bounded"</code>, i.e. <code><a href="#topic+density_bounded">density_bounded()</a></code>, which estimates the bounds from
the data and then uses a bounded density estimator based on the reflection method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_eye_+3A_adjust">adjust</code></td>
<td>
<p>Passed to <code>density</code>: the bandwidth for the density estimator for sample data
is adjusted by multiplying it by this value. See e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code> for more information.
Default (<code>waiver()</code>) defers to the default of the density estimator, which is usually <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_trim">trim</code></td>
<td>
<p>For sample data, should the density estimate be trimmed to the range of the
data? Passed on to the density estimator; see the <code>density</code> parameter. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_expand">expand</code></td>
<td>
<p>For sample data, should the slab be expanded to the limits of the scale? Default <code>FALSE</code>.
Can be length two to control expansion to the lower and upper limit respectively.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_outline_bars">outline_bars</code></td>
<td>
<p>For sample data (if <code>density</code> is <code>"histogram"</code>) and for discrete analytical
distributions (whose slabs are drawn as histograms), determines
if outlines in between the bars are drawn when the <code>slab_color</code> aesthetic is used. If <code>FALSE</code>
(the default), the outline is drawn only along the tops of the bars; if <code>TRUE</code>, outlines in between
bars are also drawn. See <code><a href="#topic+density_histogram">density_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_slab_type">slab_type</code></td>
<td>
<p>(deprecated) The type of slab function to calculate: probability density (or mass) function
(<code>"pdf"</code>), cumulative distribution function (<code>"cdf"</code>), or complementary CDF (<code>"ccdf"</code>). Instead of using
<code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an aesthetic, it is now recommended to simply map the
corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or  <code>1 - cdf</code>) directly onto the desired aesthetic.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_limits">limits</code></td>
<td>
<p>Manually-specified limits for the slab, as a vector of length two. These limits are combined with those
computed based on <code>p_limits</code> as well as the limits defined by the scales of the plot to determine the
limits used to draw the slab functions: these limits specify the maximal limits; i.e., if specified, the limits
will not be wider than these (but may be narrower). Use <code>NA</code> to leave a limit alone; e.g.
<code>limits = c(0, NA)</code> will ensure that the lower limit does not go below 0, but let the upper limit
be determined by either <code>p_limits</code> or the scale settings.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate the function that defines the slab.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_eye_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a eye (violin + interval) geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval</a>()</code>,
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval</a>()</code>,
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval</a>()</code>,
<code><a href="#topic+stat_halfeye">stat_halfeye</a>()</code>,
<code><a href="#topic+stat_histinterval">stat_histinterval</a>()</code>,
<code><a href="#topic+stat_interval">stat_interval</a>()</code>,
<code><a href="#topic+stat_pointinterval">stat_pointinterval</a>()</code>,
<code><a href="#topic+stat_slab">stat_slab</a>()</code>,
<code><a href="#topic+stat_spike">stat_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c"),
  value = rnorm(1500, mean = c(5, 7, 9), sd = c(1, 1.5, 1))
)
df %&gt;%
  ggplot(aes(x = value, y = group)) +
  stat_eye()

# ON ANALYTICAL DISTRIBUTIONS
dist_df = data.frame(
  group = c("a", "b", "c"),
  mean =  c(  5,   7,   8),
  sd =    c(  1, 1.5,   1)
)
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
dist_df %&gt;%
  ggplot(aes(y = group, xdist = dist_normal(mean, sd))) +
  stat_eye()
</code></pre>

<hr>
<h2 id='stat_gradientinterval'>Gradient + interval plot (shortcut stat)</h2><span id='topic+stat_gradientinterval'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for
creating gradient + interval plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_slabinterval(
  aes(
    justification = after_stat(0.5),
    thickness = after_stat(thickness(1)),
    slab_alpha = after_stat(f)
  ),
  fill_type = "auto",
  show.legend = c(size = FALSE, slab_alpha = FALSE)
)</pre>
<p>If your graphics device supports it, it is recommended to use this stat
with <code>fill_type = "gradient"</code> (see the description of that parameter). On R &gt;= 4.2,
support for <code>fill_type = "gradient"</code> should be auto-detected based on the
graphics device you are using.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_gradientinterval(
  mapping = NULL,
  data = NULL,
  geom = "slabinterval",
  position = "identity",
  ...,
  fill_type = "auto",
  p_limits = c(NA, NA),
  density = "bounded",
  adjust = waiver(),
  trim = TRUE,
  expand = FALSE,
  breaks = waiver(),
  align = "none",
  outline_bars = FALSE,
  point_interval = "median_qi",
  slab_type = NULL,
  limits = NULL,
  n = 501,
  .width = c(0.66, 0.95),
  orientation = NA,
  na.rm = FALSE,
  show.legend = c(size = FALSE, slab_alpha = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_gradientinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code> and <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code></p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>,
these include:
</p>

<dl>
<dt><code>normalize</code></dt><dd><p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</dd>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>fatten_point</code></dt><dd><p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_fill_type">fill_type</code></td>
<td>
<p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_p_limits">p_limits</code></td>
<td>
<p>Probability limits (as a vector of size 2) used to determine the lower and upper
limits of <em>theoretical</em> distributions (distributions from <em>samples</em> ignore this parameter and determine
their limits based on the limits of the sample). E.g., if this is <code>c(.001, .999)</code>, then a slab is drawn
for the distribution from the quantile at <code>p = .001</code> to the quantile at <code>p = .999</code>. If the lower
(respectively upper) limit is <code>NA</code>, then the lower (upper) limit will be the minimum (maximum) of the
distribution's support if it is finite, and <code>0.001</code> (<code>0.999</code>) if it is not finite. E.g., if
<code>p_limits</code> is <code>c(NA, NA)</code>, on a gamma distribution the effective value of <code>p_limits</code> would be
<code>c(0, .999)</code> since the gamma distribution is defined on <code style="white-space: pre;">&#8288;(0, Inf)&#8288;</code>; whereas on a normal distribution
it would be equivalent to <code>c(.001, .999)</code> since the normal distribution is defined on <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_density">density</code></td>
<td>
<p>Density estimator for sample data. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>. This format is also compatible with <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>, <code>"unbounded"</code> for <code style="white-space: pre;">&#8288;[density_unbounded()]&#8288;</code>,
or <code>"histogram"</code> for <code><a href="#topic+density_histogram">density_histogram()</a></code>.
Defaults to <code>"bounded"</code>, i.e. <code><a href="#topic+density_bounded">density_bounded()</a></code>, which estimates the bounds from
the data and then uses a bounded density estimator based on the reflection method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_adjust">adjust</code></td>
<td>
<p>Passed to <code>density</code>: the bandwidth for the density estimator for sample data
is adjusted by multiplying it by this value. See e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code> for more information.
Default (<code>waiver()</code>) defers to the default of the density estimator, which is usually <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_trim">trim</code></td>
<td>
<p>For sample data, should the density estimate be trimmed to the range of the
data? Passed on to the density estimator; see the <code>density</code> parameter. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_expand">expand</code></td>
<td>
<p>For sample data, should the slab be expanded to the limits of the scale? Default <code>FALSE</code>.
Can be length two to control expansion to the lower and upper limit respectively.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_outline_bars">outline_bars</code></td>
<td>
<p>For sample data (if <code>density</code> is <code>"histogram"</code>) and for discrete analytical
distributions (whose slabs are drawn as histograms), determines
if outlines in between the bars are drawn when the <code>slab_color</code> aesthetic is used. If <code>FALSE</code>
(the default), the outline is drawn only along the tops of the bars; if <code>TRUE</code>, outlines in between
bars are also drawn. See <code><a href="#topic+density_histogram">density_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_slab_type">slab_type</code></td>
<td>
<p>(deprecated) The type of slab function to calculate: probability density (or mass) function
(<code>"pdf"</code>), cumulative distribution function (<code>"cdf"</code>), or complementary CDF (<code>"ccdf"</code>). Instead of using
<code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an aesthetic, it is now recommended to simply map the
corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or  <code>1 - cdf</code>) directly onto the desired aesthetic.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_limits">limits</code></td>
<td>
<p>Manually-specified limits for the slab, as a vector of length two. These limits are combined with those
computed based on <code>p_limits</code> as well as the limits defined by the scales of the plot to determine the
limits used to draw the slab functions: these limits specify the maximal limits; i.e., if specified, the limits
will not be wider than these (but may be narrower). Use <code>NA</code> to leave a limit alone; e.g.
<code>limits = c(0, NA)</code> will ensure that the lower limit does not go below 0, but let the upper limit
be determined by either <code>p_limits</code> or the scale settings.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate the function that defines the slab.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_gradientinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a gradient + interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval</a>()</code>,
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval</a>()</code>,
<code><a href="#topic+stat_eye">stat_eye</a>()</code>,
<code><a href="#topic+stat_halfeye">stat_halfeye</a>()</code>,
<code><a href="#topic+stat_histinterval">stat_histinterval</a>()</code>,
<code><a href="#topic+stat_interval">stat_interval</a>()</code>,
<code><a href="#topic+stat_pointinterval">stat_pointinterval</a>()</code>,
<code><a href="#topic+stat_slab">stat_slab</a>()</code>,
<code><a href="#topic+stat_spike">stat_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c"),
  value = rnorm(1500, mean = c(5, 7, 9), sd = c(1, 1.5, 1))
)
df %&gt;%
  ggplot(aes(x = value, y = group)) +
  stat_gradientinterval()

# ON ANALYTICAL DISTRIBUTIONS
dist_df = data.frame(
  group = c("a", "b", "c"),
  mean =  c(  5,   7,   8),
  sd =    c(  1, 1.5,   1)
)
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
dist_df %&gt;%
  ggplot(aes(y = group, xdist = dist_normal(mean, sd))) +
  stat_gradientinterval()
</code></pre>

<hr>
<h2 id='stat_halfeye'>Half-eye (density + interval) plot (shortcut stat)</h2><span id='topic+stat_halfeye'></span>

<h3>Description</h3>

<p>Equivalent to <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code>, whose default settings create half-eye (density + interval) plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_halfeye(
  mapping = NULL,
  data = NULL,
  geom = "slabinterval",
  position = "identity",
  ...,
  p_limits = c(NA, NA),
  density = "bounded",
  adjust = waiver(),
  trim = TRUE,
  expand = FALSE,
  breaks = waiver(),
  align = "none",
  outline_bars = FALSE,
  point_interval = "median_qi",
  slab_type = NULL,
  limits = NULL,
  n = 501,
  .width = c(0.66, 0.95),
  orientation = NA,
  na.rm = FALSE,
  show.legend = c(size = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_halfeye_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_halfeye">stat_halfeye()</a></code> and <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code></p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>,
these include:
</p>

<dl>
<dt><code>normalize</code></dt><dd><p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</dd>
<dt><code>fill_type</code></dt><dd><p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</dd>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>fatten_point</code></dt><dd><p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_p_limits">p_limits</code></td>
<td>
<p>Probability limits (as a vector of size 2) used to determine the lower and upper
limits of <em>theoretical</em> distributions (distributions from <em>samples</em> ignore this parameter and determine
their limits based on the limits of the sample). E.g., if this is <code>c(.001, .999)</code>, then a slab is drawn
for the distribution from the quantile at <code>p = .001</code> to the quantile at <code>p = .999</code>. If the lower
(respectively upper) limit is <code>NA</code>, then the lower (upper) limit will be the minimum (maximum) of the
distribution's support if it is finite, and <code>0.001</code> (<code>0.999</code>) if it is not finite. E.g., if
<code>p_limits</code> is <code>c(NA, NA)</code>, on a gamma distribution the effective value of <code>p_limits</code> would be
<code>c(0, .999)</code> since the gamma distribution is defined on <code style="white-space: pre;">&#8288;(0, Inf)&#8288;</code>; whereas on a normal distribution
it would be equivalent to <code>c(.001, .999)</code> since the normal distribution is defined on <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_density">density</code></td>
<td>
<p>Density estimator for sample data. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>. This format is also compatible with <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>, <code>"unbounded"</code> for <code style="white-space: pre;">&#8288;[density_unbounded()]&#8288;</code>,
or <code>"histogram"</code> for <code><a href="#topic+density_histogram">density_histogram()</a></code>.
Defaults to <code>"bounded"</code>, i.e. <code><a href="#topic+density_bounded">density_bounded()</a></code>, which estimates the bounds from
the data and then uses a bounded density estimator based on the reflection method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_adjust">adjust</code></td>
<td>
<p>Passed to <code>density</code>: the bandwidth for the density estimator for sample data
is adjusted by multiplying it by this value. See e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code> for more information.
Default (<code>waiver()</code>) defers to the default of the density estimator, which is usually <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_trim">trim</code></td>
<td>
<p>For sample data, should the density estimate be trimmed to the range of the
data? Passed on to the density estimator; see the <code>density</code> parameter. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_expand">expand</code></td>
<td>
<p>For sample data, should the slab be expanded to the limits of the scale? Default <code>FALSE</code>.
Can be length two to control expansion to the lower and upper limit respectively.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_outline_bars">outline_bars</code></td>
<td>
<p>For sample data (if <code>density</code> is <code>"histogram"</code>) and for discrete analytical
distributions (whose slabs are drawn as histograms), determines
if outlines in between the bars are drawn when the <code>slab_color</code> aesthetic is used. If <code>FALSE</code>
(the default), the outline is drawn only along the tops of the bars; if <code>TRUE</code>, outlines in between
bars are also drawn. See <code><a href="#topic+density_histogram">density_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_slab_type">slab_type</code></td>
<td>
<p>(deprecated) The type of slab function to calculate: probability density (or mass) function
(<code>"pdf"</code>), cumulative distribution function (<code>"cdf"</code>), or complementary CDF (<code>"ccdf"</code>). Instead of using
<code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an aesthetic, it is now recommended to simply map the
corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or  <code>1 - cdf</code>) directly onto the desired aesthetic.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_limits">limits</code></td>
<td>
<p>Manually-specified limits for the slab, as a vector of length two. These limits are combined with those
computed based on <code>p_limits</code> as well as the limits defined by the scales of the plot to determine the
limits used to draw the slab functions: these limits specify the maximal limits; i.e., if specified, the limits
will not be wider than these (but may be narrower). Use <code>NA</code> to leave a limit alone; e.g.
<code>limits = c(0, NA)</code> will ensure that the lower limit does not go below 0, but let the upper limit
be determined by either <code>p_limits</code> or the scale settings.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate the function that defines the slab.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_halfeye_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a half-eye (density + interval) geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval</a>()</code>,
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval</a>()</code>,
<code><a href="#topic+stat_eye">stat_eye</a>()</code>,
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval</a>()</code>,
<code><a href="#topic+stat_histinterval">stat_histinterval</a>()</code>,
<code><a href="#topic+stat_interval">stat_interval</a>()</code>,
<code><a href="#topic+stat_pointinterval">stat_pointinterval</a>()</code>,
<code><a href="#topic+stat_slab">stat_slab</a>()</code>,
<code><a href="#topic+stat_spike">stat_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c"),
  value = rnorm(1500, mean = c(5, 7, 9), sd = c(1, 1.5, 1))
)
df %&gt;%
  ggplot(aes(x = value, y = group)) +
  stat_halfeye()

# ON ANALYTICAL DISTRIBUTIONS
dist_df = data.frame(
  group = c("a", "b", "c"),
  mean =  c(  5,   7,   8),
  sd =    c(  1, 1.5,   1)
)
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
dist_df %&gt;%
  ggplot(aes(y = group, xdist = dist_normal(mean, sd))) +
  stat_halfeye()
</code></pre>

<hr>
<h2 id='stat_histinterval'>Histogram + interval plot (shortcut stat)</h2><span id='topic+stat_histinterval'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for
creating histogram + interval plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_slabinterval(
  density = "histogram"
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_histinterval(
  mapping = NULL,
  data = NULL,
  geom = "slabinterval",
  position = "identity",
  ...,
  density = "histogram",
  p_limits = c(NA, NA),
  adjust = waiver(),
  trim = TRUE,
  expand = FALSE,
  breaks = waiver(),
  align = "none",
  outline_bars = FALSE,
  point_interval = "median_qi",
  slab_type = NULL,
  limits = NULL,
  n = 501,
  .width = c(0.66, 0.95),
  orientation = NA,
  na.rm = FALSE,
  show.legend = c(size = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_histinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_histinterval">stat_histinterval()</a></code> and <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code></p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>,
these include:
</p>

<dl>
<dt><code>normalize</code></dt><dd><p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</dd>
<dt><code>fill_type</code></dt><dd><p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</dd>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>fatten_point</code></dt><dd><p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_density">density</code></td>
<td>
<p>Density estimator for sample data. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>. This format is also compatible with <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>, <code>"unbounded"</code> for <code style="white-space: pre;">&#8288;[density_unbounded()]&#8288;</code>,
or <code>"histogram"</code> for <code><a href="#topic+density_histogram">density_histogram()</a></code>.
Defaults to <code>"bounded"</code>, i.e. <code><a href="#topic+density_bounded">density_bounded()</a></code>, which estimates the bounds from
the data and then uses a bounded density estimator based on the reflection method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_p_limits">p_limits</code></td>
<td>
<p>Probability limits (as a vector of size 2) used to determine the lower and upper
limits of <em>theoretical</em> distributions (distributions from <em>samples</em> ignore this parameter and determine
their limits based on the limits of the sample). E.g., if this is <code>c(.001, .999)</code>, then a slab is drawn
for the distribution from the quantile at <code>p = .001</code> to the quantile at <code>p = .999</code>. If the lower
(respectively upper) limit is <code>NA</code>, then the lower (upper) limit will be the minimum (maximum) of the
distribution's support if it is finite, and <code>0.001</code> (<code>0.999</code>) if it is not finite. E.g., if
<code>p_limits</code> is <code>c(NA, NA)</code>, on a gamma distribution the effective value of <code>p_limits</code> would be
<code>c(0, .999)</code> since the gamma distribution is defined on <code style="white-space: pre;">&#8288;(0, Inf)&#8288;</code>; whereas on a normal distribution
it would be equivalent to <code>c(.001, .999)</code> since the normal distribution is defined on <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_adjust">adjust</code></td>
<td>
<p>Passed to <code>density</code>: the bandwidth for the density estimator for sample data
is adjusted by multiplying it by this value. See e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code> for more information.
Default (<code>waiver()</code>) defers to the default of the density estimator, which is usually <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_trim">trim</code></td>
<td>
<p>For sample data, should the density estimate be trimmed to the range of the
data? Passed on to the density estimator; see the <code>density</code> parameter. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_expand">expand</code></td>
<td>
<p>For sample data, should the slab be expanded to the limits of the scale? Default <code>FALSE</code>.
Can be length two to control expansion to the lower and upper limit respectively.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_outline_bars">outline_bars</code></td>
<td>
<p>For sample data (if <code>density</code> is <code>"histogram"</code>) and for discrete analytical
distributions (whose slabs are drawn as histograms), determines
if outlines in between the bars are drawn when the <code>slab_color</code> aesthetic is used. If <code>FALSE</code>
(the default), the outline is drawn only along the tops of the bars; if <code>TRUE</code>, outlines in between
bars are also drawn. See <code><a href="#topic+density_histogram">density_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_slab_type">slab_type</code></td>
<td>
<p>(deprecated) The type of slab function to calculate: probability density (or mass) function
(<code>"pdf"</code>), cumulative distribution function (<code>"cdf"</code>), or complementary CDF (<code>"ccdf"</code>). Instead of using
<code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an aesthetic, it is now recommended to simply map the
corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or  <code>1 - cdf</code>) directly onto the desired aesthetic.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_limits">limits</code></td>
<td>
<p>Manually-specified limits for the slab, as a vector of length two. These limits are combined with those
computed based on <code>p_limits</code> as well as the limits defined by the scales of the plot to determine the
limits used to draw the slab functions: these limits specify the maximal limits; i.e., if specified, the limits
will not be wider than these (but may be narrower). Use <code>NA</code> to leave a limit alone; e.g.
<code>limits = c(0, NA)</code> will ensure that the lower limit does not go below 0, but let the upper limit
be determined by either <code>p_limits</code> or the scale settings.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate the function that defines the slab.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_histinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a histogram + interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval</a>()</code>,
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval</a>()</code>,
<code><a href="#topic+stat_eye">stat_eye</a>()</code>,
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval</a>()</code>,
<code><a href="#topic+stat_halfeye">stat_halfeye</a>()</code>,
<code><a href="#topic+stat_interval">stat_interval</a>()</code>,
<code><a href="#topic+stat_pointinterval">stat_pointinterval</a>()</code>,
<code><a href="#topic+stat_slab">stat_slab</a>()</code>,
<code><a href="#topic+stat_spike">stat_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c"),
  value = rnorm(1500, mean = c(5, 7, 9), sd = c(1, 1.5, 1))
)
df %&gt;%
  ggplot(aes(x = value, y = group)) +
  stat_histinterval()

# ON ANALYTICAL DISTRIBUTIONS
dist_df = data.frame(
  group = c("a", "b", "c"),
  mean =  c(  5,   7,   8),
  sd =    c(  1, 1.5,   1)
)
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
dist_df %&gt;%
  ggplot(aes(y = group, xdist = dist_normal(mean, sd))) +
  stat_histinterval()
</code></pre>

<hr>
<h2 id='stat_interval'>Multiple-interval plot (shortcut stat)</h2><span id='topic+stat_interval'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> with <code><a href="#topic+geom_interval">geom_interval()</a></code> for
creating multiple-interval plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_slabinterval(
  aes(
    colour = after_stat(level),
    size = NULL
  ),
  geom = "interval",
  show_point = FALSE,
  .width = c(0.5, 0.8, 0.95),
  show_slab = FALSE,
  show.legend = NA
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_interval(
  mapping = NULL,
  data = NULL,
  geom = "interval",
  position = "identity",
  ...,
  .width = c(0.5, 0.8, 0.95),
  point_interval = "median_qi",
  orientation = NA,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_interval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_interval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_interval_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_interval">stat_interval()</a></code> and <code><a href="#topic+geom_interval">geom_interval()</a></code></p>
</td></tr>
<tr><td><code id="stat_interval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_interval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_interval">geom_interval()</a></code>,
these include:
</p>

<dl>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_interval_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_interval_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_interval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_interval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_interval_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_interval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a multiple-interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_interval">geom_interval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_interval">geom_interval()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval</a>()</code>,
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval</a>()</code>,
<code><a href="#topic+stat_eye">stat_eye</a>()</code>,
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval</a>()</code>,
<code><a href="#topic+stat_halfeye">stat_halfeye</a>()</code>,
<code><a href="#topic+stat_histinterval">stat_histinterval</a>()</code>,
<code><a href="#topic+stat_pointinterval">stat_pointinterval</a>()</code>,
<code><a href="#topic+stat_slab">stat_slab</a>()</code>,
<code><a href="#topic+stat_spike">stat_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c"),
  value = rnorm(1500, mean = c(5, 7, 9), sd = c(1, 1.5, 1))
)
df %&gt;%
  ggplot(aes(x = value, y = group)) +
  stat_interval() +
  scale_color_brewer()

# ON ANALYTICAL DISTRIBUTIONS
dist_df = data.frame(
  group = c("a", "b", "c"),
  mean =  c(  5,   7,   8),
  sd =    c(  1, 1.5,   1)
)
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
dist_df %&gt;%
  ggplot(aes(y = group, xdist = dist_normal(mean, sd))) +
  stat_interval() +
  scale_color_brewer()
</code></pre>

<hr>
<h2 id='stat_lineribbon'>Line + multiple-ribbon plot (shortcut stat)</h2><span id='topic+stat_lineribbon'></span>

<h3>Description</h3>

<p>A combination of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> with sensible defaults
for making line + multiple-ribbon plots. While <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> is intended for use on data
frames that have already been summarized using a <code><a href="#topic+point_interval">point_interval()</a></code> function,
<code><a href="#topic+stat_lineribbon">stat_lineribbon()</a></code> is intended for use directly on data frames of draws or of
analytical distributions, and will perform the summarization using a <code><a href="#topic+point_interval">point_interval()</a></code>
function.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_slabinterval(
  aes(
    group = after_stat(level),
    fill = after_stat(level),
    order = after_stat(level),
    size = NULL
  ),
  geom = "lineribbon",
  .width = c(0.5, 0.8, 0.95),
  show_slab = FALSE,
  show.legend = NA
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_lineribbon(
  mapping = NULL,
  data = NULL,
  geom = "lineribbon",
  position = "identity",
  ...,
  .width = c(0.5, 0.8, 0.95),
  point_interval = "median_qi",
  orientation = NA,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_lineribbon_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_lineribbon">stat_lineribbon()</a></code> and <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code></p>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code>,
these include:
</p>

<dl>
<dt><code>step</code></dt><dd><p>Should the line/ribbon be drawn as a step function? One of:
</p>

<ul>
<li> <p><code>FALSE</code> (default): do not draw as a step function.
</p>
</li>
<li> <p><code>"mid"</code> (or <code>TRUE</code>): draw steps midway between adjacent x values.
</p>
</li>
<li> <p><code>"hv"</code>: draw horizontal-then-vertical steps.
</p>
</li>
<li> <p><code>"vh"</code>: draw as vertical-then-horizontal steps.
</p>
</li></ul>

<p><code>TRUE</code> is an alias for <code>"mid"</code> because for a step function with ribbons, <code>"mid"</code> is probably what you want
(for the other two step approaches the ribbons at either the very first or very last x value will not be
visible).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? <code>NA</code>,
the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes,
and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_lineribbon_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a line + multiple-ribbon geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The line+ribbon <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their two sub-geometries: the <strong>line</strong> and the <strong>ribbon</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Ribbon-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left edge of the ribbon sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right edge of the ribbon sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower edge of the ribbon sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper edge of the ribbon sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>order</code>: The order in which ribbons are drawn. Ribbons with the smallest mean value of <code>order</code>
are drawn first (i.e., will be drawn below ribbons with larger mean values of <code>order</code>). If
<code>order</code> is not supplied to <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code>, <code>-abs(xmax - xmin)</code> or <code>-abs(ymax - ymax)</code>
(depending on <code>orientation</code>) is used, having the effect of drawing the widest (on average)
ribbons on the bottom. <code><a href="#topic+stat_lineribbon">stat_lineribbon()</a></code> uses <code>order = after_stat(level)</code> by default,
causing the ribbons generated from the largest <code>.width</code> to be drawn on the bottom.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>line</strong> sub-geometry.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>ribbon</strong> sub-geometry.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>line</strong> and <strong>ribbon</strong> sub-geometries.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of <strong>line</strong>. In <span class="pkg">ggplot2</span> &lt; 3.4, was called <code>size</code>.
</p>
</li>
<li><p><code>linetype</code>: Type of <strong>line</strong> (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc)
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("lineribbon")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> for the geom underlying this stat.
</p>
<p>Other lineribbon stats: 
<code><a href="#topic+stat_ribbon">stat_ribbon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(12345)
tibble(
  x = rep(1:10, 100),
  y = rnorm(1000, x)
) %&gt;%
  ggplot(aes(x = x, y = y)) +
  stat_lineribbon() +
  scale_fill_brewer()

# ON ANALYTICAL DISTRIBUTIONS
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
tibble(
  x = 1:10,
  sd = seq(1, 3, length.out = 10)
) %&gt;%
  ggplot(aes(x = x, ydist = dist_normal(x, sd))) +
  stat_lineribbon() +
  scale_fill_brewer()
</code></pre>

<hr>
<h2 id='stat_mcse_dots'>Blurry MCSE dot plot (stat)</h2><span id='topic+stat_mcse_dots'></span>

<h3>Description</h3>

<p>Variant of <code><a href="#topic+stat_dots">stat_dots()</a></code> for creating blurry dotplots of quantiles. Uses
<code><a href="posterior.html#topic+mcse_quantile">posterior::mcse_quantile()</a></code> to calculate the Monte Carlo Standard Error
of each quantile computed for the dotplot, yielding an <code>se</code> computed variable
that is by default mapped onto the <code>sd</code> aesthetic of <code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_mcse_dots(
  mapping = NULL,
  data = NULL,
  geom = "blur_dots",
  position = "identity",
  ...,
  quantiles = NA,
  orientation = NA,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_mcse_dots_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_mcse_dots_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_mcse_dots_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code> and <code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code></p>
</td></tr>
<tr><td><code id="stat_mcse_dots_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_mcse_dots_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>,
these include:
</p>

<dl>
<dt><code>blur</code></dt><dd><p>Blur function to apply to dots.
One of: </p>

<ul>
<li><p> A function that takes a numeric vector of distances from the dot
center, the dot radius, and the standard deviation of the blur and returns
a vector of opacities in <code class="reqn">[0, 1]</code>, such as <code><a href="#topic+blur_gaussian">blur_gaussian()</a></code>
or <code><a href="#topic+blur_interval">blur_interval()</a></code>.
</p>
</li>
<li><p> A string indicating what blur function to use, as the suffix to a
function name starting with <code>blur_</code>; e.g. <code>"gaussian"</code> (the default)
applies <code><a href="#topic+blur_gaussian">blur_gaussian()</a></code>.
</p>
</li></ul>
</dd>
<dt><code>binwidth</code></dt><dd><p>The bin width to use for laying out the dots.
One of:
</p>

<ul>
<li> <p><code>NA</code> (the default): Dynamically select the bin width based on the
size of the plot when drawn. This will pick a <code>binwidth</code> such that the
tallest stack of dots is at most <code>scale</code> in height (ideally exactly <code>scale</code>
in height, though this is not guaranteed).
</p>
</li>
<li><p> A length-1 (scalar) numeric or <a href="grid.html#topic+unit">unit</a> object giving the exact bin width.
</p>
</li>
<li><p> A length-2 (vector) numeric or <a href="grid.html#topic+unit">unit</a> object giving the minimum and maximum
desired bin width. The bin width will be dynamically selected within
these bounds.
</p>
</li></ul>

<p>If the value is numeric, it is assumed to be in units of data. The bin width
(or its bounds) can also be specified using <code><a href="grid.html#topic+unit">unit()</a></code>, which may be useful if
it is desired that the dots be a certain point size or a certain percentage of
the width/height of the viewport. For example, <code>unit(0.1, "npc")</code> would make
dots that are <em>exactly</em> 10% of the viewport size along whichever dimension the
dotplot is drawn; <code>unit(c(0, 0.1), "npc")</code> would make dots that are <em>at most</em>
10% of the viewport size (while still ensuring the tallest stack is less than
or equal to <code>scale</code>).</p>
</dd>
<dt><code>dotsize</code></dt><dd><p>The width of the dots relative to the <code>binwidth</code>. The default,
<code>1.07</code>, makes dots be just a bit wider than the bin width, which is a
manually-tuned parameter that tends to work well with the default circular
shape, preventing gaps between bins from appearing to be too large visually
(as might arise from dots being <em>precisely</em> the <code>binwidth</code>). If it is desired
to have dots be precisely the <code>binwidth</code>, set <code>dotsize = 1</code>.</p>
</dd>
<dt><code>stackratio</code></dt><dd><p>The distance between the center of the dots in the same
stack relative to the dot height. The default, <code>1</code>, makes dots in the same
stack just touch each other.</p>
</dd>
<dt><code>layout</code></dt><dd><p>The layout method used
for the dots: </p>

<ul>
<li> <p><code>"bin"</code> (default): places dots on the off-axis at the midpoint of
their bins as in the classic Wilkinson dotplot. This maintains the
alignment of rows and columns in the dotplot. This layout is slightly
different from the classic Wilkinson algorithm in that: (1) it nudges
bins slightly to avoid overlapping bins and (2) if the input data are
symmetrical it will return a symmetrical layout.
</p>
</li>
<li> <p><code>"weave"</code>: uses the same basic binning approach of <code>"bin"</code>, but
places dots in the off-axis at their actual positions (unless
<code>overlaps = "nudge"</code>, in which case overlaps may be nudged out of the
way). This maintains the alignment of rows but does not align dots
within columns.
</p>
</li>
<li> <p><code>"hex"</code>: uses the same basic binning approach of <code>"bin"</code>, but
alternates placing dots <code>+ binwidth/4</code> or <code>- binwidth/4</code> in the
off-axis from the bin center. This allows hexagonal packing by setting
a <code>stackratio</code> less than 1 (something like <code>0.9</code> tends to work).
</p>
</li>
<li> <p><code>"swarm"</code>: uses the <code>"compactswarm"</code> layout from
<code><a href="beeswarm.html#topic+beeswarm">beeswarm::beeswarm()</a></code>. Does not maintain alignment of rows or columns,
but can be more compact and neat looking, especially for sample data
(as opposed to quantile dotplots of theoretical distributions, which
may look better with <code>"bin"</code>, <code>"weave"</code>, or <code>"hex"</code>).
</p>
</li>
<li> <p><code>"bar"</code>: for discrete distributions, lays out duplicate values in
rectangular bars.
</p>
</li></ul>
</dd>
<dt><code>overlaps</code></dt><dd><p>How to handle overlapping dots or bins in the <code>"bin"</code>,
<code>"weave"</code>, and <code>"hex"</code> layouts (dots never overlap in the <code>"swarm"</code> or <code>"bar"</code> layouts).
For the purposes of this argument, dots are only considered to be overlapping
if they would be overlapping when <code>dotsize = 1</code> and <code>stackratio = 1</code>; i.e.
if you set those arguments to other values, overlaps may still occur.
One of: </p>

<ul>
<li> <p><code>"keep"</code>: leave overlapping dots as they are. Dots may overlap
(usually only slightly) in the <code>"bin"</code>, <code>"weave"</code>, and <code>"hex"</code> layouts.
</p>
</li>
<li> <p><code>"nudge"</code>: nudge overlapping dots out of the way. Overlaps are avoided
using a constrained optimization which minimizes the squared distance of
dots to their desired positions, subject to the constraint that adjacent
dots do not overlap.
</p>
</li></ul>
</dd>
<dt><code>smooth</code></dt><dd><p>Smoother to apply to dot positions.
One of:
</p>

<ul>
<li><p> A function that takes a numeric vector of dot positions and returns a
smoothed version of that vector, such as <code>smooth_bounded()</code>,
<code>smooth_unbounded()</code>, smooth_discrete()<code style="white-space: pre;">&#8288;, or &#8288;</code>smooth_bar()'.
</p>
</li>
<li><p> A string indicating what smoother to use, as the suffix to a function
name starting with <code>smooth_</code>; e.g. <code>"none"</code> (the default) applies
<code>smooth_none()</code>, which simply returns the given vector without
applying smoothing.
</p>
</li></ul>

<p>Smoothing is most effective when the smoother is matched to the support of
the distribution; e.g. using <code>smooth_bounded(bounds = ...)</code>.</p>
</dd>
<dt><code>overflow</code></dt><dd><p>How to handle overflow of dots beyond the extent of the geom
when a minimum <code>binwidth</code> (or an exact <code>binwidth</code>) is supplied.
One of:
</p>

<ul>
<li> <p><code>"keep"</code>: Keep the overflow, drawing dots outside the geom bounds.
</p>
</li>
<li> <p><code>"warn"</code>: Keep the overflow, but produce a warning suggesting solutions,
such as setting <code>binwidth = NA</code> or <code>overflow = "compress"</code>.
</p>
</li>
<li> <p><code>"compress"</code>: Compress the layout. Reduces the <code>binwidth</code> to the size necessary
to keep the dots within bounds, then adjusts <code>stackratio</code> and <code>dotsize</code> so that
the apparent dot size is the user-specified minimum <code>binwidth</code> times the
user-specified <code>dotsize</code>.
</p>
</li></ul>

<p>If you find the default layout has dots that are too small, and you are okay
with dots overlapping, consider setting <code>overflow = "compress"</code> and supplying
an exact or minimum dot size using <code>binwidth</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>If <code>TRUE</code>, print out the bin width of the dotplot. Can be useful
if you want to start from an automatically-selected bin width and then adjust it
manually. Bin width is printed both as data units and as normalized parent
coordinates or <code>"npc"</code>s (see <code><a href="grid.html#topic+unit">unit()</a></code>). Note that if you just want to scale the
selected bin width to fit within a desired area, it is probably easier to use
<code>scale</code> than to copy and scale <code>binwidth</code> manually, and if you just want to
provide constraints on the bin width, you can pass a length-2 vector to <code>binwidth</code>.
</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_mcse_dots_+3A_quantiles">quantiles</code></td>
<td>
<p>Setting this to a value other than <code>NA</code>
will produce a quantile dotplot: that is, a dotplot of quantiles from the sample or distribution
(for analytical distributions, the default of <code>NA</code> is taken to mean <code>100</code> quantiles). The value of
<code>quantiles</code> determines the number
of quantiles to plot. See Kay et al. (2016) and Fernandes et al. (2018) for more information on quantile dotplots.</p>
</td></tr>
<tr><td><code id="stat_mcse_dots_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_mcse_dots_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_mcse_dots_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_mcse_dots_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>dots</em> family of stats and geoms are similar to <code><a href="ggplot2.html#topic+geom_dotplot">geom_dotplot()</a></code> but with a number of differences:
</p>

<ul>
<li><p> Dots geoms act like slabs in <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and can be given x positions (or y positions when
in a horizontal orientation).
</p>
</li>
<li><p> Given the available space to lay out dots, the dots geoms will automatically determine how many bins to
use to fit the available space.
</p>
</li>
<li><p> Dots geoms use a dynamic layout algorithm that lays out dots from the center out if the input data are
symmetrical, guaranteeing that symmetrical data results in a symmetrical plot. The layout algorithm also prevents
dots from overlapping each other.
</p>
</li>
<li><p> The shape of the dots in these geoms can be changed using the <code>slab_shape</code> aesthetic (when using the
<code>dotsinterval</code> family) or the <code>shape</code> or <code>slab_shape</code> aesthetic (when using the <code>dots</code> family)
</p>
</li></ul>

<p>Stats and geoms in this family include:
</p>

<ul>
<li> <p><code><a href="#topic+geom_dots">geom_dots()</a></code>: dotplots on raw data. Ensures the dotplot fits within available space by reducing the size
of the dots automatically (may result in very small dots).
</p>
</li>
<li> <p><code><a href="#topic+geom_swarm">geom_swarm()</a></code> and <code><a href="#topic+geom_weave">geom_weave()</a></code>: dotplots on raw data with defaults intended to create &quot;beeswarm&quot; plots.
Used <code>side = "both"</code> by default, and sets the default dot size to the same size as <code><a href="ggplot2.html#topic+geom_point">geom_point()</a></code>
(<code>binwidth = unit(1.5, "mm")</code>), allowing dots to overlap instead of getting very small.
</p>
</li>
<li> <p><code><a href="#topic+stat_dots">stat_dots()</a></code>: dotplots on raw data, <span class="pkg">distributional</span> objects, and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s
</p>
</li>
<li> <p><code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>: dotplot + interval plots on raw data with already-calculated
intervals (rarely useful directly).
</p>
</li>
<li> <p><code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>: dotplot + interval plots on raw data, <span class="pkg">distributional</span> objects,
and <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>s (will calculate intervals for you).
</p>
</li>
<li> <p><code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>: blurry dotplots that allow the standard deviation of a blur applied to
each dot to be specified using the <code>sd</code> aesthetic.
</p>
</li>
<li> <p><code><a href="#topic+stat_mcse_dots">stat_mcse_dots()</a></code>: blurry dotplots of quantiles using the Monte Carlo Standard Error of each quantile.
</p>
</li></ul>

<p><code><a href="#topic+stat_dots">stat_dots()</a></code> and <code><a href="#topic+stat_dotsinterval">stat_dotsinterval()</a></code>, when used with the <code>quantiles</code> argument,
are particularly useful for constructing quantile dotplots, which can be an effective way to communicate uncertainty
using a frequency framing that may be easier for laypeople to understand (Kay et al. 2016, Fernandes et al. 2018).
</p>
<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a blurry MCSE dot geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li>
<li> <p><code>se</code>: For dots, the Monte Carlo Standard Error of the quantile corresponding to each dot.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The dots+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>dots</strong> (aka the <strong>slab</strong>), the
<strong>point</strong>, and the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Dots-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>sd</code>: The standard deviation (in data units) of the blur associated with each dot.
</p>
</li>
<li><p><code>order</code>: The order in which data points are stacked within bins. Can be used to create the effect of
&quot;stacked&quot; dots by ordering dots according to a discrete variable. If omitted (<code>NULL</code>), the
value of the data points themselves are used to determine stacking order. Only applies when
<code>layout</code> is <code>"bin"</code> or <code>"hex"</code>, as the other layout methods fully determine both <em>x</em> and <em>y</em> positions.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li>
<li><p><code>slab_shape</code>: Override for <code>shape</code>: the shape of the dots used to draw the dotplot slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("dotsinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>References</h3>

<p>Kay, M., Kola, T., Hullman, J. R., &amp; Munson, S. A. (2016). When (ish) is My Bus? User-centered Visualizations
of Uncertainty in Everyday, Mobile Predictive Systems. <em>Conference on Human Factors
in Computing Systems - CHI '16</em>, 5092&ndash;5103. <a href="https://doi.org/10.1145/2858036.2858558">doi:10.1145/2858036.2858558</a>.
</p>
<p>Fernandes, M., Walls, L., Munson, S., Hullman, J., &amp; Kay, M. (2018). Uncertainty Displays Using Quantile Dotplots
or CDFs Improve Transit Decision-Making. <em>Conference on Human Factors in Computing Systems - CHI '18</em>.
<a href="https://doi.org/10.1145/3173574.3173718">doi:10.1145/3173574.3173718</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_blur_dots">geom_blur_dots()</a></code> for the geom underlying this stat.
See <code>vignette("dotsinterval")</code> for a variety of examples of use.
</p>
<p>Other dotsinterval stats: 
<code><a href="#topic+stat_dots">stat_dots</a>()</code>,
<code><a href="#topic+stat_dotsinterval">stat_dotsinterval</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

theme_set(theme_ggdist())

set.seed(1234)
data.frame(x = rnorm(1000)) %&gt;%
  ggplot(aes(x = x)) +
  stat_mcse_dots(quantiles = 100, layout = "weave")

</code></pre>

<hr>
<h2 id='stat_pointinterval'>Point + multiple-interval plot (shortcut stat)</h2><span id='topic+stat_pointinterval'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> with <code><a href="#topic+geom_pointinterval">geom_pointinterval()</a></code> for
creating point + multiple-interval plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_slabinterval(
  geom = "pointinterval",
  show_slab = FALSE
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_pointinterval(
  mapping = NULL,
  data = NULL,
  geom = "pointinterval",
  position = "identity",
  ...,
  point_interval = "median_qi",
  .width = c(0.66, 0.95),
  orientation = NA,
  na.rm = FALSE,
  show.legend = c(size = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_pointinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_pointinterval">stat_pointinterval()</a></code> and <code><a href="#topic+geom_pointinterval">geom_pointinterval()</a></code></p>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_pointinterval">geom_pointinterval()</a></code>,
these include:
</p>

<dl>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>fatten_point</code></dt><dd><p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_pointinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a point + multiple-interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_pointinterval">geom_pointinterval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_pointinterval">geom_pointinterval()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval</a>()</code>,
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval</a>()</code>,
<code><a href="#topic+stat_eye">stat_eye</a>()</code>,
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval</a>()</code>,
<code><a href="#topic+stat_halfeye">stat_halfeye</a>()</code>,
<code><a href="#topic+stat_histinterval">stat_histinterval</a>()</code>,
<code><a href="#topic+stat_interval">stat_interval</a>()</code>,
<code><a href="#topic+stat_slab">stat_slab</a>()</code>,
<code><a href="#topic+stat_spike">stat_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c"),
  value = rnorm(1500, mean = c(5, 7, 9), sd = c(1, 1.5, 1))
)
df %&gt;%
  ggplot(aes(x = value, y = group)) +
  stat_pointinterval()

# ON ANALYTICAL DISTRIBUTIONS
dist_df = data.frame(
  group = c("a", "b", "c"),
  mean =  c(  5,   7,   8),
  sd =    c(  1, 1.5,   1)
)
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
dist_df %&gt;%
  ggplot(aes(y = group, xdist = dist_normal(mean, sd))) +
  stat_pointinterval()
</code></pre>

<hr>
<h2 id='stat_ribbon'>Multiple-ribbon plot (shortcut stat)</h2><span id='topic+stat_ribbon'></span>

<h3>Description</h3>

<p>A combination of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> with sensible defaults
for making multiple-ribbon plots. While <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> is intended for use on data
frames that have already been summarized using a <code><a href="#topic+point_interval">point_interval()</a></code> function,
<code><a href="#topic+stat_ribbon">stat_ribbon()</a></code> is intended for use directly on data frames of draws or of
analytical distributions, and will perform the summarization using a <code><a href="#topic+point_interval">point_interval()</a></code>
function.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_lineribbon(
  show_point = FALSE
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ribbon(
  mapping = NULL,
  data = NULL,
  geom = "lineribbon",
  position = "identity",
  ...,
  .width = c(0.5, 0.8, 0.95),
  point_interval = "median_qi",
  orientation = NA,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_ribbon_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_ribbon">stat_ribbon()</a></code> and <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code></p>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code>,
these include:
</p>

<dl>
<dt><code>step</code></dt><dd><p>Should the line/ribbon be drawn as a step function? One of:
</p>

<ul>
<li> <p><code>FALSE</code> (default): do not draw as a step function.
</p>
</li>
<li> <p><code>"mid"</code> (or <code>TRUE</code>): draw steps midway between adjacent x values.
</p>
</li>
<li> <p><code>"hv"</code>: draw horizontal-then-vertical steps.
</p>
</li>
<li> <p><code>"vh"</code>: draw as vertical-then-horizontal steps.
</p>
</li></ul>

<p><code>TRUE</code> is an alias for <code>"mid"</code> because for a step function with ribbons, <code>"mid"</code> is probably what you want
(for the other two step approaches the ribbons at either the very first or very last x value will not be
visible).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? <code>NA</code>,
the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes,
and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_ribbon_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a multiple-ribbon geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The line+ribbon <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their two sub-geometries: the <strong>line</strong> and the <strong>ribbon</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Ribbon-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left edge of the ribbon sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right edge of the ribbon sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower edge of the ribbon sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper edge of the ribbon sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>order</code>: The order in which ribbons are drawn. Ribbons with the smallest mean value of <code>order</code>
are drawn first (i.e., will be drawn below ribbons with larger mean values of <code>order</code>). If
<code>order</code> is not supplied to <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code>, <code>-abs(xmax - xmin)</code> or <code>-abs(ymax - ymax)</code>
(depending on <code>orientation</code>) is used, having the effect of drawing the widest (on average)
ribbons on the bottom. <code><a href="#topic+stat_lineribbon">stat_lineribbon()</a></code> uses <code>order = after_stat(level)</code> by default,
causing the ribbons generated from the largest <code>.width</code> to be drawn on the bottom.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>line</strong> sub-geometry.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>ribbon</strong> sub-geometry.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>line</strong> and <strong>ribbon</strong> sub-geometries.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("lineribbon")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_lineribbon">geom_lineribbon()</a></code> for the geom underlying this stat.
</p>
<p>Other lineribbon stats: 
<code><a href="#topic+stat_lineribbon">stat_lineribbon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(12345)
tibble(
  x = rep(1:10, 100),
  y = rnorm(1000, x)
) %&gt;%
  ggplot(aes(x = x, y = y)) +
  stat_ribbon() +
  scale_fill_brewer()

# ON ANALYTICAL DISTRIBUTIONS
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
tibble(
  x = 1:10,
  sd = seq(1, 3, length.out = 10)
) %&gt;%
  ggplot(aes(x = x, ydist = dist_normal(x, sd))) +
  stat_ribbon() +
  scale_fill_brewer()
</code></pre>

<hr>
<h2 id='stat_slab'>Slab (ridge) plot (shortcut stat)</h2><span id='topic+stat_slab'></span>

<h3>Description</h3>

<p>Shortcut version of <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> with <code><a href="#topic+geom_slab">geom_slab()</a></code> for
creating slab (ridge) plots.
</p>
<p><strong>Roughly equivalent to:</strong>
</p>
<pre>stat_slabinterval(
  aes(size = NULL),
  geom = "slab",
  show_point = FALSE,
  show_interval = FALSE,
  show.legend = NA
)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>stat_slab(
  mapping = NULL,
  data = NULL,
  geom = "slab",
  position = "identity",
  ...,
  p_limits = c(NA, NA),
  density = "bounded",
  adjust = waiver(),
  trim = TRUE,
  expand = FALSE,
  breaks = waiver(),
  align = "none",
  outline_bars = FALSE,
  slab_type = NULL,
  limits = NULL,
  n = 501,
  orientation = NA,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_slab_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_slab">stat_slab()</a></code> and <code><a href="#topic+geom_slab">geom_slab()</a></code></p>
</td></tr>
<tr><td><code id="stat_slab_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_slab">geom_slab()</a></code>,
these include:
</p>

<dl>
<dt><code>normalize</code></dt><dd><p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</dd>
<dt><code>fill_type</code></dt><dd><p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_slab_+3A_p_limits">p_limits</code></td>
<td>
<p>Probability limits (as a vector of size 2) used to determine the lower and upper
limits of <em>theoretical</em> distributions (distributions from <em>samples</em> ignore this parameter and determine
their limits based on the limits of the sample). E.g., if this is <code>c(.001, .999)</code>, then a slab is drawn
for the distribution from the quantile at <code>p = .001</code> to the quantile at <code>p = .999</code>. If the lower
(respectively upper) limit is <code>NA</code>, then the lower (upper) limit will be the minimum (maximum) of the
distribution's support if it is finite, and <code>0.001</code> (<code>0.999</code>) if it is not finite. E.g., if
<code>p_limits</code> is <code>c(NA, NA)</code>, on a gamma distribution the effective value of <code>p_limits</code> would be
<code>c(0, .999)</code> since the gamma distribution is defined on <code style="white-space: pre;">&#8288;(0, Inf)&#8288;</code>; whereas on a normal distribution
it would be equivalent to <code>c(.001, .999)</code> since the normal distribution is defined on <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_density">density</code></td>
<td>
<p>Density estimator for sample data. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>. This format is also compatible with <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>, <code>"unbounded"</code> for <code style="white-space: pre;">&#8288;[density_unbounded()]&#8288;</code>,
or <code>"histogram"</code> for <code><a href="#topic+density_histogram">density_histogram()</a></code>.
Defaults to <code>"bounded"</code>, i.e. <code><a href="#topic+density_bounded">density_bounded()</a></code>, which estimates the bounds from
the data and then uses a bounded density estimator based on the reflection method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_slab_+3A_adjust">adjust</code></td>
<td>
<p>Passed to <code>density</code>: the bandwidth for the density estimator for sample data
is adjusted by multiplying it by this value. See e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code> for more information.
Default (<code>waiver()</code>) defers to the default of the density estimator, which is usually <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_trim">trim</code></td>
<td>
<p>For sample data, should the density estimate be trimmed to the range of the
data? Passed on to the density estimator; see the <code>density</code> parameter. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_expand">expand</code></td>
<td>
<p>For sample data, should the slab be expanded to the limits of the scale? Default <code>FALSE</code>.
Can be length two to control expansion to the lower and upper limit respectively.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_outline_bars">outline_bars</code></td>
<td>
<p>For sample data (if <code>density</code> is <code>"histogram"</code>) and for discrete analytical
distributions (whose slabs are drawn as histograms), determines
if outlines in between the bars are drawn when the <code>slab_color</code> aesthetic is used. If <code>FALSE</code>
(the default), the outline is drawn only along the tops of the bars; if <code>TRUE</code>, outlines in between
bars are also drawn. See <code><a href="#topic+density_histogram">density_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_slab_type">slab_type</code></td>
<td>
<p>(deprecated) The type of slab function to calculate: probability density (or mass) function
(<code>"pdf"</code>), cumulative distribution function (<code>"cdf"</code>), or complementary CDF (<code>"ccdf"</code>). Instead of using
<code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an aesthetic, it is now recommended to simply map the
corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or  <code>1 - cdf</code>) directly onto the desired aesthetic.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_limits">limits</code></td>
<td>
<p>Manually-specified limits for the slab, as a vector of length two. These limits are combined with those
computed based on <code>p_limits</code> as well as the limits defined by the scales of the plot to determine the
limits used to draw the slab functions: these limits specify the maximal limits; i.e., if specified, the limits
will not be wider than these (but may be narrower). Use <code>NA</code> to leave a limit alone; e.g.
<code>limits = c(0, NA)</code> will ensure that the lower limit does not go below 0, but let the upper limit
be determined by either <code>p_limits</code> or the scale settings.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate the function that defines the slab.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_slab_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a slab (ridge) geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_slab">geom_slab()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_slab">geom_slab()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval</a>()</code>,
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval</a>()</code>,
<code><a href="#topic+stat_eye">stat_eye</a>()</code>,
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval</a>()</code>,
<code><a href="#topic+stat_halfeye">stat_halfeye</a>()</code>,
<code><a href="#topic+stat_histinterval">stat_histinterval</a>()</code>,
<code><a href="#topic+stat_interval">stat_interval</a>()</code>,
<code><a href="#topic+stat_pointinterval">stat_pointinterval</a>()</code>,
<code><a href="#topic+stat_spike">stat_spike</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())

# ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c"),
  value = rnorm(1500, mean = c(5, 7, 9), sd = c(1, 1.5, 1))
)
df %&gt;%
  ggplot(aes(x = value, y = group)) +
  stat_slab()

# ON ANALYTICAL DISTRIBUTIONS
dist_df = data.frame(
  group = c("a", "b", "c"),
  mean =  c(  5,   7,   8),
  sd =    c(  1, 1.5,   1)
)
# Vectorized distribution types, like distributional::dist_normal()
# and posterior::rvar(), can be used with the `xdist` / `ydist` aesthetics
dist_df %&gt;%
  ggplot(aes(y = group, xdist = dist_normal(mean, sd))) +
  stat_slab()

# RIDGE PLOTS
# "ridge" plots can be created by expanding the slabs to the limits of the plot
# (expand = TRUE), allowing the density estimator to be nonzero outside the
# limits of the data (trim = FALSE), and increasing the height of the slabs.
data.frame(
  group = letters[1:3],
  value = rnorm(3000, 3:1)
) %&gt;%
  ggplot(aes(y = group, x = value)) +
  stat_slab(color = "black", expand = TRUE, trim = FALSE, height = 2)
</code></pre>

<hr>
<h2 id='stat_slabinterval'>Slab + interval plots for sample data and analytical distributions (ggplot stat)</h2><span id='topic+stat_slabinterval'></span>

<h3>Description</h3>

<p>&quot;Meta&quot; stat for computing distribution functions (densities or CDFs) + intervals for use with
<code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>. Useful for creating eye plots, half-eye plots, CCDF bar plots,
gradient plots, histograms, and more. Sample data can be supplied to the <code>x</code> and <code>y</code>
aesthetics or analytical distributions (in a variety of formats) can be supplied to the
<code>xdist</code> and <code>ydist</code> aesthetics.
See <strong>Details</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_slabinterval(
  mapping = NULL,
  data = NULL,
  geom = "slabinterval",
  position = "identity",
  ...,
  p_limits = c(NA, NA),
  density = "bounded",
  adjust = waiver(),
  trim = TRUE,
  expand = FALSE,
  breaks = waiver(),
  align = "none",
  outline_bars = FALSE,
  point_interval = "median_qi",
  slab_type = NULL,
  limits = NULL,
  n = 501,
  .width = c(0.66, 0.95),
  orientation = NA,
  na.rm = FALSE,
  show.legend = c(size = FALSE),
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_slabinterval_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between
<code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> and <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code></p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>,
these include:
</p>

<dl>
<dt><code>normalize</code></dt><dd><p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</dd>
<dt><code>fill_type</code></dt><dd><p>What type of fill to use when the fill color or alpha varies within a slab. One of:
</p>

<ul>
<li> <p><code>"segments"</code>: breaks up the slab geometry into segments for each unique combination of fill color and
alpha value. This approach is supported by all graphics devices and works well for sharp cutoff values,
but can give ugly results if a large number of unique fill colors are being used (as in gradients,
like in <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>).
</p>
</li>
<li> <p><code>"gradient"</code>: a <code>grid::linearGradient()</code> is used to create a smooth gradient fill. This works well for
large numbers of unique fill colors, but requires R &gt;= 4.1 and is not yet supported on all graphics devices.
As of this writing, the <code>png()</code> graphics device with <code>type = "cairo"</code>, the <code>svg()</code> device, the <code>pdf()</code>
device, and the <code>ragg::agg_png()</code> devices are known to support this option. On R &lt; 4.1, this option
will fall back to <code>fill_type = "segments"</code> with a message.
</p>
</li>
<li> <p><code>"auto"</code>: attempts to use <code>fill_type = "gradient"</code> if support for it can be auto-detected. On R &gt;= 4.2,
support for gradients can be auto-detected on some graphics devices; if support is not detected, this
option will fall back to <code>fill_type = "segments"</code> (in case of a false negative, <code>fill_type = "gradient"</code>
can be set explicitly). On R &lt; 4.2, support for gradients cannot be auto-detected, so this will always
fall back to <code>fill_type = "segments"</code>, in which case you can set <code>fill_type = "gradient"</code> explicitly
if you are using a graphics device that support gradients.
</p>
</li></ul>
</dd>
<dt><code>interval_size_domain</code></dt><dd><p>A length-2 numeric vector giving the minimum and maximum of the values of the <code>size</code> and <code>linewidth</code> aesthetics
that will be translated into actual sizes for intervals drawn according to <code>interval_size_range</code> (see the
documentation for that argument.)</p>
</dd>
<dt><code>interval_size_range</code></dt><dd><p>A length-2 numeric vector. This geom scales the raw size aesthetic values when drawing interval and point
sizes, as they tend to be too thick when using the default settings of <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>, which give
sizes with a range of <code>c(1, 6)</code>. The <code>interval_size_domain</code> value indicates the input domain of raw size
values (typically this should be equal to the value of the <code>range</code> argument of the <code><a href="ggplot2.html#topic+scale_size_continuous">scale_size_continuous()</a></code>
function), and <code>interval_size_range</code> indicates the desired output range of the size values (the min and max of
the actual sizes used to draw intervals). Most of the time it is not recommended to change the value of this
argument, as it may result in strange scaling of legends; this argument is a holdover from earlier versions
that did not have size aesthetics targeting the point and interval separately. If you want to adjust the
size of the interval or points separately, you can also use the <code>linewidth</code> or <code>point_size</code>
aesthetics; see <a href="#topic+sub-geometry-scales">sub-geometry-scales</a>.</p>
</dd>
<dt><code>fatten_point</code></dt><dd><p>A multiplicative factor used to adjust the size of the point relative to the size of the
thickest interval line. If you wish to specify point sizes directly, you can also use the <code>point_size</code>
aesthetic and <code><a href="#topic+scale_point_size_continuous">scale_point_size_continuous()</a></code> or <code><a href="#topic+scale_point_size_discrete">scale_point_size_discrete()</a></code>; sizes
specified with that aesthetic will not be adjusted using <code>fatten_point</code>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the interval, or <code>NULL</code> for no arrows.</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_p_limits">p_limits</code></td>
<td>
<p>Probability limits (as a vector of size 2) used to determine the lower and upper
limits of <em>theoretical</em> distributions (distributions from <em>samples</em> ignore this parameter and determine
their limits based on the limits of the sample). E.g., if this is <code>c(.001, .999)</code>, then a slab is drawn
for the distribution from the quantile at <code>p = .001</code> to the quantile at <code>p = .999</code>. If the lower
(respectively upper) limit is <code>NA</code>, then the lower (upper) limit will be the minimum (maximum) of the
distribution's support if it is finite, and <code>0.001</code> (<code>0.999</code>) if it is not finite. E.g., if
<code>p_limits</code> is <code>c(NA, NA)</code>, on a gamma distribution the effective value of <code>p_limits</code> would be
<code>c(0, .999)</code> since the gamma distribution is defined on <code style="white-space: pre;">&#8288;(0, Inf)&#8288;</code>; whereas on a normal distribution
it would be equivalent to <code>c(.001, .999)</code> since the normal distribution is defined on <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_density">density</code></td>
<td>
<p>Density estimator for sample data. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>. This format is also compatible with <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>, <code>"unbounded"</code> for <code style="white-space: pre;">&#8288;[density_unbounded()]&#8288;</code>,
or <code>"histogram"</code> for <code><a href="#topic+density_histogram">density_histogram()</a></code>.
Defaults to <code>"bounded"</code>, i.e. <code><a href="#topic+density_bounded">density_bounded()</a></code>, which estimates the bounds from
the data and then uses a bounded density estimator based on the reflection method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_adjust">adjust</code></td>
<td>
<p>Passed to <code>density</code>: the bandwidth for the density estimator for sample data
is adjusted by multiplying it by this value. See e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code> for more information.
Default (<code>waiver()</code>) defers to the default of the density estimator, which is usually <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_trim">trim</code></td>
<td>
<p>For sample data, should the density estimate be trimmed to the range of the
data? Passed on to the density estimator; see the <code>density</code> parameter. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_expand">expand</code></td>
<td>
<p>For sample data, should the slab be expanded to the limits of the scale? Default <code>FALSE</code>.
Can be length two to control expansion to the lower and upper limit respectively.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_outline_bars">outline_bars</code></td>
<td>
<p>For sample data (if <code>density</code> is <code>"histogram"</code>) and for discrete analytical
distributions (whose slabs are drawn as histograms), determines
if outlines in between the bars are drawn when the <code>slab_color</code> aesthetic is used. If <code>FALSE</code>
(the default), the outline is drawn only along the tops of the bars; if <code>TRUE</code>, outlines in between
bars are also drawn. See <code><a href="#topic+density_histogram">density_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_point_interval">point_interval</code></td>
<td>
<p>A function from the <code><a href="#topic+point_interval">point_interval()</a></code> family (e.g., <code>median_qi</code>,
<code>mean_qi</code>, <code>mode_hdi</code>, etc), or a string giving the name of a function from that family
(e.g., <code>"median_qi"</code>, <code>"mean_qi"</code>, <code>"mode_hdi"</code>, etc; if a string, the caller's environment is searched
for the function, followed by the <span class="pkg">ggdist</span> environment). This function determines the point summary
(typically mean, median, or mode) and interval type (quantile interval, <code>qi</code>;
highest-density interval, <code>hdi</code>; or highest-density continuous interval, <code>hdci</code>). Output will
be converted to the appropriate <code>x</code>- or <code>y</code>-based aesthetics depending on the value of <code>orientation</code>.
See the <code><a href="#topic+point_interval">point_interval()</a></code> family of functions for more information.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_slab_type">slab_type</code></td>
<td>
<p>(deprecated) The type of slab function to calculate: probability density (or mass) function
(<code>"pdf"</code>), cumulative distribution function (<code>"cdf"</code>), or complementary CDF (<code>"ccdf"</code>). Instead of using
<code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an aesthetic, it is now recommended to simply map the
corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or  <code>1 - cdf</code>) directly onto the desired aesthetic.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_limits">limits</code></td>
<td>
<p>Manually-specified limits for the slab, as a vector of length two. These limits are combined with those
computed based on <code>p_limits</code> as well as the limits defined by the scales of the plot to determine the
limits used to draw the slab functions: these limits specify the maximal limits; i.e., if specified, the limits
will not be wider than these (but may be narrower). Use <code>NA</code> to leave a limit alone; e.g.
<code>limits = c(0, NA)</code> will ensure that the lower limit does not go below 0, but let the upper limit
be determined by either <code>p_limits</code> or the scale settings.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate the function that defines the slab.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_.width">.width</code></td>
<td>
<p>The <code>.width</code> argument passed to <code>point_interval</code>: a vector of probabilities to use
that determine the widths of the resulting intervals. If multiple probabilities are provided,
multiple intervals per group are generated, each with a different probability interval (and
value of the corresponding <code>.width</code> and <code>level</code> generated variables).</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_slabinterval_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A highly configurable stat for generating a variety of plots that combine a &quot;slab&quot;
that describes a distribution plus a point summary and any number of intervals.
Several &quot;shortcut&quot; stats are provided
which combine multiple options to create useful geoms, particularly <em>eye plots</em>
(a violin plot of density plus interval), <em>half-eye plots</em> (a density plot plus interval),
<em>CCDF bar plots</em> (a complementary CDF plus interval), and <em>gradient plots</em>
(a density encoded in color alpha plus interval).
</p>
<p>The shortcut stats include:
</p>

<ul>
<li> <p><code><a href="#topic+stat_eye">stat_eye()</a></code>: Eye plots (violin + interval)
</p>
</li>
<li> <p><code><a href="#topic+stat_halfeye">stat_halfeye()</a></code>: Half-eye plots (density + interval)
</p>
</li>
<li> <p><code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval()</a></code>: CCDF bar plots (CCDF + interval)
</p>
</li>
<li> <p><code><a href="#topic+stat_cdfinterval">stat_cdfinterval()</a></code>: CDF bar plots (CDF + interval)
</p>
</li>
<li> <p><code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>: Density gradient + interval plots
</p>
</li>
<li> <p><code><a href="#topic+stat_slab">stat_slab()</a></code>: Density plots
</p>
</li>
<li> <p><code><a href="#topic+stat_histinterval">stat_histinterval()</a></code>: Histogram + interval plots
</p>
</li>
<li> <p><code><a href="#topic+stat_pointinterval">stat_pointinterval()</a></code>: Point + interval plots
</p>
</li>
<li> <p><code><a href="#topic+stat_interval">stat_interval()</a></code>: Interval plots
</p>
</li></ul>

<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a slab or combined slab+interval geometry which can
be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li></ul>



<h3>Aesthetics</h3>

<p>The slab+interval <code>stat</code>s and <code>geom</code>s have a wide variety of aesthetics that control
the appearance of their three sub-geometries: the <strong>slab</strong>, the <strong>point</strong>, and
the <strong>interval</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Slab-specific aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li>
<li><p><code>justification</code>: Justification of the interval relative to the slab, where <code>0</code> indicates bottom/left
justification and <code>1</code> indicates top/right justification (depending on <code>orientation</code>). If <code>justification</code>
is <code>NULL</code> (the default), then it is set automatically based on the value of <code>side</code>: when <code>side</code> is
<code>"top"</code>/<code>"right"</code> <code>justification</code> is set to <code>0</code>, when <code>side</code> is <code>"bottom"</code>/<code>"left"</code>
<code>justification</code> is set to <code>1</code>, and when <code>side</code> is <code>"both"</code> <code>justification</code> is set to 0.5.
</p>
</li>
<li><p><code>datatype</code>: When using composite geoms directly without a <code>stat</code> (e.g. <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>), <code>datatype</code> is used to
indicate which part of the geom a row in the data targets: rows with <code>datatype = "slab"</code> target the
slab portion of the geometry and rows with <code>datatype = "interval"</code> target the interval portion of
the geometry. This is set automatically when using ggdist <code>stat</code>s.
</p>
</li></ul>

<p><strong>Interval-specific aesthetics</strong>
</p>

<ul>
<li><p><code>xmin</code>: Left end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>xmax</code>: Right end of the interval sub-geometry (if <code>orientation = "horizontal"</code>).
</p>
</li>
<li><p><code>ymin</code>: Lower end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li>
<li><p><code>ymax</code>: Upper end of the interval sub-geometry (if <code>orientation = "vertical"</code>).
</p>
</li></ul>

<p><strong>Point-specific aesthetics</strong>
</p>

<ul>
<li><p><code>shape</code>: Shape type used to draw the <strong>point</strong> sub-geometry.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>interval</strong> and <strong>point</strong> sub-geometries.
Use the <code>slab_color</code>, <code>interval_color</code>, or <code>point_color</code> aesthetics (below) to
set sub-geometry colors separately.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>slab</strong> and <strong>point</strong> sub-geometries. Use the <code>slab_fill</code>
or <code>point_fill</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>slab</strong>, <strong>interval</strong>, and <strong>point</strong> sub-geometries. Use the <code>slab_alpha</code>,
<code>interval_alpha</code>, or <code>point_alpha</code> aesthetics (below) to set sub-geometry colors separately.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>interval</strong> (except with <code><a href="#topic+geom_slab">geom_slab()</a></code>: then
it is the width of the <strong>slab</strong>). With composite geometries including an interval and slab,
use <code>slab_linewidth</code> to set the line width of the <strong>slab</strong> (see below). For <strong>interval</strong>, raw
<code>linewidth</code> values are transformed according to the <code>interval_size_domain</code> and <code>interval_size_range</code>
parameters of the <code>geom</code> (see above).
</p>
</li>
<li><p><code>size</code>: Determines the size of the <strong>point</strong>. If <code>linewidth</code> is not provided, <code>size</code> will
also determines the width of the line used to draw the <strong>interval</strong> (this allows line width and
point size to be modified together by setting only <code>size</code> and not <code>linewidth</code>). Raw
<code>size</code> values are transformed according to the <code>interval_size_domain</code>, <code>interval_size_range</code>,
and <code>fatten_point</code> parameters of the <code>geom</code> (see above). Use the <code>point_size</code> aesthetic
(below) to set sub-geometry size directly without applying the effects of
<code>interval_size_domain</code>, <code>interval_size_range</code>, and <code>fatten_point</code>.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>interval</strong>
and the outline of the <strong>slab</strong> (if it is visible). Use the <code>slab_linetype</code> or
<code>interval_linetype</code> aesthetics (below) to set sub-geometry line types separately.
</p>
</li></ul>

<p><strong>Slab-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>slab_fill</code>: Override for <code>fill</code>: the fill color of the slab.
</p>
</li>
<li><p><code>slab_colour</code>: (or <code>slab_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the slab.
</p>
</li>
<li><p><code>slab_alpha</code>: Override for <code>alpha</code>: the opacity of the slab.
</p>
</li>
<li><p><code>slab_linewidth</code>: Override for <code>linwidth</code>: the width of the outline of the slab.
</p>
</li>
<li><p><code>slab_linetype</code>: Override for <code>linetype</code>: the line type of the outline of the slab.
</p>
</li></ul>

<p><strong>Interval-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>interval_colour</code>: (or <code>interval_color</code>) Override for <code>colour</code>/<code>color</code>: the color of the interval.
</p>
</li>
<li><p><code>interval_alpha</code>: Override for <code>alpha</code>: the opacity of the interval.
</p>
</li>
<li><p><code>interval_linetype</code>: Override for <code>linetype</code>: the line type of the interval.
</p>
</li></ul>

<p><strong>Point-specific color and line override aesthetics</strong>
</p>

<ul>
<li><p><code>point_fill</code>: Override for <code>fill</code>: the fill color of the point.
</p>
</li>
<li><p><code>point_colour</code>: (or <code>point_color</code>) Override for <code>colour</code>/<code>color</code>: the outline color of the point.
</p>
</li>
<li><p><code>point_alpha</code>: Override for <code>alpha</code>: the opacity of the point.
</p>
</li>
<li><p><code>point_size</code>: Override for <code>size</code>: the size of the point.
</p>
</li></ul>

<p><strong>Deprecated aesthetics</strong>
</p>

<ul>
<li><p><code>slab_size</code>: Use <code>slab_linewidth</code>.
</p>
</li>
<li><p><code>interval_size</code>: Use <code>interval_linewidth</code>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> for more information on the geom these stats
use by default and some of the options it has.
See <code>vignette("slabinterval")</code> for a variety of examples of use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)
library(distributional)

theme_set(theme_ggdist())


# EXAMPLES ON SAMPLE DATA
set.seed(1234)
df = data.frame(
  group = c("a", "b", "c", "c", "c"),
  value = rnorm(2500, mean = c(5, 7, 9, 9, 9), sd = c(1, 1.5, 1, 1, 1))
)

# here are vertical eyes:
df %&gt;%
  ggplot(aes(x = group, y = value)) +
  stat_eye()

# note the sample size is not automatically incorporated into the
# area of the densities in case one wishes to plot densities against
# a reference (e.g. a prior distribution).
# But you may wish to account for sample size if using these geoms
# for something other than visualizing posteriors; in which case
# you can use after_stat(f*n):
df %&gt;%
  ggplot(aes(x = group, y = value)) +
  stat_eye(aes(thickness = after_stat(pdf*n)))


# EXAMPLES ON ANALYTICAL DISTRIBUTIONS

dist_df = tribble(
  ~group, ~subgroup, ~mean, ~sd,
  "a",          "h",     5,   1,
  "b",          "h",     7,   1.5,
  "c",          "h",     8,   1,
  "c",          "i",     9,   1,
  "c",          "j",     7,   1
)

# Using functions from the distributional package (like dist_normal()) with the
# dist aesthetic can lead to more compact/expressive specifications

dist_df %&gt;%
  ggplot(aes(x = group, ydist = dist_normal(mean, sd), fill = subgroup)) +
  stat_eye(position = "dodge")

# using the old character vector + args approach
dist_df %&gt;%
  ggplot(aes(x = group, dist = "norm", arg1 = mean, arg2 = sd, fill = subgroup)) +
  stat_eye(position = "dodge")

# the stat_slabinterval family applies a Jacobian adjustment to densities
# when plotting on transformed scales in order to plot them correctly.
# It determines the Jacobian using symbolic differentiation if possible,
# using stats::D(). If symbolic differentation fails, it falls back
# to numericDeriv(), which is less reliable; therefore, it is
# advisable to use scale transformation functions that are defined in
# terms of basic math functions so that their derivatives can be
# determined analytically (most of the transformation functions in the
# scales package currently have this property).
# For example, here is a log-Normal distribution plotted on the log
# scale, where it will appear Normal:
data.frame(dist = "lnorm", logmean = log(10), logsd = 2*log(10)) %&gt;%
  ggplot(aes(y = 1, dist = dist, arg1 = logmean, arg2 = logsd)) +
  stat_halfeye() +
  scale_x_log10(breaks = 10^seq(-5,7, by = 2))

# see vignette("slabinterval") for many more examples.

</code></pre>

<hr>
<h2 id='stat_spike'>Spike plot (ggplot2 stat)</h2><span id='topic+stat_spike'></span>

<h3>Description</h3>

<p>Stat for drawing &quot;spikes&quot; (optionally with points on them) at specific points
on a distribution (numerical or determined as a function of the distribution),
intended for annotating <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_spike(
  mapping = NULL,
  data = NULL,
  geom = "spike",
  position = "identity",
  ...,
  at = "median",
  p_limits = c(NA, NA),
  density = "bounded",
  adjust = waiver(),
  trim = TRUE,
  expand = FALSE,
  breaks = waiver(),
  align = "none",
  outline_bars = FALSE,
  slab_type = NULL,
  limits = NULL,
  n = 501,
  orientation = NA,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_spike_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_geom">geom</code></td>
<td>
<p>Use to override the default connection between <code><a href="#topic+stat_spike">stat_spike()</a></code> and <code><a href="#topic+geom_spike">geom_spike()</a></code></p>
</td></tr>
<tr><td><code id="stat_spike_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to a position adjustment function.
Setting this equal to <code>"dodge"</code> (<code><a href="ggplot2.html#topic+position_dodge">position_dodge()</a></code>) or <code>"dodgejust"</code> (<code><a href="#topic+position_dodgejust">position_dodgejust()</a></code>) can be useful if
you have overlapping geometries.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are often aesthetics, used to set an aesthetic
to a fixed value, like <code>colour = "red"</code> or <code>linewidth = 3</code> (see <strong>Aesthetics</strong>, below). They may also be
parameters to the paired geom/stat. When paired with the default geom, <code><a href="#topic+geom_spike">geom_spike()</a></code>,
these include:
</p>

<dl>
<dt><code>normalize</code></dt><dd><p>How to normalize heights of functions input to the <code>thickness</code> aesthetic. One of:
</p>

<ul>
<li> <p><code>"all"</code>: normalize so that the maximum height across all data is <code>1</code>.
</p>
</li>
<li> <p><code>"panels"</code>: normalize within panels so that the maximum height in each panel is <code>1</code>.
</p>
</li>
<li> <p><code>"xy"</code>: normalize within the x/y axis opposite the <code>orientation</code> of this geom so
that the maximum height at each value of the opposite axis is <code>1</code>.
</p>
</li>
<li> <p><code>"groups"</code>: normalize within values of the opposite axis and within each
group so that the maximum height in each group is <code>1</code>.
</p>
</li>
<li> <p><code>"none"</code>: values are taken as is with no normalization (this should probably
only be used with functions whose values are in [0,1], such as CDFs).
</p>
</li></ul>

<p>For a comprehensive discussion and examples of slab scaling and normalization, see the
<a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.</p>
</dd>
<dt><code>arrow</code></dt><dd><p><code><a href="grid.html#topic+arrow">grid::arrow()</a></code> giving the arrow heads to use on the spike, or <code>NULL</code> for no arrows.</p>
</dd>
<dt><code>subguide</code></dt><dd><p>Sub-guide used to annotate the <code>thickness</code> scale. One of:
</p>

<ul>
<li><p> A function that takes a <code>scale</code> argument giving a <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a>
object and an <code>orientation</code> argument giving the orientation of the
geometry and then returns a <a href="grid.html#topic+grid.grob">grid::grob</a> that will draw the axis
annotation, such as <code><a href="#topic+subguide_axis">subguide_axis()</a></code> (to draw a traditional axis) or
<code><a href="#topic+subguide_none">subguide_none()</a></code> (to draw no annotation). See <code><a href="#topic+subguide_axis">subguide_axis()</a></code>
for a list of possibilities and examples.
</p>
</li>
<li><p> A string giving the name of such a function when prefixed
with <code>"subguide"</code>; e.g. <code>"axis"</code> or <code>"none"</code>.
</p>
</li></ul>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_spike_+3A_at">at</code></td>
<td>
<p>The points at which to evaluate the PDF and CDF of the distribution. One of:
</p>

<ul>
<li> <p><a href="base.html#topic+numeric">numeric</a> vector: points to evaluate the PDF and CDF of the distributions at.
</p>
</li>
<li><p> function or character vector: function (or names of functions) which,
when applied on a distribution-like object (e.g. a <span class="pkg">distributional</span> object or a
<code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code>), returns a vector of values to evaluate the distribution functions at.
</p>
</li>
<li><p> a <a href="base.html#topic+list">list</a> where each element is any of the above (e.g. a <a href="base.html#topic+numeric">numeric</a>, function, or
name of a function): the evaluation points determined by each element of the
list are concatenated together. This means, e.g., <code>c(0, median, qi)</code> would add
a spike at <code>0</code>, the median, and the endpoints of the <code>qi</code> of the distribution.
</p>
</li></ul>

<p>The values of <code>at</code> are also converted into a character vector which is supplied
as a computed variable (also called <code>at</code>) generated by this <code>stat</code>, which can be
mapped onto aesthetics using <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>. Non-empty names can be used to override
the values of the computed variable; e.g. <code>at = c(zero = 0, "median", mode = "Mode")</code>
will generate a computed variable with the values <code>c("zero", "median", "mode")</code> that
is evaluated at <code>0</code>, the median, and the mode of the distribution.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_p_limits">p_limits</code></td>
<td>
<p>Probability limits (as a vector of size 2) used to determine the lower and upper
limits of <em>theoretical</em> distributions (distributions from <em>samples</em> ignore this parameter and determine
their limits based on the limits of the sample). E.g., if this is <code>c(.001, .999)</code>, then a slab is drawn
for the distribution from the quantile at <code>p = .001</code> to the quantile at <code>p = .999</code>. If the lower
(respectively upper) limit is <code>NA</code>, then the lower (upper) limit will be the minimum (maximum) of the
distribution's support if it is finite, and <code>0.001</code> (<code>0.999</code>) if it is not finite. E.g., if
<code>p_limits</code> is <code>c(NA, NA)</code>, on a gamma distribution the effective value of <code>p_limits</code> would be
<code>c(0, .999)</code> since the gamma distribution is defined on <code style="white-space: pre;">&#8288;(0, Inf)&#8288;</code>; whereas on a normal distribution
it would be equivalent to <code>c(.001, .999)</code> since the normal distribution is defined on <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_density">density</code></td>
<td>
<p>Density estimator for sample data. One of:
</p>

<ul>
<li><p> A function which takes a numeric vector and returns a list with elements
<code>x</code> (giving grid points for the density estimator) and <code>y</code> (the
corresponding densities). <span class="pkg">ggdist</span> provides a family of functions
following this format, including <code><a href="#topic+density_unbounded">density_unbounded()</a></code> and
<code><a href="#topic+density_bounded">density_bounded()</a></code>. This format is also compatible with <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li><p> A string giving the suffix of a function name that starts with <code>"density_"</code>;
e.g. <code>"bounded"</code> for <code style="white-space: pre;">&#8288;[density_bounded()]&#8288;</code>, <code>"unbounded"</code> for <code style="white-space: pre;">&#8288;[density_unbounded()]&#8288;</code>,
or <code>"histogram"</code> for <code><a href="#topic+density_histogram">density_histogram()</a></code>.
Defaults to <code>"bounded"</code>, i.e. <code><a href="#topic+density_bounded">density_bounded()</a></code>, which estimates the bounds from
the data and then uses a bounded density estimator based on the reflection method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_spike_+3A_adjust">adjust</code></td>
<td>
<p>Passed to <code>density</code>: the bandwidth for the density estimator for sample data
is adjusted by multiplying it by this value. See e.g. <code><a href="#topic+density_bounded">density_bounded()</a></code> for more information.
Default (<code>waiver()</code>) defers to the default of the density estimator, which is usually <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_trim">trim</code></td>
<td>
<p>For sample data, should the density estimate be trimmed to the range of the
data? Passed on to the density estimator; see the <code>density</code> parameter. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_expand">expand</code></td>
<td>
<p>For sample data, should the slab be expanded to the limits of the scale? Default <code>FALSE</code>.
Can be length two to control expansion to the lower and upper limit respectively.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_breaks">breaks</code></td>
<td>
<p>Determines the breakpoints defining bins. Defaults to <code>"Scott"</code>.
Similar to (but not exactly the same as) the <code>breaks</code> argument to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>.
One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving the number of bins
</p>
</li>
<li><p> A vector numeric giving the breakpoints between histogram bins
</p>
</li>
<li><p> A function taking <code>x</code> and <code>weights</code> and returning either the
number of bins or a vector of breakpoints
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"breaks_"</code>. <span class="pkg">ggdist</span> provides weighted implementations of the
<code>"Sturges"</code>, <code>"Scott"</code>, and <code>"FD"</code> break-finding algorithms from
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, as well as <code><a href="#topic+breaks_fixed">breaks_fixed()</a></code> for manually setting
the bin width. See <a href="#topic+breaks">breaks</a>.
</p>
</li></ul>

<p>For example, <code>breaks = "Sturges"</code> will use the <code><a href="#topic+breaks_Sturges">breaks_Sturges()</a></code> algorithm,
<code>breaks = 9</code> will create 9 bins, and <code>breaks = breaks_fixed(width = 1)</code> will
set the bin width to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_align">align</code></td>
<td>
<p>Determines how to align the breakpoints defining bins. Default
(<code>"none"</code>) performs no alignment. One of:
</p>

<ul>
<li><p> A scalar (length-1) numeric giving an offset that is subtracted from the breaks.
The offset must be between <code>0</code> and the bin width.
</p>
</li>
<li><p> A function taking a sorted vector of <code>breaks</code> (bin edges) and returning
an offset to subtract from the breaks.
</p>
</li>
<li><p> A string giving the suffix of a function that starts with
<code>"align_"</code> used to determine the alignment, such as <code><a href="#topic+align_none">align_none()</a></code>,
<code><a href="#topic+align_boundary">align_boundary()</a></code>, or <code><a href="#topic+align_center">align_center()</a></code>.
</p>
</li></ul>

<p>For example, <code>align = "none"</code> will provide no alignment, <code>align = align_center(at = 0)</code>
will center a bin on <code>0</code>, and <code>align = align_boundary(at = 0)</code> will align a bin
edge on <code>0</code>.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_outline_bars">outline_bars</code></td>
<td>
<p>For sample data (if <code>density</code> is <code>"histogram"</code>) and for discrete analytical
distributions (whose slabs are drawn as histograms), determines
if outlines in between the bars are drawn when the <code>slab_color</code> aesthetic is used. If <code>FALSE</code>
(the default), the outline is drawn only along the tops of the bars; if <code>TRUE</code>, outlines in between
bars are also drawn. See <code><a href="#topic+density_histogram">density_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_slab_type">slab_type</code></td>
<td>
<p>(deprecated) The type of slab function to calculate: probability density (or mass) function
(<code>"pdf"</code>), cumulative distribution function (<code>"cdf"</code>), or complementary CDF (<code>"ccdf"</code>). Instead of using
<code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an aesthetic, it is now recommended to simply map the
corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or  <code>1 - cdf</code>) directly onto the desired aesthetic.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_limits">limits</code></td>
<td>
<p>Manually-specified limits for the slab, as a vector of length two. These limits are combined with those
computed based on <code>p_limits</code> as well as the limits defined by the scales of the plot to determine the
limits used to draw the slab functions: these limits specify the maximal limits; i.e., if specified, the limits
will not be wider than these (but may be narrower). Use <code>NA</code> to leave a limit alone; e.g.
<code>limits = c(0, NA)</code> will ensure that the lower limit does not go below 0, but let the upper limit
be determined by either <code>p_limits</code> or the scale settings.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate the function that defines the slab.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_orientation">orientation</code></td>
<td>
<p>Whether this geom is drawn horizontally or vertically. One of:
</p>

<ul>
<li> <p><code>NA</code> (default): automatically detect the orientation based on how the aesthetics
are assigned. Automatic detection works most of the time.
</p>
</li>
<li> <p><code>"horizontal"</code> (or <code>"y"</code>): draw horizontally, using the <code>y</code> aesthetic to identify different
groups. For each group, uses the <code>x</code>, <code>xmin</code>, <code>xmax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li>
<li> <p><code>"vertical"</code> (or <code>"x"</code>): draw vertically, using the <code>x</code> aesthetic to identify different
groups. For each group, uses the <code>y</code>, <code>ymin</code>, <code>ymax</code>, and <code>thickness</code> aesthetics to
draw points, intervals, and slabs.
</p>
</li></ul>

<p>For compatibility with the base ggplot naming scheme for <code>orientation</code>, <code>"x"</code> can be used as an alias
for <code>"vertical"</code> and <code>"y"</code> as an alias for <code>"horizontal"</code> (<span class="pkg">ggdist</span> had an <code>orientation</code> parameter
before base ggplot did, hence the discrepancy).</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing
values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_show.legend">show.legend</code></td>
<td>
<p>Should this layer be included in the legends? Default is <code>c(size = FALSE)</code>, unlike most geoms,
to match its common use cases. <code>FALSE</code> hides all legends, <code>TRUE</code> shows all legends, and <code>NA</code> shows only
those that are mapped (the default for most geoms).</p>
</td></tr>
<tr><td><code id="stat_spike_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This stat computes slab values (i.e. PDF and CDF values) at specified locations
on a distribution, as determined by the <code>at</code> parameter.
</p>
<p><strong>To visualize sample data</strong>, such as a data distribution, samples from a
bootstrap distribution, or a Bayesian posterior, you can supply samples to
the <code>x</code> or <code>y</code> aesthetic.
</p>
<p><strong>To visualize analytical distributions</strong>, you can use the <code>xdist</code> or <code>ydist</code>
aesthetic. For historical reasons, you can also use <code>dist</code> to specify the distribution, though
this is not recommended as it does not work as well with orientation detection.
These aesthetics can be used as follows:
</p>

<ul>
<li> <p><code>xdist</code>, <code>ydist</code>, and <code>dist</code> can be any distribution object from the <a href="https://pkg.mitchelloharawild.com/distributional/">distributional</a>
package (<code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>, <code><a href="distributional.html#topic+dist_beta">dist_beta()</a></code>, etc) or can be a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
Since these functions are vectorized,
other columns can be passed directly to them in an <code><a href="ggplot2.html#topic+aes">aes()</a></code> specification; e.g.
<code>aes(dist = dist_normal(mu, sigma))</code> will work if <code>mu</code> and <code>sigma</code> are columns in the
input data frame.
</p>
</li>
<li> <p><code>dist</code> can be a character vector giving the distribution name. Then the  <code>arg1</code>, ... <code>arg9</code>
aesthetics (or <code>args</code> as a list column) specify distribution arguments. Distribution names
should correspond to R functions that have <code>"p"</code>, <code>"q"</code>, and <code>"d"</code> functions; e.g. <code>"norm"</code>
is a valid distribution name because R defines the <code><a href="stats.html#topic+pnorm">pnorm()</a></code>, <code><a href="stats.html#topic+qnorm">qnorm()</a></code>, and <code><a href="stats.html#topic+dnorm">dnorm()</a></code>
functions for Normal distributions.
</p>
<p>See the <code><a href="#topic+parse_dist">parse_dist()</a></code> function for a useful way to generate <code>dist</code> and <code>args</code>
values from human-readable distribution specs (like <code>"normal(0,1)"</code>). Such specs are also
produced by other packages (like the <code>brms::get_prior</code> function in brms); thus,
<code><a href="#topic+parse_dist">parse_dist()</a></code> combined with the stats described here can help you visualize the output
of those functions.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Stat</a> representing a spike geometry which can be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Aesthetics</h3>

<p>The spike <code>geom</code> has a wide variety of aesthetics that control
the appearance of its two sub-geometries: the <strong>spike</strong> and the <strong>point</strong>.
</p>
<p>These <code>stat</code>s support the following aesthetics:
</p>

<ul>
<li><p><code>x</code>: x position of the geometry (when orientation = <code>"vertical"</code>); or sample data to be summarized
(when <code>orientation = "horizontal"</code> with sample data).
</p>
</li>
<li><p><code>y</code>: y position of the geometry (when orientation = <code>"horizontal"</code>); or sample data to be summarized
(when <code>orientation = "vertical"</code> with sample data).
</p>
</li>
<li><p><code>weight</code>: When using samples (i.e. the <code>x</code> and <code>y</code> aesthetics, not <code>xdist</code> or <code>ydist</code>), optional
weights to be applied to each draw.
</p>
</li>
<li><p><code>xdist</code>: When using analytical distributions, distribution to map on the x axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>ydist</code>: When using analytical distributions, distribution to map on the y axis: a <span class="pkg">distributional</span>
object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>) or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object.
</p>
</li>
<li><p><code>dist</code>: When using analytical distributions, a name of a distribution (e.g. <code>"norm"</code>), a
<span class="pkg">distributional</span> object (e.g. <code><a href="distributional.html#topic+dist_normal">dist_normal()</a></code>), or a <code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> object. See <strong>Details</strong>.
</p>
</li>
<li><p><code>args</code>: Distribution arguments (<code>args</code> or <code>arg1</code>, ... <code>arg9</code>). See <strong>Details</strong>.
</p>
</li></ul>

<p>In addition, in their default configuration (paired with <code><a href="#topic+geom_spike">geom_spike()</a></code>)
the following aesthetics are supported by the underlying geom:
</p>
<p><strong>Spike-specific (aka Slab-specific) aesthetics</strong>
</p>

<ul>
<li><p><code>thickness</code>: The thickness of the slab at each <code>x</code> value (if <code>orientation = "horizontal"</code>) or
<code>y</code> value (if <code>orientation = "vertical"</code>) of the slab.
</p>
</li>
<li><p><code>side</code>: Which side to place the slab on. <code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms
which cause the slab to be drawn on the top or the right depending on if <code>orientation</code> is <code>"horizontal"</code>
or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code> are synonyms which cause the slab
to be drawn on the bottom or the left depending on if <code>orientation</code> is <code>"horizontal"</code> or
<code>"vertical"</code>. <code>"topleft"</code> causes the slab to be drawn on the top or the left, and <code>"bottomright"</code>
causes the slab to be drawn on the bottom or the right. <code>"both"</code> draws the slab mirrored on both
sides (as in a violin plot).
</p>
</li>
<li><p><code>scale</code>: What proportion of the region allocated to this geom to use to draw the slab. If <code>scale = 1</code>,
slabs that use the maximum range will just touch each other. Default is <code>0.9</code> to leave some space
between adjacent slabs. For a comprehensive discussion and examples of slab scaling and normalization,
see the <a href="https://mjskay.github.io/ggdist/articles/thickness.html"><code>thickness</code> scale article</a>.
</p>
</li></ul>

<p><strong>Color aesthetics</strong>
</p>

<ul>
<li><p><code>colour</code>: (or <code>color</code>) The color of the <strong>spike</strong> and <strong>point</strong> sub-geometries.
</p>
</li>
<li><p><code>fill</code>: The fill color of the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>alpha</code>: The opacity of the <strong>spike</strong> and <strong>point</strong> sub-geometries.
</p>
</li>
<li><p><code>colour_ramp</code>: (or <code>color_ramp</code>) A secondary scale that modifies the <code>color</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_colour_ramp">scale_colour_ramp()</a></code> for examples.
</p>
</li>
<li><p><code>fill_ramp</code>: A secondary scale that modifies the <code>fill</code>
scale to &quot;ramp&quot; to another color. See <code><a href="#topic+scale_fill_ramp">scale_fill_ramp()</a></code> for examples.
</p>
</li></ul>

<p><strong>Line aesthetics</strong>
</p>

<ul>
<li><p><code>linewidth</code>: Width of the line used to draw the <strong>spike</strong> sub-geometry.
</p>
</li>
<li><p><code>size</code>: Size of the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>stroke</code>: Width of the outline around the <strong>point</strong> sub-geometry.
</p>
</li>
<li><p><code>linetype</code>: Type of line (e.g., <code>"solid"</code>, <code>"dashed"</code>, etc) used to draw the <strong>spike</strong>.
</p>
</li></ul>

<p><strong>Other aesthetics</strong> (these work as in standard <code>geom</code>s)
</p>

<ul>
<li><p><code>width</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>group</code>
</p>
</li></ul>

<p>See examples of some of these aesthetics in action in <code>vignette("slabinterval")</code>.
Learn more about the sub-geom override aesthetics (like <code>interval_color</code>) in the
<a href="#topic+scales">scales</a> documentation. Learn more about basic ggplot aesthetics in
<code>vignette("ggplot2-specs")</code>.
</p>


<h3>Computed Variables</h3>

<p>The following variables are computed by this stat and made available for
use in aesthetic specifications (<code><a href="ggplot2.html#topic+aes">aes()</a></code>) using the <code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
function or the <code>after_stat</code> argument of <code><a href="ggplot2.html#topic+stage">stage()</a></code>:
</p>

<ul>
<li> <p><code>x</code> or <code>y</code>: For slabs, the input values to the slab function.
For intervals, the point summary from the interval function. Whether it is <code>x</code> or <code>y</code> depends on <code>orientation</code>
</p>
</li>
<li> <p><code>xmin</code> or <code>ymin</code>: For intervals, the lower end of the interval from the interval function.
</p>
</li>
<li> <p><code>xmax</code> or <code>ymax</code>: For intervals, the upper end of the interval from the interval function.
</p>
</li>
<li> <p><code>.width</code>: For intervals, the interval width as a numeric value in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
For slabs, the width of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>level</code>: For intervals, the interval width as an ordered factor.
For slabs, the level of the smallest interval containing that value of the slab.
</p>
</li>
<li> <p><code>pdf</code>: For slabs, the probability density function (PDF).
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the PDF at the point summary; intervals also have <code>pdf_min</code> and <code>pdf_max</code>
for the PDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>cdf</code>: For slabs, the cumulative distribution function.
If <code>options("ggdist.experimental.slab_data_in_intervals")</code> is <code>TRUE</code>:
For intervals, the CDF at the point summary; intervals also have <code>cdf_min</code> and <code>cdf_max</code>
for the CDF at the lower and upper ends of the interval.
</p>
</li>
<li> <p><code>n</code>: For slabs, the number of data points summarized into that slab. If the slab was created from
an analytical distribution via the <code>xdist</code>, <code>ydist</code>, or <code>dist</code> aesthetic, <code>n</code> will be <code>Inf</code>.
</p>
</li>
<li> <p><code>f</code>: (deprecated) For slabs, the output values from the slab function (such as the PDF, CDF, or CCDF),
determined by <code>slab_type</code>. Instead of using <code>slab_type</code> to change <code>f</code> and then mapping <code>f</code> onto an
aesthetic, it is now recommended to simply map the corresponding computed variable (e.g. <code>pdf</code>, <code>cdf</code>, or
<code>1 - cdf</code>) directly onto the desired aesthetic.
</p>
</li>
<li> <p><code>at</code>: For spikes, a character vector of names of the functions or expressions used to determine
the points at which the slab functions were evaluated to create spikes. Values of this computed
variable are determined by the <code>at</code> parameter; see its description above.
</p>
</li></ul>



<h3>See Also</h3>

<p>See <code><a href="#topic+geom_spike">geom_spike()</a></code> for the geom underlying this stat.
See <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code> for the stat this shortcut is based on.
</p>
<p>Other slabinterval stats: 
<code><a href="#topic+stat_ccdfinterval">stat_ccdfinterval</a>()</code>,
<code><a href="#topic+stat_cdfinterval">stat_cdfinterval</a>()</code>,
<code><a href="#topic+stat_eye">stat_eye</a>()</code>,
<code><a href="#topic+stat_gradientinterval">stat_gradientinterval</a>()</code>,
<code><a href="#topic+stat_halfeye">stat_halfeye</a>()</code>,
<code><a href="#topic+stat_histinterval">stat_histinterval</a>()</code>,
<code><a href="#topic+stat_interval">stat_interval</a>()</code>,
<code><a href="#topic+stat_pointinterval">stat_pointinterval</a>()</code>,
<code><a href="#topic+stat_slab">stat_slab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(distributional)
library(dplyr)

df = tibble(
  d = c(dist_normal(1), dist_gamma(2,2)), g = c("a", "b")
)

# annotate the density at the mode of a distribution
df %&gt;%
  ggplot(aes(y = g, xdist = d)) +
  stat_slab(aes(xdist = d)) +
  stat_spike(at = "Mode") +
  # need shared thickness scale so that stat_slab and geom_spike line up
  scale_thickness_shared()

# annotate the endpoints of intervals of a distribution
# here we'll use an arrow instead of a point by setting size = 0
arrow_spec = arrow(angle = 45, type = "closed", length = unit(4, "pt"))
df %&gt;%
  ggplot(aes(y = g, xdist = d)) +
  stat_halfeye(point_interval = mode_hdci) +
  stat_spike(
    at = function(x) hdci(x, .width = .66),
    size = 0, arrow = arrow_spec, color = "blue", linewidth = 0.75
  ) +
  scale_thickness_shared()

# annotate quantiles of a sample
set.seed(1234)
data.frame(x = rnorm(1000, 1:2), g = c("a","b")) %&gt;%
  ggplot(aes(x, g)) +
  stat_slab() +
  stat_spike(at = function(x) quantile(x, ppoints(10))) +
  scale_thickness_shared()

</code></pre>

<hr>
<h2 id='student_t'>Scaled and shifted Student's t distribution</h2><span id='topic+student_t'></span><span id='topic+dstudent_t'></span><span id='topic+pstudent_t'></span><span id='topic+qstudent_t'></span><span id='topic+rstudent_t'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the
scaled and shifted Student's t distribution, parameterized by degrees of freedom (<code>df</code>),
location (<code>mu</code>), and scale (<code>sigma</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dstudent_t(x, df, mu = 0, sigma = 1, log = FALSE)

pstudent_t(q, df, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qstudent_t(p, df, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rstudent_t(n, df, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="student_t_+3A_x">x</code>, <code id="student_t_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="student_t_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="student_t_+3A_mu">mu</code></td>
<td>
<p>Location parameter (median)</p>
</td></tr>
<tr><td><code id="student_t_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter</p>
</td></tr>
<tr><td><code id="student_t_+3A_log">log</code>, <code id="student_t_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="student_t_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="student_t_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="student_t_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>dstudent_t</code> gives the density
</p>
</li>
<li> <p><code>pstudent_t</code> gives the cumulative distribution function (CDF)
</p>
</li>
<li> <p><code>qstudent_t</code> gives the quantile function (inverse CDF)
</p>
</li>
<li> <p><code>rstudent_t</code> generates random draws.
</p>
</li></ul>

<p>The length of the result is determined by <code>n</code> for <code>rstudent_t</code>, and is the maximum of the lengths of
the numerical arguments for the other functions.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length of the result. Only the first elements
of the logical arguments are used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_dist">parse_dist()</a></code> and parsing distribution specs and the <code><a href="#topic+stat_slabinterval">stat_slabinterval()</a></code>
family of stats for visualizing them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

expand.grid(
  df = c(3,5,10,30),
  scale = c(1,1.5)
) %&gt;%
  ggplot(aes(y = 0, dist = "student_t", arg1 = df, arg2 = 0, arg3 = scale, color = ordered(df))) +
  stat_slab(p_limits = c(.01, .99), fill = NA) +
  scale_y_continuous(breaks = NULL) +
  facet_grid( ~ scale) +
  labs(
    title = "dstudent_t(x, df, 0, sigma)",
    subtitle = "Scale (sigma)",
    y = NULL,
    x = NULL
  ) +
  theme_ggdist() +
  theme(axis.title = element_text(hjust = 0))

</code></pre>

<hr>
<h2 id='sub-geometry-scales'>Sub-geometry scales for geom_slabinterval (ggplot2 scales)</h2><span id='topic+sub-geometry-scales'></span><span id='topic+scale_point_colour_discrete'></span><span id='topic+scales'></span><span id='topic+scale_point_color_discrete'></span><span id='topic+scale_point_colour_continuous'></span><span id='topic+scale_point_color_continuous'></span><span id='topic+scale_point_fill_discrete'></span><span id='topic+scale_point_fill_continuous'></span><span id='topic+scale_point_alpha_continuous'></span><span id='topic+scale_point_alpha_discrete'></span><span id='topic+scale_point_size_continuous'></span><span id='topic+scale_point_size_discrete'></span><span id='topic+scale_interval_colour_discrete'></span><span id='topic+scale_interval_color_discrete'></span><span id='topic+scale_interval_colour_continuous'></span><span id='topic+scale_interval_color_continuous'></span><span id='topic+scale_interval_alpha_continuous'></span><span id='topic+scale_interval_alpha_discrete'></span><span id='topic+scale_interval_size_continuous'></span><span id='topic+scale_interval_size_discrete'></span><span id='topic+scale_interval_linetype_discrete'></span><span id='topic+scale_interval_linetype_continuous'></span><span id='topic+scale_slab_colour_discrete'></span><span id='topic+scale_slab_color_discrete'></span><span id='topic+scale_slab_colour_continuous'></span><span id='topic+scale_slab_color_continuous'></span><span id='topic+scale_slab_fill_discrete'></span><span id='topic+scale_slab_fill_continuous'></span><span id='topic+scale_slab_alpha_continuous'></span><span id='topic+scale_slab_alpha_discrete'></span><span id='topic+scale_slab_size_continuous'></span><span id='topic+scale_slab_size_discrete'></span><span id='topic+scale_slab_linewidth_continuous'></span><span id='topic+scale_slab_linewidth_discrete'></span><span id='topic+scale_slab_linetype_discrete'></span><span id='topic+scale_slab_linetype_continuous'></span><span id='topic+scale_slab_shape_discrete'></span><span id='topic+scale_slab_shape_continuous'></span><span id='topic+guide_colourbar2'></span><span id='topic+guide_colorbar2'></span>

<h3>Description</h3>

<p>These scales allow more specific aesthetic mappings to be made when using <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>
and stats/geoms based on it (like eye plots).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_point_colour_discrete(..., aesthetics = "point_colour")

scale_point_color_discrete(..., aesthetics = "point_colour")

scale_point_colour_continuous(
  ...,
  aesthetics = "point_colour",
  guide = guide_colourbar2()
)

scale_point_color_continuous(
  ...,
  aesthetics = "point_colour",
  guide = guide_colourbar2()
)

scale_point_fill_discrete(..., aesthetics = "point_fill")

scale_point_fill_continuous(
  ...,
  aesthetics = "point_fill",
  guide = guide_colourbar2()
)

scale_point_alpha_continuous(..., range = c(0.1, 1))

scale_point_alpha_discrete(..., range = c(0.1, 1))

scale_point_size_continuous(..., range = c(1, 6))

scale_point_size_discrete(..., range = c(1, 6), na.translate = FALSE)

scale_interval_colour_discrete(..., aesthetics = "interval_colour")

scale_interval_color_discrete(..., aesthetics = "interval_colour")

scale_interval_colour_continuous(
  ...,
  aesthetics = "interval_colour",
  guide = guide_colourbar2()
)

scale_interval_color_continuous(
  ...,
  aesthetics = "interval_colour",
  guide = guide_colourbar2()
)

scale_interval_alpha_continuous(..., range = c(0.1, 1))

scale_interval_alpha_discrete(..., range = c(0.1, 1))

scale_interval_size_continuous(..., range = c(1, 6))

scale_interval_size_discrete(..., range = c(1, 6), na.translate = FALSE)

scale_interval_linetype_discrete(..., na.value = "blank")

scale_interval_linetype_continuous(...)

scale_slab_colour_discrete(..., aesthetics = "slab_colour")

scale_slab_color_discrete(..., aesthetics = "slab_colour")

scale_slab_colour_continuous(
  ...,
  aesthetics = "slab_colour",
  guide = guide_colourbar2()
)

scale_slab_color_continuous(
  ...,
  aesthetics = "slab_colour",
  guide = guide_colourbar2()
)

scale_slab_fill_discrete(..., aesthetics = "slab_fill")

scale_slab_fill_continuous(
  ...,
  aesthetics = "slab_fill",
  guide = guide_colourbar2()
)

scale_slab_alpha_continuous(
  ...,
  limits = function(l) c(min(0, l[[1]]), l[[2]]),
  range = c(0, 1)
)

scale_slab_alpha_discrete(..., range = c(0.1, 1))

scale_slab_size_continuous(..., range = c(1, 6))

scale_slab_size_discrete(..., range = c(1, 6), na.translate = FALSE)

scale_slab_linewidth_continuous(..., range = c(1, 6))

scale_slab_linewidth_discrete(..., range = c(1, 6), na.translate = FALSE)

scale_slab_linetype_discrete(..., na.value = "blank")

scale_slab_linetype_continuous(...)

scale_slab_shape_discrete(..., solid = TRUE)

scale_slab_shape_continuous(...)

guide_colourbar2(...)

guide_colorbar2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub-geometry-scales_+3A_...">...</code></td>
<td>
<p>Arguments passed to underlying scale or guide functions. E.g. <code>scale_point_color_discrete</code>
passes arguments to <code><a href="ggplot2.html#topic+scale_color_discrete">scale_color_discrete()</a></code>. See those functions for more details.</p>
</td></tr>
<tr><td><code id="sub-geometry-scales_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Names of aesthetics to set scales for.</p>
</td></tr>
<tr><td><code id="sub-geometry-scales_+3A_guide">guide</code></td>
<td>
<p>Guide to use for legends for an aesthetic.</p>
</td></tr>
<tr><td><code id="sub-geometry-scales_+3A_range">range</code></td>
<td>
<p>a numeric vector of length 2 that specifies the minimum and maximum size of the plotting symbol
after transformation.</p>
</td></tr>
<tr><td><code id="sub-geometry-scales_+3A_na.translate">na.translate</code></td>
<td>
<p>In discrete scales, should we show missing values?</p>
</td></tr>
<tr><td><code id="sub-geometry-scales_+3A_na.value">na.value</code></td>
<td>
<p>When <code>na.translate</code> is true, what value should be shown?</p>
</td></tr>
<tr><td><code id="sub-geometry-scales_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="sub-geometry-scales_+3A_solid">solid</code></td>
<td>
<p>Should the shapes be solid, <code>TRUE</code>, or hollow,
<code>FALSE</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following additional scales / aesthetics are defined for use with <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code> and
related geoms:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;scale_point_color_* &#8288;</code></dt><dd><p>Point color</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_point_fill_* &#8288;</code></dt><dd><p>Point fill color</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_point_alpha_* &#8288;</code></dt><dd><p>Point alpha level / opacity</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_point_size_* &#8288;</code></dt><dd><p>Point size</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_interval_color_* &#8288;</code></dt><dd><p>Interval line color</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_interval_alpha_* &#8288;</code></dt><dd><p>Interval alpha level / opacity</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_interval_linetype_* &#8288;</code></dt><dd><p>Interval line type</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_slab_color_* &#8288;</code></dt><dd><p>Slab outline color</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_slab_fill_* &#8288;</code></dt><dd><p>Slab fill color</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_slab_alpha_* &#8288;</code></dt><dd><p>Slab alpha level / opacity. The default settings of
<code>scale_slab_alpha_continuous</code> differ from <code><a href="ggplot2.html#topic+scale_alpha_continuous">scale_alpha_continuous()</a></code> and
are designed for gradient plots (e.g. <code><a href="#topic+stat_gradientinterval">stat_gradientinterval()</a></code>) by ensuring that
densities of 0 get mapped to 0 in the output.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_slab_linewidth_* &#8288;</code></dt><dd><p>Slab outline line width</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_slab_linetype_* &#8288;</code></dt><dd><p>Slab outline line type</p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_slab_shape_* &#8288;</code></dt><dd><p>Slab dot shape (for <code><a href="#topic+geom_dotsinterval">geom_dotsinterval()</a></code>)</p>
</dd>
</dl>

<p>See the corresponding scale documentation in ggplot for more information; e.g.
<code><a href="ggplot2.html#topic+scale_color_discrete">scale_color_discrete()</a></code>, <code><a href="ggplot2.html#topic+scale_color_continuous">scale_color_continuous()</a></code>, etc.
</p>
<p>Other scale functions can be used with the aesthetics/scales defined here by using the <code>aesthetics</code>
argument to that scale function. For example, to use color brewer scales with the <code>point_color</code> aesthetic:
</p>
<p><code>scale_color_brewer(..., aesthetics = "point_color")</code>
</p>
<p>With continuous color scales, you may also need to provide a guide as the default guide does not work properly;
this is what <code>guide_colorbar2</code> is for:
</p>
<p><code>scale_color_distiller(..., guide = "colorbar2", aesthetics = "point_color")</code>
</p>
<p>These scales have been deprecated:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;scale_interval_size_* &#8288;</code></dt><dd><p>Use <code style="white-space: pre;">&#8288;scale_linewidth_*&#8288;</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;scale_slab_size_* &#8288;</code></dt><dd><p>Slab <code style="white-space: pre;">&#8288;scale_size_linewidth_*&#8288;</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::Scale</a> representing one of the aesthetics used to target the appearance of specific parts of composite
<code>ggdist</code> geoms. Can be added to a <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>Other ggplot2 scales: <code><a href="ggplot2.html#topic+scale_color_discrete">scale_color_discrete()</a></code>, <code><a href="ggplot2.html#topic+scale_color_continuous">scale_color_continuous()</a></code>, etc.
</p>
<p>Other ggdist scales: 
<code><a href="#topic+scale_colour_ramp">scale_colour_ramp</a></code>,
<code><a href="#topic+scale_side_mirrored">scale_side_mirrored</a>()</code>,
<code><a href="#topic+scale_thickness">scale_thickness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

# This plot shows how to set multiple specific aesthetics
# NB it is very ugly and is only for demo purposes.
data.frame(distribution = "Normal(1,2)") %&gt;%
  parse_dist(distribution) %&gt;%
  ggplot(aes(y = distribution, xdist = .dist, args = .args)) +
  stat_halfeye(
    shape = 21,  # this point shape has a fill and outline
    point_color = "red",
    point_fill = "black",
    point_alpha = .1,
    point_size = 6,
    stroke = 2,
    interval_color = "blue",
    # interval line widths are scaled from [1, 6] onto [0.6, 1.4] by default
    # see the interval_size_range parameter in help("geom_slabinterval")
    linewidth = 8,
    interval_linetype = "dashed",
    interval_alpha = .25,
    # fill sets the fill color of the slab (here the density)
    slab_color = "green",
    slab_fill = "purple",
    slab_linewidth = 3,
    slab_linetype = "dotted",
    slab_alpha = .5
  )

</code></pre>

<hr>
<h2 id='subguide_axis'>Axis sub-guide for thickness scales</h2><span id='topic+subguide_axis'></span><span id='topic+subguide_inside'></span><span id='topic+subguide_outside'></span><span id='topic+subguide_integer'></span><span id='topic+subguide_count'></span>

<h3>Description</h3>

<p>This is a sub-guide intended for annotating the <a href="#topic+thickness">thickness</a> aesthetic
in <span class="pkg">ggdist</span>. It can be used with the <code>subguide</code> parameter of
<code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>.
</p>
<p>Supports <a href="#topic+automatic-partial-functions">automatic partial function application</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subguide_axis(
  values,
  title = NULL,
  breaks = waiver(),
  labels = waiver(),
  position = 0,
  just = 0,
  label_side = "topright",
  orientation = "horizontal",
  theme = theme_get()
)

subguide_inside(..., label_side = "inside")

subguide_outside(..., label_side = "outside", just = 1)

subguide_integer(..., breaks = scales::breaks_extended(Q = c(1, 5, 2, 4, 3)))

subguide_count(..., breaks = scales::breaks_width(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subguide_axis_+3A_values">values</code></td>
<td>
<p>Values used to construct the scale used for this guide.
Typically provided automatically by <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>.</p>
</td></tr>
<tr><td><code id="subguide_axis_+3A_title">title</code></td>
<td>
<p>The title of the scale shown on the sub-guide's axis.</p>
</td></tr>
<tr><td><code id="subguide_axis_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="subguide_axis_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="subguide_axis_+3A_position">position</code></td>
<td>
<p>Numeric value between <code>0</code> and <code>1</code> giving the position of the
guide relative to the axis: <code>0</code> causes the sub-guide to be drawn on the
left or bottom depending on if <code>orientation</code> is <code>"horizontal"</code> or <code>"vertical"</code>,
and <code>1</code> causes the sub-guide to be drawn on the top or right depending on
if <code>orientation</code> is <code>"horizontal"</code> or <code>"vertical"</code>. May also be a string
indicating the position: <code>"top"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"left"</code>,
<code>"topright"</code>, <code>"topleft"</code>, <code>"bottomright"</code>, or <code>"bottomleft"</code>.</p>
</td></tr>
<tr><td><code id="subguide_axis_+3A_just">just</code></td>
<td>
<p>Numeric value between <code>0</code> and <code>1</code> giving the justification of the
guide relative to its position: 0 means aligned towards the inside of the
axis edge, 1 means aligned towards the outside of the axis edge.</p>
</td></tr>
<tr><td><code id="subguide_axis_+3A_label_side">label_side</code></td>
<td>
<p>Which side of the axis to draw the ticks and labels on.
<code>"topright"</code>, <code>"top"</code>, and <code>"right"</code> are synonyms which cause the labels
to be drawn on the top or the right depending on if <code>orientation</code> is
<code>"horizontal"</code> or <code>"vertical"</code>. <code>"bottomleft"</code>, <code>"bottom"</code>, and <code>"left"</code>
are synonyms which cause the labels to be drawn on the bottom or the left
depending on if <code>orientation</code> is <code>"horizontal"</code> or <code>"vertical"</code>.
<code>"topleft"</code> causes the labels to be drawn on the top or the left, and
<code>"bottomright"</code> causes the labels to be drawn on the bottom or the right.
<code>"inside"</code> causes the labels to be drawn on the side closest to the inside
of the chart, depending on <code>position</code>, and <code>"outside"</code> on the side closest
to the outside of the chart.</p>
</td></tr>
<tr><td><code id="subguide_axis_+3A_orientation">orientation</code></td>
<td>
<p>Orientation of the geometry this sub-guide is for. One
of <code>"horizontal"</code> (<code>"y"</code>) or <code>"vertical"</code> (<code>"x"</code>). See the <code>orientation</code>
parameter to <code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>.</p>
</td></tr>
<tr><td><code id="subguide_axis_+3A_theme">theme</code></td>
<td>
<p>A <a href="ggplot2.html#topic+theme">ggplot2::theme</a> object used to determine the style that the
sub-guide elements are drawn in. The title label is drawn using the
<code>"axis.title.x"</code> or <code>"axis.title.y"</code> theme setting, and the axis line,
ticks, and tick labels are drawn using <code><a href="ggplot2.html#topic+guide_axis">guide_axis()</a></code>, so the same theme
settings that normally apply to axis guides will be followed.</p>
</td></tr>
<tr><td><code id="subguide_axis_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions, typically back to
<code>subguide_axis()</code> itself.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+subguide_inside">subguide_inside()</a></code> is a shortcut for drawing labels inside of the chart
region.
</p>
<p><code><a href="#topic+subguide_outside">subguide_outside()</a></code> is a shortcut for drawing labels outside of the chart
region.
</p>
<p><code><a href="#topic+subguide_integer">subguide_integer()</a></code> only draws breaks that are integer values, useful for
labeling counts in <code><a href="#topic+geom_dots">geom_dots()</a></code>.
</p>
<p><code><a href="#topic+subguide_count">subguide_count()</a></code> is a shortcut for drawing labels where <em>every</em> whole number
is labeled, useful for labeling counts in <code><a href="#topic+geom_dots">geom_dots()</a></code>. If your max count is
large, <code><a href="#topic+subguide_integer">subguide_integer()</a></code> may be better.
</p>


<h3>See Also</h3>

<p>Other sub-guides: 
<code><a href="#topic+subguide_none">subguide_none</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example code
library(ggplot2)
library(distributional)

df = data.frame(d = dist_normal(2:3, 2:3), g = c("a", "b"))

# subguides allow you to label thickness axes
ggplot(df, aes(xdist = d, y = g)) +
  stat_slabinterval(subguide = "inside")

# they respect normalization and use of scale_thickness_shared()
ggplot(df, aes(xdist = d, y = g)) +
  stat_slabinterval(subguide = "inside", normalize = "groups")

# they can also be positioned outside the plot area, though
# this typically requires manually adjusting plot margins
ggplot(df, aes(xdist = d, y = g)) +
  stat_slabinterval(subguide = subguide_outside(title = "density", position = "right")) +
  theme(plot.margin = margin(5.5, 50, 5.5, 5.5))

# any of the subguide types will also work to indicate bin counts in
# geom_dots(); subguide_integer() and subguide_count() can be useful for
# dotplots as they only label integers / whole numbers:
df = data.frame(d = dist_gamma(2:3, 2:3), g = c("a", "b"))
ggplot(df, aes(xdist = d, y = g)) +
  stat_dots(subguide = subguide_count(label_side = "left", title = "count")) +
  scale_y_discrete(expand = expansion(add = 0.1)) +
  scale_x_continuous(expand = expansion(add = 0.5))

</code></pre>

<hr>
<h2 id='subguide_none'>Empty sub-guide for thickness scales</h2><span id='topic+subguide_none'></span>

<h3>Description</h3>

<p>This is a blank sub-guide that omits annotations for the <a href="#topic+thickness">thickness</a> aesthetic
in <span class="pkg">ggdist</span>. It can be used with the <code>subguide</code> parameter of
<code><a href="#topic+geom_slabinterval">geom_slabinterval()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subguide_none(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subguide_none_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other sub-guides: 
<code><a href="#topic+subguide_axis">subguide_axis</a>()</code>
</p>

<hr>
<h2 id='theme_ggdist'>Simple, light ggplot2 theme for ggdist and tidybayes</h2><span id='topic+theme_ggdist'></span><span id='topic+theme_tidybayes'></span><span id='topic+facet_title_horizontal'></span><span id='topic+axis_titles_bottom_left'></span><span id='topic+facet_title_left_horizontal'></span><span id='topic+facet_title_right_horizontal'></span>

<h3>Description</h3>

<p>A simple, relatively minimalist ggplot2 theme, and some helper functions to go with it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_ggdist(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

theme_tidybayes(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22
)

facet_title_horizontal()

axis_titles_bottom_left()

facet_title_left_horizontal()

facet_title_right_horizontal()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_ggdist_+3A_base_size">base_size</code></td>
<td>
<p>base font size, given in pts.</p>
</td></tr>
<tr><td><code id="theme_ggdist_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
<tr><td><code id="theme_ggdist_+3A_base_line_size">base_line_size</code></td>
<td>
<p>base size for line elements</p>
</td></tr>
<tr><td><code id="theme_ggdist_+3A_base_rect_size">base_rect_size</code></td>
<td>
<p>base size for rect elements</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a relatively minimalist ggplot2 theme, intended to be used for making publication-ready plots.
It is currently based on <code><a href="ggplot2.html#topic+ggtheme">ggplot2::theme_light()</a></code>.
</p>
<p>A word of warning: this theme may (and very likely will) change in the future as I tweak it to my taste.
</p>
<p><code><a href="#topic+theme_ggdist">theme_ggdist()</a></code> and <code><a href="#topic+theme_tidybayes">theme_tidybayes()</a></code> are aliases.
</p>


<h3>Value</h3>

<p>A named list in the format of <code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code>
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code>, <code><a href="ggplot2.html#topic+theme_get">ggplot2::theme_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)

theme_set(theme_ggdist())

</code></pre>

<hr>
<h2 id='tidy-format-translators'>Translate between different tidy data frame formats for draws from distributions</h2><span id='topic+tidy-format-translators'></span><span id='topic+to_broom_names'></span><span id='topic+from_broom_names'></span><span id='topic+to_ggmcmc_names'></span><span id='topic+from_ggmcmc_names'></span>

<h3>Description</h3>

<p>These functions translate <span class="pkg">ggdist</span>/<span class="pkg">tidybayes</span>-style data frames to/from different data frame
formats (each format using a different naming scheme for its columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_broom_names(data)

from_broom_names(data)

to_ggmcmc_names(data)

from_ggmcmc_names(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy-format-translators_+3A_data">data</code></td>
<td>
<p>A data frame to translate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function prefixed with <code>to_</code> translate from the <span class="pkg">ggdist</span>/<span class="pkg">tidybayes</span> format to another format, functions
prefixed with <code>from_</code> translate from that format back to the <span class="pkg">ggdist</span>/<span class="pkg">tidybayes</span> format. Formats include:
</p>
<p><code><a href="#topic+to_broom_names">to_broom_names()</a></code> / <code><a href="#topic+from_broom_names">from_broom_names()</a></code>:
</p>

<ul>
<li> <p><code>.variable</code> &lt;-&gt; <code>term</code>
</p>
</li>
<li> <p><code>.value</code> &lt;-&gt; <code>estimate</code>
</p>
</li>
<li> <p><code>.prediction</code> &lt;-&gt; <code>.fitted</code>
</p>
</li>
<li> <p><code>.lower</code> &lt;-&gt; <code>conf.low</code>
</p>
</li>
<li> <p><code>.upper</code> &lt;-&gt; <code>conf.high</code>
</p>
</li></ul>

<p><code><a href="#topic+to_ggmcmc_names">to_ggmcmc_names()</a></code> / <code><a href="#topic+from_ggmcmc_names">from_ggmcmc_names()</a></code>:
</p>

<ul>
<li> <p><code>.chain</code> &lt;-&gt; <code>Chain</code>
</p>
</li>
<li> <p><code>.iteration</code> &lt;-&gt; <code>Iteration</code>
</p>
</li>
<li> <p><code>.variable</code> &lt;-&gt; <code>Parameter</code>
</p>
</li>
<li> <p><code>.value</code> &lt;-&gt; <code>value</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame with (possibly) new names in some columns, according to the
translation scheme described in <strong>Details</strong>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

data(RankCorr_u_tau, package = "ggdist")

df = RankCorr_u_tau %&gt;%
  dplyr::rename(.variable = i, .value = u_tau) %&gt;%
  group_by(.variable) %&gt;%
  median_qi(.value)

df

df %&gt;%
  to_broom_names()

</code></pre>

<hr>
<h2 id='weighted_ecdf'>Weighted empirical cumulative distribution function</h2><span id='topic+weighted_ecdf'></span>

<h3>Description</h3>

<p>A variation of <code><a href="stats.html#topic+ecdf">ecdf()</a></code> that can be applied to weighted samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_ecdf(x, weights = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_ecdf_+3A_x">x</code></td>
<td>
<p>numeric vector: sample values</p>
</td></tr>
<tr><td><code id="weighted_ecdf_+3A_weights">weights</code></td>
<td>
<p>Weights for the sample. One of:
</p>

<ul>
<li><p> numeric vector of same length as <code>x</code>: weights for corresponding values in <code>x</code>,
which will be normalized to sum to 1.
</p>
</li>
<li> <p><code>NULL</code>: indicates no weights are provided, so the unweighted empirical
cumulative distribution function (equivalent to <code><a href="stats.html#topic+ecdf">ecdf()</a></code>) is returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="weighted_ecdf_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if <code>TRUE</code>, corresponding entries in <code>x</code> and <code>weights</code>
are removed if either is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a weighted empirical cumulative distribution function, <code class="reqn">F(x)</code>.
Given <code class="reqn">x</code>, a sorted vector (derived from <code>x</code>), and <code class="reqn">w_i</code>, the corresponding
<code>weight</code> for <code class="reqn">x_i</code>, <code class="reqn">F(x)</code> is a step function with steps at each <code class="reqn">x_i</code>
with <code class="reqn">F(x_i)</code> equal to the sum of all weights up to and including <code class="reqn">w_i</code>.
</p>


<h3>Value</h3>

<p><code>weighted_ecdf()</code> returns a function of class <code>"weighted_ecdf"</code>, which also
inherits from the <code><a href="stats.html#topic+stepfun">stepfun()</a></code> class. Thus, it also has <code>plot()</code> and <code>print()</code>
methods. Like <code><a href="stats.html#topic+ecdf">ecdf()</a></code>, <code><a href="#topic+weighted_ecdf">weighted_ecdf()</a></code> also provides a <code><a href="stats.html#topic+quantile">quantile()</a></code> method,
which dispatches to <code><a href="#topic+weighted_quantile">weighted_quantile()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weighted_quantile">weighted_quantile()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weighted_ecdf(1:3, weights = 1:3)
plot(weighted_ecdf(1:3, weights = 1:3))
quantile(weighted_ecdf(1:3, weights = 1:3), 0.4)
</code></pre>

<hr>
<h2 id='weighted_quantile'>Weighted sample quantiles</h2><span id='topic+weighted_quantile'></span><span id='topic+weighted_quantile_fun'></span>

<h3>Description</h3>

<p>A variation of <code><a href="stats.html#topic+quantile">quantile()</a></code> that can be applied to weighted samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_quantile(
  x,
  probs = seq(0, 1, 0.25),
  weights = NULL,
  n = NULL,
  na.rm = FALSE,
  names = TRUE,
  type = 7,
  digits = 7
)

weighted_quantile_fun(x, weights = NULL, n = NULL, na.rm = FALSE, type = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_quantile_+3A_x">x</code></td>
<td>
<p>numeric vector: sample values</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_probs">probs</code></td>
<td>
<p>numeric vector: probabilities in <code class="reqn">[0, 1]</code></p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_weights">weights</code></td>
<td>
<p>Weights for the sample. One of:
</p>

<ul>
<li><p> numeric vector of same length as <code>x</code>: weights for corresponding values in <code>x</code>,
which will be normalized to sum to 1.
</p>
</li>
<li> <p><code>NULL</code>: indicates no weights are provided, so unweighted sample quantiles
(equivalent to <code><a href="stats.html#topic+quantile">quantile()</a></code>) are returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_n">n</code></td>
<td>
<p>Presumed effective sample size. If this is greater than 1 and
continuous quantiles (<code>type &gt;= 4</code>) are requested, flat regions may be added
to the approximation to the inverse CDF in areas where the normalized
weight exceeds <code>1/n</code> (i.e., regions of high density). This can be used to
ensure that if a sample of size <code>n</code> with duplicate <code>x</code> values is summarized
into a weighted sample without duplicates, the result of <code>weighted_quantile(..., n = n)</code>
on the weighted sample is equal to the result of <code>quantile()</code> on the original
sample. One of:
</p>

<ul>
<li> <p><code>NULL</code>: do not make a sample size adjustment.
</p>
</li>
<li><p> numeric: presumed effective sample size.
</p>
</li>
<li><p> function or name of function (as a string): A function applied to
<code>weights</code> (prior to normalization) to determine the sample size. Some
useful values may be:
</p>

<ul>
<li> <p><code>"length"</code>: i.e. use the number of elements in <code>weights</code> (equivalently
in <code>x</code>) as the effective sample size.
</p>
</li>
<li> <p><code>"sum"</code>: i.e. use the sum of the unnormalized <code>weights</code> as the sample
size. Useful if the provided <code>weights</code> is unnormalized so that its
sum represents the true sample size.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if <code>TRUE</code>, corresponding entries in <code>x</code> and <code>weights</code>
are removed if either is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_names">names</code></td>
<td>
<p>logical: If <code>TRUE</code>, add names to the output giving the input
<code>probs</code> formatted as a percentage.</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_type">type</code></td>
<td>
<p>integer between 1 and 9: determines the type of quantile estimator
to be used. Types 1 to 3 are for discontinuous quantiles, types 4 to 9 are
for continuous quantiles. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_digits">digits</code></td>
<td>
<p>numeric: the number of digits to use to format percentages
when <code>names</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates weighted quantiles using a variation of the quantile types based
on a generalization of <code><a href="stats.html#topic+quantile">quantile()</a></code>.
</p>
<p>Type 1&ndash;3 (discontinuous) quantiles are directly a function of the inverse
CDF as a step function, and so can be directly translated to the weighted
case using the natural definition of the weighted ECDF as the cumulative
sum of the normalized weights.
</p>
<p>Type 4&ndash;9 (continuous) quantiles require some translation from the definitions
in <code><a href="stats.html#topic+quantile">quantile()</a></code>. <code><a href="stats.html#topic+quantile">quantile()</a></code> defines continuous estimators in terms of
<code class="reqn">x_k</code>, which is the <code class="reqn">k</code>th order statistic, and <code class="reqn">p_k</code>, which is a function of <code class="reqn">k</code>
and <code class="reqn">n</code> (the sample size). In the weighted case, we instead take <code class="reqn">x_k</code> as the <code class="reqn">k</code>th
smallest value of <code class="reqn">x</code> in the weighted sample (not necessarily an order statistic,
because of the weights). Then we can re-write the formulas for <code class="reqn">p_k</code> in terms of
<code class="reqn">F(x_k)</code> (the empirical CDF at <code class="reqn">x_k</code>, i.e. the cumulative sum of normalized
weights) and <code class="reqn">f(x_k)</code> (the normalized weight at <code class="reqn">x_k</code>), by using the
fact that, in the unweighted case, <code class="reqn">k = F(x_k) \cdot n</code> and <code class="reqn">1/n = f(x_k)</code>:
</p>

<dl>
<dt>Type 4</dt><dd><p><code class="reqn">p_k = \frac{k}{n} = F(x_k)</code></p>
</dd>
<dt>Type 5</dt><dd><p><code class="reqn">p_k = \frac{k - 0.5}{n} = F(x_k) - \frac{f(x_k)}{2}</code></p>
</dd>
<dt>Type 6</dt><dd><p><code class="reqn">p_k = \frac{k}{n + 1} = \frac{F(x_k)}{1 + f(x_k)}</code></p>
</dd>
<dt>Type 7</dt><dd><p><code class="reqn">p_k = \frac{k - 1}{n - 1} = \frac{F(x_k) - f(x_k)}{1 - f(x_k)}</code></p>
</dd>
<dt>Type 8</dt><dd><p><code class="reqn">p_k = \frac{k - 1/3}{n + 1/3} = \frac{F(x_k) - f(x_k)/3}{1 + f(x_k)/3}</code></p>
</dd>
<dt>Type 9</dt><dd><p><code class="reqn">p_k = \frac{k - 3/8}{n + 1/4} = \frac{F(x_k) - f(x_k) \cdot 3/8}{1 + f(x_k)/4}</code></p>
</dd>
</dl>

<p>Then the quantile function (inverse CDF) is the piece-wise linear function
defined by the points <code class="reqn">(p_k, x_k)</code>.
</p>


<h3>Value</h3>

<p><code>weighted_quantile()</code> returns a numeric vector of <code>length(probs)</code> with the
estimate of the corresponding quantile from <code>probs</code>.
</p>
<p><code>weighted_quantile_fun()</code> returns a function that takes a single argument,
a vector of probabilities, which itself returns the corresponding quantile
estimates. It may be useful when <code>weighted_quantile()</code> needs to be called
repeatedly for the same sample, re-using some pre-computation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weighted_ecdf">weighted_ecdf()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
