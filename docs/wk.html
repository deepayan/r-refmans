<!DOCTYPE html><html><head><title>Help for package wk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#wk-package'><p>wk: Lightweight Well-Known Geometry Parsing</p></a></li>
<li><a href='#crc'><p>2D Circle Vectors</p></a></li>
<li><a href='#crc_x'><p>Circle accessors</p></a></li>
<li><a href='#grd'><p>Raster-like objects</p></a></li>
<li><a href='#grd_cell'><p>Grid cell operators</p></a></li>
<li><a href='#grd_extract'><p>Extract values from a grid</p></a></li>
<li><a href='#grd_snap_next'><p>Index snap functions</p></a></li>
<li><a href='#grd_subset'><p>Subset grid objects</p></a></li>
<li><a href='#grd_summary'><p>Grid information</p></a></li>
<li><a href='#grd_tile'><p>Extract normalized grid tiles</p></a></li>
<li><a href='#grd_tile_template'><p>Compute overview grid tile</p></a></li>
<li><a href='#handle_wkt_without_vector_size'><p>Test handlers for handling of unknown size vectors</p></a></li>
<li><a href='#new_wk_crc'><p>S3 details for crc objects</p></a></li>
<li><a href='#new_wk_grd'><p>S3 details for grid objects</p></a></li>
<li><a href='#new_wk_rct'><p>S3 details for rct objects</p></a></li>
<li><a href='#new_wk_wkb'><p>S3 Details for wk_wkb</p></a></li>
<li><a href='#new_wk_wkt'><p>S3 Details for wk_wkt</p></a></li>
<li><a href='#new_wk_xy'><p>S3 details for xy objects</p></a></li>
<li><a href='#plot.wk_grd_xy'><p>Plot grid objects</p></a></li>
<li><a href='#rct'><p>2D rectangle vectors</p></a></li>
<li><a href='#rct_xmin'><p>Rectangle accessors and operators</p></a></li>
<li><a href='#vctrs-methods'><p>Vctrs methods</p></a></li>
<li><a href='#wk_bbox'><p>2D bounding rectangles</p></a></li>
<li><a href='#wk_chunk_strategy_single'><p>Chunking strategies</p></a></li>
<li><a href='#wk_count'><p>Count geometry components</p></a></li>
<li><a href='#wk_crs'><p>Set and get vector CRS</p></a></li>
<li><a href='#wk_crs_equal'><p>Compare CRS objects</p></a></li>
<li><a href='#wk_crs_inherit'><p>Special CRS values</p></a></li>
<li><a href='#wk_crs_proj_definition'><p>CRS object generic methods</p></a></li>
<li><a href='#wk_debug'><p>Debug filters and handlers</p></a></li>
<li><a href='#wk_example'><p>Create example geometry objects</p></a></li>
<li><a href='#wk_flatten'><p>Extract simple geometries</p></a></li>
<li><a href='#wk_format'><p>Format well-known geometry for printing</p></a></li>
<li><a href='#wk_handle_slice.data.frame'><p>Handle specific regions of objects</p></a></li>
<li><a href='#wk_handle.data.frame'><p>Use data.frame with wk</p></a></li>
<li><a href='#wk_handle.wk_crc'><p>Read geometry vectors</p></a></li>
<li><a href='#wk_handle.wk_grd_xy'><p>Handler interface for grid objects</p></a></li>
<li><a href='#wk_identity'><p>Copy a geometry vector</p></a></li>
<li><a href='#wk_is_geodesic'><p>Set and get vector geodesic edge interpolation</p></a></li>
<li><a href='#wk_linestring'><p>Create lines, polygons, and collections</p></a></li>
<li><a href='#wk_meta'><p>Extract feature-level meta</p></a></li>
<li><a href='#wk_orient'><p>Orient polygon coordinates</p></a></li>
<li><a href='#wk_plot'><p>Plot well-known geometry vectors</p></a></li>
<li><a href='#wk_problems'><p>Validate well-known binary and well-known text</p></a></li>
<li><a href='#wk_proj_crs_view'><p>Common CRS Representations</p></a></li>
<li><a href='#wk_set_z'><p>Set coordinate values</p></a></li>
<li><a href='#wk_trans_affine'><p>Affine transformer</p></a></li>
<li><a href='#wk_trans_explicit'><p>Transform using explicit coordinate values</p></a></li>
<li><a href='#wk_trans_inverse'><p>Generic transform class</p></a></li>
<li><a href='#wk_transform'><p>Apply coordinate transformations</p></a></li>
<li><a href='#wk_translate.sfc'><p>Translate geometry vectors</p></a></li>
<li><a href='#wk_vertices'><p>Extract vertices</p></a></li>
<li><a href='#wk_void'><p>Do nothing</p></a></li>
<li><a href='#wk_writer.sfc'><p>Write geometry vectors</p></a></li>
<li><a href='#wkb'><p>Mark lists of raw vectors as well-known binary</p></a></li>
<li><a href='#wkb_to_hex'><p>Convert well-known binary to hex</p></a></li>
<li><a href='#wkb_translate_wkt'><p>Deprecated functions</p></a></li>
<li><a href='#wkt'><p>Mark character vectors as well-known text</p></a></li>
<li><a href='#xy'><p>Efficient point vectors</p></a></li>
<li><a href='#xy_x'><p>XY vector extractors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Lightweight Well-Known Geometry Parsing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dewey Dunnington &lt;dewey@fishandwhistle.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a minimal R and C++ API for parsing
  well-known binary and well-known text representation of
  geometries to and from R-native formats.
  Well-known binary is compact
  and fast to parse; well-known text is human-readable
  and is useful for writing tests. These formats are
  useful in R only if the information they contain can be
  accessed in R, for which high-performance functions
  are provided here.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), vctrs (&ge; 0.3.0), sf, tibble, readr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paleolimbot.github.io/wk/">https://paleolimbot.github.io/wk/</a>,
<a href="https://github.com/paleolimbot/wk">https://github.com/paleolimbot/wk</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paleolimbot/wk/issues">https://github.com/paleolimbot/wk/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-09 05:24:04 UTC; deweydunnington</td>
</tr>
<tr>
<td>Author:</td>
<td>Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Anthony North [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-09 06:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='wk-package'>wk: Lightweight Well-Known Geometry Parsing</h2><span id='topic+wk'></span><span id='topic+wk-package'></span>

<h3>Description</h3>

<p>Provides a minimal R and C++ API for parsing well-known binary and well-known text representation of geometries to and from R-native formats. Well-known binary is compact and fast to parse; well-known text is human-readable and is useful for writing tests. These formats are useful in R only if the information they contain can be accessed in R, for which high-performance functions are provided here.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dewey Dunnington <a href="mailto:dewey@fishandwhistle.net">dewey@fishandwhistle.net</a> (<a href="https://orcid.org/0000-0002-9415-4582">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Edzer Pebesma <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> (<a href="https://orcid.org/0000-0001-8049-7069">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Anthony North <a href="mailto:anthony.jl.north@gmail.com">anthony.jl.north@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://paleolimbot.github.io/wk/">https://paleolimbot.github.io/wk/</a>
</p>
</li>
<li> <p><a href="https://github.com/paleolimbot/wk">https://github.com/paleolimbot/wk</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/paleolimbot/wk/issues">https://github.com/paleolimbot/wk/issues</a>
</p>
</li></ul>


<hr>
<h2 id='crc'>2D Circle Vectors</h2><span id='topic+crc'></span><span id='topic+as_crc'></span><span id='topic+as_crc.wk_crc'></span><span id='topic+as_crc.matrix'></span><span id='topic+as_crc.data.frame'></span>

<h3>Description</h3>

<p>2D Circle Vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crc(x = double(), y = double(), r = double(), crs = wk_crs_auto())

as_crc(x, ...)

## S3 method for class 'wk_crc'
as_crc(x, ...)

## S3 method for class 'matrix'
as_crc(x, ..., crs = NULL)

## S3 method for class 'data.frame'
as_crc(x, ..., crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crc_+3A_x">x</code>, <code id="crc_+3A_y">y</code></td>
<td>
<p>Coordinates of the center</p>
</td></tr>
<tr><td><code id="crc_+3A_r">r</code></td>
<td>
<p>Circle radius</p>
</td></tr>
<tr><td><code id="crc_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
<tr><td><code id="crc_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>as_crc()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector along the recycled length of bounds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crc(1, 2, 3)

</code></pre>

<hr>
<h2 id='crc_x'>Circle accessors</h2><span id='topic+crc_x'></span><span id='topic+crc_y'></span><span id='topic+crc_center'></span><span id='topic+crc_r'></span>

<h3>Description</h3>

<p>Circle accessors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crc_x(x)

crc_y(x)

crc_center(x)

crc_r(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crc_x_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+crc">crc()</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Components of the <code><a href="#topic+crc">crc()</a></code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- crc(1, 2, r = 3)
crc_x(x)
crc_y(x)
crc_r(x)
crc_center(x)

</code></pre>

<hr>
<h2 id='grd'>Raster-like objects</h2><span id='topic+grd'></span><span id='topic+grd_rct'></span><span id='topic+grd_xy'></span><span id='topic+as_grd_rct'></span><span id='topic+as_grd_rct.wk_grd_rct'></span><span id='topic+as_grd_rct.wk_grd_xy'></span><span id='topic+as_grd_xy'></span><span id='topic+as_grd_xy.wk_grd_xy'></span><span id='topic+as_grd_xy.wk_grd_rct'></span>

<h3>Description</h3>

<p><code><a href="#topic+grd">grd()</a></code> objects are just an array (any object with more than
two <code><a href="base.html#topic+dim">dim()</a></code>s) and a bounding box (a <code><a href="#topic+rct">rct()</a></code>, which may or
may not have a <code><a href="#topic+wk_crs">wk_crs()</a></code> attached). The ordering of the dimensions
is y (indices increasing downwards), x (indices increasing to the right).
This follows the ordering of <code><a href="grDevices.html#topic+as.raster">as.raster()</a></code>/<code><a href="graphics.html#topic+rasterImage">rasterImage()</a></code> and aligns
with the printing of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grd(
  bbox = NULL,
  nx = NULL,
  ny = NULL,
  dx = NULL,
  dy = NULL,
  type = c("polygons", "corners", "centers")
)

grd_rct(data, bbox = rct(0, 0, dim(data)[2], dim(data)[1]))

grd_xy(data, bbox = rct(0, 0, dim(data)[2] - 1, dim(data)[1] - 1))

as_grd_rct(x, ...)

## S3 method for class 'wk_grd_rct'
as_grd_rct(x, ...)

## S3 method for class 'wk_grd_xy'
as_grd_rct(x, ...)

as_grd_xy(x, ...)

## S3 method for class 'wk_grd_xy'
as_grd_xy(x, ...)

## S3 method for class 'wk_grd_rct'
as_grd_xy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grd_+3A_bbox">bbox</code></td>
<td>
<p>A <code><a href="#topic+rct">rct()</a></code> containing the bounds and CRS of the object. You can
specify a <code><a href="#topic+rct">rct()</a></code> with <code>xmin &gt; xmax</code> or <code>ymin &gt; ymax</code> which will flip
the underlying data and return an object with a normalized bounding
box and data.</p>
</td></tr>
<tr><td><code id="grd_+3A_nx">nx</code>, <code id="grd_+3A_ny">ny</code>, <code id="grd_+3A_dx">dx</code>, <code id="grd_+3A_dy">dy</code></td>
<td>
<p>Either a number of cells in the x- and y- directions
or delta in the x- and y-directions (in which case <code>bbox</code> must
be specified).</p>
</td></tr>
<tr><td><code id="grd_+3A_type">type</code></td>
<td>
<p>Use &quot;polygons&quot; to return a grid whose objects can be
represented using an <code><a href="#topic+rct">rct()</a></code>; use &quot;centers&quot; to return a grid whose
objects are the center of the <code><a href="#topic+rct">rct()</a></code> grid; use &quot;corners&quot; to return
a grid along the corners of <code>bbox</code>.</p>
</td></tr>
<tr><td><code id="grd_+3A_data">data</code></td>
<td>
<p>An object with two or more dimensions. Most usefully, a matrix.</p>
</td></tr>
<tr><td><code id="grd_+3A_x">x</code></td>
<td>
<p>An object to convert to a grid</p>
</td></tr>
<tr><td><code id="grd_+3A_...">...</code></td>
<td>
<p>Passed to S3 methods</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>grd()</code> returns a <code>grd_rct()</code> for <code style="white-space: pre;">&#8288;type == "polygons&#8288;</code> or
a <code>grd_xy()</code> otherwise.
</p>
</li>
<li> <p><code>grd_rct()</code> returns an object of class &quot;wk_grd_rct&quot;.
</p>
</li>
<li> <p><code>grd_xy()</code> returns an object of class &quot;wk_grd_xy&quot;.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># create a grid with no data (just for coordinates)
(grid &lt;- grd(nx = 2, ny = 2))
as_rct(grid)
as_xy(grid)
plot(grid, border = "black")

# more usefully, wraps a matrix or nd array + bbox
# approx volcano in New Zealand Transverse Mercator
bbox &lt;- rct(
  5917000,       1757000 + 870,
  5917000 + 610, 1757000,
  crs = "EPSG:2193"
)
(grid &lt;- grd_rct(volcano, bbox))

# these come with a reasonable default plot method for matrix data
plot(grid)

# you can set the data or the bounding box after creation
grid$bbox &lt;- rct(0, 0, 1, 1)

# subset by indices or rct
plot(grid[1:2, 1:2])
plot(grid[c(start = NA, stop = NA, step = 2), c(start = NA, stop = NA, step = 2)])
plot(grid[rct(0, 0, 0.5, 0.5)])

</code></pre>

<hr>
<h2 id='grd_cell'>Grid cell operators</h2><span id='topic+grd_cell'></span><span id='topic+grd_cell_range'></span><span id='topic+grd_cell_rct'></span><span id='topic+grd_cell_rct.wk_grd_rct'></span><span id='topic+grd_cell_rct.wk_grd_xy'></span><span id='topic+grd_cell_xy'></span><span id='topic+grd_cell_xy.wk_grd_rct'></span><span id='topic+grd_cell_xy.wk_grd_xy'></span>

<h3>Description</h3>

<p>Grid cell operators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grd_cell(grid, point, ..., snap = grd_snap_next)

grd_cell_range(
  grid,
  bbox = wk_bbox(grid),
  ...,
  step = 1L,
  snap = grd_snap_next
)

grd_cell_rct(grid, i, j = NULL, ...)

## S3 method for class 'wk_grd_rct'
grd_cell_rct(grid, i, j = NULL, ..., out_of_bounds = "keep")

## S3 method for class 'wk_grd_xy'
grd_cell_rct(grid, i, j = NULL, ..., out_of_bounds = "keep")

grd_cell_xy(grid, i, j = NULL, ...)

## S3 method for class 'wk_grd_rct'
grd_cell_xy(grid, i, j = NULL, ..., out_of_bounds = "keep")

## S3 method for class 'wk_grd_xy'
grd_cell_xy(grid, i, j = NULL, ..., out_of_bounds = "keep")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grd_cell_+3A_grid">grid</code></td>
<td>
<p>A <code><a href="#topic+grd_xy">grd_xy()</a></code>, <code><a href="#topic+grd_rct">grd_rct()</a></code>, or other object
implementing <code style="white-space: pre;">&#8288;grd_*()&#8288;</code> methods.</p>
</td></tr>
<tr><td><code id="grd_cell_+3A_point">point</code></td>
<td>
<p>A <a href="#topic+wk_handle">handleable</a> of points.</p>
</td></tr>
<tr><td><code id="grd_cell_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="grd_cell_+3A_snap">snap</code></td>
<td>
<p>A function that transforms real-valued indices to integer
indices (e.g., <code><a href="base.html#topic+floor">floor()</a></code>, <code><a href="base.html#topic+ceiling">ceiling()</a></code>, or <code><a href="base.html#topic+round">round()</a></code>).
For <code><a href="#topic+grd_cell_range">grd_cell_range()</a></code>, a <code>list()</code> with exactly two elements to be called
for the minimum and maximum index values, respectively.</p>
</td></tr>
<tr><td><code id="grd_cell_+3A_bbox">bbox</code></td>
<td>
<p>An <code><a href="#topic+rct">rct()</a></code> object.</p>
</td></tr>
<tr><td><code id="grd_cell_+3A_step">step</code></td>
<td>
<p>The difference between adjascent indices in the output</p>
</td></tr>
<tr><td><code id="grd_cell_+3A_i">i</code>, <code id="grd_cell_+3A_j">j</code></td>
<td>
<p>1-based index values. <code>i</code> indices correspond to decreasing
<code>y</code> values; <code>j</code> indices correspond to increasing <code>x</code> values.
Values outside the range <code>1:nrow|ncol(data)</code> will be censored to
<code>NA</code> including 0 and negative values.</p>
</td></tr>
<tr><td><code id="grd_cell_+3A_out_of_bounds">out_of_bounds</code></td>
<td>
<p>One of 'keep', 'censor', 'discard', or 'squish'</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>grd_cell()</code>: returns a <code>list(i, j)</code> of index values corresponding
to the input points and adjusted according to <code>snap</code>. Index values
will be outside <code>dim(grid)</code> for points outside <code>wk_bbox(grid)</code> including
negative values.
</p>
</li>
<li> <p><code>grd_cell_range()</code> returns a slice describing the range of indices
in the <code>i</code> and <code>j</code> directions.
</p>
</li>
<li> <p><code>grd_cell_rct()</code> returns a <code><a href="#topic+rct">rct()</a></code> of the cell extent at <code style="white-space: pre;">&#8288;i, j&#8288;</code>.
</p>
</li>
<li> <p><code>grd_cell_xy()</code> returns a <code><a href="#topic+xy">xy()</a></code> of the cell center at <code style="white-space: pre;">&#8288;i, j&#8288;</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- grd(nx = 3, ny = 2)
grd_cell(grid, xy(0.5, 0.5))
grd_cell_range(grid, grid$bbox)
grd_cell_rct(grid, 1, 1)
grd_cell_xy(grid, 1, 1)

</code></pre>

<hr>
<h2 id='grd_extract'>Extract values from a grid</h2><span id='topic+grd_extract'></span><span id='topic+grd_extract_nearest'></span><span id='topic+grd_data_extract'></span>

<h3>Description</h3>

<p>Unlike <code><a href="#topic+grd_subset">grd_subset()</a></code>, which subsets like a matrix, <code><a href="#topic+grd_extract">grd_extract()</a></code> returns
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grd_extract(grid, i = NULL, j = NULL)

grd_extract_nearest(grid, point, out_of_bounds = c("censor", "squish"))

grd_data_extract(grid_data, i = NULL, j = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grd_extract_+3A_grid">grid</code></td>
<td>
<p>A <code><a href="#topic+grd_xy">grd_xy()</a></code>, <code><a href="#topic+grd_rct">grd_rct()</a></code>, or other object
implementing <code style="white-space: pre;">&#8288;grd_*()&#8288;</code> methods.</p>
</td></tr>
<tr><td><code id="grd_extract_+3A_i">i</code>, <code id="grd_extract_+3A_j">j</code></td>
<td>
<p>Index values as in <code><a href="#topic+grd_subset">grd_subset()</a></code> except recycled to a common
size.</p>
</td></tr>
<tr><td><code id="grd_extract_+3A_point">point</code></td>
<td>
<p>A <a href="#topic+wk_handle">handleable</a> of points.</p>
</td></tr>
<tr><td><code id="grd_extract_+3A_out_of_bounds">out_of_bounds</code></td>
<td>
<p>One of 'keep', 'censor', 'discard', or 'squish'</p>
</td></tr>
<tr><td><code id="grd_extract_+3A_grid_data">grid_data</code></td>
<td>
<p>The <code>data</code> member of a <code><a href="#topic+grd">grd()</a></code>. This is typically an
array but can also be an S3 object with an array-like subset method.
The <a href="grDevices.html#topic+as.raster">native raster</a> is special-cased as its
subset method requires non-standard handling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector with two fewer dimensions than the input.
</p>

<hr>
<h2 id='grd_snap_next'>Index snap functions</h2><span id='topic+grd_snap_next'></span><span id='topic+grd_snap_previous'></span>

<h3>Description</h3>

<p>These functions can be used in <code><a href="#topic+grd_cell">grd_cell()</a></code> and
<code><a href="#topic+grd_cell_range">grd_cell_range()</a></code>. These functions differ in the way
they round 0.5: <code><a href="#topic+grd_snap_next">grd_snap_next()</a></code> always rounds up
and <code><a href="#topic+grd_snap_previous">grd_snap_previous()</a></code> always rounds down. You can
also use <code><a href="base.html#topic+floor">floor()</a></code> and <code><a href="base.html#topic+ceiling">ceiling()</a></code> as index
snap functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grd_snap_next(x)

grd_snap_previous(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grd_snap_next_+3A_x">x</code></td>
<td>
<p>A vector of rescaled but non-integer indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integer indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grd_snap_next(seq(0, 2, 0.25))
grd_snap_previous(seq(0, 2, 0.25))

</code></pre>

<hr>
<h2 id='grd_subset'>Subset grid objects</h2><span id='topic+grd_subset'></span><span id='topic+grd_crop'></span><span id='topic+grd_extend'></span><span id='topic+grd_crop.wk_grd_rct'></span><span id='topic+grd_crop.wk_grd_xy'></span><span id='topic+grd_extend.wk_grd_rct'></span><span id='topic+grd_extend.wk_grd_xy'></span><span id='topic+grd_data_subset'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+grd_subset">grd_subset()</a></code> method handles the subsetting of a <code><a href="#topic+grd">grd()</a></code>
in x-y space. Ordering of indices is not considered and logical
indies are recycled silently along dimensions. The result of
a <code><a href="#topic+grd_subset">grd_subset()</a></code> is always a <code><a href="#topic+grd">grd()</a></code> of the same type whose
relationship to x-y space has not changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grd_subset(grid, i = NULL, j = NULL, ...)

grd_crop(grid, bbox, ..., step = 1L, snap = NULL)

grd_extend(grid, bbox, ..., step = 1L, snap = NULL)

## S3 method for class 'wk_grd_rct'
grd_crop(grid, bbox, ..., step = 1L, snap = NULL)

## S3 method for class 'wk_grd_xy'
grd_crop(grid, bbox, ..., step = 1L, snap = NULL)

## S3 method for class 'wk_grd_rct'
grd_extend(grid, bbox, ..., step = 1L, snap = NULL)

## S3 method for class 'wk_grd_xy'
grd_extend(grid, bbox, ..., step = 1L, snap = NULL)

grd_data_subset(grid_data, i = NULL, j = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grd_subset_+3A_grid">grid</code></td>
<td>
<p>A <code><a href="#topic+grd_xy">grd_xy()</a></code>, <code><a href="#topic+grd_rct">grd_rct()</a></code>, or other object
implementing <code style="white-space: pre;">&#8288;grd_*()&#8288;</code> methods.</p>
</td></tr>
<tr><td><code id="grd_subset_+3A_i">i</code>, <code id="grd_subset_+3A_j">j</code></td>
<td>
<p>1-based index values. <code>i</code> indices correspond to decreasing
<code>y</code> values; <code>j</code> indices correspond to increasing <code>x</code> values.
Values outside the range <code>1:nrow|ncol(data)</code> will be censored to
<code>NA</code> including 0 and negative values.</p>
</td></tr>
<tr><td><code id="grd_subset_+3A_...">...</code></td>
<td>
<p>Passed to subset methods</p>
</td></tr>
<tr><td><code id="grd_subset_+3A_bbox">bbox</code></td>
<td>
<p>An <code><a href="#topic+rct">rct()</a></code> object.</p>
</td></tr>
<tr><td><code id="grd_subset_+3A_step">step</code></td>
<td>
<p>The difference between adjascent indices in the output</p>
</td></tr>
<tr><td><code id="grd_subset_+3A_snap">snap</code></td>
<td>
<p>A function that transforms real-valued indices to integer
indices (e.g., <code><a href="base.html#topic+floor">floor()</a></code>, <code><a href="base.html#topic+ceiling">ceiling()</a></code>, or <code><a href="base.html#topic+round">round()</a></code>).
For <code><a href="#topic+grd_cell_range">grd_cell_range()</a></code>, a <code>list()</code> with exactly two elements to be called
for the minimum and maximum index values, respectively.</p>
</td></tr>
<tr><td><code id="grd_subset_+3A_grid_data">grid_data</code></td>
<td>
<p>The <code>data</code> member of a <code><a href="#topic+grd">grd()</a></code>. This is typically an
array but can also be an S3 object with an array-like subset method.
The <a href="grDevices.html#topic+as.raster">native raster</a> is special-cased as its
subset method requires non-standard handling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>grid</code> whose cell centres have not changed location
as a result of the subset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- grd_rct(volcano)
grd_subset(grid, 1:20, 1:30)
grd_crop(grid, rct(-10, -10, 10, 10))
grd_extend(grid, rct(-10, -10, 10, 10))

</code></pre>

<hr>
<h2 id='grd_summary'>Grid information</h2><span id='topic+grd_summary'></span>

<h3>Description</h3>

<p>Grid information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grd_summary(grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grd_summary_+3A_grid">grid</code></td>
<td>
<p>A <code><a href="#topic+grd_xy">grd_xy()</a></code>, <code><a href="#topic+grd_rct">grd_rct()</a></code>, or other object
implementing <code style="white-space: pre;">&#8288;grd_*()&#8288;</code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>grd_summary()</code> returns a <code>list()</code> with components
<code>xmin</code>, <code>ymin</code>, <code>xmax</code>, <code>ymax</code>,
<code>nx</code>, <code>ny</code>, <code>dx</code>, <code>dy</code>, <code>width</code>, and <code>height</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>grd_summary(grd(nx = 3, ny = 2))

</code></pre>

<hr>
<h2 id='grd_tile'>Extract normalized grid tiles</h2><span id='topic+grd_tile'></span><span id='topic+grd_tile.wk_grd_rct'></span><span id='topic+grd_tile.wk_grd_xy'></span>

<h3>Description</h3>

<p>Unlike <code><a href="#topic+grd_tile_template">grd_tile_template()</a></code>, which returns a <code><a href="#topic+grd">grd()</a></code> whose elements are
the boundaries of the specified tiles with no data attached, <code><a href="#topic+grd_tile">grd_tile()</a></code>
returns the actual tile with the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grd_tile(grid, level, i, j = NULL)

## S3 method for class 'wk_grd_rct'
grd_tile(grid, level, i, j = NULL)

## S3 method for class 'wk_grd_xy'
grd_tile(grid, level, i, j = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grd_tile_+3A_grid">grid</code></td>
<td>
<p>A <code><a href="#topic+grd_xy">grd_xy()</a></code>, <code><a href="#topic+grd_rct">grd_rct()</a></code>, or other object
implementing <code style="white-space: pre;">&#8288;grd_*()&#8288;</code> methods.</p>
</td></tr>
<tr><td><code id="grd_tile_+3A_level">level</code></td>
<td>
<p>An integer describing the overview level. This is related to
the <code>step</code> value by a power of 2 (i.e., a level of <code>1</code> indicates a step of
<code>2</code>, a level of <code>2</code> indicates a step of <code>4</code>, etc.).</p>
</td></tr>
<tr><td><code id="grd_tile_+3A_i">i</code>, <code id="grd_tile_+3A_j">j</code></td>
<td>
<p>1-based index values. <code>i</code> indices correspond to decreasing
<code>y</code> values; <code>j</code> indices correspond to increasing <code>x</code> values.
Values outside the range <code>1:nrow|ncol(data)</code> will be censored to
<code>NA</code> including 0 and negative values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+grd_subset">grd_subset()</a></code>ed version
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- grd_rct(volcano)
plot(grd_tile(grid, 4, 1, 1))

plot(grd_tile(grid, 3, 1, 1), add = TRUE)
plot(grd_tile(grid, 3, 1, 2), add = TRUE)
plot(grd_tile(grid, 3, 2, 1), add = TRUE)
plot(grd_tile(grid, 3, 2, 2), add = TRUE)

grid &lt;- as_grd_xy(grd_tile(grid, 4, 1, 1))
plot(grid, add = TRUE, pch = ".")
plot(grd_tile(grid, 3, 1, 1), add = TRUE, col = "green", pch = ".")
plot(grd_tile(grid, 3, 1, 2), add = TRUE, col = "red", pch = ".")
plot(grd_tile(grid, 3, 2, 1), add = TRUE, col = "blue", pch = ".")
plot(grd_tile(grid, 3, 2, 2), add = TRUE, col = "magenta", pch = ".")

</code></pre>

<hr>
<h2 id='grd_tile_template'>Compute overview grid tile</h2><span id='topic+grd_tile_template'></span><span id='topic+grd_tile_summary'></span>

<h3>Description</h3>

<p>A useful workflow for raster data in a memory bounded environment is to
chunk a grid into sections or tiles. These functions compute tiles
suitable for such processing. Use <code><a href="#topic+grd_tile_summary">grd_tile_summary()</a></code> to generate
statistics for <code>level</code> values to choose for your application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grd_tile_template(grid, level)

grd_tile_summary(grid, levels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grd_tile_template_+3A_grid">grid</code></td>
<td>
<p>A <code><a href="#topic+grd_xy">grd_xy()</a></code>, <code><a href="#topic+grd_rct">grd_rct()</a></code>, or other object
implementing <code style="white-space: pre;">&#8288;grd_*()&#8288;</code> methods.</p>
</td></tr>
<tr><td><code id="grd_tile_template_+3A_level">level</code></td>
<td>
<p>An integer describing the overview level. This is related to
the <code>step</code> value by a power of 2 (i.e., a level of <code>1</code> indicates a step of
<code>2</code>, a level of <code>2</code> indicates a step of <code>4</code>, etc.).</p>
</td></tr>
<tr><td><code id="grd_tile_template_+3A_levels">levels</code></td>
<td>
<p>A vector of <code>level</code> values or <code>NULL</code> to use a sequence from
0 to the level that would result in a 1 x 1 grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+grd">grd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- grd_rct(volcano)
grd_tile_summary(grid)
grd_tile_template(grid, 3)

</code></pre>

<hr>
<h2 id='handle_wkt_without_vector_size'>Test handlers for handling of unknown size vectors</h2><span id='topic+handle_wkt_without_vector_size'></span>

<h3>Description</h3>

<p>Test handlers for handling of unknown size vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_wkt_without_vector_size(handleable, handler)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_wkt_without_vector_size_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="handle_wkt_without_vector_size_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>handle_wkt_without_vector_size(wkt(), wk_vector_meta_handler())

</code></pre>

<hr>
<h2 id='new_wk_crc'>S3 details for crc objects</h2><span id='topic+new_wk_crc'></span>

<h3>Description</h3>

<p>S3 details for crc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_wk_crc(x = list(x = double(), y = double(), r = double()), crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_wk_crc_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+crc">crc()</a></code></p>
</td></tr>
<tr><td><code id="new_wk_crc_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
</table>

<hr>
<h2 id='new_wk_grd'>S3 details for grid objects</h2><span id='topic+new_wk_grd'></span>

<h3>Description</h3>

<p>S3 details for grid objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_wk_grd(x, subclass = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_wk_grd_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+grd">grd()</a></code></p>
</td></tr>
<tr><td><code id="new_wk_grd_+3A_subclass">subclass</code></td>
<td>
<p>An optional subclass.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object inheriting from 'grd'
</p>

<hr>
<h2 id='new_wk_rct'>S3 details for rct objects</h2><span id='topic+new_wk_rct'></span>

<h3>Description</h3>

<p>S3 details for rct objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_wk_rct(
  x = list(xmin = double(), ymin = double(), xmax = double(), ymax = double()),
  crs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_wk_rct_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+rct">rct()</a></code></p>
</td></tr>
<tr><td><code id="new_wk_rct_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
</table>

<hr>
<h2 id='new_wk_wkb'>S3 Details for wk_wkb</h2><span id='topic+new_wk_wkb'></span><span id='topic+validate_wk_wkb'></span><span id='topic+is_wk_wkb'></span>

<h3>Description</h3>

<p>S3 Details for wk_wkb
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_wk_wkb(x = list(), crs = NULL, geodesic = NULL)

validate_wk_wkb(x)

is_wk_wkb(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_wk_wkb_+3A_x">x</code></td>
<td>
<p>A (possibly) <code><a href="#topic+wkb">wkb()</a></code> vector</p>
</td></tr>
<tr><td><code id="new_wk_wkb_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
<tr><td><code id="new_wk_wkb_+3A_geodesic">geodesic</code></td>
<td>
<p><code>TRUE</code> if edges must be interpolated as geodesics when
coordinates are spherical, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>

<hr>
<h2 id='new_wk_wkt'>S3 Details for wk_wkt</h2><span id='topic+new_wk_wkt'></span><span id='topic+is_wk_wkt'></span><span id='topic+validate_wk_wkt'></span>

<h3>Description</h3>

<p>S3 Details for wk_wkt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_wk_wkt(x = character(), crs = NULL, geodesic = NULL)

is_wk_wkt(x)

validate_wk_wkt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_wk_wkt_+3A_x">x</code></td>
<td>
<p>A (possibly) <code><a href="#topic+wkt">wkt()</a></code> vector</p>
</td></tr>
<tr><td><code id="new_wk_wkt_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
<tr><td><code id="new_wk_wkt_+3A_geodesic">geodesic</code></td>
<td>
<p><code>TRUE</code> if edges must be interpolated as geodesics when
coordinates are spherical, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>

<hr>
<h2 id='new_wk_xy'>S3 details for xy objects</h2><span id='topic+new_wk_xy'></span><span id='topic+new_wk_xyz'></span><span id='topic+new_wk_xym'></span><span id='topic+new_wk_xyzm'></span><span id='topic+validate_wk_xy'></span><span id='topic+validate_wk_xyz'></span><span id='topic+validate_wk_xym'></span><span id='topic+validate_wk_xyzm'></span>

<h3>Description</h3>

<p>S3 details for xy objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_wk_xy(x = list(x = double(), y = double()), crs = NULL)

new_wk_xyz(x = list(x = double(), y = double(), z = double()), crs = NULL)

new_wk_xym(x = list(x = double(), y = double(), m = double()), crs = NULL)

new_wk_xyzm(
  x = list(x = double(), y = double(), z = double(), m = double()),
  crs = NULL
)

validate_wk_xy(x)

validate_wk_xyz(x)

validate_wk_xym(x)

validate_wk_xyzm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_wk_xy_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+xy">xy()</a></code> object.</p>
</td></tr>
<tr><td><code id="new_wk_xy_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.wk_grd_xy'>Plot grid objects</h2><span id='topic+plot.wk_grd_xy'></span><span id='topic+plot.wk_grd_rct'></span>

<h3>Description</h3>

<p>Plot grid objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wk_grd_xy'
plot(x, ...)

## S3 method for class 'wk_grd_rct'
plot(
  x,
  ...,
  image = NULL,
  interpolate = FALSE,
  oversample = 4,
  border = NA,
  asp = 1,
  bbox = NULL,
  xlab = "",
  ylab = "",
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.wk_grd_xy_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+wkb">wkb()</a></code> or <code><a href="#topic+wkt">wkt()</a></code></p>
</td></tr>
<tr><td><code id="plot.wk_grd_xy_+3A_...">...</code></td>
<td>
<p>Passed to plotting functions for features: <code><a href="graphics.html#topic+points">graphics::points()</a></code>
for point and multipoint geometries, <code><a href="graphics.html#topic+lines">graphics::lines()</a></code> for linestring
and multilinestring geometries, and <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code> for polygon
and multipolygon geometries.</p>
</td></tr>
<tr><td><code id="plot.wk_grd_xy_+3A_image">image</code></td>
<td>
<p>A raster or nativeRaster to pass to <code><a href="graphics.html#topic+rasterImage">graphics::rasterImage()</a></code>.
use <code>NULL</code> to do a quick-and-dirty rescale of the data such that the low
value is black and the high value is white.</p>
</td></tr>
<tr><td><code id="plot.wk_grd_xy_+3A_interpolate">interpolate</code></td>
<td>
<p>Use <code>TRUE</code> to perform interpolation between color values.</p>
</td></tr>
<tr><td><code id="plot.wk_grd_xy_+3A_oversample">oversample</code></td>
<td>
<p>A scale on the number of pixels on the device to use for
sampling estimation of large raster values. Use <code>Inf</code> to disable.</p>
</td></tr>
<tr><td><code id="plot.wk_grd_xy_+3A_border">border</code></td>
<td>
<p>Color to use for polygon borders. Use <code>NULL</code> for the default
and <code>NA</code> to skip plotting borders.</p>
</td></tr>
<tr><td><code id="plot.wk_grd_xy_+3A_asp">asp</code>, <code id="plot.wk_grd_xy_+3A_xlab">xlab</code>, <code id="plot.wk_grd_xy_+3A_ylab">ylab</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code></p>
</td></tr>
<tr><td><code id="plot.wk_grd_xy_+3A_bbox">bbox</code></td>
<td>
<p>The limits of the plot as a <code><a href="#topic+rct">rct()</a></code> or compatible object</p>
</td></tr>
<tr><td><code id="plot.wk_grd_xy_+3A_add">add</code></td>
<td>
<p>Should a new plot be created, or should <code>handleable</code> be added to the
existing plot?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(grd_rct(volcano))
plot(grd_xy(volcano))

</code></pre>

<hr>
<h2 id='rct'>2D rectangle vectors</h2><span id='topic+rct'></span><span id='topic+as_rct'></span><span id='topic+as_rct.wk_rct'></span><span id='topic+as_rct.matrix'></span><span id='topic+as_rct.data.frame'></span>

<h3>Description</h3>

<p>2D rectangle vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rct(
  xmin = double(),
  ymin = double(),
  xmax = double(),
  ymax = double(),
  crs = wk_crs_auto()
)

as_rct(x, ...)

## S3 method for class 'wk_rct'
as_rct(x, ...)

## S3 method for class 'matrix'
as_rct(x, ..., crs = NULL)

## S3 method for class 'data.frame'
as_rct(x, ..., crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rct_+3A_xmin">xmin</code>, <code id="rct_+3A_ymin">ymin</code>, <code id="rct_+3A_xmax">xmax</code>, <code id="rct_+3A_ymax">ymax</code></td>
<td>
<p>Rectangle bounds.</p>
</td></tr>
<tr><td><code id="rct_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
<tr><td><code id="rct_+3A_x">x</code></td>
<td>
<p>An object to be converted to a <code><a href="#topic+rct">rct()</a></code>.</p>
</td></tr>
<tr><td><code id="rct_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>as_rct()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector along the recycled length of bounds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rct(1, 2, 3, 4)

</code></pre>

<hr>
<h2 id='rct_xmin'>Rectangle accessors and operators</h2><span id='topic+rct_xmin'></span><span id='topic+rct_ymin'></span><span id='topic+rct_xmax'></span><span id='topic+rct_ymax'></span><span id='topic+rct_width'></span><span id='topic+rct_height'></span><span id='topic+rct_intersects'></span><span id='topic+rct_contains'></span><span id='topic+rct_intersection'></span>

<h3>Description</h3>

<p>Rectangle accessors and operators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rct_xmin(x)

rct_ymin(x)

rct_xmax(x)

rct_ymax(x)

rct_width(x)

rct_height(x)

rct_intersects(x, y)

rct_contains(x, y)

rct_intersection(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rct_xmin_+3A_x">x</code>, <code id="rct_xmin_+3A_y">y</code></td>
<td>
<p><code><a href="#topic+rct">rct()</a></code> vectors</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>rct_xmin()</code>, <code>rct_xmax()</code>, <code>rct_ymin()</code>, and <code>rct_ymax()</code> return
the components of the <code><a href="#topic+rct">rct()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rct(0, 0, 10, 10)
y &lt;- rct(5, 5, 15, 15)

rct_xmin(x)
rct_ymin(x)
rct_xmax(x)
rct_ymax(x)
rct_height(x)
rct_width(x)
rct_intersects(x, y)
rct_intersection(x, y)
rct_contains(x, y)
rct_contains(x, rct(4, 4, 6, 6))

</code></pre>

<hr>
<h2 id='vctrs-methods'>Vctrs methods</h2><span id='topic+vctrs-methods'></span><span id='topic+vec_cast.wk_wkb'></span><span id='topic+vec_ptype2.wk_wkb'></span><span id='topic+vec_cast.wk_wkt'></span><span id='topic+vec_ptype2.wk_wkt'></span><span id='topic+vec_cast.wk_xy'></span><span id='topic+vec_ptype2.wk_xy'></span><span id='topic+vec_cast.wk_xyz'></span><span id='topic+vec_ptype2.wk_xyz'></span><span id='topic+vec_cast.wk_xym'></span><span id='topic+vec_ptype2.wk_xym'></span><span id='topic+vec_cast.wk_xyzm'></span><span id='topic+vec_ptype2.wk_xyzm'></span><span id='topic+vec_cast.wk_rct'></span><span id='topic+vec_ptype2.wk_rct'></span><span id='topic+vec_cast.wk_crc'></span><span id='topic+vec_ptype2.wk_crc'></span>

<h3>Description</h3>

<p>Vctrs methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_cast.wk_wkb(x, to, ...)

vec_ptype2.wk_wkb(x, y, ...)

vec_cast.wk_wkt(x, to, ...)

vec_ptype2.wk_wkt(x, y, ...)

vec_cast.wk_xy(x, to, ...)

vec_ptype2.wk_xy(x, y, ...)

vec_cast.wk_xyz(x, to, ...)

vec_ptype2.wk_xyz(x, y, ...)

vec_cast.wk_xym(x, to, ...)

vec_ptype2.wk_xym(x, y, ...)

vec_cast.wk_xyzm(x, to, ...)

vec_ptype2.wk_xyzm(x, y, ...)

vec_cast.wk_rct(x, to, ...)

vec_ptype2.wk_rct(x, y, ...)

vec_cast.wk_crc(x, to, ...)

vec_ptype2.wk_crc(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vctrs-methods_+3A_x">x</code>, <code id="vctrs-methods_+3A_y">y</code>, <code id="vctrs-methods_+3A_to">to</code>, <code id="vctrs-methods_+3A_...">...</code></td>
<td>
<p>See <code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code> and <code><a href="vctrs.html#topic+vec_ptype2">vctrs::vec_ptype2()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='wk_bbox'>2D bounding rectangles</h2><span id='topic+wk_bbox'></span><span id='topic+wk_envelope'></span><span id='topic+wk_bbox.default'></span><span id='topic+wk_envelope.default'></span><span id='topic+wk_envelope.wk_rct'></span><span id='topic+wk_envelope.wk_crc'></span><span id='topic+wk_envelope.wk_xy'></span><span id='topic+wk_bbox_handler'></span><span id='topic+wk_envelope_handler'></span>

<h3>Description</h3>

<p>2D bounding rectangles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_bbox(handleable, ...)

wk_envelope(handleable, ...)

## Default S3 method:
wk_bbox(handleable, ...)

## Default S3 method:
wk_envelope(handleable, ...)

## S3 method for class 'wk_rct'
wk_envelope(handleable, ...)

## S3 method for class 'wk_crc'
wk_envelope(handleable, ...)

## S3 method for class 'wk_xy'
wk_envelope(handleable, ...)

wk_bbox_handler()

wk_envelope_handler()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_bbox_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_bbox_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+rct">rct()</a></code> of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_bbox(wkt("LINESTRING (1 2, 3 5)"))

</code></pre>

<hr>
<h2 id='wk_chunk_strategy_single'>Chunking strategies</h2><span id='topic+wk_chunk_strategy_single'></span><span id='topic+wk_chunk_strategy_feature'></span><span id='topic+wk_chunk_strategy_coordinates'></span>

<h3>Description</h3>

<p>It is often impractical, inefficient, or impossible to perform
an operation on a vector of geometries with all the geometries loaded
into memory at the same time. These functions help generalize the
pattern of split-apply-combine to one or more handlers recycled along a
common length. These functions are designed for developers rather than users
and should be considered experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_chunk_strategy_single()

wk_chunk_strategy_feature(n_chunks = NULL, chunk_size = NULL)

wk_chunk_strategy_coordinates(n_chunks = NULL, chunk_size = NULL, reduce = "*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_chunk_strategy_single_+3A_n_chunks">n_chunks</code>, <code id="wk_chunk_strategy_single_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Exactly one of the number of
chunks or the chunk size. For <code><a href="#topic+wk_chunk_strategy_feature">wk_chunk_strategy_feature()</a></code>
the chunk size refers to the number of features; for
<code><a href="#topic+wk_chunk_strategy_coordinates">wk_chunk_strategy_coordinates()</a></code> this refers to the number
of coordinates as calculated from multiple handleables
using <code>reduce</code>.</p>
</td></tr>
<tr><td><code id="wk_chunk_strategy_single_+3A_reduce">reduce</code></td>
<td>
<p>For <code><a href="#topic+wk_chunk_strategy_coordinates">wk_chunk_strategy_coordinates()</a></code> this refers to
the function used with <code><a href="base.html#topic+Reduce">Reduce()</a></code> to combine coordinate counts
from more than one handleable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that returns a <code>data.frame</code> with columns <code>from</code> and <code>to</code>
when called with a <code>handleable</code> and the feature count.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>feat &lt;- c(as_wkt(xy(1:4, 1:4)), wkt("LINESTRING (1 1, 2 2)"))
wk_chunk_strategy_single()(list(feat), 5)
wk_chunk_strategy_feature(chunk_size = 2)(list(feat), 5)
wk_chunk_strategy_coordinates(chunk_size = 2)(list(feat), 5)

</code></pre>

<hr>
<h2 id='wk_count'>Count geometry components</h2><span id='topic+wk_count'></span><span id='topic+wk_count.default'></span><span id='topic+wk_count_handler'></span>

<h3>Description</h3>

<p>Counts the number of geometries, rings, and coordinates found within
each feature. As opposed to <code><a href="#topic+wk_meta">wk_meta()</a></code>, this handler will iterate
over the entire geometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_count(handleable, ...)

## Default S3 method:
wk_count(handleable, ...)

wk_count_handler()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_count_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_count_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one row for every feature encountered and
columns:
</p>

<ul>
<li> <p><code>n_geom</code>: The number of geometries encountered, including the
root geometry. Will be zero for a null feature.
</p>
</li>
<li> <p><code>n_ring</code>: The number of rings encountered. Will be zero for a
null feature.
</p>
</li>
<li> <p><code>n_coord</code>: The number of coordinates encountered. Will be zero
for a null feature.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>wk_count(as_wkt("LINESTRING (0 0, 1 1)"))
wk_count(as_wkb("LINESTRING (0 0, 1 1)"))

</code></pre>

<hr>
<h2 id='wk_crs'>Set and get vector CRS</h2><span id='topic+wk_crs'></span><span id='topic+wk_crs.wk_vctr'></span><span id='topic+wk_crs.wk_rcrd'></span><span id='topic+wk_crs+3C-'></span><span id='topic+wk_set_crs'></span><span id='topic+wk_crs_output'></span><span id='topic+wk_is_geodesic_output'></span>

<h3>Description</h3>

<p>The wk package doesn't operate on CRS objects, but does propagate them
through subsetting and concatenation. A CRS object can be any R object,
and x can be any object whose 'crs' attribute carries a CRS. These functions
are S3 generics to keep them from being used
on objects that do not use this system of CRS propagation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_crs(x)

## S3 method for class 'wk_vctr'
wk_crs(x)

## S3 method for class 'wk_rcrd'
wk_crs(x)

wk_crs(x) &lt;- value

wk_set_crs(x, crs)

wk_crs_output(...)

wk_is_geodesic_output(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_crs_+3A_x">x</code>, <code id="wk_crs_+3A_...">...</code></td>
<td>
<p>Objects whose &quot;crs&quot; attribute is used to carry a CRS.</p>
</td></tr>
<tr><td><code id="wk_crs_+3A_value">value</code></td>
<td>
<p>See <code>crs</code>.</p>
</td></tr>
<tr><td><code id="wk_crs_+3A_crs">crs</code></td>
<td>
<p>An object that can be interpreted as a CRS</p>
</td></tr>
</table>

<hr>
<h2 id='wk_crs_equal'>Compare CRS objects</h2><span id='topic+wk_crs_equal'></span><span id='topic+wk_crs_equal_generic'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+wk_crs_equal">wk_crs_equal()</a></code> function uses special S3 dispatch on <code><a href="#topic+wk_crs_equal_generic">wk_crs_equal_generic()</a></code>
to evaluate whether or not two CRS values can be considered equal. When implementing
<code><a href="#topic+wk_crs_equal_generic">wk_crs_equal_generic()</a></code>, every attempt should be made to make <code>wk_crs_equal(x, y)</code>
and <code>wk_crs_equal(y, x)</code> return identically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_crs_equal(x, y)

wk_crs_equal_generic(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_crs_equal_+3A_x">x</code>, <code id="wk_crs_equal_+3A_y">y</code></td>
<td>
<p>Objects stored in the <code>crs</code> attribute of a vector.</p>
</td></tr>
<tr><td><code id="wk_crs_equal_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> and <code>y</code> can be considered equal, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='wk_crs_inherit'>Special CRS values</h2><span id='topic+wk_crs_inherit'></span><span id='topic+wk_crs_longlat'></span><span id='topic+wk_crs_auto'></span><span id='topic+wk_crs_auto_value'></span>

<h3>Description</h3>

<p>The CRS handling in the wk package requires two sentinel CRS values.
The first, <code><a href="#topic+wk_crs_inherit">wk_crs_inherit()</a></code>, signals that the vector should inherit
a CRS of another vector if combined. This is useful for empty, <code>NULL</code>,
and/or zero-length geometries. The second, <code><a href="#topic+wk_crs_auto">wk_crs_auto()</a></code>, is used
as the default argument of <code>crs</code> for constructors so that zero-length
geometries are assigned a CRS of <code>wk_crs_inherit()</code> by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_crs_inherit()

wk_crs_longlat(crs = NULL)

wk_crs_auto()

wk_crs_auto_value(x, crs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_crs_inherit_+3A_crs">crs</code></td>
<td>
<p>A value for the coordinate reference system supplied by
the user.</p>
</td></tr>
<tr><td><code id="wk_crs_inherit_+3A_x">x</code></td>
<td>
<p>A raw input to a construuctor whose length and crs attributte
is used to determine the default CRS returned by <code><a href="#topic+wk_crs_auto">wk_crs_auto()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>wk_crs_auto_value(list(), wk_crs_auto())
wk_crs_auto_value(list(), 1234)
wk_crs_auto_value(list(NULL), wk_crs_auto())

</code></pre>

<hr>
<h2 id='wk_crs_proj_definition'>CRS object generic methods</h2><span id='topic+wk_crs_proj_definition'></span><span id='topic+wk_crs_projjson'></span><span id='topic+wk_crs_proj_definition.NULL'></span><span id='topic+wk_crs_proj_definition.wk_crs_inherit'></span><span id='topic+wk_crs_proj_definition.character'></span><span id='topic+wk_crs_proj_definition.double'></span><span id='topic+wk_crs_proj_definition.integer'></span>

<h3>Description</h3>

<p>CRS object generic methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_crs_proj_definition(crs, proj_version = NULL, verbose = FALSE)

wk_crs_projjson(crs)

## S3 method for class ''NULL''
wk_crs_proj_definition(crs, proj_version = NULL, verbose = FALSE)

## S3 method for class 'wk_crs_inherit'
wk_crs_proj_definition(crs, proj_version = NULL, verbose = FALSE)

## S3 method for class 'character'
wk_crs_proj_definition(crs, proj_version = NULL, verbose = FALSE)

## S3 method for class 'double'
wk_crs_proj_definition(crs, proj_version = NULL, verbose = FALSE)

## S3 method for class 'integer'
wk_crs_proj_definition(crs, proj_version = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_crs_proj_definition_+3A_crs">crs</code></td>
<td>
<p>An arbitrary R object</p>
</td></tr>
<tr><td><code id="wk_crs_proj_definition_+3A_proj_version">proj_version</code></td>
<td>
<p>A <code><a href="base.html#topic+package_version">package_version()</a></code> of the PROJ version, or
<code>NULL</code> if the PROJ version is unknown.</p>
</td></tr>
<tr><td><code id="wk_crs_proj_definition_+3A_verbose">verbose</code></td>
<td>
<p>Use <code>TRUE</code> to request a more verbose version of the
PROJ definition (e.g., PROJJSON). The default of <code>FALSE</code> should return
the most compact version that completely describes the CRS. An
authority:code string (e.g., &quot;OGC:CRS84&quot;) is the recommended way
to represent a CRS when <code>verbose</code> is <code>FALSE</code>, if possible, falling
back to the most recent version of WKT2 or PROJJSON.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>wk_crs_proj_definition()</code> Returns a string used to represent the
CRS in PROJ. For recent PROJ version you'll want to return PROJJSON;
however you should check <code>proj_version</code> if you want this to work with
older versions of PROJ.
</p>
</li>
<li> <p><code>wk_crs_projjson()</code> Returns a PROJJSON string or NA_character_ if this
representation is unknown or can't be calculated.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>wk_crs_proj_definition("EPSG:4326")

</code></pre>

<hr>
<h2 id='wk_debug'>Debug filters and handlers</h2><span id='topic+wk_debug'></span><span id='topic+wk_debug_filter'></span>

<h3>Description</h3>

<p>Debug filters and handlers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_debug(handleable, handler = wk_void_handler(), ...)

wk_debug_filter(handler = wk_void_handler())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_debug_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_debug_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk_debug_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the <code>handler</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_debug(wkt("POINT (1 1)"))
wk_handle(wkt("POINT (1 1)"), wk_debug_filter())

</code></pre>

<hr>
<h2 id='wk_example'>Create example geometry objects</h2><span id='topic+wk_example'></span><span id='topic+wk_example_wkt'></span>

<h3>Description</h3>

<p>Create example geometry objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_example(which = "nc", crs = NA, geodesic = FALSE)

wk_example_wkt
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_example_+3A_which">which</code></td>
<td>
<p>An example name. Valid example names are
</p>

<ul>
<li><p> &quot;nc&quot; (data derived from the sf package)
</p>
</li>
<li><p> &quot;point&quot;, &quot;linestring&quot;, &quot;polygon&quot;, &quot;multipoint&quot;,
&quot;multilinestring&quot;, &quot;multipolygon&quot;, &quot;geometrycollection&quot;
</p>
</li>
<li><p> One of the above with the &quot;_z&quot;, &quot;_m&quot;, or &quot;_zm&quot; suffix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="wk_example_+3A_crs">crs</code></td>
<td>
<p>An object that can be interpreted as a CRS</p>
</td></tr>
<tr><td><code id="wk_example_+3A_geodesic">geodesic</code></td>
<td>
<p><code>TRUE</code> if edges must be interpolated as geodesics when
coordinates are spherical, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 29.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+wkt">wkt()</a></code> with the specified example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_example("polygon")

</code></pre>

<hr>
<h2 id='wk_flatten'>Extract simple geometries</h2><span id='topic+wk_flatten'></span><span id='topic+wk_flatten_filter'></span>

<h3>Description</h3>

<p>Extract simple geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_flatten(handleable, ..., max_depth = 1)

wk_flatten_filter(handler, max_depth = 1L, add_details = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_flatten_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_flatten_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_flatten_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum (outer) depth to remove.</p>
</td></tr>
<tr><td><code id="wk_flatten_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk_flatten_+3A_add_details">add_details</code></td>
<td>
<p>Use <code>TRUE</code> to add a &quot;wk_details&quot; attribute, which
contains columns <code>feature_id</code>, <code>part_id</code>, and <code>ring_id</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>handleable</code> transformed such that collections have been
expanded and only simple geometries (point, linestring, polygon)
remain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_flatten(wkt("MULTIPOINT (1 1, 2 2, 3 3)"))
wk_flatten(
  wkt("GEOMETRYCOLLECTION (GEOMETRYCOLLECTION (GEOMETRYCOLLECTION (POINT (0 1))))"),
  max_depth = 2
)

</code></pre>

<hr>
<h2 id='wk_format'>Format well-known geometry for printing</h2><span id='topic+wk_format'></span><span id='topic+wkt_format_handler'></span>

<h3>Description</h3>

<p>Provides an abbreviated version of the well-known text
representation of a geometry. This returns a constant
number of coordinates for each geometry, so is safe to
use for geometry vectors with many (potentially large)
features. Parse errors are passed on to the format string
and do not cause this handler to error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_format(handleable, precision = 7, trim = TRUE, max_coords = 6, ...)

wkt_format_handler(precision = 7, trim = TRUE, max_coords = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_format_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_format_+3A_precision">precision</code></td>
<td>
<p>If <code>trim</code> is <code>TRUE</code>, the total number of significant digits to keep
for each result or the number of digits after the decimal place otherwise.</p>
</td></tr>
<tr><td><code id="wk_format_+3A_trim">trim</code></td>
<td>
<p>Use <code>FALSE</code> to keep trailing zeroes after the decimal place.</p>
</td></tr>
<tr><td><code id="wk_format_+3A_max_coords">max_coords</code></td>
<td>
<p>The maximum number of coordinates to include
in the output.</p>
</td></tr>
<tr><td><code id="wk_format_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of abbreviated well-known text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_format(wkt("MULTIPOLYGON (((0 0, 10 0, 0 10, 0 0)))"))
wk_format(new_wk_wkt("POINT ENTPY"))
wk_handle(
  wkt("MULTIPOLYGON (((0 0, 10 0, 0 10, 0 0)))"),
  wkt_format_handler()
)

</code></pre>

<hr>
<h2 id='wk_handle_slice.data.frame'>Handle specific regions of objects</h2><span id='topic+wk_handle_slice.data.frame'></span><span id='topic+wk_handle_slice'></span><span id='topic+wk_handle_slice.default'></span>

<h3>Description</h3>

<p>Handle specific regions of objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
wk_handle_slice(handleable, handler, from = NULL, to = NULL, ...)

wk_handle_slice(
  handleable,
  handler = wk_writer(handleable),
  from = NULL,
  to = NULL,
  ...
)

## Default S3 method:
wk_handle_slice(
  handleable,
  handler = wk_writer(handleable),
  from = NULL,
  to = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_handle_slice.data.frame_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_handle_slice.data.frame_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk_handle_slice.data.frame_+3A_from">from</code></td>
<td>
<p>1-based index of the feature to start from</p>
</td></tr>
<tr><td><code id="wk_handle_slice.data.frame_+3A_to">to</code></td>
<td>
<p>1-based index of the feature to end at</p>
</td></tr>
<tr><td><code id="wk_handle_slice.data.frame_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of <code>handleable</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_handle_slice(xy(1:5, 1:5), wkt_writer(), from = 3, to = 5)
wk_handle_slice(
  data.frame(let = letters[1:5], geom = xy(1:5, 1:5)),
  wkt_writer(),
  from = 3, to = 5
)

</code></pre>

<hr>
<h2 id='wk_handle.data.frame'>Use data.frame with wk</h2><span id='topic+wk_handle.data.frame'></span><span id='topic+wk_restore.data.frame'></span><span id='topic+wk_restore.tbl_df'></span><span id='topic+wk_translate.data.frame'></span><span id='topic+wk_translate.tbl_df'></span><span id='topic+wk_translate.sf'></span><span id='topic+wk_restore.sf'></span>

<h3>Description</h3>

<p>Use data.frame with wk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
wk_handle(handleable, handler, ...)

## S3 method for class 'data.frame'
wk_restore(handleable, result, ...)

## S3 method for class 'tbl_df'
wk_restore(handleable, result, ...)

## S3 method for class 'data.frame'
wk_translate(handleable, to, ...)

## S3 method for class 'tbl_df'
wk_translate(handleable, to, ...)

## S3 method for class 'sf'
wk_translate(handleable, to, ...)

## S3 method for class 'sf'
wk_restore(handleable, result, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_handle.data.frame_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_handle.data.frame_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk_handle.data.frame_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_handle.data.frame_+3A_result">result</code></td>
<td>
<p>The result of a filter operation intended to be a
transformation.</p>
</td></tr>
<tr><td><code id="wk_handle.data.frame_+3A_to">to</code></td>
<td>
<p>A prototype object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>wk_handle(data.frame(a = wkt("POINT (0 1)")), wkb_writer())
wk_translate(wkt("POINT (0 1)"), data.frame(col_name = wkb()))
wk_translate(data.frame(a = wkt("POINT (0 1)")), data.frame(wkb()))

</code></pre>

<hr>
<h2 id='wk_handle.wk_crc'>Read geometry vectors</h2><span id='topic+wk_handle.wk_crc'></span><span id='topic+wk_handle.wk_rct'></span><span id='topic+wk_handle.sfc'></span><span id='topic+wk_handle.wk_wkb'></span><span id='topic+wk_handle.wk_wkt'></span><span id='topic+wk_handle.wk_xy'></span><span id='topic+wk_handle'></span><span id='topic+is_handleable'></span><span id='topic+new_wk_handler'></span><span id='topic+is_wk_handler'></span><span id='topic+as_wk_handler'></span><span id='topic+wk_handle.sfg'></span><span id='topic+wk_handle.sf'></span><span id='topic+wk_handle.bbox'></span>

<h3>Description</h3>

<p>The handler is the basic building block of the wk package. In
particular, the <code><a href="#topic+wk_handle">wk_handle()</a></code> generic allows operations written
as handlers to &quot;just work&quot; with many different input types. The
wk package provides the <code><a href="#topic+wk_void">wk_void()</a></code> handler, the <code><a href="#topic+wk_format">wk_format()</a></code>
handler, the <code><a href="#topic+wk_debug">wk_debug()</a></code> handler, the <code><a href="#topic+wk_problems">wk_problems()</a></code> handler,
and <code><a href="#topic+wk_writer">wk_writer()</a></code>s for <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>, and <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>)
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wk_crc'
wk_handle(
  handleable,
  handler,
  ...,
  n_segments = getOption("wk.crc_n_segments", NULL),
  resolution = getOption("wk.crc_resolution", NULL)
)

## S3 method for class 'wk_rct'
wk_handle(handleable, handler, ...)

## S3 method for class 'sfc'
wk_handle(handleable, handler, ...)

## S3 method for class 'wk_wkb'
wk_handle(handleable, handler, ...)

## S3 method for class 'wk_wkt'
wk_handle(handleable, handler, ...)

## S3 method for class 'wk_xy'
wk_handle(handleable, handler, ...)

wk_handle(handleable, handler, ...)

is_handleable(handleable)

new_wk_handler(handler_ptr, subclass = character())

is_wk_handler(handler)

as_wk_handler(handler, ...)

## S3 method for class 'sfg'
wk_handle(handleable, handler, ...)

## S3 method for class 'sf'
wk_handle(handleable, handler, ...)

## S3 method for class 'bbox'
wk_handle(handleable, handler, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_handle.wk_crc_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_handle.wk_crc_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk_handle.wk_crc_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_handle.wk_crc_+3A_n_segments">n_segments</code>, <code id="wk_handle.wk_crc_+3A_resolution">resolution</code></td>
<td>
<p>The number of segments to use when approximating
a circle. The default uses <code>getOption("wk.crc_n_segments")</code> so that
this value can be set for implicit conversions (e.g., <code>as_wkb()</code>).
Alternatively, set the minimum distance between points on the circle
(used to estimate <code>n_segments</code>). The default is obtained
using <code>getOption("wk.crc_resolution")</code>.</p>
</td></tr>
<tr><td><code id="wk_handle.wk_crc_+3A_handler_ptr">handler_ptr</code></td>
<td>
<p>An external pointer to a newly created WK handler</p>
</td></tr>
<tr><td><code id="wk_handle.wk_crc_+3A_subclass">subclass</code></td>
<td>
<p>The handler subclass</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A WK handler.
</p>

<hr>
<h2 id='wk_handle.wk_grd_xy'>Handler interface for grid objects</h2><span id='topic+wk_handle.wk_grd_xy'></span><span id='topic+wk_handle.wk_grd_rct'></span>

<h3>Description</h3>

<p>Handler interface for grid objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wk_grd_xy'
wk_handle(handleable, handler, ..., data_order = c("y", "x"))

## S3 method for class 'wk_grd_rct'
wk_handle(handleable, handler, ..., data_order = c("y", "x"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_handle.wk_grd_xy_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_handle.wk_grd_xy_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk_handle.wk_grd_xy_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_handle.wk_grd_xy_+3A_data_order">data_order</code></td>
<td>
<p>A vector of length 2 describing the order in which
values should appear. The default, <code>c("y", "x")</code>, will output values
in the same order as the default matrix storage in R (column-major).
You can prefix a dimension with <code>-</code> to reverse the order of a
dimension (e.g., <code>c("-y", "x")</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the <code>handler</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_handle(grd(nx = 3, ny = 3), wkt_writer())
wk_handle(grd(nx = 3, ny = 3, type = "centers"), wkt_writer())

</code></pre>

<hr>
<h2 id='wk_identity'>Copy a geometry vector</h2><span id='topic+wk_identity'></span><span id='topic+wk_identity_filter'></span><span id='topic+wk_restore'></span><span id='topic+wk_restore.default'></span>

<h3>Description</h3>

<p>Copy a geometry vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_identity(handleable, ...)

wk_identity_filter(handler)

wk_restore(handleable, result, ...)

## Default S3 method:
wk_restore(handleable, result, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_identity_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_identity_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_identity_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk_identity_+3A_result">result</code></td>
<td>
<p>The result of a filter operation intended to be a
transformation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>handleable</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_identity(wkt("POINT (1 2)"))

</code></pre>

<hr>
<h2 id='wk_is_geodesic'>Set and get vector geodesic edge interpolation</h2><span id='topic+wk_is_geodesic'></span><span id='topic+wk_set_geodesic'></span><span id='topic+wk_is_geodesic+3C-'></span><span id='topic+wk_geodesic_inherit'></span>

<h3>Description</h3>

<p>Set and get vector geodesic edge interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_is_geodesic(x)

wk_set_geodesic(x, geodesic)

wk_is_geodesic(x) &lt;- value

wk_geodesic_inherit()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_is_geodesic_+3A_x">x</code></td>
<td>
<p>An R object that contains edges</p>
</td></tr>
<tr><td><code id="wk_is_geodesic_+3A_geodesic">geodesic</code></td>
<td>
<p><code>TRUE</code> if edges must be interpolated as geodesics when
coordinates are spherical, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="wk_is_geodesic_+3A_value">value</code></td>
<td>
<p>See <code>geodesic</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if edges must be interpolated as geodesics when
coordinates are spherical, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='wk_linestring'>Create lines, polygons, and collections</h2><span id='topic+wk_linestring'></span><span id='topic+wk_polygon'></span><span id='topic+wk_collection'></span><span id='topic+wk_linestring_filter'></span><span id='topic+wk_polygon_filter'></span><span id='topic+wk_collection_filter'></span>

<h3>Description</h3>

<p>Create lines, polygons, and collections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_linestring(handleable, feature_id = 1L, ..., geodesic = NULL)

wk_polygon(handleable, feature_id = 1L, ring_id = 1L, ..., geodesic = NULL)

wk_collection(
  handleable,
  geometry_type = wk_geometry_type("geometrycollection"),
  feature_id = 1L,
  ...
)

wk_linestring_filter(handler, feature_id = 1L)

wk_polygon_filter(handler, feature_id = 1L, ring_id = 1L)

wk_collection_filter(
  handler,
  geometry_type = wk_geometry_type("geometrycollection"),
  feature_id = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_linestring_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_linestring_+3A_feature_id">feature_id</code></td>
<td>
<p>An identifier where changes in sequential
values indicate a new feature. This is recycled silently
as needed.</p>
</td></tr>
<tr><td><code id="wk_linestring_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_linestring_+3A_geodesic">geodesic</code></td>
<td>
<p>Use <code>TRUE</code> or <code>FALSE</code> to explicitly force
the geodesic-ness of the output.</p>
</td></tr>
<tr><td><code id="wk_linestring_+3A_ring_id">ring_id</code></td>
<td>
<p>An identifier where changes in sequential
values indicate a new ring. Rings are automatically
closed. This is recycled silently as needed.</p>
</td></tr>
<tr><td><code id="wk_linestring_+3A_geometry_type">geometry_type</code></td>
<td>
<p>The collection type to create.</p>
</td></tr>
<tr><td><code id="wk_linestring_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>handleable</code> with
whose coordinates have been assembled into the given
type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_linestring(xy(c(1, 1), c(2, 3)))
wk_polygon(xy(c(0, 1, 0), c(0, 0, 1)))
wk_collection(xy(c(1, 1), c(2, 3)))

</code></pre>

<hr>
<h2 id='wk_meta'>Extract feature-level meta</h2><span id='topic+wk_meta'></span><span id='topic+wk_meta.default'></span><span id='topic+wk_vector_meta'></span><span id='topic+wk_vector_meta.default'></span><span id='topic+wk_meta_handler'></span><span id='topic+wk_vector_meta_handler'></span><span id='topic+wk_geometry_type_label'></span><span id='topic+wk_geometry_type'></span>

<h3>Description</h3>

<p>These functions return the non-coordinate information of a geometry
and/or vector. They do not parse an entire geometry/vector and are
intended to be very fast even for large vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_meta(handleable, ...)

## Default S3 method:
wk_meta(handleable, ...)

wk_vector_meta(handleable, ...)

## Default S3 method:
wk_vector_meta(handleable, ...)

wk_meta_handler()

wk_vector_meta_handler()

wk_geometry_type_label(geometry_type)

wk_geometry_type(geometry_type_label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_meta_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_meta_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_meta_+3A_geometry_type">geometry_type</code></td>
<td>
<p>An integer code for the geometry type. These
integers follow the WKB specification (e.g., 1 for point,
7 for geometrycollection).</p>
</td></tr>
<tr><td><code id="wk_meta_+3A_geometry_type_label">geometry_type_label</code></td>
<td>
<p>A character vector of (lowercase)
geometry type labels as would be found in WKT (e.g., point,
geometrycollection).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns:
</p>

<ul>
<li> <p><code>geometry_type</code>: An integer identifying the geometry type.
A value of 0 indicates that the types of geometry in the vector
are not known without parsing the entire vector.
</p>
</li>
<li> <p><code>size</code>: For points and linestrings, the number of coordinates; for
polygons, the number of rings; for collections, the number of
child geometries. A value of zero indicates an EMPTY geometry.
A value of <code>NA</code> means this value is unknown without parsing the
entire geometry.
</p>
</li>
<li> <p><code>has_z</code>: <code>TRUE</code> if coordinates contain a Z value. A value of <code>NA</code>
means this value is unknown without parsing the entire vector.
</p>
</li>
<li> <p><code>has_m</code>: <code>TRUE</code> if coordinates contain an M value. A value of <code>NA</code>
means this value is unknown without parsing the entire vector.
</p>
</li>
<li> <p><code>srid</code>: An integer identifying a CRS or NA if this value was not
provided.
</p>
</li>
<li> <p><code>precision</code>: A grid size or 0.0 if a grid size was not provided.
Note that coordinate values may not have been rounded; the grid
size only refers to the level of detail with which they should
be interpreted.
</p>
</li>
<li> <p><code>is_empty</code>: <code>TRUE</code> if there is at least one non-empty coordinate.
For the purposes of this value, a non-empty coordinate is one that
contains at least one value that is not <code>NA</code> or <code>NaN</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>wk_vector_meta(as_wkt("LINESTRING (0 0, 1 1)"))
wk_meta(as_wkt("LINESTRING (0 0, 1 1)"))
wk_meta(as_wkb("LINESTRING (0 0, 1 1)"))

wk_geometry_type_label(1:7)
wk_geometry_type(c("point", "geometrycollection"))

</code></pre>

<hr>
<h2 id='wk_orient'>Orient polygon coordinates</h2><span id='topic+wk_orient'></span><span id='topic+wk_orient_filter'></span><span id='topic+wk_clockwise'></span><span id='topic+wk_counterclockwise'></span>

<h3>Description</h3>

<p>Orient polygon coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_orient(handleable, ..., direction = wk_counterclockwise())

wk_orient_filter(handler, direction = wk_counterclockwise())

wk_clockwise()

wk_counterclockwise()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_orient_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_orient_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_orient_+3A_direction">direction</code></td>
<td>
<p>The winding polygon winding direction</p>
</td></tr>
<tr><td><code id="wk_orient_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>handleable</code> with consistently oriented polygons, in <code>direction</code>
winding order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_orient(wkt("POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))"))
wk_orient(
  wkt("POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))"),
  direction = wk_clockwise()
)

</code></pre>

<hr>
<h2 id='wk_plot'>Plot well-known geometry vectors</h2><span id='topic+wk_plot'></span><span id='topic+wk_plot.default'></span><span id='topic+plot.wk_wkt'></span><span id='topic+plot.wk_wkb'></span><span id='topic+plot.wk_xy'></span><span id='topic+plot.wk_rct'></span><span id='topic+plot.wk_crc'></span>

<h3>Description</h3>

<p>Plot well-known geometry vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_plot(
  handleable,
  ...,
  asp = 1,
  bbox = NULL,
  xlab = "",
  ylab = "",
  rule = "evenodd",
  add = FALSE
)

## Default S3 method:
wk_plot(
  handleable,
  ...,
  asp = 1,
  bbox = NULL,
  xlab = "",
  ylab = "",
  rule = "evenodd",
  add = FALSE
)

## S3 method for class 'wk_wkt'
plot(
  x,
  ...,
  asp = 1,
  bbox = NULL,
  xlab = "",
  ylab = "",
  rule = "evenodd",
  add = FALSE
)

## S3 method for class 'wk_wkb'
plot(
  x,
  ...,
  asp = 1,
  bbox = NULL,
  xlab = "",
  ylab = "",
  rule = "evenodd",
  add = FALSE
)

## S3 method for class 'wk_xy'
plot(x, ..., asp = 1, bbox = NULL, xlab = "", ylab = "", add = FALSE)

## S3 method for class 'wk_rct'
plot(x, ..., asp = 1, bbox = NULL, xlab = "", ylab = "", add = FALSE)

## S3 method for class 'wk_crc'
plot(x, ..., asp = 1, bbox = NULL, xlab = "", ylab = "", add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_plot_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_plot_+3A_...">...</code></td>
<td>
<p>Passed to plotting functions for features: <code><a href="graphics.html#topic+points">graphics::points()</a></code>
for point and multipoint geometries, <code><a href="graphics.html#topic+lines">graphics::lines()</a></code> for linestring
and multilinestring geometries, and <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code> for polygon
and multipolygon geometries.</p>
</td></tr>
<tr><td><code id="wk_plot_+3A_asp">asp</code>, <code id="wk_plot_+3A_xlab">xlab</code>, <code id="wk_plot_+3A_ylab">ylab</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code></p>
</td></tr>
<tr><td><code id="wk_plot_+3A_bbox">bbox</code></td>
<td>
<p>The limits of the plot as a <code><a href="#topic+rct">rct()</a></code> or compatible object</p>
</td></tr>
<tr><td><code id="wk_plot_+3A_rule">rule</code></td>
<td>
<p>The rule to use for filling polygons (see <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code>)</p>
</td></tr>
<tr><td><code id="wk_plot_+3A_add">add</code></td>
<td>
<p>Should a new plot be created, or should <code>handleable</code> be added to the
existing plot?</p>
</td></tr>
<tr><td><code id="wk_plot_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+wkb">wkb()</a></code> or <code><a href="#topic+wkt">wkt()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(as_wkt("LINESTRING (0 0, 1 1)"))
plot(as_wkb("LINESTRING (0 0, 1 1)"))

</code></pre>

<hr>
<h2 id='wk_problems'>Validate well-known binary and well-known text</h2><span id='topic+wk_problems'></span><span id='topic+wk_problems_handler'></span>

<h3>Description</h3>

<p>The problems handler returns a character vector of parse
errors and can be used to validate input of any type
for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_problems(handleable, ...)

wk_problems_handler()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_problems_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_problems_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of parsing errors. <code>NA</code> signifies
that there was no parsing error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_problems(new_wk_wkt(c("POINT EMTPY", "POINT (20 30)")))
wk_handle(
  new_wk_wkt(c("POINT EMTPY", "POINT (20 30)")),
  wk_problems_handler()
)

</code></pre>

<hr>
<h2 id='wk_proj_crs_view'>Common CRS Representations</h2><span id='topic+wk_proj_crs_view'></span><span id='topic+wk_proj_crs_json'></span>

<h3>Description</h3>

<p>These fixtures are calculated from PROJ version 9.1.0 and the database
built from its source. They are used internally to transform and inspect
coordinate reference systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_proj_crs_view

wk_proj_crs_json
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 13387 rows and 7 columns.
</p>
<p>An object of class <code>data.frame</code> with 13387 rows and 3 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(wk_proj_crs_view)
colnames(wk_proj_crs_json)

</code></pre>

<hr>
<h2 id='wk_set_z'>Set coordinate values</h2><span id='topic+wk_set_z'></span><span id='topic+wk_set_m'></span><span id='topic+wk_drop_z'></span><span id='topic+wk_drop_m'></span><span id='topic+wk_trans_set'></span>

<h3>Description</h3>

<p>Set coordinate values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_set_z(handleable, z, ...)

wk_set_m(handleable, m, ...)

wk_drop_z(handleable, ...)

wk_drop_m(handleable, ...)

wk_trans_set(value, use_z = NA, use_m = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_set_z_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_set_z_+3A_z">z</code>, <code id="wk_set_z_+3A_m">m</code></td>
<td>
<p>A vector of Z or M values applied feature-wise and recycled
along <code>handleable</code>. Use <code>NA</code> to keep the existing value of a given
feature.</p>
</td></tr>
<tr><td><code id="wk_set_z_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_set_z_+3A_value">value</code></td>
<td>
<p>An <code><a href="#topic+xy">xy()</a></code>, <code><a href="#topic+xyz">xyz()</a></code>, <code><a href="#topic+xym">xym()</a></code>, or <code><a href="#topic+xyzm">xyzm()</a></code> of coordinates
used to replace values in the input. Use <code>NA</code> to keep the existing
value.</p>
</td></tr>
<tr><td><code id="wk_set_z_+3A_use_z">use_z</code>, <code id="wk_set_z_+3A_use_m">use_m</code></td>
<td>
<p>Used to declare the output type. Use <code>TRUE</code> to
ensure the output has that dimension, <code>FALSE</code> to ensure it does not,
and <code>NA</code> to leave the dimension unchanged.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>wk_set_z(wkt("POINT (0 1)"), 2)
wk_set_m(wkt("POINT (0 1)"), 2)
wk_drop_z(wkt("POINT ZM (0 1 2 3)"))
wk_drop_m(wkt("POINT ZM (0 1 2 3)"))

</code></pre>

<hr>
<h2 id='wk_trans_affine'>Affine transformer</h2><span id='topic+wk_trans_affine'></span><span id='topic+wk_affine_identity'></span><span id='topic+wk_affine_rotate'></span><span id='topic+wk_affine_scale'></span><span id='topic+wk_affine_translate'></span><span id='topic+wk_affine_fit'></span><span id='topic+wk_affine_rescale'></span><span id='topic+wk_affine_compose'></span><span id='topic+wk_affine_invert'></span>

<h3>Description</h3>

<p>Affine transformer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_trans_affine(trans_matrix)

wk_affine_identity()

wk_affine_rotate(rotation_deg)

wk_affine_scale(scale_x = 1, scale_y = 1)

wk_affine_translate(dx = 0, dy = 0)

wk_affine_fit(src, dst)

wk_affine_rescale(rct_in, rct_out)

wk_affine_compose(...)

wk_affine_invert(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_trans_affine_+3A_trans_matrix">trans_matrix</code></td>
<td>
<p>A 3x3 transformation matrix</p>
</td></tr>
<tr><td><code id="wk_trans_affine_+3A_rotation_deg">rotation_deg</code></td>
<td>
<p>A rotation to apply in degrees counterclockwise.</p>
</td></tr>
<tr><td><code id="wk_trans_affine_+3A_scale_x">scale_x</code>, <code id="wk_trans_affine_+3A_scale_y">scale_y</code></td>
<td>
<p>Scale factor to apply in the x and y directions, respectively</p>
</td></tr>
<tr><td><code id="wk_trans_affine_+3A_dx">dx</code>, <code id="wk_trans_affine_+3A_dy">dy</code></td>
<td>
<p>Coordinate offsets in the x and y direction</p>
</td></tr>
<tr><td><code id="wk_trans_affine_+3A_src">src</code>, <code id="wk_trans_affine_+3A_dst">dst</code></td>
<td>
<p>Point vectors of control points used to estimate the affine mapping
(using <code><a href="base.html#topic+qr">base::qr.solve()</a></code>).</p>
</td></tr>
<tr><td><code id="wk_trans_affine_+3A_rct_in">rct_in</code>, <code id="wk_trans_affine_+3A_rct_out">rct_out</code></td>
<td>
<p>The input and output bounds</p>
</td></tr>
<tr><td><code id="wk_trans_affine_+3A_...">...</code></td>
<td>
<p>Zero or more transforms in the order they should be applied.</p>
</td></tr>
<tr><td><code id="wk_trans_affine_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+wk_trans_affine">wk_trans_affine()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='wk_trans_explicit'>Transform using explicit coordinate values</h2><span id='topic+wk_trans_explicit'></span>

<h3>Description</h3>

<p>A <a href="#topic+wk_transform">wk_trans</a> implementation that replaces coordinate values
using a vector of pre-calculated coordinates. This is used to perform generic
transforms using R functions and system calls that are impossible or impractical
to implement at the C level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_trans_explicit(value, use_z = NA, use_m = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_trans_explicit_+3A_value">value</code></td>
<td>
<p>An <code><a href="#topic+xy">xy()</a></code>, <code><a href="#topic+xyz">xyz()</a></code>, <code><a href="#topic+xym">xym()</a></code>, or <code><a href="#topic+xyzm">xyzm()</a></code> of coordinates
used to replace values in the input. Use <code>NA</code> to keep the existing
value.</p>
</td></tr>
<tr><td><code id="wk_trans_explicit_+3A_use_z">use_z</code>, <code id="wk_trans_explicit_+3A_use_m">use_m</code></td>
<td>
<p>Used to declare the output type. Use <code>TRUE</code> to
ensure the output has that dimension, <code>FALSE</code> to ensure it does not,
and <code>NA</code> to leave the dimension unchanged.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+wk_coords">wk_coords()</a></code> which has a replacement version  &quot;<code style="white-space: pre;">&#8288;wk_coords&lt;-&#8288;</code>&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trans &lt;- wk_trans_explicit(xy(1:5, 1:5))
wk_transform(rep(xy(0, 0), 5), trans)
</code></pre>

<hr>
<h2 id='wk_trans_inverse'>Generic transform class</h2><span id='topic+wk_trans_inverse'></span><span id='topic+as_wk_trans'></span><span id='topic+as_wk_trans.wk_trans'></span><span id='topic+new_wk_trans'></span>

<h3>Description</h3>

<p>Generic transform class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_trans_inverse(trans, ...)

as_wk_trans(x, ...)

## S3 method for class 'wk_trans'
as_wk_trans(x, ...)

new_wk_trans(trans_ptr, subclass = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_trans_inverse_+3A_trans">trans</code></td>
<td>
<p>An external pointer to a wk_trans object</p>
</td></tr>
<tr><td><code id="wk_trans_inverse_+3A_...">...</code></td>
<td>
<p>Passed to S3 methods</p>
</td></tr>
<tr><td><code id="wk_trans_inverse_+3A_x">x</code></td>
<td>
<p>An object to be converted to a transform.</p>
</td></tr>
<tr><td><code id="wk_trans_inverse_+3A_trans_ptr">trans_ptr</code></td>
<td>
<p>An external pointer to a wk_trans_t transform
struct.</p>
</td></tr>
<tr><td><code id="wk_trans_inverse_+3A_subclass">subclass</code></td>
<td>
<p>An optional subclass to apply to the pointer</p>
</td></tr>
</table>

<hr>
<h2 id='wk_transform'>Apply coordinate transformations</h2><span id='topic+wk_transform'></span><span id='topic+wk_transform_filter'></span>

<h3>Description</h3>

<p>Apply coordinate transformations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_transform(handleable, trans, ...)

wk_transform_filter(handler, trans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_transform_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_transform_+3A_trans">trans</code></td>
<td>
<p>An external pointer to a wk_trans object</p>
</td></tr>
<tr><td><code id="wk_transform_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_transform_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>wk_transform(xy(0, 0), wk_affine_translate(2, 3))

</code></pre>

<hr>
<h2 id='wk_translate.sfc'>Translate geometry vectors</h2><span id='topic+wk_translate.sfc'></span><span id='topic+wk_translate'></span><span id='topic+wk_translate.default'></span>

<h3>Description</h3>

<p>Translate geometry vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfc'
wk_translate(handleable, to, ...)

wk_translate(handleable, to, ...)

## Default S3 method:
wk_translate(handleable, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_translate.sfc_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_translate.sfc_+3A_to">to</code></td>
<td>
<p>A prototype object.</p>
</td></tr>
<tr><td><code id="wk_translate.sfc_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
</table>

<hr>
<h2 id='wk_vertices'>Extract vertices</h2><span id='topic+wk_vertices'></span><span id='topic+wk_coords'></span><span id='topic+wk_coords+3C-'></span><span id='topic+wk_vertex_filter'></span>

<h3>Description</h3>

<p>These functions provide ways to extract individual coordinate values.
Whereas <code>wk_vertices()</code> returns a vector of coordinates as in the same
format as the input, <code>wk_coords()</code> returns a data frame with coordinates
as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_vertices(handleable, ...)

wk_coords(handleable, ...)

wk_coords(handleable, use_z = NA, use_m = NA) &lt;- value

wk_vertex_filter(handler, add_details = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_vertices_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_vertices_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_vertices_+3A_use_z">use_z</code>, <code id="wk_vertices_+3A_use_m">use_m</code></td>
<td>
<p>Used to declare the output type. Use <code>TRUE</code> to
ensure the output has that dimension, <code>FALSE</code> to ensure it does not,
and <code>NA</code> to leave the dimension unchanged.</p>
</td></tr>
<tr><td><code id="wk_vertices_+3A_value">value</code></td>
<td>
<p>An <code><a href="#topic+xy">xy()</a></code>, <code><a href="#topic+xyz">xyz()</a></code>, <code><a href="#topic+xym">xym()</a></code>, or <code><a href="#topic+xyzm">xyzm()</a></code> of coordinates
used to replace values in the input. Use <code>NA</code> to keep the existing
value.</p>
</td></tr>
<tr><td><code id="wk_vertices_+3A_handler">handler</code></td>
<td>
<p>A <a href="#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk_vertices_+3A_add_details">add_details</code></td>
<td>
<p>Use <code>TRUE</code> to add a &quot;wk_details&quot; attribute, which
contains columns <code>feature_id</code>, <code>part_id</code>, and <code>ring_id</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;wk_coords&lt;-&#8288;</code> is the replacement-function version of 'wk_coords'.
Using the engine of <code><a href="#topic+wk_trans_explicit">wk_trans_explicit()</a></code> the coordinates of an object
can be transformed in a generic way using R functions as needed.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>wk_vertices()</code> extracts vertices and returns the in the same format as
the handler
</p>
</li>
<li> <p><code>wk_coords()</code> returns a data frame with columns columns <code>feature_id</code>
(the index of the feature from whence it came), <code>part_id</code> (an arbitrary
integer identifying the point, line, or polygon from whence it came),
<code>ring_id</code> (an arbitrary integer identifying individual rings within
polygons), and one column per coordinate (<code>x</code>, <code>y</code>, and/or <code>z</code> and/or <code>m</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>wk_vertices(wkt("LINESTRING (0 0, 1 1)"))
wk_coords(wkt("LINESTRING (0 0, 1 1)"))

# wk_coords() replacement function
x &lt;- xy(1:5, 1:5)
y &lt;- as_wkt(x)
wk_coords(y) &lt;- cbind(5:1, 0:4)
wk_coords(x) &lt;- y[5:1]
y
x

</code></pre>

<hr>
<h2 id='wk_void'>Do nothing</h2><span id='topic+wk_void'></span><span id='topic+wk_void_handler'></span>

<h3>Description</h3>

<p>This handler does nothing and returns <code>NULL</code>. It is useful for
benchmarking readers and handlers and when using filters
that have side-effects (e.g., <code><a href="#topic+wk_debug">wk_debug()</a></code>). Note that this
handler stops on the first parse error; to see a list of parse
errors see the <code><a href="#topic+wk_problems">wk_problems()</a></code> handler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wk_void(handleable, ...)

wk_void_handler()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_void_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_void_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wk_void(wkt("POINT (1 4)"))
wk_handle(wkt("POINT (1 4)"), wk_void_handler())

</code></pre>

<hr>
<h2 id='wk_writer.sfc'>Write geometry vectors</h2><span id='topic+wk_writer.sfc'></span><span id='topic+wk_writer.sf'></span><span id='topic+sfc_writer'></span><span id='topic+wkb_writer'></span><span id='topic+wkt_writer'></span><span id='topic+wk_writer'></span><span id='topic+wk_writer.default'></span><span id='topic+wk_writer.wk_wkt'></span><span id='topic+wk_writer.wk_wkb'></span><span id='topic+wk_writer.wk_xy'></span><span id='topic+xy_writer'></span>

<h3>Description</h3>

<p>When writing transformation functions, it is often useful to know which
handler should be used to create a (potentially modified) version
of an object. Some transformers (e.g., <code><a href="#topic+wk_vertices">wk_vertices()</a></code>) modify
the geometry type of an object, in which case a generic writer is needed.
This defaults to <code><a href="#topic+wkb_writer">wkb_writer()</a></code> because it is fast and can handle
all geometry types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfc'
wk_writer(handleable, ...)

## S3 method for class 'sf'
wk_writer(handleable, ...)

sfc_writer(promote_multi = FALSE)

wkb_writer(buffer_size = 2048L, endian = NA_integer_)

wkt_writer(precision = 16L, trim = TRUE)

wk_writer(handleable, ..., generic = FALSE)

## Default S3 method:
wk_writer(handleable, ...)

## S3 method for class 'wk_wkt'
wk_writer(handleable, ..., precision = 16, trim = TRUE)

## S3 method for class 'wk_wkb'
wk_writer(handleable, ...)

## S3 method for class 'wk_xy'
wk_writer(handleable, ..., generic = FALSE)

xy_writer()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_writer.sfc_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="#topic+wkb">wkb()</a></code>, <code><a href="#topic+wkt">wkt()</a></code>, <code><a href="#topic+xy">xy()</a></code>,
<code><a href="#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_writer.sfc_+3A_...">...</code></td>
<td>
<p>Passed to the writer constructor.</p>
</td></tr>
<tr><td><code id="wk_writer.sfc_+3A_promote_multi">promote_multi</code></td>
<td>
<p>Use TRUE to promote all simple geometries to a multi
type when reading to sfc. This is useful to increase the likelihood that
the sfc will contain a single geometry type.</p>
</td></tr>
<tr><td><code id="wk_writer.sfc_+3A_buffer_size">buffer_size</code></td>
<td>
<p>Control the initial buffer size used when writing WKB.</p>
</td></tr>
<tr><td><code id="wk_writer.sfc_+3A_endian">endian</code></td>
<td>
<p>Use 1 for little endian, 0 for big endian, or NA for
system endian.</p>
</td></tr>
<tr><td><code id="wk_writer.sfc_+3A_precision">precision</code></td>
<td>
<p>If <code>trim</code> is <code>TRUE</code>, the total number of significant digits to keep
for each result or the number of digits after the decimal place otherwise.</p>
</td></tr>
<tr><td><code id="wk_writer.sfc_+3A_trim">trim</code></td>
<td>
<p>Use <code>FALSE</code> to keep trailing zeroes after the decimal place.</p>
</td></tr>
<tr><td><code id="wk_writer.sfc_+3A_generic">generic</code></td>
<td>
<p>Use <code>TRUE</code> to obtain a writer that can write all geometry
types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+wk_handle">wk_handler</a>.
</p>

<hr>
<h2 id='wkb'>Mark lists of raw vectors as well-known binary</h2><span id='topic+wkb'></span><span id='topic+parse_wkb'></span><span id='topic+wk_platform_endian'></span><span id='topic+as_wkb'></span><span id='topic+as_wkb.default'></span><span id='topic+as_wkb.character'></span><span id='topic+as_wkb.wk_wkb'></span><span id='topic+as_wkb.blob'></span><span id='topic+as_wkb.WKB'></span>

<h3>Description</h3>

<p>Mark lists of raw vectors as well-known binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkb(x = list(), crs = wk_crs_auto(), geodesic = FALSE)

parse_wkb(x, crs = wk_crs_auto(), geodesic = FALSE)

wk_platform_endian()

as_wkb(x, ...)

## Default S3 method:
as_wkb(x, ...)

## S3 method for class 'character'
as_wkb(x, ..., crs = NULL, geodesic = FALSE)

## S3 method for class 'wk_wkb'
as_wkb(x, ...)

## S3 method for class 'blob'
as_wkb(x, ..., crs = NULL, geodesic = FALSE)

## S3 method for class 'WKB'
as_wkb(x, ..., crs = NULL, geodesic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkb_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list()</a></code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="wkb_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
<tr><td><code id="wkb_+3A_geodesic">geodesic</code></td>
<td>
<p><code>TRUE</code> if edges must be interpolated as geodesics when
coordinates are spherical, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="wkb_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+new_wk_wkb">new_wk_wkb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_wkb("POINT (20 10)")

</code></pre>

<hr>
<h2 id='wkb_to_hex'>Convert well-known binary to hex</h2><span id='topic+wkb_to_hex'></span>

<h3>Description</h3>

<p>Convert well-known binary to hex
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkb_to_hex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkb_to_hex_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+wkb">wkb()</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A hex encoded <code><a href="#topic+wkb">wkb()</a></code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_wkb(xyz(1:5, 6:10, 11:15))
wkb_to_hex(x)

</code></pre>

<hr>
<h2 id='wkb_translate_wkt'>Deprecated functions</h2><span id='topic+wkb_translate_wkt'></span><span id='topic+wkb_translate_wkb'></span><span id='topic+wkt_translate_wkt'></span><span id='topic+wkt_translate_wkb'></span>

<h3>Description</h3>

<p>These functions are deprecated and will be removed in a future version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkb_translate_wkt(wkb, ..., precision = 16, trim = TRUE)

wkb_translate_wkb(wkb, ..., endian = NA_integer_)

wkt_translate_wkt(wkt, ..., precision = 16, trim = TRUE)

wkt_translate_wkb(wkt, ..., endian = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkb_translate_wkt_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors, such as that
returned by <code>sf::st_as_binary()</code>.</p>
</td></tr>
<tr><td><code id="wkb_translate_wkt_+3A_...">...</code></td>
<td>
<p>Used to keep backward compatibility with previous
versions of these functions.</p>
</td></tr>
<tr><td><code id="wkb_translate_wkt_+3A_precision">precision</code></td>
<td>
<p>The rounding precision to use when writing
(number of decimal places).</p>
</td></tr>
<tr><td><code id="wkb_translate_wkt_+3A_trim">trim</code></td>
<td>
<p>Trim unnecessary zeroes in the output?</p>
</td></tr>
<tr><td><code id="wkb_translate_wkt_+3A_endian">endian</code></td>
<td>
<p>Force the endian of the resulting WKB.</p>
</td></tr>
<tr><td><code id="wkb_translate_wkt_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
</table>

<hr>
<h2 id='wkt'>Mark character vectors as well-known text</h2><span id='topic+wkt'></span><span id='topic+parse_wkt'></span><span id='topic+as_wkt'></span><span id='topic+as_wkt.default'></span><span id='topic+as_wkt.character'></span><span id='topic+as_wkt.wk_wkt'></span>

<h3>Description</h3>

<p>Mark character vectors as well-known text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkt(x = character(), crs = wk_crs_auto(), geodesic = FALSE)

parse_wkt(x, crs = wk_crs_auto(), geodesic = FALSE)

as_wkt(x, ...)

## Default S3 method:
as_wkt(x, ...)

## S3 method for class 'character'
as_wkt(x, ..., crs = NULL, geodesic = FALSE)

## S3 method for class 'wk_wkt'
as_wkt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkt_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character()</a></code> vector containing well-known text.</p>
</td></tr>
<tr><td><code id="wkt_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
<tr><td><code id="wkt_+3A_geodesic">geodesic</code></td>
<td>
<p><code>TRUE</code> if edges must be interpolated as geodesics when
coordinates are spherical, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="wkt_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+new_wk_wkt">new_wk_wkt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wkt("POINT (20 10)")

</code></pre>

<hr>
<h2 id='xy'>Efficient point vectors</h2><span id='topic+xy'></span><span id='topic+xyz'></span><span id='topic+xym'></span><span id='topic+xyzm'></span><span id='topic+xy_dims'></span><span id='topic+as_xy'></span><span id='topic+as_xy.default'></span><span id='topic+as_xy.wk_xy'></span><span id='topic+as_xy.matrix'></span><span id='topic+as_xy.data.frame'></span>

<h3>Description</h3>

<p>Efficient point vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy(x = double(), y = double(), crs = wk_crs_auto())

xyz(x = double(), y = double(), z = double(), crs = wk_crs_auto())

xym(x = double(), y = double(), m = double(), crs = wk_crs_auto())

xyzm(
  x = double(),
  y = double(),
  z = double(),
  m = double(),
  crs = wk_crs_auto()
)

xy_dims(x)

as_xy(x, ...)

## Default S3 method:
as_xy(x, ..., dims = NULL)

## S3 method for class 'wk_xy'
as_xy(x, ..., dims = NULL)

## S3 method for class 'matrix'
as_xy(x, ..., crs = NULL)

## S3 method for class 'data.frame'
as_xy(x, ..., dims = NULL, crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xy_+3A_x">x</code>, <code id="xy_+3A_y">y</code>, <code id="xy_+3A_z">z</code>, <code id="xy_+3A_m">m</code></td>
<td>
<p>Coordinate values.</p>
</td></tr>
<tr><td><code id="xy_+3A_crs">crs</code></td>
<td>
<p>A value to be propagated as the CRS for this vector.</p>
</td></tr>
<tr><td><code id="xy_+3A_...">...</code></td>
<td>
<p>Passed to methods.</p>
</td></tr>
<tr><td><code id="xy_+3A_dims">dims</code></td>
<td>
<p>A set containing one or more of <code>c("x", "y", "z", "m")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of coordinate values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy(1:5, 1:5)
xyz(1:5, 1:5, 10)
xym(1:5, 1:5, 10)
xyzm(1:5, 1:5, 10, 12)

# NA, NA maps to a null/na feature; NaN, NaN maps to EMPTY
as_wkt(xy(NaN, NaN))
as_wkt(xy(NA, NA))

</code></pre>

<hr>
<h2 id='xy_x'>XY vector extractors</h2><span id='topic+xy_x'></span><span id='topic+xy_y'></span><span id='topic+xy_z'></span><span id='topic+xy_m'></span>

<h3>Description</h3>

<p>XY vector extractors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy_x(x)

xy_y(x)

xy_z(x)

xy_m(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xy_x_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+xy">xy()</a></code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Components of the <code><a href="#topic+xy">xy()</a></code> vector or NULL if the dimension is missing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xyz(1:5, 6:10, 11:15)
xy_x(x)
xy_y(x)
xy_z(x)
xy_m(x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
