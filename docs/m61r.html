<!DOCTYPE html><html><head><title>Help for package m61r</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {m61r}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arrange'><p>Arrange your data.frames</p></a></li>
<li><a href='#expression'><p>Formula to be run on a data.frame given a group</p></a></li>
<li><a href='#filter'><p>filter a data.frame</p></a></li>
<li><a href='#group_by'><p>group_by a data.frame by chosen columns</p></a></li>
<li><a href='#join'><p>Join two data.frames</p></a></li>
<li><a href='#m61r'><p>Create m61r object</p></a></li>
<li><a href='#mutate'><p>Mutate and transmutate a data.frame</p></a></li>
<li><a href='#reshape'><p>Reshape a data.frame</p></a></li>
<li><a href='#select'><p>select columns of a data.frame</p></a></li>
<li><a href='#summarise'><p>Summarise formula on groups</p></a></li>
<li><a href='#value'><p>get or assign a value to a data.frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Title:</td>
<td>Package About Data Manipulation in Pure Base R</td>
</tr>
<tr>
<td>Description:</td>
<td>Data manipulation in one package and in base R.
  Minimal. No dependencies.
  'dplyr' and 'tidyr'-like in one place.
  Nothing else than base R to build the package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pv71u98h1/m61r/">https://github.com/pv71u98h1/m61r/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pv71u98h1/m61r/issues/">https://github.com/pv71u98h1/m61r/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-06 14:33:12 UTC; jean-marie</td>
</tr>
<tr>
<td>Author:</td>
<td>Jean-Marie Lepioufle [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jean-Marie Lepioufle &lt;pv71u98h1@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-06 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='arrange'>Arrange your data.frames</h2><span id='topic+arrange_'></span><span id='topic+desange_'></span>

<h3>Description</h3>

<p>Re-arrange your data.frame in ascending or descending order and given one or several columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_(df, ...)

desange_(df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>formula used for arranging the data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions return an object of the same type as <code>df</code>.
The output has the following properties:
Properties:
</p>

<ul>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Output get rows in the order specified by </p>
</li>
<li><p>....
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
tmp &lt;- arrange_(CO2,~c(conc))
head(tmp)

tmp &lt;- arrange_(CO2,~c(Treatment,conc,uptake))
head(tmp)

tmp &lt;- desange_(CO2,~c(Treatment,conc,uptake))
head(tmp)

</code></pre>

<hr>
<h2 id='expression'>Formula to be run on a data.frame given a group</h2><span id='topic+expression_'></span>

<h3>Description</h3>

<p>Evaluate a formula on the data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expression_(df, group=NULL, fun_expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expression_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="expression_+3A_group">group</code></td>
<td>
<p>formula that describes the group</p>
</td></tr>
<tr><td><code id="expression_+3A_fun_expr">fun_expr</code></td>
<td>
<p>formula that describes the expression to be run on the data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list.
Each element of the list get the result of processed expressions determined in <code>...</code> on the whole data frame <code>df</code> if <code>group</code> is kept <code>NULL</code>, or for each group determined in <code>group</code> otherwise.
The class of each element is intrinsic to the output of the expression determined in argument <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression_(CO2,fun_expr=~mean(conc))

expression_(CO2,fun_expr=~conc/uptake)

# with group
expression_(CO2,group=~Type,fun_expr=~mean(uptake))

expression_(CO2,group=~Type,fun_expr=~lm(uptake~conc))

</code></pre>

<hr>
<h2 id='filter'>filter a data.frame</h2><span id='topic+filter_'></span>

<h3>Description</h3>

<p>Filter rows of a data.frame with conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_(df, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="filter_+3A_subset">subset</code></td>
<td>
<p>formula that describes the conditions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of the same type as <code>df</code>.
Properties:
</p>

<ul>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Only rows following the condtion determined by </p>
</li>
<li><p>subset appear.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
tmp &lt;- filter_(CO2,~Plant=="Qn1")
head(tmp)

tmp &lt;- filter_(CO2,~Type=="Quebec")
head(tmp)

</code></pre>

<hr>
<h2 id='group_by'>group_by a data.frame by chosen columns</h2><span id='topic+group_by_'></span>

<h3>Description</h3>

<p>Group a data.frame by chosen columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by_(df, group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="group_by_+3A_group">group</code></td>
<td>
<p>formula that describes the group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list.
Each element of the list is a subset of data frame <code>df</code>. Subset is determined by variables given in <code>group</code>.
Each data frame get the following properties:
</p>

<ul>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Only rows corresponding to the subset.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- group_by_(CO2,~c(Type,Treatment))

tmp[[1]]
</code></pre>

<hr>
<h2 id='join'>Join two data.frames</h2><span id='topic+left_join_'></span><span id='topic+anti_join_'></span><span id='topic+full_join_'></span><span id='topic+inner_join_'></span><span id='topic+right_join_'></span><span id='topic+semi_join_'></span>

<h3>Description</h3>

<p>Join two data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left_join_(df, df2, by = NULL, by.x = NULL, by.y = NULL)

anti_join_(df, df2, by = NULL, by.x = NULL, by.y = NULL)

full_join_(df, df2, by = NULL, by.x = NULL, by.y = NULL)

inner_join_(df, df2, by = NULL, by.x = NULL, by.y = NULL)

right_join_(df, df2, by = NULL, by.x = NULL, by.y = NULL)

semi_join_(df, df2, by = NULL, by.x = NULL, by.y = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="join_+3A_df2">df2</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="join_+3A_by">by</code></td>
<td>
<p>column names of the pivot of both data.frame 1 and data.frame 2 if they are identical. Otherwise, better to use by.x and by.y</p>
</td></tr>
<tr><td><code id="join_+3A_by.x">by.x</code></td>
<td>
<p>column names of the pivot of data.frame 1</p>
</td></tr>
<tr><td><code id="join_+3A_by.y">by.y</code></td>
<td>
<p>column names of the pivot of data.frame 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions return a data frame.
The output has the following properties:
</p>

<ul>
<li>
<p>For functions <code>left_join()</code>, <code>inner_join()</code>, <code>full_join()</code>, and <code>right_join()</code>, output includes all <code>df1</code> columns and all <code>df2</code> columns. For columns with
identical names in <code>df1</code> and <code>df2</code>, a suffix '.x' and '.y' is added.
For <code>left_join()</code>, all <code>df1</code> rows with matching rows of <code>df2</code>
For <code>inner_join()</code>, a subset of <code>df1</code> rows matching rows of <code>df2</code>.
For <code>full_join()</code>, all <code>df1</code> rows, with all <code>df2</code> rows.
For <code>right_join()</code>, all <code>df2</code> rows with matching rows of <code>df1</code>.
</p>
</li>
<li>
<p>For functions <code>semi_join()</code> and <code>anti_join()</code>, output include columns of <code>df1</code> only.
For <code>semi_join()</code>, all <code>df1</code> rows with a match in <code>df2</code>.
For <code>anti_join()</code>, a subset of <code>df1</code> rows not matching rows of <code>df2</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
books &lt;- data.frame(
             name = I(c("Tukey", "Venables", "Tierney","Ripley",
                   "Ripley", "McNeil", "R Core")),
             title = c("Exploratory Data Analysis",
                   "Modern Applied Statistics ...",
                   "LISP-STAT",
                   "Spatial Statistics", "Stochastic Simulation",
                   "Interactive Data Analysis",
                   "An Introduction to R"),
              other.author = c(NA, "Ripley", NA, NA, NA, NA,"Venables &amp; Smith"))

authors &lt;- data.frame(
               surname = I(c("Tukey", "Venables", "Tierney", "Ripley", "McNeil","Asimov")),
               nationality = c("US", "Australia", "US", "UK", "Australia","US"),
               deceased = c("yes", rep("no", 4),"yes"))

tmp &lt;- left_join_(books,authors, by.x = "name", by.y = "surname")
head(tmp)

tmp &lt;- inner_join_(books,authors, by.x = "name", by.y = "surname")
head(tmp)

tmp &lt;- full_join_(books,authors, by.x = "name", by.y = "surname")
head(tmp)

tmp &lt;- right_join_(books,authors, by.x = "name", by.y = "surname")
head(tmp)

tmp &lt;- semi_join_(books,authors, by.x = "name", by.y = "surname")
head(tmp)

tmp &lt;- anti_join_(books,authors, by.x = "name", by.y = "surname")
head(tmp)
</code></pre>

<hr>
<h2 id='m61r'>Create m61r object</h2><span id='topic+m61r'></span><span id='topic++5B.m61r'></span><span id='topic++5B+3C-.m61r'></span><span id='topic+print.m61r'></span><span id='topic+names.m61r'></span><span id='topic+dim.m61r'></span><span id='topic+as.data.frame.m61r'></span><span id='topic+rbind.m61r'></span><span id='topic+cbind.m61r'></span><span id='topic+left_join'></span><span id='topic+anti_join'></span><span id='topic+full_join'></span><span id='topic+inner_join'></span><span id='topic+right_join'></span><span id='topic+semi_join'></span>

<h3>Description</h3>

<p>Create a m61r object that enables to run a sequence of operations on a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m61r(df = NULL)

## S3 method for class 'm61r'
x[i, j, ...]

## S3 replacement method for class 'm61r'
x[i, j] &lt;- value

## S3 method for class 'm61r'
print(x, ...)

## S3 method for class 'm61r'
names(x, ...)

## S3 method for class 'm61r'
dim(x, ...)

## S3 method for class 'm61r'
as.data.frame(x, ...)

## S3 method for class 'm61r'
rbind(x, ...)

## S3 method for class 'm61r'
cbind(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m61r_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="m61r_+3A_x">x</code></td>
<td>
<p>object of class <code>m61r</code></p>
</td></tr>
<tr><td><code id="m61r_+3A_i">i</code></td>
<td>
<p>row</p>
</td></tr>
<tr><td><code id="m61r_+3A_j">j</code></td>
<td>
<p>column</p>
</td></tr>
<tr><td><code id="m61r_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="m61r_+3A_value">value</code></td>
<td>
<p>value to be assigned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>m61r</code> returns an object of type <code>m61r</code>.
</p>
<p>Argument <code>df</code> get stored internally to the object <code>m61r</code>.
One manipulates the internal <code>data.frame</code> by using internal functions similar to the ones implemented in package <code>m61r</code> for <code>data.frames</code> as <code>arrange</code>, <code>desange</code>, <code>filter</code>, <code>join</code> and its relatives, <code>mutate</code> and <code>transmutate</code>, <code>gather</code> and <code>spread</code>, <code>select</code>, <code>groupe_by</code>, <code>summarise</code>, <code>values</code> and <code>modify</code>.
The result of the last action is stored internally to the object <code>m61r</code> until the internal function <code>values</code> get called.
It is thus possible to create a readable sequence of actions on a <code>data.frame</code>.
</p>
<p>In addition,
</p>

<ul>
<li> <p><code>[.m61r</code> returns a subset of the internal <code>data.frame</code> embedded to the object <code>m61r</code>.
</p>
</li>
<li> <p><code>[&lt;-.m61r</code> assigns <code>value</code> to the internal <code>data.frame</code> embedded to the object <code>m61r</code>.
</p>
</li>
<li> <p><code>print.m61r</code> prints the internal <code>data.frame</code> embedded to the object <code>m61r</code>.
</p>
</li>
<li> <p><code>names.m61r</code> provides the names of the column of the internal <code>data.frame</code> embedded to the object <code>m61r</code>.
</p>
</li>
<li> <p><code>dim.m61r</code> provides the dimensions of the internal <code>data.frame</code> embedded to the object <code>m61r</code>.
</p>
</li>
<li> <p><code>as.data.frame.m61r</code> extracts the internal <code>data.frame</code> embedded to the object <code>m61r</code>.
</p>
</li>
<li> <p><code>cbind.m61r</code> combines by _c_olumns two objects <code>m61r</code>.
</p>
</li>
<li> <p><code>rbind.m61r</code> combines by _r_ows two objects <code>m61r</code>.
</p>
</li>
<li> <p><code>left_join</code>, <code>anti_join</code>, <code>full_join</code>, <code>inner_join</code>, <code>right_join</code>, <code>semi_join</code> join two objects <code>m61r</code>.
</p>
</li></ul>

<p>Finally, it is possible to clone a <code>m61r</code> object into a new one by using the internal function <code>clone</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # init
  co2 &lt;- m61r(df=CO2)

  # filter
  co2$filter(~Plant=="Qn1")
  co2

  co2$filter(~Type=="Quebec")
  co2

  # select
  co2$select(~Type)
  co2

  co2$select(~c(Plant,Type))
  co2

  co2$select(~-Type)
  co2

  co2$select(variable=~-(Plant:Treatment))
  co2

  # mutate/transmutate
  co2$mutate(z=~conc/uptake)
  co2

  co2$mutate(mean=~mean(uptake))
  co2

  co2$mutate(z1=~uptake/conc,y=~conc/100)
  co2

  co2$transmutate(z2=~uptake/conc,y2=~conc/100)
  co2

  # summarise
  co2$summarise(mean=~mean(uptake),sd=~sd(uptake))
  co2

  co2$group_by(~c(Type,Treatment))
  co2$summarise(mean=~mean(uptake),sd=~sd(uptake))
  co2

  # arrange/dessange
  co2$arrange(~c(conc))
  co2

  co2$arrange(~c(Treatment,conc,uptake))
  co2

  co2$desange(~c(Treatment,conc,uptake))
  co2

  # join
  authors &lt;- data.frame(
               surname = I(c("Tukey", "Venables", "Tierney", "Ripley", "McNeil")),
               nationality = c("US", "Australia", "US", "UK", "Australia"),
               deceased = c("yes", rep("no", 4)))

  books &lt;- data.frame(
             name = I(c("Tukey", "Venables", "Tierney","Ripley",
                   "Ripley", "McNeil", "R Core")),
            title = c("Exploratory Data Analysis",
                   "Modern Applied Statistics ...",
                   "LISP-STAT",
                   "Spatial Statistics", "Stochastic Simulation",
                   "Interactive Data Analysis",
                   "An Introduction to R"),
         other.author = c(NA, "Ripley", NA, NA, NA, NA,"Venables &amp; Smith"))

  ## inner join
  tmp &lt;- m61r(df=authors)

  tmp$inner_join(books, by.x = "surname", by.y = "name")
  tmp

  ## left join
  tmp$left_join(books, by.x = "surname", by.y = "name")
  tmp

  ## right join
  tmp$right_join(books, by.x = "surname", by.y = "name")
  tmp

  ## full join
  tmp$full_join(books, by.x = "surname", by.y = "name")
  tmp

  ## semi join
  tmp$semi_join(books, by.x = "surname", by.y = "name")
  tmp

  ## anti join #1
  tmp$anti_join(books, by.x = "surname", by.y = "name")
  tmp

  ## anti join #2
  tmp2 &lt;- m61r(df=books)
  tmp2$anti_join(authors, by.x = "name", by.y = "surname")
  tmp2

  ## with two m61r objects
  tmp1 &lt;- m61r(books)
  tmp2 &lt;- m61r(authors)
  tmp3 &lt;- anti_join(tmp1,tmp2, by.x = "name", by.y = "surname")
  tmp3

  # Reshape

  ## gather
  df3 &lt;- data.frame(id = 1:4,
                    age = c(40,50,60,50),
                    dose.a1 = c(1,2,1,2),
                    dose.a2 = c(2,1,2,1),
                    dose.a14 = c(3,3,3,3))

  df4 &lt;- m61r::m61r(df3)
  df4$gather(pivot = c("id","age"))
  df4

  ## spread
  df3 &lt;- data.frame(id = 1:4,
                    age = c(40,50,60,50),
                    dose.a1 = c(1,2,1,2),
                    dose.a2 = c(2,1,2,1),
                    dose.a14 = c(3,3,3,3))

  df4 &lt;- m61r::gather_(df3,pivot = c("id","age"))
  df4 &lt;- rbind(df4,
    data.frame(id=5, age=20,parameters="dose.a14",values=8),
    data.frame(id=6, age=10,parameters="dose.a1",values=5))

  tmp &lt;- m61r::m61r(df4)
  tmp$spread(col_name="parameters",col_values="values",pivot=c("id","age"))
  tmp


  # equivalence
  co2           # is not equivalent to co2[]
  co2[]         # is equivalent to co2$values()
  co2[1,]       # is equivalent to co2$values(1,)
  co2[,2:3]     # is equivalent to co2$values(,2:3)
  co2[1:10,1:3] # is equivalent to co2$values(1:10,2:3)
  co2[1,"Plant"]# is equivalent to co2$values(1,"Plant")

  # modification on m61r object only stay for one step
  co2[1,"conc"] &lt;- 100
  co2[1,] # temporary result
  co2[1,] # back to normal

  # WARNING:
  # Keep the brackets to manipulate the intern data.frame
  co2[] &lt;- co2[-1,]
  co2[1:3,] # temporary result
  co2[1:3,] # back to normal

  # ... OR you will destroy co2, and only keep the data.frame
  # co2 &lt;- co2[-1,]
  # class(co2) # data.frame

  # descriptive manipulation
  names(co2)
  dim(co2)
  str(co2)

  ## cloning
  # The following will only create a second variable that point on
  # the same object (!= cloning)
  foo &lt;- co2
  str(co2)
  str(foo)

  # Instead, cloning into a new environemnt
  foo &lt;- co2$clone()
  str(co2)
  str(foo)
</code></pre>

<hr>
<h2 id='mutate'>Mutate and transmutate a data.frame</h2><span id='topic+mutate_'></span><span id='topic+transmutate_'></span>

<h3>Description</h3>

<p>Mutate and transmutate a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_(df, ...)

transmutate_(df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="mutate_+3A_...">...</code></td>
<td>
<p>formula used for mutating/transmutating the data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions return a data frame.
The output has the following properties:
</p>

<ul>
<li>
<p>For function <code>mutate_()</code>, output includes all <code>df</code> columns.
In addition, new columns are created according to argument <code>...</code> and placed after the others.
</p>
</li>
<li>
<p>For function <code>transmutate_()</code>, output includes only columns created according to argument <code>...</code> and placed after the others.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- mutate_(CO2,z=~conc/uptake)
head(tmp)

# Return an warning: expression mean(uptake) get a result with 'nrow' different from 'df'
# tmp &lt;- mutate_(CO2,mean=~mean(uptake))

tmp &lt;- mutate_(CO2,z1=~uptake/conc,y=~conc/100)
head(tmp)

tmp &lt;- transmutate_(CO2,z2=~uptake/conc,y2=~conc/100)
head(tmp)
</code></pre>

<hr>
<h2 id='reshape'>Reshape a data.frame</h2><span id='topic+gather_'></span><span id='topic+spread_'></span>

<h3>Description</h3>

<p>Reshape a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_(df, new_col_name = "parameters", new_col_values = "values",
  pivot)

spread_(df, col_name, col_values, pivot)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="reshape_+3A_new_col_name">new_col_name</code></td>
<td>
<p>name of the new column 'parameters'</p>
</td></tr>
<tr><td><code id="reshape_+3A_new_col_values">new_col_values</code></td>
<td>
<p>name of the new columns 'values'</p>
</td></tr>
<tr><td><code id="reshape_+3A_col_name">col_name</code></td>
<td>
<p>name of the column 'parameters'</p>
</td></tr>
<tr><td><code id="reshape_+3A_col_values">col_values</code></td>
<td>
<p>name of the new columns 'values'</p>
</td></tr>
<tr><td><code id="reshape_+3A_pivot">pivot</code></td>
<td>
<p>name of the columns used as pivot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A data frame is said 'wide' if several of its columns describe connected information of the same record.
A data frame is said ‘long’ if two of its columns provide information about records, with one describing their name and the second their value.
Functions <code>gather_()</code> and <code>spread_()</code> enable to reshape a data frames from a ‘wide’ format to a 'long' format, and vice-versa.
</p>


<h3>Value</h3>

<p>The functions return a data frame.
</p>

<ul>
<li><p> Output from function <code>gather_()</code> get 'pivot' columns determined by argument <code>pivot</code>, and 'long' columns named according to arguments <code>new_col_name</code> and <code>new_col_values</code>.
</p>
</li>
<li><p> Output from function <code>spread_()</code> get 'pivot' columns determined by argument <code>pivot</code>, and 'wide' columns named according to values in column determined by argument <code>col_name</code>.
For 'wide' columns, each row corresponds to values present in column determined by argument <code>col_values</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
df3 &lt;- data.frame(id = 1:4,
                    age = c(40,50,60,50),
                    dose.a1 = c(1,2,1,2),
                    dose.a2 = c(2,1,2,1),
                    dose.a14 = c(3,3,3,3))

gather_(df3,pivot = c("id","age"))

df4 &lt;- gather_(df3,pivot = c("id","age"))
df5 &lt;- rbind(df4,
    data.frame(id=5, age=20,parameters="dose.a14",values=8),
    data.frame(id=6, age=10,parameters="dose.a1",values=5))

spread_(df5,col_name="parameters",col_values="values",pivot=c("id","age"))

</code></pre>

<hr>
<h2 id='select'>select columns of a data.frame</h2><span id='topic+select_'></span>

<h3>Description</h3>

<p>Select columns of a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_(df, variable = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="select_+3A_variable">variable</code></td>
<td>
<p>formula that describes the selection</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>select_()</code> returns a data frame.
Properties:
</p>

<ul>
<li><p> Only columns following the condtion determined by </p>
</li>
<li><p>variable appear.
</p>
</li>
<li><p> Rows are not modified.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
  tmp &lt;- select_(CO2,~Type)
  head(tmp)

  tmp &lt;- select_(CO2,~c(Plant,Type))
  head(tmp)

  tmp &lt;- select_(CO2,~-Type)
  head(tmp)

  tmp &lt;- select_(CO2,variable=~-(Plant:Treatment))
  head(tmp)
</code></pre>

<hr>
<h2 id='summarise'>Summarise formula on groups </h2><span id='topic+summarise_'></span>

<h3>Description</h3>

<p>Summarise of formulas on a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_(df, group = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="summarise_+3A_group">group</code></td>
<td>
<p>formula that describes the group</p>
</td></tr>
<tr><td><code id="summarise_+3A_...">...</code></td>
<td>
<p>formulas to be generated</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summarise_()</code> returns a data frame.
If argument <code>group</code> is not <code>NULL</code>, output get its first columns called according to the names present in argument <code>group</code>.
The following columns are called according to the name of each argument present in <code>...</code>.
Each row corresponds to processed expressions determined in <code>...</code> for each group determined in <code>group</code>, or over the whole data frame if <code>group</code> is <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  summarise_(CO2,a=~mean(uptake),b=~sd(uptake))

  summarise_(CO2, group=~c(Type,Treatment),a=~mean(uptake),b=~sd(uptake))

</code></pre>

<hr>
<h2 id='value'>get or assign a value to a data.frame</h2><span id='topic+value_'></span><span id='topic+modify_+3C-'></span>

<h3>Description</h3>

<p>Get or assign a value to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_(df, i, j)

'modify_&lt;-'(df,i,j,value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="value_+3A_i">i</code></td>
<td>
<p>row</p>
</td></tr>
<tr><td><code id="value_+3A_j">j</code></td>
<td>
<p>column</p>
</td></tr>
<tr><td><code id="value_+3A_value">value</code></td>
<td>
<p>value to be assigned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>value_</code> and <code>'modify_&lt;-'</code> return a data frame.
Properties:
</p>

<ul>
<li><p> Only rows determined by </p>
</li>
<li><p>i appear. If </p>
</li>
<li><p>i is missing, no row is filtered.
</p>
</li>
<li><p> Only columns determined by </p>
</li>
<li><p>j appear. If </p>
</li>
<li><p>j is missing, no column is filtered.
</p>
</li></ul>

<p>Besides,
</p>

<ul>
<li><p> For function <code>value_</code>:
If argument <code>i</code> is non-missing and argument <code>j</code> is missing, the function returns an object of the same type as <code>df</code>.
If both arguments <code>i</code> and <code>j</code> are missing, the function returns an object of the same type as <code>df</code>.
</p>
</li>
<li><p> For function <code>'modify_&lt;-'</code>:
The function returns an object of the same type as <code>df</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
tmp &lt;- value_(CO2,1,2)
attributes(tmp) # data frame

tmp &lt;- value_(CO2,1:2,2)
attributes(tmp) # data frame

tmp &lt;- value_(CO2,1:2,2:4)
attributes(tmp) # data frame

tmp &lt;- value_(CO2,,2)
attributes(tmp) # data frame

tmp &lt;- value_(CO2,2)
attributes(tmp) # same as CO2

tmp &lt;- value_(CO2)
attributes(tmp) # same as CO2

df3 &lt;- data.frame(id = 1:4,
                      age = c(40,50,60,50),
                      dose.a1 = c(1,2,1,2),
                      dose.a2 = c(2,1,2,1),
                      dose.a14 = c(3,3,3,3))


'modify_&lt;-'(df3,1,2,6)

'modify_&lt;-'(df3,1:3,2:4,data.frame(c(20,10,90),c(9,3,4),c(0,0,0)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
