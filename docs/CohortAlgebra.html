<!DOCTYPE html><html><head><title>Help for package CohortAlgebra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CohortAlgebra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CohortAlgebra-package'><p>CohortAlgebra: Use of Interval Algebra to Create New Cohort(s) from Existing Cohorts</p></a></li>
<li><a href='#appendCohortTables'><p>Append cohort data from multiple cohort tables(s)</p></a></li>
<li><a href='#copyCohorts'><p>Copy cohorts from one table to another</p></a></li>
<li><a href='#deleteCohort'><p>Delete cohort</p></a></li>
<li><a href='#eraFyCohorts'><p>Era-fy cohort(s)</p></a></li>
<li><a href='#getCohortIdsInCohortTable'><p>Get cohort ids in table</p></a></li>
<li><a href='#intersectCohorts'><p>Intersect cohort(s)</p></a></li>
<li><a href='#minusCohorts'><p>Minus cohort(s)</p></a></li>
<li><a href='#reindexCohortsByDays'><p>Reindex cohort(s) by relative days</p></a></li>
<li><a href='#removeOverlappingSubjects'><p>Remove subjects in cohort that overlap with another cohort</p></a></li>
<li><a href='#unionCohorts'><p>Union cohort(s)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Use of Interval Algebra to Create New Cohort(s) from Existing
Cohorts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gowtham Rao &lt;rao@ohdsi.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This software tool is designed to generate new cohorts utilizing data from 
    previously instantiated cohorts. It employs interval algebra operators such as UNION, 
    INTERSECT, and MINUS to manipulate the data within the instantiated cohorts and 
    create new cohorts.</td>
</tr>
<tr>
<td>Depends:</td>
<td>DatabaseConnector (&ge; 5.0.0), R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, dplyr, lifecycle, rlang, SqlRender</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Andromeda, knitr, rmarkdown, testthat, withr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/LICENSE-1.1">Apache License version 1.1</a> | <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License version 2.0</a> [expanded from: Apache License]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/OHDSI/CohortAlgebra">https://github.com/OHDSI/CohortAlgebra</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OHDSI/CohortAlgebra/issues">https://github.com/OHDSI/CohortAlgebra/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-03 18:32:46 UTC; admin_grao9</td>
</tr>
<tr>
<td>Author:</td>
<td>Gowtham Rao [aut, cre],
  Observational Health Data Science and Informatics [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-04 09:48:51 UTC</td>
</tr>
</table>
<hr>
<h2 id='CohortAlgebra-package'>CohortAlgebra: Use of Interval Algebra to Create New Cohort(s) from Existing Cohorts</h2><span id='topic+CohortAlgebra-package'></span>

<h3>Description</h3>

<p>This software tool is designed to generate new cohorts utilizing data from previously instantiated cohorts. It employs interval algebra operators such as UNION, INTERSECT, and MINUS to manipulate the data within the instantiated cohorts and create new cohorts.
</p>
<p>This software tool is designed to generate new cohorts utilizing data from previously instantiated cohorts. It employs interval algebra operators such as UNION, INTERSECT, and MINUS to manipulate the data within the instantiated cohorts and create new cohorts.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gowtham Rao <a href="mailto:rao@ohdsi.org">rao@ohdsi.org</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Observational Health Data Science and Informatics [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/OHDSI/CohortAlgebra">https://github.com/OHDSI/CohortAlgebra</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/OHDSI/CohortAlgebra/issues">https://github.com/OHDSI/CohortAlgebra/issues</a>
</p>
</li></ul>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/OHDSI/CohortAlgebra">https://github.com/OHDSI/CohortAlgebra</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/OHDSI/CohortAlgebra/issues">https://github.com/OHDSI/CohortAlgebra/issues</a>
</p>
</li></ul>


<hr>
<h2 id='appendCohortTables'>Append cohort data from multiple cohort tables(s)</h2><span id='topic+appendCohortTables'></span>

<h3>Description</h3>

<p>Append cohort data from multiple cohort tables.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendCohortTables(
  connectionDetails = NULL,
  connection = NULL,
  sourceTables,
  targetCohortDatabaseSchema = NULL,
  targetCohortTable,
  isTempTable = FALSE,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendCohortTables_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="appendCohortTables_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="appendCohortTables_+3A_sourcetables">sourceTables</code></td>
<td>
<p>A data.frame object with the columns sourceCohortDatabaseSchema, sourceCohortTableName.</p>
</td></tr>
<tr><td><code id="appendCohortTables_+3A_targetcohortdatabaseschema">targetCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your target cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="appendCohortTables_+3A_targetcohorttable">targetCohortTable</code></td>
<td>
<p>The name of the target cohort table.</p>
</td></tr>
<tr><td><code id="appendCohortTables_+3A_istemptable">isTempTable</code></td>
<td>
<p>Is the output a temp table. If yes, a new temp table is created. This will required
an active connection. Any old temp table is dropped and replaced.</p>
</td></tr>
<tr><td><code id="appendCohortTables_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>

<hr>
<h2 id='copyCohorts'>Copy cohorts from one table to another</h2><span id='topic+copyCohorts'></span>

<h3>Description</h3>

<p>Copy cohorts from one table to another table. If the new cohort table
has any cohort id that matches the cohort id being copied, an error will
be displayed.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copyCohorts(
  connectionDetails = NULL,
  connection = NULL,
  oldToNewCohortId,
  sourceCohortDatabaseSchema = NULL,
  targetCohortDatabaseSchema = sourceCohortDatabaseSchema,
  sourceCohortTable,
  targetCohortTable,
  isTempTable = FALSE,
  purgeConflicts = FALSE,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copyCohorts_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="copyCohorts_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="copyCohorts_+3A_oldtonewcohortid">oldToNewCohortId</code></td>
<td>
<p>A data.frame object with two columns. oldCohortId and newCohortId. Both should be integers.
The oldCohortId are the cohorts that are the input cohorts that need to be transformed.
The newCohortId are the cohortIds of the corresponding output after transformation.
If the oldCohortId = newCohortId then the data corresponding to oldCohortId
will be replaced by the data from the newCohortId.</p>
</td></tr>
<tr><td><code id="copyCohorts_+3A_sourcecohortdatabaseschema">sourceCohortDatabaseSchema</code></td>
<td>
<p>The database schema of the source cohort table.</p>
</td></tr>
<tr><td><code id="copyCohorts_+3A_targetcohortdatabaseschema">targetCohortDatabaseSchema</code></td>
<td>
<p>The database schema of the source cohort table.</p>
</td></tr>
<tr><td><code id="copyCohorts_+3A_sourcecohorttable">sourceCohortTable</code></td>
<td>
<p>The name of the source cohort table.</p>
</td></tr>
<tr><td><code id="copyCohorts_+3A_targetcohorttable">targetCohortTable</code></td>
<td>
<p>The name of the target cohort table.</p>
</td></tr>
<tr><td><code id="copyCohorts_+3A_istemptable">isTempTable</code></td>
<td>
<p>Is the output a temp table. If yes, a new temp table is created. This will required
an active connection. Any old temp table is dropped and replaced.</p>
</td></tr>
<tr><td><code id="copyCohorts_+3A_purgeconflicts">purgeConflicts</code></td>
<td>
<p>If there are conflicts in the target cohort table i.e. the target cohort table
already has records with newCohortId, do you want to purge and replace them
with transformed. By default - it will not be replaced, and an error message is thrown.</p>
</td></tr>
<tr><td><code id="copyCohorts_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>

<hr>
<h2 id='deleteCohort'>Delete cohort</h2><span id='topic+deleteCohort'></span>

<h3>Description</h3>

<p>Delete all records for a given set of cohorts from the cohort table. Edit privileges
to the cohort table is required.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteCohort(
  connectionDetails = NULL,
  connection = NULL,
  cohortDatabaseSchema,
  cohortTable = "cohort",
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  cohortIds
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteCohort_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="deleteCohort_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="deleteCohort_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="deleteCohort_+3A_cohorttable">cohortTable</code></td>
<td>
<p>The name of the cohort table.</p>
</td></tr>
<tr><td><code id="deleteCohort_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="deleteCohort_+3A_cohortids">cohortIds</code></td>
<td>
<p>A vector of one or more Cohort Ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>

<hr>
<h2 id='eraFyCohorts'>Era-fy cohort(s)</h2><span id='topic+eraFyCohorts'></span>

<h3>Description</h3>

<p>Given a table with cohort_definition_id, subject_id, cohort_start_date,
cohort_end_date execute era logic. This will delete and replace the
original rows with the cohort_definition_id(s). edit privileges
to the cohort table is required.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eraFyCohorts(
  connectionDetails = NULL,
  connection = NULL,
  sourceCohortDatabaseSchema = NULL,
  sourceCohortTable = "cohort",
  targetCohortDatabaseSchema = NULL,
  targetCohortTable,
  oldCohortIds,
  newCohortId,
  eraconstructorpad = 0,
  cdmDatabaseSchema = NULL,
  purgeConflicts = FALSE,
  isTempTable = FALSE,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eraFyCohorts_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_sourcecohortdatabaseschema">sourceCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your source cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_sourcecohorttable">sourceCohortTable</code></td>
<td>
<p>The name of the source cohort table.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_targetcohortdatabaseschema">targetCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your target cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_targetcohorttable">targetCohortTable</code></td>
<td>
<p>The name of the target cohort table.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_oldcohortids">oldCohortIds</code></td>
<td>
<p>An array of 1 or more integer id representing the cohort id of the cohort
on which the function will be applied.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_newcohortid">newCohortId</code></td>
<td>
<p>The cohort id of the output cohort.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_eraconstructorpad">eraconstructorpad</code></td>
<td>
<p>Optional value to pad cohort era construction logic. Default = 0. i.e. no padding.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_cdmdatabaseschema">cdmDatabaseSchema</code></td>
<td>
<p>Schema name where your patient-level data in OMOP CDM format resides.
Note that for SQL Server, this should include both the database and
schema name, for example 'cdm_data.dbo'.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_purgeconflicts">purgeConflicts</code></td>
<td>
<p>If there are conflicts in the target cohort table i.e. the target cohort table
already has records with newCohortId, do you want to purge and replace them
with transformed. By default - it will not be replaced, and an error message is thrown.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_istemptable">isTempTable</code></td>
<td>
<p>Is the output a temp table. If yes, a new temp table is created. This will required
an active connection. Any old temp table is dropped and replaced.</p>
</td></tr>
<tr><td><code id="eraFyCohorts_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>

<hr>
<h2 id='getCohortIdsInCohortTable'>Get cohort ids in table</h2><span id='topic+getCohortIdsInCohortTable'></span>

<h3>Description</h3>

<p>Get cohort ids in table
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCohortIdsInCohortTable(
  connection = NULL,
  cohortDatabaseSchema = NULL,
  cohortTable,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCohortIdsInCohortTable_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="getCohortIdsInCohortTable_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="getCohortIdsInCohortTable_+3A_cohorttable">cohortTable</code></td>
<td>
<p>The name of the cohort table.</p>
</td></tr>
<tr><td><code id="getCohortIdsInCohortTable_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of integers called cohort id.
</p>

<hr>
<h2 id='intersectCohorts'>Intersect cohort(s)</h2><span id='topic+intersectCohorts'></span>

<h3>Description</h3>

<p>Find the common cohort period for persons present in all the cohorts. Note: if
subject is not found in any of the cohorts, then they will not
be in the final cohort.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectCohorts(
  connectionDetails = NULL,
  connection = NULL,
  sourceCohortDatabaseSchema = NULL,
  sourceCohortTable,
  targetCohortDatabaseSchema = NULL,
  targetCohortTable,
  cohortIds,
  newCohortId,
  purgeConflicts = FALSE,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersectCohorts_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_sourcecohortdatabaseschema">sourceCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your source cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_sourcecohorttable">sourceCohortTable</code></td>
<td>
<p>The name of the source cohort table.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_targetcohortdatabaseschema">targetCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your target cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_targetcohorttable">targetCohortTable</code></td>
<td>
<p>The name of the target cohort table.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_cohortids">cohortIds</code></td>
<td>
<p>A vector of one or more Cohort Ids.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_newcohortid">newCohortId</code></td>
<td>
<p>The cohort id of the output cohort.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_purgeconflicts">purgeConflicts</code></td>
<td>
<p>If there are conflicts in the target cohort table i.e. the target cohort table
already has records with newCohortId, do you want to purge and replace them
with transformed. By default - it will not be replaced, and an error message is thrown.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>

<hr>
<h2 id='minusCohorts'>Minus cohort(s)</h2><span id='topic+minusCohorts'></span>

<h3>Description</h3>

<p>Given two cohorts, substract (minus) the dates from the first cohort, the
dates the subject also had on the second cohort.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minusCohorts(
  connectionDetails = NULL,
  connection = NULL,
  sourceCohortDatabaseSchema = NULL,
  sourceCohortTable = "cohort",
  targetCohortDatabaseSchema = sourceCohortDatabaseSchema,
  targetCohortTable = sourceCohortTable,
  firstCohortId,
  secondCohortId,
  newCohortId,
  purgeConflicts = FALSE,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minusCohorts_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_sourcecohortdatabaseschema">sourceCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your source cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_sourcecohorttable">sourceCohortTable</code></td>
<td>
<p>The name of the source cohort table.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_targetcohortdatabaseschema">targetCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your target cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_targetcohorttable">targetCohortTable</code></td>
<td>
<p>The name of the target cohort table.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_firstcohortid">firstCohortId</code></td>
<td>
<p>The cohort id of the cohort from which to subtract.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_secondcohortid">secondCohortId</code></td>
<td>
<p>The cohort id of the cohort that is used to subtract.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_newcohortid">newCohortId</code></td>
<td>
<p>The cohort id of the output cohort.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_purgeconflicts">purgeConflicts</code></td>
<td>
<p>If there are conflicts in the target cohort table i.e. the target cohort table
already has records with newCohortId, do you want to purge and replace them
with transformed. By default - it will not be replaced, and an error message is thrown.</p>
</td></tr>
<tr><td><code id="minusCohorts_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>

<hr>
<h2 id='reindexCohortsByDays'>Reindex cohort(s) by relative days</h2><span id='topic+reindexCohortsByDays'></span>

<h3>Description</h3>

<p>reindexCohort changes the cohort_start_date and/or cohort_end_date of
one or more source cohorts based on a set of reindexing rules. The output
is a one or more valid target cohorts.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reindexCohortsByDays(
  connectionDetails = NULL,
  connection = NULL,
  sourceCohortDatabaseSchema = NULL,
  sourceCohortTable = "cohort",
  sourceCohortIds,
  targetCohortDatabaseSchema = NULL,
  targetCohortTable,
  offsetStartAnchor = "cohort_start_date",
  offsetEndAnchor = "cohort_end_date",
  reindexRules,
  cdmDatabaseSchema = NULL,
  purgeConflicts = FALSE,
  isTempTable = FALSE,
  bulkLoad = Sys.getenv("DATABASE_CONNECTOR_BULK_UPLOAD"),
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reindexCohortsByDays_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_sourcecohortdatabaseschema">sourceCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your source cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_sourcecohorttable">sourceCohortTable</code></td>
<td>
<p>The name of the source cohort table.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_sourcecohortids">sourceCohortIds</code></td>
<td>
<p>An array of one or more cohortIds in the source cohort table.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_targetcohortdatabaseschema">targetCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your target cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_targetcohorttable">targetCohortTable</code></td>
<td>
<p>The name of the target cohort table.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_offsetstartanchor">offsetStartAnchor</code></td>
<td>
<p>Determines the anchor point for the start of the reindexing. It can be either
cohort_start_date or cohort_end_date of sourceCohort.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_offsetendanchor">offsetEndAnchor</code></td>
<td>
<p>Determines the anchor point for the end of the reindexing. It can be either
cohort_start_date or cohort_end_date of targetCohort.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_reindexrules">reindexRules</code></td>
<td>
<p>A data frame specifying the reindexing rules. It should contain the following columns: 'offsetId'
a unique key for identifying the newly generated cohorts. Each offsetId corresponds to a
specific reindex rule and will be used to create new cohort id in targetCohort. 'offsetStartValue'
is an integer value indicating the number of days to 'offsetStartAnchor'. A positive
values will extend, while negative values will shorten the start date from
the 'offsetStartAnchor'. offsetEndValue' An integer value indicating the number of
days to offset the end date. Positive values will extend, while negative values will
shorten the end date from the 'offsetEndAnchor'.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_cdmdatabaseschema">cdmDatabaseSchema</code></td>
<td>
<p>Schema name where your patient-level data in OMOP CDM format resides.
Note that for SQL Server, this should include both the database and
schema name, for example 'cdm_data.dbo'.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_purgeconflicts">purgeConflicts</code></td>
<td>
<p>If there are conflicts in the target cohort table i.e. the target cohort table
already has records with newCohortId, do you want to purge and replace them
with transformed. By default - it will not be replaced, and an error message is thrown.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_istemptable">isTempTable</code></td>
<td>
<p>Is the output a temp table. If yes, a new temp table is created. This will required
an active connection. Any old temp table is dropped and replaced.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_bulkload">bulkLoad</code></td>
<td>
<p>See 'insertTable' function in 'DatabaseConnector'.</p>
</td></tr>
<tr><td><code id="reindexCohortsByDays_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If output is temp table, then the name of the temp table is returned.
</p>

<hr>
<h2 id='removeOverlappingSubjects'>Remove subjects in cohort that overlap with another cohort</h2><span id='topic+removeOverlappingSubjects'></span>

<h3>Description</h3>

<p>Remove subjects in cohort that overlap with another cohort. Given a Cohort A, check if the records of
subjects in cohort A overlaps with records for the same subject in cohort B. If there is overlap
then remove all records of that subject from Cohort A.
Overlap is defined as b.cohort_end_date &gt;= a.cohort_start_date AND b.cohort_start_date &lt;= a.cohort_end_date.
The overlap logic maybe offset by using a startDayOffSet (applied on cohort A's cohort_start_date)
and endDayOffSet (applied on Cohort A's cohort_end_date). If while applying offset, the window becomes
such that (a.cohort_start_date + startDayOffSet) &gt; (a.cohort_end_date + endDayOffset) that record is ignored
and thus deleted.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeOverlappingSubjects(
  connectionDetails = NULL,
  connection = NULL,
  cohortDatabaseSchema,
  cohortId,
  newCohortId,
  cohortsWithSubjectsToRemove,
  offsetCohortStartDate = -99999,
  offsetCohortEndDate = 99999,
  restrictSecondCohortStartBeforeFirstCohortStart = FALSE,
  restrictSecondCohortStartAfterFirstCohortStart = FALSE,
  cohortTable = "cohort",
  purgeConflicts = FALSE,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeOverlappingSubjects_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_cohortid">cohortId</code></td>
<td>
<p>The cohort id of the cohort whose subjects will be removed.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_newcohortid">newCohortId</code></td>
<td>
<p>The cohort id of the output cohort.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_cohortswithsubjectstoremove">cohortsWithSubjectsToRemove</code></td>
<td>
<p>An array of one or more cohorts with subjects to remove from given cohorts.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_offsetcohortstartdate">offsetCohortStartDate</code></td>
<td>
<p>(Default = 0) If you want to offset cohort start date, please provide a integer number.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_offsetcohortenddate">offsetCohortEndDate</code></td>
<td>
<p>(Default = 0) If you want to offset cohort start date, please provide a integer number.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_restrictsecondcohortstartbeforefirstcohortstart">restrictSecondCohortStartBeforeFirstCohortStart</code></td>
<td>
<p>(Default = FALSE) If TRUE, then the secondCohort's cohort_start_date
should be &lt; firstCohort's cohort_start_date.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_restrictsecondcohortstartafterfirstcohortstart">restrictSecondCohortStartAfterFirstCohortStart</code></td>
<td>
<p>(Default = FALSE) If TRUE, then the secondCohort's cohort_start_date
should be &gt; firstCohort's cohort_start_date.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_cohorttable">cohortTable</code></td>
<td>
<p>The name of the cohort table.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_purgeconflicts">purgeConflicts</code></td>
<td>
<p>If there are conflicts in the target cohort table i.e. the target cohort table
already has records with newCohortId, do you want to purge and replace them
with transformed. By default - it will not be replaced, and an error message is thrown.</p>
</td></tr>
<tr><td><code id="removeOverlappingSubjects_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>

<hr>
<h2 id='unionCohorts'>Union cohort(s)</h2><span id='topic+unionCohorts'></span>

<h3>Description</h3>

<p>Given a specified array of cohortIds in a cohort table, perform
cohort union operator to create new cohorts.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unionCohorts(
  connectionDetails = NULL,
  connection = NULL,
  sourceCohortDatabaseSchema = NULL,
  sourceCohortTable,
  targetCohortDatabaseSchema = NULL,
  targetCohortTable,
  oldToNewCohortId,
  isTempTable = FALSE,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  purgeConflicts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unionCohorts_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_sourcecohortdatabaseschema">sourceCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your source cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_sourcecohorttable">sourceCohortTable</code></td>
<td>
<p>The name of the source cohort table.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_targetcohortdatabaseschema">targetCohortDatabaseSchema</code></td>
<td>
<p>Schema name where your target cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_targetcohorttable">targetCohortTable</code></td>
<td>
<p>The name of the target cohort table.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_oldtonewcohortid">oldToNewCohortId</code></td>
<td>
<p>A data.frame object with two columns. oldCohortId and newCohortId. Both should be integers.
The oldCohortId are the cohorts that are the input cohorts that need to be transformed.
The newCohortId are the cohortIds of the corresponding output after transformation.
If the oldCohortId = newCohortId then the data corresponding to oldCohortId
will be replaced by the data from the newCohortId.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_istemptable">isTempTable</code></td>
<td>
<p>Is the output a temp table. If yes, a new temp table is created. This will required
an active connection. Any old temp table is dropped and replaced.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_purgeconflicts">purgeConflicts</code></td>
<td>
<p>If there are conflicts in the target cohort table i.e. the target cohort table
already has records with newCohortId, do you want to purge and replace them
with transformed. By default - it will not be replaced, and an error message is thrown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
