<!DOCTYPE html><html lang="en"><head><title>Help for package synlik</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {synlik}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#synlik-package'>
<p>Synthetic Likelihood Methods for Intractable Likelihoods</p></a></li>
<li><a href='#ANYOrNULL-class'><p>Dummy class</p></a></li>
<li><a href='#bf'><p>Nicholson's 1954 blowfly data</p></a></li>
<li><a href='#blow_sl'><p>Blowfly model</p></a></li>
<li><a href='#blowSimul'><p>Simulates from the blowfly model</p></a></li>
<li><a href='#checkNorm'><p>Checking the multivariate normal approximation.</p></a></li>
<li><a href='#continue'><p>Continuing estimation.</p></a></li>
<li><a href='#extractCorr'><p>Extracting correlations from a covariance matrix</p></a></li>
<li><a href='#functionOrNULL-class'><p>Dummy class</p></a></li>
<li><a href='#internal_C'><p>Internal C and C++ function</p></a></li>
<li><a href='#nlar'><p>Estimate non-linear autoregressive coefficients</p></a></li>
<li><a href='#numericOrNULL-class'><p>Dummy class</p></a></li>
<li><a href='#orderDist'><p>Summarize marginal distribution of (differenced) series.</p></a></li>
<li><a href='#plot-smcmc'><p>Plotting objects of class <code>smcmc</code>.</p></a></li>
<li><a href='#plot-synlik'><p>Method for plotting an object of class <code>synlik</code>.</p></a></li>
<li><a href='#ricker_sl'><p>Ricker model</p></a></li>
<li><a href='#rickerSimul'><p>Simulates from the ricker model</p></a></li>
<li><a href='#robCov'><p>Robust covariance matrix estimation</p></a></li>
<li><a href='#simulate+2Csynlik-method'><p>Simulate data or statistics from an object of class <code>synlik</code>.</p></a></li>
<li><a href='#slAcf'><p>Estimate auto-covariances for multiple datasets.</p></a></li>
<li><a href='#slice'><p>Plot slices of the synthetic log-likelihood.</p></a></li>
<li><a href='#slik'><p>Evaluates the synthetic log-likelihood.</p></a></li>
<li><a href='#smcmc'><p>MCMC parameter estimation for objects of class <code>synlik</code>.</p></a></li>
<li><a href='#smcmc-class'><p><code>smcmc-class</code></p></a></li>
<li><a href='#synlik-class'><p><code>synlik-class</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Synthetic Likelihood Methods for Intractable Likelihoods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Matteo Fasiolo and Simon Wood</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Framework to perform synthetic likelihood inference
    for models where the likelihood function is unavailable or
    intractable.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://mfasiolo.github.io/synlik_release/">http://mfasiolo.github.io/synlik_release/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), Rcpp (&ge; 0.12.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, graphics, Matrix, compiler, stats, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, stabledist</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-02 12:05:29 UTC; mf15002</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-02 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='synlik-package'>
Synthetic Likelihood Methods for Intractable Likelihoods
</h2><span id='topic+synlik-package'></span>

<h3>Description</h3>

<p>Package that provides Synthetic Likelihood methods for intractable likelihoods. The package is meant to be as general purpose
as possible: as long as you are able to simulate data from your model you should be able to fit it.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> synlik</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.2 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-05-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package allows users to create objects of class <code>synlik</code> (S4), which are essentially constituted of a <code>simulator</code> function and 
a function (<code>summaries</code>) that transforms the data into summary statistics. The <code>simulator</code> can output any kind of data (vector, list, etc)
and this will be passed directly to the <code>summaries</code> function. This allow the package to fit a large variety of models. <br />
</p>
<p>Once the model of interest has been set up as a <code>synlik</code> object, it is possible several methods on it. The function most useful function is <code>slik</code>, which can be used to evaluate the synthetic likelihood. The <code>slice.synlik</code> function allows to obtain and plot slices of the synthetic likelihood with respect to model parameters. It is possible to simulate data or statistics from the model using the generic <code>simulate</code>, and to check the normality of the statistics using the <code>checkNorm</code> function. Unknow parameters can be estimated by MCMC, through the <code>smcmc</code> function. This function will return an object of class <code>smcmc</code> (S4), which contains all the inputs and results of the MCMC procedure. <br />
</p>
<p>Many functions in the package support parallel simulation on multiple cores.
</p>


<h3>Author(s)</h3>

<p>Matteo Fasiolo and Simon N. Wood
</p>
<p>Maintainer: Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;
</p>


<h3>References</h3>

<p>Simon N Wood. Statistical inference for noisy nonlinear ecological dynamic systems. Nature, 466(7310):1102&ndash;1104, 2010.
</p>


<h3>See Also</h3>

<p>For some examples see the Vignettes (type <code>vignette("synlik")</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#### Here I put a simple example, 
#### if you want to see more type: vignette("synlik")

## End(Not run)

#### Create synlik object
ricker_sl &lt;- synlik(simulator = rickerSimul,
                    summaries = rickerStats,
                    param = c(logR = 3.8, logSigma = log(0.3), logPhi = log(10)),
                    extraArgs = list("nObs" = 50, "nBurn" = 50),
                    plotFun = function(input, ...){
                               plot(drop(input), type = 'l', ylab = "Pop", xlab = "Time", ...)
                            }
)

#### Simulate from the object
ricker_sl@data &lt;- simulate(ricker_sl)
ricker_sl@extraArgs$obsData &lt;- ricker_sl@data

#### Simulate statistics (each row is a vector of statistics)
simulate(ricker_sl, seed = 523, nsim = 10, stats = TRUE)

#### Plotting the data
plot(ricker_sl)

#### Checking multivariate normality of the statistics
checkNorm(ricker_sl)

#### Evaluate the likelihood
set.seed(4234)
slik(ricker_sl, 
     param  = c(logR = 3.8, logSigma = log(0.3), logPhi = log(10)),
     nsim    = 1e3)

#### Plotting a slice of the log-Likelihood possibly using multiple cores
slice(object = ricker_sl, 
      ranges = list("logR" = seq(3.5, 3.9, by = 0.02),
                    "logPhi" = seq(2, 2.6, by = 0.02),
                    "logSigma" = seq(-2, -0.5, by = 0.05)), 
      param = c(logR = 3.8, logSigma = log(0.3), logPhi = log(10)), 
      nsim = 500, multicore = FALSE)

#### MCMC estimation possibly using multiple cores
set.seed(4235)
ricker_sl &lt;- smcmc(ricker_sl, 
                   initPar = c(3.2, -1, 2.6),
                   niter = 50, 
                   burn = 3,
                   priorFun = function(input, ...) 0, 
                   propCov = diag(c(0.1, 0.1, 0.1))^2, 
                   nsim = 1e3, 
                   multicore = FALSE)

# Continue with additional 50 iterations
ricker_sl &lt;- continue(ricker_sl, niter = 50)

# Plotting results on transformed scale (exponential)
trans &lt;- rep("exp", 3)
names(trans) &lt;- names(ricker_sl@param)

plot(ricker_sl)
</code></pre>

<hr>
<h2 id='ANYOrNULL-class'>Dummy class</h2><span id='topic+ANYOrNULL-class'></span>

<h3>Description</h3>

<p>Class unions for internal use only
</p>

<hr>
<h2 id='bf'>Nicholson's 1954 blowfly data</h2><span id='topic+bf'></span><span id='topic+bf1'></span><span id='topic+bf2'></span><span id='topic+bf3'></span>

<h3>Description</h3>

<p>Data from figures 3 and 4 of Nicholson, 1954. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bf1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bf_+3A_bf1">bf1</code></td>
<td>
<p>the dataset name</p>
</td></tr>
</table>


<h3>Details</h3>

 <p><code>bf1</code> is Nisbet and Gurney's run 1, and Nicholson's (1954) figure 3 (adult food limitation). The 
data are actually from the global population dynamics database at Silwood. They are daily: Nicholson's figure 3 
plots data every other day, but the text says that measurements were taken daily. However elsewhere they are 
reported every other day. Probably best to assume that they have been interpolated to daily.
</p>
<p><code>bf2</code> and <code>bf3</code> are digitized from Nicholson's (1954) figure 4. <code>bf2</code> is the upper series: 
larval food limitation, with 50g per day of larval food provided. <code>bf3</code> is the lower series: same set up, half as much food. 
These are Nisbet and Gurney's runs 2 and 3, respectively.
</p>


<h3>Value</h3>

<p>matrix of replicate data series
</p>


<h3>Author(s)</h3>

<p> Simon N. Wood, maintainer Matteo Fasiolo &lt;matteo.fasiolo@@gmail.com&gt;</p>


<h3>References</h3>

<p>Alexander J Nicholson. An outline of the dynamics of animal populations. Australian
Journal of Zoology, 2(1):9&ndash;65, 1954.
</p>


<h3>See Also</h3>

  
<p>blowfly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(synlik)
  data(bf1)
  data(bf2)
  data(bf3)
  par(mfrow=c(3,1),mar=c(4,4,1,1))
  with(bf1,plot(day,pop,type="l"))
  with(bf1,points(day,pop,pch=20,cex=.8))
  abline(mean(bf1$pop),0,col=2); abline(median(bf1$pop),0,col=3);
  with(bf2,plot(day,pop,type="l"))
  with(bf2,points(day,pop,pch=20,cex=.8))
  abline(mean(bf2$pop),0,col=2); abline(median(bf2$pop),0,col=3);
  with(bf3,plot(day,pop,type="l"))
  with(bf3,points(day,pop,pch=20,cex=.8))
  abline(mean(bf3$pop),0,col=2); abline(median(bf3$pop),0,col=3);
</code></pre>

<hr>
<h2 id='blow_sl'>Blowfly model</h2><span id='topic+blowStats'></span><span id='topic+blow_sl'></span><span id='topic+blow_smcmc'></span>

<h3>Description</h3>

<p><code>synlik</code> object containing the blowfly model proposed by Wood (2010).
The main components are the simulator <a href="#topic+blowSimul">blowSimul</a> and the statistics
<code>blowStats</code>, described in the same reference.
</p>


<h3>Author(s)</h3>

<p>Simon Wood and Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Simon N Wood. Statistical inference for noisy nonlinear ecological dynamic systems. Nature, 466(7310):1102&ndash;1104, 2010.
</p>


<h3>See Also</h3>

<p><a href="#topic+blowSimul">blowSimul</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(blow_sl)

plot(blow_sl)
simulate(blow_sl, stats = TRUE)

slik(blow_sl, 
     param  = log( c( "delta" = 0.16, "P" = 6.5, "N0" = 400, 
                      "var.p" = 0.1, "tau" = 14, "var.d" = 0.1)  ),
     nsim    = 1e3)

# Using Nicholson's data
data(bf1)

plot(blow_sl)

blow_sl@data &lt;- bf1$pop
blow_sl@extraArgs$obsData &lt;- bf1$pop #Important: blow_sl@blowStats uses the observed data

slik(blow_sl, 
     param  = log( c( "delta" = 0.16, "P" = 6.5, "N0" = 400, 
                      "var.p" = 0.1, "tau" = 14, "var.d" = 0.1)  ),
     nsim    = 1e3)
</code></pre>

<hr>
<h2 id='blowSimul'>Simulates from the blowfly model</h2><span id='topic+blowSimul'></span>

<h3>Description</h3>

<p>Simulator for the blowfly model proposed by Wood (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blowSimul(param, nsim, extraArgs, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blowSimul_+3A_param">param</code></td>
<td>
<p>vector of log-parameters: delta, P, N0, var.p, tau and var.d. The interpretation of these parameters is
described in Wood (2010).</p>
</td></tr>
<tr><td><code id="blowSimul_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations from the model.</p>
</td></tr>
<tr><td><code id="blowSimul_+3A_extraargs">extraArgs</code></td>
<td>
<p>A named list of additional arguments: </p>

<ul>
<li><p><code>nObs</code> = Length of each simulated time series.
</p>
</li>
<li><p><code>nBurn</code> = Number of initial steps to be discarded before saving the following <code>nObs</code> steps.
</p>
</li>
<li><p><code>steps</code> = Positive integer. If <code>steps == n</code> the observations correspond to <code>n</code> time steps. 
</p>
</li></ul>
</td></tr>
<tr><td><code id="blowSimul_+3A_...">...</code></td>
<td>
<p>Need for compatibility with <code>synlik</code>, but not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code>nsim</code> by <code>nObs</code>, where each row is a simulated path.
</p>


<h3>Author(s)</h3>

<p>Simon Wood and Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Simon N Wood. Statistical inference for noisy nonlinear ecological dynamic systems. Nature, 466(7310):1102&ndash;1104, 2010. <br /> <br />
Brillinger, D. R., J. Guckenheimer, P. Guttorp, and G. Oster. 1980. 
Empirical modelling of population time series data: the case of age and density dependent 
vital rates. Lectures on Mathematics in the Life Sciences13:65-90.  <br /> <br />
Nicholson, A. J. 1957. The self-adjustment of populations to change. 
Cold Spring Harbor Symposia on Quantitative Biology22:153-173.
</p>


<h3>See Also</h3>

<p><a href="#topic+blow_sl">blow_sl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- blowSimul(param = log( c( "delta" = 0.16, "P" = 6.5, "N0" = 400, 
                                 "var.p" = 0.1, "tau" = 14, "var.d" = 0.1)  ), 
                 nsim = 2, 
                 extraArgs = list("nObs" = 200, "nBurn" = 1000, "steps" = 2))
matplot(t(tmp), type = 'l', ylab = "Y", xlab = "Time")
</code></pre>

<hr>
<h2 id='checkNorm'>Checking the multivariate normal approximation.</h2><span id='topic+checkNorm'></span>

<h3>Description</h3>

<p>Given an object of class <code>synlik</code> this routine provides a 
graphical check of whether the distribution of the random 
summary statistics is multivariate normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkNorm(object, param = object@param, nsim = 1000, observed = NULL,
  cex.axis = 1, cex.lab = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkNorm_+3A_object">object</code></td>
<td>
<p>An object of class <code>synlik</code> or a matrix where each row is a random vector.</p>
</td></tr>
<tr><td><code id="checkNorm_+3A_param">param</code></td>
<td>
<p>A vector of model's parameters at which the summary statistics will be simulated.</p>
</td></tr>
<tr><td><code id="checkNorm_+3A_nsim">nsim</code></td>
<td>
<p>number of summary statistics to be simulated if object is of class <code>synlik</code>, otherwise
it is not used.</p>
</td></tr>
<tr><td><code id="checkNorm_+3A_observed">observed</code></td>
<td>
<p>A vector of observed summary statistics. By default <code>NULL</code>, so <code>object@data</code> will be used as observed statistics.
It will be looked at only if <code>object</code> is a matrix.</p>
</td></tr>
<tr><td><code id="checkNorm_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Axis scale expansion factor.</p>
</td></tr>
<tr><td><code id="checkNorm_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Axis label expansion factor.</p>
</td></tr>
<tr><td><code id="checkNorm_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>object@simulator</code> and <code>object@summaries</code>.
In general I would avoid using it and including in <code>object@extraArgs</code> everything they need.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is from section 7.5 of Krzanowski (1988). The replicate vectors of summary statistic <code>S</code> 
are transformed to variables which should be univariate chi squared r.v.s with DoF given by the number of rows of <code>S</code>. 
An appropriate QQ-plot is produced, and the proportion of the data differing substantially from the ideal 
line is reported. Deviations at the right hand end of the plot indicate that the tail behaviour of the Normal 
approximation is poor: in the context of synthetic likelihood this is of little consequence.  
Secondly, <code>s</code> is transformed to a vector which should be i.i.d. N(0,1) under
multivariate normality, and a QQ plot is produced. Unfortunately this approach is not very
useful unless the dimension of <code>s</code> is rather large. In simulations, perfectly MVN data produce 
highly variable results, so that the approach lacks any real power.
</p>


<h3>Value</h3>

<p>Mainly produces plots and prints output. Also an array indicating 
proportion of simulated statistics smaller than observed.
</p>


<h3>Author(s)</h3>

<p>Simon N. Wood, maintained by Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Krzanowski, W.J. (1988) Principles of Multivariate Analysis. Oxford.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Create Object
data(ricker_sl)

#### Simulate from the object
ricker_sl@data &lt;- simulate(ricker_sl)
ricker_sl@extraArgs$obsData &lt;- ricker_sl@data 

#### Checking multivariate normality
checkNorm(ricker_sl)

# With matrix input
checkNorm(matrix(rnorm(200), 100, 2))
</code></pre>

<hr>
<h2 id='continue'>Continuing estimation.</h2><span id='topic+continue'></span><span id='topic+continue+2Csmcmc-method'></span>

<h3>Description</h3>

<p>Generic function, that given the results of an estimation procedure (ex. MCMC or maximum likelihood optimization)
continues the procedure for some more iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continue(object, ...)

## S4 method for signature 'smcmc'
continue(object, niter = object@niter, nsim = object@nsim,
  propCov = object@propCov, targetRate = object@targetRate,
  recompute = object@recompute, multicore = object@multicore,
  ncores = object@ncores, cluster = NULL, control = object@control, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="continue_+3A_object">object</code></td>
<td>
<p>An object representing the results of an estimation procedure which we wish to continue.
For example it might represents an MCMC chain.</p>
</td></tr>
<tr><td><code id="continue_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>slik</code> function, see <code><a href="#topic+slik">slik</a></code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_niter">niter</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_nsim">nsim</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_propcov">propCov</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_targetrate">targetRate</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_recompute">recompute</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_multicore">multicore</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_ncores">ncores</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_cluster">cluster</code></td>
<td>
<p>an object of class <code>c("SOCKcluster", "cluster")</code>. This allowes the user to pass her own cluster,
which will be used if <code>multicore == TRUE</code>. The user has to remember to stop the cluster.</p>
</td></tr>
<tr><td><code id="continue_+3A_control">control</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>is("smcmc", object) == TRUE</code>  continues MCMC estimation of an object of class <code>smcmc</code>. All input parameters are defaulted to the corresponding
slots in the input object, with the exception of cluster. The chain restarts were it ended, burn-in is set to zero, the
same prior (if any) is used.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>object</code>, where the results of the estimation have been updated.
</p>


<h3>See Also</h3>

<p>For examples, see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.
</p>

<hr>
<h2 id='extractCorr'>Extracting correlations from a covariance matrix</h2><span id='topic+extractCorr'></span>

<h3>Description</h3>

<p>Extracting correlations from a covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCorr(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractCorr_+3A_mat">mat</code></td>
<td>
<p>A covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The correlation matrix embedded in <code>mat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 dimensional case
d &lt;- 2
tmp &lt;- matrix(rnorm(d^2), d, d)
mcov &lt;- tcrossprod(tmp, tmp)

# Covariance matrix
mcov

# Correlation matrix
extractCorr(mcov)
</code></pre>

<hr>
<h2 id='functionOrNULL-class'>Dummy class</h2><span id='topic+functionOrNULL-class'></span>

<h3>Description</h3>

<p>Class unions for internal use only
</p>

<hr>
<h2 id='internal_C'>Internal C and C++ function</h2><span id='topic+blowC'></span><span id='topic+checkBoundsCpp'></span><span id='topic+cleanStats'></span><span id='topic+internal_C'></span><span id='topic+order_reg'></span><span id='topic+simpleModelsWrap'></span><span id='topic+slacf'></span><span id='topic+slnlar'></span>

<h3>Description</h3>

<p>This functions are for internal use only.
</p>


<h3>Author(s)</h3>

<p>Simon Wood and Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>

<hr>
<h2 id='nlar'>Estimate non-linear autoregressive coefficients</h2><span id='topic+nlar'></span>

<h3>Description</h3>

<p>Function that, give time series data, transforms them into summary statistics
using polynomial autoregression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlar(x, lag, power)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlar_+3A_x">x</code></td>
<td>
<p>a matrix. Each column contains a replicate series.</p>
</td></tr>
<tr><td><code id="nlar_+3A_lag">lag</code></td>
<td>
<p>vector of lags, for rhs terms.</p>
</td></tr>
<tr><td><code id="nlar_+3A_power">power</code></td>
<td>
<p>vector of powers, for rhs terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix where each column contains the coefficients for a different replicate.
</p>


<h3>Author(s)</h3>

<p>Simon N. Wood, maintainer Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(synlik)
  set.seed(10)
  x &lt;- matrix(runif(200),100,2)
  beta &lt;- nlar(x,lag=c(1,1),power=c(1,2))
  y &lt;- x[,1]
  y &lt;- y - mean(y)
  z &lt;- y[1:99];y &lt;- y[2:100]
  lm(y~z+I(z^2)-1)
  beta
  
  ## NA testing
  x[5,1] &lt;- x[45,2] &lt;- NA
  beta &lt;- nlar(x,lag=c(1,1),power=c(1,2))
  y &lt;- x[,1]
  y &lt;- y - mean(y,na.rm=TRUE)
  z &lt;- y[1:99];y &lt;- y[2:100]
  lm(y~z+I(z^2)-1)
  beta
  
  ## higher order...
  set.seed(10)
  x &lt;- matrix(runif(100),100,2)
  beta &lt;- nlar(x,lag=c(6,6,6,1,1),power=c(1,2,3,1,2))
  k &lt;- 2
  y &lt;- x[,k]
  y &lt;- y - mean(y)
  ind &lt;- (1+6):100
  y6 &lt;- y[ind-6];y1 &lt;- y[ind-1];y &lt;- y[ind]
  beta0 &lt;- coef(lm(y~y6+I(y6^2)+I(y6^3)+y1+I(y1^2)-1))
  as.numeric(beta[,k]);beta0;beta0-as.numeric(beta[,k])
</code></pre>

<hr>
<h2 id='numericOrNULL-class'>Dummy class</h2><span id='topic+numericOrNULL-class'></span>

<h3>Description</h3>

<p>Class unions for internal use only
</p>

<hr>
<h2 id='orderDist'>Summarize marginal distribution of (differenced) series.</h2><span id='topic+orderDist'></span>

<h3>Description</h3>

<p>Summarizes (difference) distribution of replicate series, by regressing ordered 
differenced series on a reference series (which might correspond to observed data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderDist(x, z, np = 3, diff = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderDist_+3A_x">x</code></td>
<td>
<p>a matrix. Each column contains a replicate series.</p>
</td></tr>
<tr><td><code id="orderDist_+3A_z">z</code></td>
<td>
<p>vector of lags, for rhs terms.</p>
</td></tr>
<tr><td><code id="orderDist_+3A_np">np</code></td>
<td>
<p>maximum power on rhs of regression.</p>
</td></tr>
<tr><td><code id="orderDist_+3A_diff">diff</code></td>
<td>
<p>order of differencing (zero for none).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix where each column contains the coefficients for a different replicate.
</p>


<h3>Author(s)</h3>

<p>Simon N. Wood, maintainer Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(synlik)
set.seed(10)
n &lt;- 100;nr &lt;- 3
x &lt;- matrix(runif(n*nr),n,nr)
z &lt;- runif(n)
beta &lt;- orderDist(x,z,np=3,diff=1)

zd &lt;- z;xd &lt;- x[,3]
zd &lt;- diff(zd,1);xd &lt;- diff(xd,1)
zd &lt;- sort(zd);zd &lt;- zd - mean(zd)
xd &lt;- sort(xd);xd &lt;- xd - mean(xd)
lm(xd~zd+I(zd^2)+I(zd^3)-1)
</code></pre>

<hr>
<h2 id='plot-smcmc'>Plotting objects of class <code>smcmc</code>.</h2><span id='topic+plot+2Csmcmc+2Cmissing-method'></span><span id='topic+plot-smcmc'></span>

<h3>Description</h3>

<p>Method for plotting an object of class <code>smcmc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'smcmc,missing'
plot(x, trans = NULL, addPlot1 = NULL,
  addPlot2 = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot-smcmc_+3A_x">x</code></td>
<td>
<p>An object of class <code>smcmc</code>.</p>
</td></tr>
<tr><td><code id="plot-smcmc_+3A_trans">trans</code></td>
<td>
<p>Name list or vector containing names of transforms for some parameters (ex: <code>list("par1" = "exp", "par2" = "log")</code>).
The transformations will be applied before plotting.</p>
</td></tr>
<tr><td><code id="plot-smcmc_+3A_addplot1">addPlot1</code></td>
<td>
<p>Name of additional plotting function that will be call after the MCMC chain have been plotted. It has
to have prototype <code>fun(nam, ...)</code> where <code>nam</code> will be the parameter name. See &quot;examples&quot;.</p>
</td></tr>
<tr><td><code id="plot-smcmc_+3A_addplot2">addPlot2</code></td>
<td>
<p>Name of additional plotting function that will be call after the histograms have been plotted. It has
to have prototype <code>fun(nam, ...)</code> where <code>nam</code> will be the parameter name. See &quot;examples&quot;.</p>
</td></tr>
<tr><td><code id="plot-smcmc_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the plotting functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+smcmc-class">smcmc-class</a></code>, <code><a href="base.html#topic+plot">plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ricker_smcmc)

# Functions for additional annotations (true parameters)
addline1 &lt;- function(parNam, ...){ 
               abline(h = exp(ricker_smcmc@param[parNam]), lwd = 2, lty = 2, col = 3) 
               }
addline2 &lt;- function(parNam, ...){ 
               abline(v = exp(ricker_smcmc@param[parNam]), lwd = 2, lty = 2, col = 3)
               }

# Transformations (exponentials)
trans &lt;- rep("exp", 3)
names(trans) &lt;- names(ricker_smcmc@param)

plot(ricker_smcmc, 
     trans = trans,
     addPlot1 = "addline1", 
     addPlot2 = "addline2")
</code></pre>

<hr>
<h2 id='plot-synlik'>Method for plotting an object of class <code>synlik</code>.</h2><span id='topic+plot+2Csynlik+2Cmissing-method'></span><span id='topic+plot-synlik'></span>

<h3>Description</h3>

<p>It basically calls the slot <code>object@plotFun</code> with input <code>object@data</code>, if it has been provided by the user. 
Otherwise it tries to use the <code>plot(x = object@data, y, ...)</code> generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'synlik,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot-synlik_+3A_x">x</code></td>
<td>
<p>An object of class <code>synlik</code>.</p>
</td></tr>
<tr><td><code id="plot-synlik_+3A_y">y</code></td>
<td>
<p>Useless argument, only here for compatibility reasons.</p>
</td></tr>
<tr><td><code id="plot-synlik_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>object@plotFun</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synlik-class">synlik-class</a></code>, <code><a href="base.html#topic+plot">plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ricker_sl)

# Using ricker_sl@plotFun
plot(ricker_sl)

# Using generic plot, doesn't work well because object@data is a matrix. 
ricker_sl@plotFun &lt;- NULL
plot(ricker_sl)

</code></pre>

<hr>
<h2 id='ricker_sl'>Ricker model</h2><span id='topic+rickerStats'></span><span id='topic+ricker_sl'></span><span id='topic+ricker_smcmc'></span>

<h3>Description</h3>

<p><code>ricker_sl</code> is <code>synlik</code> object containing the stochastic Ricker model, <code>ricker_smcmc</code> is a <code>smcmc</code>
object which also contains the results of some MCMC iterations. The model is described <a href="#topic+rickerSimul">rickerSimul</a> and in Wood (2010).
The main components of the object are the simulator <a href="#topic+rickerSimul">rickerSimul</a> and the statistics
<code>rickerStats</code>, described in the same reference.
</p>


<h3>Author(s)</h3>

<p>Simon Wood and Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Simon N Wood. Statistical inference for noisy nonlinear ecological dynamic systems. Nature, 466(7310):1102&ndash;1104, 2010.
</p>


<h3>See Also</h3>

<p><a href="#topic+rickerSimul">rickerSimul</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ricker_sl)

plot(ricker_sl)
simulate(ricker_sl, stats = TRUE)

slik(ricker_sl, 
     param  =  c( logR = 3.8, logSigma = log(0.3), logPhi = log(10) ),
     nsim    = 1e3)

# Using Nicholson's data
data(ricker_smcmc)

plot(ricker_smcmc)

</code></pre>

<hr>
<h2 id='rickerSimul'>Simulates from the ricker model</h2><span id='topic+rickerSimul'></span>

<h3>Description</h3>

<p>Simulator for the stochastic Ricker model, as described by Wood (2010). The observations are Y_t ~ Pois(Phi * N_t),
and the dynamics of the hidden state are given by N_t = r * N_{t-1} * exp( -N_{t-1} + e_t ), where e_t ~ N(0, Sigma^2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rickerSimul(param, nsim, extraArgs, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rickerSimul_+3A_param">param</code></td>
<td>
<p>vector of log-parameters: logR, logSigma, logPhi. Alternatively a matrix <code>nsim</code> by 3 were each row is
a different parameter vector.</p>
</td></tr>
<tr><td><code id="rickerSimul_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations from the model.</p>
</td></tr>
<tr><td><code id="rickerSimul_+3A_extraargs">extraArgs</code></td>
<td>
<p>A named list of additional arguments: </p>

<ul>
<li><p><code>nObs</code> = Length of each simulated time series.
</p>
</li>
<li><p><code>nBurn</code> = Number of initial steps to be discarded before saving the following <code>nObs</code> steps.
</p>
</li>
<li><p><code>randInit</code> = if <code>TRUE</code> (default) the initial state N0 is <code>runif(0, 1)</code>, otherwise it is equal to <code>extraArgs$initVal</code>.
</p>
</li>
<li><p><code>initVal</code> = initial value N0, used only if <code>extraArgs$randInit == TRUE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rickerSimul_+3A_...">...</code></td>
<td>
<p>Need for compatibility with <code>synlik</code>, but not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code>nsim</code> by <code>nObs</code>, where each row is a simulated path.
</p>


<h3>Author(s)</h3>

<p>Simon Wood and Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Simon N Wood. Statistical inference for noisy nonlinear ecological dynamic systems. Nature, 466(7310):1102&ndash;1104, 2010. <br /> <br />
</p>


<h3>See Also</h3>

<p><a href="#topic+ricker_sl">ricker_sl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp &lt;- rickerSimul(c(3.8, -1.2, 2.3), nsim = 2, extraArgs = list("nObs" = 50, "nBurn" = 200))
matplot(t(tmp), type = 'l', ylab = "Y", xlab = "Time")

parMat &lt;- rbind(c(3.8, -1.2, 2.3),  # Chaotic
                c(2.5, -1.2, 2.3))  # Not Chaotic
                
par(mfrow = c(2, 1))
tmp &lt;- rickerSimul(parMat, nsim = 2, extraArgs = list("nObs" = 50, "nBurn" = 200))
plot(tmp[1, ], type = 'l', ylab = "Y", xlab = "Time")
plot(tmp[2, ], type = 'l', ylab = "Y", xlab = "Time")
</code></pre>

<hr>
<h2 id='robCov'>Robust covariance matrix estimation</h2><span id='topic+robCov'></span>

<h3>Description</h3>

<p>Obtains a robust estimate of the covariance matrix of a sample of multivariate data, 
using Campbell's (1980) method as described on p231-235 of Krzanowski (1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robCov(sY, alpha = 2, beta = 1.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robCov_+3A_sy">sY</code></td>
<td>
<p>A matrix, where each column is a replicate observation on a multivariate r.v.</p>
</td></tr>
<tr><td><code id="robCov_+3A_alpha">alpha</code></td>
<td>
<p>tuning parameter, see details.</p>
</td></tr>
<tr><td><code id="robCov_+3A_beta">beta</code></td>
<td>
<p>tuning parameter, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Campbell (1980) suggests an estimator of the covariance matrix which downweights observations 
at more than some Mahalanobis distance <code>d.0</code> from the mean.
<code>d.0</code> is <code>sqrt(nrow(sY))+alpha/sqrt(2)</code>. Weights are one for observations 
with Mahalanobis distance, <code>d</code>, less than <code>d.0</code>. Otherwise weights are 
<code>d.0*exp(-.5*(d-d.0)^2/beta)/d</code>. The defaults are as recommended by Campbell.
This routine also uses pre-conditioning to ensure good scaling and stable 
numerical calculations.
</p>


<h3>Value</h3>

<p>A list where:
</p>

<ul>
<li><p><code>E</code>a square root of the inverse covariance matrix. i.e. the inverse cov 
matrix is <code>t(E)%*%E</code>;
</p>
</li>
<li><p><code>half.ldet.V</code>Half the log of the determinant of the covariance matrix;
</p>
</li>
<li><p><code>mY</code>The estimated mean; 
</p>
</li>
<li><p><code>sd</code>The estimated standard deviations of each variable.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Simon N. Wood, maintained by Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Krzanowski, W.J. (1988) Principles of Multivariate Analysis. Oxford.
Campbell, N.A. (1980) Robust procedures in multivariate analysis I: robust covariance estimation. JRSSC 29, 231-237.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 5;n &lt;- 100
Y &lt;- matrix(runif(p*n),p,n)
robCov(Y)
</code></pre>

<hr>
<h2 id='simulate+2Csynlik-method'>Simulate data or statistics from an object of class <code>synlik</code>.</h2><span id='topic+simulate+2Csynlik-method'></span>

<h3>Description</h3>

<p>Simulate data or statistics from an object of class <code>synlik</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'synlik'
simulate(object, nsim, seed = NULL, param = object@param,
  stats = FALSE, clean = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate+2B2Csynlik-method_+3A_object">object</code></td>
<td>
<p>An object of class <code>synlik</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2Csynlik-method_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations from the model.</p>
</td></tr>
<tr><td><code id="simulate+2B2Csynlik-method_+3A_seed">seed</code></td>
<td>
<p>Random seed to be used. It is not passed to the simulator, but simply passed to <code>set.seed()</code> from within
<code>simulate.synlik</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2Csynlik-method_+3A_param">param</code></td>
<td>
<p>Vector of parameters passed to <code>object@simulator</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2Csynlik-method_+3A_stats">stats</code></td>
<td>
<p>If <code>TRUE</code> the function trasforms the simulated data into statistics using <code>object@summaries</code>.</p>
</td></tr>
<tr><td><code id="simulate+2B2Csynlik-method_+3A_clean">clean</code></td>
<td>
<p>If <code>TRUE</code> the function tries to clean the statistics from NaNs or non-finite values.
Given that <code>object@summaries</code> has to returns a numeric vector or 
a matrix where each row is a simulation, rows containing non-finite values will be discarded.</p>
</td></tr>
<tr><td><code id="simulate+2B2Csynlik-method_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> the function will complain if, for instance, the simulations contain lots of non-finite values.</p>
</td></tr>
<tr><td><code id="simulate+2B2Csynlik-method_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>object@simulator</code> and <code>object@summaries</code>.
In general I would avoid using it and including <code>object@extraArgs</code> everything they need.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>stats == FALSE</code> the output will that of <code>object@simulator</code>, which depends on the simulator used by the user.
If <code>stats == TRUE</code> the output will be a matrix where each row is vector of simulated summary statistics.
</p>


<h3>Author(s)</h3>

<p>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synlik-class">synlik-class</a></code>, <code><a href="stats.html#topic+simulate">simulate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ricker_sl)

# Simulate data
simulate(ricker_sl, nsim = 2)

# Simulate statistics
simulate(ricker_sl, nsim = 2, stats = TRUE)                                              
</code></pre>

<hr>
<h2 id='slAcf'>Estimate auto-covariances for multiple datasets.</h2><span id='topic+slAcf'></span>

<h3>Description</h3>

<p>Function that, give time series data, transforms them into auto-covariances with different lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slAcf(x, max.lag = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slAcf_+3A_x">x</code></td>
<td>
<p>a matrix. Each column contains a replicate series.</p>
</td></tr>
<tr><td><code id="slAcf_+3A_max.lag">max.lag</code></td>
<td>
<p>How many lags to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix where each column contains the coefficients for a different replicate. The first coefficient
corresponds to lag == 0, hence it is the variance, the second is the covariance one step ahead and so 
on.
</p>


<h3>Author(s)</h3>

<p>Simon N. Wood, maintainer Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(synlik)
set.seed(10)
x &lt;- matrix(runif(1000),100,10)
acf &lt;- slAcf(x)
</code></pre>

<hr>
<h2 id='slice'>Plot slices of the synthetic log-likelihood.</h2><span id='topic+slice'></span>

<h3>Description</h3>

<p>Plot slices of the synthetic log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(object, ranges, nsim, param = object@param, pairs = FALSE,
  draw = TRUE, trans = NULL, multicore = FALSE, ncores = detectCores() -
  1, cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_+3A_object">object</code></td>
<td>
<p><code>synlik</code> object.</p>
</td></tr>
<tr><td><code id="slice_+3A_ranges">ranges</code></td>
<td>
<p>ranges of values along which we want the slices. If <code>length(parName) == 1</code> than range has a vector, while
if <code>length(parName) == 2</code> it have to be a named list of 2 vectors (ex: <code>list("alpha" = 1:10, "beta" = 10:1)</code>).</p>
</td></tr>
<tr><td><code id="slice_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations used to evaluate the synthetic likelihood at each location.</p>
</td></tr>
<tr><td><code id="slice_+3A_param">param</code></td>
<td>
<p>Named vector containing the value of the ALL parameters (including the sliced one). Parameters that are not
in <code>parName</code> will be fixed to the values in <code>param</code>.</p>
</td></tr>
<tr><td><code id="slice_+3A_pairs">pairs</code></td>
<td>
<p>if <code>TRUE</code> the function will produce a 2D slice for every pair of parameters in <code>ranges</code>. <code>FALSE</code>
by default.</p>
</td></tr>
<tr><td><code id="slice_+3A_draw">draw</code></td>
<td>
<p>If <code>TRUE</code> the slice will be plotted.</p>
</td></tr>
<tr><td><code id="slice_+3A_trans">trans</code></td>
<td>
<p>Named vector or list of transformations to be applied to the parameters in <code>parName</code> 
before plotting ex: <code>trans = c(s = "exp", d = "exp")</code>/</p>
</td></tr>
<tr><td><code id="slice_+3A_multicore">multicore</code></td>
<td>
<p>If <code>TRUE</code> the <code>object@simulator</code> and <code>object@summaries</code> functions will
be executed in parallel. That is the <code>nsim</code> simulations will be divided in multiple cores.</p>
</td></tr>
<tr><td><code id="slice_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use if <code>multicore == TRUE</code>.</p>
</td></tr>
<tr><td><code id="slice_+3A_cluster">cluster</code></td>
<td>
<p>An object of class <code>c("SOCKcluster", "cluster")</code>. This allowes the user to pass her own cluster,
which will be used if <code>multicore == TRUE</code>. The user has to remember to stop the cluster.</p>
</td></tr>
<tr><td><code id="slice_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>slik()</code>, see <code><a href="#topic+slik">slik</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector or matrix of log-synthetic likelihood estimates, depending on whether <code>length(parNames) ==</code> 1 or 2.
These are returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ricker_sl)

# Plotting slices of the logLikelihood
slice(object = ricker_sl, 
     ranges = list("logR" = seq(3.5, 3.9, by = 0.01),
                   "logPhi" = seq(2, 2.6, by = 0.01),
                    "logSigma" = seq(-2, -0.5, by = 0.01)), 
     param = c(logR = 3.8, logSigma = log(0.3), logPhi = log(10)), 
     nsim = 500)
            
## Not run: 
# Plotting a contour of the logLikelihood
slice(object = ricker_sl, 
     ranges = list("logR" = seq(3.5, 3.9, by = 0.01),
                   "logPhi" = seq(2, 2.6, by = 0.01),
                   "logSigma" = seq(-2, -0.5, by = 0.04)), 
     pairs = TRUE,
     param = c(logR = 3.8, logSigma = log(0.3), logPhi = log(10)), 
     nsim = 500, multicore = TRUE)   

## End(Not run)                     
</code></pre>

<hr>
<h2 id='slik'>Evaluates the synthetic log-likelihood.</h2><span id='topic+slik'></span>

<h3>Description</h3>

<p>Evaluates the synthetic log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slik(object, param, nsim, multicore = FALSE, ncores = detectCores() - 1,
  cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slik_+3A_object">object</code></td>
<td>
<p>An object of class <code>synlik</code>.</p>
</td></tr>
<tr><td><code id="slik_+3A_param">param</code></td>
<td>
<p>Vector of parameters at which the synthetic likelihood will be evaluated.</p>
</td></tr>
<tr><td><code id="slik_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulation from the model.</p>
</td></tr>
<tr><td><code id="slik_+3A_multicore">multicore</code></td>
<td>
<p>(logical) if <code>TRUE</code> the <code>object@simulator</code> and <code>object@summaries</code> functions will
be executed in parallel. That is the nsim simulations will be divided in multiple cores.</p>
</td></tr>
<tr><td><code id="slik_+3A_ncores">ncores</code></td>
<td>
<p>(integer) number of cores to use if <code>multicore == TRUE</code>.</p>
</td></tr>
<tr><td><code id="slik_+3A_cluster">cluster</code></td>
<td>
<p>an object of class <code>c("SOCKcluster", "cluster")</code>. This allowes the user to pass her own cluster,
which will be used if <code>multicore == TRUE</code>. The user has to remember to stop the cluster.</p>
</td></tr>
<tr><td><code id="slik_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>object@simulator</code> and <code>object@summaries</code>.
In general I would avoid using it and including <code>object@extraArgs</code> everything they need.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated value of the synthetic log-likelihood at <code>param</code>.
</p>


<h3>Author(s)</h3>

<p>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;
</p>


<h3>References</h3>

<p>Simon N Wood. Statistical inference for noisy nonlinear ecological dynamic systems. Nature, 466(7310):1102&ndash;1104, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ricker_sl)
set.seed(643)
slik(ricker_sl, param = c(3.8, -1.2, 2.3), nsim = 500)                     
</code></pre>

<hr>
<h2 id='smcmc'>MCMC parameter estimation for objects of class <code>synlik</code>.</h2><span id='topic+smcmc'></span>

<h3>Description</h3>

<p>MCMC parameter estimation for objects of class <code>synlik</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smcmc(object, initPar, niter, nsim, propCov, burn = 0,
  priorFun = function(param, ...) 0, targetRate = NULL, recompute = FALSE,
  multicore = !is.null(cluster), cluster = NULL, ncores = detectCores() -
  1, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smcmc_+3A_object">object</code></td>
<td>
<p>An object of class <code>synlik</code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_initpar">initPar</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_niter">niter</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_nsim">nsim</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_propcov">propCov</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_burn">burn</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_priorfun">priorFun</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_targetrate">targetRate</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_recompute">recompute</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_multicore">multicore</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_cluster">cluster</code></td>
<td>
<p>an object of class <code>c("SOCKcluster", "cluster")</code>. This allowes the user to pass her own cluster,
which will be used if <code>multicore == TRUE</code>. The user has to remember to stop the cluster.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_ncores">ncores</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_control">control</code></td>
<td>
<p>see <code><a href="#topic+smcmc-class">smcmc-class</a></code>.</p>
</td></tr>
<tr><td><code id="smcmc_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>slik</code> function, see <code><a href="#topic+slik">slik</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>smcmc</code>.
</p>


<h3>Author(s)</h3>

<p>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;, code for adaptive step from the adaptMCMC package.
</p>


<h3>References</h3>

<p>Vihola, M. (2011) Robust adaptive Metropolis algorithm with coerced acceptance rate. 
Statistics and Computing.
</p>

<hr>
<h2 id='smcmc-class'><code>smcmc-class</code></h2><span id='topic+smcmc-class'></span>

<h3>Description</h3>

<p>Object representing the results of MCMC estimation on an object of class <code>synlik</code>, from which it inherits.
</p>


<h3>Slots</h3>


<dl>
<dt>initPar</dt><dd><p>Vector of initial parameters where the MCMC chain will start (<code>numeric</code>).</p>
</dd>
<dt>niter</dt><dd><p>Number of MCMC iterations (<code>integer</code>).</p>
</dd>
<dt>nsim</dt><dd><p>Number of simulations from the simulator at each step of the MCMC algorithm (<code>integer</code>).</p>
</dd>
<dt>burn</dt><dd><p>Number of initial MCMC iterations that are discarded (<code>integer</code>).</p>
</dd>
<dt>priorFun</dt><dd><p>Function that takes a vector of parameters as input and the log-density of the prior
as output. If the output is not finite the proposed point will be discarded. (<code>function</code>).
The function needs to have signature <code>fun(x, ...)</code>, where <code>x</code> represents the input parameters (<code>function</code>).</p>
</dd>
<dt>propCov</dt><dd><p>Matrix representing the covariance matrix to be used to perturb the 
parameters at each step of the MCMC chain (<code>matrix</code>).</p>
</dd>
<dt>targetRate</dt><dd><p>Target rate for the adaptive MCMC sampler. Should be in (0, 1), default is NULL (no adaptation). The adaptation
uses the approach of Vihola (2011). (<code>numeric</code>)</p>
</dd>
<dt>recompute</dt><dd><p>If TRUE the synthetic likelihood will be evaluated at the current and proposed positions in the parameter
space (thus doubling the computational effort). If FALSE the likelihood of the current
position won't be re-estimated (<code>logical</code>).</p>
</dd>
<dt>multicore</dt><dd><p>If TRUE the <code>object@simulator</code> and <code>object@summaries</code> functions will
be executed in parallel. That is the nsim simulations will be divided in multiple cores (<code>logical</code>).</p>
</dd>
<dt>ncores</dt><dd><p>Number of cores to use if multicore == TRUE (<code>integer</code>).</p>
</dd>
<dt>accRate</dt><dd><p>Acceptance rate of the MCMC chain, between 0 and 1 (<code>numeric</code>).</p>
</dd>
<dt>chains</dt><dd><p>Matrix of size niter by length(initPar) where the i-th row contains the position of the MCMC algorithm
in the parameter space at the i-th (<code>matrix</code>).</p>
</dd>
<dt>llkChain</dt><dd><p>Vector of niter elements where the i-th element is contains the estimate of the 
synthetic likelihood at the i-th iteration (<code>numeric</code>).</p>
</dd>
<dt>control</dt><dd><p>Control parameters used by the MCMC sampler: </p>

<ul>
<li><p><code>theta</code> = controls the speed of adaption. Should be between 0.5 and 1.
A lower gamma leads to faster adaption.
</p>
</li>
<li><p><code>adaptStart</code> = iteration where the adaption starts. Default 0.
</p>
</li>
<li><p><code>adaptStop</code> = iteration where the adaption stops. Default <code>burn + niter</code>
</p>
</li>
<li><p><code>saveFile</code> = path to the file where the intermediate results will be stored (ex: &quot;~/Res.RData&quot;).
</p>
</li>
<li><p><code>saveFreq</code> = frequency with which the intermediate results will be saved on <code>saveFile</code>.
Default 100.
</p>
</li>
<li><p><code>verbose</code> = if <code>TRUE</code> intermediate posterior means will be printer.
</p>
</li>
<li><p><code>verbFreq</code> = frequency with which the intermediate posterior means will be printer. Default 500.
</p>
</li></ul>
 </dd>
</dl>



<h3>Author(s)</h3>

<p>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;
</p>


<h3>References</h3>

<p>Vihola, M. (2011) Robust adaptive Metropolis algorithm with coerced acceptance rate. 
Statistics and Computing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load "synlik" object
data(ricker_sl)

plot(ricker_sl)
 
# MCMC estimation
set.seed(4235)
ricker_sl &lt;- smcmc(ricker_sl, 
                   initPar = c(3.2, -1, 2.6),
                   niter = 50, 
                   burn = 3,
                   priorFun = function(input, ...) 1, 
                   propCov = diag( c(0.1, 0.1, 0.1) )^2, 
                   nsim = 200, 
                   multicore = FALSE)

# Continue with additional 50 iterations
ricker_sl &lt;- continue(ricker_sl, niter = 50)

plot(ricker_sl)       

</code></pre>

<hr>
<h2 id='synlik-class'><code>synlik-class</code></h2><span id='topic+synlik'></span><span id='topic+synlik-class'></span>

<h3>Description</h3>

<p>Basic class for simulation-based approximate inference using Synthetic Likelihood methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synlik(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="synlik-class_+3A_...">...</code></td>
<td>
<p>See section &quot;Slots&quot;.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt>param</dt><dd><p>Named vector of parameters used by <code>object@simulator</code> (<code>numeric</code>).</p>
</dd>
<dt>simulator</dt><dd><p>Function that simulates from the model (<code>function</code>). It has to have prototype <code>fun(param, nsim, extraArgs, ...)</code>. 
If <code>summaries()</code> is not specified the <code>simulator()</code> has output a matrix with <code>nsim</code> rows, where
each row is a vector of simulated statistics. Otherwise it can output any kind of object, and this output will be
passed to <code>summaries()</code>.</p>
</dd>
<dt>summaries</dt><dd><p>Function that transforms simulated data into summary statistics (<code>function</code>). 
It has to have prototype <code>fun(x, extraArgs, ...)</code> and it has to output a matrix with <code>nsim</code> rows, where
each row is a vector of simulated statistics. Parameter <code>x</code> contains the data.</p>
</dd>
<dt>data</dt><dd><p>Object containing the observed data or statistics (<code>ANY</code>).</p>
</dd>
<dt>extraArgs</dt><dd><p>List containing all the extra arguments to be passed to <code>object@simulator</code> and <code>object@summaries</code> (<code>list</code>).</p>
</dd>
<dt>plotFun</dt><dd><p>Function that will be used to plot <code>object@data</code>. Prototype should be <code>fun(x, ...)</code> (<code>function</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;
</p>


<h3>References</h3>

<p>Simon N Wood. Statistical inference for noisy nonlinear ecological dynamic systems. Nature, 466(7310):1102&ndash;1104, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Create Object
ricker_sl &lt;- synlik(simulator = rickerSimul,
                    summaries = rickerStats,
                    param = c( logR = 3.8, logSigma = log(0.3), logPhi = log(10) ),
                    extraArgs = list("nObs" = 50, "nBurn" = 50),
                    plotFun = function(input, ...) 
                                plot(drop(input), type = 'l', ylab = "Pop", xlab = "Time", ...)
)
 
# Simulate from the object
ricker_sl@data &lt;- simulate(ricker_sl)
ricker_sl@extraArgs$obsData &lt;- ricker_sl@data # Needed by WOOD2010 statistics

plot(ricker_sl)      
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
