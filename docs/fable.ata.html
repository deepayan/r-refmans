<!DOCTYPE html><html><head><title>Help for package fable.ata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fable.ata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AutoATA'><p>ATAforecasting: Automatic Time Series Analysis and Forecasting using Ata Method with Box-Cox Power Transformations Family and Seasonal Decomposition Techniques</p></a></li>
<li><a href='#components.ATA'><p>Extract estimated states from an ATA model.</p></a></li>
<li><a href='#fable.ata-package'><p>fable.ata: 'ATAforecasting' Modelling Interface for 'fable' Framework</p></a></li>
<li><a href='#fitted.ATA'><p>Extract fitted values</p></a></li>
<li><a href='#forecast.ATA'><p>Forecast a model from the fable ATA model</p></a></li>
<li><a href='#format.ATA'><p>Format of ATA model</p></a></li>
<li><a href='#glance.ATA'><p>Glance an ATA model</p></a></li>
<li><a href='#model_sum.ATA'><p>Summary of ATA model</p></a></li>
<li><a href='#report.ATA'><p>Specialized Screen Print Function of ATA model</p></a></li>
<li><a href='#residuals.ATA'><p>Extract model residuals</p></a></li>
<li><a href='#tidy.ATA'><p>Tidy a ATA model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'ATAforecasting' Modelling Interface for 'fable' Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-11</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ali Sabri Taylan &lt;alisabritaylan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows ATA (Automatic Time series analysis using the Ata method) models from the 'ATAforecasting' package to be used in a tidy workflow with the modeling interface of
    'fabletools'. This extends 'ATAforecasting' to provide enhanced model specification and management, performance evaluation methods, and
    model combination tools. The Ata method (Yapar et al. (2019) &lt;<a href="https://doi.org/10.15672%2Fhujms.461032">doi:10.15672/hujms.461032</a>&gt;), an alternative to exponential smoothing (described in Yapar (2016)
    &lt;<a href="https://doi.org/10.15672%2FHJMS.201614320580">doi:10.15672/HJMS.201614320580</a>&gt;, Yapar et al. (2017) &lt;<a href="https://doi.org/10.15672%2FHJMS.2017.493">doi:10.15672/HJMS.2017.493</a>&gt;), is a new univariate time series forecasting method which provides
    innovative solutions to issues faced during the initialization and optimization stages of existing forecasting methods.
    Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting.
    It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal).</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, rlang, tibble, dplyr, tsibble, distributional, tsbox,
lubridate</td>
</tr>
<tr>
<td>Depends:</td>
<td>fabletools (&ge; 0.3.3), ATAforecasting (&ge; 0.0.60)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://alsabtay.github.io/fable.ata/">https://alsabtay.github.io/fable.ata/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alsabtay/fable.ata/issues">https://github.com/alsabtay/fable.ata/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-11 19:01:53 UTC; astaylan</td>
</tr>
<tr>
<td>Author:</td>
<td>Ali Sabri Taylan <a href="https://orcid.org/0000-0001-9514-934X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Hanife Taylan Selamlar
    <a href="https://orcid.org/0000-0002-4091-884X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph],
  Guckan Yapar <a href="https://orcid.org/0000-0002-0971-6676"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-19 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AutoATA'>ATAforecasting: Automatic Time Series Analysis and Forecasting using Ata Method with Box-Cox Power Transformations Family and Seasonal Decomposition Techniques</h2><span id='topic+AutoATA'></span>

<h3>Description</h3>

<p>Returns ATA(p,q,phi)(E,T,S) applied to time series data.
The Ata method based on the modified simple exponential smoothing as described in Yapar, G. (2016) &lt;doi:10.15672/HJMS.201614320580&gt; ,
Yapar G., Capar, S., Selamlar, H. T., Yavuz, I. (2017) &lt;doi:10.15672/HJMS.2017.493&gt; and Yapar G., Selamlar, H. T., Capar, S., Yavuz, I. (2019)
&lt;doi:10.15672/hujms.461032&gt; is a new univariate time series forecasting method which provides innovative solutions to issues faced during
the initialization and optimization stages of existing methods.
Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting.
It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal).
This methodology performed well on the M3 and M4-competition data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoATA(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoATA_+3A_formula">formula</code></td>
<td>
<p>Model specification (see &quot;Specials&quot; section).</p>
</td></tr>
<tr><td><code id="AutoATA_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model specification.
</p>


<h3>Specials</h3>

<p>The _specials_ define the methods and parameters for the components (level, trend, seasonality, accuracy, transform, holdout) of an ATA method.
</p>
<p>There are a couple of limitations to note about ATA method:
</p>
<p>- It supports only additive error term.
- It does not support exogenous regressors.
- It does not support missing values. You can complete missing values in the data with imputed values (e.g. with [tsibble::fill_gaps()], [tidyr::fill()], or by fitting a different model type and then calling [fabletools::interpolate()]) before fitting the model.
</p>


<h4>level</h4>

<p>The 'level' special is used to specify the form of the level term.
</p>
<pre>
level(parP = NULL, level_fixed = TRUE, initial_level = "none")
</pre>

<table>
<tr>
 <td style="text-align: left;">
  `parP`     </td><td style="text-align: left;"> The value of the smoothing parameter for the level. If `p = 0`, the level will not change over time. Conversely, if `p = 1` the level will update similarly to a random walk process. If NULL or "opt", it is estimated. <code>p</code> has all integer values from 1 to <code>length(data)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `level_fixed`      </td><td style="text-align: left;"> If TRUE, "pStarQ"  --&gt; First, fits ATA(p,0) where p = p* is optimized for q=0. Then, fits ATA(p*,q) where q is optimized for p = p*. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `initial_level`     </td><td style="text-align: left;"> If NULL, "none" is default. If "none", ATA Method calculates the pth observation in <code>data</code> for level. If "mean", ATA Method calculates average of first p value in <code>data</code>for level. If "median", ATA Method calculates median of first p value in <code>data</code>for level. </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>




<h4>trend</h4>

<p>The 'trend' special is used to specify the form of the trend term and associated parameters.
</p>
<pre>
trend(type = "A", parQ = NULL, initial_trend = "none", opt_trend = "none",
       parPHI = NULL, parPHI_range = c(0.8, 1.0), parPHI_increment = 0.01,
       uroot_test = "adf", uroot_alpha = 0.05, uroot_type = "level")
</pre>

<table>
<tr>
 <td style="text-align: left;">
  `type`     </td><td style="text-align: left;"> The form of the trend term: either none ("N"), additive ("A"), multiplicative ("M") or damped variants ("Ad", "Md"). </td>
</tr>
<tr>
 <td style="text-align: left;">
  `parQ`      </td><td style="text-align: left;"> The value of the smoothing parameter for the slope. If `q = 0`, the slope will not change over time. Conversely, if `q = 1` the slope will have mean of past slopes. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `parPHI` </td><td style="text-align: left;"> The value of the dampening parameter for the slope. If `phi = 0`, the slope will be dampened immediately (no slope). Conversely, if `phi = 1` the slope will not be dampened. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `parPHI_range`       </td><td style="text-align: left;"> If `phi=NULL`, `phi_range` provides bounds for the optimised value of `phi`.</td>
</tr>
<tr>
 <td style="text-align: left;">
  `parPHI_increment`  </td><td style="text-align: left;"> If `phi=NULL`, `parPHI_increment` provides increment step for searching `phi`. If NULL, `parPHI_increment` will be determined as the value that allows the `parPHI_range` to be divided into 20 equal parts. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `initial_trend`     </td><td style="text-align: left;"> If NULL, "none" is default. If "none", ATA Method calculates the qth observation in <code>data</code> for trend. If "mean", ATA Method calculates average of first q value in <code>X(T)-X(T-1)</code> for trend. If "median", ATA Method calculates median of first q value in <code>X(T)-X(T-1)</code> for trend. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `trend_opt`        </td><td style="text-align: left;"> Default is `none`. If `fixed` is set, "pBullet" --&gt; Fits ATA(p,1) where p = p* is optimized for q = 1. If `search` is set "qBullet" --&gt; Fits ATA(p,q) where p = p* is optimized for q = q* (q &gt; 0). Then, fits ATA(p*,q) where q is optimized for p = p*. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `uroot_test`        </td><td style="text-align: left;"> Type of unit root test before all type seasonality test. Possible values are "adf", "pp" and "kpss". </td>
</tr>
<tr>
 <td style="text-align: left;">
  `uroot_alpha`   </td><td style="text-align: left;"> Significant level of the unit root test, possible values range from 0.01 to 0.1. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `uroot_type`        </td><td style="text-align: left;"> Specification of the deterministic component in the regression for unit root test. Possible values are "level" and "trend". </td>
</tr>
<tr>
 <td style="text-align: left;">
  `uroot_maxd`       </td><td style="text-align: left;"> Maximum number of non-seasonal differences allowed. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>season</h4>

<p>The 'season' special is used to specify the form of the seasonal term and associated parameters. To specify a nonseasonal model you would include 'season(method = &quot;N&quot;)'.
</p>
<pre>
season(type = "A", test = TRUE, period = NULL, method = "decomp",
       suroot_test = "correlogram", suroot_tcrit = 1.28, suroot_uroot = TRUE, suroot_m = NULL)
</pre>

<table>
<tr>
 <td style="text-align: left;">
  `type`     </td><td style="text-align: left;"> The form of the seasonal term: either none ("N"), additive ("A") or multiplicative ("M"). </td>
</tr>
<tr>
 <td style="text-align: left;">
  `test`     </td><td style="text-align: left;"> Testing for stationary and seasonality. If TRUE, the method firstly uses <code>test="adf"</code>, Augmented Dickey-Fuller, unit-root test then the test returns the least number of differences required to pass the test at level <code>alpha</code>. After the unit-root test, seasonal test applies on the stationary <code>data</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `period`     </td><td style="text-align: left;"> The periodic nature of the seasonality. This can be a number indicating the number of observations in each seasonal period (for example, annual seasonality would be "1").  </td>
</tr>
<tr>
 <td style="text-align: left;">
  `method`      </td><td style="text-align: left;"> A string identifying method for seasonal decomposition. If NULL, "decomp" method is default. Possible values are c("none", "decomp", "stl", "stlplus", "tbats", "stR") phrases of methods denote. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `suroot_test`     </td><td style="text-align: left;"> Type of seasonal unit root test to use. Possible values are "correlogram", "seas", "hegy", "ch" and "ocsb". </td>
</tr>
<tr>
 <td style="text-align: left;">
  `suroot_tcrit`     </td><td style="text-align: left;"> t-value for autocorrelogram.  </td>
</tr>
<tr>
 <td style="text-align: left;">
  `suroot_alpha`     </td><td style="text-align: left;"> Significant level of the seasonal unit root test, possible values range from 0.01 to 0.1.  </td>
</tr>
<tr>
 <td style="text-align: left;">
  `suroot_uroot`     </td><td style="text-align: left;"> If TRUE, unit root test for stationary before seasonal unit root test is allowed. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `suroot_m`      </td><td style="text-align: left;"> Deprecated. Length of seasonal period: frequency of data for nsdiffs. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `suroot_maxD`     </td><td style="text-align: left;"> Maximum number of seasonal differences allowed. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>accuracy</h4>

<p>The 'accuracy' special is used to the optimization criterion for selecting the best ATA Method forecasting.
</p>
<pre>
accuracy(criteria = "sMAPE", nmse = 3, ic = "AIC")
</pre>

<table>
<tr>
 <td style="text-align: left;">
  `criteria`     </td><td style="text-align: left;"> Accuracy measure for optimization of the best ATA Method forecasting. IF NULL, `sMAPE` is default. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `nmse`     </td><td style="text-align: left;"> If `accuracy.type == "AMSE"`, `nmse` provides the number of steps for average multistep MSE `(2&lt;=nmse&lt;=30)`. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `ic`     </td><td style="text-align: left;"> The information criterion used in selecting the model.  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>transform</h4>

<p>The 'transform' special is used to provide the applicability of different types of transformation techniques for the data to which the ATA method will be applied.
</p>
<pre>
transform(method="none", order = "none", lambda = NULL, shift = 0,
          bcMethod = "guerrero", bcLower = 0, bcUpper = 5)
</pre>

<table>
<tr>
 <td style="text-align: left;">
  `method`     </td><td style="text-align: left;"> Transformation method  --&gt; "Box_Cox", "Sqrt", "Reciprocal", "Log", "NegLog", "Modulus", "BickelDoksum", "Manly", "Dual", "YeoJohnson", "GPower", "GLog". If the transformation process needs shift parameter, it will be calculated required shift parameter automatically. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `order`     </td><td style="text-align: left;"> Default is "none. If "before", Box-Cox transformation family will be applied and then seasonal decomposition techniques will be applied. If "after", seasonal decomposition techniques will be applied and then Box-Cox transformation family will be applied. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `lambda`     </td><td style="text-align: left;"> Box-Cox power transformation family parameter. If NULL, data transformed before model is estimated.  </td>
</tr>
<tr>
 <td style="text-align: left;">
  `shift`     </td><td style="text-align: left;"> Box-Cox power transformation family shifting parameter. If NULL, data transformed before model is estimated. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `bcMethod`     </td><td style="text-align: left;"> Choose method to be used in calculating lambda. "guerrero" is default. Other method is "loglik". </td>
</tr>
<tr>
 <td style="text-align: left;">
  `bcLower`     </td><td style="text-align: left;"> Lower limit for possible lambda values. The lower value is limited by -5. Default value is 0. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `bcUpper`     </td><td style="text-align: left;"> Upper limit for possible lambda values. The upper value is limited by 5. Default value is 5. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>holdout</h4>

<p>The 'holdout' special is used to improve the optimized parameter value obtained for the ATA Method forecasting.
</p>
<pre>
holdout(holdout = FALSE, adjustment = TRUE, set_size = NULL, onestep = FALSE)
</pre>

<table>
<tr>
 <td style="text-align: left;">
  `holdout`     </td><td style="text-align: left;"> Default is FALSE. If TRUE, ATA Method uses the holdout forecasting for accuracy measure to select the best parameter set. In holdout forecasting, this parameter divides `data` into two parts: training set (in-sample) and validation set (holdout set). </td>
</tr>
<tr>
 <td style="text-align: left;">
  `adjustment`     </td><td style="text-align: left;"> Default is TRUE. If TRUE, `parP` will be adjusted by length of training, validation sets and main data set when the holdout forecasting is active. </td>
</tr>
<tr>
 <td style="text-align: left;">
  `set_size`     </td><td style="text-align: left;"> If `holdout` is TRUE, this parameter divides `data` into two parts: training set (in-sample) and validation set (holdout set). Also, this parameter will be same as `h` for defining holdout set.  </td>
</tr>
<tr>
 <td style="text-align: left;">
  `onestep`     </td><td style="text-align: left;"> Default is FALSE. if TRUE, the dynamic forecast strategy uses a one-step model multiple times `h` (forecast horizon) where the holdout prediction for the prior time step is used as an input for making a prediction on the following time step.
</td>
</tr>

</table>




<h3>Examples</h3>

<pre><code class='language-R'>library(fable.ata)
as_tsibble(USAccDeaths) %&gt;% model(ata = AutoATA(value ~ trend("A") + season("A")))

</code></pre>

<hr>
<h2 id='components.ATA'>Extract estimated states from an ATA model.</h2><span id='topic+components.ATA'></span>

<h3>Description</h3>

<p>Extract estimated states from an ATA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ATA'
components(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="components.ATA_+3A_object">object</code></td>
<td>
<p>An estimated model.</p>
</td></tr>
<tr><td><code id="components.ATA_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A [fabletools::dable()] containing estimated states.
</p>

<hr>
<h2 id='fable.ata-package'>fable.ata: 'ATAforecasting' Modelling Interface for 'fable' Framework</h2><span id='topic+fable.ata'></span><span id='topic+fable.ata-package'></span>

<h3>Description</h3>

<p>Allows ATA (Automatic Time series analysis using the Ata method) models from the 'ATAforecasting' package to be used in a tidy workflow with the modeling interface of 'fabletools'. This extends 'ATAforecasting' to provide enhanced model specification and management, performance evaluation methods, and model combination tools. The Ata method (Yapar et al. (2019) <a href="https://doi.org/10.15672/hujms.461032">doi:10.15672/hujms.461032</a>), an alternative to exponential smoothing (described in Yapar (2016) <a href="https://doi.org/10.15672/HJMS.201614320580">doi:10.15672/HJMS.201614320580</a>, Yapar et al. (2017) <a href="https://doi.org/10.15672/HJMS.2017.493">doi:10.15672/HJMS.2017.493</a>), is a new univariate time series forecasting method which provides innovative solutions to issues faced during the initialization and optimization stages of existing forecasting methods. Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting. It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal).
</p>
<p>Allows ATA (Automatic Time series analysis using the Ata method) models from the 'ATAforecasting' package to be used in a tidy workflow with the modeling interface of 'fabletools'. This extends 'ATAforecasting' to provide enhanced model specification and management, performance evaluation methods, and model combination tools. The Ata method (Yapar et al. (2019) <a href="https://doi.org/10.15672/hujms.461032">doi:10.15672/hujms.461032</a>), an alternative to exponential smoothing (described in Yapar (2016) <a href="https://doi.org/10.15672/HJMS.201614320580">doi:10.15672/HJMS.201614320580</a>, Yapar et al. (2017) <a href="https://doi.org/10.15672/HJMS.2017.493">doi:10.15672/HJMS.2017.493</a>), is a new univariate time series forecasting method which provides innovative solutions to issues faced during the initialization and optimization stages of existing forecasting methods. Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting. It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ali Sabri Taylan <a href="mailto:alisabritaylan@gmail.com">alisabritaylan@gmail.com</a> (<a href="https://orcid.org/0000-0001-9514-934X">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Hanife Taylan Selamlar (<a href="https://orcid.org/0000-0002-4091-884X">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Guckan Yapar (<a href="https://orcid.org/0000-0002-0971-6676">ORCID</a>) [thesis advisor, copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://alsabtay.github.io/fable.ata/">https://alsabtay.github.io/fable.ata/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/alsabtay/fable.ata/issues">https://github.com/alsabtay/fable.ata/issues</a>
</p>
</li></ul>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://alsabtay.github.io/fable.ata/">https://alsabtay.github.io/fable.ata/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/alsabtay/fable.ata/issues">https://github.com/alsabtay/fable.ata/issues</a>
</p>
</li></ul>


<hr>
<h2 id='fitted.ATA'>Extract fitted values</h2><span id='topic+fitted.ATA'></span>

<h3>Description</h3>

<p>Extracts the fitted values from an estimated ATA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ATA'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.ATA_+3A_object">object</code></td>
<td>
<p>An estimated model.</p>
</td></tr>
<tr><td><code id="fitted.ATA_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of fitted values.
</p>

<hr>
<h2 id='forecast.ATA'>Forecast a model from the fable ATA model</h2><span id='topic+forecast.ATA'></span>

<h3>Description</h3>

<p>Forecast a model from the fable ATA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ATA'
forecast(
  object,
  new_data,
  h = NULL,
  ci_level = 95,
  negative_forecast = TRUE,
  onestep = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.ATA_+3A_object">object</code></td>
<td>
<p>The time series model used to produce the forecasts</p>
</td></tr>
<tr><td><code id="forecast.ATA_+3A_new_data">new_data</code></td>
<td>
<p>A 'tsibble' containing future information used to forecast.</p>
</td></tr>
<tr><td><code id="forecast.ATA_+3A_h">h</code></td>
<td>
<p>The forecast horison (can be used instead of 'new_data' for regular time series with no exogenous regressors).</p>
</td></tr>
<tr><td><code id="forecast.ATA_+3A_ci_level">ci_level</code></td>
<td>
<p>Confidence Interval levels for forecasting. Default value is 95.</p>
</td></tr>
<tr><td><code id="forecast.ATA_+3A_negative_forecast">negative_forecast</code></td>
<td>
<p>Negative values are allowed for forecasting. Default value is TRUE. If FALSE, all negative values for forecasting are set to 0.</p>
</td></tr>
<tr><td><code id="forecast.ATA_+3A_onestep">onestep</code></td>
<td>
<p>Default is FALSE. if TRUE, the dynamic forecast strategy uses a one-step model multiple times 'h' forecast horizon) where the prediction for the prior time step is used as an input for making a prediction on the following time step.</p>
</td></tr>
<tr><td><code id="forecast.ATA_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of fitted residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fable.ata)
as_tsibble(USAccDeaths) %&gt;%
  model(ata = AutoATA(value ~ trend("A") + season("M"))) %&gt;% forecast(h=24)

</code></pre>

<hr>
<h2 id='format.ATA'>Format of ATA model</h2><span id='topic+format.ATA'></span>

<h3>Description</h3>

<p>Format of ATA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ATA'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.ATA_+3A_x">x</code></td>
<td>
<p>An estimated model.</p>
</td></tr>
<tr><td><code id="format.ATA_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The forecasting model's name.
</p>

<hr>
<h2 id='glance.ATA'>Glance an ATA model</h2><span id='topic+glance.ATA'></span>

<h3>Description</h3>

<p>Glance an ATA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ATA'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.ATA_+3A_x">x</code></td>
<td>
<p>An estimated model.</p>
</td></tr>
<tr><td><code id="glance.ATA_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one row tibble summarising the model's fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fable.ata)
as_tsibble(USAccDeaths) %&gt;%
  model(ata = AutoATA(value ~ trend("A") + season("M"))) %&gt;% glance()

</code></pre>

<hr>
<h2 id='model_sum.ATA'>Summary of ATA model</h2><span id='topic+model_sum.ATA'></span>

<h3>Description</h3>

<p>Summary of ATA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ATA'
model_sum(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_sum.ATA_+3A_x">x</code></td>
<td>
<p>An estimated model.</p>
</td></tr>
<tr><td><code id="model_sum.ATA_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model's summary specs.
</p>

<hr>
<h2 id='report.ATA'>Specialized Screen Print Function of ATA model</h2><span id='topic+report.ATA'></span>

<h3>Description</h3>

<p>Specialized Screen Print Function of ATA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ATA'
report(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report.ATA_+3A_object">object</code></td>
<td>
<p>An estimated model.</p>
</td></tr>
<tr><td><code id="report.ATA_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary for the results of the ATAforecasting
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(fable.ata)
 as_tsibble(USAccDeaths) %&gt;% model(ata = AutoATA(value ~ trend("A") + season("M"))) %&gt;% report()

</code></pre>

<hr>
<h2 id='residuals.ATA'>Extract model residuals</h2><span id='topic+residuals.ATA'></span>

<h3>Description</h3>

<p>Extracts the residuals from an estimated ATA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ATA'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.ATA_+3A_object">object</code></td>
<td>
<p>An estimated model.</p>
</td></tr>
<tr><td><code id="residuals.ATA_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residuals.
</p>

<hr>
<h2 id='tidy.ATA'>Tidy a ATA model</h2><span id='topic+tidy.ATA'></span>

<h3>Description</h3>

<p>Tidy a ATA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ATA'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.ATA_+3A_x">x</code></td>
<td>
<p>An estimated model.</p>
</td></tr>
<tr><td><code id="tidy.ATA_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model's coefficients in a 'tibble'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fable.ata)
as_tsibble(USAccDeaths) %&gt;%
  model(ata = AutoATA(value ~ trend("A") + season("M"))) %&gt;% tidy()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
