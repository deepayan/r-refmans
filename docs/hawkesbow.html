<!DOCTYPE html><html><head><title>Help for package hawkesbow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hawkesbow}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compensator'><p>Compensator of a Hawkes process</p></a></li>
<li><a href='#discrete'><p>Discretizes a Hawkes simulation</p></a></li>
<li><a href='#dpowerlaw'><p>The power law distribution</p></a></li>
<li><a href='#E1_imaginary'><p>Exponential integral of imaginary argument</p></a></li>
<li><a href='#Etheta_imaginary'><p>Incomplete gamma function of imaginary argument with arbitrary power</p></a></li>
<li><a href='#Exponential'><p>Reproduction kernels for the Hawkes processes</p></a></li>
<li><a href='#hawkes'><p>Simulation of a Hawkes process</p></a></li>
<li><a href='#hawkes_ogata'><p>Simulation of a Hawkes process</p></a></li>
<li><a href='#hawkesbow-package'><p>hawkesbow: Estimation of Hawkes Processes from Binned Observations</p></a></li>
<li><a href='#inc_gamma_imag'><p>Incomplete gamma function of imaginary argument</p></a></li>
<li><a href='#inhpois'><p>Simulation of an inhomogeneous Poisson process by thinning</p></a></li>
<li><a href='#intensity'><p>Intensity of a Hawkes process</p></a></li>
<li><a href='#mle'><p>Fitting Hawkes processes from continuous data</p></a></li>
<li><a href='#Model'><p>C++ abstract class for Hawkes processes</p></a></li>
<li><a href='#plot.hawkes'><p>Plot of a Hawkes process</p></a></li>
<li><a href='#plot.hawkes_ogata'><p>Plot of a simulated Hawkes process</p></a></li>
<li><a href='#plot.inhpois'><p>Plot of a simulated inhomogeneous Poisson process</p></a></li>
<li><a href='#residuals'><p>Residuals of a Hawkes process</p></a></li>
<li><a href='#whittle'><p>Fitting Hawkes processes from discrete data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimation of Hawkes Processes from Binned Observations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an estimation method for Hawkes processes when count data are only observed in discrete time, using a spectral approach derived from the Bartlett spectrum, see Cheysson and Lang (2020) &lt;<a href="https://arxiv.org/abs/2003.04314">arXiv:2003.04314</a>&gt;. Some general use functions for Hawkes processes are also included: simulation of (in)homogeneous Hawkes process, maximum likelihood estimation, residual analysis, etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, nloptr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, BH</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-12 13:03:11 UTC; fcheysso</td>
</tr>
<tr>
<td>Author:</td>
<td>Felix Cheysson <a href="https://orcid.org/0000-0002-9095-2878"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felix Cheysson &lt;felix@cheysson.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-12 13:30:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='compensator'>Compensator of a Hawkes process</h2><span id='topic+compensator'></span>

<h3>Description</h3>

<p>Outputs the compensator (integrated intensity) of a Hawkes process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compensator(x, t, fun = NULL, repr = NULL, family = NULL, M = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compensator_+3A_x">x</code></td>
<td>
<p>A non-negative numeric vector, sorted in ascending order; or an object of class &quot;hawkes&quot; output by function <code>hawkes</code>.</p>
</td></tr>
<tr><td><code id="compensator_+3A_t">t</code></td>
<td>
<p>A non-negative numeric value or vector, at which the intensity should be computed.</p>
</td></tr>
<tr><td><code id="compensator_+3A_fun">fun</code></td>
<td>
<p>(default = TRUE) A non-negative numeric function or value - intensity (function) of the immigrant process.</p>
</td></tr>
<tr><td><code id="compensator_+3A_repr">repr</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - mean number of offsprings.</p>
</td></tr>
<tr><td><code id="compensator_+3A_family">family</code></td>
<td>
<p>(default = NULL) A character string &quot;name&quot; naming a distribution with corresponding distribution function <code>dname</code>, or directly the distribution function.</p>
</td></tr>
<tr><td><code id="compensator_+3A_m">M</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - upper bound on <code>fun</code>(ignored if <code>fun</code> is a numeric value).</p>
</td></tr>
<tr><td><code id="compensator_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the random generation function <code>dname</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The compensator at time t.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an exponential Hawkes process with baseline intensity 1,
# reproduction mean 0.5 and exponential fertility distribution with rate 2.
x &lt;- hawkes(10, fun=1, repr=0.5, family="exp", rate=2)
compensator(x, 0:10)
# Compensator with a different set of parameters
compensator(x, 0:10, repr=0.8, rate=3)
# Compensator with a different distribution function
compensator(x, 0:10, family="chisq", df=2)
# Simulate a Hawkes process with baseline intensity function 1 + sin(x),
# reproduction mean 0.5 and custom [0,1]-triangular fertility function.
x &lt;- hawkes(10, fun=function(y) {1+sin(y)}, M=2, repr=0.5,
            family=function(n) {1 - sqrt(1 - runif(n))})
compensator(x, 0:10, family=function(y) ifelse(y&gt;0 &amp; y&lt;1, 2-2*y, 0))
</code></pre>

<hr>
<h2 id='discrete'>Discretizes a Hawkes simulation</h2><span id='topic+discrete'></span>

<h3>Description</h3>

<p>Discretizes a Hawkes simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete(hawkes, length = NULL, binsize = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete_+3A_hawkes">hawkes</code></td>
<td>
<p>An object created by the function <code>hawkes</code></p>
</td></tr>
<tr><td><code id="discrete_+3A_length">length</code></td>
<td>
<p>(Either) The length for the output vector</p>
</td></tr>
<tr><td><code id="discrete_+3A_binsize">binsize</code></td>
<td>
<p>(Either) The binsize for the discretization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = hawkes(100, fun=1, repr=0.5, family="exp", rate=2)
y = discrete(x, length=100)
z = discrete(x, binsize=1)
all(y == z)
</code></pre>

<hr>
<h2 id='dpowerlaw'>The power law distribution</h2><span id='topic+dpowerlaw'></span><span id='topic+ppowerlaw'></span><span id='topic+qpowerlaw'></span><span id='topic+rpowerlaw'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for
the power law distribution with shape equal to <code>shape</code> and scale equal to
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpowerlaw(x, shape = 1, scale = 1)

ppowerlaw(q, shape = 1, scale = 1)

qpowerlaw(p, shape = 1, scale = 1)

rpowerlaw(n, shape = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpowerlaw_+3A_x">x</code>, <code id="dpowerlaw_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dpowerlaw_+3A_shape">shape</code></td>
<td>
<p>parameter of shape.</p>
</td></tr>
<tr><td><code id="dpowerlaw_+3A_scale">scale</code></td>
<td>
<p>parameter of scale.</p>
</td></tr>
<tr><td><code id="dpowerlaw_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dpowerlaw_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density function of the power law distribution is
</p>
<p style="text-align: center;"><code class="reqn">f(t) = \theta a^\theta (a+t)^{-\theta-1}</code>
</p>

<p>where <code class="reqn">\theta</code> is the shape parameter, and <code class="reqn">a</code> the scale parameter.
</p>


<h3>Value</h3>

<p><code>dpowerlaw</code> gives the density, <code>ppowerlaw</code> gives the distribution function,
<code>qpowerlaw</code> gives the quantile function, and <code>rpowerlaw</code> generates random
deviates.
</p>

<hr>
<h2 id='E1_imaginary'>Exponential integral of imaginary argument</h2><span id='topic+E1_imaginary'></span>

<h3>Description</h3>

<p>Calculates the value of
</p>
<p style="text-align: center;"><code class="reqn">E_1(ix) = \int_1^\infty \frac{e^{-ixt}}{t} \mathrm{d}t</code>
</p>

<p>using its relation to the trigonometric integrals
(cf. <a href="https://en.wikipedia.org/wiki/Exponential_integral#Exponential_integral_of_imaginary_argument">https://en.wikipedia.org/wiki/Exponential_integral#Exponential_integral_of_imaginary_argument</a>):
</p>
<p style="text-align: center;"><code class="reqn">E_1(ix) = i \left[ -\frac{1}{2} \pi + Si(x) \right] - Ci(x)</code>
</p>

<p>and their Pad\'e approximants
(cf. <a href="https://en.wikipedia.org/wiki/Trigonometric_integral#Efficient_evaluation">https://en.wikipedia.org/wiki/Trigonometric_integral#Efficient_evaluation</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E1_imaginary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="E1_imaginary_+3A_x">x</code></td>
<td>
<p>A non-negative number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The exponential integral of argument ix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E1_imaginary(1.0)
</code></pre>

<hr>
<h2 id='Etheta_imaginary'>Incomplete gamma function of imaginary argument with arbitrary power</h2><span id='topic+Etheta_imaginary'></span>

<h3>Description</h3>

<p>Calculates the value of
</p>
<p style="text-align: center;"><code class="reqn">-ix e^{ix} E_\theta(ix) = -ix e{ix} \int_1^\infty t^{-\theta} e^{-ixt} \mathrm d t</code>
</p>

<p>for <code class="reqn">\theta &gt; 0</code>.
This is achieved using recursive integrations by parts until <code class="reqn">0 &lt; \theta \le 1</code>,
then using either the exponential integral <code>E1_imaginary</code> if <code class="reqn">\theta = 1</code>,
or the incomplete gamma function <code>inc_gamma_imag</code> if <code class="reqn">0 &lt; \theta &lt; 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Etheta_imaginary(theta, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Etheta_imaginary_+3A_theta">theta</code></td>
<td>
<p>A strictly positive number</p>
</td></tr>
<tr><td><code id="Etheta_imaginary_+3A_x">x</code></td>
<td>
<p>A vector of non-negative numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The incomplete gamma function of imaginary argument with arbitrary power (see Details)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Etheta_imaginary(3.14, 1.0)
</code></pre>

<hr>
<h2 id='Exponential'>Reproduction kernels for the Hawkes processes</h2><span id='topic+Exponential'></span><span id='topic+SymmetricExponential'></span><span id='topic+Gaussian'></span><span id='topic+PowerLaw'></span><span id='topic+Pareto3'></span><span id='topic+Pareto2'></span><span id='topic+Pareto1'></span>

<h3>Description</h3>

<p>These classes are derived from the class <code>Model</code>, each implementing
a different reproduction kernel for the Hawkes process.
They inherit all fields from <a href="#topic+Model">Model</a>.
</p>


<h3>Details</h3>


<ul>
<li><p> The kernel <code>Exponential</code> has density function
</p>
<p style="text-align: center;"><code class="reqn">h^\ast(t) = \beta \exp(-\beta t) 1_{\{t \ge 0\}}.</code>
</p>

<p>Its vector of parameters must be of the form <code class="reqn">(\eta, \mu, \beta)</code>.
Both <code>loglik</code>, its derivatives, and <code>whittle</code> can be used with this reproduction kernel.
</p>
</li>
<li><p> The kernel <code>SymmetricExponential</code> has density function
</p>
<p style="text-align: center;"><code class="reqn">h^\ast(t) = 0.5 \beta \exp(-\beta |t|).</code>
</p>

<p>Its vector of parameters must be of the form <code class="reqn">(\eta, \mu, \beta)</code>.
Only <code>whittle</code> can be used with this reproduction kernel.
</p>
</li>
<li><p> The kernel <code>Gaussian</code> has density function
</p>
<p style="text-align: center;"><code class="reqn">h^\ast(t) = \frac{1}{\sigma \sqrt{2\pi}}\exp\left(-\frac{(t-\nu)^2}{2\sigma^2}\right).</code>
</p>

<p>Its vector of parameters must be of the form <code class="reqn">(\eta, \mu, \nu, \sigma^2)</code>.
Only <code>whittle</code> is available with this reproduction kernel.
</p>
</li>
<li><p> The kernel <code>PowerLaw</code> has density function
</p>
<p style="text-align: center;"><code class="reqn">h^\ast(t) = \theta a^\theta (t+a)^{-\theta-1} 1_{\{\theta &gt; 0 \}}.</code>
</p>

<p>Its vector of parameters must be of the form <code class="reqn">(\eta, \mu, \theta, a)</code>.
Both <code>loglik</code>, its derivatives, and <code>whittle</code> can be used with this reproduction kernel.
</p>
</li>
<li><p> The kernels <code>Pareto3</code>, <code>Pareto2</code> and <code>Pareto1</code> have density function
</p>
<p style="text-align: center;"><code class="reqn">h_\theta^\ast(t) = \theta a^\theta t^{-\theta - 1} 1_{\{t &gt; a\}},</code>
</p>

<p>with <code class="reqn">\theta</code> = 3, 2 and 1 respectively.
Their vectors of parameters must be of the form <code class="reqn">(\eta, \mu, a)</code>.
Only <code>whittle</code> is available with this reproduction kernel.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+Model">Model</a>
</p>

<hr>
<h2 id='hawkes'>Simulation of a Hawkes process</h2><span id='topic+hawkes'></span>

<h3>Description</h3>

<p>Simulates a Hawkes process using its cluster representation:
</p>

<ul>
<li><p> First, the immigrants are drawn according to an (inhomogeneous) Poisson process with intensity measure <code>fun</code>.
</p>
</li>
<li><p> Second, the number of offsprings of an immigrant follows a Poisson distribution with intensity <code>repr</code>.
</p>
</li>
<li><p> Third, these offsprings are distributed according to the <code>family</code> distribution.
</p>
</li>
<li><p> Then, generate further offsprings according to the last two steps.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>hawkes(end, fun, repr, family, M = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hawkes_+3A_end">end</code></td>
<td>
<p>A non-negative numeric value - right bound of the interval <code class="reqn">[0,\mathrm{end}]</code>.</p>
</td></tr>
<tr><td><code id="hawkes_+3A_fun">fun</code></td>
<td>
<p>A non-negative function or numeric value - intensity (function) of the immigrant process.</p>
</td></tr>
<tr><td><code id="hawkes_+3A_repr">repr</code></td>
<td>
<p>A non-negative numeric value - mean number of offsprings.</p>
</td></tr>
<tr><td><code id="hawkes_+3A_family">family</code></td>
<td>
<p>A character string &quot;name&quot; naming a distribution with corresponding random generation function <code>rname</code>, or directly the random generation function.</p>
</td></tr>
<tr><td><code id="hawkes_+3A_m">M</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - upper bound on <code>fun</code>(ignored if <code>fun</code> is a numeric value).</p>
</td></tr>
<tr><td><code id="hawkes_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the random generation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A S3 object of class Hawkes containing a vector ($p) of simulated values,
and all other objects used for the simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an exponential Hawkes process with baseline intensity 1,
# reproduction mean 0.5 and exponential fertility function with rate 2.
x &lt;- hawkes(10, fun=1, repr=0.5, family="exp", rate=2)
# Simulate a Hawkes process with baseline intensity function 1 + sin(x),
# reproduction mean 0.5 and custom [0,1]-triangular fertility function.
x &lt;- hawkes(10, fun=function(y) {1+sin(y)}, M=2, repr=0.5,
            family=function(n) {1 - sqrt(1 - runif(n))})
</code></pre>

<hr>
<h2 id='hawkes_ogata'>Simulation of a Hawkes process</h2><span id='topic+hawkes_ogata'></span>

<h3>Description</h3>

<p>Simulates a Hawkes process via Ogata's modified thinning algorithm on <code class="reqn">[0,\mathrm{end}]</code>.
This is less efficient than function <code>hawkes</code>, but can be useful for pedagogical reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hawkes_ogata(end, lambda, alpha, beta, lambda0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hawkes_ogata_+3A_end">end</code></td>
<td>
<p>Right bound on time.</p>
</td></tr>
<tr><td><code id="hawkes_ogata_+3A_lambda">lambda</code></td>
<td>
<p>Baseline intensity.</p>
</td></tr>
<tr><td><code id="hawkes_ogata_+3A_alpha">alpha</code></td>
<td>
<p>Parameter for the amplitude of the spike.</p>
</td></tr>
<tr><td><code id="hawkes_ogata_+3A_beta">beta</code></td>
<td>
<p>Parameter for the speed of exponential decay.</p>
</td></tr>
<tr><td><code id="hawkes_ogata_+3A_lambda0">lambda0</code></td>
<td>
<p>(Optional) Initial value of the conditional intensity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A S3 object of class Hawkes containing a vector ($p) of simulated values,
and all other objects used for the simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an exponential Hawkes process with baseline intensity 1 and
# excitation function 1*exp(-2t)
x &lt;- hawkes_ogata(10, 1, 1, 2)
plot(x)
</code></pre>

<hr>
<h2 id='hawkesbow-package'>hawkesbow: Estimation of Hawkes Processes from Binned Observations</h2><span id='topic+hawkesbow'></span><span id='topic+hawkesbow-package'></span>

<h3>Description</h3>

<p>Implements an estimation method for Hawkes processes when count data are only observed in discrete time, using a spectral approach derived from the Bartlett spectrum, see Cheysson and Lang (2020) &lt;arXiv:2003.04314&gt;. Some general use functions for Hawkes processes are also included: simulation of (in)homogeneous Hawkes process, maximum likelihood estimation, residual analysis, etc.
</p>


<h3>Details</h3>

<p>To be implemented later:
</p>

<ul>
<li><p> Variance and confidence interval for the estimated parameters
</p>
</li>
<li><p> Spectral density based goodness-of-fit tests
</p>
</li>
<li><p> Custom built-kernels
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Felix Cheysson <a href="mailto:felix@cheysson.fr">felix@cheysson.fr</a> (<a href="https://orcid.org/0000-0002-9095-2878">ORCID</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an exponential Hawkes process with baseline intensity 1,
# reproduction mean 0.5 and exponential fertility function with rate 2.
x &lt;- hawkes(10, fun=1, repr=0.5, family="exp", rate=2)

# Plot its conditional intensity function
oldpar = par()
par(mfrow = c(2, 1), mar = c(4.1, 4.1, 1.1, 2.1))
plot(x, intensity = TRUE)
# and its poisson cluster representation
plot(x, intensity = FALSE)
par(oldpar)

# Estimate the parameters from the arrival times of `x`
# using maximum likelihood estimation
opt = mle(x$p, "Exponential", x$end)
opt$par                          # Estimated parameters
opt$model$ddloglik(x$p, x$end)     # Hessian matrix of the log-likelihood

# Estimate the parameters from count data using Whittle's method
y = discrete(x, binsize = 1)
opt = whittle(y, "Exponential", binsize = 1)
opt$par                          # Estimated parameters
</code></pre>

<hr>
<h2 id='inc_gamma_imag'>Incomplete gamma function of imaginary argument</h2><span id='topic+inc_gamma_imag'></span>

<h3>Description</h3>

<p>Calculates the value of
</p>
<p style="text-align: center;"><code class="reqn">\Gamma_1(x, \alpha) = \int_x^\infty t^{\alpha-1} e^{-it} \mathrm{d}t</code>
</p>

<p>for <code class="reqn">0 &lt; \alpha &lt; 1</code> through the following relations:
</p>
<p style="text-align: center;"><code class="reqn">\int_0^\infty t^{\alpha-1} e^{-it} \mathrm{d}t =
e^{-i\frac{\pi}{2}\alpha} \int_0^\infty t^{\alpha-1} e^{-t} \mathrm{d}t =
e^{-i\frac{\pi}{2}\alpha} \Gamma(\alpha).</code>
</p>

<p>obtained by contour integration, and:
</p>
<p style="text-align: center;"><code class="reqn">\int_0^x t^{\alpha-1} e^{-it} \mathrm{d}t =
\int_0^x t^{\alpha-1} \mathrm{cos}(t) \mathrm{d}t -
i \int_0^x t^{\alpha-1} \mathrm{sin}(t) \mathrm{d}t =
Ci(x, \alpha) - i Si(x, \alpha)</code>
</p>
<p>.
The first integral is calculated using function &quot;tgamma&quot; from the library
&quot;boost::math&quot;, while the functions Ci and Si are approximated via
Taylor expansions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inc_gamma_imag(x, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inc_gamma_imag_+3A_x">x</code></td>
<td>
<p>A non-negative number</p>
</td></tr>
<tr><td><code id="inc_gamma_imag_+3A_alpha">alpha</code></td>
<td>
<p>A number between 0 and 1 (strictly)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The incomplete gamma function of imaginary argument (see Details)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inc_gamma_imag(1.0, 0.5)
</code></pre>

<hr>
<h2 id='inhpois'>Simulation of an inhomogeneous Poisson process by thinning</h2><span id='topic+inhpois'></span>

<h3>Description</h3>

<p>Simulates an inhomogeneous Poisson process via Ogata's modified thinning algorithm on <code class="reqn">[0,\mathrm{end}]</code>.
An homogeneous Poisson process with intensity <code>M</code> is first generated on <code class="reqn">[0,\mathrm{end}]</code>, then thinned using the specified intensity function <code>fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inhpois(end, fun, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inhpois_+3A_end">end</code></td>
<td>
<p>A non-negative numeric value - right bound of the interval <code class="reqn">[0,\mathrm{end}]</code>.</p>
</td></tr>
<tr><td><code id="inhpois_+3A_fun">fun</code></td>
<td>
<p>A non-negative function or numeric value - intensity (function) of the Poisson process.</p>
</td></tr>
<tr><td><code id="inhpois_+3A_m">M</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - upper bound on <code>fun</code> (ignored if <code>fun</code> is a numeric value).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A S3 object of class <code>inhpois</code> containing a vector ($p) of simulated values,
and all other objects used for the simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an inhomogeneous Poisson process with function intensity 1 + sin(x) (bounded by 2)
x &lt;- inhpois(end=10, fun=function(y) {1 + sin(y)}, M=2)
# Simulate a homogeneous Poisson process with intensity 3
x &lt;- inhpois(end=10, fun=3)
</code></pre>

<hr>
<h2 id='intensity'>Intensity of a Hawkes process</h2><span id='topic+intensity'></span>

<h3>Description</h3>

<p>Outputs the intensity of a Hawkes process <code>x</code>, given the specified set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intensity(x, t, fun = NULL, repr = NULL, family = NULL, M = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity_+3A_x">x</code></td>
<td>
<p>A non-negative numeric vector, sorted in ascending order; or an object of class &quot;hawkes&quot; output by function <code>hawkes</code>.</p>
</td></tr>
<tr><td><code id="intensity_+3A_t">t</code></td>
<td>
<p>A non-negative numeric value or vector, at which the intensity should be computed.</p>
</td></tr>
<tr><td><code id="intensity_+3A_fun">fun</code></td>
<td>
<p>(default = TRUE) A non-negative numeric function or value - intensity (function) of the immigrant process.</p>
</td></tr>
<tr><td><code id="intensity_+3A_repr">repr</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - mean number of offsprings.</p>
</td></tr>
<tr><td><code id="intensity_+3A_family">family</code></td>
<td>
<p>(default = NULL) A character string &quot;name&quot; naming a distribution with corresponding distribution function <code>dname</code>, or directly the distribution function.</p>
</td></tr>
<tr><td><code id="intensity_+3A_m">M</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - upper bound on <code>fun</code>(ignored if <code>fun</code> is a numeric value).</p>
</td></tr>
<tr><td><code id="intensity_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the random generation function <code>dname</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input <code>x</code> has been simulated using the function <code>hawkes</code>, the parameters of the simulation will be used by default to compute the intensity.
If any parameter is specified in this function call, the function will use this instead.
</p>


<h3>Value</h3>

<p>The intensity at time t.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an exponential Hawkes process with baseline intensity 1,
# reproduction mean 0.5 and exponential fertility distribution with rate 2.
x &lt;- hawkes(10, fun=1, repr=0.5, family="exp", rate=2)
intensity(x, 0:10)
# Intensity with a different set of parameters
intensity(x, 0:10, repr=0.8, rate=3)
# Intensity with a different distribution function
intensity(x, 0:10, family="chisq", df=2)
# Simulate a Hawkes process with baseline intensity function 1 + sin(x),
# reproduction mean 0.5 and custom [0,1]-triangular fertility function.
x &lt;- hawkes(10, fun=function(y) {1+sin(y)}, M=2, repr=0.5,
            family=function(n) {1 - sqrt(1 - runif(n))})
intensity(x, 0:10, family=function(y) ifelse(y&gt;0 &amp; y&lt;1, 2-2*y, 0))
</code></pre>

<hr>
<h2 id='mle'>Fitting Hawkes processes from continuous data</h2><span id='topic+mle'></span>

<h3>Description</h3>

<p>This function fits a Hawkes process to continuous data by minimizing the likelihood
on the interval <code class="reqn">[0,\mathrm{end}]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle(events, kern, end, init = NULL, opts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle_+3A_events">events</code></td>
<td>
<p>The locations of events (sorted in ascending order)</p>
</td></tr>
<tr><td><code id="mle_+3A_kern">kern</code></td>
<td>
<p>Either a string (partially) matching one of the kernels implemented (see Details), or an object of class Model</p>
</td></tr>
<tr><td><code id="mle_+3A_end">end</code></td>
<td>
<p>The time until which the process is observed.</p>
</td></tr>
<tr><td><code id="mle_+3A_init">init</code></td>
<td>
<p>(Optional) Initial values of the optimisation algorithm</p>
</td></tr>
<tr><td><code id="mle_+3A_opts">opts</code></td>
<td>
<p>(Optional) To be passed to <code>nloptr</code></p>
</td></tr>
<tr><td><code id="mle_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>nloptr</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum likelihood estimation procedure has only been implemented for the
exponential and the power law kernels.
For the exponential kernel, the likelihood is computed in <code class="reqn">O(n)</code> complexity
(as described in details in T. Ozaki and Y. Ogata, “Maximum likelihood
estimation of Hawkes’ self-exciting point processes,” Ann. Inst. Stat. Math.,
vol. 31, no. 1, pp. 145–155, Dec. 1979).
For the power law kernel, the complexity is <code class="reqn">O(n^2)</code>.
</p>


<h3>Value</h3>

<p>Returns a list containing the solution of the optimisation procedure, the object Model
with its parameters updated to the solution, and the output produced by <code>nloptr</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hawkes">hawkes()</a></code> for the simulation of Hawkes processes,
<a href="#topic+Model">Model</a> for the abstract class, and <a href="#topic+Exponential">Exponential</a> for the specific
reproduction kernels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an exponential Hawkes process with baseline intensity 1,
# reproduction mean 0.5 and exponential fertility function with rate 2.
x = hawkes(100, fun = 1, repr = .5, family = "exp", rate = 1)
# Estimate the parameters from the arrival times of `x` using MLE
opt = mle(x$p, "Exponential", x$end)
opt$par                          # Estimated parameters
opt$model$ddloglik(x$p, x$end)     # Hessian matrix of the log-likelihood
</code></pre>

<hr>
<h2 id='Model'>C++ abstract class for Hawkes processes</h2><span id='topic+Model'></span>

<h3>Description</h3>

<p>This is a C++ abstract class for Hawkes processes, which holds
methods for the estimation of its parameters.
</p>


<h3>Details</h3>

<p>This serves as a basis for the Hawkes model and its count sequence,
with conditional intensity function
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t) = \eta + \mu \sum_{T_i &lt; t} h^\ast(t - T_i).</code>
</p>

<p>As an abstract class, an object of class <code>Model</code> should never be directly
instanciated, but rather one of its derived class.
The constructor can take no argument, in which case the vector <code>param</code> is
initialised to sensible values and <code>binsize</code> defaults to 1.
Alternatively, <code>param</code> and/or <code>binsize</code> can be specified.
</p>


<h3>Fields</h3>


<dl>
<dt><code>param</code></dt><dd><p>Vector of parameters of the Hawkes process, of the form <code class="reqn">(\eta, \mu, ...)</code>.</p>
</dd>
<dt><code>binsize</code></dt><dd><p>Bin size for the count sequences.</p>
</dd>
<dt><code>new(DerivedClass,(param),(binsize))</code></dt><dd><p>Constructor for derived classes; <code>param</code> and/or <code>binsize</code>
can be safely ignored.</p>
</dd>
<dt><code>mean()</code></dt><dd><p>Returns the expected value on <code class="reqn">[0,\mathrm{end}]</code>.</p>
</dd>
<dt><code>dmean()</code></dt><dd><p>Returns the Jacobian matrix of the expected value on <code class="reqn">[0,\mathrm{end}]</code>.</p>
</dd>
<dt><code>ddmean()</code></dt><dd><p>Returns the Hessian matrix of the expected value on <code class="reqn">[0,\mathrm{end}]</code>.</p>
</dd>
<dt><code>f(xi)</code></dt><dd><p>Returns the spectral density function of the time-continuous count sequence. </p>

<ul>
<li> <p><code>xi</code> A numeric vector of frequencies.
</p>
</li></ul>
</dd>
<dt><code>f1(xi,trunc)</code></dt><dd><p>Returns the spectral density function of the discrete time count sequence. </p>

<ul>
<li> <p><code>xi</code> A numeric vector of frequencies.
</p>
</li>
<li> <p><code>trunc</code> The number of foldings to take into account for the aliasing.
</p>
</li></ul>
</dd>
<dt><code>whittle(I,trunc)</code></dt><dd><p>Returns the log-spectral likelihood of a discrete time count sequence. </p>

<ul>
<li> <p><code>I</code> The periodogram of the count sequence.
</p>
</li>
<li> <p><code>trunc</code> The number of foldings to take into account for the aliasing.
</p>
</li></ul>
</dd>
<dt><code>loglik(events,end)</code></dt><dd><p>Returns the log-likelihood of a sequence of arrival times. </p>

<ul>
<li> <p><code>events</code> The sequence of arrival times.
</p>
</li>
<li> <p><code>end</code> The endpoint of the observation window <code class="reqn">[0,\mathrm{end}]</code>.
</p>
</li></ul>
</dd>
<dt><code>dloglik(events,end)</code></dt><dd><p>Returns the Jacobian matrix of the log-likelihood of a sequence of arrival times. </p>

<ul>
<li> <p><code>events</code> The sequence of arrival times.
</p>
</li>
<li> <p><code>end</code> The endpoint of the observation window <code class="reqn">[0,\mathrm{end}]</code>.
</p>
</li></ul>
</dd>
<dt><code>ddloglik(events,end)</code></dt><dd><p>Returns the Hessian matrix of the log-likelihood of a sequence of arrival times. </p>

<ul>
<li> <p><code>events</code> The sequence of arrival times.
</p>
</li>
<li> <p><code>end</code> The endpoint of the observation window <code class="reqn">[0,\mathrm{end}]</code>.
</p>
</li></ul>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+Exponential">Exponential</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate 1000 exponential Hawkes processes on \eqn{[0, 100]},
# and average the periodogram of the count sequences with bin size 1
# at each frequency.
I = rep(0, 100)
for (k in 1:1e3) {
    x = hawkes(100, fun = 1, repr = .5, family = "exp", rate = 2)
    y = discrete(x, binsize = 1)
    I = I + Mod(fft(y - mean(y)))^2 / length(y)
}

# Check that the averaged periodogram correctly approximates the spectral
# density function of the count sequence
model = new(Exponential)
model$param = c(1, .5, 2)
model$binsize = 1

z = 2 * pi * 0:99 / 100     # Frequencies of the periodogram
plot(z, I / 1e3, type = "l") # Averaged periodogram
lines(z, model$f1(xi = z, trunc = 10L), col = "red")

</code></pre>

<hr>
<h2 id='plot.hawkes'>Plot of a Hawkes process</h2><span id='topic+plot.hawkes'></span>

<h3>Description</h3>

<p>Plots the realisation of a Hawkes process and either its cluster representation (<code>intensity=FALSE</code>, only available for a simulated Hawkes process) or its intensity function (<code>intensity=TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hawkes'
plot(
  x,
  intensity = FALSE,
  precision = 1000,
  fun = NULL,
  repr = NULL,
  family = NULL,
  M = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hawkes_+3A_x">x</code></td>
<td>
<p>Either: a numeric vector, sorted in ascending order; or an object of class &quot;hawkes&quot; output by function <code>hawkes</code>.</p>
</td></tr>
<tr><td><code id="plot.hawkes_+3A_intensity">intensity</code></td>
<td>
<p>(default = FALSE) A boolean - whether to represent the cluster representation (<code>FALSE</code>) or the intensity function (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.hawkes_+3A_precision">precision</code></td>
<td>
<p>(default = 1e3) Number of points to plot.</p>
</td></tr>
<tr><td><code id="plot.hawkes_+3A_fun">fun</code></td>
<td>
<p>(default = NULL) A numeric function - intensity (function) of the immigrant process.</p>
</td></tr>
<tr><td><code id="plot.hawkes_+3A_repr">repr</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - mean number of offsprings.</p>
</td></tr>
<tr><td><code id="plot.hawkes_+3A_family">family</code></td>
<td>
<p>(default = NULL) A character string &quot;name&quot; naming a distribution with corresponding distribution function <code>dname</code>, or directly the distribution function.</p>
</td></tr>
<tr><td><code id="plot.hawkes_+3A_m">M</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - upper bound on <code>fun</code>(ignored if <code>fun</code> is a numeric value).</p>
</td></tr>
<tr><td><code id="plot.hawkes_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the random generation function <code>dname</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an exponential Hawkes process with baseline intensity 1,
# reproduction mean 0.5 and exponential fertility function with rate 2.
x &lt;- hawkes(10, fun=1, repr=0.5, family="exp", rate=2)
plot(x)
# Simulate a Hawkes process with baseline intensity function 1 + sin(x),
# reproduction mean 0.5 and custom [0,1]-triangular fertility function.
x &lt;- hawkes(10, fun=function(y) {1+sin(y)}, M=2, repr=0.5,
            family=function(n) {1 - sqrt(1 - runif(n))})
plot(x, intensity=TRUE, family=function(y) ifelse(y&gt;0 &amp; y&lt;1, 2-2*y, 0))
</code></pre>

<hr>
<h2 id='plot.hawkes_ogata'>Plot of a simulated Hawkes process</h2><span id='topic+plot.hawkes_ogata'></span>

<h3>Description</h3>

<p>Plots a Hawkes process simulated by the function <code>hawkes_ogata</code>,
highlighting the steps used in Ogata's thinning algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hawkes_ogata'
plot(x, precision = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hawkes_ogata_+3A_x">x</code></td>
<td>
<p>A simulated Hawkes process from <code>hawkes_ogata</code>.</p>
</td></tr>
<tr><td><code id="plot.hawkes_ogata_+3A_precision">precision</code></td>
<td>
<p>(default = 1e3) Number of points to plot.</p>
</td></tr>
<tr><td><code id="plot.hawkes_ogata_+3A_...">...</code></td>
<td>
<p>Only there to fit the declaration of S3 method <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an exponential Hawkes process with baseline intensity 1 and
# excitation function 1*exp(-2t)
x &lt;- hawkes_ogata(10, 1, 1, 2)
plot(x)
</code></pre>

<hr>
<h2 id='plot.inhpois'>Plot of a simulated inhomogeneous Poisson process</h2><span id='topic+plot.inhpois'></span>

<h3>Description</h3>

<p>Plots a simulated inhomogeneous Poisson process, highlighting the steps used in Ogata's thinning algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inhpois'
plot(x, precision = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.inhpois_+3A_x">x</code></td>
<td>
<p>A simulated inhomogeneous Poisson process.</p>
</td></tr>
<tr><td><code id="plot.inhpois_+3A_precision">precision</code></td>
<td>
<p>(default = 1e3) Number of points to plot.</p>
</td></tr>
<tr><td><code id="plot.inhpois_+3A_...">...</code></td>
<td>
<p>Only there to fit the declaration of S3 method <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an inhomogeneous Poisson process with function intensity 1 + sin(x)
x &lt;- inhpois(end=10, fun=function(y) {1 + sin(y)}, M=2)
plot(x)
</code></pre>

<hr>
<h2 id='residuals'>Residuals of a Hawkes process</h2><span id='topic+residuals'></span>

<h3>Description</h3>

<p>Outputs the residuals (values of the compensator at the times of arrival) of a Hawkes process.
Useful function for diagnosis through the random time change theorem: the residuals should follow
a unit rate Poisson process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals(x, fun = NULL, repr = NULL, family = NULL, M = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_+3A_x">x</code></td>
<td>
<p>A non-negative numeric vector, sorted in ascending order; or an object of class &quot;hawkes&quot; output by function <code>hawkes</code>.</p>
</td></tr>
<tr><td><code id="residuals_+3A_fun">fun</code></td>
<td>
<p>(default = TRUE) A non-negative numeric function or value - intensity (function) of the immigrant process.</p>
</td></tr>
<tr><td><code id="residuals_+3A_repr">repr</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - mean number of offsprings.</p>
</td></tr>
<tr><td><code id="residuals_+3A_family">family</code></td>
<td>
<p>(default = NULL) A character string &quot;name&quot; naming a distribution with corresponding distribution function <code>dname</code>, or directly the distribution function.</p>
</td></tr>
<tr><td><code id="residuals_+3A_m">M</code></td>
<td>
<p>(default = NULL) A non-negative numeric value - upper bound on <code>fun</code>(ignored if <code>fun</code> is a numeric value).</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the random generation function <code>dname</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The residuals of the process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an exponential Hawkes process with baseline intensity 1,
# reproduction mean 0.5 and exponential fertility distribution with rate 2.
x &lt;- hawkes(10, fun=1, repr=0.5, family="exp", rate=2)
resid = residuals(x)
resid
plot(resid)
abline(0, 1, col="red", lty="dashed")
# Residuals with a different set of parameters
residuals(x, repr=0.8, rate=3)
# Residuals with a different distribution function
residuals(x, family="chisq", df=2)
# Simulate a Hawkes process with baseline intensity function 1 + sin(x),
# reproduction mean 0.5 and custom [0,1]-triangular fertility function.
x &lt;- hawkes(10, fun=function(y) {1+sin(y)}, M=2, repr=0.5,
            family=function(n) {1 - sqrt(1 - runif(n))})
resid = residuals(x, family=function(y) ifelse(y&gt;0 &amp; y&lt;1, 2-2*y, 0))
plot(resid)
abline(0, 1, col="red", lty="dashed")
</code></pre>

<hr>
<h2 id='whittle'>Fitting Hawkes processes from discrete data</h2><span id='topic+whittle'></span>

<h3>Description</h3>

<p>This function fits a Hawkes process to discrete data by minimizing the Whittle contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whittle(counts, kern, binsize = NULL, trunc = 5L, init = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whittle_+3A_counts">counts</code></td>
<td>
<p>A bin-count sequence</p>
</td></tr>
<tr><td><code id="whittle_+3A_kern">kern</code></td>
<td>
<p>Either a string (partially) matching one of the kernels implemented (see Details), or an object of class Model</p>
</td></tr>
<tr><td><code id="whittle_+3A_binsize">binsize</code></td>
<td>
<p>(Optional) The bin size of the bin-count sequence; if omitted, defaults to 1 if <code>kern</code> is a string, or uses the member <code>binsize</code> of <code>kern</code> if it is of class Model</p>
</td></tr>
<tr><td><code id="whittle_+3A_trunc">trunc</code></td>
<td>
<p>(Optional) The number of foldings taken into account due to aliasing</p>
</td></tr>
<tr><td><code id="whittle_+3A_init">init</code></td>
<td>
<p>(Optional) Initial values of the optimisation algorithm</p>
</td></tr>
<tr><td><code id="whittle_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>optim</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If specified as string, the argument <code>kern</code> must match (partially) one of the following
(upper cases not taken into account): Exponential, SymmetricExponential,
Gaussian, PowerLaw, Pareto3, Pareto2, Pareto1.
The periodogram used in the optimisation procedure is computed in complexity
<code class="reqn">O(n \log n)</code>, using function <code>fft</code>.
</p>


<h3>Value</h3>

<p>Returns a list containing the solution of the optimisation procedure, the object Model
with its parameters updated to the solution, and the output produced by <code>optim</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hawkes">hawkes()</a></code> for the simulation of Hawkes processes,
<code><a href="#topic+discrete">discrete()</a></code> for the discretisation of simulated Hawkes processes,
<a href="#topic+Model">Model</a> for the abstract class, and <a href="#topic+Exponential">Exponential</a> for the specific
reproduction kernels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate and fit a Hawkes process with exponential kernel
x = hawkes(1000, fun = 1, repr = .5, family = "exp", rate = 1)
y = discrete(x, binsize = 1)
opt = whittle(y, "Exponential")
opt$par      # Estimated parameters


# May take up to 20 seconds
# Simulate and fit a Hawkes process with power law kernel
x = hawkes(1000, fun = 1, repr= .3, family = "powerlaw", shape = 3.5, scale = 1.0)
y = discrete(x, binsize = 1)
opt = whittle(y, "powerlaw")
opt$par      # Estimated parameters

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
