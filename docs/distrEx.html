<!DOCTYPE html><html><head><title>Help for package distrEx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distrEx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distrEx-package'>
<p>distrEx &ndash; Extensions of Package distr</p></a></li>
<li><a href='#AbscontCondDistribution-class'><p>Absolutely continuous conditional distribution</p></a></li>
<li><a href='#AsymTotalVarDist'><p>Generic function for the computation of asymmetric total variation distance of two distributions</p></a></li>
<li><a href='#Condition-class'><p>Conditions</p></a></li>
<li><a href='#ContaminationSize'><p>Generic Function for the Computation of the Convex Contamination</p>
(Pseudo-)Distance of Two Distributions</a></li>
<li><a href='#ConvexContamination'><p>Generic Function for Generating Convex Contaminations</p></a></li>
<li><a href='#CvMDist'><p>Generic function for the computation of the Cramer - von Mises  distance of two distributions</p></a></li>
<li><a href='#dim-methods'><p> Methods for Function dim in Package &lsquo;distrEx&rsquo;</p></a></li>
<li><a href='#DiscreteCondDistribution-class'><p>Discrete conditional distribution</p></a></li>
<li><a href='#DiscreteMVDistribution'><p>Generating function for multivariate discrete distribution</p></a></li>
<li><a href='#DiscreteMVDistribution-class'><p>Discrete Multivariate Distributions</p></a></li>
<li><a href='#distrExIntegrate'><p>Integration of One-Dimensional Functions</p></a></li>
<li><a href='#distrExMASK'><p>Masking of/by other functions in package &quot;distrEx&quot;</p></a></li>
<li><a href='#distrExMOVED'><p>Moved functionality from package &quot;distrEx&quot;</p></a></li>
<li><a href='#distrExOptions'><p>Function to change the global variables of the package &lsquo;distrEx&rsquo;</p></a></li>
<li><a href='#E'><p>Generic Function for the Computation of (Conditional) Expectations</p></a></li>
<li><a href='#EmpiricalMVDistribution'><p>Generating function for mulitvariate discrete distribution</p></a></li>
<li><a href='#EuclCondition'><p>Generating function for EuclCondition-class</p></a></li>
<li><a href='#EuclCondition-class'><p>Conditioning by an Euclidean space.</p></a></li>
<li><a href='#GLIntegrate'><p>Gauss-Legendre Quadrature</p></a></li>
<li><a href='#HellingerDist'><p>Generic function for the computation of the Hellinger distance of two distributions</p></a></li>
<li><a href='#internals_for_distrEx'><p>Internal functions of package distrEx</p></a></li>
<li><a href='#KolmogorovDist'><p>Generic function for the computation of the Kolmogorov distance of two distributions</p></a></li>
<li><a href='#liesInSupport'><p>Generic Function for Testing the Support of a Distribution</p></a></li>
<li><a href='#LMCondDistribution'><p>Generating function for the conditional distribution</p>
of a linear regression model.</a></li>
<li><a href='#LMParameter'><p>Generating function for LMParameter-class</p></a></li>
<li><a href='#LMParameter-class'><p>Parameter of a linear regression model</p></a></li>
<li><a href='#m1df'><p>Generic Function for the Computation of Clipped First Moments</p></a></li>
<li><a href='#m2df'><p>Generic function for the computation of clipped second moments</p></a></li>
<li><a href='#make01'><p>Centering and Standardization of Univariate Distributions</p></a></li>
<li><a href='#MultivariateDistribution-class'><p>Multivariate Distributions</p></a></li>
<li><a href='#OAsymTotalVarDist'><p>Generic function for the computation of (minimal) asymmetric total variation distance of two distributions</p></a></li>
<li><a href='#plot-methods'><p> Methods for Function plot in Package &lsquo;distrEx&rsquo;</p></a></li>
<li><a href='#PrognCondDistribution'><p>Generating function for PrognCondDistribution-class</p></a></li>
<li><a href='#PrognCondDistribution-class'><p>Posterior distribution in convolution</p></a></li>
<li><a href='#PrognCondition-class'><p>Conditions of class 'PrognCondition'</p></a></li>
<li><a href='#TotalVarDist'><p>Generic function for the computation of the total variation distance of two distributions</p></a></li>
<li><a href='#UnivariateCondDistribution-class'><p>Univariate conditional distribution</p></a></li>
<li><a href='#var'><p>Generic Functions for the Computation of Functionals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.9.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-29</td>
</tr>
<tr>
<td>Title:</td>
<td>Extensions of Package 'distr'</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends package 'distr' by functionals, distances, and conditional distributions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4), methods, distr(&ge; 2.8.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>startupmsg, utils, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tcltk</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://distr.r-forge.r-project.org/">http://distr.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>LastChangedDate:</td>
<td>{$LastChangedDate: 2024-01-29 19:03:53 +0100 (Mo, 29.
Jan 2024) $}</td>
</tr>
<tr>
<td>LastChangedRevision:</td>
<td>{$LastChangedRevision: 1427 $}</td>
</tr>
<tr>
<td>VCS/SVNRevision:</td>
<td>1426</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 10:46:04 UTC; kohlm</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl [cre, cph],
  Peter Ruckdeschel [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='distrEx-package'>
distrEx &ndash; Extensions of Package distr
</h2><span id='topic+distrEx-package'></span><span id='topic+distrEx'></span>

<h3>Description</h3>

<p><span class="pkg">distrEx</span> provides some extensions of package <span class="pkg">distr</span>:
</p>
<ul>
<li><p> expectations in the form
</p>
<ul>
<li> <p><code>E(X)</code> for the expectation of a 
distribution object <code>X</code> 
</p>
</li>
<li> <p><code>E(X,f)</code> for the expectation of <code>f(X)</code> 
where <code>X</code> is some distribution object and 
<code>f</code> some function in <code>X</code> </p>
</li></ul>

</li>
<li><p> further functionals: var, sd, IQR, mad, median, skewness, kurtosis
</p>
</li>
<li><p> truncated moments,
</p>
</li>
<li><p> distances between distributions
(Hellinger, Cramer von Mises, Kolmogorov, total variation, &quot;convex contamination&quot;)
</p>
</li>
<li><p> lists of distributions,
</p>
</li>
<li><p> conditional distributions in factorized form 
</p>
</li>
<li><p> conditional expectations in factorized form
</p>
</li></ul>

<p>Support for  extreme value distributions has moved to package <span class="pkg">RobExtremes</span>
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> distrEx </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.9.2 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-29 </td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.4), methods, distr(&gt;= 2.8.0) </td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> startupmsg, utils, stats </td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests:  </td><td style="text-align: left;"> tcltk </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://distr.r-forge.r-project.org/</td>
</tr>
<tr>
 <td style="text-align: left;">
VCS/SVNRevision: </td><td style="text-align: left;"> 1426 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Classes</h3>

<pre>
Distribution Classes
"Distribution" (from distr)
|&gt;"UnivariateDistribution" (from distr)
|&gt;|&gt;"AbscontDistribution" (from distr)
|&gt;|&gt;|&gt;"Gumbel"  (moved to package 'RobExtremes')
|&gt;|&gt;|&gt;"Pareto"  (moved to package 'RobExtremes')
|&gt;|&gt;|&gt;"GPareto" (moved to package 'RobExtremes')
|&gt;"MultivariateDistribution"
|&gt;|&gt;"DiscreteMVDistribution-class"
|&gt;"UnivariateCondDistribution"
|&gt;|&gt;"AbscontCondDistribution"
|&gt;|&gt;|&gt;"PrognCondDistribution"
|&gt;|&gt;"DiscreteCondDistribution"
Condition Classes
"Condition"
|&gt;"EuclCondition"
|&gt;"PrognCondition"
Parameter Classes
"OptionalParameter" (from distr)
|&gt;"Parameter" (from distr)
|&gt;|&gt;"LMParameter"
|&gt;|&gt;"GumbelParameter"
|&gt;|&gt;"ParetoParameter"
</pre>


<h3>Functions</h3>

<pre>
Integration:
GLIntegrate             Gauss-Legendre quadrature
distrExIntegrate        Integration of one-dimensional functions
Options:
distrExOptions          Function to change the global variables of the
                        package 'distrEx'
Standardization:
make01                  Centering and standardization of univariate
                        distributions
</pre>

<h3>Generating Functions</h3>

<pre>
Distribution Classes
ConvexContamination     Generic function for generating convex
                        contaminations
DiscreteMVDistribution
                        Generating function for
                        DiscreteMVDistribution-class
Gumbel                  Generating function for Gumbel-class
LMCondDistribution      Generating function for the conditional
                        distribution of a linear regression model.
Condition Classes
EuclCondition           Generating function for EuclCondition-class
Parameter Classes
LMParameter             Generating function for LMParameter-class
</pre>

<h3>Methods</h3>

<pre>
Distances:
ContaminationSize       Generic function for the computation of the
                        convex contamination (Pseudo-)distance of two
                        distributions
HellingerDist           Generic function for the computation of the
                        Hellinger distance of two distributions
KolmogorovDist          Generic function for the computation of the
                        Kolmogorov distance of two distributions
TotalVarDist            Generic function for the computation of the
                        total variation distance of two distributions
AsymTotalVarDist        Generic function for the computation of the
                        asymmetric total variation distance of two distributions
                        (for given ratio rho of negative to positive part of deviation)
OAsymTotalVarDist       Generic function for the computation of the minimal (in rho)
                        asymmetric total variation distance of two distributions
vonMisesDist            Generic function for the computation of the
                        von Mises distance of two distributions
liesInSupport           Generic function for testing the support of a
                        distribution
Functionals:
E                       Generic function for the computation of
                        (conditional) expectations
var                     Generic functions for the computation of
                        functionals
IQR                     Generic functions for the computation of
                        functionals
sd                      Generic functions for the computation of
                        functionals
mad                     Generic functions for the computation of
                        functionals
median                  Generic functions for the computation of
                        functionals
skewness                Generic functions for the computation of
                        functionals
kurtosis                Generic functions for the computation of
                        Functionals
truncated Moments:
m1df                    Generic function for the computation of clipped
                        first moments
m2df                    Generic function for the computation of clipped
                        second moments
</pre>


<h3>Demos</h3>

<p>Demos are available &mdash; see <code>demo(package="distrEx")</code>.</p>


<h3>Acknowledgement</h3>

<p>G. Jay Kerns, <a href="mailto:gkerns@ysu.edu">gkerns@ysu.edu</a>, has provided a major contribution,
in particular the functionals <code>skewness</code> and <code>kurtosis</code> are due to him.
</p>


<h3>Start-up-Banner</h3>

<p>You may suppress the start-up banner/message completely by setting 
<code>options("StartupBanner"="off")</code> somewhere before loading this package by 
<code>library</code> or <code>require</code> in your R-code / R-session.
If option <code>"StartupBanner"</code> is not defined (default) or setting    
<code>options("StartupBanner"=NULL)</code> or 
<code>options("StartupBanner"="complete")</code> the complete start-up banner is 
displayed.
For any other value of option <code>"StartupBanner"</code> (i.e., not in 
<code>c(NULL,"off","complete")</code>) only the version information is displayed.
The same can be achieved by wrapping the <code>library</code> or <code>require</code>  call 
into either <code>suppressStartupMessages()</code> or 
<code>onlytypeStartupMessages(.,atypes="version")</code>.  
</p>
<p>As for general <code>packageStartupMessage</code>'s, you may also suppress all
the start-up banner by wrapping the <code>library</code> or <code>require</code> 
call into <code>suppressPackageStartupMessages()</code> from 
<span class="pkg">startupmsg</span>-version 0.5 on.
</p>


<h3>Package versions</h3>

<p>Note: The first two numbers of package versions do not necessarily reflect
package-individual development, but rather are chosen for the
distrXXX family as a whole in order to ease updating &quot;depends&quot;
information.
</p>


<h3>Note</h3>

<p>Some functions of package <span class="pkg">stats</span> have intentionally been masked, but 
completely retain their functionality &mdash; see <code>distrExMASK()</code>.
If any of the packages <span class="pkg">e1071</span>, <span class="pkg">moments</span>, <span class="pkg">fBasics</span> is to be used 
together with <span class="pkg">distrEx</span> the latter must be attached <em>after</em> any of the 
first mentioned. Otherwise <code>kurtosis()</code> and <code>skewness()</code>
defined as <em>methods</em> in <span class="pkg">distrEx</span> may get masked.<br />  To re-mask, you 
may use  <code>kurtosis &lt;- distrEx::kurtosis; skewness &lt;- distrEx::skewness</code>. 
See also <code>distrExMASK()</code>
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> and <br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br /> 
<em>Maintainer:</em>  Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>References</h3>

<p>P. Ruckdeschel, M. Kohl, T. Stabla, F. Camphausen (2006):
S4 Classes for Distributions, <em>R News</em>, <em>6</em>(2), 2-6. 
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-2.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-2.pdf</a>
a vignette for packages <span class="pkg">distr</span>, <span class="pkg">distrSim</span>, <span class="pkg">distrTEst</span>,
</p>
<p>and <span class="pkg">distrEx</span> is included into the mere documentation package <span class="pkg">distrDoc</span> 
and may be called by <code>require("distrDoc");vignette("distr")</code>
a homepage to this package is available under<br />
<a href="https://distr.r-forge.r-project.org/">https://distr.r-forge.r-project.org/</a>
M. Kohl (2005): <em>Numerical Contributions to the Asymptotic 
Theory of Robustness.</em> PhD Thesis. Bayreuth. Available as 
<a href="https://www.stamats.de/wp-content/uploads/2018/04/ThesisMKohl.pdf">https://www.stamats.de/wp-content/uploads/2018/04/ThesisMKohl.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+0distr-package">distr-package</a></code> 
</p>

<hr>
<h2 id='AbscontCondDistribution-class'>Absolutely continuous conditional distribution</h2><span id='topic+AbscontCondDistribution-class'></span>

<h3>Description</h3>

<p>The class of absolutely continuous conditional univariate distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("AbscontCondDistribution", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cond</code></dt><dd><p>Object of class <code>"Condition"</code>: condition </p>
</dd>
<dt><code>img</code></dt><dd><p>Object of class <code>"rSpace"</code>: the image space. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"OptionalParameter"</code>: an 
optional parameter.</p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: 
generates random numbers. </p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional conditional density function. </p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional conditional cumulative distribution function. </p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>:
optional conditional quantile function. </p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UnivariateCondDistribution"</code>, directly.<br />
Class <code>"Distribution"</code>, by class <code>"UnivariateCondDistribution"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+UnivariateCondDistribution-class">UnivariateCondDistribution-class</a></code>, <code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("AbscontCondDistribution")</code></pre>

<hr>
<h2 id='AsymTotalVarDist'>Generic function for the computation of asymmetric total variation distance of two distributions</h2><span id='topic+AsymTotalVarDist'></span><span id='topic+AsymTotalVarDist-methods'></span><span id='topic+AsymTotalVarDist+2CAbscontDistribution+2CAbscontDistribution-method'></span><span id='topic+AsymTotalVarDist+2CAbscontDistribution+2CDiscreteDistribution-method'></span><span id='topic+AsymTotalVarDist+2CDiscreteDistribution+2CDiscreteDistribution-method'></span><span id='topic+AsymTotalVarDist+2CDiscreteDistribution+2CAbscontDistribution-method'></span><span id='topic+AsymTotalVarDist+2CLatticeDistribution+2CDiscreteDistribution-method'></span><span id='topic+AsymTotalVarDist+2CDiscreteDistribution+2CLatticeDistribution-method'></span><span id='topic+AsymTotalVarDist+2CLatticeDistribution+2CLatticeDistribution-method'></span><span id='topic+AsymTotalVarDist+2Cnumeric+2CDiscreteDistribution-method'></span><span id='topic+AsymTotalVarDist+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic+AsymTotalVarDist+2Cnumeric+2CAbscontDistribution-method'></span><span id='topic+AsymTotalVarDist+2CAbscontDistribution+2Cnumeric-method'></span><span id='topic+AsymTotalVarDist+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of asymmetric total variation distance 
<code class="reqn">d_v(\rho)</code>
of two distributions <code class="reqn">P</code> and <code class="reqn">Q</code> where the distributions may be 
defined for an arbitrary sample space <code class="reqn">(\Omega,{\cal A})</code>.
For given ratio of inlier and outlier probability <code class="reqn">\rho</code>, this distance 
is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_v(\rho)(P,Q)=\int (dQ-c\,dP)_+</code>
</p>

<p>for <code class="reqn">c</code> defined by 
</p>
<p style="text-align: center;"><code class="reqn">\rho \int (dQ-c\,dP)_+ = \int (dQ-c\,dP)_-</code>
</p>

<p>It coincides with total variation distance for <code class="reqn">\rho=1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AsymTotalVarDist(e1, e2, ...)
## S4 method for signature 'AbscontDistribution,AbscontDistribution'
AsymTotalVarDist(e1,e2, rho = 1,
             rel.tol = .Machine$double.eps^0.3, maxiter=1000, Ngrid = 10000,
             TruncQuantile = getdistrOption("TruncQuantile"),
             IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,DiscreteDistribution'
AsymTotalVarDist(e1,e2, rho = 1, ...)
## S4 method for signature 'DiscreteDistribution,AbscontDistribution'
AsymTotalVarDist(e1,e2, rho = 1, ...)
## S4 method for signature 'DiscreteDistribution,DiscreteDistribution'
AsymTotalVarDist(e1,e2, rho = 1, ...)
## S4 method for signature 'numeric,DiscreteDistribution'
AsymTotalVarDist(e1, e2, rho = 1, ...)
## S4 method for signature 'DiscreteDistribution,numeric'
AsymTotalVarDist(e1, e2, rho  = 1, ...)
## S4 method for signature 'numeric,AbscontDistribution'
AsymTotalVarDist(e1, e2, rho = 1, asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e2),
            up.discr = getUp(e2), h.smooth = getdistrExOption("hSmooth"),
             rel.tol = .Machine$double.eps^0.3, maxiter=1000, Ngrid = 10000,
             TruncQuantile = getdistrOption("TruncQuantile"),
             IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,numeric'
AsymTotalVarDist(e1, e2,  rho = 1,
            asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e1),
            up.discr = getUp(e1), h.smooth = getdistrExOption("hSmooth"),
             rel.tol = .Machine$double.eps^0.3, maxiter=1000, Ngrid = 10000,
             TruncQuantile = getdistrOption("TruncQuantile"),
             IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AcDcLcDistribution,AcDcLcDistribution'
AsymTotalVarDist(e1, e2,
          rho = 1, rel.tol = .Machine$double.eps^0.3, maxiter=1000, Ngrid = 10000,
             TruncQuantile = getdistrOption("TruncQuantile"),
             IQR.fac = 15, ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AsymTotalVarDist_+3A_e1">e1</code></td>
<td>
<p> object of class <code>"Distribution"</code> or <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_e2">e2</code></td>
<td>
<p> object of class <code>"Distribution"</code> or <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_asis.smooth.discretize">asis.smooth.discretize</code></td>
<td>
<p> possible methods are <code>"asis"</code>, 
<code>"smooth"</code> and <code>"discretize"</code>. Default is <code>"discretize"</code>.</p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_n.discr">n.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the number of lattice points 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_low.discr">low.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the lower end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_up.discr">up.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the upper end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_h.smooth">h.smooth</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"smooth"</code> &ndash; i.e., the empirical distribution of the provided 
data should be smoothed &ndash; one has to specify this parameter.</p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_rho">rho</code></td>
<td>
<p>ratio of inlier/outlier radius</p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code> and <code>uniroot</code></p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_maxiter">maxiter</code></td>
<td>
<p>parameter for <code>uniroot</code></p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_ngrid">Ngrid</code></td>
<td>
<p>How many grid points are to be evaluated to determine the range
of the likelihood ratio?</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="AsymTotalVarDist_+3A_truncquantile">TruncQuantile</code></td>
<td>
<p>Quantile the quantile based integration bounds (see details)</p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_iqr.fac">IQR.fac</code></td>
<td>
<p>Factor for the scale based integration bounds (see details)</p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_...">...</code></td>
<td>
<p> further arguments to be used in particular methods &ndash; (in package <span class="pkg">distrEx</span>: just
used for distributions with a.c. parts, where it is used to pass on arguments
to <code>distrExIntegrate</code>). </p>
</td></tr>
<tr><td><code id="AsymTotalVarDist_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For distances between absolutely continuous distributions, we use numerical
integration; to determine sensible bounds we proceed as follows:
by means of <code>min(getLow(e1,eps=TruncQuantile),getLow(e2,eps=TruncQuantile))</code>, 
<code>max(getUp(e1,eps=TruncQuantile),getUp(e2,eps=TruncQuantile))</code> we determine
quantile based bounds <code>c(low.0,up.0)</code>, and by means of
<code>s1 &lt;- max(IQR(e1),IQR(e2));</code> <code>m1&lt;- median(e1);</code> 
<code>m2 &lt;- median(e2)</code>
and <code>low.1 &lt;- min(m1,m2)-s1*IQR.fac</code>, <code>up.1 &lt;- max(m1,m2)+s1*IQR.fac</code>
we determine scale based bounds; these are combined by
<code>low &lt;- max(low.0,low.1)</code>, <code>up &lt;- max(up.0,up1)</code>.
</p>
<p>Again in the absolutely continuous case, to determine the range of the 
likelihood ratio, we evaluate this ratio on a grid constructed as follows:
<code>x.range &lt;- c(seq(low, up, length=Ngrid/3),
                     q.l(e1)(seq(0,1,length=Ngrid/3)*.999),
                     q.l(e2)(seq(0,1,length=Ngrid/3)*.999))</code>
</p>
<p>Finally, for both discrete and absolutely continuous case,
we clip this ratio downwards by <code>1e-10</code> and upwards by <code>1e10</code>
</p>
<p>In case we want to compute the total variation distance between (empirical) data
and an abs. cont. distribution, we can specify the parameter <code>asis.smooth.discretize</code>
to avoid trivial distances (distance = 1).
</p>
<p>Using <code>asis.smooth.discretize = "discretize"</code>, which is the default,
leads to a discretization of the provided abs. cont. distribution and 
the distance is computed between the provided data and the discretized
distribution.
</p>
<p>Using <code>asis.smooth.discretize = "smooth"</code> causes smoothing of the
empirical distribution of the provided data. This is, the empirical
data is convoluted with the normal distribution <code>Norm(mean = 0, sd = h.smooth)</code>
which leads to an abs. cont. distribution. Afterwards the distance 
between the smoothed empirical distribution and the provided abs. cont.
distribution is computed.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p> Asymmetric Total variation distance of <code>e1</code> and <code>e2</code> </p>


<h3>Methods</h3>


<dl>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>total variation distance of two absolutely continuous 
univariate distributions which is computed using <code>distrExIntegrate</code>.
</p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>total variation distance of absolutely continuous and discrete
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>total variation distance of two discrete univariate distributions
which is computed using <code>support</code> and <code>sum</code>.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>total variation distance of discrete and absolutely continuous 
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and a discrete 
distribution.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;numeric&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and a discrete 
distribution.
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e1 = &quot;numeric&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = &quot;AcDcLcDistribution&quot;, e2 = &quot;AcDcLcDistribution&quot;:</dt><dd>
<p>Total variation distance of mixed discrete and absolutely continuous
univariate distributions.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>to be filled; 
Agostinelli, C and Ruckdeschel, P. (2009): A simultaneous inlier and outlier model
by asymmetric total variation distance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TotalVarDist-methods">TotalVarDist-methods</a></code>, <code><a href="#topic+ContaminationSize">ContaminationSize</a></code>, 
<code><a href="#topic+KolmogorovDist">KolmogorovDist</a></code>, <code><a href="#topic+HellingerDist">HellingerDist</a></code>, 
<code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>AsymTotalVarDist(Norm(), UnivarMixingDistribution(Norm(1,2),Norm(0.5,3),
                 mixCoeff=c(0.2,0.8)), rho=0.3)
AsymTotalVarDist(Norm(), Td(10), rho=0.3)
AsymTotalVarDist(Norm(mean = 50, sd = sqrt(25)), Binom(size = 100), rho=0.3) # mutually singular
AsymTotalVarDist(Pois(10), Binom(size = 20), rho=0.3) 

x &lt;- rnorm(100)
AsymTotalVarDist(Norm(), x, rho=0.3)
AsymTotalVarDist(x, Norm(), asis.smooth.discretize = "smooth", rho=0.3)

y &lt;- (rbinom(50, size = 20, prob = 0.5)-10)/sqrt(5)
AsymTotalVarDist(y, Norm(), rho=0.3)
AsymTotalVarDist(y, Norm(), asis.smooth.discretize = "smooth", rho=0.3)

AsymTotalVarDist(rbinom(50, size = 20, prob = 0.5), Binom(size = 20, prob = 0.5), rho=0.3)
</code></pre>

<hr>
<h2 id='Condition-class'>Conditions</h2><span id='topic+Condition-class'></span><span id='topic+name+2CCondition-method'></span><span id='topic+name+3C-+2CCondition-method'></span>

<h3>Description</h3>

<p>The class of conditions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Condition", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: name of the condition</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "Condition")</code>: accessor function
for slot <code>name</code>.</p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "Condition")</code>: replacement function
for slot <code>name</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+UnivariateCondDistribution-class">UnivariateCondDistribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("Condition")</code></pre>

<hr>
<h2 id='ContaminationSize'>Generic Function for the Computation of the Convex Contamination 
(Pseudo-)Distance of Two Distributions</h2><span id='topic+ContaminationSize'></span><span id='topic+ContaminationSize-methods'></span><span id='topic+ContaminationSize+2CAbscontDistribution+2CAbscontDistribution-method'></span><span id='topic+ContaminationSize+2CDiscreteDistribution+2CDiscreteDistribution-method'></span><span id='topic+ContaminationSize+2CLatticeDistribution+2CDiscreteDistribution-method'></span><span id='topic+ContaminationSize+2CDiscreteDistribution+2CLatticeDistribution-method'></span><span id='topic+ContaminationSize+2CLatticeDistribution+2CLatticeDistribution-method'></span><span id='topic+ContaminationSize+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of convex contamination (pseudo-)distance 
of two probability distributions <code class="reqn">P</code> and <code class="reqn">Q</code>. That is, the 
minimal size <code class="reqn">\varepsilon\in [0,1]</code> is computed such that 
there exists some probability distribution <code class="reqn">R</code> with
</p>
<p style="text-align: center;"><code class="reqn">Q = (1-\varepsilon)P + \varepsilon R</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>ContaminationSize(e1, e2, ...)
## S4 method for signature 'AbscontDistribution,AbscontDistribution'
ContaminationSize(e1,e2)
## S4 method for signature 'DiscreteDistribution,DiscreteDistribution'
ContaminationSize(e1,e2)
## S4 method for signature 'AcDcLcDistribution,AcDcLcDistribution'
ContaminationSize(e1,e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ContaminationSize_+3A_e1">e1</code></td>
<td>
<p> object of class <code>"Distribution"</code> </p>
</td></tr>
<tr><td><code id="ContaminationSize_+3A_e2">e2</code></td>
<td>
<p> object of class <code>"Distribution"</code> </p>
</td></tr>
<tr><td><code id="ContaminationSize_+3A_...">...</code></td>
<td>
<p> further arguments to be used in particular methods (not in package <span class="pkg">distrEx</span>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the distance from <code>e1</code> to <code>e2</code> respectively
<code class="reqn">P</code> to <code class="reqn">Q</code>. This is not really a distance as it is not symmetric!</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>e1</code></td>
<td>
<p> object of class <code>"Distribution"</code>; ideal distribution  </p>
</td></tr>
<tr><td><code>e2</code></td>
<td>
<p> object of class <code>"Distribution"</code>; 'contaminated' distribution </p>
</td></tr>
<tr><td><code>size.of.contamination</code></td>
<td>
<p> size of contamination </p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>convex contamination (pseudo-)distance of two absolutely
continuous univariate distributions.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>convex contamination (pseudo-)distance of two discrete 
univariate distributions.
</p>
</dd>
<dt>e1 = &quot;AcDcLcDistribution&quot;, e2 = &quot;AcDcLcDistribution&quot;:</dt><dd>
<p>convex contamination (pseudo-)distance of two discrete 
univariate distributions.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.</p>


<h3>See Also</h3>

<p><code><a href="#topic+KolmogorovDist">KolmogorovDist</a></code>, <code><a href="#topic+TotalVarDist">TotalVarDist</a></code>, 
<code><a href="#topic+HellingerDist">HellingerDist</a></code>, <code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ContaminationSize(Norm(), Norm(mean=0.1))
ContaminationSize(Pois(), Pois(1.5))
</code></pre>

<hr>
<h2 id='ConvexContamination'>Generic Function for Generating Convex Contaminations</h2><span id='topic+ConvexContamination'></span><span id='topic+ConvexContamination-methods'></span><span id='topic+ConvexContamination+2CUnivariateDistribution+2CUnivariateDistribution+2Cnumeric-method'></span><span id='topic+ConvexContamination+2CAbscontDistribution+2CAbscontDistribution+2Cnumeric-method'></span><span id='topic+ConvexContamination+2CAbscontDistribution+2CUnivariateDistribution+2Cnumeric-method'></span><span id='topic+ConvexContamination+2CDiscreteDistribution+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic+ConvexContamination+2CLatticeDistribution+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic+ConvexContamination+2CDiscreteDistribution+2CLatticeDistribution+2Cnumeric-method'></span><span id='topic+ConvexContamination+2CLatticeDistribution+2CLatticeDistribution+2Cnumeric-method'></span><span id='topic+ConvexContamination+2CAcDcLcDistribution+2CAcDcLcDistribution+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function for generating convex contaminations. This is also 
known as <em>gross error model</em>. Given two distributions <code class="reqn">P</code> 
(ideal distribution), <code class="reqn">R</code> (contaminating distribution) and the
size <code class="reqn">\varepsilon\in [0,1]</code> the convex contaminated distribution
</p>
<p style="text-align: center;"><code class="reqn">Q = (1-\varepsilon)P + \varepsilon R</code>
</p>

<p>is generated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvexContamination(e1, e2, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConvexContamination_+3A_e1">e1</code></td>
<td>
<p> object of class <code>"Distribution"</code>: ideal distribution</p>
</td></tr>
<tr><td><code id="ConvexContamination_+3A_e2">e2</code></td>
<td>
<p> object of class <code>"Distribution"</code>: contaminating distribution</p>
</td></tr>
<tr><td><code id="ConvexContamination_+3A_size">size</code></td>
<td>
<p> size of contamination (amount of gross errors)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"Distribution"</code>.</p>


<h3>Methods</h3>


<dl>
<dt>e1 = &quot;UnivariateDistribution&quot;, e2 = &quot;UnivariateDistribution&quot;, size = &quot;numeric&quot;:</dt><dd> 
<p>convex combination of two univariate distributions </p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;AbscontDistribution&quot;, size = &quot;numeric&quot;:</dt><dd> 
<p>convex combination of two absolutely continuous univariate distributions </p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;, size = &quot;numeric&quot;:</dt><dd>
<p>convex combination of two discrete univariate distributions </p>
</dd>
<dt>e1 = &quot;AcDcLcDistribution&quot;, e2 = &quot;AcDcLcDistribution&quot;, size = &quot;numeric&quot;:</dt><dd>
<p>convex combination of two univariate distributions which may be coerced to
<code>"UnivarLebDecDistribution"</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ContaminationSize">ContaminationSize</a></code>, <code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Convex combination of two normal distributions
C1 &lt;- ConvexContamination(e1 = Norm(), e2 = Norm(mean = 5), size = 0.1)
plot(C1)
</code></pre>

<hr>
<h2 id='CvMDist'>Generic function for the computation of the Cramer - von Mises  distance of two distributions</h2><span id='topic+CvMDist'></span><span id='topic+CvMDist-methods'></span><span id='topic+CvMDist+2CUnivariateDistribution+2CUnivariateDistribution-method'></span><span id='topic+CvMDist+2Cnumeric+2CUnivariateDistribution-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the Cramer - von Mises  distance <code class="reqn">d_\mu</code>
of two distributions <code class="reqn">P</code> and <code class="reqn">Q</code> where the distributions are defined 
on a finite-dimensional Euclidean space <code class="reqn">(\R^m,{\cal B}^m)</code>
with <code class="reqn"> {\cal B}^m </code> the Borel-<code class="reqn">\sigma</code>-algebra on <code class="reqn">R^m</code>.
The Cramer - von Mises  distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_\mu(P,Q)^2=\int\,(P(\{y\in\R^m\,|\,y\le x\})-Q(\{y\in\R^m\,|\,y\le x\}))^2\,\mu(dx)</code>
</p>

<p>where <code class="reqn">\le</code> is coordinatewise on <code class="reqn">\R^m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CvMDist(e1, e2, ...)
## S4 method for signature 'UnivariateDistribution,UnivariateDistribution'
CvMDist(e1, e2, mu = e1, useApply = FALSE, ..., diagnostic = FALSE)
## S4 method for signature 'numeric,UnivariateDistribution'
CvMDist(e1, e2, mu = e1, ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CvMDist_+3A_e1">e1</code></td>
<td>
<p> object of class <code>"Distribution"</code> or class <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="CvMDist_+3A_e2">e2</code></td>
<td>
<p> object of class <code>"Distribution"</code> </p>
</td></tr>
<tr><td><code id="CvMDist_+3A_...">...</code></td>
<td>
<p> further arguments to be used e.g. by <code>E()</code></p>
</td></tr>
<tr><td><code id="CvMDist_+3A_useapply">useApply</code></td>
<td>
<p> logical; to be passed to <code><a href="#topic+E">E</a>()</code></p>
</td></tr>
<tr><td><code id="CvMDist_+3A_mu">mu</code></td>
<td>
<p> object of class <code>"Distribution"</code>; integration measure; defaulting to <code>e2</code> </p>
</td></tr>
<tr><td><code id="CvMDist_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p> Cramer - von Mises  distance of <code>e1</code> and <code>e2</code> </p>


<h3>Methods</h3>


<dl>
<dt>e1 = &quot;UnivariateDistribution&quot;, e2 = &quot;UnivariateDistribution&quot;:</dt><dd>
<p>Cramer - von Mises  distance of two univariate distributions.
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;UnivariateDistribution&quot;:</dt><dd>
<p>Cramer - von Mises  distance between the empirical formed from a data set (e1) and a 
univariate distribution. 
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ContaminationSize">ContaminationSize</a></code>, <code><a href="#topic+TotalVarDist">TotalVarDist</a></code>, 
<code><a href="#topic+HellingerDist">HellingerDist</a></code>, <code><a href="#topic+KolmogorovDist">KolmogorovDist</a></code>,
<code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>CvMDist(Norm(), UnivarMixingDistribution(Norm(1,2),Norm(0.5,3),
                 mixCoeff=c(0.2,0.8)))
CvMDist(Norm(), UnivarMixingDistribution(Norm(1,2),Norm(0.5,3),
                 mixCoeff=c(0.2,0.8)),mu=Norm())
CvMDist(Norm(), Td(10))
CvMDist(Norm(mean = 50, sd = sqrt(25)), Binom(size = 100))
CvMDist(Pois(10), Binom(size = 20)) 
CvMDist(rnorm(100),Norm())
CvMDist((rbinom(50, size = 20, prob = 0.5)-10)/sqrt(5), Norm())
CvMDist(rbinom(50, size = 20, prob = 0.5), Binom(size = 20, prob = 0.5))
CvMDist(rbinom(50, size = 20, prob = 0.5), Binom(size = 20, prob = 0.5), mu = Pois())
</code></pre>

<hr>
<h2 id='dim-methods'> Methods for Function dim in Package &lsquo;distrEx&rsquo; </h2><span id='topic+dim-methods'></span><span id='topic+dim'></span><span id='topic+dim+2CDiscreteMVDistribution-method'></span>

<h3>Description</h3>

<p>dim-methods</p>


<h3>Methods</h3>


<dl>
<dt>dim</dt><dd><p><code>signature(object = "DiscreteMVDistribution")</code>: returns the dimension of the distribution </p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+dim-methods">dim-methods</a></code>,<br />
<code><a href="base.html#topic+dim">dim</a></code></p>

<hr>
<h2 id='DiscreteCondDistribution-class'>Discrete conditional distribution</h2><span id='topic+DiscreteCondDistribution-class'></span>

<h3>Description</h3>

<p>The class of discrete conditional univariate distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("DiscreteCondDistribution", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>support</code></dt><dd><p>Object of class <code>"function"</code>: conditional support.</p>
</dd>
<dt><code>cond</code></dt><dd><p>Object of class <code>"Condition"</code>: condition </p>
</dd>
<dt><code>img</code></dt><dd><p>Object of class <code>"rSpace"</code>: the image space. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"OptionalParameter"</code>: an 
optional parameter.</p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: 
generates random numbers. </p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional conditional density function. </p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional conditional cumulative distribution function. </p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>:
optional conditional quantile function. </p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UnivariateCondDistribution"</code>, directly.<br />
Class <code>"Distribution"</code>, by class <code>"UnivariateCondDistribution"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+UnivariateCondDistribution-class">UnivariateCondDistribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("DiscreteCondDistribution")</code></pre>

<hr>
<h2 id='DiscreteMVDistribution'>Generating function for multivariate discrete distribution</h2><span id='topic+DiscreteMVDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"DiscreteMVDistribution"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiscreteMVDistribution(supp, prob, Symmetry = NoSymmetry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscreteMVDistribution_+3A_supp">supp</code></td>
<td>
<p> numeric matrix whose rows form the support 
of the discrete multivariate distribution. </p>
</td></tr>
<tr><td><code id="DiscreteMVDistribution_+3A_prob">prob</code></td>
<td>
<p> vector of probability weights for the 
elements of <code>supp</code>.</p>
</td></tr>
<tr><td><code id="DiscreteMVDistribution_+3A_symmetry">Symmetry</code></td>
<td>
<p>you may help <span class="rlang"><b>R</b></span> in calculations if you tell it whether
the distribution is non-symmetric (default) or symmetric with respect
to a center.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
    DiscreteMVDistribution(supp, prob)
    DiscreteMVDistribution(supp)
  </pre>
<p>Identical rows are collapsed to unique support values. 
If <code>prob</code> is missing, all elements in <code>supp</code>
are equally weighted. 
</p>


<h3>Value</h3>

<p>Object of class <code>"DiscreteMVDistribution"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DiscreteMVDistribution-class">DiscreteMVDistribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Dirac-measure at (0,0,0)
D1 &lt;- DiscreteMVDistribution(supp = c(0,0,0))
support(D1)

# simple discrete distribution
D2 &lt;- DiscreteMVDistribution(supp = matrix(c(0,1,0,2,2,1,1,0), ncol=2), 
                prob = c(0.3, 0.2, 0.2, 0.3))
support(D2)
r(D2)(10)
</code></pre>

<hr>
<h2 id='DiscreteMVDistribution-class'>Discrete Multivariate Distributions</h2><span id='topic+DiscreteMVDistribution-class'></span><span id='topic+support+2CDiscreteMVDistribution-method'></span>

<h3>Description</h3>

<p>The class of discrete multivariate distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("DiscreteMVDistribution", ...)</code>.
More frequently they are created via the generating function 
<code>DiscreteMVDistribution</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p> Object of class <code>"rSpace"</code>. 
Image space of the distribution. Usually an object of 
class <code>"EuclideanSpace"</code>.</p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"OptionalParameter"</code>.
Optional parameter of the multivariate distribution.</p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: 
generates (pseudo-)random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional density function</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional cumulative distribution function </p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional quantile function </p>
</dd>
<dt><code>support</code></dt><dd><p> numeric matrix whose rows form the
support of the distribution</p>
</dd>
<dt><code>.finSupport</code></dt><dd><p>logical: (later on to be) used internally to check
whether the true support is finite; the element in the 1st row and ith column
indicates whether the ith marginal distribution has a finite left endpoint,
and the element in the  2nd row and ith column if it is has a finite right
endpoint); not yet further used.</p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
log version of density, cdf, and quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
lower tail version of cdf and quantile function</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"MultivariateDistribution"</code>, directly.<br />
Class <code>"Distribution"</code>, by class <code>"MultivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>support</dt><dd><p><code>signature(object = "DiscreteMVDistribution")</code>:
accessor function for slot <code>support</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code>, <code><a href="#topic+MultivariateDistribution-class">MultivariateDistribution-class</a></code>,
<code><a href="#topic+DiscreteMVDistribution">DiscreteMVDistribution</a></code>, <code><a href="#topic+E-methods">E-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(D1 &lt;- new("MultivariateDistribution")) # Dirac measure in (0,0)
r(D1)(5)

(D2 &lt;- DiscreteMVDistribution(supp = matrix(c(1:5, rep(3, 5)), ncol=2, byrow=TRUE)))
support(D2)
r(D2)(10)
d(D2)(support(D2))
p(D2)(lower = c(1,1), upper = c(3,3))
q(D2)
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
param(D2)
img(D2)

e1 &lt;- E(D2) # expectation
</code></pre>

<hr>
<h2 id='distrExIntegrate'>Integration of One-Dimensional Functions</h2><span id='topic+distrExIntegrate'></span><span id='topic+print.DiagnosticClass'></span><span id='topic+showDiagnostic'></span><span id='topic+getDiagnostic'></span>

<h3>Description</h3>

<p>Numerical integration via <code>integrate</code>. In case <code>integrate</code>
fails a Gauss-Legendre quadrature is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distrExIntegrate(f, lower, upper, subdivisions = 100, 
                 rel.tol = .Machine$double.eps^0.25, 
                 abs.tol = rel.tol, stop.on.error = TRUE, 
                 distr, order, ..., diagnostic = FALSE)
showDiagnostic(x, what, withNonShows = FALSE, ...)
getDiagnostic(x, what, reorganized=TRUE)
## S3 method for class 'DiagnosticClass'
print(x, what, withNonShows = FALSE, xname, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distrExIntegrate_+3A_f">f</code></td>
<td>
<p> an R function taking a numeric first argument and returning a
numeric vector of the same length.  Returning a non-finite
element will generate an error. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_lower">lower</code></td>
<td>
<p> lower limit of integration. Can be <code>-Inf</code>. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_upper">upper</code></td>
<td>
<p> upper limit of integration. Can be <code>Inf</code>. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_subdivisions">subdivisions</code></td>
<td>
<p> the maximum number of subintervals. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_rel.tol">rel.tol</code></td>
<td>
<p> relative accuracy requested. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_abs.tol">abs.tol</code></td>
<td>
<p> absolute accuracy requested. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_stop.on.error">stop.on.error</code></td>
<td>
<p> logical. If <code>TRUE</code> (the default) an error 
stops the function. If false some errors will give a result with a 
warning in the <code>message</code> component. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_distr">distr</code></td>
<td>
<p> object of class <code>UnivariateDistribution</code>. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_order">order</code></td>
<td>
<p> order of Gauss-Legendre quadrature. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_...">...</code></td>
<td>
<p> In case of integrators: additional arguments to be passed to <code>f</code>. Remember
to use argument names not matching those of <code>integrate</code>
and <code>GLIntegrate</code>! In case of <code>showDiagnostic</code>, <code>print.DiagnosticClass</code>:
additional arguments to be passed on to print methods called for particular
items in the diagnostic list. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_x">x</code></td>
<td>
<p> the item for which the diagnostic is to be shown. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_what">what</code></td>
<td>
<p> a character vector with all the diagnostic items to be
selected/shown. If empty or missing all items are selected/shown. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_withnonshows">withNonShows</code></td>
<td>
<p> internally we distinguish items which are easily
printed (first kind) (numeric, logical, character)
and more difficult ones (second kind), e.g., calls, functions, lists. The
distinction is made according to the list item name. If
<code>withNonShows==TRUE</code> one also attempts to show the selected items
of the second kind, otherwise they are not shown (but returned). </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_xname">xname</code></td>
<td>
<p> an optional name for the diagnostic object to be shown. </p>
</td></tr>
<tr><td><code id="distrExIntegrate_+3A_reorganized">reorganized</code></td>
<td>
<p>should the diagnostic information be reorganized
(using internal function <code><a href="#topic+.reorganizeDiagnosticList">.reorganizeDiagnosticList</a></code>? </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>distrExIntegrate</code> calls <code>integrate</code>. In case <code>integrate</code>
returns an error a Gauss-Legendre integration is performed using
<code>GLIntegrate</code>. If <code>lower</code> or (and) <code>upper</code> are infinite
the <code>GLIntegrateTruncQuantile</code>, respectively the 
<code>1-GLIntegrateTruncQuantile</code> quantile of <code>distr</code> is used 
instead.
</p>
<p><code>distrExIntegrate</code> is called from many places in the distr and robast
families of packages. At every such instance, diagnostic information can
be collected (setting a corresponding argument <code>diagnostic</code> to <code>TRUE</code>
in the calling function. This diagnostic information is originally stored in
a tree like list structure of S3 class <code>DiagnosticClass</code> which is then
attached as attribute <code>diagnostic</code> to the respective object. It can be
inspected and accessed through <code>showDiagnostic</code> and  <code>getDiagnostic</code>.
More specifically, for any object with attribute <code>diagnostic</code>,
<code>showDiagnostic</code> shows the diagnostic collected during integration, and
<code>getDiagnostic</code> returns the diagnostic collected during integration.
To this end, <code>print.DiagnosticClass</code> is an S3 method for <code>print</code>
for objects of S3 class <code>DiagnosticClass</code>.
</p>


<h3>Value</h3>

<p>The value of <code>distrExIntegrate</code> is a numeric approximation of the integral.
If argument <code>diagnostic==TRUE</code> in <code>distrExIntegrate</code>, the return
value has an attribute <code>diagnostic</code> of S3 class <code>DiagnosticClass</code>
containing diagnostic information on the integration.
</p>
<p><code>showDiagnostic</code>, <code>getDiagnostic</code>, <code>print.DiagnosticClass</code> all
return (invisibly) a list with the selected items, reorganized by internal
function <code>.reorganizeDiagnosticList</code>, respectively, in case
of argument <code>reorganized==FALSE</code>, <code>getDiagnostic</code> returns (invisibly)
the diagnostic information as is.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Based on QUADPACK routines <code>dqags</code> and <code>dqagi</code> by
R. Piessens and E. deDoncker-Kapenga, available from Netlib.
</p>
<p>R. Piessens, E. deDoncker-Kapenga, C. Uberhuber, D. Kahaner (1983)
<em>Quadpack: a Subroutine Package for Automatic Integration</em>.
Springer Verlag.
</p>
<p>W.H. Press, S.A. Teukolsky, W.T. Vetterling, B.P. Flannery (1992)
<em>Numerical Recipies in C</em>. The Art of Scientific Computing.
Second Edition. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+integrate">integrate</a></code>, <code><a href="#topic+GLIntegrate">GLIntegrate</a></code>, 
<code><a href="#topic+distrExOptions">distrExOptions</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fkt &lt;- function(x){x*dchisq(x+1, df = 1)}
integrate(fkt, lower = -1, upper = 3)
GLIntegrate(fkt, lower = -1, upper = 3)
try(integrate(fkt, lower = -1, upper = 5))
distrExIntegrate(fkt, lower = -1, upper = 5)
</code></pre>

<hr>
<h2 id='distrExMASK'>Masking of/by other functions in package &quot;distrEx&quot;</h2><span id='topic+distrExMASK'></span><span id='topic+MASKING'></span>

<h3>Description</h3>

<p>Provides information on the (intended) masking of
and (non-intended) masking by other other functions in package <span class="pkg">distrEx</span></p>


<h3>Usage</h3>

<pre><code class='language-R'>distrExMASK(library = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distrExMASK_+3A_library">library</code></td>
<td>
<p>a character vector with path names of R libraries, or <code>NULL</code>.
The default value of <code>NULL</code> corresponds to all libraries
currently known.  If the default is used, the loaded packages
are searched before the libraries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>distrExMASK()
</code></pre>

<hr>
<h2 id='distrExMOVED'>Moved functionality from package &quot;distrEx&quot;</h2><span id='topic+distrExMOVED'></span><span id='topic+MOVEDING'></span>

<h3>Description</h3>

<p>Provides information on moved  of
functionality from package <span class="pkg">distrEx</span>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>distrExMOVED(library = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distrExMOVED_+3A_library">library</code></td>
<td>
<p>a character vector with path names of R libraries, or <code>NULL</code>.
The default value of <code>NULL</code> corresponds to all libraries
currently known.  If the default is used, the loaded packages
are searched before the libraries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>distrExMOVED()
</code></pre>

<hr>
<h2 id='distrExOptions'>Function to change the global variables of the package &lsquo;distrEx&rsquo; </h2><span id='topic+distrExOptions'></span><span id='topic+distrExoptions'></span><span id='topic+getdistrExOption'></span><span id='topic+MCIterations'></span><span id='topic+GLIntegrateTruncQuantile'></span><span id='topic+GLIntegrateOrder'></span><span id='topic+ElowerTruncQuantile'></span><span id='topic+EupperTruncQuantile'></span><span id='topic+ErelativeTolerance'></span><span id='topic+m1dfLowerTruncQuantile'></span><span id='topic+m1dfRelativeTolerance'></span><span id='topic+m2dfLowerTruncQuantile'></span><span id='topic+m2dfRelativeTolerance'></span><span id='topic+nDiscretize'></span><span id='topic+hSmooth'></span><span id='topic+IQR.fac'></span><span id='topic+propagate.names.functionals'></span>

<h3>Description</h3>

<p>With <code>distrExOptions</code> you can inspect and change 
the global variables of the package <span class="pkg">distrEx</span>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>distrExOptions(...)
distrExoptions(...)
getdistrExOption(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distrExOptions_+3A_...">...</code></td>
<td>
<p> any options can be defined, using name = value or by passing a list of such tagged values. </p>
</td></tr>
<tr><td><code id="distrExOptions_+3A_x">x</code></td>
<td>
<p> a character string holding an option name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>distrExOptions()</code> returns a list of the global variables.<br />
<code>distrExOptions(x)</code> returns the global variable <var>x</var>.<br />
<code>getdistrExOption(x)</code> returns the global variable <var>x</var>.<br />
<code>distrExOptions(x=y)</code> sets the value of the global variable <var>x</var> to <var>y</var>.
</p>


<h3>distrExoptions</h3>

<p>For compatibility with spelling in package <span class="pkg">distr</span>, <code>distrExoptions</code> is 
just a synonym to <code>distrExOptions</code>.
</p>


<h3>Global Options</h3>


<dl>
<dt>MCIterations:</dt><dd><p> number of Monte-Carlo iterations used for crude 
Monte-Carlo integration; defaults to <code>1e5</code>. </p>
</dd>
<dt>GLIntegrateTruncQuantile:</dt><dd><p> If <code>integrate</code> fails and there are 
infinite integration limits, the function <code>GLIntegrate</code> is 
called inside of <code>distrExIntegrate</code> with the corresponding quantiles 
<code>GLIntegrateTruncQuantile</code> respectively,  
1 - <code>GLIntegrateTruncQuantile</code> as finite integration limits; defaults
to <code>10*.Machine$double.eps</code>. </p>
</dd>
<dt>GLIntegrateOrder:</dt><dd><p> The order used for the Gauss-Legendre integration
inside of <code>distrExIntegrate</code>; defaults to 500. </p>
</dd>
<dt>ElowerTruncQuantile:</dt><dd><p> The lower limit of integration used inside of 
<code>E</code> which corresponds to the <code>ElowerTruncQuantile</code>-quantile; defaults to
<code>1e-7</code>. </p>
</dd>
<dt>EupperTruncQuantile:</dt><dd><p> The upper limit of integration used inside of 
<code>E</code> which corresponds to the (1-<code>ElowerTruncQuantile</code>)-quantile; defaults to
<code>1e-7</code>. </p>
</dd>
<dt>ErelativeTolerance:</dt><dd><p> The relative tolerance used inside of <code>E</code>
when calling <code>distrExIntegrate</code>; defaults to <code>.Machine$double.eps^0.25</code>. </p>
</dd>
<dt>m1dfLowerTruncQuantile:</dt><dd><p> The lower limit of integration used inside 
of <code>m1df</code> which corresponds to the <code>m1dfLowerTruncQuantile</code>-quantile; defaults to 0. </p>
</dd>
<dt>m1dfRelativeTolerance:</dt><dd><p> The relative tolerance used inside of <code>m1df</code>
when calling <code>distrExIntegrate</code>; defaults to <code>.Machine$double.eps^0.25</code>. </p>
</dd>
<dt>m2dfLowerTruncQuantile:</dt><dd><p> The lower limit of integration used inside 
of <code>m2df</code> which corresponds to the <code>m2dfLowerTruncQuantile</code>-quantile;
defaults to 0. </p>
</dd>
<dt>m2dfRelativeTolerance:</dt><dd><p> The relative tolerance used inside of <code>m2df</code>
when calling <code>distrExIntegrate</code>; defaults to <code>.Machine$double.eps^0.25</code>. </p>
</dd>
<dt>nDiscretize:</dt><dd><p> number of support values used for the discretization
of objects of class <code>"AbscontDistribution"</code>; defaults to 100. </p>
</dd>
<dt>hSmooth:</dt><dd><p> smoothing parameter to smooth objects of class 
<code>"DiscreteDistribution"</code>. This is done via convolution with the
normal distribution <code>Norm(mean = 0, sd = hSmooth)</code>; defaults to 0.05.</p>
</dd>
<dt>IQR.fac:</dt><dd><p>for determining sensible integration ranges, we use
both quantile and scale based methods; for the scale based
method we use the median of the distribution <code class="reqn">\pm</code>
<code>IQR.fac</code><code class="reqn">\times</code> the IQR; defaults to 15.</p>
</dd>
<dt>propagate.names.functionals</dt><dd><p>should names obtained from parameter
coordinates be propagated to return values of specific S4 methods
for functionals; defaults to <code>TRUE</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>, <code><a href="base.html#topic+options">getOption</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>distrExOptions()
distrExOptions("ElowerTruncQuantile")
distrExOptions("ElowerTruncQuantile" = 1e-6)
# or
distrExOptions(ElowerTruncQuantile = 1e-6)
getdistrExOption("ElowerTruncQuantile")
</code></pre>

<hr>
<h2 id='E'>Generic Function for the Computation of (Conditional) Expectations</h2><span id='topic+E'></span><span id='topic+E-methods'></span><span id='topic+E+2CUnivariateDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CAbscontDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CDiscreteDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CLatticeDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CAffLinDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CAffLinAbscontDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CAffLinDiscreteDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CAffLinLatticeDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CMultivariateDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CDiscreteMVDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CUnivarLebDecDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CAffLinUnivarLebDecDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CUnivarMixingDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CUnivariateDistribution+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CAbscontDistribution+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CDiscreteDistribution+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CLatticeDistribution+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CMultivariateDistribution+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CDiscreteMVDistribution+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CUnivarLebDecDistribution+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CUnivarMixingDistribution+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CAcDcLcDistribution+2CANY+2CANY-method'></span><span id='topic+E+2CCompoundDistribution+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CUnivariateCondDistribution+2Cmissing+2Cnumeric-method'></span><span id='topic+E+2CAbscontCondDistribution+2Cmissing+2Cnumeric-method'></span><span id='topic+E+2CDiscreteCondDistribution+2Cmissing+2Cnumeric-method'></span><span id='topic+E+2CUnivarLebDecDistribution+2Cmissing+2CANY-method'></span><span id='topic+E+2CUnivarMixingDistribution+2Cmissing+2CANY-method'></span><span id='topic+E+2CUnivarLebDecDistribution+2Cfunction+2CANY-method'></span><span id='topic+E+2CUnivariateCondDistribution+2Cfunction+2Cnumeric-method'></span><span id='topic+E+2CUnivarMixingDistribution+2Cfunction+2CANY-method'></span><span id='topic+E+2CAbscontCondDistribution+2Cfunction+2Cnumeric-method'></span><span id='topic+E+2CDiscreteCondDistribution+2Cfunction+2Cnumeric-method'></span><span id='topic+E+2CArcsine+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CBeta+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CBinom+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CCauchy+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CChisq+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CDirac+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CDExp+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CExp+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CFd+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CGammad+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CGeom+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CHyper+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CLogis+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CLnorm+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CNbinom+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CNorm+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CPois+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CTd+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CUnif+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CWeibull+2Cmissing+2Cmissing-method'></span><span id='topic+E+2CGammad+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CWeibull+2Cfunction+2Cmissing-method'></span><span id='topic+E+2CCauchy+2Cfunction+2Cmissing-method'></span><span id='topic+.qtlIntegrate'></span>

<h3>Description</h3>

<p>Generic function for the computation of (conditional) expectations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E(object, fun, cond, ...)

## S4 method for signature 'UnivariateDistribution,missing,missing'
E(object, 
             low = NULL, upp = NULL, Nsim = getdistrExOption("MCIterations"), ...)

## S4 method for signature 'UnivariateDistribution,function,missing'
E(object, fun, 
        useApply = TRUE, low = NULL, upp = NULL,
        Nsim = getdistrExOption("MCIterations"), ...)

## S4 method for signature 'AbscontDistribution,missing,missing'
E(object, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'AbscontDistribution,function,missing'
E(object, fun, useApply = TRUE,
             low = NULL, upp = NULL, 
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'UnivarMixingDistribution,missing,missing'
E(object, low = NULL, 
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'UnivarMixingDistribution,function,missing'
E(object, fun,
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'UnivarMixingDistribution,missing,ANY'
E(object, cond, low = NULL, 
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'UnivarMixingDistribution,function,ANY'
E(object, fun, cond,
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'DiscreteDistribution,function,missing'
E(object, fun, useApply = TRUE, 
             low = NULL, upp = NULL, ...)

## S4 method for signature 'AffLinDistribution,missing,missing'
E(object, low = NULL, upp = NULL,
             ..., diagnostic = FALSE)

## S4 method for signature 'AffLinUnivarLebDecDistribution,missing,missing'
E(object, low = NULL,
             upp = NULL, ..., diagnostic = FALSE)

## S4 method for signature 'MultivariateDistribution,missing,missing'
E(object, 
             Nsim = getdistrExOption("MCIterations"), ...)
## S4 method for signature 'MultivariateDistribution,function,missing'
E(object, fun,
             useApply = TRUE, Nsim = getdistrExOption("MCIterations"), ...)

## S4 method for signature 'DiscreteMVDistribution,missing,missing'
E(object, low = NULL,
             upp = NULL, ...)

## S4 method for signature 'DiscreteMVDistribution,function,missing'
E(object, fun, 
             useApply = TRUE, ...)

## S4 method for signature 'AbscontCondDistribution,missing,numeric'
E(object, cond,
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'DiscreteCondDistribution,missing,numeric'
E(object, cond,
             useApply = TRUE, low = NULL, upp = NULL, ...)

## S4 method for signature 'UnivariateCondDistribution,function,numeric'
E(object, fun, cond, 
              withCond = FALSE, useApply = TRUE, low = NULL, upp = NULL,
              Nsim = getdistrExOption("MCIterations"), ...)

## S4 method for signature 'AbscontCondDistribution,function,numeric'
E(object, fun, cond, 
               withCond = FALSE, useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac")
             , ..., diagnostic = FALSE)

## S4 method for signature 'DiscreteCondDistribution,function,numeric'
E(object, fun, cond, 
             withCond = FALSE, useApply = TRUE, low = NULL, upp = NULL,...)

## S4 method for signature 'UnivarLebDecDistribution,missing,missing'
E(object, low = NULL,
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE )
## S4 method for signature 'UnivarLebDecDistribution,function,missing'
E(object, fun, 
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE )
## S4 method for signature 'UnivarLebDecDistribution,missing,ANY'
E(object, cond, low = NULL,
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE )
## S4 method for signature 'UnivarLebDecDistribution,function,ANY'
E(object, fun, cond, 
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE )

## S4 method for signature 'AcDcLcDistribution,ANY,ANY'
E(object, fun, cond, low = NULL,
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)
## S4 method for signature 'CompoundDistribution,missing,missing'
E(object, low = NULL,
             upp = NULL, ..., diagnostic = FALSE)

## S4 method for signature 'Arcsine,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'Beta,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Binom,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Cauchy,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'Cauchy,function,missing'
E(object, fun, low = NULL, upp = NULL,
             rel.tol = getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")),
             ..., diagnostic = FALSE)
## S4 method for signature 'Chisq,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Dirac,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'DExp,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'Exp,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Fd,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Gammad,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Gammad,function,missing'
E(object, fun, low = NULL, upp = NULL,
             rel.tol = getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ..., diagnostic = FALSE)
## S4 method for signature 'Geom,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Hyper,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Logis,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Lnorm,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Nbinom,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Norm,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Pois,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Unif,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Td,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Weibull,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Weibull,function,missing'
E(object, fun, low = NULL, upp = NULL,
             rel.tol = getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ..., diagnostic = FALSE)
.qtlIntegrate(object, fun, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ...,
             .withLeftTail = FALSE, .withRightTail = FALSE, diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="E_+3A_object">object</code></td>
<td>
<p> object of class <code>"Distribution"</code></p>
</td></tr>
<tr><td><code id="E_+3A_fun">fun</code></td>
<td>
<p> if missing the (conditional) expectation is computed
else the (conditional) expection of <code>fun</code> is computed. </p>
</td></tr>
<tr><td><code id="E_+3A_cond">cond</code></td>
<td>
<p> if not missing the conditional expectation 
given <code>cond</code> is computed. </p>
</td></tr>
<tr><td><code id="E_+3A_nsim">Nsim</code></td>
<td>
<p> number of MC simulations used to determine the expectation. </p>
</td></tr>
<tr><td><code id="E_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code>.</p>
</td></tr> 
<tr><td><code id="E_+3A_low">low</code></td>
<td>
<p>lower bound of integration range.</p>
</td></tr>
<tr><td><code id="E_+3A_upp">upp</code></td>
<td>
<p>upper bound of integration range.</p>
</td></tr>
<tr><td><code id="E_+3A_lowertruncquantile">lowerTruncQuantile</code></td>
<td>
<p>lower quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="E_+3A_uppertruncquantile">upperTruncQuantile</code></td>
<td>
<p>upper quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="E_+3A_iqr.fac">IQR.fac</code></td>
<td>
<p>factor for scale based integration range (i.e.; 
median of the distribution <code class="reqn">\pm</code><code>IQR.fac</code><code class="reqn">\times</code>IQR).</p>
</td></tr>
<tr><td><code id="E_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>fun</code> </p>
</td></tr>
<tr><td><code id="E_+3A_useapply">useApply</code></td>
<td>
<p> logical: should <code>sapply</code>, respectively <code>apply</code> 
be used to evaluate <code>fun</code>. </p>
</td></tr>
<tr><td><code id="E_+3A_withcond">withCond</code></td>
<td>
<p> logical: is <code>cond</code> in the argument list of <code>fun</code>. </p>
</td></tr>
<tr><td><code id="E_+3A_.withlefttail">.withLeftTail</code></td>
<td>
<p> logical: should left tail (falling into quantile range [0,0.02])
be computed separately to enhance accuracy? </p>
</td></tr>
<tr><td><code id="E_+3A_.withrighttail">.withRightTail</code></td>
<td>
<p> logical: should right tail (falling into quantile range [0.98,1])
be computed separately to enhance accuracy? </p>
</td></tr>
<tr><td><code id="E_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td></tr>
<tr><td><code id="E_+3A_propagate.names">propagate.names</code></td>
<td>
<p> logical: should names obtained from parameter
coordinates be propagated to return values of specific S4 methods
for functionals; defaults to the value of the respective
<code>distrExoption</code> <code>propagate.names.functionals</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The precision of the computations can be controlled via 
certain global options; cf. <code><a href="#topic+distrExOptions">distrExOptions</a></code>. 
Also note that arguments <code>low</code> and <code>upp</code> should be given as
named arguments in order to prevent them to be matched by arguments
<code>fun</code> or <code>cond</code>. Also the result, when arguments 
<code>low</code> or <code>upp</code> is given, is the <em>unconditional value</em> of the
expectation; no conditioning with respect to <code>low &lt;= object &lt;= upp</code>
is done.
</p>
<p>For the Cauchy, the Gamma and Weibull distribution for integration with
missing argument <code>cond</code> but given argument <code>fun</code>, we use
integration on [0,1]  (i.e, via the respective probability transformation).
This done via helper
function <code>.qtlIntegrate</code>, where both arguments <code>.withLeftTail</code>
and <code>.withRightTail</code> are <code>TRUE</code> for the Cauchy and Gamma distributions,
and only <code>.withRightTail</code> ist <code>TRUE</code> for the Weibull distribution.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p>The (conditional) expectation is computed.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;UnivariateDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>expectation of univariate distributions using crude Monte-Carlo integration. </p>
</dd>
<dt>object = &quot;AbscontDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>expectation of absolutely continuous univariate distributions
using <code>distrExIntegrate</code>. </p>
</dd>
<dt>object = &quot;DiscreteDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>  
<p>expectation of discrete univariate distributions using <code>support</code>
and <code>sum</code>.</p>
</dd>
<dt>object = &quot;MultivariateDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation of multivariate distributions using crude Monte-Carlo integration. </p>
</dd>
<dt>object = &quot;DiscreteMVDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation of discrete multivariate distributions. The computation is based
on <code>support</code> and <code>sum</code>.</p>
</dd>
<dt>object = &quot;UnivariateDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>expectation of univariate Lebesgue decomposed distributions
by separate calculations for discrete and absolutely continuous part. </p>
</dd>
<dt>object = &quot;AffLinDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation of an affine linear transformation <code class="reqn">aX+b</code> as
<code class="reqn">a E[X]+b</code> for <code>X</code> either <code>"DiscreteDistribution"</code>
or <code>"AbscontDistribution"</code>.
</p>
</dd>
<dt>object = &quot;AffLinUnivarLebDecDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation of an affine linear transformation <code class="reqn">aX+b</code> as
<code class="reqn">a E[X]+b</code> for <code>X</code> either <code>"UnivarLebDecDistribution"</code>.
</p>
</dd>
<dt>object = &quot;UnivariateDistribution&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>expectation of <code>fun</code> under univariate distributions using 
crude Monte-Carlo integration. </p>
</dd>
<dt>object = &quot;UnivariateDistribution&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>expectation of <code>fun</code> under univariate Lebesgue decomposed distributions
by separate calculations for discrete and absolutely continuous part. </p>
</dd>
<dt>object = &quot;AbscontDistribution&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>expectation of <code>fun</code> under absolutely continuous 
univariate distributions using <code>distrExIntegrate</code>. </p>
</dd>
<dt>object = &quot;DiscreteDistribution&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd>  
<p>expectation of <code>fun</code> under discrete univariate 
distributions using <code>support</code> and <code>sum</code>. </p>
</dd>
<dt>object = &quot;MultivariateDistribution&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation of multivariate distributions using crude Monte-Carlo integration. </p>
</dd>
<dt>object = &quot;DiscreteMVDistribution&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation of <code>fun</code> under discrete multivariate 
distributions. The computation is based on <code>support</code> and <code>sum</code>. </p>
</dd>  
<dt>object = &quot;UnivariateCondDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;numeric&quot;:</dt><dd>
<p>conditional expectation for univariate conditional distributions given <code>cond</code>. 
The integral is computed using crude Monte-Carlo integration. </p>
</dd>
<dt>object = &quot;AbscontCondDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;numeric&quot;:</dt><dd>
<p>conditional expectation for absolutely continuous, univariate 
conditional distributions given <code>cond</code>. The computation
is based on <code>distrExIntegrate</code>. </p>
</dd>
<dt>object = &quot;DiscreteCondDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;numeric&quot;:</dt><dd> 
<p>conditional expectation for discrete, univariate conditional 
distributions given <code>cond</code>. The computation is based 
on <code>support</code> and <code>sum</code>. </p>
</dd>
<dt>object = &quot;UnivariateCondDistribution&quot;, fun = &quot;function&quot;, cond = &quot;numeric&quot;:</dt><dd>
<p>conditional expectation of <code>fun</code> under univariate conditional distributions 
given <code>cond</code>. The integral is computed using crude Monte-Carlo integration. </p>
</dd>
<dt>object = &quot;AbscontCondDistribution&quot;, fun = &quot;function&quot;, cond = &quot;numeric&quot;:</dt><dd>
<p>conditional expectation of <code>fun</code> under absolutely continuous, 
univariate conditional distributions given <code>cond</code>. The
computation is based on <code>distrExIntegrate</code>. </p>
</dd>
<dt>object = &quot;DiscreteCondDistribution&quot;, fun = &quot;function&quot;, cond = &quot;numeric&quot;:</dt><dd> 
<p>conditional expectation of <code>fun</code> under discrete, univariate 
conditional distributions given <code>cond</code>. The computation is
based on <code>support</code> and <code>sum</code>. </p>
</dd>
<dt>object = &quot;UnivarLebDecDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation by separate evaluation of expectation of discrete and
abs. continuous part and subsequent weighting.
</p>
</dd>
<dt>object = &quot;UnivarLebDecDistribution&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation by separate evaluation of expectation of discrete and
abs. continuous part and subsequent weighting.
</p>
</dd>
<dt>object = &quot;UnivarLebDecDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;ANY&quot;:</dt><dd>
<p>expectation by separate evaluation of expectation of discrete and
abs. continuous part and subsequent weighting.
</p>
</dd>
<dt>object = &quot;UnivarLebDecDistribution&quot;, fun = &quot;function&quot;, cond = &quot;ANY&quot;:</dt><dd>
<p>expectation by separate evaluation of expectation of discrete and
abs. continuous part and subsequent weighting.
</p>
</dd>
<dt>object = &quot;UnivarMixingDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation is computed component-wise with subsequent weighting acc.
to <code>mixCoeff</code>.</p>
</dd>
<dt>object = &quot;UnivarMixingDistribution&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>expectation is computed component-wise with subsequent weighting acc.
to <code>mixCoeff</code>.</p>
</dd>
<dt>object = &quot;UnivarMixingDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;ANY&quot;:</dt><dd>
<p>expectation is computed component-wise with subsequent weighting acc.
to <code>mixCoeff</code>.</p>
</dd>
<dt>object = &quot;UnivarMixingDistribution&quot;, fun = &quot;function&quot;, cond = &quot;ANY&quot;:</dt><dd>
<p>expectation is computed component-wise with subsequent weighting acc.
to <code>mixCoeff</code>.</p>
</dd>
<dt>object = &quot;AcDcLcDistribution&quot;, fun = &quot;ANY&quot;, cond = &quot;ANY&quot;:</dt><dd>
<p>expectation by first coercing to class <code>"UnivarLebDecDistribution"</code>
and using the corresponding method.
</p>
</dd>
<dt>object = &quot;CompoundDistribution&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>if we are in i.i.d. situation (i.e., slot <code>SummandsDistr</code> is of
class <code>UnivariateDistribution</code>) the formula 
<code class="reqn">E[N]E[S]</code> for <code class="reqn">N</code> the frequency distribution and
<code class="reqn">S</code> the summand distribution; else we coerce to 
<code>"UnivarLebDecDistribution"</code>.
</p>
</dd>
<dt>object = &quot;Arcsine&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Beta&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>for noncentrality 0 exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Binom&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Cauchy&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Chisq&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Dirac&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;DExp&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Exp&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Fd&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Gammad&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Gammad&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>use integration over the quantile range for numerical integration
via helper function <code>.qtlIntegrate</code>.</p>
</dd>
<dt>object = &quot;Geom&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Hyper&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Logis&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Lnorm&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Nbinom&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Norm&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Pois&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Unif&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Td&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Weibull&quot;, fun = &quot;missing&quot;, cond = &quot;missing&quot;:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = &quot;Weibull&quot;, fun = &quot;function&quot;, cond = &quot;missing&quot;:</dt><dd>
<p>use integration over the quantile range for numerical integration
via helper function <code>.qtlIntegrate</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> and Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+distrExIntegrate">distrExIntegrate</a></code>, <code><a href="#topic+m1df">m1df</a></code>, <code><a href="#topic+m2df">m2df</a></code>,
<code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># mean of Exp(1) distribution
E &lt;- Exp() 

E(E) ## uses explicit terms
E(as(E,"AbscontDistribution")) ## uses numerical integration
E(as(E,"UnivariateDistribution")) ## uses simulations
E(E, fun = function(x){2*x^2}) ## uses simulations

# the same operator for discrete distributions:
P &lt;- Pois(lambda=2)

E(P) ## uses explicit terms
E(as(P,"DiscreteDistribution")) ## uses sums
E(as(P,"UnivariateDistribution")) ## uses simulations
E(P, fun = function(x){2*x^2}) ## uses simulations


# second moment of N(1,4)
E(Norm(mean=1, sd=2), fun = function(x){x^2})
E(Norm(mean=1, sd=2), fun = function(x){x^2}, useApply = FALSE)

# conditional distribution of a linear model
D1 &lt;- LMCondDistribution(theta = 1) 
E(D1, cond = 1)
E(Norm(mean=1))
E(D1, function(x){x^2}, cond = 1)
E(Norm(mean=1), fun = function(x){x^2})
E(D1, function(x, cond){cond*x^2}, cond = 2, withCond = TRUE, useApply = FALSE)
E(Norm(mean=2), function(x){2*x^2})

E(as(Norm(mean=2),"AbscontDistribution"))
### somewhat less accurate:
E(as(Norm(mean=2),"AbscontDistribution"), 
     lowerTruncQuantil=1e-4,upperTruncQuantil=1e-4, IQR.fac= 4)
### even less accurate:
E(as(Norm(mean=2),"AbscontDistribution"), 
     lowerTruncQuantil=1e-2,upperTruncQuantil=1e-2, IQR.fac= 4)
### no good idea, but just as an example:
E(as(Norm(mean=2),"AbscontDistribution"), 
     lowerTruncQuantil=1e-2,upperTruncQuantil=1e-2, IQR.fac= .1)

### truncation of integration range; see also m1df...
E(Norm(mean=2), low=2,upp=4)

E(Cauchy())
E(Cauchy(),upp=3,low=-2)
# some Lebesgue decomposed distribution 
mymix &lt;- UnivarLebDecDistribution(acPart = Norm(), discretePart = Binom(4,.4),
         acWeight = 0.4)
E(mymix)
</code></pre>

<hr>
<h2 id='EmpiricalMVDistribution'>Generating function for mulitvariate discrete distribution</h2><span id='topic+EmpiricalMVDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"DiscreteMVDistribution"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EmpiricalMVDistribution(data, Symmetry = NoSymmetry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EmpiricalMVDistribution_+3A_data">data</code></td>
<td>
<p> numeric matrix with data where the rows are 
interpreted as observations. </p>
</td></tr>
<tr><td><code id="EmpiricalMVDistribution_+3A_symmetry">Symmetry</code></td>
<td>
<p>you may help <span class="rlang"><b>R</b></span> in calculations if you tell it whether
the distribution is non-symmetric (default) or symmetric with respect
to a center.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a simple utility function providing a wrapper to the 
generating function <code><a href="distr.html#topic+DiscreteDistribution">DiscreteDistribution</a></code>.
</p>
<p>Typical usages are
</p>
<pre>
    EmpiricalMVDistribution(data)
  </pre>
<p>Identical rows are collapsed to unique support values. 
If <code>prob</code> is missing, all elements in <code>supp</code>
are equally weighted. 
</p>


<h3>Value</h3>

<p>Object of class <code>"DiscreteMVDistribution"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DiscreteMVDistribution">DiscreteMVDistribution</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some data
X &lt;- matrix(rnorm(50), ncol = 5)

## empirical distribution of X
D1 &lt;- EmpiricalMVDistribution(data = X)
support(D1)
r(D1)(10)
</code></pre>

<hr>
<h2 id='EuclCondition'>Generating function for EuclCondition-class</h2><span id='topic+EuclCondition'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"EuclCondition"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EuclCondition(dimension)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EuclCondition_+3A_dimension">dimension</code></td>
<td>
<p>positive integer: dimension of the Euclidean space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"EuclCondition"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+EuclCondition-class">EuclCondition-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>EuclCondition(dimension = 3)

## The function is currently defined as
function(dimension){
    new("EuclCondition", Range = EuclideanSpace(dimension = dimension))
}
</code></pre>

<hr>
<h2 id='EuclCondition-class'>Conditioning by an Euclidean space.</h2><span id='topic+EuclCondition-class'></span><span id='topic+Range'></span><span id='topic+Range+2CEuclCondition-method'></span><span id='topic+show+2CEuclCondition-method'></span>

<h3>Description</h3>

<p>Conditioning by an Euclidean space.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("EuclCondition", ...)</code>.
More frequently they are created via the generating function 
<code>EuclCondition</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>Range</code></dt><dd><p>Object of class <code>"EuclideanSpace"</code>. </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: name of condition. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Condition"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>Range</dt><dd><p><code>signature(object = "EuclCondition")</code> accessor
function for slot <code>Range</code>.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "EuclCondition")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Condition-class">Condition-class</a></code>, <code><a href="#topic+EuclCondition">EuclCondition</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  new("EuclCondition")
</code></pre>

<hr>
<h2 id='GLIntegrate'>Gauss-Legendre Quadrature</h2><span id='topic+GLIntegrate'></span>

<h3>Description</h3>

<p>Gauss-Legendre quadrature over a finite interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLIntegrate(f, lower, upper, order = 500, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLIntegrate_+3A_f">f</code></td>
<td>
<p> an R function taking a numeric first argument and returning a
numeric vector of the same length.  Returning a non-finite
element will generate an error. </p>
</td></tr>
<tr><td><code id="GLIntegrate_+3A_lower">lower</code></td>
<td>
<p> finite lower limit of integration. </p>
</td></tr>
<tr><td><code id="GLIntegrate_+3A_upper">upper</code></td>
<td>
<p> finite upper limit of integration. </p>
</td></tr>
<tr><td><code id="GLIntegrate_+3A_order">order</code></td>
<td>
<p> order of Gauss-Legendre quadrature. </p>
</td></tr>
<tr><td><code id="GLIntegrate_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to <code>f</code>. Remember 
to use argument names not matching those of <code>GLIntegrate</code>! </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case <code>order = 100, 500, 1000</code> saved abscissas and weights 
are used. Otherwise the corresponding abscissas and weights are
computed using the algorithm given in Section 4.5 of
Press et al. (1992). 
</p>


<h3>Value</h3>

<p>Estimate of the integral.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>W.H. Press, S.A. Teukolsky, W.T. Vetterling, B.P. Flannery (1992)
<em>Numerical Recipies in C</em>. The Art of Scientific Computing.
Second Edition. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+integrate">integrate</a></code>, <code><a href="#topic+distrExIntegrate">distrExIntegrate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>integrate(dnorm, -1.96, 1.96)
GLIntegrate(dnorm, -1.96, 1.96)
</code></pre>

<hr>
<h2 id='HellingerDist'>Generic function for the computation of the Hellinger distance of two distributions</h2><span id='topic+HellingerDist'></span><span id='topic+HellingerDist-methods'></span><span id='topic+HellingerDist+2CAbscontDistribution+2CAbscontDistribution-method'></span><span id='topic+HellingerDist+2CAbscontDistribution+2CDiscreteDistribution-method'></span><span id='topic+HellingerDist+2CDiscreteDistribution+2CDiscreteDistribution-method'></span><span id='topic+HellingerDist+2CDiscreteMVDistribution+2CDiscreteMVDistribution-method'></span><span id='topic+HellingerDist+2CDiscreteDistribution+2CAbscontDistribution-method'></span><span id='topic+HellingerDist+2CLatticeDistribution+2CDiscreteDistribution-method'></span><span id='topic+HellingerDist+2CDiscreteDistribution+2CLatticeDistribution-method'></span><span id='topic+HellingerDist+2CLatticeDistribution+2CLatticeDistribution-method'></span><span id='topic+HellingerDist+2Cnumeric+2CDiscreteDistribution-method'></span><span id='topic+HellingerDist+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic+HellingerDist+2Cnumeric+2CAbscontDistribution-method'></span><span id='topic+HellingerDist+2CAbscontDistribution+2Cnumeric-method'></span><span id='topic+HellingerDist+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the Hellinger distance <code class="reqn">d_h</code>
of two distributions <code class="reqn">P</code> and <code class="reqn">Q</code> which may be defined for an arbitrary 
sample space <code class="reqn">(\Omega,{\cal A})</code>. The Hellinger distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_h(P,Q)=\frac{1}{2}\int|\sqrt{dP}\,-\sqrt{dQ}\,|^2</code>
</p>

<p>where <code class="reqn">\sqrt{dP}</code>, respectively <code class="reqn">\sqrt{dQ}</code> denotes the square root 
of the densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HellingerDist(e1, e2, ...)
## S4 method for signature 'AbscontDistribution,AbscontDistribution'
HellingerDist(e1,e2, 
                        rel.tol=.Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,DiscreteDistribution'
HellingerDist(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,AbscontDistribution'
HellingerDist(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,DiscreteDistribution'
HellingerDist(e1,e2, ...)
## S4 method for signature 'numeric,DiscreteDistribution'
HellingerDist(e1, e2, ...)
## S4 method for signature 'DiscreteDistribution,numeric'
HellingerDist(e1, e2, ...)
## S4 method for signature 'numeric,AbscontDistribution'
HellingerDist(e1, e2, asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e2),
            up.discr = getUp(e2), h.smooth = getdistrExOption("hSmooth"),
                        rel.tol=.Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,numeric'
HellingerDist(e1, e2, asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e1),
            up.discr = getUp(e1), h.smooth = getdistrExOption("hSmooth"), 
                        rel.tol=.Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AcDcLcDistribution,AcDcLcDistribution'
HellingerDist(e1,e2, 
                        rel.tol=.Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HellingerDist_+3A_e1">e1</code></td>
<td>
<p> object of class <code>"Distribution"</code> or class <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_e2">e2</code></td>
<td>
<p> object of class <code>"Distribution"</code> or class <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_asis.smooth.discretize">asis.smooth.discretize</code></td>
<td>
<p> possible methods are <code>"asis"</code>, 
<code>"smooth"</code> and <code>"discretize"</code>. Default is <code>"discretize"</code>.</p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_n.discr">n.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the number of lattice points 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_low.discr">low.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the lower end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_up.discr">up.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the upper end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_h.smooth">h.smooth</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"smooth"</code> &ndash; i.e., the empirical distribution of the provided 
data should be smoothed &ndash; one has to specify this parameter.</p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_rel.tol">rel.tol</code></td>
<td>
<p> relative accuracy requested in integration </p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_truncquantile">TruncQuantile</code></td>
<td>
<p>Quantile the quantile based integration bounds (see details)</p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_iqr.fac">IQR.fac</code></td>
<td>
<p>Factor for the scale based integration bounds (see details)</p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_...">...</code></td>
<td>
<p> further arguments to be used in particular methods &ndash; (in package <span class="pkg">distrEx</span>: just
used for distributions with a.c. parts, where it is used to pass on arguments
to <code>distrExIntegrate</code>). </p>
</td></tr>
<tr><td><code id="HellingerDist_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For distances between absolutely continuous distributions, we use numerical
integration; to determine sensible bounds we proceed as follows:
by means of <code>min(getLow(e1,eps=TruncQuantile),getLow(e2,eps=TruncQuantile))</code>, 
<code>max(getUp(e1,eps=TruncQuantile),getUp(e2,eps=TruncQuantile))</code> we determine
quantile based bounds <code>c(low.0,up.0)</code>, and by means of
<code>s1 &lt;- max(IQR(e1),IQR(e2));</code> <code>m1&lt;- median(e1);</code> 
<code>m2 &lt;- median(e2)</code>
and <code>low.1 &lt;- min(m1,m2)-s1*IQR.fac</code>, <code>up.1 &lt;- max(m1,m2)+s1*IQR.fac</code>
we determine scale based bounds; these are combined by
<code>low &lt;- max(low.0,low.1)</code>, <code>up &lt;- max(up.0,up1)</code>.
</p>
<p>In case we want to compute the Hellinger distance between (empirical) data
and an abs. cont. distribution, we can specify the parameter <code>asis.smooth.discretize</code>
to avoid trivial distances (distance = 1).
</p>
<p>Using <code>asis.smooth.discretize = "discretize"</code>, which is the default,
leads to a discretization of the provided abs. cont. distribution and 
the distance is computed between the provided data and the discretized
distribution.
</p>
<p>Using <code>asis.smooth.discretize = "smooth"</code> causes smoothing of the
empirical distribution of the provided data. This is, the empirical
data is convoluted with the normal distribution <code>Norm(mean = 0, sd = h.smooth)</code>
which leads to an abs. cont. distribution. Afterwards the distance 
between the smoothed empirical distribution and the provided abs. cont.
distribution is computed.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p> Hellinger distance of <code>e1</code> and <code>e2</code> </p>


<h3>Methods</h3>


<dl>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>Hellinger distance of two absolutely continuous 
univariate distributions which is computed using <code>distrExintegrate</code>.
</p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>Hellinger distance of absolutely continuous and discrete
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>Hellinger distance of two discrete univariate distributions
which is computed using <code>support</code> and <code>sum</code>.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>Hellinger distance of discrete and absolutely continuous 
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>Hellinger distance between (empirical) data and a discrete 
distribution.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;numeric&quot;:</dt><dd>
<p>Hellinger distance between (empirical) data and a discrete
distribution.
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>Hellinger distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e1 = &quot;numeric&quot;:</dt><dd>
<p>Hellinger distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = &quot;AcDcLcDistribution&quot;, e2 = &quot;AcDcLcDistribution&quot;:</dt><dd>
<p>Hellinger distance of mixed discrete and absolutely continuous 
univariate distributions.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distrExIntegrate">distrExIntegrate</a></code>, <code><a href="#topic+ContaminationSize">ContaminationSize</a></code>, 
<code><a href="#topic+TotalVarDist">TotalVarDist</a></code>, <code><a href="#topic+KolmogorovDist">KolmogorovDist</a></code>, 
<code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>HellingerDist(Norm(), UnivarMixingDistribution(Norm(1,2),Norm(0.5,3),
                 mixCoeff=c(0.2,0.8)))
HellingerDist(Norm(), Td(10))
HellingerDist(Norm(mean = 50, sd = sqrt(25)), Binom(size = 100)) # mutually singular
HellingerDist(Pois(10), Binom(size = 20)) 

x &lt;- rnorm(100)
HellingerDist(Norm(), x)
HellingerDist(x, Norm(), asis.smooth.discretize = "smooth")

y &lt;- (rbinom(50, size = 20, prob = 0.5)-10)/sqrt(5)
HellingerDist(y, Norm())
HellingerDist(y, Norm(), asis.smooth.discretize = "smooth")

HellingerDist(rbinom(50, size = 20, prob = 0.5), Binom(size = 20, prob = 0.5))
</code></pre>

<hr>
<h2 id='internals_for_distrEx'>Internal functions of package distrEx</h2><span id='topic+internals_for_distrEx'></span><span id='topic+.getIntbounds'></span><span id='topic+.filterFunargs'></span><span id='topic+.filterEargs'></span><span id='topic+.nmsToGather'></span><span id='topic+.showallNamesDiagnosticList'></span><span id='topic+.reorganizeDiagnosticList'></span>

<h3>Description</h3>

<p>These functions are used internally by package distrEx.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getIntbounds(object, low, upp, lowTQ, uppTQ, IQR.fac, ...)
.filterFunargs(dots, fun, neg = FALSE)
.filterEargs(dots, neg = FALSE)
.reorganizeDiagnosticList(liste, .depth=1, names0, prenames = "",
          nmstoGather="", nmstoGatherNS="",  withprint=TRUE,
          .GatherList = NULL, .GatherListNS = NULL)
.showallNamesDiagnosticList(liste, .depth=1)
.nmsToGather
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_distrEx_+3A_object">object</code></td>
<td>
<p>an object of class <code>"AbscontDistribution"</code></p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_low">low</code></td>
<td>
<p>given lower integration bound</p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_upp">upp</code></td>
<td>
<p>given lower integration bound</p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_lowtq">lowTQ</code></td>
<td>
<p>lower quantile for quantile based integration range. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_upptq">uppTQ</code></td>
<td>
<p>upper quantile for quantile based integration range. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_iqr.fac">IQR.fac</code></td>
<td>
<p>factor for scale based integration range (i.e.; 
median of the distribution <code class="reqn">\pm</code><code>IQR.fac</code><code class="reqn">\times</code>IQR).</p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_dots">dots</code></td>
<td>
<p> a list as obtained by <code>list(...)</code>. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_...">...</code></td>
<td>
<p>arguments passed through to other functions (in particular argument
<code>cond</code> in <code>.getIntbounds</code>)</p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_neg">neg</code></td>
<td>
<p>logical: if <code>FALSE</code> (default) the items in <code>dots</code> with argument
names coinciding with formal argument names used by <code>distrExIntegrate</code>,
<code>integrate</code>, <code>GLIntegrate</code>, except for <code>...</code>, <code>f</code>,
<code>distr</code>, are returned; otherwise the logical complement, i.e., those
items not coinciding with the mentioned names are returned.</p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_fun">fun</code></td>
<td>
<p> a function the formals of which are to be filtered from argument list
<code>dots</code>. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_liste">liste</code></td>
<td>
<p> a list (usually of S3 class <code>"DiagnosticClass"</code>)
as filled from various functions with diagnostic information; it usually
has a tree structure and is the to be reorganized; this is done in
function <code>.reorganizeDiagnosticList</code> which groups items of the
same name in several sublists. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_.depth">.depth</code></td>
<td>
<p> an argument to be used internally to determine the depth
of the recursion when moving through the tree. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_names0">names0</code></td>
<td>
<p> a character vector with the names of the items to be regrouped
in new sublists. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_prenames">prenames</code></td>
<td>
<p> to determine the position in the original tree, the names
of parent nodes are concatenated, separated by &quot;$&quot; and passed on
to children nodes by argument <code>prenames</code>. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_nmstogather">nmstoGather</code></td>
<td>
<p> we have two kind of diagnostic list items, ones which
are easily grouped (numeric, character, logical) and ones which are calls,
lists or functions. <code>nmstoGather</code> takes the names of items
to be regrouped which are of the first kind. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_nmstogatherns">nmstoGatherNS</code></td>
<td>
<p> the names of items to be regrouped which are of the
second kind (NS standing for &quot;non-shown&quot;). </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_.gatherlist">.GatherList</code></td>
<td>
<p> the list of new regrouped sublists (of first kind).
This argument is not filled by the user but rather passed on within the
recursion when moving through the tree. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_.gatherlistns">.GatherListNS</code></td>
<td>
<p> the list of new regrouped sublists (of second kind).
This argument is not filled by the user but rather passed on within the
recursion when moving through the tree. </p>
</td></tr>
<tr><td><code id="internals_for_distrEx_+3A_withprint">withprint</code></td>
<td>
<p> logical; should intermediate information when moving
through the tree be printed? </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.getIntbounds</code> integration bounds are obtained
as <code>lowB &lt;- max(low, q.l(object)(lowTQ), median(object)-IQR.fac*IQR(object))</code>
and <code>uppB &lt;- min(upp, q.l(object)(1-uppTQ), median(object)+IQR.fac*IQR(object))</code>
</p>
<p><code>.filterEargs</code> filters out arguments that are used in numerical integration
and returns only these (or returns all items except for them, if argument
<code>neg</code> is <code>TRUE</code>).
</p>
<p><code>.filterFunargs</code> filters out arguments the names of which are within the
names of the formal arguments of <code>fun</code> (or returns all items of
<code>dots</code> except for the matched ones, if argument
<code>neg</code> is <code>TRUE</code>).
</p>
<p><code>.nmsToGather</code> is a character vector containing the names of items
which are easily regrouped (of first kind in the distinction in the
arguments <code>namestoGather</code> and <code>namestoGatherNS</code>); the distinction
in these two categories is based on this vector; those items not in this
vector are put into the second kind.
</p>
<p><code>.showallNamesDiagnosticList</code> runs through all the nodes in the list and
collects all names and then returns the list of all (unique) names found.
</p>
<p><code>.reorganizeDiagnosticList</code> reorganizes the nodes of the nodes in the list,
regrouping them into groups with the names.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.getIntbounds</code></td>
<td>
<p>a named numeric vector with coordinates <code>low</code> and <code>upp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,
</p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+AbscontDistribution">AbscontDistribution</a></code>,
<code><a href="#topic+distrExIntegrate">distrExIntegrate</a></code>
</p>

<hr>
<h2 id='KolmogorovDist'>Generic function for the computation of the Kolmogorov distance of two distributions</h2><span id='topic+KolmogorovDist'></span><span id='topic+KolmogorovDist-methods'></span><span id='topic+KolmogorovDist+2CAbscontDistribution+2CAbscontDistribution-method'></span><span id='topic+KolmogorovDist+2CAbscontDistribution+2CDiscreteDistribution-method'></span><span id='topic+KolmogorovDist+2CDiscreteDistribution+2CDiscreteDistribution-method'></span><span id='topic+KolmogorovDist+2CDiscreteDistribution+2CAbscontDistribution-method'></span><span id='topic+KolmogorovDist+2CLatticeDistribution+2CDiscreteDistribution-method'></span><span id='topic+KolmogorovDist+2CDiscreteDistribution+2CLatticeDistribution-method'></span><span id='topic+KolmogorovDist+2CLatticeDistribution+2CLatticeDistribution-method'></span><span id='topic+KolmogorovDist+2Cnumeric+2CUnivariateDistribution-method'></span><span id='topic+KolmogorovDist+2CUnivariateDistribution+2Cnumeric-method'></span><span id='topic+KolmogorovDist+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the Kolmogorov distance <code class="reqn">d_\kappa</code>
of two distributions <code class="reqn">P</code> and <code class="reqn">Q</code> where the distributions are defined 
on a finite-dimensional Euclidean space <code class="reqn">(\R^m,{\cal B}^m)</code>
with <code class="reqn"> {\cal B}^m </code> the Borel-<code class="reqn">\sigma</code>-algebra on <code class="reqn">R^m</code>.
The Kolmogorov distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_\kappa(P,Q)=\sup\{|P(\{y\in\R^m\,|\,y\le x\})-Q(\{y\in\R^m\,|\,y\le x\})| | x\in\R^m\}</code>
</p>

<p>where <code class="reqn">\le</code> is coordinatewise on <code class="reqn">\R^m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KolmogorovDist(e1, e2, ...)
## S4 method for signature 'AbscontDistribution,AbscontDistribution'
KolmogorovDist(e1,e2, ...)
## S4 method for signature 'AbscontDistribution,DiscreteDistribution'
KolmogorovDist(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,AbscontDistribution'
KolmogorovDist(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,DiscreteDistribution'
KolmogorovDist(e1,e2, ...)
## S4 method for signature 'numeric,UnivariateDistribution'
KolmogorovDist(e1, e2, ...)
## S4 method for signature 'UnivariateDistribution,numeric'
KolmogorovDist(e1, e2, ...)
## S4 method for signature 'AcDcLcDistribution,AcDcLcDistribution'
KolmogorovDist(e1, e2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KolmogorovDist_+3A_e1">e1</code></td>
<td>
<p> object of class <code>"Distribution"</code> or class <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="KolmogorovDist_+3A_e2">e2</code></td>
<td>
<p> object of class <code>"Distribution"</code> or class <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="KolmogorovDist_+3A_...">...</code></td>
<td>
<p> further arguments to be used in particular methods (not in package <span class="pkg">distrEx</span>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Kolmogorov distance of <code>e1</code> and <code>e2</code> </p>


<h3>Methods</h3>


<dl>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>Kolmogorov distance of two absolutely continuous 
univariate distributions which is computed using a
union of a (pseudo-)random and a deterministic grid.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>Kolmogorov distance of two discrete univariate distributions. 
The distance is attained at some point of the union of the supports 
of <code>e1</code> and <code>e2</code>.
</p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>Kolmogorov distance of absolutely continuous and discrete
univariate distributions. It is computed using a union of 
a (pseudo-)random and a deterministic grid in combination
with the support of <code>e2</code>.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>Kolmogorov distance of discrete and absolutely continuous
univariate distributions. It is computed using a union of 
a (pseudo-)random and a deterministic grid in combination
with the support of <code>e1</code>.
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;UnivariateDistribution&quot;:</dt><dd>
<p>Kolmogorov distance between (empirical) data and a univariate 
distribution. The computation is based on <code>ks.test</code>.
</p>
</dd>
<dt>e1 = &quot;UnivariateDistribution&quot;, e2 = &quot;numeric&quot;:</dt><dd>
<p>Kolmogorov distance between (empirical) data and a univariate 
distribution. The computation is based on <code>ks.test</code>.
</p>
</dd>
<dt>e1 = &quot;AcDcLcDistribution&quot;, e2 = &quot;AcDcLcDistribution&quot;:</dt><dd>
<p>Kolmogorov distance of mixed discrete and absolutely continuous
univariate distributions. It is computed using a union of 
the discrete part, a (pseudo-)random and
a deterministic grid in combination
with the support of <code>e1</code>.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ContaminationSize">ContaminationSize</a></code>, <code><a href="#topic+TotalVarDist">TotalVarDist</a></code>, 
<code><a href="#topic+HellingerDist">HellingerDist</a></code>, <code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>KolmogorovDist(Norm(), UnivarMixingDistribution(Norm(1,2),Norm(0.5,3),
                 mixCoeff=c(0.2,0.8)))
KolmogorovDist(Norm(), Td(10))
KolmogorovDist(Norm(mean = 50, sd = sqrt(25)), Binom(size = 100))
KolmogorovDist(Pois(10), Binom(size = 20)) 
KolmogorovDist(Norm(), rnorm(100))
KolmogorovDist((rbinom(50, size = 20, prob = 0.5)-10)/sqrt(5), Norm())
KolmogorovDist(rbinom(50, size = 20, prob = 0.5), Binom(size = 20, prob = 0.5))
</code></pre>

<hr>
<h2 id='liesInSupport'>Generic Function for Testing the Support of a Distribution </h2><span id='topic+liesInSupport+2CDiscreteMVDistribution+2Cnumeric-method'></span><span id='topic+liesInSupport+2CDiscreteMVDistribution+2Cmatrix-method'></span>

<h3>Description</h3>

<p>The function tests if <code>x</code> lies in the support of the
distribution <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DiscreteMVDistribution,numeric'
liesInSupport(object, x, checkFin = FALSE)
## S4 method for signature 'DiscreteMVDistribution,matrix'
liesInSupport(object, x, checkFin = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="liesInSupport_+3A_object">object</code></td>
<td>
<p> object of class <code>"Distribution"</code> </p>
</td></tr>
<tr><td><code id="liesInSupport_+3A_x">x</code></td>
<td>
<p> numeric vector or matrix </p>
</td></tr>
<tr><td><code id="liesInSupport_+3A_checkfin">checkFin</code></td>
<td>
<p> logical: in case <code>FALSE</code>, we simply check whether
<code>x</code> lies exactly in the <em>numerical</em> support (of finitely many
support points); later on we might try to mimick the univariate case
more closely in case <code>TRUE</code>, but so far this is not yet used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;DiscreteMVDistribution&quot;, x = &quot;numeric&quot;:</dt><dd> 
<p>does <code>x</code> lie in the support of <code>object</code>. </p>
</dd>
<dt>object = &quot;DiscreteMVDistribution&quot;, x = &quot;matrix&quot;:</dt><dd> 
<p>does <code>x</code> lie in the support of <code>object</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(rpois(30, lambda = 10), ncol = 3)
D1 &lt;- DiscreteMVDistribution(M)
M1 &lt;- rbind(r(D1)(10), matrix(rpois(30, lam = 10), ncol = 3))
liesInSupport(D1, M1)
</code></pre>

<hr>
<h2 id='LMCondDistribution'>Generating function for the conditional distribution 
of a linear regression model.</h2><span id='topic+LMCondDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"AbscontCondDistribution"</code> which 
is the conditional distribution of a linear regression model (given
the regressor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMCondDistribution(Error = Norm(), theta = 0, intercept = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LMCondDistribution_+3A_error">Error</code></td>
<td>
<p> Object of class <code>"AbscontDistribution"</code>: 
error distribution. </p>
</td></tr>
<tr><td><code id="LMCondDistribution_+3A_theta">theta</code></td>
<td>
<p> numeric vector: regression parameter. </p>
</td></tr>
<tr><td><code id="LMCondDistribution_+3A_intercept">intercept</code></td>
<td>
<p> real number: intercept parameter. </p>
</td></tr>
<tr><td><code id="LMCondDistribution_+3A_scale">scale</code></td>
<td>
<p> positive real number: scale parameter. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"AbscontCondDistribution"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+AbscontCondDistribution-class">AbscontCondDistribution-class</a></code>, <code><a href="#topic+E-methods">E-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># normal error distribution
(D1 &lt;- LMCondDistribution(theta = 1)) # corresponds to Norm(cond, 1)
plot(D1)
r(D1)
d(D1)
p(D1)
q(D1)
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
param(D1)
cond(D1)

d(D1)(0, cond = 1)
d(Norm(mean=1))(0)

E(D1, cond = 1)
E(D1, function(x){x^2}, cond = 2)
E(Norm(mean=2), function(x){x^2})
</code></pre>

<hr>
<h2 id='LMParameter'>Generating function for LMParameter-class</h2><span id='topic+LMParameter'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"LMParameter"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMParameter(theta = 0, intercept = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LMParameter_+3A_theta">theta</code></td>
<td>
<p> numeric vector: regression parameter (default <code>=0</code>). </p>
</td></tr>
<tr><td><code id="LMParameter_+3A_intercept">intercept</code></td>
<td>
<p> real number: intercept parameter (default <code>=0</code>). </p>
</td></tr>
<tr><td><code id="LMParameter_+3A_scale">scale</code></td>
<td>
<p> positive real number: scale parameter (default <code>=1</code>). </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"LMParameter"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+LMParameter-class">LMParameter-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>LMParameter(theta = c(1,1), intercept = 2, scale = 0.5)

## The function is currently defined as
function(theta = 0, intercept = 0, scale = 1){
    new("LMParameter", theta = theta, intercept = intercept, scale = 1)
}
</code></pre>

<hr>
<h2 id='LMParameter-class'>Parameter of a linear regression model</h2><span id='topic+LMParameter-class'></span><span id='topic+show+2CLMParameter-method'></span>

<h3>Description</h3>

<p>Parameter of a linear regression model 
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + x^\tau\theta + \sigma u</code>
</p>

<p>with intercept <code class="reqn">\mu</code>, regression parameter <code class="reqn">\theta</code> 
and error scale <code class="reqn">\sigma</code>. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("LMParameter", ...)</code>.
More frequently they are created via the generating function 
<code>LMParameter</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code></dt><dd><p> numeric vector: 
regression parameter. </p>
</dd>
<dt><code>intercept</code></dt><dd><p> real number: 
intercept parameter. </p>
</dd>
<dt><code>scale</code></dt><dd><p> positive real number: 
scale paramter. </p>
</dd>
<dt><code>name</code></dt><dd><p> character vector:
the default name is &ldquo;parameter of a linear regression model&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.<br />
Class <code>"OptionalParameter"</code>, by class <code>"Parameter"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "LMParameter")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+Parameter-class">Parameter-class</a></code>, <code><a href="#topic+LMParameter">LMParameter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  new("LMParameter")
</code></pre>

<hr>
<h2 id='m1df'>Generic Function for the Computation of Clipped First Moments</h2><span id='topic+m1df'></span><span id='topic+m1df-methods'></span><span id='topic+m1df+2CUnivariateDistribution-method'></span><span id='topic+m1df+2CAbscontDistribution-method'></span><span id='topic+m1df+2CLatticeDistribution-method'></span><span id='topic+m1df+2CAffLinDistribution-method'></span><span id='topic+m1df+2CBinom-method'></span><span id='topic+m1df+2CPois-method'></span><span id='topic+m1df+2CNorm-method'></span><span id='topic+m1df+2CExp-method'></span><span id='topic+m1df+2CChisq-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of clipped first moments.
The moments are clipped at <code>upper</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m1df(object, upper, ...)
## S4 method for signature 'AbscontDistribution'
m1df(object, upper, 
             lowerTruncQuantile = getdistrExOption("m1dfLowerTruncQuantile"),
             rel.tol = getdistrExOption("m1dfRelativeTolerance"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m1df_+3A_object">object</code></td>
<td>
<p> object of class <code>"Distribution"</code> </p>
</td></tr>
<tr><td><code id="m1df_+3A_upper">upper</code></td>
<td>
<p> clipping bound </p>
</td></tr>
<tr><td><code id="m1df_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code>.</p>
</td></tr> 
<tr><td><code id="m1df_+3A_lowertruncquantile">lowerTruncQuantile</code></td>
<td>
<p>lower quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="m1df_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>E</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The precision of the computations can be controlled via 
certain global options; cf. <code><a href="#topic+distrExOptions">distrExOptions</a></code>. </p>


<h3>Value</h3>

<p>The first moment of <code>object</code> clipped at <code>upper</code> is computed.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;UnivariateDistribution&quot;:</dt><dd>



<p>uses call <code>E(object, upp=upper, ...)</code>.
</p>
</dd>
<dt>object = &quot;AbscontDistribution&quot;:</dt><dd><p> clipped first moment
for absolutely continuous univariate distributions which is 
computed using <code>integrate</code>. </p>
</dd>
<dt>object = &quot;LatticeDistribution&quot;:</dt><dd><p> clipped first moment
for discrete univariate distributions which is computed 
using <code>support</code> and <code>sum</code>. </p>
</dd>
<dt>object = &quot;AffLinDistribution&quot;:</dt><dd><p> clipped first moment
for affine linear distributions  which is computed on basis of 
slot <code>X0</code>. </p>
</dd>
<dt>object = &quot;Binom&quot;:</dt><dd><p> clipped first moment
for Binomial distributions which is computed using <code>pbinom</code>. </p>
</dd>
<dt>object = &quot;Pois&quot;:</dt><dd><p> clipped first moment
for Poisson distributions which is computed using <code>ppois</code>. </p>
</dd>
<dt>object = &quot;Norm&quot;:</dt><dd><p> clipped first moment
for normal distributions which is computed using <code>dnorm</code> and <code>pnorm</code>. </p>
</dd>
<dt>object = &quot;Exp&quot;:</dt><dd><p> clipped first moment
for exponential distributions which is computed using <code>pexp</code>. </p>
</dd>
<dt>object = &quot;Chisq&quot;:</dt><dd><p> clipped first moment
for <code class="reqn">\chi^2</code> distributions which is computed using <code>pchisq</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+distrExIntegrate">distrExIntegrate</a></code>, <code><a href="#topic+m2df">m2df</a></code>, <code><a href="#topic+E">E</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># standard normal distribution
N1 &lt;- Norm()
m1df(N1, 0)

# Poisson distribution
P1 &lt;- Pois(lambda=2)
m1df(P1, 3)
m1df(P1, 3, fun = function(x)sin(x))

# absolutely continuous distribution
D1 &lt;- Norm() + Exp() # convolution
m1df(D1, 2)
m1df(D1, Inf)
E(D1)
</code></pre>

<hr>
<h2 id='m2df'>Generic function for the computation of clipped second moments</h2><span id='topic+m2df'></span><span id='topic+m2df-methods'></span><span id='topic+m2df+2CUnivariateDistribution-method'></span><span id='topic+m2df+2CAbscontDistribution-method'></span><span id='topic+m2df+2CLatticeDistribution-method'></span><span id='topic+m2df+2CAffLinDistribution-method'></span><span id='topic+m2df+2CBinom-method'></span><span id='topic+m2df+2CPois-method'></span><span id='topic+m2df+2CNorm-method'></span><span id='topic+m2df+2CExp-method'></span><span id='topic+m2df+2CChisq-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of clipped second moments.
The moments are clipped at <code>upper</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2df(object, upper, ...)
## S4 method for signature 'AbscontDistribution'
m2df(object, upper, 
             lowerTruncQuantile = getdistrExOption("m2dfLowerTruncQuantile"),
             rel.tol = getdistrExOption("m2dfRelativeTolerance"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2df_+3A_object">object</code></td>
<td>
<p> object of class <code>"Distribution"</code> </p>
</td></tr>
<tr><td><code id="m2df_+3A_upper">upper</code></td>
<td>
<p> clipping bound </p>
</td></tr>
<tr><td><code id="m2df_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code>.</p>
</td></tr> 
<tr><td><code id="m2df_+3A_lowertruncquantile">lowerTruncQuantile</code></td>
<td>
<p>lower quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="m2df_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>E</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The precision of the computations can be controlled via 
certain global options; cf. <code><a href="#topic+distrExOptions">distrExOptions</a></code>. </p>


<h3>Value</h3>

<p>The second moment of <code>object</code> clipped at <code>upper</code> is computed.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;UnivariateDistribution&quot;:</dt><dd> 



<p>uses call <code>E(object, upp=upper, fun = function, ...)</code>.
</p>
</dd>
<dt>object = &quot;AbscontDistribution&quot;:</dt><dd><p> clipped second moment
for absolutely continuous univariate distributions which is 
computed using <code>integrate</code>. </p>
</dd>
<dt>object = &quot;LatticeDistribution&quot;:</dt><dd><p> clipped second moment
for discrete univariate distributions which is computed 
using <code>support</code> and <code>sum</code>. </p>
</dd>
<dt>object = &quot;AffLinDistribution&quot;:</dt><dd><p> clipped second moment
for affine linear distributions  which is computed on basis of 
slot <code>X0</code>. </p>
</dd>
<dt>object = &quot;Binom&quot;:</dt><dd><p> clipped second moment
for Binomial distributions which is computed using <code>pbinom</code>. </p>
</dd>
<dt>object = &quot;Pois&quot;:</dt><dd><p> clipped second moment
for Poisson distributions which is computed using <code>ppois</code>. </p>
</dd>
<dt>object = &quot;Norm&quot;:</dt><dd><p> clipped second moment
for normal distributions which is computed using <code>dnorm</code> and <code>pnorm</code>. </p>
</dd>
<dt>object = &quot;Exp&quot;:</dt><dd><p> clipped second moment
for exponential distributions which is computed using <code>pexp</code>. </p>
</dd>
<dt>object = &quot;Chisq&quot;:</dt><dd><p> clipped second moment
for <code class="reqn">\chi^2</code> distributions which is computed using <code>pchisq</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+m2df-methods">m2df-methods</a></code>, <code><a href="#topic+E-methods">E-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># standard normal distribution
N1 &lt;- Norm()
m2df(N1, 0)

# Poisson distribution
P1 &lt;- Pois(lambda=2)
m2df(P1, 3)
m2df(P1, 3, fun = function(x)sin(x))

# absolutely continuous distribution
D1 &lt;- Norm() + Exp() # convolution
m2df(D1, 2)
m2df(D1, Inf)
E(D1, function(x){x^2})
</code></pre>

<hr>
<h2 id='make01'>Centering and Standardization of Univariate Distributions</h2><span id='topic+make01'></span>

<h3>Description</h3>

<p>The function <code>make01</code> produces a new centered and 
standardized univariate distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make01(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make01_+3A_x">x</code></td>
<td>
<p> an object of class <code>"UnivariateDistribution"</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Thanks to the functionals provided in this package, the code is 
a one-liner: <code>(x-E(x))/sd(x)</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"UnivariateDistribution"</code> with expectation 0 and variance 1.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code>E</code>, <code>Var</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- sin(exp(2*log(abs( Norm())))) ## something weird
X01 &lt;- make01(X)
print(X01)
plot(X01)
sd(X01); E(X01)
</code></pre>

<hr>
<h2 id='MultivariateDistribution-class'>Multivariate Distributions</h2><span id='topic+MultivariateDistribution-class'></span><span id='topic+show+2CMultivariateDistribution-method'></span><span id='topic+plot+2CMultivariateDistribution-method'></span>

<h3>Description</h3>

<p>The class of multivariate distributions. One has at least to 
specify the image space of the distribution and a function generating
(pseudo-)random numbers. The slot <code>q</code> is usually filled with 
<code>NULL</code> for dimensions <code>&gt; 1</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MultivariateDistribution", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt><dd><p> Object of class <code>"rSpace"</code>. 
Image space of the distribution. Usually an object of 
class <code>"EuclideanSpace"</code>.</p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"OptionalParameter"</code>.
Optional parameter of the multivariate distribution.</p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: 
generates (pseudo-)random numbers</p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional density function</p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional cumulative distribution function </p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional quantile function </p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Distribution"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "MultivariateDistribution")</code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(object = "MultivariateDistribution")</code>:
not yet implemented.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Dirac-measure in (0,0)
new("MultivariateDistribution")
</code></pre>

<hr>
<h2 id='OAsymTotalVarDist'>Generic function for the computation of (minimal) asymmetric total variation distance of two distributions</h2><span id='topic+OAsymTotalVarDist'></span><span id='topic+OAsymTotalVarDist-methods'></span><span id='topic+OAsymTotalVarDist+2CAbscontDistribution+2CAbscontDistribution-method'></span><span id='topic+OAsymTotalVarDist+2CAbscontDistribution+2CDiscreteDistribution-method'></span><span id='topic+OAsymTotalVarDist+2CDiscreteDistribution+2CDiscreteDistribution-method'></span><span id='topic+OAsymTotalVarDist+2CDiscreteDistribution+2CAbscontDistribution-method'></span><span id='topic+OAsymTotalVarDist+2CLatticeDistribution+2CDiscreteDistribution-method'></span><span id='topic+OAsymTotalVarDist+2CDiscreteDistribution+2CLatticeDistribution-method'></span><span id='topic+OAsymTotalVarDist+2CLatticeDistribution+2CLatticeDistribution-method'></span><span id='topic+OAsymTotalVarDist+2Cnumeric+2CDiscreteDistribution-method'></span><span id='topic+OAsymTotalVarDist+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic+OAsymTotalVarDist+2Cnumeric+2CAbscontDistribution-method'></span><span id='topic+OAsymTotalVarDist+2CAbscontDistribution+2Cnumeric-method'></span><span id='topic+OAsymTotalVarDist+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of (minimal) asymmetric total variation distance 
<code class="reqn">d_v^\ast</code>
of two distributions <code class="reqn">P</code> and <code class="reqn">Q</code> where the distributions may be 
defined for an arbitrary sample space <code class="reqn">(\Omega,{\cal A})</code>.
This distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_v^\ast(P,Q)=\min_c \int |dQ-c\,dP|</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>OAsymTotalVarDist(e1, e2, ...)
## S4 method for signature 'AbscontDistribution,AbscontDistribution'
OAsymTotalVarDist(e1,e2, 
             rel.tol = .Machine$double.eps^0.3,  Ngrid = 10000,
             TruncQuantile = getdistrOption("TruncQuantile"),
             IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,DiscreteDistribution'
OAsymTotalVarDist(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,AbscontDistribution'
OAsymTotalVarDist(e1,e2,  ...)
## S4 method for signature 'DiscreteDistribution,DiscreteDistribution'
OAsymTotalVarDist(e1,e2, ...)
## S4 method for signature 'numeric,DiscreteDistribution'
OAsymTotalVarDist(e1, e2,  ...)
## S4 method for signature 'DiscreteDistribution,numeric'
OAsymTotalVarDist(e1, e2,  ...)
## S4 method for signature 'numeric,AbscontDistribution'
OAsymTotalVarDist(e1, e2,  asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e2),
            up.discr = getUp(e2), h.smooth = getdistrExOption("hSmooth"),
             rel.tol = .Machine$double.eps^0.3, Ngrid = 10000,
             TruncQuantile = getdistrOption("TruncQuantile"),
             IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,numeric'
OAsymTotalVarDist(e1, e2, 
            asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e1),
            up.discr = getUp(e1), h.smooth = getdistrExOption("hSmooth"),
             rel.tol = .Machine$double.eps^0.3, Ngrid = 10000,
             TruncQuantile = getdistrOption("TruncQuantile"),
             IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AcDcLcDistribution,AcDcLcDistribution'
OAsymTotalVarDist(e1, e2,
             rel.tol = .Machine$double.eps^0.3, Ngrid = 10000,
             TruncQuantile = getdistrOption("TruncQuantile"),
             IQR.fac = 15, ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OAsymTotalVarDist_+3A_e1">e1</code></td>
<td>
<p> object of class <code>"Distribution"</code> or <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_e2">e2</code></td>
<td>
<p> object of class <code>"Distribution"</code> or <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_asis.smooth.discretize">asis.smooth.discretize</code></td>
<td>
<p> possible methods are <code>"asis"</code>, 
<code>"smooth"</code> and <code>"discretize"</code>. Default is <code>"discretize"</code>.</p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_n.discr">n.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the number of lattice points 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_low.discr">low.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the lower end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_up.discr">up.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the upper end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_h.smooth">h.smooth</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"smooth"</code> &ndash; i.e., the empirical distribution of the provided 
data should be smoothed &ndash; one has to specify this parameter.</p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code> and <code>uniroot</code></p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_ngrid">Ngrid</code></td>
<td>
<p>How many grid points are to be evaluated to determine the range
of the likelihood ratio?</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="OAsymTotalVarDist_+3A_truncquantile">TruncQuantile</code></td>
<td>
<p>Quantile the quantile based integration bounds (see details)</p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_iqr.fac">IQR.fac</code></td>
<td>
<p>Factor for the scale based integration bounds (see details)</p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_...">...</code></td>
<td>
<p> further arguments to be used in particular methods &ndash; (in package <span class="pkg">distrEx</span>: just
used for distributions with a.c. parts, where it is used to pass on arguments
to <code>distrExIntegrate</code>). </p>
</td></tr>
<tr><td><code id="OAsymTotalVarDist_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For distances between absolutely continuous distributions, we use numerical
integration; to determine sensible bounds we proceed as follows:
by means of <code>min(getLow(e1,eps=TruncQuantile),getLow(e2,eps=TruncQuantile))</code>, 
<code>max(getUp(e1,eps=TruncQuantile),getUp(e2,eps=TruncQuantile))</code> we determine
quantile based bounds <code>c(low.0,up.0)</code>, and by means of
<code>s1 &lt;- max(IQR(e1),IQR(e2));</code> <code>m1&lt;- median(e1);</code> 
<code>m2 &lt;- median(e2)</code>
and <code>low.1 &lt;- min(m1,m2)-s1*IQR.fac</code>, <code>up.1 &lt;- max(m1,m2)+s1*IQR.fac</code>
we determine scale based bounds; these are combined by
<code>low &lt;- max(low.0,low.1)</code>, <code>up &lt;- max(up.0,up1)</code>.
</p>
<p>Again in the absolutely continuous case, to determine the range of the 
likelihood ratio, we evaluate this ratio on a grid constructed as follows:
<code>x.range &lt;- c(seq(low, up, length=Ngrid/3),
                     q.l(e1)(seq(0,1,length=Ngrid/3)*.999),
                     q.l(e2)(seq(0,1,length=Ngrid/3)*.999))</code>
</p>
<p>Finally, for both discrete and absolutely continuous case,
we clip this ratio downwards by <code>1e-10</code> and upwards by <code>1e10</code>
</p>
<p>In case we want to compute the total variation distance between (empirical) data
and an abs. cont. distribution, we can specify the parameter <code>asis.smooth.discretize</code>
to avoid trivial distances (distance = 1).
</p>
<p>Using <code>asis.smooth.discretize = "discretize"</code>, which is the default,
leads to a discretization of the provided abs. cont. distribution and 
the distance is computed between the provided data and the discretized
distribution.
</p>
<p>Using <code>asis.smooth.discretize = "smooth"</code> causes smoothing of the
empirical distribution of the provided data. This is, the empirical
data is convoluted with the normal distribution <code>Norm(mean = 0, sd = h.smooth)</code>
which leads to an abs. cont. distribution. Afterwards the distance 
between the smoothed empirical distribution and the provided abs. cont.
distribution is computed.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p> OAsymmetric Total variation distance of <code>e1</code> and <code>e2</code> </p>


<h3>Methods</h3>


<dl>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>total variation distance of two absolutely continuous 
univariate distributions which is computed using <code>distrExIntegrate</code>.
</p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>total variation distance of absolutely continuous and discrete
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>total variation distance of two discrete univariate distributions
which is computed using <code>support</code> and <code>sum</code>.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>total variation distance of discrete and absolutely continuous 
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and a discrete 
distribution.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;numeric&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and a discrete 
distribution.
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e1 = &quot;numeric&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = &quot;AcDcLcDistribution&quot;, e2 = &quot;AcDcLcDistribution&quot;:</dt><dd>
<p>Total variation distance of mixed discrete and absolutely continuous
univariate distributions.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>to be filled; 
Agostinelli, C and Ruckdeschel, P. (2009): A simultaneous inlier and outlier model
by asymmetric total variation distance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TotalVarDist-methods">TotalVarDist-methods</a></code>, <code><a href="#topic+ContaminationSize">ContaminationSize</a></code>, 
<code><a href="#topic+KolmogorovDist">KolmogorovDist</a></code>, <code><a href="#topic+HellingerDist">HellingerDist</a></code>, 
<code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>OAsymTotalVarDist(Norm(), UnivarMixingDistribution(Norm(1,2),Norm(0.5,3),
                 mixCoeff=c(0.2,0.8)))
OAsymTotalVarDist(Norm(), Td(10))
OAsymTotalVarDist(Norm(mean = 50, sd = sqrt(25)), Binom(size = 100)) # mutually singular
OAsymTotalVarDist(Pois(10), Binom(size = 20)) 

x &lt;- rnorm(100)
OAsymTotalVarDist(Norm(), x)
OAsymTotalVarDist(x, Norm(), asis.smooth.discretize = "smooth")

y &lt;- (rbinom(50, size = 20, prob = 0.5)-10)/sqrt(5)
OAsymTotalVarDist(y, Norm())
OAsymTotalVarDist(y, Norm(), asis.smooth.discretize = "smooth")

OAsymTotalVarDist(rbinom(50, size = 20, prob = 0.5), Binom(size = 20, prob = 0.5))
</code></pre>

<hr>
<h2 id='plot-methods'> Methods for Function plot in Package &lsquo;distrEx&rsquo; </h2><span id='topic+plot'></span><span id='topic+plot-methods'></span><span id='topic+plot+2CUnivariateCondDistribution+2Cmissing-method'></span><span id='topic+plot+2CMultivariateDistribution+2Cmissing-method'></span>

<h3>Description</h3>

<p>plot-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(x, y, ...)
## S4 method for signature 'UnivariateCondDistribution,missing'
plot(x, y, ...)
## S4 method for signature 'MultivariateDistribution,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>object of class 
<code>"UnivariateCondDistribution"</code> or class
<code>"MultivariateDistribution"</code>: 
distribution(s) which should be plotted </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p> missing </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>addtional arguments </p>
</td></tr>
</table>


<h3>Details</h3>

<p>upto now only warnings are issued that the corresponding
method is not yet implemented;
</p>

<hr>
<h2 id='PrognCondDistribution'>Generating function for PrognCondDistribution-class</h2><span id='topic+PrognCondDistribution'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"PrognCondDistribution"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrognCondDistribution(Regr, Error,
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"))
             
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrognCondDistribution_+3A_regr">Regr</code></td>
<td>
<p>object of class <code>AbscontDistribution</code>;
the distribution of <code>X</code>. </p>
</td></tr>
<tr><td><code id="PrognCondDistribution_+3A_error">Error</code></td>
<td>
<p>object of class <code>AbscontDistribution</code>;
the distribution of <code>eps</code>. </p>
</td></tr>
<tr><td><code id="PrognCondDistribution_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code>.</p>
</td></tr> 
<tr><td><code id="PrognCondDistribution_+3A_lowertruncquantile">lowerTruncQuantile</code></td>
<td>
<p>lower quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="PrognCondDistribution_+3A_uppertruncquantile">upperTruncQuantile</code></td>
<td>
<p>upper quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="PrognCondDistribution_+3A_iqr.fac">IQR.fac</code></td>
<td>
<p>factor for scale based integration range (i.e.; 
median of the distribution <code class="reqn">\pm</code><code>IQR.fac</code><code class="reqn">\times</code>IQR).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For independent r.v.'s X,E with univariate, absolutely continuous 
(a.c.) distributions <code>Regr</code> and <code>Error</code>, respectively, 
<code>PrognCondDistribution()</code> returns the 
(factorized, conditional) posterior distribution of X given X+E=y.
as an object of class <code>PrognCondDistribution</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"PrognCondDistribution"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,
</p>


<h3>See Also</h3>

<p><code>PrognCondDistribution-class</code>; demo(&lsquo;<span class="file">Prognose.R</span>&rsquo;).</p>


<h3>Examples</h3>

<pre><code class='language-R'>PrognCondDistribution(Error = ConvexContamination(Norm(), Norm(4,1), size=0.1))
</code></pre>

<hr>
<h2 id='PrognCondDistribution-class'>Posterior distribution in convolution</h2><span id='topic+PrognCondDistribution-class'></span>

<h3>Description</h3>

<p>The posterior distribution of X given (X+E)=y</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code><a href="#topic+PrognCondDistribution">PrognCondDistribution</a></code>
where <code>Regr</code> and <code>error</code> are the respective (a.c.) distributions of X and E
and the other arguments control accuracy in integration.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cond</code>:</dt><dd><p>Object of class <code>"PrognCondition"</code>: condition </p>
</dd>
<dt><code>img</code>:</dt><dd><p>Object of class <code>"rSpace"</code>: the image space. </p>
</dd>
<dt><code>param</code>:</dt><dd><p>Object of class <code>"OptionalParameter"</code>: an 
optional parameter.</p>
</dd>
<dt><code>r</code>:</dt><dd><p>Object of class <code>"function"</code>: 
generates random numbers. </p>
</dd>
<dt><code>d</code>:</dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional conditional density function. </p>
</dd>
<dt><code>p</code>:</dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional conditional cumulative distribution function. </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Object of class <code>"OptionalFunction"</code>:
optional conditional quantile function. </p>
</dd>
<dt><code>gaps</code>:</dt><dd><p>(numeric) matrix or <code>NULL</code></p>
</dd>
<dt><code>.withArith</code>:</dt><dd><p>logical: used internally to issue warnings as to interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code>:</dt><dd><p>logical: used internally to issue warnings as to accuracy</p>
</dd>
<dt><code>.logExact</code>:</dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
log version of density, cdf, and quantile function</p>
</dd>
<dt><code>.lowerExact</code>:</dt><dd><p>logical: used internally to flag the case where there are explicit formulae for the
lower tail version of cdf and quantile function</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"AbscontCondDistribution"</code>, directly.<br />
Class <code>"Distribution"</code>, by classes <code>"UnivariateCondDistribution"</code> and <code>"AbscontCondDistribution"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+PrognCondition-class">PrognCondition-class</a></code>, <code><a href="#topic+UnivariateCondDistribution-class">UnivariateCondDistribution-class</a></code>
<code><a href="#topic+AbscontCondDistribution-class">AbscontCondDistribution-class</a></code>, <code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>PrognCondDistribution()</code></pre>

<hr>
<h2 id='PrognCondition-class'>Conditions of class 'PrognCondition'</h2><span id='topic+PrognCondition-class'></span><span id='topic+show+2CPrognCondition-method'></span><span id='topic+PrognCondition'></span>

<h3>Description</h3>

<p>The class <code>PrognCondition</code> realizes the condition that X+E=y in a convolution setup</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrognCondition(range = EuclideanSpace())</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrognCondition-class_+3A_range">range</code></td>
<td>
<p> an object of class <code>"EuclideanSpace"</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"PrognCondition"</code></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>PrognCondition(range)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: name of the PrognCondition</p>
</dd>
<dt><code>range</code></dt><dd><p>Object of class <code>"EuclideanSpace"</code>: range of the PrognCondition</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Condition"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "PrognCondition")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+PrognCondDistribution-class">PrognCondDistribution-class</a></code>,<code><a href="#topic+Condition-class">Condition-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>PrognCondition()</code></pre>

<hr>
<h2 id='TotalVarDist'>Generic function for the computation of the total variation distance of two distributions</h2><span id='topic+TotalVarDist'></span><span id='topic+TotalVarDist-methods'></span><span id='topic+TotalVarDist+2CAbscontDistribution+2CAbscontDistribution-method'></span><span id='topic+TotalVarDist+2CAbscontDistribution+2CDiscreteDistribution-method'></span><span id='topic+TotalVarDist+2CDiscreteDistribution+2CDiscreteDistribution-method'></span><span id='topic+TotalVarDist+2CDiscreteMVDistribution+2CDiscreteMVDistribution-method'></span><span id='topic+TotalVarDist+2CDiscreteDistribution+2CAbscontDistribution-method'></span><span id='topic+TotalVarDist+2CLatticeDistribution+2CDiscreteDistribution-method'></span><span id='topic+TotalVarDist+2CDiscreteDistribution+2CLatticeDistribution-method'></span><span id='topic+TotalVarDist+2CLatticeDistribution+2CLatticeDistribution-method'></span><span id='topic+TotalVarDist+2Cnumeric+2CDiscreteDistribution-method'></span><span id='topic+TotalVarDist+2CDiscreteDistribution+2Cnumeric-method'></span><span id='topic+TotalVarDist+2Cnumeric+2CAbscontDistribution-method'></span><span id='topic+TotalVarDist+2CAbscontDistribution+2Cnumeric-method'></span><span id='topic+TotalVarDist+2CAcDcLcDistribution+2CAcDcLcDistribution-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the total variation distance <code class="reqn">d_v</code>
of two distributions <code class="reqn">P</code> and <code class="reqn">Q</code> where the distributions may be 
defined for an arbitrary sample space <code class="reqn">(\Omega,{\cal A})</code>.
The total variation distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_v(P,Q)=\sup_{B\in{\cal A}}|P(B)-Q(B)|</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>TotalVarDist(e1, e2, ...)
## S4 method for signature 'AbscontDistribution,AbscontDistribution'
TotalVarDist(e1,e2, 
                        rel.tol=.Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,DiscreteDistribution'
TotalVarDist(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,AbscontDistribution'
TotalVarDist(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,DiscreteDistribution'
TotalVarDist(e1,e2, ...)
## S4 method for signature 'numeric,DiscreteDistribution'
TotalVarDist(e1, e2, ...)
## S4 method for signature 'DiscreteDistribution,numeric'
TotalVarDist(e1, e2, ...)
## S4 method for signature 'numeric,AbscontDistribution'
TotalVarDist(e1, e2, asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e2),
            up.discr = getUp(e2), h.smooth = getdistrExOption("hSmooth"),
            rel.tol = .Machine$double.eps^0.3, 
            TruncQuantile = getdistrOption("TruncQuantile"), IQR.fac = 15, ...,
            diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,numeric'
TotalVarDist(e1, e2, asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e1),
            up.discr = getUp(e1), h.smooth = getdistrExOption("hSmooth"),
            rel.tol = .Machine$double.eps^0.3, 
            TruncQuantile = getdistrOption("TruncQuantile"), IQR.fac = 15, ...,
            diagnostic = FALSE)
## S4 method for signature 'AcDcLcDistribution,AcDcLcDistribution'
TotalVarDist(e1, e2,                         
                        rel.tol = .Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TotalVarDist_+3A_e1">e1</code></td>
<td>
<p> object of class <code>"Distribution"</code> or <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_e2">e2</code></td>
<td>
<p> object of class <code>"Distribution"</code> or <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_asis.smooth.discretize">asis.smooth.discretize</code></td>
<td>
<p> possible methods are <code>"asis"</code>, 
<code>"smooth"</code> and <code>"discretize"</code>. Default is <code>"discretize"</code>.</p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_n.discr">n.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the number of lattice points 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_low.discr">low.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the lower end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_up.discr">up.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the upper end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_h.smooth">h.smooth</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"smooth"</code> &ndash; i.e., the empirical distribution of the provided 
data should be smoothed &ndash; one has to specify this parameter.</p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_rel.tol">rel.tol</code></td>
<td>
<p> relative accuracy requested in integration </p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_truncquantile">TruncQuantile</code></td>
<td>
<p>Quantile the quantile based integration bounds (see details)</p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_iqr.fac">IQR.fac</code></td>
<td>
<p>Factor for the scale based integration bounds (see details)</p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_...">...</code></td>
<td>
<p> further arguments to be used in particular methods &ndash; (in package <span class="pkg">distrEx</span>: just
used for distributions with a.c. parts, where it is used to pass on arguments
to <code>distrExIntegrate</code>). </p>
</td></tr>
<tr><td><code id="TotalVarDist_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For distances between absolutely continuous distributions, we use numerical
integration; to determine sensible bounds we proceed as follows:
by means of <code>min(getLow(e1,eps=TruncQuantile),getLow(e2,eps=TruncQuantile))</code>, 
<code>max(getUp(e1,eps=TruncQuantile),getUp(e2,eps=TruncQuantile))</code> we determine
quantile based bounds <code>c(low.0,up.0)</code>, and by means of
<code>s1 &lt;- max(IQR(e1),IQR(e2));</code> <code>m1&lt;- median(e1);</code> 
<code>m2 &lt;- median(e2)</code>
and <code>low.1 &lt;- min(m1,m2)-s1*IQR.fac</code>, <code>up.1 &lt;- max(m1,m2)+s1*IQR.fac</code>
we determine scale based bounds; these are combined by
<code>low &lt;- max(low.0,low.1)</code>, <code>up &lt;- max(up.0,up1)</code>.
</p>
<p>In case we want to compute the total variation distance between (empirical) data
and an abs. cont. distribution, we can specify the parameter <code>asis.smooth.discretize</code>
to avoid trivial distances (distance = 1).
</p>
<p>Using <code>asis.smooth.discretize = "discretize"</code>, which is the default,
leads to a discretization of the provided abs. cont. distribution and 
the distance is computed between the provided data and the discretized
distribution.
</p>
<p>Using <code>asis.smooth.discretize = "smooth"</code> causes smoothing of the
empirical distribution of the provided data. This is, the empirical
data is convoluted with the normal distribution <code>Norm(mean = 0, sd = h.smooth)</code>
which leads to an abs. cont. distribution. Afterwards the distance 
between the smoothed empirical distribution and the provided abs. cont.
distribution is computed.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p> Total variation distance of <code>e1</code> and <code>e2</code> </p>


<h3>Methods</h3>


<dl>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>total variation distance of two absolutely continuous 
univariate distributions which is computed using <code>distrExIntegrate</code>.
</p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>total variation distance of absolutely continuous and discrete
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>total variation distance of two discrete univariate distributions
which is computed using <code>support</code> and <code>sum</code>.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>total variation distance of discrete and absolutely continuous 
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;DiscreteDistribution&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and a discrete 
distribution.
</p>
</dd>
<dt>e1 = &quot;DiscreteDistribution&quot;, e2 = &quot;numeric&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and a discrete 
distribution.
</p>
</dd>
<dt>e1 = &quot;numeric&quot;, e2 = &quot;AbscontDistribution&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = &quot;AbscontDistribution&quot;, e1 = &quot;numeric&quot;:</dt><dd>
<p>Total variation distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = &quot;AcDcLcDistribution&quot;, e2 = &quot;AcDcLcDistribution&quot;:</dt><dd>
<p>Total variation distance of mixed discrete and absolutely continuous
univariate distributions.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TotalVarDist-methods">TotalVarDist-methods</a></code>, <code><a href="#topic+ContaminationSize">ContaminationSize</a></code>, 
<code><a href="#topic+KolmogorovDist">KolmogorovDist</a></code>, <code><a href="#topic+HellingerDist">HellingerDist</a></code>, 
<code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>TotalVarDist(Norm(), UnivarMixingDistribution(Norm(1,2),Norm(0.5,3),
                 mixCoeff=c(0.2,0.8)))
TotalVarDist(Norm(), Td(10))
TotalVarDist(Norm(mean = 50, sd = sqrt(25)), Binom(size = 100)) # mutually singular
TotalVarDist(Pois(10), Binom(size = 20)) 

x &lt;- rnorm(100)
TotalVarDist(Norm(), x)
TotalVarDist(x, Norm(), asis.smooth.discretize = "smooth")

y &lt;- (rbinom(50, size = 20, prob = 0.5)-10)/sqrt(5)
TotalVarDist(y, Norm())
TotalVarDist(y, Norm(), asis.smooth.discretize = "smooth")

TotalVarDist(rbinom(50, size = 20, prob = 0.5), Binom(size = 20, prob = 0.5))
</code></pre>

<hr>
<h2 id='UnivariateCondDistribution-class'>Univariate conditional distribution</h2><span id='topic+UnivariateCondDistribution-class'></span><span id='topic+cond'></span><span id='topic+cond+2CUnivariateCondDistribution-method'></span><span id='topic+plot+2CUnivariateCondDistribution-method'></span><span id='topic+show+2CUnivariateCondDistribution-method'></span>

<h3>Description</h3>

<p>Class of univariate conditional distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("UnivariateCondDistribution", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cond</code></dt><dd><p>Object of class <code>"Condition"</code>: condition </p>
</dd>
<dt><code>img</code></dt><dd><p>Object of class <code>"rSpace"</code>: the image space. </p>
</dd>
<dt><code>param</code></dt><dd><p>Object of class <code>"OptionalParameter"</code>: an 
optional parameter.</p>
</dd>
<dt><code>r</code></dt><dd><p>Object of class <code>"function"</code>: 
generates random numbers. </p>
</dd>
<dt><code>d</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional conditional density function. </p>
</dd>
<dt><code>p</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>: 
optional conditional cumulative distribution function. </p>
</dd>
<dt><code>q</code></dt><dd><p>Object of class <code>"OptionalFunction"</code>:
optional conditional quantile function. </p>
</dd>
<dt><code>.withArith</code></dt><dd><p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt><dd><p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt><dd><p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt><dd><p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"UnivariateDistribution"</code>, directly.<br />
Class <code>"Distribution"</code>, by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>cond</dt><dd><p><code>signature(object = "UnivariateCondDistribution")</code>:
accessor function for slot <code>cond</code>.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "UnivariateCondDistribution")</code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(object = "UnivariateCondDistribution")</code>:
not yet implemented.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("UnivariateCondDistribution")</code></pre>

<hr>
<h2 id='var'>Generic Functions for the Computation of Functionals</h2><span id='topic+var'></span><span id='topic+var-methods'></span><span id='topic+var+2CANY-method'></span><span id='topic+var+2CUnivariateDistribution-method'></span><span id='topic+var+2CAffLinDistribution-method'></span><span id='topic+var+2CAffLinAbscontDistribution-method'></span><span id='topic+var+2CAffLinDiscreteDistribution-method'></span><span id='topic+var+2CAffLinLatticeDistribution-method'></span><span id='topic+var+2CCompoundDistribution-method'></span><span id='topic+var+2CArcsine-method'></span><span id='topic+var+2CBeta-method'></span><span id='topic+var+2CBinom-method'></span><span id='topic+var+2CCauchy-method'></span><span id='topic+var+2CChisq-method'></span><span id='topic+var+2CDirac-method'></span><span id='topic+var+2CDExp-method'></span><span id='topic+var+2CExp-method'></span><span id='topic+var+2CFd-method'></span><span id='topic+var+2CGammad-method'></span><span id='topic+var+2CGeom-method'></span><span id='topic+var+2CHyper-method'></span><span id='topic+var+2CLogis-method'></span><span id='topic+var+2CLnorm-method'></span><span id='topic+var+2CNbinom-method'></span><span id='topic+var+2CNorm-method'></span><span id='topic+var+2CPois-method'></span><span id='topic+var+2CUnif-method'></span><span id='topic+var+2CWeibull-method'></span><span id='topic+var+2CTd-method'></span><span id='topic+sd'></span><span id='topic+sd-methods'></span><span id='topic+sd+2CUnivariateDistribution-method'></span><span id='topic+sd+2CNorm-method'></span><span id='topic+median'></span><span id='topic+median+2CANY-method'></span><span id='topic+median-methods'></span><span id='topic+median+2CUnivariateDistribution-method'></span><span id='topic+median+2CUnivariateCondDistribution-method'></span><span id='topic+median+2CAffLinDistribution-method'></span><span id='topic+median+2CAffLinAbscontDistribution-method'></span><span id='topic+median+2CAffLinDiscreteDistribution-method'></span><span id='topic+median+2CAffLinLatticeDistribution-method'></span><span id='topic+median+2CArcsine-method'></span><span id='topic+median+2CCauchy-method'></span><span id='topic+median+2CDirac-method'></span><span id='topic+median+2CDExp-method'></span><span id='topic+median+2CExp-method'></span><span id='topic+median+2CGeom-method'></span><span id='topic+median+2CLogis-method'></span><span id='topic+median+2CLnorm-method'></span><span id='topic+median+2CNorm-method'></span><span id='topic+median+2CUnif-method'></span><span id='topic+IQR'></span><span id='topic+IQR-methods'></span><span id='topic+IQR+2CANY-method'></span><span id='topic+IQR+2CUnivariateDistribution-method'></span><span id='topic+IQR+2CUnivariateCondDistribution-method'></span><span id='topic+IQR+2CAffLinDistribution-method'></span><span id='topic+IQR+2CAffLinAbscontDistribution-method'></span><span id='topic+IQR+2CAffLinDiscreteDistribution-method'></span><span id='topic+IQR+2CAffLinLatticeDistribution-method'></span><span id='topic+IQR+2CDiscreteDistribution-method'></span><span id='topic+IQR+2CArcsine-method'></span><span id='topic+IQR+2CCauchy-method'></span><span id='topic+IQR+2CDirac-method'></span><span id='topic+IQR+2CDExp-method'></span><span id='topic+IQR+2CExp-method'></span><span id='topic+IQR+2CGeom-method'></span><span id='topic+IQR+2CLogis-method'></span><span id='topic+IQR+2CNorm-method'></span><span id='topic+IQR+2CUnif-method'></span><span id='topic+mad'></span><span id='topic+mad+2CANY-method'></span><span id='topic+mad-methods'></span><span id='topic+mad+2CUnivariateDistribution-method'></span><span id='topic+mad+2CAffLinDistribution-method'></span><span id='topic+mad+2CAffLinAbscontDistribution-method'></span><span id='topic+mad+2CAffLinDiscreteDistribution-method'></span><span id='topic+mad+2CAffLinLatticeDistribution-method'></span><span id='topic+mad+2CCauchy-method'></span><span id='topic+mad+2CDirac-method'></span><span id='topic+mad+2CDExp-method'></span><span id='topic+mad+2CExp-method'></span><span id='topic+mad+2CGeom-method'></span><span id='topic+mad+2CLogis-method'></span><span id='topic+mad+2CNorm-method'></span><span id='topic+mad+2CUnif-method'></span><span id='topic+mad+2CArcsine-method'></span><span id='topic+skewness'></span><span id='topic+skewness-methods'></span><span id='topic+skewness+2CANY-method'></span><span id='topic+skewness+2CUnivariateDistribution-method'></span><span id='topic+skewness+2CAffLinDistribution-method'></span><span id='topic+skewness+2CAffLinAbscontDistribution-method'></span><span id='topic+skewness+2CAffLinDiscreteDistribution-method'></span><span id='topic+skewness+2CAffLinLatticeDistribution-method'></span><span id='topic+skewness+2CArcsine-method'></span><span id='topic+skewness+2CBeta-method'></span><span id='topic+skewness+2CBinom-method'></span><span id='topic+skewness+2CCauchy-method'></span><span id='topic+skewness+2CChisq-method'></span><span id='topic+skewness+2CDirac-method'></span><span id='topic+skewness+2CDExp-method'></span><span id='topic+skewness+2CExp-method'></span><span id='topic+skewness+2CFd-method'></span><span id='topic+skewness+2CGammad-method'></span><span id='topic+skewness+2CGeom-method'></span><span id='topic+skewness+2CHyper-method'></span><span id='topic+skewness+2CLogis-method'></span><span id='topic+skewness+2CLnorm-method'></span><span id='topic+skewness+2CNbinom-method'></span><span id='topic+skewness+2CNorm-method'></span><span id='topic+skewness+2CPois-method'></span><span id='topic+skewness+2CUnif-method'></span><span id='topic+skewness+2CWeibull-method'></span><span id='topic+skewness+2CTd-method'></span><span id='topic+kurtosis'></span><span id='topic+kurtosis-methods'></span><span id='topic+kurtosis+2CANY-method'></span><span id='topic+kurtosis+2CUnivariateDistribution-method'></span><span id='topic+kurtosis+2CAffLinDistribution-method'></span><span id='topic+kurtosis+2CAffLinAbscontDistribution-method'></span><span id='topic+kurtosis+2CAffLinDiscreteDistribution-method'></span><span id='topic+kurtosis+2CAffLinLatticeDistribution-method'></span><span id='topic+kurtosis+2CArcsine-method'></span><span id='topic+kurtosis+2CBeta-method'></span><span id='topic+kurtosis+2CBinom-method'></span><span id='topic+kurtosis+2CCauchy-method'></span><span id='topic+kurtosis+2CChisq-method'></span><span id='topic+kurtosis+2CDirac-method'></span><span id='topic+kurtosis+2CDExp-method'></span><span id='topic+kurtosis+2CExp-method'></span><span id='topic+kurtosis+2CFd-method'></span><span id='topic+kurtosis+2CGammad-method'></span><span id='topic+kurtosis+2CGeom-method'></span><span id='topic+kurtosis+2CHyper-method'></span><span id='topic+kurtosis+2CLogis-method'></span><span id='topic+kurtosis+2CLnorm-method'></span><span id='topic+kurtosis+2CNbinom-method'></span><span id='topic+kurtosis+2CNorm-method'></span><span id='topic+kurtosis+2CPois-method'></span><span id='topic+kurtosis+2CUnif-method'></span><span id='topic+kurtosis+2CWeibull-method'></span><span id='topic+kurtosis+2CTd-method'></span>

<h3>Description</h3>

<p>Generic functions for the computation of functionals on distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IQR(x, ...)

## S4 method for signature 'UnivariateDistribution'
IQR(x)
## S4 method for signature 'UnivariateCondDistribution'
IQR(x,cond)
## S4 method for signature 'AffLinDistribution'
IQR(x)
## S4 method for signature 'DiscreteDistribution'
IQR(x)
## S4 method for signature 'Arcsine'
IQR(x)
## S4 method for signature 'Cauchy'
IQR(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Dirac'
IQR(x)
## S4 method for signature 'DExp'
IQR(x)
## S4 method for signature 'Exp'
IQR(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Geom'
IQR(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Logis'
IQR(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Norm'
IQR(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Unif'
IQR(x, propagate.names=getdistrExOption("propagate.names.functionals"))

median(x, ...)

## S4 method for signature 'UnivariateDistribution'
median(x)
## S4 method for signature 'UnivariateCondDistribution'
median(x,cond)
## S4 method for signature 'AffLinDistribution'
median(x)
## S4 method for signature 'Arcsine'
median(x)
## S4 method for signature 'Cauchy'
median(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Dirac'
median(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'DExp'
median(x)
## S4 method for signature 'Exp'
median(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Geom'
median(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Logis'
median(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Lnorm'
median(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Norm'
median(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Unif'
median(x, propagate.names=getdistrExOption("propagate.names.functionals"))

mad(x, ...)

## S4 method for signature 'UnivariateDistribution'
mad(x)
## S4 method for signature 'AffLinDistribution'
mad(x)
## S4 method for signature 'Cauchy'
mad(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Dirac'
mad(x)
## S4 method for signature 'DExp'
mad(x)
## S4 method for signature 'Exp'
mad(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Geom'
mad(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Logis'
mad(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Norm'
mad(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Unif'
mad(x, propagate.names=getdistrExOption("propagate.names.functionals"))
## S4 method for signature 'Arcsine'
mad(x)

sd(x, ...)

## S4 method for signature 'UnivariateDistribution'
sd(x, fun, cond, withCond, useApply,
          propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Norm'
sd(x, fun, cond, withCond = FALSE, useApply = TRUE,
          propagate.names=getdistrExOption("propagate.names.functionals"), ...)

var(x, ...)

## S4 method for signature 'UnivariateDistribution'
var(x, fun, cond, withCond, useApply, ...)
## S4 method for signature 'AffLinDistribution'
var(x, fun, cond, withCond, useApply, ...)
## S4 method for signature 'CompoundDistribution'
var(x, ...)
## S4 method for signature 'Arcsine'
var(x, ...)
## S4 method for signature 'Binom'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Beta'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"),...)
## S4 method for signature 'Cauchy'
var(x, ...)
## S4 method for signature 'Chisq'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Dirac'
var(x, ...)
## S4 method for signature 'DExp'
var(x, ...)
## S4 method for signature 'Exp'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Fd'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Gammad'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Geom'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Hyper'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Logis'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Lnorm'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Nbinom'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Norm'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Pois'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Td'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Unif'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Weibull'
var(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)

skewness(x, ...)
## S4 method for signature 'UnivariateDistribution'
skewness(x, fun, cond, withCond, useApply, ...)
## S4 method for signature 'AffLinDistribution'
skewness(x, fun, cond, withCond, useApply, ...)
## S4 method for signature 'Arcsine'
skewness(x, ...)
## S4 method for signature 'Binom'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Beta'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Cauchy'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Chisq'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Dirac'
skewness(x, ...)
## S4 method for signature 'DExp'
skewness(x, ...)
## S4 method for signature 'Exp'
skewness(x, ...)
## S4 method for signature 'Fd'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Gammad'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Geom'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Hyper'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Logis'
skewness(x, ...)
## S4 method for signature 'Lnorm'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Nbinom'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Norm'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Pois'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Td'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Unif'
skewness(x,  ...)
## S4 method for signature 'Weibull'
skewness(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)

kurtosis(x, ...)
## S4 method for signature 'UnivariateDistribution'
kurtosis(x, fun, cond, withCond, useApply, ...)
## S4 method for signature 'AffLinDistribution'
kurtosis(x, fun, cond, withCond, useApply, ...)
## S4 method for signature 'Arcsine'
kurtosis(x, ...)
## S4 method for signature 'Binom'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Beta'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Cauchy'
kurtosis(x, ...)
## S4 method for signature 'Chisq'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Dirac'
kurtosis(x, ...)
## S4 method for signature 'DExp'
kurtosis(x, ...)
## S4 method for signature 'Exp'
kurtosis(x, ...)
## S4 method for signature 'Fd'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Gammad'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Geom'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Hyper'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Logis'
kurtosis(x, ...)
## S4 method for signature 'Lnorm'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Nbinom'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"),...)
## S4 method for signature 'Norm'
kurtosis(x, ...)
## S4 method for signature 'Pois'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"),...)
## S4 method for signature 'Td'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"),...)
## S4 method for signature 'Unif'
kurtosis(x, ...)
## S4 method for signature 'Weibull'
kurtosis(x, propagate.names=getdistrExOption("propagate.names.functionals"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_+3A_x">x</code></td>
<td>
<p> object of class <code>"UnivariateDistribution"</code></p>
</td></tr>
<tr><td><code id="var_+3A_fun">fun</code></td>
<td>
<p> if missing the (conditional) variance resp. standard deviation is computed
else the (conditional) variance resp. standard deviation of <code>fun</code> is computed. </p>
</td></tr>
<tr><td><code id="var_+3A_cond">cond</code></td>
<td>
<p> if not missing the conditional variance resp. standard deviation  
given <code>cond</code> is computed. </p>
</td></tr>
<tr><td><code id="var_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>fun</code> or <code>E</code></p>
</td></tr>
<tr><td><code id="var_+3A_useapply">useApply</code></td>
<td>
<p> logical: should <code>sapply</code>, respectively <code>apply</code> 
be used to evaluate <code>fund</code>.</p>
</td></tr>
<tr><td><code id="var_+3A_withcond">withCond</code></td>
<td>
<p> logical: is <code>cond</code> in the argument list of <code>fun</code>. </p>
</td></tr>
<tr><td><code id="var_+3A_propagate.names">propagate.names</code></td>
<td>
<p> logical: should names obtained from parameter
coordinates be propagated to return values of specific S4 methods
for functionals; defaults to the value of the respective
<code>distrExoption</code> <code>propagate.names.functionals</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the corresponding functional at the distribution in the argument is computed.
</p>


<h3>Methods</h3>


<dl>
<dt><code>var</code>, <code>signature(x = "Any")</code>:</dt><dd>
<p>interface to the <span class="pkg">stats</span>-function <code>var</code> &mdash; see <code><a href="stats.html#topic+cor">var</a></code>
resp. <code>help(var,package="stats")</code>.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "UnivariateDistribution")</code>:</dt><dd> 
<p>variance of univariate distributions using corresponding <code>E()</code>-method.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "AffLinDistribution")</code>:</dt><dd> 
<p>if arguments <code>fun</code>, <code>cond</code> are missing: <code>x@a^2 * var(x@X0)</code>
else uses method for <code>signature(x = "UnivariateDistribution")</code></p>
</dd>
<dt><code>var</code>, <code>signature(x = "CompoundDistribution")</code>:</dt><dd> 
<p>if we are in i.i.d. situation (i.e., slot <code>SummandsDistr</code> is of
class <code>UnivariateDistribution</code>) the formula 
<code class="reqn">{\rm E}[N]{\rm var}[S]+({\rm E}[S]^2+{\rm var}(S)){\rm var}(N)</code> 
for <code class="reqn">N</code> the frequency distribution and
<code class="reqn">S</code> the summand distribution; else we coerce to 
<code>"UnivarLebDecDistribution"</code>.
</p>
</dd>
<dt><code>sd</code>, <code>signature(x = "Any")</code>:</dt><dd>
<p>interface to the <span class="pkg">stats</span>-function <code>sd</code> &mdash; see <code><a href="stats.html#topic+sd">sd</a></code>
resp. <code>help(sd,package="stats")</code>.</p>
</dd>
<dt><code>sd</code>, <code>signature(x = "NormParameter")</code>:</dt><dd>
<p>returns the slot <code>sd</code> of the parameter of a normal distribution &mdash; see 
<code><a href="distr.html#topic+sd-methods">sd</a></code> resp. <code>help(sd,package="distr")</code>.</p>
</dd>    
<dt><code>sd</code>, <code>signature(x = "Norm")</code>:</dt><dd>
<p>returns the slot <code>sd</code> of the parameter of a normal distribution &mdash; see 
<code><a href="distr.html#topic+sd-methods">sd</a></code> resp. <code>help(sd,package="distr")</code>.</p>
</dd>    
<dt><code>sd</code>, <code>signature(x = "UnivariateDistribution")</code>:</dt><dd> 
<p>standard deviation of univariate distributions using corresponding <code>E()</code>-method.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Any")</code>:</dt><dd>
<p>interface to the <span class="pkg">stats</span>-function <code>IQR</code> &mdash; see <code><a href="stats.html#topic+IQR">IQR</a></code>
resp. <code>help(IQR,package="stats")</code>.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "UnivariateDistribution")</code>:</dt><dd> 
<p>interquartile range of univariate distributions using corresponding <code>q()</code>-method.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "UnivariateCondDistribution")</code>:</dt><dd> 
<p>interquartile range of univariate conditional distributions using corresponding <code>q()</code>-method. </p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "DiscreteDistribution")</code>:</dt><dd> 
<p>interquartile range of discrete distributions using corresponding 
<code>q()</code>-method but taking care that between upper and lower quartile 
there is 50% probability </p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "AffLinDistribution")</code>:</dt><dd><p><code>abs(x@a) * IQR(x@X0)</code></p>
</dd>
<dt><code>median</code>, <code>signature(x = "Any")</code>:</dt><dd>
<p>interface to the <span class="pkg">stats</span>-function <code>median</code> &mdash; see <code><a href="stats.html#topic+median">median</a></code>
resp. <code>help(var,package="stats")</code>.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "UnivariateDistribution")</code>:</dt><dd> 
<p>median of univariate distributions using corresponding <code>q()</code>-method. </p>
</dd>
<dt><code>median</code>, <code>signature(x = "UnivariateCondDistribution")</code>:</dt><dd> 
<p>median of univariate conditional distributions using corresponding <code>q()</code>-method. </p>
</dd>
<dt><code>median</code>, <code>signature(x = "AffLinDistribution")</code>:</dt><dd><p><code>x@a * median(x@X0) + x@b </code></p>
</dd>
<dt><code>mad</code>, <code>signature(x = "Any")</code>:</dt><dd>
<p>interface to the <span class="pkg">stats</span>-function <code>mad</code> &mdash; see <code><a href="stats.html#topic+mad">mad</a></code>.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "UnivariateDistribution")</code>:</dt><dd> 
<p>mad of univariate distributions using corresponding <code>q()</code>-method applied to <code>abs(x-median(x))</code>.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "AffLinDistribution")</code>:</dt><dd><p><code>abs(x@a) * mad(x@X0)</code></p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Any")</code>:</dt><dd>
<p>bias free estimation of skewness under normal distribution (default) as
well as sample version (by argument <code>sample.version = TRUE</code>).</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "UnivariateDistribution")</code>:</dt><dd> 
<p>skewness of univariate distributions using corresponding <code>E()</code>-method.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "AffLinDistribution")</code>:</dt><dd> 
<p>if arguments <code>fun</code>, <code>cond</code> are missing: <code>skewness(x@X0)</code>
else uses method for <code>signature(x = "UnivariateDistribution")</code></p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Any")</code>:</dt><dd>
<p>bias free estimation of kurtosis under normal distribution (default) as
well as sample version (by argument <code>sample.version = TRUE</code>).</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "UnivariateDistribution")</code>:</dt><dd> 
<p>kurtosis of univariate distributions using corresponding <code>E()</code>-method.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "AffLinDistribution")</code>:</dt><dd> 
<p>if arguments <code>fun</code>, <code>cond</code> are missing: <code>kurtosis(x@X0)</code>
else uses method for <code>signature(x = "UnivariateDistribution")</code></p>
</dd>
<dt><code>var</code>, <code>signature(x = "Arcsine")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Beta")</code>:</dt><dd> 
<p>for noncentrality 0 exact evaluation using explicit expressions.</p>
</dd>  
<dt><code>var</code>, <code>signature(x = "Binom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Cauchy")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Chisq")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Dirac")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "DExp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Exp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Fd")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Gammad")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Geom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Hyper")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Logis")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Lnorm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Nbinom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Norm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Pois")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Td")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Unif")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>var</code>, <code>signature(x = "Weibull")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Arcsine")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Cauchy")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Dirac")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "DExp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Exp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Geom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Logis")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Norm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>IQR</code>, <code>signature(x = "Unif")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Arcsine")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Cauchy")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Dirac")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "DExp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Exp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Geom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Logis")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Lnorm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Norm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>median</code>, <code>signature(x = "Unif")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "Arcsine")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "Cauchy")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "Dirac")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "DExp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "Exp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "Geom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "Logis")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "Norm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>mad</code>, <code>signature(x = "Unif")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Arcsine")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Beta")</code>:</dt><dd> 
<p>for noncentrality 0 exact evaluation using explicit expressions.</p>
</dd>  
<dt><code>skewness</code>, <code>signature(x = "Binom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Cauchy")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Chisq")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Dirac")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "DExp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Exp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Fd")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Gammad")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Geom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Hyper")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Logis")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Lnorm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Nbinom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Norm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Pois")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Td")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Unif")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>skewness</code>, <code>signature(x = "Weibull")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Arcsine")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Beta")</code>:</dt><dd> 
<p>for noncentrality 0 exact evaluation using explicit expressions.</p>
</dd>  
<dt><code>kurtosis</code>, <code>signature(x = "Binom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Cauchy")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Chisq")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Dirac")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "DExp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Exp")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Fd")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Gammad")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Geom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Hyper")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Logis")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Lnorm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Nbinom")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Norm")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Pois")</code>:</dt><dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Td")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Unif")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt><code>kurtosis</code>, <code>signature(x = "Weibull")</code>:</dt><dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
</dl>


<h3>Caveat</h3>

<p>If any of the packages <span class="pkg">e1071</span>, <span class="pkg">moments</span>, <span class="pkg">fBasics</span> is to be used together with <span class="pkg">distrEx</span> 
the latter must be attached <em>after</em> any of the first mentioned. Otherwise <code>kurtosis()</code> and <code>skewness()</code>
defined as <em>methods</em> in <span class="pkg">distrEx</span> may get masked.<br />  
To re-mask, you may use 
<code>kurtosis &lt;- distrEx::kurtosis; skewness &lt;- distrEx::skewness</code>. 
See also <code>distrExMASK()</code>.
</p>


<h3>Acknowledgement</h3>

<p>G. Jay Kerns, <a href="mailto:gkerns@ysu.edu">gkerns@ysu.edu</a>, has provided a major contribution,
in particular the functionals <code>skewness</code> and <code>kurtosis</code> are due to him.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+distrExIntegrate">distrExIntegrate</a></code>, <code><a href="#topic+m1df">m1df</a></code>, <code><a href="#topic+m2df">m2df</a></code>,
<code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code>,<br />
<code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+cor">var</a></code>, <code><a href="stats.html#topic+IQR">IQR</a></code>,<br />
<code><a href="stats.html#topic+median">median</a></code>, <code><a href="stats.html#topic+mad">mad</a></code>,  <code><a href="distr.html#topic+sd-methods">sd</a></code>,<br />
<code><a href="robustbase.html#topic+Sn">Sn</a></code>,  <code><a href="robustbase.html#topic+Qn">Qn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Variance of Exp(1) distribution
var(Exp())

#median(Exp())
IQR(Exp())
mad(Exp())

# Variance of N(1,4)^2
var(Norm(mean=1, sd=2), fun = function(x){x^2})
var(Norm(mean=1, sd=2), fun = function(x){x^2}, useApply = FALSE)

## sd -- may equivalently be replaced by var
sd(Pois()) ## uses explicit terms
sd(as(Pois(),"DiscreteDistribution")) ## uses sums
sd(as(Pois(),"UnivariateDistribution")) ## uses simulations
sd(Norm(mean=2), fun = function(x){2*x^2}) ## uses simulations
#
mad(sin(exp(Norm()+2*Pois()))) ## weird
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
