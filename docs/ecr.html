<!DOCTYPE html><html><head><title>Help for package ecr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ecr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addUnionGroup'><p>Grouping helpers</p></a></li>
<li><a href='#approximateNadirPoint'><p>Reference point approximations.</p></a></li>
<li><a href='#approximateRefPoints'><p>Helper function to estimate reference points.</p></a></li>
<li><a href='#approximateRefSets'><p>Helper function to estimate reference set(s).</p></a></li>
<li><a href='#asemoa'><p>Implementation of the NSGA-II EMOA algorithm by Deb.</p></a></li>
<li><a href='#categorize'><p>Assign group membership based on another group membership.</p></a></li>
<li><a href='#computeAverageHausdorffDistance'><p>Average Hausdorff Distance computation.</p></a></li>
<li><a href='#computeCrowdingDistance'><p>Compute the crowding distance of a set of points.</p></a></li>
<li><a href='#computeDistanceFromPointToSetOfPoints'><p>Computes distance between a single point and set of points.</p></a></li>
<li><a href='#computeDominanceRanking'><p>Ranking of approximation sets.</p></a></li>
<li><a href='#computeGenerationalDistance'><p>Computes Generational Distance.</p></a></li>
<li><a href='#computeHV'><p>Functions for the calculation of the dominated hypervolume (contribution).</p></a></li>
<li><a href='#computeIndicators'><p>Computation of EMOA performance indicators.</p></a></li>
<li><a href='#computeInvertedGenerationalDistance'><p>Computes Inverted Generational Distance.</p></a></li>
<li><a href='#dominated'><p>Check for pareto dominance.</p></a></li>
<li><a href='#dominates'><p>Dominance relation check.</p></a></li>
<li><a href='#doNondominatedSorting'><p>Fast non-dominated sorting algorithm.</p></a></li>
<li><a href='#ecr'><p>Interface to ecr similar to the optim function.</p></a></li>
<li><a href='#ecr_parallelization'><p>Parallelization in ecr</p></a></li>
<li><a href='#ecr_result'><p>Result object.</p></a></li>
<li><a href='#emoaIndEps'><p>EMOA performance indicators</p></a></li>
<li><a href='#evaluateFitness'><p>Computes the fitness value(s) for each individual of a given set.</p></a></li>
<li><a href='#explode'><p>Explode/implode data frame column(s).</p></a></li>
<li><a href='#filterDuplicated'><p>Filter approximation sets by duplicate objective vectors.</p></a></li>
<li><a href='#generateOffspring'><p>Helper functions for offspring generation</p></a></li>
<li><a href='#generatesMultipleChildren'><p>Does the recombinator generate multiple children?</p></a></li>
<li><a href='#generators'><p>Population generators</p></a></li>
<li><a href='#getFront'><p>Extract fitness values from Pareto archive.</p></a></li>
<li><a href='#getIndividuals'><p>Extract individuals from Pareto archive.</p></a></li>
<li><a href='#getNumberOfChildren'><p>Number of children</p></a></li>
<li><a href='#getNumberOfParentsNeededForMating'><p>Number of parents  needed for mating</p></a></li>
<li><a href='#getPopulationFitness'><p>Access to logged population fitness.</p></a></li>
<li><a href='#getPopulations'><p>Access to logged populations.</p></a></li>
<li><a href='#getSize'><p>Get size of Pareto-archive.</p></a></li>
<li><a href='#getStatistics'><p>Access the logged statistics.</p></a></li>
<li><a href='#getSupportedRepresentations'><p>Get supported representations.</p></a></li>
<li><a href='#initECRControl'><p>Control object generator.</p></a></li>
<li><a href='#initLogger'><p>Initialize a log object.</p></a></li>
<li><a href='#initParetoArchive'><p>Initialize Pareto Archive.</p></a></li>
<li><a href='#initPopulation'><p>Helper function to build initial population.</p></a></li>
<li><a href='#is.supported'><p>Check if ecr operator supports given representation.</p></a></li>
<li><a href='#isEcrOperator'><p>Check if given function is an ecr operator.</p></a></li>
<li><a href='#makeECRMonitor'><p>Factory method for monitor objects.</p></a></li>
<li><a href='#makeEMOAIndicator'><p>Constructor for EMOA indicators.</p></a></li>
<li><a href='#makeMutator'><p>Construct a mutation operator.</p></a></li>
<li><a href='#makeOperator'><p>Construct evolutionary operator.</p></a></li>
<li><a href='#makeOptimizationTask'><p>Creates an optimization task.</p></a></li>
<li><a href='#makeRecombinator'><p>Construct a recombination operator.</p></a></li>
<li><a href='#makeSelector'><p>Construct a selection operator.</p></a></li>
<li><a href='#makeTerminator'><p>Generate stopping condition.</p></a></li>
<li><a href='#mcMST'><p>mcMST</p></a></li>
<li><a href='#mutBitflip'><p>Bitplip mutator.</p></a></li>
<li><a href='#mutGauss'><p>Gaussian mutator.</p></a></li>
<li><a href='#mutInsertion'><p>Insertion mutator.</p></a></li>
<li><a href='#mutInversion'><p>Inversion mutator.</p></a></li>
<li><a href='#mutJump'><p>Jump mutator.</p></a></li>
<li><a href='#mutPolynomial'><p>Polynomial mutation.</p></a></li>
<li><a href='#mutScramble'><p>Scramble mutator.</p></a></li>
<li><a href='#mutSwap'><p>Swap mutator.</p></a></li>
<li><a href='#mutUniform'><p>Uniform mutator.</p></a></li>
<li><a href='#niceCellFormater'><p>Formatter for table cells of LaTeX tables.</p></a></li>
<li><a href='#normalize'><p>Normalize approximations set(s).</p></a></li>
<li><a href='#nsga2'><p>Implementation of the NSGA-II EMOA algorithm by Deb.</p></a></li>
<li><a href='#plotDistribution'><p>Plot distribution of EMOA indicators.</p></a></li>
<li><a href='#plotFront'><p>Draw scatterplot of Pareto-front approximation</p></a></li>
<li><a href='#plotHeatmap'><p>Plot heatmap.</p></a></li>
<li><a href='#plotScatter2d'><p>Visualize bi-objective Pareto-front approximations.</p></a></li>
<li><a href='#plotScatter3d'><p>Visualize three-objective Pareto-front approximations.</p></a></li>
<li><a href='#plotStatistics'><p>Generate line plot of logged statistics.</p></a></li>
<li><a href='#recCrossover'><p>One-point crossover recombinator.</p></a></li>
<li><a href='#recIntermediate'><p>Indermediate recombinator.</p></a></li>
<li><a href='#recOX'><p>Ordered-Crossover (OX) recombinator.</p></a></li>
<li><a href='#recPMX'><p>Partially-Mapped-Crossover (PMX) recombinator.</p></a></li>
<li><a href='#recSBX'><p>Simulated Binary Crossover (SBX) recombinator.</p></a></li>
<li><a href='#recUnifCrossover'><p>Uniform crossover recombinator.</p></a></li>
<li><a href='#reduceToSingleDataFrame'><p>Combine multiple data frames into a single data.frame.</p></a></li>
<li><a href='#registerECROperator'><p>Register operators to control object.</p></a></li>
<li><a href='#replace'><p>(mu + lambda) selection</p></a></li>
<li><a href='#selDomHV'><p>Dominated Hypervolume selector.</p></a></li>
<li><a href='#select'><p>Select individuals.</p></a></li>
<li><a href='#selGreedy'><p>Simple selector.</p></a></li>
<li><a href='#selNondom'><p>Non-dominated sorting selector.</p></a></li>
<li><a href='#selRanking'><p>Rank Selection Operator</p></a></li>
<li><a href='#selRoulette'><p>Roulette-wheel / fitness-proportional selector.</p></a></li>
<li><a href='#selSimple'><p>Simple (naive) selector.</p></a></li>
<li><a href='#selTournament'><p>k-Tournament selector.</p></a></li>
<li><a href='#setDominates'><p>Check if one set is better than another.</p></a></li>
<li><a href='#setup'><p>Set up parameters for evolutionary operator.</p></a></li>
<li><a href='#setupECRDefaultMonitor'><p>Default monitor.</p></a></li>
<li><a href='#smsemoa'><p>Implementation of the SMS-EMOA by Emmerich et al.</p></a></li>
<li><a href='#sortByObjective'><p>Sort Pareto-front approximation by objective.</p></a></li>
<li><a href='#stoppingConditions'><p>Stopping conditions</p></a></li>
<li><a href='#toGG'><p>Transform to long format.</p></a></li>
<li><a href='#toLatex'><p>Export results of statistical tests to LaTeX table(s).</p></a></li>
<li><a href='#toParetoDf'><p>Convert matrix to Pareto front data frame.</p></a></li>
<li><a href='#transformFitness'><p>Fitness transformation / scaling.</p></a></li>
<li><a href='#updateLogger'><p>Update the log.</p></a></li>
<li><a href='#updateParetoArchive'><p>Update Pareto Archive.</p></a></li>
<li><a href='#which.dominated'><p>Determine which points of a set are (non)dominated.</p></a></li>
<li><a href='#wrapChildren'><p>Wrap the individuals constructed by a recombination operator.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Evolutionary Computation in R</td>
</tr>
<tr>
<td>Description:</td>
<td>Framework for building evolutionary algorithms for both single- and multi-objective continuous or discrete optimization problems. A set of predefined evolutionary building blocks and operators is included. Moreover, the user can easily set up custom objective functions, operators, building blocks and representations sticking to few conventions. The package allows both a black-box approach for standard tasks (plug-and-play style) and a much more flexible white-box approach where the evolutionary cycle is written by hand.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakob Bossek &lt;j.bossek@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jakobbossek/ecr2">https://github.com/jakobbossek/ecr2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jakobbossek/ecr2/issues">https://github.com/jakobbossek/ecr2/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), BBmisc (&ge; 1.6), smoof (&ge; 1.4), ParamHelpers (&ge;
1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 1.1), Rcpp (&ge; 0.12.16), parallelMap (&ge; 1.3),
reshape2 (&ge; 1.4.1), ggplot2 (&ge; 1.0.0), viridis, dplyr,
plot3D, plot3Drgl, scatterplot3d, plotly, knitr, kableExtra,
lazyeval</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.9.1), rmarkdown, mlr, mlbench, randomForest,
covr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-08 16:02:04 UTC; bossek</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakob Bossek [aut, cre, cph],
  Michael H. Buselli [ctb, cph],
  Wessel Dankers [ctb, cph],
  Carlos M. Fonseca [ctb, cph],
  Manuel Lopez-Ibanez [ctb, cph],
  Luis Paquete [ctb, cph],
  Joshua Knowles [ctb, cph],
  Eckart Zitzler [ctb, cph],
  Olaf Mersmann [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-08 22:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='addUnionGroup'>Grouping helpers</h2><span id='topic+addUnionGroup'></span><span id='topic+addAllGroup'></span>

<h3>Description</h3>

<p>Consider a data frame with results of multi-objective stochastic optimizers on
a set of problems from different categories/groups (say indicated by column &ldquo;group&rdquo;).
Occasionally, it is useful to unite the results of several groups into a meta-group.
The function <code>addUnionGroup</code> aids in generation of such a meta-group while
function <code>addAllGroup</code> is a wrapper around the former which generates a
union of all groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addUnionGroup(df, col, group, values)

addAllGroup(df, col, group = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addUnionGroup_+3A_df">df</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data frame.</p>
</td></tr>
<tr><td><code id="addUnionGroup_+3A_col">col</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Column name of group-column.</p>
</td></tr>
<tr><td><code id="addUnionGroup_+3A_group">group</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name for new group.</p>
</td></tr>
<tr><td><code id="addUnionGroup_+3A_values">values</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Subset of values within the value range of column <code>col</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>data.frame</code>] Modified data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df = data.frame(
  group = c("A1", "A1", "A2", "A2", "B"),
  perf = runif(5),
  stringsAsFactors = FALSE)

df2 = addUnionGroup(df, col = "group", group = "A", values = c("A1", "A2"))
df3 = addAllGroup(df, col = "group", group = "ALL")
</code></pre>

<hr>
<h2 id='approximateNadirPoint'>Reference point approximations.</h2><span id='topic+approximateNadirPoint'></span><span id='topic+approximateIdealPoint'></span>

<h3>Description</h3>

<p>Helper functions to compute nadir or ideal point from sets of
points, e.g., multiple approximation sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approximateNadirPoint(..., sets = NULL)

approximateIdealPoint(..., sets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approximateNadirPoint_+3A_...">...</code></td>
<td>
<p>[<code>matrix</code>]<br />
Arbirary number of matrizes.</p>
</td></tr>
<tr><td><code id="approximateNadirPoint_+3A_sets">sets</code></td>
<td>
<p>[<code>list</code>]<br />
List of matrizes. This is an alternative way of passing the sets. Can be used
exclusively or combined with <code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>] Reference point.
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='approximateRefPoints'>Helper function to estimate reference points.</h2><span id='topic+approximateRefPoints'></span>

<h3>Description</h3>

<p>E.g., for calculation of dominated hypervolume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approximateRefPoints(df, obj.cols = c("f1", "f2"), offset = 0, as.df = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approximateRefPoints_+3A_df">df</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data frame with the required structure, i.e. the data frame must contain a problem column &quot;prob&quot; as well as objective column(s).</p>
</td></tr>
<tr><td><code id="approximateRefPoints_+3A_obj.cols">obj.cols</code></td>
<td>
<p>[<code>character(&gt;= 2)</code>]<br />
Column names of the objective functions.
Default is <code>c("f1", "f2")</code>, i.e., the bi-objective case is assumed.</p>
</td></tr>
<tr><td><code id="approximateRefPoints_+3A_offset">offset</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Offset added to reference points.
Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="approximateRefPoints_+3A_as.df">as.df</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a data.frame be returned?
Default is <code>FALSE</code>. In this case a named list is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code> | <code>data.frame</code>]
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='approximateRefSets'>Helper function to estimate reference set(s).</h2><span id='topic+approximateRefSets'></span>

<h3>Description</h3>

<p>The function takes an data frame with columns at least
specified by <code>obj.cols</code> and &ldquo;prob&rdquo;. The reference set for
each unique problem in column &ldquo;prob&rdquo; is then obtained by
combining all approximation sets generated by all considered algorithms
for the corresponding problem and filtering the non-dominated solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approximateRefSets(df, obj.cols, as.df = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approximateRefSets_+3A_df">df</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data frame with the required structure.</p>
</td></tr>
<tr><td><code id="approximateRefSets_+3A_obj.cols">obj.cols</code></td>
<td>
<p>[<code>character(&gt;= 2)</code>]<br />
Column names of the objective functions.</p>
</td></tr>
<tr><td><code id="approximateRefSets_+3A_as.df">as.df</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a data.frame be returned?
Default is <code>FALSE</code>. In this case a named list is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code> | <code>data.frame</code>] Named list of matrizes
(names are the problems) or data frame with columns <code>obj.cols</code> and &ldquo;prob&rdquo;.
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='asemoa'>Implementation of the NSGA-II EMOA algorithm by Deb.</h2><span id='topic+asemoa'></span>

<h3>Description</h3>

<p>The AS-EMOA, short for aspiration set evolutionary multi-objective
algorithm aims to incorporate expert knowledge into multi-objective optimization [1].
The algorithm expects an aspiration set, i.e., a set of reference points. It
then creates an approximation of the pareto front close to the aspiration set
utilizing the average Hausdorff distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asemoa(
  fitness.fun,
  n.objectives = NULL,
  minimize = NULL,
  n.dim = NULL,
  lower = NULL,
  upper = NULL,
  mu = 10L,
  aspiration.set = NULL,
  normalize.fun = NULL,
  dist.fun = computeEuclideanDistance,
  p = 1,
  parent.selector = setup(selSimple),
  mutator = setup(mutPolynomial, eta = 25, p = 0.2, lower = lower, upper = upper),
  recombinator = setup(recSBX, eta = 15, p = 0.7, lower = lower, upper = upper),
  terminators = list(stopOnIters(100L))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asemoa_+3A_fitness.fun">fitness.fun</code></td>
<td>
<p>[<code>function</code>]<br />
The fitness function.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives of <code>obj.fun</code>.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical(n.objectives)</code>]<br />
Logical vector with ith entry <code>TRUE</code> if the ith objective of <code>fitness.fun</code>
shall be minimized. If a single logical is passed, it is assumed to be valid
for each objective.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_n.dim">n.dim</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Dimension of the decision space.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_mu">mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Population size. Default is 10.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_aspiration.set">aspiration.set</code></td>
<td>
<p>[<code>matrix</code>]<br />
The aspiration set. Each column contains one point of the set.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_normalize.fun">normalize.fun</code></td>
<td>
<p>[<code>function</code>]<br />
Function used to normalize fitness values of the individuals
before computation of the average Hausdorff distance.
The function must have the formal arguments &ldquo;set&rdquo; and &ldquo;aspiration.set&rdquo;.
Default is <code>NULL</code>, i.e., no normalization at all.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_dist.fun">dist.fun</code></td>
<td>
<p>[<code>function</code>]<br />
Distance function used internally by Hausdorff metric to compute distance
between two points. Expects a single vector of coordinate-wise differences
between points.
Default is <code>computeEuclideanDistance</code>.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Parameter <code class="reqn">p</code> for the average Hausdorff metric. Default is 1.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_parent.selector">parent.selector</code></td>
<td>
<p>[<code>ecr_selector</code>]<br />
Selection operator which implements a procedure to copy individuals from a
given population to the mating pool, i. e., allow them to become parents.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_mutator">mutator</code></td>
<td>
<p>[<code>ecr_mutator</code>]<br />
Mutation operator of type <code>ecr_mutator</code>.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_recombinator">recombinator</code></td>
<td>
<p>[<code>ecr_recombinator</code>]<br />
Recombination operator of type <code>ecr_recombinator</code>.</p>
</td></tr>
<tr><td><code id="asemoa_+3A_terminators">terminators</code></td>
<td>
<p>[<code>list</code>]<br />
List of stopping conditions of type &ldquo;ecr_terminator&rdquo;.
Default is to stop after 100 iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_multi_objective_result</code>]
</p>


<h3>Note</h3>

<p>This is a pure R implementation of the AS-EMOA algorithm. It hides the regular
ecr interface and offers a more R like interface while still being quite
adaptable.
</p>


<h3>References</h3>

<p>[1] Rudolph, G., Schuetze, S., Grimme, C., Trautmann, H: An Aspiration Set
EMOA Based on Averaged Hausdorff Distances. LION 2014: 153-156.
[2] G. Rudolph, O. Schuetze, C. Grimme, and H. Trautmann: A Multiobjective
Evolutionary Algorithm Guided by Averaged Hausdorff Distance to Aspiration
Sets, pp. 261-273 in A.-A. Tantar et al. (eds.): Proceedings of EVOLVE - A
bridge between Probability, Set Oriented Numerics and Evolutionary Computation
V, Springer: Berlin Heidelberg 2014.
</p>

<hr>
<h2 id='categorize'>Assign group membership based on another group membership.</h2><span id='topic+categorize'></span>

<h3>Description</h3>

<p>Given a data frame and a grouping column of type factor or character this function
generates a new grouping column which groups the groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorize(df, col, categories, cat.col, keep = TRUE, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="categorize_+3A_df">df</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data frame.</p>
</td></tr>
<tr><td><code id="categorize_+3A_col">col</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Column name of group variable.</p>
</td></tr>
<tr><td><code id="categorize_+3A_categories">categories</code></td>
<td>
<p>[<code>list</code>]<br />
Named list. Names indicate the name of the category while the values are character vectors
of values within the range of the <code>col</code> column.</p>
</td></tr>
<tr><td><code id="categorize_+3A_cat.col">cat.col</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Column name for categorization.</p>
</td></tr>
<tr><td><code id="categorize_+3A_keep">keep</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Keep the source column <code>col</code>?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="categorize_+3A_overwrite">overwrite</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, <code>cat.col</code> is set to <code>col</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>data.frame</code>]
df = data.frame(
group = c(&quot;A1&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;A2&quot;, &quot;B1&quot;, &quot;B2&quot;),
perf = runif(6),
stringsAsFactors = FALSE)
df2 = categorize(df, col = &quot;group&quot;, categories = list(A = c(&quot;A1&quot;, &quot;A2&quot;), B = c(&quot;B1&quot;, &quot;B2&quot;)), cat.col = &quot;group2&quot;)
</p>

<hr>
<h2 id='computeAverageHausdorffDistance'>Average Hausdorff Distance computation.</h2><span id='topic+computeAverageHausdorffDistance'></span>

<h3>Description</h3>

<p>Computes the average Hausdroff distance measure between two point sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeAverageHausdorffDistance(
  A,
  B,
  p = 1,
  normalize = FALSE,
  dist.fun = computeEuclideanDistance
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeAverageHausdorffDistance_+3A_a">A</code></td>
<td>
<p>[<code>matrix</code>]<br />
First point set (each column corresponds to a point).</p>
</td></tr>
<tr><td><code id="computeAverageHausdorffDistance_+3A_b">B</code></td>
<td>
<p>[<code>matrix</code>]<br />
Second point set (each column corresponds to a point).</p>
</td></tr>
<tr><td><code id="computeAverageHausdorffDistance_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Parameter p of the average Hausdoff metric.
Default is 1.</p>
</td></tr>
<tr><td><code id="computeAverageHausdorffDistance_+3A_normalize">normalize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the front be normalized on basis of <code>B</code>?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="computeAverageHausdorffDistance_+3A_dist.fun">dist.fun</code></td>
<td>
<p>[<code>matrix</code>]<br />
Distance function to compute distance between points x and y. Expects a single
numeric vector d with the coordinate-wise differences di = (xi - yi).
Default is <code>computeEuclideanDist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(1)</code>] Average Hausdorff distance of sets <code>A</code> and <code>B</code>.
</p>

<hr>
<h2 id='computeCrowdingDistance'>Compute the crowding distance of a set of points.</h2><span id='topic+computeCrowdingDistance'></span>

<h3>Description</h3>

<p>The crowding distance is a measure of spread of solutions in the
approximation of the Pareto front. It is used, e.g., in the NSGA-II algorithm
as a second selection criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeCrowdingDistance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeCrowdingDistance_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
Numeric matrix with each column representing a point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>] Vector of crowding distance values.
</p>


<h3>References</h3>

<p>K. Deb, A. Pratap, S. Agarwal, T. Meyarivan, A fast and elitist
multiobjective genetic algorithm: NSGA-II, IEEE Transactions on Evolutionary
Computation In Evolutionary Computation, IEEE Transactions on, Vol. 6, No. 2.
(07 April 2002), pp. 182-197, doi:10.1109/4235.996017
</p>

<hr>
<h2 id='computeDistanceFromPointToSetOfPoints'>Computes distance between a single point and set of points.</h2><span id='topic+computeDistanceFromPointToSetOfPoints'></span>

<h3>Description</h3>

<p>Helper to compute distance between a single point and a point set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeDistanceFromPointToSetOfPoints(
  a,
  B,
  dist.fun = computeEuclideanDistance
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeDistanceFromPointToSetOfPoints_+3A_a">a</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Point given as a numeric vector.</p>
</td></tr>
<tr><td><code id="computeDistanceFromPointToSetOfPoints_+3A_b">B</code></td>
<td>
<p>[<code>matrix</code>]<br />
Point set (each column corresponds to a point).</p>
</td></tr>
<tr><td><code id="computeDistanceFromPointToSetOfPoints_+3A_dist.fun">dist.fun</code></td>
<td>
<p>[<code>matrix</code>]<br />
Distance function to compute distance between points x and y. Expects a single
numeric vector d with the coordinate-wise differences di = (xi - yi).
Default is <code>computeEuclideanDist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(1)</code>]
</p>

<hr>
<h2 id='computeDominanceRanking'>Ranking of approximation sets.</h2><span id='topic+computeDominanceRanking'></span>

<h3>Description</h3>

<p>Ranking is performed by merging all approximation sets over all
algorithms and runs per instance. Next, each approximation set <code class="reqn">C</code> is assigned a
rank which is 1 plus the number of approximation sets that are better than
<code class="reqn">C</code>. A set <code class="reqn">D</code> is better than <code class="reqn">C</code>, if for each point <code class="reqn">x \in C</code> there
exists a point in <code class="reqn">y \in D</code> which weakly dominates <code class="reqn">x</code>.
Thus, each approximation set is reduced to a number &ndash; its rank. This rank distribution
may act for first comparrison of multi-objecitve stochastic optimizers.
See [1] for more details.
This function makes use of <code><a href="parallelMap.html#topic+parallelMap">parallelMap</a></code> to
parallelize the computation of dominance ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeDominanceRanking(df, obj.cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeDominanceRanking_+3A_df">df</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data frame with columns at least &ldquo;prob&rdquo;, &ldquo;algorithm&rdquo;, &ldquo;repl&rdquo; and
column names specified via parameter <code>obj.cols</code>.</p>
</td></tr>
<tr><td><code id="computeDominanceRanking_+3A_obj.cols">obj.cols</code></td>
<td>
<p>[<code>character(&gt;= 2)</code>]<br />
Column names in <code>df</code> which store the objective function values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>data.frame</code>] Reduced <code>df</code> with columns &ldquo;prob&rdquo;, &ldquo;algorithm&rdquo;, &ldquo;repl&rdquo;
and &ldquo;rank&rdquo;.
</p>


<h3>Note</h3>

<p>Since pairwise non-domination checks are performed over all algorithms and
algorithm runs this function may take some time if the number of problems, algorithms
and/or replications is high.
</p>


<h3>References</h3>

<p>[1] Knowles, J., Thiele, L., &amp; Zitzler, E. (2006). A Tutorial on the Performance Assessment
of Stochastic Multiobjective Optimizers. Retrieved from https://sop.tik.ee.ethz.ch/KTZ2005a.pdf
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='computeGenerationalDistance'>Computes Generational Distance.</h2><span id='topic+computeGenerationalDistance'></span>

<h3>Description</h3>

<p>Helper to compute the Generational Distance (GD) between two sets of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGenerationalDistance(
  A,
  B,
  p = 1,
  normalize = FALSE,
  dist.fun = computeEuclideanDistance
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGenerationalDistance_+3A_a">A</code></td>
<td>
<p>[<code>matrix</code>]<br />
First point set (each column corresponds to a point).</p>
</td></tr>
<tr><td><code id="computeGenerationalDistance_+3A_b">B</code></td>
<td>
<p>[<code>matrix</code>]<br />
Second point set (each column corresponds to a point).</p>
</td></tr>
<tr><td><code id="computeGenerationalDistance_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Parameter p of the average Hausdoff metric.
Default is 1.</p>
</td></tr>
<tr><td><code id="computeGenerationalDistance_+3A_normalize">normalize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the front be normalized on basis of <code>B</code>?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="computeGenerationalDistance_+3A_dist.fun">dist.fun</code></td>
<td>
<p>[<code>matrix</code>]<br />
Distance function to compute distance between points x and y. Expects a single
numeric vector d with the coordinate-wise differences di = (xi - yi).
Default is <code>computeEuclideanDist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(1)</code>]
</p>

<hr>
<h2 id='computeHV'>Functions for the calculation of the dominated hypervolume (contribution).</h2><span id='topic+computeHV'></span><span id='topic+computeHVContr'></span>

<h3>Description</h3>

<p>The function <code>computeHV</code> computes the dominated
hypervolume of a set of points given a reference set whereby
<code>computeHVContr</code> computes the hypervolume contribution
of each point.
</p>
<p>If no reference point is given the nadir point of the set <code>x</code> is
determined and a positive offset with default 1 is added. This is to ensure
that the reference point dominates all of the points in the reference set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeHV(x, ref.point = NULL, ...)

computeHVContr(x, ref.point = NULL, offset = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeHV_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of points (column-wise).</p>
</td></tr>
<tr><td><code id="computeHV_+3A_ref.point">ref.point</code></td>
<td>
<p>[<code>numeric</code> | <code>NULL</code>]<br />
Reference point.
Set to the maximum in each dimension by default if not provided.</p>
</td></tr>
<tr><td><code id="computeHV_+3A_...">...</code></td>
<td>
<p>[any]<br />
Not used at the moment.</p>
</td></tr>
<tr><td><code id="computeHV_+3A_offset">offset</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Offset to be added to each component of the reference point only in the case
where no reference is provided and one is calculated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(1)</code>] Dominated hypervolume in the case of
<code>computeHV</code> and the dominated hypervolume contributions
for each point in the case of <code>computeHVContr</code>.
</p>


<h3>Note</h3>

<p>: Keep in mind that this function assumes all objectives to be minimized.
In case at least one objective is to be maximized the matrix <code>x</code> needs
to be transformed accordingly in advance.
</p>

<hr>
<h2 id='computeIndicators'>Computation of EMOA performance indicators.</h2><span id='topic+computeIndicators'></span>

<h3>Description</h3>

<p>Given a data.frame of Pareto-front approximations for different
sets of problems, algorithms and replications, the function computes sets
of unary and binary EMOA performance indicators.
This function makes use of <code><a href="parallelMap.html#topic+parallelMap">parallelMap</a></code> to
parallelize the computation of indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeIndicators(
  df,
  obj.cols = c("f1", "f2"),
  unary.inds = NULL,
  binary.inds = NULL,
  normalize = FALSE,
  offset = 0,
  ref.points = NULL,
  ref.sets = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeIndicators_+3A_df">df</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data frame with columns <code>obj.cols</code>, &ldquo;prob&rdquo;, &ldquo;algorithm&rdquo;
and &ldquo;repl&rdquo;.</p>
</td></tr>
<tr><td><code id="computeIndicators_+3A_obj.cols">obj.cols</code></td>
<td>
<p>[<code>character(&gt;= 2)</code>]<br />
Column names of the objective functions.
Default is <code>c("f1", "f2")</code>, i.e., the bi-objective case is assumed.</p>
</td></tr>
<tr><td><code id="computeIndicators_+3A_unary.inds">unary.inds</code></td>
<td>
<p>[<code>list</code>]<br />
Named list of unary indicators which shall be calculated.
Each component must be another list with mandatory argument <code>fun</code> (the
function which calculates the indicator) and optional argument <code>pars</code> (a named
list of parameters for <code>fun</code>). Function <code>fun</code> must have the
signiture &ldquo;function(points, arg1, ..., argk, ...)&rdquo;.
The arguments &ldquo;points&rdquo; and &ldquo;...&rdquo; are mandatory, the remaining are
optional.
The names of the components on the first level are used for the column names
of the output data.frame.
Default is <code>list(HV = list(fun = computeHV))</code>, i.e., the dominated
Hypervolume indicator.</p>
</td></tr>
<tr><td><code id="computeIndicators_+3A_binary.inds">binary.inds</code></td>
<td>
<p>[<code>list</code>]<br />
Named list of binary indicators which shall be applied for each algorithm
combination. Parameter <code>binary.inds</code> needs the same structure as <code>unary.inds</code>.
However, the function signature of <code>fun</code> is slighly different:
&ldquo;function(points1, points2, arg1, ..., argk, ...)&rdquo;.
See function <code><a href="#topic+emoaIndEps">emoaIndEps</a></code> for an example.
Default is <code>list(EPS = list(fun = emoaIndEps))</code>.</p>
</td></tr>
<tr><td><code id="computeIndicators_+3A_normalize">normalize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Normalize approximation sets to <code class="reqn">[0, 1]^p</code> where <code class="reqn">p</code> is the number of
objectives? Normalization is done on the union of all approximation sets for each
problem.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="computeIndicators_+3A_offset">offset</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Offset added to reference point estimations.
Default is 0.</p>
</td></tr>
<tr><td><code id="computeIndicators_+3A_ref.points">ref.points</code></td>
<td>
<p>[<code>list</code>]<br />
Named list of numeric vectors (the reference points). The names must be the
unique problem names in <code>df$prob</code> or a subset of these.
If <code>NULL</code> (the default), reference points are estimated from the
approximation sets for each problem.</p>
</td></tr>
<tr><td><code id="computeIndicators_+3A_ref.sets">ref.sets</code></td>
<td>
<p>[<code>list</code>]<br />
Named list matrizes (the reference sets). The names must be the
unique problem names in <code>df$prob</code> or a subset of these.
If <code>NULL</code> (the default), reference points are estimated from the
approximation sets for each problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List with components &ldquo;unary&rdquo; (data frame of
unary indicators), &ldquo;binary&rdquo; (list of matrizes of binary indicators),
&ldquo;ref.points&rdquo; (list of reference points used) and &ldquo;ref.sets&rdquo;
(reference sets used).
</p>


<h3>References</h3>

<p>[1] Knowles, J., Thiele, L., &amp; Zitzler, E. (2006). A Tutorial on the Performance Assessment
of Stochastic Multiobjective Optimizers. Retrieved from https://sop.tik.ee.ethz.ch/KTZ2005a.pdf
[2] Knowles, J., &amp; Corne, D. (2002). On Metrics for Comparing Non-Dominated Sets.
In Proceedings of the 2002 Congress on Evolutionary Computation Conference (CEC02)
(pp. 711–716). Honolulu, HI, USA: Institute of Electrical and Electronics Engineers.
[3] Okabe, T., Yaochu, Y., &amp; Sendhoff, B. (2003). A Critical Survey of Performance
Indices for Multi-Objective Optimisation. In Proceedings of the 2003 Congress on Evolutionary
Computation Conference (CEC03) (pp. 878–885). Canberra, ACT, Australia: IEEE.
</p>

<hr>
<h2 id='computeInvertedGenerationalDistance'>Computes Inverted Generational Distance.</h2><span id='topic+computeInvertedGenerationalDistance'></span>

<h3>Description</h3>

<p>Helper to compute the Inverted Generational Distance (IGD) between two sets
of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeInvertedGenerationalDistance(
  A,
  B,
  p = 1,
  normalize = FALSE,
  dist.fun = computeEuclideanDistance
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeInvertedGenerationalDistance_+3A_a">A</code></td>
<td>
<p>[<code>matrix</code>]<br />
First point set (each column corresponds to a point).</p>
</td></tr>
<tr><td><code id="computeInvertedGenerationalDistance_+3A_b">B</code></td>
<td>
<p>[<code>matrix</code>]<br />
Second point set (each column corresponds to a point).</p>
</td></tr>
<tr><td><code id="computeInvertedGenerationalDistance_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Parameter p of the average Hausdoff metric.
Default is 1.</p>
</td></tr>
<tr><td><code id="computeInvertedGenerationalDistance_+3A_normalize">normalize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the front be normalized on basis of <code>B</code>?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="computeInvertedGenerationalDistance_+3A_dist.fun">dist.fun</code></td>
<td>
<p>[<code>matrix</code>]<br />
Distance function to compute distance between points x and y. Expects a single
numeric vector d with the coordinate-wise differences di = (xi - yi).
Default is <code>computeEuclideanDist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(1)</code>]
</p>

<hr>
<h2 id='dominated'>Check for pareto dominance.</h2><span id='topic+dominated'></span><span id='topic+nondominated'></span>

<h3>Description</h3>

<p>These functions take a numeric matrix <code>x</code> where each column corresponds to
a point and return a logical vector. The i-th position of the latter is
<code>TRUE</code> if the i-th point is dominated by at least one other point for
<code>dominated</code> and <code>FALSE</code> for <code>nonDominated</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominated(x)

nondominated(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominated_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
Numeric (d x n) matrix where d is the number of objectives and n is the
number of points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical</code>]
</p>

<hr>
<h2 id='dominates'>Dominance relation check.</h2><span id='topic+dominates'></span><span id='topic+isDominated'></span><span id='topic++25dominates+25'></span><span id='topic++25isDominatedBy+25'></span>

<h3>Description</h3>

<p>Check if a vector dominates another (<code>dominates</code>) or is
dominated by another (<code>isDominated</code>). There are corresponding infix
operators <code>dominates</code> and <code>isDominatedBy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominates(x, y)

isDominated(x, y)

x %dominates% y

x %isDominatedBy% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominates_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code>]<br />
First vector.</p>
</td></tr>
<tr><td><code id="dominates_+3A_y">y</code></td>
<td>
<p>[<code>numeric</code>]<br />
Second vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='doNondominatedSorting'>Fast non-dominated sorting algorithm.</h2><span id='topic+doNondominatedSorting'></span>

<h3>Description</h3>

<p>Fast non-dominated sorting algorithm proposed by Deb. Non-dominated sorting
expects a set of points and returns a
set of non-dominated fronts. In short words this is done as follows: the
non-dominated points of the entire set are determined and assigned rank 1.
Afterwards all points with the current rank are removed, the rank is increased
by one and the procedure starts again. This is done until the set is empty, i.~e.,
each point is assigned a rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doNondominatedSorting(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doNondominatedSorting_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
Numeric matrix of points. Each column contains one point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>]
List with the following components
</p>

<dl>
<dt>ranks</dt><dd><p>Integer vector of ranks of length <code>ncol(x)</code>. The higher
the rank, the higher the domination front the corresponding point is
located on.</p>
</dd>
<dt>dom.counter</dt><dd><p>Integer vector of length <code>ncol(x)</code>. The i-th element
is the domination number of the i-th point.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This procedure is the key survival selection of the famous NSGA-II multi-objective
evolutionary algorithm (see <code><a href="#topic+nsga2">nsga2</a></code>).
</p>


<h3>References</h3>

<p>[1] Deb, K., Pratap, A., and Agarwal, S. A Fast and Elitist Multiobjective Genetic
Algorithm: NSGA-II. IEEE Transactions on Evolutionary Computation, 6 (8) (2002),
182-197.
</p>

<hr>
<h2 id='ecr'>Interface to ecr similar to the optim function.</h2><span id='topic+ecr'></span>

<h3>Description</h3>

<p>The most flexible way to setup evolutionary algorithms with ecr is by
explicitely writing the evolutionary loop utilizing various ecr utlity functions.
However, in everyday life R users frequently need to optimize a single-objective R function.
The <code>ecr</code> function thus provides a more R like interface for single
objective optimization similar to the interface of the <code><a href="stats.html#topic+optim">optim</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecr(
  fitness.fun,
  minimize = NULL,
  n.objectives = NULL,
  n.dim = NULL,
  lower = NULL,
  upper = NULL,
  n.bits,
  representation,
  mu,
  lambda,
  perm = NULL,
  p.recomb = 0.7,
  p.mut = 0.3,
  survival.strategy = "plus",
  n.elite = 0L,
  log.stats = list(fitness = list("min", "mean", "max")),
  log.pop = FALSE,
  monitor = NULL,
  initial.solutions = NULL,
  parent.selector = NULL,
  survival.selector = NULL,
  mutator = NULL,
  recombinator = NULL,
  terminators = list(stopOnIters(100L)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecr_+3A_fitness.fun">fitness.fun</code></td>
<td>
<p>[<code>function</code>]<br />
The fitness function.</p>
</td></tr>
<tr><td><code id="ecr_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical(n.objectives)</code>]<br />
Logical vector with ith entry <code>TRUE</code> if the ith objective of <code>fitness.fun</code>
shall be minimized. If a single logical is passed, it is assumed to be valid
for each objective.</p>
</td></tr>
<tr><td><code id="ecr_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives of <code>obj.fun</code>.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="ecr_+3A_n.dim">n.dim</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Dimension of the decision space.</p>
</td></tr>
<tr><td><code id="ecr_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="ecr_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="ecr_+3A_n.bits">n.bits</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of bits to use for binary representation.</p>
</td></tr>
<tr><td><code id="ecr_+3A_representation">representation</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Genotype representation of the parameters. Available are &ldquo;binary&rdquo;,
&ldquo;float&rdquo;, &ldquo;permutation&rdquo; and &ldquo;custom&rdquo;.</p>
</td></tr>
<tr><td><code id="ecr_+3A_mu">mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of individuals in the population.</p>
</td></tr>
<tr><td><code id="ecr_+3A_lambda">lambda</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of individuals generated in each generation.</p>
</td></tr>
<tr><td><code id="ecr_+3A_perm">perm</code></td>
<td>
<p>[<code>integer(1)</code> | <code>vector</code>]<br />
Either a single integer number. In this case the set is assumed to be <code>1:perm</code>.
Alternatively, a set, i.e., a vector of elements can be passed which should form each
individual.</p>
</td></tr>
<tr><td><code id="ecr_+3A_p.recomb">p.recomb</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability of two parents to perform crossover.
Default is 0.7.</p>
</td></tr>
<tr><td><code id="ecr_+3A_p.mut">p.mut</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
The probability that the mutation operator will be applied to a child. 
Refers only to the application of the mutation operator, not to the 
probability of mutating individual genes of the respective child.
Default is 0.1.</p>
</td></tr>
<tr><td><code id="ecr_+3A_survival.strategy">survival.strategy</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Determines the survival strategy used by the EA. Possible are &ldquo;plus&rdquo; for
a classical (mu + lambda) strategy and &ldquo;comma&rdquo; for (mu, lambda).
Default is &ldquo;plus&rdquo;.</p>
</td></tr>
<tr><td><code id="ecr_+3A_n.elite">n.elite</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of fittest individuals of the current generation that shall be copied to the
next generation without changing. Keep in mind, that the algorithm
does not care about this option if the <code>survival.strategy</code> is set to 'plus'.
Default is 0.</p>
</td></tr>
<tr><td><code id="ecr_+3A_log.stats">log.stats</code></td>
<td>
<p>[<code>list</code>]<br />
(Named) list of scalar functions to compute statistics on the fitness values
in each generation. See <code><a href="#topic+initLogger">initLogger</a></code> for more information.
Default is to log fitness minimum, mean and maximum values.</p>
</td></tr>
<tr><td><code id="ecr_+3A_log.pop">log.pop</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Shall the entire population be saved in each generation?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ecr_+3A_monitor">monitor</code></td>
<td>
<p>[<code>function</code>]<br />
Monitoring function.
Default is <code>NULL</code>, i.e. no monitoring.</p>
</td></tr>
<tr><td><code id="ecr_+3A_initial.solutions">initial.solutions</code></td>
<td>
<p>[<code>list</code>]<br />
List of individuals which should be placed in the initial population.
If the number of passed individuals
is lower than <code>mu</code>, the population will be filled up
by individuals generated by the corresponding generator.
Default is <code>NULL</code>, i.e., the entire population is generated by the
population generator.</p>
</td></tr>
<tr><td><code id="ecr_+3A_parent.selector">parent.selector</code></td>
<td>
<p>[<code>ecr_selector</code>]<br />
Selection operator which implements a procedure to copy individuals from a
given population to the mating pool, i. e., allow them to become parents.</p>
</td></tr>
<tr><td><code id="ecr_+3A_survival.selector">survival.selector</code></td>
<td>
<p>[<code>ecr_selector</code>]<br />
Selection operator which implements a procedurce to extract individuals from
a given set, which should survive and set up the next generation.</p>
</td></tr>
<tr><td><code id="ecr_+3A_mutator">mutator</code></td>
<td>
<p>[<code>ecr_mutator</code>]<br />
Mutation operator of type <code>ecr_mutator</code>.</p>
</td></tr>
<tr><td><code id="ecr_+3A_recombinator">recombinator</code></td>
<td>
<p>[<code>ecr_recombinator</code>]<br />
Recombination operator of type <code>ecr_recombinator</code>.</p>
</td></tr>
<tr><td><code id="ecr_+3A_terminators">terminators</code></td>
<td>
<p>[<code>list</code>]<br />
List of stopping conditions of type &ldquo;ecr_terminator&rdquo;.
Default is to stop after 100 iterations.</p>
</td></tr>
<tr><td><code id="ecr_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed down to <code>fitness.fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ecr_result">ecr_result</a></code>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn = function(x) {
   sum(x^2)
}
lower = c(-5, -5); upper = c(5, 5)
res = ecr(fn, n.dim = 2L, n.objectives = 1L, lower = lower, upper = lower,
 representation = "float", mu = 20L, lambda = 10L,
  mutator = setup(mutGauss, lower = lower, upper = upper))
</code></pre>

<hr>
<h2 id='ecr_parallelization'>Parallelization in ecr</h2><span id='topic+ecr_parallelization'></span>

<h3>Description</h3>

<p>In ecr it is possible to parallelize the fitness function evaluation
to make use, e.g., of multiple CP cores or nodes in a HPC cluster.
For maximal flexibility this is realized by means of the <span class="pkg">parallelMap</span> package
(see the <a href="https://github.com/mlr-org/parallelMap">official
GitHub page</a> for instructions on how to set up parallelization).
The different levels of parallelization can be specified in the
<code>parallelStart*</code> function. At them moment only the level
&ldquo;ecr.evaluateFitness&rdquo; is supported.
</p>
<p>Keep in mind that parallelization comes along with some overhead. Thus activating
parallelization, e.g., for evaluation a fitness function which is evaluated
lightning-fast, may result in higher computation time. However, if the function
evaluations are computationally more expensive, parallelization leads to
significant running time benefits.
</p>

<hr>
<h2 id='ecr_result'>Result object.</h2><span id='topic+ecr_result'></span>

<h3>Description</h3>

<p>S3 object returned by <code><a href="#topic+ecr">ecr</a></code> containing the best found
parameter setting and value in the single-objective case and the Pareto-front/-set
in case of a multi-objective optimization problem. Moreover a set of further
information, e.g., reason of termination, the control object etc. are returned.
</p>
<p>The single objective result object contains the following fields:
</p>

<dl>
<dt>task</dt><dd><p>The <code>ecr_optimization_task</code>.</p>
</dd>
<dt>best.x</dt><dd><p>Overall best parameter setting.</p>
</dd>
<dt>best.y</dt><dd><p>Overall best objective value.</p>
</dd>
<dt>log</dt><dd><p>Logger object.</p>
</dd>
<dt>last.population</dt><dd><p>Last population.</p>
</dd>
<dt>last.fitness</dt><dd><p>Numeric vector of fitness values of the last population.</p>
</dd>
<dt>message</dt><dd><p>Character string describing the reason of termination.</p>
</dd>
</dl>

<p>In case of a solved multi-objective function the result object contains the
following fields:
</p>

<dl>
<dt>task</dt><dd><p>The <code>ecr_optimization_task</code>.</p>
</dd>
<dt>log</dt><dd><p>Logger object.</p>
</dd>
<dt>pareto.idx</dt><dd><p>Indizes of the non-dominated solutions in the last population.</p>
</dd>
<dt>pareto.front</dt><dd><p>(n x d) matrix of the approximated non-dominated front where n
is the number of non-dominated points and d is the number of objectives.</p>
</dd>
<dt>pareto.set</dt><dd><p>Matrix of decision space values resulting with objective values
given in pareto.front.</p>
</dd>
<dt>last.population</dt><dd><p>Last population.</p>
</dd>
<dt>message</dt><dd><p>Character string describing the reason of termination.</p>
</dd>
</dl>


<hr>
<h2 id='emoaIndEps'>EMOA performance indicators</h2><span id='topic+emoaIndEps'></span><span id='topic+emoaIndHV'></span><span id='topic+emoaIndR1'></span><span id='topic+emoaIndR2'></span><span id='topic+emoaIndR3'></span><span id='topic+emoaIndMD'></span><span id='topic+emoaIndC'></span><span id='topic+emoaIndM1'></span><span id='topic+emoaIndONVG'></span><span id='topic+emoaIndGD'></span><span id='topic+emoaIndIGD'></span><span id='topic+emoaIndDeltap'></span><span id='topic+emoaIndSP'></span><span id='topic+emoaIndDelta'></span>

<h3>Description</h3>

<p>Functions for the computation of unary and binary measures which
are useful for the evaluation of the performace of EMOAs. See the references
section for literature on these indicators.
</p>
<p>Given a set of points <code>points</code>, <code>emoaIndEps</code> computes the
unary epsilon-indicator provided a set of reference points <code>ref.points</code>.
</p>
<p>The <code>emoaIndHV</code> function computes the hypervolume indicator
Hyp(X, R, r). Given a set of points X (<code>points</code>), another set of reference
points R (<code>ref.points</code>) (which maybe the true Pareto front) and a reference
point r (<code>ref.point</code>) it is defined as Hyp(X, R, r) = HV(R, r) - HV(X, r).
</p>
<p>Function <code>emoaIndR1</code>, <code>emoaIndR2</code> and <code>emoaIndR3</code> calculate the
R1, R2 and R3 indicator respectively.
</p>
<p>Function <code>emoaIndMD</code> computes the minimum distance indicator, i.e., the minimum
Euclidean distance between two points of the set <code>points</code> while function
<code>emoaIndM1</code> determines the mean Euclidean distance between <code>points</code>
and points from a reference set <code>ref.points</code>.
</p>
<p>Function <code>emoaIndC</code> calculates the coverage of the sets <code>points</code> (A) and
<code>ref.points</code> (B). This is the ratio of points in B which are dominated by
at least one solution in A.
</p>
<p><code>emoaIndONVG</code> calculates the &ldquo;Overall Non-dominated Vector Generation&rdquo;
indicator. Despite its complicated name it is just the number of non-dominated points
in <code>points</code>.
</p>
<p>Functions <code>emoaIndSP</code> and <code>emoaIndDelta</code> calculate spacing indicators.
The former was proposed by Schott: first calculate the sum of squared distances
between minimal distancesof points to all other points and the mean of these minimal
distance. Next, normalize by the number of points minus 1 and finally calculate the
square root. In contrast, Delta-indicator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emoaIndEps(points, ref.points, ...)

emoaIndHV(points, ref.points, ref.point = NULL, ...)

emoaIndR1(
  points,
  ref.points,
  ideal.point = NULL,
  nadir.point = NULL,
  lambda = NULL,
  utility = "tschebycheff",
  ...
)

emoaIndR2(
  points,
  ref.points,
  ideal.point = NULL,
  nadir.point = NULL,
  lambda = NULL,
  utility = "tschebycheff",
  ...
)

emoaIndR3(
  points,
  ref.points,
  ideal.point = NULL,
  nadir.point = NULL,
  lambda = NULL,
  utility = "tschebycheff",
  ...
)

emoaIndMD(points, ...)

emoaIndC(points, ref.points, ...)

emoaIndM1(points, ref.points, ...)

emoaIndONVG(points, ...)

emoaIndGD(
  points,
  ref.points,
  p = 1,
  normalize = FALSE,
  dist.fun = computeEuclideanDistance,
  ...
)

emoaIndIGD(
  points,
  ref.points,
  p = 1,
  normalize = FALSE,
  dist.fun = computeEuclideanDistance,
  ...
)

emoaIndDeltap(
  points,
  ref.points,
  p = 1,
  normalize = FALSE,
  dist.fun = computeEuclideanDistance,
  ...
)

emoaIndSP(points, ...)

emoaIndDelta(points, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emoaIndEps_+3A_points">points</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of points.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_ref.points">ref.points</code></td>
<td>
<p>[<code>matrix</code>]<br />
Set of reference points.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_...">...</code></td>
<td>
<p>[any]<br />
Not used at the moment.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_ref.point">ref.point</code></td>
<td>
<p>[<code>numeric</code>]<br />
A single reference point used, e.g., for the computation of the hypervolume
indicator via <code>emoaIndHV</code>. If <code>NULL</code> the
nadir point of the union of the <code>points</code> and <code>ref.points</code> is used.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_ideal.point">ideal.point</code></td>
<td>
<p>[<code>numeric</code>]<br />
The utopia point of the true Pareto front, i.e., each component of the point
contains the best value if the other objectives are neglected.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_nadir.point">nadir.point</code></td>
<td>
<p>[<code>numeric</code>]<br />
Nadir point of the true Pareto front.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_lambda">lambda</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of weight vectors to use in estimating the utility function.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_utility">utility</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the utility function to use. Must be one of &ldquo;weightedsum&rdquo;,
&ldquo;tschebycheff&rdquo; or &ldquo;augmented tschbycheff&rdquo;.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Parameter p of the average Hausdoff metric.
Default is 1.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_normalize">normalize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the front be normalized on basis of <code>B</code>?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="emoaIndEps_+3A_dist.fun">dist.fun</code></td>
<td>
<p>[<code>matrix</code>]<br />
Distance function to compute distance between points x and y. Expects a single
numeric vector d with the coordinate-wise differences di = (xi - yi).
Default is <code>computeEuclideanDist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(1)</code>] Epsilon indicator.
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='evaluateFitness'>Computes the fitness value(s) for each individual of a given set.</h2><span id='topic+evaluateFitness'></span>

<h3>Description</h3>

<p>This function expects a list of individuals, computes the fitness and always
returns a matrix of fitness values; even in single-objective optimization a
(1 x n) matrix is returned for consistency, where n is the number of individuals.
This function makes use of <code><a href="parallelMap.html#topic+parallelMap">parallelMap</a></code> to
parallelize the fitness evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateFitness(control, inds, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateFitness_+3A_control">control</code></td>
<td>
<p>[<code>ecr_control</code>]<br />
Control object.</p>
</td></tr>
<tr><td><code id="evaluateFitness_+3A_inds">inds</code></td>
<td>
<p>[<code>list</code>]<br />
List of individuals.</p>
</td></tr>
<tr><td><code id="evaluateFitness_+3A_...">...</code></td>
<td>
<p>[any]<br />
Optional parameters passed down to fitness function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix</code>].
</p>

<hr>
<h2 id='explode'>Explode/implode data frame column(s).</h2><span id='topic+explode'></span><span id='topic+implode'></span>

<h3>Description</h3>

<p>Given a data frame and a column name, function
<code>explode</code> splits the content of a column by a specified
delimiter (thus exploded) into multiple columns. Function <code>implode</code>
does vice versa, i.e., given a non-empty set of column names or
numbers, the function glues together the columns. Hence, functions
<code>explode</code> and <code>implode</code> are kind of inverse to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explode(df, col, by = ".", keep = FALSE, col.names = NULL)

implode(df, cols, by = ".", keep = FALSE, col.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explode_+3A_df">df</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data frame.</p>
</td></tr>
<tr><td><code id="explode_+3A_col">col</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of column which should be exploded.</p>
</td></tr>
<tr><td><code id="explode_+3A_by">by</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Delimeter used to split cell entries (for <code>explode</code>) or
glue them together (for <code>implode</code>).</p>
</td></tr>
<tr><td><code id="explode_+3A_keep">keep</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should exploded or imploded source column be kept?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="explode_+3A_col.names">col.names</code></td>
<td>
<p>[<code>character</code>]<br />
Names of new columns.
Default is &ldquo;<code>col</code>.1&rdquo;, ..., &ldquo;<code>col</code>.k&rdquo;, where
k is the number of elements each cell in column <code>col</code> is split into.</p>
</td></tr>
<tr><td><code id="explode_+3A_cols">cols</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Names of columns (or column number) which should be imploded.</p>
</td></tr>
<tr><td><code id="explode_+3A_col.name">col.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of new column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>data.frame</code>] Modified data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df = data.frame(x = 1:3, y = c("a.c", "a.b", "a.c"))
df.ex = explode(df, col = "y", col.names = c("y1", "y2"))
df.im = implode(df.ex, cols = c("y1", "y2"), by = "---", col.name = "y", keep = TRUE)
</code></pre>

<hr>
<h2 id='filterDuplicated'>Filter approximation sets by duplicate objective vectors.</h2><span id='topic+filterDuplicated'></span><span id='topic+filterDuplicated.data.frame'></span><span id='topic+filterDuplicated.matrix'></span><span id='topic+filterDuplicated.ecr_multi_objective_result'></span><span id='topic+filterDuplicated.list'></span>

<h3>Description</h3>

<p>Filter approximation sets by duplicate objective vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterDuplicated(x, ...)

## S3 method for class 'data.frame'
filterDuplicated(x, ...)

## S3 method for class 'matrix'
filterDuplicated(x, ...)

## S3 method for class 'ecr_multi_objective_result'
filterDuplicated(x, ...)

## S3 method for class 'list'
filterDuplicated(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterDuplicated_+3A_x">x</code></td>
<td>
<p>[<code>object</code>]<br />
Object of type data frame (objectives column-wise), matrix (objectives row-wise),
<code><a href="#topic+ecr_result">ecr_multi_objective_result</a></code> or <code>list</code> (with components &ldquo;pareto.front&rdquo;)
and &ldquo;pareto.set&rdquo;.</p>
</td></tr>
<tr><td><code id="filterDuplicated_+3A_...">...</code></td>
<td>
<p>[any]<br />
Not used at the moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>object</code>] Modified input <code>x</code>.
</p>


<h3>Note</h3>

<p>Note that this may be misleading if there can be solutions with identical
objective function values but different values in decision space.
</p>

<hr>
<h2 id='generateOffspring'>Helper functions for offspring generation</h2><span id='topic+generateOffspring'></span><span id='topic+mutate'></span><span id='topic+recombinate'></span>

<h3>Description</h3>

<p>Function <code>mutate</code> expects a control object, a list of individuals, and a mutation
probability. The mutation operator registered in the control object is then applied
with the given probability to each individual.
Function <code>recombinate</code> expects a control object, a list of individuals as well as
their fitness matrix and creates <code>lambda</code> offspring individuals by recombining parents
from <code>inds</code>. Which parents take place in the parent selection depends on
the <code>parent.selector</code> registered in the control object.
Finally, function <code>generateOffspring</code> is a wrapper for both <code>recombinate</code>
and <code>mutate</code>. Both functions are applied subsequently to generate new individuals
by variation and mutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateOffspring(control, inds, fitness, lambda, p.recomb = 0.7, p.mut = 0.1)

mutate(control, inds, p.mut = 0.1, slot = "mutate", ...)

recombinate(
  control,
  inds,
  fitness,
  lambda = length(inds),
  p.recomb = 0.7,
  slot = "recombine",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateOffspring_+3A_control">control</code></td>
<td>
<p>[<code>ecr_control</code>]<br />
Control object.</p>
</td></tr>
<tr><td><code id="generateOffspring_+3A_inds">inds</code></td>
<td>
<p>[<code>list</code>]<br />
List of individuals.</p>
</td></tr>
<tr><td><code id="generateOffspring_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) of one
individual).</p>
</td></tr>
<tr><td><code id="generateOffspring_+3A_lambda">lambda</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of individuals generated in each generation.</p>
</td></tr>
<tr><td><code id="generateOffspring_+3A_p.recomb">p.recomb</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability of two parents to perform crossover.
Default is 0.7.</p>
</td></tr>
<tr><td><code id="generateOffspring_+3A_p.mut">p.mut</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
The probability that the mutation operator will be applied to a child. 
Refers only to the application of the mutation operator, not to the 
probability of mutating individual genes of the respective child.
Default is 0.1.</p>
</td></tr>
<tr><td><code id="generateOffspring_+3A_slot">slot</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The slot of the control object which contains the registered operator to use.
Default is &ldquo;mutate&rdquo; for <code>mutate</code> and &ldquo;recombine&rdquo; for <code>recombinate</code>.
In most cases there is no need to change this. However, it might be useful if you make use
of different mutation operators registerted, e.g., in the slots &ldquo;mutate1&rdquo; and &ldquo;mutate2&rdquo;.</p>
</td></tr>
<tr><td><code id="generateOffspring_+3A_...">...</code></td>
<td>
<p>[any]<br />
Furhter arguments passed down to recombinator/mutator.
There parameters will overwrite parameters in <code>par.list</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List of individuals.
</p>

<hr>
<h2 id='generatesMultipleChildren'>Does the recombinator generate multiple children?</h2><span id='topic+generatesMultipleChildren'></span>

<h3>Description</h3>

<p>Returns as to whether the recombinator generates multiple Children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatesMultipleChildren(recombinator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatesMultipleChildren_+3A_recombinator">recombinator</code></td>
<td>
<p>[<code>function</code>]<br />
Actual mutation operator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical</code>]
Boolean
</p>

<hr>
<h2 id='generators'>Population generators</h2><span id='topic+generators'></span><span id='topic+gen'></span><span id='topic+genBin'></span><span id='topic+genPerm'></span><span id='topic+genReal'></span>

<h3>Description</h3>

<p>Utility functions to build a set of individuals. The function
<code>gen</code> expects an R expression and a number n in order to create a list
of n individuals based on the given expression. Functions <code>genBin</code>,
<code>genPerm</code> and <code>genReal</code> are shortcuts for initializing populations
of binary strings, permutations or real-valued vectors respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen(expr, n)

genBin(n, n.dim)

genPerm(n, n.dim)

genReal(n, n.dim, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generators_+3A_expr">expr</code></td>
<td>
<p>[R expression]<br />
Expression to generate a single individual.</p>
</td></tr>
<tr><td><code id="generators_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of individuals to create.</p>
</td></tr>
<tr><td><code id="generators_+3A_n.dim">n.dim</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Dimension of the decision space.</p>
</td></tr>
<tr><td><code id="generators_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values for each parameter of the decision space in case
of float encoding.</p>
</td></tr>
<tr><td><code id="generators_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values for each parameter of the decision space in case
of float encoding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>]
</p>

<hr>
<h2 id='getFront'>Extract fitness values from Pareto archive.</h2><span id='topic+getFront'></span>

<h3>Description</h3>

<p>Get all non-dominated points in objective space, i.e., an (m x n)
matrix of fitness with m being the number of objectives and n being the number
of non-dominated points in the Pareto archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFront(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFront_+3A_x">x</code></td>
<td>
<p>[<code>ecr_pareto_archive</code>]<br />
Pareto archive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix</code>]
</p>

<hr>
<h2 id='getIndividuals'>Extract individuals from Pareto archive.</h2><span id='topic+getIndividuals'></span>

<h3>Description</h3>

<p>Get the non-dominated individuals logged in the Pareto archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIndividuals(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIndividuals_+3A_x">x</code></td>
<td>
<p>[<code>ecr_pareto_archive</code>]<br />
Pareto archive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>]
</p>


<h3>See Also</h3>

<p>Other ParetoArchive: 
<code><a href="#topic+getSize">getSize</a>()</code>,
<code><a href="#topic+initParetoArchive">initParetoArchive</a>()</code>,
<code><a href="#topic+updateParetoArchive">updateParetoArchive</a>()</code>
</p>

<hr>
<h2 id='getNumberOfChildren'>Number of children</h2><span id='topic+getNumberOfChildren'></span>

<h3>Description</h3>

<p>Returns the number children generated by the recombinator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfChildren(recombinator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfChildren_+3A_recombinator">recombinator</code></td>
<td>
<p>[<code>function</code>]<br />
Actual mutation operator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>]
Number of children generated
</p>

<hr>
<h2 id='getNumberOfParentsNeededForMating'>Number of parents  needed for mating</h2><span id='topic+getNumberOfParentsNeededForMating'></span>

<h3>Description</h3>

<p>Returns the number of parents needed for mating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfParentsNeededForMating(recombinator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfParentsNeededForMating_+3A_recombinator">recombinator</code></td>
<td>
<p>[<code>function</code>]<br />
Actual mutation operator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>]
Number of Parents need for mating
</p>

<hr>
<h2 id='getPopulationFitness'>Access to logged population fitness.</h2><span id='topic+getPopulationFitness'></span>

<h3>Description</h3>

<p>Returns the fitness values of all individuals as a data.frame
with columns f1, ..., fo, where o is the number of objectives and column
&ldquo;gen&rdquo; for generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPopulationFitness(log, trim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPopulationFitness_+3A_log">log</code></td>
<td>
<p>[<code>ecr_logger</code>]<br />
The log generated by <code>initLogger</code>.</p>
</td></tr>
<tr><td><code id="getPopulationFitness_+3A_trim">trim</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should unused lines in the logged be cut off?
Usually one wants this behaviour.
Thus the default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List of populations.
</p>


<h3>See Also</h3>

<p>Other logging: 
<code><a href="#topic+getPopulations">getPopulations</a>()</code>,
<code><a href="#topic+getStatistics">getStatistics</a>()</code>,
<code><a href="#topic+initLogger">initLogger</a>()</code>,
<code><a href="#topic+updateLogger">updateLogger</a>()</code>
</p>

<hr>
<h2 id='getPopulations'>Access to logged populations.</h2><span id='topic+getPopulations'></span>

<h3>Description</h3>

<p>Simple getter for the logged populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPopulations(log, trim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPopulations_+3A_log">log</code></td>
<td>
<p>[<code>ecr_logger</code>]<br />
The log generated by <code>initLogger</code>.</p>
</td></tr>
<tr><td><code id="getPopulations_+3A_trim">trim</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should unused lines in the logged be cut off?
Usually one wants this behaviour.
Thus the default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions throws an error if the logger was initialized with
<code>log.pop = FALSE</code> (see <code>initLogger</code>).
</p>


<h3>Value</h3>

<p>[<code>list</code>] List of populations.
</p>


<h3>See Also</h3>

<p>Other logging: 
<code><a href="#topic+getPopulationFitness">getPopulationFitness</a>()</code>,
<code><a href="#topic+getStatistics">getStatistics</a>()</code>,
<code><a href="#topic+initLogger">initLogger</a>()</code>,
<code><a href="#topic+updateLogger">updateLogger</a>()</code>
</p>

<hr>
<h2 id='getSize'>Get size of Pareto-archive.</h2><span id='topic+getSize'></span>

<h3>Description</h3>

<p>Returns the number of stored individuals in Pareto archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSize_+3A_x">x</code></td>
<td>
<p>[<code>ecr_pareto_archive</code>]<br />
Pareto archive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer(1)</code>]
</p>


<h3>See Also</h3>

<p>Other ParetoArchive: 
<code><a href="#topic+getIndividuals">getIndividuals</a>()</code>,
<code><a href="#topic+initParetoArchive">initParetoArchive</a>()</code>,
<code><a href="#topic+updateParetoArchive">updateParetoArchive</a>()</code>
</p>

<hr>
<h2 id='getStatistics'>Access the logged statistics.</h2><span id='topic+getStatistics'></span>

<h3>Description</h3>

<p>Simple getter for the logged fitness statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStatistics(log, trim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStatistics_+3A_log">log</code></td>
<td>
<p>[<code>ecr_logger</code>]<br />
The log generated by <code>initLogger</code>.</p>
</td></tr>
<tr><td><code id="getStatistics_+3A_trim">trim</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should unused lines in the logged be cut off?
Usually one wants this behaviour.
Thus the default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>data.frame</code>] Logged statistics.
</p>


<h3>See Also</h3>

<p>Other logging: 
<code><a href="#topic+getPopulationFitness">getPopulationFitness</a>()</code>,
<code><a href="#topic+getPopulations">getPopulations</a>()</code>,
<code><a href="#topic+initLogger">initLogger</a>()</code>,
<code><a href="#topic+updateLogger">updateLogger</a>()</code>
</p>

<hr>
<h2 id='getSupportedRepresentations'>Get supported representations.</h2><span id='topic+getSupportedRepresentations'></span>

<h3>Description</h3>

<p>Returns the character vector of representation which the operator supports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSupportedRepresentations(operator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSupportedRepresentations_+3A_operator">operator</code></td>
<td>
<p>[<code>ecr_operator</code>]<br />
Operator object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character</code>]
Vector of representation types.
</p>

<hr>
<h2 id='initECRControl'>Control object generator.</h2><span id='topic+initECRControl'></span>

<h3>Description</h3>

<p>The control object keeps information on the objective function and a set of
evolutionary components, i.e., operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initECRControl(fitness.fun, n.objectives = NULL, minimize = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initECRControl_+3A_fitness.fun">fitness.fun</code></td>
<td>
<p>[<code>function</code>]<br />
The fitness function.</p>
</td></tr>
<tr><td><code id="initECRControl_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives of <code>obj.fun</code>.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="initECRControl_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical(n.objectives)</code>]<br />
Logical vector with ith entry <code>TRUE</code> if the ith objective of <code>fitness.fun</code>
shall be minimized. If a single logical is passed, it is assumed to be valid
for each objective.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_control</code>]
</p>

<hr>
<h2 id='initLogger'>Initialize a log object.</h2><span id='topic+initLogger'></span>

<h3>Description</h3>

<p>Logging is a central aspect of each EA. Besides the final solution(s)
especially in research often we need to keep track of different aspects of the
evolutionary process, e.g., fitness statistics. The logger of ecr keeps
track of different user-defined statistics and the population.
It may also be used to check stopping conditions (see <code>makeECRTerminator</code>). Most
important this logger is used internally by the <code><a href="#topic+ecr">ecr</a></code> black-box interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initLogger(
  control,
  log.stats = list(fitness = list("min", "mean", "max")),
  log.extras = NULL,
  log.pop = FALSE,
  init.size = 1000L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initLogger_+3A_control">control</code></td>
<td>
<p>[<code>ecr_control</code>]<br />
Control object.</p>
</td></tr>
<tr><td><code id="initLogger_+3A_log.stats">log.stats</code></td>
<td>
<p>[<code>list</code>]<br />
List of lists for statistic computation on attributes of the individuals
of the population. Each entry should be named by the attribute it should be
based on, e.g., fitness, and should contain a list of R functions as a
character string or a a list with elements <code>fun</code> for the function, and <code>pars</code> for additional
parameters which shall be passed to the corresponding function.
Each function is required to return a scalar numeric value.
By default the minimum, mean and maximum of the fitness values is computed.
Since fitness statistics are the most important ones these do not have to
be stored as attributes, but can be passed as a matrix to the update function.</p>
</td></tr>
<tr><td><code id="initLogger_+3A_log.extras">log.extras</code></td>
<td>
<p>[<code>character</code>]<br />
Possibility to instruct the logger to store additional
scalar values in each generation. Named character vector where the names
indicate the value to store and the value indicates the corresponding data types.
Currently we support all atomic modes of <code><a href="base.html#topic+vector">vector</a></code> expect &ldquo;factor&rdquo;
and &ldquo;raw&rdquo;.</p>
</td></tr>
<tr><td><code id="initLogger_+3A_log.pop">log.pop</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Shall the entire population be saved in each generation?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="initLogger_+3A_init.size">init.size</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Initial number of rows of the slot of the logger, where the fitness
statistics are stored. The size of the statistics log is doubled each time an
overflow occurs.
Default is 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_logger</code>]
An S3 object of class <code>ecr_logger</code> with the following components:
</p>

<dl>
<dt>log.stats</dt><dd><p>The <code>log.stats</code> list.</p>
</dd>
<dt>log.pop</dt><dd><p>The <code>log.pop</code> parameter.</p>
</dd>
<dt>init.size</dt><dd><p>Initial size of the log.</p>
</dd>
<dt>env</dt><dd><p>The actual log. This is an R environment which ensures, that
in-place modification is possible.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Statistics are logged in a <code>data.frame</code>.
</p>


<h3>See Also</h3>

<p>Other logging: 
<code><a href="#topic+getPopulationFitness">getPopulationFitness</a>()</code>,
<code><a href="#topic+getPopulations">getPopulations</a>()</code>,
<code><a href="#topic+getStatistics">getStatistics</a>()</code>,
<code><a href="#topic+updateLogger">updateLogger</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control = initECRControl(function(x) sum(x), minimize = TRUE,
  n.objectives = 1L)
control = registerECROperator(control, "mutate", mutBitflip, p = 0.1)
control = registerECROperator(control, "selectForMating", selTournament, k = 2)
control = registerECROperator(control, "selectForSurvival", selGreedy)

log = initLogger(control,
  log.stats = list(
    fitness = list("mean", "myRange" = function(x) max(x) - min(x)),
    age = list("min", "max")
  ), log.pop = TRUE, init.size = 1000L)

 # simply pass stuff down to control object constructor
population = initPopulation(mu = 10L, genBin, n.dim = 10L)
fitness = evaluateFitness(control, population)

# append fitness to individuals and init age
for (i in seq_along(population)) {
  attr(population[[i]], "fitness") = fitness[, i]
  attr(population[[i]], "age") = 1L
}

for (iter in seq_len(10)) {
  # generate offspring
  offspring = generateOffspring(control, population, fitness, lambda = 5)
  fitness.offspring = evaluateFitness(control, offspring)

  # update age of population
  for (i in seq_along(population)) {
    attr(population[[i]], "age") = attr(population[[i]], "age") + 1L
  }

  # set offspring attributes
  for (i in seq_along(offspring)) {
    attr(offspring[[i]], "fitness") = fitness.offspring[, i]
    # update age
    attr(offspring[[i]], "age") = 1L
  }

  sel = replaceMuPlusLambda(control, population, offspring)

  population = sel$population
  fitness = sel$fitness

  # do some logging
  updateLogger(log, population, n.evals = 5)
}
head(getStatistics(log))
</code></pre>

<hr>
<h2 id='initParetoArchive'>Initialize Pareto Archive.</h2><span id='topic+initParetoArchive'></span>

<h3>Description</h3>

<p>A Pareto archive is usually used to store all / a part of the
non-dominated points stored during a run of an multi-objective evolutionary
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initParetoArchive(control, max.size = Inf, trunc.fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initParetoArchive_+3A_control">control</code></td>
<td>
<p>[<code>ecr_control</code>]<br />
Control object.</p>
</td></tr>
<tr><td><code id="initParetoArchive_+3A_max.size">max.size</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximum capacity of the Pareto archive, i.e., the maximal number of non-dominated
points which can be stored in the archive. Default is <code>Inf</code>, i.e., (theoretically)
unbounded capacity.</p>
</td></tr>
<tr><td><code id="initParetoArchive_+3A_trunc.fun">trunc.fun</code></td>
<td>
<p>[<code>function(archive, inds, fitness, ...)</code>]<br />
In case the archive is limited in capacity, i.e., <code>max.size</code> is not infinite,
this function is called internally if an archive overflow occurs. This function
expects the <code>archive</code>, a list of individuals <code>inds</code>, a matrix of fitness
values (each column contains the fitness value(s) of one individual) <code>fitness</code>
and further optional arguments <code>...</code> which may be used by the internals
of <code>trunc.fun</code>. The function must return a list with components &ldquo;fitness&rdquo;
and &ldquo;inds&rdquo; which shall be the subsets of <code>fitness</code> and <code>inds</code>
respectively, which should be kept by the archive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_pareto_archive</code>]
</p>


<h3>See Also</h3>

<p>Other ParetoArchive: 
<code><a href="#topic+getIndividuals">getIndividuals</a>()</code>,
<code><a href="#topic+getSize">getSize</a>()</code>,
<code><a href="#topic+updateParetoArchive">updateParetoArchive</a>()</code>
</p>

<hr>
<h2 id='initPopulation'>Helper function to build initial population.</h2><span id='topic+initPopulation'></span>

<h3>Description</h3>

<p>Generates the initial population. Optionally a set of initial solutions
can be passed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initPopulation(mu, gen.fun, initial.solutions = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initPopulation_+3A_mu">mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of individuals in the population.</p>
</td></tr>
<tr><td><code id="initPopulation_+3A_gen.fun">gen.fun</code></td>
<td>
<p>[<code>function</code>]<br />
Function used to generate initial solutions, e.g., <code><a href="#topic+genBin">genBin</a></code>.</p>
</td></tr>
<tr><td><code id="initPopulation_+3A_initial.solutions">initial.solutions</code></td>
<td>
<p>[<code>list</code>]<br />
List of individuals which should be placed in the initial population.
If the number of passed individuals
is lower than <code>mu</code>, the population will be filled up
by individuals generated by the corresponding generator.
Default is <code>NULL</code>, i.e., the entire population is generated by the
population generator.</p>
</td></tr>
<tr><td><code id="initPopulation_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further parameters passed to <code>gen.fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_population</code>]
</p>

<hr>
<h2 id='is.supported'>Check if ecr operator supports given representation.</h2><span id='topic+is.supported'></span>

<h3>Description</h3>

<p>Check if the given operator supportds a certain representation, e.g., &ldquo;float&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.supported(operator, representation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.supported_+3A_operator">operator</code></td>
<td>
<p>[<code>ecr_operator</code>]<br />
Object of type <code>ecr_operator</code>.</p>
</td></tr>
<tr><td><code id="is.supported_+3A_representation">representation</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Representation as a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
<code>TRUE</code>, if operator supports the representation type.
</p>

<hr>
<h2 id='isEcrOperator'>Check if given function is an ecr operator.</h2><span id='topic+isEcrOperator'></span>

<h3>Description</h3>

<p>Checks if the passed object is of type <code>ecr_operator</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isEcrOperator(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isEcrOperator_+3A_obj">obj</code></td>
<td>
<p>[any]<br />
Arbitrary R object to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='makeECRMonitor'>Factory method for monitor objects.</h2><span id='topic+makeECRMonitor'></span>

<h3>Description</h3>

<p>Monitor objects serve for monitoring the optimization process, e.g., printing
some status messages to the console. Each monitor includes the functions
<code>before</code>, <code>step</code> and <code>after</code>, each being a function and expecting
a log <code>log</code> of type <code>ecr_logger</code> and <code>...</code> as the only parameters.
This way the logger has access to the entire log.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeECRMonitor(before = NULL, step = NULL, after = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeECRMonitor_+3A_before">before</code></td>
<td>
<p>[<code>function</code>]<br />
Function called one time after initialization of the EA.</p>
</td></tr>
<tr><td><code id="makeECRMonitor_+3A_step">step</code></td>
<td>
<p>[<code>function</code>]<br />
Function applied after each iteration of the algorithm.</p>
</td></tr>
<tr><td><code id="makeECRMonitor_+3A_after">after</code></td>
<td>
<p>[<code>function</code>]<br />
Function applied after the EA terminated.</p>
</td></tr>
<tr><td><code id="makeECRMonitor_+3A_...">...</code></td>
<td>
<p>[<code>any</code>]<br />
Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_monitor</code>]
Monitor object.
</p>

<hr>
<h2 id='makeEMOAIndicator'>Constructor for EMOA indicators.</h2><span id='topic+makeEMOAIndicator'></span>

<h3>Description</h3>

<p>Simple wrapper for function which compute
performance indicators for multi-objective stochastic algorithm.
Basically this function appends some meta information to the
passed function <code>fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeEMOAIndicator(fun, minimize, name, latex.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeEMOAIndicator_+3A_fun">fun</code></td>
<td>
<p>[<code>function(points, ...)</code>]<br />
Function which expects a numeric matrix &ldquo;points&rdquo; as first argument.
Optional named arguments (often &ldquo;ref.point&rdquo; for a reference
point or &ldquo;ref.points&rdquo; for a reference set, e.g., the true Pareto-front)
are allowed. See implementations of existing indicators for examples.</p>
</td></tr>
<tr><td><code id="makeEMOAIndicator_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Lower values indicate better performance?</p>
</td></tr>
<tr><td><code id="makeEMOAIndicator_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Short name of the indicator. Used, e.g., as column name for the indicator
in the data.frame returned by <code><a href="#topic+computeIndicators">computeIndicators</a></code>.</p>
</td></tr>
<tr><td><code id="makeEMOAIndicator_+3A_latex.name">latex.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
LaTeX representation of the indicator. Used in LaTeX-table output statistical
tests (see <code><a href="#topic+toLatex">toLatex</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>function(points, ...)</code>] Argument <code>fun</code> with all other
arguments appended.
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='makeMutator'>Construct a mutation operator.</h2><span id='topic+makeMutator'></span>

<h3>Description</h3>

<p>Helper function which constructs a mutator, i. e., a mutation operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMutator(mutator, supported = getAvailableRepresentations())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMutator_+3A_mutator">mutator</code></td>
<td>
<p>[<code>function</code>]<br />
Actual mutation operator.</p>
</td></tr>
<tr><td><code id="makeMutator_+3A_supported">supported</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of strings/names of supported parameter representations. Possible choices:
&ldquo;permutation&rdquo;, &ldquo;float&rdquo;, &ldquo;binary&rdquo; or &ldquo;custom&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_mutator</code>]
Mutator object.
</p>

<hr>
<h2 id='makeOperator'>Construct evolutionary operator.</h2><span id='topic+makeOperator'></span>

<h3>Description</h3>

<p>Helper function which constructs an evolutionary operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeOperator(operator, supported = getAvailableRepresentations())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeOperator_+3A_operator">operator</code></td>
<td>
<p>[<code>function</code>]<br />
Actual operator.</p>
</td></tr>
<tr><td><code id="makeOperator_+3A_supported">supported</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of names of supported parameter representations. Possible choices:
&ldquo;permutation&rdquo;, &ldquo;float&rdquo;, &ldquo;binary&rdquo; or &ldquo;custom&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_operator</code>] Operator object.
</p>


<h3>Note</h3>

<p>In general you will not need this function, but rather one of its
deriviatives like <code><a href="#topic+makeMutator">makeMutator</a></code> or <code><a href="#topic+makeSelector">makeSelector</a></code>.
</p>

<hr>
<h2 id='makeOptimizationTask'>Creates an optimization task.</h2><span id='topic+makeOptimizationTask'></span>

<h3>Description</h3>

<p>An optimization task consists of the fitness/objective function, the
number of objectives, the &ldquo;direction&rdquo; of optimization, i.e.,
which objectives should be minimized/maximized and the names of the
objectives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeOptimizationTask(
  fun,
  n.objectives = NULL,
  minimize = NULL,
  objective.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeOptimizationTask_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code> | <code>smoof_function</code>]<br />
Fitness/objective function.</p>
</td></tr>
<tr><td><code id="makeOptimizationTask_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives. This must be a positive integer value unless <code>fun</code>
is of type <code>smoof_function</code>.</p>
</td></tr>
<tr><td><code id="makeOptimizationTask_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical</code>]<br />
A logical vector indicating which objectives to minimize/maximize. By default
all objectives are assumed to be minimized.</p>
</td></tr>
<tr><td><code id="makeOptimizationTask_+3A_objective.names">objective.names</code></td>
<td>
<p>[<code>character</code>]<br />
Names for the objectuves.
Default is <code>NULL</code>. In this case the names are set to y1, ..., yn with
n equal to <code>n.objectives</code> and simply y in the single-objective case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_optimization_task</code>]
</p>

<hr>
<h2 id='makeRecombinator'>Construct a recombination operator.</h2><span id='topic+makeRecombinator'></span>

<h3>Description</h3>

<p>Helper function which constructs a recombinator, i. e., a recombination operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeRecombinator(
  recombinator,
  supported = getAvailableRepresentations(),
  n.parents = 2L,
  n.children = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeRecombinator_+3A_recombinator">recombinator</code></td>
<td>
<p>[<code>function</code>]<br />
Actual mutation operator.</p>
</td></tr>
<tr><td><code id="makeRecombinator_+3A_supported">supported</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of strings/names of supported parameter representations. Possible choices:
&ldquo;permutation&rdquo;, &ldquo;float&rdquo;, &ldquo;binary&rdquo; or &ldquo;custom&rdquo;.</p>
</td></tr>
<tr><td><code id="makeRecombinator_+3A_n.parents">n.parents</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of parents supported.</p>
</td></tr>
<tr><td><code id="makeRecombinator_+3A_n.children">n.children</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
How many children does the recombinator produce?
Default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_recombinator</code>]
Recombinator object.
</p>


<h3>Note</h3>

<p>If a recombinator returns more than one child, the <code>multiple.children</code>
parameter needs to be <code>TRUE</code>, which is the default. In case of multiple
children produced these have to be placed within a list.
</p>

<hr>
<h2 id='makeSelector'>Construct a selection operator.</h2><span id='topic+makeSelector'></span>

<h3>Description</h3>

<p>Helper function which defines a selector method, i. e., an operator which
takes the population and returns a part of it for mating or survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSelector(
  selector,
  supported = getAvailableRepresentations(),
  supported.objectives,
  supported.opt.direction = "minimize"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSelector_+3A_selector">selector</code></td>
<td>
<p>[<code>function</code>]<br />
Actual selection operator.</p>
</td></tr>
<tr><td><code id="makeSelector_+3A_supported">supported</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of strings/names of supported parameter representations. Possible choices:
&ldquo;permutation&rdquo;, &ldquo;float&rdquo;, &ldquo;binary&rdquo; or &ldquo;custom&rdquo;.</p>
</td></tr>
<tr><td><code id="makeSelector_+3A_supported.objectives">supported.objectives</code></td>
<td>
<p>[<code>character</code>]<br />
At least one of &ldquo;single-objective&rdquo; or &ldquo;multi-objective&rdquo;.</p>
</td></tr>
<tr><td><code id="makeSelector_+3A_supported.opt.direction">supported.opt.direction</code></td>
<td>
<p>[<code>character(1-2)</code>]<br />
Does the selector work for maximization tasks xor minimization tasks or both?
Default is &ldquo;<code>minimize</code>&rdquo;, which means that the selector selects
in favour of low fitness values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_selector</code>]
Selector object.
</p>

<hr>
<h2 id='makeTerminator'>Generate stopping condition.</h2><span id='topic+makeTerminator'></span>

<h3>Description</h3>

<p>Wrap a function within a stopping condition object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTerminator(condition.fun, name, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTerminator_+3A_condition.fun">condition.fun</code></td>
<td>
<p>[<code>function</code>]<br />
Function which takes a logger object <code>log</code> (see <code><a href="#topic+initLogger">initLogger</a></code>)
and returns a single logical.</p>
</td></tr>
<tr><td><code id="makeTerminator_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Identifier for the stopping condition.</p>
</td></tr>
<tr><td><code id="makeTerminator_+3A_message">message</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Message which should be stored in the termination object, if the stopping
condition is met.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_terminator</code>]
</p>

<hr>
<h2 id='mcMST'>mcMST</h2><span id='topic+mcMST'></span>

<h3>Description</h3>

<p>Pareto-front approximations for some graph problems obtained by several
algorithms for the multi-criteria minimum spanning tree (mcMST) problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcMST
</code></pre>


<h3>Format</h3>

<p>A data frame with four variables:
</p>

<dl>
<dt><code>f1</code></dt><dd><p>First objective (to be minimized).</p>
</dd>
<dt><code>f2</code></dt><dd><p>Second objective (to be minimized).</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Short name of algorithm used.</p>
</dd>
<dt><code>prob</code></dt><dd><p>Short name of problem instance.</p>
</dd>
<dt><code>repl</code></dt><dd><p>Algorithm run.</p>
</dd>
</dl>

<p>The data is based on the <span class="pkg">mcMST</span> package.
</p>

<hr>
<h2 id='mutBitflip'>Bitplip mutator.</h2><span id='topic+mutBitflip'></span>

<h3>Description</h3>

<p>This operator works only on binary representation and flips each bit
with a given probability <code class="reqn">p \in (0, 1)</code>. Usually it is recommended to
set <code class="reqn">p = \frac{1}{n}</code> where <code class="reqn">n</code> is the number of bits in the
representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutBitflip(ind, p = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutBitflip_+3A_ind">ind</code></td>
<td>
<p>[<code>binary</code>]<br />
Binary vector, i.e., vector with elements 0 and 1 only.</p>
</td></tr>
<tr><td><code id="mutBitflip_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability to flip a single bit.
Default is <code>0.1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>binary</code>]
</p>


<h3>References</h3>

<p>[1] Eiben, A. E. &amp; Smith, James E. (2015). Introduction to Evolutionary
Computing (2nd ed.). Springer Publishing Company, Incorporated. 52.
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+mutGauss">mutGauss</a>()</code>,
<code><a href="#topic+mutInsertion">mutInsertion</a>()</code>,
<code><a href="#topic+mutInversion">mutInversion</a>()</code>,
<code><a href="#topic+mutJump">mutJump</a>()</code>,
<code><a href="#topic+mutPolynomial">mutPolynomial</a>()</code>,
<code><a href="#topic+mutScramble">mutScramble</a>()</code>,
<code><a href="#topic+mutSwap">mutSwap</a>()</code>,
<code><a href="#topic+mutUniform">mutUniform</a>()</code>
</p>

<hr>
<h2 id='mutGauss'>Gaussian mutator.</h2><span id='topic+mutGauss'></span>

<h3>Description</h3>

<p>Default Gaussian mutation operator known from Evolutionary Algorithms.
This mutator is applicable only for <code>representation="float"</code>. Given
an individual <code class="reqn">\mathbf{x} \in R^l</code> this mutator adds a Gaussian
distributed random value to each component of <code class="reqn">\mathbf{x}</code>, i.~e.,
<code class="reqn">\tilde{\mathbf{x}}_i = \mathbf{x}_i + \sigma \mathcal{N}(0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutGauss(ind, p = 1L, sdev = 0.05, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutGauss_+3A_ind">ind</code></td>
<td>
<p>[<code>numeric</code>]<br />
Numeric vector / individual to mutate.</p>
</td></tr>
<tr><td><code id="mutGauss_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability of mutation for the gauss mutation operator.</p>
</td></tr>
<tr><td><code id="mutGauss_+3A_sdev">sdev</code></td>
<td>
<p>[<code>numeric(1)</code><br />
Standard deviance of the Gauss mutation, i. e., the mutation strength.</p>
</td></tr>
<tr><td><code id="mutGauss_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values for each parameter of the decision space.</p>
</td></tr>
<tr><td><code id="mutGauss_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values for each parameter of the decision space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>]
</p>


<h3>References</h3>

<p>[1] Beyer, Hans-Georg &amp; Schwefel, Hans-Paul (2002). Evolution strategies. 
Kluwer Academic Publishers.
</p>
<p>[2] Mateo, P. M. &amp; Alberto, I. (2011). A mutation operator based
on a Pareto ranking for multi-objective evolutionary algorithms. 
Springer Science+Business Meda. 57.
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+mutBitflip">mutBitflip</a>()</code>,
<code><a href="#topic+mutInsertion">mutInsertion</a>()</code>,
<code><a href="#topic+mutInversion">mutInversion</a>()</code>,
<code><a href="#topic+mutJump">mutJump</a>()</code>,
<code><a href="#topic+mutPolynomial">mutPolynomial</a>()</code>,
<code><a href="#topic+mutScramble">mutScramble</a>()</code>,
<code><a href="#topic+mutSwap">mutSwap</a>()</code>,
<code><a href="#topic+mutUniform">mutUniform</a>()</code>
</p>

<hr>
<h2 id='mutInsertion'>Insertion mutator.</h2><span id='topic+mutInsertion'></span>

<h3>Description</h3>

<p>The Insertion mutation operator selects a position random and inserts it at
a random position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutInsertion(ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutInsertion_+3A_ind">ind</code></td>
<td>
<p>[<code>integer</code>]<br />
Permutation of integers, i.e., vector of integer values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>]
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+mutBitflip">mutBitflip</a>()</code>,
<code><a href="#topic+mutGauss">mutGauss</a>()</code>,
<code><a href="#topic+mutInversion">mutInversion</a>()</code>,
<code><a href="#topic+mutJump">mutJump</a>()</code>,
<code><a href="#topic+mutPolynomial">mutPolynomial</a>()</code>,
<code><a href="#topic+mutScramble">mutScramble</a>()</code>,
<code><a href="#topic+mutSwap">mutSwap</a>()</code>,
<code><a href="#topic+mutUniform">mutUniform</a>()</code>
</p>

<hr>
<h2 id='mutInversion'>Inversion mutator.</h2><span id='topic+mutInversion'></span>

<h3>Description</h3>

<p>The Inversion mutation operator selects two positions within the chromosome at
random and inverts the elements inbetween.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutInversion(ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutInversion_+3A_ind">ind</code></td>
<td>
<p>[<code>integer</code>]<br />
Permutation of integers, i.e., vector of integer values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>]
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+mutBitflip">mutBitflip</a>()</code>,
<code><a href="#topic+mutGauss">mutGauss</a>()</code>,
<code><a href="#topic+mutInsertion">mutInsertion</a>()</code>,
<code><a href="#topic+mutJump">mutJump</a>()</code>,
<code><a href="#topic+mutPolynomial">mutPolynomial</a>()</code>,
<code><a href="#topic+mutScramble">mutScramble</a>()</code>,
<code><a href="#topic+mutSwap">mutSwap</a>()</code>,
<code><a href="#topic+mutUniform">mutUniform</a>()</code>
</p>

<hr>
<h2 id='mutJump'>Jump mutator.</h2><span id='topic+mutJump'></span>

<h3>Description</h3>

<p>The jump mutation operator selects two positions within the chromosome at
random, say <code class="reqn">a</code> and <code class="reqn">b</code> with <code class="reqn">a &lt; b</code>. Next, all elements at
positions <code class="reqn">b-1, b-2, ..., a</code> are shifted to the right by one position
and finally the element at position <code class="reqn">b</code> is assigned at position <code class="reqn">a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutJump(ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutJump_+3A_ind">ind</code></td>
<td>
<p>[<code>integer</code>]<br />
Permutation of integers, i.e., vector of integer values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>]
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+mutBitflip">mutBitflip</a>()</code>,
<code><a href="#topic+mutGauss">mutGauss</a>()</code>,
<code><a href="#topic+mutInsertion">mutInsertion</a>()</code>,
<code><a href="#topic+mutInversion">mutInversion</a>()</code>,
<code><a href="#topic+mutPolynomial">mutPolynomial</a>()</code>,
<code><a href="#topic+mutScramble">mutScramble</a>()</code>,
<code><a href="#topic+mutSwap">mutSwap</a>()</code>,
<code><a href="#topic+mutUniform">mutUniform</a>()</code>
</p>

<hr>
<h2 id='mutPolynomial'>Polynomial mutation.</h2><span id='topic+mutPolynomial'></span>

<h3>Description</h3>

<p>Performs an polynomial mutation as used in the SMS-EMOA algorithm.
Polynomial mutation tries to simulate the distribution of the offspring of 
binary-encoded bit flip mutations based on real-valued decision variables. 
Polynomial mutation favors offspring nearer to the parent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutPolynomial(ind, p = 0.2, eta = 10, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutPolynomial_+3A_ind">ind</code></td>
<td>
<p>[<code>numeric</code>]<br />
Numeric vector / individual to mutate.</p>
</td></tr>
<tr><td><code id="mutPolynomial_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability of mutation for each gene of an offspring. In other words, 
the probability that the value (allele) of a given gene will change.
Default is 0.2</p>
</td></tr>
<tr><td><code id="mutPolynomial_+3A_eta">eta</code></td>
<td>
<p>[<code>numeric(1)</code><br />
Distance parameter to control the shape of the mutation distribution. 
Larger values generate offspring closer to the parents.
Default is 10.</p>
</td></tr>
<tr><td><code id="mutPolynomial_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values for each parameter of the decision space.
Must have the same length as <code>ind</code>.</p>
</td></tr>
<tr><td><code id="mutPolynomial_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values for each parameter of the decision space.
Must have the same length as <code>ind</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>]
</p>


<h3>References</h3>

<p>[1] Deb, Kalyanmoy &amp; Goyal, Mayank. (1999). A Combined Genetic Adaptive 
Search (GeneAS) for Engineering Design. Computer Science and Informatics. 26.
Retrieved from http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.767&amp;rep=rep1&amp;type=pdf
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+mutBitflip">mutBitflip</a>()</code>,
<code><a href="#topic+mutGauss">mutGauss</a>()</code>,
<code><a href="#topic+mutInsertion">mutInsertion</a>()</code>,
<code><a href="#topic+mutInversion">mutInversion</a>()</code>,
<code><a href="#topic+mutJump">mutJump</a>()</code>,
<code><a href="#topic+mutScramble">mutScramble</a>()</code>,
<code><a href="#topic+mutSwap">mutSwap</a>()</code>,
<code><a href="#topic+mutUniform">mutUniform</a>()</code>
</p>

<hr>
<h2 id='mutScramble'>Scramble mutator.</h2><span id='topic+mutScramble'></span>

<h3>Description</h3>

<p>The Scramble mutation operator selects two positions within the chromosome at
random and randomly intermixes the subsequence between these positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutScramble(ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutScramble_+3A_ind">ind</code></td>
<td>
<p>[<code>integer</code>]<br />
Permutation of integers, i.e., vector of integer values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>]
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+mutBitflip">mutBitflip</a>()</code>,
<code><a href="#topic+mutGauss">mutGauss</a>()</code>,
<code><a href="#topic+mutInsertion">mutInsertion</a>()</code>,
<code><a href="#topic+mutInversion">mutInversion</a>()</code>,
<code><a href="#topic+mutJump">mutJump</a>()</code>,
<code><a href="#topic+mutPolynomial">mutPolynomial</a>()</code>,
<code><a href="#topic+mutSwap">mutSwap</a>()</code>,
<code><a href="#topic+mutUniform">mutUniform</a>()</code>
</p>

<hr>
<h2 id='mutSwap'>Swap mutator.</h2><span id='topic+mutSwap'></span>

<h3>Description</h3>

<p>Chooses two positions at random and swaps the genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutSwap(ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutSwap_+3A_ind">ind</code></td>
<td>
<p>[<code>integer</code>]<br />
Permutation of integers, i.e., vector of integer values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>]
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+mutBitflip">mutBitflip</a>()</code>,
<code><a href="#topic+mutGauss">mutGauss</a>()</code>,
<code><a href="#topic+mutInsertion">mutInsertion</a>()</code>,
<code><a href="#topic+mutInversion">mutInversion</a>()</code>,
<code><a href="#topic+mutJump">mutJump</a>()</code>,
<code><a href="#topic+mutPolynomial">mutPolynomial</a>()</code>,
<code><a href="#topic+mutScramble">mutScramble</a>()</code>,
<code><a href="#topic+mutUniform">mutUniform</a>()</code>
</p>

<hr>
<h2 id='mutUniform'>Uniform mutator.</h2><span id='topic+mutUniform'></span>

<h3>Description</h3>

<p>This mutation operator works on real-valued genotypes only. It selects a position
in the solution vector at random and replaced it with a uniformally chosen value
within the box constraints of the corresponding parameter.
This mutator may proof beneficial in early stages of the optimization process,
since it distributes points widely within the box constraints and thus may
hinder premature convergence. However, in later stages - when fine tuning is
necessary, this feature is disadvantegous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutUniform(ind, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutUniform_+3A_ind">ind</code></td>
<td>
<p>[<code>numeric</code>]<br />
Numeric vector / individual to mutate.</p>
</td></tr>
<tr><td><code id="mutUniform_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values for each parameter of the decision space.</p>
</td></tr>
<tr><td><code id="mutUniform_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values for each parameter of the decision space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>]
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+mutBitflip">mutBitflip</a>()</code>,
<code><a href="#topic+mutGauss">mutGauss</a>()</code>,
<code><a href="#topic+mutInsertion">mutInsertion</a>()</code>,
<code><a href="#topic+mutInversion">mutInversion</a>()</code>,
<code><a href="#topic+mutJump">mutJump</a>()</code>,
<code><a href="#topic+mutPolynomial">mutPolynomial</a>()</code>,
<code><a href="#topic+mutScramble">mutScramble</a>()</code>,
<code><a href="#topic+mutSwap">mutSwap</a>()</code>
</p>

<hr>
<h2 id='niceCellFormater'>Formatter for table cells of LaTeX tables.</h2><span id='topic+niceCellFormater'></span>

<h3>Description</h3>

<p>This formatter function should be applied to
tables where each table cell contains a <code class="reqn">p</code>-value of
a statistical significance test. See <code><a href="#topic+toLatex">toLatex</a></code>
for an application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niceCellFormater(cell, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niceCellFormater_+3A_cell">cell</code></td>
<td>
<p>[any]<br />
Cell value. In the majority of cases this will be a numeric value.</p>
</td></tr>
<tr><td><code id="niceCellFormater_+3A_alpha">alpha</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Significance level of underlying statistical test.
Default is 0.05.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted output.
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='normalize'>Normalize approximations set(s).</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Normalization is done by subtracting the <code>min.value</code> for each dimension
and dividing by the difference <code>max.value - min.value</code> for each dimension
Certain EMOA indicators require all elements to be strictly positive. Hence, an optional
<code>offset</code> is added to each element which defaults to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x, obj.cols, min.value = NULL, max.value = NULL, offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code> | <code>data.frame</code>]<br />
Either a numeric <code>matrix</code> (each column corresponds to a point) or a
<code>data.frame</code> with columns at least <code>obj.cols</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_obj.cols">obj.cols</code></td>
<td>
<p>[<code>character(&gt;= 2)</code>]<br />
Column names of the objective functions.</p>
</td></tr>
<tr><td><code id="normalize_+3A_min.value">min.value</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values of length <code>nrow(x)</code>.
Only relevant if <code>x</code> is a matrix.
Default is the row-wise minimum of <code>x</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_max.value">max.value</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values of length <code>nrow(x)</code>.
Only relevant if <code>x</code> is a matrix.
Default is the row-wise maximum of <code>x</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_offset">offset</code></td>
<td>
<p>[<code>numeric</code>]<br />
Numeric constant added to each normalized element.
Useful to make all objectives strictly positive, e.g., located in <code class="reqn">[1,2]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix</code> | <code>data.frame</code>]
</p>


<h3>Note</h3>

<p>In case a data.frame is passed and a &ldquo;prob&rdquo; column exists, normalization
is performed for each unique element of the &ldquo;prob&rdquo; column independently (if
existent).
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='nsga2'>Implementation of the NSGA-II EMOA algorithm by Deb.</h2><span id='topic+nsga2'></span>

<h3>Description</h3>

<p>The NSGA-II merges the current population and the generated offspring and
reduces it by means of the following procedure: It first applies the non
dominated sorting algorithm to obtain the nondominated fronts. Starting with
the first front, it fills the new population until the i-th front does not fit.
It then applies the secondary crowding distance criterion to select the missing
individuals from the i-th front.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsga2(
  fitness.fun,
  n.objectives = NULL,
  n.dim = NULL,
  minimize = NULL,
  lower = NULL,
  upper = NULL,
  mu = 100L,
  lambda = mu,
  mutator = setup(mutPolynomial, eta = 25, p = 0.2, lower = lower, upper = upper),
  recombinator = setup(recSBX, eta = 15, p = 0.7, lower = lower, upper = upper),
  terminators = list(stopOnIters(100L)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsga2_+3A_fitness.fun">fitness.fun</code></td>
<td>
<p>[<code>function</code>]<br />
The fitness function.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives of <code>obj.fun</code>.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_n.dim">n.dim</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Dimension of the decision space.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical(n.objectives)</code>]<br />
Logical vector with ith entry <code>TRUE</code> if the ith objective of <code>fitness.fun</code>
shall be minimized. If a single logical is passed, it is assumed to be valid
for each objective.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_mu">mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of individuals in the population.
Default is 100.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_lambda">lambda</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Offspring size, i.e., number of individuals generated by variation operators
in each iteration.
Default is 100.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_mutator">mutator</code></td>
<td>
<p>[<code>ecr_mutator</code>]<br />
Mutation operator of type <code>ecr_mutator</code>.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_recombinator">recombinator</code></td>
<td>
<p>[<code>ecr_recombinator</code>]<br />
Recombination operator of type <code>ecr_recombinator</code>.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_terminators">terminators</code></td>
<td>
<p>[<code>list</code>]<br />
List of stopping conditions of type &ldquo;ecr_terminator&rdquo;.
Default is to stop after 100 iterations.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed down to fitness function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_multi_objective_result</code>]
</p>


<h3>Note</h3>

<p>This is a pure R implementation of the NSGA-II algorithm. It hides the regular
ecr interface and offers a more R like interface while still being quite
adaptable.
</p>


<h3>References</h3>

<p>Deb, K., Pratap, A., and Agarwal, S. A Fast and Elitist Multiobjective Genetic
Algorithm: NSGA-II. IEEE Transactions on Evolutionary Computation, 6 (8) (2002),
182-197.
</p>

<hr>
<h2 id='plotDistribution'>Plot distribution of EMOA indicators.</h2><span id='topic+plotDistribution'></span>

<h3>Description</h3>

<p>Visualizes of empirical distributions of unary EMOA indicator
based on the results of <code><a href="#topic+computeIndicators">computeIndicators</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDistribution(
  inds,
  plot.type = "boxplot",
  fill = "algorithm",
  facet.type = "grid",
  facet.args = list(),
  logscale = character()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDistribution_+3A_inds">inds</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data frame with columns &ldquo;algorithm&rdquo;, &ldquo;prob&rdquo;, &ldquo;repl&rdquo; and
one additional column per EMOA indicator.</p>
</td></tr>
<tr><td><code id="plotDistribution_+3A_plot.type">plot.type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Either &ldquo;boxplot&rdquo; (the default) for boxplots or &ldquo;violin&rdquo; for
violin plots.</p>
</td></tr>
<tr><td><code id="plotDistribution_+3A_fill">fill</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Variable used to fill boxplots.
Default is &ldquo;algorithm&rdquo;.</p>
</td></tr>
<tr><td><code id="plotDistribution_+3A_facet.type">facet.type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Which faceting method to use? Pass &ldquo;wrap&rdquo; for <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>
or &ldquo;grid&rdquo; for <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code>.
Default is &ldquo;wrap&rdquo;.</p>
</td></tr>
<tr><td><code id="plotDistribution_+3A_facet.args">facet.args</code></td>
<td>
<p>[<code>list</code>]<br />
Named list of arguments passed down to <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> or
<code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code> respectively (depends on <code>facet.type</code>).
E.g., <code>nrow</code> to change layout.
Default is the empty list. In this case data is grouped by problem and indicator.</p>
</td></tr>
<tr><td><code id="plotDistribution_+3A_logscale">logscale</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of indicator names which should be log-transformed prior to
visualization.
Default is the empty character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>]
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='plotFront'>Draw scatterplot of Pareto-front approximation</h2><span id='topic+plotFront'></span>

<h3>Description</h3>

<p>The function expects a data.frame or a matrix. By default the first
2 or 3 columns/rows are assumed to contain the elements of the approximation sets.
Depending on the number of numeric columns (in case of a data.frame) or the
number of rows (in case of a matrix) the function internally calls
<code><a href="#topic+plotScatter2d">plotScatter2d</a></code> or <code>plotScatter3d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFront(x, obj.names = NULL, minimize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFront_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code> | <code>data.frame</code>]<br />
Object which contains the approximations sets.</p>
</td></tr>
<tr><td><code id="plotFront_+3A_obj.names">obj.names</code></td>
<td>
<p>[<code>character</code>]<br />
Optional objectives names.
Default is <code>c("f1", "f2")</code>.</p>
</td></tr>
<tr><td><code id="plotFront_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical</code>]<br />
Logical vector with ith entry <code>TRUE</code> if the ith objective shall be minimized.
If a single logical is passed, it is assumed to be valid for each objective.
If the matrix is of type <code>ecr_fitness_matrix</code> (this is the case if it is
produced by one of ecr2's utility functions, e.g. <code><a href="#topic+evaluateFitness">evaluateFitness</a></code>),
the appended <code>minimize</code> attribute is the default.</p>
</td></tr>
<tr><td><code id="plotFront_+3A_...">...</code></td>
<td>
<p>[any]<br />
Not used at the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ggplot</code>] <span class="pkg">ggplot</span> object.
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='plotHeatmap'>Plot heatmap.</h2><span id='topic+plotHeatmap'></span>

<h3>Description</h3>

<p>Given a matrix or list of matrizes <code>x</code> this function
visualizes each matrix with a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHeatmap(x, value.name = "Value", show.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHeatmap_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code> | <code>list[matrix]</code>]<br />
Either a matrix or a list of matrizes.</p>
</td></tr>
<tr><td><code id="plotHeatmap_+3A_value.name">value.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name for the values represented by the matrix.
Internally, the matrix is transformed into a <code>data.frame</code>
via <code><a href="reshape2.html#topic+melt">melt</a></code> in order to obtain a format
which may be processed by <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> easily.
Default is &ldquo;Value&rdquo;.</p>
</td></tr>
<tr><td><code id="plotHeatmap_+3A_show.values">show.values</code></td>
<td>
<p>[<code>logical(1L)</code>]<br />
Should the values be printed within the heatmap cells?
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>] ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate two (correlation) matrizes
x = matrix(runif(100), ncol = 10)
y = matrix(runif(100), ncol = 10)
## Not run: 
pl = plotHeatmap(x)
pl = plotHeatmap(list(x, y), value.name = "Correlation")
pl = plotHeatmap(list(MatrixX = x, MatrixY = y), value.name = "Correlation")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotScatter2d'>Visualize bi-objective Pareto-front approximations.</h2><span id='topic+plotScatter2d'></span>

<h3>Description</h3>

<p>Given a data frame with the results of (multiple) runs of (multiple)
different multi-objective optimization algorithms on (multiple) problem instances
the function generates <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> plots of the obtained
Pareto-front approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotScatter2d(
  df,
  obj.cols = c("f1", "f2"),
  shape = "algorithm",
  colour = NULL,
  highlight.algos = NULL,
  offset.highlighted = 0,
  title = NULL,
  subtitle = NULL,
  facet.type = "wrap",
  facet.args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotScatter2d_+3A_df">df</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data.frame with columns at least <code>obj.cols</code>, &ldquo;prob&rdquo; and &ldquo;algorithm&rdquo;.</p>
</td></tr>
<tr><td><code id="plotScatter2d_+3A_obj.cols">obj.cols</code></td>
<td>
<p>[<code>character(&gt;= 2)</code>]<br />
Column names of the objective functions.
Default is <code>c("f1", "f2")</code>.</p>
</td></tr>
<tr><td><code id="plotScatter2d_+3A_shape">shape</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of column which shall be used to define shape of points.
Default is &ldquo;algorithm&rdquo;.</p>
</td></tr>
<tr><td><code id="plotScatter2d_+3A_colour">colour</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of column which shall be used to define colour of points.
Default is <code>NULL</code>, i.e., coloring is deactivated.</p>
</td></tr>
<tr><td><code id="plotScatter2d_+3A_highlight.algos">highlight.algos</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of algorithm to highlight exclusively. Useful to highlight, e.g., the
true Pareto-optimal front (if known) or some reference set.
Default is <code>NULL</code>, i.e., unknown.</p>
</td></tr>
<tr><td><code id="plotScatter2d_+3A_offset.highlighted">offset.highlighted</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Numeric offset used to shift set (see <code>highlight.algos</code>)
which should be highlighted.
Even though this produces objective vectors it
may be used to make visible reference sets which otherwise would
be hidden by overlap of multiple other approximation sets.</p>
</td></tr>
<tr><td><code id="plotScatter2d_+3A_title">title</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Plot title.</p>
</td></tr>
<tr><td><code id="plotScatter2d_+3A_subtitle">subtitle</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Plot subtitle.</p>
</td></tr>
<tr><td><code id="plotScatter2d_+3A_facet.type">facet.type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Which faceting method to use? Pass &ldquo;wrap&rdquo; for <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>
or &ldquo;grid&rdquo; for <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code>.
Default is &ldquo;wrap&rdquo;.</p>
</td></tr>
<tr><td><code id="plotScatter2d_+3A_facet.args">facet.args</code></td>
<td>
<p>[<code>list</code>]<br />
Named list of arguments passed down to <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> or
<code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code> respectively (depends on <code>facet.type</code>).
E.g., <code>nrow</code> to change layout.
Default is the empty list. In this case data is grouped by problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>] A ggplot object.
</p>


<h3>Note</h3>

<p>At the moment only approximations of bi-objective functions are supported.
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load examplary data
data(mcMST)
print(head(mcMST))

# no customization; use the defaults
pl = plotFronts(mcMST)

# algo PRIM is obtained by weighted sum scalarization
# Since the front is (mainly) convex we highlight these solutions
pl = plotFronts(mcMST, highlight.algos = "PRIM")

# customize layout
pl = plotFronts(mcMST, title = "Pareto-approximations",
  subtitle = "based on different mcMST algorithms.", facet.args = list(nrow = 2))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotScatter3d'>Visualize three-objective Pareto-front approximations.</h2><span id='topic+plotScatter3d'></span>

<h3>Description</h3>

<p>Given a data frame with the results of (multiple) runs of (multiple)
different three-objective optimization algorithms on (multiple) problem instances
the function generates 3D scatterplots of the obtained Pareto-front approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotScatter3d(
  df,
  obj.cols = c("f1", "f2", "f3"),
  max.in.row = 4L,
  package = "scatterplot3d",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotScatter3d_+3A_df">df</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Data.frame with columns at least <code>obj.cols</code>, &ldquo;prob&rdquo; and &ldquo;algorithm&rdquo;.</p>
</td></tr>
<tr><td><code id="plotScatter3d_+3A_obj.cols">obj.cols</code></td>
<td>
<p>[<code>character(&gt;= 3)</code>]<br />
Column names of the objective functions.
Default is <code>c("f1", "f2", "f3")</code>.</p>
</td></tr>
<tr><td><code id="plotScatter3d_+3A_max.in.row">max.in.row</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximum number of plots to be displayed side by side in a row.
Default is 4.</p>
</td></tr>
<tr><td><code id="plotScatter3d_+3A_package">package</code></td>
<td>
<p>[<code>character(1L)</code>]<br />
Which package to use for 3d scatterplot generation?
Possible choices are &ldquo;scatterplot3d&rdquo;, &ldquo;plot3D&rdquo;, &ldquo;plot3Drgl&rdquo;
or &ldquo;plotly&rdquo;.
Default is &ldquo;scatterplot3d&rdquo;.</p>
</td></tr>
<tr><td><code id="plotScatter3d_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed down to scatterplot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+toLatex">toLatex</a>()</code>
</p>

<hr>
<h2 id='plotStatistics'>Generate line plot of logged statistics.</h2><span id='topic+plotStatistics'></span>

<h3>Description</h3>

<p>Expects a data.frame of logged statistics, e.g., extracted from
a logger object by calling <code><a href="#topic+getStatistics">getStatistics</a></code>, and generates a basic
line plot. The plot is generated with the <span class="pkg">ggplot2</span> package and the ggplot
object is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotStatistics(x, drop.stats = character(0L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotStatistics_+3A_x">x</code></td>
<td>
<p>[<code>ecr_statistics</code> | <code>ecr_logger</code>]<br />
Logger object or statistics data frame from logger object.</p>
</td></tr>
<tr><td><code id="plotStatistics_+3A_drop.stats">drop.stats</code></td>
<td>
<p>[<code>character</code>]<br />
Names of logged statistics to be dropped.
Default is the empty character, i.e., not to drop any stats.</p>
</td></tr>
</table>

<hr>
<h2 id='recCrossover'>One-point crossover recombinator.</h2><span id='topic+recCrossover'></span>

<h3>Description</h3>

<p>The one-point crossover recombinator is defined for float and binary
representations. Given two real-valued/binary vectors of length n, the
selector samples a random position i between 1 and n-1. In the next step
it creates two children. The first part of the first child contains of the
subvector from position 1 to position i of the first parent, the second part
from position i+1 to n is taken from the second parent. The second child
is build analogously.
If the parents are list of real-valued/binary vectors, the procedure described
above is applied to each element of the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recCrossover(inds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recCrossover_+3A_inds">inds</code></td>
<td>
<p>[<code>list</code>]<br />
Parents, i.e., list of exactly two numeric or binary vectors of equal length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>]
</p>


<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+recIntermediate">recIntermediate</a>()</code>,
<code><a href="#topic+recOX">recOX</a>()</code>,
<code><a href="#topic+recPMX">recPMX</a>()</code>,
<code><a href="#topic+recSBX">recSBX</a>()</code>,
<code><a href="#topic+recUnifCrossover">recUnifCrossover</a>()</code>
</p>

<hr>
<h2 id='recIntermediate'>Indermediate recombinator.</h2><span id='topic+recIntermediate'></span>

<h3>Description</h3>

<p>Intermediate recombination computes the component-wise mean value of the
<code>k</code> given parents. It is applicable only for float representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recIntermediate(inds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recIntermediate_+3A_inds">inds</code></td>
<td>
<p>[<code>list</code>]<br />
Parents, i.e., list of exactly two numeric vectors of equal length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>] Single offspring.
</p>


<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+recCrossover">recCrossover</a>()</code>,
<code><a href="#topic+recOX">recOX</a>()</code>,
<code><a href="#topic+recPMX">recPMX</a>()</code>,
<code><a href="#topic+recSBX">recSBX</a>()</code>,
<code><a href="#topic+recUnifCrossover">recUnifCrossover</a>()</code>
</p>

<hr>
<h2 id='recOX'>Ordered-Crossover (OX) recombinator.</h2><span id='topic+recOX'></span>

<h3>Description</h3>

<p>This recombination operator is specifically designed for permutations.
The operators chooses two cut-points at random and generates two offspring
as follows: a) copy the subsequence of one parent and b) remove the copied
node indizes from the entire sequence of the second parent from the sescond
cut point and b) fill the remaining gaps with this trimmed sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recOX(inds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recOX_+3A_inds">inds</code></td>
<td>
<p>[<code>list</code>]<br />
Parents, i.e., list of exactly two permutations (vectors of integer values) of equal length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>]
</p>


<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+recCrossover">recCrossover</a>()</code>,
<code><a href="#topic+recIntermediate">recIntermediate</a>()</code>,
<code><a href="#topic+recPMX">recPMX</a>()</code>,
<code><a href="#topic+recSBX">recSBX</a>()</code>,
<code><a href="#topic+recUnifCrossover">recUnifCrossover</a>()</code>
</p>

<hr>
<h2 id='recPMX'>Partially-Mapped-Crossover (PMX) recombinator.</h2><span id='topic+recPMX'></span>

<h3>Description</h3>

<p>This recombination operator is specifically designed for permutations.
The operators chooses two cut-points at random and generates two offspring
as follows: a) copy the subsequence of one parent and b) fill the remaining
positions while preserving the order and position of as many genes as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recPMX(inds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recPMX_+3A_inds">inds</code></td>
<td>
<p>[<code>numeric</code>]<br />
Parents, i.e., list of exactly two permutations of equal length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_recombinator</code>]
</p>


<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+recCrossover">recCrossover</a>()</code>,
<code><a href="#topic+recIntermediate">recIntermediate</a>()</code>,
<code><a href="#topic+recOX">recOX</a>()</code>,
<code><a href="#topic+recSBX">recSBX</a>()</code>,
<code><a href="#topic+recUnifCrossover">recUnifCrossover</a>()</code>
</p>

<hr>
<h2 id='recSBX'>Simulated Binary Crossover (SBX) recombinator.</h2><span id='topic+recSBX'></span>

<h3>Description</h3>

<p>The Simulated Binary Crossover was first proposed by [1]. It i suited for
float representation only and creates two offspring. Given parents <code class="reqn">p_1, p_2</code>
the offspring are generated as <code class="reqn">c_{1/2} = \bar{x} \pm \frac{1}{2}\beta(p_2 - p_1)</code>
where <code class="reqn">\bar{x} = \frac{1}{2}(p_1 + p_2), p_2 &gt; p_1</code>. This way <code class="reqn">\bar{c} = \bar{x}</code>
is assured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recSBX(inds, eta = 5, p = 1, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recSBX_+3A_inds">inds</code></td>
<td>
<p>[<code>numeric</code>]<br />
Parents, i.e., list of exactly two numeric vectors of equal length.</p>
</td></tr>
<tr><td><code id="recSBX_+3A_eta">eta</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Parameter eta, i.e., the distance parameters of the crossover distribution.</p>
</td></tr>
<tr><td><code id="recSBX_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Crossover probability for each gene. Default is <code>1.0</code>.</p>
</td></tr>
<tr><td><code id="recSBX_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values for each parameter of the decision space.</p>
</td></tr>
<tr><td><code id="recSBX_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values for each parameter of the decision space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_recombinator</code>]
</p>


<h3>Note</h3>

<p>This is the default recombination operator used in the NSGA-II EMOA (see <code><a href="#topic+nsga2">nsga2</a></code>).
</p>


<h3>References</h3>

<p>[1] Deb, K. and Agrawal, R. B. (1995). Simulated binary crossover for continuous
search space. Complex Systems 9(2), 115-148.
</p>


<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+recCrossover">recCrossover</a>()</code>,
<code><a href="#topic+recIntermediate">recIntermediate</a>()</code>,
<code><a href="#topic+recOX">recOX</a>()</code>,
<code><a href="#topic+recPMX">recPMX</a>()</code>,
<code><a href="#topic+recUnifCrossover">recUnifCrossover</a>()</code>
</p>

<hr>
<h2 id='recUnifCrossover'>Uniform crossover recombinator.</h2><span id='topic+recUnifCrossover'></span>

<h3>Description</h3>

<p>Produces two child individuals. The i-th gene is from parent1 with probability
<code>p</code> and from parent2 with probability <code>1-p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recUnifCrossover(inds, p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recUnifCrossover_+3A_inds">inds</code></td>
<td>
<p>[<code>list</code>]<br />
Parents, i.e., list of exactly two numeric or binary vectors of equal length.</p>
</td></tr>
<tr><td><code id="recUnifCrossover_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability to select gene from parent1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>]
</p>


<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+recCrossover">recCrossover</a>()</code>,
<code><a href="#topic+recIntermediate">recIntermediate</a>()</code>,
<code><a href="#topic+recOX">recOX</a>()</code>,
<code><a href="#topic+recPMX">recPMX</a>()</code>,
<code><a href="#topic+recSBX">recSBX</a>()</code>
</p>

<hr>
<h2 id='reduceToSingleDataFrame'>Combine multiple data frames into a single data.frame.</h2><span id='topic+reduceToSingleDataFrame'></span>

<h3>Description</h3>

<p>Combine multiple data frames into a single data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceToSingleDataFrame(res = list(), what = NULL, group.col.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceToSingleDataFrame_+3A_res">res</code></td>
<td>
<p>[<code>list</code>]<br />
List of data frames or other lists which contain a data frame as one of the
components which is selected by <code>what</code>. If <code>res</code> is a named list
those names are used to fill the group column. Otherwise the names are 1 to
<code>length(res)</code> by default.</p>
</td></tr>
<tr><td><code id="reduceToSingleDataFrame_+3A_what">what</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Which component of each list element in <code>res</code> to choose. Set this to
<code>NULL</code>, if <code>res</code> is not complex, i.e., is not a list of lists.</p>
</td></tr>
<tr><td><code id="reduceToSingleDataFrame_+3A_group.col.name">group.col.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name for the grouping column.</p>
</td></tr>
</table>

<hr>
<h2 id='registerECROperator'>Register operators to control object.</h2><span id='topic+registerECROperator'></span>

<h3>Description</h3>

<p>In ecr the control object stores information on the fitness
function and serves as a storage for evolutionary components used by your evolutionary
algorithm. This function handles the registration process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerECROperator(control, slot, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registerECROperator_+3A_control">control</code></td>
<td>
<p>[<code>ecr_control</code>]<br />
Control object.</p>
</td></tr>
<tr><td><code id="registerECROperator_+3A_slot">slot</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the field in the control object where to store the operator.</p>
</td></tr>
<tr><td><code id="registerECROperator_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code>]<br />
Actual operator. In order to use the various helper functions of ecr one needs
to stick to a simple convention: The first argument of <code>function</code> should
be the individual to mutate, a list of individuals for recombination or a matrix
of fitness values for recombination. If one does not want to use the corresponding
helpers, e.g., <code>mutate</code>, the signature of the function does not matter. However,
in this case you are responsible to pass arguments correctly.</p>
</td></tr>
<tr><td><code id="registerECROperator_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments for <code>fun</code>. These arguments are stored in the control object
and passed on to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_control</code>]
</p>

<hr>
<h2 id='replace'>(mu + lambda) selection</h2><span id='topic+replace'></span><span id='topic+replaceMuPlusLambda'></span><span id='topic+replaceMuCommaLambda'></span>

<h3>Description</h3>

<p>Takes a population of mu individuals and another set of lambda
offspring individuals and selects mu individuals out of the union set according
to the survival selection strategy stored in the control object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceMuPlusLambda(
  control,
  population,
  offspring,
  fitness = NULL,
  fitness.offspring = NULL
)

replaceMuCommaLambda(
  control,
  population,
  offspring,
  fitness = NULL,
  fitness.offspring = NULL,
  n.elite = base::max(ceiling(length(population) * 0.1), 1L)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_+3A_control">control</code></td>
<td>
<p>[<code>ecr_control</code>]<br />
Control object.</p>
</td></tr>
<tr><td><code id="replace_+3A_population">population</code></td>
<td>
<p>[<code>list</code>]<br />
Current set of individuals.</p>
</td></tr>
<tr><td><code id="replace_+3A_offspring">offspring</code></td>
<td>
<p>[<code>list</code>]<br />
Another set of individuals.</p>
</td></tr>
<tr><td><code id="replace_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values for the individuals from <code>population</code>.
This is only optional in the case that each individual in <code>population</code> has
an attribute &ldquo;fitness&rdquo;.</p>
</td></tr>
<tr><td><code id="replace_+3A_fitness.offspring">fitness.offspring</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values for the individuals from <code>offspring</code>.
This is only optional in the case that each individual in <code>offspring</code> has
an attribute &ldquo;fitness&rdquo;.</p>
</td></tr>
<tr><td><code id="replace_+3A_n.elite">n.elite</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of fittest individuals of the current generation that shall be copied to the
next generation without changing. Keep in mind, that the algorithm
does not care about this option if the <code>survival.strategy</code> is set to 'plus'.
Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List with selected population and corresponding fitness matrix.
</p>

<hr>
<h2 id='selDomHV'>Dominated Hypervolume selector.</h2><span id='topic+selDomHV'></span>

<h3>Description</h3>

<p>Performs non-dominated sorting and drops the individual from the last front
with minimal hypervolume contribution. This selector is the basis of the
S-Metric Selection Evolutionary Multi-Objective Algorithm, termed SMS-EMOA
(see <code><a href="#topic+smsemoa">smsemoa</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selDomHV(fitness, n.select, ref.point)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selDomHV_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) of one
individual).</p>
</td></tr>
<tr><td><code id="selDomHV_+3A_n.select">n.select</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of elements to select.</p>
</td></tr>
<tr><td><code id="selDomHV_+3A_ref.point">ref.point</code></td>
<td>
<p>[<code>numeric</code>]<br />
Reference point for hypervolume computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>] Vector of survivor indizes.
</p>


<h3>Note</h3>

<p>Note that the current implementation expects <code>n.select = ncol(fitness) - 1</code>
and the selection process quits with an error message if <code>n.select</code> is greater
than 1.
</p>


<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+selGreedy">selGreedy</a>()</code>,
<code><a href="#topic+selNondom">selNondom</a>()</code>,
<code><a href="#topic+selRanking">selRanking</a>()</code>,
<code><a href="#topic+selRoulette">selRoulette</a>()</code>,
<code><a href="#topic+selSimple">selSimple</a>()</code>,
<code><a href="#topic+selTournament">selTournament</a>()</code>
</p>

<hr>
<h2 id='select'>Select individuals.</h2><span id='topic+select'></span><span id='topic+selectForMating'></span><span id='topic+selectForSurvival'></span>

<h3>Description</h3>

<p>This utility functions expect a control object, a matrix of
fitness values - each column containing the fitness value(s) of one individual -
and the number of individuals to select.
The corresponding selector, i.e., mating selector for <code>selectForMating</code>
or survival selector for <code>selectForSurvival</code> is than called internally
and a vector of indizes of selected individuals is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectForMating(control, fitness, n.select)

selectForSurvival(control, fitness, n.select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_control">control</code></td>
<td>
<p>[<code>ecr_control</code>]<br />
Control object.</p>
</td></tr>
<tr><td><code id="select_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) of one
individual).</p>
</td></tr>
<tr><td><code id="select_+3A_n.select">n.select</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of individuals to select.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions check the optimization directions stored in the task
inside the control object, i.e., whether to minimize or maximize each objective,
and transparently prepare/transform the <code>fitness</code> matrix for the selector.
</p>


<h3>Value</h3>

<p>[<code>integer</code>] Integer vector with the indizes of selected individuals.
</p>

<hr>
<h2 id='selGreedy'>Simple selector.</h2><span id='topic+selGreedy'></span>

<h3>Description</h3>

<p>Sorts the individuals according to their fitness value in increasing order
and selects the best ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selGreedy(fitness, n.select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selGreedy_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) of one
individual).</p>
</td></tr>
<tr><td><code id="selGreedy_+3A_n.select">n.select</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of elements to select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>] Vector of survivor indizes.
</p>


<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+selDomHV">selDomHV</a>()</code>,
<code><a href="#topic+selNondom">selNondom</a>()</code>,
<code><a href="#topic+selRanking">selRanking</a>()</code>,
<code><a href="#topic+selRoulette">selRoulette</a>()</code>,
<code><a href="#topic+selSimple">selSimple</a>()</code>,
<code><a href="#topic+selTournament">selTournament</a>()</code>
</p>

<hr>
<h2 id='selNondom'>Non-dominated sorting selector.</h2><span id='topic+selNondom'></span>

<h3>Description</h3>

<p>Applies non-dominated sorting of the objective vectors and subsequent crowding
distance computation to select a subset of individuals. This is the selector used
by the famous NSGA-II EMOA (see <code><a href="#topic+nsga2">nsga2</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selNondom(fitness, n.select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selNondom_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) of one
individual).</p>
</td></tr>
<tr><td><code id="selNondom_+3A_n.select">n.select</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of elements to select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>setOfIndividuals</code>]
</p>


<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+selDomHV">selDomHV</a>()</code>,
<code><a href="#topic+selGreedy">selGreedy</a>()</code>,
<code><a href="#topic+selRanking">selRanking</a>()</code>,
<code><a href="#topic+selRoulette">selRoulette</a>()</code>,
<code><a href="#topic+selSimple">selSimple</a>()</code>,
<code><a href="#topic+selTournament">selTournament</a>()</code>
</p>

<hr>
<h2 id='selRanking'>Rank Selection Operator</h2><span id='topic+selRanking'></span>

<h3>Description</h3>

<p>Rank-based selection preserves a constant selection pressure by sorting the
population on the basis of fitness, and then allocating selection
probabilities to individuals according to their rank, rather than according
to their actual fitness values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selRanking(fitness, n.select, s = 1.5, scheme = "linear")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selRanking_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) of one
individual).</p>
</td></tr>
<tr><td><code id="selRanking_+3A_n.select">n.select</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of elements to select.</p>
</td></tr>
<tr><td><code id="selRanking_+3A_s">s</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Selection pressure for linear ranking scheme with value range <code class="reqn">[0,1]</code>.
Ignored if <code>scheme</code> is set to &ldquo;exponential&rdquo;.
Default is 1.5.</p>
</td></tr>
<tr><td><code id="selRanking_+3A_scheme">scheme</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Mapping from rank number to selection probability, either
&ldquo;linear&rdquo; or &ldquo;exponential&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>setOfIndividuals</code>]
</p>


<h3>References</h3>

<p>Eiben, A. E., &amp; Smith, J. E. (2007). Introduction to evolutionary computing.
Berlin: Springer.
</p>


<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+selDomHV">selDomHV</a>()</code>,
<code><a href="#topic+selGreedy">selGreedy</a>()</code>,
<code><a href="#topic+selNondom">selNondom</a>()</code>,
<code><a href="#topic+selRoulette">selRoulette</a>()</code>,
<code><a href="#topic+selSimple">selSimple</a>()</code>,
<code><a href="#topic+selTournament">selTournament</a>()</code>
</p>

<hr>
<h2 id='selRoulette'>Roulette-wheel / fitness-proportional selector.</h2><span id='topic+selRoulette'></span>

<h3>Description</h3>

<p>The chance of an individual to get selected is proportional to its fitness,
i.e., better individuals get a higher chance to take part in the reproduction
process. Low-fitness individuals however, have a positive fitness as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selRoulette(fitness, n.select, offset = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selRoulette_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) of one
individual).</p>
</td></tr>
<tr><td><code id="selRoulette_+3A_n.select">n.select</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of elements to select.</p>
</td></tr>
<tr><td><code id="selRoulette_+3A_offset">offset</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
In case of negative fitness values all values are shifted towards positive
values by adding the negative of the minimal fitness value. However, in this
case the minimal fitness value after the shifting process is zero. The
<code>offset</code> is a positive numeric value which is added additionally to each
shifted fitness value. This way even the individual with the smallest fitness
value has a positive porbability to be selected.
Default is <code>0.1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitness proportional selection can be naturally applied to single objective
maximization problems. However, negative fitness values can are problematic.
The Roulette-Wheel selector thus works with the following heuristic: if
negative values occur, the negative of the smallest fitness value is added
to each fitness value. In this case to avoid the smallest shifted fitness
value to be zero and thus have a zero probability of being selected an additional
positive constant <code>offset</code> is added (see parameters).
</p>


<h3>Value</h3>

<p>[<code>setOfIndividuals</code>]
</p>


<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+selDomHV">selDomHV</a>()</code>,
<code><a href="#topic+selGreedy">selGreedy</a>()</code>,
<code><a href="#topic+selNondom">selNondom</a>()</code>,
<code><a href="#topic+selRanking">selRanking</a>()</code>,
<code><a href="#topic+selSimple">selSimple</a>()</code>,
<code><a href="#topic+selTournament">selTournament</a>()</code>
</p>

<hr>
<h2 id='selSimple'>Simple (naive) selector.</h2><span id='topic+selSimple'></span>

<h3>Description</h3>

<p>Just for testing. Actually does not really select, but instead returns a random
sample of <code>ncol(fitness)</code> indizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selSimple(fitness, n.select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selSimple_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) of one
individual).</p>
</td></tr>
<tr><td><code id="selSimple_+3A_n.select">n.select</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of elements to select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>setOfIndividuals</code>]
</p>


<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+selDomHV">selDomHV</a>()</code>,
<code><a href="#topic+selGreedy">selGreedy</a>()</code>,
<code><a href="#topic+selNondom">selNondom</a>()</code>,
<code><a href="#topic+selRanking">selRanking</a>()</code>,
<code><a href="#topic+selRoulette">selRoulette</a>()</code>,
<code><a href="#topic+selTournament">selTournament</a>()</code>
</p>

<hr>
<h2 id='selTournament'>k-Tournament selector.</h2><span id='topic+selTournament'></span>

<h3>Description</h3>

<p>k individuals from the population are chosen randomly and the best one is
selected to be included into the mating pool. This process is repeated until
the desired number of individuals for the mating pool is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selTournament(fitness, n.select, k = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selTournament_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) of one
individual).</p>
</td></tr>
<tr><td><code id="selTournament_+3A_n.select">n.select</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of elements to select.</p>
</td></tr>
<tr><td><code id="selTournament_+3A_k">k</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of individuals to participate in each tournament. Default is <code>2L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>] Vector of survivor indizes.
</p>


<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+selDomHV">selDomHV</a>()</code>,
<code><a href="#topic+selGreedy">selGreedy</a>()</code>,
<code><a href="#topic+selNondom">selNondom</a>()</code>,
<code><a href="#topic+selRanking">selRanking</a>()</code>,
<code><a href="#topic+selRoulette">selRoulette</a>()</code>,
<code><a href="#topic+selSimple">selSimple</a>()</code>
</p>

<hr>
<h2 id='setDominates'>Check if one set is better than another.</h2><span id='topic+setDominates'></span>

<h3>Description</h3>

<p>The function checks, whether each points of the second set of points
is dominated by at least one point from the first set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDominates(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDominates_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
First set of points.</p>
</td></tr>
<tr><td><code id="setDominates_+3A_y">y</code></td>
<td>
<p>[<code>matrix</code>]<br />
Second set of points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='setup'>Set up parameters for evolutionary operator.</h2><span id='topic+setup'></span>

<h3>Description</h3>

<p>This function builds a simple wrapper around an evolutionary operator, i.e.,
mutator, recombinator or selector and defines its parameters. The result is a
function that does not longer depend on the parameters. E.g., <code>fun = setup(mutBitflip, p = 0.3)</code>
initializes a bitflip mutator with mutation probability 0.3. Thus,
the following calls have the same behaviour: <code>fun(c(1, 0, 0))</code> and
<code>mutBitflip(fun(c(1, 0, 0), p = 0.3)</code>.
Basically, this type of preinitialization is only neccessary if operators
with additional parameters shall be initialized in order to use the black-box
<code><a href="#topic+ecr">ecr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup(operator, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_+3A_operator">operator</code></td>
<td>
<p>[<code>ecr_operator</code>]<br />
Evolutionary operator.</p>
</td></tr>
<tr><td><code id="setup_+3A_...">...</code></td>
<td>
<p>[any]<br />
Furhter parameters for <code>operator</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>function</code>] Wrapper evolutionary operator with parameters <code>x</code> and <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># initialize bitflip mutator with p = 0.3
bf = setup(mutBitflip, p = 0.3)
# sample binary string
x = sample(c(0, 1), 100, replace = TRUE)

set.seed(1)
# apply preinitialized function
print(bf(x))

set.seed(1)
# apply raw function
print(mutBitflip(x, p = 0.3))

# overwrite preinitialized values with mutate
ctrl = initECRControl(fitness.fun = function(x) sum(x), n.objectives = 1L)
# here we define a mutation probability of 0.3
ctrl = registerECROperator(ctrl, "mutate", setup(mutBitflip, p = 0.3))
# here we overwrite with 1, i.e., each bit is flipped
print(x)
print(mutate(ctrl, list(x), p.mut = 1, p = 1)[[1]])
</code></pre>

<hr>
<h2 id='setupECRDefaultMonitor'>Default monitor.</h2><span id='topic+setupECRDefaultMonitor'></span>

<h3>Description</h3>

<p>Default monitor object that outputs messages to the console
based on a default logger (see <code>initLogger</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupECRDefaultMonitor(step = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupECRDefaultMonitor_+3A_step">step</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of steps of the EA between monitoring.
Default is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_monitor</code>]
</p>

<hr>
<h2 id='smsemoa'>Implementation of the SMS-EMOA by Emmerich et al.</h2><span id='topic+smsemoa'></span>

<h3>Description</h3>

<p>Pure R implementation of the SMS-EMOA. This algorithm belongs to the group
of indicator based multi-objective evolutionary algorithms. In each generation,
the SMS-EMOA selects two parents uniformly at, applies recombination and mutation
and finally selects the best subset of individuals among all subsets by maximizing
the Hypervolume indicator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smsemoa(
  fitness.fun,
  n.objectives = NULL,
  n.dim = NULL,
  minimize = NULL,
  lower = NULL,
  upper = NULL,
  mu = 100L,
  ref.point = NULL,
  mutator = setup(mutPolynomial, eta = 25, p = 0.2, lower = lower, upper = upper),
  recombinator = setup(recSBX, eta = 15, p = 0.7, lower = lower, upper = upper),
  terminators = list(stopOnIters(100L)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smsemoa_+3A_fitness.fun">fitness.fun</code></td>
<td>
<p>[<code>function</code>]<br />
The fitness function.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives of <code>obj.fun</code>.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_n.dim">n.dim</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Dimension of the decision space.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical(n.objectives)</code>]<br />
Logical vector with ith entry <code>TRUE</code> if the ith objective of <code>fitness.fun</code>
shall be minimized. If a single logical is passed, it is assumed to be valid
for each objective.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of minimal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of maximal values for each parameter of the decision space in case
of float or permutation encoding.
Optional if <code>obj.fun</code> is a benchmark function from package <span class="pkg">smoof</span>.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_mu">mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of individuals in the population.
Default is 100.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_ref.point">ref.point</code></td>
<td>
<p>[<code>numeric</code>]<br />
Reference point for the hypervolume computation. Default is (11, ..., 11)'
with the corresponding dimension.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_mutator">mutator</code></td>
<td>
<p>[<code>ecr_mutator</code>]<br />
Mutation operator of type <code>ecr_mutator</code>.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_recombinator">recombinator</code></td>
<td>
<p>[<code>ecr_recombinator</code>]<br />
Recombination operator of type <code>ecr_recombinator</code>.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_terminators">terminators</code></td>
<td>
<p>[<code>list</code>]<br />
List of stopping conditions of type &ldquo;ecr_terminator&rdquo;.
Default is to stop after 100 iterations.</p>
</td></tr>
<tr><td><code id="smsemoa_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed down to fitness function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_multi_objective_result</code>]
</p>


<h3>Note</h3>

<p>This helper function hides the regular ecr interface and offers a more
R like interface of this state of the art EMOA.
</p>


<h3>References</h3>

<p>Beume, N., Naujoks, B., Emmerich, M., SMS-EMOA: Multiobjective selection based
on dominated hypervolume, European Journal of Operational Research, Volume 181,
Issue 3, 16 September 2007, Pages 1653-1669.
</p>

<hr>
<h2 id='sortByObjective'>Sort Pareto-front approximation by objective.</h2><span id='topic+sortByObjective'></span><span id='topic+sortByObjective.data.frame'></span><span id='topic+sortByObjective.matrix'></span><span id='topic+sortByObjective.ecr_multi_objective_result'></span><span id='topic+sortByObjective.list'></span>

<h3>Description</h3>

<p>Sort Pareto-front approximation by objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortByObjective(x, obj = 1L, ...)

## S3 method for class 'data.frame'
sortByObjective(x, obj = 1L, ...)

## S3 method for class 'matrix'
sortByObjective(x, obj = 1L, ...)

## S3 method for class 'ecr_multi_objective_result'
sortByObjective(x, obj = 1L, ...)

## S3 method for class 'list'
sortByObjective(x, obj = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortByObjective_+3A_x">x</code></td>
<td>
<p>[<code>object</code>]<br />
Object of type data frame (objectives column-wise), matrix (objectives row-wise),
<code><a href="#topic+ecr_result">ecr_multi_objective_result</a></code> or <code>list</code> (with components &ldquo;pareto.front&rdquo;)
and &ldquo;pareto.set&rdquo;.</p>
</td></tr>
<tr><td><code id="sortByObjective_+3A_obj">obj</code></td>
<td>
<p>[<code>integer(1) | character(1)</code>]<br />
Either the row/column number to sort by or the column name, e.g., for data frames.</p>
</td></tr>
<tr><td><code id="sortByObjective_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed down to <code><a href="base.html#topic+order">order</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified object.
</p>

<hr>
<h2 id='stoppingConditions'>Stopping conditions</h2><span id='topic+stoppingConditions'></span><span id='topic+stopOnEvals'></span><span id='topic+stopOnIters'></span><span id='topic+stopOnOptY'></span><span id='topic+stopOnMaxTime'></span>

<h3>Description</h3>

<p>Stop the EA after a fixed number of fitness function evaluations, after
a predefined number of generations/iterations, a given cutoff time or
if the known optimal function value is approximated (only for single-objective optimization).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopOnEvals(max.evals = NULL)

stopOnIters(max.iter = NULL)

stopOnOptY(opt.y, eps)

stopOnMaxTime(max.time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoppingConditions_+3A_max.evals">max.evals</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximal number of function evaluations.
Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="stoppingConditions_+3A_max.iter">max.iter</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximal number of iterations/generations.
Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="stoppingConditions_+3A_opt.y">opt.y</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Optimal scalar fitness function value.</p>
</td></tr>
<tr><td><code id="stoppingConditions_+3A_eps">eps</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Stop if absolute deviation from <code>opt.y</code> is lower than <code>eps</code>.</p>
</td></tr>
<tr><td><code id="stoppingConditions_+3A_max.time">max.time</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Time limit in seconds.
Default is <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ecr_terminator</code>]
</p>

<hr>
<h2 id='toGG'>Transform to long format.</h2><span id='topic+toGG'></span>

<h3>Description</h3>

<p>Transform the data.frame of logged statistics from wide to
<span class="pkg">ggplot2</span>-friendly long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toGG(x, drop.stats = character(0L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toGG_+3A_x">x</code></td>
<td>
<p>[<code>ecr_statistics</code> | <code>ecr_logger</code>]<br />
Logger object or statistics data frame from logger object.</p>
</td></tr>
<tr><td><code id="toGG_+3A_drop.stats">drop.stats</code></td>
<td>
<p>[<code>character</code>]<br />
Names of logged statistics to be dropped.
Default is the empty character, i.e., not to drop any stats.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>data.frame</code>]
</p>

<hr>
<h2 id='toLatex'>Export results of statistical tests to LaTeX table(s).</h2><span id='topic+toLatex'></span><span id='topic+toLatex.list'></span><span id='topic+toLatex.data.frame'></span>

<h3>Description</h3>

<p>Returns high-quality LaTeX-tables of the test results of
statistical tests performed with function <code>test</code>
on per-instance basis. I.e., a table is returned for each instances combining
the results of different indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toLatex(
  stats,
  stat.cols = NULL,
  probs = NULL,
  type = "by.instance",
  cell.formatter = NULL
)

## S3 method for class 'list'
toLatex(
  stats,
  stat.cols = NULL,
  probs = NULL,
  type = "by.instance",
  cell.formatter = NULL
)

## S3 method for class 'data.frame'
toLatex(
  stats,
  stat.cols = NULL,
  probs = NULL,
  type = "by.instance",
  cell.formatter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toLatex_+3A_stats">stats</code></td>
<td>
<p>[<code>list</code>]<br />
Data frame (return value of <code><a href="#topic+computeIndicators">computeIndicators</a></code>) or named list of list as returned by <code>test</code>.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_stat.cols">stat.cols</code></td>
<td>
<p>[<code>character</code>]<br />
Names of the indicators to consider.
Defaults to all indicators available in <code>stats</code>.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_probs">probs</code></td>
<td>
<p>[<code>character</code>]<br />
Filtering: vector of problem instances. This way one can restrict the
size of the table(s).
Defaults to all problems available in <code>stats</code>.
Ignored if <code>stats</code> is a data frame.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Type of tables. At the moment only option &ldquo;by.instance&rdquo; is available.
I.e., a separate LaTeX-table is generated for each instance specified via <code>probs</code>.
Ignored if <code>stats</code> is a data frame.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_cell.formatter">cell.formatter</code></td>
<td>
<p>[<code>function(cell, ...)</code>]<br />
Function which is used to format table cells. This function is applied to each
table cell and may be used to customize the output. Default is <code>niceCellFormater</code>.
Ignored if <code>stats</code> is a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] Named list of strings (LaTeX tables). Names correspond to the
selected problem instances in <code>probs</code>.
</p>


<h3>See Also</h3>

<p>Other EMOA performance assessment tools: 
<code><a href="#topic+approximateNadirPoint">approximateNadirPoint</a>()</code>,
<code><a href="#topic+approximateRefPoints">approximateRefPoints</a>()</code>,
<code><a href="#topic+approximateRefSets">approximateRefSets</a>()</code>,
<code><a href="#topic+computeDominanceRanking">computeDominanceRanking</a>()</code>,
<code><a href="#topic+emoaIndEps">emoaIndEps</a>()</code>,
<code><a href="#topic+makeEMOAIndicator">makeEMOAIndicator</a>()</code>,
<code><a href="#topic+niceCellFormater">niceCellFormater</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+plotDistribution">plotDistribution</a>()</code>,
<code><a href="#topic+plotFront">plotFront</a>()</code>,
<code><a href="#topic+plotScatter2d">plotScatter2d</a>()</code>,
<code><a href="#topic+plotScatter3d">plotScatter3d</a>()</code>
</p>

<hr>
<h2 id='toParetoDf'>Convert matrix to Pareto front data frame.</h2><span id='topic+toParetoDf'></span>

<h3>Description</h3>

<p>Inside ecr EMOA algorithms the fitness is maintained in an <code class="reqn">(o, n)</code> matrix
where <code class="reqn">o</code> is the number of objectives and <code class="reqn">n</code> is the number of individuals.
This function basically transposes such a matrix and converts it into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toParetoDf(x, filter.dups = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toParetoDf_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix.</p>
</td></tr>
<tr><td><code id="toParetoDf_+3A_filter.dups">filter.dups</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Shall duplicates be removed?
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>data.frame</code>]
</p>

<hr>
<h2 id='transformFitness'>Fitness transformation / scaling.</h2><span id='topic+transformFitness'></span>

<h3>Description</h3>

<p>Some selectors support maximization only, e.g., roulette wheel selector, or
minimization (most others). This function computes a factor from -1, 1 for
each objective to match supported selector optimization directions and
the actual objectives of the task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformFitness(fitness, task, selector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformFitness_+3A_fitness">fitness</code></td>
<td>
<p>[matrix]
Matrix of fitness values with the fitness vector of individual i in the i-th
column.</p>
</td></tr>
<tr><td><code id="transformFitness_+3A_task">task</code></td>
<td>
<p>[ecr_optimization_task]
Optimization task.</p>
</td></tr>
<tr><td><code id="transformFitness_+3A_selector">selector</code></td>
<td>
<p>[ecr_selector] 
Selector object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[matrix] Transformed / scaled fitness matrix.
</p>

<hr>
<h2 id='updateLogger'>Update the log.</h2><span id='topic+updateLogger'></span>

<h3>Description</h3>

<p>This function modifies the log in-place, i.e., without making
copies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateLogger(log, population, fitness = NULL, n.evals, extras = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateLogger_+3A_log">log</code></td>
<td>
<p>[<code>ecr_logger</code>]<br />
The log generated by <code>initLogger</code>.</p>
</td></tr>
<tr><td><code id="updateLogger_+3A_population">population</code></td>
<td>
<p>[<code>list</code>]<br />
List of individuals.</p>
</td></tr>
<tr><td><code id="updateLogger_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Optional matrix of fitness values (each column contains the fitness value(s) for
one individual) of <code>population</code>. If no matrix is passed and the log shall
store information of the fitness, each individual needs to have an attribute fitness.</p>
</td></tr>
<tr><td><code id="updateLogger_+3A_n.evals">n.evals</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of fitness function evaluations performed in the last generation.</p>
</td></tr>
<tr><td><code id="updateLogger_+3A_extras">extras</code></td>
<td>
<p>[<code>list</code>]<br />
Optional named list of additional scalar values to log.
See <code>log.extras</code> argument of <code><a href="#topic+initLogger">initLogger</a></code> for details.</p>
</td></tr>
<tr><td><code id="updateLogger_+3A_...">...</code></td>
<td>
<p>[any]<br />
Furhter arguments. Not used at the moment.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other logging: 
<code><a href="#topic+getPopulationFitness">getPopulationFitness</a>()</code>,
<code><a href="#topic+getPopulations">getPopulations</a>()</code>,
<code><a href="#topic+getStatistics">getStatistics</a>()</code>,
<code><a href="#topic+initLogger">initLogger</a>()</code>
</p>

<hr>
<h2 id='updateParetoArchive'>Update Pareto Archive.</h2><span id='topic+updateParetoArchive'></span>

<h3>Description</h3>

<p>This function updates a Pareto archive, i.e., an archive of non-dominated
points. It expects the archive, a set of individuals, a matrix of fitness values
(each column corresponds to the fitness vector of one individual) and updates
the archive &ldquo;in-place&rdquo;. If the archive has unlimited capacity all non-dominated points of
the union of archive and passed individuals are stored. Otherwise, i.e., in case
the archive is limited in capacity (argument <code>max.size</code> of
<code><a href="#topic+initParetoArchive">initParetoArchive</a></code> was set to an integer value greater zero), the
<code>trunc.fun</code> function passed to <code><a href="#topic+initParetoArchive">initParetoArchive</a></code> is applied to
all non-dominated points to determine which points should be dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateParetoArchive(archive, inds, fitness, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateParetoArchive_+3A_archive">archive</code></td>
<td>
<p>[<code>ecr_pareto_archive</code>]<br />
The archive generated by <code><a href="#topic+initParetoArchive">initParetoArchive</a></code>.</p>
</td></tr>
<tr><td><code id="updateParetoArchive_+3A_inds">inds</code></td>
<td>
<p>[<code>list</code>]<br />
List of individuals.</p>
</td></tr>
<tr><td><code id="updateParetoArchive_+3A_fitness">fitness</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of fitness values (each column contains the fitness value(s) for
one individual) of <code>inds</code>.</p>
</td></tr>
<tr><td><code id="updateParetoArchive_+3A_...">...</code></td>
<td>
<p>[any]<br />
Furhter arguments passed down to <code>trunc.fun</code> (set via <code><a href="#topic+initParetoArchive">initParetoArchive</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ParetoArchive: 
<code><a href="#topic+getIndividuals">getIndividuals</a>()</code>,
<code><a href="#topic+getSize">getSize</a>()</code>,
<code><a href="#topic+initParetoArchive">initParetoArchive</a>()</code>
</p>

<hr>
<h2 id='which.dominated'>Determine which points of a set are (non)dominated.</h2><span id='topic+which.dominated'></span><span id='topic+which.nondominated'></span><span id='topic+isMaximallyDominated'></span>

<h3>Description</h3>

<p>Given a matrix with one point per column <code>which.dominated</code> returns the
column numbers of the dominated points and <code>which.nondominated</code> the column
numbers of the nondominated points. Function <code>isMaximallyDominated</code> returns
a logical vector with <code>TRUE</code> for each point which is located on the last
non-domination level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.dominated(x)

which.nondominated(x)

isMaximallyDominated(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.dominated_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
Numeric (n x d) matrix where n is the number of points and d is the number
of objectives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mtcars)
  # assume we want to maximize horsepower and minimize gas consumption
  cars = mtcars[, c("mpg", "hp")]
  cars$hp = -cars$hp
  idxs = which.nondominated(as.matrix(cars))
  print(mtcars[idxs, ])
</code></pre>

<hr>
<h2 id='wrapChildren'>Wrap the individuals constructed by a recombination operator.</h2><span id='topic+wrapChildren'></span>

<h3>Description</h3>

<p>Should be used if the recombinator returns multiple children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapChildren(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapChildren_+3A_...">...</code></td>
<td>
<p>[any]<br />
Individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List of individuals.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
