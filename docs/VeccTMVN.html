<!DOCTYPE html><html lang="en"><head><title>Help for package VeccTMVN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VeccTMVN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FIC_reorder_univar'><p>Univariate ordering under FIC approximation, first m chosen by m iter of</p>
dense univariate reordering</a></li>
<li><a href='#find_nn_corr'><p>Find ordered nearest neighbors based on a correlation Matrix. Assuming the</p>
absolute value of the correlation is monotonically decreasing with distance.
Returns an n X (m + 1) matrix similar to 'GpGp::find_ordered_nn'.</a></li>
<li><a href='#get_sp_inv_chol'><p>Get the inverse upper Cholesky factor under the Vecchia approximation</p></a></li>
<li><a href='#loglk_censor_MVN'><p>Compute censored multivariate normal (MVN) log-probabilities that have</p>
spatial covariance matrices using Vecchia approximation</a></li>
<li><a href='#mvrandn'><p>Simulate truncated multivariate normal (TMVN) using the Vecchia approximation</p></a></li>
<li><a href='#mvrandt'><p>Simulate truncated multivariate normal (TMVT) using the Vecchia approximation</p></a></li>
<li><a href='#pmvn'><p>Compute multivariate normal (MVN) probabilities that have spatial covariance</p>
matrices using Vecchia approximation</a></li>
<li><a href='#pmvn_MLMC'><p>Applying the multi-level Monte Carlo (MLMC) technique to the pmvn function</p>
The function uses <code>NLevel1 = 1</code> for <code>m = m2</code> and the same
exponential tilting parameter as <code>m = m1</code> to compute one MC estimate.
This MC estimate is used to correct the bias from the Vecchia approximation</a></li>
<li><a href='#pmvt'><p>Compute multivariate Student-t (MVT) probabilities that have spatial covariance</p>
matrices using Vecchia approximation</a></li>
<li><a href='#pmvt_MLMC'><p>Applying the multi-level Monte Carlo (MLMC) technique to the pmvt function</p>
The function uses <code>NLevel1 = 1</code> for <code>m = m2</code> and the same
exponential tilting parameter as <code>m = m1</code> to compute one MC estimate.
This MC estimate is used to correct the bias from the Vecchia approximation</a></li>
<li><a href='#ptmvrandn'><p>Simulate partially censored multivariate normal (MVN) at censored locations</p>
using the Vecchia approximation</a></li>
<li><a href='#univar_order'><p>Univariate variable reordering, described in Genz and Bretz (2009)</p>
If failed due to PD singularity, the unfinished order will be returned
and a warning will be issued</a></li>
<li><a href='#Vecc_reorder'><p>Univariate ordering under Vecchia approximation</p></a></li>
<li><a href='#VeccTMVN'><p>VeccTMVN</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Normal Probabilities using Vecchia Approximation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Jian Cao [aut, cre],
  Matthias Katzfuss [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jian Cao &lt;jcao2416@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Under a different representation of the multivariate normal (MVN) probability, we can use the Vecchia approximation to sample the integrand at a linear complexity with respect to n. Additionally, both the SOV algorithm from Genz (92) and the exponential-tilting method from Botev (2017) can be adapted to linear complexity. The reference for the method implemented in this package is Jian Cao and Matthias Katzfuss (2024) "Linear-Cost Vecchia Approximation of Multivariate Normal Probabilities" &lt;<a href="https://doi.org/10.48550%2FarXiv.2311.09426">doi:10.48550/arXiv.2311.09426</a>&gt;. Two major references for the development of our method are Alan Genz (1992) "Numerical Computation of Multivariate Normal Probabilities" &lt;<a href="https://doi.org/10.1080%2F10618600.1992.10477010">doi:10.1080/10618600.1992.10477010</a>&gt; and Z. I. Botev (2017) "The Normal Law Under Linear Restrictions: Simulation and Estimation via Minimax Tilting" &lt;<a href="https://doi.org/10.48550%2FarXiv.1603.04166">doi:10.48550/arXiv.1603.04166</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), Matrix (&ge; 1.5-3), GpGp (&ge; 0.4.0),
truncnorm (&ge; 1.0-8), GPvecchia, TruncatedNormal, nleqslv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), lhs, mvtnorm</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JCatwood/VeccTMVN">https://github.com/JCatwood/VeccTMVN</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JCatwood/VeccTMVN/issues">https://github.com/JCatwood/VeccTMVN/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-26 19:21:04 UTC; jcao21</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-26 19:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='FIC_reorder_univar'>Univariate ordering under FIC approximation, first m chosen by m iter of
dense univariate reordering</h2><span id='topic+FIC_reorder_univar'></span>

<h3>Description</h3>

<p>Univariate ordering under FIC approximation, first m chosen by m iter of
dense univariate reordering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIC_reorder_univar(
  a,
  b,
  m,
  locs = NULL,
  covName = NULL,
  covParms = NULL,
  covMat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FIC_reorder_univar_+3A_a">a</code></td>
<td>
<p>lower bound vector for TMVN</p>
</td></tr>
<tr><td><code id="FIC_reorder_univar_+3A_b">b</code></td>
<td>
<p>upper bound vector for TMVN</p>
</td></tr>
<tr><td><code id="FIC_reorder_univar_+3A_m">m</code></td>
<td>
<p>Vecchia conditioning set size</p>
</td></tr>
<tr><td><code id="FIC_reorder_univar_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="FIC_reorder_univar_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="FIC_reorder_univar_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="FIC_reorder_univar_+3A_covmat">covMat</code></td>
<td>
<p>dense covariance matrix, not needed when 'locs' is not null</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of new order based on FIC assumption and maxmin ordering
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(VeccTMVN)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1 * n2
m &lt;- 5
locs &lt;- as.matrix(expand.grid((1:n1) / n1, (1:n2) / n2))
covparms &lt;- c(2, 0.1, 0)
cov_name &lt;- "matern15_isotropic"
a &lt;- rep(-Inf, n)
b &lt;- seq(from = -3, to = 3, length.out = n)
cat("The output order should be roughly 1 to ", n)
cat(FIC_reorder_univar(a, b, m, locs, cov_name, covparms))

</code></pre>

<hr>
<h2 id='find_nn_corr'>Find ordered nearest neighbors based on a correlation Matrix. Assuming the
absolute value of the correlation is monotonically decreasing with distance.
Returns an n X (m + 1) matrix similar to 'GpGp::find_ordered_nn'.</h2><span id='topic+find_nn_corr'></span>

<h3>Description</h3>

<p>Find ordered nearest neighbors based on a correlation Matrix. Assuming the
absolute value of the correlation is monotonically decreasing with distance.
Returns an n X (m + 1) matrix similar to 'GpGp::find_ordered_nn'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_nn_corr(corrMat, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_nn_corr_+3A_corrmat">corrMat</code></td>
<td>
<p>the correlation matrix</p>
</td></tr>
<tr><td><code id="find_nn_corr_+3A_m">m</code></td>
<td>
<p>the number of nearest neighbors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an n X (m + 1) matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GpGp)
library(VeccTMVN)
set.seed(123)
d &lt;- 3
n &lt;- 100
locs &lt;- matrix(runif(d * n), n, d)
covparms &lt;- c(2, 0.01, 0)
cov_mat &lt;- GpGp::matern15_isotropic(covparms, locs)
m &lt;- 10
NNarray_test &lt;- GpGp::find_ordered_nn(locs, m = m)
NNarray &lt;- find_nn_corr(cov_mat, m)
cat("Number of mismatch is", sum(NNarray != NNarray_test, na.rm = TRUE))

</code></pre>

<hr>
<h2 id='get_sp_inv_chol'>Get the inverse upper Cholesky factor under the Vecchia approximation</h2><span id='topic+get_sp_inv_chol'></span>

<h3>Description</h3>

<p>Get the inverse upper Cholesky factor under the Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sp_inv_chol(covMat, NNarray)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sp_inv_chol_+3A_covmat">covMat</code></td>
<td>
<p>the covariance matrix</p>
</td></tr>
<tr><td><code id="get_sp_inv_chol_+3A_nnarray">NNarray</code></td>
<td>
<p>n X (m + 1) matrix representing the nearest neighbor indices
among previous observations. This is typically the return of
GpGp::find_ordered_nn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>upper Cholesky of the inverse of 'covMat'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GpGp)
n1 &lt;- 10
n2 &lt;- 10
n &lt;- n1 * n2
locs &lt;- as.matrix(expand.grid((1:n1) / n1, (1:n2) / n2))
covparms &lt;- c(2, 0.3, 0)
cov_mat &lt;- GpGp::matern15_isotropic(covparms, locs)
m &lt;- 30
NNarray &lt;- GpGp::find_ordered_nn(locs, m = m)
# Vecchia approx --------------------------------
U_Vecc &lt;- get_sp_inv_chol(cov_mat, NNarray)
U &lt;- solve(chol(cov_mat))
cat("Frobenius norm of the difference is", sqrt(sum((U - U_Vecc)^2)))

</code></pre>

<hr>
<h2 id='loglk_censor_MVN'>Compute censored multivariate normal (MVN) log-probabilities that have
spatial covariance matrices using Vecchia approximation</h2><span id='topic+loglk_censor_MVN'></span>

<h3>Description</h3>

<p>Compute censored multivariate normal (MVN) log-probabilities that have
spatial covariance matrices using Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglk_censor_MVN(
  locs,
  indCensor,
  y,
  bCensor,
  covName = NULL,
  covParms = NULL,
  m = 30,
  NLevel1 = 10,
  NLevel2 = 1000,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglk_censor_MVN_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="loglk_censor_MVN_+3A_indcensor">indCensor</code></td>
<td>
<p>indices of locations that have only censored observations</p>
</td></tr>
<tr><td><code id="loglk_censor_MVN_+3A_y">y</code></td>
<td>
<p>observed (not censored) values, of length n</p>
</td></tr>
<tr><td><code id="loglk_censor_MVN_+3A_bcensor">bCensor</code></td>
<td>
<p>upper bound, above which observations are not censored,
can be different for different locations, of length 1 or n</p>
</td></tr>
<tr><td><code id="loglk_censor_MVN_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="loglk_censor_MVN_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="loglk_censor_MVN_+3A_m">m</code></td>
<td>
<p>Vecchia conditioning set size</p>
</td></tr>
<tr><td><code id="loglk_censor_MVN_+3A_nlevel1">NLevel1</code></td>
<td>
<p>first level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="loglk_censor_MVN_+3A_nlevel2">NLevel2</code></td>
<td>
<p>second level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="loglk_censor_MVN_+3A_verbose">verbose</code></td>
<td>
<p>verbose level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated MVN probability and estimation error
</p>

<hr>
<h2 id='mvrandn'>Simulate truncated multivariate normal (TMVN) using the Vecchia approximation</h2><span id='topic+mvrandn'></span>

<h3>Description</h3>

<p>Simulate truncated multivariate normal (TMVN) using the Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrandn(
  lower,
  upper,
  mean,
  locs = NULL,
  covName = "matern15_isotropic",
  covParms = c(1, 0.1, 0),
  m = 30,
  sigma = NULL,
  N = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvrandn_+3A_lower">lower</code></td>
<td>
<p>lower bound vector for TMVN</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_upper">upper</code></td>
<td>
<p>upper bound vector for TMVN</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_mean">mean</code></td>
<td>
<p>MVN mean</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_m">m</code></td>
<td>
<p>Vecchia conditioning set size</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_sigma">sigma</code></td>
<td>
<p>dense covariance matrix, not needed when 'locs' is not null</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_n">N</code></td>
<td>
<p>number of samples required</p>
</td></tr>
<tr><td><code id="mvrandn_+3A_verbose">verbose</code></td>
<td>
<p>verbose level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n X N matrix of generated samples
</p>

<hr>
<h2 id='mvrandt'>Simulate truncated multivariate normal (TMVT) using the Vecchia approximation</h2><span id='topic+mvrandt'></span>

<h3>Description</h3>

<p>Simulate truncated multivariate normal (TMVT) using the Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrandt(
  lower,
  upper,
  delta,
  df,
  locs = NULL,
  covName = "matern15_isotropic",
  covParms = c(1, 0.1, 0),
  m = 30,
  sigma = NULL,
  N = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvrandt_+3A_lower">lower</code></td>
<td>
<p>lower bound vector for TMVT</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_upper">upper</code></td>
<td>
<p>upper bound vector for TMVT</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_delta">delta</code></td>
<td>
<p>MVT shifting parameter</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_m">m</code></td>
<td>
<p>Vecchia conditioning set size</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_sigma">sigma</code></td>
<td>
<p>dense covariance matrix, not needed when 'locs' is not null</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_n">N</code></td>
<td>
<p>number of samples required</p>
</td></tr>
<tr><td><code id="mvrandt_+3A_verbose">verbose</code></td>
<td>
<p>verbose level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n X N matrix of generated samples
</p>

<hr>
<h2 id='pmvn'>Compute multivariate normal (MVN) probabilities that have spatial covariance
matrices using Vecchia approximation</h2><span id='topic+pmvn'></span>

<h3>Description</h3>

<p>Compute multivariate normal (MVN) probabilities that have spatial covariance
matrices using Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvn(
  lower,
  upper,
  mean,
  locs = NULL,
  covName = "matern15_isotropic",
  covParms = c(1, 0.1, 0),
  m = 30,
  sigma = NULL,
  reorder = 0,
  NLevel1 = 12,
  NLevel2 = 10000,
  verbose = FALSE,
  retlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmvn_+3A_lower">lower</code></td>
<td>
<p>lower bound vector for TMVN</p>
</td></tr>
<tr><td><code id="pmvn_+3A_upper">upper</code></td>
<td>
<p>upper bound vector for TMVN</p>
</td></tr>
<tr><td><code id="pmvn_+3A_mean">mean</code></td>
<td>
<p>MVN mean</p>
</td></tr>
<tr><td><code id="pmvn_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="pmvn_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="pmvn_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="pmvn_+3A_m">m</code></td>
<td>
<p>Vecchia conditioning set size</p>
</td></tr>
<tr><td><code id="pmvn_+3A_sigma">sigma</code></td>
<td>
<p>dense covariance matrix, not needed when 'locs' is not null</p>
</td></tr>
<tr><td><code id="pmvn_+3A_reorder">reorder</code></td>
<td>
<p>whether to reorder integration variables. '0' for no,
'1' for FIC-based univariate ordering, '2' for Vecchia-based univariate
ordering, and '3' for univariate reordering, which appeared faster than '2'</p>
</td></tr>
<tr><td><code id="pmvn_+3A_nlevel1">NLevel1</code></td>
<td>
<p>first level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="pmvn_+3A_nlevel2">NLevel2</code></td>
<td>
<p>second level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="pmvn_+3A_verbose">verbose</code></td>
<td>
<p>verbose or not</p>
</td></tr>
<tr><td><code id="pmvn_+3A_retlog">retlog</code></td>
<td>
<p>TRUE or FALSE for whether to return loglk or not</p>
</td></tr>
<tr><td><code id="pmvn_+3A_...">...</code></td>
<td>
<p>could be
m_ord for conditioning set size for reordering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated MVN probability and estimation error
</p>

<hr>
<h2 id='pmvn_MLMC'>Applying the multi-level Monte Carlo (MLMC) technique to the pmvn function
The function uses <code>NLevel1 = 1</code> for <code>m = m2</code> and the same
exponential tilting parameter as <code>m = m1</code> to compute one MC estimate.
This MC estimate is used to correct the bias from the Vecchia approximation</h2><span id='topic+pmvn_MLMC'></span>

<h3>Description</h3>

<p>Applying the multi-level Monte Carlo (MLMC) technique to the pmvn function
The function uses <code>NLevel1 = 1</code> for <code>m = m2</code> and the same
exponential tilting parameter as <code>m = m1</code> to compute one MC estimate.
This MC estimate is used to correct the bias from the Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvn_MLMC(
  lower,
  upper,
  mean,
  locs = NULL,
  covName = "matern15_isotropic",
  covParms = c(1, 0.1, 0),
  m1 = 30,
  m2 = 100,
  sigma = NULL,
  reorder = 0,
  NLevel1 = 12,
  NLevel2 = 10000,
  verbose = FALSE,
  retlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmvn_MLMC_+3A_lower">lower</code></td>
<td>
<p>lower bound vector for TMVN</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_upper">upper</code></td>
<td>
<p>upper bound vector for TMVN</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_mean">mean</code></td>
<td>
<p>MVN mean</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_m1">m1</code></td>
<td>
<p>the smaller Vecchia conditioning set size for Level 1 MC</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_m2">m2</code></td>
<td>
<p>the bigger Vecchia conditioning set size for Level 2 MC</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_sigma">sigma</code></td>
<td>
<p>dense covariance matrix, not needed when 'locs' is not null</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_reorder">reorder</code></td>
<td>
<p>whether to reorder integration variables. '0' for no,
'1' for FIC-based univariate ordering, '2' for Vecchia-based univariate
ordering, and '3' for univariate reordering, which appeared faster than '2'</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_nlevel1">NLevel1</code></td>
<td>
<p>first level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_nlevel2">NLevel2</code></td>
<td>
<p>second level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_verbose">verbose</code></td>
<td>
<p>verbose or not</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_retlog">retlog</code></td>
<td>
<p>TRUE or FALSE for whether to return loglk or not</p>
</td></tr>
<tr><td><code id="pmvn_MLMC_+3A_...">...</code></td>
<td>
<p>could be
m_ord for conditioning set size for reordering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated MVN probability and estimation error
</p>

<hr>
<h2 id='pmvt'>Compute multivariate Student-t (MVT) probabilities that have spatial covariance
matrices using Vecchia approximation</h2><span id='topic+pmvt'></span>

<h3>Description</h3>

<p>Compute multivariate Student-t (MVT) probabilities that have spatial covariance
matrices using Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvt(
  lower,
  upper,
  delta,
  df,
  locs = NULL,
  covName = "matern15_isotropic",
  covParms = c(1, 0.1, 0),
  m = 30,
  sigma = NULL,
  reorder = 0,
  NLevel1 = 12,
  NLevel2 = 10000,
  verbose = FALSE,
  retlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmvt_+3A_lower">lower</code></td>
<td>
<p>lower bound vector for TMVT</p>
</td></tr>
<tr><td><code id="pmvt_+3A_upper">upper</code></td>
<td>
<p>upper bound vector for TMVT</p>
</td></tr>
<tr><td><code id="pmvt_+3A_delta">delta</code></td>
<td>
<p>MVT shifting parameter</p>
</td></tr>
<tr><td><code id="pmvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="pmvt_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="pmvt_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="pmvt_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="pmvt_+3A_m">m</code></td>
<td>
<p>Vecchia conditioning set size</p>
</td></tr>
<tr><td><code id="pmvt_+3A_sigma">sigma</code></td>
<td>
<p>dense covariance matrix, not needed when 'locs' is not null</p>
</td></tr>
<tr><td><code id="pmvt_+3A_reorder">reorder</code></td>
<td>
<p>whether to reorder integration variables. '0' for no,
'1' for FIC-based univariate ordering, '2' for Vecchia-based univariate
ordering, and '3' for univariate reordering, which appeared faster than '2'</p>
</td></tr>
<tr><td><code id="pmvt_+3A_nlevel1">NLevel1</code></td>
<td>
<p>first level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="pmvt_+3A_nlevel2">NLevel2</code></td>
<td>
<p>second level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="pmvt_+3A_verbose">verbose</code></td>
<td>
<p>verbose or not</p>
</td></tr>
<tr><td><code id="pmvt_+3A_retlog">retlog</code></td>
<td>
<p>TRUE or FALSE for whether to return loglk or not</p>
</td></tr>
<tr><td><code id="pmvt_+3A_...">...</code></td>
<td>
<p>could be
m_ord for conditioning set size for reordering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated MVT probability and estimation error
</p>

<hr>
<h2 id='pmvt_MLMC'>Applying the multi-level Monte Carlo (MLMC) technique to the pmvt function
The function uses <code>NLevel1 = 1</code> for <code>m = m2</code> and the same
exponential tilting parameter as <code>m = m1</code> to compute one MC estimate.
This MC estimate is used to correct the bias from the Vecchia approximation</h2><span id='topic+pmvt_MLMC'></span>

<h3>Description</h3>

<p>Applying the multi-level Monte Carlo (MLMC) technique to the pmvt function
The function uses <code>NLevel1 = 1</code> for <code>m = m2</code> and the same
exponential tilting parameter as <code>m = m1</code> to compute one MC estimate.
This MC estimate is used to correct the bias from the Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvt_MLMC(
  lower,
  upper,
  delta,
  df,
  locs = NULL,
  covName = "matern15_isotropic",
  covParms = c(1, 0.1, 0),
  m1 = 30,
  m2 = 100,
  sigma = NULL,
  reorder = 0,
  NLevel1 = 12,
  NLevel2 = 10000,
  verbose = FALSE,
  retlog = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmvt_MLMC_+3A_lower">lower</code></td>
<td>
<p>lower bound vector for TMVT</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_upper">upper</code></td>
<td>
<p>upper bound vector for TMVT</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_delta">delta</code></td>
<td>
<p>MVT shifting parameter</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_m1">m1</code></td>
<td>
<p>the smaller Vecchia conditioning set size for Level 1 MC</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_m2">m2</code></td>
<td>
<p>the bigger Vecchia conditioning set size for Level 2 MC</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_sigma">sigma</code></td>
<td>
<p>dense covariance matrix, not needed when 'locs' is not null</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_reorder">reorder</code></td>
<td>
<p>whether to reorder integration variables. '0' for no,
'1' for FIC-based univariate ordering, '2' for Vecchia-based univariate
ordering, and '3' for univariate reordering, which appeared faster than '2'</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_nlevel1">NLevel1</code></td>
<td>
<p>first level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_nlevel2">NLevel2</code></td>
<td>
<p>second level Monte Carlo sample size</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_verbose">verbose</code></td>
<td>
<p>verbose or not</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_retlog">retlog</code></td>
<td>
<p>TRUE or FALSE for whether to return loglk or not</p>
</td></tr>
<tr><td><code id="pmvt_MLMC_+3A_...">...</code></td>
<td>
<p>could be
m_ord for conditioning set size for reordering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated MVT probability and estimation error
</p>

<hr>
<h2 id='ptmvrandn'>Simulate partially censored multivariate normal (MVN) at censored locations 
using the Vecchia approximation</h2><span id='topic+ptmvrandn'></span>

<h3>Description</h3>

<p>Simulate partially censored multivariate normal (MVN) at censored locations 
using the Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptmvrandn(
  locs,
  indCensor,
  y,
  bCensor,
  covName = NULL,
  covParms = NULL,
  m = 30,
  N = 1000,
  verbose = TRUE,
  reorder = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptmvrandn_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="ptmvrandn_+3A_indcensor">indCensor</code></td>
<td>
<p>indices of locations that have only censored observations</p>
</td></tr>
<tr><td><code id="ptmvrandn_+3A_y">y</code></td>
<td>
<p>observed (not censored) values, of length n</p>
</td></tr>
<tr><td><code id="ptmvrandn_+3A_bcensor">bCensor</code></td>
<td>
<p>upper bound, above which observations are not censored,
can be different for different locations, of length 1 or n</p>
</td></tr>
<tr><td><code id="ptmvrandn_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="ptmvrandn_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="ptmvrandn_+3A_m">m</code></td>
<td>
<p>Vecchia conditioning set size</p>
</td></tr>
<tr><td><code id="ptmvrandn_+3A_n">N</code></td>
<td>
<p>number of samples required</p>
</td></tr>
<tr><td><code id="ptmvrandn_+3A_verbose">verbose</code></td>
<td>
<p>verbose level</p>
</td></tr>
<tr><td><code id="ptmvrandn_+3A_reorder">reorder</code></td>
<td>
<p>whether to Vecchia univariate variable reordering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n X N matrix of generated samples
</p>

<hr>
<h2 id='univar_order'>Univariate variable reordering, described in Genz and Bretz (2009)
If failed due to PD singularity, the unfinished order will be returned 
and a warning will be issued</h2><span id='topic+univar_order'></span>

<h3>Description</h3>

<p>Univariate variable reordering, described in Genz and Bretz (2009)
If failed due to PD singularity, the unfinished order will be returned 
and a warning will be issued
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univar_order(a, b, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="univar_order_+3A_a">a</code></td>
<td>
<p>lower integration limits</p>
</td></tr>
<tr><td><code id="univar_order_+3A_b">b</code></td>
<td>
<p>upper integration limits</p>
</td></tr>
<tr><td><code id="univar_order_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new order
</p>

<hr>
<h2 id='Vecc_reorder'>Univariate ordering under Vecchia approximation</h2><span id='topic+Vecc_reorder'></span>

<h3>Description</h3>

<p>Univariate ordering under Vecchia approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vecc_reorder(
  a,
  b,
  m,
  locs = NULL,
  covName = NULL,
  covParms = NULL,
  covMat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Vecc_reorder_+3A_a">a</code></td>
<td>
<p>lower bound vector for TMVN</p>
</td></tr>
<tr><td><code id="Vecc_reorder_+3A_b">b</code></td>
<td>
<p>upper bound vector for TMVN</p>
</td></tr>
<tr><td><code id="Vecc_reorder_+3A_m">m</code></td>
<td>
<p>Vecchia conditioning set size</p>
</td></tr>
<tr><td><code id="Vecc_reorder_+3A_locs">locs</code></td>
<td>
<p>location (feature) matrix n X d</p>
</td></tr>
<tr><td><code id="Vecc_reorder_+3A_covname">covName</code></td>
<td>
<p>covariance function name from the 'GpGp' package</p>
</td></tr>
<tr><td><code id="Vecc_reorder_+3A_covparms">covParms</code></td>
<td>
<p>parameters for 'covName'</p>
</td></tr>
<tr><td><code id="Vecc_reorder_+3A_covmat">covMat</code></td>
<td>
<p>dense covariance matrix, not needed when 'locs' is not null</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new order, nearest neighbor matrix, and coefficient matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lhs)
library(GpGp)
library(VeccTMVN)
set.seed(123)
n &lt;- 100
m &lt;- 5
locs &lt;- lhs::geneticLHS(n, 2)
covparms &lt;- c(1, 0.1, 0)
cov_name &lt;- "matern15_isotropic"
cov_mat &lt;- get(cov_name)(covparms, locs)
a &lt;- rep(-Inf, n)
b &lt;- runif(n)
odr_TN &lt;- TruncatedNormal::cholperm(cov_mat, a, b)$perm
rslt &lt;- Vecc_reorder(a, b, m,
  locs = locs, covName = cov_name,
  covParms = covparms
)
# compare order
cat(rslt$order)
cat(odr_TN)
</code></pre>

<hr>
<h2 id='VeccTMVN'>VeccTMVN</h2><span id='topic+VeccTMVN'></span>

<h3>Description</h3>

<p>Compute multivariate normal probabilities and sample from multivariate 
truncated normal distribution, taking advantage of the Vecchia approximation
</p>


<h3>Author(s)</h3>

<p>jcao2416@gmail.com
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
