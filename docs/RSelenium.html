<!DOCTYPE html><html lang="en"><head><title>Help for package RSelenium</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RSelenium}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RSelenium-package'><p>An R client for Selenium Remote Webdriver</p></a></li>
<li><a href='#errorHandler-class'><p>CLASS errorHandler</p></a></li>
<li><a href='#getChromeProfile'><p>Get Chrome profile.</p></a></li>
<li><a href='#getFirefoxProfile'><p>Get Firefox profile.</p></a></li>
<li><a href='#makeFirefoxProfile'><p>Make Firefox profile.</p></a></li>
<li><a href='#remoteDriver-class'><p>CLASS remoteDriver</p></a></li>
<li><a href='#rsDriver'><p>Start a selenium server and browser</p></a></li>
<li><a href='#selKeys'><p>Selenium key mappings</p></a></li>
<li><a href='#webElement-class'><p>CLASS webElement</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Bindings for 'Selenium WebDriver'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.9</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of R bindings for the 'Selenium 2.0 WebDriver'
    (see <a href="https://www.selenium.dev/documentation/">https://www.selenium.dev/documentation/</a>
    for more information) using the 'JsonWireProtocol' (see
    <a href="https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol">https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol</a> for more
    information). 'Selenium 2.0 WebDriver' allows driving a web browser
    natively as a user would either locally or on a remote machine using
    the Selenium server it marks a leap forward in terms of web browser
    automation. Selenium automates web browsers (commonly referred to as
    browsers). Using RSelenium you can automate browsers locally or
    remotely.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/RSelenium/">https://docs.ropensci.org/RSelenium/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/RSelenium/issues">https://github.com/ropensci/RSelenium/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, caTools, utils, httr, wdman(&ge; 0.2.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>binman, XML, testthat, knitr, covr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RSelenium.R' 'errorHandler.R' 'remoteDriver.R' 'rsDriver.R'
'selKeys-data.R' 'util.R' 'webElement.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-01 20:00:13 UTC; juyeongkim</td>
</tr>
<tr>
<td>Author:</td>
<td>John Harrison [aut] (original author),
  Ju Yeong Kim [cre] (rOpenSci maintainer)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ju Yeong Kim &lt;jkim2345@fredhutch.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-02 08:10:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='RSelenium-package'>An R client for Selenium Remote Webdriver</h2><span id='topic+RSelenium-package'></span><span id='topic+RSelenium'></span>

<h3>Description</h3>

<p>These are R bindings for the WebDriver API in Selenium 2.
They use the JsonWireProtocol defined at
https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol
to communicate with a Selenium RemoteWebDriver Server.
</p>


<h3>Author(s)</h3>

<p>John Harrison
</p>


<h3>References</h3>

<p>http://seleniumhq.org/projects/webdriver/
</p>

<hr>
<h2 id='errorHandler-class'>CLASS errorHandler</h2><span id='topic+errorHandler-class'></span><span id='topic+errorHandler'></span>

<h3>Description</h3>

<p>class to handle errors
</p>


<h3>Details</h3>

<p>This class is an internal class used by remoteDriver and webElement. It
describes how drivers may respond. With a wide range of browsers etc
the response can be variable.
</p>


<h3>Fields</h3>


<dl>
<dt><code>statusCodes</code></dt><dd><p>A list with status codes and their descriptions.</p>
</dd>
<dt><code>status</code></dt><dd><p>A status code summarizing the result of the command. A
non-zero value indicates that the command failed. A value of one is
not a failure but may  indicate a problem.</p>
</dd>
<dt><code>statusclass</code></dt><dd><p>Class associated with the java library underlying
the server. For Example: org.openqa.selenium.remote.Response</p>
</dd>
<dt><code>sessionid</code></dt><dd><p>An opaque handle used by the server to determine where
to route session-specific commands. This ID should be included in
all future session-commands in place of the :sessionId path segment
variable.</p>
</dd>
<dt><code>hcode</code></dt><dd><p>A list</p>
</dd>
<dt><code>value</code></dt><dd><p>A list containing detailed information regarding possible
errors:
</p>

<dl>
<dt><code>message</code>:</dt><dd><p>A descriptive message for the command
failure.</p>
</dd>
<dt><code>screen</code>:</dt><dd><p>string   (Optional) If included, a
screenshot of the current page as a base64 encoded string.</p>
</dd>
<dt><code>class</code>:</dt><dd><p>string   (Optional) If included, specifies
the fully qualified class name for the exception that was thrown
when the command failed.</p>
</dd>
<dt><code>stackTrace</code>:</dt><dd><p>array   (Optional) If included,
specifies an array of JSON objects describing the stack trace
for the exception that was thrown when the command failed. The
zeroth element of the array represents the top of the stack.</p>
</dd>
</dl>
</dd>
<dt><code>responseheader</code></dt><dd><p>There are two levels of error handling specified
by the wire protocol: invalid requests and failed commands.
Invalid Requests will probably be indicted by a status of 1.
</p>
<p>All invalid requests should result in the server returning a 4xx HTTP
response. The response Content-Type should be set to text/plain and
the message body should be a descriptive error message. The
categories of invalid requests are as follows:
</p>

<dl>
<dt><code>Unknown Commands</code>:</dt><dd>
<p>If the server receives a command request whose path is not mapped
to a resource in the REST service, it should respond with a 404
Not Found message.
</p>
</dd>
<dt><code>Unimplemented Commands</code>:</dt><dd>
<p>Every server implementing the WebDriver wire protocol must
respond to every defined command. If an individual command has
not been implemented on the server, the server should respond
with a 501 Not Implemented error message. Note this is the only
error in the Invalid Request category that does not return a 4xx
status code.
</p>
</dd>
<dt><code>Variable Resource Not Found</code>:</dt><dd>
<p>If a request path maps to a variable resource, but that resource
does not exist, then the server should respond with a 404 Not
Found. For example, if ID my-session is not a valid session ID
on the server, and a command is sent to GET /session/my-session
HTTP/1.1, then the server should gracefully return a 404.
</p>
</dd>
<dt><code>Invalid Command Method</code>:</dt><dd>
<p>If a request path maps to a valid resource, but that resource
does not respond to the request method, the server should
respond with a 405 Method Not Allowed. The response must include
an Allows header with a list of the allowed methods for the
requested resource.
</p>
</dd>
<dt><code>Missing Command Parameters</code>:</dt><dd>
<p>If a POST/PUT command maps to a resource that expects a set of
JSON parameters, and the response body does not include one of
those parameters, the server should respond with a 400 Bad
Request. The response body should list the missing parameters.
</p>
</dd>
</dl>
</dd>
<dt><code>debugheader</code></dt><dd><p>Not currently implemented</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>checkStatus(resContent)</code></dt><dd><p>An internal method to check the status returned by the server. If
status indicates an error an appropriate error message is thrown.</p>
</dd>
<dt><code>errorDetails(type = "value")</code></dt><dd><p>Return error details. Type can one of c(&quot;value&quot;, &quot;class&quot;,
&quot;status&quot;)</p>
</dd>
<dt><code>obscureUrlPassword(url)</code></dt><dd><p>Replaces the username and password of url with ****</p>
</dd>
<dt><code>queryRD(ipAddr, method = "GET", qdata = NULL)</code></dt><dd><p>A method to communicate with the remote server implementing the
JSON wire protocol.</p>
</dd>
</dl>

<hr>
<h2 id='getChromeProfile'>Get Chrome profile.</h2><span id='topic+getChromeProfile'></span>

<h3>Description</h3>

<p><code>getChromeProfile</code>
A utility function to get a Chrome profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChromeProfile(dataDir, profileDir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getChromeProfile_+3A_datadir">dataDir</code></td>
<td>
<p>Specifies the user data directory, which is where the
browser will look for all of its state.</p>
</td></tr>
<tr><td><code id="getChromeProfile_+3A_profiledir">profileDir</code></td>
<td>
<p>Selects directory of profile to associate with the
first browser launched.</p>
</td></tr>
</table>


<h3>Detail</h3>

<p>A chrome profile directory is passed as an extraCapability.
The data dir has a number of default locations
</p>

<dl>
<dt>Windows XP</dt><dd>
<p>Google Chrome: C:/Documents and Settings/%USERNAME%/Local Settings/Application Data/Google/Chrome/User Data
</p>
</dd>
<dt>Windows 8 or 7 or Vista</dt><dd>
<p>Google Chrome: C:/Users/%USERNAME%/AppData/Local/Google/Chrome/User Data
</p>
</dd>
<dt>Mac OS X</dt><dd>
<p>Google Chrome: ~/Library/Application Support/Google/Chrome
</p>
</dd>
<dt>Linux</dt><dd>
<p>Google Chrome: ~/.config/google-chrome
</p>
</dd>
</dl>

<p>The profile directory is contained in the user directory and by default
is named &quot;Default&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example from windows using a profile directory "Profile 1"
cprof &lt;- getChromeProfile(
  "C:\\Users\\john\\AppData\\Local\\Google\\Chrome\\User Data",
  "Profile 1"
)
remDr &lt;- remoteDriver(browserName = "chrome", extraCapabilities = cprof)

## End(Not run)
</code></pre>

<hr>
<h2 id='getFirefoxProfile'>Get Firefox profile.</h2><span id='topic+getFirefoxProfile'></span>

<h3>Description</h3>

<p><code>getFirefoxProfile</code>
A utility function to get a firefox profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFirefoxProfile(profDir, useBase = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFirefoxProfile_+3A_profdir">profDir</code></td>
<td>
<p>The directory in which the firefox profile resides</p>
</td></tr>
<tr><td><code id="getFirefoxProfile_+3A_usebase">useBase</code></td>
<td>
<p>Logical indicating whether to attempt to use zip from
utils package. Maybe easier for Windows users.</p>
</td></tr>
</table>


<h3>Detail</h3>

<p>A firefox profile directory is zipped and base64
encoded. It can then be passed to the selenium server as a required
capability with key firefox_profile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fprof &lt;- getFirefoxProfile("~/.mozilla/firefox/9qlj1ofd.testprofile")
remDr &lt;- remoteDriver(extraCapabilities = fprof)
remDr$open()

## End(Not run)
</code></pre>

<hr>
<h2 id='makeFirefoxProfile'>Make Firefox profile.</h2><span id='topic+makeFirefoxProfile'></span>

<h3>Description</h3>

<p><code>makeFirefoxProfile</code>
A utility function to make a firefox profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFirefoxProfile(opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeFirefoxProfile_+3A_opts">opts</code></td>
<td>
<p>option list of firefox</p>
</td></tr>
</table>


<h3>Detail</h3>

<p>A firefox profile directory is zipped and base64
encoded. It can then be passed
to the selenium server as a required capability with key
firefox_profile
</p>


<h3>Note</h3>

<p>Windows doesn't come with command-line zip capability.
Installing rtools
<a href="https://CRAN.R-project.org/bin/windows/Rtools/index.html">https://CRAN.R-project.org/bin/windows/Rtools/index.html</a> is a
straightforward way to gain this capability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fprof &lt;- makeFirefoxProfile(list(browser.download.dir = "D:/temp"))
remDr &lt;- remoteDriver(extraCapabilities = fprof)
remDr$open()

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteDriver-class'>CLASS remoteDriver</h2><span id='topic+remoteDriver-class'></span><span id='topic+remoteDriver'></span>

<h3>Description</h3>

<p>remoteDriver Class uses the JsonWireProtocol to communicate with the
Selenium Server. If an error occurs while executing the command then
the server sends back an HTTP error code with a JSON encoded response
that indicates the precise Response Error Code. The remoteDriver
class inherits from the <code>errorHandler</code> class. If no error
occurred, then the subroutine called will return the value sent back
from the server (if a return value was sent).
So a rule of thumb while invoking methods on the driver is if the
method did not return a status greater then zero when called, then
you can safely assume the command was successful even if nothing was
returned by the method.
</p>


<h3>Details</h3>

<p>remoteDriver is a generator object. To define a new remoteDriver class
method 'new' is called. The slots (default value) that are user
defined are:
remoteServerAddr(localhost), port(4444), browserName(firefox),
version(&quot;&quot;), platform(ANY),
javascript(TRUE). See examples for more information on use.
</p>


<h3>Fields</h3>


<dl>
<dt><code>remoteServerAddr</code></dt><dd><p>Object of class <code>"character"</code>, giving the
ip of the remote server. Defaults to localhost</p>
</dd>
<dt><code>port</code></dt><dd><p>Object of class <code>"numeric"</code>, the port of the remote
server on which to connect</p>
</dd>
<dt><code>browserName</code></dt><dd><p>Object of class <code>"character"</code>. The name of the
browser being used; should be one of chrome|firefox|htmlunit|
internet explorer|iphone.</p>
</dd>
<dt><code>path</code></dt><dd><p>base URL path prefix for commands on the remote server.
Defaults to &quot;/wd/hub&quot;</p>
</dd>
<dt><code>version</code></dt><dd><p>Object of class <code>"character"</code>. The browser version,
or the empty string if unknown.</p>
</dd>
<dt><code>platform</code></dt><dd><p>Object of class <code>"character"</code>. A key specifying
which platform the browser is running on. This value should be one
of WINDOWS|XP|VISTA|MAC|LINUX|UNIX. When requesting a new session,
the client may specify ANY to indicate any available platform may be
used.</p>
</dd>
<dt><code>javascript</code></dt><dd><p>Object of class <code>"logical"</code>. Whether the session
supports executing user supplied JavaScript in the context of the
current page.</p>
</dd>
<dt><code>nativeEvents</code></dt><dd><p>Object of class <code>"logical"</code>. Whether the
session supports native events. n WebDriver advanced user
interactions are provided by either simulating the Javascript events
directly (i.e. synthetic events) or by letting the browser generate
the Javascript events (i.e. native events). Native events simulate
the user interactions better.</p>
</dd>
<dt><code>serverURL</code></dt><dd><p>Object of class <code>"character"</code>. Url of the remote
server which JSON requests are sent to.</p>
</dd>
<dt><code>sessionInfo</code></dt><dd><p>Object of class <code>"list"</code>. A list containing
information on sessions.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>acceptAlert()</code></dt><dd><p>Accepts the currently displayed alert dialog.  Usually, this is
equivalent to clicking the 'OK' button in the dialog.</p>
</dd>
<dt><code>addCookie(
  name,
  value,
  path = "/",
  domain = NULL,
  httpOnly = NULL,
  expiry = NULL,
  secure = FALSE
)</code></dt><dd><p>Set a cookie on the domain. The inputs are required apart from
those with default values.</p>
</dd>
<dt><code>buttondown(buttonId = 0)</code></dt><dd><p>Click and hold the given mouse button (at the coordinates set by
the last moveto command). Note that the next mouse-related command
that should follow is buttondown . Any other mouse command (such
as click or another call to buttondown) will yield undefined
behaviour. buttonId - any one of 'LEFT'/0 'MIDDLE'/1 'RIGHT'/2.
Defaults to 'LEFT'</p>
</dd>
<dt><code>buttonup(buttonId = 0)</code></dt><dd><p>Releases the mouse button previously held (where the mouse is
currently at). Must be called once for every buttondown command
issued. See the note in click and buttondown about implications of
out-of-order commands. buttonId - any one of 'LEFT'/0 'MIDDLE'/1
'RIGHT'/2. Defaults to 'LEFT'</p>
</dd>
<dt><code>click(buttonId = 0)</code></dt><dd><p>Click any mouse button (at the coordinates set by the last
mouseMoveToLocation() command). buttonId - any one of 'LEFT'/0
'MIDDLE'/1 'RIGHT'/2. Defaults to 'LEFT'</p>
</dd>
<dt><code>close()</code></dt><dd><p>Close the current session.</p>
</dd>
<dt><code>closeServer()</code></dt><dd><p>Closes the server in practice terminating the process. This is
useful for linux systems. On windows the java binary operates as a
separate shell which the user can terminate.</p>
</dd>
<dt><code>closeWindow()</code></dt><dd><p>Close the current window.</p>
</dd>
<dt><code>deleteAllCookies()</code></dt><dd><p>Delete all cookies visible to the current page.</p>
</dd>
<dt><code>deleteCookieNamed(name)</code></dt><dd><p>Delete the cookie with the given name. This command will be a
no-op if there is no such cookie visible to the current page.</p>
</dd>
<dt><code>dismissAlert()</code></dt><dd><p>Dismisses the currently displayed alert dialog. For confirm() and
prompt() dialogs, this is equivalent to clicking the 'Cancel'
button. For alert() dialogs, this is equivalent to clicking the
'OK' button.</p>
</dd>
<dt><code>doubleclick(buttonId = 0)</code></dt><dd><p>Double-Click any mouse button (at the coordinates set by the last
mouseMoveToLocation() command). buttonId - any one of 'LEFT'/0
'MIDDLE'/1 'RIGHT'/2. Defaults to 'LEFT'</p>
</dd>
<dt><code>executeAsyncScript(script, args = list())</code></dt><dd><p>Inject a snippet of JavaScript into the page for execution in the
context of the currently selected frame. The executed script is
assumed to be asynchronous and must signal that is done by
invoking the provided callback, which is always provided as the
final argument to the function. The value to this callback will be
returned to the client. Asynchronous script commands may not span
page loads. If an unload event is fired while waiting for a script
result, an error should be returned to the client. </p>
</dd>
<dt><code>executeScript(script, args = list(""))</code></dt><dd><p>Inject a snippet of JavaScript into the page for execution in the
context of the currently selected frame. The executed script is
assumed to be synchronous and the result of evaluating the script
is returned to the client. The script argument defines the script
to execute in the form of a function body. The value returned by
that function will be returned to the client. The function will be
invoked with the provided args array and the values may be
accessed via the arguments object in the order specified.
Arguments may be any JSON-primitive, array, or JSON object. JSON
objects that define a WebElement reference will be converted to
the corresponding DOM element. Likewise, any WebElements in the
script result will be returned to the client as WebElement JSON
objects.</p>
</dd>
<dt><code>findElement(
  using = c("xpath", "css selector", "id", "name", "tag name", "class name", "link text",
    "partial link text"),
  value
)</code></dt><dd><p>Search for an element on the page, starting from the document
root. The located element will be returned as an object of
webElement class.The inputs are:
</p>

<dl>
<dt><code>using</code>:</dt><dd><p>Locator scheme to use to search the
element, available schemes: Defaults to 'xpath'. Partial
string matching is accepted.
</p>

<dl>
<dt>&quot;class name&quot; :</dt><dd><p>Returns an element whose class name
contains the search value; compound class names are not
permitted.</p>
</dd>
<dt>&quot;css selector&quot; :</dt><dd><p>Returns an element matching a CSS
selector.</p>
</dd>
<dt>&quot;id&quot; :</dt><dd><p>Returns an element whose ID attribute
matches the search value.</p>
</dd>
<dt>&quot;name&quot; :</dt><dd><p>Returns an element whose NAME attribute
matches the search value.</p>
</dd>
<dt>&quot;link text&quot; :</dt><dd><p>Returns an anchor element whose
visible text matches the search value.</p>
</dd>
<dt>&quot;partial link text&quot; :</dt><dd><p>Returns an anchor element
whose visible text partially matches the search value.</p>
</dd>
<dt>&quot;tag name&quot; :</dt><dd><p>Returns an element whose tag name
matches the search value.</p>
</dd>
<dt>&quot;xpath&quot; :</dt><dd><p>Returns an element matching an XPath
expression.</p>
</dd>
</dl>

</dd>
<dt><code>value</code>:</dt><dd><p>The search target. See examples.</p>
</dd>
</dl>
</dd>
<dt><code>findElements(
  using = c("xpath", "css selector", "id", "name", "tag name", "class name", "link text",
    "partial link text"),
  value
)</code></dt><dd><p>Search for multiple elements on the page, starting from the
document root. The located elements will be returned as an list of
objects of class WebElement. The inputs are:
</p>

<dl>
<dt><code>using</code>:</dt><dd><p>Locator scheme to use to search the
element, available schemes: &quot;class name&quot;, &quot;css selector&quot;,
&quot;id&quot;, &quot;name&quot;, &quot;link text&quot;, &quot;partial link text&quot;,
&quot;tag name&quot;, &quot;xpath&quot; . Defaults to 'xpath'. Partial string
matching is accepted. See the findElement method for details</p>
</dd>
<dt><code>value</code>:</dt><dd><p>The search target. See examples.</p>
</dd>
</dl>
</dd>
<dt><code>getActiveElement()</code></dt><dd><p>Get the element on the page that currently has focus. The located
element will be returned as a WebElement id.</p>
</dd>
<dt><code>getAlertText()</code></dt><dd><p>Gets the text of the currently displayed JavaScript alert(),
confirm() or prompt() dialog.</p>
</dd>
<dt><code>getAllCookies()</code></dt><dd><p>Retrieve all cookies visible to the current page. Each cookie
will be returned as a list with the following name and value types:
</p>

<dl>
<dt><code>name</code>:</dt><dd><p>character</p>
</dd>
<dt><code>value</code>:</dt><dd><p>character</p>
</dd>
<dt><code>path</code>:</dt><dd><p>character</p>
</dd>
<dt><code>domain</code>:</dt><dd><p>character</p>
</dd>
<dt><code>secure</code>:</dt><dd><p>logical</p>
</dd>
</dl>
</dd>
<dt><code>getCurrentUrl()</code></dt><dd><p>Retrieve the url of the current page.</p>
</dd>
<dt><code>getCurrentWindowHandle()</code></dt><dd><p>Retrieve the current window handle.</p>
</dd>
<dt><code>getLogTypes()</code></dt><dd><p>Get available log types. Common log types include 'client' = Logs
from the client, 'driver' = Logs from the webdriver, 'browser' =
Logs from the browser, 'server' = Logs from the server. Other log
types, for instance, for performance logging may also be
available. phantomjs for example returns a har log type which is a
single-entry log, with the HAR (HTTP Archive) of the current
webpage, since the first load (it's cleared at every unload event)</p>
</dd>
<dt><code>getPageSource(...)</code></dt><dd><p>Get the current page source.</p>
</dd>
<dt><code>getSessions()</code></dt><dd><p>Returns a list of the currently active sessions. Each session
will be returned as a list containing amongst other items:
</p>

<dl>
<dt><code>id</code>:</dt><dd><p>The session ID</p>
</dd>
<dt><code>capabilities</code>:</dt><dd><p>An object describing session's
capabilities</p>
</dd>
</dl>
</dd>
<dt><code>getStatus()</code></dt><dd><p>Query the server's current status. All server implementations
should return two basic objects describing the server's current
platform and when the server was built.</p>
</dd>
<dt><code>getTitle(url)</code></dt><dd><p>Get the current page title.</p>
</dd>
<dt><code>getWindowHandles()</code></dt><dd><p>Retrieve the list of window handles used in the session.</p>
</dd>
<dt><code>getWindowPosition(windowId = "current")</code></dt><dd><p>Retrieve the window position. 'windowid' is optional (default is
'current' window). Can pass an appropriate 'handle'</p>
</dd>
<dt><code>getWindowSize(windowId = "current")</code></dt><dd><p>Retrieve the window size. 'windowid' is optional (default is
'current' window). Can pass an appropriate 'handle'</p>
</dd>
<dt><code>goBack()</code></dt><dd><p>Equivalent to hitting the back button on the browser.</p>
</dd>
<dt><code>goForward()</code></dt><dd><p>Equivalent to hitting the forward button on the browser.</p>
</dd>
<dt><code>log(type)</code></dt><dd><p>Get the log for a given log type. Log buffer is reset after each
request.
</p>

<dl>
<dt><code>type</code>:</dt><dd><p>The log type. Typically 'client', 'driver',
'browser', 'server'</p>
</dd>
</dl>
</dd>
<dt><code>maxWindowSize(winHand = "current")</code></dt><dd><p>Set the size of the browser window to maximum. The windows handle
is optional. If not specified the current window in focus is used.</p>
</dd>
<dt><code>mouseMoveToLocation(x = NA_integer_, y = NA_integer_, webElement = NULL)</code></dt><dd><p>Move the mouse by an offset of the specified element. If no
element is specified, the move is relative to the current mouse
cursor. If an element is provided but no offset, the mouse will be
moved to the center of the element. If the element is not visible,
it will be scrolled into view.</p>
</dd>
<dt><code>navigate(url)</code></dt><dd><p>Navigate to a given url.</p>
</dd>
<dt><code>open(silent = FALSE)</code></dt><dd><p>Send a request to the remote server to instantiate the browser.</p>
</dd>
<dt><code>phantomExecute(script, args = list())</code></dt><dd><p>This API allows you to send a string of JavaScript via 'script',
written for PhantomJS, and be interpreted within the context of a
WebDriver Page. In other words, for the given script then this
variable is initialized to be the current Page. See
<a href="https://github.com/ariya/phantomjs/wiki/API-Reference-WebPage">https://github.com/ariya/phantomjs/wiki/API-Reference-WebPage</a>
and the example in this help file. NOTE: Calling the PhantomJS API
currently only works when PhantomJS is driven directly via
<code><a href="grDevices.html#topic+phantom">phantom</a></code></p>
</dd>
<dt><code>quit()</code></dt><dd><p>Delete the session &amp; close open browsers.</p>
</dd>
<dt><code>refresh()</code></dt><dd><p>Reload the current page.</p>
</dd>
<dt><code>screenshot(display = FALSE, useViewer = TRUE, file = NULL)</code></dt><dd><p>Take a screenshot of the current page. The screenshot is returned
as a base64 encoded PNG. If display is TRUE the screenshot is
displayed locally. If useViewer is TRUE and RStudio is in use the
screenshot is displayed in the RStudio viewer panel. If file is
not NULL and display = FALSE the screenshot is written to the file
denoted by file.</p>
</dd>
<dt><code>sendKeysToActiveElement(sendKeys)</code></dt><dd><p>Send a sequence of key strokes to the active element. This
command is similar to the send keys command in every aspect except
the implicit termination: The modifiers are not released at the
end of the call. Rather, the state of the modifier keys is kept
between calls, so mouse interactions can be performed while
modifier keys are depressed. The key strokes are sent as a list.
Plain text is enter as an unnamed element of the list. Keyboard
entries are defined in 'selKeys' and should be listed with name
'key'. See the examples.</p>
</dd>
<dt><code>sendKeysToAlert(sendKeys)</code></dt><dd><p>Sends keystrokes to a JavaScript prompt() or alert() dialog.
The key strokes are sent as a list. Plain text is enter as an
unnamed element of the list. Keyboard entries are defined in
'selKeys' and should be listed with name 'key'. See the examples.</p>
</dd>
<dt><code>setAsyncScriptTimeout(milliseconds = 10000)</code></dt><dd><p>Set the amount of time, in milliseconds, that asynchronous
scripts executed by execute_async_script() are permitted to run
before they are aborted and a |Timeout| error is returned to the
client.</p>
</dd>
<dt><code>setImplicitWaitTimeout(milliseconds = 10000)</code></dt><dd><p>Set the amount of time the driver should wait when searching for
elements. When searching for a single element, the driver will poll
the page until an element is found or the timeout expires,
whichever occurs first. When searching for multiple elements, the
driver should poll the page until at least one element is found or
the timeout expires, at which point it will return an empty list.
If this method is never called, the driver will default to an
implicit wait of 0ms.</p>
</dd>
<dt><code>setTimeout(type = "page load", milliseconds = 10000)</code></dt><dd><p>Configure the amount of time that a particular type of operation
can execute for before they are aborted and a |Timeout| error is
returned to the client.
</p>

<dl>
<dt><code>type</code>:</dt><dd><p>The type of operation to set the timeout
for. Valid values are: &quot;script&quot; for script timeouts,
&quot;implicit&quot; for modifying the implicit wait timeout and
&quot;page load&quot; for setting a page load timeout. Defaults to
&quot;page load&quot; </p>
</dd>
<dt><code>milliseconds</code>:</dt><dd><p>The amount of time, in
milliseconds, that time-limited commands are permitted to run.
Defaults to 10000 milliseconds. </p>
</dd>
</dl>
</dd>
<dt><code>setWindowPosition(x, y, winHand = "current")</code></dt><dd><p>Set the position (on screen) where you want your browser to be
displayed. The windows handle is optional. If not specified the
current window in focus is used.</p>
</dd>
<dt><code>setWindowSize(width, height, winHand = "current")</code></dt><dd><p>Set the size of the browser window. The windows handle is
optional. If not specified the current window in focus is used.</p>
</dd>
<dt><code>switchToFrame(Id)</code></dt><dd><p>Change focus to another frame on the page. Id can be
string|number|null|WebElement Object. If the Id is null, the
server should switch to the page's default content.</p>
</dd>
<dt><code>switchToWindow(windowId)</code></dt><dd><p>Change focus to another window. The window to change focus to may
be specified by its server assigned window handle, or by the value
of its name attribute.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# use default server initialisation values
remDr &lt;- remoteDriver$new()

# send request to server to initialise session
remDr$open()

# navigate to R home page
remDr$navigate("http://www.r-project.org")

# navigate to www.bbc.co.uk notice the need for http://
remDr$navigate("http://www.bbc.co.uk")

# go backwards and forwards
remDr$goBack()

remDr$goForward()

remDr$goBack()

# Examine the page source
frontPage &lt;- remDr$getPageSource()

# The R homepage contains frames
webElem &lt;- remDr$findElements(value = "//frame")
sapply(webElem, function(x) {
  x$getElementAttribute("name")
})

# The homepage contains 3 frames: logo, contents and banner
# switch to the `contents` frame
webElem &lt;- remDr$findElement(using = "name", value = "contents")
remDr$switchToFrame(webElem$elementId)

# re-examine the page source

contentPage &lt;- remDr$getPageSource()
identical(contentPage, frontPage) # false we hope!!

# Find the link for the search page on R homepage. Use xpath as default.
webElem &lt;- remDr$findElement(value = '//a[@href = "search.html"]')
webElem$getElementAttribute("href")
# http://www.r-project.org/search.html

# click the search link
webElem$clickElement()

# FILL OUT A GOOGLE SEARCH FORM
remDr$navigate("http://www.google.com")

# show different methods of accessing DOM components

webElem1 &lt;- remDr$findElement(using = "name", value = "q")
webElem2 &lt;- remDr$findElement(
  using = "id",
  value = webElem1$getElementAttribute("id")[[1]]
)
webElem3 &lt;- remDr$findElement(
  using = "xpath",
  value = '//input[@name = "q"]'
)

# Enter some text in the search box

webElem1$sendKeysToElement(list("RSelenium was here"))

# clear the text previously entered

webElem1$clearElement()

# show an example of sending a key press
webElem1$sendKeysToElement(list("R", key = "enter"))

# Collate the results for the `R` search
googLinkText &lt;- remDr$findElements(value = "//h3[@class = 'r']")
linkHeading &lt;- sapply(googLinkText, function(x) x$getElementText())
googLinkDesc &lt;- remDr$findElements(value = "//div[@class = 's']")
linkDescription &lt;- sapply(googLinkDesc, function(x) x$getElementText())
googLinkHref &lt;- remDr$findElements(value = "//h3[@class = 'r']/a")
linkHref &lt;- sapply(
  googLinkHref,
  function(x) x$getElementAttribute("href")
)

data.frame(
  heading = linkHeading,
  description = linkDescription, href = linkHref
)

# Example of javascript call
remDr$executeScript("return arguments[0] + arguments[1];", args = 1:2)
# Example of javascript async call
jsscript &lt;-
  "arguments[arguments.length - 1](arguments[0] + arguments[1]);"
remDr$executeAsyncScript(jsscript, args = 1:2)

# EXAMPLE INJECTING INTO PHANTOMJS using phantomExecute
require(RSelenium)
pJS &lt;- wdman::phantomjs(port = 4932L)
remDr &lt;- remoteDriver(browserName = "phantomjs", port = 4932L)
remDr$open(silent = TRUE)
remDr$navigate("http://ariya.github.com/js/random/")
# returns a set of random numbers
remDr$findElement("id", "numbers")$getElementText()[[1]]
#  # now try injecting a new Math,random function
result &lt;- remDr$phantomExecute("var page = this;
                               page.onInitialized = function () {
                               page.evaluate(function () {
                               Math.random = function() {return 42/100}
                               })
                               }", list())
remDr$navigate("http://ariya.github.com/js/random/")
# Math.random returns our custom function
remDr$findElement("id", "numbers")$getElementText()[[1]]
remDr$close()
pJS$stop()

## End(Not run)

</code></pre>

<hr>
<h2 id='rsDriver'>Start a selenium server and browser</h2><span id='topic+rsDriver'></span>

<h3>Description</h3>

<p>Start a selenium server and browser
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsDriver(
  port = 4567L,
  browser = c("chrome", "firefox", "phantomjs", "internet explorer"),
  version = "latest",
  chromever = "latest",
  geckover = "latest",
  iedrver = NULL,
  phantomver = "2.1.1",
  verbose = TRUE,
  check = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsDriver_+3A_port">port</code></td>
<td>
<p>Port to run on</p>
</td></tr>
<tr><td><code id="rsDriver_+3A_browser">browser</code></td>
<td>
<p>Which browser to start</p>
</td></tr>
<tr><td><code id="rsDriver_+3A_version">version</code></td>
<td>
<p>what version of Selenium Server to run. Default = &quot;latest&quot;
which runs the most recent version. To see other version currently
sourced run binman::list_versions(&quot;seleniumserver&quot;)</p>
</td></tr>
<tr><td><code id="rsDriver_+3A_chromever">chromever</code></td>
<td>
<p>what version of Chrome driver to run. Default = &quot;latest&quot;
which runs the most recent version. To see other version currently
sourced run binman::list_versions(&quot;chromedriver&quot;), A value of NULL
excludes adding the chrome browser to Selenium Server.</p>
</td></tr>
<tr><td><code id="rsDriver_+3A_geckover">geckover</code></td>
<td>
<p>what version of Gecko driver to run. Default = &quot;latest&quot;
which runs the most recent version. To see other version currently
sourced run binman::list_versions(&quot;geckodriver&quot;), A value of NULL
excludes adding the firefox browser to Selenium Server.</p>
</td></tr>
<tr><td><code id="rsDriver_+3A_iedrver">iedrver</code></td>
<td>
<p>what version of IEDriverServer to run. Default = &quot;latest&quot;
which runs the most recent version. To see other version currently
sourced run binman::list_versions(&quot;iedriverserver&quot;), A value of NULL
excludes adding the internet explorer browser to Selenium Server.
NOTE this functionality is Windows OS only.</p>
</td></tr>
<tr><td><code id="rsDriver_+3A_phantomver">phantomver</code></td>
<td>
<p>what version of PhantomJS to run. Default = &quot;2.1.1&quot;
which runs the most recent stable version. To see other version currently
sourced run binman::list_versions(&quot;phantomjs&quot;), A value of NULL
excludes adding the PhantomJS headless browser to Selenium Server.</p>
</td></tr>
<tr><td><code id="rsDriver_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, include status messages (if any)</p>
</td></tr>
<tr><td><code id="rsDriver_+3A_check">check</code></td>
<td>
<p>If TRUE check the versions of selenium available and the
versions of associated drivers (chromever, geckover, phantomver,
iedrver). If new versions are available they will be downloaded.</p>
</td></tr>
<tr><td><code id="rsDriver_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="#topic+remoteDriver">remoteDriver</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around <code><a href="wdman.html#topic+selenium">selenium</a></code>.
It provides a &quot;shim&quot; for the current issue running firefox on
Windows. For a more detailed set of functions for running binaries
relating to the Selenium/webdriver project see the
<code><a href="wdman.html#topic+wdman">wdman</a></code> package. Both the client and server
are closed using a registered finalizer.
</p>


<h3>Value</h3>

<p>A list containing a server and a client. The server is the object
returned by <code><a href="wdman.html#topic+selenium">selenium</a></code> and the client is an object of class
<code><a href="#topic+remoteDriver">remoteDriver</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# start a chrome browser
rD &lt;- rsDriver()
remDr &lt;- rD[["client"]]
remDr$navigate("http://www.google.com/ncr")
remDr$navigate("http://www.bbc.com")
remDr$close()
# stop the selenium server
rD[["server"]]$stop()

# if user forgets to stop server it will be garbage collected.
rD &lt;- rsDriver()
rm(rD)
gc(rD)

## End(Not run)
</code></pre>

<hr>
<h2 id='selKeys'>Selenium key mappings</h2><span id='topic+selKeys'></span>

<h3>Description</h3>

<p>This data set contains a list of selenium key mappings.
selKeys is used when a sendKeys variable is needed.
sendKeys is defined as a list.
If an entry is needed from selKeys it is denoted by key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selKeys
</code></pre>


<h3>Format</h3>

<p>A named list. The names are the descriptions of the keys. The
values are the &quot;UTF-8&quot; character representations.
</p>


<h3>Source</h3>

<p>https://www.selenium.dev/documentation/legacy/json_wire_protocol/#sessionsessionidelementidvalue
</p>

<hr>
<h2 id='webElement-class'>CLASS webElement</h2><span id='topic+webElement-class'></span><span id='topic+webElement'></span>

<h3>Description</h3>

<p>Selenium Webdriver represents all the HTML elements as WebElements.
This class provides a mechanism to represent them as objects &amp;
perform various actions on the related elements. Typically, the
findElement method in <code><a href="#topic+remoteDriver">remoteDriver</a></code> returns an object
of class webElement.
</p>


<h3>Details</h3>

<p>webElement is a generator object. To define a new webElement class
method 'new' is called.  When a webElement class is created an
elementId should be given. Each webElement inherits from a
remoteDriver. webElement is not usually called by the end-user.
</p>


<h3>Fields</h3>


<dl>
<dt><code>elementId</code></dt><dd><p>Object of class <code>"character"</code>, giving a character
representation of the element id.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>clearElement()</code></dt><dd><p>Clear a TEXTAREA or text INPUT element's value.</p>
</dd>
<dt><code>clickElement()</code></dt><dd><p>Click the element.</p>
</dd>
<dt><code>compareElements(otherElem)</code></dt><dd><p>Test if the current webElement and an other web element refer to
the same DOM element.</p>
</dd>
<dt><code>describeElement()</code></dt><dd><p>Describe the identified element.</p>
</dd>
<dt><code>findChildElement(
  using = c("xpath", "css selector", "id", "name", "tag name", "class name", "link text",
    "partial link text"),
  value
)</code></dt><dd><p>Search for an element on the page, starting from the node defined
by the parent webElement. The located element will be returned as
an object of webElement class.
The inputs are:
</p>

<dl>
<dt><code>using</code>:</dt><dd><p>Locator scheme to use to search the
element, available schemes: &quot;class name&quot;, &quot;css selector&quot;,
&quot;id&quot;, &quot;name&quot;, &quot;link text&quot;, &quot;partial link text&quot;,
&quot;tag name&quot;, &quot;xpath&quot; . Defaults to 'xpath'. Partial string
matching is accepted.</p>
</dd>
<dt><code>value</code>:</dt><dd><p>The search target. See examples.</p>
</dd>
</dl>
</dd>
<dt><code>findChildElements(
  using = c("xpath", "css selector", "id", "name", "tag name", "class name", "link text",
    "partial link text"),
  value
)</code></dt><dd><p>Search for multiple elements on the page, starting from the node
defined by the parent webElement. The located elements will be
returned as an list of objects of class WebElement.
The inputs are:
</p>

<dl>
<dt><code>using</code>:</dt><dd><p>Locator scheme to use to search the
element, available schemes: &quot;class name&quot;, &quot;css selector&quot;,
&quot;id&quot;, &quot;name&quot;, &quot;link text&quot;, &quot;partial link text&quot;,
&quot;tag name&quot;, &quot;xpath&quot; . Defaults to 'xpath'.
Partial string matching is accepted.</p>
</dd>
<dt><code>value</code>:</dt><dd><p>The search target. See examples.</p>
</dd>
</dl>
</dd>
<dt><code>getElementAttribute(attrName)</code></dt><dd><p>Get the value of an element's attribute. See examples.</p>
</dd>
<dt><code>getElementLocation()</code></dt><dd><p>Determine an element's location on the page. The point (0, 0)
refers to the upper-left corner of the page.</p>
</dd>
<dt><code>getElementLocationInView()</code></dt><dd><p>Determine an element's location on the screen once it has been
scrolled into view.
Note: This is considered an internal command and should only be
used to determine an element's location for correctly generating
native events.</p>
</dd>
<dt><code>getElementSize()</code></dt><dd><p>Determine an element's size in pixels. The size will be returned
with width and height properties.</p>
</dd>
<dt><code>getElementTagName()</code></dt><dd><p>Query for an element's tag name.</p>
</dd>
<dt><code>getElementText()</code></dt><dd><p>Get the innerText of the element.</p>
</dd>
<dt><code>getElementValueOfCssProperty(propName)</code></dt><dd><p>Query the value of an element's computed CSS property. The CSS
property to query should be specified using the CSS property name,
not the JavaScript property name (e.g. background-color instead of
backgroundColor).</p>
</dd>
<dt><code>highlightElement(wait = 75/1000)</code></dt><dd><p>Utility function to highlight current Element. Wait denotes the
time in seconds between style changes on element.</p>
</dd>
<dt><code>isElementDisplayed()</code></dt><dd><p>Determine if an element is currently displayed.</p>
</dd>
<dt><code>isElementEnabled()</code></dt><dd><p>Determine if an element is currently enabled. Obviously to enable
an element just preform a click on it.</p>
</dd>
<dt><code>isElementSelected()</code></dt><dd><p>Determine if an OPTION element, or an INPUT element of type
checkbox or radiobutton is currently selected.</p>
</dd>
<dt><code>selectTag()</code></dt><dd><p>Utility function to return options from a select DOM node. The
option nodes are returned as webElements. The option text and the
value of the option attribute 'value' and whether the option is
selected are returned also. If this
method is called on a webElement that is not a select DOM node an
error will result.</p>
</dd>
<dt><code>sendKeysToElement(sendKeys)</code></dt><dd><p>Send a sequence of key strokes to an element. The key strokes are
sent as a list. Plain text is enter as an unnamed element of the
list. Keyboard entries are defined in 'selKeys' and should be
listed with name 'key'. See the examples.</p>
</dd>
<dt><code>setElementAttribute(attributeName, value)</code></dt><dd><p>Utility function to set an elements attributes.</p>
</dd>
<dt><code>submitElement()</code></dt><dd><p>Submit a FORM element. The submit command may also be applied to
any element that is a descendant of a FORM element.</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
