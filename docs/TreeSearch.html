<!DOCTYPE html><html><head><title>Help for package TreeSearch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TreeSearch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.CombineResults'><p>Combine two edge matrices</p></a></li>
<li><a href='#.GapHandler'><p>Translate a gap treatment into a string in the format expected by Morphy</p></a></li>
<li><a href='#.NonDuplicateRoot'><p>Non-duplicate root</p></a></li>
<li><a href='#.UniqueExceptHits'><p>Unique trees (ignoring &quot;hits&quot; attribute)</p></a></li>
<li><a href='#AdditionTree'><p>Addition tree</p></a></li>
<li><a href='#AllSPR'><p>All SPR trees</p></a></li>
<li><a href='#Carter1'><p>Number of trees with <em>m</em> steps</p></a></li>
<li><a href='#CharacterLength'><p>Character length</p></a></li>
<li><a href='#ClusterStrings'><p>Cluster similar strings</p></a></li>
<li><a href='#ConcordantInformation'><p>Evaluate the concordance of information between a tree and a dataset</p></a></li>
<li><a href='#congreveLamsdellMatrices'><p>100 simulated data matrices</p></a></li>
<li><a href='#Consistency'><p>Consistency / retention &quot;indices&quot;</p></a></li>
<li><a href='#cSPR'><p><code>cSPR()</code> expects a tree rooted on a single tip.</p></a></li>
<li><a href='#DoubleNNI'><p>Double NNI</p></a></li>
<li><a href='#EdgeListSearch'><p>Search for most parsimonious trees</p></a></li>
<li><a href='#GapHandler'><p>Read how a Morphy Object handles the inapplicable token</p></a></li>
<li><a href='#inapplicable.datasets'><p>Thirty datasets with inapplicable data</p></a></li>
<li><a href='#is.morphyPtr'><p>Is an object a valid Morphy object?</p></a></li>
<li><a href='#IWScore'><p>Calculate the parsimony score of a tree given a dataset</p></a></li>
<li><a href='#Jackknife'><p>Jackknife resampling</p></a></li>
<li><a href='#JackLabels'><p>Label nodes with jackknife support values</p></a></li>
<li><a href='#LengthAdded'><p>Contribution of character to leaf instability</p></a></li>
<li><a href='#MaximizeParsimony'><p>Find most parsimonious trees</p></a></li>
<li><a href='#MinimumLength'><p>Minimum and Maximum lengths possible for a character</p></a></li>
<li><a href='#MorphyBootstrap'><p>Parsimony Ratchet</p></a></li>
<li><a href='#MorphyErrorCheck'><p>Check for error whilst modifying Morphy object</p></a></li>
<li><a href='#MorphyTreeLength'><p>Calculate parsimony score from Morphy object</p></a></li>
<li><a href='#MorphyWeights'><p>Set and get the character weightings associated with a Morphy object.</p></a></li>
<li><a href='#mpl_apply_tipdata'><p>Commits parameters prior to nodal set calculations.</p></a></li>
<li><a href='#mpl_attach_rawdata'><p>Attach raw character state data (i.e. tip data).</p></a></li>
<li><a href='#mpl_attach_symbols'><p>Attach a caller-specified list of symbols.</p></a></li>
<li><a href='#mpl_delete_Morphy'><p>Destroys an instance of a Morphy object.</p></a></li>
<li><a href='#mpl_delete_rawdata'><p>Deletes the caller-input data.</p></a></li>
<li><a href='#mpl_first_down_recon'><p>Reconstructs the first (downpass) nodal reconstructions</p></a></li>
<li><a href='#mpl_first_up_recon'><p>Reconstructs the second (uppass) nodal reconstructions.</p></a></li>
<li><a href='#mpl_get_charac_weight'><p>Retrieve the weight of a character in the dataset</p></a></li>
<li><a href='#mpl_get_gaphandl'><p>Get / set gap handler from a Morphy object.</p></a></li>
<li><a href='#mpl_get_num_charac'><p>Retrieve the number of character (columns) in the dataset.</p></a></li>
<li><a href='#mpl_get_num_internal_nodes'><p>Gets the number of internal nodal reconstruction sets being used by</p>
MorphyLib.</a></li>
<li><a href='#mpl_get_numtaxa'><p>Retrieve the number of taxa (rows) in the dataset.</p></a></li>
<li><a href='#mpl_get_symbols'><p>Retrieves the current list of symbols.</p></a></li>
<li><a href='#mpl_init_Morphy'><p>Sets up the dimensions of the dataset.</p></a></li>
<li><a href='#mpl_new_Morphy'><p>Creates a new instance of a Morphy object</p></a></li>
<li><a href='#mpl_second_down_recon'><p>Performs the second nodal reconstructions for characters with</p>
inapplicability.</a></li>
<li><a href='#mpl_second_up_recon'><p>Finalises the ancestral state reconstructions for characters with</p>
inapplicable values.</a></li>
<li><a href='#mpl_set_charac_weight'><p>Set the weight of a character in the dataset</p></a></li>
<li><a href='#mpl_set_num_internal_nodes'><p>Sets the number of internal nodes in the dataset</p></a></li>
<li><a href='#mpl_set_parsim_t'><p>Sets a character's parsimony function type</p></a></li>
<li><a href='#mpl_translate_error'><p>Converts a numeric error code to human-readable format</p></a></li>
<li><a href='#mpl_update_lower_root'><p>Updates the nodal sets for a lower (&quot;dummy&quot;) root node</p></a></li>
<li><a href='#mpl_update_tip'><p>Initial update of tip values following uppass reconstruction.</p></a></li>
<li><a href='#NNI'><p>Nearest neighbour interchange (NNI)</p></a></li>
<li><a href='#PhyDat2Morphy'><p>Initialize a Morphy object from a <code>phyDat</code> object</p></a></li>
<li><a href='#PlotCharacter'><p>Plot the distribution of a character on a tree</p></a></li>
<li><a href='#PrepareDataProfile'><p>Prepare data for Profile Parsimony</p></a></li>
<li><a href='#profiles'><p>Empirically counted profiles for small trees</p></a></li>
<li><a href='#QuartetResolution'><p>Relationship between four taxa</p></a></li>
<li><a href='#RandomMorphyTree'><p>Random postorder tree</p></a></li>
<li><a href='#RandomTreeScore'><p>Parsimony score of random postorder tree</p></a></li>
<li><a href='#RearrangeEdges'><p>Rearrange edges of a phylogenetic tree</p></a></li>
<li><a href='#referenceTree'><p>Tree topology for matrix simulation</p></a></li>
<li><a href='#SingleCharMorphy'><p>Morphy object from single character</p></a></li>
<li><a href='#SiteConcordance'><p>Calculate site concordance factor</p></a></li>
<li><a href='#SPR'><p>Subtree pruning and rearrangement (SPR)</p></a></li>
<li><a href='#SPRWarning'><p>TBR Warning</p>
Print a warning and return given tree</a></li>
<li><a href='#StepInformation'><p>Information content of a character known to contain <em>e</em> steps</p></a></li>
<li><a href='#StopUnlessBifurcating'><p>Check that all nodes in a tree are bifurcating.</p></a></li>
<li><a href='#Suboptimality'><p>Tree suboptimality</p></a></li>
<li><a href='#SuccessiveApproximations'><p>Tree search using successive approximations</p></a></li>
<li><a href='#summary.morphyPtr'><p>Details the attributes of a morphy object</p></a></li>
<li><a href='#TaxonInfluence'><p>Rank taxa by their influence on phylogenetic results</p></a></li>
<li><a href='#TBR'><p>Tree bisection and reconnection (TBR)</p></a></li>
<li><a href='#UnloadMorphy'><p>Destroy a Morphy object</p></a></li>
<li><a href='#WhenFirstHit'><p>When was a tree topology first hit?</p></a></li>
<li><a href='#WithOneExtraStep'><p>Number of trees with one extra step</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Phylogenetic Analysis with Discrete Character Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>Incorporates C/C++ code from Morphy Phylogenetic Library by
Martin Brazeau &lt;https://github.com/mbrazeau/MorphyLib&gt; (GPL3)</td>
</tr>
<tr>
<td>Description:</td>
<td>Reconstruct phylogenetic trees from discrete data.
  Inapplicable character states are handled using the algorithm of Brazeau,
  Guillerme and Smith (2019) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyy083">doi:10.1093/sysbio/syy083</a>&gt; with the "Morphy"
  library, under equal or implied step weights.
  Contains a "shiny" user interface for interactive tree search and exploration
  of results, including character visualization, rogue taxon detection,
  tree space mapping, and cluster consensus trees (Smith 2022a, b)
  &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyab099">doi:10.1093/sysbio/syab099</a>&gt;, &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyab100">doi:10.1093/sysbio/syab100</a>&gt;.
  Profile Parsimony (Faith and Trueman, 2001) &lt;<a href="https://doi.org/10.1080%2F10635150118627">doi:10.1080/10635150118627</a>&gt;, 
  Successive Approximations (Farris, 1969) &lt;<a href="https://doi.org/10.2307%2F2412182">doi:10.2307/2412182</a>&gt;
  and custom optimality criteria are implemented.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ms609.github.io/TreeSearch/">https://ms609.github.io/TreeSearch/</a> (doc),
<a href="https://github.com/ms609/TreeSearch/">https://github.com/ms609/TreeSearch/</a> (devel)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ms609/TreeSearch/issues/">https://github.com/ms609/TreeSearch/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 5.6), cli (&ge; 3.0), cluster, fastmatch (&ge; 1.1.3), fs,
future, PlotTools, promises, protoclust, Rcpp, Rdpack (&ge; 0.7),
Rogue (&gt; 2.0.0), shiny (&ge; 1.6.0), shinyjs, stats, TreeDist (&ge;
2.6.3), TreeTools (&ge; 1.10.0),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, phangorn (&ge; 2.2.1), Quartet, readxl, rmarkdown,
shinytest, spelling, testthat, vdiffr (&ge; 1.0.0),</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>callr, pkgbuild, rcmdcheck,</td>
</tr>
<tr>
<td>Config/Needs/coverage:</td>
<td>covr, spelling</td>
</tr>
<tr>
<td>Config/Needs/memcheck:</td>
<td>devtools</td>
</tr>
<tr>
<td>Config/Needs/metadata:</td>
<td>codemeta</td>
</tr>
<tr>
<td>Config/Needs/revdeps:</td>
<td>revdepcheck</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>curl, igraph, pkgdown,</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, TreeTools,</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-03 14:08:20 UTC; pjjg18</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin R. Smith <a href="https://orcid.org/0000-0001-5660-1727"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Martin Brazeau <a href="https://orcid.org/0000-0002-0650-1282"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin R. Smith &lt;martin.smith@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 16:53:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='.CombineResults'>Combine two edge matrices</h2><span id='topic+.CombineResults'></span><span id='topic+.ReplaceResults'></span>

<h3>Description</h3>

<p>Combine two edge matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.CombineResults(x, y, stage)

.ReplaceResults(old, new, stage)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".CombineResults_+3A_x">x</code>, <code id=".CombineResults_+3A_y">y</code></td>
<td>
<p>3D arrays, each slice containing an edge matrix from a tree
of class <code>phylo</code>.  <code>x</code> should not contain duplicates.</p>
</td></tr>
<tr><td><code id=".CombineResults_+3A_stage">stage</code></td>
<td>
<p>Integer specifying element of <code>firstHit</code> in which new hits
should be recorded.</p>
</td></tr>
<tr><td><code id=".CombineResults_+3A_old">old</code></td>
<td>
<p>old array of edge matrices with <code>firstHit</code> attribute.</p>
</td></tr>
<tr><td><code id=".CombineResults_+3A_new">new</code></td>
<td>
<p>new array of edge matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single 3D array containing each unique edge matrix from (<code>x</code> and)
<code>y</code>, with a <code>firstHit</code> attribute as documented in <code><a href="#topic+MaximizeParsimony">MaximizeParsimony()</a></code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='.GapHandler'>Translate a gap treatment into a string in the format expected by Morphy</h2><span id='topic+.GapHandler'></span>

<h3>Description</h3>

<p>Translate a gap treatment into a string in the format expected by Morphy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.GapHandler(gap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".GapHandler_+3A_gap">gap</code></td>
<td>
<p>Character vector: how should gaps be handled?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string that can be translated into a gap handling strategy
by Morphy.
</p>

<hr>
<h2 id='.NonDuplicateRoot'>Non-duplicate root</h2><span id='topic+.NonDuplicateRoot'></span>

<h3>Description</h3>

<p>Identify, for each edge, whether it denotes a different partition from
the root edge.
The first edge of the input tree must be a root edge; this can be
accomplished using <code>Preorder()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.NonDuplicateRoot(parent, child, nEdge = length(parent))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".NonDuplicateRoot_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
<tr><td><code id=".NonDuplicateRoot_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td></tr>
<tr><td><code id=".NonDuplicateRoot_+3A_nedge">nEdge</code></td>
<td>
<p>(optional) integer specifying the number of edges of a tree of
class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>dim(tree$edge)[1]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a copy of a deprecated ancestor in TreeTools; see
<a href="https://github.com/ms609/TreeTools/issues/32">#32</a>.
</p>


<h3>Value</h3>

<p><code>.NonDuplicateRoot()</code> returns a logical vector of length <code>nEdge</code>,
specifying <code>TRUE</code> unless an edge identifies the same partition as
the root edge.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- TreeTools::Preorder(TreeTools::BalancedTree(8))
edge &lt;- tree$edge
parent &lt;- edge[, 1]
child &lt;- edge[, 2]

which(!.NonDuplicateRoot(parent, child))
</code></pre>

<hr>
<h2 id='.UniqueExceptHits'>Unique trees (ignoring &quot;hits&quot; attribute)</h2><span id='topic+.UniqueExceptHits'></span>

<h3>Description</h3>

<p>Unique trees (ignoring &quot;hits&quot; attribute)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.UniqueExceptHits(trees)
</code></pre>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>

<hr>
<h2 id='AdditionTree'>Addition tree</h2><span id='topic+AdditionTree'></span>

<h3>Description</h3>

<p>Generates a starting tree by adding each taxon in turn to the most
parsimonious location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdditionTree(dataset, concavity = Inf, constraint, sequence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdditionTree_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="AdditionTree_+3A_concavity">concavity</code></td>
<td>
<p>Numeric specifying concavity constant for implied step
weighting.
The most appropriate value will depend on the dataset, but values around
10&ndash;15 often perform well (Goloboff et al. 2018; Smith 2019).
The character string &quot;profile&quot; employs an approximation of profile parsimony
(Faith and Trueman 2001).
Set as <code>Inf</code> for equal step weights, which underperforms step weighting
approaches
(Goloboff et al. 2008; Goloboff et al. 2018; Goloboff and Arias 2019; Smith 2019).</p>
</td></tr>
<tr><td><code id="AdditionTree_+3A_constraint">constraint</code></td>
<td>
<p>Either an object of class <code>phyDat</code>, in which case
returned trees will be perfectly compatible with each character in
<code>constraint</code>; or a tree of class <code>phylo</code>, all of whose nodes will occur
in any output tree.
See <code><a href="TreeTools.html#topic+ImposeConstraint">ImposeConstraint()</a></code> and
<a href="https://ms609.github.io/TreeSearch/articles/tree-search.html">vignette</a>
for further examples.</p>
</td></tr>
<tr><td><code id="AdditionTree_+3A_sequence">sequence</code></td>
<td>
<p>Character or numeric vector listing sequence in which to add
taxa. Randomized if not provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>AdditionTree()</code> returns a tree of class <code>phylo</code>, rooted on
<code>sequence[1]</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Impose a constraint: <a href="https://ms609.github.io/TreeTools/reference/ImposeConstraint"><code>TreeTools::ImposeConstraint()</code></a>
</p>
<p>Neighbour-joining trees: <a href="https://ms609.github.io/TreeTools/reference/NJTree.html"><code>TreeTools::NJTree()</code></a>;
<a href="https://ms609.github.io/TreeTools/reference/ConstrainedNJ"><code>TreeTools::ConstrainedNJ()</code></a>
</p>
<p>Other tree generation functions: 
<code><a href="#topic+RandomMorphyTree">RandomMorphyTree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("inapplicable.phyData", package = "TreeSearch")
AdditionTree(inapplicable.phyData[["Longrich2010"]], concavity = 10)
</code></pre>

<hr>
<h2 id='AllSPR'>All SPR trees</h2><span id='topic+AllSPR'></span>

<h3>Description</h3>

<p>All SPR trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AllSPR(parent, child, nEdge, notDuplicateRoot, edgeToBreak)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AllSPR_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
<tr><td><code id="AllSPR_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td></tr>
<tr><td><code id="AllSPR_+3A_nedge">nEdge</code></td>
<td>
<p>integer specifying the number of edges of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>dim(tree$edge)[1]</code></p>
</td></tr>
<tr><td><code id="AllSPR_+3A_notduplicateroot">notDuplicateRoot</code></td>
<td>
<p>logical vector of length <code>nEdge</code>, specifying for each
edge whether it is the second edge leading to the root (in which case
its breaking will be equivalent to breaking the other root edge...
except insofar as it moves the position of the root.)</p>
</td></tr>
<tr><td><code id="AllSPR_+3A_edgetobreak">edgeToBreak</code></td>
<td>
<p>(optional) integer specifying the index of an edge to bisect/prune,
generated randomly if not specified.
Alternatively, set to <code>-1</code> to return a complete list
of all trees one step from the input tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>AllSPR()</code> returns a list of edge matrices for all trees one SPR
rearrangement from the starting tree
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>

<hr>
<h2 id='Carter1'>Number of trees with <em>m</em> steps</h2><span id='topic+Carter1'></span><span id='topic+Log2Carter1'></span><span id='topic+LogCarter1'></span>

<h3>Description</h3>

<p>Calculate the number of trees in which Fitch parsimony will reconstruct
<em>m</em> steps, where <em>a</em> leaves are labelled with one state, and <em>b</em> leaves are
labelled with a second state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Carter1(m, a, b)

Log2Carter1(m, a, b)

LogCarter1(m, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Carter1_+3A_m">m</code></td>
<td>
<p>Number of steps.</p>
</td></tr>
<tr><td><code id="Carter1_+3A_a">a</code>, <code id="Carter1_+3A_b">b</code></td>
<td>
<p>Number of leaves labelled <code>0</code> and <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implementation of theorem 1 from Carter et al. (1990)
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Carter M, Hendy M, Penny D, Székely LA, Wormald NC (1990).
&ldquo;On the distribution of lengths of evolutionary trees.&rdquo;
<em>SIAM Journal on Discrete Mathematics</em>, <b>3</b>(1), 38&ndash;47.
<a href="https://doi.org/10.1137/0403005">doi:10.1137/0403005</a>.
</p>
<p>See also:
</p>
<p>Steel MA (1993).
&ldquo;Distributions on bicoloured binary trees arising from the principle of parsimony.&rdquo;
<em>Discrete Applied Mathematics</em>, <b>41</b>(3), 245&ndash;261.
<a href="https://doi.org/10.1016/0166-218X%2890%2990058-K">doi:10.1016/0166-218X(90)90058-K</a>.
</p>
<p>Steel M, Charleston M (1995).
&ldquo;Five surprising properties of parsimoniously colored trees.&rdquo;
<em>Bulletin of Mathematical Biology</em>, <b>57</b>(2), 367&ndash;375.
<a href="https://doi.org/10.1016/0092-8240%2894%2900051-D">doi:10.1016/0092-8240(94)00051-D</a>.
</p>
<p>(Steel M, Goldstein L, Waterman MS (1996).
&ldquo;A central limit theorem for the parsimony length of trees.&rdquo;
<em>Advances in Applied Probability</em>, <b>28</b>(4), 1051&ndash;1071.
<a href="https://doi.org/10.2307/1428164">doi:10.2307/1428164</a>.)
</p>


<h3>See Also</h3>

<p>Other profile parsimony functions: 
<code><a href="#topic+PrepareDataProfile">PrepareDataProfile</a>()</code>,
<code><a href="#topic+StepInformation">StepInformation</a>()</code>,
<code><a href="#topic+WithOneExtraStep">WithOneExtraStep</a>()</code>,
<code><a href="#topic+profiles">profiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The character `0 0 0 1 1 1`
Carter1(1, 3, 3) # Exactly one step
Carter1(2, 3, 3) # Two steps (one extra step)

# Number of trees that the character can map onto with exactly _m_ steps
# if non-parsimonious reconstructions are permitted:
cumsum(sapply(1:3, Carter1, 3, 3))

# Three steps allow the character to map onto any of the 105 six-leaf trees.

</code></pre>

<hr>
<h2 id='CharacterLength'>Character length</h2><span id='topic+CharacterLength'></span><span id='topic+FitchSteps'></span><span id='topic+FastCharacterLength'></span>

<h3>Description</h3>

<p>Homoplasy length of each character in a dataset on a specified tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CharacterLength(tree, dataset, compress = FALSE)

FitchSteps(tree, dataset)

FastCharacterLength(tree, dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CharacterLength_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="CharacterLength_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="CharacterLength_+3A_compress">compress</code></td>
<td>
<p>Logical specifying whether to retain the compression of a
<code>phyDat</code> object or to return a vector specifying to each individual
character, decompressed using the dataset's <code>index</code> attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CharacterLength()</code> returns a vector listing the contribution of each
character to tree score, according to the algorithm of
Brazeau et al. (2019).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>FastCharacterLength()</code>: Do not perform checks.  Use with care: may cause
erroneous results or software crash if variables are in the incorrect format.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Brazeau MD, Guillerme T, Smith MR (2019).
&ldquo;An algorithm for morphological phylogenetic analysis with inapplicable data.&rdquo;
<em>Systematic Biology</em>, <b>68</b>(4), 619&ndash;631.
<a href="https://doi.org/10.1093/sysbio/syy083">doi:10.1093/sysbio/syy083</a>.
</p>


<h3>See Also</h3>

<p>Other tree scoring: 
<code><a href="#topic+IWScore">IWScore</a>()</code>,
<code><a href="#topic+LengthAdded">LengthAdded</a>()</code>,
<code><a href="#topic+MinimumLength">MinimumLength</a>()</code>,
<code><a href="#topic+MorphyTreeLength">MorphyTreeLength</a>()</code>,
<code><a href="#topic+TaxonInfluence">TaxonInfluence</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("inapplicable.datasets")
dataset &lt;- inapplicable.phyData[[12]]
tree &lt;- TreeTools::NJTree(dataset)
CharacterLength(tree, dataset)
CharacterLength(tree, dataset, compress = TRUE)
</code></pre>

<hr>
<h2 id='ClusterStrings'>Cluster similar strings</h2><span id='topic+ClusterStrings'></span>

<h3>Description</h3>

<p>Calculate string similarity using the Levenshtein distance and return
clusters of similar strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusterStrings(x, maxCluster = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClusterStrings_+3A_x">x</code></td>
<td>
<p>Character vector.</p>
</td></tr>
<tr><td><code id="ClusterStrings_+3A_maxcluster">maxCluster</code></td>
<td>
<p>Integer specifying maximum number of clusters to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NameClusters()</code> returns an integer assigning each element of <code>x</code>
to a cluster, with an attribute <code>med</code> specifying the median string in each
cluster, and <code>silhouette</code> reporting the silhouette coefficient of the optimal
clustering.  Coefficients &lt; 0.5 indicate weak structure, and no clusters are
returned.  If the number of unique elements of <code>x</code> is less than <code>maxCluster</code>,
all occurrences of each entry are assigned to an individual cluster.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code><a href="#topic+QuartetResolution">QuartetResolution</a>()</code>,
<code><a href="#topic+WhenFirstHit">WhenFirstHit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ClusterStrings(c(paste0("FirstCluster ", 1:5),
                 paste0("SecondCluster.", 8:12),
                 paste0("AnotherCluster_", letters[1:6])))
</code></pre>

<hr>
<h2 id='ConcordantInformation'>Evaluate the concordance of information between a tree and a dataset</h2><span id='topic+ConcordantInformation'></span><span id='topic+Evaluate'></span><span id='topic+ConcordantInfo'></span>

<h3>Description</h3>

<p>Details the amount of information in a phylogenetic dataset that is
consistent with a specified phylogenetic tree, and the signal:noise
ratio of the character matrix implied if the tree is true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConcordantInformation(tree, dataset)

Evaluate(tree, dataset)

ConcordantInfo(tree, dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConcordantInformation_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="ConcordantInformation_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Presently restricted to datasets whose characters contain a maximum of
two parsimony-informative states.
</p>


<h3>Value</h3>

<p><code>ConcordantInformation()</code> returns a named vector with elements:
</p>

<ul>
<li> <p><code>informationContent</code>: cladistic information content of <code>dataset</code>
</p>
</li>
<li> <p><code>signal</code>, <code>noise</code>: amount of cladistic information that represents
phylogenetic signal and noise, according to <code>tree</code>
</p>
</li>
<li> <p><code>signalToNoise</code>: the implied signal:noise ratio of <code>dataset</code>
</p>
</li>
<li> <p><code>treeInformation</code>: the cladistic information content of a bifurcating tree
on <code>dataset</code>; this is the minimum amount of information necessary to resolve
a bifurcating tree, assuming no duplicate information or noise
</p>
</li>
<li> <p><code>matrixToTree</code>: the ratio of the cladistic information content of the
matrix to the cladistic information content of the tree, a measure of the
redundancy of the matrix
</p>
</li>
<li> <p><code>ignored</code>: information content of characters whose signal and noise could
not be calculated (too many states) and so are not included in the totals
above.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(congreveLamsdellMatrices)
myMatrix &lt;- congreveLamsdellMatrices[[10]]
ConcordantInformation(TreeTools::NJTree(myMatrix), myMatrix)
</code></pre>

<hr>
<h2 id='congreveLamsdellMatrices'>100 simulated data matrices</h2><span id='topic+congreveLamsdellMatrices'></span>

<h3>Description</h3>

<p>Contains the 100 simulated matrices generated by
(Congreve and Lamsdell 2016) using a heterogeneous Markov-k model,
generated from the <a href="#topic+referenceTree">referenceTree</a> topology, with
all branches sharing an equal length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congreveLamsdellMatrices
</code></pre>


<h3>Format</h3>

<p>A list with 100 entries, each comprising a <code>phyDat</code> object of 55
characters for 22 taxa
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.5061/dryad.7dq0j">doi:10.5061/dryad.7dq0j</a>
</p>


<h3>References</h3>

<p>Congreve CR, Lamsdell JC (2016).
&ldquo;Implied weighting and its utility in palaeontological datasets: a study using modelled phylogenetic matrices.&rdquo;
<em>Palaeontology</em>, <b>59</b>(3), 447&ndash;465.
<a href="https://doi.org/10.1111/pala.12236">doi:10.1111/pala.12236</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("referenceTree")
data("congreveLamsdellMatrices")
TreeLength(referenceTree, congreveLamsdellMatrices[[17]], "profile")

</code></pre>

<hr>
<h2 id='Consistency'>Consistency / retention &quot;indices&quot;</h2><span id='topic+Consistency'></span>

<h3>Description</h3>

<p><code>Consistency()</code> calculates the consistency &quot;index&quot; and retention index
(Farris 1989)
for each character in a dataset, given a bifurcating tree.
Although there is not a straightforward interpretation of these indices,
they are sometimes taken as an indicator of the fit of a character to a
tree.
Values correlate with the number of species sampled and the
distribution of taxa between character states, so are not strictly comparable
between characters in which these factors differ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Consistency(dataset, tree, compress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Consistency_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="Consistency_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="Consistency_+3A_compress">compress</code></td>
<td>
<p>Logical specifying whether to retain the compression of a
<code>phyDat</code> object or to return a vector specifying to each individual
character, decompressed using the dataset's <code>index</code> attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>consistency &quot;index&quot;</strong> (Kluge and Farris 1969) is defined as the
number of steps observed in the most parsimonious mapping of a character
to a tree, divided by the number of steps observed on the shortest possible
tree for that character. A value of one indicates that a character's fit to
the tree is optimal.
Note that as the possible values of the consistency index do not range from
zero to one, it is not an index in the mathematical sense of the term.
</p>
<p>The maximum length of a character (see <code><a href="#topic+MaximumLength">MaximumLength()</a></code>) is the
number of steps in a parsimonious reconstruction on the longest possible tree
for a character.
The <strong>retention index</strong> is the maximum length of a character minus the number
of steps observed on a given tree; divided by the maximum length minus the
minimum length.  It is interpreted as the ratio between the observed
homoplasy, and the maximum observed homoplasy, and scales from zero
(worst fit that can be reconstructed under parsimony) to one (perfect fit).
</p>
<p>The <strong>rescaled consistency index</strong> is the product of the consistency and
retention indices; it rescales the consistency index such that its range of
possible values runs from zero (least consistent) to one
(perfectly consistent).
</p>
<p>The lengths of characters including inapplicable tokens are calculated
following Brazeau et al. (2019), matching their
default treatment in <code><a href="#topic+TreeLength">TreeLength()</a></code>.
</p>


<h3>Value</h3>

<p><code>Consistency()</code> returns a matrix with named columns specifying the
consistency index (<code>ci</code>),
retention index (<code>ri</code>), and
rescaled consistency index (<code>rc</code>).
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Brazeau MD, Guillerme T, Smith MR (2019).
&ldquo;An algorithm for morphological phylogenetic analysis with inapplicable data.&rdquo;
<em>Systematic Biology</em>, <b>68</b>(4), 619&ndash;631.
<a href="https://doi.org/10.1093/sysbio/syy083">doi:10.1093/sysbio/syy083</a>.<br /><br /> Farris JS (1989).
&ldquo;The Retention Index and the Rescaled Consistency Index.&rdquo;
<em>Cladistics</em>, <b>5</b>(4), 417&ndash;419.
<a href="https://doi.org/10.1111/j.1096-0031.1989.tb00573.x">doi:10.1111/j.1096-0031.1989.tb00573.x</a>.<br /><br /> Kluge AG, Farris JS (1969).
&ldquo;Quantitative Phyletics and the Evolution of Anurans.&rdquo;
<em>Systematic Zoology</em>, <b>18</b>(1), 1&ndash;32.
<a href="https://doi.org/10.1093/sysbio/18.1.1">doi:10.1093/sysbio/18.1.1</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inapplicable.datasets)
dataset &lt;- inapplicable.phyData[[4]]
head(Consistency(dataset, TreeTools::NJTree(dataset)))
</code></pre>

<hr>
<h2 id='cSPR'><code>cSPR()</code> expects a tree rooted on a single tip.</h2><span id='topic+cSPR'></span>

<h3>Description</h3>

<p><code>cSPR()</code> expects a tree rooted on a single tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cSPR(tree, whichMove = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSPR_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="cSPR_+3A_whichmove">whichMove</code></td>
<td>
<p>Integer specifying which SPR move index to perform.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- TreeTools::BalancedTree(8)

# Tree must be rooted on leaf
tree &lt;- TreeTools::RootTree(tree, 1)

# Random rearrangement
cSPR(tree)

# Specific rearrangement
cSPR(tree, 9)
</code></pre>

<hr>
<h2 id='DoubleNNI'>Double NNI</h2><span id='topic+DoubleNNI'></span>

<h3>Description</h3>

<p>Returns the edge parameter of the two trees consistent with the speficied <abbr><span class="acronym">NNI</span></abbr> rearrangement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoubleNNI(parent, child, edgeToBreak)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DoubleNNI_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
<tr><td><code id="DoubleNNI_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td></tr>
<tr><td><code id="DoubleNNI_+3A_edgetobreak">edgeToBreak</code></td>
<td>
<p>(optional) integer specifying the index of an edge to bisect/prune,
generated randomly if not specified.
Alternatively, set to <code>-1</code> to return a complete list
of all trees one step from the input tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>tree[["edge"]]</code> parameter of the two trees consistent with the specified rearrangement
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>

<hr>
<h2 id='EdgeListSearch'>Search for most parsimonious trees</h2><span id='topic+EdgeListSearch'></span><span id='topic+TreeSearch'></span><span id='topic+IWTreeSearch'></span><span id='topic+EmptyPhyDat'></span><span id='topic+DoNothing'></span>

<h3>Description</h3>

<p>Run standard search algorithms (<abbr><span class="acronym">NNI</span></abbr>, <abbr><span class="acronym">SPR</span></abbr> or <abbr><span class="acronym">TBR</span></abbr>)
to search for a more parsimonious tree.
</p>
<p>For detailed documentation of the &quot;TreeSearch&quot; package, including full
instructions for loading phylogenetic data into R and initiating and
configuring tree search, see the
<a href="https://ms609.github.io/TreeSearch/">package documentation</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EdgeListSearch(
  edgeList,
  dataset,
  TreeScorer = MorphyLength,
  EdgeSwapper = RootedTBRSwap,
  maxIter = 100,
  maxHits = 20,
  bestScore = NULL,
  stopAtScore = NULL,
  stopAtPeak = FALSE,
  stopAtPlateau = 0L,
  verbosity = 1L,
  ...
)

TreeSearch(
  tree,
  dataset,
  InitializeData = PhyDat2Morphy,
  CleanUpData = UnloadMorphy,
  TreeScorer = MorphyLength,
  EdgeSwapper = RootedTBRSwap,
  maxIter = 100L,
  maxHits = 20L,
  stopAtPeak = FALSE,
  stopAtPlateau = 0L,
  verbosity = 1L,
  ...
)

IWTreeSearch(...)

EmptyPhyDat(tree)

DoNothing(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EdgeListSearch_+3A_edgelist">edgeList</code></td>
<td>
<p>a list containing the following:
- vector of integers corresponding to the parent of each edge in turn
- vector of integers corresponding to the child of each edge in turn
- (optionally) score of the tree
- (optionally, if score provided) number of times this score has been hit</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_treescorer">TreeScorer</code></td>
<td>
<p>function to score a given tree.
The function will be passed three parameters, corresponding to the
<code>parent</code> and <code>child</code> entries of a tree's edge list, and a dataset.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_edgeswapper">EdgeSwapper</code></td>
<td>
<p>a function that rearranges a parent and child vector,
and returns a list with modified vectors; for example <code><a href="#topic+SPRSwap">SPRSwap()</a></code>.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_maxiter">maxIter</code></td>
<td>
<p>Numeric specifying maximum number of iterations to perform
before abandoning the search.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_maxhits">maxHits</code></td>
<td>
<p>Numeric specifying maximum times to hit the best pscore
before abandoning the search.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_stopatpeak">stopAtPeak</code></td>
<td>
<p>Logical specifying whether to terminate search once a
subsequent iteration recovers a sub-optimal score.
Will be overridden if a passed function has an attribute <code>stopAtPeak</code> set by
<code>attr(FunctionName, "stopAtPeak") &lt;- TRUE</code>.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_stopatplateau">stopAtPlateau</code></td>
<td>
<p>Integer. If &gt; 0, tree search will terminate if the score
has not improved after <code>stopAtPlateau</code> iterations.
Will be overridden if a passed function has an attribute <code>stopAtPlateau</code> set
by <code>attr(FunctionName, "stopAtPlateau") &lt;- TRUE</code>.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_verbosity">verbosity</code></td>
<td>
<p>Numeric specifying level of detail to display in console:
larger numbers provide more verbose feedback to the user.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>TreeScorer()</code>, e.g. <code style="white-space: pre;">&#8288;dataset = &#8288;</code>.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_tree">tree</code></td>
<td>
<p>A fully-resolved starting tree in <code><a href="ape.html#topic+phylo">phylo</a></code> format,
with the desired outgroup.
Edge lengths are not supported and will be removed.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_initializedata">InitializeData</code></td>
<td>
<p>Function that sets up data object to prepare for tree search.
The function will be passed the <code>dataset</code> parameter.
Its return value will be passed to <code>TreeScorer()</code> and <code>CleanUpData()</code>.</p>
</td></tr>
<tr><td><code id="EdgeListSearch_+3A_cleanupdata">CleanUpData</code></td>
<td>
<p>Function to destroy data object on function exit.
The function will be passed the value returned by <code>InitializeData()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TreeSearch()</code> returns a tree, with an attribute <code>pscore</code> conveying its
parsimony score.
#&quot; Note that the parsimony score will be inherited from the tree&quot;s
attributes, which is only valid if it was generated using the same
<code>data</code> that is passed here.
</p>
<p><code>EmptyPhyDat()</code> returns a <code>phyDat</code> object comprising a single
null character, coded with state zero for every leaf in <code>tree</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>EdgeListSearch()</code>: Tree search from edge lists
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+Fitch">Fitch</a></code>, calculates parsimony score;
</p>
</li>
<li> <p><code><a href="#topic+RootedNNI">RootedNNI</a></code>, conducts tree rearrangements;
</p>
</li>
<li> <p><code><a href="#topic+Ratchet">Ratchet</a></code>, alternative heuristic, useful to escape local
optima.
</p>
</li></ul>

<p>Other custom search functions: 
<code><a href="#topic+Jackknife">Jackknife</a>()</code>,
<code><a href="#topic+MorphyBootstrap">MorphyBootstrap</a>()</code>,
<code><a href="#topic+SuccessiveApproximations">SuccessiveApproximations</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lobo", package="TreeTools")
njtree &lt;- TreeTools::NJTree(Lobo.phy)

## Only run examples in interactive R sessions
if (interactive()) {
  TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = NNISwap)
  TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = RootedSPRSwap)
  TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = TBRSwap)
}
</code></pre>

<hr>
<h2 id='GapHandler'>Read how a Morphy Object handles the inapplicable token</h2><span id='topic+GapHandler'></span>

<h3>Description</h3>

<p>Gaps represented by the inapplicable token can be treated as &quot;missing data&quot;,
i.e. as equivalent to the ambiguous token <code style="white-space: pre;">&#8288;?&#8288;</code>; as an extra state, equivalent
to other states such as <code>0</code> or <code>1</code>; or as &quot;inapplicable data&quot; using the
algorithm of Brazeau, Guillerme and Smith (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GapHandler(morphyObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GapHandler_+3A_morphyobj">morphyObj</code></td>
<td>
<p>Object of class <code>morphy</code>, perhaps created with
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>GapHandler()</code> returns a character string stating how
gaps are handled by <code>morphyObj</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>morphyObj &lt;- SingleCharMorphy("-0-0", "Extra")
GapHandler(morphyObj)
morphyObj &lt;- UnloadMorphy(morphyObj)
</code></pre>

<hr>
<h2 id='inapplicable.datasets'>Thirty datasets with inapplicable data</h2><span id='topic+inapplicable.datasets'></span><span id='topic+inapplicable.phyData'></span><span id='topic+inapplicable.trees'></span><span id='topic+inapplicable.citations'></span>

<h3>Description</h3>

<p>These are the datasets used to evaluate the behaviour of the inapplicable
algorithm in Brazeau et al. (2019).
The name of each item corresponds to the datasets listed below.
Datasets are sorted into two subsets, each sorted alphabetically;
the first subset comprise simpler datasets with faster processing times.
<code>inapplicable.datasets</code> provide the data in the matrix format generated by
<code><a href="ape.html#topic+read.nexus.data">read.nexus.data()</a></code>; <code>inapplicable.phyData</code> are in <code>phyDat</code> format.
<code>inapplicable.trees</code> lists for each dataset a sample of up to 50 trees
obtained by tree search under each inapplicable treatment, named accordingly.
<code>inapplicable.citations</code> is a named character vector specifying the source of
each dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inapplicable.datasets

inapplicable.phyData

inapplicable.trees

inapplicable.citations
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 30.
</p>
<p>An object of class <code>list</code> of length 30.
</p>
<p>An object of class <code>list</code> of length 31.
</p>
<p>An object of class <code>character</code> of length 30.
</p>


<h3>Source</h3>


<p>Subset one (faster processing):
</p>

<dl>
<dt>Agnarsson2004</dt><dd><p>AGNARSSON, I. 2004. Morphological phylogeny of cobweb spiders and their
relatives (Araneae, Araneoidea, Theridiidae). Zoological Journal of the
Linnean Society, 141, 447&ndash;626.</p>
</dd>
<dt>Capa2011</dt><dd><p>CAPA, M., HUTCHINGS, P., AGUADO, M. T. and BOTT, N. J. 2011. Phylogeny of
Sabellidae (Annelida) and relationships with other taxa inferred from
morphology and multiple genes. Cladistics, 27, 449&ndash;469.</p>
</dd>
<dt>DeAssis2011</dt><dd><p> DE ASSIS, J. E. and CHRISTOFFERSEN, M. L. 2011. Phylogenetic relationships
within Maldanidae (Capitellida, Annelida), based on morphological characters.
Systematics and Biodiversity, 9, 233&ndash;245.</p>
</dd>
<dt>OLeary1999</dt><dd><p> O'LEARY, M. A. and GEISLER, J. H. 1999. The position of Cetacea within
Mammalia: phylogenetic analysis of morphological data from extinct and
extant taxa. Systematic Biology, 48, 455&ndash;490.</p>
</dd>
<dt>Rousset2004</dt><dd><p> ROUSSET, V., ROUSE, G. W., SIDDALL, M. E., TILLIER, A. and PLEIJEL, F.
2004. The phylogenetic position of Siboglinidae (Annelida) inferred from
18S rRNA, 28S rRNA and morphological data. Cladistics, 20, 518&ndash;533.</p>
</dd>
<dt>Sano2011</dt><dd><p> SANO, M. and AKIMOTO, S.-I. 2011. Morphological phylogeny of
gall-forming aphids of the tribe Eriosomatini (Aphididae: Eriosomatinae).
Systematic Entomology, 36, 607&ndash;627.</p>
</dd>
<dt>Sansom2010</dt><dd><p> SANSOM, R. S., FREEDMAN, K., GABBOTT, S. E., ALDRIDGE, R. J. and
PURNELL, M. A. 2010. Taphonomy and affinity of an enigmatic Silurian vertebrate,
<em>Jamoytius kerwoodi</em> White. Palaeontology, 53, 1393&ndash;1409.</p>
</dd>
<dt>Schulze2007</dt><dd><p> SCHULZE, A., CUTLER, E. B. and GIRIBET, G. 2007. Phylogeny of sipunculan
worms: A combined analysis of four gene regions and morphology. Molecular Phylogenetics and Evolution, 42, 171&ndash;92.</p>
</dd>
<dt>Shultz2007</dt><dd><p> SHULTZ, J. W. 2007. A phylogenetic analysis of the arachnid orders based
on morphological characters. Zoological Journal of the Linnean Society, 150, 221&ndash;265.</p>
</dd>
<dt>Wetterer2000</dt><dd><p> WETTERER, A. L., ROCKKMAN, M. V. and SIMMONS, N. B. 2000. Phylogeny of
phyllostomid bats (Mammalia: Chiroptera): data from diverse morphological
systems, sex chromosomes, and restriction sites. Bulletin of the American Museum of Natural History, 248, 1&ndash;200.</p>
</dd>
<dt>Wills2012</dt><dd><p> WILLS, M. A., GERBER, S., RUTA, M. and HUGHES, M. 2012. The disparity of
priapulid, archaeopriapulid and palaeoscolecid worms in the light of new data.
Journal of Evolutionary Biology, 25, 2056&ndash;2076.</p>
</dd>
</dl>

<p>Subset two (longer processing times):
</p>

<dl>
<dt>Aguado2009</dt><dd><p> AGUADO, M. T. and SAN MARTIN, G. 2009. Phylogeny of Syllidae (Polychaeta)
based on morphological data. Zoologica Scripta, 38, 379&ndash;402.</p>
</dd>
<dt>Aria2015</dt><dd><p> ARIA, C., CARON, J. B. and GAINES, R. 2015. A large new leanchoiliid from
the Burgess Shale and the influence of inapplicable states on stem arthropod
phylogeny. Palaeontology, 58, 629&ndash;660.</p>
</dd>
<dt>Asher2005</dt><dd><p>ASHER, R. J. and HOFREITER, M. 2006. Tenrec phylogeny and the noninvasive
extraction of nuclear DNA. Systematic biology, 55, 181&ndash;94.</p>
</dd>
<dt>Baker2009</dt><dd><p> BAKER, W. J., SAVOLAINEN, V., ASMUSSEN-LANGE, C. B., CHASE, M. W.,
DRANSFIELD, J., FOREST, F., HARLEY, M. M., UHL, N. W. and WILKINSON, M. 2009.
Complete generic-level phylogenetic analyses of palms (Arecaceae) with
comparisons of supertree and supermatrix approaches.
Systematic Biology, 58, 240&ndash;256.</p>
</dd>
<dt>Bouchenak2010</dt><dd><p> BOUCHENAK-KHELLADI, Y., VERBOOM, G. A., SAVOLAINEN, V. and HODKINSON, T. R.
2010. Biogeography of the grasses (Poaceae): a phylogenetic approach to reveal
evolutionary history in geographical space and geological time. Botanical
Journal of the Linnean Society, 162, 543&ndash;557.</p>
</dd>
<dt>Conrad2008</dt><dd><p> CONRAD, J. L. 2008. Phylogeny And Systematics Of Squamata (Reptilia) Based
On Morphology. Bulletin of the American Museum of Natural History, 310, 1&ndash;182.</p>
</dd>
<dt>Dikow2009</dt><dd><p> DIKOW, T. 2009. A phylogenetic hypothesis for Asilidae based on a total
evidence analysis of morphological and DNA sequence data (Insecta: Diptera:
Brachycera: Asiloidea). Organisms Diversity and Evolution, 9, 165&ndash;188.</p>
</dd>
<dt>Eklund2004</dt><dd><p> EKLUND, H., DOYLE, J. A. and HERENDEEN, P. S. 2004. Morphological
phylogenetic analysis of living and fossil Chloranthaceae. International
Journal of Plant Sciences, 165, 107&ndash;151.</p>
</dd>
<dt>Geisler2001</dt><dd><p> GEISLER, J. H. 2001. New morphological evidence for the phylogeny of
Artiodactyla, Cetacea, and Mesonychidae. American Museum Novitates, 3344, 53.</p>
</dd>
<dt>Giles2015</dt><dd><p> GILES, S., FRIEDMAN, M. and BRAZEAU, M. D. 2015. Osteichthyan-like cranial
conditions in an Early Devonian stem gnathostome. Nature, 520, 82&ndash;85.</p>
</dd>
<dt>Griswold1999</dt><dd><p> GRISWOLD, C. E., CODDINGTON, J. A., PLATNICK, N. I. and FORSTER, R. R. 1999.
Towards a phylogeny of entelegyne spiders (Araneae, Araneomorphae, Entelegynae).
Journal of Arachnology, 27, 53&ndash;63.</p>
</dd>
<dt>Liljeblad2008</dt><dd><p> LILJEBLAD, J., RONQUIST, F., NIEVES-ALDREY, J. L., FONTAL-CAZALLA, F.,
ROS-FARRE, P., GAITROS, D. and PUJADE-VILLAR, J. 2008. A fully web-illustrated
morphological phylogenetic study of relationships among oak gall wasps and
their closest relatives (Hymenoptera: Cynipidae).</p>
</dd>
<dt>Loconte1991</dt><dd><p> LOCONTE, H. and STEVENSON, D. W. 1991. Cladistics of the Magnoliidae.
Cladistics, 7, 267&ndash;296.</p>
</dd>
<dt>Longrich2010</dt><dd><p> LONGRICH, N. R., SANKEY, J. and TANKE, D. 2010. <em>Texacephale langstoni</em>,
a new genus of pachycephalosaurid (Dinosauria: Ornithischia) from the upper
Campanian Aguja Formation, southern Texas, USA. Cretaceous Research, 31, 274&ndash;284.</p>
</dd>
<dt>OMeara2014</dt><dd><p> O'MEARA, R. N. and THOMPSON, R. S. 2014. Were There Miocene Meridiolestidans?
Assessing the phylogenetic placement of <em>Necrolestes patagonensis</em> and the
presence of a 40 million year Meridiolestidan ghost lineage. Journal
of Mammalian Evolution, 21, 271&ndash;284.</p>
</dd>
<dt>Rougier2012</dt><dd><p> ROUGIER, G. W., WIBLE, J. R., BECK, R. M. D. and APESTEGUIA, S. 2012.
The Miocene mammal <em>Necrolestes</em> demonstrates the survival of a
Mesozoic nontherian lineage into the late Cenozoic of South America.
Proceedings of the National Academy of Sciences, 109, 20053&ndash;8.</p>
</dd>
<dt>Sharkey2011</dt><dd><p> SHARKEY, M. J., CARPENTER, J. M., VILHELMSEN, L., HERATY, J., LILJEBLAD, J.,
DOWLING, A. P. G., SCHULMEISTER, S., MURRAY, D., DEANS, A. R., RONQUIST, F.,
KROGMANN, L. and WHEELER, W. C. 2012. Phylogenetic relationships among
superfamilies of Hymenoptera. Cladistics, 28, 80&ndash;112.</p>
</dd>
<dt>Sundue2010</dt><dd><p> SUNDUE, M. A., ISLAM, M. B. and RANKER, T. A. 2010. Systematics of
Grammitid Ferns (Polypodiaceae): Using Morphology and Plastid Sequence Data
to Resolve the Circumscriptions of Melpomene and the Polyphyletic Genera
<em>Lellingeria</em> and <em>Terpsichore</em>. Systematic Botany, 35, 701&ndash;715.</p>
</dd>
<dt>Vinther2008</dt><dd><p> VINTHER, J., VAN ROY, P. and BRIGGS, D. E. G. 2008. Machaeridians are
Palaeozoic armoured annelids. Nature, 451, 185&ndash;188.</p>
</dd>
<dt>Wilson2003</dt><dd><p> WILSON, G. D. F. and EDGECOMBE, G. D. 2003. The Triassic isopod
<em>Protamphisopus wianamattensis</em> (Chilton) and comparison by extant
taxa (Crustacea, Phreatoicidea). Journal of Paleontology, 77, 454&ndash;470.</p>
</dd>
<dt>Wortley2006</dt><dd><p> WORTLEY, A. H. and SCOTLAND, R. W. 2006. The effect of combining molecular
and morphological data in published phylogenetic analyses.
Systematic Biology, 55, 677&ndash;685.</p>
</dd>
<dt>Zanol2014</dt><dd><p> ZANOL, J., HALANYCH, K. M. and FAUCHALD, K. 2014. Reconciling taxonomy and
phylogeny in the bristleworm family Eunicidae (Polychaete, Annelida).
Zoologica Scripta, 43, 79&ndash;100.</p>
</dd>
<dt>Zhu2013</dt><dd><p> ZHU, M., YU, X., AHLBERG, P. E., CHOO, B., LU, J., QIAO, T., QU, Q., ZHAO, W.,
JIA, L., BLOM, H. and ZHU, Y. 2013. A Silurian placoderm with osteichthyan-like
marginal jaw bones. Nature, 502, 188&ndash;193.</p>
</dd>
</dl>




<h3>References</h3>

<p>Brazeau MD, Guillerme T, Smith MR (2019).
&ldquo;An algorithm for morphological phylogenetic analysis with inapplicable data.&rdquo;
<em>Systematic Biology</em>, <b>68</b>(4), 619&ndash;631.
<a href="https://doi.org/10.1093/sysbio/syy083">doi:10.1093/sysbio/syy083</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("inapplicable.datasets", package = "TreeSearch")
names(inapplicable.datasets)
</code></pre>

<hr>
<h2 id='is.morphyPtr'>Is an object a valid Morphy object?</h2><span id='topic+is.morphyPtr'></span>

<h3>Description</h3>

<p>Is an object a valid Morphy object?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.morphyPtr(morphyObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.morphyPtr_+3A_morphyobj">morphyObj</code></td>
<td>
<p>Object of class <code>morphy</code>, perhaps created with
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.morphyPtr()</code> returns <code>TRUE</code> if <code>morphyObj</code> is a valid morphy
pointer, <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='IWScore'>Calculate the parsimony score of a tree given a dataset</h2><span id='topic+IWScore'></span><span id='topic+TreeLength'></span><span id='topic+TreeLength.phylo'></span><span id='topic+TreeLength.numeric'></span><span id='topic+TreeLength.list'></span><span id='topic+TreeLength.multiPhylo'></span><span id='topic+Fitch'></span>

<h3>Description</h3>

<p><code>TreeLength()</code> uses the Morphy library (Brazeau et al. 2017)
to calculate a parsimony score for a tree, handling inapplicable data
according to the algorithm of Brazeau et al. (2019).
Trees may be scored using equal weights, implied weights
(Goloboff 1993), or profile parsimony
(Faith and Trueman 2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IWScore(tree, dataset, concavity = 10L, ...)

TreeLength(tree, dataset, concavity = Inf)

## S3 method for class 'phylo'
TreeLength(tree, dataset, concavity = Inf)

## S3 method for class 'numeric'
TreeLength(tree, dataset, concavity = Inf)

## S3 method for class 'list'
TreeLength(tree, dataset, concavity = Inf)

## S3 method for class 'multiPhylo'
TreeLength(tree, dataset, concavity = Inf)

Fitch(tree, dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IWScore_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code>phylo</code>, a list thereof (optionally of class
<code>multiPhylo</code>), or an integer &ndash; in which case <code>tree</code> random trees will be
uniformly sampled.</p>
</td></tr>
<tr><td><code id="IWScore_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="IWScore_+3A_concavity">concavity</code></td>
<td>
<p>Determines the degree to which extra steps beyond the first
are penalized.  Specify a numeric value to use implied weighting
(Goloboff 1993); <code>concavity</code> specifies <em>k</em> in
<em>k</em> / <em>e</em> + <em>k</em>. A value of 10 is recommended;
TNT sets a default of 3, but this is too low in some circumstances
(Goloboff et al. 2018; Smith 2019).
Better still explore the sensitivity of results under a range of
concavity values, e.g. <code>k = 2 ^ (1:7)</code>.
Specify <code>Inf</code> to weight each additional step equally.
Specify <code>"profile"</code> to employ profile parsimony (Faith and Trueman 2001).</p>
</td></tr>
<tr><td><code id="IWScore_+3A_...">...</code></td>
<td>
<p>unused; allows additional parameters specified within ... to be
received by the function without throwing an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TreeLength()</code> returns a numeric vector containing the score for
each tree in <code>tree</code>.
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith (using Morphy C library, by Martin Brazeau)
</p>


<h3>References</h3>

<p>Brazeau MD, Guillerme T, Smith MR (2019).
&ldquo;An algorithm for morphological phylogenetic analysis with inapplicable data.&rdquo;
<em>Systematic Biology</em>, <b>68</b>(4), 619&ndash;631.
<a href="https://doi.org/10.1093/sysbio/syy083">doi:10.1093/sysbio/syy083</a>.<br /><br /> Brazeau MD, Smith MR, Guillerme T (2017).
&ldquo;MorphyLib: a library for phylogenetic analysis of categorical trait data with inapplicability.&rdquo;
<a href="https://doi.org/10.5281/zenodo.815372">doi:10.5281/zenodo.815372</a>.<br /><br /> Faith DP, Trueman JWH (2001).
&ldquo;Towards an inclusive philosophy for phylogenetic inference.&rdquo;
<em>Systematic Biology</em>, <b>50</b>(3), 331&ndash;350.
<a href="https://doi.org/10.1080/10635150118627">doi:10.1080/10635150118627</a>.<br /><br /> Goloboff PA (1993).
&ldquo;Estimating character weights during tree search.&rdquo;
<em>Cladistics</em>, <b>9</b>(1), 83&ndash;91.
<a href="https://doi.org/10.1111/j.1096-0031.1993.tb00209.x">doi:10.1111/j.1096-0031.1993.tb00209.x</a>.<br /><br /> Goloboff PA, Torres A, Arias JS (2018).
&ldquo;Weighted parsimony outperforms other methods of phylogenetic inference under models appropriate for morphology.&rdquo;
<em>Cladistics</em>, <b>34</b>(4), 407&ndash;437.
<a href="https://doi.org/10.1111/cla.12205">doi:10.1111/cla.12205</a>.<br /><br /> Smith MR (2019).
&ldquo;Bayesian and parsimony approaches reconstruct informative trees from simulated morphological datasets.&rdquo;
<em>Biology Letters</em>, <b>15</b>(2), 20180632.
<a href="https://doi.org/10.1098/rsbl.2018.0632">doi:10.1098/rsbl.2018.0632</a>.
</p>


<h3>See Also</h3>


<ul>
<li><p> Conduct tree search using <code><a href="#topic+MaximizeParsimony">MaximizeParsimony()</a></code> (command line),
<code><a href="#topic+EasyTrees">EasyTrees()</a></code> (graphical user interface), or <code><a href="#topic+TreeSearch">TreeSearch()</a></code>
(custom optimality criteria).
</p>
</li>
<li><p> See score for each character: <code><a href="#topic+CharacterLength">CharacterLength()</a></code>.
</p>
</li></ul>

<p>Other tree scoring: 
<code><a href="#topic+CharacterLength">CharacterLength</a>()</code>,
<code><a href="#topic+LengthAdded">LengthAdded</a>()</code>,
<code><a href="#topic+MinimumLength">MinimumLength</a>()</code>,
<code><a href="#topic+MorphyTreeLength">MorphyTreeLength</a>()</code>,
<code><a href="#topic+TaxonInfluence">TaxonInfluence</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("inapplicable.datasets")
tree &lt;- TreeTools::BalancedTree(inapplicable.phyData[[1]])
TreeLength(tree, inapplicable.phyData[[1]])
TreeLength(tree, inapplicable.phyData[[1]], concavity = 10)
TreeLength(tree, inapplicable.phyData[[1]], concavity = "profile")
TreeLength(5, inapplicable.phyData[[1]])
</code></pre>

<hr>
<h2 id='Jackknife'>Jackknife resampling</h2><span id='topic+Jackknife'></span>

<h3>Description</h3>

<p>Resample trees using Jackknife resampling, i.e. removing a subset of
characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jackknife(
  tree,
  dataset,
  resampleFreq = 2/3,
  InitializeData = PhyDat2Morphy,
  CleanUpData = UnloadMorphy,
  TreeScorer = MorphyLength,
  EdgeSwapper = TBRSwap,
  jackIter = 5000L,
  searchIter = 4000L,
  searchHits = 42L,
  verbosity = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jackknife_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="Jackknife_+3A_dataset">dataset</code></td>
<td>
<p>a dataset in the format required by <code>TreeScorer()</code>.</p>
</td></tr>
<tr><td><code id="Jackknife_+3A_resamplefreq">resampleFreq</code></td>
<td>
<p>Double between 0 and 1 stating proportion of characters
to resample.</p>
</td></tr>
<tr><td><code id="Jackknife_+3A_initializedata">InitializeData</code></td>
<td>
<p>Function that sets up data object to prepare for tree search.
The function will be passed the <code>dataset</code> parameter.
Its return value will be passed to <code>TreeScorer()</code> and <code>CleanUpData()</code>.</p>
</td></tr>
<tr><td><code id="Jackknife_+3A_cleanupdata">CleanUpData</code></td>
<td>
<p>Function to destroy data object on function exit.
The function will be passed the value returned by <code>InitializeData()</code>.</p>
</td></tr>
<tr><td><code id="Jackknife_+3A_treescorer">TreeScorer</code></td>
<td>
<p>function to score a given tree.
The function will be passed three parameters, corresponding to the
<code>parent</code> and <code>child</code> entries of a tree's edge list, and a dataset.</p>
</td></tr>
<tr><td><code id="Jackknife_+3A_edgeswapper">EdgeSwapper</code></td>
<td>
<p>a function that rearranges a parent and child vector,
and returns a list with modified vectors; for example <code><a href="#topic+SPRSwap">SPRSwap()</a></code>.</p>
</td></tr>
<tr><td><code id="Jackknife_+3A_jackiter">jackIter</code></td>
<td>
<p>Integer specifying number of jackknife iterations to conduct.</p>
</td></tr>
<tr><td><code id="Jackknife_+3A_searchiter">searchIter</code></td>
<td>
<p>Integer specifying maximum rearrangements to perform on each bootstrap or
ratchet iteration.
To override this value for a single swapper function, set e.g.
<code>attr(SwapperFunction, "searchIter") &lt;- 99</code></p>
</td></tr>
<tr><td><code id="Jackknife_+3A_searchhits">searchHits</code></td>
<td>
<p>Integer specifying maximum times to hit best score before terminating a tree
search within a ratchet iteration.
To override this value for a single swapper function, set e.g.
<code>attr(SwapperFunction, "searchHits") &lt;- 99</code></p>
</td></tr>
<tr><td><code id="Jackknife_+3A_verbosity">verbosity</code></td>
<td>
<p>Numeric specifying level of detail to display in console:
larger numbers provide more verbose feedback to the user.</p>
</td></tr>
<tr><td><code id="Jackknife_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>TreeScorer()</code>, e.g. <code style="white-space: pre;">&#8288;dataset = &#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes
that <code>InitializeData()</code> will return a morphy object; if this doesn't hold
for you, post a <a href="https://github.com/ms609/TreeSearch/issues/new/">GitHub issue</a>
or e-mail the maintainer.
</p>


<h3>Value</h3>

<p><code>Jackknife()</code> returns a list of trees recovered after jackknife
iterations.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+JackLabels">JackLabels()</a></code>: Label nodes of a tree with jackknife supports.
</p>
</li></ul>

<p>Other split support functions: 
<code><a href="#topic+JackLabels">JackLabels</a>()</code>,
<code><a href="#topic+MaximizeParsimony">MaximizeParsimony</a>()</code>,
<code><a href="#topic+SiteConcordance">SiteConcordance</a></code>
</p>
<p>Other custom search functions: 
<code><a href="#topic+EdgeListSearch">EdgeListSearch</a>()</code>,
<code><a href="#topic+MorphyBootstrap">MorphyBootstrap</a>()</code>,
<code><a href="#topic+SuccessiveApproximations">SuccessiveApproximations</a>()</code>
</p>

<hr>
<h2 id='JackLabels'>Label nodes with jackknife support values</h2><span id='topic+JackLabels'></span>

<h3>Description</h3>

<p>Label nodes with jackknife support values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackLabels(
  tree,
  jackTrees,
  plot = TRUE,
  add = FALSE,
  adj = 0,
  col = NULL,
  frame = "none",
  pos = 2L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JackLabels_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="JackLabels_+3A_jacktrees">jackTrees</code></td>
<td>
<p>A list or <code>multiPhylo</code> object containing trees generated
by <code><a href="#topic+Jackknife">Jackknife()</a></code>.</p>
</td></tr>
<tr><td><code id="JackLabels_+3A_plot">plot</code></td>
<td>
<p>Logical specifying whether to plot results; if <code>FALSE</code>,
returns blank labels for nodes near the root that do not correspond to a
unique split.</p>
</td></tr>
<tr><td><code id="JackLabels_+3A_add">add</code></td>
<td>
<p>Logical specifying whether to add the labels to an existing
plot.</p>
</td></tr>
<tr><td><code id="JackLabels_+3A_adj">adj</code>, <code id="JackLabels_+3A_col">col</code>, <code id="JackLabels_+3A_frame">frame</code>, <code id="JackLabels_+3A_pos">pos</code>, <code id="JackLabels_+3A_...">...</code></td>
<td>
<p>Parameters to pass to <code>nodelabels()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector specifying the proportion of jackknife trees
consistent with each node in <code>tree</code>, as plotted.
If <code>plot = FALSE</code>, blank entries are included corresponding to nodes
that do not require labelling; the return value is in the value required
by <code>phylo$node.label</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jackknife">Jackknife()</a></code>: Generate trees by jackknife resampling
</p>
<p>Other split support functions: 
<code><a href="#topic+Jackknife">Jackknife</a>()</code>,
<code><a href="#topic+MaximizeParsimony">MaximizeParsimony</a>()</code>,
<code><a href="#topic+SiteConcordance">SiteConcordance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE) # for as.phylo

# jackTrees will usually be generated with Jackknife(), but for simplicity:
jackTrees &lt;- as.phylo(1:100, 8)

tree &lt;- as.phylo(0, 8)
JackLabels(tree, jackTrees)

tree$node.label &lt;- JackLabels(tree, jackTrees, plot = FALSE)
</code></pre>

<hr>
<h2 id='LengthAdded'>Contribution of character to leaf instability</h2><span id='topic+LengthAdded'></span><span id='topic+PolEscapa'></span>

<h3>Description</h3>

<p>Would tree lengths change if a character was coded as ambiguous for each
leaf (Pol and Escapa 2009)?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LengthAdded(trees, char, concavity = Inf)

PolEscapa(trees, char, concavity = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LengthAdded_+3A_trees">trees</code></td>
<td>
<p>List of trees of class <code>phylo</code>, or <code>multiPhylo</code> object.</p>
</td></tr>
<tr><td><code id="LengthAdded_+3A_char">char</code></td>
<td>
<p><code>phyDat</code> object containing a single character.</p>
</td></tr>
<tr><td><code id="LengthAdded_+3A_concavity">concavity</code></td>
<td>
<p>Determines the degree to which extra steps beyond the first
are penalized.  Specify a numeric value to use implied weighting
(Goloboff 1993); <code>concavity</code> specifies <em>k</em> in
<em>k</em> / <em>e</em> + <em>k</em>. A value of 10 is recommended;
TNT sets a default of 3, but this is too low in some circumstances
(Goloboff et al. 2018; Smith 2019).
Better still explore the sensitivity of results under a range of
concavity values, e.g. <code>k = 2 ^ (1:7)</code>.
Specify <code>Inf</code> to weight each additional step equally.
Specify <code>"profile"</code> to employ profile parsimony (Faith and Trueman 2001).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>High values for a leaf indicate that its coding contributes to instability
(&quot;wildcard&quot; or &quot;roguish&quot; behaviour; see
<a href="https://ms609.github.io/Rogue/"><span class="pkg">Rogue</span></a>for further details).
The coding is in tension with other data, which may indicate that the
assumptions of homology that underlie the character's construction and
scoring require careful scrutiny – or that the taxon in question has
been subject to convergent evolution.
</p>
<p>When inapplicable tokens are present in a character, the applicability of
each coding is maintained: i.e. a leaf coded with an applicable token is
never allowed to take an inapplicable value; and an inapplicable token
remains inapplicable.
</p>


<h3>Value</h3>

<p><code>LengthAdded()</code> returns a named numeric vector listing the mean
absolute change to tree length resulting if the character were coded
ambiguous for each leaf in turn, under the specified concavity constant.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Faith DP, Trueman JWH (2001).
&ldquo;Towards an inclusive philosophy for phylogenetic inference.&rdquo;
<em>Systematic Biology</em>, <b>50</b>(3), 331&ndash;350.
<a href="https://doi.org/10.1080/10635150118627">doi:10.1080/10635150118627</a>.<br /><br /> Goloboff PA (1993).
&ldquo;Estimating character weights during tree search.&rdquo;
<em>Cladistics</em>, <b>9</b>(1), 83&ndash;91.
<a href="https://doi.org/10.1111/j.1096-0031.1993.tb00209.x">doi:10.1111/j.1096-0031.1993.tb00209.x</a>.<br /><br /> Goloboff PA, Torres A, Arias JS (2018).
&ldquo;Weighted parsimony outperforms other methods of phylogenetic inference under models appropriate for morphology.&rdquo;
<em>Cladistics</em>, <b>34</b>(4), 407&ndash;437.
<a href="https://doi.org/10.1111/cla.12205">doi:10.1111/cla.12205</a>.<br /><br /> Pol D, Escapa IH (2009).
&ldquo;Unstable taxa in cladistic analysis: identification and the assessment of relevant characters.&rdquo;
<em>Cladistics</em>, <b>25</b>(5), 515&ndash;527.
<a href="https://doi.org/10.1111/j.1096-0031.2009.00258.x">doi:10.1111/j.1096-0031.2009.00258.x</a>.<br /><br /> Smith MR (2019).
&ldquo;Bayesian and parsimony approaches reconstruct informative trees from simulated morphological datasets.&rdquo;
<em>Biology Letters</em>, <b>15</b>(2), 20180632.
<a href="https://doi.org/10.1098/rsbl.2018.0632">doi:10.1098/rsbl.2018.0632</a>.
</p>


<h3>See Also</h3>

<p>Other tree scoring: 
<code><a href="#topic+CharacterLength">CharacterLength</a>()</code>,
<code><a href="#topic+IWScore">IWScore</a>()</code>,
<code><a href="#topic+MinimumLength">MinimumLength</a>()</code>,
<code><a href="#topic+MorphyTreeLength">MorphyTreeLength</a>()</code>,
<code><a href="#topic+TaxonInfluence">TaxonInfluence</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trees &lt;- inapplicable.trees[["Vinther2008"]]
dataset &lt;- inapplicable.phyData[["Vinther2008"]]
char &lt;- dataset[, 11]
added &lt;- LengthAdded(trees, char)

PlotCharacter(
  tree = trees[[1]], 
  dataset = char,
  tip.color = 1 + added[trees[[1]]$tip.label] # Colour by added steps
) -&gt; XX # Suppress return value; display plot only

</code></pre>

<hr>
<h2 id='MaximizeParsimony'>Find most parsimonious trees</h2><span id='topic+MaximizeParsimony'></span><span id='topic+Resample'></span><span id='topic+EasyTrees'></span><span id='topic+EasyTreesy'></span>

<h3>Description</h3>

<p>Search for most parsimonious trees using the parsimony ratchet and
<abbr><span class="acronym">TBR</span></abbr> rearrangements, treating inapplicable data as such using the
algorithm of Brazeau et al. (2019).
</p>
<p>Tree search will be conducted from a specified or automatically-generated
starting tree in order to find a tree with an optimal parsimony score,
under implied or equal weights, treating inapplicable characters as such
in order to avoid the artefacts of the standard Fitch algorithm
(see Maddison 1993; Brazeau et al. 2019).
Tree length is calculated using the MorphyLib C library
(Brazeau et al. 2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaximizeParsimony(
  dataset,
  tree,
  ratchIter = 7L,
  tbrIter = 2L,
  startIter = 2L,
  finalIter = 1L,
  maxHits = NTip(dataset) * 1.8,
  maxTime = 60,
  quickHits = 1/3,
  concavity = Inf,
  ratchEW = TRUE,
  tolerance = sqrt(.Machine[["double.eps"]]),
  constraint,
  verbosity = 3L
)

Resample(
  dataset,
  tree,
  method = "jack",
  proportion = 2/3,
  ratchIter = 1L,
  tbrIter = 8L,
  finalIter = 3L,
  maxHits = 12L,
  concavity = Inf,
  tolerance = sqrt(.Machine[["double.eps"]]),
  constraint,
  verbosity = 2L,
  ...
)

EasyTrees()

EasyTreesy()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaximizeParsimony_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_tree">tree</code></td>
<td>
<p>(optional) A bifurcating tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>,
containing only the tips listed in <code>dataset</code>, from which the search
should begin.
If unspecified, an <a href="#topic+AdditionTree">addition tree</a> will be generated from
<code>dataset</code>, respecting any supplied <code>constraint</code>.
Edge lengths are not supported and will be deleted.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_ratchiter">ratchIter</code></td>
<td>
<p>Numeric specifying number of iterations of the
parsimony ratchet (Nixon 1999) to conduct.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_tbriter">tbrIter</code></td>
<td>
<p>Numeric specifying the maximum number of <abbr><span class="acronym">TBR</span></abbr>
break points to evaluate before concluding each search.
The counter is reset to zero each time tree score improves.
The counter is reset to zero each time tree score improves.
One &quot;iteration&quot; comprises breaking a single branch and evaluating all
possible reconnections.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_startiter">startIter</code></td>
<td>
<p>Numeric: an initial round of tree search with
<code>startIter</code> × <code>tbrIter</code> <abbr><span class="acronym">TBR</span></abbr> break points is conducted in
order to locate a local optimum before beginning ratchet searches.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_finaliter">finalIter</code></td>
<td>
<p>Numeric: a final round of tree search will evaluate
<code>finalIter</code> × <code>tbrIter</code> <abbr><span class="acronym">TBR</span></abbr> break points, in order to
sample the final optimal neighbourhood more intensely.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_maxhits">maxHits</code></td>
<td>
<p>Numeric specifying the maximum times that an optimal
parsimony score may be hit before concluding a ratchet iteration or final
search concluded.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_maxtime">maxTime</code></td>
<td>
<p>Numeric: after <code>maxTime</code> minutes, stop tree search at the
next opportunity.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_quickhits">quickHits</code></td>
<td>
<p>Numeric: iterations on subsampled datasets
will retain <code>quickHits</code> × <code>maxHits</code> trees with the best score.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_concavity">concavity</code></td>
<td>
<p>Numeric specifying concavity constant for implied step
weighting.
The most appropriate value will depend on the dataset, but values around
10&ndash;15 often perform well (Goloboff et al. 2018; Smith 2019).
The character string &quot;profile&quot; employs an approximation of profile parsimony
(Faith and Trueman 2001).
Set as <code>Inf</code> for equal step weights, which underperforms step weighting
approaches
(Goloboff et al. 2008; Goloboff et al. 2018; Goloboff and Arias 2019; Smith 2019).</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_ratchew">ratchEW</code></td>
<td>
<p>Logical specifying whether to use equal weighting during
ratchet iterations, improving search speed whilst still facilitating
escape from local optima.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric specifying degree of suboptimality to tolerate
before rejecting a tree.  The default, <code>sqrt(.Machine$double.eps)</code>, retains
trees that may be equally parsimonious but for rounding errors.
Setting to larger values will include trees suboptimal by up to <code>tolerance</code>
in search results, which may improve the accuracy of the consensus tree
(at the expense of resolution) (Smith 2019).</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_constraint">constraint</code></td>
<td>
<p>Either an object of class <code>phyDat</code>, in which case
returned trees will be perfectly compatible with each character in
<code>constraint</code>; or a tree of class <code>phylo</code>, all of whose nodes will occur
in any output tree.
See <code><a href="TreeTools.html#topic+ImposeConstraint">ImposeConstraint()</a></code> and
<a href="https://ms609.github.io/TreeSearch/articles/tree-search.html">vignette</a>
for further examples.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_verbosity">verbosity</code></td>
<td>
<p>Integer specifying level of messaging; higher values give
more detailed commentary on search progress. Set to <code>0</code> to run silently.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_method">method</code></td>
<td>
<p>Unambiguous abbreviation of <code>jackknife</code> or <code>bootstrap</code>
specifying how to resample characters.  Note that jackknife is considered
to give more meaningful results.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_proportion">proportion</code></td>
<td>
<p>Numeric between 0 and 1 specifying what proportion of
characters to retain under jackknife resampling.</p>
</td></tr>
<tr><td><code id="MaximizeParsimony_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code>MaximizeParsimony()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tree search commences with <code>ratchIter</code> iterations of the parsimony ratchet
(Nixon 1999), which bootstraps the input dataset
in order to escape local optima.
A final round of tree bisection and reconnection (<abbr><span class="acronym">TBR</span></abbr>)
is conducted to broaden the sampling of trees.
</p>
<p>This function can be called using the R command line / terminal, or through
the &quot;shiny&quot; graphical user interface app (type <code>EasyTrees()</code> to launch).
</p>
<p>For detailed documentation of the &quot;TreeSearch&quot; package, including full
instructions for loading phylogenetic data into R and initiating and
configuring tree search, see the
<a href="https://ms609.github.io/TreeSearch/">package documentation</a>.
</p>


<h3>Value</h3>

<p><code>MaximizeParsimony()</code> returns a list of trees with class
<code>multiPhylo</code>. This lists all trees found during each search step that
are within <code>tolerance</code> of the optimal score, listed in the sequence that
they were first visited, and named according to the step in which they were
first found; it may contain more than <code>maxHits</code> elements.
Note that the default search parameters may need to be increased in order for
these trees to be the globally optimal trees; examine the messages printed
during tree search to evaluate whether the optimal score has stabilized.
</p>
<p>The return value has the attribute <code>firstHit</code>, a named integer vector listing
the number of optimal trees visited for the first time in each stage of
the tree search. Stages are named:
</p>

<ul>
<li> <p><code>seed</code>: starting trees;
</p>
</li>
<li> <p><code>start</code>: Initial TBR search;
</p>
</li>
<li> <p><code>ratchN</code>: Ratchet iteration <code>N</code>;
</p>
</li>
<li> <p><code>final</code>: Final TBR search.
The first tree hit for the first time in ratchet iteration three is named
<code>ratch3_1</code>.
</p>
</li></ul>

<p><code>Resample()</code> returns a <code>multiPhylo</code> object containing a list of
trees obtained by tree search using a resampled version of <code>dataset</code>.
</p>


<h3>Resampling</h3>

<p>Note that bootstrap support is a measure of the amount of data supporting
a split, rather than the amount of confidence that should be afforded the
grouping.
&quot;Bootstrap support of 100% is not enough, the tree must also be correct&quot;
(Phillips et al. 2004).
See discussion in Egan (2006);
Wagele et al. (2009);
(Simmons and Freudenstein 2011);
Kumar et al. (2012).
</p>
<p>For a discussion of suitable search parameters in resampling estimates, see
Muller (2005).
The user should decide whether to start each resampling
from the optimal tree (which may be quicker, but result in overestimated
support values as searches get stuck in local optima close to the
optimal tree) or a random tree (which may take longer as more rearrangements
are necessary to find an optimal tree on each iteration).
</p>
<p>For other ways to estimate clade concordance, see <code><a href="#topic+SiteConcordance">SiteConcordance()</a></code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Brazeau MD, Guillerme T, Smith MR (2019).
&ldquo;An algorithm for morphological phylogenetic analysis with inapplicable data.&rdquo;
<em>Systematic Biology</em>, <b>68</b>(4), 619&ndash;631.
<a href="https://doi.org/10.1093/sysbio/syy083">doi:10.1093/sysbio/syy083</a>.<br /><br /> Brazeau MD, Smith MR, Guillerme T (2017).
&ldquo;MorphyLib: a library for phylogenetic analysis of categorical trait data with inapplicability.&rdquo;
<a href="https://doi.org/10.5281/zenodo.815372">doi:10.5281/zenodo.815372</a>.<br /><br /> Egan MG (2006).
&ldquo;Support versus corroboration.&rdquo;
<em>Journal of Biomedical Informatics</em>, <b>39</b>(1), 72&ndash;85.
<a href="https://doi.org/10.1016/j.jbi.2005.11.007">doi:10.1016/j.jbi.2005.11.007</a>.<br /><br /> Faith DP, Trueman JWH (2001).
&ldquo;Towards an inclusive philosophy for phylogenetic inference.&rdquo;
<em>Systematic Biology</em>, <b>50</b>(3), 331&ndash;350.
<a href="https://doi.org/10.1080/10635150118627">doi:10.1080/10635150118627</a>.<br /><br /> Goloboff PA, Arias JS (2019).
&ldquo;Likelihood approximations of implied weights parsimony can be selected over the Mk model by the Akaike information criterion.&rdquo;
<em>Cladistics</em>, <b>35</b>(6), 695&ndash;716.
<a href="https://doi.org/10.1111/cla.12380">doi:10.1111/cla.12380</a>.<br /><br /> Goloboff PA, Carpenter JM, Arias JS, Esquivel DRM (2008).
&ldquo;Weighting against homoplasy improves phylogenetic analysis of morphological data sets.&rdquo;
<em>Cladistics</em>, <b>24</b>(5), 758&ndash;773.
<a href="https://doi.org/10.1111/j.1096-0031.2008.00209.x">doi:10.1111/j.1096-0031.2008.00209.x</a>.<br /><br /> Goloboff PA, Torres A, Arias JS (2018).
&ldquo;Weighted parsimony outperforms other methods of phylogenetic inference under models appropriate for morphology.&rdquo;
<em>Cladistics</em>, <b>34</b>(4), 407&ndash;437.
<a href="https://doi.org/10.1111/cla.12205">doi:10.1111/cla.12205</a>.<br /><br /> Kumar S, Filipski AJ, Battistuzzi FU, Kosakovsky Pond SL, Tamura K (2012).
&ldquo;Statistics and truth in phylogenomics.&rdquo;
<em>Molecular Biology and Evolution</em>, <b>29</b>(2), 457&ndash;472.
<a href="https://doi.org/10.1093/molbev/msr202">doi:10.1093/molbev/msr202</a>.<br /><br /> Maddison WP (1993).
&ldquo;Missing data versus missing characters in phylogenetic analysis.&rdquo;
<em>Systematic Biology</em>, <b>42</b>(4), 576&ndash;581.
<a href="https://doi.org/10.1093/sysbio/42.4.576">doi:10.1093/sysbio/42.4.576</a>.<br /><br /> Muller KF (2005).
&ldquo;The efficiency of different search strategies in estimating parsimony jackknife, bootstrap, and Bremer support.&rdquo;
<em>BMC Evolutionary Biology</em>, <b>5</b>(1), 58.
<a href="https://doi.org/10.1186/1471-2148-5-58">doi:10.1186/1471-2148-5-58</a>.<br /><br /> Nixon KC (1999).
&ldquo;The Parsimony Ratchet, a new method for rapid parsimony analysis.&rdquo;
<em>Cladistics</em>, <b>15</b>(4), 407&ndash;414.
ISSN 0748-3007, <a href="https://doi.org/10.1111/j.1096-0031.1999.tb00277.x">doi:10.1111/j.1096-0031.1999.tb00277.x</a>.<br /><br /> Phillips MJ, Delsuc F, Penny D (2004).
&ldquo;Genome-scale phylogeny and the detection of systematic biases.&rdquo;
<em>Molecular biology and evolution</em>, <b>21</b>(7), 1455&ndash;8.
<a href="https://doi.org/10.1093/molbev/msh137">doi:10.1093/molbev/msh137</a>.<br /><br /> Simmons MP, Freudenstein JV (2011).
&ldquo;Spurious 99% bootstrap and jackknife support for unsupported clades.&rdquo;
<em>Molecular Phylogenetics and Evolution</em>, <b>61</b>(1), 177&ndash;191.
<a href="https://doi.org/10.1016/j.ympev.2011.06.003">doi:10.1016/j.ympev.2011.06.003</a>.<br /><br /> Smith MR (2019).
&ldquo;Bayesian and parsimony approaches reconstruct informative trees from simulated morphological datasets.&rdquo;
<em>Biology Letters</em>, <b>15</b>(2), 20180632.
<a href="https://doi.org/10.1098/rsbl.2018.0632">doi:10.1098/rsbl.2018.0632</a>.<br /><br /> Wagele JW, Letsch H, Klussmann-Kolb A, Mayer C, Misof B, Wagele H (2009).
&ldquo;Phylogenetic support values are not necessarily informative: the case of the Serialia hypothesis (a mollusk phylogeny).&rdquo;
<em>Frontiers in Zoology</em>, <b>6</b>(1), 12&ndash;29.
<a href="https://doi.org/10.1186/1742-9994-6-12">doi:10.1186/1742-9994-6-12</a>.
</p>


<h3>See Also</h3>

<p>Tree search <em>via</em> graphical user interface: <code><a href="#topic+EasyTrees">EasyTrees()</a></code>
</p>
<p>Other split support functions: 
<code><a href="#topic+JackLabels">JackLabels</a>()</code>,
<code><a href="#topic+Jackknife">Jackknife</a>()</code>,
<code><a href="#topic+SiteConcordance">SiteConcordance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {
  # launch "shiny" point-and-click interface
  EasyTrees()
  
  # Here too, use the "continue search" function to ensure that tree score
  # has stabilized and a global optimum has been found
}


# Load data for analysis in R
library("TreeTools")
data("congreveLamsdellMatrices", package = "TreeSearch")
dataset &lt;- congreveLamsdellMatrices[[42]]

# A very quick run for demonstration purposes
trees &lt;- MaximizeParsimony(dataset, ratchIter = 0, startIter = 0,
                           tbrIter = 1, maxHits = 4, maxTime = 1/100,
                           concavity = 10, verbosity = 4)
names(trees)

# In actual use, be sure to check that the score has converged on a global
# optimum, conducting additional iterations and runs as necessary.
 
if (interactive()) {
# Jackknife resampling
nReplicates &lt;- 10
jackTrees &lt;- replicate(nReplicates,
  #c() ensures that each replicate returns a list of trees
  c(Resample(dataset, trees, ratchIter = 0, tbrIter = 2, startIter = 1,
             maxHits = 5, maxTime = 1 / 10,
             concavity = 10, verbosity = 0))
 )

# In a serious analysis, more replicates would be conducted, and each
# search would undergo more iterations.

# Now we must decide what to do with the multiple optimal trees from
# each replicate.

# Treat each tree equally
JackLabels(ape::consensus(trees), unlist(jackTrees, recursive = FALSE))

# Take the strict consensus of all trees for each replicate
JackLabels(ape::consensus(trees), lapply(jackTrees, ape::consensus))

# Take a single tree from each replicate (the first; order's irrelevant)
JackLabels(ape::consensus(trees), lapply(jackTrees, `[[`, 1))
}

# Tree search with a constraint
constraint &lt;- MatrixToPhyDat(c(a = 1, b = 1, c = 0, d = 0, e = 0, f = 0))
characters &lt;- MatrixToPhyDat(matrix(
  c(0, 1, 1, 1, 0, 0,
    1, 1, 1, 0, 0, 0), ncol = 2,
  dimnames = list(letters[1:6], NULL)))
MaximizeParsimony(characters, constraint = constraint, verbosity = 0)

</code></pre>

<hr>
<h2 id='MinimumLength'>Minimum and Maximum lengths possible for a character</h2><span id='topic+MinimumLength'></span><span id='topic+MinimumLength.phyDat'></span><span id='topic+MinimumLength.numeric'></span><span id='topic+MinimumLength.character'></span><span id='topic+MaximumLength.character'></span><span id='topic+MinimumSteps'></span><span id='topic+MaximumLength'></span><span id='topic+MaximumLength.numeric'></span>

<h3>Description</h3>

<p>The smallest and largest length that a phylogenetic character can attain on
any tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinimumLength(x, compress = FALSE)

## S3 method for class 'phyDat'
MinimumLength(x, compress = FALSE)

## S3 method for class 'numeric'
MinimumLength(x, compress = NA)

## S3 method for class 'character'
MinimumLength(x, compress = TRUE)

## S3 method for class 'character'
MaximumLength(x, compress = TRUE)

MinimumSteps(x)

MaximumLength(x, compress = TRUE)

## S3 method for class 'numeric'
MaximumLength(x, compress = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinimumLength_+3A_x">x</code></td>
<td>
<p>An object of class <code>phyDat</code>;
or a string to be coerced to a <code>phyDat</code> object via
<code><a href="TreeTools.html#topic+PhyToString">TreeTools::StringToPhyDat()</a></code>;
or an integer vector listing the tokens that may be present at each
tip along a single character, with each token represented as a binary digit;
e.g. a value of 11 ( = 2^0 + 2^1 + 2^3) means that
the tip may have tokens 0, 1 or 3.
</p>
<p>Inapplicable tokens should be denoted with the integer <code>0</code> (not 2^0).</p>
</td></tr>
<tr><td><code id="MinimumLength_+3A_compress">compress</code></td>
<td>
<p>Logical specifying whether to retain the compression of a
<code>phyDat</code> object or to return a vector specifying to each individual
character, decompressed using the dataset's <code>index</code> attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ambiguous inapplicables (e.g. <code style="white-space: pre;">&#8288;{0, -}&#8288;</code>) are currently replaced with the
plain inapplicable token <code>-</code>, reflecting the current behaviour of Morphy.
</p>


<h3>Value</h3>

<p><code>MinimumLength()</code> returns a vector of integers specifying the
minimum number of steps that each character must contain.
</p>
<p><code>MaximumLength()</code> returns a vector of integers specifying the
maximum number of steps that each character can attain in a parsimonious
reconstruction on a tree.  Inapplicable tokens are not yet supported.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other tree scoring: 
<code><a href="#topic+CharacterLength">CharacterLength</a>()</code>,
<code><a href="#topic+IWScore">IWScore</a>()</code>,
<code><a href="#topic+LengthAdded">LengthAdded</a>()</code>,
<code><a href="#topic+MorphyTreeLength">MorphyTreeLength</a>()</code>,
<code><a href="#topic+TaxonInfluence">TaxonInfluence</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("inapplicable.datasets")
myPhyDat &lt;- inapplicable.phyData[[4]]

# load your own data with
# my.PhyDat &lt;- as.phyDat(read.nexus.data("filepath"))
# or Windows users can select a file interactively using:
# my.PhyDat &lt;- as.phyDat(read.nexus.data(choose.files()))

class(myPhyDat) # phyDat object

# Minimum length of each character in turn
MinimumLength(myPhyDat)

# Collapse duplicate characters, per phyDat compression
MinimumLength(myPhyDat, compress = TRUE)

# Calculate length of a single character from its textual representation
MinimumLength("-{-1}{-2}{-3}2233")
MaximumLength("----0011")
</code></pre>

<hr>
<h2 id='MorphyBootstrap'>Parsimony Ratchet</h2><span id='topic+MorphyBootstrap'></span><span id='topic+Ratchet'></span><span id='topic+MultiRatchet'></span><span id='topic+RatchetConsensus'></span>

<h3>Description</h3>

<p><code>Ratchet()</code> uses the parsimony ratchet (Nixon 1999)
to search for a more parsimonious tree using custom optimality criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MorphyBootstrap(
  edgeList,
  morphyObj,
  EdgeSwapper = NNISwap,
  maxIter,
  maxHits,
  verbosity = 1L,
  stopAtPeak = FALSE,
  stopAtPlateau = 0L,
  ...
)

Ratchet(
  tree,
  dataset,
  InitializeData = PhyDat2Morphy,
  CleanUpData = UnloadMorphy,
  TreeScorer = MorphyLength,
  Bootstrapper = MorphyBootstrap,
  swappers = list(TBRSwap, SPRSwap, NNISwap),
  BootstrapSwapper = if (is.list(swappers)) swappers[[length(swappers)]] else swappers,
  returnAll = FALSE,
  stopAtScore = NULL,
  stopAtPeak = FALSE,
  stopAtPlateau = 0L,
  ratchIter = 100,
  ratchHits = 10,
  searchIter = 4000,
  searchHits = 42,
  bootstrapIter = searchIter,
  bootstrapHits = searchHits,
  verbosity = 1L,
  suboptimal = sqrt(.Machine[["double.eps"]]),
  ...
)

MultiRatchet(
  tree,
  dataset,
  ratchHits = 10,
  searchIter = 500,
  searchHits = 20,
  verbosity = 0L,
  swappers = list(RootedNNISwap),
  nSearch = 10,
  stopAtScore = NULL,
  ...
)

RatchetConsensus(
  tree,
  dataset,
  ratchHits = 10,
  searchIter = 500,
  searchHits = 20,
  verbosity = 0L,
  swappers = list(RootedNNISwap),
  nSearch = 10,
  stopAtScore = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MorphyBootstrap_+3A_edgelist">edgeList</code></td>
<td>
<p>a list containing the following:
- vector of integers corresponding to the parent of each edge in turn
- vector of integers corresponding to the child of each edge in turn
- (optionally) score of the tree
- (optionally, if score provided) number of times this score has been hit</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_morphyobj">morphyObj</code></td>
<td>
<p>Object of class <code>morphy</code>, perhaps created with
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy()</a></code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_edgeswapper">EdgeSwapper</code></td>
<td>
<p>a function that rearranges a parent and child vector,
and returns a list with modified vectors; for example <code><a href="#topic+SPRSwap">SPRSwap()</a></code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_maxiter">maxIter</code></td>
<td>
<p>Numeric specifying maximum number of iterations to perform in
tree search.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_maxhits">maxHits</code></td>
<td>
<p>Numeric specifying maximum number of hits to accomplish in
tree search.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_verbosity">verbosity</code></td>
<td>
<p>Numeric specifying level of detail to display in console:
larger numbers provide more verbose feedback to the user.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_stopatpeak">stopAtPeak</code></td>
<td>
<p>Logical specifying whether to terminate search once a
subsequent iteration recovers a sub-optimal score.
Will be overridden if a passed function has an attribute <code>stopAtPeak</code> set by
<code>attr(FunctionName, "stopAtPeak") &lt;- TRUE</code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_stopatplateau">stopAtPlateau</code></td>
<td>
<p>Integer. If &gt; 0, tree search will terminate if the score
has not improved after <code>stopAtPlateau</code> iterations.
Will be overridden if a passed function has an attribute <code>stopAtPlateau</code> set
by <code>attr(FunctionName, "stopAtPlateau") &lt;- TRUE</code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>TreeScorer()</code>, e.g. <code style="white-space: pre;">&#8288;dataset = &#8288;</code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_dataset">dataset</code></td>
<td>
<p>a dataset in the format required by <code>TreeScorer()</code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_initializedata">InitializeData</code></td>
<td>
<p>Function that sets up data object to prepare for tree search.
The function will be passed the <code>dataset</code> parameter.
Its return value will be passed to <code>TreeScorer()</code> and <code>CleanUpData()</code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_cleanupdata">CleanUpData</code></td>
<td>
<p>Function to destroy data object on function exit.
The function will be passed the value returned by <code>InitializeData()</code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_treescorer">TreeScorer</code></td>
<td>
<p>function to score a given tree.
The function will be passed three parameters, corresponding to the
<code>parent</code> and <code>child</code> entries of a tree's edge list, and a dataset.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_bootstrapper">Bootstrapper</code></td>
<td>
<p>Function to perform bootstrapped rearrangements of tree.
First arguments will be an <code>edgeList</code> and a dataset, initialized using
<code>InitializeData()</code>. Should return a rearranged <code>edgeList</code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_swappers">swappers</code></td>
<td>
<p>A list of functions to use to conduct edge rearrangement during tree search.
Provide functions like <code><a href="#topic+NNISwap">NNISwap</a></code> to shuffle root position,
or <code><a href="#topic+RootedTBRSwap">RootedTBRSwap</a></code> if the position of the root should be retained.
You may wish to use extreme swappers (such as <abbr><span class="acronym">TBR</span></abbr>) early in the list,
and a more subtle rearranger (such as <abbr><span class="acronym">NNI</span></abbr>) later in the list to make
incremental tinkerings once an almost-optimal tree has been found.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_bootstrapswapper">BootstrapSwapper</code></td>
<td>
<p>Function such as <code><a href="#topic+RootedNNISwap">RootedNNISwap</a></code> to use
to rearrange trees within <code>Bootstrapper()</code>.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_returnall">returnAll</code></td>
<td>
<p>Set to <code>TRUE</code> to report all MPTs encountered during the
search, perhaps to analyse consensus.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_stopatscore">stopAtScore</code></td>
<td>
<p>stop search as soon as this score is hit or beaten.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_ratchiter">ratchIter</code></td>
<td>
<p>Stop when this many ratchet iterations have been performed.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_ratchhits">ratchHits</code></td>
<td>
<p>Stop when this many ratchet iterations have found the same
best score.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_searchiter">searchIter</code></td>
<td>
<p>Integer specifying maximum rearrangements to perform on each bootstrap or
ratchet iteration.
To override this value for a single swapper function, set e.g.
<code>attr(SwapperFunction, "searchIter") &lt;- 99</code></p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_searchhits">searchHits</code></td>
<td>
<p>Integer specifying maximum times to hit best score before terminating a tree
search within a ratchet iteration.
To override this value for a single swapper function, set e.g.
<code>attr(SwapperFunction, "searchHits") &lt;- 99</code></p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_bootstrapiter">bootstrapIter</code></td>
<td>
<p>Integer specifying maximum rearrangements to perform on each bootstrap
iteration (default: <code>searchIter</code>).</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_bootstraphits">bootstrapHits</code></td>
<td>
<p>Integer specifying maximum times to hit best score on each bootstrap
iteration (default: <code>searchHits</code>).</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_suboptimal">suboptimal</code></td>
<td>
<p>retain trees that are suboptimal by this score.
Defaults to a small value that will counter rounding errors.</p>
</td></tr>
<tr><td><code id="MorphyBootstrap_+3A_nsearch">nSearch</code></td>
<td>
<p>Number of Ratchet searches to conduct
(for <code>RatchetConsensus()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For usage pointers, see the
<a href="https://ms609.github.io/TreeSearch/articles/custom.html">vignette</a>.
</p>


<h3>Value</h3>

<p><code>MorphyBootstrap()</code> returns a tree that is optimal under a random
sampling of the original characters.
</p>
<p><code>Ratchet()</code> returns a tree modified by parsimony ratchet iterations.
</p>
<p><code>MultiRatchet()</code> returns a list of optimal trees
produced by <code>nSearch</code>
ratchet searches, from which a consensus tree can be generated using
<code><a href="ape.html#topic+consensus">ape::consensus()</a></code> or <code><a href="TreeTools.html#topic+ConsensusWithout">TreeTools::ConsensusWithout()</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>RatchetConsensus()</code>: deprecated alias for <code>MultiRatchet()</code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Nixon KC (1999).
&ldquo;The Parsimony Ratchet, a new method for rapid parsimony analysis.&rdquo;
<em>Cladistics</em>, <b>15</b>(4), 407&ndash;414.
ISSN 0748-3007, <a href="https://doi.org/10.1111/j.1096-0031.1999.tb00277.x">doi:10.1111/j.1096-0031.1999.tb00277.x</a>.
</p>


<h3>See Also</h3>


<ul>
<li><p> Adapted from <code><a href="phangorn.html#topic+parsimony">pratchet()</a></code> in the
<span class="pkg">phangorn</span> package.
</p>
</li></ul>

<p>Other custom search functions: 
<code><a href="#topic+EdgeListSearch">EdgeListSearch</a>()</code>,
<code><a href="#topic+Jackknife">Jackknife</a>()</code>,
<code><a href="#topic+SuccessiveApproximations">SuccessiveApproximations</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lobo", package = "TreeTools")
njtree &lt;- TreeTools::NJTree(Lobo.phy)
# Increase value of ratchIter and searchHits to do a proper search
quickResult &lt;- Ratchet(njtree, Lobo.phy, ratchIter = 2, searchHits = 3)

# Plot result (legibly)
oldPar &lt;- par(mar = rep(0, 4), cex = 0.75)
plot(quickResult)
par(oldPar)
</code></pre>

<hr>
<h2 id='MorphyErrorCheck'>Check for error whilst modifying Morphy object</h2><span id='topic+MorphyErrorCheck'></span>

<h3>Description</h3>

<p>Check for error whilst modifying Morphy object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MorphyErrorCheck(action)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MorphyErrorCheck_+3A_action">action</code></td>
<td>
<p>action to perform</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='MorphyTreeLength'>Calculate parsimony score from Morphy object</h2><span id='topic+MorphyTreeLength'></span><span id='topic+MorphyLength'></span><span id='topic+GetMorphyLength'></span><span id='topic+C_MorphyLength'></span>

<h3>Description</h3>

<p>This function must be passed a valid Morphy object, or R may crash.
For most users, the function <code><a href="#topic+TreeLength">TreeLength()</a></code> will be more appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MorphyTreeLength(tree, morphyObj)

MorphyLength(
  parent,
  child,
  morphyObj,
  inPostorder = FALSE,
  nTaxa = mpl_get_numtaxa(morphyObj)
)

GetMorphyLength(parentOf, leftChild, rightChild, morphyObj)

C_MorphyLength(parentOf, leftChild, rightChild, morphyObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MorphyTreeLength_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+read.tree">phylo</a></code>, with tip labels in the order generated by
<code><a href="TreeTools.html#topic+RenumberTips">RenumberTips</a></code>, i.e. corresponding to the sequence of taxa
in the corresponding Morphy object.</p>
</td></tr>
<tr><td><code id="MorphyTreeLength_+3A_morphyobj">morphyObj</code></td>
<td>
<p>Object of class <code>morphy</code>, perhaps created with
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy()</a></code>.</p>
</td></tr>
<tr><td><code id="MorphyTreeLength_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
<tr><td><code id="MorphyTreeLength_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td></tr>
<tr><td><code id="MorphyTreeLength_+3A_parentof">parentOf</code></td>
<td>
<p>For each node, numbered in postorder, the number of its parent node.</p>
</td></tr>
<tr><td><code id="MorphyTreeLength_+3A_leftchild">leftChild</code></td>
<td>
<p>For each internal node, numbered in postorder, the number of its left
child node or tip.</p>
</td></tr>
<tr><td><code id="MorphyTreeLength_+3A_rightchild">rightChild</code></td>
<td>
<p>For each internal node, numbered in postorder, the number of its right
child node or tip.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MorphyTreeLength()</code> returns the length of the tree,
after applying weighting.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>MorphyLength()</code>: Faster function that requires internal tree
parameters. Node numbering must increase monotonically away from root.
</p>
</li>
<li> <p><code>GetMorphyLength()</code>: Fastest function that requires internal tree parameters
</p>
</li>
<li> <p><code>C_MorphyLength()</code>: Direct call to C function. Use with caution.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>


<h3>See Also</h3>

<p>PhyDat2Morphy
</p>
<p>Other tree scoring: 
<code><a href="#topic+CharacterLength">CharacterLength</a>()</code>,
<code><a href="#topic+IWScore">IWScore</a>()</code>,
<code><a href="#topic+LengthAdded">LengthAdded</a>()</code>,
<code><a href="#topic+MinimumLength">MinimumLength</a>()</code>,
<code><a href="#topic+TaxonInfluence">TaxonInfluence</a>()</code>
</p>
<p>Other tree scoring: 
<code><a href="#topic+CharacterLength">CharacterLength</a>()</code>,
<code><a href="#topic+IWScore">IWScore</a>()</code>,
<code><a href="#topic+LengthAdded">LengthAdded</a>()</code>,
<code><a href="#topic+MinimumLength">MinimumLength</a>()</code>,
<code><a href="#topic+TaxonInfluence">TaxonInfluence</a>()</code>
</p>

<hr>
<h2 id='MorphyWeights'>Set and get the character weightings associated with a Morphy object.</h2><span id='topic+MorphyWeights'></span><span id='topic+SetMorphyWeights'></span>

<h3>Description</h3>

<p><code>MorphyWeights()</code> details the approximate and exact weights associated with
characters in a <code>Morphy</code> object; <code>SetMorphyWeights()</code> edits them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MorphyWeights(morphyObj)

SetMorphyWeights(weight, morphyObj, checkInput = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MorphyWeights_+3A_morphyobj">morphyObj</code></td>
<td>
<p>Object of class <code>morphy</code>, perhaps created with
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy()</a></code>.</p>
</td></tr>
<tr><td><code id="MorphyWeights_+3A_weight">weight</code></td>
<td>
<p>A vector listing the new weights to be applied to each character</p>
</td></tr>
<tr><td><code id="MorphyWeights_+3A_checkinput">checkInput</code></td>
<td>
<p>Whether to sanity-check input data before applying.
Defaults to <code>TRUE</code> to protect the user from crashes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MorphyWeights()</code> returns a data frame with two named rows and
one column per character pattern:
row 1, <code>approx</code>, is a list of integers specifying the approximate (integral)
weights used by MorphyLib;
row 2, <code>exact</code>, is a list of numerics specifying the exact weights specified
by the user.
</p>
<p><code>SetMorphyWeights()</code> returns the Morphy error code generated when
applying <code>weight</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens &lt;- matrix(c(
  0, 0, 0, 1, 1, 2,
  0, 0, 0, 0, 0, 0), byrow = TRUE, nrow = 2L,
  dimnames = list(letters[1:2], NULL))
pd &lt;- TreeTools::MatrixToPhyDat(tokens)
morphyObj &lt;- PhyDat2Morphy(pd)
MorphyWeights(morphyObj)
if (SetMorphyWeights(c(1, 1.5, 2/3), morphyObj) != 0L) message("Errored")
MorphyWeights(morphyObj)
morphyObj &lt;- UnloadMorphy(morphyObj)
</code></pre>

<hr>
<h2 id='mpl_apply_tipdata'>Commits parameters prior to nodal set calculations.</h2><span id='topic+mpl_apply_tipdata'></span>

<h3>Description</h3>

<p>Once the caller is satisfied with the setup of types, weights,
and partitioning, this function must be called, thereby committing the
parameters until any changes are made. If no character types have been
assigned, the function will fail with an error code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_apply_tipdata(morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_apply_tipdata_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Morphy error code.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_attach_rawdata'>Attach raw character state data (i.e. tip data).</h2><span id='topic+mpl_attach_rawdata'></span>

<h3>Description</h3>

<p>Attaches a raw data character state matrix in the form of a C-style
(i.e. NULL-terminated) string. This can be the matrix block extracted from a
Nexus file or an <code>xread</code> table format.
The matrix should contain no leaf labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_attach_rawdata(rawdata, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_attach_rawdata_+3A_rawdata">rawdata</code></td>
<td>
<p>C-style string corresponding to the tip data for each taxon in
turn.</p>
</td></tr>
<tr><td><code id="mpl_attach_rawdata_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Morphy error code.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_attach_symbols'>Attach a caller-specified list of symbols.</h2><span id='topic+mpl_attach_symbols'></span>

<h3>Description</h3>

<p>Allows the caller to specify a list of symbols in the data matrix,
otherwise, the symbols list used by Morphy will be extracted from the matrix.
The symbols list must match the symbols provided in the matrix. When Morphy
extracts symbols from the matrix, their ordering is alphanumeric, according to
their ASCII codes (i.e. &quot;+0123...ABCD...abcd...&quot;). Loading a user-specified
symbols list will override this ordering. Symbols loaded in either the list or
the matrix must be valid Morphy character state symbols as defined in the
statedata.h header file.  The list must end with a semicolon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_attach_symbols(symbols, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_attach_symbols_+3A_symbols">symbols</code></td>
<td>
<p>A C-style (i.e. NULL-terminated) string of valid state symbols.</p>
</td></tr>
<tr><td><code id="mpl_attach_symbols_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Morphy error code.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_delete_Morphy'>Destroys an instance of a Morphy object.</h2><span id='topic+mpl_delete_Morphy'></span>

<h3>Description</h3>

<p>Destroys an instance of the Morphy object, calling all
destructor for internal object completely returning the memory to the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_delete_Morphy(morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_delete_Morphy_+3A_morphyobj">morphyobj</code></td>
<td>
<p>A Morphy object to be destroyed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Morphy error code.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_delete_rawdata'>Deletes the caller-input data.</h2><span id='topic+mpl_delete_rawdata'></span>

<h3>Description</h3>

<p>Deletes all of the user-input data and restores all parameters
to their original values, except for the dimensions of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_delete_rawdata(morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_delete_rawdata_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Morphy error code.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_first_down_recon'>Reconstructs the first (downpass) nodal reconstructions</h2><span id='topic+mpl_first_down_recon'></span>

<h3>Description</h3>

<p>Reconstructs the preliminary nodal set for all characters for a
particular node. This function is called over a postorder sequence of internal
nodes where left and right descendants are known.
Because this function needs to be fairly high-performance, it does not do much
checking for parameter validity, thus unsafe usage of this function might not
be caught. It is up to calling functions to ensure that the appropriate
parameters have been set before use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_first_down_recon(node_id, left_id, right_id, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_first_down_recon_+3A_node_id">node_id</code></td>
<td>
<p>The index of the node being reconstructed.</p>
</td></tr>
<tr><td><code id="mpl_first_down_recon_+3A_left_id">left_id</code></td>
<td>
<p>The index of the left descendant.</p>
</td></tr>
<tr><td><code id="mpl_first_down_recon_+3A_right_id">right_id</code></td>
<td>
<p>The index of the right descendant.</p>
</td></tr>
<tr><td><code id="mpl_first_down_recon_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integral parsimony length (right now)
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_first_up_recon'>Reconstructs the second (uppass) nodal reconstructions.</h2><span id='topic+mpl_first_up_recon'></span>

<h3>Description</h3>

<p>Reconstructs second-pass nodal sets. For normal (all-applicable)
characters, this is the final pass. This function is called over a preorder
sequence of nodes where left, right, and ancestral nodes are known.
Because this function needs to be fairly high-performance, it does not do much
checking for parameter validity, thus unsafe usage of this function might not
be caught. It is up to calling functions to ensure that the appropriate
parameters have been set before use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_first_up_recon(node_id, left_id, right_id, anc_id, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_first_up_recon_+3A_node_id">node_id</code></td>
<td>
<p>The index of the node being reconstructed.</p>
</td></tr>
<tr><td><code id="mpl_first_up_recon_+3A_left_id">left_id</code></td>
<td>
<p>The index of the left descendant.</p>
</td></tr>
<tr><td><code id="mpl_first_up_recon_+3A_right_id">right_id</code></td>
<td>
<p>The index of the right descendant.</p>
</td></tr>
<tr><td><code id="mpl_first_up_recon_+3A_anc_id">anc_id</code></td>
<td>
<p>The index of the immediate ancestor of the node.</p>
</td></tr>
<tr><td><code id="mpl_first_up_recon_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A null value (for now).
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_get_charac_weight'>Retrieve the weight of a character in the dataset</h2><span id='topic+mpl_get_charac_weight'></span>

<h3>Description</h3>

<p>Gets the weights of a character in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_get_charac_weight(charID, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_get_charac_weight_+3A_charid">charID</code></td>
<td>
<p>Number of the character (i.e. first character is number 1)</p>
</td></tr>
<tr><td><code id="mpl_get_charac_weight_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, detailing (item 1) the exact weight of the character; (item 2) the integer
approximation used by Morphy.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_get_gaphandl'>Get / set gap handler from a Morphy object.</h2><span id='topic+mpl_get_gaphandl'></span><span id='topic+mpl_set_gaphandl'></span>

<h3>Description</h3>

<p>0 = inapplicable; 1 = missing; 2 = extra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_get_gaphandl(morphyobj)

mpl_set_gaphandl(handl, morphyobj)
</code></pre>


<h3>Value</h3>

<p><code>mpl_get_gaphandl()</code> returns an integer corresponding to the gap
handling approach.
</p>
<p><code>mpl_set_gaphandl()</code> returns a Morphy error code.
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_get_num_charac'>Retrieve the number of character (columns) in the dataset.</h2><span id='topic+mpl_get_num_charac'></span>

<h3>Description</h3>

<p>Retrieves the number of character (columns) in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_get_num_charac(morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_get_num_charac_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of internal nodes.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_get_num_internal_nodes'>Gets the number of internal nodal reconstruction sets being used by
MorphyLib.</h2><span id='topic+mpl_get_num_internal_nodes'></span>

<h3>Description</h3>

<p>Gets the number of internal nodal reconstruction sets being used
by MorphyLib.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_get_num_internal_nodes(morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_get_num_internal_nodes_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of internal nodes.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_get_numtaxa'>Retrieve the number of taxa (rows) in the dataset.</h2><span id='topic+mpl_get_numtaxa'></span>

<h3>Description</h3>

<p>Retrieves the number of taxa (rows) in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_get_numtaxa(morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_get_numtaxa_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of taxa if success, otherwise an error code.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_get_symbols'>Retrieves the current list of symbols.</h2><span id='topic+mpl_get_symbols'></span>

<h3>Description</h3>

<p>Returns a pointer to the string of character state symbols
currently being used by Morphy (i.e. either the list of symbols extracted
from the matrix, or the caller-specified values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_get_symbols(morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_get_symbols_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A C-style (null-terminated) string of the character state symbols
being used. NULL if failure.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_init_Morphy'>Sets up the dimensions of the dataset.</h2><span id='topic+mpl_init_Morphy'></span>

<h3>Description</h3>

<p>Provides initial dimensions for the dataset, which will
constrain any input matrix supplied to Morphy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_init_Morphy(numtaxa, numchars, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_init_Morphy_+3A_numtaxa">numtaxa</code></td>
<td>
<p>The number of taxa (or tips/terminals).</p>
</td></tr>
<tr><td><code id="mpl_init_Morphy_+3A_numchars">numchars</code></td>
<td>
<p>The number of characters (i.e. transformation series) in the
data set.</p>
</td></tr>
<tr><td><code id="mpl_init_Morphy_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Morphy error code.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_new_Morphy'>Creates a new instance of a Morphy object</h2><span id='topic+mpl_new_Morphy'></span>

<h3>Description</h3>

<p>Creates a new empty Morphy object. All fields are unpopulated
and uninitialised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_new_Morphy()
</code></pre>


<h3>Value</h3>

<p>A void pointer to the Morphy instance. NULL if unsuccessful.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>morphyObj &lt;- mpl_new_Morphy() # Create new object
## Do some stuff ... ##
mpl_delete_Morphy(morphyObj) # Delete when done

</code></pre>

<hr>
<h2 id='mpl_second_down_recon'>Performs the second nodal reconstructions for characters with
inapplicability.</h2><span id='topic+mpl_second_down_recon'></span>

<h3>Description</h3>

<p>Updates the nodal sets that had ambiguous unions with the
inapplicable state and calculates steps involving applicable states after
the update.
Because this function needs to be fairly high-performance, it does not do much
checking for parameter validity, thus unsafe usage of this function might not
be caught. It is up to calling functions to ensure that the appropriate
parameters have been set before use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_second_down_recon(node_id, left_id, right_id, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_second_down_recon_+3A_node_id">node_id</code></td>
<td>
<p>The index of the node being reconstructed.</p>
</td></tr>
<tr><td><code id="mpl_second_down_recon_+3A_left_id">left_id</code></td>
<td>
<p>The index of the left descendant.</p>
</td></tr>
<tr><td><code id="mpl_second_down_recon_+3A_right_id">right_id</code></td>
<td>
<p>The index of the right descendant.</p>
</td></tr>
<tr><td><code id="mpl_second_down_recon_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integral parsimony length (right now)
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_second_up_recon'>Finalises the ancestral state reconstructions for characters with
inapplicable values.</h2><span id='topic+mpl_second_up_recon'></span>

<h3>Description</h3>

<p>Finalises the nodal sets for any characters that may have involved
the inapplicable token and counts excess regions of applicability at nodes
having at least two descendant subtrees that possess any applicable characters.
Because this function needs to be fairly high-performance, it does not do much
checking for parameter validity, thus unsafe usage of this function might not
be caught. It is up to calling functions to ensure that the appropriate
parameters have been set before use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_second_up_recon(node_id, left_id, right_id, anc_id, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_second_up_recon_+3A_node_id">node_id</code></td>
<td>
<p>The index of the node being reconstructed.</p>
</td></tr>
<tr><td><code id="mpl_second_up_recon_+3A_left_id">left_id</code></td>
<td>
<p>The index of the left descendant.</p>
</td></tr>
<tr><td><code id="mpl_second_up_recon_+3A_right_id">right_id</code></td>
<td>
<p>The index of the right descendant.</p>
</td></tr>
<tr><td><code id="mpl_second_up_recon_+3A_anc_id">anc_id</code></td>
<td>
<p>The index of the immediate ancestor of the node.</p>
</td></tr>
<tr><td><code id="mpl_second_up_recon_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integral parsimony length (right now)
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_set_charac_weight'>Set the weight of a character in the dataset</h2><span id='topic+mpl_set_charac_weight'></span>

<h3>Description</h3>

<p>Sets the weight of a character in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_set_charac_weight(charID, weight, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_set_charac_weight_+3A_charid">charID</code></td>
<td>
<p>Number of the character (i.e. first character is number 1)</p>
</td></tr>
<tr><td><code id="mpl_set_charac_weight_+3A_weight">weight</code></td>
<td>
<p>Weight to assign</p>
</td></tr>
<tr><td><code id="mpl_set_charac_weight_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error code.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_set_num_internal_nodes'>Sets the number of internal nodes in the dataset</h2><span id='topic+mpl_set_num_internal_nodes'></span>

<h3>Description</h3>

<p>This specifies the number of internal nodes over which
reconstruction sets need to be made. It is up to the caller to ensure the
correct number of nodes and the relationships between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_set_num_internal_nodes(numnodes, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_set_num_internal_nodes_+3A_numnodes">numnodes</code></td>
<td>
<p>The desired number of internal nodes.</p>
</td></tr>
<tr><td><code id="mpl_set_num_internal_nodes_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Morphy error code.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_set_parsim_t'>Sets a character's parsimony function type</h2><span id='topic+mpl_set_parsim_t'></span>

<h3>Description</h3>

<p>Set the parsimony function type to one defined in the
morphydefs.h header file. Setting the character to type NONE_T will also
cause it to be excluded from any further calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_set_parsim_t(char_id, tname = "typename", morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_set_parsim_t_+3A_char_id">char_id</code></td>
<td>
<p>The number of the character (transformation series) as defined
in the input matrix.  The first character is numbered 1 (one).</p>
</td></tr>
<tr><td><code id="mpl_set_parsim_t_+3A_tname">tname</code></td>
<td>
<p>The parsimony function type as defined in morphydefs.h</p>
</td></tr>
<tr><td><code id="mpl_set_parsim_t_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Morphy error code.
</p>


<h3>Author(s)</h3>

<p>Martin Brazeau
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_translate_error'>Converts a numeric error code to human-readable format</h2><span id='topic+mpl_translate_error'></span>

<h3>Description</h3>

<p>Converts a numeric error code to human-readable format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_translate_error(errorCode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_translate_error_+3A_errorcode">errorCode</code></td>
<td>
<p>Non-positive integer to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string corresponding to the provided error code
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mpl_translate_error(-1) # "ERR_INVALID_SYMBOL"

</code></pre>

<hr>
<h2 id='mpl_update_lower_root'>Updates the nodal sets for a lower (&quot;dummy&quot;) root node</h2><span id='topic+mpl_update_lower_root'></span>

<h3>Description</h3>

<p>If trees are rooted, then Morphy uppass functions
require a lower or &quot;dummy&quot; root in order to function properly. This
function should be called to set the nodal state sets to the dummy
root. The nodal set will be equal to the set of the root node, unless
there is an ambiguous union of applicable and gap tokens when gaps are
treated as in applicable. In which case, the set union is resolved in
favour of any applicable tokens in the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_update_lower_root(l_root_id, root_id, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_update_lower_root_+3A_l_root_id">l_root_id</code></td>
<td>
<p>The index of the lower root.</p>
</td></tr>
<tr><td><code id="mpl_update_lower_root_+3A_root_id">root_id</code></td>
<td>
<p>The index of the upper root node.</p>
</td></tr>
<tr><td><code id="mpl_update_lower_root_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Morphy error code.
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='mpl_update_tip'>Initial update of tip values following uppass reconstruction.</h2><span id='topic+mpl_update_tip'></span>

<h3>Description</h3>

<p>Ambiguous terminal state sets need to be resolved after the first uppass
based on descendant state values in order for local reoptimisation procedures
to be accurate and for inapplicable step counting to proceed accurately. This
function calls updaters for the records of states active on the subtrees,
thereby allowing the second downpass to accurately reconstruct subtree state
activity.
Because this function needs to be fairly high-performance, it does not do much
checking for parameter validity, thus unsafe usage of this function might not
be caught. It is up to calling functions to ensure that the appropriate
parameters have been set before use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpl_update_tip(tip_id, anc_id, morphyobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpl_update_tip_+3A_tip_id">tip_id</code></td>
<td>
<p>The index of the tip being updated.</p>
</td></tr>
<tr><td><code id="mpl_update_tip_+3A_anc_id">anc_id</code></td>
<td>
<p>The index of the tip's immediate ancestor.</p>
</td></tr>
<tr><td><code id="mpl_update_tip_+3A_morphyobj">morphyobj</code></td>
<td>
<p>An instance of the Morphy object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integral parsimony length (right now)
</p>


<h3>Author(s)</h3>

<p>Thomas Guillerme
</p>


<h3>See Also</h3>

<p>A null value (for now).
</p>
<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='NNI'>Nearest neighbour interchange (NNI)</h2><span id='topic+NNI'></span><span id='topic+cNNI'></span><span id='topic+NNISwap'></span><span id='topic+RootedNNI'></span><span id='topic+RootedNNISwap'></span>

<h3>Description</h3>

<p><code>NNI()</code>performs a single iteration of the nearest-neighbour interchange
algorithm; <code>RootedNNI()</code> retains the position of the root.
These functions are based on equivalents in the <span class="pkg">phangorn</span> package.
<code>cNNI()</code> is an equivalent function coded in C, that runs much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNI(tree, edgeToBreak = NULL)

cNNI(tree, edgeToBreak = NULL, whichSwitch = NULL)

NNISwap(parent, child, nTips = (length(parent)/2L) + 1L, edgeToBreak = NULL)

RootedNNI(tree, edgeToBreak = NULL)

RootedNNISwap(
  parent,
  child,
  nTips = (length(parent)/2L) + 1L,
  edgeToBreak = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNI_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="NNI_+3A_edgetobreak">edgeToBreak</code></td>
<td>
<p>In (<code>Rooted</code>)<code>NNI()</code>, an optional integer specifying the
index of an edge to bisect/prune, generated randomly if not specified.
If <code>-1</code>, a complete list of all trees one step from the input tree
will be returned.
In <code>cNNI()</code>, an integer from zero to <code>nEdge(tree) - nTip(tree) - 2</code>,
specifying which internal edge to break.</p>
</td></tr>
<tr><td><code id="NNI_+3A_whichswitch">whichSwitch</code></td>
<td>
<p>Integer from zero to one, specifying which way to re-build
the broken internal edge.</p>
</td></tr>
<tr><td><code id="NNI_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
<tr><td><code id="NNI_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td></tr>
<tr><td><code id="NNI_+3A_ntips">nTips</code></td>
<td>
<p>(optional) Number of tips.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Branch lengths are not supported.
</p>
<p>All nodes in a tree must be bifurcating; <code><a href="ape.html#topic+collapse.singles">ape::collapse.singles()</a></code> and
<code><a href="ape.html#topic+multi2di">ape::multi2di()</a></code> may help.
</p>


<h3>Value</h3>

<p>Returns a tree with class <code>phylo</code> (if <code>returnAll = FALSE</code>) or
a set of trees, with class <code>multiPhylo</code> (if <code>returnAll = TRUE</code>).
</p>
<p><code>cNNI()</code> returns a tree of class <code>phylo</code>, rooted on the same leaf,
on which the specified rearrangement has been conducted.
</p>
<p><code>NNISwap()</code> returns a list containing two elements, corresponding in
turn to the  rearranged parent and child parameters.
</p>
<p>a list containing two elements, corresponding in turn to the rearranged parent and child parameters
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>NNISwap()</code>: faster version that takes and returns parent and child parameters
</p>
</li>
<li> <p><code>RootedNNI()</code>: Perform <abbr><span class="acronym">NNI</span></abbr> rearrangement, retaining position of root
</p>
</li>
<li> <p><code>RootedNNISwap()</code>: faster version that takes and returns parent and child parameters
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>The algorithm is summarized in
Felsenstein J (2004).
<em>Inferring phylogenies</em>.
Sinauer Associates, Sunderland, Massachusetts.
</p>


<h3>See Also</h3>

<p>Other tree rearrangement functions: 
<code><a href="#topic+SPR">SPR</a>()</code>,
<code><a href="#topic+TBR">TBR</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- TreeTools::BalancedTree(8)
# A random rearrangement
NNI(tree)
cNNI(tree)

# All trees one NNI rearrangement away
NNI(tree, edgeToBreak = -1)

# Manual random sampling
cNNI(tree, sample.int(14 - 8 - 1, 1), sample.int(2, 1))

# A specified rearrangement
cNNI(tree, 0, 0)

# If a tree may not be binary, collapse nodes with
tree &lt;- TreeTools::MakeTreeBinary(tree)

# If a tree may be improperly rooted, use
tree &lt;- TreeTools::RootTree(tree, 1)

# If a tree may exhibit unusual node ordering, this can be addressed with
tree &lt;- TreeTools::Preorder(tree)
</code></pre>

<hr>
<h2 id='PhyDat2Morphy'>Initialize a Morphy object from a <code>phyDat</code> object</h2><span id='topic+PhyDat2Morphy'></span>

<h3>Description</h3>

<p>Creates a new Morphy object with the same size and characters as the
<code>phyDat</code> object.
Once finished with the object, it should be destroyed using
<code><a href="#topic+UnloadMorphy">UnloadMorphy()</a></code> to free the allocated memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhyDat2Morphy(phy, gap = "inapplicable")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhyDat2Morphy_+3A_phy">phy</code></td>
<td>
<p>An object of <span class="pkg">phangorn</span> class <code>phyDat</code>.</p>
</td></tr>
<tr><td><code id="PhyDat2Morphy_+3A_gap">gap</code></td>
<td>
<p>An unambiguous abbreviation of <code>inapplicable</code>, <code>ambiguous</code>
(= <code>missing</code>), or <code style="white-space: pre;">&#8288;extra state&#8288;</code>, specifying how gaps will be handled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PhyDat2Morphy()</code> returns a pointer to an initialized Morphy object.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lobo", package="TreeTools")
morphyObj &lt;- PhyDat2Morphy(Lobo.phy)
# Set object to be destroyed at end of session or closure of function
# on.exit(morphyObj &lt;- UnloadMorphy(morphyObj), add = TRUE)

# Do something with pointer
# ....

# Or, instead of on.exit, manually destroy morphy object and free memory:
morphyObj &lt;- UnloadMorphy(morphyObj)
</code></pre>

<hr>
<h2 id='PlotCharacter'>Plot the distribution of a character on a tree</h2><span id='topic+PlotCharacter'></span>

<h3>Description</h3>

<p>Reconstructs the distribution of a character on a tree topology using the
modified Fitch algorithm presented in
Brazeau et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotCharacter(
  tree,
  dataset,
  char = 1L,
  updateTips = FALSE,
  plot = TRUE,
  tokenCol = NULL,
  ambigCol = "grey",
  inappCol = "lightgrey",
  ambigLty = "dotted",
  inappLty = "dashed",
  plainLty = par("lty"),
  tipOffset = 1,
  unitEdge = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotCharacter_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="PlotCharacter_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="PlotCharacter_+3A_char">char</code></td>
<td>
<p>Index of character to plot.</p>
</td></tr>
<tr><td><code id="PlotCharacter_+3A_updatetips">updateTips</code></td>
<td>
<p>Logical; if <code>FALSE</code>, tips will be labelled with their
original state in <code>dataset</code>.</p>
</td></tr>
<tr><td><code id="PlotCharacter_+3A_plot">plot</code></td>
<td>
<p>Logical specifying whether to plot the output.</p>
</td></tr>
<tr><td><code id="PlotCharacter_+3A_tokencol">tokenCol</code></td>
<td>
<p>Palette specifying colours to associate with each token in
turn, in the sequence listed in <code>attr(dataset, "levels")</code>.</p>
</td></tr>
<tr><td><code id="PlotCharacter_+3A_ambigcol">ambigCol</code>, <code id="PlotCharacter_+3A_ambiglty">ambigLty</code>, <code id="PlotCharacter_+3A_inappcol">inappCol</code>, <code id="PlotCharacter_+3A_inapplty">inappLty</code>, <code id="PlotCharacter_+3A_plainlty">plainLty</code></td>
<td>
<p>Colours and line types
to apply to ambiguous, inapplicable and applicable tokens.  See the <code>lty</code>
<a href="graphics.html#topic+graphical+20parameter">graphical parameter</a> for details of line styles.  Overrides <code>tokenCol</code>.</p>
</td></tr>
<tr><td><code id="PlotCharacter_+3A_tipoffset">tipOffset</code></td>
<td>
<p>Numeric: how much to offset tips from their labels.</p>
</td></tr>
<tr><td><code id="PlotCharacter_+3A_unitedge">unitEdge</code></td>
<td>
<p>Logical: Should all edges be plotted with a unit length?</p>
</td></tr>
<tr><td><code id="PlotCharacter_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code>plot.phylo()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PlotCharacter()</code> invisibly returns a matrix in which each row
corresponds to a numbered tip or node of <code>tree</code>, and each column corresponds
to a token; the tokens that might parsimoniously be present at each point
on a tree are denoted with <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Brazeau MD, Guillerme T, Smith MR (2019).
&ldquo;An algorithm for morphological phylogenetic analysis with inapplicable data.&rdquo;
<em>Systematic Biology</em>, <b>68</b>(4), 619&ndash;631.
<a href="https://doi.org/10.1093/sysbio/syy083">doi:10.1093/sysbio/syy083</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up plotting area
oPar &lt;- par(mar = rep(0, 4))

tree &lt;- ape::read.tree(text = 
  "((((((a, b), c), d), e), f), (g, (h, (i, (j, (k, l))))));")
## A character with inapplicable data
dataset &lt;- TreeTools::StringToPhyDat("23--1??--032", tips = tree)
plotted &lt;- PlotCharacter(tree, dataset)
plotted

# Character from a real dataset 
data("Lobo", package = "TreeTools")
dataset &lt;- Lobo.phy
tree &lt;- TreeTools::NJTree(dataset)
PlotCharacter(tree, dataset, 14)
par(oPar)
</code></pre>

<hr>
<h2 id='PrepareDataProfile'>Prepare data for Profile Parsimony</h2><span id='topic+PrepareDataProfile'></span><span id='topic+PrepareDataIW'></span>

<h3>Description</h3>

<p>Calculates profiles for each character in a dataset.  Will also simplify
characters, with a warning, where they are too complex for the present
implementation of profile parsimony:
</p>

<ul>
<li><p> inapplicable tokens will be replaced with the ambiguous token
(i.e. <code>-</code> &rarr; <code style="white-space: pre;">&#8288;?&#8288;</code>);
</p>
</li>
<li><p> Ambiguous tokens will be treated as fully ambiguous
(i.e. <code>{02}</code> &rarr; <code style="white-space: pre;">&#8288;?&#8288;</code>)
</p>
</li>
<li><p> Where more than two states are informative (i.e. unambiguously present in
more than one taxon), states beyond the two most informative will be
ignored.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>PrepareDataProfile(dataset)

PrepareDataIW(dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrepareDataProfile_+3A_dataset">dataset</code></td>
<td>
<p>dataset of class <code>phyDat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>phyDat</code>, with additional attributes.
<code>PrepareDataProfile</code> adds the attributes:
</p>

<ul>
<li> <p><code>info.amounts</code>: details the information represented by each
character when subject to N additional steps.
</p>
</li>
<li> <p><code>informative</code>: logical specifying which characters contain any
phylogenetic information.
</p>
</li>
<li> <p><code>bootstrap</code>: The character vector
<code>c("info.amounts", "split.sizes")</code>, indicating attributes to sample
when bootstrapping the dataset (e.g. in Ratchet searches).
</p>
</li></ul>

<p><code>PrepareDataIW</code> adds the attribute:
</p>

<ul>
<li> <p><code>min.length</code>: The minimum number of steps that must be present in each
transformation series.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>PrepareDataIW()</code>: Prepare data for implied weighting
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Martin R. Smith; written with reference to
<code>phangorn:::prepareDataFitch()</code>
</p>


<h3>See Also</h3>

<p>Other profile parsimony functions: 
<code><a href="#topic+Carter1">Carter1</a>()</code>,
<code><a href="#topic+StepInformation">StepInformation</a>()</code>,
<code><a href="#topic+WithOneExtraStep">WithOneExtraStep</a>()</code>,
<code><a href="#topic+profiles">profiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("congreveLamsdellMatrices")
dataset &lt;- congreveLamsdellMatrices[[42]]
PrepareDataProfile(dataset)
</code></pre>

<hr>
<h2 id='profiles'>Empirically counted profiles for small trees</h2><span id='topic+profiles'></span>

<h3>Description</h3>

<p>The base 2 logarithm of the number of trees containing <em>s</em> steps, calculated
by scoring a character on each <em>n</em>-leaf tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profiles
</code></pre>


<h3>Format</h3>

<p>A list with the structure
<code style="white-space: pre;">&#8288;profiles[[number of leaves]][[number of tokens]][[tokens in smallest split]]&#8288;</code>
The list entry returns a named numeric vector; each entry lists
log2(proportion of <em>n</em>-leaf trees with <em>s</em> or fewer steps for this character).
</p>


<h3>See Also</h3>

<p>Other profile parsimony functions: 
<code><a href="#topic+Carter1">Carter1</a>()</code>,
<code><a href="#topic+PrepareDataProfile">PrepareDataProfile</a>()</code>,
<code><a href="#topic+StepInformation">StepInformation</a>()</code>,
<code><a href="#topic+WithOneExtraStep">WithOneExtraStep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(profiles)

# Load profile for a character of the structure 0 0 0 1 1 1 1 1
profile3.5 &lt;- profiles[[8]][[2]][[3]]

# Number of trees with _s_ or fewer steps on that character
TreeTools::NUnrooted(8) * 2 ^ profile3.5
</code></pre>

<hr>
<h2 id='QuartetResolution'>Relationship between four taxa</h2><span id='topic+QuartetResolution'></span>

<h3>Description</h3>

<p>Relationship between four taxa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuartetResolution(trees, tips)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuartetResolution_+3A_trees">trees</code></td>
<td>
<p>A list of trees of class <code>phylo</code>, or a <code>multiPhylo</code> object.</p>
</td></tr>
<tr><td><code id="QuartetResolution_+3A_tips">tips</code></td>
<td>
<p>Vector specifying four tips whose relationship should be
reported, in a format accepted by <code><a href="TreeTools.html#topic+KeepTip">KeepTip</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector specifying an integer, for each tree, which of <code>tips[-1]</code>
is most closely related to <code>tips[1]</code>.
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code><a href="#topic+ClusterStrings">ClusterStrings</a>()</code>,
<code><a href="#topic+WhenFirstHit">WhenFirstHit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trees &lt;- inapplicable.trees[["Vinther2008"]]
tips &lt;- c("Lingula", "Halkieria", "Wiwaxia", "Acaenoplax")
QuartetResolution(trees, tips)
</code></pre>

<hr>
<h2 id='RandomMorphyTree'>Random postorder tree</h2><span id='topic+RandomMorphyTree'></span>

<h3>Description</h3>

<p>Random postorder tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomMorphyTree(nTip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RandomMorphyTree_+3A_ntip">nTip</code></td>
<td>
<p>Integer specifying the number of tips to include in the tree
(minimum 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements, each a vector of integers, respectively
containing:
</p>

<ul>
<li><p> The parent of each tip and node, in order
</p>
</li>
<li><p> The left child of each node
</p>
</li>
<li><p> The right child of each node.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other tree generation functions: 
<code><a href="#topic+AdditionTree">AdditionTree</a>()</code>
</p>

<hr>
<h2 id='RandomTreeScore'>Parsimony score of random postorder tree</h2><span id='topic+RandomTreeScore'></span>

<h3>Description</h3>

<p>Parsimony score of random postorder tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomTreeScore(morphyObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RandomTreeScore_+3A_morphyobj">morphyObj</code></td>
<td>
<p>Object of class <code>morphy</code>, perhaps created with
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RandomTreeScore()</code> returns the parsimony score of a random tree
for the given Morphy object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens &lt;- matrix(c(
  0, "-", "-", 1, 1, 2,
  0, 1, 0, 1, 2, 2,
  0, "-", "-", 0, 0, 0), byrow = TRUE, nrow = 3L,
  dimnames = list(letters[1:3], NULL))
pd &lt;- TreeTools::MatrixToPhyDat(tokens)
morphyObj &lt;- PhyDat2Morphy(pd)

RandomTreeScore(morphyObj)

morphyObj &lt;- UnloadMorphy(morphyObj)
</code></pre>

<hr>
<h2 id='RearrangeEdges'>Rearrange edges of a phylogenetic tree</h2><span id='topic+RearrangeEdges'></span>

<h3>Description</h3>

<p><code>RearrangeEdges()</code> performs the specified edge rearrangement on a matrix
that corresponds to the edges of a phylogenetic tree, returning the score of
the new tree.
Will generally be called from within a tree search function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RearrangeEdges(
  parent,
  child,
  dataset,
  TreeScorer = MorphyLength,
  EdgeSwapper,
  scoreToBeat = TreeScorer(parent, child, dataset, ...),
  iter = "?",
  hits = 0L,
  verbosity = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RearrangeEdges_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
<tr><td><code id="RearrangeEdges_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td></tr>
<tr><td><code id="RearrangeEdges_+3A_dataset">dataset</code></td>
<td>
<p>Third argument to pass to <code>TreeScorer</code>.</p>
</td></tr>
<tr><td><code id="RearrangeEdges_+3A_treescorer">TreeScorer</code></td>
<td>
<p>function to score a given tree.
The function will be passed three parameters, corresponding to the
<code>parent</code> and <code>child</code> entries of a tree's edge list, and a dataset.</p>
</td></tr>
<tr><td><code id="RearrangeEdges_+3A_edgeswapper">EdgeSwapper</code></td>
<td>
<p>a function that rearranges a parent and child vector,
and returns a list with modified vectors; for example <code><a href="#topic+SPRSwap">SPRSwap()</a></code>.</p>
</td></tr>
<tr><td><code id="RearrangeEdges_+3A_scoretobeat">scoreToBeat</code></td>
<td>
<p>Double giving score of input tree.</p>
</td></tr>
<tr><td><code id="RearrangeEdges_+3A_iter">iter</code></td>
<td>
<p>iteration number of calling function, for reporting to user only.</p>
</td></tr>
<tr><td><code id="RearrangeEdges_+3A_hits">hits</code></td>
<td>
<p>Integer giving number of times the input tree has already been hit.</p>
</td></tr>
<tr><td><code id="RearrangeEdges_+3A_verbosity">verbosity</code></td>
<td>
<p>Numeric specifying level of detail to display in console:
larger numbers provide more verbose feedback to the user.</p>
</td></tr>
<tr><td><code id="RearrangeEdges_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>TreeScorer()</code>, e.g. <code style="white-space: pre;">&#8288;dataset = &#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RearrangeTree()</code> performs one tree rearrangement of a
specified type, and returns the score of the tree (with the given dataset).
It also reports the number of times that this score was hit in the
current function call.
</p>


<h3>Value</h3>

<p>This function returns a list with two to four elements, corresponding to a binary tree:
- 1. Integer vector listing the parent node of each edge;
- 2. Integer vector listing the child node of each edge;
- 3. Score of the tree;
- 4. Number of times that score has been hit.
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lobo", package="TreeTools")
tree &lt;- TreeTools::NJTree(Lobo.phy)
edge &lt;- tree$edge
parent &lt;- edge[, 1]
child &lt;- edge[, 2]
dataset &lt;- PhyDat2Morphy(Lobo.phy)
RearrangeEdges(parent, child, dataset, EdgeSwapper = RootedNNISwap)
# Remember to free memory:
dataset &lt;- UnloadMorphy(dataset)
</code></pre>

<hr>
<h2 id='referenceTree'>Tree topology for matrix simulation</h2><span id='topic+referenceTree'></span>

<h3>Description</h3>

<p>The tree topology used to generate the matrices in
<code><a href="#topic+congreveLamsdellMatrices">congreveLamsdellMatrices</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>referenceTree
</code></pre>


<h3>Format</h3>

<p>A single phylogenetic tree saved as an object of class <code>phylo</code>
</p>


<h3>Source</h3>

<p>Congreve &amp; Lamsdell (2016); <a href="https://doi.org/10.1111/pala.12236">doi:10.1111/pala.12236</a>
</p>


<h3>References</h3>

<p>Congreve CR, Lamsdell JC (2016).
&ldquo;Implied weighting and its utility in palaeontological datasets: a study using modelled phylogenetic matrices.&rdquo;
<em>Palaeontology</em>, <b>59</b>(3), 447&ndash;465.
<a href="https://doi.org/10.1111/pala.12236">doi:10.1111/pala.12236</a>.
Congreve CR, Lamsdell JC (2016).
&ldquo;Data from: Implied weighting and its utility in palaeontological datasets: a study using modelled phylogenetic matrices.&rdquo;
<em>Dryad Digital Repository</em>, doi:10.5061/dryad.7dq0j.
<a href="https://doi.org/10.5061/dryad.7dq0j">doi:10.5061/dryad.7dq0j</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(referenceTree)
plot(referenceTree)

</code></pre>

<hr>
<h2 id='SingleCharMorphy'>Morphy object from single character</h2><span id='topic+SingleCharMorphy'></span>

<h3>Description</h3>

<p>Morphy object from single character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleCharMorphy(char, gap = "inapp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleCharMorphy_+3A_char">char</code></td>
<td>
<p>State of each character at each tip in turn, in a format that will be converted
to a character string by <code><a href="base.html#topic+paste0">paste0</a>(char, ";", collapse="")</code>.</p>
</td></tr>
<tr><td><code id="SingleCharMorphy_+3A_gap">gap</code></td>
<td>
<p>An unambiguous abbreviation of <code>inapplicable</code>, <code>ambiguous</code>
(= <code>missing</code>), or <code style="white-space: pre;">&#8288;extra state&#8288;</code>, specifying how gaps will be handled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pointer to an object of class <code>morphyObj</code>.
Don't forget to unload it when you've finished with it.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Score a tree: <code><a href="#topic+MorphyTreeLength">MorphyTreeLength()</a></code>
</p>
<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>morphyObj &lt;- SingleCharMorphy("-0-0", gap = "Extra")
RandomTreeScore(morphyObj)
morphyObj &lt;- UnloadMorphy(morphyObj)
</code></pre>

<hr>
<h2 id='SiteConcordance'>Calculate site concordance factor</h2><span id='topic+SiteConcordance'></span><span id='topic+QuartetConcordance'></span><span id='topic+ClusteringConcordance'></span><span id='topic+PhylogeneticConcordance'></span><span id='topic+MutualClusteringConcordance'></span><span id='topic+SharedPhylogeneticConcordance'></span>

<h3>Description</h3>

<p>The site concordance factor (Minh et al. 2020) is a measure
of the strength of support that the dataset presents for a given split in a
tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuartetConcordance(tree, dataset = NULL)

ClusteringConcordance(tree, dataset)

PhylogeneticConcordance(tree, dataset)

MutualClusteringConcordance(tree, dataset)

SharedPhylogeneticConcordance(tree, dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SiteConcordance_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="SiteConcordance_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>QuartetConcordance()</code> is the proportion of quartets (sets of four leaves)
that are decisive for a split which are also concordant with it.
For example, a quartet with the characters <code style="white-space: pre;">&#8288;0 0 0 1&#8288;</code> is not decisive, as
all relationships between those leaves are equally parsimonious.
But a quartet with characters <code style="white-space: pre;">&#8288;0 0 1 1&#8288;</code> is decisive, and is concordant
with any tree that groups the first two leaves together to the exclusion
of the second.
</p>
<p>NOTE: These functions are under development, and may be incompletely tested
or change without notice.
Complete documentation and discussion will follow in due course.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Minh BQ, Hahn MW, Lanfear R (2020).
&ldquo;New methods to calculate concordance factors for phylogenomic datasets.&rdquo;
<em>Molecular Biology and Evolution</em>, <b>37</b>(9), 2727&ndash;2733.
<a href="https://doi.org/10.1093/molbev/msaa106">doi:10.1093/molbev/msaa106</a>.
</p>


<h3>See Also</h3>

<p>Other split support functions: 
<code><a href="#topic+JackLabels">JackLabels</a>()</code>,
<code><a href="#topic+Jackknife">Jackknife</a>()</code>,
<code><a href="#topic+MaximizeParsimony">MaximizeParsimony</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("congreveLamsdellMatrices", package = "TreeSearch")
dataset &lt;- congreveLamsdellMatrices[[1]][, 1:20]
tree &lt;- referenceTree
qc &lt;- QuartetConcordance(tree, dataset)
cc &lt;- ClusteringConcordance(tree, dataset)
pc &lt;- PhylogeneticConcordance(tree, dataset)
spc &lt;- SharedPhylogeneticConcordance(tree, dataset)
mcc &lt;- MutualClusteringConcordance(tree, dataset)

oPar &lt;- par(mar = rep(0, 4), cex = 0.8)
plot(tree)
TreeTools::LabelSplits(tree, signif(qc, 3))
TreeTools::LabelSplits(tree, signif(cc, 3))
TreeTools::LabelSplits(tree, signif(pc, 3))
par(oPar)

pairs(cbind(qc, cc, pc, spc, mcc))
</code></pre>

<hr>
<h2 id='SPR'>Subtree pruning and rearrangement (SPR)</h2><span id='topic+SPR'></span><span id='topic+SPRMoves'></span><span id='topic+SPRMoves.phylo'></span><span id='topic+SPRMoves.matrix'></span><span id='topic+SPRSwap'></span><span id='topic+RootedSPR'></span><span id='topic+RootedSPRSwap'></span>

<h3>Description</h3>

<p>Perform one <abbr><span class="acronym">SPR</span></abbr> rearrangement on a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPR(tree, edgeToBreak = NULL, mergeEdge = NULL)

SPRMoves(tree, edgeToBreak = integer(0))

## S3 method for class 'phylo'
SPRMoves(tree, edgeToBreak = integer(0))

## S3 method for class 'matrix'
SPRMoves(tree, edgeToBreak = integer(0))

SPRSwap(
  parent,
  child,
  nEdge = length(parent),
  nNode = nEdge/2L,
  edgeToBreak = NULL,
  mergeEdge = NULL
)

RootedSPR(tree, edgeToBreak = NULL, mergeEdge = NULL)

RootedSPRSwap(
  parent,
  child,
  nEdge = length(parent),
  nNode = nEdge/2L,
  edgeToBreak = NULL,
  mergeEdge = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPR_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="SPR_+3A_edgetobreak">edgeToBreak</code></td>
<td>
<p>the index of an edge to bisect, generated randomly if not specified.</p>
</td></tr>
<tr><td><code id="SPR_+3A_mergeedge">mergeEdge</code></td>
<td>
<p>the index of an edge on which to merge the broken edge.</p>
</td></tr>
<tr><td><code id="SPR_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
<tr><td><code id="SPR_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td></tr>
<tr><td><code id="SPR_+3A_nedge">nEdge</code></td>
<td>
<p>(optional) integer specifying the number of edges of a tree of
class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>dim(tree$edge)[1]</code></p>
</td></tr>
<tr><td><code id="SPR_+3A_nnode">nNode</code></td>
<td>
<p>(optional) Number of nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equivalent to <code>kSPR()</code> in the <span class="pkg">phangorn</span> package, but faster.
Note that rearrangements that only change the position of the root WILL be returned by
<code>SPR</code>.  If the position of the root is irrelevant (as in Fitch parsimony, for example)
then this function will occasionally return a functionally equivalent topology.
<code>RootIrrelevantSPR</code> will search tree space more efficiently in these cases.
Branch lengths are not (yet) supported.
</p>
<p>All nodes in a tree must be bifurcating; <a href="ape.html#topic+collapse.singles">ape::collapse.singles</a> and
<a href="ape.html#topic+multi2di">ape::multi2di</a> may help.
</p>


<h3>Value</h3>

<p>This function returns a tree in <code>phyDat</code> format that has undergone one <abbr><span class="acronym">SPR</span></abbr> iteration.
</p>
<p><code>TBRMoves()</code> returns a list of all trees one SPR move away from
<code>tree</code>, with edges and nodes in preorder, rooted on the first-labelled tip.
</p>
<p>a list containing two elements, corresponding in turn to the
rearranged parent and child parameters
</p>
<p>a list containing two elements, corresponding in turn to the rearranged parent and child parameters
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>SPRSwap()</code>: faster version that takes and returns parent and child parameters
</p>
</li>
<li> <p><code>RootedSPR()</code>: Perform <abbr><span class="acronym">SPR</span></abbr> rearrangement, retaining position of root
</p>
</li>
<li> <p><code>RootedSPRSwap()</code>: faster version that takes and returns parent and child parameters
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>


<h3>References</h3>

<p>The <abbr><span class="acronym">SPR</span></abbr> algorithm is summarized in
Felsenstein J (2004).
<em>Inferring phylogenies</em>.
Sinauer Associates, Sunderland, Massachusetts.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+RootedSPR">RootedSPR()</a></code>: useful when the position of the root node should be retained.
</p>
</li></ul>

<p>Other tree rearrangement functions: 
<code><a href="#topic+NNI">NNI</a>()</code>,
<code><a href="#topic+TBR">TBR</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
tree &lt;- ape::rtree(20, br=FALSE)
SPR(tree)
}
</code></pre>

<hr>
<h2 id='SPRWarning'>TBR Warning
Print a warning and return given tree</h2><span id='topic+SPRWarning'></span><span id='topic+TBRWarning'></span>

<h3>Description</h3>

<p>TBR Warning
Print a warning and return given tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPRWarning(parent, child, error)

TBRWarning(parent, child, error)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPRWarning_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
<tr><td><code id="SPRWarning_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td></tr>
<tr><td><code id="SPRWarning_+3A_error">error</code></td>
<td>
<p>error message to report</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the entries <code>parent</code>, <code>child</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>SPRWarning()</code>: for SPR rearrangements
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(TBRWarning(0, 0, "Message text")) # will trigger warning

</code></pre>

<hr>
<h2 id='StepInformation'>Information content of a character known to contain <em>e</em> steps</h2><span id='topic+StepInformation'></span>

<h3>Description</h3>

<p><code>StepInformation()</code> calculates the phylogenetic information content of a
character <code>char</code> when <em>e</em> extra steps are present, for all possible
values of <em>e</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepInformation(char, ambiguousTokens = c("-", "?"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepInformation_+3A_char">char</code></td>
<td>
<p>Vector of tokens listing states for the character in question.</p>
</td></tr>
<tr><td><code id="StepInformation_+3A_ambiguoustokens">ambiguousTokens</code></td>
<td>
<p>Vector specifying which tokens, if any, correspond to
the ambiguous token (<code style="white-space: pre;">&#8288;?&#8288;</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the number of trees consistent with the character having
<em>e</em> extra steps, where <em>e</em> ranges from its minimum possible value
(i.e. number of different tokens minus one) to its maximum.
</p>


<h3>Value</h3>

<p><code>StepInformation()</code> returns a numeric vector detailing the amount
of phylogenetic information (in bits) associated with the character when
0, 1, 2… extra steps are present.  The vector is named with the
total number of steps associated with each entry in the vector: for example,
a character with three observed tokens must exhibit two steps, so the first
entry (zero extra steps) is named <code>2</code> (two steps observed).
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other profile parsimony functions: 
<code><a href="#topic+Carter1">Carter1</a>()</code>,
<code><a href="#topic+PrepareDataProfile">PrepareDataProfile</a>()</code>,
<code><a href="#topic+WithOneExtraStep">WithOneExtraStep</a>()</code>,
<code><a href="#topic+profiles">profiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>character &lt;- rep(c(0:3, "?", "-"), c(8, 5, 1, 1, 2, 2))
StepInformation(character)
</code></pre>

<hr>
<h2 id='StopUnlessBifurcating'>Check that all nodes in a tree are bifurcating.</h2><span id='topic+StopUnlessBifurcating'></span>

<h3>Description</h3>

<p>Check that all nodes in a tree are bifurcating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StopUnlessBifurcating(parent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StopUnlessBifurcating_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code>, but will <code>stop</code> with an error message if a tree
does not appear to be bifurcating.
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>

<hr>
<h2 id='Suboptimality'>Tree suboptimality</h2><span id='topic+Suboptimality'></span>

<h3>Description</h3>

<p>How suboptimal is a tree?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Suboptimality(trees, proportional = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Suboptimality_+3A_trees">trees</code></td>
<td>
<p>list of trees, to include an optimal tree</p>
</td></tr>
<tr><td><code id="Suboptimality_+3A_proportional">proportional</code></td>
<td>
<p>logical stating whether to normalise results to lowest
score</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Suboptimality()</code> returns a vector listing, for each tree, how much
its score differs from the optimal (lowest) score.
</p>

<hr>
<h2 id='SuccessiveApproximations'>Tree search using successive approximations</h2><span id='topic+SuccessiveApproximations'></span><span id='topic+SuccessiveWeights'></span>

<h3>Description</h3>

<p>Searches for a tree that is optimal under the Successive Approximations
criterion (Farris 1969).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuccessiveApproximations(
  tree,
  dataset,
  outgroup = NULL,
  k = 3,
  maxSuccIter = 20,
  ratchetHits = 100,
  searchHits = 50,
  searchIter = 500,
  ratchetIter = 5000,
  verbosity = 0,
  suboptimal = 0.1
)

SuccessiveWeights(tree, dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuccessiveApproximations_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_outgroup">outgroup</code></td>
<td>
<p>if not NULL, taxa on which the tree should be rooted</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_k">k</code></td>
<td>
<p>Constant for successive approximations, see Farris 1969 p. 379</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_maxsucciter">maxSuccIter</code></td>
<td>
<p>maximum iterations of successive approximation</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_ratchethits">ratchetHits</code></td>
<td>
<p>maximum hits for parsimony ratchet</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_searchhits">searchHits</code></td>
<td>
<p>maximum hits in tree search</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_searchiter">searchIter</code></td>
<td>
<p>maximum iterations in tree search</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_ratchetiter">ratchetIter</code></td>
<td>
<p>maximum iterations of parsimony ratchet</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_verbosity">verbosity</code></td>
<td>
<p>Numeric specifying level of detail to display in console:
larger numbers provide more verbose feedback to the user.</p>
</td></tr>
<tr><td><code id="SuccessiveApproximations_+3A_suboptimal">suboptimal</code></td>
<td>
<p>retain trees that are this proportion less optimal than the optimal tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SuccessiveApproximations()</code> returns a list of class <code>multiPhylo</code>
containing optimal (and slightly suboptimal, if suboptimal &gt; 0) trees.
</p>
<p><code>SuccessiveWeights()</code> returns the score of a tree, given the
weighting instructions specified in the attributes of the dataset.
</p>


<h3>References</h3>

<p>Farris JS (1969).
&ldquo;A successive approximations approach to character weighting.&rdquo;
<em>Systematic Biology</em>, <b>18</b>(4), 374&ndash;385.
<a href="https://doi.org/10.2307/2412182">doi:10.2307/2412182</a>.
</p>


<h3>See Also</h3>

<p>Other custom search functions: 
<code><a href="#topic+EdgeListSearch">EdgeListSearch</a>()</code>,
<code><a href="#topic+Jackknife">Jackknife</a>()</code>,
<code><a href="#topic+MorphyBootstrap">MorphyBootstrap</a>()</code>
</p>

<hr>
<h2 id='summary.morphyPtr'>Details the attributes of a morphy object</h2><span id='topic+summary.morphyPtr'></span>

<h3>Description</h3>

<p>Details the attributes of a morphy object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'morphyPtr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.morphyPtr_+3A_object">object</code></td>
<td>
<p>A Morphy object</p>
</td></tr>
<tr><td><code id="summary.morphyPtr_+3A_...">...</code></td>
<td>
<p>any other parameters...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list detailing the number of taxa, internal nodes, and characters and their weights.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+UnloadMorphy">UnloadMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>
</p>

<hr>
<h2 id='TaxonInfluence'>Rank taxa by their influence on phylogenetic results</h2><span id='topic+TaxonInfluence'></span>

<h3>Description</h3>

<p><code>TaxonInfluence()</code> ranks taxa according to their influence on the most
parsimonious topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TaxonInfluence(
  dataset,
  tree = NULL,
  Distance = ClusteringInfoDistance,
  calcWeighted = TRUE,
  savePath = NULL,
  useCache = FALSE,
  verbosity = 3L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TaxonInfluence_+3A_dataset">dataset</code></td>
<td>
<p>A phylogenetic data matrix of <span class="pkg">phangorn</span> class
<code>phyDat</code>, whose names correspond to the labels of any accompanying tree.</p>
</td></tr>
<tr><td><code id="TaxonInfluence_+3A_tree">tree</code></td>
<td>
<p>Optimal tree or summary tree (of class &quot;phylo&quot;) or list of trees
(of class &quot;list&quot; or &quot;multiPhylo&quot;) against which results should be evaluated.
If <code>NULL</code>, an optimal tree will be sought using parsimony search with
the parameters provided in <code>...</code>.</p>
</td></tr>
<tr><td><code id="TaxonInfluence_+3A_distance">Distance</code></td>
<td>
<p>Function to calculate tree distance; default:
<code><a href="TreeDist.html#topic+ClusteringInfoDistance">ClusteringInfoDistance()</a></code>.</p>
</td></tr>
<tr><td><code id="TaxonInfluence_+3A_calcweighted">calcWeighted</code></td>
<td>
<p>Logical specifying whether to compute the
distance-weighted mean value.</p>
</td></tr>
<tr><td><code id="TaxonInfluence_+3A_savepath">savePath</code></td>
<td>
<p>Character giving prefix of path to which reduced trees will be
saved (with <code><a href="ape.html#topic+write.nexus">write.nexus()</a></code>). File names will follow the pattern
<code>paste0(savePath, droppedTaxonName, ".nex")</code>; <code>savePath</code> should thus contain
a trailing <code>/</code> if writing to a directory, which will be created if it does
not exist.  Special characters will be removed from leaf labels when
creating the file path (using <code><a href="fs.html#topic+path_sanitize">path_sanitize()</a></code>).
If <code>NULL</code>, computed trees will not be saved.</p>
</td></tr>
<tr><td><code id="TaxonInfluence_+3A_usecache">useCache</code></td>
<td>
<p>Logical vector; if <code>TRUE</code>, previous tree search results will
be loaded from the location given by <code>savePath</code>, instead of running a fresh
search with the specified dataset and parameters.</p>
</td></tr>
<tr><td><code id="TaxonInfluence_+3A_verbosity">verbosity</code>, <code id="TaxonInfluence_+3A_...">...</code></td>
<td>
<p>Parameters for <code><a href="#topic+MaximizeParsimony">MaximizeParsimony()</a></code>.
Tree search will be conducted using <code>tree</code> as a starting tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>TaxonInfluence()</code> follows the approach of
Mariadassou et al. (2012) in repeating tree search
whilst leaving each taxon in turn out of the analysis, and measuring
the distance of reconstructed trees from the optimal tree obtained when
all taxa are included in phylogenetic inference.
</p>
<p>As Denton and Goolsby (2018) emphasize, the
Robinson–Foulds distance is unsuitable for this purpose; this function
allows the user to specify a preferred tree distance measure, defaulting
to the clustering information distance (Smith 2020).
Because optimal parsimony trees are not equiprobable, taxon influence is
ranked based on the maximum and minimum tree-to-tree distances between
optimal trees.
</p>


<h3>Value</h3>

<p><code>TaxonInfluence()</code> returns a matrix listing the phylogenetic
influence of each taxon, measured in the units of the chosen tree distance
metric (default = bits).
Columns denote taxa; rows denote the maximum, distance-weighted mean,
and minimum distance between optimal tree sets.
</p>


<h3>Distance-weighted mean</h3>

<p>Sets of equally parsimonious trees are not statistical samples of tree space,
but are biased towards areas of uncertainty.
It is possible that a set of trees contains all possible resolutions of a
particular clade, and a single other topology in which that clade does not
exist – essentially two distinct solutions, one (<em>a</em>) which could be
summarised with a summary tree that contains a polytomy, and another (<em>b</em>)
which could be summarized by a perfectly resolved tree.
Neither of these scenarios is preferable under the principles of parsimony;
but summary statistics (e.g. mean, median) will be strongly influenced by the
many trees in group <em>a</em>, thus underplaying the existence of solution <em>b</em>.
</p>
<p><code>TaxonInfluence()</code> uses an <em>ad hoc</em> method to produce summary statistics
after weighting for trees' distance from other trees.  Trees that have few
close neighbours contribute more to the weighted mean, thus reducing the
influence of many trees that differ only in small details.
This distance-weighted mean is thus less prone to bias than a simple mean
– it is no more statistically valid, but (potentially) provides a more
representative summary of comparisons between sets of trees.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Denton JS, Goolsby EW (2018).
&ldquo;Measuring Inferential Importance of Taxa Using Taxon Influence Indices.&rdquo;
<em>Ecology and Evolution</em>, <b>8</b>(9), 4484&ndash;4494.
<a href="https://doi.org/10.1002/ece3.3941">doi:10.1002/ece3.3941</a>.<br /><br /> Mariadassou M, Bar-Hen A, Kishino H (2012).
&ldquo;Taxon Influence Index: Assessing Taxon-Induced Incongruities in Phylogenetic Inference.&rdquo;
<em>Systematic Biology</em>, <b>61</b>(2), 337&ndash;345.
<a href="https://doi.org/10.1093/sysbio/syr129">doi:10.1093/sysbio/syr129</a>.<br /><br /> Smith MR (2020).
&ldquo;Information Theoretic Generalized Robinson-Foulds Metrics for Comparing Phylogenetic Trees.&rdquo;
<em>Bioinformatics</em>, <b>36</b>(20), 5007&ndash;5013.
<a href="https://doi.org/10.1093/bioinformatics/btaa614">doi:10.1093/bioinformatics/btaa614</a>.
</p>


<h3>See Also</h3>

<p>Other tree scoring: 
<code><a href="#topic+CharacterLength">CharacterLength</a>()</code>,
<code><a href="#topic+IWScore">IWScore</a>()</code>,
<code><a href="#topic+LengthAdded">LengthAdded</a>()</code>,
<code><a href="#topic+MinimumLength">MinimumLength</a>()</code>,
<code><a href="#topic+MorphyTreeLength">MorphyTreeLength</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Load data for analysis in R
library("TreeTools")
data("congreveLamsdellMatrices", package = "TreeSearch")

# Small dataset for demonstration purposes
dataset &lt;- congreveLamsdellMatrices[[42]][1:8, ]
bestTree &lt;- MaximizeParsimony(dataset, verbosity = 0)[[1]]

# Calculate tip influence
influence &lt;- TaxonInfluence(dataset, ratchIt = 0, startIt = 0, verbos = 0)

# Colour tip labels according to their influence
upperBound &lt;- 2 * TreeDist::ClusteringEntropy(
  PectinateTree(NTip(dataset) - 1))
nBin &lt;- 128
bin &lt;- cut(
  influence["max", ],
  breaks = seq(0, upperBound, length.out = nBin),
  include.lowest = TRUE
)
palette &lt;- hcl.colors(nBin, "inferno")

plot(bestTree, tip.color = palette[bin])
PlotTools::SpectrumLegend(
  "bottomleft",
  palette = palette,
  title = "Tip influence / bits",
  legend = signif(seq(upperBound, 0, length.out = 4), 3),
  bty = "n"
)
</code></pre>

<hr>
<h2 id='TBR'>Tree bisection and reconnection (TBR)</h2><span id='topic+TBR'></span><span id='topic+TBRMoves'></span><span id='topic+TBRMoves.phylo'></span><span id='topic+TBRMoves.matrix'></span><span id='topic+TBRSwap'></span><span id='topic+RootedTBR'></span><span id='topic+RootedTBRSwap'></span>

<h3>Description</h3>

<p><code>TBR</code> performs a single random <abbr><span class="acronym">TBR</span></abbr> iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TBR(tree, edgeToBreak = NULL, mergeEdges = NULL)

TBRMoves(tree, edgeToBreak = integer(0))

## S3 method for class 'phylo'
TBRMoves(tree, edgeToBreak = integer(0))

## S3 method for class 'matrix'
TBRMoves(tree, edgeToBreak = integer(0))

TBRSwap(
  parent,
  child,
  nEdge = length(parent),
  edgeToBreak = NULL,
  mergeEdges = NULL
)

RootedTBR(tree, edgeToBreak = NULL, mergeEdges = NULL)

RootedTBRSwap(
  parent,
  child,
  nEdge = length(parent),
  edgeToBreak = NULL,
  mergeEdges = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TBR_+3A_tree">tree</code></td>
<td>
<p>A bifurcating tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, with all nodes resolved;</p>
</td></tr>
<tr><td><code id="TBR_+3A_edgetobreak">edgeToBreak</code></td>
<td>
<p>(optional) integer specifying the index of an edge to bisect/prune,
generated randomly if not specified.
Alternatively, set to <code>-1</code> to return a complete list
of all trees one step from the input tree.</p>
</td></tr>
<tr><td><code id="TBR_+3A_mergeedges">mergeEdges</code></td>
<td>
<p>(optional) vector of length 1 or 2, listing edge(s) to be joined:
In SPR, this is where the pruned subtree will be reconnected.
In TBR, these edges will be reconnected (so must be on opposite
sides of <code>edgeToBreak</code>); if only a single edge is specified,
the second will be chosen at random</p>
</td></tr>
<tr><td><code id="TBR_+3A_parent">parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td></tr>
<tr><td><code id="TBR_+3A_child">child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td></tr>
<tr><td><code id="TBR_+3A_nedge">nEdge</code></td>
<td>
<p>(optional) Number of edges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Branch lengths are not (yet) supported.
</p>
<p>All nodes in a tree must be bifurcating; <a href="ape.html#topic+collapse.singles">ape::collapse.singles</a> and
<a href="ape.html#topic+multi2di">ape::multi2di</a> may help.
</p>


<h3>Value</h3>

<p><code>TBR()</code> returns a tree in <code>phyDat</code> format that has undergone one
<abbr><span class="acronym">TBR</span></abbr> iteration.
</p>
<p><code>TBRMoves()</code> returns a <code>multiPhylo</code> object listing all trees one
<abbr><span class="acronym">TBR</span></abbr> move away from <code>tree</code>, with edges and nodes in preorder,
rooted on the first-labelled tip.
</p>
<p>a list containing two elements, corresponding in turn to the
rearranged parent and child parameters
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>TBRSwap()</code>: faster version that takes and returns parent and child
parameters
</p>
</li>
<li> <p><code>RootedTBR()</code>: Perform <abbr><span class="acronym">TBR</span></abbr> rearrangement, retaining position of root
</p>
</li>
<li> <p><code>RootedTBRSwap()</code>: faster version that takes and returns parent and child parameters
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>The <abbr><span class="acronym">TBR</span></abbr> algorithm is summarized in
Felsenstein J (2004).
<em>Inferring phylogenies</em>.
Sinauer Associates, Sunderland, Massachusetts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RootedTBR">RootedTBR()</a></code>: useful when the position of the root node should be retained.
</p>
<p>Other tree rearrangement functions: 
<code><a href="#topic+NNI">NNI</a>()</code>,
<code><a href="#topic+SPR">SPR</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("ape")
tree &lt;- rtree(20, br=NULL)
TBR(tree)
</code></pre>

<hr>
<h2 id='UnloadMorphy'>Destroy a Morphy object</h2><span id='topic+UnloadMorphy'></span>

<h3>Description</h3>

<p>Destroys a previously-created Morphy object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnloadMorphy(morphyObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnloadMorphy_+3A_morphyobj">morphyObj</code></td>
<td>
<p>Object of class <code>morphy</code>, perhaps created with
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Best practice is to call <code>morphyObj &lt;- UnloadMorphy(morphyObj)</code>
Failure to do so will cause a crash if <code>UnloadMorphy()</code> is called on an
object that  has already been destroyed
</p>


<h3>Value</h3>

<p>Morphy error code, decipherable using <code><a href="#topic+mpl_translate_error">mpl_translate_error</a></code>
</p>


<h3>Author(s)</h3>

<p>Martin R. Smith
</p>


<h3>See Also</h3>

<p>Other Morphy API functions: 
<code><a href="#topic+GapHandler">GapHandler</a>()</code>,
<code><a href="#topic+MorphyErrorCheck">MorphyErrorCheck</a>()</code>,
<code><a href="#topic+MorphyWeights">MorphyWeights</a>()</code>,
<code><a href="#topic+PhyDat2Morphy">PhyDat2Morphy</a>()</code>,
<code><a href="#topic+SingleCharMorphy">SingleCharMorphy</a>()</code>,
<code><a href="#topic+is.morphyPtr">is.morphyPtr</a>()</code>,
<code><a href="#topic+mpl_apply_tipdata">mpl_apply_tipdata</a>()</code>,
<code><a href="#topic+mpl_attach_rawdata">mpl_attach_rawdata</a>()</code>,
<code><a href="#topic+mpl_attach_symbols">mpl_attach_symbols</a>()</code>,
<code><a href="#topic+mpl_delete_Morphy">mpl_delete_Morphy</a>()</code>,
<code><a href="#topic+mpl_delete_rawdata">mpl_delete_rawdata</a>()</code>,
<code><a href="#topic+mpl_first_down_recon">mpl_first_down_recon</a>()</code>,
<code><a href="#topic+mpl_first_up_recon">mpl_first_up_recon</a>()</code>,
<code><a href="#topic+mpl_get_charac_weight">mpl_get_charac_weight</a>()</code>,
<code><a href="#topic+mpl_get_gaphandl">mpl_get_gaphandl</a>()</code>,
<code><a href="#topic+mpl_get_num_charac">mpl_get_num_charac</a>()</code>,
<code><a href="#topic+mpl_get_num_internal_nodes">mpl_get_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_get_numtaxa">mpl_get_numtaxa</a>()</code>,
<code><a href="#topic+mpl_get_symbols">mpl_get_symbols</a>()</code>,
<code><a href="#topic+mpl_init_Morphy">mpl_init_Morphy</a>()</code>,
<code><a href="#topic+mpl_new_Morphy">mpl_new_Morphy</a>()</code>,
<code><a href="#topic+mpl_second_down_recon">mpl_second_down_recon</a>()</code>,
<code><a href="#topic+mpl_second_up_recon">mpl_second_up_recon</a>()</code>,
<code><a href="#topic+mpl_set_charac_weight">mpl_set_charac_weight</a>()</code>,
<code><a href="#topic+mpl_set_num_internal_nodes">mpl_set_num_internal_nodes</a>()</code>,
<code><a href="#topic+mpl_set_parsim_t">mpl_set_parsim_t</a>()</code>,
<code><a href="#topic+mpl_translate_error">mpl_translate_error</a>()</code>,
<code><a href="#topic+mpl_update_lower_root">mpl_update_lower_root</a>()</code>,
<code><a href="#topic+mpl_update_tip">mpl_update_tip</a>()</code>,
<code><a href="#topic+summary.morphyPtr">summary.morphyPtr</a>()</code>
</p>

<hr>
<h2 id='WhenFirstHit'>When was a tree topology first hit?</h2><span id='topic+WhenFirstHit'></span>

<h3>Description</h3>

<p>Reports when each tree in a list was first found by tree search.
This information is read from the <code>firstHit</code> attribute if present.
If not, trees are taken to be listed in the order in which they were found,
and named according to the search iteration in which they were first hit -
the situation when trees found by <code><a href="#topic+MaximizeParsimony">MaximizeParsimony()</a></code> are saved to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WhenFirstHit(trees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WhenFirstHit_+3A_trees">trees</code></td>
<td>
<p>A list of trees, or a <code>multiPhylo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>trees</code>, with a <code>firstHit</code> attribute listing the number of trees hit
for the first time in each search iteration.
</p>


<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+MaximizeParsimony">MaximizeParsimony()</a></code>
</p>
</li></ul>

<p>Other utility functions: 
<code><a href="#topic+ClusterStrings">ClusterStrings</a>()</code>,
<code><a href="#topic+QuartetResolution">QuartetResolution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("TreeTools", quietly = TRUE)
trees &lt;- list(
   seed_00 = as.phylo(1, 8),
   ratch1_01 = as.phylo(2, 8),
   ratch1_02 = as.phylo(3, 8),
   ratch4_44 = as.phylo(4, 8),
   final_99 = as.phylo(5, 8)
)
attr(WhenFirstHit(trees), "firstHit")
</code></pre>

<hr>
<h2 id='WithOneExtraStep'>Number of trees with one extra step</h2><span id='topic+WithOneExtraStep'></span>

<h3>Description</h3>

<p>Number of trees with one extra step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WithOneExtraStep(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WithOneExtraStep_+3A_...">...</code></td>
<td>
<p>Vector or series of integers specifying the number of leaves
bearing each distinct non-ambiguous token.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other profile parsimony functions: 
<code><a href="#topic+Carter1">Carter1</a>()</code>,
<code><a href="#topic+PrepareDataProfile">PrepareDataProfile</a>()</code>,
<code><a href="#topic+StepInformation">StepInformation</a>()</code>,
<code><a href="#topic+profiles">profiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WithOneExtraStep(1, 2, 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
