<!DOCTYPE html><html><head><title>Help for package rotasym</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rotasym}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACG'><p>Angular central Gaussian distribution</p></a></li>
<li><a href='#check_unit_norm'><p>Checking of unit-norm data</p></a></li>
<li><a href='#cosines-signs'><p>Cosines and multivariate signs of a hyperspherical sample about a</p>
given location</a></li>
<li><a href='#estimators'><p>Estimators for the axis of rotational symmetry</p>
<code class="reqn">\boldsymbol\theta</code></a></li>
<li><a href='#rotasym-package'><p><span class="pkg">rotasym</span> &ndash; Tests for Rotational Symmetry on the Hypersphere</p></a></li>
<li><a href='#sunspots_births'><p>Recorded sunspots births during 1872&ndash;2018</p></a></li>
<li><a href='#tang-norm-decomp'><p>Distributions based on the tangent-normal decomposition</p></a></li>
<li><a href='#tangent-elliptical'><p>Tangent elliptical distribution</p></a></li>
<li><a href='#tangent-vMF'><p>Tangent von Mises&ndash;Fisher distribution</p></a></li>
<li><a href='#test_rotasym'><p>Tests of rotational symmetry for hyperspherical data</p></a></li>
<li><a href='#unif'><p>Uniform distribution on the hypersphere</p></a></li>
<li><a href='#vMF'><p>von Mises&ndash;Fisher distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tests for Rotational Symmetry on the Hypersphere</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the tests for rotational symmetry on the
    hypersphere proposed in García-Portugués, Paindaveine and Verdebout (2020)
    &lt;<a href="https://doi.org/10.1080%2F01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>&gt;. The package also implements the
    proposed distributions on the hypersphere, based on the tangent-normal
    decomposition, and allows for the replication of the data application
    considered in the paper.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, viridisLite</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egarpor/rotasym">https://github.com/egarpor/rotasym</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egarpor/rotasym">https://github.com/egarpor/rotasym</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 00:23:19 UTC; Eduardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo García-Portugués
    <a href="https://orcid.org/0000-0002-9224-4111"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Davy Paindaveine [aut],
  Thomas Verdebout [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo García-Portugués &lt;edgarcia@est-econ.uc3m.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 04:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACG'>Angular central Gaussian distribution</h2><span id='topic+ACG'></span><span id='topic+d_ACG'></span><span id='topic+c_ACG'></span><span id='topic+r_ACG'></span>

<h3>Description</h3>

<p>Density and simulation of the Angular Central Gaussian (ACG)
distribution on
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p\ge 1</code>. The density at
<code class="reqn">\mathbf{x} \in S^{p-1}</code>, <code class="reqn">p\ge 2</code>, is given by
</p>
<p style="text-align: center;"><code class="reqn">c^{\mathrm{ACG}}_{p,\boldsymbol{\Lambda}}
(\mathbf{x}' \boldsymbol{\Lambda}^{-1} \mathbf{x})^{-p/2}
\quad\mathrm{with}\quad c^{\mathrm{ACG}}_{p,\boldsymbol{\Lambda}}:=
1 / (\omega_p |\boldsymbol{\Lambda}|^{1/2})</code>
</p>

<p>where <code class="reqn">\boldsymbol{\Lambda}</code> is the shape matrix, a
<code class="reqn">p\times p</code> symmetric and positive definite matrix, and
<code class="reqn">\omega_p</code> is the surface area of <code class="reqn">S^{p-1}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_ACG(x, Lambda, log = FALSE)

c_ACG(p, Lambda, log = FALSE)

r_ACG(n, Lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ACG_+3A_x">x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td></tr>
<tr><td><code id="ACG_+3A_lambda">Lambda</code></td>
<td>
<p>the shape matrix <code class="reqn">\boldsymbol{\Lambda}</code> of the
ACG. A symmetric and positive definite matrix of size <code>c(p, p)</code>.</p>
</td></tr>
<tr><td><code id="ACG_+3A_log">log</code></td>
<td>
<p>flag to indicate if the logarithm of the density (or the
normalizing constant) is to be computed.</p>
</td></tr>
<tr><td><code id="ACG_+3A_p">p</code></td>
<td>
<p>dimension of the ambient space <code class="reqn">R^p</code> that contains
<code class="reqn">S^{p-1}</code>. A positive integer.</p>
</td></tr>
<tr><td><code id="ACG_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to the projection of the ACG, the shape matrix
<code class="reqn">\boldsymbol{\Lambda}</code> is only identified up to a constant,
that is, <code class="reqn">\boldsymbol{\Lambda}</code> and
<code class="reqn">c\boldsymbol{\Lambda}</code> give the same ACG distribution.
Usually, <code class="reqn">\boldsymbol{\Lambda}</code> is normalized to have trace
equal to <code class="reqn">p</code>.
</p>
<p><code>c_ACG</code> is vectorized on <code>p</code>. If <code class="reqn">p = 1</code>, then the ACG is the
uniform distribution in the set <code class="reqn">\{-1, 1\}</code>.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>d_ACG</code>: a vector of length <code>nx</code> or <code>1</code> with the
evaluated density at <code>x</code>.
</p>
</li>
<li> <p><code>r_ACG</code>: a matrix of size <code>c(n, p)</code> with the random sample.
</p>
</li>
<li> <p><code>c_ACG</code>: the normalizing constant.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>Tyler, D. E. (1987). Statistical analysis for the angular central Gaussian
distribution on the sphere. <em>Biometrika</em>, 74(3):579&ndash;589.
<a href="https://doi.org/10.1093/biomet/74.3.579">doi:10.1093/biomet/74.3.579</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tangent-elliptical">tangent-elliptical</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation and density evaluation for p = 2
Lambda &lt;- diag(c(5, 1))
n &lt;- 1e3
x &lt;- r_ACG(n = n, Lambda = Lambda)
col &lt;- viridisLite::viridis(n)
r &lt;- runif(n, 0.95, 1.05) # Radius perturbation to improve visualization
plot(r * x, pch = 16, col = col[rank(d_ACG(x = x, Lambda = Lambda))])

# Simulation and density evaluation for p = 3
Lambda &lt;- rbind(c(5, 1, 0.5),
                c(1, 2, 1),
                c(0.5, 1, 1))
x &lt;- r_ACG(n = n, Lambda = Lambda)
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(d_ACG(x = x, Lambda = Lambda))], size = 5)
}
</code></pre>

<hr>
<h2 id='check_unit_norm'>Checking of unit-norm data</h2><span id='topic+check_unit_norm'></span>

<h3>Description</h3>

<p>Utility for normalizing data without unit norms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_unit_norm(x, warnings = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_unit_norm_+3A_x">x</code></td>
<td>
<p>observations claimed to have unit norms. Either a matrix of size
<code>c(nx, p)</code> or a vector of length <code>p</code>.</p>
</td></tr>
<tr><td><code id="check_unit_norm_+3A_warnings">warnings</code></td>
<td>
<p>whether to show warnings if the normalization of
<code>x</code> happened.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A curated version of <code>x</code> with unit-norm observations and
possible zeros excluded.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_unit_norm(c(sqrt(2), sqrt(2), 0) / 2)
check_unit_norm(1:3, warnings = FALSE)
check_unit_norm(rbind(c(0, 0, 0), c(0, 0, 1), 1:3, c(NA, 0, 1)),
                warnings = FALSE)
</code></pre>

<hr>
<h2 id='cosines-signs'>Cosines and multivariate signs of a hyperspherical sample about a
given location</h2><span id='topic+cosines-signs'></span><span id='topic+signs'></span><span id='topic+cosines'></span><span id='topic+Gamma_theta'></span>

<h3>Description</h3>

<p>Computation of the cosines and multivariate signs of the
hyperspherical sample <code class="reqn">\mathbf{X}_1,\ldots,\mathbf{X}_n\in S^{p-1}</code> about a location
<code class="reqn">\boldsymbol{\theta}\in S^{p-1}</code>,
for <code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code> with <code class="reqn">p\ge 2</code>.
The <em>cosines</em> are defined as
</p>
<p style="text-align: center;"><code class="reqn">V_i:=\mathbf{X}_i'\boldsymbol{\theta},\quad i=1,\ldots,n,</code>
</p>

<p>whereas the <em>multivariate signs</em> are the vectors
<code class="reqn">\mathbf{U}_1,\ldots,\mathbf{U}_n\in S^{p-2}</code> defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{U}_i := \boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{X}_i/
||\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{X}_i||,\quad
i=1,\ldots,n.</code>
</p>

<p>The projection matrix
<code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> is a
<code class="reqn">p\times (p-1)</code> semi-orthogonal matrix that satisfies
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}'
\boldsymbol{\Gamma}_{\boldsymbol{\theta}}=\mathbf{I}_{p-1}
\quad\mathrm{and}\quad\boldsymbol{\Gamma}_{\boldsymbol{\theta}}
\boldsymbol{\Gamma}_{\boldsymbol{\theta}}'=
\mathbf{I}_p-\boldsymbol{\theta}\boldsymbol{\theta}'.</code>
</p>

<p>where <code class="reqn">\mathbf{I}_p</code> is the identity matrix of dimension <code class="reqn">p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signs(X, theta, Gamma = NULL, check_X = FALSE)

cosines(X, theta, check_X = FALSE)

Gamma_theta(theta, eig = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosines-signs_+3A_x">X</code></td>
<td>
<p>hyperspherical data, a matrix of size <code>c(n, p)</code> with
unit-norm rows. <code>NA</code>s are allowed.</p>
</td></tr>
<tr><td><code id="cosines-signs_+3A_theta">theta</code></td>
<td>
<p>a unit-norm vector of length <code>p</code>. Normalized internally
if it does not have unit norm (with a <code>warning</code> message).</p>
</td></tr>
<tr><td><code id="cosines-signs_+3A_gamma">Gamma</code></td>
<td>
<p>output from <code>Gamma_theta(theta = theta)</code>. If <code>NULL</code>
(default), it is computed internally.</p>
</td></tr>
<tr><td><code id="cosines-signs_+3A_check_x">check_X</code></td>
<td>
<p>whether to check the unit norms on the rows of <code>X</code>.
Defaults to <code>FALSE</code> for performance reasons.</p>
</td></tr>
<tr><td><code id="cosines-signs_+3A_eig">eig</code></td>
<td>
<p>whether <code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> is to be found using an eigendecomposition of
<code class="reqn">\mathbf{I}_p-\boldsymbol{\theta}\boldsymbol{\theta}'</code> (inefficient). Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the projection matrix
<code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> is <em>not</em>
unique. In particular, any completion of <code class="reqn">\boldsymbol{\theta}</code>
to an orthonormal basis
<code class="reqn">\{\boldsymbol{\theta},\mathbf{v}_1,\ldots,\mathbf{v}_{p-1}\}</code> gives a set of <code class="reqn">p-1</code> orthonormal
<code class="reqn">p</code>-vectors <code class="reqn">\{\mathbf{v}_1,\ldots,\mathbf{v}_{p-1}\}</code> that conform the columns of
<code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code>. If
<code>eig = FALSE</code>, this approach is employed by rotating the canonical
completion of <code class="reqn">\mathbf{e}_1=(1,0,\ldots,0)</code>,
<code class="reqn">\{\mathbf{e}_2,\ldots,\mathbf{e}_p\}</code>, by the rotation matrix that rotates
<code class="reqn">\mathbf{e}_1</code> to <code class="reqn">\boldsymbol{\theta}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{H}_{\boldsymbol{\theta}}=
(\boldsymbol{\theta}+\mathbf{e}_1)(\boldsymbol{\theta}+\mathbf{e}_1)'/
(1+\theta_1)-\mathbf{I}_p.</code>
</p>
<p> If <code>eig = TRUE</code>, then a much more expensive
eigendecomposition of <code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}
\boldsymbol{\Gamma}_{\boldsymbol{\theta}}'=
\mathbf{I}_p-\boldsymbol{\theta}\boldsymbol{\theta}'</code> is performed for
determining <code class="reqn">\{\mathbf{v}_1,\ldots,\mathbf{v}_{p-1}\}</code>.
</p>
<p>If <code>signs</code> and <code>cosines</code> are called with <code>X</code> without unit
norms in the rows, then the results will be spurious. Setting
<code>check_X = TRUE</code> prevents this from happening.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>cosines</code>: a vector of length <code>n</code> with the cosines of
<code>X</code>.
</p>
</li>
<li> <p><code>signs</code>: a matrix of size <code>c(n, p - 1)</code> with the
multivariate signs of <code>X</code>.
</p>
</li>
<li> <p><code>Gamma_theta</code>: a projection matrix
<code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> of size
<code>c(p, p - 1)</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873&ndash;1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gamma_theta
theta &lt;- c(0, 1)
Gamma_theta(theta = theta)

# Signs and cosines for p = 2
L &lt;- rbind(c(1, 0.5),
           c(0.5, 1))
X &lt;- r_ACG(n = 1e3, Lambda = L)
par(mfrow = c(1, 2))
plot(signs(X = X, theta = theta), main = "Signs", xlab = expression(x[1]),
     ylab = expression(x[2]))
hist(cosines(X = X, theta = theta), prob = TRUE, main = "Cosines",
     xlab = expression(x * "'" * theta))

# Signs and cosines for p = 3
L &lt;- rbind(c(2, 0.25, 0.25),
           c(0.25, 0.5, 0.25),
           c(0.25, 0.25, 0.5))
X &lt;- r_ACG(n = 1e3, Lambda = L)
par(mfrow = c(1, 2))
theta &lt;- c(0, 1, 0)
plot(signs(X = X, theta = theta), main = "Signs", xlab = expression(x[1]),
     ylab = expression(x[2]))
hist(cosines(X = X, theta = theta), prob = TRUE, main = "Cosines",
     xlab = expression(x * "'" * theta))
</code></pre>

<hr>
<h2 id='estimators'>Estimators for the axis of rotational symmetry
<code class="reqn">\boldsymbol\theta</code></h2><span id='topic+estimators'></span><span id='topic+spherical_mean'></span><span id='topic+spherical_loc_PCA'></span>

<h3>Description</h3>

<p>Estimation of the axis of rotational symmetry
<code class="reqn">\boldsymbol{\theta}</code> of a rotational symmetric unit-norm
random vector <code class="reqn">\mathbf{X}</code> in
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p \ge 2</code>, from a
hyperspherical sample <code class="reqn">\mathbf{X}_1,\ldots,\mathbf{X}_n\in S^{p-1}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spherical_mean(data)

spherical_loc_PCA(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimators_+3A_data">data</code></td>
<td>
<p>hyperspherical data, a matrix of size <code>c(n, p)</code> with unit
norm rows. Normalized internally if any row does not have unit norm
(with a <code>warning</code> message). <code>NA</code>s are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spherical_mean</code> estimator computes the sample mean of
<code class="reqn">\mathbf{X}_1,\ldots,\mathbf{X}_n</code> and normalizes it
by its norm (if the norm is different from zero). It estimates consistently
<code class="reqn">\boldsymbol{\theta}</code> for rotational symmetric models based on
<a href="#topic+tang-norm-decomp">angular functions</a> <code class="reqn">g</code> that are
monotone increasing.
</p>
<p>The estimator in <code>spherical_loc_PCA</code> is based on the fact that, under
rotational symmetry, the expectation of
<code class="reqn">\mathbf{X}\mathbf{X}'</code> is
<code class="reqn">a\boldsymbol{\theta}\boldsymbol{\theta}' +
b(\mathbf{I}_p - \boldsymbol{\theta}\boldsymbol{\theta}')</code>
for certain constants <code class="reqn">a,b \ge 0</code>. Therefore,
<code class="reqn">\boldsymbol{\theta}</code> is the eigenvector with unique
multiplicity of the expectation of <code class="reqn">\mathbf{X}\mathbf{X}'</code>. Its
use is recommended if the rotationally symmetric data is not unimodal.
</p>


<h3>Value</h3>

<p>A vector of length <code>p</code> with an estimate for
<code class="reqn">\boldsymbol{\theta}</code>.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873&ndash;1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample from a vMF
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
set.seed(123456789)
data &lt;- r_vMF(n = n, mu = theta, kappa = 3)
theta_mean &lt;- spherical_mean(data)
theta_PCA &lt;- spherical_loc_PCA(data)
sqrt(sum((theta - theta_mean)^2)) # More efficient
sqrt(sum((theta - theta_PCA)^2))

# Sample from a mixture of antipodal vMF's
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
set.seed(123456789)
data &lt;- rbind(r_vMF(n = n, mu = theta, kappa = 3),
              r_vMF(n = n, mu = -theta, kappa = 3))
theta_mean &lt;- spherical_mean(data)
theta_PCA &lt;- spherical_loc_PCA(data)
sqrt(sum((theta - theta_mean)^2))
sqrt(sum((theta - theta_PCA)^2)) # Better suited in this case
</code></pre>

<hr>
<h2 id='rotasym-package'><span class="pkg">rotasym</span> &ndash; Tests for Rotational Symmetry on the Hypersphere</h2><span id='topic+rotasym-package'></span><span id='topic+rotasym'></span>

<h3>Description</h3>

<p>Implementation of the tests for rotational symmetry on the
hypersphere proposed in García-Portugués, Paindaveine and Verdebout (2020)
&lt;doi:10.1080/01621459.2019.1665527&gt;. The package implements the proposed
distributions on the hypersphere based on the tangent-normal decomposition.
It also allows for the replication of the data application considered in
the paper.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873&ndash;1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>

<hr>
<h2 id='sunspots_births'>Recorded sunspots births during 1872&ndash;2018</h2><span id='topic+sunspots_births'></span>

<h3>Description</h3>

<p>Processed version of the
<a href="http://fenyi.solarobs.csfk.mta.hu/DPD/">
Debrecen Photoheliographic Data (DPD)</a> sunspot catalogue and the
revised version of the
<a href="http://fenyi.solarobs.csfk.mta.hu/GPR/">
Greenwich Photoheliographic Results (GPR)</a> sunspot catalogue. The two
sources contain the records of sunspots appeared during 1872&ndash;2018 (GPR for
1872&ndash;1976; DPD for 1974&ndash;2018).
</p>
<p>Sunspots appear in groups and have a variable lifetime. This dataset has
been processed to account only for the <em>births</em> or emergences
(first observations) of <em>groups</em> of sunspots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sunspots_births
</code></pre>


<h3>Format</h3>

<p>A data frame with 51303 rows and 6 variables:
</p>

<dl>
<dt>date</dt><dd><p>UTC date, as <code><a href="base.html#topic+DateTimeClasses">POSIXct</a></code>, of
the first observation of a group of sunspots.</p>
</dd>
<dt>cycle</dt><dd><p><a href="https://en.wikipedia.org/wiki/List_of_solar_cycles">
solar cycle</a> in which the group of sunspots was observed.</p>
</dd>
<dt>total_area</dt><dd><p>total whole spot area of the group, measured in
millionths of the solar hemisphere.</p>
</dd>
<dt>dist_sun_disc</dt><dd><p>distance from the center of Sun's disc, measured in
units of the solar radius.</p>
</dd>
<dt>theta</dt><dd><p>mean longitude angle <code class="reqn">\theta \in [0, 2\pi)</code> of the
group position.</p>
</dd>
<dt>phi</dt><dd><p>mean latitude angle <code class="reqn">\phi \in [-\pi/2, \pi/2)</code> of the
group position.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The mean position of the group of sunspots is obtained by a weighted average
of the positions of the single sunspots by the whole spot area of the
single spots. The areas are corrected to account for foreshortening.
</p>
<p>The <code class="reqn">(\theta, \phi)</code> angles are such their associated Cartesian
coordinates are:
</p>
<p style="text-align: center;"><code class="reqn">(\cos(\phi) \cos(\theta), \cos(\phi) \sin(\theta), \sin(\phi)),</code>
</p>

<p>with <code class="reqn">(0, 0, 1)</code> denoting the north pole.
</p>
<p>The DPD data has
<a href="http://fenyi.solarobs.csfk.mta.hu/ftp/pub/DPD/README.txt">
different states</a> of completeness and quality control. The
longest span of &quot;final complete data&quot; (no missing observation days and
the data has undergone a systematic quality control) is from 2005 to 2015.
</p>
<p>The data has been preprocessed using the following pipeline:
</p>

<ol>
<li><p> Retrieve data from the GPR and DPD sunspot catalogues.
</p>
</li>
<li><p> Omit observations with <code>NA</code>s in the sunspot positions.
</p>
</li>
<li><p> Filter for sunspot groups.
</p>
</li>
<li><p> Relabel the NOAA identifier for the sunspot group for records
before 1974, prefixing the &quot;GPR&quot; string. Otherwise, very different groups
of sunspots from the two catalogues may share the same identifier.
</p>
</li>
<li><p> Keep only the first row of each NOAA instance, the first-ever
observation of each sunspot group.
</p>
</li></ol>

<p>The script performing the preprocessing is available at
<a href="https://github.com/egarpor/rotasym/blob/master/data-raw/sunspots-births.R">
<code>sunspots-births.R</code></a>
</p>


<h3>Author(s)</h3>

<p>Data processed by Eduardo García-Portugués, Davy Paindaveine, and
Thomas Verdebout from the original sources.
</p>


<h3>Source</h3>

<p><a href="http://fenyi.solarobs.csfk.mta.hu">http://fenyi.solarobs.csfk.mta.hu</a>
</p>


<h3>References</h3>

<p>Baranyi, T., Győri, L., Ludmány, A. (2016) On-line tools for solar data
compiled at the Debrecen observatory and their extensions with the
Greenwich sunspot data. <em>Solar Physics</em>, 291(9&ndash;10):3081&ndash;3102.
<a href="https://doi.org/10.1007/s11207-016-0930-1">doi:10.1007/s11207-016-0930-1</a>
</p>
<p>Győri, L., Ludmány, A., Baranyi, T. (2019) Comparative analysis of Debrecen
sunspot catalogues. <em>Monthly Notices of the Royal Astronomical
Society</em>, 465(2):1259&ndash;1273. <a href="https://doi.org/10.1093/mnras/stw2667">doi:10.1093/mnras/stw2667</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("sunspots_births")

# Transform to Cartesian coordinates
sunspots_births$X &lt;-
  cbind(cos(sunspots_births$phi) * cos(sunspots_births$theta),
        cos(sunspots_births$phi) * sin(sunspots_births$theta),
        sin(sunspots_births$phi))

# Plot data associated to the 23rd cycle
sunspots_23 &lt;- subset(sunspots_births, cycle == 23)
n &lt;- nrow(sunspots_23$X)
if (requireNamespace("rgl")) {
  rgl::plot3d(0, 0, 0, xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
              radius = 1, type = "s", col = "lightblue", alpha = 0.25,
              lit = FALSE)
}
n_cols &lt;- 100
cuts &lt;- cut(x = sunspots_23$date, include.lowest = TRUE,
            breaks = quantile(sunspots_23$date,
                             probs = seq(0, 1, l = n_cols + 1)))
if (requireNamespace("rgl")) {
  rgl::points3d(sunspots_23$X, col = viridisLite::viridis(n_cols)[cuts])
}
# Spörer's law: sunspots at the beginning of the solar cycle (dark blue
# color) tend to appear at higher latitutes, gradually decreasing to the
# equator as the solar cycle advances (yellow color)

# Estimation of the density of the cosines
V &lt;- cosines(X = sunspots_23$X, theta = c(0, 0, 1))
h &lt;- bw.SJ(x = V, method = "dpi")
plot(kde &lt;- density(x = V, bw = h, n = 2^13, from = -1, to = 1), col = 1,
     xlim = c(-1, 1), ylim = c(0, 3), axes = FALSE, main = "",
     xlab = "Cosines (latitude angles)", lwd = 2)
at &lt;- seq(-1, 1, by = 0.25)
axis(2); axis(1, at = at)
axis(1, at = at, line = 1, tick = FALSE,
     labels = paste0("(", 90 - round(acos(at) / pi * 180, 1), "º)"))
rug(V)
legend("topright", legend = c("Full cycle", "Initial 25% cycle",
                              "Final 25% cycle"),
       lwd = 2, col = c(1, viridisLite::viridis(12)[c(3, 8)]))

# Density for the observations within the initial 25% of the cycle
part1 &lt;- sunspots_23$date &lt; quantile(sunspots_23$date, 0.25)
V1 &lt;- cosines(X = sunspots_23$X[part1, ], theta = c(0, 0, 1))
h1 &lt;- bw.SJ(x = V1, method = "dpi")
lines(kde1 &lt;- density(x = V1, bw = h1, n = 2^13, from = -1, to = 1),
      col = viridisLite::viridis(12)[3], lwd = 2)

# Density for the observations within the final 25% of the cycle
part2 &lt;- sunspots_23$date &gt; quantile(sunspots_23$date, 0.75)
V2 &lt;- cosines(X = sunspots_23$X[part2, ], theta = c(0, 0, 1))
h2 &lt;- bw.SJ(x = V2, method = "dpi")
lines(kde2 &lt;- density(x = V2, bw = h2, n = 2^13, from = -1, to = 1),
      col = viridisLite::viridis(12)[8], lwd = 2)

# Computation the level set of a kernel density estimator that contains
# at least 1 - alpha of the probability (kde stands for an object
# containing the output of density(x = data))
kde_level_set &lt;- function(kde, data, alpha) {

  # Estimate c from alpha
  c &lt;- quantile(approx(x = kde$x, y = kde$y, xout = data)$y, probs = alpha)

  # Begin and end index for the potentially many intervals in the level sets
  kde_larger_c &lt;- kde$y &gt;= c
  run_length_kde &lt;- rle(kde_larger_c)
  begin &lt;- which(diff(kde_larger_c) &gt; 0) + 1
  end &lt;- begin + run_length_kde$lengths[run_length_kde$values] - 1

  # Return the [a_i, b_i], i = 1, ..., K in the K rows
  return(cbind(kde$x[begin], kde$x[end]))

}

# Level set containing the 90% of the probability, in latitude angles
90 - acos(kde_level_set(kde = kde, data = V, alpha = 0.10)) / pi * 180

# Modes (in cosines and latitude angles)
modes &lt;- c(kde$x[kde$x &lt; 0][which.max(kde$y[kde$x &lt; 0])],
           kde$x[kde$x &gt; 0][which.max(kde$y[kde$x &gt; 0])])
90 - acos(modes) / pi * 180
</code></pre>

<hr>
<h2 id='tang-norm-decomp'>Distributions based on the tangent-normal decomposition</h2><span id='topic+tang-norm-decomp'></span><span id='topic+d_tang_norm'></span><span id='topic+r_tang_norm'></span>

<h3>Description</h3>

<p>Density and simulation of a distribution on
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p\ge 2</code>, obtained by the
tangent-normal decomposition. The <em>tangent-normal decomposition</em> of
the random vector <code class="reqn">\mathbf{X}\in S^{p-1}</code> is
</p>
<p style="text-align: center;"><code class="reqn">V\boldsymbol{\theta} +
\sqrt{1 - V^2}\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{U}</code>
</p>

<p>where <code class="reqn">V := \mathbf{X}'\boldsymbol{\theta}</code> is a
random variable in <code class="reqn">[-1, 1]</code> (the <em>cosines</em> of
<code class="reqn">\mathbf{X}</code>) and
<code class="reqn">\mathbf{U} := \boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{X}/
||\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{X}||</code> is a random vector in
<code class="reqn">S^{p-2}</code> (the <em>multivariate signs</em> of <code class="reqn">\mathbf{X}</code>)
and <code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> is the
<code class="reqn">p\times(p-1)</code> matrix computed by <code><a href="#topic+Gamma_theta">Gamma_theta</a></code>.
</p>
<p>The tangent-normal decomposition can be employed for constructing
distributions for <code class="reqn">\mathbf{X}</code> that arise for certain choices of
<code class="reqn">V</code> and <code class="reqn">\mathbf{U}</code>. If <code class="reqn">V</code> and
<code class="reqn">\mathbf{U}</code> are <em>independent</em>, then simulation from
<code class="reqn">\mathbf{X}</code> is straightforward using the tangent-normal
decomposition. Also, the density of <code class="reqn">\mathbf{X}</code> at
<code class="reqn">\mathbf{x}\in S^{p-1}</code>,
<code class="reqn">f_\mathbf{X}(\mathbf{x})</code>, is readily computed as
</p>
<p style="text-align: center;"><code class="reqn">f_\mathbf{X}(\mathbf{x})=
\omega_{p-1}c_g g(t)(1-t^2)^{(p-3)/2}f_\mathbf{U}(\mathbf{u})</code>
</p>

<p>where <code class="reqn">t:=\mathbf{x}'\boldsymbol{\theta}</code>,
<code class="reqn">\mathbf{u}:=\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{x}/
||\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{x}||</code>,
<code class="reqn">f_\mathbf{U}</code> is the density of <code class="reqn">\mathbf{U}</code>,
and <code class="reqn">f_V(v) := \omega_{p-1} c_g g(v) (1 - v^2)^{(p-3)/2}</code> is the density
of <code class="reqn">V</code> for an angular function <code class="reqn">g</code> with normalizing constant
<code class="reqn">c_g</code>. <code class="reqn">\omega_{p-1}</code> is the surface area of <code class="reqn">S^{p-2}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_tang_norm(x, theta, g_scaled, d_V, d_U, log = FALSE)

r_tang_norm(n, theta, r_U, r_V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tang-norm-decomp_+3A_x">x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td></tr>
<tr><td><code id="tang-norm-decomp_+3A_theta">theta</code></td>
<td>
<p>a unit norm vector of size <code>p</code> giving the axis of
rotational symmetry.</p>
</td></tr>
<tr><td><code id="tang-norm-decomp_+3A_g_scaled">g_scaled</code></td>
<td>
<p>the <em>scaled</em> angular density <code class="reqn">c_g g</code>. In the
form <br /><code>g_scaled &lt;- function(t, log = TRUE) {...}</code>. See examples.</p>
</td></tr>
<tr><td><code id="tang-norm-decomp_+3A_d_v">d_V</code></td>
<td>
<p>the density <code class="reqn">f_V</code>. In the form
<code>d_V &lt;- function(v, log = TRUE) {...}</code>. See examples.</p>
</td></tr>
<tr><td><code id="tang-norm-decomp_+3A_d_u">d_U</code></td>
<td>
<p>the density <code class="reqn">f_\mathbf{U}</code>. In the form
<code>d_U &lt;- function(u, log = TRUE) {...}</code>. See examples.</p>
</td></tr>
<tr><td><code id="tang-norm-decomp_+3A_log">log</code></td>
<td>
<p>flag to indicate if the logarithm of the density (or the
normalizing constant) is to be computed.</p>
</td></tr>
<tr><td><code id="tang-norm-decomp_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td></tr>
<tr><td><code id="tang-norm-decomp_+3A_r_u">r_U</code></td>
<td>
<p>a function for simulating <code class="reqn">\mathbf{U}</code>. Its first argument
must be the sample size. See examples.</p>
</td></tr>
<tr><td><code id="tang-norm-decomp_+3A_r_v">r_V</code></td>
<td>
<p>a function for simulating <code class="reqn">V</code>. Its first argument must be
the sample size. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>g_scaled</code> or <code>d_V</code> can be supplied to <code>d_tang_norm</code>
(the rest of the arguments are compulsory). One possible choice for
<code>g_scaled</code> is <code><a href="#topic+g_vMF">g_vMF</a></code> with <code>scaled = TRUE</code>. Another
possible choice is the angular function <code class="reqn">g(t) = 1 - t^2</code>, normalized by
its normalizing constant
<code class="reqn">c_g = (\Gamma(p/2) p) / (2\pi^{p/2} (p - 1))</code> (see examples).
This angular function makes <code class="reqn">V^2</code> to be distributed as a
<code class="reqn">\mathrm{Beta}(1/2,(p+1)/2)</code>.
</p>
<p>The normalizing constants and densities are computed through log-scales for
numerical accuracy.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>d_tang_norm</code>: a vector of length <code>nx</code> or <code>1</code>
with the evaluated density at <code>x</code>.
</p>
</li>
<li> <p><code>r_tang_norm</code>: a matrix of size <code>c(n, p)</code> with the
random sample.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873&ndash;1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gamma_theta">Gamma_theta</a></code>, <code><a href="#topic+signs">signs</a></code>,
<code><a href="#topic+tangent-elliptical">tangent-elliptical</a></code>, <code><a href="#topic+tangent-vMF">tangent-vMF</a></code>,
<code><a href="#topic+vMF">vMF</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulation and density evaluation for p = 2

# Parameters
n &lt;- 1e3
p &lt;- 2
theta &lt;- c(rep(0, p - 1), 1)
mu &lt;- c(rep(0, p - 2), 1)
kappa_V &lt;- 2
kappa_U &lt;- 0.1

# The vMF scaled angular function
g_scaled &lt;- function(t, log) {
  g_vMF(t, p = p - 1, kappa = kappa_V, scaled = TRUE, log = log)
}

# Cosine density for the vMF distribution
d_V &lt;- function(v, log) {
 log_dens &lt;- g_scaled(v, log = log) + (p - 3)/2 * log(1 - v^2)
 switch(log + 1, exp(log_dens), log_dens)
}

# Multivariate signs density based on a vMF
d_U &lt;- function(x, log) d_vMF(x = x, mu = mu, kappa = kappa_U, log = log)

# Simulation functions
r_V &lt;- function(n) r_g_vMF(n = n, p = p, kappa = kappa_V)
r_U &lt;- function(n) r_vMF(n = n, mu = mu, kappa = kappa_U)

# Sample and color according to density
x &lt;- r_tang_norm(n = n, theta = theta, r_V = r_V, r_U = r_U)
r &lt;- runif(n, 0.95, 1.05) # Radius perturbation to improve visualization
col &lt;- viridisLite::viridis(n)
dens &lt;- d_tang_norm(x = x, theta = theta, g_scaled = g_scaled, d_U = d_U)
# dens &lt;- d_tang_norm(x = x, theta = theta, d_V = d_V, d_U = d_U) # The same
plot(r * x, pch = 16, col = col[rank(dens)])

## Simulation and density evaluation for p = 3

# Parameters
p &lt;- 3
n &lt;- 5e3
theta &lt;- c(rep(0, p - 1), 1)
mu &lt;- c(rep(0, p - 2), 1)
kappa_V &lt;- 2
kappa_U &lt;- 2

# Sample and color according to density
x &lt;- r_tang_norm(n = n, theta = theta, r_V = r_V, r_U = r_U)
col &lt;- viridisLite::viridis(n)
dens &lt;- d_tang_norm(x = x, theta = theta, g_scaled = g_scaled, d_U = d_U)
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(dens)], size = 5)
}

## A non-vMF angular function: g(t) = 1 - t^2. It is sssociated to the
## Beta(1/2, (p + 1)/2) distribution.

# Scaled angular function
g_scaled &lt;- function(t, log) {
  log_c_g &lt;- lgamma(0.5 * p) + log(0.5 * p / (p - 1)) - 0.5 * p * log(pi)
  log_g &lt;- log_c_g + log(1 - t^2)
  switch(log + 1, exp(log_g), log_g)
}

# Cosine density
d_V &lt;- function(v, log) {
  log_dens &lt;- w_p(p = p - 1, log = TRUE) + g_scaled(t = v, log = TRUE) +
    (0.5 * (p - 3)) * log(1 - v^2)
  switch(log + 1, exp(log_dens), log_dens)
}

# Simulation
r_V &lt;- function(n) {
  sample(x = c(-1, 1), size = n, replace = TRUE) *
    sqrt(rbeta(n = n, shape1 = 0.5, shape2 = 0.5 * (p + 1)))
}

# Sample and color according to density
r_U &lt;- function(n) r_unif_sphere(n = n, p = p - 1)
x &lt;- r_tang_norm(n = n, theta = theta, r_V = r_V, r_U = r_U)
col &lt;- viridisLite::viridis(n)
dens &lt;- d_tang_norm(x = x, theta = theta, d_V = d_V, d_U = d_unif_sphere)
# dens &lt;- d_tang_norm(x = x, theta = theta, g_scaled = g_scaled,
#                     d_U = d_unif_sphere) # The same
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(dens)], size = 5)
}
</code></pre>

<hr>
<h2 id='tangent-elliptical'>Tangent elliptical distribution</h2><span id='topic+tangent-elliptical'></span><span id='topic+d_TE'></span><span id='topic+TE'></span><span id='topic+r_TE'></span>

<h3>Description</h3>

<p>Density and simulation of the Tangent Elliptical (TE)
distribution on
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p\ge 2</code>. The distribution arises
by considering the
<a href="#topic+tang-norm-decomp">tangent-normal decomposition</a> with
multivariate <a href="#topic+cosines-signs">signs</a> distributed as an
<a href="#topic+ACG">Angular Central Gaussian</a> distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_TE(x, theta, g_scaled, d_V, Lambda, log = FALSE)

r_TE(n, theta, r_V, Lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tangent-elliptical_+3A_x">x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td></tr>
<tr><td><code id="tangent-elliptical_+3A_theta">theta</code></td>
<td>
<p>a unit norm vector of size <code>p</code> giving the axis of
rotational symmetry.</p>
</td></tr>
<tr><td><code id="tangent-elliptical_+3A_g_scaled">g_scaled</code></td>
<td>
<p>the <em>scaled</em> angular density <code class="reqn">c_g g</code>. In the
form <br /><code>g_scaled &lt;- function(t, log = TRUE) {...}</code>. See examples.</p>
</td></tr>
<tr><td><code id="tangent-elliptical_+3A_d_v">d_V</code></td>
<td>
<p>the density <code class="reqn">f_V</code>. In the form
<code>d_V &lt;- function(v, log = TRUE) {...}</code>. See examples.</p>
</td></tr>
<tr><td><code id="tangent-elliptical_+3A_lambda">Lambda</code></td>
<td>
<p>the shape matrix <code class="reqn">\boldsymbol{\Lambda}</code> of the
ACG used in the multivariate signs. A symmetric and positive definite
matrix of size <code>c(p - 1, p - 1)</code>.</p>
</td></tr>
<tr><td><code id="tangent-elliptical_+3A_log">log</code></td>
<td>
<p>flag to indicate if the logarithm of the density (or the
normalizing constant) is to be computed.</p>
</td></tr>
<tr><td><code id="tangent-elliptical_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td></tr>
<tr><td><code id="tangent-elliptical_+3A_r_v">r_V</code></td>
<td>
<p>a function for simulating <code class="reqn">V</code>. Its first argument must be
the sample size. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are wrappers for <code><a href="#topic+d_tang_norm">d_tang_norm</a></code> and
<code><a href="#topic+r_tang_norm">r_tang_norm</a></code> with <code>d_U = <a href="#topic+d_ACG">d_ACG</a></code> and
<code>r_U = <a href="#topic+r_ACG">r_ACG</a></code>.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>d_TE</code>: a vector of length <code>nx</code> or <code>1</code> with the
evaluated density at <code>x</code>.
</p>
</li>
<li> <p><code>r_TE</code>: a matrix of size <code>c(n, p)</code> with the random sample.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873&ndash;1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tang-norm-decomp">tang-norm-decomp</a></code>,
<code><a href="#topic+tangent-vMF">tangent-vMF</a></code>, <code><a href="#topic+ACG">ACG</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulation and density evaluation for p = 2

# Parameters
p &lt;- 2
n &lt;- 1e3
theta &lt;- c(rep(0, p - 1), 1)
Lambda &lt;- matrix(0.5, nrow = p - 1, ncol = p - 1)
diag(Lambda) &lt;- 1
kappa_V &lt;- 2

# Required functions
r_V &lt;- function(n) r_g_vMF(n = n, p = p, kappa = kappa_V)
g_scaled &lt;- function(t, log) {
  g_vMF(t, p = p - 1, kappa = kappa_V, scaled = TRUE, log = log)
}

# Sample and color according to density
x &lt;- r_TE(n = n, theta = theta, r_V = r_V, Lambda = Lambda)
col &lt;- viridisLite::viridis(n)
r &lt;- runif(n, 0.95, 1.05) # Radius perturbation to improve visualization
dens &lt;- d_TE(x = x, theta = theta, g_scaled = g_scaled, Lambda = Lambda)
plot(r * x, pch = 16, col = col[rank(dens)])

## Simulation and density evaluation for p = 3

# Parameters
p &lt;- 3
n &lt;- 5e3
theta &lt;- c(rep(0, p - 1), 1)
Lambda &lt;- matrix(0.5, nrow = p - 1, ncol = p - 1)
diag(Lambda) &lt;- 1
kappa_V &lt;- 2

# Sample and color according to density
x &lt;- r_TE(n = n, theta = theta, r_V = r_V, Lambda = Lambda)
col &lt;- viridisLite::viridis(n)
dens &lt;- d_TE(x = x, theta = theta, g_scaled = g_scaled, Lambda = Lambda)
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(dens)], size = 5)
}

## A non-vMF angular function: g(t) = 1 - t^2. It is sssociated to the
## Beta(1/2, (p + 1)/2) distribution.

# Scaled angular function
g_scaled &lt;- function(t, log) {
  log_c_g &lt;- lgamma(0.5 * p) + log(0.5 * p / (p - 1)) - 0.5 * p * log(pi)
  log_g &lt;- log_c_g + log(1 - t^2)
  switch(log + 1, exp(log_g), log_g)
}

# Simulation
r_V &lt;- function(n) {
  sample(x = c(-1, 1), size = n, replace = TRUE) *
    sqrt(rbeta(n = n, shape1 = 0.5, shape2 = 0.5 * (p + 1)))
}

# Sample and color according to density
kappa_V &lt;- 1
Lambda &lt;- matrix(0.75, nrow = p - 1, ncol = p - 1)
diag(Lambda) &lt;- 1
x &lt;- r_TE(n = n, theta = theta, r_V = r_V, Lambda = Lambda)
col &lt;- viridisLite::viridis(n)
dens &lt;- d_TE(x = x, theta = theta, g_scaled = g_scaled, Lambda = Lambda)
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(dens)], size = 5)
}
</code></pre>

<hr>
<h2 id='tangent-vMF'>Tangent von Mises&ndash;Fisher distribution</h2><span id='topic+tangent-vMF'></span><span id='topic+d_TM'></span><span id='topic+TM'></span><span id='topic+r_TM'></span>

<h3>Description</h3>

<p>Density and simulation of the Tangent von Mises&ndash;Fisher (TM)
distribution on
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p\ge 2</code>. The distribution arises
by considering the
<a href="#topic+tang-norm-decomp">tangent-normal decomposition</a> with
multivariate <a href="#topic+cosines-signs">signs</a> distributed as a
<a href="#topic+vMF">von Mises&ndash;Fisher</a> distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_TM(x, theta, g_scaled, d_V, mu, kappa, log = FALSE)

r_TM(n, theta, r_V, mu, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tangent-vMF_+3A_x">x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td></tr>
<tr><td><code id="tangent-vMF_+3A_theta">theta</code></td>
<td>
<p>a unit norm vector of size <code>p</code> giving the axis of
rotational symmetry.</p>
</td></tr>
<tr><td><code id="tangent-vMF_+3A_g_scaled">g_scaled</code></td>
<td>
<p>the <em>scaled</em> angular density <code class="reqn">c_g g</code>. In the
form <br /><code>g_scaled &lt;- function(t, log = TRUE) {...}</code>. See examples.</p>
</td></tr>
<tr><td><code id="tangent-vMF_+3A_d_v">d_V</code></td>
<td>
<p>the density <code class="reqn">f_V</code>. In the form
<code>d_V &lt;- function(v, log = TRUE) {...}</code>. See examples.</p>
</td></tr>
<tr><td><code id="tangent-vMF_+3A_mu">mu</code></td>
<td>
<p>the directional mean <code class="reqn">\boldsymbol{\mu}</code> of the vMF
used in the multivariate signs. A unit-norm vector of length <code>p - 1</code>.</p>
</td></tr>
<tr><td><code id="tangent-vMF_+3A_kappa">kappa</code></td>
<td>
<p>concentration parameter <code class="reqn">\kappa</code> of the vMF used in the
multivariate signs. A nonnegative scalar.</p>
</td></tr>
<tr><td><code id="tangent-vMF_+3A_log">log</code></td>
<td>
<p>flag to indicate if the logarithm of the density (or the
normalizing constant) is to be computed.</p>
</td></tr>
<tr><td><code id="tangent-vMF_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td></tr>
<tr><td><code id="tangent-vMF_+3A_r_v">r_V</code></td>
<td>
<p>a function for simulating <code class="reqn">V</code>. Its first argument must be
the sample size. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are wrappers for <code><a href="#topic+d_tang_norm">d_tang_norm</a></code> and
<code><a href="#topic+r_tang_norm">r_tang_norm</a></code> with <code>d_U = <a href="#topic+d_vMF">d_vMF</a></code> and
<code>r_U = <a href="#topic+r_vMF">r_vMF</a></code>.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>d_TM</code>: a vector of length <code>nx</code> or <code>1</code> with the
evaluated density at <code>x</code>.
</p>
</li>
<li> <p><code>r_TM</code>: a matrix of size <code>c(n, p)</code> with the random sample.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873&ndash;1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tang-norm-decomp">tang-norm-decomp</a></code>,
<code><a href="#topic+tangent-elliptical">tangent-elliptical</a></code>, <code><a href="#topic+vMF">vMF</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulation and density evaluation for p = 2

# Parameters
p &lt;- 2
n &lt;- 1e3
theta &lt;- c(rep(0, p - 1), 1)
mu &lt;- c(rep(0, p - 2), 1)
kappa &lt;- 1
kappa_V &lt;- 2

# Required functions
r_V &lt;- function(n) r_g_vMF(n = n, p = p, kappa = kappa_V)
g_scaled &lt;- function(t, log) {
  g_vMF(t, p = p - 1, kappa = kappa_V, scaled = TRUE, log = log)
}

# Sample and color according to density
x &lt;- r_TM(n = n, theta = theta, r_V = r_V, mu = 1, kappa = kappa)
col &lt;- viridisLite::viridis(n)
r &lt;- runif(n, 0.95, 1.05) # Radius perturbation to improve visualization
dens &lt;- d_TM(x = x, theta = theta, g_scaled = g_scaled, mu = mu,
             kappa = kappa)
plot(r * x, pch = 16, col = col[rank(dens)])

## Simulation and density evaluation for p = 3

# Parameters
p &lt;- 3
n &lt;- 5e3
theta &lt;- c(rep(0, p - 1), 1)
mu &lt;- c(rep(0, p - 2), 1)
kappa &lt;- 1
kappa_V &lt;- 2

# Sample and color according to density
x &lt;- r_TM(n = n, theta = theta, r_V = r_V, mu = mu, kappa = kappa)
col &lt;- viridisLite::viridis(n)
dens &lt;- d_TM(x = x, theta = theta, g_scaled = g_scaled, mu = mu,
             kappa = kappa)
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(dens)], size = 5)
}

## A non-vMF angular function: g(t) = 1 - t^2. It is sssociated to the
## Beta(1/2, (p + 1)/2) distribution.

# Scaled angular function
g_scaled &lt;- function(t, log) {
  log_c_g &lt;- lgamma(0.5 * p) + log(0.5 * p / (p - 1)) - 0.5 * p * log(pi)
  log_g &lt;- log_c_g + log(1 - t^2)
  switch(log + 1, exp(log_g), log_g)
}

# Simulation
r_V &lt;- function(n) {
  sample(x = c(-1, 1), size = n, replace = TRUE) *
    sqrt(rbeta(n = n, shape1 = 0.5, shape2 = 0.5 * (p + 1)))
}

# Sample and color according to density
kappa &lt;- 0.5
x &lt;- r_TM(n = n, theta = theta, r_V = r_V, mu = mu, kappa = kappa)
col &lt;- viridisLite::viridis(n)
dens &lt;- d_TM(x = x, theta = theta, g_scaled = g_scaled,
             mu = mu, kappa = kappa)
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(dens)], size = 5)
}
</code></pre>

<hr>
<h2 id='test_rotasym'>Tests of rotational symmetry for hyperspherical data</h2><span id='topic+test_rotasym'></span>

<h3>Description</h3>

<p>Tests for assessing the rotational symmetry of a unit-norm
random vector <code class="reqn">\mathbf{X}</code> in
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p \ge 2</code>, about a location
<code class="reqn">\boldsymbol{\theta}\in S^{p-1}</code>, from a
hyperspherical sample <code class="reqn">\mathbf{X}_1,\ldots,\mathbf{X}_n\in S^{p-1}</code>.
</p>
<p>The vector <code class="reqn">\mathbf{X}</code> is said to be rotational symmetric about
<code class="reqn">\boldsymbol{\theta}</code> if the distributions of
<code class="reqn">\mathbf{OX}</code> and <code class="reqn">\mathbf{X}</code> coincide, where
<code class="reqn">\mathbf{O}</code> is any <code class="reqn">p\times p</code> rotation matrix
that fixes <code class="reqn">\boldsymbol{\theta}</code>, <em>i.e.</em>,
<code class="reqn">\mathbf{O}\boldsymbol{\theta}=\boldsymbol{\theta}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_rotasym(data, theta = spherical_mean, type = c("sc", "loc", "loc_vMF",
  "hyb", "hyb_vMF")[5], Fisher = FALSE, U = NULL, V = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_rotasym_+3A_data">data</code></td>
<td>
<p>hyperspherical data, a matrix of size <code>c(n, p)</code> with unit
norm rows. Normalized internally if any row does not have unit norm
(with a <code>warning</code> message). <code>NA</code>s are ignored.</p>
</td></tr>
<tr><td><code id="test_rotasym_+3A_theta">theta</code></td>
<td>
<p>either a unit norm vector of size <code>p</code> giving the axis of
rotational symmetry (for the specified-<code class="reqn">\boldsymbol{\theta}</code>
case) or a function that implements an estimator
<code class="reqn">\hat{\boldsymbol{\theta}}</code> of
<code class="reqn">\boldsymbol{\theta}</code> (for the
unspecified-<code class="reqn">\boldsymbol{\theta}</code> case). The default calls
the <code><a href="#topic+spherical_mean">spherical_mean</a></code> function. See examples.</p>
</td></tr>
<tr><td><code id="test_rotasym_+3A_type">type</code></td>
<td>
<p>a character string (case insensitive) indicating the type of
test to conduct:
</p>

<ul>
<li> <p><code>"sc"</code>: &quot;scatter&quot; test based on the statistic
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code>. Evaluates if the
covariance matrix of the multivariate signs is isotropic.
</p>
</li>
<li> <p><code>"loc"</code>: &quot;location&quot; test based on the statistic
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{loc}}</code>. Evaluates if
the expectation of the multivariate signs is zero.
</p>
</li>
<li> <p><code>"loc_vMF"</code>: adapted &quot;location&quot; test, based on the statistic
<code class="reqn">Q_{\mathrm{vMF}}^{\mathrm{loc}}</code>.
</p>
</li>
<li> <p><code>"hyb"</code>: &quot;hybrid&quot; test based on the statistics
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code> and
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{loc}}</code>.
</p>
</li>
<li> <p><code>"hyb_vMF"</code> (default): adapted &quot;hybrid&quot; test based on the
statistics <code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code> and
<code class="reqn">Q_{\mathrm{vMF}}^{\mathrm{loc}}</code>.
</p>
</li></ul>

<p>See the details below for further explanations of the tests.</p>
</td></tr>
<tr><td><code id="test_rotasym_+3A_fisher">Fisher</code></td>
<td>
<p>if <code>TRUE</code>, then Fisher's method is employed to aggregate
the scatter and location tests in the hybrid test, see details below.
Otherwise, the hybrid statistic is the sum of the scatter and location
statistics. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="test_rotasym_+3A_u">U</code></td>
<td>
<p><em>multivariate signs</em> of <code>data</code>, a matrix of size
<code>c(n, p - 1)</code>. Computed if <code>NULL</code> (the default).</p>
</td></tr>
<tr><td><code id="test_rotasym_+3A_v">V</code></td>
<td>
<p><em>cosines</em> of <code>data</code>, a vector of size <code>n</code>. Computed
if <code>NULL</code> (the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Descriptions of the tests:
</p>

<ul>
<li><p> The &quot;scatter&quot; test is locally and asymptotically optimal against
<a href="#topic+tangent-elliptical">tangent elliptical</a> alternatives to rotational
symmetry. However, it is not consistent against
<a href="#topic+tangent-vMF">tangent von Mises&ndash;Fisher</a> (vMF) alternatives.
The asymptotic null distribution of
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code>
is unaffected if <code class="reqn">\boldsymbol{\theta}</code> is estimated, that is,
the asymptotic null distributions of
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code> and
<code class="reqn">Q_{\hat{\boldsymbol{\theta}}}^{\mathrm{sc}}</code> are
the same.
</p>
</li>
<li><p> The &quot;location&quot; test is locally and asymptotically most powerful
against vMF alternatives to rotational symmetry. However, it is not
consistent against tangent elliptical alternatives. The asymptotic
null distribution of
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{loc}}</code>
for known <code class="reqn">\boldsymbol{\theta}</code> (the one implemented in
<code>test_rotasym</code>) <em>does change</em> if <code class="reqn">\boldsymbol{\theta}</code>
is estimated by <code class="reqn">\hat{\boldsymbol{\theta}}</code>. Therefore, if
the test is performed with an estimated <code class="reqn">\boldsymbol{\theta}</code>
(if <code>theta</code> is a function)
<code class="reqn">Q_{\hat{\boldsymbol{\theta}}}^{\mathrm{loc}}</code>
will not be properly calibrated. <code>test_rotasym</code> will give a warning in
such case.
</p>
</li>
<li><p> The &quot;vMF location&quot; test is a modification of the &quot;location&quot; test
designed to make its null asymptotic distribution invariant from the
estimation of <code class="reqn">\boldsymbol{\theta}</code> (as the &quot;scatter&quot; test is).
The test is optimal against tangent vMF alternatives with a <em>specific</em>,
vMF-based, angular function <code><a href="#topic+g_vMF">g_vMF</a></code>. Despite not
being optimal against all tangent vMF alternatives, it is
consistent for all of them. As the location test,
it is not consistent against tangent elliptical alternatives.
</p>
</li>
<li><p> The &quot;hybrid&quot; test combines (see below how) the &quot;scatter&quot; and
&quot;location&quot; tests. The test is neither optimal against tangent elliptical nor
tangent vMF alternatives, but it is consistent against both. Since it is
based on the &quot;location&quot; test, if computed with an estimator
<code class="reqn">\hat{\boldsymbol{\theta}}</code>, the test statistic will not
be properly calibrated. <code>test_rotasym</code> will give a warning in such case.
</p>
</li>
<li><p> The &quot;vMF hybrid&quot; test is the analogous of the &quot;hybrid&quot; test but
replaces the &quot;location&quot; test by the &quot;vMF location&quot; test.
</p>
</li></ul>

<p>The combination of the scatter and location tests in the hybrid tests is
done in two different ways:
</p>

<ul>
<li><p> If <code>Fisher = FALSE</code>, then the scatter and location tests
statistics give the hybrid test statistic
</p>
<p style="text-align: center;"><code class="reqn">Q^{\mathrm{hyb}}:=Q_{\boldsymbol{\theta}}^{\mathrm{sc}}+
Q_{\boldsymbol{\theta}}^{\mathrm{loc}}.</code>
</p>

</li>
<li><p> If <code>Fisher = TRUE</code>, then Fisher's method for aggregating
independent tests (the two test statistics are independent under rotational
symmetry) is considered, resulting the hybrid test statistic:
</p>
<p style="text-align: center;"><code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{hyb}}
:=-2(\log(p_{\mathrm{sc}})+\log(p_{\mathrm{loc}}))</code>
</p>

<p>where <code class="reqn">p_{\mathrm{sc}}</code> and <code class="reqn">p_{\mathrm{loc}}</code> are
the <code class="reqn">p</code>-values of the scatter and location tests, respectively.
</p>
</li></ul>

<p>The hybrid test statistic <code class="reqn">Q_{\mathrm{vMF}}^{\mathrm{hyb}}</code> follows analogously to
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{hyb}}</code> by replacing
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{loc}}</code> with
<code class="reqn">Q_{\mathrm{vMF}}^{\mathrm{loc}}</code>.
</p>
<p>Finally, recall that the tests are designed to test <em>implications</em> of
rotational symmetry. Therefore, the tests are not consistent against
<em>all</em> types of alternatives to rotational symmetry.
</p>


<h3>Value</h3>

<p>An object of the <code>htest</code> class with the following elements:
</p>

<ul>
<li> <p><code>statistic</code>: test statistic.
</p>
</li>
<li> <p><code>parameter</code>: degrees of freedom of the chi-square distribution
appearing in all the null asymptotic distributions.
</p>
</li>
<li> <p><code>p.value</code>: <code class="reqn">p</code>-value of the test.
</p>
</li>
<li> <p><code>method</code>: information on the type of test performed.
</p>
</li>
<li> <p><code>data.name</code>: name of the value of <code>data</code>.
</p>
</li>
<li> <p><code>U</code>: multivariate signs of <code>data</code>.
</p>
</li>
<li> <p><code>V</code>: cosines of <code>data</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873&ndash;1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tangent-elliptical">tangent-elliptical</a></code>, <code><a href="#topic+tangent-vMF">tangent-vMF</a></code>,
<code><a href="#topic+spherical_mean">spherical_mean</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Rotational symmetry holds

# Sample data from a vMF (rotational symmetric distribution about mu)
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
set.seed(123456789)
data_0 &lt;- r_vMF(n = n, mu = theta, kappa = 1)

# theta known
test_rotasym(data = data_0, theta = theta, type = "sc")
test_rotasym(data = data_0, theta = theta, type = "loc")
test_rotasym(data = data_0, theta = theta, type = "loc_vMF")
test_rotasym(data = data_0, theta = theta, type = "hyb")
test_rotasym(data = data_0, theta = theta, type = "hyb", Fisher = TRUE)
test_rotasym(data = data_0, theta = theta, type = "hyb_vMF")
test_rotasym(data = data_0, theta = theta, type = "hyb_vMF", Fisher = TRUE)

# theta unknown (employs the spherical mean as estimator)
test_rotasym(data = data_0, type = "sc")
test_rotasym(data = data_0, type = "loc") # Warning
test_rotasym(data = data_0, type = "loc_vMF")
test_rotasym(data = data_0, type = "hyb") # Warning
test_rotasym(data = data_0, type = "hyb", Fisher = TRUE) # Warning
test_rotasym(data = data_0, type = "hyb_vMF")
test_rotasym(data = data_0, type = "hyb_vMF", Fisher = TRUE)

## Rotational symmetry does not hold

# Sample non-rotational symmetric data from a tangent-vMF distribution
# The scatter test is blind to these deviations, while the location tests
# are optimal
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
mu &lt;- c(rep(0, p - 2), 1)
kappa &lt;- 2
set.seed(123456789)
r_V &lt;- function(n) {
  r_g_vMF(n = n, p = p, kappa = 1)
}
data_1 &lt;- r_TM(n = n, r_V = r_V, theta = theta, mu = mu, kappa = kappa)

# theta known
test_rotasym(data = data_1, theta = theta, type = "sc")
test_rotasym(data = data_1, theta = theta, type = "loc")
test_rotasym(data = data_1, theta = theta, type = "loc_vMF")
test_rotasym(data = data_1, theta = theta, type = "hyb")
test_rotasym(data = data_1, theta = theta, type = "hyb", Fisher = TRUE)
test_rotasym(data = data_1, theta = theta, type = "hyb_vMF")
test_rotasym(data = data_1, theta = theta, type = "hyb_vMF", Fisher = TRUE)

# theta unknown (employs the spherical mean as estimator)
test_rotasym(data = data_1, type = "sc")
test_rotasym(data = data_1, type = "loc") # Warning
test_rotasym(data = data_1, type = "loc_vMF")
test_rotasym(data = data_1, type = "hyb") # Warning
test_rotasym(data = data_1, type = "hyb", Fisher = TRUE) # Warning
test_rotasym(data = data_1, type = "hyb_vMF")
test_rotasym(data = data_1, type = "hyb_vMF", Fisher = TRUE)

# Sample non-rotational symmetric data from a tangent-elliptical distribution
# The location tests are blind to these deviations, while the
# scatter test is optimal
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
Lambda &lt;- matrix(0.5, nrow = p - 1, ncol = p - 1)
diag(Lambda) &lt;- 1
set.seed(123456789)
r_V &lt;- function(n) {
  r_g_vMF(n = n, p = p, kappa = 1)
}
data_2 &lt;- r_TE(n = n, r_V = r_V, theta = theta, Lambda = Lambda)

# theta known
test_rotasym(data = data_2, theta = theta, type = "sc")
test_rotasym(data = data_2, theta = theta, type = "loc")
test_rotasym(data = data_2, theta = theta, type = "loc_vMF")
test_rotasym(data = data_2, theta = theta, type = "hyb")
test_rotasym(data = data_2, theta = theta, type = "hyb", Fisher = TRUE)
test_rotasym(data = data_2, theta = theta, type = "hyb_vMF")
test_rotasym(data = data_2, theta = theta, type = "hyb_vMF", Fisher = TRUE)

# theta unknown (employs the spherical mean as estimator)
test_rotasym(data = data_2, type = "sc")
test_rotasym(data = data_2, type = "loc") # Warning
test_rotasym(data = data_2, type = "loc_vMF")
test_rotasym(data = data_2, type = "hyb") # Warning
test_rotasym(data = data_2, type = "hyb", Fisher = TRUE) # Warning
test_rotasym(data = data_2, type = "hyb_vMF")
test_rotasym(data = data_2, type = "hyb_vMF", Fisher = TRUE)

## Sunspots births data

# Load data
data("sunspots_births")
sunspots_births$X &lt;-
  cbind(cos(sunspots_births$phi) * cos(sunspots_births$theta),
        cos(sunspots_births$phi) * sin(sunspots_births$theta),
        sin(sunspots_births$phi))

# Test rotational symmetry for the 23rd cycle, specified theta
sunspots_23 &lt;- subset(sunspots_births, cycle == 23)
test_rotasym(data = sunspots_23$X, type = "sc", theta = c(0, 0, 1))
test_rotasym(data = sunspots_23$X, type = "loc", theta = c(0, 0, 1))
test_rotasym(data = sunspots_23$X, type = "hyb", theta = c(0, 0, 1))

# Test rotational symmetry for the 23rd cycle, unspecified theta
spherical_loc_PCA(sunspots_23$X)
test_rotasym(data = sunspots_23$X, type = "sc", theta = spherical_loc_PCA)
test_rotasym(data = sunspots_23$X, type = "loc_vMF",
             theta = spherical_loc_PCA)
test_rotasym(data = sunspots_23$X, type = "hyb_vMF",
             theta = spherical_loc_PCA)

# Test rotational symmetry for the 22nd cycle, specified theta
sunspots_22 &lt;- subset(sunspots_births, cycle == 22)
test_rotasym(data = sunspots_22$X, type = "sc", theta = c(0, 0, 1))
test_rotasym(data = sunspots_22$X, type = "loc", theta = c(0, 0, 1))
test_rotasym(data = sunspots_22$X, type = "hyb", theta = c(0, 0, 1))

# Test rotational symmetry for the 22nd cycle, unspecified theta
spherical_loc_PCA(sunspots_22$X)
test_rotasym(data = sunspots_22$X, type = "sc", theta = spherical_loc_PCA)
test_rotasym(data = sunspots_22$X, type = "loc_vMF",
             theta = spherical_loc_PCA)
test_rotasym(data = sunspots_22$X, type = "hyb_vMF",
             theta = spherical_loc_PCA)
</code></pre>

<hr>
<h2 id='unif'>Uniform distribution on the hypersphere</h2><span id='topic+unif'></span><span id='topic+d_unif_sphere'></span><span id='topic+r_unif_sphere'></span><span id='topic+w_p'></span>

<h3>Description</h3>

<p>Density and simulation of the uniform distribution on
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p\ge 1</code>. The density is just the
inverse of the surface area of <code class="reqn">S^{p-1}</code>, given by
</p>
<p style="text-align: center;"><code class="reqn">\omega_p:=2\pi^{p/2}/\Gamma(p/2).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>d_unif_sphere(x, log = FALSE)

r_unif_sphere(n, p)

w_p(p, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unif_+3A_x">x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td></tr>
<tr><td><code id="unif_+3A_log">log</code></td>
<td>
<p>flag to indicate if the logarithm of the density (or the
normalizing constant) is to be computed.</p>
</td></tr>
<tr><td><code id="unif_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td></tr>
<tr><td><code id="unif_+3A_p">p</code></td>
<td>
<p>dimension of the ambient space <code class="reqn">R^p</code> that contains
<code class="reqn">S^{p-1}</code>. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">p = 1</code>, then <code class="reqn">S^{0} = \{-1, 1\}</code> and the &quot;surface area&quot; is
<code class="reqn">2</code>. The function <code>w_p</code> is vectorized on <code>p</code>.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>d_unif_sphere</code>: a vector of length <code>nx</code> or <code>1</code> with
the evaluated density at <code>x</code>.
</p>
</li>
<li> <p><code>r_unif_sphere</code>: a matrix of size <code>c(n, p)</code> with the
random sample.
</p>
</li>
<li> <p><code>w_p</code>: the surface area of <code class="reqn">S^{p-1}</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Area of S^{p - 1}

# Areas of S^0, S^1, and S^2
w_p(p = 1:3)

# Area as a function of p
p &lt;- 1:20
plot(p, w_p(p = p), type = "o", pch = 16, xlab = "p", ylab = "Area",
     main = expression("Surface area of " * S^{p - 1}), axes = FALSE)
box()
axis(1, at = p)
axis(2, at = seq(0, 34, by = 2))

## Simulation and density evaluation for p = 1, 2, 3

# p = 1
n &lt;- 500
x &lt;- r_unif_sphere(n = n, p = 1)
barplot(table(x) / n)
head(d_unif_sphere(x))

# p = 2
x &lt;- r_unif_sphere(n = n, p = 3)
plot(x)
head(d_unif_sphere(x))

# p = 3
x &lt;- r_unif_sphere(n = n, p = 3)
if (requireNamespace("rgl")) {
  rgl::plot3d(x)
}
head(d_unif_sphere(x))
</code></pre>

<hr>
<h2 id='vMF'>von Mises&ndash;Fisher distribution</h2><span id='topic+vMF'></span><span id='topic+d_vMF'></span><span id='topic+c_vMF'></span><span id='topic+r_vMF'></span><span id='topic+g_vMF'></span><span id='topic+r_g_vMF'></span>

<h3>Description</h3>

<p>Density and simulation of the von Mises&ndash;Fisher (vMF)
distribution on
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p\ge 1</code>. The density at
<code class="reqn">\mathbf{x} \in S^{p-1}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">c^{\mathrm{vMF}}_{p,\kappa}
e^{\kappa\mathbf{x}' \boldsymbol{\mu}}
\quad\mathrm{with}\quad c^{\mathrm{vMF}}_{p,\kappa}:=
\kappa^{(p-2)/2}/((2\pi)^{p/2} I_{(p-2)/2}(\kappa))</code>
</p>

<p>where <code class="reqn">\boldsymbol{\mu}\in S^{p-1}</code> is the directional
mean, <code class="reqn">\kappa\ge 0</code> is the concentration parameter about
<code class="reqn">\boldsymbol{\mu}</code>, and <code class="reqn">I_\nu</code> is the order-<code class="reqn">\nu</code>
modified Bessel function of the first kind.
</p>
<p>The angular function of the vMF is <code class="reqn">g(t) := e^{\kappa t}</code>. The
associated <em>cosines</em> density is
<code class="reqn">\tilde g(v):= \omega_{p-1} c^{\mathrm{vMF}}_{p,\kappa}
g(v) (1 - v^2)^{(p-3)/2}</code>,
where <code class="reqn">\omega_{p-1}</code> is the surface area of <code class="reqn">S^{p-2}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_vMF(x, mu, kappa, log = FALSE)

c_vMF(p, kappa, log = FALSE)

r_vMF(n, mu, kappa)

g_vMF(t, p, kappa, scaled = TRUE, log = FALSE)

r_g_vMF(n, p, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vMF_+3A_x">x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td></tr>
<tr><td><code id="vMF_+3A_mu">mu</code></td>
<td>
<p>the directional mean <code class="reqn">\boldsymbol{\mu}</code> of the vMF.
A unit-norm vector of length <code>p</code>.</p>
</td></tr>
<tr><td><code id="vMF_+3A_kappa">kappa</code></td>
<td>
<p>concentration parameter <code class="reqn">\kappa</code> of the vMF.
A nonnegative scalar. Can be a vector for <code>c_vMF</code>.</p>
</td></tr>
<tr><td><code id="vMF_+3A_log">log</code></td>
<td>
<p>flag to indicate if the logarithm of the density (or the
normalizing constant) is to be computed.</p>
</td></tr>
<tr><td><code id="vMF_+3A_p">p</code></td>
<td>
<p>dimension of the ambient space <code class="reqn">R^p</code> that contains
<code class="reqn">S^{p-1}</code>. A positive integer.</p>
</td></tr>
<tr><td><code id="vMF_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td></tr>
<tr><td><code id="vMF_+3A_t">t</code></td>
<td>
<p>a vector with values in <code class="reqn">[-1, 1]</code>.</p>
</td></tr>
<tr><td><code id="vMF_+3A_scaled">scaled</code></td>
<td>
<p>whether to scale the angular function by the von Mises&ndash;Fisher
normalizing constant. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>r_g_vMF</code> implements algorithm VM in Wood (1994). <code>c_vMF</code> is
vectorized on <code>p</code> and <code>kappa</code>.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>d_vMF</code>: a vector of length <code>nx</code> or <code>1</code> with the
evaluated density at <code>x</code>.
</p>
</li>
<li> <p><code>r_vMF</code>: a matrix of size <code>c(n, p)</code> with the random sample.
</p>
</li>
<li> <p><code>c_vMF</code>: the normalizing constant.
</p>
</li>
<li> <p><code>g_vMF</code>: a vector of size <code>length(t)</code> with the evaluated
angular function.
</p>
</li>
<li> <p><code>r_g_vMF</code>: a vector of length <code>n</code> containing simulated
values from the cosines density associated to the angular function.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>Wood, A. T. A. (1994) Simulation of the von Mises Fisher distribution.
<em>Commun. Stat. Simulat.</em>, 23(1):157&ndash;164.
<a href="https://doi.org/10.1080/03610919408813161">doi:10.1080/03610919408813161</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tangent-vMF">tangent-vMF</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation and density evaluation for p = 2
mu &lt;- c(0, 1)
kappa &lt;- 2
n &lt;- 1e3
x &lt;- r_vMF(n = n, mu = mu, kappa = kappa)
col &lt;- viridisLite::viridis(n)
r &lt;- runif(n, 0.95, 1.05) # Radius perturbation to improve visualization
plot(r * x, pch = 16, col = col[rank(d_vMF(x = x, mu = mu, kappa = kappa))])

# Simulation and density evaluation for p = 3
mu &lt;- c(0, 0, 1)
kappa &lt;- 2
x &lt;- r_vMF(n = n, mu = mu, kappa = kappa)
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(d_vMF(x = x, mu = mu, kappa = kappa))],
              size = 5)
}

# Cosines density
g_tilde &lt;- function(t, p, kappa) {
  exp(w_p(p = p - 1, log = TRUE) +
        g_vMF(t = t, p = p, kappa = kappa, scaled = TRUE, log = TRUE) +
        ((p - 3) / 2) * log(1 - t^2))
}

# Simulated data from the cosines density
n &lt;- 1e3
p &lt;- 3
kappa &lt;- 2
hist(r_g_vMF(n = n, p = p, kappa = kappa), breaks = seq(-1, 1, l = 20),
     probability = TRUE, main = "Simulated data from g_vMF", xlab = "t")
t &lt;- seq(-1, 1, by = 0.01)
lines(t, g_tilde(t = t, p = p, kappa = kappa))

# Cosine density as a function of the dimension
M &lt;- 100
col &lt;- viridisLite::viridis(M)
plot(t, g_tilde(t = t, p = 2, kappa = kappa), col = col[2], type = "l",
     ylab = "Density")
for (p in 3:M) {
  lines(t, g_tilde(t = t, p = p, kappa = kappa), col = col[p])
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
